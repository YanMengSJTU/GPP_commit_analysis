diff --git a/TMessagesProj/build.gradle b/TMessagesProj/build.gradle
index 0a5ec1030..b8a623a83 100644
--- a/TMessagesProj/build.gradle
+++ b/TMessagesProj/build.gradle
@@ -3,7 +3,7 @@ buildscript {
         mavenCentral()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.1.3'
+        classpath 'com.android.tools.build:gradle:1.2.3'
     }
 }
 apply plugin: 'com.android.application'
@@ -81,15 +81,15 @@ android {
     defaultConfig {
         minSdkVersion 8
         targetSdkVersion 22
-        versionCode 521
-        versionName "2.8.1"
+        versionCode 542
+        versionName "2.9.1"
     }
 
     productFlavors {
         Moegram {
             applicationId "me.swineson.moegram.messenger"
-            versionCode 508
-            versionName "0.0.5"
+            versionCode 509
+            versionName "0.0.6"
         }
     }
 }
diff --git a/TMessagesProj/jni/sqlite/sqlite3.c b/TMessagesProj/jni/sqlite/sqlite3.c
index cae0c4ad2..a09cf7178 100644
--- a/TMessagesProj/jni/sqlite/sqlite3.c
+++ b/TMessagesProj/jni/sqlite/sqlite3.c
@@ -1,6 +1,6 @@
 /******************************************************************************
 ** This file is an amalgamation of many separate C source files from SQLite
-** version 3.8.8.1.  By combining all the individual C code files into this 
+** version 3.8.10.  By combining all the individual C code files into this 
 ** single large file, the entire code can be compiled as a single translation
 ** unit.  This allows many compilers to do optimizations that would not be
 ** possible if the files were compiled separately.  Performance improvements
@@ -22,9 +22,6 @@
 #ifndef SQLITE_PRIVATE
 # define SQLITE_PRIVATE static
 #endif
-#ifndef SQLITE_API
-# define SQLITE_API
-#endif
 /************** Begin file sqliteInt.h ***************************************/
 /*
 ** 2001 September 15
@@ -73,6 +70,7 @@
 #pragma warning(disable : 4055)
 #pragma warning(disable : 4100)
 #pragma warning(disable : 4127)
+#pragma warning(disable : 4130)
 #pragma warning(disable : 4152)
 #pragma warning(disable : 4189)
 #pragma warning(disable : 4206)
@@ -90,6 +88,44 @@
 /************** End of msvc.h ************************************************/
 /************** Continuing where we left off in sqliteInt.h ******************/
 
+/*
+** Special setup for VxWorks
+*/
+/************** Include vxworks.h in the middle of sqliteInt.h ***************/
+/************** Begin file vxworks.h *****************************************/
+/*
+** 2015-03-02
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+**
+** This file contains code that is specific to Wind River's VxWorks
+*/
+#if defined(__RTP__) || defined(_WRS_KERNEL)
+/* This is VxWorks.  Set up things specially for that OS
+*/
+#include <vxWorks.h>
+#include <pthread.h>  /* amalgamator: dontcache */
+#define OS_VXWORKS 1
+#define SQLITE_OS_OTHER 0
+#define SQLITE_HOMEGROWN_RECURSIVE_MUTEX 1
+#define SQLITE_OMIT_LOAD_EXTENSION 1
+#define SQLITE_ENABLE_LOCKING_STYLE 0
+#define HAVE_UTIME 1
+#else
+/* This is not VxWorks. */
+#define OS_VXWORKS 0
+#endif /* defined(_WRS_KERNEL) */
+
+/************** End of vxworks.h *********************************************/
+/************** Continuing where we left off in sqliteInt.h ******************/
+
 /*
 ** These #defines should enable >2GB file support on POSIX if the
 ** underlying operating system supports it.  If the OS lacks
@@ -214,16 +250,20 @@ extern "C" {
 
 
 /*
-** Add the ability to override 'extern'
+** Provide the ability to override linkage features of the interface.
 */
 #ifndef SQLITE_EXTERN
 # define SQLITE_EXTERN extern
 #endif
-
 #ifndef SQLITE_API
 # define SQLITE_API
 #endif
-
+#ifndef SQLITE_CDECL
+# define SQLITE_CDECL
+#endif
+#ifndef SQLITE_STDCALL
+# define SQLITE_STDCALL
+#endif
 
 /*
 ** These no-op macros are used in front of interfaces to mark those
@@ -278,9 +318,9 @@ extern "C" {
 ** [sqlite3_libversion_number()], [sqlite3_sourceid()],
 ** [sqlite_version()] and [sqlite_source_id()].
 */
-#define SQLITE_VERSION        "3.8.8.1"
-#define SQLITE_VERSION_NUMBER 3008008
-#define SQLITE_SOURCE_ID      "2015-01-20 16:51:25 f73337e3e289915a76ca96e7a05a1a8d4e890d55"
+#define SQLITE_VERSION        "3.8.10"
+#define SQLITE_VERSION_NUMBER 3008010
+#define SQLITE_SOURCE_ID      "2015-05-07 11:53:08 cf975957b9ae671f34bb65f049acf351e650d437"
 
 /*
 ** CAPI3REF: Run-Time Library Version Numbers
@@ -313,9 +353,9 @@ extern "C" {
 ** See also: [sqlite_version()] and [sqlite_source_id()].
 */
 SQLITE_API const char sqlite3_version[] = SQLITE_VERSION;
-SQLITE_API const char *sqlite3_libversion(void);
-SQLITE_API const char *sqlite3_sourceid(void);
-SQLITE_API int sqlite3_libversion_number(void);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_libversion(void);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_sourceid(void);
+SQLITE_API int SQLITE_STDCALL sqlite3_libversion_number(void);
 
 /*
 ** CAPI3REF: Run-Time Library Compilation Options Diagnostics
@@ -340,8 +380,8 @@ SQLITE_API int sqlite3_libversion_number(void);
 ** [sqlite_compileoption_get()] and the [compile_options pragma].
 */
 #ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
-SQLITE_API int sqlite3_compileoption_used(const char *zOptName);
-SQLITE_API const char *sqlite3_compileoption_get(int N);
+SQLITE_API int SQLITE_STDCALL sqlite3_compileoption_used(const char *zOptName);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_compileoption_get(int N);
 #endif
 
 /*
@@ -380,7 +420,7 @@ SQLITE_API const char *sqlite3_compileoption_get(int N);
 **
 ** See the [threading mode] documentation for additional information.
 */
-SQLITE_API int sqlite3_threadsafe(void);
+SQLITE_API int SQLITE_STDCALL sqlite3_threadsafe(void);
 
 /*
 ** CAPI3REF: Database Connection Handle
@@ -437,6 +477,7 @@ typedef sqlite_uint64 sqlite3_uint64;
 
 /*
 ** CAPI3REF: Closing A Database Connection
+** DESTRUCTOR: sqlite3
 **
 ** ^The sqlite3_close() and sqlite3_close_v2() routines are destructors
 ** for the [sqlite3] object.
@@ -476,8 +517,8 @@ typedef sqlite_uint64 sqlite3_uint64;
 ** ^Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointer
 ** argument is a harmless no-op.
 */
-SQLITE_API int sqlite3_close(sqlite3*);
-SQLITE_API int sqlite3_close_v2(sqlite3*);
+SQLITE_API int SQLITE_STDCALL sqlite3_close(sqlite3*);
+SQLITE_API int SQLITE_STDCALL sqlite3_close_v2(sqlite3*);
 
 /*
 ** The type for a callback function.
@@ -488,6 +529,7 @@ typedef int (*sqlite3_callback)(void*,int,char**, char**);
 
 /*
 ** CAPI3REF: One-Step Query Execution Interface
+** METHOD: sqlite3
 **
 ** The sqlite3_exec() interface is a convenience wrapper around
 ** [sqlite3_prepare_v2()], [sqlite3_step()], and [sqlite3_finalize()],
@@ -547,7 +589,7 @@ typedef int (*sqlite3_callback)(void*,int,char**, char**);
 **      the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.
 ** </ul>
 */
-SQLITE_API int sqlite3_exec(
+SQLITE_API int SQLITE_STDCALL sqlite3_exec(
   sqlite3*,                                  /* An open database */
   const char *sql,                           /* SQL to be evaluated */
   int (*callback)(void*,int,char**,char**),  /* Callback function */
@@ -927,14 +969,16 @@ struct sqlite3_io_methods {
 ** of the [sqlite3_io_methods] object and for the [sqlite3_file_control()]
 ** interface.
 **
+** <ul>
+** <li>[[SQLITE_FCNTL_LOCKSTATE]]
 ** The [SQLITE_FCNTL_LOCKSTATE] opcode is used for debugging.  This
 ** opcode causes the xFileControl method to write the current state of
 ** the lock (one of [SQLITE_LOCK_NONE], [SQLITE_LOCK_SHARED],
 ** [SQLITE_LOCK_RESERVED], [SQLITE_LOCK_PENDING], or [SQLITE_LOCK_EXCLUSIVE])
 ** into an integer that the pArg argument points to. This capability
-** is used during testing and only needs to be supported when SQLITE_TEST
-** is defined.
-** <ul>
+** is used during testing and is only available when the SQLITE_TEST
+** compile-time option is used.
+**
 ** <li>[[SQLITE_FCNTL_SIZE_HINT]]
 ** The [SQLITE_FCNTL_SIZE_HINT] opcode is used by SQLite to give the VFS
 ** layer a hint of how large the database file will grow to be during the
@@ -1059,7 +1103,9 @@ struct sqlite3_io_methods {
 ** [PRAGMA] processing continues.  ^If the [SQLITE_FCNTL_PRAGMA]
 ** file control returns [SQLITE_OK], then the parser assumes that the
 ** VFS has handled the PRAGMA itself and the parser generates a no-op
-** prepared statement.  ^If the [SQLITE_FCNTL_PRAGMA] file control returns
+** prepared statement if result string is NULL, or that returns a copy
+** of the result string if the string is non-NULL.
+** ^If the [SQLITE_FCNTL_PRAGMA] file control returns
 ** any result code other than [SQLITE_OK] or [SQLITE_NOTFOUND], that means
 ** that the VFS encountered an error while handling the [PRAGMA] and the
 ** compilation of the PRAGMA fails with an error.  ^The [SQLITE_FCNTL_PRAGMA]
@@ -1117,12 +1163,19 @@ struct sqlite3_io_methods {
 ** pointed to by the pArg argument.  This capability is used during testing
 ** and only needs to be supported when SQLITE_TEST is defined.
 **
+** <li>[[SQLITE_FCNTL_WAL_BLOCK]]
+** The [SQLITE_FCNTL_WAL_BLOCK] is a signal to the VFS layer that it might
+** be advantageous to block on the next WAL lock if the lock is not immediately
+** available.  The WAL subsystem issues this signal during rare
+** circumstances in order to fix a problem with priority inversion.
+** Applications should <em>not</em> use this file-control.
+**
 ** </ul>
 */
 #define SQLITE_FCNTL_LOCKSTATE               1
-#define SQLITE_GET_LOCKPROXYFILE             2
-#define SQLITE_SET_LOCKPROXYFILE             3
-#define SQLITE_LAST_ERRNO                    4
+#define SQLITE_FCNTL_GET_LOCKPROXYFILE       2
+#define SQLITE_FCNTL_SET_LOCKPROXYFILE       3
+#define SQLITE_FCNTL_LAST_ERRNO              4
 #define SQLITE_FCNTL_SIZE_HINT               5
 #define SQLITE_FCNTL_CHUNK_SIZE              6
 #define SQLITE_FCNTL_FILE_POINTER            7
@@ -1141,6 +1194,13 @@ struct sqlite3_io_methods {
 #define SQLITE_FCNTL_SYNC                   21
 #define SQLITE_FCNTL_COMMIT_PHASETWO        22
 #define SQLITE_FCNTL_WIN32_SET_HANDLE       23
+#define SQLITE_FCNTL_WAL_BLOCK              24
+
+/* deprecated names */
+#define SQLITE_GET_LOCKPROXYFILE      SQLITE_FCNTL_GET_LOCKPROXYFILE
+#define SQLITE_SET_LOCKPROXYFILE      SQLITE_FCNTL_SET_LOCKPROXYFILE
+#define SQLITE_LAST_ERRNO             SQLITE_FCNTL_LAST_ERRNO
+
 
 /*
 ** CAPI3REF: Mutex Handle
@@ -1489,10 +1549,10 @@ struct sqlite3_vfs {
 ** must return [SQLITE_OK] on success and some other [error code] upon
 ** failure.
 */
-SQLITE_API int sqlite3_initialize(void);
-SQLITE_API int sqlite3_shutdown(void);
-SQLITE_API int sqlite3_os_init(void);
-SQLITE_API int sqlite3_os_end(void);
+SQLITE_API int SQLITE_STDCALL sqlite3_initialize(void);
+SQLITE_API int SQLITE_STDCALL sqlite3_shutdown(void);
+SQLITE_API int SQLITE_STDCALL sqlite3_os_init(void);
+SQLITE_API int SQLITE_STDCALL sqlite3_os_end(void);
 
 /*
 ** CAPI3REF: Configuring The SQLite Library
@@ -1523,10 +1583,11 @@ SQLITE_API int sqlite3_os_end(void);
 ** ^If the option is unknown or SQLite is unable to set the option
 ** then this routine returns a non-zero [error code].
 */
-SQLITE_API int sqlite3_config(int, ...);
+SQLITE_API int SQLITE_CDECL sqlite3_config(int, ...);
 
 /*
 ** CAPI3REF: Configure database connections
+** METHOD: sqlite3
 **
 ** The sqlite3_db_config() interface is used to make configuration
 ** changes to a [database connection].  The interface is similar to
@@ -1541,7 +1602,7 @@ SQLITE_API int sqlite3_config(int, ...);
 ** ^Calls to sqlite3_db_config() return SQLITE_OK if and only if
 ** the call is considered successful.
 */
-SQLITE_API int sqlite3_db_config(sqlite3*, int op, ...);
+SQLITE_API int SQLITE_CDECL sqlite3_db_config(sqlite3*, int op, ...);
 
 /*
 ** CAPI3REF: Memory Allocation Routines
@@ -1701,7 +1762,7 @@ struct sqlite3_mem_methods {
 **   <li> [sqlite3_memory_used()]
 **   <li> [sqlite3_memory_highwater()]
 **   <li> [sqlite3_soft_heap_limit64()]
-**   <li> [sqlite3_status()]
+**   <li> [sqlite3_status64()]
 **   </ul>)^
 ** ^Memory allocation statistics are enabled by default unless SQLite is
 ** compiled with [SQLITE_DEFAULT_MEMSTATUS]=0 in which case memory
@@ -1912,7 +1973,6 @@ struct sqlite3_mem_methods {
 ** compiled for Windows with the [SQLITE_WIN32_MALLOC] pre-processor macro
 ** defined. ^SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer value
 ** that specifies the maximum size of the created heap.
-** </dl>
 **
 ** [[SQLITE_CONFIG_PCACHE_HDRSZ]]
 ** <dt>SQLITE_CONFIG_PCACHE_HDRSZ
@@ -2025,15 +2085,17 @@ struct sqlite3_mem_methods {
 
 /*
 ** CAPI3REF: Enable Or Disable Extended Result Codes
+** METHOD: sqlite3
 **
 ** ^The sqlite3_extended_result_codes() routine enables or disables the
 ** [extended result codes] feature of SQLite. ^The extended result
 ** codes are disabled by default for historical compatibility.
 */
-SQLITE_API int sqlite3_extended_result_codes(sqlite3*, int onoff);
+SQLITE_API int SQLITE_STDCALL sqlite3_extended_result_codes(sqlite3*, int onoff);
 
 /*
 ** CAPI3REF: Last Insert Rowid
+** METHOD: sqlite3
 **
 ** ^Each entry in most SQLite tables (except for [WITHOUT ROWID] tables)
 ** has a unique 64-bit signed
@@ -2081,10 +2143,11 @@ SQLITE_API int sqlite3_extended_result_codes(sqlite3*, int onoff);
 ** unpredictable and might not equal either the old or the new
 ** last insert [rowid].
 */
-SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_last_insert_rowid(sqlite3*);
 
 /*
 ** CAPI3REF: Count The Number Of Rows Modified
+** METHOD: sqlite3
 **
 ** ^This function returns the number of rows modified, inserted or
 ** deleted by the most recently completed INSERT, UPDATE or DELETE
@@ -2133,10 +2196,11 @@ SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);
 ** while [sqlite3_changes()] is running then the value returned
 ** is unpredictable and not meaningful.
 */
-SQLITE_API int sqlite3_changes(sqlite3*);
+SQLITE_API int SQLITE_STDCALL sqlite3_changes(sqlite3*);
 
 /*
 ** CAPI3REF: Total Number Of Rows Modified
+** METHOD: sqlite3
 **
 ** ^This function returns the total number of rows inserted, modified or
 ** deleted by all [INSERT], [UPDATE] or [DELETE] statements completed
@@ -2156,10 +2220,11 @@ SQLITE_API int sqlite3_changes(sqlite3*);
 ** while [sqlite3_total_changes()] is running then the value
 ** returned is unpredictable and not meaningful.
 */
-SQLITE_API int sqlite3_total_changes(sqlite3*);
+SQLITE_API int SQLITE_STDCALL sqlite3_total_changes(sqlite3*);
 
 /*
 ** CAPI3REF: Interrupt A Long-Running Query
+** METHOD: sqlite3
 **
 ** ^This function causes any pending database operation to abort and
 ** return at its earliest opportunity. This routine is typically
@@ -2195,7 +2260,7 @@ SQLITE_API int sqlite3_total_changes(sqlite3*);
 ** If the database connection closes while [sqlite3_interrupt()]
 ** is running then bad things will likely happen.
 */
-SQLITE_API void sqlite3_interrupt(sqlite3*);
+SQLITE_API void SQLITE_STDCALL sqlite3_interrupt(sqlite3*);
 
 /*
 ** CAPI3REF: Determine If An SQL Statement Is Complete
@@ -2230,12 +2295,13 @@ SQLITE_API void sqlite3_interrupt(sqlite3*);
 ** The input to [sqlite3_complete16()] must be a zero-terminated
 ** UTF-16 string in native byte order.
 */
-SQLITE_API int sqlite3_complete(const char *sql);
-SQLITE_API int sqlite3_complete16(const void *sql);
+SQLITE_API int SQLITE_STDCALL sqlite3_complete(const char *sql);
+SQLITE_API int SQLITE_STDCALL sqlite3_complete16(const void *sql);
 
 /*
 ** CAPI3REF: Register A Callback To Handle SQLITE_BUSY Errors
 ** KEYWORDS: {busy-handler callback} {busy handler}
+** METHOD: sqlite3
 **
 ** ^The sqlite3_busy_handler(D,X,P) routine sets a callback function X
 ** that might be invoked with argument P whenever
@@ -2291,10 +2357,11 @@ SQLITE_API int sqlite3_complete16(const void *sql);
 ** A busy handler must not close the database connection
 ** or [prepared statement] that invoked the busy handler.
 */
-SQLITE_API int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);
+SQLITE_API int SQLITE_STDCALL sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);
 
 /*
 ** CAPI3REF: Set A Busy Timeout
+** METHOD: sqlite3
 **
 ** ^This routine sets a [sqlite3_busy_handler | busy handler] that sleeps
 ** for a specified amount of time when a table is locked.  ^The handler
@@ -2313,10 +2380,11 @@ SQLITE_API int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);
 **
 ** See also:  [PRAGMA busy_timeout]
 */
-SQLITE_API int sqlite3_busy_timeout(sqlite3*, int ms);
+SQLITE_API int SQLITE_STDCALL sqlite3_busy_timeout(sqlite3*, int ms);
 
 /*
 ** CAPI3REF: Convenience Routines For Running Queries
+** METHOD: sqlite3
 **
 ** This is a legacy interface that is preserved for backwards compatibility.
 ** Use of this interface is not recommended.
@@ -2387,7 +2455,7 @@ SQLITE_API int sqlite3_busy_timeout(sqlite3*, int ms);
 ** reflected in subsequent calls to [sqlite3_errcode()] or
 ** [sqlite3_errmsg()].
 */
-SQLITE_API int sqlite3_get_table(
+SQLITE_API int SQLITE_STDCALL sqlite3_get_table(
   sqlite3 *db,          /* An open database */
   const char *zSql,     /* SQL to be evaluated */
   char ***pazResult,    /* Results of the query */
@@ -2395,13 +2463,17 @@ SQLITE_API int sqlite3_get_table(
   int *pnColumn,        /* Number of result columns written here */
   char **pzErrmsg       /* Error msg written here */
 );
-SQLITE_API void sqlite3_free_table(char **result);
+SQLITE_API void SQLITE_STDCALL sqlite3_free_table(char **result);
 
 /*
 ** CAPI3REF: Formatted String Printing Functions
 **
 ** These routines are work-alikes of the "printf()" family of functions
 ** from the standard C library.
+** These routines understand most of the common K&R formatting options,
+** plus some additional non-standard formats, detailed below.
+** Note that some of the more obscure formatting options from recent
+** C-library standards are omitted from this implementation.
 **
 ** ^The sqlite3_mprintf() and sqlite3_vmprintf() routines write their
 ** results into memory obtained from [sqlite3_malloc()].
@@ -2434,7 +2506,7 @@ SQLITE_API void sqlite3_free_table(char **result);
 ** These routines all implement some additional formatting
 ** options that are useful for constructing SQL statements.
 ** All of the usual printf() formatting options apply.  In addition, there
-** is are "%q", "%Q", and "%z" options.
+** is are "%q", "%Q", "%w" and "%z" options.
 **
 ** ^(The %q option works like %s in that it substitutes a nul-terminated
 ** string from the argument list.  But %q also doubles every '\'' character.
@@ -2487,14 +2559,20 @@ SQLITE_API void sqlite3_free_table(char **result);
 ** The code above will render a correct SQL statement in the zSQL
 ** variable even if the zText variable is a NULL pointer.
 **
+** ^(The "%w" formatting option is like "%q" except that it expects to
+** be contained within double-quotes instead of single quotes, and it
+** escapes the double-quote character instead of the single-quote
+** character.)^  The "%w" formatting option is intended for safely inserting
+** table and column names into a constructed SQL statement.
+**
 ** ^(The "%z" formatting option works like "%s" but with the
 ** addition that after the string has been read and copied into
 ** the result, [sqlite3_free()] is called on the input string.)^
 */
-SQLITE_API char *sqlite3_mprintf(const char*,...);
-SQLITE_API char *sqlite3_vmprintf(const char*, va_list);
-SQLITE_API char *sqlite3_snprintf(int,char*,const char*, ...);
-SQLITE_API char *sqlite3_vsnprintf(int,char*,const char*, va_list);
+SQLITE_API char *SQLITE_CDECL sqlite3_mprintf(const char*,...);
+SQLITE_API char *SQLITE_STDCALL sqlite3_vmprintf(const char*, va_list);
+SQLITE_API char *SQLITE_CDECL sqlite3_snprintf(int,char*,const char*, ...);
+SQLITE_API char *SQLITE_STDCALL sqlite3_vsnprintf(int,char*,const char*, va_list);
 
 /*
 ** CAPI3REF: Memory Allocation Subsystem
@@ -2584,12 +2662,12 @@ SQLITE_API char *sqlite3_vsnprintf(int,char*,const char*, va_list);
 ** a block of memory after it has been released using
 ** [sqlite3_free()] or [sqlite3_realloc()].
 */
-SQLITE_API void *sqlite3_malloc(int);
-SQLITE_API void *sqlite3_malloc64(sqlite3_uint64);
-SQLITE_API void *sqlite3_realloc(void*, int);
-SQLITE_API void *sqlite3_realloc64(void*, sqlite3_uint64);
-SQLITE_API void sqlite3_free(void*);
-SQLITE_API sqlite3_uint64 sqlite3_msize(void*);
+SQLITE_API void *SQLITE_STDCALL sqlite3_malloc(int);
+SQLITE_API void *SQLITE_STDCALL sqlite3_malloc64(sqlite3_uint64);
+SQLITE_API void *SQLITE_STDCALL sqlite3_realloc(void*, int);
+SQLITE_API void *SQLITE_STDCALL sqlite3_realloc64(void*, sqlite3_uint64);
+SQLITE_API void SQLITE_STDCALL sqlite3_free(void*);
+SQLITE_API sqlite3_uint64 SQLITE_STDCALL sqlite3_msize(void*);
 
 /*
 ** CAPI3REF: Memory Allocator Statistics
@@ -2614,8 +2692,8 @@ SQLITE_API sqlite3_uint64 sqlite3_msize(void*);
 ** by [sqlite3_memory_highwater(1)] is the high-water mark
 ** prior to the reset.
 */
-SQLITE_API sqlite3_int64 sqlite3_memory_used(void);
-SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag);
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_memory_used(void);
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_memory_highwater(int resetFlag);
 
 /*
 ** CAPI3REF: Pseudo-Random Number Generator
@@ -2638,10 +2716,11 @@ SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag);
 ** internally and without recourse to the [sqlite3_vfs] xRandomness
 ** method.
 */
-SQLITE_API void sqlite3_randomness(int N, void *P);
+SQLITE_API void SQLITE_STDCALL sqlite3_randomness(int N, void *P);
 
 /*
 ** CAPI3REF: Compile-Time Authorization Callbacks
+** METHOD: sqlite3
 **
 ** ^This routine registers an authorizer callback with a particular
 ** [database connection], supplied in the first argument.
@@ -2720,7 +2799,7 @@ SQLITE_API void sqlite3_randomness(int N, void *P);
 ** as stated in the previous paragraph, sqlite3_step() invokes
 ** sqlite3_prepare_v2() to reprepare a statement after a schema change.
 */
-SQLITE_API int sqlite3_set_authorizer(
+SQLITE_API int SQLITE_STDCALL sqlite3_set_authorizer(
   sqlite3*,
   int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),
   void *pUserData
@@ -2798,6 +2877,7 @@ SQLITE_API int sqlite3_set_authorizer(
 
 /*
 ** CAPI3REF: Tracing And Profiling Functions
+** METHOD: sqlite3
 **
 ** These routines register callback functions that can be used for
 ** tracing and profiling the execution of SQL statements.
@@ -2824,12 +2904,13 @@ SQLITE_API int sqlite3_set_authorizer(
 ** sqlite3_profile() function is considered experimental and is
 ** subject to change in future versions of SQLite.
 */
-SQLITE_API void *sqlite3_trace(sqlite3*, void(*xTrace)(void*,const char*), void*);
-SQLITE_API SQLITE_EXPERIMENTAL void *sqlite3_profile(sqlite3*,
+SQLITE_API void *SQLITE_STDCALL sqlite3_trace(sqlite3*, void(*xTrace)(void*,const char*), void*);
+SQLITE_API SQLITE_EXPERIMENTAL void *SQLITE_STDCALL sqlite3_profile(sqlite3*,
    void(*xProfile)(void*,const char*,sqlite3_uint64), void*);
 
 /*
 ** CAPI3REF: Query Progress Callbacks
+** METHOD: sqlite3
 **
 ** ^The sqlite3_progress_handler(D,N,X,P) interface causes the callback
 ** function X to be invoked periodically during long running calls to
@@ -2859,10 +2940,11 @@ SQLITE_API SQLITE_EXPERIMENTAL void *sqlite3_profile(sqlite3*,
 ** database connections for the meaning of "modify" in this paragraph.
 **
 */
-SQLITE_API void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);
+SQLITE_API void SQLITE_STDCALL sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);
 
 /*
 ** CAPI3REF: Opening A New Database Connection
+** CONSTRUCTOR: sqlite3
 **
 ** ^These routines open an SQLite database file as specified by the 
 ** filename argument. ^The filename argument is interpreted as UTF-8 for
@@ -3087,15 +3169,15 @@ SQLITE_API void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);
 **
 ** See also: [sqlite3_temp_directory]
 */
-SQLITE_API int sqlite3_open(
+SQLITE_API int SQLITE_STDCALL sqlite3_open(
   const char *filename,   /* Database filename (UTF-8) */
   sqlite3 **ppDb          /* OUT: SQLite db handle */
 );
-SQLITE_API int sqlite3_open16(
+SQLITE_API int SQLITE_STDCALL sqlite3_open16(
   const void *filename,   /* Database filename (UTF-16) */
   sqlite3 **ppDb          /* OUT: SQLite db handle */
 );
-SQLITE_API int sqlite3_open_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_open_v2(
   const char *filename,   /* Database filename (UTF-8) */
   sqlite3 **ppDb,         /* OUT: SQLite db handle */
   int flags,              /* Flags */
@@ -3141,19 +3223,22 @@ SQLITE_API int sqlite3_open_v2(
 ** VFS method, then the behavior of this routine is undefined and probably
 ** undesirable.
 */
-SQLITE_API const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam);
-SQLITE_API int sqlite3_uri_boolean(const char *zFile, const char *zParam, int bDefault);
-SQLITE_API sqlite3_int64 sqlite3_uri_int64(const char*, const char*, sqlite3_int64);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_uri_parameter(const char *zFilename, const char *zParam);
+SQLITE_API int SQLITE_STDCALL sqlite3_uri_boolean(const char *zFile, const char *zParam, int bDefault);
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_uri_int64(const char*, const char*, sqlite3_int64);
 
 
 /*
 ** CAPI3REF: Error Codes And Messages
-**
-** ^The sqlite3_errcode() interface returns the numeric [result code] or
-** [extended result code] for the most recent failed sqlite3_* API call
-** associated with a [database connection]. If a prior API call failed
-** but the most recent API call succeeded, the return value from
-** sqlite3_errcode() is undefined.  ^The sqlite3_extended_errcode()
+** METHOD: sqlite3
+**
+** ^If the most recent sqlite3_* API call associated with 
+** [database connection] D failed, then the sqlite3_errcode(D) interface
+** returns the numeric [result code] or [extended result code] for that
+** API call.
+** If the most recent API call was successful,
+** then the return value from sqlite3_errcode() is undefined.
+** ^The sqlite3_extended_errcode()
 ** interface is the same except that it always returns the 
 ** [extended result code] even when extended result codes are
 ** disabled.
@@ -3184,40 +3269,41 @@ SQLITE_API sqlite3_int64 sqlite3_uri_int64(const char*, const char*, sqlite3_int
 ** was invoked incorrectly by the application.  In that case, the
 ** error code and message may or may not be set.
 */
-SQLITE_API int sqlite3_errcode(sqlite3 *db);
-SQLITE_API int sqlite3_extended_errcode(sqlite3 *db);
-SQLITE_API const char *sqlite3_errmsg(sqlite3*);
-SQLITE_API const void *sqlite3_errmsg16(sqlite3*);
-SQLITE_API const char *sqlite3_errstr(int);
+SQLITE_API int SQLITE_STDCALL sqlite3_errcode(sqlite3 *db);
+SQLITE_API int SQLITE_STDCALL sqlite3_extended_errcode(sqlite3 *db);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_errmsg(sqlite3*);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_errmsg16(sqlite3*);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_errstr(int);
 
 /*
-** CAPI3REF: SQL Statement Object
+** CAPI3REF: Prepared Statement Object
 ** KEYWORDS: {prepared statement} {prepared statements}
 **
-** An instance of this object represents a single SQL statement.
-** This object is variously known as a "prepared statement" or a
-** "compiled SQL statement" or simply as a "statement".
+** An instance of this object represents a single SQL statement that
+** has been compiled into binary form and is ready to be evaluated.
+**
+** Think of each SQL statement as a separate computer program.  The
+** original SQL text is source code.  A prepared statement object 
+** is the compiled object code.  All SQL must be converted into a
+** prepared statement before it can be run.
 **
-** The life of a statement object goes something like this:
+** The life-cycle of a prepared statement object usually goes like this:
 **
 ** <ol>
-** <li> Create the object using [sqlite3_prepare_v2()] or a related
-**      function.
-** <li> Bind values to [host parameters] using the sqlite3_bind_*()
+** <li> Create the prepared statement object using [sqlite3_prepare_v2()].
+** <li> Bind values to [parameters] using the sqlite3_bind_*()
 **      interfaces.
 ** <li> Run the SQL by calling [sqlite3_step()] one or more times.
-** <li> Reset the statement using [sqlite3_reset()] then go back
+** <li> Reset the prepared statement using [sqlite3_reset()] then go back
 **      to step 2.  Do this zero or more times.
 ** <li> Destroy the object using [sqlite3_finalize()].
 ** </ol>
-**
-** Refer to documentation on individual methods above for additional
-** information.
 */
 typedef struct sqlite3_stmt sqlite3_stmt;
 
 /*
 ** CAPI3REF: Run-time Limits
+** METHOD: sqlite3
 **
 ** ^(This interface allows the size of various constructs to be limited
 ** on a connection by connection basis.  The first parameter is the
@@ -3255,7 +3341,7 @@ typedef struct sqlite3_stmt sqlite3_stmt;
 **
 ** New run-time limit categories may be added in future releases.
 */
-SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
+SQLITE_API int SQLITE_STDCALL sqlite3_limit(sqlite3*, int id, int newVal);
 
 /*
 ** CAPI3REF: Run-Time Limit Categories
@@ -3329,6 +3415,8 @@ SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
 /*
 ** CAPI3REF: Compiling An SQL Statement
 ** KEYWORDS: {SQL statement compiler}
+** METHOD: sqlite3
+** CONSTRUCTOR: sqlite3_stmt
 **
 ** To execute an SQL query, it must first be compiled into a byte-code
 ** program using one of these routines.
@@ -3342,16 +3430,14 @@ SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
 ** interfaces use UTF-8, and sqlite3_prepare16() and sqlite3_prepare16_v2()
 ** use UTF-16.
 **
-** ^If the nByte argument is less than zero, then zSql is read up to the
-** first zero terminator. ^If nByte is non-negative, then it is the maximum
-** number of  bytes read from zSql.  ^When nByte is non-negative, the
-** zSql string ends at either the first '\000' or '\u0000' character or
-** the nByte-th byte, whichever comes first. If the caller knows
-** that the supplied string is nul-terminated, then there is a small
-** performance advantage to be gained by passing an nByte parameter that
-** is equal to the number of bytes in the input string <i>including</i>
-** the nul-terminator bytes as this saves SQLite from having to
-** make a copy of the input string.
+** ^If the nByte argument is negative, then zSql is read up to the
+** first zero terminator. ^If nByte is positive, then it is the
+** number of bytes read from zSql.  ^If nByte is zero, then no prepared
+** statement is generated.
+** If the caller knows that the supplied string is nul-terminated, then
+** there is a small performance advantage to passing an nByte parameter that
+** is the number of bytes in the input string <i>including</i>
+** the nul-terminator.
 **
 ** ^If pzTail is not NULL then *pzTail is made to point to the first byte
 ** past the end of the first SQL statement in zSql.  These routines only
@@ -3407,28 +3493,28 @@ SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
 ** </li>
 ** </ol>
 */
-SQLITE_API int sqlite3_prepare(
+SQLITE_API int SQLITE_STDCALL sqlite3_prepare(
   sqlite3 *db,            /* Database handle */
   const char *zSql,       /* SQL statement, UTF-8 encoded */
   int nByte,              /* Maximum length of zSql in bytes. */
   sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
   const char **pzTail     /* OUT: Pointer to unused portion of zSql */
 );
-SQLITE_API int sqlite3_prepare_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_prepare_v2(
   sqlite3 *db,            /* Database handle */
   const char *zSql,       /* SQL statement, UTF-8 encoded */
   int nByte,              /* Maximum length of zSql in bytes. */
   sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
   const char **pzTail     /* OUT: Pointer to unused portion of zSql */
 );
-SQLITE_API int sqlite3_prepare16(
+SQLITE_API int SQLITE_STDCALL sqlite3_prepare16(
   sqlite3 *db,            /* Database handle */
   const void *zSql,       /* SQL statement, UTF-16 encoded */
   int nByte,              /* Maximum length of zSql in bytes. */
   sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
   const void **pzTail     /* OUT: Pointer to unused portion of zSql */
 );
-SQLITE_API int sqlite3_prepare16_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_prepare16_v2(
   sqlite3 *db,            /* Database handle */
   const void *zSql,       /* SQL statement, UTF-16 encoded */
   int nByte,              /* Maximum length of zSql in bytes. */
@@ -3438,15 +3524,17 @@ SQLITE_API int sqlite3_prepare16_v2(
 
 /*
 ** CAPI3REF: Retrieving Statement SQL
+** METHOD: sqlite3_stmt
 **
 ** ^This interface can be used to retrieve a saved copy of the original
 ** SQL text used to create a [prepared statement] if that statement was
 ** compiled using either [sqlite3_prepare_v2()] or [sqlite3_prepare16_v2()].
 */
-SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_sql(sqlite3_stmt *pStmt);
 
 /*
 ** CAPI3REF: Determine If An SQL Statement Writes The Database
+** METHOD: sqlite3_stmt
 **
 ** ^The sqlite3_stmt_readonly(X) interface returns true (non-zero) if
 ** and only if the [prepared statement] X makes no direct changes to
@@ -3474,10 +3562,11 @@ SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt);
 ** change the configuration of a database connection, they do not make 
 ** changes to the content of the database files on disk.
 */
-SQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt);
+SQLITE_API int SQLITE_STDCALL sqlite3_stmt_readonly(sqlite3_stmt *pStmt);
 
 /*
 ** CAPI3REF: Determine If A Prepared Statement Has Been Reset
+** METHOD: sqlite3_stmt
 **
 ** ^The sqlite3_stmt_busy(S) interface returns true (non-zero) if the
 ** [prepared statement] S has been stepped at least once using 
@@ -3493,7 +3582,7 @@ SQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt);
 ** for example, in diagnostic routines to search for prepared 
 ** statements that are holding a transaction open.
 */
-SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt*);
+SQLITE_API int SQLITE_STDCALL sqlite3_stmt_busy(sqlite3_stmt*);
 
 /*
 ** CAPI3REF: Dynamically Typed Value Object
@@ -3552,6 +3641,7 @@ typedef struct sqlite3_context sqlite3_context;
 ** CAPI3REF: Binding Values To Prepared Statements
 ** KEYWORDS: {host parameter} {host parameters} {host parameter name}
 ** KEYWORDS: {SQL parameter} {SQL parameters} {parameter binding}
+** METHOD: sqlite3_stmt
 **
 ** ^(In the SQL statement text input to [sqlite3_prepare_v2()] and its variants,
 ** literals may be replaced by a [parameter] that matches one of following
@@ -3654,22 +3744,23 @@ typedef struct sqlite3_context sqlite3_context;
 ** See also: [sqlite3_bind_parameter_count()],
 ** [sqlite3_bind_parameter_name()], and [sqlite3_bind_parameter_index()].
 */
-SQLITE_API int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
-SQLITE_API int sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64,
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64,
                         void(*)(void*));
-SQLITE_API int sqlite3_bind_double(sqlite3_stmt*, int, double);
-SQLITE_API int sqlite3_bind_int(sqlite3_stmt*, int, int);
-SQLITE_API int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);
-SQLITE_API int sqlite3_bind_null(sqlite3_stmt*, int);
-SQLITE_API int sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));
-SQLITE_API int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));
-SQLITE_API int sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_double(sqlite3_stmt*, int, double);
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_int(sqlite3_stmt*, int, int);
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_null(sqlite3_stmt*, int);
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,
                          void(*)(void*), unsigned char encoding);
-SQLITE_API int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
-SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
 
 /*
 ** CAPI3REF: Number Of SQL Parameters
+** METHOD: sqlite3_stmt
 **
 ** ^This routine can be used to find the number of [SQL parameters]
 ** in a [prepared statement].  SQL parameters are tokens of the
@@ -3686,10 +3777,11 @@ SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
 ** [sqlite3_bind_parameter_name()], and
 ** [sqlite3_bind_parameter_index()].
 */
-SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt*);
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_parameter_count(sqlite3_stmt*);
 
 /*
 ** CAPI3REF: Name Of A Host Parameter
+** METHOD: sqlite3_stmt
 **
 ** ^The sqlite3_bind_parameter_name(P,N) interface returns
 ** the name of the N-th [SQL parameter] in the [prepared statement] P.
@@ -3713,10 +3805,11 @@ SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt*);
 ** [sqlite3_bind_parameter_count()], and
 ** [sqlite3_bind_parameter_index()].
 */
-SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_bind_parameter_name(sqlite3_stmt*, int);
 
 /*
 ** CAPI3REF: Index Of A Parameter With A Given Name
+** METHOD: sqlite3_stmt
 **
 ** ^Return the index of an SQL parameter given its name.  ^The
 ** index value returned is suitable for use as the second
@@ -3729,19 +3822,21 @@ SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);
 ** [sqlite3_bind_parameter_count()], and
 ** [sqlite3_bind_parameter_index()].
 */
-SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);
 
 /*
 ** CAPI3REF: Reset All Bindings On A Prepared Statement
+** METHOD: sqlite3_stmt
 **
 ** ^Contrary to the intuition of many, [sqlite3_reset()] does not reset
 ** the [sqlite3_bind_blob | bindings] on a [prepared statement].
 ** ^Use this routine to reset all host parameters to NULL.
 */
-SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt*);
+SQLITE_API int SQLITE_STDCALL sqlite3_clear_bindings(sqlite3_stmt*);
 
 /*
 ** CAPI3REF: Number Of Columns In A Result Set
+** METHOD: sqlite3_stmt
 **
 ** ^Return the number of columns in the result set returned by the
 ** [prepared statement]. ^This routine returns 0 if pStmt is an SQL
@@ -3749,10 +3844,11 @@ SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt*);
 **
 ** See also: [sqlite3_data_count()]
 */
-SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt);
+SQLITE_API int SQLITE_STDCALL sqlite3_column_count(sqlite3_stmt *pStmt);
 
 /*
 ** CAPI3REF: Column Names In A Result Set
+** METHOD: sqlite3_stmt
 **
 ** ^These routines return the name assigned to a particular column
 ** in the result set of a [SELECT] statement.  ^The sqlite3_column_name()
@@ -3777,11 +3873,12 @@ SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt);
 ** then the name of the column is unspecified and may change from
 ** one release of SQLite to the next.
 */
-SQLITE_API const char *sqlite3_column_name(sqlite3_stmt*, int N);
-SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt*, int N);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_column_name(sqlite3_stmt*, int N);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_name16(sqlite3_stmt*, int N);
 
 /*
 ** CAPI3REF: Source Of Data In A Query Result
+** METHOD: sqlite3_stmt
 **
 ** ^These routines provide a means to determine the database, table, and
 ** table column that is the origin of a particular result column in
@@ -3825,15 +3922,16 @@ SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt*, int N);
 ** for the same [prepared statement] and result column
 ** at the same time then the results are undefined.
 */
-SQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt*,int);
-SQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt*,int);
-SQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt*,int);
-SQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt*,int);
-SQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt*,int);
-SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt*,int);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_column_database_name(sqlite3_stmt*,int);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_database_name16(sqlite3_stmt*,int);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_column_table_name(sqlite3_stmt*,int);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_table_name16(sqlite3_stmt*,int);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_column_origin_name(sqlite3_stmt*,int);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_origin_name16(sqlite3_stmt*,int);
 
 /*
 ** CAPI3REF: Declared Datatype Of A Query Result
+** METHOD: sqlite3_stmt
 **
 ** ^(The first parameter is a [prepared statement].
 ** If this statement is a [SELECT] statement and the Nth column of the
@@ -3861,11 +3959,12 @@ SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt*,int);
 ** is associated with individual values, not with the containers
 ** used to hold those values.
 */
-SQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt*,int);
-SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_column_decltype(sqlite3_stmt*,int);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_decltype16(sqlite3_stmt*,int);
 
 /*
 ** CAPI3REF: Evaluate An SQL Statement
+** METHOD: sqlite3_stmt
 **
 ** After a [prepared statement] has been prepared using either
 ** [sqlite3_prepare_v2()] or [sqlite3_prepare16_v2()] or one of the legacy
@@ -3941,10 +4040,11 @@ SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int);
 ** then the more specific [error codes] are returned directly
 ** by sqlite3_step().  The use of the "v2" interface is recommended.
 */
-SQLITE_API int sqlite3_step(sqlite3_stmt*);
+SQLITE_API int SQLITE_STDCALL sqlite3_step(sqlite3_stmt*);
 
 /*
 ** CAPI3REF: Number of columns in a result set
+** METHOD: sqlite3_stmt
 **
 ** ^The sqlite3_data_count(P) interface returns the number of columns in the
 ** current row of the result set of [prepared statement] P.
@@ -3961,7 +4061,7 @@ SQLITE_API int sqlite3_step(sqlite3_stmt*);
 **
 ** See also: [sqlite3_column_count()]
 */
-SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
+SQLITE_API int SQLITE_STDCALL sqlite3_data_count(sqlite3_stmt *pStmt);
 
 /*
 ** CAPI3REF: Fundamental Datatypes
@@ -3998,6 +4098,7 @@ SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
 /*
 ** CAPI3REF: Result Values From A Query
 ** KEYWORDS: {column access functions}
+** METHOD: sqlite3_stmt
 **
 ** These routines form the "result set" interface.
 **
@@ -4157,19 +4258,20 @@ SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
 ** pointer.  Subsequent calls to [sqlite3_errcode()] will return
 ** [SQLITE_NOMEM].)^
 */
-SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);
-SQLITE_API int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
-SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
-SQLITE_API double sqlite3_column_double(sqlite3_stmt*, int iCol);
-SQLITE_API int sqlite3_column_int(sqlite3_stmt*, int iCol);
-SQLITE_API sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);
-SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
-SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);
-SQLITE_API int sqlite3_column_type(sqlite3_stmt*, int iCol);
-SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_blob(sqlite3_stmt*, int iCol);
+SQLITE_API int SQLITE_STDCALL sqlite3_column_bytes(sqlite3_stmt*, int iCol);
+SQLITE_API int SQLITE_STDCALL sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
+SQLITE_API double SQLITE_STDCALL sqlite3_column_double(sqlite3_stmt*, int iCol);
+SQLITE_API int SQLITE_STDCALL sqlite3_column_int(sqlite3_stmt*, int iCol);
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_column_int64(sqlite3_stmt*, int iCol);
+SQLITE_API const unsigned char *SQLITE_STDCALL sqlite3_column_text(sqlite3_stmt*, int iCol);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_text16(sqlite3_stmt*, int iCol);
+SQLITE_API int SQLITE_STDCALL sqlite3_column_type(sqlite3_stmt*, int iCol);
+SQLITE_API sqlite3_value *SQLITE_STDCALL sqlite3_column_value(sqlite3_stmt*, int iCol);
 
 /*
 ** CAPI3REF: Destroy A Prepared Statement Object
+** DESTRUCTOR: sqlite3_stmt
 **
 ** ^The sqlite3_finalize() function is called to delete a [prepared statement].
 ** ^If the most recent evaluation of the statement encountered no errors
@@ -4193,10 +4295,11 @@ SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);
 ** statement after it has been finalized can result in undefined and
 ** undesirable behavior such as segfaults and heap corruption.
 */
-SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt);
+SQLITE_API int SQLITE_STDCALL sqlite3_finalize(sqlite3_stmt *pStmt);
 
 /*
 ** CAPI3REF: Reset A Prepared Statement Object
+** METHOD: sqlite3_stmt
 **
 ** The sqlite3_reset() function is called to reset a [prepared statement]
 ** object back to its initial state, ready to be re-executed.
@@ -4219,13 +4322,14 @@ SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt);
 ** ^The [sqlite3_reset(S)] interface does not change the values
 ** of any [sqlite3_bind_blob|bindings] on the [prepared statement] S.
 */
-SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt);
+SQLITE_API int SQLITE_STDCALL sqlite3_reset(sqlite3_stmt *pStmt);
 
 /*
 ** CAPI3REF: Create Or Redefine SQL Functions
 ** KEYWORDS: {function creation routines}
 ** KEYWORDS: {application-defined SQL function}
 ** KEYWORDS: {application-defined SQL functions}
+** METHOD: sqlite3
 **
 ** ^These functions (collectively known as "function creation routines")
 ** are used to add SQL functions or aggregates or to redefine the behavior
@@ -4318,7 +4422,7 @@ SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt);
 ** close the database connection nor finalize or reset the prepared
 ** statement in which the function is running.
 */
-SQLITE_API int sqlite3_create_function(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_function(
   sqlite3 *db,
   const char *zFunctionName,
   int nArg,
@@ -4328,7 +4432,7 @@ SQLITE_API int sqlite3_create_function(
   void (*xStep)(sqlite3_context*,int,sqlite3_value**),
   void (*xFinal)(sqlite3_context*)
 );
-SQLITE_API int sqlite3_create_function16(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_function16(
   sqlite3 *db,
   const void *zFunctionName,
   int nArg,
@@ -4338,7 +4442,7 @@ SQLITE_API int sqlite3_create_function16(
   void (*xStep)(sqlite3_context*,int,sqlite3_value**),
   void (*xFinal)(sqlite3_context*)
 );
-SQLITE_API int sqlite3_create_function_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_function_v2(
   sqlite3 *db,
   const char *zFunctionName,
   int nArg,
@@ -4380,21 +4484,22 @@ SQLITE_API int sqlite3_create_function_v2(
 ** These functions are [deprecated].  In order to maintain
 ** backwards compatibility with older code, these functions continue 
 ** to be supported.  However, new applications should avoid
-** the use of these functions.  To help encourage people to avoid
-** using these functions, we are not going to tell you what they do.
+** the use of these functions.  To encourage programmers to avoid
+** these functions, we will not explain what they do.
 */
 #ifndef SQLITE_OMIT_DEPRECATED
-SQLITE_API SQLITE_DEPRECATED int sqlite3_aggregate_count(sqlite3_context*);
-SQLITE_API SQLITE_DEPRECATED int sqlite3_expired(sqlite3_stmt*);
-SQLITE_API SQLITE_DEPRECATED int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);
-SQLITE_API SQLITE_DEPRECATED int sqlite3_global_recover(void);
-SQLITE_API SQLITE_DEPRECATED void sqlite3_thread_cleanup(void);
-SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*,sqlite3_int64,int),
+SQLITE_API SQLITE_DEPRECATED int SQLITE_STDCALL sqlite3_aggregate_count(sqlite3_context*);
+SQLITE_API SQLITE_DEPRECATED int SQLITE_STDCALL sqlite3_expired(sqlite3_stmt*);
+SQLITE_API SQLITE_DEPRECATED int SQLITE_STDCALL sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);
+SQLITE_API SQLITE_DEPRECATED int SQLITE_STDCALL sqlite3_global_recover(void);
+SQLITE_API SQLITE_DEPRECATED void SQLITE_STDCALL sqlite3_thread_cleanup(void);
+SQLITE_API SQLITE_DEPRECATED int SQLITE_STDCALL sqlite3_memory_alarm(void(*)(void*,sqlite3_int64,int),
                       void*,sqlite3_int64);
 #endif
 
 /*
 ** CAPI3REF: Obtaining SQL Function Parameter Values
+** METHOD: sqlite3_value
 **
 ** The C-language implementation of SQL functions and aggregates uses
 ** this set of interface routines to access the parameter values on
@@ -4438,21 +4543,22 @@ SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*,sqlite3_int6
 ** These routines must be called from the same thread as
 ** the SQL function that supplied the [sqlite3_value*] parameters.
 */
-SQLITE_API const void *sqlite3_value_blob(sqlite3_value*);
-SQLITE_API int sqlite3_value_bytes(sqlite3_value*);
-SQLITE_API int sqlite3_value_bytes16(sqlite3_value*);
-SQLITE_API double sqlite3_value_double(sqlite3_value*);
-SQLITE_API int sqlite3_value_int(sqlite3_value*);
-SQLITE_API sqlite3_int64 sqlite3_value_int64(sqlite3_value*);
-SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value*);
-SQLITE_API const void *sqlite3_value_text16(sqlite3_value*);
-SQLITE_API const void *sqlite3_value_text16le(sqlite3_value*);
-SQLITE_API const void *sqlite3_value_text16be(sqlite3_value*);
-SQLITE_API int sqlite3_value_type(sqlite3_value*);
-SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_value_blob(sqlite3_value*);
+SQLITE_API int SQLITE_STDCALL sqlite3_value_bytes(sqlite3_value*);
+SQLITE_API int SQLITE_STDCALL sqlite3_value_bytes16(sqlite3_value*);
+SQLITE_API double SQLITE_STDCALL sqlite3_value_double(sqlite3_value*);
+SQLITE_API int SQLITE_STDCALL sqlite3_value_int(sqlite3_value*);
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_value_int64(sqlite3_value*);
+SQLITE_API const unsigned char *SQLITE_STDCALL sqlite3_value_text(sqlite3_value*);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_value_text16(sqlite3_value*);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_value_text16le(sqlite3_value*);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_value_text16be(sqlite3_value*);
+SQLITE_API int SQLITE_STDCALL sqlite3_value_type(sqlite3_value*);
+SQLITE_API int SQLITE_STDCALL sqlite3_value_numeric_type(sqlite3_value*);
 
 /*
 ** CAPI3REF: Obtain Aggregate Function Context
+** METHOD: sqlite3_context
 **
 ** Implementations of aggregate SQL functions use this
 ** routine to allocate memory for storing their state.
@@ -4493,10 +4599,11 @@ SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*);
 ** This routine must be called from the same thread in which
 ** the aggregate SQL function is running.
 */
-SQLITE_API void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);
+SQLITE_API void *SQLITE_STDCALL sqlite3_aggregate_context(sqlite3_context*, int nBytes);
 
 /*
 ** CAPI3REF: User Data For Functions
+** METHOD: sqlite3_context
 **
 ** ^The sqlite3_user_data() interface returns a copy of
 ** the pointer that was the pUserData parameter (the 5th parameter)
@@ -4507,10 +4614,11 @@ SQLITE_API void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);
 ** This routine must be called from the same thread in which
 ** the application-defined function is running.
 */
-SQLITE_API void *sqlite3_user_data(sqlite3_context*);
+SQLITE_API void *SQLITE_STDCALL sqlite3_user_data(sqlite3_context*);
 
 /*
 ** CAPI3REF: Database Connection For Functions
+** METHOD: sqlite3_context
 **
 ** ^The sqlite3_context_db_handle() interface returns a copy of
 ** the pointer to the [database connection] (the 1st parameter)
@@ -4518,10 +4626,11 @@ SQLITE_API void *sqlite3_user_data(sqlite3_context*);
 ** and [sqlite3_create_function16()] routines that originally
 ** registered the application defined function.
 */
-SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context*);
+SQLITE_API sqlite3 *SQLITE_STDCALL sqlite3_context_db_handle(sqlite3_context*);
 
 /*
 ** CAPI3REF: Function Auxiliary Data
+** METHOD: sqlite3_context
 **
 ** These functions may be used by (non-aggregate) SQL functions to
 ** associate metadata with argument values. If the same value is passed to
@@ -4570,8 +4679,8 @@ SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context*);
 ** These routines must be called from the same thread in which
 ** the SQL function is running.
 */
-SQLITE_API void *sqlite3_get_auxdata(sqlite3_context*, int N);
-SQLITE_API void sqlite3_set_auxdata(sqlite3_context*, int N, void*, void (*)(void*));
+SQLITE_API void *SQLITE_STDCALL sqlite3_get_auxdata(sqlite3_context*, int N);
+SQLITE_API void SQLITE_STDCALL sqlite3_set_auxdata(sqlite3_context*, int N, void*, void (*)(void*));
 
 
 /*
@@ -4594,6 +4703,7 @@ typedef void (*sqlite3_destructor_type)(void*);
 
 /*
 ** CAPI3REF: Setting The Result Of An SQL Function
+** METHOD: sqlite3_context
 **
 ** These routines are used by the xFunc or xFinal callbacks that
 ** implement SQL functions and aggregates.  See
@@ -4706,29 +4816,30 @@ typedef void (*sqlite3_destructor_type)(void*);
 ** than the one containing the application-defined function that received
 ** the [sqlite3_context] pointer, the results are undefined.
 */
-SQLITE_API void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));
-SQLITE_API void sqlite3_result_blob64(sqlite3_context*,const void*,
+SQLITE_API void SQLITE_STDCALL sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));
+SQLITE_API void SQLITE_STDCALL sqlite3_result_blob64(sqlite3_context*,const void*,
                            sqlite3_uint64,void(*)(void*));
-SQLITE_API void sqlite3_result_double(sqlite3_context*, double);
-SQLITE_API void sqlite3_result_error(sqlite3_context*, const char*, int);
-SQLITE_API void sqlite3_result_error16(sqlite3_context*, const void*, int);
-SQLITE_API void sqlite3_result_error_toobig(sqlite3_context*);
-SQLITE_API void sqlite3_result_error_nomem(sqlite3_context*);
-SQLITE_API void sqlite3_result_error_code(sqlite3_context*, int);
-SQLITE_API void sqlite3_result_int(sqlite3_context*, int);
-SQLITE_API void sqlite3_result_int64(sqlite3_context*, sqlite3_int64);
-SQLITE_API void sqlite3_result_null(sqlite3_context*);
-SQLITE_API void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));
-SQLITE_API void sqlite3_result_text64(sqlite3_context*, const char*,sqlite3_uint64,
+SQLITE_API void SQLITE_STDCALL sqlite3_result_double(sqlite3_context*, double);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_error(sqlite3_context*, const char*, int);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_error16(sqlite3_context*, const void*, int);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_error_toobig(sqlite3_context*);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_error_nomem(sqlite3_context*);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_error_code(sqlite3_context*, int);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_int(sqlite3_context*, int);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_int64(sqlite3_context*, sqlite3_int64);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_null(sqlite3_context*);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));
+SQLITE_API void SQLITE_STDCALL sqlite3_result_text64(sqlite3_context*, const char*,sqlite3_uint64,
                            void(*)(void*), unsigned char encoding);
-SQLITE_API void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*));
-SQLITE_API void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));
-SQLITE_API void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));
-SQLITE_API void sqlite3_result_value(sqlite3_context*, sqlite3_value*);
-SQLITE_API void sqlite3_result_zeroblob(sqlite3_context*, int n);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*));
+SQLITE_API void SQLITE_STDCALL sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));
+SQLITE_API void SQLITE_STDCALL sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));
+SQLITE_API void SQLITE_STDCALL sqlite3_result_value(sqlite3_context*, sqlite3_value*);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_zeroblob(sqlite3_context*, int n);
 
 /*
 ** CAPI3REF: Define New Collating Sequences
+** METHOD: sqlite3
 **
 ** ^These functions add, remove, or modify a [collation] associated
 ** with the [database connection] specified as the first argument.
@@ -4806,14 +4917,14 @@ SQLITE_API void sqlite3_result_zeroblob(sqlite3_context*, int n);
 **
 ** See also:  [sqlite3_collation_needed()] and [sqlite3_collation_needed16()].
 */
-SQLITE_API int sqlite3_create_collation(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_collation(
   sqlite3*, 
   const char *zName, 
   int eTextRep, 
   void *pArg,
   int(*xCompare)(void*,int,const void*,int,const void*)
 );
-SQLITE_API int sqlite3_create_collation_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_collation_v2(
   sqlite3*, 
   const char *zName, 
   int eTextRep, 
@@ -4821,7 +4932,7 @@ SQLITE_API int sqlite3_create_collation_v2(
   int(*xCompare)(void*,int,const void*,int,const void*),
   void(*xDestroy)(void*)
 );
-SQLITE_API int sqlite3_create_collation16(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_collation16(
   sqlite3*, 
   const void *zName,
   int eTextRep, 
@@ -4831,6 +4942,7 @@ SQLITE_API int sqlite3_create_collation16(
 
 /*
 ** CAPI3REF: Collation Needed Callbacks
+** METHOD: sqlite3
 **
 ** ^To avoid having to register all collation sequences before a database
 ** can be used, a single callback function may be registered with the
@@ -4855,12 +4967,12 @@ SQLITE_API int sqlite3_create_collation16(
 ** [sqlite3_create_collation()], [sqlite3_create_collation16()], or
 ** [sqlite3_create_collation_v2()].
 */
-SQLITE_API int sqlite3_collation_needed(
+SQLITE_API int SQLITE_STDCALL sqlite3_collation_needed(
   sqlite3*, 
   void*, 
   void(*)(void*,sqlite3*,int eTextRep,const char*)
 );
-SQLITE_API int sqlite3_collation_needed16(
+SQLITE_API int SQLITE_STDCALL sqlite3_collation_needed16(
   sqlite3*, 
   void*,
   void(*)(void*,sqlite3*,int eTextRep,const void*)
@@ -4874,11 +4986,11 @@ SQLITE_API int sqlite3_collation_needed16(
 ** The code to implement this API is not available in the public release
 ** of SQLite.
 */
-SQLITE_API int sqlite3_key(
+SQLITE_API int SQLITE_STDCALL sqlite3_key(
   sqlite3 *db,                   /* Database to be rekeyed */
   const void *pKey, int nKey     /* The key */
 );
-SQLITE_API int sqlite3_key_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_key_v2(
   sqlite3 *db,                   /* Database to be rekeyed */
   const char *zDbName,           /* Name of the database */
   const void *pKey, int nKey     /* The key */
@@ -4892,11 +5004,11 @@ SQLITE_API int sqlite3_key_v2(
 ** The code to implement this API is not available in the public release
 ** of SQLite.
 */
-SQLITE_API int sqlite3_rekey(
+SQLITE_API int SQLITE_STDCALL sqlite3_rekey(
   sqlite3 *db,                   /* Database to be rekeyed */
   const void *pKey, int nKey     /* The new key */
 );
-SQLITE_API int sqlite3_rekey_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_rekey_v2(
   sqlite3 *db,                   /* Database to be rekeyed */
   const char *zDbName,           /* Name of the database */
   const void *pKey, int nKey     /* The new key */
@@ -4906,7 +5018,7 @@ SQLITE_API int sqlite3_rekey_v2(
 ** Specify the activation key for a SEE database.  Unless 
 ** activated, none of the SEE routines will work.
 */
-SQLITE_API void sqlite3_activate_see(
+SQLITE_API void SQLITE_STDCALL sqlite3_activate_see(
   const char *zPassPhrase        /* Activation phrase */
 );
 #endif
@@ -4916,7 +5028,7 @@ SQLITE_API void sqlite3_activate_see(
 ** Specify the activation key for a CEROD database.  Unless 
 ** activated, none of the CEROD routines will work.
 */
-SQLITE_API void sqlite3_activate_cerod(
+SQLITE_API void SQLITE_STDCALL sqlite3_activate_cerod(
   const char *zPassPhrase        /* Activation phrase */
 );
 #endif
@@ -4938,7 +5050,7 @@ SQLITE_API void sqlite3_activate_cerod(
 ** all, then the behavior of sqlite3_sleep() may deviate from the description
 ** in the previous paragraphs.
 */
-SQLITE_API int sqlite3_sleep(int);
+SQLITE_API int SQLITE_STDCALL sqlite3_sleep(int);
 
 /*
 ** CAPI3REF: Name Of The Folder Holding Temporary Files
@@ -5038,6 +5150,7 @@ SQLITE_API char *sqlite3_data_directory;
 /*
 ** CAPI3REF: Test For Auto-Commit Mode
 ** KEYWORDS: {autocommit mode}
+** METHOD: sqlite3
 **
 ** ^The sqlite3_get_autocommit() interface returns non-zero or
 ** zero if the given database connection is or is not in autocommit mode,
@@ -5056,10 +5169,11 @@ SQLITE_API char *sqlite3_data_directory;
 ** connection while this routine is running, then the return value
 ** is undefined.
 */
-SQLITE_API int sqlite3_get_autocommit(sqlite3*);
+SQLITE_API int SQLITE_STDCALL sqlite3_get_autocommit(sqlite3*);
 
 /*
 ** CAPI3REF: Find The Database Handle Of A Prepared Statement
+** METHOD: sqlite3_stmt
 **
 ** ^The sqlite3_db_handle interface returns the [database connection] handle
 ** to which a [prepared statement] belongs.  ^The [database connection]
@@ -5068,10 +5182,11 @@ SQLITE_API int sqlite3_get_autocommit(sqlite3*);
 ** to the [sqlite3_prepare_v2()] call (or its variants) that was used to
 ** create the statement in the first place.
 */
-SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt*);
+SQLITE_API sqlite3 *SQLITE_STDCALL sqlite3_db_handle(sqlite3_stmt*);
 
 /*
 ** CAPI3REF: Return The Filename For A Database Connection
+** METHOD: sqlite3
 **
 ** ^The sqlite3_db_filename(D,N) interface returns a pointer to a filename
 ** associated with database N of connection D.  ^The main database file
@@ -5084,19 +5199,21 @@ SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt*);
 ** will be an absolute pathname, even if the filename used
 ** to open the database originally was a URI or relative pathname.
 */
-SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_db_filename(sqlite3 *db, const char *zDbName);
 
 /*
 ** CAPI3REF: Determine if a database is read-only
+** METHOD: sqlite3
 **
 ** ^The sqlite3_db_readonly(D,N) interface returns 1 if the database N
 ** of connection D is read-only, 0 if it is read/write, or -1 if N is not
 ** the name of a database on connection D.
 */
-SQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName);
+SQLITE_API int SQLITE_STDCALL sqlite3_db_readonly(sqlite3 *db, const char *zDbName);
 
 /*
 ** CAPI3REF: Find the next prepared statement
+** METHOD: sqlite3
 **
 ** ^This interface returns a pointer to the next [prepared statement] after
 ** pStmt associated with the [database connection] pDb.  ^If pStmt is NULL
@@ -5108,10 +5225,11 @@ SQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName);
 ** [sqlite3_next_stmt(D,S)] must refer to an open database
 ** connection and in particular must not be a NULL pointer.
 */
-SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);
+SQLITE_API sqlite3_stmt *SQLITE_STDCALL sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);
 
 /*
 ** CAPI3REF: Commit And Rollback Notification Callbacks
+** METHOD: sqlite3
 **
 ** ^The sqlite3_commit_hook() interface registers a callback
 ** function to be invoked whenever a transaction is [COMMIT | committed].
@@ -5156,11 +5274,12 @@ SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);
 **
 ** See also the [sqlite3_update_hook()] interface.
 */
-SQLITE_API void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);
-SQLITE_API void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);
+SQLITE_API void *SQLITE_STDCALL sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);
+SQLITE_API void *SQLITE_STDCALL sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);
 
 /*
 ** CAPI3REF: Data Change Notification Callbacks
+** METHOD: sqlite3
 **
 ** ^The sqlite3_update_hook() interface registers a callback function
 ** with the [database connection] identified by the first argument
@@ -5207,7 +5326,7 @@ SQLITE_API void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);
 ** See also the [sqlite3_commit_hook()] and [sqlite3_rollback_hook()]
 ** interfaces.
 */
-SQLITE_API void *sqlite3_update_hook(
+SQLITE_API void *SQLITE_STDCALL sqlite3_update_hook(
   sqlite3*, 
   void(*)(void *,int ,char const *,char const *,sqlite3_int64),
   void*
@@ -5237,12 +5356,17 @@ SQLITE_API void *sqlite3_update_hook(
 ** future releases of SQLite.  Applications that care about shared
 ** cache setting should set it explicitly.
 **
+** Note: This method is disabled on MacOS X 10.7 and iOS version 5.0
+** and will always return SQLITE_MISUSE. On those systems, 
+** shared cache mode should be enabled per-database connection via 
+** [sqlite3_open_v2()] with [SQLITE_OPEN_SHAREDCACHE].
+**
 ** This interface is threadsafe on processors where writing a
 ** 32-bit integer is atomic.
 **
 ** See Also:  [SQLite Shared-Cache Mode]
 */
-SQLITE_API int sqlite3_enable_shared_cache(int);
+SQLITE_API int SQLITE_STDCALL sqlite3_enable_shared_cache(int);
 
 /*
 ** CAPI3REF: Attempt To Free Heap Memory
@@ -5258,10 +5382,11 @@ SQLITE_API int sqlite3_enable_shared_cache(int);
 **
 ** See also: [sqlite3_db_release_memory()]
 */
-SQLITE_API int sqlite3_release_memory(int);
+SQLITE_API int SQLITE_STDCALL sqlite3_release_memory(int);
 
 /*
 ** CAPI3REF: Free Memory Used By A Database Connection
+** METHOD: sqlite3
 **
 ** ^The sqlite3_db_release_memory(D) interface attempts to free as much heap
 ** memory as possible from database connection D. Unlike the
@@ -5271,7 +5396,7 @@ SQLITE_API int sqlite3_release_memory(int);
 **
 ** See also: [sqlite3_release_memory()]
 */
-SQLITE_API int sqlite3_db_release_memory(sqlite3*);
+SQLITE_API int SQLITE_STDCALL sqlite3_db_release_memory(sqlite3*);
 
 /*
 ** CAPI3REF: Impose A Limit On Heap Size
@@ -5323,7 +5448,7 @@ SQLITE_API int sqlite3_db_release_memory(sqlite3*);
 ** The circumstances under which SQLite will enforce the soft heap limit may
 ** changes in future releases of SQLite.
 */
-SQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 N);
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_soft_heap_limit64(sqlite3_int64 N);
 
 /*
 ** CAPI3REF: Deprecated Soft Heap Limit Interface
@@ -5334,11 +5459,12 @@ SQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 N);
 ** only.  All new applications should use the
 ** [sqlite3_soft_heap_limit64()] interface rather than this one.
 */
-SQLITE_API SQLITE_DEPRECATED void sqlite3_soft_heap_limit(int N);
+SQLITE_API SQLITE_DEPRECATED void SQLITE_STDCALL sqlite3_soft_heap_limit(int N);
 
 
 /*
 ** CAPI3REF: Extract Metadata About A Column Of A Table
+** METHOD: sqlite3
 **
 ** ^(The sqlite3_table_column_metadata(X,D,T,C,....) routine returns
 ** information about column C of table T in database D
@@ -5403,7 +5529,7 @@ SQLITE_API SQLITE_DEPRECATED void sqlite3_soft_heap_limit(int N);
 ** parsed, if that has not already been done, and returns an error if
 ** any errors are encountered while loading the schema.
 */
-SQLITE_API int sqlite3_table_column_metadata(
+SQLITE_API int SQLITE_STDCALL sqlite3_table_column_metadata(
   sqlite3 *db,                /* Connection handle */
   const char *zDbName,        /* Database name or NULL */
   const char *zTableName,     /* Table name */
@@ -5417,6 +5543,7 @@ SQLITE_API int sqlite3_table_column_metadata(
 
 /*
 ** CAPI3REF: Load An Extension
+** METHOD: sqlite3
 **
 ** ^This interface loads an SQLite extension library from the named file.
 **
@@ -5449,7 +5576,7 @@ SQLITE_API int sqlite3_table_column_metadata(
 **
 ** See also the [load_extension() SQL function].
 */
-SQLITE_API int sqlite3_load_extension(
+SQLITE_API int SQLITE_STDCALL sqlite3_load_extension(
   sqlite3 *db,          /* Load the extension into this database connection */
   const char *zFile,    /* Name of the shared library containing extension */
   const char *zProc,    /* Entry point.  Derived from zFile if 0 */
@@ -5458,6 +5585,7 @@ SQLITE_API int sqlite3_load_extension(
 
 /*
 ** CAPI3REF: Enable Or Disable Extension Loading
+** METHOD: sqlite3
 **
 ** ^So as not to open security holes in older applications that are
 ** unprepared to deal with [extension loading], and as a means of disabling
@@ -5469,7 +5597,7 @@ SQLITE_API int sqlite3_load_extension(
 ** to turn extension loading on and call it with onoff==0 to turn
 ** it back off again.
 */
-SQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff);
+SQLITE_API int SQLITE_STDCALL sqlite3_enable_load_extension(sqlite3 *db, int onoff);
 
 /*
 ** CAPI3REF: Automatically Load Statically Linked Extensions
@@ -5507,7 +5635,7 @@ SQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff);
 ** See also: [sqlite3_reset_auto_extension()]
 ** and [sqlite3_cancel_auto_extension()]
 */
-SQLITE_API int sqlite3_auto_extension(void (*xEntryPoint)(void));
+SQLITE_API int SQLITE_STDCALL sqlite3_auto_extension(void (*xEntryPoint)(void));
 
 /*
 ** CAPI3REF: Cancel Automatic Extension Loading
@@ -5519,7 +5647,7 @@ SQLITE_API int sqlite3_auto_extension(void (*xEntryPoint)(void));
 ** unregistered and it returns 0 if X was not on the list of initialization
 ** routines.
 */
-SQLITE_API int sqlite3_cancel_auto_extension(void (*xEntryPoint)(void));
+SQLITE_API int SQLITE_STDCALL sqlite3_cancel_auto_extension(void (*xEntryPoint)(void));
 
 /*
 ** CAPI3REF: Reset Automatic Extension Loading
@@ -5527,7 +5655,7 @@ SQLITE_API int sqlite3_cancel_auto_extension(void (*xEntryPoint)(void));
 ** ^This interface disables all automatic extensions previously
 ** registered using [sqlite3_auto_extension()].
 */
-SQLITE_API void sqlite3_reset_auto_extension(void);
+SQLITE_API void SQLITE_STDCALL sqlite3_reset_auto_extension(void);
 
 /*
 ** The interface to the virtual-table mechanism is currently considered
@@ -5707,6 +5835,7 @@ struct sqlite3_index_info {
 
 /*
 ** CAPI3REF: Register A Virtual Table Implementation
+** METHOD: sqlite3
 **
 ** ^These routines are used to register a new [virtual table module] name.
 ** ^Module names must be registered before
@@ -5730,13 +5859,13 @@ struct sqlite3_index_info {
 ** interface is equivalent to sqlite3_create_module_v2() with a NULL
 ** destructor.
 */
-SQLITE_API int sqlite3_create_module(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_module(
   sqlite3 *db,               /* SQLite connection to register module with */
   const char *zName,         /* Name of the module */
   const sqlite3_module *p,   /* Methods for the module */
   void *pClientData          /* Client data for xCreate/xConnect */
 );
-SQLITE_API int sqlite3_create_module_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_module_v2(
   sqlite3 *db,               /* SQLite connection to register module with */
   const char *zName,         /* Name of the module */
   const sqlite3_module *p,   /* Methods for the module */
@@ -5764,7 +5893,7 @@ SQLITE_API int sqlite3_create_module_v2(
 */
 struct sqlite3_vtab {
   const sqlite3_module *pModule;  /* The module for this virtual table */
-  int nRef;                       /* NO LONGER USED */
+  int nRef;                       /* Number of open cursors */
   char *zErrMsg;                  /* Error message from sqlite3_mprintf() */
   /* Virtual table implementations will typically add additional fields */
 };
@@ -5799,10 +5928,11 @@ struct sqlite3_vtab_cursor {
 ** to declare the format (the names and datatypes of the columns) of
 ** the virtual tables they implement.
 */
-SQLITE_API int sqlite3_declare_vtab(sqlite3*, const char *zSQL);
+SQLITE_API int SQLITE_STDCALL sqlite3_declare_vtab(sqlite3*, const char *zSQL);
 
 /*
 ** CAPI3REF: Overload A Function For A Virtual Table
+** METHOD: sqlite3
 **
 ** ^(Virtual tables can provide alternative implementations of functions
 ** using the [xFindFunction] method of the [virtual table module].  
@@ -5817,7 +5947,7 @@ SQLITE_API int sqlite3_declare_vtab(sqlite3*, const char *zSQL);
 ** purpose is to be a placeholder function that can be overloaded
 ** by a [virtual table].
 */
-SQLITE_API int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);
+SQLITE_API int SQLITE_STDCALL sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);
 
 /*
 ** The interface to the virtual-table mechanism defined above (back up
@@ -5845,6 +5975,8 @@ typedef struct sqlite3_blob sqlite3_blob;
 
 /*
 ** CAPI3REF: Open A BLOB For Incremental I/O
+** METHOD: sqlite3
+** CONSTRUCTOR: sqlite3_blob
 **
 ** ^(This interfaces opens a [BLOB handle | handle] to the BLOB located
 ** in row iRow, column zColumn, table zTable in database zDb;
@@ -5914,7 +6046,7 @@ typedef struct sqlite3_blob sqlite3_blob;
 ** To avoid a resource leak, every open [BLOB handle] should eventually
 ** be released by a call to [sqlite3_blob_close()].
 */
-SQLITE_API int sqlite3_blob_open(
+SQLITE_API int SQLITE_STDCALL sqlite3_blob_open(
   sqlite3*,
   const char *zDb,
   const char *zTable,
@@ -5926,6 +6058,7 @@ SQLITE_API int sqlite3_blob_open(
 
 /*
 ** CAPI3REF: Move a BLOB Handle to a New Row
+** METHOD: sqlite3_blob
 **
 ** ^This function is used to move an existing blob handle so that it points
 ** to a different row of the same database table. ^The new row is identified
@@ -5946,10 +6079,11 @@ SQLITE_API int sqlite3_blob_open(
 **
 ** ^This function sets the database handle error code and message.
 */
-SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64);
+SQLITE_API SQLITE_EXPERIMENTAL int SQLITE_STDCALL sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64);
 
 /*
 ** CAPI3REF: Close A BLOB Handle
+** DESTRUCTOR: sqlite3_blob
 **
 ** ^This function closes an open [BLOB handle]. ^(The BLOB handle is closed
 ** unconditionally.  Even if this routine returns an error code, the 
@@ -5968,10 +6102,11 @@ SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_i
 ** is passed a valid open blob handle, the values returned by the 
 ** sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.
 */
-SQLITE_API int sqlite3_blob_close(sqlite3_blob *);
+SQLITE_API int SQLITE_STDCALL sqlite3_blob_close(sqlite3_blob *);
 
 /*
 ** CAPI3REF: Return The Size Of An Open BLOB
+** METHOD: sqlite3_blob
 **
 ** ^Returns the size in bytes of the BLOB accessible via the 
 ** successfully opened [BLOB handle] in its only argument.  ^The
@@ -5983,10 +6118,11 @@ SQLITE_API int sqlite3_blob_close(sqlite3_blob *);
 ** been closed by [sqlite3_blob_close()].  Passing any other pointer in
 ** to this routine results in undefined and probably undesirable behavior.
 */
-SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *);
+SQLITE_API int SQLITE_STDCALL sqlite3_blob_bytes(sqlite3_blob *);
 
 /*
 ** CAPI3REF: Read Data From A BLOB Incrementally
+** METHOD: sqlite3_blob
 **
 ** ^(This function is used to read data from an open [BLOB handle] into a
 ** caller-supplied buffer. N bytes of data are copied into buffer Z
@@ -6011,10 +6147,11 @@ SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *);
 **
 ** See also: [sqlite3_blob_write()].
 */
-SQLITE_API int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);
+SQLITE_API int SQLITE_STDCALL sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);
 
 /*
 ** CAPI3REF: Write Data Into A BLOB Incrementally
+** METHOD: sqlite3_blob
 **
 ** ^(This function is used to write data into an open [BLOB handle] from a
 ** caller-supplied buffer. N bytes of data are copied from the buffer Z
@@ -6052,7 +6189,7 @@ SQLITE_API int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);
 **
 ** See also: [sqlite3_blob_read()].
 */
-SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);
+SQLITE_API int SQLITE_STDCALL sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);
 
 /*
 ** CAPI3REF: Virtual File System Objects
@@ -6083,9 +6220,9 @@ SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOff
 ** ^(If the default VFS is unregistered, another VFS is chosen as
 ** the default.  The choice for the new VFS is arbitrary.)^
 */
-SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName);
-SQLITE_API int sqlite3_vfs_register(sqlite3_vfs*, int makeDflt);
-SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs*);
+SQLITE_API sqlite3_vfs *SQLITE_STDCALL sqlite3_vfs_find(const char *zVfsName);
+SQLITE_API int SQLITE_STDCALL sqlite3_vfs_register(sqlite3_vfs*, int makeDflt);
+SQLITE_API int SQLITE_STDCALL sqlite3_vfs_unregister(sqlite3_vfs*);
 
 /*
 ** CAPI3REF: Mutexes
@@ -6198,11 +6335,11 @@ SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs*);
 **
 ** See also: [sqlite3_mutex_held()] and [sqlite3_mutex_notheld()].
 */
-SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int);
-SQLITE_API void sqlite3_mutex_free(sqlite3_mutex*);
-SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex*);
-SQLITE_API int sqlite3_mutex_try(sqlite3_mutex*);
-SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex*);
+SQLITE_API sqlite3_mutex *SQLITE_STDCALL sqlite3_mutex_alloc(int);
+SQLITE_API void SQLITE_STDCALL sqlite3_mutex_free(sqlite3_mutex*);
+SQLITE_API void SQLITE_STDCALL sqlite3_mutex_enter(sqlite3_mutex*);
+SQLITE_API int SQLITE_STDCALL sqlite3_mutex_try(sqlite3_mutex*);
+SQLITE_API void SQLITE_STDCALL sqlite3_mutex_leave(sqlite3_mutex*);
 
 /*
 ** CAPI3REF: Mutex Methods Object
@@ -6312,8 +6449,8 @@ struct sqlite3_mutex_methods {
 ** interface should also return 1 when given a NULL pointer.
 */
 #ifndef NDEBUG
-SQLITE_API int sqlite3_mutex_held(sqlite3_mutex*);
-SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex*);
+SQLITE_API int SQLITE_STDCALL sqlite3_mutex_held(sqlite3_mutex*);
+SQLITE_API int SQLITE_STDCALL sqlite3_mutex_notheld(sqlite3_mutex*);
 #endif
 
 /*
@@ -6342,6 +6479,7 @@ SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex*);
 
 /*
 ** CAPI3REF: Retrieve the mutex for a database connection
+** METHOD: sqlite3
 **
 ** ^This interface returns a pointer the [sqlite3_mutex] object that 
 ** serializes access to the [database connection] given in the argument
@@ -6349,10 +6487,11 @@ SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex*);
 ** ^If the [threading mode] is Single-thread or Multi-thread then this
 ** routine returns a NULL pointer.
 */
-SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3*);
+SQLITE_API sqlite3_mutex *SQLITE_STDCALL sqlite3_db_mutex(sqlite3*);
 
 /*
 ** CAPI3REF: Low-Level Control Of Database Files
+** METHOD: sqlite3
 **
 ** ^The [sqlite3_file_control()] interface makes a direct call to the
 ** xFileControl method for the [sqlite3_io_methods] object associated
@@ -6383,7 +6522,7 @@ SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3*);
 **
 ** See also: [SQLITE_FCNTL_LOCKSTATE]
 */
-SQLITE_API int sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*);
+SQLITE_API int SQLITE_STDCALL sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*);
 
 /*
 ** CAPI3REF: Testing Interface
@@ -6402,7 +6541,7 @@ SQLITE_API int sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*
 ** Unlike most of the SQLite API, this function is not guaranteed to
 ** operate consistently from one release to the next.
 */
-SQLITE_API int sqlite3_test_control(int op, ...);
+SQLITE_API int SQLITE_CDECL sqlite3_test_control(int op, ...);
 
 /*
 ** CAPI3REF: Testing Interface Operation Codes
@@ -6436,12 +6575,13 @@ SQLITE_API int sqlite3_test_control(int op, ...);
 #define SQLITE_TESTCTRL_BYTEORDER               22
 #define SQLITE_TESTCTRL_ISINIT                  23
 #define SQLITE_TESTCTRL_SORTER_MMAP             24
-#define SQLITE_TESTCTRL_LAST                    24
+#define SQLITE_TESTCTRL_IMPOSTER                25
+#define SQLITE_TESTCTRL_LAST                    25
 
 /*
 ** CAPI3REF: SQLite Runtime Status
 **
-** ^This interface is used to retrieve runtime status information
+** ^These interfaces are used to retrieve runtime status information
 ** about the performance of SQLite, and optionally to reset various
 ** highwater marks.  ^The first argument is an integer code for
 ** the specific parameter to measure.  ^(Recognized integer codes
@@ -6455,19 +6595,22 @@ SQLITE_API int sqlite3_test_control(int op, ...);
 ** ^(Other parameters record only the highwater mark and not the current
 ** value.  For these latter parameters nothing is written into *pCurrent.)^
 **
-** ^The sqlite3_status() routine returns SQLITE_OK on success and a
-** non-zero [error code] on failure.
+** ^The sqlite3_status() and sqlite3_status64() routines return
+** SQLITE_OK on success and a non-zero [error code] on failure.
 **
-** This routine is threadsafe but is not atomic.  This routine can be
-** called while other threads are running the same or different SQLite
-** interfaces.  However the values returned in *pCurrent and
-** *pHighwater reflect the status of SQLite at different points in time
-** and it is possible that another thread might change the parameter
-** in between the times when *pCurrent and *pHighwater are written.
+** If either the current value or the highwater mark is too large to
+** be represented by a 32-bit integer, then the values returned by
+** sqlite3_status() are undefined.
 **
 ** See also: [sqlite3_db_status()]
 */
-SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag);
+SQLITE_API int SQLITE_STDCALL sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag);
+SQLITE_API int SQLITE_STDCALL sqlite3_status64(
+  int op,
+  sqlite3_int64 *pCurrent,
+  sqlite3_int64 *pHighwater,
+  int resetFlag
+);
 
 
 /*
@@ -6565,6 +6708,7 @@ SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetF
 
 /*
 ** CAPI3REF: Database Connection Status
+** METHOD: sqlite3
 **
 ** ^This interface is used to retrieve runtime status information 
 ** about a single [database connection].  ^The first argument is the
@@ -6585,7 +6729,7 @@ SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetF
 **
 ** See also: [sqlite3_status()] and [sqlite3_stmt_status()].
 */
-SQLITE_API int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg);
+SQLITE_API int SQLITE_STDCALL sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg);
 
 /*
 ** CAPI3REF: Status Parameters for database connections
@@ -6693,6 +6837,7 @@ SQLITE_API int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int r
 
 /*
 ** CAPI3REF: Prepared Statement Status
+** METHOD: sqlite3_stmt
 **
 ** ^(Each prepared statement maintains various
 ** [SQLITE_STMTSTATUS counters] that measure the number
@@ -6714,7 +6859,7 @@ SQLITE_API int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int r
 **
 ** See also: [sqlite3_status()] and [sqlite3_db_status()].
 */
-SQLITE_API int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);
+SQLITE_API int SQLITE_STDCALL sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);
 
 /*
 ** CAPI3REF: Status Parameters for prepared statements
@@ -7137,20 +7282,20 @@ typedef struct sqlite3_backup sqlite3_backup;
 ** is not a permanent error and does not affect the return value of
 ** sqlite3_backup_finish().
 **
-** [[sqlite3_backup__remaining()]] [[sqlite3_backup_pagecount()]]
+** [[sqlite3_backup_remaining()]] [[sqlite3_backup_pagecount()]]
 ** <b>sqlite3_backup_remaining() and sqlite3_backup_pagecount()</b>
 **
-** ^Each call to sqlite3_backup_step() sets two values inside
-** the [sqlite3_backup] object: the number of pages still to be backed
-** up and the total number of pages in the source database file.
-** The sqlite3_backup_remaining() and sqlite3_backup_pagecount() interfaces
-** retrieve these two values, respectively.
-**
-** ^The values returned by these functions are only updated by
-** sqlite3_backup_step(). ^If the source database is modified during a backup
-** operation, then the values are not updated to account for any extra
-** pages that need to be updated or the size of the source database file
-** changing.
+** ^The sqlite3_backup_remaining() routine returns the number of pages still
+** to be backed up at the conclusion of the most recent sqlite3_backup_step().
+** ^The sqlite3_backup_pagecount() routine returns the total number of pages
+** in the source database at the conclusion of the most recent
+** sqlite3_backup_step().
+** ^(The values returned by these functions are only updated by
+** sqlite3_backup_step(). If the source database is modified in a way that
+** changes the size of the source database or the number of pages remaining,
+** those changes are not reflected in the output of sqlite3_backup_pagecount()
+** and sqlite3_backup_remaining() until after the next
+** sqlite3_backup_step().)^
 **
 ** <b>Concurrent Usage of Database Handles</b>
 **
@@ -7183,19 +7328,20 @@ typedef struct sqlite3_backup sqlite3_backup;
 ** same time as another thread is invoking sqlite3_backup_step() it is
 ** possible that they return invalid values.
 */
-SQLITE_API sqlite3_backup *sqlite3_backup_init(
+SQLITE_API sqlite3_backup *SQLITE_STDCALL sqlite3_backup_init(
   sqlite3 *pDest,                        /* Destination database handle */
   const char *zDestName,                 /* Destination database name */
   sqlite3 *pSource,                      /* Source database handle */
   const char *zSourceName                /* Source database name */
 );
-SQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage);
-SQLITE_API int sqlite3_backup_finish(sqlite3_backup *p);
-SQLITE_API int sqlite3_backup_remaining(sqlite3_backup *p);
-SQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p);
+SQLITE_API int SQLITE_STDCALL sqlite3_backup_step(sqlite3_backup *p, int nPage);
+SQLITE_API int SQLITE_STDCALL sqlite3_backup_finish(sqlite3_backup *p);
+SQLITE_API int SQLITE_STDCALL sqlite3_backup_remaining(sqlite3_backup *p);
+SQLITE_API int SQLITE_STDCALL sqlite3_backup_pagecount(sqlite3_backup *p);
 
 /*
 ** CAPI3REF: Unlock Notification
+** METHOD: sqlite3
 **
 ** ^When running in shared-cache mode, a database operation may fail with
 ** an [SQLITE_LOCKED] error if the required locks on the shared-cache or
@@ -7308,7 +7454,7 @@ SQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p);
 ** the special "DROP TABLE/INDEX" case, the extended error code is just 
 ** SQLITE_LOCKED.)^
 */
-SQLITE_API int sqlite3_unlock_notify(
+SQLITE_API int SQLITE_STDCALL sqlite3_unlock_notify(
   sqlite3 *pBlocked,                          /* Waiting connection */
   void (*xNotify)(void **apArg, int nArg),    /* Callback function to invoke */
   void *pNotifyArg                            /* Argument to pass to xNotify */
@@ -7323,8 +7469,8 @@ SQLITE_API int sqlite3_unlock_notify(
 ** strings in a case-independent fashion, using the same definition of "case
 ** independence" that SQLite uses internally when comparing identifiers.
 */
-SQLITE_API int sqlite3_stricmp(const char *, const char *);
-SQLITE_API int sqlite3_strnicmp(const char *, const char *, int);
+SQLITE_API int SQLITE_STDCALL sqlite3_stricmp(const char *, const char *);
+SQLITE_API int SQLITE_STDCALL sqlite3_strnicmp(const char *, const char *, int);
 
 /*
 ** CAPI3REF: String Globbing
@@ -7339,7 +7485,7 @@ SQLITE_API int sqlite3_strnicmp(const char *, const char *, int);
 ** Note that this routine returns zero on a match and non-zero if the strings
 ** do not match, the same as [sqlite3_stricmp()] and [sqlite3_strnicmp()].
 */
-SQLITE_API int sqlite3_strglob(const char *zGlob, const char *zStr);
+SQLITE_API int SQLITE_STDCALL sqlite3_strglob(const char *zGlob, const char *zStr);
 
 /*
 ** CAPI3REF: Error Logging Interface
@@ -7362,10 +7508,11 @@ SQLITE_API int sqlite3_strglob(const char *zGlob, const char *zStr);
 ** a few hundred characters, it will be truncated to the length of the
 ** buffer.
 */
-SQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...);
+SQLITE_API void SQLITE_CDECL sqlite3_log(int iErrCode, const char *zFormat, ...);
 
 /*
 ** CAPI3REF: Write-Ahead Log Commit Hook
+** METHOD: sqlite3
 **
 ** ^The [sqlite3_wal_hook()] function is used to register a callback that
 ** is invoked each time data is committed to a database in wal mode.
@@ -7397,7 +7544,7 @@ SQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...);
 ** [wal_autocheckpoint pragma] both invoke [sqlite3_wal_hook()] and will
 ** those overwrite any prior [sqlite3_wal_hook()] settings.
 */
-SQLITE_API void *sqlite3_wal_hook(
+SQLITE_API void *SQLITE_STDCALL sqlite3_wal_hook(
   sqlite3*, 
   int(*)(void *,sqlite3*,const char*,int),
   void*
@@ -7405,6 +7552,7 @@ SQLITE_API void *sqlite3_wal_hook(
 
 /*
 ** CAPI3REF: Configure an auto-checkpoint
+** METHOD: sqlite3
 **
 ** ^The [sqlite3_wal_autocheckpoint(D,N)] is a wrapper around
 ** [sqlite3_wal_hook()] that causes any database on [database connection] D
@@ -7431,10 +7579,11 @@ SQLITE_API void *sqlite3_wal_hook(
 ** is only necessary if the default setting is found to be suboptimal
 ** for a particular application.
 */
-SQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int N);
+SQLITE_API int SQLITE_STDCALL sqlite3_wal_autocheckpoint(sqlite3 *db, int N);
 
 /*
 ** CAPI3REF: Checkpoint a database
+** METHOD: sqlite3
 **
 ** ^(The sqlite3_wal_checkpoint(D,X) is equivalent to
 ** [sqlite3_wal_checkpoint_v2](D,X,[SQLITE_CHECKPOINT_PASSIVE],0,0).)^
@@ -7452,10 +7601,11 @@ SQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int N);
 ** start a callback but which do not need the full power (and corresponding
 ** complication) of [sqlite3_wal_checkpoint_v2()].
 */
-SQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb);
+SQLITE_API int SQLITE_STDCALL sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb);
 
 /*
 ** CAPI3REF: Checkpoint a database
+** METHOD: sqlite3
 **
 ** ^(The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint
 ** operation on database X of [database connection] D in mode M.  Status
@@ -7545,7 +7695,7 @@ SQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb);
 ** ^The [PRAGMA wal_checkpoint] command can be used to invoke this interface
 ** from SQL.
 */
-SQLITE_API int sqlite3_wal_checkpoint_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_wal_checkpoint_v2(
   sqlite3 *db,                    /* Database handle */
   const char *zDb,                /* Name of attached database (or NULL) */
   int eMode,                      /* SQLITE_CHECKPOINT_* value */
@@ -7581,7 +7731,7 @@ SQLITE_API int sqlite3_wal_checkpoint_v2(
 ** this function. (See [SQLITE_VTAB_CONSTRAINT_SUPPORT].)  Further options
 ** may be added in the future.
 */
-SQLITE_API int sqlite3_vtab_config(sqlite3*, int op, ...);
+SQLITE_API int SQLITE_CDECL sqlite3_vtab_config(sqlite3*, int op, ...);
 
 /*
 ** CAPI3REF: Virtual Table Configuration Options
@@ -7634,7 +7784,7 @@ SQLITE_API int sqlite3_vtab_config(sqlite3*, int op, ...);
 ** of the SQL statement that triggered the call to the [xUpdate] method of the
 ** [virtual table].
 */
-SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *);
+SQLITE_API int SQLITE_STDCALL sqlite3_vtab_on_conflict(sqlite3 *);
 
 /*
 ** CAPI3REF: Conflict resolution modes
@@ -7710,6 +7860,7 @@ SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *);
 
 /*
 ** CAPI3REF: Prepared Statement Scan Status
+** METHOD: sqlite3_stmt
 **
 ** This interface returns information about the predicted and measured
 ** performance for pStmt.  Advanced applications can use this
@@ -7738,7 +7889,7 @@ SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *);
 **
 ** See also: [sqlite3_stmt_scanstatus_reset()]
 */
-SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_stmt_scanstatus(
+SQLITE_API SQLITE_EXPERIMENTAL int SQLITE_STDCALL sqlite3_stmt_scanstatus(
   sqlite3_stmt *pStmt,      /* Prepared statement for which info desired */
   int idx,                  /* Index of loop to report on */
   int iScanStatusOp,        /* Information desired.  SQLITE_SCANSTAT_* */
@@ -7747,13 +7898,14 @@ SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_stmt_scanstatus(
 
 /*
 ** CAPI3REF: Zero Scan-Status Counters
+** METHOD: sqlite3_stmt
 **
 ** ^Zero all [sqlite3_stmt_scanstatus()] related event counters.
 **
 ** This API is only available if the library is built with pre-processor
 ** symbol [SQLITE_ENABLE_STMT_SCANSTATUS] defined.
 */
-SQLITE_API SQLITE_EXPERIMENTAL void sqlite3_stmt_scanstatus_reset(sqlite3_stmt*);
+SQLITE_API SQLITE_EXPERIMENTAL void SQLITE_STDCALL sqlite3_stmt_scanstatus_reset(sqlite3_stmt*);
 
 
 /*
@@ -7808,7 +7960,7 @@ typedef struct sqlite3_rtree_query_info sqlite3_rtree_query_info;
 **
 **   SELECT ... FROM <rtree> WHERE <rtree col> MATCH $zGeom(... params ...)
 */
-SQLITE_API int sqlite3_rtree_geometry_callback(
+SQLITE_API int SQLITE_STDCALL sqlite3_rtree_geometry_callback(
   sqlite3 *db,
   const char *zGeom,
   int (*xGeom)(sqlite3_rtree_geometry*, int, sqlite3_rtree_dbl*,int*),
@@ -7834,7 +7986,7 @@ struct sqlite3_rtree_geometry {
 **
 **   SELECT ... FROM <rtree> WHERE <rtree col> MATCH $zQueryFunc(... params ...)
 */
-SQLITE_API int sqlite3_rtree_query_callback(
+SQLITE_API int SQLITE_STDCALL sqlite3_rtree_query_callback(
   sqlite3 *db,
   const char *zQueryFunc,
   int (*xQueryFunc)(sqlite3_rtree_query_info*),
@@ -7998,15 +8150,17 @@ struct sqlite3_rtree_query_info {
 #endif
 
 /*
-** The maximum number of in-memory pages to use for the main database
-** table and for temporary tables.  The SQLITE_DEFAULT_CACHE_SIZE
+** The suggested maximum number of in-memory pages to use for
+** the main database table and for temporary tables.
+**
+** IMPLEMENTATION-OF: R-31093-59126 The default suggested cache size
+** is 2000 pages.
+** IMPLEMENTATION-OF: R-48205-43578 The default suggested cache size can be
+** altered using the SQLITE_DEFAULT_CACHE_SIZE compile-time options.
 */
 #ifndef SQLITE_DEFAULT_CACHE_SIZE
 # define SQLITE_DEFAULT_CACHE_SIZE  2000
 #endif
-#ifndef SQLITE_DEFAULT_TEMP_CACHE_SIZE
-# define SQLITE_DEFAULT_TEMP_CACHE_SIZE  500
-#endif
 
 /*
 ** The default number of frames to accumulate in the log file before
@@ -8355,6 +8509,32 @@ SQLITE_PRIVATE   void sqlite3Coverage(int);
 # define NEVER(X)       (X)
 #endif
 
+/*
+** Declarations used for tracing the operating system interfaces.
+*/
+#if defined(SQLITE_FORCE_OS_TRACE) || defined(SQLITE_TEST) || \
+    (defined(SQLITE_DEBUG) && SQLITE_OS_WIN)
+  extern int sqlite3OSTrace;
+# define OSTRACE(X)          if( sqlite3OSTrace ) sqlite3DebugPrintf X
+# define SQLITE_HAVE_OS_TRACE
+#else
+# define OSTRACE(X)
+# undef  SQLITE_HAVE_OS_TRACE
+#endif
+
+/*
+** Is the sqlite3ErrName() function needed in the build?  Currently,
+** it is needed by "mutex_w32.c" (when debugging), "os_win.c" (when
+** OSTRACE is enabled), and by several "test*.c" files (which are
+** compiled using SQLITE_TEST).
+*/
+#if defined(SQLITE_HAVE_OS_TRACE) || defined(SQLITE_TEST) || \
+    (defined(SQLITE_DEBUG) && SQLITE_OS_WIN)
+# define SQLITE_NEED_ERR_NAME
+#else
+# undef  SQLITE_NEED_ERR_NAME
+#endif
+
 /*
 ** Return true (non-zero) if the input is an integer that is too large
 ** to fit in 32-bits.  This macro is used inside of various testcase()
@@ -8850,6 +9030,20 @@ typedef INT8_TYPE i8;              /* 1-byte signed integer */
 */
 typedef INT16_TYPE LogEst;
 
+/*
+** Set the SQLITE_PTRSIZE macro to the number of bytes in a pointer
+*/
+#ifndef SQLITE_PTRSIZE
+# if defined(__SIZEOF_POINTER__)
+#   define SQLITE_PTRSIZE __SIZEOF_POINTER__
+# elif defined(i386)     || defined(__i386__)   || defined(_M_IX86) ||    \
+       defined(_M_ARM)   || defined(__arm__)    || defined(__x86)
+#   define SQLITE_PTRSIZE 4
+# else
+#   define SQLITE_PTRSIZE 8
+# endif
+#endif
+
 /*
 ** Macros to determine whether the machine is big or little endian,
 ** and whether or not that determination is run-time or compile-time.
@@ -9062,8 +9256,8 @@ struct BusyHandler {
   #define SQLITE_WSD const
   #define GLOBAL(t,v) (*(t*)sqlite3_wsd_find((void*)&(v), sizeof(v)))
   #define sqlite3GlobalConfig GLOBAL(struct Sqlite3Config, sqlite3Config)
-SQLITE_API   int sqlite3_wsd_init(int N, int J);
-SQLITE_API   void *sqlite3_wsd_find(void *K, int L);
+SQLITE_API int SQLITE_STDCALL sqlite3_wsd_init(int N, int J);
+SQLITE_API void *SQLITE_STDCALL sqlite3_wsd_find(void *K, int L);
 #else
   #define SQLITE_WSD 
   #define GLOBAL(t,v) v
@@ -9221,10 +9415,8 @@ SQLITE_PRIVATE int sqlite3BtreeGetPageSize(Btree*);
 SQLITE_PRIVATE int sqlite3BtreeMaxPageCount(Btree*,int);
 SQLITE_PRIVATE u32 sqlite3BtreeLastPage(Btree*);
 SQLITE_PRIVATE int sqlite3BtreeSecureDelete(Btree*,int);
-SQLITE_PRIVATE int sqlite3BtreeGetReserve(Btree*);
-#if defined(SQLITE_HAS_CODEC) || defined(SQLITE_DEBUG)
+SQLITE_PRIVATE int sqlite3BtreeGetOptimalReserve(Btree*);
 SQLITE_PRIVATE int sqlite3BtreeGetReserveNoMutex(Btree *p);
-#endif
 SQLITE_PRIVATE int sqlite3BtreeSetAutoVacuum(Btree *, int);
 SQLITE_PRIVATE int sqlite3BtreeGetAutoVacuum(Btree *);
 SQLITE_PRIVATE int sqlite3BtreeBeginTrans(Btree*,int);
@@ -9302,8 +9494,18 @@ SQLITE_PRIVATE int sqlite3BtreeNewDb(Btree *p);
 /*
 ** Values that may be OR'd together to form the second argument of an
 ** sqlite3BtreeCursorHints() call.
+**
+** The BTREE_BULKLOAD flag is set on index cursors when the index is going
+** to be filled with content that is already in sorted order.
+**
+** The BTREE_SEEK_EQ flag is set on cursors that will get OP_SeekGE or
+** OP_SeekLE opcodes for a range search, but where the range of entries
+** selected will all have the same key.  In other words, the cursor will
+** be used only for equality key searches.
+**
 */
-#define BTREE_BULKLOAD 0x00000001
+#define BTREE_BULKLOAD 0x00000001  /* Used to full index in sorted order */
+#define BTREE_SEEK_EQ  0x00000002  /* EQ seeks only - no range seeks */
 
 SQLITE_PRIVATE int sqlite3BtreeCursor(
   Btree*,                              /* BTree containing table to open */
@@ -9349,6 +9551,9 @@ SQLITE_PRIVATE void sqlite3BtreeIncrblobCursor(BtCursor *);
 SQLITE_PRIVATE void sqlite3BtreeClearCursor(BtCursor *);
 SQLITE_PRIVATE int sqlite3BtreeSetVersion(Btree *pBt, int iVersion);
 SQLITE_PRIVATE void sqlite3BtreeCursorHints(BtCursor *, unsigned int mask);
+#ifdef SQLITE_DEBUG
+SQLITE_PRIVATE int sqlite3BtreeCursorHasHint(BtCursor*, unsigned int mask);
+#endif
 SQLITE_PRIVATE int sqlite3BtreeIsReadonly(Btree *pBt);
 SQLITE_PRIVATE int sqlite3HeaderSizeBtree(void);
 
@@ -9715,23 +9920,25 @@ typedef struct VdbeOpList VdbeOpList;
 #define OP_MemMax        136 /* synopsis: r[P1]=max(r[P1],r[P2])           */
 #define OP_IfPos         137 /* synopsis: if r[P1]>0 goto P2               */
 #define OP_IfNeg         138 /* synopsis: r[P1]+=P3, if r[P1]<0 goto P2    */
-#define OP_IfZero        139 /* synopsis: r[P1]+=P3, if r[P1]==0 goto P2   */
-#define OP_AggFinal      140 /* synopsis: accum=r[P1] N=P2                 */
-#define OP_IncrVacuum    141
-#define OP_Expire        142
-#define OP_TableLock     143 /* synopsis: iDb=P1 root=P2 write=P3          */
-#define OP_VBegin        144
-#define OP_VCreate       145
-#define OP_VDestroy      146
-#define OP_VOpen         147
-#define OP_VColumn       148 /* synopsis: r[P3]=vcolumn(P2)                */
-#define OP_VNext         149
-#define OP_VRename       150
-#define OP_Pagecount     151
-#define OP_MaxPgcnt      152
-#define OP_Init          153 /* synopsis: Start at P2                      */
-#define OP_Noop          154
-#define OP_Explain       155
+#define OP_IfNotZero     139 /* synopsis: if r[P1]!=0 then r[P1]+=P3, goto P2 */
+#define OP_DecrJumpZero  140 /* synopsis: if (--r[P1])==0 goto P2          */
+#define OP_JumpZeroIncr  141 /* synopsis: if (r[P1]++)==0 ) goto P2        */
+#define OP_AggFinal      142 /* synopsis: accum=r[P1] N=P2                 */
+#define OP_IncrVacuum    143
+#define OP_Expire        144
+#define OP_TableLock     145 /* synopsis: iDb=P1 root=P2 write=P3          */
+#define OP_VBegin        146
+#define OP_VCreate       147
+#define OP_VDestroy      148
+#define OP_VOpen         149
+#define OP_VColumn       150 /* synopsis: r[P3]=vcolumn(P2)                */
+#define OP_VNext         151
+#define OP_VRename       152
+#define OP_Pagecount     153
+#define OP_MaxPgcnt      154
+#define OP_Init          155 /* synopsis: Start at P2                      */
+#define OP_Noop          156
+#define OP_Explain       157
 
 
 /* Properties such as "out2" or "jump" that are specified in
@@ -9739,33 +9946,32 @@ typedef struct VdbeOpList VdbeOpList;
 ** are encoded into bitvectors as follows:
 */
 #define OPFLG_JUMP            0x0001  /* jump:  P2 holds jmp target */
-#define OPFLG_OUT2_PRERELEASE 0x0002  /* out2-prerelease: */
-#define OPFLG_IN1             0x0004  /* in1:   P1 is an input */
-#define OPFLG_IN2             0x0008  /* in2:   P2 is an input */
-#define OPFLG_IN3             0x0010  /* in3:   P3 is an input */
-#define OPFLG_OUT2            0x0020  /* out2:  P2 is an output */
-#define OPFLG_OUT3            0x0040  /* out3:  P3 is an output */
+#define OPFLG_IN1             0x0002  /* in1:   P1 is an input */
+#define OPFLG_IN2             0x0004  /* in2:   P2 is an input */
+#define OPFLG_IN3             0x0008  /* in3:   P3 is an input */
+#define OPFLG_OUT2            0x0010  /* out2:  P2 is an output */
+#define OPFLG_OUT3            0x0020  /* out3:  P3 is an output */
 #define OPFLG_INITIALIZER {\
 /*   0 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01,\
-/*   8 */ 0x01, 0x01, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00,\
-/*  16 */ 0x01, 0x01, 0x04, 0x24, 0x01, 0x04, 0x05, 0x10,\
-/*  24 */ 0x00, 0x02, 0x02, 0x02, 0x02, 0x00, 0x02, 0x02,\
-/*  32 */ 0x00, 0x00, 0x20, 0x00, 0x00, 0x04, 0x05, 0x04,\
-/*  40 */ 0x04, 0x00, 0x00, 0x01, 0x01, 0x05, 0x05, 0x00,\
-/*  48 */ 0x00, 0x00, 0x02, 0x02, 0x10, 0x00, 0x00, 0x00,\
-/*  56 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11,\
-/*  64 */ 0x11, 0x11, 0x08, 0x11, 0x11, 0x11, 0x11, 0x4c,\
-/*  72 */ 0x4c, 0x02, 0x02, 0x00, 0x05, 0x05, 0x15, 0x15,\
-/*  80 */ 0x15, 0x15, 0x15, 0x15, 0x00, 0x4c, 0x4c, 0x4c,\
-/*  88 */ 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x00,\
-/*  96 */ 0x24, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\
-/* 104 */ 0x00, 0x01, 0x01, 0x01, 0x01, 0x08, 0x08, 0x00,\
-/* 112 */ 0x02, 0x01, 0x01, 0x01, 0x01, 0x02, 0x00, 0x00,\
-/* 120 */ 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
-/* 128 */ 0x0c, 0x45, 0x15, 0x01, 0x02, 0x02, 0x00, 0x01,\
-/* 136 */ 0x08, 0x05, 0x05, 0x05, 0x00, 0x01, 0x00, 0x00,\
-/* 144 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02,\
-/* 152 */ 0x02, 0x01, 0x00, 0x00,}
+/*   8 */ 0x01, 0x01, 0x00, 0x00, 0x10, 0x00, 0x01, 0x00,\
+/*  16 */ 0x01, 0x01, 0x02, 0x12, 0x01, 0x02, 0x03, 0x08,\
+/*  24 */ 0x00, 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x10,\
+/*  32 */ 0x00, 0x00, 0x10, 0x00, 0x00, 0x02, 0x03, 0x02,\
+/*  40 */ 0x02, 0x00, 0x00, 0x01, 0x01, 0x03, 0x03, 0x00,\
+/*  48 */ 0x00, 0x00, 0x10, 0x10, 0x08, 0x00, 0x00, 0x00,\
+/*  56 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x09,\
+/*  64 */ 0x09, 0x09, 0x04, 0x09, 0x09, 0x09, 0x09, 0x26,\
+/*  72 */ 0x26, 0x10, 0x10, 0x00, 0x03, 0x03, 0x0b, 0x0b,\
+/*  80 */ 0x0b, 0x0b, 0x0b, 0x0b, 0x00, 0x26, 0x26, 0x26,\
+/*  88 */ 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x00,\
+/*  96 */ 0x12, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\
+/* 104 */ 0x00, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x00,\
+/* 112 */ 0x10, 0x01, 0x01, 0x01, 0x01, 0x10, 0x00, 0x00,\
+/* 120 */ 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
+/* 128 */ 0x06, 0x23, 0x0b, 0x01, 0x10, 0x10, 0x00, 0x01,\
+/* 136 */ 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x01,\
+/* 144 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\
+/* 152 */ 0x00, 0x10, 0x10, 0x01, 0x00, 0x00,}
 
 /************** End of opcodes.h *********************************************/
 /************** Continuing where we left off in vdbe.h ***********************/
@@ -9824,6 +10030,7 @@ SQLITE_PRIVATE int sqlite3MemCompare(const Mem*, const Mem*, const CollSeq*);
 
 SQLITE_PRIVATE void sqlite3VdbeRecordUnpack(KeyInfo*,int,const void*,UnpackedRecord*);
 SQLITE_PRIVATE int sqlite3VdbeRecordCompare(int,const void*,UnpackedRecord*);
+SQLITE_PRIVATE int sqlite3VdbeRecordCompareWithSkip(int, const void *, UnpackedRecord *, int);
 SQLITE_PRIVATE UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(KeyInfo *, char *, int, char **);
 
 typedef int (*RecordCompare)(int,const void*,UnpackedRecord*);
@@ -10841,11 +11048,13 @@ struct sqlite3 {
     u8 iDb;                     /* Which db file is being initialized */
     u8 busy;                    /* TRUE if currently initializing */
     u8 orphanTrigger;           /* Last statement is orphaned TEMP trigger */
+    u8 imposterTable;           /* Building an imposter table */
   } init;
   int nVdbeActive;              /* Number of VDBEs currently running */
   int nVdbeRead;                /* Number of active VDBEs that read or write */
   int nVdbeWrite;               /* Number of active VDBEs that read and write */
   int nVdbeExec;                /* Number of nested calls to VdbeExec() */
+  int nVDestroy;                /* Number of active OP_VDestroy operations */
   int nExtension;               /* Number of loaded extensions */
   void **aExtension;            /* Array of shared library handles */
   void (*xTrace)(void*,const char*);        /* Trace function */
@@ -10959,6 +11168,7 @@ struct sqlite3 {
 #define SQLITE_DeferFKs       0x01000000  /* Defer all FK constraints */
 #define SQLITE_QueryOnly      0x02000000  /* Disable database changes */
 #define SQLITE_VdbeEQP        0x04000000  /* Debug EXPLAIN QUERY PLAN */
+#define SQLITE_Vacuum         0x08000000  /* Currently in a VACUUM */
 
 
 /*
@@ -11289,34 +11499,8 @@ struct VTable {
 };
 
 /*
-** Each SQL table is represented in memory by an instance of the
-** following structure.
-**
-** Table.zName is the name of the table.  The case of the original
-** CREATE TABLE statement is stored, but case is not significant for
-** comparisons.
-**
-** Table.nCol is the number of columns in this table.  Table.aCol is a
-** pointer to an array of Column structures, one for each column.
-**
-** If the table has an INTEGER PRIMARY KEY, then Table.iPKey is the index of
-** the column that is that key.   Otherwise Table.iPKey is negative.  Note
-** that the datatype of the PRIMARY KEY must be INTEGER for this field to
-** be set.  An INTEGER PRIMARY KEY is used as the rowid for each row of
-** the table.  If a table has no INTEGER PRIMARY KEY, then a random rowid
-** is generated for each row of the table.  TF_HasPrimaryKey is set if
-** the table has any PRIMARY KEY, INTEGER or otherwise.
-**
-** Table.tnum is the page number for the root BTree page of the table in the
-** database file.  If Table.iDb is the index of the database table backend
-** in sqlite.aDb[].  0 is for the main database and 1 is for the file that
-** holds temporary tables and indices.  If TF_Ephemeral is set
-** then the table is stored in a file that is automatically deleted
-** when the VDBE cursor to the table is closed.  In this case Table.tnum 
-** refers VDBE cursor number that holds the table open, not to the root
-** page number.  Transient tables are used to hold the results of a
-** sub-query that appears instead of a real table name in the FROM clause 
-** of a SELECT statement.
+** The schema for each SQL table and view is represented in memory
+** by an instance of the following structure.
 */
 struct Table {
   char *zName;         /* Name of the table or view */
@@ -11328,11 +11512,11 @@ struct Table {
 #ifndef SQLITE_OMIT_CHECK
   ExprList *pCheck;    /* All CHECK constraints */
 #endif
-  LogEst nRowLogEst;   /* Estimated rows in table - from sqlite_stat1 table */
-  int tnum;            /* Root BTree node for this table (see note above) */
-  i16 iPKey;           /* If not negative, use aCol[iPKey] as the primary key */
+  int tnum;            /* Root BTree page for this table */
+  i16 iPKey;           /* If not negative, use aCol[iPKey] as the rowid */
   i16 nCol;            /* Number of columns in this table */
   u16 nRef;            /* Number of pointers to this Table */
+  LogEst nRowLogEst;   /* Estimated rows in table - from sqlite_stat1 table */
   LogEst szTabRow;     /* Estimated size of each table row in bytes */
 #ifdef SQLITE_ENABLE_COSTMULT
   LogEst costMult;     /* Cost multiplier for using this table */
@@ -11354,6 +11538,12 @@ struct Table {
 
 /*
 ** Allowed values for Table.tabFlags.
+**
+** TF_OOOHidden applies to virtual tables that have hidden columns that are
+** followed by non-hidden columns.  Example:  "CREATE VIRTUAL TABLE x USING
+** vtab1(a HIDDEN, b);".  Since "b" is a non-hidden column but "a" is hidden,
+** the TF_OOOHidden attribute would apply in this case.  Such tables require
+** special handling during INSERT processing.
 */
 #define TF_Readonly        0x01    /* Read-only system table */
 #define TF_Ephemeral       0x02    /* An ephemeral table */
@@ -11361,6 +11551,7 @@ struct Table {
 #define TF_Autoincrement   0x08    /* Integer primary key is autoincrement */
 #define TF_Virtual         0x10    /* Is a virtual table */
 #define TF_WithoutRowid    0x20    /* No rowid used. PRIMARY KEY is the key */
+#define TF_OOOHidden       0x40    /* Out-of-Order hidden columns */
 
 
 /*
@@ -11797,8 +11988,14 @@ struct Expr {
 #define EP_MemToken  0x010000 /* Need to sqlite3DbFree() Expr.zToken */
 #define EP_NoReduce  0x020000 /* Cannot EXPRDUP_REDUCE this Expr */
 #define EP_Unlikely  0x040000 /* unlikely() or likelihood() function */
-#define EP_Constant  0x080000 /* Node is a constant */
+#define EP_ConstFunc 0x080000 /* Node is a SQLITE_FUNC_CONSTANT function */
 #define EP_CanBeNull 0x100000 /* Can be null despite NOT NULL constraint */
+#define EP_Subquery  0x200000 /* Tree contains a TK_SELECT operator */
+
+/*
+** Combinations of two or more EP_* flags
+*/
+#define EP_Propagate (EP_Collate|EP_Subquery) /* Propagate these bits up tree */
 
 /*
 ** These macros can be used to test, set, or clear bits in the 
@@ -11997,7 +12194,7 @@ struct SrcList {
 #define WHERE_OMIT_OPEN_CLOSE  0x0010 /* Table cursors are already open */
 #define WHERE_FORCE_TABLE      0x0020 /* Do not use an index-only search */
 #define WHERE_ONETABLE_ONLY    0x0040 /* Only code the 1st table in pTabList */
-                          /*   0x0080 // not currently used */
+#define WHERE_NO_AUTOINDEX     0x0080 /* Disallow automatic indexes */
 #define WHERE_GROUPBY          0x0100 /* pOrderBy is really a GROUP BY */
 #define WHERE_DISTINCTBY       0x0200 /* pOrderby is really a DISTINCT clause */
 #define WHERE_WANT_DISTINCT    0x0400 /* All output needs to be distinct */
@@ -12111,11 +12308,12 @@ struct Select {
 #define SF_HasTypeInfo     0x0020  /* FROM subqueries have Table metadata */
 #define SF_Compound        0x0040  /* Part of a compound query */
 #define SF_Values          0x0080  /* Synthesized from VALUES clause */
-#define SF_AllValues       0x0100  /* All terms of compound are VALUES */
+#define SF_MultiValue      0x0100  /* Single VALUES term with multiple rows */
 #define SF_NestedFrom      0x0200  /* Part of a parenthesized FROM clause */
 #define SF_MaybeConvert    0x0400  /* Need convertCompoundSelectToSubquery() */
 #define SF_Recursive       0x0800  /* The recursive part of a recursive CTE */
 #define SF_MinMaxAgg       0x1000  /* Aggregate containing min() or max() */
+#define SF_Converted       0x2000  /* By convertCompoundSelectToSubquery() */
 
 
 /*
@@ -12434,7 +12632,8 @@ struct AuthContext {
 #define OPFLAG_LENGTHARG     0x40    /* OP_Column only used for length() */
 #define OPFLAG_TYPEOFARG     0x80    /* OP_Column only used for typeof() */
 #define OPFLAG_BULKCSR       0x01    /* OP_Open** used to open bulk cursor */
-#define OPFLAG_P2ISREG       0x02    /* P2 to OP_Open** is a register number */
+#define OPFLAG_SEEKEQ        0x02    /* OP_Open** cursor uses EQ seek only */
+#define OPFLAG_P2ISREG       0x04    /* P2 to OP_Open** is a register number */
 #define OPFLAG_PERMUTE       0x01    /* OP_Compare: use the permutation */
 
 /*
@@ -12493,7 +12692,7 @@ struct Trigger {
  * orconf    -> stores the ON CONFLICT algorithm
  * pSelect   -> If this is an INSERT INTO ... SELECT ... statement, then
  *              this stores a pointer to the SELECT statement. Otherwise NULL.
- * target    -> A token holding the quoted name of the table to insert into.
+ * zTarget   -> Dequoted name of the table to insert into.
  * pExprList -> If this is an INSERT INTO ... VALUES ... statement, then
  *              this stores values to be inserted. Otherwise NULL.
  * pIdList   -> If this is an INSERT INTO ... (<column-names>) VALUES ... 
@@ -12501,12 +12700,12 @@ struct Trigger {
  *              inserted into.
  *
  * (op == TK_DELETE)
- * target    -> A token holding the quoted name of the table to delete from.
+ * zTarget   -> Dequoted name of the table to delete from.
  * pWhere    -> The WHERE clause of the DELETE statement if one is specified.
  *              Otherwise NULL.
  * 
  * (op == TK_UPDATE)
- * target    -> A token holding the quoted name of the table to update rows of.
+ * zTarget   -> Dequoted name of the table to update.
  * pWhere    -> The WHERE clause of the UPDATE statement if one is specified.
  *              Otherwise NULL.
  * pExprList -> A list of the columns to update and the expressions to update
@@ -12518,8 +12717,8 @@ struct TriggerStep {
   u8 op;               /* One of TK_DELETE, TK_UPDATE, TK_INSERT, TK_SELECT */
   u8 orconf;           /* OE_Rollback etc. */
   Trigger *pTrig;      /* The trigger that this step is a part of */
-  Select *pSelect;     /* SELECT statment or RHS of INSERT INTO .. SELECT ... */
-  Token target;        /* Target table for DELETE, UPDATE, INSERT */
+  Select *pSelect;     /* SELECT statement or RHS of INSERT INTO SELECT ... */
+  char *zTarget;       /* Target table for DELETE, UPDATE, INSERT */
   Expr *pWhere;        /* The WHERE clause for DELETE or UPDATE steps */
   ExprList *pExprList; /* SET clause for UPDATE. */
   IdList *pIdList;     /* Column names for INSERT */
@@ -12552,8 +12751,7 @@ struct StrAccum {
   char *zText;         /* The string collected so far */
   int  nChar;          /* Length of the string so far */
   int  nAlloc;         /* Amount of space allocated in zText */
-  int  mxAlloc;        /* Maximum allowed string length */
-  u8   useMalloc;      /* 0: none,  1: sqlite3DbMalloc,  2: sqlite3_malloc */
+  int  mxAlloc;        /* Maximum allowed allocation.  0 for no malloc usage */
   u8   accError;       /* STRACCUM_NOMEM or STRACCUM_TOOBIG */
 };
 #define STRACCUM_NOMEM   1
@@ -12838,10 +13036,15 @@ SQLITE_PRIVATE   int sqlite3MutexInit(void);
 SQLITE_PRIVATE   int sqlite3MutexEnd(void);
 #endif
 
-SQLITE_PRIVATE int sqlite3StatusValue(int);
-SQLITE_PRIVATE void sqlite3StatusAdd(int, int);
+SQLITE_PRIVATE sqlite3_int64 sqlite3StatusValue(int);
+SQLITE_PRIVATE void sqlite3StatusUp(int, int);
+SQLITE_PRIVATE void sqlite3StatusDown(int, int);
 SQLITE_PRIVATE void sqlite3StatusSet(int, int);
 
+/* Access to mutexes used by sqlite3_status() */
+SQLITE_PRIVATE sqlite3_mutex *sqlite3Pcache1Mutex(void);
+SQLITE_PRIVATE sqlite3_mutex *sqlite3MallocMutex(void);
+
 #ifndef SQLITE_OMIT_FLOATING_POINT
 SQLITE_PRIVATE   int sqlite3IsNaN(double);
 #else
@@ -12865,7 +13068,7 @@ SQLITE_PRIVATE void sqlite3XPrintf(StrAccum*, u32, const char*, ...);
 SQLITE_PRIVATE char *sqlite3MPrintf(sqlite3*,const char*, ...);
 SQLITE_PRIVATE char *sqlite3VMPrintf(sqlite3*,const char*, va_list);
 SQLITE_PRIVATE char *sqlite3MAppendf(sqlite3*,char*,const char*,...);
-#if defined(SQLITE_TEST) || defined(SQLITE_DEBUG)
+#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)
 SQLITE_PRIVATE   void sqlite3DebugPrintf(const char*, ...);
 #endif
 #if defined(SQLITE_TEST)
@@ -12906,6 +13109,7 @@ SQLITE_PRIVATE ExprList *sqlite3ExprListAppend(Parse*,ExprList*,Expr*);
 SQLITE_PRIVATE void sqlite3ExprListSetName(Parse*,ExprList*,Token*,int);
 SQLITE_PRIVATE void sqlite3ExprListSetSpan(Parse*,ExprList*,ExprSpan*);
 SQLITE_PRIVATE void sqlite3ExprListDelete(sqlite3*, ExprList*);
+SQLITE_PRIVATE u32 sqlite3ExprListFlags(const ExprList*);
 SQLITE_PRIVATE int sqlite3Init(sqlite3*, char**);
 SQLITE_PRIVATE int sqlite3InitCallback(void*, int, char**, char**);
 SQLITE_PRIVATE void sqlite3Pragma(Parse*,Token*,Token*,Token*,int);
@@ -13211,7 +13415,7 @@ SQLITE_PRIVATE void *sqlite3HexToBlob(sqlite3*, const char *z, int n);
 SQLITE_PRIVATE u8 sqlite3HexToInt(int h);
 SQLITE_PRIVATE int sqlite3TwoPartName(Parse *, Token *, Token *, Token **);
 
-#if defined(SQLITE_TEST) 
+#if defined(SQLITE_NEED_ERR_NAME)
 SQLITE_PRIVATE const char *sqlite3ErrName(int);
 #endif
 
@@ -13220,7 +13424,7 @@ SQLITE_PRIVATE int sqlite3ReadSchema(Parse *pParse);
 SQLITE_PRIVATE CollSeq *sqlite3FindCollSeq(sqlite3*,u8 enc, const char*,int);
 SQLITE_PRIVATE CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char*zName);
 SQLITE_PRIVATE CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr);
-SQLITE_PRIVATE Expr *sqlite3ExprAddCollateToken(Parse *pParse, Expr*, const Token*);
+SQLITE_PRIVATE Expr *sqlite3ExprAddCollateToken(Parse *pParse, Expr*, const Token*, int);
 SQLITE_PRIVATE Expr *sqlite3ExprAddCollateString(Parse*,Expr*,const char*);
 SQLITE_PRIVATE Expr *sqlite3ExprSkipCollate(Expr*);
 SQLITE_PRIVATE int sqlite3CheckCollSeq(Parse *, CollSeq *);
@@ -13305,7 +13509,7 @@ SQLITE_PRIVATE int sqlite3CreateFunc(sqlite3 *, const char *, int, int, void *,
 SQLITE_PRIVATE int sqlite3ApiExit(sqlite3 *db, int);
 SQLITE_PRIVATE int sqlite3OpenTempDatabase(Parse *);
 
-SQLITE_PRIVATE void sqlite3StrAccumInit(StrAccum*, char*, int, int);
+SQLITE_PRIVATE void sqlite3StrAccumInit(StrAccum*, sqlite3*, char*, int, int);
 SQLITE_PRIVATE void sqlite3StrAccumAppend(StrAccum*,const char*,int);
 SQLITE_PRIVATE void sqlite3StrAccumAppendAll(StrAccum*,const char*);
 SQLITE_PRIVATE void sqlite3AppendChar(StrAccum*,int,char);
@@ -13489,12 +13693,11 @@ SQLITE_PRIVATE void sqlite3MemJournalOpen(sqlite3_file *);
 SQLITE_PRIVATE int sqlite3MemJournalSize(void);
 SQLITE_PRIVATE int sqlite3IsMemJournal(sqlite3_file *);
 
+SQLITE_PRIVATE void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p);
 #if SQLITE_MAX_EXPR_DEPTH>0
-SQLITE_PRIVATE   void sqlite3ExprSetHeight(Parse *pParse, Expr *p);
 SQLITE_PRIVATE   int sqlite3SelectExprHeight(Select *);
 SQLITE_PRIVATE   int sqlite3ExprCheckHeight(Parse*, int);
 #else
-  #define sqlite3ExprSetHeight(x,y)
   #define sqlite3SelectExprHeight(x) 0
   #define sqlite3ExprCheckHeight(x,y)
 #endif
@@ -13524,7 +13727,7 @@ SQLITE_PRIVATE   void sqlite3ParserTrace(FILE*, char *);
 #ifdef SQLITE_ENABLE_IOTRACE
 # define IOTRACE(A)  if( sqlite3IoTrace ){ sqlite3IoTrace A; }
 SQLITE_PRIVATE   void sqlite3VdbeIOTraceSql(Vdbe*);
-void (*sqlite3IoTrace)(const char*,...);
+SQLITE_API SQLITE_EXTERN void (SQLITE_CDECL *sqlite3IoTrace)(const char*,...);
 #else
 # define IOTRACE(A)
 # define sqlite3VdbeIOTraceSql(X)
@@ -13631,16 +13834,16 @@ SQLITE_PRIVATE const unsigned char sqlite3UpperToLower[] = {
      48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, /* 3x */
      64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, /* 4x */
      80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, /* 5x */
-     96, 97, 66, 67, 68, 69, 70, 71, 72, 73,106,107,108,109,110,111, /* 6x */
-    112, 81, 82, 83, 84, 85, 86, 87, 88, 89,122,123,124,125,126,127, /* 7x */
+     96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111, /* 6x */
+    112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127, /* 7x */
     128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143, /* 8x */
-    144,145,146,147,148,149,150,151,152,153,154,155,156,157,156,159, /* 9x */
+    144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159, /* 9x */
     160,161,162,163,164,165,166,167,168,169,170,171,140,141,142,175, /* Ax */
     176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191, /* Bx */
     192,129,130,131,132,133,134,135,136,137,202,203,204,205,206,207, /* Cx */
     208,145,146,147,148,149,150,151,152,153,218,219,220,221,222,223, /* Dx */
-    224,225,162,163,164,165,166,167,168,169,232,203,204,205,206,207, /* Ex */
-    239,240,241,242,243,244,245,246,247,248,249,219,220,221,222,255, /* Fx */
+    224,225,162,163,164,165,166,167,168,169,234,235,236,237,238,239, /* Ex */
+    240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255, /* Fx */
 #endif
 };
 
@@ -14237,7 +14440,7 @@ static const char * const azCompileOpt[] = {
 ** The name can optionally begin with "SQLITE_" but the "SQLITE_" prefix
 ** is not required for a match.
 */
-SQLITE_API int sqlite3_compileoption_used(const char *zOptName){
+SQLITE_API int SQLITE_STDCALL sqlite3_compileoption_used(const char *zOptName){
   int i, n;
 
 #if SQLITE_ENABLE_API_ARMOR
@@ -14265,7 +14468,7 @@ SQLITE_API int sqlite3_compileoption_used(const char *zOptName){
 ** Return the N-th compile-time option string.  If N is out of range,
 ** return a NULL pointer.
 */
-SQLITE_API const char *sqlite3_compileoption_get(int N){
+SQLITE_API const char *SQLITE_STDCALL sqlite3_compileoption_get(int N){
   if( N>=0 && N<ArraySize(azCompileOpt) ){
     return azCompileOpt[N];
   }
@@ -14608,14 +14811,6 @@ struct ScanStatus {
 **
 ** The "sqlite3_stmt" structure pointer that is returned by sqlite3_prepare()
 ** is really a pointer to an instance of this structure.
-**
-** The Vdbe.inVtabMethod variable is set to non-zero for the duration of
-** any virtual table method invocations made by the vdbe program. It is
-** set to 2 for xDestroy method calls and 1 for all other methods. This
-** variable is used for two purposes: to allow xDestroy methods to execute
-** "DROP TABLE" statements and to prevent some nasty side effects of
-** malloc failure when SQLite is invoked recursively by a virtual table 
-** method function.
 */
 struct Vdbe {
   sqlite3 *db;            /* The database connection that owns this statement */
@@ -14639,11 +14834,13 @@ struct Vdbe {
   u32 cacheCtr;           /* VdbeCursor row cache generation counter */
   int pc;                 /* The program counter */
   int rc;                 /* Value to return */
+#ifdef SQLITE_DEBUG
+  int rcApp;              /* errcode set by sqlite3_result_error_code() */
+#endif
   u16 nResColumn;         /* Number of columns in one row of the result set */
   u8 errorAction;         /* Recovery action to do in case of an error */
   u8 minWriteFileFormat;  /* Minimum file format for writable database files */
   bft explain:2;          /* True if EXPLAIN present on SQL command */
-  bft inVtabMethod:2;     /* See comments above */
   bft changeCntOn:1;      /* True to update the change-counter */
   bft expired:1;          /* True if the VM needs to be recompiled */
   bft runOnlyOnce:1;      /* Automatically expire on reset */
@@ -14803,10 +15000,32 @@ SQLITE_PRIVATE   int sqlite3VdbeMemExpandBlob(Mem *);
 */
 typedef struct sqlite3StatType sqlite3StatType;
 static SQLITE_WSD struct sqlite3StatType {
-  int nowValue[10];         /* Current value */
-  int mxValue[10];          /* Maximum value */
+#if SQLITE_PTRSIZE>4
+  sqlite3_int64 nowValue[10];         /* Current value */
+  sqlite3_int64 mxValue[10];          /* Maximum value */
+#else
+  u32 nowValue[10];                   /* Current value */
+  u32 mxValue[10];                    /* Maximum value */
+#endif
 } sqlite3Stat = { {0,}, {0,} };
 
+/*
+** Elements of sqlite3Stat[] are protected by either the memory allocator
+** mutex, or by the pcache1 mutex.  The following array determines which.
+*/
+static const char statMutex[] = {
+  0,  /* SQLITE_STATUS_MEMORY_USED */
+  1,  /* SQLITE_STATUS_PAGECACHE_USED */
+  1,  /* SQLITE_STATUS_PAGECACHE_OVERFLOW */
+  0,  /* SQLITE_STATUS_SCRATCH_USED */
+  0,  /* SQLITE_STATUS_SCRATCH_OVERFLOW */
+  0,  /* SQLITE_STATUS_MALLOC_SIZE */
+  0,  /* SQLITE_STATUS_PARSER_STACK */
+  1,  /* SQLITE_STATUS_PAGECACHE_SIZE */
+  0,  /* SQLITE_STATUS_SCRATCH_SIZE */
+  0,  /* SQLITE_STATUS_MALLOC_COUNT */
+};
+
 
 /* The "wsdStat" macro will resolve to the status information
 ** state vector.  If writable static data is unsupported on the target,
@@ -14823,33 +15042,60 @@ static SQLITE_WSD struct sqlite3StatType {
 #endif
 
 /*
-** Return the current value of a status parameter.
+** Return the current value of a status parameter.  The caller must
+** be holding the appropriate mutex.
 */
-SQLITE_PRIVATE int sqlite3StatusValue(int op){
+SQLITE_PRIVATE sqlite3_int64 sqlite3StatusValue(int op){
   wsdStatInit;
   assert( op>=0 && op<ArraySize(wsdStat.nowValue) );
+  assert( op>=0 && op<ArraySize(statMutex) );
+  assert( sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()
+                                           : sqlite3MallocMutex()) );
   return wsdStat.nowValue[op];
 }
 
 /*
-** Add N to the value of a status record.  It is assumed that the
-** caller holds appropriate locks.
+** Add N to the value of a status record.  The caller must hold the
+** appropriate mutex.  (Locking is checked by assert()).
+**
+** The StatusUp() routine can accept positive or negative values for N.
+** The value of N is added to the current status value and the high-water
+** mark is adjusted if necessary.
+**
+** The StatusDown() routine lowers the current value by N.  The highwater
+** mark is unchanged.  N must be non-negative for StatusDown().
 */
-SQLITE_PRIVATE void sqlite3StatusAdd(int op, int N){
+SQLITE_PRIVATE void sqlite3StatusUp(int op, int N){
   wsdStatInit;
   assert( op>=0 && op<ArraySize(wsdStat.nowValue) );
+  assert( op>=0 && op<ArraySize(statMutex) );
+  assert( sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()
+                                           : sqlite3MallocMutex()) );
   wsdStat.nowValue[op] += N;
   if( wsdStat.nowValue[op]>wsdStat.mxValue[op] ){
     wsdStat.mxValue[op] = wsdStat.nowValue[op];
   }
 }
+SQLITE_PRIVATE void sqlite3StatusDown(int op, int N){
+  wsdStatInit;
+  assert( N>=0 );
+  assert( op>=0 && op<ArraySize(statMutex) );
+  assert( sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()
+                                           : sqlite3MallocMutex()) );
+  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );
+  wsdStat.nowValue[op] -= N;
+}
 
 /*
-** Set the value of a status to X.
+** Set the value of a status to X.  The highwater mark is adjusted if
+** necessary.  The caller must hold the appropriate mutex.
 */
 SQLITE_PRIVATE void sqlite3StatusSet(int op, int X){
   wsdStatInit;
   assert( op>=0 && op<ArraySize(wsdStat.nowValue) );
+  assert( op>=0 && op<ArraySize(statMutex) );
+  assert( sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()
+                                           : sqlite3MallocMutex()) );
   wsdStat.nowValue[op] = X;
   if( wsdStat.nowValue[op]>wsdStat.mxValue[op] ){
     wsdStat.mxValue[op] = wsdStat.nowValue[op];
@@ -14858,12 +15104,14 @@ SQLITE_PRIVATE void sqlite3StatusSet(int op, int X){
 
 /*
 ** Query status information.
-**
-** This implementation assumes that reading or writing an aligned
-** 32-bit integer is an atomic operation.  If that assumption is not true,
-** then this routine is not threadsafe.
 */
-SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag){
+SQLITE_API int SQLITE_STDCALL sqlite3_status64(
+  int op,
+  sqlite3_int64 *pCurrent,
+  sqlite3_int64 *pHighwater,
+  int resetFlag
+){
+  sqlite3_mutex *pMutex;
   wsdStatInit;
   if( op<0 || op>=ArraySize(wsdStat.nowValue) ){
     return SQLITE_MISUSE_BKPT;
@@ -14871,18 +15119,35 @@ SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetF
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( pCurrent==0 || pHighwater==0 ) return SQLITE_MISUSE_BKPT;
 #endif
+  pMutex = statMutex[op] ? sqlite3Pcache1Mutex() : sqlite3MallocMutex();
+  sqlite3_mutex_enter(pMutex);
   *pCurrent = wsdStat.nowValue[op];
   *pHighwater = wsdStat.mxValue[op];
   if( resetFlag ){
     wsdStat.mxValue[op] = wsdStat.nowValue[op];
   }
+  sqlite3_mutex_leave(pMutex);
+  (void)pMutex;  /* Prevent warning when SQLITE_THREADSAFE=0 */
   return SQLITE_OK;
 }
+SQLITE_API int SQLITE_STDCALL sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag){
+  sqlite3_int64 iCur, iHwtr;
+  int rc;
+#ifdef SQLITE_ENABLE_API_ARMOR
+  if( pCurrent==0 || pHighwater==0 ) return SQLITE_MISUSE_BKPT;
+#endif
+  rc = sqlite3_status64(op, &iCur, &iHwtr, resetFlag);
+  if( rc==0 ){
+    *pCurrent = (int)iCur;
+    *pHighwater = (int)iHwtr;
+  }
+  return rc;
+}
 
 /*
 ** Query status information for a single database connection
 */
-SQLITE_API int sqlite3_db_status(
+SQLITE_API int SQLITE_STDCALL sqlite3_db_status(
   sqlite3 *db,          /* The database connection whose status is desired */
   int op,               /* Status verb */
   int *pCurrent,        /* Write current value here */
@@ -16506,7 +16771,7 @@ static sqlite3_vfs * SQLITE_WSD vfsList = 0;
 ** Locate a VFS by name.  If no name is given, simply return the
 ** first VFS on the list.
 */
-SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfs){
+SQLITE_API sqlite3_vfs *SQLITE_STDCALL sqlite3_vfs_find(const char *zVfs){
   sqlite3_vfs *pVfs = 0;
 #if SQLITE_THREADSAFE
   sqlite3_mutex *mutex;
@@ -16552,7 +16817,7 @@ static void vfsUnlink(sqlite3_vfs *pVfs){
 ** VFS multiple times.  The new VFS becomes the default if makeDflt is
 ** true.
 */
-SQLITE_API int sqlite3_vfs_register(sqlite3_vfs *pVfs, int makeDflt){
+SQLITE_API int SQLITE_STDCALL sqlite3_vfs_register(sqlite3_vfs *pVfs, int makeDflt){
   MUTEX_LOGIC(sqlite3_mutex *mutex;)
 #ifndef SQLITE_OMIT_AUTOINIT
   int rc = sqlite3_initialize();
@@ -16580,7 +16845,7 @@ SQLITE_API int sqlite3_vfs_register(sqlite3_vfs *pVfs, int makeDflt){
 /*
 ** Unregister a VFS so that it is no longer accessible.
 */
-SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs *pVfs){
+SQLITE_API int SQLITE_STDCALL sqlite3_vfs_unregister(sqlite3_vfs *pVfs){
 #if SQLITE_THREADSAFE
   sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);
 #endif
@@ -18916,7 +19181,7 @@ SQLITE_PRIVATE int sqlite3MutexEnd(void){
 /*
 ** Retrieve a pointer to a static mutex or allocate a new dynamic one.
 */
-SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int id){
+SQLITE_API sqlite3_mutex *SQLITE_STDCALL sqlite3_mutex_alloc(int id){
 #ifndef SQLITE_OMIT_AUTOINIT
   if( id<=SQLITE_MUTEX_RECURSIVE && sqlite3_initialize() ) return 0;
   if( id>SQLITE_MUTEX_RECURSIVE && sqlite3MutexInit() ) return 0;
@@ -18935,7 +19200,7 @@ SQLITE_PRIVATE sqlite3_mutex *sqlite3MutexAlloc(int id){
 /*
 ** Free a dynamic mutex.
 */
-SQLITE_API void sqlite3_mutex_free(sqlite3_mutex *p){
+SQLITE_API void SQLITE_STDCALL sqlite3_mutex_free(sqlite3_mutex *p){
   if( p ){
     sqlite3GlobalConfig.mutex.xMutexFree(p);
   }
@@ -18945,7 +19210,7 @@ SQLITE_API void sqlite3_mutex_free(sqlite3_mutex *p){
 ** Obtain the mutex p. If some other thread already has the mutex, block
 ** until it can be obtained.
 */
-SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex *p){
+SQLITE_API void SQLITE_STDCALL sqlite3_mutex_enter(sqlite3_mutex *p){
   if( p ){
     sqlite3GlobalConfig.mutex.xMutexEnter(p);
   }
@@ -18955,7 +19220,7 @@ SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex *p){
 ** Obtain the mutex p. If successful, return SQLITE_OK. Otherwise, if another
 ** thread holds the mutex and it cannot be obtained, return SQLITE_BUSY.
 */
-SQLITE_API int sqlite3_mutex_try(sqlite3_mutex *p){
+SQLITE_API int SQLITE_STDCALL sqlite3_mutex_try(sqlite3_mutex *p){
   int rc = SQLITE_OK;
   if( p ){
     return sqlite3GlobalConfig.mutex.xMutexTry(p);
@@ -18969,7 +19234,7 @@ SQLITE_API int sqlite3_mutex_try(sqlite3_mutex *p){
 ** is not currently entered. If a NULL pointer is passed as an argument
 ** this function is a no-op.
 */
-SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex *p){
+SQLITE_API void SQLITE_STDCALL sqlite3_mutex_leave(sqlite3_mutex *p){
   if( p ){
     sqlite3GlobalConfig.mutex.xMutexLeave(p);
   }
@@ -18980,10 +19245,10 @@ SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex *p){
 ** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine are
 ** intended for use inside assert() statements.
 */
-SQLITE_API int sqlite3_mutex_held(sqlite3_mutex *p){
+SQLITE_API int SQLITE_STDCALL sqlite3_mutex_held(sqlite3_mutex *p){
   return p==0 || sqlite3GlobalConfig.mutex.xMutexHeld(p);
 }
-SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex *p){
+SQLITE_API int SQLITE_STDCALL sqlite3_mutex_notheld(sqlite3_mutex *p){
   return p==0 || sqlite3GlobalConfig.mutex.xMutexNotheld(p);
 }
 #endif
@@ -19113,8 +19378,12 @@ static sqlite3_mutex *debugMutexAlloc(int id){
       break;
     }
     default: {
-      assert( id-2 >= 0 );
-      assert( id-2 < (int)(sizeof(aStatic)/sizeof(aStatic[0])) );
+#ifdef SQLITE_ENABLE_API_ARMOR
+      if( id-2<0 || id-2>=ArraySize(aStatic) ){
+        (void)SQLITE_MISUSE_BKPT;
+        return 0;
+      }
+#endif
       pNew = &aStatic[id-2];
       pNew->id = id;
       break;
@@ -19129,8 +19398,13 @@ static sqlite3_mutex *debugMutexAlloc(int id){
 static void debugMutexFree(sqlite3_mutex *pX){
   sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;
   assert( p->cnt==0 );
-  assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE );
-  sqlite3_free(p);
+  if( p->id==SQLITE_MUTEX_RECURSIVE || p->id==SQLITE_MUTEX_FAST ){
+    sqlite3_free(p);
+  }else{
+#ifdef SQLITE_ENABLE_API_ARMOR
+    (void)SQLITE_MISUSE_BKPT;
+#endif
+  }
 }
 
 /*
@@ -19241,8 +19515,10 @@ SQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void){
 */
 struct sqlite3_mutex {
   pthread_mutex_t mutex;     /* Mutex controlling the lock */
-#if SQLITE_MUTEX_NREF
+#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)
   int id;                    /* Mutex type */
+#endif
+#if SQLITE_MUTEX_NREF
   volatile int nRef;         /* Number of entrances */
   volatile pthread_t owner;  /* Thread that is within this mutex */
   int trace;                 /* True to trace changes */
@@ -19358,9 +19634,6 @@ static sqlite3_mutex *pthreadMutexAlloc(int iType){
         pthread_mutexattr_settype(&recursiveAttr, PTHREAD_MUTEX_RECURSIVE);
         pthread_mutex_init(&p->mutex, &recursiveAttr);
         pthread_mutexattr_destroy(&recursiveAttr);
-#endif
-#if SQLITE_MUTEX_NREF
-        p->id = iType;
 #endif
       }
       break;
@@ -19368,9 +19641,6 @@ static sqlite3_mutex *pthreadMutexAlloc(int iType){
     case SQLITE_MUTEX_FAST: {
       p = sqlite3MallocZero( sizeof(*p) );
       if( p ){
-#if SQLITE_MUTEX_NREF
-        p->id = iType;
-#endif
         pthread_mutex_init(&p->mutex, 0);
       }
       break;
@@ -19383,12 +19653,12 @@ static sqlite3_mutex *pthreadMutexAlloc(int iType){
       }
 #endif
       p = &staticMutexes[iType-2];
-#if SQLITE_MUTEX_NREF
-      p->id = iType;
-#endif
       break;
     }
   }
+#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)
+  if( p ) p->id = iType;
+#endif
   return p;
 }
 
@@ -19400,9 +19670,18 @@ static sqlite3_mutex *pthreadMutexAlloc(int iType){
 */
 static void pthreadMutexFree(sqlite3_mutex *p){
   assert( p->nRef==0 );
-  assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE );
-  pthread_mutex_destroy(&p->mutex);
-  sqlite3_free(p);
+#if SQLITE_ENABLE_API_ARMOR
+  if( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE )
+#endif
+  {
+    pthread_mutex_destroy(&p->mutex);
+    sqlite3_free(p);
+  }
+#ifdef SQLITE_ENABLE_API_ARMOR
+  else{
+    (void)SQLITE_MISUSE_BKPT;
+  }
+#endif
 }
 
 /*
@@ -19614,16 +19893,6 @@ SQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void){
 # error "The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead."
 #endif
 
-#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)
-# ifndef SQLITE_DEBUG_OS_TRACE
-#   define SQLITE_DEBUG_OS_TRACE 0
-# endif
-  int sqlite3OSTrace = SQLITE_DEBUG_OS_TRACE;
-# define OSTRACE(X)          if( sqlite3OSTrace ) sqlite3DebugPrintf X
-#else
-# define OSTRACE(X)
-#endif
-
 /*
 ** Macros for performance tracing.  Normally turned off.  Only works
 ** on i486 hardware.
@@ -19872,6 +20141,17 @@ SQLITE_API int sqlite3_open_file_count = 0;
 # define SQLITE_WIN32_VOLATILE volatile
 #endif
 
+/*
+** For some Windows sub-platforms, the _beginthreadex() / _endthreadex()
+** functions are not available (e.g. those not using MSVC, Cygwin, etc).
+*/
+#if SQLITE_OS_WIN && !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && \
+    SQLITE_THREADSAFE>0 && !defined(__CYGWIN__)
+# define SQLITE_OS_WIN_THREADS 1
+#else
+# define SQLITE_OS_WIN_THREADS 0
+#endif
+
 #endif /* _OS_WIN_H_ */
 
 /************** End of os_win.h **********************************************/
@@ -19954,8 +20234,8 @@ static int winMutex_isNt = -1; /* <0 means "need to query" */
 */
 static LONG SQLITE_WIN32_VOLATILE winMutex_lock = 0;
 
-SQLITE_API int sqlite3_win32_is_nt(void); /* os_win.c */
-SQLITE_API void sqlite3_win32_sleep(DWORD milliseconds); /* os_win.c */
+SQLITE_API int SQLITE_STDCALL sqlite3_win32_is_nt(void); /* os_win.c */
+SQLITE_API void SQLITE_STDCALL sqlite3_win32_sleep(DWORD milliseconds); /* os_win.c */
 
 static int winMutexInit(void){
   /* The first to increment to 1 does actual initialization */
@@ -20047,8 +20327,8 @@ static sqlite3_mutex *winMutexAlloc(int iType){
     case SQLITE_MUTEX_RECURSIVE: {
       p = sqlite3MallocZero( sizeof(*p) );
       if( p ){
-#ifdef SQLITE_DEBUG
         p->id = iType;
+#ifdef SQLITE_DEBUG
 #ifdef SQLITE_WIN32_MUTEX_TRACE_DYNAMIC
         p->trace = 1;
 #endif
@@ -20068,12 +20348,9 @@ static sqlite3_mutex *winMutexAlloc(int iType){
         return 0;
       }
 #endif
-      assert( iType-2 >= 0 );
-      assert( iType-2 < ArraySize(winMutex_staticMutexes) );
-      assert( winMutex_isInit==1 );
       p = &winMutex_staticMutexes[iType-2];
-#ifdef SQLITE_DEBUG
       p->id = iType;
+#ifdef SQLITE_DEBUG
 #ifdef SQLITE_WIN32_MUTEX_TRACE_STATIC
       p->trace = 1;
 #endif
@@ -20092,13 +20369,15 @@ static sqlite3_mutex *winMutexAlloc(int iType){
 */
 static void winMutexFree(sqlite3_mutex *p){
   assert( p );
-#ifdef SQLITE_DEBUG
   assert( p->nRef==0 && p->owner==0 );
-  assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE );
+  if( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE ){
+    DeleteCriticalSection(&p->mutex);
+    sqlite3_free(p);
+  }else{
+#ifdef SQLITE_ENABLE_API_ARMOR
+    (void)SQLITE_MISUSE_BKPT;
 #endif
-  assert( winMutex_isInit==1 );
-  DeleteCriticalSection(&p->mutex);
-  sqlite3_free(p);
+  }
 }
 
 /*
@@ -20252,7 +20531,7 @@ SQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void){
 ** held by SQLite. An example of non-essential memory is memory used to
 ** cache database pages that are not currently in use.
 */
-SQLITE_API int sqlite3_release_memory(int n){
+SQLITE_API int SQLITE_STDCALL sqlite3_release_memory(int n){
 #ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
   return sqlite3PcacheReleaseMemory(n);
 #else
@@ -20307,6 +20586,13 @@ static SQLITE_WSD struct Mem0Global {
 
 #define mem0 GLOBAL(struct Mem0Global, mem0)
 
+/*
+** Return the memory allocator mutex. sqlite3_status() needs it.
+*/
+SQLITE_PRIVATE sqlite3_mutex *sqlite3MallocMutex(void){
+  return mem0.mutex;
+}
+
 /*
 ** This routine runs when the memory allocator sees that the
 ** total memory allocation is about to exceed the soft heap
@@ -20329,7 +20615,7 @@ static int sqlite3MemoryAlarm(
   void *pArg,
   sqlite3_int64 iThreshold
 ){
-  int nUsed;
+  sqlite3_int64 nUsed;
   sqlite3_mutex_enter(mem0.mutex);
   mem0.alarmCallback = xCallback;
   mem0.alarmArg = pArg;
@@ -20345,7 +20631,7 @@ static int sqlite3MemoryAlarm(
 ** Deprecated external interface.  Internal/core SQLite code
 ** should call sqlite3MemoryAlarm.
 */
-SQLITE_API int sqlite3_memory_alarm(
+SQLITE_API int SQLITE_STDCALL sqlite3_memory_alarm(
   void(*xCallback)(void *pArg, sqlite3_int64 used,int N),
   void *pArg,
   sqlite3_int64 iThreshold
@@ -20358,7 +20644,7 @@ SQLITE_API int sqlite3_memory_alarm(
 ** Set the soft heap-size limit for the library. Passing a zero or 
 ** negative value indicates no limit.
 */
-SQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n){
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_soft_heap_limit64(sqlite3_int64 n){
   sqlite3_int64 priorLimit;
   sqlite3_int64 excess;
 #ifndef SQLITE_OMIT_AUTOINIT
@@ -20378,7 +20664,7 @@ SQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n){
   if( excess>0 ) sqlite3_release_memory((int)(excess & 0x7fffffff));
   return priorLimit;
 }
-SQLITE_API void sqlite3_soft_heap_limit(int n){
+SQLITE_API void SQLITE_STDCALL sqlite3_soft_heap_limit(int n){
   if( n<0 ) n = 0;
   sqlite3_soft_heap_limit64(n);
 }
@@ -20387,6 +20673,7 @@ SQLITE_API void sqlite3_soft_heap_limit(int n){
 ** Initialize the memory allocation subsystem.
 */
 SQLITE_PRIVATE int sqlite3MallocInit(void){
+  int rc;
   if( sqlite3GlobalConfig.m.xMalloc==0 ){
     sqlite3MemSetDefault();
   }
@@ -20422,7 +20709,9 @@ SQLITE_PRIVATE int sqlite3MallocInit(void){
     sqlite3GlobalConfig.szPage = 0;
     sqlite3GlobalConfig.nPage = 0;
   }
-  return sqlite3GlobalConfig.m.xInit(sqlite3GlobalConfig.m.pAppData);
+  rc = sqlite3GlobalConfig.m.xInit(sqlite3GlobalConfig.m.pAppData);
+  if( rc!=SQLITE_OK ) memset(&mem0, 0, sizeof(mem0));
+  return rc;
 }
 
 /*
@@ -20447,7 +20736,7 @@ SQLITE_PRIVATE void sqlite3MallocEnd(void){
 /*
 ** Return the amount of memory currently checked out.
 */
-SQLITE_API sqlite3_int64 sqlite3_memory_used(void){
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_memory_used(void){
   int n, mx;
   sqlite3_int64 res;
   sqlite3_status(SQLITE_STATUS_MEMORY_USED, &n, &mx, 0);
@@ -20460,7 +20749,7 @@ SQLITE_API sqlite3_int64 sqlite3_memory_used(void){
 ** checked out since either the beginning of this process
 ** or since the most recent reset.
 */
-SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag){
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_memory_highwater(int resetFlag){
   int n, mx;
   sqlite3_int64 res;
   sqlite3_status(SQLITE_STATUS_MEMORY_USED, &n, &mx, resetFlag);
@@ -20498,7 +20787,7 @@ static int mallocWithAlarm(int n, void **pp){
   nFull = sqlite3GlobalConfig.m.xRoundup(n);
   sqlite3StatusSet(SQLITE_STATUS_MALLOC_SIZE, n);
   if( mem0.alarmCallback!=0 ){
-    int nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);
+    sqlite3_int64 nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);
     if( nUsed >= mem0.alarmThreshold - nFull ){
       mem0.nearlyFull = 1;
       sqlite3MallocAlarm(nFull);
@@ -20515,8 +20804,8 @@ static int mallocWithAlarm(int n, void **pp){
 #endif
   if( p ){
     nFull = sqlite3MallocSize(p);
-    sqlite3StatusAdd(SQLITE_STATUS_MEMORY_USED, nFull);
-    sqlite3StatusAdd(SQLITE_STATUS_MALLOC_COUNT, 1);
+    sqlite3StatusUp(SQLITE_STATUS_MEMORY_USED, nFull);
+    sqlite3StatusUp(SQLITE_STATUS_MALLOC_COUNT, 1);
   }
   *pp = p;
   return nFull;
@@ -20551,13 +20840,13 @@ SQLITE_PRIVATE void *sqlite3Malloc(u64 n){
 ** First make sure the memory subsystem is initialized, then do the
 ** allocation.
 */
-SQLITE_API void *sqlite3_malloc(int n){
+SQLITE_API void *SQLITE_STDCALL sqlite3_malloc(int n){
 #ifndef SQLITE_OMIT_AUTOINIT
   if( sqlite3_initialize() ) return 0;
 #endif
   return n<=0 ? 0 : sqlite3Malloc(n);
 }
-SQLITE_API void *sqlite3_malloc64(sqlite3_uint64 n){
+SQLITE_API void *SQLITE_STDCALL sqlite3_malloc64(sqlite3_uint64 n){
 #ifndef SQLITE_OMIT_AUTOINIT
   if( sqlite3_initialize() ) return 0;
 #endif
@@ -20593,14 +20882,14 @@ SQLITE_PRIVATE void *sqlite3ScratchMalloc(int n){
     p = mem0.pScratchFree;
     mem0.pScratchFree = mem0.pScratchFree->pNext;
     mem0.nScratchFree--;
-    sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_USED, 1);
+    sqlite3StatusUp(SQLITE_STATUS_SCRATCH_USED, 1);
     sqlite3_mutex_leave(mem0.mutex);
   }else{
     sqlite3_mutex_leave(mem0.mutex);
     p = sqlite3Malloc(n);
     if( sqlite3GlobalConfig.bMemstat && p ){
       sqlite3_mutex_enter(mem0.mutex);
-      sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_OVERFLOW, sqlite3MallocSize(p));
+      sqlite3StatusUp(SQLITE_STATUS_SCRATCH_OVERFLOW, sqlite3MallocSize(p));
       sqlite3_mutex_leave(mem0.mutex);
     }
     sqlite3MemdebugSetType(p, MEMTYPE_SCRATCH);
@@ -20641,19 +20930,19 @@ SQLITE_PRIVATE void sqlite3ScratchFree(void *p){
       mem0.pScratchFree = pSlot;
       mem0.nScratchFree++;
       assert( mem0.nScratchFree <= (u32)sqlite3GlobalConfig.nScratch );
-      sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_USED, -1);
+      sqlite3StatusDown(SQLITE_STATUS_SCRATCH_USED, 1);
       sqlite3_mutex_leave(mem0.mutex);
     }else{
       /* Release memory back to the heap */
       assert( sqlite3MemdebugHasType(p, MEMTYPE_SCRATCH) );
-      assert( sqlite3MemdebugNoType(p, ~MEMTYPE_SCRATCH) );
+      assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_SCRATCH) );
       sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
       if( sqlite3GlobalConfig.bMemstat ){
         int iSize = sqlite3MallocSize(p);
         sqlite3_mutex_enter(mem0.mutex);
-        sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_OVERFLOW, -iSize);
-        sqlite3StatusAdd(SQLITE_STATUS_MEMORY_USED, -iSize);
-        sqlite3StatusAdd(SQLITE_STATUS_MALLOC_COUNT, -1);
+        sqlite3StatusDown(SQLITE_STATUS_SCRATCH_OVERFLOW, iSize);
+        sqlite3StatusDown(SQLITE_STATUS_MEMORY_USED, iSize);
+        sqlite3StatusDown(SQLITE_STATUS_MALLOC_COUNT, 1);
         sqlite3GlobalConfig.m.xFree(p);
         sqlite3_mutex_leave(mem0.mutex);
       }else{
@@ -20684,7 +20973,7 @@ SQLITE_PRIVATE int sqlite3MallocSize(void *p){
 }
 SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3 *db, void *p){
   if( db==0 ){
-    assert( sqlite3MemdebugNoType(p, ~MEMTYPE_HEAP) );
+    assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );
     assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );
     return sqlite3MallocSize(p);
   }else{
@@ -20693,13 +20982,13 @@ SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3 *db, void *p){
       return db->lookaside.sz;
     }else{
       assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
-      assert( sqlite3MemdebugNoType(p, ~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
+      assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
       return sqlite3GlobalConfig.m.xSize(p);
     }
   }
 }
-SQLITE_API sqlite3_uint64 sqlite3_msize(void *p){
-  assert( sqlite3MemdebugNoType(p, ~MEMTYPE_HEAP) );
+SQLITE_API sqlite3_uint64 SQLITE_STDCALL sqlite3_msize(void *p){
+  assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );
   assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );
   return (sqlite3_uint64)sqlite3GlobalConfig.m.xSize(p);
 }
@@ -20707,14 +20996,14 @@ SQLITE_API sqlite3_uint64 sqlite3_msize(void *p){
 /*
 ** Free memory previously obtained from sqlite3Malloc().
 */
-SQLITE_API void sqlite3_free(void *p){
+SQLITE_API void SQLITE_STDCALL sqlite3_free(void *p){
   if( p==0 ) return;  /* IMP: R-49053-54554 */
   assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );
-  assert( sqlite3MemdebugNoType(p, ~MEMTYPE_HEAP) );
+  assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );
   if( sqlite3GlobalConfig.bMemstat ){
     sqlite3_mutex_enter(mem0.mutex);
-    sqlite3StatusAdd(SQLITE_STATUS_MEMORY_USED, -sqlite3MallocSize(p));
-    sqlite3StatusAdd(SQLITE_STATUS_MALLOC_COUNT, -1);
+    sqlite3StatusDown(SQLITE_STATUS_MEMORY_USED, sqlite3MallocSize(p));
+    sqlite3StatusDown(SQLITE_STATUS_MALLOC_COUNT, 1);
     sqlite3GlobalConfig.m.xFree(p);
     sqlite3_mutex_leave(mem0.mutex);
   }else{
@@ -20755,7 +21044,7 @@ SQLITE_PRIVATE void sqlite3DbFree(sqlite3 *db, void *p){
     }
   }
   assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
-  assert( sqlite3MemdebugNoType(p, ~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
+  assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
   assert( db!=0 || sqlite3MemdebugNoType(p, MEMTYPE_LOOKASIDE) );
   sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
   sqlite3_free(p);
@@ -20768,7 +21057,7 @@ SQLITE_PRIVATE void *sqlite3Realloc(void *pOld, u64 nBytes){
   int nOld, nNew, nDiff;
   void *pNew;
   assert( sqlite3MemdebugHasType(pOld, MEMTYPE_HEAP) );
-  assert( sqlite3MemdebugNoType(pOld, ~MEMTYPE_HEAP) );
+  assert( sqlite3MemdebugNoType(pOld, (u8)~MEMTYPE_HEAP) );
   if( pOld==0 ){
     return sqlite3Malloc(nBytes); /* IMP: R-04300-56712 */
   }
@@ -20802,7 +21091,7 @@ SQLITE_PRIVATE void *sqlite3Realloc(void *pOld, u64 nBytes){
     }
     if( pNew ){
       nNew = sqlite3MallocSize(pNew);
-      sqlite3StatusAdd(SQLITE_STATUS_MEMORY_USED, nNew-nOld);
+      sqlite3StatusUp(SQLITE_STATUS_MEMORY_USED, nNew-nOld);
     }
     sqlite3_mutex_leave(mem0.mutex);
   }else{
@@ -20816,14 +21105,14 @@ SQLITE_PRIVATE void *sqlite3Realloc(void *pOld, u64 nBytes){
 ** The public interface to sqlite3Realloc.  Make sure that the memory
 ** subsystem is initialized prior to invoking sqliteRealloc.
 */
-SQLITE_API void *sqlite3_realloc(void *pOld, int n){
+SQLITE_API void *SQLITE_STDCALL sqlite3_realloc(void *pOld, int n){
 #ifndef SQLITE_OMIT_AUTOINIT
   if( sqlite3_initialize() ) return 0;
 #endif
   if( n<0 ) n = 0;  /* IMP: R-26507-47431 */
   return sqlite3Realloc(pOld, n);
 }
-SQLITE_API void *sqlite3_realloc64(void *pOld, sqlite3_uint64 n){
+SQLITE_API void *SQLITE_STDCALL sqlite3_realloc64(void *pOld, sqlite3_uint64 n){
 #ifndef SQLITE_OMIT_AUTOINIT
   if( sqlite3_initialize() ) return 0;
 #endif
@@ -20935,7 +21224,7 @@ SQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *db, void *p, u64 n){
       }
     }else{
       assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
-      assert( sqlite3MemdebugNoType(p, ~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
+      assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
       sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
       pNew = sqlite3_realloc64(p, n);
       if( !pNew ){
@@ -21188,6 +21477,7 @@ static char et_getdigit(LONGDOUBLE_TYPE *val, int *cnt){
 ** Set the StrAccum object to an error mode.
 */
 static void setStrAccumError(StrAccum *p, u8 eError){
+  assert( eError==STRACCUM_NOMEM || eError==STRACCUM_TOOBIG );
   p->accError = eError;
   p->nAlloc = 0;
 }
@@ -21262,13 +21552,6 @@ SQLITE_PRIVATE void sqlite3VXPrintf(
   PrintfArguments *pArgList = 0; /* Arguments for SQLITE_PRINTF_SQLFUNC */
   char buf[etBUFSIZE];       /* Conversion buffer */
 
-#ifdef SQLITE_ENABLE_API_ARMOR
-  if( ap==0 ){
-    (void)SQLITE_MISUSE_BKPT;
-    sqlite3StrAccumReset(pAccum);
-    return;
-  }
-#endif
   bufpt = 0;
   if( bFlags ){
     if( (bArgList = (bFlags & SQLITE_PRINTF_SQLFUNC))!=0 ){
@@ -21309,7 +21592,6 @@ SQLITE_PRIVATE void sqlite3VXPrintf(
       }
     }while( !done && (c=(*++fmt))!=0 );
     /* Get the field width */
-    width = 0;
     if( c=='*' ){
       if( bArgList ){
         width = (int)getIntArg(pArgList);
@@ -21318,18 +21600,21 @@ SQLITE_PRIVATE void sqlite3VXPrintf(
       }
       if( width<0 ){
         flag_leftjustify = 1;
-        width = -width;
+        width = width >= -2147483647 ? -width : 0;
       }
       c = *++fmt;
     }else{
+      unsigned wx = 0;
       while( c>='0' && c<='9' ){
-        width = width*10 + c - '0';
+        wx = wx*10 + c - '0';
         c = *++fmt;
       }
+      testcase( wx>0x7fffffff );
+      width = wx & 0x7fffffff;
     }
+
     /* Get the precision */
     if( c=='.' ){
-      precision = 0;
       c = *++fmt;
       if( c=='*' ){
         if( bArgList ){
@@ -21337,13 +21622,18 @@ SQLITE_PRIVATE void sqlite3VXPrintf(
         }else{
           precision = va_arg(ap,int);
         }
-        if( precision<0 ) precision = -precision;
         c = *++fmt;
+        if( precision<0 ){
+          precision = precision >= -2147483647 ? -precision : -1;
+        }
       }else{
+        unsigned px = 0;
         while( c>='0' && c<='9' ){
-          precision = precision*10 + c - '0';
+          px = px*10 + c - '0';
           c = *++fmt;
         }
+        testcase( px>0x7fffffff );
+        precision = px & 0x7fffffff;
       }
     }else{
       precision = -1;
@@ -21507,7 +21797,8 @@ SQLITE_PRIVATE void sqlite3VXPrintf(
           else                         prefix = 0;
         }
         if( xtype==etGENERIC && precision>0 ) precision--;
-        for(idx=precision, rounder=0.5; idx>0; idx--, rounder*=0.1){}
+        testcase( precision>0xfff );
+        for(idx=precision&0xfff, rounder=0.5; idx>0; idx--, rounder*=0.1){}
         if( xtype==etFLOAT ) realvalue += rounder;
         /* Normalize realvalue to within 10.0 > realvalue >= 1.0 */
         exp = 0;
@@ -21562,8 +21853,9 @@ SQLITE_PRIVATE void sqlite3VXPrintf(
         }else{
           e2 = exp;
         }
-        if( MAX(e2,0)+precision+width > etBUFSIZE - 15 ){
-          bufpt = zExtra = sqlite3Malloc( MAX(e2,0)+precision+width+15 );
+        if( MAX(e2,0)+(i64)precision+(i64)width > etBUFSIZE - 15 ){
+          bufpt = zExtra 
+              = sqlite3Malloc( MAX(e2,0)+(i64)precision+(i64)width+15 );
           if( bufpt==0 ){
             setStrAccumError(pAccum, STRACCUM_NOMEM);
             return;
@@ -21795,13 +22087,13 @@ SQLITE_PRIVATE void sqlite3VXPrintf(
 */
 static int sqlite3StrAccumEnlarge(StrAccum *p, int N){
   char *zNew;
-  assert( p->nChar+N >= p->nAlloc ); /* Only called if really needed */
+  assert( p->nChar+(i64)N >= p->nAlloc ); /* Only called if really needed */
   if( p->accError ){
     testcase(p->accError==STRACCUM_TOOBIG);
     testcase(p->accError==STRACCUM_NOMEM);
     return 0;
   }
-  if( !p->useMalloc ){
+  if( p->mxAlloc==0 ){
     N = p->nAlloc - p->nChar - 1;
     setStrAccumError(p, STRACCUM_TOOBIG);
     return N;
@@ -21821,10 +22113,10 @@ static int sqlite3StrAccumEnlarge(StrAccum *p, int N){
     }else{
       p->nAlloc = (int)szNew;
     }
-    if( p->useMalloc==1 ){
+    if( p->db ){
       zNew = sqlite3DbRealloc(p->db, zOld, p->nAlloc);
     }else{
-      zNew = sqlite3_realloc(zOld, p->nAlloc);
+      zNew = sqlite3_realloc64(zOld, p->nAlloc);
     }
     if( zNew ){
       assert( p->zText!=0 || p->nChar==0 );
@@ -21844,7 +22136,10 @@ static int sqlite3StrAccumEnlarge(StrAccum *p, int N){
 ** Append N copies of character c to the given string buffer.
 */
 SQLITE_PRIVATE void sqlite3AppendChar(StrAccum *p, int N, char c){
-  if( p->nChar+N >= p->nAlloc && (N = sqlite3StrAccumEnlarge(p, N))<=0 ) return;
+  testcase( p->nChar + (i64)N > 0x7fffffff );
+  if( p->nChar+(i64)N >= p->nAlloc && (N = sqlite3StrAccumEnlarge(p, N))<=0 ){
+    return;
+  }
   while( (N--)>0 ) p->zText[p->nChar++] = c;
 }
 
@@ -21869,7 +22164,7 @@ static void SQLITE_NOINLINE enlargeAndAppend(StrAccum *p, const char *z, int N){
 ** size of the memory allocation for StrAccum if necessary.
 */
 SQLITE_PRIVATE void sqlite3StrAccumAppend(StrAccum *p, const char *z, int N){
-  assert( z!=0 );
+  assert( z!=0 || N==0 );
   assert( p->zText!=0 || p->nChar==0 || p->accError );
   assert( N>=0 );
   assert( p->accError==0 || p->nAlloc==0 );
@@ -21898,12 +22193,8 @@ SQLITE_PRIVATE void sqlite3StrAccumAppendAll(StrAccum *p, const char *z){
 SQLITE_PRIVATE char *sqlite3StrAccumFinish(StrAccum *p){
   if( p->zText ){
     p->zText[p->nChar] = 0;
-    if( p->useMalloc && p->zText==p->zBase ){
-      if( p->useMalloc==1 ){
-        p->zText = sqlite3DbMallocRaw(p->db, p->nChar+1 );
-      }else{
-        p->zText = sqlite3_malloc(p->nChar+1);
-      }
+    if( p->mxAlloc>0 && p->zText==p->zBase ){
+      p->zText = sqlite3DbMallocRaw(p->db, p->nChar+1 );
       if( p->zText ){
         memcpy(p->zText, p->zBase, p->nChar+1);
       }else{
@@ -21919,25 +22210,31 @@ SQLITE_PRIVATE char *sqlite3StrAccumFinish(StrAccum *p){
 */
 SQLITE_PRIVATE void sqlite3StrAccumReset(StrAccum *p){
   if( p->zText!=p->zBase ){
-    if( p->useMalloc==1 ){
-      sqlite3DbFree(p->db, p->zText);
-    }else{
-      sqlite3_free(p->zText);
-    }
+    sqlite3DbFree(p->db, p->zText);
   }
   p->zText = 0;
 }
 
 /*
-** Initialize a string accumulator
+** Initialize a string accumulator.
+**
+** p:     The accumulator to be initialized.
+** db:    Pointer to a database connection.  May be NULL.  Lookaside
+**        memory is used if not NULL. db->mallocFailed is set appropriately
+**        when not NULL.
+** zBase: An initial buffer.  May be NULL in which case the initial buffer
+**        is malloced.
+** n:     Size of zBase in bytes.  If total space requirements never exceed
+**        n then no memory allocations ever occur.
+** mx:    Maximum number of bytes to accumulate.  If mx==0 then no memory
+**        allocations will ever occur.
 */
-SQLITE_PRIVATE void sqlite3StrAccumInit(StrAccum *p, char *zBase, int n, int mx){
+SQLITE_PRIVATE void sqlite3StrAccumInit(StrAccum *p, sqlite3 *db, char *zBase, int n, int mx){
   p->zText = p->zBase = zBase;
-  p->db = 0;
+  p->db = db;
   p->nChar = 0;
   p->nAlloc = n;
   p->mxAlloc = mx;
-  p->useMalloc = 1;
   p->accError = 0;
 }
 
@@ -21950,9 +22247,8 @@ SQLITE_PRIVATE char *sqlite3VMPrintf(sqlite3 *db, const char *zFormat, va_list a
   char zBase[SQLITE_PRINT_BUF_SIZE];
   StrAccum acc;
   assert( db!=0 );
-  sqlite3StrAccumInit(&acc, zBase, sizeof(zBase),
+  sqlite3StrAccumInit(&acc, db, zBase, sizeof(zBase),
                       db->aLimit[SQLITE_LIMIT_LENGTH]);
-  acc.db = db;
   sqlite3VXPrintf(&acc, SQLITE_PRINTF_INTERNAL, zFormat, ap);
   z = sqlite3StrAccumFinish(&acc);
   if( acc.accError==STRACCUM_NOMEM ){
@@ -21996,7 +22292,7 @@ SQLITE_PRIVATE char *sqlite3MAppendf(sqlite3 *db, char *zStr, const char *zForma
 ** Print into memory obtained from sqlite3_malloc().  Omit the internal
 ** %-conversion extensions.
 */
-SQLITE_API char *sqlite3_vmprintf(const char *zFormat, va_list ap){
+SQLITE_API char *SQLITE_STDCALL sqlite3_vmprintf(const char *zFormat, va_list ap){
   char *z;
   char zBase[SQLITE_PRINT_BUF_SIZE];
   StrAccum acc;
@@ -22010,8 +22306,7 @@ SQLITE_API char *sqlite3_vmprintf(const char *zFormat, va_list ap){
 #ifndef SQLITE_OMIT_AUTOINIT
   if( sqlite3_initialize() ) return 0;
 #endif
-  sqlite3StrAccumInit(&acc, zBase, sizeof(zBase), SQLITE_MAX_LENGTH);
-  acc.useMalloc = 2;
+  sqlite3StrAccumInit(&acc, 0, zBase, sizeof(zBase), SQLITE_MAX_LENGTH);
   sqlite3VXPrintf(&acc, 0, zFormat, ap);
   z = sqlite3StrAccumFinish(&acc);
   return z;
@@ -22021,7 +22316,7 @@ SQLITE_API char *sqlite3_vmprintf(const char *zFormat, va_list ap){
 ** Print into memory obtained from sqlite3_malloc()().  Omit the internal
 ** %-conversion extensions.
 */
-SQLITE_API char *sqlite3_mprintf(const char *zFormat, ...){
+SQLITE_API char *SQLITE_CDECL sqlite3_mprintf(const char *zFormat, ...){
   va_list ap;
   char *z;
 #ifndef SQLITE_OMIT_AUTOINIT
@@ -22046,22 +22341,21 @@ SQLITE_API char *sqlite3_mprintf(const char *zFormat, ...){
 **
 ** sqlite3_vsnprintf() is the varargs version.
 */
-SQLITE_API char *sqlite3_vsnprintf(int n, char *zBuf, const char *zFormat, va_list ap){
+SQLITE_API char *SQLITE_STDCALL sqlite3_vsnprintf(int n, char *zBuf, const char *zFormat, va_list ap){
   StrAccum acc;
   if( n<=0 ) return zBuf;
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( zBuf==0 || zFormat==0 ) {
     (void)SQLITE_MISUSE_BKPT;
-    if( zBuf && n>0 ) zBuf[0] = 0;
+    if( zBuf ) zBuf[0] = 0;
     return zBuf;
   }
 #endif
-  sqlite3StrAccumInit(&acc, zBuf, n, 0);
-  acc.useMalloc = 0;
+  sqlite3StrAccumInit(&acc, 0, zBuf, n, 0);
   sqlite3VXPrintf(&acc, 0, zFormat, ap);
   return sqlite3StrAccumFinish(&acc);
 }
-SQLITE_API char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){
+SQLITE_API char *SQLITE_CDECL sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){
   char *z;
   va_list ap;
   va_start(ap,zFormat);
@@ -22083,8 +22377,7 @@ static void renderLogMsg(int iErrCode, const char *zFormat, va_list ap){
   StrAccum acc;                          /* String accumulator */
   char zMsg[SQLITE_PRINT_BUF_SIZE*3];    /* Complete log message */
 
-  sqlite3StrAccumInit(&acc, zMsg, sizeof(zMsg), 0);
-  acc.useMalloc = 0;
+  sqlite3StrAccumInit(&acc, 0, zMsg, sizeof(zMsg), 0);
   sqlite3VXPrintf(&acc, 0, zFormat, ap);
   sqlite3GlobalConfig.xLog(sqlite3GlobalConfig.pLogArg, iErrCode,
                            sqlite3StrAccumFinish(&acc));
@@ -22093,7 +22386,7 @@ static void renderLogMsg(int iErrCode, const char *zFormat, va_list ap){
 /*
 ** Format and write a message to the log if logging is enabled.
 */
-SQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...){
+SQLITE_API void SQLITE_CDECL sqlite3_log(int iErrCode, const char *zFormat, ...){
   va_list ap;                             /* Vararg list */
   if( sqlite3GlobalConfig.xLog ){
     va_start(ap, zFormat);
@@ -22102,7 +22395,7 @@ SQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...){
   }
 }
 
-#if defined(SQLITE_DEBUG)
+#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)
 /*
 ** A version of printf() that understands %lld.  Used for debugging.
 ** The printf() built into some versions of windows does not understand %lld
@@ -22112,8 +22405,7 @@ SQLITE_PRIVATE void sqlite3DebugPrintf(const char *zFormat, ...){
   va_list ap;
   StrAccum acc;
   char zBuf[500];
-  sqlite3StrAccumInit(&acc, zBuf, sizeof(zBuf), 0);
-  acc.useMalloc = 0;
+  sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);
   va_start(ap,zFormat);
   sqlite3VXPrintf(&acc, 0, zFormat, ap);
   va_end(ap);
@@ -22140,7 +22432,7 @@ SQLITE_PRIVATE void sqlite3DebugPrintf(const char *zFormat, ...){
 ** is not the last item in the tree. */
 SQLITE_PRIVATE TreeView *sqlite3TreeViewPush(TreeView *p, u8 moreToFollow){
   if( p==0 ){
-    p = sqlite3_malloc( sizeof(*p) );
+    p = sqlite3_malloc64( sizeof(*p) );
     if( p==0 ) return 0;
     memset(p, 0, sizeof(*p));
   }else{
@@ -22163,8 +22455,7 @@ SQLITE_PRIVATE void sqlite3TreeViewLine(TreeView *p, const char *zFormat, ...){
   int i;
   StrAccum acc;
   char zBuf[500];
-  sqlite3StrAccumInit(&acc, zBuf, sizeof(zBuf), 0);
-  acc.useMalloc = 0;
+  sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);
   if( p ){
     for(i=0; i<p->iLevel && i<sizeof(p->bLine)-1; i++){
       sqlite3StrAccumAppend(&acc, p->bLine[i] ? "|   " : "    ", 4);
@@ -22229,7 +22520,7 @@ static SQLITE_WSD struct sqlite3PrngType {
 /*
 ** Return N random bytes.
 */
-SQLITE_API void sqlite3_randomness(int N, void *pBuf){
+SQLITE_API void SQLITE_STDCALL sqlite3_randomness(int N, void *pBuf){
   unsigned char t;
   unsigned char *zBuf = pBuf;
 
@@ -22435,7 +22726,7 @@ SQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){
 
 
 /********************************* Win32 Threads ****************************/
-#if SQLITE_OS_WIN && !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_THREADSAFE>0
+#if SQLITE_OS_WIN_THREADS
 
 #define SQLITE_THREADS_IMPLEMENTED 1  /* Prevent the single-thread code below */
 #include <process.h>
@@ -22528,7 +22819,7 @@ SQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){
   return (rc==WAIT_OBJECT_0) ? SQLITE_OK : SQLITE_ERROR;
 }
 
-#endif /* SQLITE_OS_WIN && !SQLITE_OS_WINCE && !SQLITE_OS_WINRT */
+#endif /* SQLITE_OS_WIN_THREADS */
 /******************************** End Win32 Threads *************************/
 
 
@@ -23381,7 +23672,7 @@ SQLITE_PRIVATE int sqlite3Dequote(char *z){
 ** case-independent fashion, using the same definition of "case
 ** independence" that SQLite uses internally when comparing identifiers.
 */
-SQLITE_API int sqlite3_stricmp(const char *zLeft, const char *zRight){
+SQLITE_API int SQLITE_STDCALL sqlite3_stricmp(const char *zLeft, const char *zRight){
   register unsigned char *a, *b;
   if( zLeft==0 ){
     return zRight ? -1 : 0;
@@ -23393,7 +23684,7 @@ SQLITE_API int sqlite3_stricmp(const char *zLeft, const char *zRight){
   while( *a!=0 && UpperToLower[*a]==UpperToLower[*b]){ a++; b++; }
   return UpperToLower[*a] - UpperToLower[*b];
 }
-SQLITE_API int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N){
+SQLITE_API int SQLITE_STDCALL sqlite3_strnicmp(const char *zLeft, const char *zRight, int N){
   register unsigned char *a, *b;
   if( zLeft==0 ){
     return zRight ? -1 : 0;
@@ -23787,6 +24078,7 @@ SQLITE_PRIVATE int sqlite3GetInt32(const char *zNum, int *pValue){
     }
   }
 #endif
+  while( zNum[0]=='0' ) zNum++;
   for(i=0; i<11 && (c = zNum[i] - '0')>=0 && c<=9; i++){
     v = v*10 + c;
   }
@@ -24924,23 +25216,25 @@ SQLITE_PRIVATE const char *sqlite3OpcodeName(int i){
      /* 136 */ "MemMax"           OpHelp("r[P1]=max(r[P1],r[P2])"),
      /* 137 */ "IfPos"            OpHelp("if r[P1]>0 goto P2"),
      /* 138 */ "IfNeg"            OpHelp("r[P1]+=P3, if r[P1]<0 goto P2"),
-     /* 139 */ "IfZero"           OpHelp("r[P1]+=P3, if r[P1]==0 goto P2"),
-     /* 140 */ "AggFinal"         OpHelp("accum=r[P1] N=P2"),
-     /* 141 */ "IncrVacuum"       OpHelp(""),
-     /* 142 */ "Expire"           OpHelp(""),
-     /* 143 */ "TableLock"        OpHelp("iDb=P1 root=P2 write=P3"),
-     /* 144 */ "VBegin"           OpHelp(""),
-     /* 145 */ "VCreate"          OpHelp(""),
-     /* 146 */ "VDestroy"         OpHelp(""),
-     /* 147 */ "VOpen"            OpHelp(""),
-     /* 148 */ "VColumn"          OpHelp("r[P3]=vcolumn(P2)"),
-     /* 149 */ "VNext"            OpHelp(""),
-     /* 150 */ "VRename"          OpHelp(""),
-     /* 151 */ "Pagecount"        OpHelp(""),
-     /* 152 */ "MaxPgcnt"         OpHelp(""),
-     /* 153 */ "Init"             OpHelp("Start at P2"),
-     /* 154 */ "Noop"             OpHelp(""),
-     /* 155 */ "Explain"          OpHelp(""),
+     /* 139 */ "IfNotZero"        OpHelp("if r[P1]!=0 then r[P1]+=P3, goto P2"),
+     /* 140 */ "DecrJumpZero"     OpHelp("if (--r[P1])==0 goto P2"),
+     /* 141 */ "JumpZeroIncr"     OpHelp("if (r[P1]++)==0 ) goto P2"),
+     /* 142 */ "AggFinal"         OpHelp("accum=r[P1] N=P2"),
+     /* 143 */ "IncrVacuum"       OpHelp(""),
+     /* 144 */ "Expire"           OpHelp(""),
+     /* 145 */ "TableLock"        OpHelp("iDb=P1 root=P2 write=P3"),
+     /* 146 */ "VBegin"           OpHelp(""),
+     /* 147 */ "VCreate"          OpHelp(""),
+     /* 148 */ "VDestroy"         OpHelp(""),
+     /* 149 */ "VOpen"            OpHelp(""),
+     /* 150 */ "VColumn"          OpHelp("r[P3]=vcolumn(P2)"),
+     /* 151 */ "VNext"            OpHelp(""),
+     /* 152 */ "VRename"          OpHelp(""),
+     /* 153 */ "Pagecount"        OpHelp(""),
+     /* 154 */ "MaxPgcnt"         OpHelp(""),
+     /* 155 */ "Init"             OpHelp("Start at P2"),
+     /* 156 */ "Noop"             OpHelp(""),
+     /* 157 */ "Explain"          OpHelp(""),
   };
   return azName[i];
 }
@@ -25020,18 +25314,6 @@ SQLITE_PRIVATE const char *sqlite3OpcodeName(int i){
 #  endif
 #endif
 
-/*
-** Define the OS_VXWORKS pre-processor macro to 1 if building on 
-** vxworks, or 0 otherwise.
-*/
-#ifndef OS_VXWORKS
-#  if defined(__RTP__) || defined(_WRS_KERNEL)
-#    define OS_VXWORKS 1
-#  else
-#    define OS_VXWORKS 0
-#  endif
-#endif
-
 /*
 ** standard include files.
 */
@@ -25046,18 +25328,30 @@ SQLITE_PRIVATE const char *sqlite3OpcodeName(int i){
 # include <sys/mman.h>
 #endif
 
-#if SQLITE_ENABLE_LOCKING_STYLE || OS_VXWORKS
+#if SQLITE_ENABLE_LOCKING_STYLE
 # include <sys/ioctl.h>
-# if OS_VXWORKS
-#  include <semaphore.h>
-#  include <limits.h>
-# else
-#  include <sys/file.h>
-#  include <sys/param.h>
-# endif
+# include <sys/file.h>
+# include <sys/param.h>
 #endif /* SQLITE_ENABLE_LOCKING_STYLE */
 
-#if defined(__APPLE__) || (SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORKS)
+#if defined(__APPLE__) && ((__MAC_OS_X_VERSION_MIN_REQUIRED > 1050) || \
+                           (__IPHONE_OS_VERSION_MIN_REQUIRED > 2000))
+#  if (!defined(TARGET_OS_EMBEDDED) || (TARGET_OS_EMBEDDED==0)) \
+       && (!defined(TARGET_IPHONE_SIMULATOR) || (TARGET_IPHONE_SIMULATOR==0))
+#    define HAVE_GETHOSTUUID 1
+#  else
+#    warning "gethostuuid() is disabled."
+#  endif
+#endif
+
+
+#if OS_VXWORKS
+/* # include <sys/ioctl.h> */
+# include <semaphore.h>
+# include <limits.h>
+#endif /* OS_VXWORKS */
+
+#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE
 # include <sys/mount.h>
 #endif
 
@@ -25098,6 +25392,10 @@ SQLITE_PRIVATE const char *sqlite3OpcodeName(int i){
 */
 #define MAX_PATHNAME 512
 
+/* Always cast the getpid() return type for compatibility with
+** kernel modules in VxWorks. */
+#define osGetpid(X) (pid_t)getpid()
+
 /*
 ** Only set the lastErrno if the error code is a real error and not 
 ** a normal expected return code of SQLITE_BUSY or SQLITE_OK
@@ -25186,7 +25484,7 @@ struct unixFile {
 ** method was called.  If xOpen() is called from a different process id,
 ** indicating that a fork() has occurred, the PRNG will be reset.
 */
-static int randomnessPid = 0;
+static pid_t randomnessPid = 0;
 
 /*
 ** Allowed values for the unixFile.ctrlFlags bitmask:
@@ -25203,7 +25501,8 @@ static int randomnessPid = 0;
 #define UNIXFILE_DELETE      0x20     /* Delete on close */
 #define UNIXFILE_URI         0x40     /* Filename might have query parameters */
 #define UNIXFILE_NOLOCK      0x80     /* Do no file locking */
-#define UNIXFILE_WARNED    0x0100     /* verifyDbFile() warnings have been issued */
+#define UNIXFILE_WARNED    0x0100     /* verifyDbFile() warnings issued */
+#define UNIXFILE_BLOCK     0x0200     /* Next SHM lock might block */
 
 /*
 ** Include code that is common to all os_*.c files
@@ -25241,16 +25540,6 @@ static int randomnessPid = 0;
 # error "The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead."
 #endif
 
-#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)
-# ifndef SQLITE_DEBUG_OS_TRACE
-#   define SQLITE_DEBUG_OS_TRACE 0
-# endif
-  int sqlite3OSTrace = SQLITE_DEBUG_OS_TRACE;
-# define OSTRACE(X)          if( sqlite3OSTrace ) sqlite3DebugPrintf X
-#else
-# define OSTRACE(X)
-#endif
-
 /*
 ** Macros for performance tracing.  Normally turned off.  Only works
 ** on i486 hardware.
@@ -25542,7 +25831,7 @@ static struct unix_syscall {
   { "read",         (sqlite3_syscall_ptr)read,       0  },
 #define osRead      ((ssize_t(*)(int,void*,size_t))aSyscall[8].pCurrent)
 
-#if defined(USE_PREAD) || (SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORKS)
+#if defined(USE_PREAD) || SQLITE_ENABLE_LOCKING_STYLE
   { "pread",        (sqlite3_syscall_ptr)pread,      0  },
 #else
   { "pread",        (sqlite3_syscall_ptr)0,          0  },
@@ -25559,7 +25848,7 @@ static struct unix_syscall {
   { "write",        (sqlite3_syscall_ptr)write,      0  },
 #define osWrite     ((ssize_t(*)(int,const void*,size_t))aSyscall[11].pCurrent)
 
-#if defined(USE_PREAD) || (SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORKS)
+#if defined(USE_PREAD) || SQLITE_ENABLE_LOCKING_STYLE
   { "pwrite",       (sqlite3_syscall_ptr)pwrite,     0  },
 #else
   { "pwrite",       (sqlite3_syscall_ptr)0,          0  },
@@ -25793,7 +26082,7 @@ static int unixMutexHeld(void) {
 #endif
 
 
-#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)
+#ifdef SQLITE_HAVE_OS_TRACE
 /*
 ** Helper function for printing out trace information from debugging
 ** binaries. This returns the string representation of the supplied
@@ -25874,9 +26163,9 @@ static int lockTrace(int fd, int op, struct flock *p){
 /*
 ** Retry ftruncate() calls that fail due to EINTR
 **
-** All calls to ftruncate() within this file should be made through this wrapper.
-** On the Android platform, bypassing the logic below could lead to a corrupt
-** database.
+** All calls to ftruncate() within this file should be made through
+** this wrapper.  On the Android platform, bypassing the logic below
+** could lead to a corrupt database.
 */
 static int robust_ftruncate(int h, sqlite3_int64 sz){
   int rc;
@@ -26056,7 +26345,7 @@ static struct vxworksFileId *vxworksFindFileId(const char *zAbsoluteName){
 
   assert( zAbsoluteName[0]=='/' );
   n = (int)strlen(zAbsoluteName);
-  pNew = sqlite3_malloc( sizeof(*pNew) + (n+1) );
+  pNew = sqlite3_malloc64( sizeof(*pNew) + (n+1) );
   if( pNew==0 ) return 0;
   pNew->zCanonicalName = (char*)&pNew[1];
   memcpy(pNew->zCanonicalName, zAbsoluteName, n+1);
@@ -26335,6 +26624,14 @@ static void robust_close(unixFile *pFile, int h, int lineno){
   }
 }
 
+/*
+** Set the pFile->lastErrno.  Do this in a subroutine as that provides
+** a convenient place to set a breakpoint.
+*/
+static void storeLastErrno(unixFile *pFile, int error){
+  pFile->lastErrno = error;
+}
+
 /*
 ** Close all file descriptors accumuated in the unixInodeInfo->pUnused list.
 */ 
@@ -26408,7 +26705,7 @@ static int findInodeInfo(
   fd = pFile->h;
   rc = osFstat(fd, &statbuf);
   if( rc!=0 ){
-    pFile->lastErrno = errno;
+    storeLastErrno(pFile, errno);
 #ifdef EOVERFLOW
     if( pFile->lastErrno==EOVERFLOW ) return SQLITE_NOLFS;
 #endif
@@ -26429,12 +26726,12 @@ static int findInodeInfo(
   if( statbuf.st_size==0 && (pFile->fsFlags & SQLITE_FSFLAGS_IS_MSDOS)!=0 ){
     do{ rc = osWrite(fd, "S", 1); }while( rc<0 && errno==EINTR );
     if( rc!=1 ){
-      pFile->lastErrno = errno;
+      storeLastErrno(pFile, errno);
       return SQLITE_IOERR;
     }
     rc = osFstat(fd, &statbuf);
     if( rc!=0 ){
-      pFile->lastErrno = errno;
+      storeLastErrno(pFile, errno);
       return SQLITE_IOERR;
     }
   }
@@ -26452,7 +26749,7 @@ static int findInodeInfo(
     pInode = pInode->pNext;
   }
   if( pInode==0 ){
-    pInode = sqlite3_malloc( sizeof(*pInode) );
+    pInode = sqlite3_malloc64( sizeof(*pInode) );
     if( pInode==0 ){
       return SQLITE_NOMEM;
     }
@@ -26557,7 +26854,7 @@ static int unixCheckReservedLock(sqlite3_file *id, int *pResOut){
     lock.l_type = F_WRLCK;
     if( osFcntl(pFile->h, F_GETLK, &lock) ){
       rc = SQLITE_IOERR_CHECKRESERVEDLOCK;
-      pFile->lastErrno = errno;
+      storeLastErrno(pFile, errno);
     } else if( lock.l_type!=F_UNLCK ){
       reserved = 1;
     }
@@ -26690,7 +26987,8 @@ static int unixLock(sqlite3_file *id, int eFileLock){
   assert( pFile );
   OSTRACE(("LOCK    %d %s was %s(%s,%d) pid=%d (unix)\n", pFile->h,
       azFileLock(eFileLock), azFileLock(pFile->eFileLock),
-      azFileLock(pFile->pInode->eFileLock), pFile->pInode->nShared , getpid()));
+      azFileLock(pFile->pInode->eFileLock), pFile->pInode->nShared,
+      osGetpid(0)));
 
   /* If there is already a lock of this type or more restrictive on the
   ** unixFile, do nothing. Don't use the end_lock: exit path, as
@@ -26757,7 +27055,7 @@ static int unixLock(sqlite3_file *id, int eFileLock){
       tErrno = errno;
       rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);
       if( rc!=SQLITE_BUSY ){
-        pFile->lastErrno = tErrno;
+        storeLastErrno(pFile, tErrno);
       }
       goto end_lock;
     }
@@ -26792,7 +27090,7 @@ static int unixLock(sqlite3_file *id, int eFileLock){
 
     if( rc ){
       if( rc!=SQLITE_BUSY ){
-        pFile->lastErrno = tErrno;
+        storeLastErrno(pFile, tErrno);
       }
       goto end_lock;
     }else{
@@ -26825,7 +27123,7 @@ static int unixLock(sqlite3_file *id, int eFileLock){
       tErrno = errno;
       rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);
       if( rc!=SQLITE_BUSY ){
-        pFile->lastErrno = tErrno;
+        storeLastErrno(pFile, tErrno);
       }
     }
   }
@@ -26898,7 +27196,7 @@ static int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){
   assert( pFile );
   OSTRACE(("UNLOCK  %d %d was %d(%d,%d) pid=%d (unix)\n", pFile->h, eFileLock,
       pFile->eFileLock, pFile->pInode->eFileLock, pFile->pInode->nShared,
-      getpid()));
+      osGetpid(0)));
 
   assert( eFileLock<=SHARED_LOCK );
   if( pFile->eFileLock<=eFileLock ){
@@ -26932,7 +27230,6 @@ static int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){
     **  4:   [RRRR.]
     */
     if( eFileLock==SHARED_LOCK ){
-
 #if !defined(__APPLE__) || !SQLITE_ENABLE_LOCKING_STYLE
       (void)handleNFSUnlock;
       assert( handleNFSUnlock==0 );
@@ -26950,7 +27247,7 @@ static int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){
           tErrno = errno;
           rc = SQLITE_IOERR_UNLOCK;
           if( IS_LOCK_ERROR(rc) ){
-            pFile->lastErrno = tErrno;
+            storeLastErrno(pFile, tErrno);
           }
           goto end_unlock;
         }
@@ -26962,7 +27259,7 @@ static int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){
           tErrno = errno;
           rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_RDLOCK);
           if( IS_LOCK_ERROR(rc) ){
-            pFile->lastErrno = tErrno;
+            storeLastErrno(pFile, tErrno);
           }
           goto end_unlock;
         }
@@ -26974,7 +27271,7 @@ static int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){
           tErrno = errno;
           rc = SQLITE_IOERR_UNLOCK;
           if( IS_LOCK_ERROR(rc) ){
-            pFile->lastErrno = tErrno;
+            storeLastErrno(pFile, tErrno);
           }
           goto end_unlock;
         }
@@ -26993,7 +27290,7 @@ static int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){
           ** SQLITE_BUSY would confuse the upper layer (in practice it causes 
           ** an assert to fail). */ 
           rc = SQLITE_IOERR_RDLOCK;
-          pFile->lastErrno = errno;
+          storeLastErrno(pFile, errno);
           goto end_unlock;
         }
       }
@@ -27006,7 +27303,7 @@ static int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){
       pInode->eFileLock = SHARED_LOCK;
     }else{
       rc = SQLITE_IOERR_UNLOCK;
-      pFile->lastErrno = errno;
+      storeLastErrno(pFile, errno);
       goto end_unlock;
     }
   }
@@ -27024,7 +27321,7 @@ static int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){
         pInode->eFileLock = NO_LOCK;
       }else{
         rc = SQLITE_IOERR_UNLOCK;
-        pFile->lastErrno = errno;
+        storeLastErrno(pFile, errno);
         pInode->eFileLock = NO_LOCK;
         pFile->eFileLock = NO_LOCK;
       }
@@ -27299,7 +27596,7 @@ static int dotlockLock(sqlite3_file *id, int eFileLock) {
     } else {
       rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);
       if( IS_LOCK_ERROR(rc) ){
-        pFile->lastErrno = tErrno;
+        storeLastErrno(pFile, tErrno);
       }
     }
     return rc;
@@ -27326,7 +27623,7 @@ static int dotlockUnlock(sqlite3_file *id, int eFileLock) {
 
   assert( pFile );
   OSTRACE(("UNLOCK  %d %d was %d pid=%d (dotlock)\n", pFile->h, eFileLock,
-           pFile->eFileLock, getpid()));
+           pFile->eFileLock, osGetpid(0)));
   assert( eFileLock<=SHARED_LOCK );
   
   /* no-op if possible */
@@ -27353,7 +27650,7 @@ static int dotlockUnlock(sqlite3_file *id, int eFileLock) {
       rc = SQLITE_IOERR_UNLOCK;
     }
     if( IS_LOCK_ERROR(rc) ){
-      pFile->lastErrno = tErrno;
+      storeLastErrno(pFile, tErrno);
     }
     return rc; 
   }
@@ -27389,10 +27686,9 @@ static int dotlockClose(sqlite3_file *id) {
 ** still works when you do this, but concurrency is reduced since
 ** only a single process can be reading the database at a time.
 **
-** Omit this section if SQLITE_ENABLE_LOCKING_STYLE is turned off or if
-** compiling for VXWORKS.
+** Omit this section if SQLITE_ENABLE_LOCKING_STYLE is turned off
 */
-#if SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORKS
+#if SQLITE_ENABLE_LOCKING_STYLE
 
 /*
 ** Retry flock() calls that fail with EINTR
@@ -27440,7 +27736,7 @@ static int flockCheckReservedLock(sqlite3_file *id, int *pResOut){
         /* unlock failed with an error */
         lrc = SQLITE_IOERR_UNLOCK; 
         if( IS_LOCK_ERROR(lrc) ){
-          pFile->lastErrno = tErrno;
+          storeLastErrno(pFile, tErrno);
           rc = lrc;
         }
       }
@@ -27450,7 +27746,7 @@ static int flockCheckReservedLock(sqlite3_file *id, int *pResOut){
       /* someone else might have it reserved */
       lrc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK); 
       if( IS_LOCK_ERROR(lrc) ){
-        pFile->lastErrno = tErrno;
+        storeLastErrno(pFile, tErrno);
         rc = lrc;
       }
     }
@@ -27516,7 +27812,7 @@ static int flockLock(sqlite3_file *id, int eFileLock) {
     /* didn't get, must be busy */
     rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);
     if( IS_LOCK_ERROR(rc) ){
-      pFile->lastErrno = tErrno;
+      storeLastErrno(pFile, tErrno);
     }
   } else {
     /* got it, set the type and return ok */
@@ -27545,7 +27841,7 @@ static int flockUnlock(sqlite3_file *id, int eFileLock) {
   
   assert( pFile );
   OSTRACE(("UNLOCK  %d %d was %d pid=%d (flock)\n", pFile->h, eFileLock,
-           pFile->eFileLock, getpid()));
+           pFile->eFileLock, osGetpid(0)));
   assert( eFileLock<=SHARED_LOCK );
   
   /* no-op if possible */
@@ -27606,7 +27902,7 @@ static int flockClose(sqlite3_file *id) {
 ** to a non-zero value otherwise *pResOut is set to zero.  The return value
 ** is set to SQLITE_OK unless an I/O error occurs during lock checking.
 */
-static int semCheckReservedLock(sqlite3_file *id, int *pResOut) {
+static int semXCheckReservedLock(sqlite3_file *id, int *pResOut) {
   int rc = SQLITE_OK;
   int reserved = 0;
   unixFile *pFile = (unixFile*)id;
@@ -27628,7 +27924,7 @@ static int semCheckReservedLock(sqlite3_file *id, int *pResOut) {
       int tErrno = errno;
       if( EAGAIN != tErrno ){
         rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_CHECKRESERVEDLOCK);
-        pFile->lastErrno = tErrno;
+        storeLastErrno(pFile, tErrno);
       } else {
         /* someone else has the lock when we are in NO_LOCK */
         reserved = (pFile->eFileLock < SHARED_LOCK);
@@ -27673,7 +27969,7 @@ static int semCheckReservedLock(sqlite3_file *id, int *pResOut) {
 ** This routine will only increase a lock.  Use the sqlite3OsUnlock()
 ** routine to lower a locking level.
 */
-static int semLock(sqlite3_file *id, int eFileLock) {
+static int semXLock(sqlite3_file *id, int eFileLock) {
   unixFile *pFile = (unixFile*)id;
   sem_t *pSem = pFile->pInode->pSem;
   int rc = SQLITE_OK;
@@ -27706,14 +28002,14 @@ static int semLock(sqlite3_file *id, int eFileLock) {
 ** If the locking level of the file descriptor is already at or below
 ** the requested locking level, this routine is a no-op.
 */
-static int semUnlock(sqlite3_file *id, int eFileLock) {
+static int semXUnlock(sqlite3_file *id, int eFileLock) {
   unixFile *pFile = (unixFile*)id;
   sem_t *pSem = pFile->pInode->pSem;
 
   assert( pFile );
   assert( pSem );
   OSTRACE(("UNLOCK  %d %d was %d pid=%d (sem)\n", pFile->h, eFileLock,
-           pFile->eFileLock, getpid()));
+           pFile->eFileLock, osGetpid(0)));
   assert( eFileLock<=SHARED_LOCK );
   
   /* no-op if possible */
@@ -27732,7 +28028,7 @@ static int semUnlock(sqlite3_file *id, int eFileLock) {
     int rc, tErrno = errno;
     rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK);
     if( IS_LOCK_ERROR(rc) ){
-      pFile->lastErrno = tErrno;
+      storeLastErrno(pFile, tErrno);
     }
     return rc; 
   }
@@ -27743,10 +28039,10 @@ static int semUnlock(sqlite3_file *id, int eFileLock) {
 /*
  ** Close a file.
  */
-static int semClose(sqlite3_file *id) {
+static int semXClose(sqlite3_file *id) {
   if( id ){
     unixFile *pFile = (unixFile*)id;
-    semUnlock(id, NO_LOCK);
+    semXUnlock(id, NO_LOCK);
     assert( pFile );
     unixEnterMutex();
     releaseInodeInfo(pFile);
@@ -27834,7 +28130,7 @@ static int afpSetLock(
                     setLockFlag ? SQLITE_IOERR_LOCK : SQLITE_IOERR_UNLOCK);
 #endif /* SQLITE_IGNORE_AFP_LOCK_ERRORS */
     if( IS_LOCK_ERROR(rc) ){
-      pFile->lastErrno = tErrno;
+      storeLastErrno(pFile, tErrno);
     }
     return rc;
   } else {
@@ -27927,7 +28223,7 @@ static int afpLock(sqlite3_file *id, int eFileLock){
   assert( pFile );
   OSTRACE(("LOCK    %d %s was %s(%s,%d) pid=%d (afp)\n", pFile->h,
            azFileLock(eFileLock), azFileLock(pFile->eFileLock),
-           azFileLock(pInode->eFileLock), pInode->nShared , getpid()));
+           azFileLock(pInode->eFileLock), pInode->nShared , osGetpid(0)));
 
   /* If there is already a lock of this type or more restrictive on the
   ** unixFile, do nothing. Don't use the afp_end_lock: exit path, as
@@ -28017,7 +28313,7 @@ static int afpLock(sqlite3_file *id, int eFileLock){
     lrc2 = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 0);
     
     if( IS_LOCK_ERROR(lrc1) ) {
-      pFile->lastErrno = lrc1Errno;
+      storeLastErrno(pFile, lrc1Errno);
       rc = lrc1;
       goto afp_end_lock;
     } else if( IS_LOCK_ERROR(lrc2) ){
@@ -28113,7 +28409,7 @@ static int afpUnlock(sqlite3_file *id, int eFileLock) {
   assert( pFile );
   OSTRACE(("UNLOCK  %d %d was %d(%d,%d) pid=%d (afp)\n", pFile->h, eFileLock,
            pFile->eFileLock, pFile->pInode->eFileLock, pFile->pInode->nShared,
-           getpid()));
+           osGetpid(0)));
 
   assert( eFileLock<=SHARED_LOCK );
   if( pFile->eFileLock<=eFileLock ){
@@ -28304,9 +28600,9 @@ static int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt){
     SimulateIOError( newOffset-- );
     if( newOffset!=offset ){
       if( newOffset == -1 ){
-        ((unixFile*)id)->lastErrno = errno;
+        storeLastErrno((unixFile*)id, errno);
       }else{
-        ((unixFile*)id)->lastErrno = 0;
+        storeLastErrno((unixFile*)id, 0);
       }
       return -1;
     }
@@ -28316,7 +28612,7 @@ static int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt){
     if( got<0 ){
       if( errno==EINTR ){ got = 1; continue; }
       prior = 0;
-      ((unixFile*)id)->lastErrno = errno;
+      storeLastErrno((unixFile*)id,  errno);
       break;
     }else if( got>0 ){
       cnt -= got;
@@ -28381,7 +28677,7 @@ static int unixRead(
     /* lastErrno set by seekAndRead */
     return SQLITE_IOERR_READ;
   }else{
-    pFile->lastErrno = 0; /* not a system error */
+    storeLastErrno(pFile, 0);   /* not a system error */
     /* Unread parts of the buffer must be zero-filled */
     memset(&((char*)pBuf)[got], 0, amt-got);
     return SQLITE_IOERR_SHORT_READ;
@@ -28410,9 +28706,9 @@ static int seekAndWriteFd(
   TIMER_START;
 
 #if defined(USE_PREAD)
-  do{ rc = osPwrite(fd, pBuf, nBuf, iOff); }while( rc<0 && errno==EINTR );
+  do{ rc = (int)osPwrite(fd, pBuf, nBuf, iOff); }while( rc<0 && errno==EINTR );
 #elif defined(USE_PREAD64)
-  do{ rc = osPwrite64(fd, pBuf, nBuf, iOff);}while( rc<0 && errno==EINTR);
+  do{ rc = (int)osPwrite64(fd, pBuf, nBuf, iOff);}while( rc<0 && errno==EINTR);
 #else
   do{
     i64 iSeek = lseek(fd, iOff, SEEK_SET);
@@ -28522,7 +28818,7 @@ static int unixWrite(
       /* lastErrno set by seekAndWrite */
       return SQLITE_IOERR_WRITE;
     }else{
-      pFile->lastErrno = 0; /* not a system error */
+      storeLastErrno(pFile, 0); /* not a system error */
       return SQLITE_FULL;
     }
   }
@@ -28731,7 +29027,7 @@ static int unixSync(sqlite3_file *id, int flags){
   rc = full_fsync(pFile->h, isFullsync, isDataOnly);
   SimulateIOError( rc=1 );
   if( rc ){
-    pFile->lastErrno = errno;
+    storeLastErrno(pFile, errno);
     return unixLogError(SQLITE_IOERR_FSYNC, "full_fsync", pFile->zPath);
   }
 
@@ -28775,7 +29071,7 @@ static int unixTruncate(sqlite3_file *id, i64 nByte){
 
   rc = robust_ftruncate(pFile->h, nByte);
   if( rc ){
-    pFile->lastErrno = errno;
+    storeLastErrno(pFile, errno);
     return unixLogError(SQLITE_IOERR_TRUNCATE, "ftruncate", pFile->zPath);
   }else{
 #ifdef SQLITE_DEBUG
@@ -28815,7 +29111,7 @@ static int unixFileSize(sqlite3_file *id, i64 *pSize){
   rc = osFstat(((unixFile*)id)->h, &buf);
   SimulateIOError( rc=1 );
   if( rc!=0 ){
-    ((unixFile*)id)->lastErrno = errno;
+    storeLastErrno((unixFile*)id, errno);
     return SQLITE_IOERR_FSTAT;
   }
   *pSize = buf.st_size;
@@ -28851,7 +29147,9 @@ static int fcntlSizeHint(unixFile *pFile, i64 nByte){
     i64 nSize;                    /* Required file size */
     struct stat buf;              /* Used to hold return values of fstat() */
    
-    if( osFstat(pFile->h, &buf) ) return SQLITE_IOERR_FSTAT;
+    if( osFstat(pFile->h, &buf) ){
+      return SQLITE_IOERR_FSTAT;
+    }
 
     nSize = ((nByte+pFile->szChunk-1) / pFile->szChunk) * pFile->szChunk;
     if( nSize>(i64)buf.st_size ){
@@ -28898,7 +29196,7 @@ static int fcntlSizeHint(unixFile *pFile, i64 nByte){
     int rc;
     if( pFile->szChunk<=0 ){
       if( robust_ftruncate(pFile->h, nByte) ){
-        pFile->lastErrno = errno;
+        storeLastErrno(pFile, errno);
         return unixLogError(SQLITE_IOERR_TRUNCATE, "ftruncate", pFile->zPath);
       }
     }
@@ -28936,11 +29234,15 @@ static int unixGetTempname(int nBuf, char *zBuf);
 static int unixFileControl(sqlite3_file *id, int op, void *pArg){
   unixFile *pFile = (unixFile*)id;
   switch( op ){
+    case SQLITE_FCNTL_WAL_BLOCK: {
+      /* pFile->ctrlFlags |= UNIXFILE_BLOCK; // Deferred feature */
+      return SQLITE_OK;
+    }
     case SQLITE_FCNTL_LOCKSTATE: {
       *(int*)pArg = pFile->eFileLock;
       return SQLITE_OK;
     }
-    case SQLITE_LAST_ERRNO: {
+    case SQLITE_FCNTL_LAST_ERRNO: {
       *(int*)pArg = pFile->lastErrno;
       return SQLITE_OK;
     }
@@ -28968,7 +29270,7 @@ static int unixFileControl(sqlite3_file *id, int op, void *pArg){
       return SQLITE_OK;
     }
     case SQLITE_FCNTL_TEMPFILENAME: {
-      char *zTFile = sqlite3_malloc( pFile->pVfs->mxPathname );
+      char *zTFile = sqlite3_malloc64( pFile->pVfs->mxPathname );
       if( zTFile ){
         unixGetTempname(pFile->pVfs->mxPathname, zTFile);
         *(char**)pArg = zTFile;
@@ -29009,8 +29311,8 @@ static int unixFileControl(sqlite3_file *id, int op, void *pArg){
     }
 #endif
 #if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
-    case SQLITE_SET_LOCKPROXYFILE:
-    case SQLITE_GET_LOCKPROXYFILE: {
+    case SQLITE_FCNTL_SET_LOCKPROXYFILE:
+    case SQLITE_FCNTL_GET_LOCKPROXYFILE: {
       return proxyFileControl(id,op,pArg);
     }
 #endif /* SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__) */
@@ -29150,7 +29452,9 @@ static int unixDeviceCharacteristics(sqlite3_file *id){
 ** Instead, it should be called via macro osGetpagesize().
 */
 static int unixGetpagesize(void){
-#if defined(_BSD_SOURCE)
+#if OS_VXWORKS
+  return 1024;
+#elif defined(_BSD_SOURCE)
   return getpagesize();
 #else
   return (int)sysconf(_SC_PAGESIZE);
@@ -29243,15 +29547,17 @@ struct unixShm {
 ** otherwise.
 */
 static int unixShmSystemLock(
-  unixShmNode *pShmNode, /* Apply locks to this open shared-memory segment */
+  unixFile *pFile,       /* Open connection to the WAL file */
   int lockType,          /* F_UNLCK, F_RDLCK, or F_WRLCK */
   int ofst,              /* First byte of the locking range */
   int n                  /* Number of bytes to lock */
 ){
-  struct flock f;       /* The posix advisory locking structure */
-  int rc = SQLITE_OK;   /* Result code form fcntl() */
+  unixShmNode *pShmNode; /* Apply locks to this open shared-memory segment */
+  struct flock f;        /* The posix advisory locking structure */
+  int rc = SQLITE_OK;    /* Result code form fcntl() */
 
   /* Access to the unixShmNode object is serialized by the caller */
+  pShmNode = pFile->pInode->pShmNode;
   assert( sqlite3_mutex_held(pShmNode->mutex) || pShmNode->nRef==0 );
 
   /* Shared locks never span more than one byte */
@@ -29261,6 +29567,7 @@ static int unixShmSystemLock(
   assert( n>=1 && n<SQLITE_SHM_NLOCK );
 
   if( pShmNode->h>=0 ){
+    int lkType;
     /* Initialize the locking parameters */
     memset(&f, 0, sizeof(f));
     f.l_type = lockType;
@@ -29268,8 +29575,10 @@ static int unixShmSystemLock(
     f.l_start = ofst;
     f.l_len = n;
 
-    rc = osFcntl(pShmNode->h, F_SETLK, &f);
+    lkType = (pFile->ctrlFlags & UNIXFILE_BLOCK)!=0 ? F_SETLKW : F_SETLK;
+    rc = osFcntl(pShmNode->h, lkType, &f);
     rc = (rc!=(-1)) ? SQLITE_OK : SQLITE_BUSY;
+    pFile->ctrlFlags &= ~UNIXFILE_BLOCK;
   }
 
   /* Update the global lock state and do debug tracing */
@@ -29402,7 +29711,7 @@ static int unixOpenSharedMemory(unixFile *pDbFd){
   int nShmFilename;               /* Size of the SHM filename in bytes */
 
   /* Allocate space for the new unixShm object. */
-  p = sqlite3_malloc( sizeof(*p) );
+  p = sqlite3_malloc64( sizeof(*p) );
   if( p==0 ) return SQLITE_NOMEM;
   memset(p, 0, sizeof(*p));
   assert( pDbFd->pShm==0 );
@@ -29415,6 +29724,9 @@ static int unixOpenSharedMemory(unixFile *pDbFd){
   pShmNode = pInode->pShmNode;
   if( pShmNode==0 ){
     struct stat sStat;                 /* fstat() info for database file */
+#ifndef SQLITE_SHM_DIRECTORY
+    const char *zBasePath = pDbFd->zPath;
+#endif
 
     /* Call fstat() to figure out the permissions on the database file. If
     ** a new *-shm file is created, an attempt will be made to create it
@@ -29428,9 +29740,9 @@ static int unixOpenSharedMemory(unixFile *pDbFd){
 #ifdef SQLITE_SHM_DIRECTORY
     nShmFilename = sizeof(SQLITE_SHM_DIRECTORY) + 31;
 #else
-    nShmFilename = 6 + (int)strlen(pDbFd->zPath);
+    nShmFilename = 6 + (int)strlen(zBasePath);
 #endif
-    pShmNode = sqlite3_malloc( sizeof(*pShmNode) + nShmFilename );
+    pShmNode = sqlite3_malloc64( sizeof(*pShmNode) + nShmFilename );
     if( pShmNode==0 ){
       rc = SQLITE_NOMEM;
       goto shm_open_err;
@@ -29442,7 +29754,7 @@ static int unixOpenSharedMemory(unixFile *pDbFd){
                      SQLITE_SHM_DIRECTORY "/sqlite-shm-%x-%x",
                      (u32)sStat.st_ino, (u32)sStat.st_dev);
 #else
-    sqlite3_snprintf(nShmFilename, zShmFilename, "%s-shm", pDbFd->zPath);
+    sqlite3_snprintf(nShmFilename, zShmFilename, "%s-shm", zBasePath);
     sqlite3FileSuffix3(pDbFd->zPath, zShmFilename);
 #endif
     pShmNode->h = -1;
@@ -29476,13 +29788,13 @@ static int unixOpenSharedMemory(unixFile *pDbFd){
       ** If not, truncate the file to zero length. 
       */
       rc = SQLITE_OK;
-      if( unixShmSystemLock(pShmNode, F_WRLCK, UNIX_SHM_DMS, 1)==SQLITE_OK ){
+      if( unixShmSystemLock(pDbFd, F_WRLCK, UNIX_SHM_DMS, 1)==SQLITE_OK ){
         if( robust_ftruncate(pShmNode->h, 0) ){
           rc = unixLogError(SQLITE_IOERR_SHMOPEN, "ftruncate", zShmFilename);
         }
       }
       if( rc==SQLITE_OK ){
-        rc = unixShmSystemLock(pShmNode, F_RDLCK, UNIX_SHM_DMS, 1);
+        rc = unixShmSystemLock(pDbFd, F_RDLCK, UNIX_SHM_DMS, 1);
       }
       if( rc ) goto shm_open_err;
     }
@@ -29640,7 +29952,7 @@ static int unixShmMap(
           goto shmpage_out;
         }
       }else{
-        pMem = sqlite3_malloc(szRegion);
+        pMem = sqlite3_malloc64(szRegion);
         if( pMem==0 ){
           rc = SQLITE_NOMEM;
           goto shmpage_out;
@@ -29714,7 +30026,7 @@ static int unixShmLock(
 
     /* Unlock the system-level locks */
     if( (mask & allMask)==0 ){
-      rc = unixShmSystemLock(pShmNode, F_UNLCK, ofst+UNIX_SHM_BASE, n);
+      rc = unixShmSystemLock(pDbFd, F_UNLCK, ofst+UNIX_SHM_BASE, n);
     }else{
       rc = SQLITE_OK;
     }
@@ -29742,7 +30054,7 @@ static int unixShmLock(
     /* Get shared locks at the system level, if necessary */
     if( rc==SQLITE_OK ){
       if( (allShared & mask)==0 ){
-        rc = unixShmSystemLock(pShmNode, F_RDLCK, ofst+UNIX_SHM_BASE, n);
+        rc = unixShmSystemLock(pDbFd, F_RDLCK, ofst+UNIX_SHM_BASE, n);
       }else{
         rc = SQLITE_OK;
       }
@@ -29767,7 +30079,7 @@ static int unixShmLock(
     ** also mark the local connection as being locked.
     */
     if( rc==SQLITE_OK ){
-      rc = unixShmSystemLock(pShmNode, F_WRLCK, ofst+UNIX_SHM_BASE, n);
+      rc = unixShmSystemLock(pDbFd, F_WRLCK, ofst+UNIX_SHM_BASE, n);
       if( rc==SQLITE_OK ){
         assert( (p->sharedMask & mask)==0 );
         p->exclMask |= mask;
@@ -29776,7 +30088,7 @@ static int unixShmLock(
   }
   sqlite3_mutex_leave(pShmNode->mutex);
   OSTRACE(("SHM-LOCK shmid-%d, pid-%d got %03x,%03x\n",
-           p->id, getpid(), p->sharedMask, p->exclMask));
+           p->id, osGetpid(0), p->sharedMask, p->exclMask));
   return rc;
 }
 
@@ -29835,7 +30147,9 @@ static int unixShmUnmap(
   assert( pShmNode->nRef>0 );
   pShmNode->nRef--;
   if( pShmNode->nRef==0 ){
-    if( deleteFlag && pShmNode->h>=0 ) osUnlink(pShmNode->zFilename);
+    if( deleteFlag && pShmNode->h>=0 ){
+      osUnlink(pShmNode->zFilename);
+    }
     unixShmPurge(pDbFd);
   }
   unixLeaveMutex();
@@ -30112,7 +30426,7 @@ static int unixUnfetch(sqlite3_file *fd, i64 iOff, void *p){
 **   *  An I/O method finder function called FINDER that returns a pointer
 **      to the METHOD object in the previous bullet.
 */
-#define IOMETHODS(FINDER, METHOD, VERSION, CLOSE, LOCK, UNLOCK, CKLOCK, SHMMAP) \
+#define IOMETHODS(FINDER,METHOD,VERSION,CLOSE,LOCK,UNLOCK,CKLOCK,SHMMAP)     \
 static const sqlite3_io_methods METHOD = {                                   \
    VERSION,                    /* iVersion */                                \
    CLOSE,                      /* xClose */                                  \
@@ -30177,7 +30491,7 @@ IOMETHODS(
   0                         /* xShmMap method */
 )
 
-#if SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORKS
+#if SQLITE_ENABLE_LOCKING_STYLE
 IOMETHODS(
   flockIoFinder,            /* Finder function name */
   flockIoMethods,           /* sqlite3_io_methods object name */
@@ -30195,10 +30509,10 @@ IOMETHODS(
   semIoFinder,              /* Finder function name */
   semIoMethods,             /* sqlite3_io_methods object name */
   1,                        /* shared memory is disabled */
-  semClose,                 /* xClose method */
-  semLock,                  /* xLock method */
-  semUnlock,                /* xUnlock method */
-  semCheckReservedLock,     /* xCheckReservedLock method */
+  semXClose,                /* xClose method */
+  semXLock,                 /* xLock method */
+  semXUnlock,               /* xUnlock method */
+  semXCheckReservedLock,    /* xCheckReservedLock method */
   0                         /* xShmMap method */
 )
 #endif
@@ -30322,15 +30636,13 @@ static const sqlite3_io_methods
 
 #endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */
 
-#if OS_VXWORKS && SQLITE_ENABLE_LOCKING_STYLE
-/* 
-** This "finder" function attempts to determine the best locking strategy 
-** for the database file "filePath".  It then returns the sqlite3_io_methods
-** object that implements that strategy.
-**
-** This is for VXWorks only.
+#if OS_VXWORKS
+/*
+** This "finder" function for VxWorks checks to see if posix advisory
+** locking works.  If it does, then that is what is used.  If it does not
+** work, then fallback to named semaphore locking.
 */
-static const sqlite3_io_methods *autolockIoFinderImpl(
+static const sqlite3_io_methods *vxworksIoFinderImpl(
   const char *filePath,    /* name of the database file */
   unixFile *pNew           /* the open file object */
 ){
@@ -30356,9 +30668,9 @@ static const sqlite3_io_methods *autolockIoFinderImpl(
   }
 }
 static const sqlite3_io_methods 
-  *(*const autolockIoFinder)(const char*,unixFile*) = autolockIoFinderImpl;
+  *(*const vxworksIoFinder)(const char*,unixFile*) = vxworksIoFinderImpl;
 
-#endif /* OS_VXWORKS && SQLITE_ENABLE_LOCKING_STYLE */
+#endif /* OS_VXWORKS */
 
 /*
 ** An abstract type for a pointer to an IO method finder function:
@@ -30477,7 +30789,7 @@ static int fillInUnixFile(
     ** the afpLockingContext.
     */
     afpLockingContext *pCtx;
-    pNew->lockingContext = pCtx = sqlite3_malloc( sizeof(*pCtx) );
+    pNew->lockingContext = pCtx = sqlite3_malloc64( sizeof(*pCtx) );
     if( pCtx==0 ){
       rc = SQLITE_NOMEM;
     }else{
@@ -30507,7 +30819,7 @@ static int fillInUnixFile(
     int nFilename;
     assert( zFilename!=0 );
     nFilename = (int)strlen(zFilename) + 6;
-    zLockFile = (char *)sqlite3_malloc(nFilename);
+    zLockFile = (char *)sqlite3_malloc64(nFilename);
     if( zLockFile==0 ){
       rc = SQLITE_NOMEM;
     }else{
@@ -30540,7 +30852,7 @@ static int fillInUnixFile(
   }
 #endif
   
-  pNew->lastErrno = 0;
+  storeLastErrno(pNew, 0);
 #if OS_VXWORKS
   if( rc!=SQLITE_OK ){
     if( h>=0 ) robust_close(pNew, h, __LINE__);
@@ -30871,8 +31183,8 @@ static int unixOpen(
   ** the same instant might all reset the PRNG.  But multiple resets
   ** are harmless.
   */
-  if( randomnessPid!=getpid() ){
-    randomnessPid = getpid();
+  if( randomnessPid!=osGetpid(0) ){
+    randomnessPid = osGetpid(0);
     sqlite3_randomness(0,0);
   }
 
@@ -30884,7 +31196,7 @@ static int unixOpen(
     if( pUnused ){
       fd = pUnused->fd;
     }else{
-      pUnused = sqlite3_malloc(sizeof(*pUnused));
+      pUnused = sqlite3_malloc64(sizeof(*pUnused));
       if( !pUnused ){
         return SQLITE_NOMEM;
       }
@@ -30988,13 +31300,16 @@ static int unixOpen(
   
 #if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE
   if( fstatfs(fd, &fsInfo) == -1 ){
-    ((unixFile*)pFile)->lastErrno = errno;
+    storeLastErrno(p, errno);
     robust_close(p, fd, __LINE__);
     return SQLITE_IOERR_ACCESS;
   }
   if (0 == strncmp("msdos", fsInfo.f_fstypename, 5)) {
     ((unixFile*)pFile)->fsFlags |= SQLITE_FSFLAGS_IS_MSDOS;
   }
+  if (0 == strncmp("exfat", fsInfo.f_fstypename, 5)) {
+    ((unixFile*)pFile)->fsFlags |= SQLITE_FSFLAGS_IS_MSDOS;
+  }
 #endif
 
   /* Set up appropriate ctrlFlags */
@@ -31017,19 +31332,6 @@ static int unixOpen(
     if( envforce!=NULL ){
       useProxy = atoi(envforce)>0;
     }else{
-      if( statfs(zPath, &fsInfo) == -1 ){
-        /* In theory, the close(fd) call is sub-optimal. If the file opened
-        ** with fd is a database file, and there are other connections open
-        ** on that file that are currently holding advisory locks on it,
-        ** then the call to close() will cancel those locks. In practice,
-        ** we're assuming that statfs() doesn't fail very often. At least
-        ** not while other file descriptors opened by the same process on
-        ** the same file are working.  */
-        p->lastErrno = errno;
-        robust_close(p, fd, __LINE__);
-        rc = SQLITE_IOERR_ACCESS;
-        goto open_finished;
-      }
       useProxy = !(fsInfo.f_flags&MNT_LOCAL);
     }
     if( useProxy ){
@@ -31273,8 +31575,8 @@ static int unixRandomness(sqlite3_vfs *NotUsed, int nBuf, char *zBuf){
   ** tests repeatable.
   */
   memset(zBuf, 0, nBuf);
-  randomnessPid = getpid();  
-#if !defined(SQLITE_TEST)
+  randomnessPid = osGetpid(0);  
+#if !defined(SQLITE_TEST) && !defined(SQLITE_OMIT_RANDOMNESS)
   {
     int fd, got;
     fd = robust_open("/dev/urandom", O_RDONLY, 0);
@@ -31455,9 +31757,10 @@ static int unixGetLastError(sqlite3_vfs *NotUsed, int NotUsed2, char *NotUsed3){
 **
 ** C APIs
 **
-**  sqlite3_file_control(db, dbname, SQLITE_SET_LOCKPROXYFILE,
+**  sqlite3_file_control(db, dbname, SQLITE_FCNTL_SET_LOCKPROXYFILE,
 **                       <proxy_path> | ":auto:");
-**  sqlite3_file_control(db, dbname, SQLITE_GET_LOCKPROXYFILE, &<proxy_path>);
+**  sqlite3_file_control(db, dbname, SQLITE_FCNTL_GET_LOCKPROXYFILE,
+**                       &<proxy_path>);
 **
 **
 ** SQL pragmas
@@ -31550,7 +31853,7 @@ static int unixGetLastError(sqlite3_vfs *NotUsed, int NotUsed2, char *NotUsed3){
 ** setting the environment variable SQLITE_FORCE_PROXY_LOCKING to 1 will
 ** force proxy locking to be used for every database file opened, and 0
 ** will force automatic proxy locking to be disabled for all database
-** files (explicitly calling the SQLITE_SET_LOCKPROXYFILE pragma or
+** files (explicitly calling the SQLITE_FCNTL_SET_LOCKPROXYFILE pragma or
 ** sqlite_file_control API is not affected by SQLITE_FORCE_PROXY_LOCKING).
 */
 
@@ -31571,6 +31874,7 @@ struct proxyLockingContext {
   char *lockProxyPath;         /* Name of the proxy lock file */
   char *dbPath;                /* Name of the open file */
   int conchHeld;               /* 1 if the conch is held, -1 if lockless */
+  int nFails;                  /* Number of conch taking failures */
   void *oldLockingContext;     /* Original lockingcontext to restore on close */
   sqlite3_io_methods const *pOldMethod;     /* Original I/O methods for close */
 };
@@ -31592,7 +31896,7 @@ static int proxyGetLockPath(const char *dbPath, char *lPath, size_t maxLen){
   {
     if( !confstr(_CS_DARWIN_USER_TEMP_DIR, lPath, maxLen) ){
       OSTRACE(("GETLOCKPATH  failed %s errno=%d pid=%d\n",
-               lPath, errno, getpid()));
+               lPath, errno, osGetpid(0)));
       return SQLITE_IOERR_LOCK;
     }
     len = strlcat(lPath, "sqliteplocks", maxLen);    
@@ -31614,7 +31918,7 @@ static int proxyGetLockPath(const char *dbPath, char *lPath, size_t maxLen){
   }
   lPath[i+len]='\0';
   strlcat(lPath, ":auto:", maxLen);
-  OSTRACE(("GETLOCKPATH  proxy lock path=%s pid=%d\n", lPath, getpid()));
+  OSTRACE(("GETLOCKPATH  proxy lock path=%s pid=%d\n", lPath, osGetpid(0)));
   return SQLITE_OK;
 }
 
@@ -31641,7 +31945,7 @@ static int proxyCreateLockPath(const char *lockPath){
           if( err!=EEXIST ) {
             OSTRACE(("CREATELOCKPATH  FAILED creating %s, "
                      "'%s' proxy lock path=%s pid=%d\n",
-                     buf, strerror(err), lockPath, getpid()));
+                     buf, strerror(err), lockPath, osGetpid(0)));
             return err;
           }
         }
@@ -31650,7 +31954,7 @@ static int proxyCreateLockPath(const char *lockPath){
     }
     buf[i] = lockPath[i];
   }
-  OSTRACE(("CREATELOCKPATH  proxy lock path=%s pid=%d\n", lockPath, getpid()));
+  OSTRACE(("CREATELOCKPATH  proxy lock path=%s pid=%d\n", lockPath, osGetpid(0)));
   return 0;
 }
 
@@ -31684,7 +31988,7 @@ static int proxyCreateUnixFile(
   if( pUnused ){
     fd = pUnused->fd;
   }else{
-    pUnused = sqlite3_malloc(sizeof(*pUnused));
+    pUnused = sqlite3_malloc64(sizeof(*pUnused));
     if( !pUnused ){
       return SQLITE_NOMEM;
     }
@@ -31717,7 +32021,7 @@ static int proxyCreateUnixFile(
     }
   }
   
-  pNew = (unixFile *)sqlite3_malloc(sizeof(*pNew));
+  pNew = (unixFile *)sqlite3_malloc64(sizeof(*pNew));
   if( pNew==NULL ){
     rc = SQLITE_NOMEM;
     goto end_create_proxy;
@@ -31750,8 +32054,10 @@ SQLITE_API int sqlite3_hostid_num = 0;
 
 #define PROXY_HOSTIDLEN    16  /* conch file host id length */
 
+#ifdef HAVE_GETHOSTUUID
 /* Not always defined in the headers as it ought to be */
 extern int gethostuuid(uuid_t id, const struct timespec *wait);
+#endif
 
 /* get the host ID via gethostuuid(), pHostID must point to PROXY_HOSTIDLEN 
 ** bytes of writable memory.
@@ -31759,10 +32065,9 @@ extern int gethostuuid(uuid_t id, const struct timespec *wait);
 static int proxyGetHostID(unsigned char *pHostID, int *pError){
   assert(PROXY_HOSTIDLEN == sizeof(uuid_t));
   memset(pHostID, 0, PROXY_HOSTIDLEN);
-#if defined(__MAX_OS_X_VERSION_MIN_REQUIRED)\
-               && __MAC_OS_X_VERSION_MIN_REQUIRED<1050
+#ifdef HAVE_GETHOSTUUID
   {
-    static const struct timespec timeout = {1, 0}; /* 1 sec timeout */
+    struct timespec timeout = {1, 0}; /* 1 sec timeout */
     if( gethostuuid(pHostID, &timeout) ){
       int err = errno;
       if( pError ){
@@ -31877,7 +32182,7 @@ static int proxyConchLock(unixFile *pFile, uuid_t myHostID, int lockType){
        */
       struct stat buf;
       if( osFstat(conchFile->h, &buf) ){
-        pFile->lastErrno = errno;
+        storeLastErrno(pFile, errno);
         return SQLITE_IOERR_LOCK;
       }
       
@@ -31897,7 +32202,7 @@ static int proxyConchLock(unixFile *pFile, uuid_t myHostID, int lockType){
         char tBuf[PROXY_MAXCONCHLEN];
         int len = osPread(conchFile->h, tBuf, PROXY_MAXCONCHLEN, 0);
         if( len<0 ){
-          pFile->lastErrno = errno;
+          storeLastErrno(pFile, errno);
           return SQLITE_IOERR_LOCK;
         }
         if( len>PROXY_PATHINDEX && tBuf[0]==(char)PROXY_CONCHVERSION){
@@ -31917,7 +32222,7 @@ static int proxyConchLock(unixFile *pFile, uuid_t myHostID, int lockType){
       if( 0==proxyBreakConchLock(pFile, myHostID) ){
         rc = SQLITE_OK;
         if( lockType==EXCLUSIVE_LOCK ){
-          rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, SHARED_LOCK);          
+          rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, SHARED_LOCK);
         }
         if( !rc ){
           rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, lockType);
@@ -31955,11 +32260,12 @@ static int proxyTakeConch(unixFile *pFile){
     int forceNewLockPath = 0;
     
     OSTRACE(("TAKECONCH  %d for %s pid=%d\n", conchFile->h,
-             (pCtx->lockProxyPath ? pCtx->lockProxyPath : ":auto:"), getpid()));
+             (pCtx->lockProxyPath ? pCtx->lockProxyPath : ":auto:"),
+             osGetpid(0)));
 
     rc = proxyGetHostID(myHostID, &pError);
     if( (rc&0xff)==SQLITE_IOERR ){
-      pFile->lastErrno = pError;
+      storeLastErrno(pFile, pError);
       goto end_takeconch;
     }
     rc = proxyConchLock(pFile, myHostID, SHARED_LOCK);
@@ -31970,7 +32276,7 @@ static int proxyTakeConch(unixFile *pFile){
     readLen = seekAndRead((unixFile*)conchFile, 0, readBuf, PROXY_MAXCONCHLEN);
     if( readLen<0 ){
       /* I/O error: lastErrno set by seekAndRead */
-      pFile->lastErrno = conchFile->lastErrno;
+      storeLastErrno(pFile, conchFile->lastErrno);
       rc = SQLITE_IOERR_READ;
       goto end_takeconch;
     }else if( readLen<=(PROXY_HEADERLEN+PROXY_HOSTIDLEN) || 
@@ -32043,7 +32349,7 @@ static int proxyTakeConch(unixFile *pFile){
           rc = proxyConchLock(pFile, myHostID, EXCLUSIVE_LOCK);
         }
       }else{
-        rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, EXCLUSIVE_LOCK);
+        rc = proxyConchLock(pFile, myHostID, EXCLUSIVE_LOCK);
       }
       if( rc==SQLITE_OK ){
         char writeBuffer[PROXY_MAXCONCHLEN];
@@ -32052,7 +32358,8 @@ static int proxyTakeConch(unixFile *pFile){
         writeBuffer[0] = (char)PROXY_CONCHVERSION;
         memcpy(&writeBuffer[PROXY_HEADERLEN], myHostID, PROXY_HOSTIDLEN);
         if( pCtx->lockProxyPath!=NULL ){
-          strlcpy(&writeBuffer[PROXY_PATHINDEX], pCtx->lockProxyPath, MAXPATHLEN);
+          strlcpy(&writeBuffer[PROXY_PATHINDEX], pCtx->lockProxyPath,
+                  MAXPATHLEN);
         }else{
           strlcpy(&writeBuffer[PROXY_PATHINDEX], tempLockPath, MAXPATHLEN);
         }
@@ -32164,7 +32471,7 @@ static int proxyReleaseConch(unixFile *pFile){
   conchFile = pCtx->conchFile;
   OSTRACE(("RELEASECONCH  %d for %s pid=%d\n", conchFile->h,
            (pCtx->lockProxyPath ? pCtx->lockProxyPath : ":auto:"), 
-           getpid()));
+           osGetpid(0)));
   if( pCtx->conchHeld>0 ){
     rc = conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, NO_LOCK);
   }
@@ -32176,7 +32483,7 @@ static int proxyReleaseConch(unixFile *pFile){
 
 /*
 ** Given the name of a database file, compute the name of its conch file.
-** Store the conch filename in memory obtained from sqlite3_malloc().
+** Store the conch filename in memory obtained from sqlite3_malloc64().
 ** Make *pConchPath point to the new name.  Return SQLITE_OK on success
 ** or SQLITE_NOMEM if unable to obtain memory.
 **
@@ -32192,7 +32499,7 @@ static int proxyCreateConchPathname(char *dbPath, char **pConchPath){
 
   /* Allocate space for the conch filename and initialize the name to
   ** the name of the original database file. */  
-  *pConchPath = conchPath = (char *)sqlite3_malloc(len + 8);
+  *pConchPath = conchPath = (char *)sqlite3_malloc64(len + 8);
   if( conchPath==0 ){
     return SQLITE_NOMEM;
   }
@@ -32264,7 +32571,8 @@ static int proxyGetDbPathForUnixFile(unixFile *pFile, char *dbPath){
     /* afp style keeps a reference to the db path in the filePath field 
     ** of the struct */
     assert( (int)strlen((char*)pFile->lockingContext)<=MAXPATHLEN );
-    strlcpy(dbPath, ((afpLockingContext *)pFile->lockingContext)->dbPath, MAXPATHLEN);
+    strlcpy(dbPath, ((afpLockingContext *)pFile->lockingContext)->dbPath,
+            MAXPATHLEN);
   } else
 #endif
   if( pFile->pMethod == &dotlockIoMethods ){
@@ -32305,9 +32613,9 @@ static int proxyTransformUnixFile(unixFile *pFile, const char *path) {
   }
   
   OSTRACE(("TRANSPROXY  %d for %s pid=%d\n", pFile->h,
-           (lockPath ? lockPath : ":auto:"), getpid()));
+           (lockPath ? lockPath : ":auto:"), osGetpid(0)));
 
-  pCtx = sqlite3_malloc( sizeof(*pCtx) );
+  pCtx = sqlite3_malloc64( sizeof(*pCtx) );
   if( pCtx==0 ){
     return SQLITE_NOMEM;
   }
@@ -32377,7 +32685,7 @@ static int proxyTransformUnixFile(unixFile *pFile, const char *path) {
 */
 static int proxyFileControl(sqlite3_file *id, int op, void *pArg){
   switch( op ){
-    case SQLITE_GET_LOCKPROXYFILE: {
+    case SQLITE_FCNTL_GET_LOCKPROXYFILE: {
       unixFile *pFile = (unixFile*)id;
       if( pFile->pMethod == &proxyIoMethods ){
         proxyLockingContext *pCtx = (proxyLockingContext*)pFile->lockingContext;
@@ -32392,13 +32700,16 @@ static int proxyFileControl(sqlite3_file *id, int op, void *pArg){
       }
       return SQLITE_OK;
     }
-    case SQLITE_SET_LOCKPROXYFILE: {
+    case SQLITE_FCNTL_SET_LOCKPROXYFILE: {
       unixFile *pFile = (unixFile*)id;
       int rc = SQLITE_OK;
       int isProxyStyle = (pFile->pMethod == &proxyIoMethods);
       if( pArg==NULL || (const char *)pArg==0 ){
         if( isProxyStyle ){
-          /* turn off proxy locking - not supported */
+          /* turn off proxy locking - not supported.  If support is added for
+          ** switching proxy locking mode off then it will need to fail if
+          ** the journal mode is WAL mode. 
+          */
           rc = SQLITE_ERROR /*SQLITE_PROTOCOL? SQLITE_MISUSE?*/;
         }else{
           /* turn off proxy locking - already off - NOOP */
@@ -32589,7 +32900,7 @@ static int proxyClose(sqlite3_file *id) {
 ** necessarily been initialized when this routine is called, and so they
 ** should not be used.
 */
-SQLITE_API int sqlite3_os_init(void){ 
+SQLITE_API int SQLITE_STDCALL sqlite3_os_init(void){ 
   /* 
   ** The following macro defines an initializer for an sqlite3_vfs object.
   ** The name of the VFS is NAME.  The pAppData is a pointer to a pointer
@@ -32643,8 +32954,10 @@ SQLITE_API int sqlite3_os_init(void){
   ** array cannot be const.
   */
   static sqlite3_vfs aVfs[] = {
-#if SQLITE_ENABLE_LOCKING_STYLE && (OS_VXWORKS || defined(__APPLE__))
+#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
     UNIXVFS("unix",          autolockIoFinder ),
+#elif OS_VXWORKS
+    UNIXVFS("unix",          vxworksIoFinder ),
 #else
     UNIXVFS("unix",          posixIoFinder ),
 #endif
@@ -32654,11 +32967,11 @@ SQLITE_API int sqlite3_os_init(void){
 #if OS_VXWORKS
     UNIXVFS("unix-namedsem", semIoFinder ),
 #endif
-#if SQLITE_ENABLE_LOCKING_STYLE
+#if SQLITE_ENABLE_LOCKING_STYLE || OS_VXWORKS
     UNIXVFS("unix-posix",    posixIoFinder ),
-#if !OS_VXWORKS
-    UNIXVFS("unix-flock",    flockIoFinder ),
 #endif
+#if SQLITE_ENABLE_LOCKING_STYLE
+    UNIXVFS("unix-flock",    flockIoFinder ),
 #endif
 #if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
     UNIXVFS("unix-afp",      afpIoFinder ),
@@ -32686,7 +32999,7 @@ SQLITE_API int sqlite3_os_init(void){
 ** to release dynamically allocated objects.  But not on unix.
 ** This routine is a no-op for unix.
 */
-SQLITE_API int sqlite3_os_end(void){ 
+SQLITE_API int SQLITE_STDCALL sqlite3_os_end(void){ 
   return SQLITE_OK; 
 }
  
@@ -32746,16 +33059,6 @@ SQLITE_API int sqlite3_os_end(void){
 # error "The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead."
 #endif
 
-#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)
-# ifndef SQLITE_DEBUG_OS_TRACE
-#   define SQLITE_DEBUG_OS_TRACE 0
-# endif
-  int sqlite3OSTrace = SQLITE_DEBUG_OS_TRACE;
-# define OSTRACE(X)          if( sqlite3OSTrace ) sqlite3DebugPrintf X
-#else
-# define OSTRACE(X)
-#endif
-
 /*
 ** Macros for performance tracing.  Normally turned off.  Only works
 ** on i486 hardware.
@@ -33099,8 +33402,10 @@ WINBASEAPI LPVOID WINAPI MapViewOfFile(HANDLE, DWORD, DWORD, DWORD, SIZE_T);
 #endif /* SQLITE_OS_WINRT */
 
 /*
-** This file mapping API is common to both Win32 and WinRT.
+** These file mapping APIs are common to both Win32 and WinRT.
 */
+
+WINBASEAPI BOOL WINAPI FlushViewOfFile(LPCVOID, SIZE_T);
 WINBASEAPI BOOL WINAPI UnmapViewOfFile(LPCVOID);
 #endif /* SQLITE_WIN32_FILEMAPPING_API */
 
@@ -33968,6 +34273,32 @@ static struct win_syscall {
         SQLITE_WIN32_VOLATILE*, LONG,LONG))aSyscall[76].pCurrent)
 #endif /* defined(InterlockedCompareExchange) */
 
+#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_WIN32_USE_UUID
+  { "UuidCreate",               (SYSCALL)UuidCreate,             0 },
+#else
+  { "UuidCreate",               (SYSCALL)0,                      0 },
+#endif
+
+#define osUuidCreate ((RPC_STATUS(RPC_ENTRY*)(UUID*))aSyscall[77].pCurrent)
+
+#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_WIN32_USE_UUID
+  { "UuidCreateSequential",     (SYSCALL)UuidCreateSequential,   0 },
+#else
+  { "UuidCreateSequential",     (SYSCALL)0,                      0 },
+#endif
+
+#define osUuidCreateSequential \
+        ((RPC_STATUS(RPC_ENTRY*)(UUID*))aSyscall[78].pCurrent)
+
+#if !defined(SQLITE_NO_SYNC) && SQLITE_MAX_MMAP_SIZE>0
+  { "FlushViewOfFile",          (SYSCALL)FlushViewOfFile,        0 },
+#else
+  { "FlushViewOfFile",          (SYSCALL)0,                      0 },
+#endif
+
+#define osFlushViewOfFile \
+        ((BOOL(WINAPI*)(LPCVOID,SIZE_T))aSyscall[79].pCurrent)
+
 }; /* End of the overrideable system calls */
 
 /*
@@ -34061,7 +34392,7 @@ static const char *winNextSystemCall(sqlite3_vfs *p, const char *zName){
 ** "pnLargest" argument, if non-zero, will be used to return the size of the
 ** largest committed free block in the heap, in bytes.
 */
-SQLITE_API int sqlite3_win32_compact_heap(LPUINT pnLargest){
+SQLITE_API int SQLITE_STDCALL sqlite3_win32_compact_heap(LPUINT pnLargest){
   int rc = SQLITE_OK;
   UINT nLargest = 0;
   HANDLE hHeap;
@@ -34101,7 +34432,7 @@ SQLITE_API int sqlite3_win32_compact_heap(LPUINT pnLargest){
 ** the sqlite3_memory_used() function does not return zero, SQLITE_BUSY will
 ** be returned and no changes will be made to the Win32 native heap.
 */
-SQLITE_API int sqlite3_win32_reset_heap(){
+SQLITE_API int SQLITE_STDCALL sqlite3_win32_reset_heap(){
   int rc;
   MUTEX_LOGIC( sqlite3_mutex *pMaster; ) /* The main static mutex */
   MUTEX_LOGIC( sqlite3_mutex *pMem; )    /* The memsys static mutex */
@@ -34146,7 +34477,7 @@ SQLITE_API int sqlite3_win32_reset_heap(){
 ** (if available).
 */
 
-SQLITE_API void sqlite3_win32_write_debug(const char *zBuf, int nBuf){
+SQLITE_API void SQLITE_STDCALL sqlite3_win32_write_debug(const char *zBuf, int nBuf){
   char zDbgBuf[SQLITE_WIN32_DBG_BUF_SIZE];
   int nMin = MIN(nBuf, (SQLITE_WIN32_DBG_BUF_SIZE - 1)); /* may be negative. */
   if( nMin<-1 ) nMin = -1; /* all negative values become -1. */
@@ -34186,7 +34517,7 @@ SQLITE_API void sqlite3_win32_write_debug(const char *zBuf, int nBuf){
 static HANDLE sleepObj = NULL;
 #endif
 
-SQLITE_API void sqlite3_win32_sleep(DWORD milliseconds){
+SQLITE_API void SQLITE_STDCALL sqlite3_win32_sleep(DWORD milliseconds){
 #if SQLITE_OS_WINRT
   if ( sleepObj==NULL ){
     sleepObj = osCreateEventExW(NULL, NULL, CREATE_EVENT_MANUAL_RESET,
@@ -34235,7 +34566,7 @@ SQLITE_PRIVATE DWORD sqlite3Win32Wait(HANDLE hObject){
 ** This function determines if the machine is running a version of Windows
 ** based on the NT kernel.
 */
-SQLITE_API int sqlite3_win32_is_nt(void){
+SQLITE_API int SQLITE_STDCALL sqlite3_win32_is_nt(void){
 #if SQLITE_OS_WINRT
   /*
   ** NOTE: The WinRT sub-platform is always assumed to be based on the NT
@@ -34589,7 +34920,7 @@ static char *winUnicodeToMbcs(LPCWSTR zWideFilename){
 ** Convert multibyte character string to UTF-8.  Space to hold the
 ** returned string is obtained from sqlite3_malloc().
 */
-SQLITE_API char *sqlite3_win32_mbcs_to_utf8(const char *zFilename){
+SQLITE_API char *SQLITE_STDCALL sqlite3_win32_mbcs_to_utf8(const char *zFilename){
   char *zFilenameUtf8;
   LPWSTR zTmpWide;
 
@@ -34606,7 +34937,7 @@ SQLITE_API char *sqlite3_win32_mbcs_to_utf8(const char *zFilename){
 ** Convert UTF-8 to multibyte character string.  Space to hold the
 ** returned string is obtained from sqlite3_malloc().
 */
-SQLITE_API char *sqlite3_win32_utf8_to_mbcs(const char *zFilename){
+SQLITE_API char *SQLITE_STDCALL sqlite3_win32_utf8_to_mbcs(const char *zFilename){
   char *zFilenameMbcs;
   LPWSTR zTmpWide;
 
@@ -34626,7 +34957,7 @@ SQLITE_API char *sqlite3_win32_utf8_to_mbcs(const char *zFilename){
 ** argument is the name of the directory to use.  The return value will be
 ** SQLITE_OK if successful.
 */
-SQLITE_API int sqlite3_win32_set_directory(DWORD type, LPCWSTR zValue){
+SQLITE_API int SQLITE_STDCALL sqlite3_win32_set_directory(DWORD type, LPCWSTR zValue){
   char **ppDirectory = 0;
 #ifndef SQLITE_OMIT_AUTOINIT
   int rc = sqlite3_initialize();
@@ -34851,11 +35182,11 @@ static int winRetryIoerr(int *pnRetry, DWORD *pError){
 /*
 ** Log a I/O error retry episode.
 */
-static void winLogIoerr(int nRetry){
+static void winLogIoerr(int nRetry, int lineno){
   if( nRetry ){
-    sqlite3_log(SQLITE_IOERR,
-      "delayed %dms for lock/sharing conflict",
-      winIoerrRetryDelay*nRetry*(nRetry+1)/2
+    sqlite3_log(SQLITE_NOTICE,
+      "delayed %dms for lock/sharing conflict at line %d",
+      winIoerrRetryDelay*nRetry*(nRetry+1)/2, lineno
     );
   }
 }
@@ -35335,7 +35666,8 @@ static int winClose(sqlite3_file *id){
   assert( pFile->pShm==0 );
 #endif
   assert( pFile->h!=NULL && pFile->h!=INVALID_HANDLE_VALUE );
-  OSTRACE(("CLOSE file=%p\n", pFile->h));
+  OSTRACE(("CLOSE pid=%lu, pFile=%p, file=%p\n",
+           osGetCurrentProcessId(), pFile, pFile->h));
 
 #if SQLITE_MAX_MMAP_SIZE>0
   winUnmapfile(pFile);
@@ -35364,7 +35696,8 @@ static int winClose(sqlite3_file *id){
     pFile->h = NULL;
   }
   OpenCounter(-1);
-  OSTRACE(("CLOSE file=%p, rc=%s\n", pFile->h, rc ? "ok" : "failed"));
+  OSTRACE(("CLOSE pid=%lu, pFile=%p, file=%p, rc=%s\n",
+           osGetCurrentProcessId(), pFile, pFile->h, rc ? "ok" : "failed"));
   return rc ? SQLITE_OK
             : winLogError(SQLITE_IOERR_CLOSE, osGetLastError(),
                           "winClose", pFile->zPath);
@@ -35392,7 +35725,8 @@ static int winRead(
   assert( amt>0 );
   assert( offset>=0 );
   SimulateIOError(return SQLITE_IOERR_READ);
-  OSTRACE(("READ file=%p, buffer=%p, amount=%d, offset=%lld, lock=%d\n",
+  OSTRACE(("READ pid=%lu, pFile=%p, file=%p, buffer=%p, amount=%d, "
+           "offset=%lld, lock=%d\n", osGetCurrentProcessId(), pFile,
            pFile->h, pBuf, amt, offset, pFile->locktype));
 
 #if SQLITE_MAX_MMAP_SIZE>0
@@ -35401,7 +35735,8 @@ static int winRead(
   if( offset<pFile->mmapSize ){
     if( offset+amt <= pFile->mmapSize ){
       memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], amt);
-      OSTRACE(("READ-MMAP file=%p, rc=SQLITE_OK\n", pFile->h));
+      OSTRACE(("READ-MMAP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",
+               osGetCurrentProcessId(), pFile, pFile->h));
       return SQLITE_OK;
     }else{
       int nCopy = (int)(pFile->mmapSize - offset);
@@ -35415,7 +35750,8 @@ static int winRead(
 
 #if SQLITE_OS_WINCE || defined(SQLITE_WIN32_NO_OVERLAPPED)
   if( winSeekFile(pFile, offset) ){
-    OSTRACE(("READ file=%p, rc=SQLITE_FULL\n", pFile->h));
+    OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_FULL\n",
+             osGetCurrentProcessId(), pFile, pFile->h));
     return SQLITE_FULL;
   }
   while( !osReadFile(pFile->h, pBuf, amt, &nRead, 0) ){
@@ -35429,19 +35765,22 @@ static int winRead(
     DWORD lastErrno;
     if( winRetryIoerr(&nRetry, &lastErrno) ) continue;
     pFile->lastErrno = lastErrno;
-    OSTRACE(("READ file=%p, rc=SQLITE_IOERR_READ\n", pFile->h));
+    OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_READ\n",
+             osGetCurrentProcessId(), pFile, pFile->h));
     return winLogError(SQLITE_IOERR_READ, pFile->lastErrno,
                        "winRead", pFile->zPath);
   }
-  winLogIoerr(nRetry);
+  winLogIoerr(nRetry, __LINE__);
   if( nRead<(DWORD)amt ){
     /* Unread parts of the buffer must be zero-filled */
     memset(&((char*)pBuf)[nRead], 0, amt-nRead);
-    OSTRACE(("READ file=%p, rc=SQLITE_IOERR_SHORT_READ\n", pFile->h));
+    OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_SHORT_READ\n",
+             osGetCurrentProcessId(), pFile, pFile->h));
     return SQLITE_IOERR_SHORT_READ;
   }
 
-  OSTRACE(("READ file=%p, rc=SQLITE_OK\n", pFile->h));
+  OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",
+           osGetCurrentProcessId(), pFile, pFile->h));
   return SQLITE_OK;
 }
 
@@ -35464,7 +35803,8 @@ static int winWrite(
   SimulateIOError(return SQLITE_IOERR_WRITE);
   SimulateDiskfullError(return SQLITE_FULL);
 
-  OSTRACE(("WRITE file=%p, buffer=%p, amount=%d, offset=%lld, lock=%d\n",
+  OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, buffer=%p, amount=%d, "
+           "offset=%lld, lock=%d\n", osGetCurrentProcessId(), pFile,
            pFile->h, pBuf, amt, offset, pFile->locktype));
 
 #if SQLITE_MAX_MMAP_SIZE>0
@@ -35473,7 +35813,8 @@ static int winWrite(
   if( offset<pFile->mmapSize ){
     if( offset+amt <= pFile->mmapSize ){
       memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, amt);
-      OSTRACE(("WRITE-MMAP file=%p, rc=SQLITE_OK\n", pFile->h));
+      OSTRACE(("WRITE-MMAP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",
+               osGetCurrentProcessId(), pFile, pFile->h));
       return SQLITE_OK;
     }else{
       int nCopy = (int)(pFile->mmapSize - offset);
@@ -35536,17 +35877,20 @@ static int winWrite(
   if( rc ){
     if(   ( pFile->lastErrno==ERROR_HANDLE_DISK_FULL )
        || ( pFile->lastErrno==ERROR_DISK_FULL )){
-      OSTRACE(("WRITE file=%p, rc=SQLITE_FULL\n", pFile->h));
+      OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_FULL\n",
+               osGetCurrentProcessId(), pFile, pFile->h));
       return winLogError(SQLITE_FULL, pFile->lastErrno,
                          "winWrite1", pFile->zPath);
     }
-    OSTRACE(("WRITE file=%p, rc=SQLITE_IOERR_WRITE\n", pFile->h));
+    OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_WRITE\n",
+             osGetCurrentProcessId(), pFile, pFile->h));
     return winLogError(SQLITE_IOERR_WRITE, pFile->lastErrno,
                        "winWrite2", pFile->zPath);
   }else{
-    winLogIoerr(nRetry);
+    winLogIoerr(nRetry, __LINE__);
   }
-  OSTRACE(("WRITE file=%p, rc=SQLITE_OK\n", pFile->h));
+  OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",
+           osGetCurrentProcessId(), pFile, pFile->h));
   return SQLITE_OK;
 }
 
@@ -35560,8 +35904,8 @@ static int winTruncate(sqlite3_file *id, sqlite3_int64 nByte){
 
   assert( pFile );
   SimulateIOError(return SQLITE_IOERR_TRUNCATE);
-  OSTRACE(("TRUNCATE file=%p, size=%lld, lock=%d\n",
-           pFile->h, nByte, pFile->locktype));
+  OSTRACE(("TRUNCATE pid=%lu, pFile=%p, file=%p, size=%lld, lock=%d\n",
+           osGetCurrentProcessId(), pFile, pFile->h, nByte, pFile->locktype));
 
   /* If the user has configured a chunk-size for this file, truncate the
   ** file so that it consists of an integer number of chunks (i.e. the
@@ -35593,7 +35937,8 @@ static int winTruncate(sqlite3_file *id, sqlite3_int64 nByte){
   }
 #endif
 
-  OSTRACE(("TRUNCATE file=%p, rc=%s\n", pFile->h, sqlite3ErrName(rc)));
+  OSTRACE(("TRUNCATE pid=%lu, pFile=%p, file=%p, rc=%s\n",
+           osGetCurrentProcessId(), pFile, pFile->h, sqlite3ErrName(rc)));
   return rc;
 }
 
@@ -35617,7 +35962,7 @@ static int winSync(sqlite3_file *id, int flags){
   BOOL rc;
 #endif
 #if !defined(NDEBUG) || !defined(SQLITE_NO_SYNC) || \
-    (defined(SQLITE_TEST) && defined(SQLITE_DEBUG))
+    defined(SQLITE_HAVE_OS_TRACE)
   /*
   ** Used when SQLITE_NO_SYNC is not defined and by the assert() and/or
   ** OSTRACE() macros.
@@ -35638,8 +35983,9 @@ static int winSync(sqlite3_file *id, int flags){
   */
   SimulateDiskfullError( return SQLITE_FULL );
 
-  OSTRACE(("SYNC file=%p, flags=%x, lock=%d\n",
-           pFile->h, flags, pFile->locktype));
+  OSTRACE(("SYNC pid=%lu, pFile=%p, file=%p, flags=%x, lock=%d\n",
+           osGetCurrentProcessId(), pFile, pFile->h, flags,
+           pFile->locktype));
 
 #ifndef SQLITE_TEST
   UNUSED_PARAMETER(flags);
@@ -35654,19 +36000,38 @@ static int winSync(sqlite3_file *id, int flags){
   ** no-op
   */
 #ifdef SQLITE_NO_SYNC
-  OSTRACE(("SYNC-NOP file=%p, rc=SQLITE_OK\n", pFile->h));
+  OSTRACE(("SYNC-NOP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",
+           osGetCurrentProcessId(), pFile, pFile->h));
   return SQLITE_OK;
 #else
+#if SQLITE_MAX_MMAP_SIZE>0
+  if( pFile->pMapRegion ){
+    if( osFlushViewOfFile(pFile->pMapRegion, 0) ){
+      OSTRACE(("SYNC-MMAP pid=%lu, pFile=%p, pMapRegion=%p, "
+               "rc=SQLITE_OK\n", osGetCurrentProcessId(),
+               pFile, pFile->pMapRegion));
+    }else{
+      pFile->lastErrno = osGetLastError();
+      OSTRACE(("SYNC-MMAP pid=%lu, pFile=%p, pMapRegion=%p, "
+               "rc=SQLITE_IOERR_MMAP\n", osGetCurrentProcessId(),
+               pFile, pFile->pMapRegion));
+      return winLogError(SQLITE_IOERR_MMAP, pFile->lastErrno,
+                         "winSync1", pFile->zPath);
+    }
+  }
+#endif
   rc = osFlushFileBuffers(pFile->h);
   SimulateIOError( rc=FALSE );
   if( rc ){
-    OSTRACE(("SYNC file=%p, rc=SQLITE_OK\n", pFile->h));
+    OSTRACE(("SYNC pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",
+             osGetCurrentProcessId(), pFile, pFile->h));
     return SQLITE_OK;
   }else{
     pFile->lastErrno = osGetLastError();
-    OSTRACE(("SYNC file=%p, rc=SQLITE_IOERR_FSYNC\n", pFile->h));
+    OSTRACE(("SYNC pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_FSYNC\n",
+             osGetCurrentProcessId(), pFile, pFile->h));
     return winLogError(SQLITE_IOERR_FSYNC, pFile->lastErrno,
-                       "winSync", pFile->zPath);
+                       "winSync2", pFile->zPath);
   }
 #endif
 }
@@ -36274,7 +36639,7 @@ struct winShmNode {
   int nRef;                  /* Number of winShm objects pointing to this */
   winShm *pFirst;            /* All winShm objects pointing to this */
   winShmNode *pNext;         /* Next in list of all winShmNode objects */
-#ifdef SQLITE_DEBUG
+#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)
   u8 nextShmId;              /* Next available winShm.id value */
 #endif
 };
@@ -36305,7 +36670,7 @@ struct winShm {
   u8 hasMutex;               /* True if holding the winShmNode mutex */
   u16 sharedMask;            /* Mask of shared locks held */
   u16 exclMask;              /* Mask of exclusive locks held */
-#ifdef SQLITE_DEBUG
+#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)
   u8 id;                     /* Id of this connection with its winShmNode */
 #endif
 };
@@ -36496,7 +36861,7 @@ static int winOpenSharedMemory(winFile *pDbFd){
 
   /* Make the new connection a child of the winShmNode */
   p->pShmNode = pShmNode;
-#ifdef SQLITE_DEBUG
+#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)
   p->id = pShmNode->nextShmId++;
 #endif
   pShmNode->nRef++;
@@ -36716,16 +37081,16 @@ static int winShmMap(
   void volatile **pp              /* OUT: Mapped memory */
 ){
   winFile *pDbFd = (winFile*)fd;
-  winShm *p = pDbFd->pShm;
+  winShm *pShm = pDbFd->pShm;
   winShmNode *pShmNode;
   int rc = SQLITE_OK;
 
-  if( !p ){
+  if( !pShm ){
     rc = winOpenSharedMemory(pDbFd);
     if( rc!=SQLITE_OK ) return rc;
-    p = pDbFd->pShm;
+    pShm = pDbFd->pShm;
   }
-  pShmNode = p->pShmNode;
+  pShmNode = pShm->pShmNode;
 
   sqlite3_mutex_enter(pShmNode->mutex);
   assert( szRegion==pShmNode->szRegion || pShmNode->nRegion==0 );
@@ -36765,7 +37130,7 @@ static int winShmMap(
     }
 
     /* Map the requested memory region into this processes address space. */
-    apNew = (struct ShmRegion *)sqlite3_realloc(
+    apNew = (struct ShmRegion *)sqlite3_realloc64(
         pShmNode->aRegion, (iRegion+1)*sizeof(apNew[0])
     );
     if( !apNew ){
@@ -37637,7 +38002,7 @@ static int winOpen(
     }
   }
 #endif
-  winLogIoerr(cnt);
+  winLogIoerr(cnt, __LINE__);
 
   OSTRACE(("OPEN file=%p, name=%s, access=%lx, rc=%s\n", h, zUtf8Name,
            dwDesiredAccess, (h==INVALID_HANDLE_VALUE) ? "failed" : "ok"));
@@ -37821,7 +38186,7 @@ static int winDelete(
   if( rc && rc!=SQLITE_IOERR_DELETE_NOENT ){
     rc = winLogError(SQLITE_IOERR_DELETE, lastErrno, "winDelete", zFilename);
   }else{
-    winLogIoerr(cnt);
+    winLogIoerr(cnt, __LINE__);
   }
   sqlite3_free(zConverted);
   OSTRACE(("DELETE name=%s, rc=%s\n", zFilename, sqlite3ErrName(rc)));
@@ -37871,7 +38236,7 @@ static int winAccess(
         attr = sAttrData.dwFileAttributes;
       }
     }else{
-      winLogIoerr(cnt);
+      winLogIoerr(cnt, __LINE__);
       if( lastErrno!=ERROR_FILE_NOT_FOUND && lastErrno!=ERROR_PATH_NOT_FOUND ){
         sqlite3_free(zConverted);
         return winLogError(SQLITE_IOERR_ACCESS, lastErrno, "winAccess",
@@ -38212,7 +38577,7 @@ static void winDlClose(sqlite3_vfs *pVfs, void *pHandle){
 static int winRandomness(sqlite3_vfs *pVfs, int nBuf, char *zBuf){
   int n = 0;
   UNUSED_PARAMETER(pVfs);
-#if defined(SQLITE_TEST)
+#if defined(SQLITE_TEST) || defined(SQLITE_OMIT_RANDOMNESS)
   n = nBuf;
   memset(zBuf, 0, nBuf);
 #else
@@ -38246,7 +38611,23 @@ static int winRandomness(sqlite3_vfs *pVfs, int nBuf, char *zBuf){
     memcpy(&zBuf[n], &i, sizeof(i));
     n += sizeof(i);
   }
+#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_WIN32_USE_UUID
+  if( sizeof(UUID)<=nBuf-n ){
+    UUID id;
+    memset(&id, 0, sizeof(UUID));
+    osUuidCreate(&id);
+    memcpy(zBuf, &id, sizeof(UUID));
+    n += sizeof(UUID);
+  }
+  if( sizeof(UUID)<=nBuf-n ){
+    UUID id;
+    memset(&id, 0, sizeof(UUID));
+    osUuidCreateSequential(&id);
+    memcpy(zBuf, &id, sizeof(UUID));
+    n += sizeof(UUID);
+  }
 #endif
+#endif /* defined(SQLITE_TEST) || defined(SQLITE_ZERO_PRNG_SEED) */
   return n;
 }
 
@@ -38370,7 +38751,7 @@ static int winGetLastError(sqlite3_vfs *pVfs, int nBuf, char *zBuf){
 /*
 ** Initialize and deinitialize the operating system interface.
 */
-SQLITE_API int sqlite3_os_init(void){
+SQLITE_API int SQLITE_STDCALL sqlite3_os_init(void){
   static sqlite3_vfs winVfs = {
     3,                   /* iVersion */
     sizeof(winFile),     /* szOsFile */
@@ -38424,7 +38805,7 @@ SQLITE_API int sqlite3_os_init(void){
 
   /* Double-check that the aSyscall[] array has been constructed
   ** correctly.  See ticket [bb3a86e890c8e96ab] */
-  assert( ArraySize(aSyscall)==77 );
+  assert( ArraySize(aSyscall)==80 );
 
   /* get memory map allocation granularity */
   memset(&winSysInfo, 0, sizeof(SYSTEM_INFO));
@@ -38445,7 +38826,7 @@ SQLITE_API int sqlite3_os_init(void){
   return SQLITE_OK;
 }
 
-SQLITE_API int sqlite3_os_end(void){
+SQLITE_API int SQLITE_STDCALL sqlite3_os_end(void){
 #if SQLITE_OS_WINRT
   if( sleepObj!=NULL ){
     osCloseHandle(sleepObj);
@@ -38801,7 +39182,7 @@ SQLITE_PRIVATE int sqlite3BitvecBuiltinTest(int sz, int *aOp){
   ** bits to act as the reference */
   pBitvec = sqlite3BitvecCreate( sz );
   pV = sqlite3MallocZero( (sz+7)/8 + 1 );
-  pTmpSpace = sqlite3_malloc(BITVEC_SZ);
+  pTmpSpace = sqlite3_malloc64(BITVEC_SZ);
   if( pBitvec==0 || pV==0 || pTmpSpace==0  ) goto bitvec_end;
 
   /* NULL pBitvec tests */
@@ -38983,12 +39364,20 @@ static void pcacheUnpin(PgHdr *p){
 }
 
 /*
-** Compute the number of pages of cache requested.
+** Compute the number of pages of cache requested.  p->szCache is the
+** cache size requested by the "PRAGMA cache_size" statement.
+**
+**
 */
 static int numberOfCachePages(PCache *p){
   if( p->szCache>=0 ){
+    /* IMPLEMENTATION-OF: R-42059-47211 If the argument N is positive then the
+    ** suggested cache size is set to N. */
     return p->szCache;
   }else{
+    /* IMPLEMENTATION-OF: R-61436-13639 If the argument N is negative, then
+    ** the number of cache pages is adjusted to use approximately abs(N*1024)
+    ** bytes of memory. */
     return (int)((-1024*(i64)p->szCache)/(p->szPage+p->szExtra));
   }
 }
@@ -39728,7 +40117,6 @@ SQLITE_PRIVATE void sqlite3PCacheBufferSetup(void *pBuf, int sz, int n){
 static void *pcache1Alloc(int nByte){
   void *p = 0;
   assert( sqlite3_mutex_notheld(pcache1.grp.mutex) );
-  sqlite3StatusSet(SQLITE_STATUS_PAGECACHE_SIZE, nByte);
   if( nByte<=pcache1.szSlot ){
     sqlite3_mutex_enter(pcache1.mutex);
     p = (PgHdr1 *)pcache1.pFree;
@@ -39737,7 +40125,8 @@ static void *pcache1Alloc(int nByte){
       pcache1.nFreeSlot--;
       pcache1.bUnderPressure = pcache1.nFreeSlot<pcache1.nReserve;
       assert( pcache1.nFreeSlot>=0 );
-      sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_USED, 1);
+      sqlite3StatusSet(SQLITE_STATUS_PAGECACHE_SIZE, nByte);
+      sqlite3StatusUp(SQLITE_STATUS_PAGECACHE_USED, 1);
     }
     sqlite3_mutex_leave(pcache1.mutex);
   }
@@ -39750,7 +40139,8 @@ static void *pcache1Alloc(int nByte){
     if( p ){
       int sz = sqlite3MallocSize(p);
       sqlite3_mutex_enter(pcache1.mutex);
-      sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_OVERFLOW, sz);
+      sqlite3StatusSet(SQLITE_STATUS_PAGECACHE_SIZE, nByte);
+      sqlite3StatusUp(SQLITE_STATUS_PAGECACHE_OVERFLOW, sz);
       sqlite3_mutex_leave(pcache1.mutex);
     }
 #endif
@@ -39768,7 +40158,7 @@ static int pcache1Free(void *p){
   if( p>=pcache1.pStart && p<pcache1.pEnd ){
     PgFreeslot *pSlot;
     sqlite3_mutex_enter(pcache1.mutex);
-    sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_USED, -1);
+    sqlite3StatusDown(SQLITE_STATUS_PAGECACHE_USED, 1);
     pSlot = (PgFreeslot*)p;
     pSlot->pNext = pcache1.pFree;
     pcache1.pFree = pSlot;
@@ -39782,7 +40172,7 @@ static int pcache1Free(void *p){
     nFreed = sqlite3MallocSize(p);
 #ifndef SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS
     sqlite3_mutex_enter(pcache1.mutex);
-    sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_OVERFLOW, -nFreed);
+    sqlite3StatusDown(SQLITE_STATUS_PAGECACHE_OVERFLOW, nFreed);
     sqlite3_mutex_leave(pcache1.mutex);
 #endif
     sqlite3_free(p);
@@ -40519,6 +40909,14 @@ SQLITE_PRIVATE void sqlite3PCacheSetDefault(void){
 */
 SQLITE_PRIVATE int sqlite3HeaderSizePcache1(void){ return ROUND8(sizeof(PgHdr1)); }
 
+/*
+** Return the global mutex used by this PCACHE implementation.  The
+** sqlite3_status() routine needs access to this mutex.
+*/
+SQLITE_PRIVATE sqlite3_mutex *sqlite3Pcache1Mutex(void){
+  return pcache1.mutex;
+}
+
 #ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
 /*
 ** This function is called to free superfluous dynamically allocated memory
@@ -44273,9 +44671,7 @@ static int pagerWalFrames(
 ){
   int rc;                         /* Return code */
   int nList;                      /* Number of pages in pList */
-#if defined(SQLITE_DEBUG) || defined(SQLITE_CHECK_PAGES)
   PgHdr *p;                       /* For looping over pages */
-#endif
 
   assert( pPager->pWal );
   assert( pList );
@@ -44292,7 +44688,6 @@ static int pagerWalFrames(
     ** any pages with page numbers greater than nTruncate into the WAL file.
     ** They will never be read by any client. So remove them from the pDirty
     ** list here. */
-    PgHdr *p;
     PgHdr **ppNext = &pList;
     nList = 0;
     for(p=pList; (*ppNext = p)!=0; p=p->pDirty){
@@ -44312,7 +44707,6 @@ static int pagerWalFrames(
       pPager->pageSize, pList, nTruncate, isCommit, pPager->walSyncFlags
   );
   if( rc==SQLITE_OK && pPager->pBackup ){
-    PgHdr *p;
     for(p=pList; p; p=p->pDirty){
       sqlite3BackupUpdate(pPager->pBackup, p->pgno, (u8 *)p->pData);
     }
@@ -48243,6 +48637,8 @@ SQLITE_PRIVATE int sqlite3PagerSetJournalMode(Pager *pPager, int eMode){
         }
         assert( state==pPager->eState );
       }
+    }else if( eMode==PAGER_JOURNALMODE_OFF ){
+      sqlite3OsClose(pPager->jfd);
     }
   }
 
@@ -49025,7 +49421,7 @@ static int walIndexPage(Wal *pWal, int iPage, volatile u32 **ppPage){
   if( pWal->nWiData<=iPage ){
     int nByte = sizeof(u32*)*(iPage+1);
     volatile u32 **apNew;
-    apNew = (volatile u32 **)sqlite3_realloc((void *)pWal->apWiData, nByte);
+    apNew = (volatile u32 **)sqlite3_realloc64((void *)pWal->apWiData, nByte);
     if( !apNew ){
       *ppPage = 0;
       return SQLITE_NOMEM;
@@ -49291,9 +49687,10 @@ static void walUnlockShared(Wal *pWal, int lockIdx){
                          SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED);
   WALTRACE(("WAL%p: release SHARED-%s\n", pWal, walLockName(lockIdx)));
 }
-static int walLockExclusive(Wal *pWal, int lockIdx, int n){
+static int walLockExclusive(Wal *pWal, int lockIdx, int n, int fBlock){
   int rc;
   if( pWal->exclusiveMode ) return SQLITE_OK;
+  if( fBlock ) sqlite3OsFileControl(pWal->pDbFd, SQLITE_FCNTL_WAL_BLOCK, 0);
   rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,
                         SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE);
   WALTRACE(("WAL%p: acquire EXCLUSIVE-%s cnt=%d %s\n", pWal,
@@ -49579,7 +49976,7 @@ static int walIndexRecover(Wal *pWal){
   assert( pWal->writeLock );
   iLock = WAL_ALL_BUT_WRITE + pWal->ckptLock;
   nLock = SQLITE_SHM_NLOCK - iLock;
-  rc = walLockExclusive(pWal, iLock, nLock);
+  rc = walLockExclusive(pWal, iLock, nLock, 0);
   if( rc ){
     return rc;
   }
@@ -49649,7 +50046,7 @@ static int walIndexRecover(Wal *pWal){
 
     /* Malloc a buffer to read frames into. */
     szFrame = szPage + WAL_FRAME_HDRSIZE;
-    aFrame = (u8 *)sqlite3_malloc(szFrame);
+    aFrame = (u8 *)sqlite3_malloc64(szFrame);
     if( !aFrame ){
       rc = SQLITE_NOMEM;
       goto recovery_error;
@@ -50042,7 +50439,7 @@ static int walIteratorInit(Wal *pWal, WalIterator **pp){
   nByte = sizeof(WalIterator) 
         + (nSegment-1)*sizeof(struct WalSegment)
         + iLast*sizeof(ht_slot);
-  p = (WalIterator *)sqlite3_malloc(nByte);
+  p = (WalIterator *)sqlite3_malloc64(nByte);
   if( !p ){
     return SQLITE_NOMEM;
   }
@@ -50052,7 +50449,7 @@ static int walIteratorInit(Wal *pWal, WalIterator **pp){
   /* Allocate temporary space used by the merge-sort routine. This block
   ** of memory will be freed before this function returns.
   */
-  aTmp = (ht_slot *)sqlite3_malloc(
+  aTmp = (ht_slot *)sqlite3_malloc64(
       sizeof(ht_slot) * (iLast>HASHTABLE_NPAGE?HASHTABLE_NPAGE:iLast)
   );
   if( !aTmp ){
@@ -50113,7 +50510,7 @@ static int walBusyLock(
 ){
   int rc;
   do {
-    rc = walLockExclusive(pWal, lockIdx, n);
+    rc = walLockExclusive(pWal, lockIdx, n, 0);
   }while( xBusy && rc==SQLITE_BUSY && xBusy(pBusyArg) );
   return rc;
 }
@@ -50197,7 +50594,7 @@ static int walCheckpoint(
   int sync_flags,                 /* Flags for OsSync() (or 0) */
   u8 *zBuf                        /* Temporary buffer to use */
 ){
-  int rc;                         /* Return code */
+  int rc = SQLITE_OK;             /* Return code */
   int szPage;                     /* Database page-size */
   WalIterator *pIter = 0;         /* Wal iterator context */
   u32 iDbpage = 0;                /* Next database page to write */
@@ -50211,104 +50608,115 @@ static int walCheckpoint(
   testcase( szPage<=32768 );
   testcase( szPage>=65536 );
   pInfo = walCkptInfo(pWal);
-  if( pInfo->nBackfill>=pWal->hdr.mxFrame ) return SQLITE_OK;
+  if( pInfo->nBackfill<pWal->hdr.mxFrame ){
 
-  /* Allocate the iterator */
-  rc = walIteratorInit(pWal, &pIter);
-  if( rc!=SQLITE_OK ){
-    return rc;
-  }
-  assert( pIter );
+    /* Allocate the iterator */
+    rc = walIteratorInit(pWal, &pIter);
+    if( rc!=SQLITE_OK ){
+      return rc;
+    }
+    assert( pIter );
 
-  /* EVIDENCE-OF: R-62920-47450 The busy-handler callback is never invoked
-  ** in the SQLITE_CHECKPOINT_PASSIVE mode. */
-  assert( eMode!=SQLITE_CHECKPOINT_PASSIVE || xBusy==0 );
+    /* EVIDENCE-OF: R-62920-47450 The busy-handler callback is never invoked
+    ** in the SQLITE_CHECKPOINT_PASSIVE mode. */
+    assert( eMode!=SQLITE_CHECKPOINT_PASSIVE || xBusy==0 );
 
-  /* Compute in mxSafeFrame the index of the last frame of the WAL that is
-  ** safe to write into the database.  Frames beyond mxSafeFrame might
-  ** overwrite database pages that are in use by active readers and thus
-  ** cannot be backfilled from the WAL.
-  */
-  mxSafeFrame = pWal->hdr.mxFrame;
-  mxPage = pWal->hdr.nPage;
-  for(i=1; i<WAL_NREADER; i++){
-    u32 y = pInfo->aReadMark[i];
-    if( mxSafeFrame>y ){
-      assert( y<=pWal->hdr.mxFrame );
-      rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(i), 1);
-      if( rc==SQLITE_OK ){
-        pInfo->aReadMark[i] = (i==1 ? mxSafeFrame : READMARK_NOT_USED);
-        walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);
-      }else if( rc==SQLITE_BUSY ){
-        mxSafeFrame = y;
-        xBusy = 0;
-      }else{
-        goto walcheckpoint_out;
+    /* Compute in mxSafeFrame the index of the last frame of the WAL that is
+    ** safe to write into the database.  Frames beyond mxSafeFrame might
+    ** overwrite database pages that are in use by active readers and thus
+    ** cannot be backfilled from the WAL.
+    */
+    mxSafeFrame = pWal->hdr.mxFrame;
+    mxPage = pWal->hdr.nPage;
+    for(i=1; i<WAL_NREADER; i++){
+      /* Thread-sanitizer reports that the following is an unsafe read,
+      ** as some other thread may be in the process of updating the value
+      ** of the aReadMark[] slot. The assumption here is that if that is
+      ** happening, the other client may only be increasing the value,
+      ** not decreasing it. So assuming either that either the "old" or
+      ** "new" version of the value is read, and not some arbitrary value
+      ** that would never be written by a real client, things are still 
+      ** safe.  */
+      u32 y = pInfo->aReadMark[i];
+      if( mxSafeFrame>y ){
+        assert( y<=pWal->hdr.mxFrame );
+        rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(i), 1);
+        if( rc==SQLITE_OK ){
+          pInfo->aReadMark[i] = (i==1 ? mxSafeFrame : READMARK_NOT_USED);
+          walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);
+        }else if( rc==SQLITE_BUSY ){
+          mxSafeFrame = y;
+          xBusy = 0;
+        }else{
+          goto walcheckpoint_out;
+        }
       }
     }
-  }
 
-  if( pInfo->nBackfill<mxSafeFrame
-   && (rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(0), 1))==SQLITE_OK
-  ){
-    i64 nSize;                    /* Current size of database file */
-    u32 nBackfill = pInfo->nBackfill;
+    if( pInfo->nBackfill<mxSafeFrame
+     && (rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(0),1))==SQLITE_OK
+    ){
+      i64 nSize;                    /* Current size of database file */
+      u32 nBackfill = pInfo->nBackfill;
 
-    /* Sync the WAL to disk */
-    if( sync_flags ){
-      rc = sqlite3OsSync(pWal->pWalFd, sync_flags);
-    }
+      /* Sync the WAL to disk */
+      if( sync_flags ){
+        rc = sqlite3OsSync(pWal->pWalFd, sync_flags);
+      }
 
-    /* If the database may grow as a result of this checkpoint, hint
-    ** about the eventual size of the db file to the VFS layer.
-    */
-    if( rc==SQLITE_OK ){
-      i64 nReq = ((i64)mxPage * szPage);
-      rc = sqlite3OsFileSize(pWal->pDbFd, &nSize);
-      if( rc==SQLITE_OK && nSize<nReq ){
-        sqlite3OsFileControlHint(pWal->pDbFd, SQLITE_FCNTL_SIZE_HINT, &nReq);
+      /* If the database may grow as a result of this checkpoint, hint
+      ** about the eventual size of the db file to the VFS layer.
+      */
+      if( rc==SQLITE_OK ){
+        i64 nReq = ((i64)mxPage * szPage);
+        rc = sqlite3OsFileSize(pWal->pDbFd, &nSize);
+        if( rc==SQLITE_OK && nSize<nReq ){
+          sqlite3OsFileControlHint(pWal->pDbFd, SQLITE_FCNTL_SIZE_HINT, &nReq);
+        }
       }
-    }
 
 
-    /* Iterate through the contents of the WAL, copying data to the db file. */
-    while( rc==SQLITE_OK && 0==walIteratorNext(pIter, &iDbpage, &iFrame) ){
-      i64 iOffset;
-      assert( walFramePgno(pWal, iFrame)==iDbpage );
-      if( iFrame<=nBackfill || iFrame>mxSafeFrame || iDbpage>mxPage ) continue;
-      iOffset = walFrameOffset(iFrame, szPage) + WAL_FRAME_HDRSIZE;
-      /* testcase( IS_BIG_INT(iOffset) ); // requires a 4GiB WAL file */
-      rc = sqlite3OsRead(pWal->pWalFd, zBuf, szPage, iOffset);
-      if( rc!=SQLITE_OK ) break;
-      iOffset = (iDbpage-1)*(i64)szPage;
-      testcase( IS_BIG_INT(iOffset) );
-      rc = sqlite3OsWrite(pWal->pDbFd, zBuf, szPage, iOffset);
-      if( rc!=SQLITE_OK ) break;
-    }
-
-    /* If work was actually accomplished... */
-    if( rc==SQLITE_OK ){
-      if( mxSafeFrame==walIndexHdr(pWal)->mxFrame ){
-        i64 szDb = pWal->hdr.nPage*(i64)szPage;
-        testcase( IS_BIG_INT(szDb) );
-        rc = sqlite3OsTruncate(pWal->pDbFd, szDb);
-        if( rc==SQLITE_OK && sync_flags ){
-          rc = sqlite3OsSync(pWal->pDbFd, sync_flags);
+      /* Iterate through the contents of the WAL, copying data to the db file */
+      while( rc==SQLITE_OK && 0==walIteratorNext(pIter, &iDbpage, &iFrame) ){
+        i64 iOffset;
+        assert( walFramePgno(pWal, iFrame)==iDbpage );
+        if( iFrame<=nBackfill || iFrame>mxSafeFrame || iDbpage>mxPage ){
+          continue;
         }
+        iOffset = walFrameOffset(iFrame, szPage) + WAL_FRAME_HDRSIZE;
+        /* testcase( IS_BIG_INT(iOffset) ); // requires a 4GiB WAL file */
+        rc = sqlite3OsRead(pWal->pWalFd, zBuf, szPage, iOffset);
+        if( rc!=SQLITE_OK ) break;
+        iOffset = (iDbpage-1)*(i64)szPage;
+        testcase( IS_BIG_INT(iOffset) );
+        rc = sqlite3OsWrite(pWal->pDbFd, zBuf, szPage, iOffset);
+        if( rc!=SQLITE_OK ) break;
       }
+
+      /* If work was actually accomplished... */
       if( rc==SQLITE_OK ){
-        pInfo->nBackfill = mxSafeFrame;
+        if( mxSafeFrame==walIndexHdr(pWal)->mxFrame ){
+          i64 szDb = pWal->hdr.nPage*(i64)szPage;
+          testcase( IS_BIG_INT(szDb) );
+          rc = sqlite3OsTruncate(pWal->pDbFd, szDb);
+          if( rc==SQLITE_OK && sync_flags ){
+            rc = sqlite3OsSync(pWal->pDbFd, sync_flags);
+          }
+        }
+        if( rc==SQLITE_OK ){
+          pInfo->nBackfill = mxSafeFrame;
+        }
       }
-    }
 
-    /* Release the reader lock held while backfilling */
-    walUnlockExclusive(pWal, WAL_READ_LOCK(0), 1);
-  }
+      /* Release the reader lock held while backfilling */
+      walUnlockExclusive(pWal, WAL_READ_LOCK(0), 1);
+    }
 
-  if( rc==SQLITE_BUSY ){
-    /* Reset the return code so as not to report a checkpoint failure
-    ** just because there are active readers.  */
-    rc = SQLITE_OK;
+    if( rc==SQLITE_BUSY ){
+      /* Reset the return code so as not to report a checkpoint failure
+      ** just because there are active readers.  */
+      rc = SQLITE_OK;
+    }
   }
 
   /* If this is an SQLITE_CHECKPOINT_RESTART or TRUNCATE operation, and the
@@ -50323,7 +50731,7 @@ static int walCheckpoint(
     }else if( eMode>=SQLITE_CHECKPOINT_RESTART ){
       u32 salt1;
       sqlite3_randomness(4, &salt1);
-      assert( mxSafeFrame==pWal->hdr.mxFrame );
+      assert( pInfo->nBackfill==pWal->hdr.mxFrame );
       rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(1), WAL_NREADER-1);
       if( rc==SQLITE_OK ){
         if( eMode==SQLITE_CHECKPOINT_TRUNCATE ){
@@ -50543,7 +50951,7 @@ static int walIndexReadHdr(Wal *pWal, int *pChanged){
         walUnlockShared(pWal, WAL_WRITE_LOCK);
         rc = SQLITE_READONLY_RECOVERY;
       }
-    }else if( SQLITE_OK==(rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1)) ){
+    }else if( SQLITE_OK==(rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1, 1)) ){
       pWal->writeLock = 1;
       if( SQLITE_OK==(rc = walIndexPage(pWal, 0, &page0)) ){
         badHdr = walIndexTryHdr(pWal, pChanged);
@@ -50749,7 +51157,7 @@ static int walTryBeginRead(Wal *pWal, int *pChanged, int useWal, int cnt){
      && (mxReadMark<pWal->hdr.mxFrame || mxI==0)
     ){
       for(i=1; i<WAL_NREADER; i++){
-        rc = walLockExclusive(pWal, WAL_READ_LOCK(i), 1);
+        rc = walLockExclusive(pWal, WAL_READ_LOCK(i), 1, 0);
         if( rc==SQLITE_OK ){
           mxReadMark = pInfo->aReadMark[i] = pWal->hdr.mxFrame;
           mxI = i;
@@ -51005,7 +51413,7 @@ SQLITE_PRIVATE int sqlite3WalBeginWriteTransaction(Wal *pWal){
   /* Only one writer allowed at a time.  Get the write lock.  Return
   ** SQLITE_BUSY if unable.
   */
-  rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1);
+  rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1, 0);
   if( rc ){
     return rc;
   }
@@ -51150,7 +51558,7 @@ static int walRestartLog(Wal *pWal){
     if( pInfo->nBackfill>0 ){
       u32 salt1;
       sqlite3_randomness(4, &salt1);
-      rc = walLockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);
+      rc = walLockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1, 0);
       if( rc==SQLITE_OK ){
         /* If all readers are using WAL_READ_LOCK(0) (in other words if no
         ** readers are currently using the WAL), then the transactions
@@ -51475,7 +51883,7 @@ SQLITE_PRIVATE int sqlite3WalCheckpoint(
 
   /* IMPLEMENTATION-OF: R-62028-47212 All calls obtain an exclusive 
   ** "checkpoint" lock on the database file. */
-  rc = walLockExclusive(pWal, WAL_CKPT_LOCK, 1);
+  rc = walLockExclusive(pWal, WAL_CKPT_LOCK, 1, 0);
   if( rc ){
     /* EVIDENCE-OF: R-10421-19736 If any other process is running a
     ** checkpoint operation at the same time, the lock cannot be obtained and
@@ -51950,6 +52358,7 @@ struct MemPage {
   u8 hdrOffset;        /* 100 for page 1.  0 otherwise */
   u8 childPtrSize;     /* 0 if leaf==1.  4 if leaf==0 */
   u8 max1bytePayload;  /* min(maxLocal,127) */
+  u8 bBusy;            /* Prevent endless loops on corrupt database files */
   u16 maxLocal;        /* Copy of BtShared.maxLocal or BtShared.maxLeaf */
   u16 minLocal;        /* Copy of BtShared.minLocal or BtShared.minLeaf */
   u16 cellOffset;      /* Index in aData of first cell pointer */
@@ -52088,6 +52497,9 @@ struct BtShared {
 #endif
   u8 inTransaction;     /* Transaction state */
   u8 max1bytePayload;   /* Maximum first byte of cell for a 1-byte payload */
+#ifdef SQLITE_HAS_CODEC
+  u8 optimalReserve;    /* Desired amount of reserved space per page */
+#endif
   u16 btsFlags;         /* Boolean parameters.  See BTS_* macros below */
   u16 maxLocal;         /* Maximum local payload in non-LEAFDATA tables */
   u16 minLocal;         /* Minimum local payload in non-LEAFDATA tables */
@@ -52474,6 +52886,7 @@ static void SQLITE_NOINLINE btreeLockCarefully(Btree *p){
 ** Exit the recursive mutex on a Btree.
 */
 SQLITE_PRIVATE void sqlite3BtreeLeave(Btree *p){
+  assert( sqlite3_mutex_held(p->db->mutex) );
   if( p->sharable ){
     assert( p->wantToLock>0 );
     p->wantToLock--;
@@ -52721,7 +53134,7 @@ static BtShared *SQLITE_WSD sqlite3SharedCacheList = 0;
 ** The shared cache setting effects only future calls to
 ** sqlite3_open(), sqlite3_open16(), or sqlite3_open_v2().
 */
-SQLITE_API int sqlite3_enable_shared_cache(int enable){
+SQLITE_API int SQLITE_STDCALL sqlite3_enable_shared_cache(int enable){
   sqlite3GlobalConfig.sharedCacheEnabled = enable;
   return SQLITE_OK;
 }
@@ -52810,6 +53223,12 @@ static int hasSharedCacheTableLock(
     for(p=sqliteHashFirst(&pSchema->idxHash); p; p=sqliteHashNext(p)){
       Index *pIdx = (Index *)sqliteHashData(p);
       if( pIdx->tnum==(int)iRoot ){
+        if( iTab ){
+          /* Two or more indexes share the same root page.  There must
+          ** be imposter tables.  So just return true.  The assert is not
+          ** useful in that case. */
+          return 1;
+        }
         iTab = pIdx->pTable->tnum;
       }
     }
@@ -53229,10 +53648,15 @@ static void btreeReleaseAllCursorPages(BtCursor *pCur){
 static int saveCursorPosition(BtCursor *pCur){
   int rc;
 
-  assert( CURSOR_VALID==pCur->eState );
+  assert( CURSOR_VALID==pCur->eState || CURSOR_SKIPNEXT==pCur->eState );
   assert( 0==pCur->pKey );
   assert( cursorHoldsMutex(pCur) );
 
+  if( pCur->eState==CURSOR_SKIPNEXT ){
+    pCur->eState = CURSOR_VALID;
+  }else{
+    pCur->skipNext = 0;
+  }
   rc = sqlite3BtreeKeySize(pCur, &pCur->nKey);
   assert( rc==SQLITE_OK );  /* KeySize() cannot fail */
 
@@ -53303,7 +53727,7 @@ static int SQLITE_NOINLINE saveCursorsOnList(
 ){
   do{
     if( p!=pExcept && (0==iRoot || p->pgnoRoot==iRoot) ){
-      if( p->eState==CURSOR_VALID ){
+      if( p->eState==CURSOR_VALID || p->eState==CURSOR_SKIPNEXT ){
         int rc = saveCursorPosition(p);
         if( SQLITE_OK!=rc ){
           return rc;
@@ -53375,17 +53799,19 @@ static int btreeMoveto(
 */
 static int btreeRestoreCursorPosition(BtCursor *pCur){
   int rc;
+  int skipNext;
   assert( cursorHoldsMutex(pCur) );
   assert( pCur->eState>=CURSOR_REQUIRESEEK );
   if( pCur->eState==CURSOR_FAULT ){
     return pCur->skipNext;
   }
   pCur->eState = CURSOR_INVALID;
-  rc = btreeMoveto(pCur, pCur->pKey, pCur->nKey, 0, &pCur->skipNext);
+  rc = btreeMoveto(pCur, pCur->pKey, pCur->nKey, 0, &skipNext);
   if( rc==SQLITE_OK ){
     sqlite3_free(pCur->pKey);
     pCur->pKey = 0;
     assert( pCur->eState==CURSOR_VALID || pCur->eState==CURSOR_INVALID );
+    pCur->skipNext |= skipNext;
     if( pCur->skipNext && pCur->eState==CURSOR_VALID ){
       pCur->eState = CURSOR_SKIPNEXT;
     }
@@ -53437,9 +53863,10 @@ SQLITE_PRIVATE int sqlite3BtreeCursorRestore(BtCursor *pCur, int *pDifferentRow)
     *pDifferentRow = 1;
     return rc;
   }
-  if( pCur->eState!=CURSOR_VALID || NEVER(pCur->skipNext!=0) ){
+  if( pCur->eState!=CURSOR_VALID ){
     *pDifferentRow = 1;
   }else{
+    assert( pCur->skipNext==0 );
     *pDifferentRow = 0;
   }
   return SQLITE_OK;
@@ -54580,16 +55007,18 @@ SQLITE_PRIVATE int sqlite3BtreeOpen(
   */
   if( isTempDb==0 && (isMemdb==0 || (vfsFlags&SQLITE_OPEN_URI)!=0) ){
     if( vfsFlags & SQLITE_OPEN_SHAREDCACHE ){
+      int nFilename = sqlite3Strlen30(zFilename)+1;
       int nFullPathname = pVfs->mxPathname+1;
-      char *zFullPathname = sqlite3Malloc(nFullPathname);
+      char *zFullPathname = sqlite3Malloc(MAX(nFullPathname,nFilename));
       MUTEX_LOGIC( sqlite3_mutex *mutexShared; )
+
       p->sharable = 1;
       if( !zFullPathname ){
         sqlite3_free(p);
         return SQLITE_NOMEM;
       }
       if( isMemdb ){
-        memcpy(zFullPathname, zFilename, sqlite3Strlen30(zFilename)+1);
+        memcpy(zFullPathname, zFilename, nFilename);
       }else{
         rc = sqlite3OsFullPathname(pVfs, zFilename,
                                    nFullPathname, zFullPathname);
@@ -54646,8 +55075,8 @@ SQLITE_PRIVATE int sqlite3BtreeOpen(
     ** the right size.  This is to guard against size changes that result
     ** when compiling on a different architecture.
     */
-    assert( sizeof(i64)==8 || sizeof(i64)==4 );
-    assert( sizeof(u64)==8 || sizeof(u64)==4 );
+    assert( sizeof(i64)==8 );
+    assert( sizeof(u64)==8 );
     assert( sizeof(u32)==4 );
     assert( sizeof(u16)==2 );
     assert( sizeof(Pgno)==4 );
@@ -55034,6 +55463,9 @@ SQLITE_PRIVATE int sqlite3BtreeSetPageSize(Btree *p, int pageSize, int nReserve,
   BtShared *pBt = p->pBt;
   assert( nReserve>=-1 && nReserve<=255 );
   sqlite3BtreeEnter(p);
+#if SQLITE_HAS_CODEC
+  if( nReserve>pBt->optimalReserve ) pBt->optimalReserve = (u8)nReserve;
+#endif
   if( pBt->btsFlags & BTS_PAGESIZE_FIXED ){
     sqlite3BtreeLeave(p);
     return SQLITE_READONLY;
@@ -55045,7 +55477,7 @@ SQLITE_PRIVATE int sqlite3BtreeSetPageSize(Btree *p, int pageSize, int nReserve,
   if( pageSize>=512 && pageSize<=SQLITE_MAX_PAGE_SIZE &&
         ((pageSize-1)&pageSize)==0 ){
     assert( (pageSize & 7)==0 );
-    assert( !pBt->pPage1 && !pBt->pCursor );
+    assert( !pBt->pCursor );
     pBt->pageSize = (u32)pageSize;
     freeTempSpace(pBt);
   }
@@ -55063,7 +55495,6 @@ SQLITE_PRIVATE int sqlite3BtreeGetPageSize(Btree *p){
   return p->pBt->pageSize;
 }
 
-#if defined(SQLITE_HAS_CODEC) || defined(SQLITE_DEBUG)
 /*
 ** This function is similar to sqlite3BtreeGetReserve(), except that it
 ** may only be called if it is guaranteed that the b-tree mutex is already
@@ -55076,25 +55507,33 @@ SQLITE_PRIVATE int sqlite3BtreeGetPageSize(Btree *p){
 ** database handle that owns *p, causing undefined behavior.
 */
 SQLITE_PRIVATE int sqlite3BtreeGetReserveNoMutex(Btree *p){
+  int n;
   assert( sqlite3_mutex_held(p->pBt->mutex) );
-  return p->pBt->pageSize - p->pBt->usableSize;
+  n = p->pBt->pageSize - p->pBt->usableSize;
+  return n;
 }
-#endif /* SQLITE_HAS_CODEC || SQLITE_DEBUG */
 
-#if !defined(SQLITE_OMIT_PAGER_PRAGMAS) || !defined(SQLITE_OMIT_VACUUM)
 /*
 ** Return the number of bytes of space at the end of every page that
 ** are intentually left unused.  This is the "reserved" space that is
 ** sometimes used by extensions.
+**
+** If SQLITE_HAS_MUTEX is defined then the number returned is the
+** greater of the current reserved space and the maximum requested
+** reserve space.
 */
-SQLITE_PRIVATE int sqlite3BtreeGetReserve(Btree *p){
+SQLITE_PRIVATE int sqlite3BtreeGetOptimalReserve(Btree *p){
   int n;
   sqlite3BtreeEnter(p);
-  n = p->pBt->pageSize - p->pBt->usableSize;
+  n = sqlite3BtreeGetReserveNoMutex(p);
+#ifdef SQLITE_HAS_CODEC
+  if( n<p->pBt->optimalReserve ) n = p->pBt->optimalReserve;
+#endif
   sqlite3BtreeLeave(p);
   return n;
 }
 
+
 /*
 ** Set the maximum page count for a database if mxPage is positive.
 ** No changes are made if mxPage is 0 or negative.
@@ -55125,7 +55564,6 @@ SQLITE_PRIVATE int sqlite3BtreeSecureDelete(Btree *p, int newFlag){
   sqlite3BtreeLeave(p);
   return b;
 }
-#endif /* !defined(SQLITE_OMIT_PAGER_PRAGMAS) || !defined(SQLITE_OMIT_VACUUM) */
 
 /*
 ** Change the 'auto-vacuum' property of the database. If the 'autoVacuum'
@@ -56245,7 +56683,7 @@ SQLITE_PRIVATE int sqlite3BtreeTripAllCursors(Btree *pBtree, int errCode, int wr
     for(p=pBtree->pBt->pCursor; p; p=p->pNext){
       int i;
       if( writeOnly && (p->curFlags & BTCF_WriteFlag)==0 ){
-        if( p->eState==CURSOR_VALID ){
+        if( p->eState==CURSOR_VALID || p->eState==CURSOR_SKIPNEXT ){
           rc = saveCursorPosition(p);
           if( rc!=SQLITE_OK ){
             (void)sqlite3BtreeTripAllCursors(pBtree, rc, 0);
@@ -56651,6 +57089,8 @@ SQLITE_PRIVATE int sqlite3BtreeKeySize(BtCursor *pCur, i64 *pSize){
 SQLITE_PRIVATE int sqlite3BtreeDataSize(BtCursor *pCur, u32 *pSize){
   assert( cursorHoldsMutex(pCur) );
   assert( pCur->eState==CURSOR_VALID );
+  assert( pCur->iPage>=0 );
+  assert( pCur->iPage<BTCURSOR_MAX_DEPTH );
   assert( pCur->apPage[pCur->iPage]->intKeyLeaf==1 );
   getCellInfo(pCur);
   *pSize = pCur->info.nPayload;
@@ -57059,13 +57499,18 @@ static const void *fetchPayload(
   BtCursor *pCur,      /* Cursor pointing to entry to read from */
   u32 *pAmt            /* Write the number of available bytes here */
 ){
+  u32 amt;
   assert( pCur!=0 && pCur->iPage>=0 && pCur->apPage[pCur->iPage]);
   assert( pCur->eState==CURSOR_VALID );
   assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );
   assert( cursorHoldsMutex(pCur) );
   assert( pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell );
   assert( pCur->info.nSize>0 );
-  *pAmt = pCur->info.nLocal;
+  assert( pCur->info.pPayload>pCur->apPage[pCur->iPage]->aData || CORRUPT_DB );
+  assert( pCur->info.pPayload<pCur->apPage[pCur->iPage]->aDataEnd ||CORRUPT_DB);
+  amt = (int)(pCur->apPage[pCur->iPage]->aDataEnd - pCur->info.pPayload);
+  if( pCur->info.nLocal<amt ) amt = pCur->info.nLocal;
+  *pAmt = amt;
   return (void*)pCur->info.pPayload;
 }
 
@@ -57129,7 +57574,7 @@ static int moveToChild(BtCursor *pCur, u32 newPgno){
   return SQLITE_OK;
 }
 
-#if 0
+#if SQLITE_DEBUG
 /*
 ** Page pParent is an internal (non-leaf) tree page. This function 
 ** asserts that page number iChild is the left-child if the iIdx'th
@@ -57138,6 +57583,8 @@ static int moveToChild(BtCursor *pCur, u32 newPgno){
 ** the page.
 */
 static void assertParentIndex(MemPage *pParent, int iIdx, Pgno iChild){
+  if( CORRUPT_DB ) return;  /* The conditions tested below might not be true
+                            ** in a corrupt database */
   assert( iIdx<=pParent->nCell );
   if( iIdx==pParent->nCell ){
     assert( get4byte(&pParent->aData[pParent->hdrOffset+8])==iChild );
@@ -57162,19 +57609,11 @@ static void moveToParent(BtCursor *pCur){
   assert( pCur->eState==CURSOR_VALID );
   assert( pCur->iPage>0 );
   assert( pCur->apPage[pCur->iPage] );
-
-  /* UPDATE: It is actually possible for the condition tested by the assert
-  ** below to be untrue if the database file is corrupt. This can occur if
-  ** one cursor has modified page pParent while a reference to it is held 
-  ** by a second cursor. Which can only happen if a single page is linked
-  ** into more than one b-tree structure in a corrupt database.  */
-#if 0
   assertParentIndex(
     pCur->apPage[pCur->iPage-1], 
     pCur->aiIdx[pCur->iPage-1], 
     pCur->apPage[pCur->iPage]->pgno
   );
-#endif
   testcase( pCur->aiIdx[pCur->iPage-1] > pCur->apPage[pCur->iPage-1]->nCell );
 
   releasePage(pCur->apPage[pCur->iPage]);
@@ -59349,7 +59788,6 @@ static int balance_nonroot(
     }else if( iParentIdx==i ){
       nxDiv = i-2+bBulk;
     }else{
-      assert( bBulk==0 );
       nxDiv = iParentIdx-1;
     }
     i = 2-bBulk;
@@ -60100,7 +60538,8 @@ static int balance(BtCursor *pCur){
           ** pSpace buffer passed to the latter call to balance_nonroot().
           */
           u8 *pSpace = sqlite3PageMalloc(pCur->pBt->pageSize);
-          rc = balance_nonroot(pParent, iIdx, pSpace, iPage==1, pCur->hints);
+          rc = balance_nonroot(pParent, iIdx, pSpace, iPage==1,
+                               pCur->hints&BTREE_BULKLOAD);
           if( pFree ){
             /* If pFree is not NULL, it points to the pSpace buffer used 
             ** by a previous call to balance_nonroot(). Its contents are
@@ -60121,6 +60560,7 @@ static int balance(BtCursor *pCur){
       /* The next iteration of the do-loop balances the parent page. */
       releasePage(pPage);
       pCur->iPage--;
+      assert( pCur->iPage>=0 );
     }
   }while( rc==SQLITE_OK );
 
@@ -60597,9 +61037,13 @@ static int clearDatabasePage(
   if( pgno>btreePagecount(pBt) ){
     return SQLITE_CORRUPT_BKPT;
   }
-
   rc = getAndInitPage(pBt, pgno, &pPage, 0);
   if( rc ) return rc;
+  if( pPage->bBusy ){
+    rc = SQLITE_CORRUPT_BKPT;
+    goto cleardatabasepage_out;
+  }
+  pPage->bBusy = 1;
   hdr = pPage->hdrOffset;
   for(i=0; i<pPage->nCell; i++){
     pCell = findCell(pPage, i);
@@ -60624,6 +61068,7 @@ static int clearDatabasePage(
   }
 
 cleardatabasepage_out:
+  pPage->bBusy = 0;
   releasePage(pPage);
   return rc;
 }
@@ -61131,6 +61576,57 @@ static void checkList(
 }
 #endif /* SQLITE_OMIT_INTEGRITY_CHECK */
 
+/*
+** An implementation of a min-heap.
+**
+** aHeap[0] is the number of elements on the heap.  aHeap[1] is the
+** root element.  The daughter nodes of aHeap[N] are aHeap[N*2]
+** and aHeap[N*2+1].
+**
+** The heap property is this:  Every node is less than or equal to both
+** of its daughter nodes.  A consequence of the heap property is that the
+** root node aHeap[1] is always the minimum value currently in the heap.
+**
+** The btreeHeapInsert() routine inserts an unsigned 32-bit number onto
+** the heap, preserving the heap property.  The btreeHeapPull() routine
+** removes the root element from the heap (the minimum value in the heap)
+** and then moves other nodes around as necessary to preserve the heap
+** property.
+**
+** This heap is used for cell overlap and coverage testing.  Each u32
+** entry represents the span of a cell or freeblock on a btree page.  
+** The upper 16 bits are the index of the first byte of a range and the
+** lower 16 bits are the index of the last byte of that range.
+*/
+static void btreeHeapInsert(u32 *aHeap, u32 x){
+  u32 j, i = ++aHeap[0];
+  aHeap[i] = x;
+  while( (j = i/2)>0 && aHeap[j]>aHeap[i] ){
+    x = aHeap[j];
+    aHeap[j] = aHeap[i];
+    aHeap[i] = x;
+    i = j;
+  }
+}
+static int btreeHeapPull(u32 *aHeap, u32 *pOut){
+  u32 j, i, x;
+  if( (x = aHeap[0])==0 ) return 0;
+  *pOut = aHeap[1];
+  aHeap[1] = aHeap[x];
+  aHeap[x] = 0xffffffff;
+  aHeap[0]--;
+  i = 1;
+  while( (j = i*2)<=aHeap[0] ){
+    if( aHeap[j]>aHeap[j+1] ) j++;
+    if( aHeap[i]<aHeap[j] ) break;
+    x = aHeap[i];
+    aHeap[i] = aHeap[j];
+    aHeap[j] = x;
+    i = j;
+  }
+  return 1;  
+}
+
 #ifndef SQLITE_OMIT_INTEGRITY_CHECK
 /*
 ** Do various sanity checks on a single page of a tree.  Return
@@ -61163,7 +61659,8 @@ static int checkTreePage(
   u8 *data;
   BtShared *pBt;
   int usableSize;
-  char *hit = 0;
+  u32 *heap = 0;
+  u32 x, prev = 0;
   i64 nMinKey = 0;
   i64 nMaxKey = 0;
   const char *saved_zPfx = pCheck->zPfx;
@@ -61308,15 +61805,15 @@ static int checkTreePage(
   */
   data = pPage->aData;
   hdr = pPage->hdrOffset;
-  hit = sqlite3PageMalloc( pBt->pageSize );
+  heap = (u32*)sqlite3PageMalloc( pBt->pageSize );
   pCheck->zPfx = 0;
-  if( hit==0 ){
+  if( heap==0 ){
     pCheck->mallocFailed = 1;
   }else{
     int contentOffset = get2byteNotZero(&data[hdr+5]);
     assert( contentOffset<=usableSize );  /* Enforced by btreeInitPage() */
-    memset(hit+contentOffset, 0, usableSize-contentOffset);
-    memset(hit, 1, contentOffset);
+    heap[0] = 0;
+    btreeHeapInsert(heap, contentOffset-1);
     /* EVIDENCE-OF: R-37002-32774 The two-byte integer at offset 3 gives the
     ** number of cells on the page. */
     nCell = get2byte(&data[hdr+3]);
@@ -61328,7 +61825,6 @@ static int checkTreePage(
     for(i=0; i<nCell; i++){
       int pc = get2byte(&data[cellStart+i*2]);
       u32 size = 65536;
-      int j;
       if( pc<=usableSize-4 ){
         size = cellSizePtr(pPage, &data[pc]);
       }
@@ -61337,7 +61833,7 @@ static int checkTreePage(
         checkAppendMsg(pCheck,
             "Corruption detected in cell %d on page %d",i,iPage);
       }else{
-        for(j=pc+size-1; j>=pc; j--) hit[j]++;
+        btreeHeapInsert(heap, (pc<<16)|(pc+size-1));
       }
     }
     /* EVIDENCE-OF: R-20690-50594 The second field of the b-tree page header
@@ -61349,7 +61845,7 @@ static int checkTreePage(
       assert( i<=usableSize-4 );     /* Enforced by btreeInitPage() */
       size = get2byte(&data[i+2]);
       assert( i+size<=usableSize );  /* Enforced by btreeInitPage() */
-      for(j=i+size-1; j>=i; j--) hit[j]++;
+      btreeHeapInsert(heap, (i<<16)|(i+size-1));
       /* EVIDENCE-OF: R-58208-19414 The first 2 bytes of a freeblock are a
       ** big-endian integer which is the offset in the b-tree page of the next
       ** freeblock in the chain, or zero if the freeblock is the last on the
@@ -61361,27 +61857,33 @@ static int checkTreePage(
       assert( j<=usableSize-4 );   /* Enforced by btreeInitPage() */
       i = j;
     }
-    for(i=cnt=0; i<usableSize; i++){
-      if( hit[i]==0 ){
-        cnt++;
-      }else if( hit[i]>1 ){
+    cnt = 0;
+    assert( heap[0]>0 );
+    assert( (heap[1]>>16)==0 );
+    btreeHeapPull(heap,&prev);
+    while( btreeHeapPull(heap,&x) ){
+      if( (prev&0xffff)+1>(x>>16) ){
         checkAppendMsg(pCheck,
-          "Multiple uses for byte %d of page %d", i, iPage);
+          "Multiple uses for byte %u of page %d", x>>16, iPage);
         break;
+      }else{
+        cnt += (x>>16) - (prev&0xffff) - 1;
+        prev = x;
       }
     }
+    cnt += usableSize - (prev&0xffff) - 1;
     /* EVIDENCE-OF: R-43263-13491 The total number of bytes in all fragments
     ** is stored in the fifth field of the b-tree page header.
     ** EVIDENCE-OF: R-07161-27322 The one-byte integer at offset 7 gives the
     ** number of fragmented free bytes within the cell content area.
     */
-    if( cnt!=data[hdr+7] ){
+    if( heap[0]==0 && cnt!=data[hdr+7] ){
       checkAppendMsg(pCheck,
           "Fragmentation of %d bytes reported as %d on page %d",
           cnt, data[hdr+7], iPage);
     }
   }
-  sqlite3PageFree(hit);
+  sqlite3PageFree(heap);
   releasePage(pPage);
 
 end_of_check:
@@ -61445,8 +61947,7 @@ SQLITE_PRIVATE char *sqlite3BtreeIntegrityCheck(
   }
   i = PENDING_BYTE_PAGE(pBt);
   if( i<=sCheck.nPage ) setPageReferenced(&sCheck, i);
-  sqlite3StrAccumInit(&sCheck.errMsg, zErr, sizeof(zErr), SQLITE_MAX_LENGTH);
-  sCheck.errMsg.useMalloc = 2;
+  sqlite3StrAccumInit(&sCheck.errMsg, 0, zErr, sizeof(zErr), SQLITE_MAX_LENGTH);
 
   /* Check the integrity of the freelist
   */
@@ -61763,14 +62264,23 @@ SQLITE_PRIVATE int sqlite3BtreeSetVersion(Btree *pBtree, int iVersion){
 }
 
 /*
-** set the mask of hint flags for cursor pCsr. Currently the only valid
-** values are 0 and BTREE_BULKLOAD.
+** set the mask of hint flags for cursor pCsr.
 */
 SQLITE_PRIVATE void sqlite3BtreeCursorHints(BtCursor *pCsr, unsigned int mask){
-  assert( mask==BTREE_BULKLOAD || mask==0 );
+  assert( mask==BTREE_BULKLOAD || mask==BTREE_SEEK_EQ || mask==0 );
   pCsr->hints = mask;
 }
 
+#ifdef SQLITE_DEBUG
+/*
+** Return true if the cursor has a hint specified.  This routine is
+** only used from within assert() statements
+*/
+SQLITE_PRIVATE int sqlite3BtreeCursorHasHint(BtCursor *pCsr, unsigned int mask){
+  return (pCsr->hints & mask)!=0;
+}
+#endif
+
 /*
 ** Return true if the given Btree is read-only.
 */
@@ -61929,7 +62439,7 @@ static int checkReadTransaction(sqlite3 *db, Btree *p){
 ** If an error occurs, NULL is returned and an error code and error message
 ** stored in database handle pDestDb.
 */
-SQLITE_API sqlite3_backup *sqlite3_backup_init(
+SQLITE_API sqlite3_backup *SQLITE_STDCALL sqlite3_backup_init(
   sqlite3* pDestDb,                     /* Database to write to */
   const char *zDestDb,                  /* Name of database within pDestDb */
   sqlite3* pSrcDb,                      /* Database connection to read from */
@@ -62032,7 +62542,7 @@ static int backupOnePage(
   ** guaranteed that the shared-mutex is held by this thread, handle
   ** p->pSrc may not actually be the owner.  */
   int nSrcReserve = sqlite3BtreeGetReserveNoMutex(p->pSrc);
-  int nDestReserve = sqlite3BtreeGetReserve(p->pDest);
+  int nDestReserve = sqlite3BtreeGetOptimalReserve(p->pDest);
 #endif
   int rc = SQLITE_OK;
   i64 iOff;
@@ -62137,7 +62647,7 @@ static void attachBackupObject(sqlite3_backup *p){
 /*
 ** Copy nPage pages from the source b-tree to the destination.
 */
-SQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage){
+SQLITE_API int SQLITE_STDCALL sqlite3_backup_step(sqlite3_backup *p, int nPage){
   int rc;
   int destMode;       /* Destination journal mode */
   int pgszSrc = 0;    /* Source page size */
@@ -62382,7 +62892,7 @@ SQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage){
 /*
 ** Release all resources associated with an sqlite3_backup* handle.
 */
-SQLITE_API int sqlite3_backup_finish(sqlite3_backup *p){
+SQLITE_API int SQLITE_STDCALL sqlite3_backup_finish(sqlite3_backup *p){
   sqlite3_backup **pp;                 /* Ptr to head of pagers backup list */
   sqlite3 *pSrcDb;                     /* Source database connection */
   int rc;                              /* Value to return */
@@ -62434,7 +62944,7 @@ SQLITE_API int sqlite3_backup_finish(sqlite3_backup *p){
 ** Return the number of pages still to be backed up as of the most recent
 ** call to sqlite3_backup_step().
 */
-SQLITE_API int sqlite3_backup_remaining(sqlite3_backup *p){
+SQLITE_API int SQLITE_STDCALL sqlite3_backup_remaining(sqlite3_backup *p){
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( p==0 ){
     (void)SQLITE_MISUSE_BKPT;
@@ -62448,7 +62958,7 @@ SQLITE_API int sqlite3_backup_remaining(sqlite3_backup *p){
 ** Return the total number of pages in the source database as of the most 
 ** recent call to sqlite3_backup_step().
 */
-SQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p){
+SQLITE_API int SQLITE_STDCALL sqlite3_backup_pagecount(sqlite3_backup *p){
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( p==0 ){
     (void)SQLITE_MISUSE_BKPT;
@@ -62773,10 +63283,11 @@ SQLITE_PRIVATE int sqlite3VdbeMemMakeWriteable(Mem *pMem){
     pMem->z[pMem->n] = 0;
     pMem->z[pMem->n+1] = 0;
     pMem->flags |= MEM_Term;
+  }
+  pMem->flags &= ~MEM_Ephem;
 #ifdef SQLITE_DEBUG
-    pMem->pScopyFrom = 0;
+  pMem->pScopyFrom = 0;
 #endif
-  }
 
   return SQLITE_OK;
 }
@@ -63663,7 +64174,7 @@ struct ValueNewStat4Ctx {
 ** Otherwise, if the second argument is non-zero, then this function is 
 ** being called indirectly by sqlite3Stat4ProbeSetValue(). If it has not
 ** already been allocated, allocate the UnpackedRecord structure that 
-** that function will return to its caller here. Then return a pointer 
+** that function will return to its caller here. Then return a pointer to
 ** an sqlite3_value within the UnpackedRecord.a[] array.
 */
 static sqlite3_value *valueNew(sqlite3 *db, struct ValueNewStat4Ctx *p){
@@ -63707,6 +64218,113 @@ static sqlite3_value *valueNew(sqlite3 *db, struct ValueNewStat4Ctx *p){
   return sqlite3ValueNew(db);
 }
 
+/*
+** The expression object indicated by the second argument is guaranteed
+** to be a scalar SQL function. If
+**
+**   * all function arguments are SQL literals,
+**   * the SQLITE_FUNC_CONSTANT function flag is set, and
+**   * the SQLITE_FUNC_NEEDCOLL function flag is not set,
+**
+** then this routine attempts to invoke the SQL function. Assuming no
+** error occurs, output parameter (*ppVal) is set to point to a value 
+** object containing the result before returning SQLITE_OK.
+**
+** Affinity aff is applied to the result of the function before returning.
+** If the result is a text value, the sqlite3_value object uses encoding 
+** enc.
+**
+** If the conditions above are not met, this function returns SQLITE_OK
+** and sets (*ppVal) to NULL. Or, if an error occurs, (*ppVal) is set to
+** NULL and an SQLite error code returned.
+*/
+#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+static int valueFromFunction(
+  sqlite3 *db,                    /* The database connection */
+  Expr *p,                        /* The expression to evaluate */
+  u8 enc,                         /* Encoding to use */
+  u8 aff,                         /* Affinity to use */
+  sqlite3_value **ppVal,          /* Write the new value here */
+  struct ValueNewStat4Ctx *pCtx   /* Second argument for valueNew() */
+){
+  sqlite3_context ctx;            /* Context object for function invocation */
+  sqlite3_value **apVal = 0;      /* Function arguments */
+  int nVal = 0;                   /* Size of apVal[] array */
+  FuncDef *pFunc = 0;             /* Function definition */
+  sqlite3_value *pVal = 0;        /* New value */
+  int rc = SQLITE_OK;             /* Return code */
+  int nName;                      /* Size of function name in bytes */
+  ExprList *pList = 0;            /* Function arguments */
+  int i;                          /* Iterator variable */
+
+  assert( pCtx!=0 );
+  assert( (p->flags & EP_TokenOnly)==0 );
+  pList = p->x.pList;
+  if( pList ) nVal = pList->nExpr;
+  nName = sqlite3Strlen30(p->u.zToken);
+  pFunc = sqlite3FindFunction(db, p->u.zToken, nName, nVal, enc, 0);
+  assert( pFunc );
+  if( (pFunc->funcFlags & SQLITE_FUNC_CONSTANT)==0 
+   || (pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL)
+  ){
+    return SQLITE_OK;
+  }
+
+  if( pList ){
+    apVal = (sqlite3_value**)sqlite3DbMallocZero(db, sizeof(apVal[0]) * nVal);
+    if( apVal==0 ){
+      rc = SQLITE_NOMEM;
+      goto value_from_function_out;
+    }
+    for(i=0; i<nVal; i++){
+      rc = sqlite3ValueFromExpr(db, pList->a[i].pExpr, enc, aff, &apVal[i]);
+      if( apVal[i]==0 || rc!=SQLITE_OK ) goto value_from_function_out;
+    }
+  }
+
+  pVal = valueNew(db, pCtx);
+  if( pVal==0 ){
+    rc = SQLITE_NOMEM;
+    goto value_from_function_out;
+  }
+
+  assert( pCtx->pParse->rc==SQLITE_OK );
+  memset(&ctx, 0, sizeof(ctx));
+  ctx.pOut = pVal;
+  ctx.pFunc = pFunc;
+  pFunc->xFunc(&ctx, nVal, apVal);
+  if( ctx.isError ){
+    rc = ctx.isError;
+    sqlite3ErrorMsg(pCtx->pParse, "%s", sqlite3_value_text(pVal));
+  }else{
+    sqlite3ValueApplyAffinity(pVal, aff, SQLITE_UTF8);
+    assert( rc==SQLITE_OK );
+    rc = sqlite3VdbeChangeEncoding(pVal, enc);
+    if( rc==SQLITE_OK && sqlite3VdbeMemTooBig(pVal) ){
+      rc = SQLITE_TOOBIG;
+      pCtx->pParse->nErr++;
+    }
+  }
+  pCtx->pParse->rc = rc;
+
+ value_from_function_out:
+  if( rc!=SQLITE_OK ){
+    pVal = 0;
+  }
+  if( apVal ){
+    for(i=0; i<nVal; i++){
+      sqlite3ValueFree(apVal[i]);
+    }
+    sqlite3DbFree(db, apVal);
+  }
+
+  *ppVal = pVal;
+  return rc;
+}
+#else
+# define valueFromFunction(a,b,c,d,e,f) SQLITE_OK
+#endif /* defined(SQLITE_ENABLE_STAT3_OR_STAT4) */
+
 /*
 ** Extract a value from the supplied expression in the manner described
 ** above sqlite3ValueFromExpr(). Allocate the sqlite3_value object
@@ -63739,6 +64357,12 @@ static int valueFromExpr(
   while( (op = pExpr->op)==TK_UPLUS ) pExpr = pExpr->pLeft;
   if( NEVER(op==TK_REGISTER) ) op = pExpr->op2;
 
+  /* Compressed expressions only appear when parsing the DEFAULT clause
+  ** on a table column definition, and hence only when pCtx==0.  This
+  ** check ensures that an EP_TokenOnly expression is never passed down
+  ** into valueFromFunction(). */
+  assert( (pExpr->flags & EP_TokenOnly)==0 || pCtx==0 );
+
   if( op==TK_CAST ){
     u8 aff = sqlite3AffinityType(pExpr->u.zToken,0);
     rc = valueFromExpr(db, pExpr->pLeft, enc, aff, ppVal, pCtx);
@@ -63815,6 +64439,12 @@ static int valueFromExpr(
   }
 #endif
 
+#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+  else if( op==TK_FUNCTION && pCtx!=0 ){
+    rc = valueFromFunction(db, pExpr, enc, affinity, &pVal, pCtx);
+  }
+#endif
+
   *ppVal = pVal;
   return rc;
 
@@ -64101,7 +64731,7 @@ SQLITE_PRIVATE void sqlite3Stat4ProbeFree(UnpackedRecord *pRec){
     Mem *aMem = pRec->aMem;
     sqlite3 *db = aMem[0].db;
     for(i=0; i<nCol; i++){
-      if( aMem[i].szMalloc ) sqlite3DbFree(db, aMem[i].zMalloc);
+      sqlite3VdbeMemRelease(&aMem[i]);
     }
     sqlite3KeyInfoUnref(pRec->pKeyInfo);
     sqlite3DbFree(db, pRec);
@@ -64204,7 +64834,7 @@ SQLITE_PRIVATE void sqlite3VdbeSetSql(Vdbe *p, const char *z, int n, int isPrepa
 /*
 ** Return the SQL associated with a prepared statement
 */
-SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt){
+SQLITE_API const char *SQLITE_STDCALL sqlite3_sql(sqlite3_stmt *pStmt){
   Vdbe *p = (Vdbe *)pStmt;
   return (p && p->isPrepareV2) ? p->zSql : 0;
 }
@@ -65267,7 +65897,7 @@ static char *displayP4(Op *pOp, char *zTemp, int nTemp){
 #ifndef SQLITE_OMIT_VIRTUALTABLE
     case P4_VTAB: {
       sqlite3_vtab *pVtab = pOp->p4.pVtab->pVtab;
-      sqlite3_snprintf(nTemp, zTemp, "vtab:%p:%p", pVtab, pVtab->pModule);
+      sqlite3_snprintf(nTemp, zTemp, "vtab:%p", pVtab);
       break;
     }
 #endif
@@ -65931,13 +66561,29 @@ SQLITE_PRIVATE void sqlite3VdbeFreeCursor(Vdbe *p, VdbeCursor *pCx){
   else if( pCx->pVtabCursor ){
     sqlite3_vtab_cursor *pVtabCursor = pCx->pVtabCursor;
     const sqlite3_module *pModule = pVtabCursor->pVtab->pModule;
-    p->inVtabMethod = 1;
+    assert( pVtabCursor->pVtab->nRef>0 );
+    pVtabCursor->pVtab->nRef--;
     pModule->xClose(pVtabCursor);
-    p->inVtabMethod = 0;
   }
 #endif
 }
 
+/*
+** Close all cursors in the current frame.
+*/
+static void closeCursorsInFrame(Vdbe *p){
+  if( p->apCsr ){
+    int i;
+    for(i=0; i<p->nCursor; i++){
+      VdbeCursor *pC = p->apCsr[i];
+      if( pC ){
+        sqlite3VdbeFreeCursor(p, pC);
+        p->apCsr[i] = 0;
+      }
+    }
+  }
+}
+
 /*
 ** Copy the values stored in the VdbeFrame structure to its Vdbe. This
 ** is used, for example, when a trigger sub-program is halted to restore
@@ -65945,6 +66591,7 @@ SQLITE_PRIVATE void sqlite3VdbeFreeCursor(Vdbe *p, VdbeCursor *pCx){
 */
 SQLITE_PRIVATE int sqlite3VdbeFrameRestore(VdbeFrame *pFrame){
   Vdbe *v = pFrame->v;
+  closeCursorsInFrame(v);
 #ifdef SQLITE_ENABLE_STMT_SCANSTATUS
   v->anExec = pFrame->anExec;
 #endif
@@ -65979,17 +66626,7 @@ static void closeAllCursors(Vdbe *p){
     p->nFrame = 0;
   }
   assert( p->nFrame==0 );
-
-  if( p->apCsr ){
-    int i;
-    for(i=0; i<p->nCursor; i++){
-      VdbeCursor *pC = p->apCsr[i];
-      if( pC ){
-        sqlite3VdbeFreeCursor(p, pC);
-        p->apCsr[i] = 0;
-      }
-    }
-  }
+  closeCursorsInFrame(p);
   if( p->aMem ){
     releaseMemArray(&p->aMem[1], p->nMem);
   }
@@ -66292,7 +66929,7 @@ static int vdbeCommit(sqlite3 *db, Vdbe *p){
     ** doing this the directory is synced again before any individual
     ** transaction files are deleted.
     */
-    rc = sqlite3OsDelete(pVfs, zMaster, 1);
+    rc = sqlite3OsDelete(pVfs, zMaster, needSync);
     sqlite3DbFree(db, zMaster);
     zMaster = 0;
     if( rc ){
@@ -67522,7 +68159,8 @@ static void vdbeAssertFieldCountWithinLimits(
 
   if( CORRUPT_DB ) return;
   idx = getVarint32(aKey, szHdr);
-  assert( szHdr<=nKey );
+  assert( nKey>=0 );
+  assert( szHdr<=(u32)nKey );
   while( idx<szHdr ){
     idx += getVarint32(aKey+idx, notUsed);
     nField++;
@@ -67733,7 +68371,7 @@ static i64 vdbeRecordDecodeInt(u32 serial_type, const u8 *aKey){
 ** pPKey2->errCode is set to SQLITE_NOMEM and, if it is not NULL, the
 ** malloc-failed flag set on database handle (pPKey2->pKeyInfo->db).
 */
-static int vdbeRecordCompareWithSkip(
+SQLITE_PRIVATE int sqlite3VdbeRecordCompareWithSkip(
   int nKey1, const void *pKey1,   /* Left key */
   UnpackedRecord *pPKey2,         /* Right key */
   int bSkip                       /* If true, skip the first field */
@@ -67919,7 +68557,7 @@ SQLITE_PRIVATE int sqlite3VdbeRecordCompare(
   int nKey1, const void *pKey1,   /* Left key */
   UnpackedRecord *pPKey2          /* Right key */
 ){
-  return vdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 0);
+  return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 0);
 }
 
 
@@ -68007,7 +68645,7 @@ static int vdbeRecordCompareInt(
   }else if( pPKey2->nField>1 ){
     /* The first fields of the two keys are equal. Compare the trailing 
     ** fields.  */
-    res = vdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);
+    res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);
   }else{
     /* The first fields of the two keys are equal and there are no trailing
     ** fields. Return pPKey2->default_rc in this case. */
@@ -68055,7 +68693,7 @@ static int vdbeRecordCompareString(
       res = nStr - pPKey2->aMem[0].n;
       if( res==0 ){
         if( pPKey2->nField>1 ){
-          res = vdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);
+          res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);
         }else{
           res = pPKey2->default_rc;
         }
@@ -68359,7 +68997,7 @@ SQLITE_PRIVATE void sqlite3VtabImportErrmsg(Vdbe *p, sqlite3_vtab *pVtab){
 ** collating sequences are registered or if an authorizer function is
 ** added or changed.
 */
-SQLITE_API int sqlite3_expired(sqlite3_stmt *pStmt){
+SQLITE_API int SQLITE_STDCALL sqlite3_expired(sqlite3_stmt *pStmt){
   Vdbe *p = (Vdbe*)pStmt;
   return p==0 || p->expired;
 }
@@ -68396,7 +69034,7 @@ static int vdbeSafetyNotNull(Vdbe *p){
 ** This routine sets the error code and string returned by
 ** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().
 */
-SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt){
+SQLITE_API int SQLITE_STDCALL sqlite3_finalize(sqlite3_stmt *pStmt){
   int rc;
   if( pStmt==0 ){
     /* IMPLEMENTATION-OF: R-57228-12904 Invoking sqlite3_finalize() on a NULL
@@ -68422,7 +69060,7 @@ SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt){
 ** This routine sets the error code and string returned by
 ** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().
 */
-SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt){
+SQLITE_API int SQLITE_STDCALL sqlite3_reset(sqlite3_stmt *pStmt){
   int rc;
   if( pStmt==0 ){
     rc = SQLITE_OK;
@@ -68441,7 +69079,7 @@ SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt){
 /*
 ** Set all the parameters in the compiled SQL statement to NULL.
 */
-SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt *pStmt){
+SQLITE_API int SQLITE_STDCALL sqlite3_clear_bindings(sqlite3_stmt *pStmt){
   int i;
   int rc = SQLITE_OK;
   Vdbe *p = (Vdbe*)pStmt;
@@ -68465,7 +69103,7 @@ SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt *pStmt){
 ** The following routines extract information from a Mem or sqlite3_value
 ** structure.
 */
-SQLITE_API const void *sqlite3_value_blob(sqlite3_value *pVal){
+SQLITE_API const void *SQLITE_STDCALL sqlite3_value_blob(sqlite3_value *pVal){
   Mem *p = (Mem*)pVal;
   if( p->flags & (MEM_Blob|MEM_Str) ){
     sqlite3VdbeMemExpandBlob(p);
@@ -68475,36 +69113,40 @@ SQLITE_API const void *sqlite3_value_blob(sqlite3_value *pVal){
     return sqlite3_value_text(pVal);
   }
 }
-SQLITE_API int sqlite3_value_bytes(sqlite3_value *pVal){
+SQLITE_API int SQLITE_STDCALL sqlite3_value_bytes(sqlite3_value *pVal){
   return sqlite3ValueBytes(pVal, SQLITE_UTF8);
 }
-SQLITE_API int sqlite3_value_bytes16(sqlite3_value *pVal){
+SQLITE_API int SQLITE_STDCALL sqlite3_value_bytes16(sqlite3_value *pVal){
   return sqlite3ValueBytes(pVal, SQLITE_UTF16NATIVE);
 }
-SQLITE_API double sqlite3_value_double(sqlite3_value *pVal){
+SQLITE_API double SQLITE_STDCALL sqlite3_value_double(sqlite3_value *pVal){
   return sqlite3VdbeRealValue((Mem*)pVal);
 }
-SQLITE_API int sqlite3_value_int(sqlite3_value *pVal){
+SQLITE_API int SQLITE_STDCALL sqlite3_value_int(sqlite3_value *pVal){
   return (int)sqlite3VdbeIntValue((Mem*)pVal);
 }
-SQLITE_API sqlite_int64 sqlite3_value_int64(sqlite3_value *pVal){
+SQLITE_API sqlite_int64 SQLITE_STDCALL sqlite3_value_int64(sqlite3_value *pVal){
   return sqlite3VdbeIntValue((Mem*)pVal);
 }
-SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value *pVal){
+SQLITE_API const unsigned char *SQLITE_STDCALL sqlite3_value_text(sqlite3_value *pVal){
   return (const unsigned char *)sqlite3ValueText(pVal, SQLITE_UTF8);
 }
 #ifndef SQLITE_OMIT_UTF16
-SQLITE_API const void *sqlite3_value_text16(sqlite3_value* pVal){
+SQLITE_API const void *SQLITE_STDCALL sqlite3_value_text16(sqlite3_value* pVal){
   return sqlite3ValueText(pVal, SQLITE_UTF16NATIVE);
 }
-SQLITE_API const void *sqlite3_value_text16be(sqlite3_value *pVal){
+SQLITE_API const void *SQLITE_STDCALL sqlite3_value_text16be(sqlite3_value *pVal){
   return sqlite3ValueText(pVal, SQLITE_UTF16BE);
 }
-SQLITE_API const void *sqlite3_value_text16le(sqlite3_value *pVal){
+SQLITE_API const void *SQLITE_STDCALL sqlite3_value_text16le(sqlite3_value *pVal){
   return sqlite3ValueText(pVal, SQLITE_UTF16LE);
 }
 #endif /* SQLITE_OMIT_UTF16 */
-SQLITE_API int sqlite3_value_type(sqlite3_value* pVal){
+/* EVIDENCE-OF: R-12793-43283 Every value in SQLite has one of five
+** fundamental datatypes: 64-bit signed integer 64-bit IEEE floating
+** point number string BLOB NULL
+*/
+SQLITE_API int SQLITE_STDCALL sqlite3_value_type(sqlite3_value* pVal){
   static const u8 aType[] = {
      SQLITE_BLOB,     /* 0x00 */
      SQLITE_NULL,     /* 0x01 */
@@ -68580,7 +69222,7 @@ static int invokeValueDestructor(
   if( pCtx ) sqlite3_result_error_toobig(pCtx);
   return SQLITE_TOOBIG;
 }
-SQLITE_API void sqlite3_result_blob(
+SQLITE_API void SQLITE_STDCALL sqlite3_result_blob(
   sqlite3_context *pCtx, 
   const void *z, 
   int n, 
@@ -68590,7 +69232,7 @@ SQLITE_API void sqlite3_result_blob(
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   setResultStrOrError(pCtx, z, n, 0, xDel);
 }
-SQLITE_API void sqlite3_result_blob64(
+SQLITE_API void SQLITE_STDCALL sqlite3_result_blob64(
   sqlite3_context *pCtx, 
   const void *z, 
   sqlite3_uint64 n,
@@ -68604,37 +69246,37 @@ SQLITE_API void sqlite3_result_blob64(
     setResultStrOrError(pCtx, z, (int)n, 0, xDel);
   }
 }
-SQLITE_API void sqlite3_result_double(sqlite3_context *pCtx, double rVal){
+SQLITE_API void SQLITE_STDCALL sqlite3_result_double(sqlite3_context *pCtx, double rVal){
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   sqlite3VdbeMemSetDouble(pCtx->pOut, rVal);
 }
-SQLITE_API void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){
+SQLITE_API void SQLITE_STDCALL sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   pCtx->isError = SQLITE_ERROR;
   pCtx->fErrorOrAux = 1;
   sqlite3VdbeMemSetStr(pCtx->pOut, z, n, SQLITE_UTF8, SQLITE_TRANSIENT);
 }
 #ifndef SQLITE_OMIT_UTF16
-SQLITE_API void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){
+SQLITE_API void SQLITE_STDCALL sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   pCtx->isError = SQLITE_ERROR;
   pCtx->fErrorOrAux = 1;
   sqlite3VdbeMemSetStr(pCtx->pOut, z, n, SQLITE_UTF16NATIVE, SQLITE_TRANSIENT);
 }
 #endif
-SQLITE_API void sqlite3_result_int(sqlite3_context *pCtx, int iVal){
+SQLITE_API void SQLITE_STDCALL sqlite3_result_int(sqlite3_context *pCtx, int iVal){
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   sqlite3VdbeMemSetInt64(pCtx->pOut, (i64)iVal);
 }
-SQLITE_API void sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal){
+SQLITE_API void SQLITE_STDCALL sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal){
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   sqlite3VdbeMemSetInt64(pCtx->pOut, iVal);
 }
-SQLITE_API void sqlite3_result_null(sqlite3_context *pCtx){
+SQLITE_API void SQLITE_STDCALL sqlite3_result_null(sqlite3_context *pCtx){
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   sqlite3VdbeMemSetNull(pCtx->pOut);
 }
-SQLITE_API void sqlite3_result_text(
+SQLITE_API void SQLITE_STDCALL sqlite3_result_text(
   sqlite3_context *pCtx, 
   const char *z, 
   int n,
@@ -68643,7 +69285,7 @@ SQLITE_API void sqlite3_result_text(
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   setResultStrOrError(pCtx, z, n, SQLITE_UTF8, xDel);
 }
-SQLITE_API void sqlite3_result_text64(
+SQLITE_API void SQLITE_STDCALL sqlite3_result_text64(
   sqlite3_context *pCtx, 
   const char *z, 
   sqlite3_uint64 n,
@@ -68660,7 +69302,7 @@ SQLITE_API void sqlite3_result_text64(
   }
 }
 #ifndef SQLITE_OMIT_UTF16
-SQLITE_API void sqlite3_result_text16(
+SQLITE_API void SQLITE_STDCALL sqlite3_result_text16(
   sqlite3_context *pCtx, 
   const void *z, 
   int n, 
@@ -68669,7 +69311,7 @@ SQLITE_API void sqlite3_result_text16(
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   setResultStrOrError(pCtx, z, n, SQLITE_UTF16NATIVE, xDel);
 }
-SQLITE_API void sqlite3_result_text16be(
+SQLITE_API void SQLITE_STDCALL sqlite3_result_text16be(
   sqlite3_context *pCtx, 
   const void *z, 
   int n, 
@@ -68678,7 +69320,7 @@ SQLITE_API void sqlite3_result_text16be(
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   setResultStrOrError(pCtx, z, n, SQLITE_UTF16BE, xDel);
 }
-SQLITE_API void sqlite3_result_text16le(
+SQLITE_API void SQLITE_STDCALL sqlite3_result_text16le(
   sqlite3_context *pCtx, 
   const void *z, 
   int n, 
@@ -68688,17 +69330,20 @@ SQLITE_API void sqlite3_result_text16le(
   setResultStrOrError(pCtx, z, n, SQLITE_UTF16LE, xDel);
 }
 #endif /* SQLITE_OMIT_UTF16 */
-SQLITE_API void sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue){
+SQLITE_API void SQLITE_STDCALL sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue){
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   sqlite3VdbeMemCopy(pCtx->pOut, pValue);
 }
-SQLITE_API void sqlite3_result_zeroblob(sqlite3_context *pCtx, int n){
+SQLITE_API void SQLITE_STDCALL sqlite3_result_zeroblob(sqlite3_context *pCtx, int n){
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   sqlite3VdbeMemSetZeroBlob(pCtx->pOut, n);
 }
-SQLITE_API void sqlite3_result_error_code(sqlite3_context *pCtx, int errCode){
+SQLITE_API void SQLITE_STDCALL sqlite3_result_error_code(sqlite3_context *pCtx, int errCode){
   pCtx->isError = errCode;
   pCtx->fErrorOrAux = 1;
+#ifdef SQLITE_DEBUG
+  if( pCtx->pVdbe ) pCtx->pVdbe->rcApp = errCode;
+#endif
   if( pCtx->pOut->flags & MEM_Null ){
     sqlite3VdbeMemSetStr(pCtx->pOut, sqlite3ErrStr(errCode), -1, 
                          SQLITE_UTF8, SQLITE_STATIC);
@@ -68706,7 +69351,7 @@ SQLITE_API void sqlite3_result_error_code(sqlite3_context *pCtx, int errCode){
 }
 
 /* Force an SQLITE_TOOBIG error. */
-SQLITE_API void sqlite3_result_error_toobig(sqlite3_context *pCtx){
+SQLITE_API void SQLITE_STDCALL sqlite3_result_error_toobig(sqlite3_context *pCtx){
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   pCtx->isError = SQLITE_TOOBIG;
   pCtx->fErrorOrAux = 1;
@@ -68715,7 +69360,7 @@ SQLITE_API void sqlite3_result_error_toobig(sqlite3_context *pCtx){
 }
 
 /* An SQLITE_NOMEM error. */
-SQLITE_API void sqlite3_result_error_nomem(sqlite3_context *pCtx){
+SQLITE_API void SQLITE_STDCALL sqlite3_result_error_nomem(sqlite3_context *pCtx){
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   sqlite3VdbeMemSetNull(pCtx->pOut);
   pCtx->isError = SQLITE_NOMEM;
@@ -68779,7 +69424,7 @@ static int sqlite3Step(Vdbe *p){
     ** or SQLITE_BUSY error.
     */
 #ifdef SQLITE_OMIT_AUTORESET
-    if( p->rc==SQLITE_BUSY || p->rc==SQLITE_LOCKED ){
+    if( (rc = p->rc&0xff)==SQLITE_BUSY || rc==SQLITE_LOCKED ){
       sqlite3_reset((sqlite3_stmt*)p);
     }else{
       return SQLITE_MISUSE_BKPT;
@@ -68825,6 +69470,9 @@ static int sqlite3Step(Vdbe *p){
     if( p->bIsReader ) db->nVdbeRead++;
     p->pc = 0;
   }
+#ifdef SQLITE_DEBUG
+  p->rcApp = SQLITE_OK;
+#endif
 #ifndef SQLITE_OMIT_EXPLAIN
   if( p->explain ){
     rc = sqlite3VdbeList(p);
@@ -68869,7 +69517,7 @@ static int sqlite3Step(Vdbe *p){
   assert( rc==SQLITE_ROW  || rc==SQLITE_DONE   || rc==SQLITE_ERROR 
        || rc==SQLITE_BUSY || rc==SQLITE_MISUSE
   );
-  assert( p->rc!=SQLITE_ROW && p->rc!=SQLITE_DONE );
+  assert( (p->rc!=SQLITE_ROW && p->rc!=SQLITE_DONE) || p->rc==p->rcApp );
   if( p->isPrepareV2 && rc!=SQLITE_ROW && rc!=SQLITE_DONE ){
     /* If this statement was prepared using sqlite3_prepare_v2(), and an
     ** error has occurred, then return the error code in p->rc to the
@@ -68885,7 +69533,7 @@ static int sqlite3Step(Vdbe *p){
 ** sqlite3Step() to do most of the work.  If a schema error occurs,
 ** call sqlite3Reprepare() and try again.
 */
-SQLITE_API int sqlite3_step(sqlite3_stmt *pStmt){
+SQLITE_API int SQLITE_STDCALL sqlite3_step(sqlite3_stmt *pStmt){
   int rc = SQLITE_OK;      /* Result from sqlite3Step() */
   int rc2 = SQLITE_OK;     /* Result from sqlite3Reprepare() */
   Vdbe *v = (Vdbe*)pStmt;  /* the prepared statement */
@@ -68936,7 +69584,7 @@ SQLITE_API int sqlite3_step(sqlite3_stmt *pStmt){
 ** Extract the user data from a sqlite3_context structure and return a
 ** pointer to it.
 */
-SQLITE_API void *sqlite3_user_data(sqlite3_context *p){
+SQLITE_API void *SQLITE_STDCALL sqlite3_user_data(sqlite3_context *p){
   assert( p && p->pFunc );
   return p->pFunc->pUserData;
 }
@@ -68951,22 +69599,32 @@ SQLITE_API void *sqlite3_user_data(sqlite3_context *p){
 ** sqlite3_create_function16() routines that originally registered the
 ** application defined function.
 */
-SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context *p){
+SQLITE_API sqlite3 *SQLITE_STDCALL sqlite3_context_db_handle(sqlite3_context *p){
   assert( p && p->pFunc );
   return p->pOut->db;
 }
 
 /*
-** Return the current time for a statement
+** Return the current time for a statement.  If the current time
+** is requested more than once within the same run of a single prepared
+** statement, the exact same time is returned for each invocation regardless
+** of the amount of time that elapses between invocations.  In other words,
+** the time returned is always the time of the first call.
 */
 SQLITE_PRIVATE sqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context *p){
-  Vdbe *v = p->pVdbe;
   int rc;
-  if( v->iCurrentTime==0 ){
-    rc = sqlite3OsCurrentTimeInt64(p->pOut->db->pVfs, &v->iCurrentTime);
-    if( rc ) v->iCurrentTime = 0;
+#ifndef SQLITE_ENABLE_STAT3_OR_STAT4
+  sqlite3_int64 *piTime = &p->pVdbe->iCurrentTime;
+  assert( p->pVdbe!=0 );
+#else
+  sqlite3_int64 iTime = 0;
+  sqlite3_int64 *piTime = p->pVdbe!=0 ? &p->pVdbe->iCurrentTime : &iTime;
+#endif
+  if( *piTime==0 ){
+    rc = sqlite3OsCurrentTimeInt64(p->pOut->db->pVfs, piTime);
+    if( rc ) *piTime = 0;
   }
-  return v->iCurrentTime;
+  return *piTime;
 }
 
 /*
@@ -69017,7 +69675,7 @@ static SQLITE_NOINLINE void *createAggContext(sqlite3_context *p, int nByte){
 ** context is allocated on the first call.  Subsequent calls return the
 ** same context that was returned on prior calls.
 */
-SQLITE_API void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){
+SQLITE_API void *SQLITE_STDCALL sqlite3_aggregate_context(sqlite3_context *p, int nByte){
   assert( p && p->pFunc && p->pFunc->xStep );
   assert( sqlite3_mutex_held(p->pOut->db->mutex) );
   testcase( nByte<0 );
@@ -69032,10 +69690,15 @@ SQLITE_API void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){
 ** Return the auxiliary data pointer, if any, for the iArg'th argument to
 ** the user-function defined by pCtx.
 */
-SQLITE_API void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){
+SQLITE_API void *SQLITE_STDCALL sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){
   AuxData *pAuxData;
 
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
+#if SQLITE_ENABLE_STAT3_OR_STAT4
+  if( pCtx->pVdbe==0 ) return 0;
+#else
+  assert( pCtx->pVdbe!=0 );
+#endif
   for(pAuxData=pCtx->pVdbe->pAuxData; pAuxData; pAuxData=pAuxData->pNext){
     if( pAuxData->iOp==pCtx->iOp && pAuxData->iArg==iArg ) break;
   }
@@ -69048,7 +69711,7 @@ SQLITE_API void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){
 ** argument to the user-function defined by pCtx. Any previous value is
 ** deleted by calling the delete function specified when it was set.
 */
-SQLITE_API void sqlite3_set_auxdata(
+SQLITE_API void SQLITE_STDCALL sqlite3_set_auxdata(
   sqlite3_context *pCtx, 
   int iArg, 
   void *pAux, 
@@ -69059,6 +69722,11 @@ SQLITE_API void sqlite3_set_auxdata(
 
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   if( iArg<0 ) goto failed;
+#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+  if( pVdbe==0 ) goto failed;
+#else
+  assert( pVdbe!=0 );
+#endif
 
   for(pAuxData=pVdbe->pAuxData; pAuxData; pAuxData=pAuxData->pNext){
     if( pAuxData->iOp==pCtx->iOp && pAuxData->iArg==iArg ) break;
@@ -69098,7 +69766,7 @@ SQLITE_API void sqlite3_set_auxdata(
 ** implementations should keep their own counts within their aggregate
 ** context.
 */
-SQLITE_API int sqlite3_aggregate_count(sqlite3_context *p){
+SQLITE_API int SQLITE_STDCALL sqlite3_aggregate_count(sqlite3_context *p){
   assert( p && p->pMem && p->pFunc && p->pFunc->xStep );
   return p->pMem->n;
 }
@@ -69107,7 +69775,7 @@ SQLITE_API int sqlite3_aggregate_count(sqlite3_context *p){
 /*
 ** Return the number of columns in the result set for the statement pStmt.
 */
-SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt){
+SQLITE_API int SQLITE_STDCALL sqlite3_column_count(sqlite3_stmt *pStmt){
   Vdbe *pVm = (Vdbe *)pStmt;
   return pVm ? pVm->nResColumn : 0;
 }
@@ -69116,7 +69784,7 @@ SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt){
 ** Return the number of values available from the current row of the
 ** currently executing statement pStmt.
 */
-SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt){
+SQLITE_API int SQLITE_STDCALL sqlite3_data_count(sqlite3_stmt *pStmt){
   Vdbe *pVm = (Vdbe *)pStmt;
   if( pVm==0 || pVm->pResultSet==0 ) return 0;
   return pVm->nResColumn;
@@ -69218,7 +69886,7 @@ static void columnMallocFailure(sqlite3_stmt *pStmt)
 ** The following routines are used to access elements of the current row
 ** in the result set.
 */
-SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_blob(sqlite3_stmt *pStmt, int i){
   const void *val;
   val = sqlite3_value_blob( columnMem(pStmt,i) );
   /* Even though there is no encoding conversion, value_blob() might
@@ -69228,37 +69896,37 @@ SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){
   columnMallocFailure(pStmt);
   return val;
 }
-SQLITE_API int sqlite3_column_bytes(sqlite3_stmt *pStmt, int i){
+SQLITE_API int SQLITE_STDCALL sqlite3_column_bytes(sqlite3_stmt *pStmt, int i){
   int val = sqlite3_value_bytes( columnMem(pStmt,i) );
   columnMallocFailure(pStmt);
   return val;
 }
-SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i){
+SQLITE_API int SQLITE_STDCALL sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i){
   int val = sqlite3_value_bytes16( columnMem(pStmt,i) );
   columnMallocFailure(pStmt);
   return val;
 }
-SQLITE_API double sqlite3_column_double(sqlite3_stmt *pStmt, int i){
+SQLITE_API double SQLITE_STDCALL sqlite3_column_double(sqlite3_stmt *pStmt, int i){
   double val = sqlite3_value_double( columnMem(pStmt,i) );
   columnMallocFailure(pStmt);
   return val;
 }
-SQLITE_API int sqlite3_column_int(sqlite3_stmt *pStmt, int i){
+SQLITE_API int SQLITE_STDCALL sqlite3_column_int(sqlite3_stmt *pStmt, int i){
   int val = sqlite3_value_int( columnMem(pStmt,i) );
   columnMallocFailure(pStmt);
   return val;
 }
-SQLITE_API sqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i){
+SQLITE_API sqlite_int64 SQLITE_STDCALL sqlite3_column_int64(sqlite3_stmt *pStmt, int i){
   sqlite_int64 val = sqlite3_value_int64( columnMem(pStmt,i) );
   columnMallocFailure(pStmt);
   return val;
 }
-SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i){
+SQLITE_API const unsigned char *SQLITE_STDCALL sqlite3_column_text(sqlite3_stmt *pStmt, int i){
   const unsigned char *val = sqlite3_value_text( columnMem(pStmt,i) );
   columnMallocFailure(pStmt);
   return val;
 }
-SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i){
+SQLITE_API sqlite3_value *SQLITE_STDCALL sqlite3_column_value(sqlite3_stmt *pStmt, int i){
   Mem *pOut = columnMem(pStmt, i);
   if( pOut->flags&MEM_Static ){
     pOut->flags &= ~MEM_Static;
@@ -69268,13 +69936,13 @@ SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i){
   return (sqlite3_value *)pOut;
 }
 #ifndef SQLITE_OMIT_UTF16
-SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i){
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_text16(sqlite3_stmt *pStmt, int i){
   const void *val = sqlite3_value_text16( columnMem(pStmt,i) );
   columnMallocFailure(pStmt);
   return val;
 }
 #endif /* SQLITE_OMIT_UTF16 */
-SQLITE_API int sqlite3_column_type(sqlite3_stmt *pStmt, int i){
+SQLITE_API int SQLITE_STDCALL sqlite3_column_type(sqlite3_stmt *pStmt, int i){
   int iType = sqlite3_value_type( columnMem(pStmt,i) );
   columnMallocFailure(pStmt);
   return iType;
@@ -69338,12 +70006,12 @@ static const void *columnName(
 ** Return the name of the Nth column of the result set returned by SQL
 ** statement pStmt.
 */
-SQLITE_API const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N){
+SQLITE_API const char *SQLITE_STDCALL sqlite3_column_name(sqlite3_stmt *pStmt, int N){
   return columnName(
       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_NAME);
 }
 #ifndef SQLITE_OMIT_UTF16
-SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_name16(sqlite3_stmt *pStmt, int N){
   return columnName(
       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_NAME);
 }
@@ -69363,12 +70031,12 @@ SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){
 ** Return the column declaration type (if applicable) of the 'i'th column
 ** of the result set of SQL statement pStmt.
 */
-SQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){
+SQLITE_API const char *SQLITE_STDCALL sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){
   return columnName(
       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_DECLTYPE);
 }
 #ifndef SQLITE_OMIT_UTF16
-SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){
   return columnName(
       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_DECLTYPE);
 }
@@ -69381,12 +70049,12 @@ SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){
 ** NULL is returned if the result column is an expression or constant or
 ** anything else which is not an unambiguous reference to a database column.
 */
-SQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int N){
+SQLITE_API const char *SQLITE_STDCALL sqlite3_column_database_name(sqlite3_stmt *pStmt, int N){
   return columnName(
       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_DATABASE);
 }
 #ifndef SQLITE_OMIT_UTF16
-SQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N){
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N){
   return columnName(
       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_DATABASE);
 }
@@ -69397,12 +70065,12 @@ SQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N
 ** NULL is returned if the result column is an expression or constant or
 ** anything else which is not an unambiguous reference to a database column.
 */
-SQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int N){
+SQLITE_API const char *SQLITE_STDCALL sqlite3_column_table_name(sqlite3_stmt *pStmt, int N){
   return columnName(
       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_TABLE);
 }
 #ifndef SQLITE_OMIT_UTF16
-SQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){
   return columnName(
       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_TABLE);
 }
@@ -69413,12 +70081,12 @@ SQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){
 ** NULL is returned if the result column is an expression or constant or
 ** anything else which is not an unambiguous reference to a database column.
 */
-SQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N){
+SQLITE_API const char *SQLITE_STDCALL sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N){
   return columnName(
       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_COLUMN);
 }
 #ifndef SQLITE_OMIT_UTF16
-SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N){
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N){
   return columnName(
       pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_COLUMN);
 }
@@ -69519,7 +70187,7 @@ static int bindText(
 /*
 ** Bind a blob value to an SQL statement variable.
 */
-SQLITE_API int sqlite3_bind_blob(
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_blob(
   sqlite3_stmt *pStmt, 
   int i, 
   const void *zData, 
@@ -69528,7 +70196,7 @@ SQLITE_API int sqlite3_bind_blob(
 ){
   return bindText(pStmt, i, zData, nData, xDel, 0);
 }
-SQLITE_API int sqlite3_bind_blob64(
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_blob64(
   sqlite3_stmt *pStmt, 
   int i, 
   const void *zData, 
@@ -69542,7 +70210,7 @@ SQLITE_API int sqlite3_bind_blob64(
     return bindText(pStmt, i, zData, (int)nData, xDel, 0);
   }
 }
-SQLITE_API int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){
   int rc;
   Vdbe *p = (Vdbe *)pStmt;
   rc = vdbeUnbind(p, i);
@@ -69552,10 +70220,10 @@ SQLITE_API int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){
   }
   return rc;
 }
-SQLITE_API int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){
   return sqlite3_bind_int64(p, i, (i64)iValue);
 }
-SQLITE_API int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){
   int rc;
   Vdbe *p = (Vdbe *)pStmt;
   rc = vdbeUnbind(p, i);
@@ -69565,7 +70233,7 @@ SQLITE_API int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValu
   }
   return rc;
 }
-SQLITE_API int sqlite3_bind_null(sqlite3_stmt *pStmt, int i){
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_null(sqlite3_stmt *pStmt, int i){
   int rc;
   Vdbe *p = (Vdbe*)pStmt;
   rc = vdbeUnbind(p, i);
@@ -69574,7 +70242,7 @@ SQLITE_API int sqlite3_bind_null(sqlite3_stmt *pStmt, int i){
   }
   return rc;
 }
-SQLITE_API int sqlite3_bind_text( 
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_text( 
   sqlite3_stmt *pStmt, 
   int i, 
   const char *zData, 
@@ -69583,7 +70251,7 @@ SQLITE_API int sqlite3_bind_text(
 ){
   return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF8);
 }
-SQLITE_API int sqlite3_bind_text64( 
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_text64( 
   sqlite3_stmt *pStmt, 
   int i, 
   const char *zData, 
@@ -69600,7 +70268,7 @@ SQLITE_API int sqlite3_bind_text64(
   }
 }
 #ifndef SQLITE_OMIT_UTF16
-SQLITE_API int sqlite3_bind_text16(
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_text16(
   sqlite3_stmt *pStmt, 
   int i, 
   const void *zData, 
@@ -69610,7 +70278,7 @@ SQLITE_API int sqlite3_bind_text16(
   return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF16NATIVE);
 }
 #endif /* SQLITE_OMIT_UTF16 */
-SQLITE_API int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){
   int rc;
   switch( sqlite3_value_type((sqlite3_value*)pValue) ){
     case SQLITE_INTEGER: {
@@ -69641,7 +70309,7 @@ SQLITE_API int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_valu
   }
   return rc;
 }
-SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){
   int rc;
   Vdbe *p = (Vdbe *)pStmt;
   rc = vdbeUnbind(p, i);
@@ -69656,7 +70324,7 @@ SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){
 ** Return the number of wildcards that can be potentially bound to.
 ** This routine is added to support DBD::SQLite.  
 */
-SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){
   Vdbe *p = (Vdbe*)pStmt;
   return p ? p->nVar : 0;
 }
@@ -69667,7 +70335,7 @@ SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){
 **
 ** The result is always UTF-8.
 */
-SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){
+SQLITE_API const char *SQLITE_STDCALL sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){
   Vdbe *p = (Vdbe*)pStmt;
   if( p==0 || i<1 || i>p->nzVar ){
     return 0;
@@ -69695,7 +70363,7 @@ SQLITE_PRIVATE int sqlite3VdbeParameterIndex(Vdbe *p, const char *zName, int nNa
   }
   return 0;
 }
-SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){
   return sqlite3VdbeParameterIndex((Vdbe*)pStmt, zName, sqlite3Strlen30(zName));
 }
 
@@ -69729,7 +70397,7 @@ SQLITE_PRIVATE int sqlite3TransferBindings(sqlite3_stmt *pFromStmt, sqlite3_stmt
 ** an SQLITE_ERROR is returned.  Nothing else can go wrong, so otherwise
 ** SQLITE_OK is returned.
 */
-SQLITE_API int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){
+SQLITE_API int SQLITE_STDCALL sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){
   Vdbe *pFrom = (Vdbe*)pFromStmt;
   Vdbe *pTo = (Vdbe*)pToStmt;
   if( pFrom->nVar!=pTo->nVar ){
@@ -69751,7 +70419,7 @@ SQLITE_API int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *
 ** the first argument to the sqlite3_prepare() that was used to create
 ** the statement in the first place.
 */
-SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){
+SQLITE_API sqlite3 *SQLITE_STDCALL sqlite3_db_handle(sqlite3_stmt *pStmt){
   return pStmt ? ((Vdbe*)pStmt)->db : 0;
 }
 
@@ -69759,14 +70427,14 @@ SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){
 ** Return true if the prepared statement is guaranteed to not modify the
 ** database.
 */
-SQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt){
+SQLITE_API int SQLITE_STDCALL sqlite3_stmt_readonly(sqlite3_stmt *pStmt){
   return pStmt ? ((Vdbe*)pStmt)->readOnly : 1;
 }
 
 /*
 ** Return true if the prepared statement is in need of being reset.
 */
-SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt *pStmt){
+SQLITE_API int SQLITE_STDCALL sqlite3_stmt_busy(sqlite3_stmt *pStmt){
   Vdbe *v = (Vdbe*)pStmt;
   return v!=0 && v->pc>=0 && v->magic==VDBE_MAGIC_RUN;
 }
@@ -69777,7 +70445,7 @@ SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt *pStmt){
 ** prepared statement for the database connection.  Return NULL if there
 ** are no more.
 */
-SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt){
+SQLITE_API sqlite3_stmt *SQLITE_STDCALL sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt){
   sqlite3_stmt *pNext;
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(pDb) ){
@@ -69798,7 +70466,7 @@ SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt){
 /*
 ** Return the value of a status counter for a prepared statement
 */
-SQLITE_API int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag){
+SQLITE_API int SQLITE_STDCALL sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag){
   Vdbe *pVdbe = (Vdbe*)pStmt;
   u32 v;
 #ifdef SQLITE_ENABLE_API_ARMOR
@@ -69816,7 +70484,7 @@ SQLITE_API int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag){
 /*
 ** Return status data for a single loop within query pStmt.
 */
-SQLITE_API int sqlite3_stmt_scanstatus(
+SQLITE_API int SQLITE_STDCALL sqlite3_stmt_scanstatus(
   sqlite3_stmt *pStmt,            /* Prepared statement being queried */
   int idx,                        /* Index of loop to report on */
   int iScanStatusOp,              /* Which metric to return */
@@ -69875,7 +70543,7 @@ SQLITE_API int sqlite3_stmt_scanstatus(
 /*
 ** Zero all counters associated with the sqlite3_stmt_scanstatus() data.
 */
-SQLITE_API void sqlite3_stmt_scanstatus_reset(sqlite3_stmt *pStmt){
+SQLITE_API void SQLITE_STDCALL sqlite3_stmt_scanstatus_reset(sqlite3_stmt *pStmt){
   Vdbe *p = (Vdbe*)pStmt;
   memset(p->anExec, 0, p->nOp * sizeof(i64));
 }
@@ -69967,9 +70635,8 @@ SQLITE_PRIVATE char *sqlite3VdbeExpandSql(
   char zBase[100];         /* Initial working space */
 
   db = p->db;
-  sqlite3StrAccumInit(&out, zBase, sizeof(zBase), 
+  sqlite3StrAccumInit(&out, db, zBase, sizeof(zBase), 
                       db->aLimit[SQLITE_LIMIT_LENGTH]);
-  out.db = db;
   if( db->nVdbeExec>1 ){
     while( *zRawSql ){
       const char *zStart = zRawSql;
@@ -69978,6 +70645,8 @@ SQLITE_PRIVATE char *sqlite3VdbeExpandSql(
       assert( (zRawSql - zStart) > 0 );
       sqlite3StrAccumAppend(&out, zStart, (int)(zRawSql-zStart));
     }
+  }else if( p->nVar==0 ){
+    sqlite3StrAccumAppend(&out, zRawSql, sqlite3Strlen30(zRawSql));
   }else{
     while( zRawSql[0] ){
       n = findNextHostParameter(zRawSql, &nToken);
@@ -69994,10 +70663,12 @@ SQLITE_PRIVATE char *sqlite3VdbeExpandSql(
           idx = nextIndex;
         }
       }else{
-        assert( zRawSql[0]==':' || zRawSql[0]=='$' || zRawSql[0]=='@' );
+        assert( zRawSql[0]==':' || zRawSql[0]=='$' ||
+                zRawSql[0]=='@' || zRawSql[0]=='#' );
         testcase( zRawSql[0]==':' );
         testcase( zRawSql[0]=='$' );
         testcase( zRawSql[0]=='@' );
+        testcase( zRawSql[0]=='#' );
         idx = sqlite3VdbeParameterIndex(p, zRawSql, nToken);
         assert( idx>0 );
       }
@@ -70374,7 +71045,7 @@ static void applyAffinity(
 ** is appropriate.  But only do the conversion if it is possible without
 ** loss of information and return the revised type of the argument.
 */
-SQLITE_API int sqlite3_value_numeric_type(sqlite3_value *pVal){
+SQLITE_API int SQLITE_STDCALL sqlite3_value_numeric_type(sqlite3_value *pVal){
   int eType = sqlite3_value_type(pVal);
   if( eType==SQLITE_TEXT ){
     Mem *pMem = (Mem*)pVal;
@@ -70672,6 +71343,21 @@ static int checkSavepointCount(sqlite3 *db){
 }
 #endif
 
+/*
+** Return the register of pOp->p2 after first preparing it to be
+** overwritten with an integer value.
+*/ 
+static Mem *out2Prerelease(Vdbe *p, VdbeOp *pOp){
+  Mem *pOut;
+  assert( pOp->p2>0 );
+  assert( pOp->p2<=(p->nMem-p->nCursor) );
+  pOut = &p->aMem[pOp->p2];
+  memAboutToChange(p, pOut);
+  if( VdbeMemDynamic(pOut) ) sqlite3VdbeMemSetNull(pOut);
+  pOut->flags = MEM_Int;
+  return pOut;
+}
+
 
 /*
 ** Execute as much of a VDBE program as we can.
@@ -70680,9 +71366,11 @@ static int checkSavepointCount(sqlite3 *db){
 SQLITE_PRIVATE int sqlite3VdbeExec(
   Vdbe *p                    /* The VDBE */
 ){
-  int pc=0;                  /* The program counter */
   Op *aOp = p->aOp;          /* Copy of p->aOp */
-  Op *pOp;                   /* Current operation */
+  Op *pOp = aOp;             /* Current operation */
+#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)
+  Op *pOrigOp;               /* Value of pOp at the top of the loop */
+#endif
   int rc = SQLITE_OK;        /* Value to return */
   sqlite3 *db = p->db;       /* The database */
   u8 resetSchemaOnFault = 0; /* Reset schema after an error if positive */
@@ -70758,23 +71446,22 @@ SQLITE_PRIVATE int sqlite3VdbeExec(
   }
   sqlite3EndBenignMalloc();
 #endif
-  for(pc=p->pc; rc==SQLITE_OK; pc++){
-    assert( pc>=0 && pc<p->nOp );
+  for(pOp=&aOp[p->pc]; rc==SQLITE_OK; pOp++){
+    assert( pOp>=aOp && pOp<&aOp[p->nOp]);
     if( db->mallocFailed ) goto no_mem;
 #ifdef VDBE_PROFILE
     start = sqlite3Hwtime();
 #endif
     nVmStep++;
-    pOp = &aOp[pc];
 #ifdef SQLITE_ENABLE_STMT_SCANSTATUS
-    if( p->anExec ) p->anExec[pc]++;
+    if( p->anExec ) p->anExec[(int)(pOp-aOp)]++;
 #endif
 
     /* Only allow tracing if SQLITE_DEBUG is defined.
     */
 #ifdef SQLITE_DEBUG
     if( db->flags & SQLITE_VdbeTrace ){
-      sqlite3VdbePrintOp(stdout, pc, pOp);
+      sqlite3VdbePrintOp(stdout, (int)(pOp - aOp), pOp);
     }
 #endif
       
@@ -70791,23 +71478,9 @@ SQLITE_PRIVATE int sqlite3VdbeExec(
     }
 #endif
 
-    /* On any opcode with the "out2-prerelease" tag, free any
-    ** external allocations out of mem[p2] and set mem[p2] to be
-    ** an undefined integer.  Opcodes will either fill in the integer
-    ** value or convert mem[p2] to a different type.
-    */
-    assert( pOp->opflags==sqlite3OpcodeProperty[pOp->opcode] );
-    if( pOp->opflags & OPFLG_OUT2_PRERELEASE ){
-      assert( pOp->p2>0 );
-      assert( pOp->p2<=(p->nMem-p->nCursor) );
-      pOut = &aMem[pOp->p2];
-      memAboutToChange(p, pOut);
-      if( VdbeMemDynamic(pOut) ) sqlite3VdbeMemSetNull(pOut);
-      pOut->flags = MEM_Int;
-    }
-
     /* Sanity checking on other operands */
 #ifdef SQLITE_DEBUG
+    assert( pOp->opflags==sqlite3OpcodeProperty[pOp->opcode] );
     if( (pOp->opflags & OPFLG_IN1)!=0 ){
       assert( pOp->p1>0 );
       assert( pOp->p1<=(p->nMem-p->nCursor) );
@@ -70840,6 +71513,9 @@ SQLITE_PRIVATE int sqlite3VdbeExec(
       memAboutToChange(p, &aMem[pOp->p3]);
     }
 #endif
+#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)
+    pOrigOp = pOp;
+#endif
   
     switch( pOp->opcode ){
 
@@ -70863,7 +71539,7 @@ SQLITE_PRIVATE int sqlite3VdbeExec(
 **
 ** Other keywords in the comment that follows each case are used to
 ** construct the OPFLG_INITIALIZER value that initializes opcodeProperty[].
-** Keywords include: in1, in2, in3, out2_prerelease, out2, out3.  See
+** Keywords include: in1, in2, in3, out2, out3.  See
 ** the mkopcodeh.awk script for additional information.
 **
 ** Documentation about VDBE opcodes is generated by scanning this file
@@ -70891,7 +71567,8 @@ SQLITE_PRIVATE int sqlite3VdbeExec(
 ** to the current line should be indented for EXPLAIN output.
 */
 case OP_Goto: {             /* jump */
-  pc = pOp->p2 - 1;
+jump_to_p2_and_check_for_interrupt:
+  pOp = &aOp[pOp->p2 - 1];
 
   /* Opcodes that are used as the bottom of a loop (OP_Next, OP_Prev,
   ** OP_VNext, OP_RowSetNext, or OP_SorterNext) all jump here upon
@@ -70936,9 +71613,13 @@ case OP_Gosub: {            /* jump */
   assert( VdbeMemDynamic(pIn1)==0 );
   memAboutToChange(p, pIn1);
   pIn1->flags = MEM_Int;
-  pIn1->u.i = pc;
+  pIn1->u.i = (int)(pOp-aOp);
   REGISTER_TRACE(pOp->p1, pIn1);
-  pc = pOp->p2 - 1;
+
+  /* Most jump operations do a goto to this spot in order to update
+  ** the pOp pointer. */
+jump_to_p2:
+  pOp = &aOp[pOp->p2 - 1];
   break;
 }
 
@@ -70950,7 +71631,7 @@ case OP_Gosub: {            /* jump */
 case OP_Return: {           /* in1 */
   pIn1 = &aMem[pOp->p1];
   assert( pIn1->flags==MEM_Int );
-  pc = (int)pIn1->u.i;
+  pOp = &aOp[pIn1->u.i];
   pIn1->flags = MEM_Undefined;
   break;
 }
@@ -70974,7 +71655,7 @@ case OP_InitCoroutine: {     /* jump */
   assert( !VdbeMemDynamic(pOut) );
   pOut->u.i = pOp->p3 - 1;
   pOut->flags = MEM_Int;
-  if( pOp->p2 ) pc = pOp->p2 - 1;
+  if( pOp->p2 ) goto jump_to_p2;
   break;
 }
 
@@ -70994,7 +71675,7 @@ case OP_EndCoroutine: {           /* in1 */
   pCaller = &aOp[pIn1->u.i];
   assert( pCaller->opcode==OP_Yield );
   assert( pCaller->p2>=0 && pCaller->p2<p->nOp );
-  pc = pCaller->p2 - 1;
+  pOp = &aOp[pCaller->p2 - 1];
   pIn1->flags = MEM_Undefined;
   break;
 }
@@ -71018,9 +71699,9 @@ case OP_Yield: {            /* in1, jump */
   assert( VdbeMemDynamic(pIn1)==0 );
   pIn1->flags = MEM_Int;
   pcDest = (int)pIn1->u.i;
-  pIn1->u.i = pc;
+  pIn1->u.i = (int)(pOp - aOp);
   REGISTER_TRACE(pOp->p1, pIn1);
-  pc = pcDest;
+  pOp = &aOp[pcDest];
   break;
 }
 
@@ -71071,30 +71752,34 @@ case OP_HaltIfNull: {      /* in3 */
 case OP_Halt: {
   const char *zType;
   const char *zLogFmt;
+  VdbeFrame *pFrame;
+  int pcx;
 
+  pcx = (int)(pOp - aOp);
   if( pOp->p1==SQLITE_OK && p->pFrame ){
     /* Halt the sub-program. Return control to the parent frame. */
-    VdbeFrame *pFrame = p->pFrame;
+    pFrame = p->pFrame;
     p->pFrame = pFrame->pParent;
     p->nFrame--;
     sqlite3VdbeSetChanges(db, p->nChange);
-    pc = sqlite3VdbeFrameRestore(pFrame);
+    pcx = sqlite3VdbeFrameRestore(pFrame);
     lastRowid = db->lastRowid;
     if( pOp->p2==OE_Ignore ){
-      /* Instruction pc is the OP_Program that invoked the sub-program 
+      /* Instruction pcx is the OP_Program that invoked the sub-program 
       ** currently being halted. If the p2 instruction of this OP_Halt
       ** instruction is set to OE_Ignore, then the sub-program is throwing
       ** an IGNORE exception. In this case jump to the address specified
       ** as the p2 of the calling OP_Program.  */
-      pc = p->aOp[pc].p2-1;
+      pcx = p->aOp[pcx].p2-1;
     }
     aOp = p->aOp;
     aMem = p->aMem;
+    pOp = &aOp[pcx];
     break;
   }
   p->rc = pOp->p1;
   p->errorAction = (u8)pOp->p2;
-  p->pc = pc;
+  p->pc = pcx;
   if( p->rc ){
     if( pOp->p5 ){
       static const char * const azType[] = { "NOT NULL", "UNIQUE", "CHECK",
@@ -71118,7 +71803,7 @@ case OP_Halt: {
     }else{
       sqlite3SetString(&p->zErrMsg, db, "%s constraint failed", zType);
     }
-    sqlite3_log(pOp->p1, zLogFmt, pc, p->zSql, p->zErrMsg);
+    sqlite3_log(pOp->p1, zLogFmt, pcx, p->zSql, p->zErrMsg);
   }
   rc = sqlite3VdbeHalt(p);
   assert( rc==SQLITE_BUSY || rc==SQLITE_OK || rc==SQLITE_ERROR );
@@ -71137,7 +71822,8 @@ case OP_Halt: {
 **
 ** The 32-bit integer value P1 is written into register P2.
 */
-case OP_Integer: {         /* out2-prerelease */
+case OP_Integer: {         /* out2 */
+  pOut = out2Prerelease(p, pOp);
   pOut->u.i = pOp->p1;
   break;
 }
@@ -71148,7 +71834,8 @@ case OP_Integer: {         /* out2-prerelease */
 ** P4 is a pointer to a 64-bit integer value.
 ** Write that value into register P2.
 */
-case OP_Int64: {           /* out2-prerelease */
+case OP_Int64: {           /* out2 */
+  pOut = out2Prerelease(p, pOp);
   assert( pOp->p4.pI64!=0 );
   pOut->u.i = *pOp->p4.pI64;
   break;
@@ -71161,7 +71848,8 @@ case OP_Int64: {           /* out2-prerelease */
 ** P4 is a pointer to a 64-bit floating point value.
 ** Write that value into register P2.
 */
-case OP_Real: {            /* same as TK_FLOAT, out2-prerelease */
+case OP_Real: {            /* same as TK_FLOAT, out2 */
+  pOut = out2Prerelease(p, pOp);
   pOut->flags = MEM_Real;
   assert( !sqlite3IsNaN(*pOp->p4.pReal) );
   pOut->u.r = *pOp->p4.pReal;
@@ -71173,12 +71861,13 @@ case OP_Real: {            /* same as TK_FLOAT, out2-prerelease */
 ** Synopsis: r[P2]='P4'
 **
 ** P4 points to a nul terminated UTF-8 string. This opcode is transformed 
-** into a String before it is executed for the first time.  During
+** into a String opcode before it is executed for the first time.  During
 ** this transformation, the length of string P4 is computed and stored
 ** as the P1 parameter.
 */
-case OP_String8: {         /* same as TK_STRING, out2-prerelease */
+case OP_String8: {         /* same as TK_STRING, out2 */
   assert( pOp->p4.z!=0 );
+  pOut = out2Prerelease(p, pOp);
   pOp->opcode = OP_String;
   pOp->p1 = sqlite3Strlen30(pOp->p4.z);
 
@@ -71205,18 +71894,31 @@ case OP_String8: {         /* same as TK_STRING, out2-prerelease */
   /* Fall through to the next case, OP_String */
 }
   
-/* Opcode: String P1 P2 * P4 *
+/* Opcode: String P1 P2 P3 P4 P5
 ** Synopsis: r[P2]='P4' (len=P1)
 **
 ** The string value P4 of length P1 (bytes) is stored in register P2.
+**
+** If P5!=0 and the content of register P3 is greater than zero, then
+** the datatype of the register P2 is converted to BLOB.  The content is
+** the same sequence of bytes, it is merely interpreted as a BLOB instead
+** of a string, as if it had been CAST.
 */
-case OP_String: {          /* out2-prerelease */
+case OP_String: {          /* out2 */
   assert( pOp->p4.z!=0 );
+  pOut = out2Prerelease(p, pOp);
   pOut->flags = MEM_Str|MEM_Static|MEM_Term;
   pOut->z = pOp->p4.z;
   pOut->n = pOp->p1;
   pOut->enc = encoding;
   UPDATE_MAX_BLOBSIZE(pOut);
+  if( pOp->p5 ){
+    assert( pOp->p3>0 );
+    assert( pOp->p3<=(p->nMem-p->nCursor) );
+    pIn3 = &aMem[pOp->p3];
+    assert( pIn3->flags & MEM_Int );
+    if( pIn3->u.i ) pOut->flags = MEM_Blob|MEM_Static|MEM_Term;
+  }
   break;
 }
 
@@ -71232,9 +71934,10 @@ case OP_String: {          /* out2-prerelease */
 ** NULL values will not compare equal even if SQLITE_NULLEQ is set on
 ** OP_Ne or OP_Eq.
 */
-case OP_Null: {           /* out2-prerelease */
+case OP_Null: {           /* out2 */
   int cnt;
   u16 nullFlag;
+  pOut = out2Prerelease(p, pOp);
   cnt = pOp->p3-pOp->p2;
   assert( pOp->p3<=(p->nMem-p->nCursor) );
   pOut->flags = nullFlag = pOp->p1 ? (MEM_Null|MEM_Cleared) : MEM_Null;
@@ -71269,8 +71972,9 @@ case OP_SoftNull: {
 ** P4 points to a blob of data P1 bytes long.  Store this
 ** blob in register P2.
 */
-case OP_Blob: {                /* out2-prerelease */
+case OP_Blob: {                /* out2 */
   assert( pOp->p1 <= SQLITE_MAX_LENGTH );
+  pOut = out2Prerelease(p, pOp);
   sqlite3VdbeMemSetStr(pOut, pOp->p4.z, pOp->p1, 0, 0);
   pOut->enc = encoding;
   UPDATE_MAX_BLOBSIZE(pOut);
@@ -71285,7 +71989,7 @@ case OP_Blob: {                /* out2-prerelease */
 ** If the parameter is named, then its name appears in P4.
 ** The P4 value is used by sqlite3_bind_parameter_name().
 */
-case OP_Variable: {            /* out2-prerelease */
+case OP_Variable: {            /* out2 */
   Mem *pVar;       /* Value being transferred */
 
   assert( pOp->p1>0 && pOp->p1<=p->nVar );
@@ -71294,6 +71998,7 @@ case OP_Variable: {            /* out2-prerelease */
   if( sqlite3VdbeMemTooBig(pVar) ){
     goto too_big;
   }
+  pOut = out2Prerelease(p, pOp);
   sqlite3VdbeMemShallowCopy(pOut, pVar, MEM_Static);
   UPDATE_MAX_BLOBSIZE(pOut);
   break;
@@ -71328,10 +72033,11 @@ case OP_Move: {
     memAboutToChange(p, pOut);
     sqlite3VdbeMemMove(pOut, pIn1);
 #ifdef SQLITE_DEBUG
-    if( pOut->pScopyFrom>=&aMem[p1] && pOut->pScopyFrom<&aMem[p1+pOp->p3] ){
-      pOut->pScopyFrom += p1 - pOp->p2;
+    if( pOut->pScopyFrom>=&aMem[p1] && pOut->pScopyFrom<pOut ){
+      pOut->pScopyFrom += pOp->p2 - p1;
     }
 #endif
+    Deephemeralize(pOut);
     REGISTER_TRACE(p2++, pOut);
     pIn1++;
     pOut++;
@@ -71470,7 +72176,7 @@ case OP_ResultRow: {
 
   /* Return SQLITE_ROW
   */
-  p->pc = pc + 1;
+  p->pc = (int)(pOp - aOp) + 1;
   rc = SQLITE_ROW;
   goto vdbe_return;
 }
@@ -71663,7 +72369,7 @@ case OP_Remainder: {           /* same as TK_REM, in1, in2, out3 */
 **
 ** The interface used by the implementation of the aforementioned functions
 ** to retrieve the collation sequence set by this opcode is not available
-** publicly, only to user functions defined in func.c.
+** publicly.  Only built-in functions have access to this feature.
 */
 case OP_CollSeq: {
   assert( pOp->p4type==P4_COLLSEQ );
@@ -71716,7 +72422,7 @@ case OP_Function: {
 
   assert( pOp->p4type==P4_FUNCDEF );
   ctx.pFunc = pOp->p4.pFunc;
-  ctx.iOp = pc;
+  ctx.iOp = (int)(pOp - aOp);
   ctx.pVdbe = p;
   MemSetTypeFlag(ctx.pOut, MEM_Null);
   ctx.fErrorOrAux = 0;
@@ -71730,7 +72436,7 @@ case OP_Function: {
       sqlite3SetString(&p->zErrMsg, db, "%s", sqlite3_value_text(ctx.pOut));
       rc = ctx.isError;
     }
-    sqlite3VdbeDeleteAuxData(p, pc, pOp->p1);
+    sqlite3VdbeDeleteAuxData(p, (int)(pOp - aOp), pOp->p1);
   }
 
   /* Copy the result of the function into register P3 */
@@ -71859,8 +72565,7 @@ case OP_MustBeInt: {            /* jump, in1 */
         rc = SQLITE_MISMATCH;
         goto abort_due_to_error;
       }else{
-        pc = pOp->p2 - 1;
-        break;
+        goto jump_to_p2;
       }
     }
   }
@@ -72046,7 +72751,7 @@ case OP_Ge: {             /* same as TK_GE, jump, in1, in3 */
       }else{
         VdbeBranchTaken(2,3);
         if( pOp->p5 & SQLITE_JUMPIFNULL ){
-          pc = pOp->p2-1;
+          goto jump_to_p2;
         }
       }
       break;
@@ -72066,11 +72771,15 @@ case OP_Ge: {             /* same as TK_GE, jump, in1, in3 */
         testcase( pIn1->flags & MEM_Int );
         testcase( pIn1->flags & MEM_Real );
         sqlite3VdbeMemStringify(pIn1, encoding, 1);
+        testcase( (flags1&MEM_Dyn) != (pIn1->flags&MEM_Dyn) );
+        flags1 = (pIn1->flags & ~MEM_TypeMask) | (flags1 & MEM_TypeMask);
       }
       if( (pIn3->flags & MEM_Str)==0 && (pIn3->flags & (MEM_Int|MEM_Real))!=0 ){
         testcase( pIn3->flags & MEM_Int );
         testcase( pIn3->flags & MEM_Real );
         sqlite3VdbeMemStringify(pIn3, encoding, 1);
+        testcase( (flags3&MEM_Dyn) != (pIn3->flags&MEM_Dyn) );
+        flags3 = (pIn3->flags & ~MEM_TypeMask) | (flags3 & MEM_TypeMask);
       }
     }
     assert( pOp->p4type==P4_COLLSEQ || pOp->p4.pColl==0 );
@@ -72094,6 +72803,12 @@ case OP_Ge: {             /* same as TK_GE, jump, in1, in3 */
     default:       res = res>=0;     break;
   }
 
+  /* Undo any changes made by applyAffinity() to the input registers. */
+  assert( (pIn1->flags & MEM_Dyn) == (flags1 & MEM_Dyn) );
+  pIn1->flags = flags1;
+  assert( (pIn3->flags & MEM_Dyn) == (flags3 & MEM_Dyn) );
+  pIn3->flags = flags3;
+
   if( pOp->p5 & SQLITE_STOREP2 ){
     pOut = &aMem[pOp->p2];
     memAboutToChange(p, pOut);
@@ -72103,12 +72818,9 @@ case OP_Ge: {             /* same as TK_GE, jump, in1, in3 */
   }else{
     VdbeBranchTaken(res!=0, (pOp->p5 & SQLITE_NULLEQ)?2:3);
     if( res ){
-      pc = pOp->p2-1;
+      goto jump_to_p2;
     }
   }
-  /* Undo any changes made by applyAffinity() to the input registers. */
-  pIn1->flags = flags1;
-  pIn3->flags = flags3;
   break;
 }
 
@@ -72203,11 +72915,11 @@ case OP_Compare: {
 */
 case OP_Jump: {             /* jump */
   if( iCompare<0 ){
-    pc = pOp->p1 - 1;  VdbeBranchTaken(0,3);
+    VdbeBranchTaken(0,3); pOp = &aOp[pOp->p1 - 1];
   }else if( iCompare==0 ){
-    pc = pOp->p2 - 1;  VdbeBranchTaken(1,3);
+    VdbeBranchTaken(1,3); pOp = &aOp[pOp->p2 - 1];
   }else{
-    pc = pOp->p3 - 1;  VdbeBranchTaken(2,3);
+    VdbeBranchTaken(2,3); pOp = &aOp[pOp->p3 - 1];
   }
   break;
 }
@@ -72317,7 +73029,7 @@ case OP_Once: {             /* jump */
   assert( pOp->p1<p->nOnceFlag );
   VdbeBranchTaken(p->aOnceFlag[pOp->p1]!=0, 2);
   if( p->aOnceFlag[pOp->p1] ){
-    pc = pOp->p2-1;
+    goto jump_to_p2;
   }else{
     p->aOnceFlag[pOp->p1] = 1;
   }
@@ -72352,7 +73064,7 @@ case OP_IfNot: {            /* jump, in1 */
   }
   VdbeBranchTaken(c!=0, 2);
   if( c ){
-    pc = pOp->p2-1;
+    goto jump_to_p2;
   }
   break;
 }
@@ -72366,7 +73078,7 @@ case OP_IsNull: {            /* same as TK_ISNULL, jump, in1 */
   pIn1 = &aMem[pOp->p1];
   VdbeBranchTaken( (pIn1->flags & MEM_Null)!=0, 2);
   if( (pIn1->flags & MEM_Null)!=0 ){
-    pc = pOp->p2 - 1;
+    goto jump_to_p2;
   }
   break;
 }
@@ -72380,7 +73092,7 @@ case OP_NotNull: {            /* same as TK_NOTNULL, jump, in1 */
   pIn1 = &aMem[pOp->p1];
   VdbeBranchTaken( (pIn1->flags & MEM_Null)==0, 2);
   if( (pIn1->flags & MEM_Null)==0 ){
-    pc = pOp->p2 - 1;
+    goto jump_to_p2;
   }
   break;
 }
@@ -72594,7 +73306,7 @@ case OP_Column: {
       }
     }
 
-    /* If after trying to extra new entries from the header, nHdrParsed is
+    /* If after trying to extract new entries from the header, nHdrParsed is
     ** still not up to p2, that means that the record has fewer than p2
     ** columns.  So the result will be either the default value or a NULL.
     */
@@ -72718,7 +73430,7 @@ case OP_MakeRecord: {
   u64 nData;             /* Number of bytes of data space */
   int nHdr;              /* Number of bytes of header space */
   i64 nByte;             /* Data space required for this record */
-  int nZero;             /* Number of zero bytes at the end of the record */
+  i64 nZero;             /* Number of zero bytes at the end of the record */
   int nVarint;           /* Number of bytes in a varint */
   u32 serial_type;       /* Type field */
   Mem *pData0;           /* First field to be combined into the record */
@@ -72810,7 +73522,7 @@ case OP_MakeRecord: {
     if( nVarint<sqlite3VarintLen(nHdr) ) nHdr++;
   }
   nByte = nHdr+nData;
-  if( nByte>db->aLimit[SQLITE_LIMIT_LENGTH] ){
+  if( nByte+nZero>db->aLimit[SQLITE_LIMIT_LENGTH] ){
     goto too_big;
   }
 
@@ -72861,7 +73573,7 @@ case OP_MakeRecord: {
 ** opened by cursor P1 in register P2
 */
 #ifndef SQLITE_OMIT_BTREECOUNT
-case OP_Count: {         /* out2-prerelease */
+case OP_Count: {         /* out2 */
   i64 nEntry;
   BtCursor *pCrsr;
 
@@ -72869,6 +73581,7 @@ case OP_Count: {         /* out2-prerelease */
   assert( pCrsr );
   nEntry = 0;  /* Not needed.  Only used to silence a warning. */
   rc = sqlite3BtreeCount(pCrsr, &nEntry);
+  pOut = out2Prerelease(p, pOp);
   pOut->u.i = nEntry;
   break;
 }
@@ -72982,7 +73695,7 @@ case OP_Savepoint: {
         }
         db->autoCommit = 1;
         if( sqlite3VdbeHalt(p)==SQLITE_BUSY ){
-          p->pc = pc;
+          p->pc = (int)(pOp - aOp);
           db->autoCommit = 0;
           p->rc = rc = SQLITE_BUSY;
           goto vdbe_return;
@@ -73041,7 +73754,7 @@ case OP_Savepoint: {
         db->nDeferredImmCons = pSavepoint->nDeferredImmCons;
       }
 
-      if( !isTransaction ){
+      if( !isTransaction || p1==SAVEPOINT_ROLLBACK ){
         rc = sqlite3VtabSavepoint(db, p1, iSavepoint);
         if( rc!=SQLITE_OK ) goto abort_due_to_error;
       }
@@ -73101,7 +73814,7 @@ case OP_AutoCommit: {
     }else{
       db->autoCommit = (u8)desiredAutoCommit;
       if( sqlite3VdbeHalt(p)==SQLITE_BUSY ){
-        p->pc = pc;
+        p->pc = (int)(pOp - aOp);
         db->autoCommit = (u8)(1-desiredAutoCommit);
         p->rc = rc = SQLITE_BUSY;
         goto vdbe_return;
@@ -73178,7 +73891,7 @@ case OP_Transaction: {
   if( pBt ){
     rc = sqlite3BtreeBeginTrans(pBt, pOp->p2);
     if( rc==SQLITE_BUSY ){
-      p->pc = pc;
+      p->pc = (int)(pOp - aOp);
       p->rc = rc = SQLITE_BUSY;
       goto vdbe_return;
     }
@@ -73208,7 +73921,12 @@ case OP_Transaction: {
       p->nStmtDefImmCons = db->nDeferredImmCons;
     }
 
-    /* Gather the schema version number for checking */
+    /* Gather the schema version number for checking:
+    ** IMPLEMENTATION-OF: R-32195-19465 The schema version is used by SQLite
+    ** each time a query is executed to ensure that the internal cache of the
+    ** schema used when compiling the SQL query matches the schema of the
+    ** database against which the compiled query is actually executed.
+    */
     sqlite3BtreeGetMeta(pBt, BTREE_SCHEMA_VERSION, (u32 *)&iMeta);
     iGen = db->aDb[pOp->p1].pSchema->iGeneration;
   }else{
@@ -73252,7 +73970,7 @@ case OP_Transaction: {
 ** must be started or there must be an open cursor) before
 ** executing this instruction.
 */
-case OP_ReadCookie: {               /* out2-prerelease */
+case OP_ReadCookie: {               /* out2 */
   int iMeta;
   int iDb;
   int iCookie;
@@ -73266,6 +73984,7 @@ case OP_ReadCookie: {               /* out2-prerelease */
   assert( DbMaskTest(p->btreeMask, iDb) );
 
   sqlite3BtreeGetMeta(db->aDb[iDb].pBt, iCookie, (u32 *)&iMeta);
+  pOut = out2Prerelease(p, pOp);
   pOut->u.i = iMeta;
   break;
 }
@@ -73376,31 +74095,29 @@ case OP_SetCookie: {       /* in3 */
 ** See also OpenRead.
 */
 case OP_ReopenIdx: {
+  int nField;
+  KeyInfo *pKeyInfo;
+  int p2;
+  int iDb;
+  int wrFlag;
+  Btree *pX;
   VdbeCursor *pCur;
+  Db *pDb;
 
-  assert( pOp->p5==0 );
+  assert( pOp->p5==0 || pOp->p5==OPFLAG_SEEKEQ );
   assert( pOp->p4type==P4_KEYINFO );
   pCur = p->apCsr[pOp->p1];
   if( pCur && pCur->pgnoRoot==(u32)pOp->p2 ){
     assert( pCur->iDb==pOp->p3 );      /* Guaranteed by the code generator */
-    break;
+    goto open_cursor_set_hints;
   }
   /* If the cursor is not currently open or is open on a different
   ** index, then fall through into OP_OpenRead to force a reopen */
-}
 case OP_OpenRead:
-case OP_OpenWrite: {
-  int nField;
-  KeyInfo *pKeyInfo;
-  int p2;
-  int iDb;
-  int wrFlag;
-  Btree *pX;
-  VdbeCursor *pCur;
-  Db *pDb;
+case OP_OpenWrite:
 
-  assert( (pOp->p5&(OPFLAG_P2ISREG|OPFLAG_BULKCSR))==pOp->p5 );
-  assert( pOp->opcode==OP_OpenWrite || pOp->p5==0 );
+  assert( (pOp->p5&(OPFLAG_P2ISREG|OPFLAG_BULKCSR|OPFLAG_SEEKEQ))==pOp->p5 );
+  assert( pOp->opcode==OP_OpenWrite || pOp->p5==0 || pOp->p5==OPFLAG_SEEKEQ );
   assert( p->bIsReader );
   assert( pOp->opcode==OP_OpenRead || pOp->opcode==OP_ReopenIdx
           || p->readOnly==0 );
@@ -73463,14 +74180,17 @@ case OP_OpenWrite: {
   pCur->pgnoRoot = p2;
   rc = sqlite3BtreeCursor(pX, p2, wrFlag, pKeyInfo, pCur->pCursor);
   pCur->pKeyInfo = pKeyInfo;
-  assert( OPFLAG_BULKCSR==BTREE_BULKLOAD );
-  sqlite3BtreeCursorHints(pCur->pCursor, (pOp->p5 & OPFLAG_BULKCSR));
-
   /* Set the VdbeCursor.isTable variable. Previous versions of
   ** SQLite used to check if the root-page flags were sane at this point
   ** and report database corruption if they were not, but this check has
   ** since moved into the btree layer.  */  
   pCur->isTable = pOp->p4type!=P4_KEYINFO;
+
+open_cursor_set_hints:
+  assert( OPFLAG_BULKCSR==BTREE_BULKLOAD );
+  assert( OPFLAG_SEEKEQ==BTREE_SEEK_EQ );
+  sqlite3BtreeCursorHints(pCur->pCursor,
+                          (pOp->p5 & (OPFLAG_BULKCSR|OPFLAG_SEEKEQ)));
   break;
 }
 
@@ -73586,7 +74306,7 @@ case OP_SequenceTest: {
   pC = p->apCsr[pOp->p1];
   assert( pC->pSorter );
   if( (pC->seqCount++)==0 ){
-    pc = pOp->p2 - 1;
+    goto jump_to_p2;
   }
   break;
 }
@@ -73731,6 +74451,22 @@ case OP_SeekGT: {       /* jump, in3 */
 #ifdef SQLITE_DEBUG
   pC->seekOp = pOp->opcode;
 #endif
+
+  /* For a cursor with the BTREE_SEEK_EQ hint, only the OP_SeekGE and
+  ** OP_SeekLE opcodes are allowed, and these must be immediately followed
+  ** by an OP_IdxGT or OP_IdxLT opcode, respectively, with the same key.
+  */
+#ifdef SQLITE_DEBUG
+  if( sqlite3BtreeCursorHasHint(pC->pCursor, BTREE_SEEK_EQ) ){
+    assert( pOp->opcode==OP_SeekGE || pOp->opcode==OP_SeekLE );
+    assert( pOp[1].opcode==OP_IdxLT || pOp[1].opcode==OP_IdxGT );
+    assert( pOp[1].p1==pOp[0].p1 );
+    assert( pOp[1].p2==pOp[0].p2 );
+    assert( pOp[1].p3==pOp[0].p3 );
+    assert( pOp[1].p4.i==pOp[0].p4.i );
+  }
+#endif
+ 
   if( pC->isTable ){
     /* The input value in P3 might be of any type: integer, real, string,
     ** blob, or NULL.  But it needs to be an integer before we can do
@@ -73747,7 +74483,7 @@ case OP_SeekGT: {       /* jump, in3 */
       if( (pIn3->flags & MEM_Real)==0 ){
         /* If the P3 value cannot be converted into any kind of a number,
         ** then the seek is not possible, so jump to P2 */
-        pc = pOp->p2 - 1;  VdbeBranchTaken(1,2);
+        VdbeBranchTaken(1,2); goto jump_to_p2;
         break;
       }
 
@@ -73838,7 +74574,7 @@ case OP_SeekGT: {       /* jump, in3 */
   assert( pOp->p2>0 );
   VdbeBranchTaken(res!=0,2);
   if( res ){
-    pc = pOp->p2 - 1;
+    goto jump_to_p2;
   }
   break;
 }
@@ -73932,6 +74668,7 @@ case OP_NoConflict:     /* jump, in3 */
 case OP_NotFound:       /* jump, in3 */
 case OP_Found: {        /* jump, in3 */
   int alreadyExists;
+  int takeJump;
   int ii;
   VdbeCursor *pC;
   int res;
@@ -73954,7 +74691,7 @@ case OP_Found: {        /* jump, in3 */
   pIn3 = &aMem[pOp->p3];
   assert( pC->pCursor!=0 );
   assert( pC->isTable==0 );
-  pFree = 0;  /* Not needed.  Only used to suppress a compiler warning. */
+  pFree = 0;
   if( pOp->p4.i>0 ){
     r.pKeyInfo = pC->pKeyInfo;
     r.nField = (u16)pOp->p4.i;
@@ -73977,21 +74714,20 @@ case OP_Found: {        /* jump, in3 */
     sqlite3VdbeRecordUnpack(pC->pKeyInfo, pIn3->n, pIn3->z, pIdxKey);
   }
   pIdxKey->default_rc = 0;
+  takeJump = 0;
   if( pOp->opcode==OP_NoConflict ){
     /* For the OP_NoConflict opcode, take the jump if any of the
     ** input fields are NULL, since any key with a NULL will not
     ** conflict */
     for(ii=0; ii<pIdxKey->nField; ii++){
       if( pIdxKey->aMem[ii].flags & MEM_Null ){
-        pc = pOp->p2 - 1; VdbeBranchTaken(1,2);
+        takeJump = 1;
         break;
       }
     }
   }
   rc = sqlite3BtreeMovetoUnpacked(pC->pCursor, pIdxKey, 0, 0, &res);
-  if( pOp->p4.i==0 ){
-    sqlite3DbFree(db, pFree);
-  }
+  sqlite3DbFree(db, pFree);
   if( rc!=SQLITE_OK ){
     break;
   }
@@ -74002,10 +74738,10 @@ case OP_Found: {        /* jump, in3 */
   pC->cacheStatus = CACHE_STALE;
   if( pOp->opcode==OP_Found ){
     VdbeBranchTaken(alreadyExists!=0,2);
-    if( alreadyExists ) pc = pOp->p2 - 1;
+    if( alreadyExists ) goto jump_to_p2;
   }else{
-    VdbeBranchTaken(alreadyExists==0,2);
-    if( !alreadyExists ) pc = pOp->p2 - 1;
+    VdbeBranchTaken(takeJump||alreadyExists==0,2);
+    if( takeJump || !alreadyExists ) goto jump_to_p2;
   }
   break;
 }
@@ -74054,10 +74790,8 @@ case OP_NotExists: {        /* jump, in3 */
   pC->cacheStatus = CACHE_STALE;
   pC->deferredMoveto = 0;
   VdbeBranchTaken(res!=0,2);
-  if( res!=0 ){
-    pc = pOp->p2 - 1;
-  }
   pC->seekResult = res;
+  if( res!=0 ) goto jump_to_p2;
   break;
 }
 
@@ -74069,9 +74803,10 @@ case OP_NotExists: {        /* jump, in3 */
 ** The sequence number on the cursor is incremented after this
 ** instruction.  
 */
-case OP_Sequence: {           /* out2-prerelease */
+case OP_Sequence: {           /* out2 */
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   assert( p->apCsr[pOp->p1]!=0 );
+  pOut = out2Prerelease(p, pOp);
   pOut->u.i = p->apCsr[pOp->p1]->seqCount++;
   break;
 }
@@ -74092,7 +74827,7 @@ case OP_Sequence: {           /* out2-prerelease */
 ** generated record number. This P3 mechanism is used to help implement the
 ** AUTOINCREMENT feature.
 */
-case OP_NewRowid: {           /* out2-prerelease */
+case OP_NewRowid: {           /* out2 */
   i64 v;                 /* The new rowid */
   VdbeCursor *pC;        /* Cursor of table to get the new rowid */
   int res;               /* Result of an sqlite3BtreeLast() */
@@ -74102,6 +74837,7 @@ case OP_NewRowid: {           /* out2-prerelease */
 
   v = 0;
   res = 0;
+  pOut = out2Prerelease(p, pOp);
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
   assert( pC!=0 );
@@ -74415,9 +75151,7 @@ case OP_SorterCompare: {
   res = 0;
   rc = sqlite3VdbeSorterCompare(pC, pIn3, nKeyCol, &res);
   VdbeBranchTaken(res!=0,2);
-  if( res ){
-    pc = pOp->p2-1;
-  }
+  if( res ) goto jump_to_p2;
   break;
 };
 
@@ -74546,12 +75280,13 @@ case OP_RowData: {
 ** be a separate OP_VRowid opcode for use with virtual tables, but this
 ** one opcode now works for both table types.
 */
-case OP_Rowid: {                 /* out2-prerelease */
+case OP_Rowid: {                 /* out2 */
   VdbeCursor *pC;
   i64 v;
   sqlite3_vtab *pVtab;
   const sqlite3_module *pModule;
 
+  pOut = out2Prerelease(p, pOp);
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
   assert( pC!=0 );
@@ -74604,7 +75339,7 @@ case OP_NullRow: {
   break;
 }
 
-/* Opcode: Last P1 P2 * * *
+/* Opcode: Last P1 P2 P3 * *
 **
 ** The next use of the Rowid or Column or Prev instruction for P1 
 ** will refer to the last entry in the database table or index.
@@ -74631,12 +75366,13 @@ case OP_Last: {        /* jump */
   pC->nullRow = (u8)res;
   pC->deferredMoveto = 0;
   pC->cacheStatus = CACHE_STALE;
+  pC->seekResult = pOp->p3;
 #ifdef SQLITE_DEBUG
   pC->seekOp = OP_Last;
 #endif
   if( pOp->p2>0 ){
     VdbeBranchTaken(res!=0,2);
-    if( res ) pc = pOp->p2 - 1;
+    if( res ) goto jump_to_p2;
   }
   break;
 }
@@ -74700,9 +75436,7 @@ case OP_Rewind: {        /* jump */
   pC->nullRow = (u8)res;
   assert( pOp->p2>0 && pOp->p2<p->nOp );
   VdbeBranchTaken(res!=0,2);
-  if( res ){
-    pc = pOp->p2 - 1;
-  }
+  if( res ) goto jump_to_p2;
   break;
 }
 
@@ -74813,11 +75547,11 @@ case OP_Next:          /* jump */
   VdbeBranchTaken(res==0,2);
   if( res==0 ){
     pC->nullRow = 0;
-    pc = pOp->p2 - 1;
     p->aCounter[pOp->p5]++;
 #ifdef SQLITE_TEST
     sqlite3_search_count++;
 #endif
+    goto jump_to_p2_and_check_for_interrupt;
   }else{
     pC->nullRow = 1;
   }
@@ -74925,11 +75659,12 @@ case OP_IdxDelete: {
 **
 ** See also: Rowid, MakeRecord.
 */
-case OP_IdxRowid: {              /* out2-prerelease */
+case OP_IdxRowid: {              /* out2 */
   BtCursor *pCrsr;
   VdbeCursor *pC;
   i64 rowid;
 
+  pOut = out2Prerelease(p, pOp);
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
   assert( pC!=0 );
@@ -75042,9 +75777,7 @@ case OP_IdxGE:  {       /* jump */
     res++;
   }
   VdbeBranchTaken(res>0,2);
-  if( res>0 ){
-    pc = pOp->p2 - 1 ;
-  }
+  if( res>0 ) goto jump_to_p2;
   break;
 }
 
@@ -75068,32 +75801,18 @@ case OP_IdxGE:  {       /* jump */
 **
 ** See also: Clear
 */
-case OP_Destroy: {     /* out2-prerelease */
+case OP_Destroy: {     /* out2 */
   int iMoved;
-  int iCnt;
-  Vdbe *pVdbe;
   int iDb;
 
   assert( p->readOnly==0 );
-#ifndef SQLITE_OMIT_VIRTUALTABLE
-  iCnt = 0;
-  for(pVdbe=db->pVdbe; pVdbe; pVdbe = pVdbe->pNext){
-    if( pVdbe->magic==VDBE_MAGIC_RUN && pVdbe->bIsReader 
-     && pVdbe->inVtabMethod<2 && pVdbe->pc>=0 
-    ){
-      iCnt++;
-    }
-  }
-#else
-  iCnt = db->nVdbeRead;
-#endif
+  pOut = out2Prerelease(p, pOp);
   pOut->flags = MEM_Null;
-  if( iCnt>1 ){
+  if( db->nVdbeRead > db->nVDestroy+1 ){
     rc = SQLITE_LOCKED;
     p->errorAction = OE_Abort;
   }else{
     iDb = pOp->p3;
-    assert( iCnt==1 );
     assert( DbMaskTest(p->btreeMask, iDb) );
     iMoved = 0;  /* Not needed.  Only to silence a warning. */
     rc = sqlite3BtreeDropTable(db->aDb[iDb].pBt, pOp->p1, &iMoved);
@@ -75196,12 +75915,13 @@ case OP_ResetSorter: {
 **
 ** See documentation on OP_CreateTable for additional information.
 */
-case OP_CreateIndex:            /* out2-prerelease */
-case OP_CreateTable: {          /* out2-prerelease */
+case OP_CreateIndex:            /* out2 */
+case OP_CreateTable: {          /* out2 */
   int pgno;
   int flags;
   Db *pDb;
 
+  pOut = out2Prerelease(p, pOp);
   pgno = 0;
   assert( pOp->p1>=0 && pOp->p1<db->nDb );
   assert( DbMaskTest(p->btreeMask, pOp->p1) );
@@ -75427,12 +76147,12 @@ case OP_RowSetRead: {       /* jump, in1, out3 */
   ){
     /* The boolean index is empty */
     sqlite3VdbeMemSetNull(pIn1);
-    pc = pOp->p2 - 1;
     VdbeBranchTaken(1,2);
+    goto jump_to_p2_and_check_for_interrupt;
   }else{
     /* A value was pulled from the index */
-    sqlite3VdbeMemSetInt64(&aMem[pOp->p3], val);
     VdbeBranchTaken(0,2);
+    sqlite3VdbeMemSetInt64(&aMem[pOp->p3], val);
   }
   goto check_for_interrupt;
 }
@@ -75483,10 +76203,7 @@ case OP_RowSetTest: {                     /* jump, in1, in3 */
   if( iSet ){
     exists = sqlite3RowSetTest(pIn1->u.pRowSet, iSet, pIn3->u.i);
     VdbeBranchTaken(exists!=0,2);
-    if( exists ){
-      pc = pOp->p2 - 1;
-      break;
-    }
+    if( exists ) goto jump_to_p2;
   }
   if( iSet>=0 ){
     sqlite3RowSetInsert(pIn1->u.pRowSet, pIn3->u.i);
@@ -75575,7 +76292,7 @@ case OP_Program: {        /* jump */
     pFrame->v = p;
     pFrame->nChildMem = nMem;
     pFrame->nChildCsr = pProgram->nCsr;
-    pFrame->pc = pc;
+    pFrame->pc = (int)(pOp - aOp);
     pFrame->aMem = p->aMem;
     pFrame->nMem = p->nMem;
     pFrame->apCsr = p->apCsr;
@@ -75598,7 +76315,7 @@ case OP_Program: {        /* jump */
     pFrame = pRt->u.pFrame;
     assert( pProgram->nMem+pProgram->nCsr==pFrame->nChildMem );
     assert( pProgram->nCsr==pFrame->nChildCsr );
-    assert( pc==pFrame->pc );
+    assert( (int)(pOp - aOp)==pFrame->pc );
   }
 
   p->nFrame++;
@@ -75619,7 +76336,7 @@ case OP_Program: {        /* jump */
 #ifdef SQLITE_ENABLE_STMT_SCANSTATUS
   p->anExec = 0;
 #endif
-  pc = -1;
+  pOp = &aOp[-1];
   memset(p->aOnceFlag, 0, p->nOnceFlag);
 
   break;
@@ -75637,9 +76354,10 @@ case OP_Program: {        /* jump */
 ** the value of the P1 argument to the value of the P1 argument to the
 ** calling OP_Program instruction.
 */
-case OP_Param: {           /* out2-prerelease */
+case OP_Param: {           /* out2 */
   VdbeFrame *pFrame;
   Mem *pIn;
+  pOut = out2Prerelease(p, pOp);
   pFrame = p->pFrame;
   pIn = &pFrame->aMem[pOp->p1 + pFrame->aOp[pFrame->pc].p1];   
   sqlite3VdbeMemShallowCopy(pOut, pIn, MEM_Ephem);
@@ -75683,10 +76401,10 @@ case OP_FkCounter: {
 case OP_FkIfZero: {         /* jump */
   if( pOp->p1 ){
     VdbeBranchTaken(db->nDeferredCons==0 && db->nDeferredImmCons==0, 2);
-    if( db->nDeferredCons==0 && db->nDeferredImmCons==0 ) pc = pOp->p2-1;
+    if( db->nDeferredCons==0 && db->nDeferredImmCons==0 ) goto jump_to_p2;
   }else{
     VdbeBranchTaken(p->nFkConstraint==0 && db->nDeferredImmCons==0, 2);
-    if( p->nFkConstraint==0 && db->nDeferredImmCons==0 ) pc = pOp->p2-1;
+    if( p->nFkConstraint==0 && db->nDeferredImmCons==0 ) goto jump_to_p2;
   }
   break;
 }
@@ -75726,18 +76444,18 @@ case OP_MemMax: {        /* in2 */
 /* Opcode: IfPos P1 P2 * * *
 ** Synopsis: if r[P1]>0 goto P2
 **
-** If the value of register P1 is 1 or greater, jump to P2.
+** Register P1 must contain an integer.
+** If the value of register P1 is 1 or greater, jump to P2 and
+** add the literal value P3 to register P1.
 **
-** It is illegal to use this instruction on a register that does
-** not contain an integer.  An assertion fault will result if you try.
+** If the initial value of register P1 is less than 1, then the
+** value is unchanged and control passes through to the next instruction.
 */
 case OP_IfPos: {        /* jump, in1 */
   pIn1 = &aMem[pOp->p1];
   assert( pIn1->flags&MEM_Int );
   VdbeBranchTaken( pIn1->u.i>0, 2);
-  if( pIn1->u.i>0 ){
-     pc = pOp->p2 - 1;
-  }
+  if( pIn1->u.i>0 ) goto jump_to_p2;
   break;
 }
 
@@ -75752,26 +76470,56 @@ case OP_IfNeg: {        /* jump, in1 */
   assert( pIn1->flags&MEM_Int );
   pIn1->u.i += pOp->p3;
   VdbeBranchTaken(pIn1->u.i<0, 2);
-  if( pIn1->u.i<0 ){
-     pc = pOp->p2 - 1;
+  if( pIn1->u.i<0 ) goto jump_to_p2;
+  break;
+}
+
+/* Opcode: IfNotZero P1 P2 P3 * *
+** Synopsis: if r[P1]!=0 then r[P1]+=P3, goto P2
+**
+** Register P1 must contain an integer.  If the content of register P1 is
+** initially nonzero, then add P3 to P1 and jump to P2.  If register P1 is
+** initially zero, leave it unchanged and fall through.
+*/
+case OP_IfNotZero: {        /* jump, in1 */
+  pIn1 = &aMem[pOp->p1];
+  assert( pIn1->flags&MEM_Int );
+  VdbeBranchTaken(pIn1->u.i<0, 2);
+  if( pIn1->u.i ){
+     pIn1->u.i += pOp->p3;
+     goto jump_to_p2;
   }
   break;
 }
 
-/* Opcode: IfZero P1 P2 P3 * *
-** Synopsis: r[P1]+=P3, if r[P1]==0 goto P2
+/* Opcode: DecrJumpZero P1 P2 * * *
+** Synopsis: if (--r[P1])==0 goto P2
 **
-** The register P1 must contain an integer.  Add literal P3 to the
-** value in register P1.  If the result is exactly 0, jump to P2. 
+** Register P1 must hold an integer.  Decrement the value in register P1
+** then jump to P2 if the new value is exactly zero.
 */
-case OP_IfZero: {        /* jump, in1 */
+case OP_DecrJumpZero: {      /* jump, in1 */
   pIn1 = &aMem[pOp->p1];
   assert( pIn1->flags&MEM_Int );
-  pIn1->u.i += pOp->p3;
+  pIn1->u.i--;
   VdbeBranchTaken(pIn1->u.i==0, 2);
-  if( pIn1->u.i==0 ){
-     pc = pOp->p2 - 1;
-  }
+  if( pIn1->u.i==0 ) goto jump_to_p2;
+  break;
+}
+
+
+/* Opcode: JumpZeroIncr P1 P2 * * *
+** Synopsis: if (r[P1]++)==0 ) goto P2
+**
+** The register P1 must contain an integer.  If register P1 is initially
+** zero, then jump to P2.  Increment register P1 regardless of whether or
+** not the jump is taken.
+*/
+case OP_JumpZeroIncr: {        /* jump, in1 */
+  pIn1 = &aMem[pOp->p1];
+  assert( pIn1->flags&MEM_Int );
+  VdbeBranchTaken(pIn1->u.i==0, 2);
+  if( (pIn1->u.i++)==0 ) goto jump_to_p2;
   break;
 }
 
@@ -75813,7 +76561,7 @@ case OP_AggStep: {
   ctx.pOut = &t;
   ctx.isError = 0;
   ctx.pVdbe = p;
-  ctx.iOp = pc;
+  ctx.iOp = (int)(pOp - aOp);
   ctx.skipFlag = 0;
   (ctx.pFunc->xStep)(&ctx, n, apVal); /* IMP: R-24505-23230 */
   if( ctx.isError ){
@@ -75908,7 +76656,7 @@ case OP_Checkpoint: {
 **
 ** Write a string containing the final journal-mode to register P2.
 */
-case OP_JournalMode: {    /* out2-prerelease */
+case OP_JournalMode: {    /* out2 */
   Btree *pBt;                     /* Btree to change journal mode of */
   Pager *pPager;                  /* Pager associated with pBt */
   int eNew;                       /* New journal mode */
@@ -75917,6 +76665,7 @@ case OP_JournalMode: {    /* out2-prerelease */
   const char *zFilename;          /* Name of database file for pPager */
 #endif
 
+  pOut = out2Prerelease(p, pOp);
   eNew = pOp->p3;
   assert( eNew==PAGER_JOURNALMODE_DELETE 
        || eNew==PAGER_JOURNALMODE_TRUNCATE 
@@ -75992,7 +76741,6 @@ case OP_JournalMode: {    /* out2-prerelease */
   }
   eNew = sqlite3PagerSetJournalMode(pPager, eNew);
 
-  pOut = &aMem[pOp->p2];
   pOut->flags = MEM_Str|MEM_Static|MEM_Term;
   pOut->z = (char *)sqlite3JournalModename(eNew);
   pOut->n = sqlite3Strlen30(pOut->z);
@@ -76033,8 +76781,8 @@ case OP_IncrVacuum: {        /* jump */
   rc = sqlite3BtreeIncrVacuum(pBt);
   VdbeBranchTaken(rc==SQLITE_DONE,2);
   if( rc==SQLITE_DONE ){
-    pc = pOp->p2 - 1;
     rc = SQLITE_OK;
+    goto jump_to_p2;
   }
   break;
 }
@@ -76112,13 +76860,29 @@ case OP_VBegin: {
 #endif /* SQLITE_OMIT_VIRTUALTABLE */
 
 #ifndef SQLITE_OMIT_VIRTUALTABLE
-/* Opcode: VCreate P1 * * P4 *
+/* Opcode: VCreate P1 P2 * * *
 **
-** P4 is the name of a virtual table in database P1. Call the xCreate method
-** for that table.
+** P2 is a register that holds the name of a virtual table in database 
+** P1. Call the xCreate method for that table.
 */
 case OP_VCreate: {
-  rc = sqlite3VtabCallCreate(db, pOp->p1, pOp->p4.z, &p->zErrMsg);
+  Mem sMem;          /* For storing the record being decoded */
+  const char *zTab;  /* Name of the virtual table */
+
+  memset(&sMem, 0, sizeof(sMem));
+  sMem.db = db;
+  /* Because P2 is always a static string, it is impossible for the
+  ** sqlite3VdbeMemCopy() to fail */
+  assert( (aMem[pOp->p2].flags & MEM_Str)!=0 );
+  assert( (aMem[pOp->p2].flags & MEM_Static)!=0 );
+  rc = sqlite3VdbeMemCopy(&sMem, &aMem[pOp->p2]);
+  assert( rc==SQLITE_OK );
+  zTab = (const char*)sqlite3_value_text(&sMem);
+  assert( zTab || db->mallocFailed );
+  if( zTab ){
+    rc = sqlite3VtabCallCreate(db, pOp->p1, zTab, &p->zErrMsg);
+  }
+  sqlite3VdbeMemRelease(&sMem);
   break;
 }
 #endif /* SQLITE_OMIT_VIRTUALTABLE */
@@ -76130,9 +76894,9 @@ case OP_VCreate: {
 ** of that table.
 */
 case OP_VDestroy: {
-  p->inVtabMethod = 2;
+  db->nVDestroy++;
   rc = sqlite3VtabCallDestroy(db, pOp->p1, pOp->p4.z);
-  p->inVtabMethod = 0;
+  db->nVDestroy--;
   break;
 }
 #endif /* SQLITE_OMIT_VIRTUALTABLE */
@@ -76148,14 +76912,17 @@ case OP_VOpen: {
   VdbeCursor *pCur;
   sqlite3_vtab_cursor *pVtabCursor;
   sqlite3_vtab *pVtab;
-  sqlite3_module *pModule;
+  const sqlite3_module *pModule;
 
   assert( p->bIsReader );
   pCur = 0;
   pVtabCursor = 0;
   pVtab = pOp->p4.pVtab->pVtab;
-  pModule = (sqlite3_module *)pVtab->pModule;
-  assert(pVtab && pModule);
+  if( pVtab==0 || NEVER(pVtab->pModule==0) ){
+    rc = SQLITE_LOCKED;
+    break;
+  }
+  pModule = pVtab->pModule;
   rc = pModule->xOpen(pVtab, &pVtabCursor);
   sqlite3VtabImportErrmsg(p, pVtab);
   if( SQLITE_OK==rc ){
@@ -76166,9 +76933,11 @@ case OP_VOpen: {
     pCur = allocateCursor(p, pOp->p1, 0, -1, 0);
     if( pCur ){
       pCur->pVtabCursor = pVtabCursor;
+      pVtab->nRef++;
     }else{
-      db->mallocFailed = 1;
+      assert( db->mallocFailed );
       pModule->xClose(pVtabCursor);
+      goto no_mem;
     }
   }
   break;
@@ -76224,27 +76993,19 @@ case OP_VFilter: {   /* jump */
   iQuery = (int)pQuery->u.i;
 
   /* Invoke the xFilter method */
-  {
-    res = 0;
-    apArg = p->apArg;
-    for(i = 0; i<nArg; i++){
-      apArg[i] = &pArgc[i+1];
-    }
-
-    p->inVtabMethod = 1;
-    rc = pModule->xFilter(pVtabCursor, iQuery, pOp->p4.z, nArg, apArg);
-    p->inVtabMethod = 0;
-    sqlite3VtabImportErrmsg(p, pVtab);
-    if( rc==SQLITE_OK ){
-      res = pModule->xEof(pVtabCursor);
-    }
-    VdbeBranchTaken(res!=0,2);
-    if( res ){
-      pc = pOp->p2 - 1;
-    }
+  res = 0;
+  apArg = p->apArg;
+  for(i = 0; i<nArg; i++){
+    apArg[i] = &pArgc[i+1];
+  }
+  rc = pModule->xFilter(pVtabCursor, iQuery, pOp->p4.z, nArg, apArg);
+  sqlite3VtabImportErrmsg(p, pVtab);
+  if( rc==SQLITE_OK ){
+    res = pModule->xEof(pVtabCursor);
   }
   pCur->nullRow = 0;
-
+  VdbeBranchTaken(res!=0,2);
+  if( res ) goto jump_to_p2;
   break;
 }
 #endif /* SQLITE_OMIT_VIRTUALTABLE */
@@ -76323,9 +77084,7 @@ case OP_VNext: {   /* jump */
   ** data is available) and the error code returned when xColumn or
   ** some other method is next invoked on the save virtual table cursor.
   */
-  p->inVtabMethod = 1;
   rc = pModule->xNext(pCur->pVtabCursor);
-  p->inVtabMethod = 0;
   sqlite3VtabImportErrmsg(p, pVtab);
   if( rc==SQLITE_OK ){
     res = pModule->xEof(pCur->pVtabCursor);
@@ -76333,7 +77092,7 @@ case OP_VNext: {   /* jump */
   VdbeBranchTaken(!res,2);
   if( !res ){
     /* If there is data, jump to P2 */
-    pc = pOp->p2 - 1;
+    goto jump_to_p2_and_check_for_interrupt;
   }
   goto check_for_interrupt;
 }
@@ -76400,7 +77159,7 @@ case OP_VRename: {
 */
 case OP_VUpdate: {
   sqlite3_vtab *pVtab;
-  sqlite3_module *pModule;
+  const sqlite3_module *pModule;
   int nArg;
   int i;
   sqlite_int64 rowid;
@@ -76412,7 +77171,11 @@ case OP_VUpdate: {
   );
   assert( p->readOnly==0 );
   pVtab = pOp->p4.pVtab->pVtab;
-  pModule = (sqlite3_module *)pVtab->pModule;
+  if( pVtab==0 || NEVER(pVtab->pModule==0) ){
+    rc = SQLITE_LOCKED;
+    break;
+  }
+  pModule = pVtab->pModule;
   nArg = pOp->p2;
   assert( pOp->p4type==P4_VTAB );
   if( ALWAYS(pModule->xUpdate) ){
@@ -76452,7 +77215,8 @@ case OP_VUpdate: {
 **
 ** Write the current number of pages in database P1 to memory cell P2.
 */
-case OP_Pagecount: {            /* out2-prerelease */
+case OP_Pagecount: {            /* out2 */
+  pOut = out2Prerelease(p, pOp);
   pOut->u.i = sqlite3BtreeLastPage(db->aDb[pOp->p1].pBt);
   break;
 }
@@ -76468,10 +77232,11 @@ case OP_Pagecount: {            /* out2-prerelease */
 **
 ** Store the maximum page count after the change in register P2.
 */
-case OP_MaxPgcnt: {            /* out2-prerelease */
+case OP_MaxPgcnt: {            /* out2 */
   unsigned int newMax;
   Btree *pBt;
 
+  pOut = out2Prerelease(p, pOp);
   pBt = db->aDb[pOp->p1].pBt;
   newMax = 0;
   if( pOp->p3 ){
@@ -76500,9 +77265,6 @@ case OP_Init: {          /* jump */
   char *zTrace;
   char *z;
 
-  if( pOp->p2 ){
-    pc = pOp->p2 - 1;
-  }
 #ifndef SQLITE_OMIT_TRACE
   if( db->xTrace
    && !p->doingRerun
@@ -76530,6 +77292,7 @@ case OP_Init: {          /* jump */
   }
 #endif /* SQLITE_DEBUG */
 #endif /* SQLITE_OMIT_TRACE */
+  if( pOp->p2 ) goto jump_to_p2;
   break;
 }
 
@@ -76561,8 +77324,8 @@ default: {          /* This is really OP_Noop and OP_Explain */
 #ifdef VDBE_PROFILE
     {
       u64 endTime = sqlite3Hwtime();
-      if( endTime>start ) pOp->cycles += endTime - start;
-      pOp->cnt++;
+      if( endTime>start ) pOrigOp->cycles += endTime - start;
+      pOrigOp->cnt++;
     }
 #endif
 
@@ -76572,16 +77335,16 @@ default: {          /* This is really OP_Noop and OP_Explain */
     ** the evaluator loop.  So we can leave it out when NDEBUG is defined.
     */
 #ifndef NDEBUG
-    assert( pc>=-1 && pc<p->nOp );
+    assert( pOp>=&aOp[-1] && pOp<&aOp[p->nOp-1] );
 
 #ifdef SQLITE_DEBUG
     if( db->flags & SQLITE_VdbeTrace ){
       if( rc!=0 ) printf("rc=%d\n",rc);
-      if( pOp->opflags & (OPFLG_OUT2_PRERELEASE|OPFLG_OUT2) ){
-        registerTrace(pOp->p2, &aMem[pOp->p2]);
+      if( pOrigOp->opflags & (OPFLG_OUT2) ){
+        registerTrace(pOrigOp->p2, &aMem[pOrigOp->p2]);
       }
-      if( pOp->opflags & OPFLG_OUT3 ){
-        registerTrace(pOp->p3, &aMem[pOp->p3]);
+      if( pOrigOp->opflags & OPFLG_OUT3 ){
+        registerTrace(pOrigOp->p3, &aMem[pOrigOp->p3]);
       }
     }
 #endif  /* SQLITE_DEBUG */
@@ -76596,7 +77359,7 @@ default: {          /* This is really OP_Noop and OP_Explain */
   p->rc = rc;
   testcase( sqlite3GlobalConfig.xLog!=0 );
   sqlite3_log(rc, "statement aborts at %d: [%s] %s", 
-                   pc, p->zSql, p->zErrMsg);
+                   (int)(pOp - aOp), p->zSql, p->zErrMsg);
   sqlite3VdbeHalt(p);
   if( rc==SQLITE_IOERR_NOMEM ) db->mallocFailed = 1;
   rc = SQLITE_ERROR;
@@ -76759,7 +77522,7 @@ static int blobSeekToRow(Incrblob *p, sqlite3_int64 iRow, char **pzErr){
 /*
 ** Open a blob handle.
 */
-SQLITE_API int sqlite3_blob_open(
+SQLITE_API int SQLITE_STDCALL sqlite3_blob_open(
   sqlite3* db,            /* The database connection */
   const char *zDb,        /* The attached database containing the blob */
   const char *zTable,     /* The table containing the blob */
@@ -76809,12 +77572,17 @@ SQLITE_API int sqlite3_blob_open(
   Incrblob *pBlob = 0;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
-  if( !sqlite3SafetyCheckOk(db) || ppBlob==0 || zTable==0 ){
+  if( ppBlob==0 ){
     return SQLITE_MISUSE_BKPT;
   }
 #endif
-  flags = !!flags;                /* flags = (flags ? 1 : 0); */
   *ppBlob = 0;
+#ifdef SQLITE_ENABLE_API_ARMOR
+  if( !sqlite3SafetyCheckOk(db) || zTable==0 ){
+    return SQLITE_MISUSE_BKPT;
+  }
+#endif
+  flags = !!flags;                /* flags = (flags ? 1 : 0); */
 
   sqlite3_mutex_enter(db->mutex);
 
@@ -76991,7 +77759,7 @@ SQLITE_API int sqlite3_blob_open(
 ** Close a blob handle that was previously created using
 ** sqlite3_blob_open().
 */
-SQLITE_API int sqlite3_blob_close(sqlite3_blob *pBlob){
+SQLITE_API int SQLITE_STDCALL sqlite3_blob_close(sqlite3_blob *pBlob){
   Incrblob *p = (Incrblob *)pBlob;
   int rc;
   sqlite3 *db;
@@ -77028,7 +77796,7 @@ static int blobReadWrite(
   sqlite3_mutex_enter(db->mutex);
   v = (Vdbe*)p->pStmt;
 
-  if( n<0 || iOffset<0 || (iOffset+n)>p->nByte ){
+  if( n<0 || iOffset<0 || ((sqlite3_int64)iOffset+n)>p->nByte ){
     /* Request is out of range. Return a transient error. */
     rc = SQLITE_ERROR;
   }else if( v==0 ){
@@ -77060,14 +77828,14 @@ static int blobReadWrite(
 /*
 ** Read data from a blob handle.
 */
-SQLITE_API int sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset){
+SQLITE_API int SQLITE_STDCALL sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset){
   return blobReadWrite(pBlob, z, n, iOffset, sqlite3BtreeData);
 }
 
 /*
 ** Write data to a blob handle.
 */
-SQLITE_API int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset){
+SQLITE_API int SQLITE_STDCALL sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset){
   return blobReadWrite(pBlob, (void *)z, n, iOffset, sqlite3BtreePutData);
 }
 
@@ -77077,7 +77845,7 @@ SQLITE_API int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int
 ** The Incrblob.nByte field is fixed for the lifetime of the Incrblob
 ** so no mutex is required for access.
 */
-SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *pBlob){
+SQLITE_API int SQLITE_STDCALL sqlite3_blob_bytes(sqlite3_blob *pBlob){
   Incrblob *p = (Incrblob *)pBlob;
   return (p && p->pStmt) ? p->nByte : 0;
 }
@@ -77092,7 +77860,7 @@ SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *pBlob){
 ** subsequent calls to sqlite3_blob_xxx() functions (except blob_close()) 
 ** immediately return SQLITE_ABORT.
 */
-SQLITE_API int sqlite3_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow){
+SQLITE_API int SQLITE_STDCALL sqlite3_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow){
   int rc;
   Incrblob *p = (Incrblob *)pBlob;
   sqlite3 *db;
@@ -77417,6 +78185,7 @@ struct MergeEngine {
 ** after the thread has finished are not dire. So we don't worry about
 ** memory barriers and such here.
 */
+typedef int (*SorterCompare)(SortSubtask*,int*,const void*,int,const void*,int);
 struct SortSubtask {
   SQLiteThread *pThread;          /* Background thread, if any */
   int bDone;                      /* Set if thread is finished but not joined */
@@ -77424,10 +78193,12 @@ struct SortSubtask {
   UnpackedRecord *pUnpacked;      /* Space to unpack a record */
   SorterList list;                /* List for thread to write to a PMA */
   int nPMA;                       /* Number of PMAs currently in file */
+  SorterCompare xCompare;         /* Compare function to use */
   SorterFile file;                /* Temp file for level-0 PMAs */
   SorterFile file2;               /* Space for other PMAs */
 };
 
+
 /*
 ** Main sorter structure. A single instance of this is allocated for each 
 ** sorter cursor created by the VDBE.
@@ -77454,9 +78225,13 @@ struct VdbeSorter {
   u8 bUseThreads;                 /* True to use background threads */
   u8 iPrev;                       /* Previous thread used to flush PMA */
   u8 nTask;                       /* Size of aTask[] array */
+  u8 typeMask;
   SortSubtask aTask[1];           /* One or more subtasks */
 };
 
+#define SORTER_TYPE_INTEGER 0x01
+#define SORTER_TYPE_TEXT    0x02
+
 /*
 ** An instance of the following object is used to read records out of a
 ** PMA, in sorted order.  The next key to be read is cached in nKey/aKey.
@@ -77868,32 +78643,162 @@ static int vdbePmaReaderInit(
   return rc;
 }
 
+/*
+** A version of vdbeSorterCompare() that assumes that it has already been
+** determined that the first field of key1 is equal to the first field of 
+** key2.
+*/
+static int vdbeSorterCompareTail(
+  SortSubtask *pTask,             /* Subtask context (for pKeyInfo) */
+  int *pbKey2Cached,              /* True if pTask->pUnpacked is pKey2 */
+  const void *pKey1, int nKey1,   /* Left side of comparison */
+  const void *pKey2, int nKey2    /* Right side of comparison */
+){
+  UnpackedRecord *r2 = pTask->pUnpacked;
+  if( *pbKey2Cached==0 ){
+    sqlite3VdbeRecordUnpack(pTask->pSorter->pKeyInfo, nKey2, pKey2, r2);
+    *pbKey2Cached = 1;
+  }
+  return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, r2, 1);
+}
 
 /*
 ** Compare key1 (buffer pKey1, size nKey1 bytes) with key2 (buffer pKey2, 
 ** size nKey2 bytes). Use (pTask->pKeyInfo) for the collation sequences
 ** used by the comparison. Return the result of the comparison.
 **
-** Before returning, object (pTask->pUnpacked) is populated with the
-** unpacked version of key2. Or, if pKey2 is passed a NULL pointer, then it 
-** is assumed that the (pTask->pUnpacked) structure already contains the 
-** unpacked key to use as key2.
+** If IN/OUT parameter *pbKey2Cached is true when this function is called,
+** it is assumed that (pTask->pUnpacked) contains the unpacked version
+** of key2. If it is false, (pTask->pUnpacked) is populated with the unpacked
+** version of key2 and *pbKey2Cached set to true before returning.
 **
 ** If an OOM error is encountered, (pTask->pUnpacked->error_rc) is set
 ** to SQLITE_NOMEM.
 */
 static int vdbeSorterCompare(
   SortSubtask *pTask,             /* Subtask context (for pKeyInfo) */
+  int *pbKey2Cached,              /* True if pTask->pUnpacked is pKey2 */
   const void *pKey1, int nKey1,   /* Left side of comparison */
   const void *pKey2, int nKey2    /* Right side of comparison */
 ){
   UnpackedRecord *r2 = pTask->pUnpacked;
-  if( pKey2 ){
+  if( !*pbKey2Cached ){
     sqlite3VdbeRecordUnpack(pTask->pSorter->pKeyInfo, nKey2, pKey2, r2);
+    *pbKey2Cached = 1;
   }
   return sqlite3VdbeRecordCompare(nKey1, pKey1, r2);
 }
 
+/*
+** A specially optimized version of vdbeSorterCompare() that assumes that
+** the first field of each key is a TEXT value and that the collation
+** sequence to compare them with is BINARY.
+*/
+static int vdbeSorterCompareText(
+  SortSubtask *pTask,             /* Subtask context (for pKeyInfo) */
+  int *pbKey2Cached,              /* True if pTask->pUnpacked is pKey2 */
+  const void *pKey1, int nKey1,   /* Left side of comparison */
+  const void *pKey2, int nKey2    /* Right side of comparison */
+){
+  const u8 * const p1 = (const u8 * const)pKey1;
+  const u8 * const p2 = (const u8 * const)pKey2;
+  const u8 * const v1 = &p1[ p1[0] ];   /* Pointer to value 1 */
+  const u8 * const v2 = &p2[ p2[0] ];   /* Pointer to value 2 */
+
+  int n1;
+  int n2;
+  int res;
+
+  getVarint32(&p1[1], n1); n1 = (n1 - 13) / 2;
+  getVarint32(&p2[1], n2); n2 = (n2 - 13) / 2;
+  res = memcmp(v1, v2, MIN(n1, n2));
+  if( res==0 ){
+    res = n1 - n2;
+  }
+
+  if( res==0 ){
+    if( pTask->pSorter->pKeyInfo->nField>1 ){
+      res = vdbeSorterCompareTail(
+          pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2
+      );
+    }
+  }else{
+    if( pTask->pSorter->pKeyInfo->aSortOrder[0] ){
+      res = res * -1;
+    }
+  }
+
+  return res;
+}
+
+/*
+** A specially optimized version of vdbeSorterCompare() that assumes that
+** the first field of each key is an INTEGER value.
+*/
+static int vdbeSorterCompareInt(
+  SortSubtask *pTask,             /* Subtask context (for pKeyInfo) */
+  int *pbKey2Cached,              /* True if pTask->pUnpacked is pKey2 */
+  const void *pKey1, int nKey1,   /* Left side of comparison */
+  const void *pKey2, int nKey2    /* Right side of comparison */
+){
+  const u8 * const p1 = (const u8 * const)pKey1;
+  const u8 * const p2 = (const u8 * const)pKey2;
+  const int s1 = p1[1];                 /* Left hand serial type */
+  const int s2 = p2[1];                 /* Right hand serial type */
+  const u8 * const v1 = &p1[ p1[0] ];   /* Pointer to value 1 */
+  const u8 * const v2 = &p2[ p2[0] ];   /* Pointer to value 2 */
+  int res;                              /* Return value */
+
+  assert( (s1>0 && s1<7) || s1==8 || s1==9 );
+  assert( (s2>0 && s2<7) || s2==8 || s2==9 );
+
+  if( s1>7 && s2>7 ){
+    res = s1 - s2;
+  }else{
+    if( s1==s2 ){
+      if( (*v1 ^ *v2) & 0x80 ){
+        /* The two values have different signs */
+        res = (*v1 & 0x80) ? -1 : +1;
+      }else{
+        /* The two values have the same sign. Compare using memcmp(). */
+        static const u8 aLen[] = {0, 1, 2, 3, 4, 6, 8 };
+        int i;
+        res = 0;
+        for(i=0; i<aLen[s1]; i++){
+          if( (res = v1[i] - v2[i]) ) break;
+        }
+      }
+    }else{
+      if( s2>7 ){
+        res = +1;
+      }else if( s1>7 ){
+        res = -1;
+      }else{
+        res = s1 - s2;
+      }
+      assert( res!=0 );
+
+      if( res>0 ){
+        if( *v1 & 0x80 ) res = -1;
+      }else{
+        if( *v2 & 0x80 ) res = +1;
+      }
+    }
+  }
+
+  if( res==0 ){
+    if( pTask->pSorter->pKeyInfo->nField>1 ){
+      res = vdbeSorterCompareTail(
+          pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2
+      );
+    }
+  }else if( pTask->pSorter->pKeyInfo->aSortOrder[0] ){
+    res = res * -1;
+  }
+
+  return res;
+}
+
 /*
 ** Initialize the temporary index cursor just opened as a sorter cursor.
 **
@@ -77961,9 +78866,13 @@ SQLITE_PRIVATE int sqlite3VdbeSorterInit(
     pSorter->pKeyInfo = pKeyInfo = (KeyInfo*)((u8*)pSorter + sz);
     memcpy(pKeyInfo, pCsr->pKeyInfo, szKeyInfo);
     pKeyInfo->db = 0;
-    if( nField && nWorker==0 ) pKeyInfo->nField = nField;
+    if( nField && nWorker==0 ){
+      pKeyInfo->nXField += (pKeyInfo->nField - nField);
+      pKeyInfo->nField = nField;
+    }
     pSorter->pgsz = pgsz = sqlite3BtreeGetPageSize(db->aDb[0].pBt);
     pSorter->nTask = nWorker + 1;
+    pSorter->iPrev = nWorker-1;
     pSorter->bUseThreads = (pSorter->nTask>1);
     pSorter->db = db;
     for(i=0; i<pSorter->nTask; i++){
@@ -77989,6 +78898,12 @@ SQLITE_PRIVATE int sqlite3VdbeSorterInit(
         if( !pSorter->list.aMemory ) rc = SQLITE_NOMEM;
       }
     }
+
+    if( (pKeyInfo->nField+pKeyInfo->nXField)<13 
+     && (pKeyInfo->aColl[0]==0 || pKeyInfo->aColl[0]==db->pDfltColl)
+    ){
+      pSorter->typeMask = SORTER_TYPE_INTEGER | SORTER_TYPE_TEXT;
+    }
   }
 
   return rc;
@@ -78013,30 +78928,24 @@ static void vdbeSorterRecordFree(sqlite3 *db, SorterRecord *pRecord){
 */
 static void vdbeSortSubtaskCleanup(sqlite3 *db, SortSubtask *pTask){
   sqlite3DbFree(db, pTask->pUnpacked);
-  pTask->pUnpacked = 0;
 #if SQLITE_MAX_WORKER_THREADS>0
   /* pTask->list.aMemory can only be non-zero if it was handed memory
   ** from the main thread.  That only occurs SQLITE_MAX_WORKER_THREADS>0 */
   if( pTask->list.aMemory ){
     sqlite3_free(pTask->list.aMemory);
-    pTask->list.aMemory = 0;
   }else
 #endif
   {
     assert( pTask->list.aMemory==0 );
     vdbeSorterRecordFree(0, pTask->list.pList);
   }
-  pTask->list.pList = 0;
   if( pTask->file.pFd ){
     sqlite3OsCloseFree(pTask->file.pFd);
-    pTask->file.pFd = 0;
-    pTask->file.iEof = 0;
   }
   if( pTask->file2.pFd ){
     sqlite3OsCloseFree(pTask->file2.pFd);
-    pTask->file2.pFd = 0;
-    pTask->file2.iEof = 0;
   }
+  memset(pTask, 0, sizeof(SortSubtask));
 }
 
 #ifdef SQLITE_DEBUG_SORTER_THREADS
@@ -78216,6 +79125,7 @@ SQLITE_PRIVATE void sqlite3VdbeSorterReset(sqlite3 *db, VdbeSorter *pSorter){
   for(i=0; i<pSorter->nTask; i++){
     SortSubtask *pTask = &pSorter->aTask[i];
     vdbeSortSubtaskCleanup(db, pTask);
+    pTask->pSorter = pSorter;
   }
   if( pSorter->list.aMemory==0 ){
     vdbeSorterRecordFree(0, pSorter->list.pList);
@@ -78277,6 +79187,7 @@ static int vdbeSorterOpenTempFile(
   sqlite3_file **ppFd
 ){
   int rc;
+  if( sqlite3FaultSim(202) ) return SQLITE_IOERR_ACCESS;
   rc = sqlite3OsOpenMalloc(db->pVfs, 0, ppFd,
       SQLITE_OPEN_TEMP_JOURNAL |
       SQLITE_OPEN_READWRITE    | SQLITE_OPEN_CREATE |
@@ -78324,28 +79235,42 @@ static void vdbeSorterMerge(
 ){
   SorterRecord *pFinal = 0;
   SorterRecord **pp = &pFinal;
-  void *pVal2 = p2 ? SRVAL(p2) : 0;
+  int bCached = 0;
 
   while( p1 && p2 ){
     int res;
-    res = vdbeSorterCompare(pTask, SRVAL(p1), p1->nVal, pVal2, p2->nVal);
+    res = pTask->xCompare(
+        pTask, &bCached, SRVAL(p1), p1->nVal, SRVAL(p2), p2->nVal
+    );
+
     if( res<=0 ){
       *pp = p1;
       pp = &p1->u.pNext;
       p1 = p1->u.pNext;
-      pVal2 = 0;
     }else{
       *pp = p2;
-       pp = &p2->u.pNext;
+      pp = &p2->u.pNext;
       p2 = p2->u.pNext;
-      if( p2==0 ) break;
-      pVal2 = SRVAL(p2);
+      bCached = 0;
     }
   }
   *pp = p1 ? p1 : p2;
   *ppOut = pFinal;
 }
 
+/*
+** Return the SorterCompare function to compare values collected by the
+** sorter object passed as the only argument.
+*/
+static SorterCompare vdbeSorterGetCompare(VdbeSorter *p){
+  if( p->typeMask==SORTER_TYPE_INTEGER ){
+    return vdbeSorterCompareInt;
+  }else if( p->typeMask==SORTER_TYPE_TEXT ){
+    return vdbeSorterCompareText; 
+  }
+  return vdbeSorterCompare;
+}
+
 /*
 ** Sort the linked list of records headed at pTask->pList. Return 
 ** SQLITE_OK if successful, or an SQLite error code (i.e. SQLITE_NOMEM) if 
@@ -78360,12 +79285,14 @@ static int vdbeSorterSort(SortSubtask *pTask, SorterList *pList){
   rc = vdbeSortAllocUnpacked(pTask);
   if( rc!=SQLITE_OK ) return rc;
 
+  p = pList->pList;
+  pTask->xCompare = vdbeSorterGetCompare(pTask->pSorter);
+
   aSlot = (SorterRecord **)sqlite3MallocZero(64 * sizeof(SorterRecord *));
   if( !aSlot ){
     return SQLITE_NOMEM;
   }
 
-  p = pList->pList;
   while( p ){
     SorterRecord *pNext;
     if( pList->aMemory ){
@@ -78579,13 +79506,12 @@ static int vdbeMergeEngineStep(
     int i;                      /* Index of aTree[] to recalculate */
     PmaReader *pReadr1;         /* First PmaReader to compare */
     PmaReader *pReadr2;         /* Second PmaReader to compare */
-    u8 *pKey2;                  /* To pReadr2->aKey, or 0 if record cached */
+    int bCached = 0;
 
     /* Find the first two PmaReaders to compare. The one that was just
     ** advanced (iPrev) and the one next to it in the array.  */
     pReadr1 = &pMerger->aReadr[(iPrev & 0xFFFE)];
     pReadr2 = &pMerger->aReadr[(iPrev | 0x0001)];
-    pKey2 = pReadr2->aKey;
 
     for(i=(pMerger->nTree+iPrev)/2; i>0; i=i/2){
       /* Compare pReadr1 and pReadr2. Store the result in variable iRes. */
@@ -78595,8 +79521,8 @@ static int vdbeMergeEngineStep(
       }else if( pReadr2->pFd==0 ){
         iRes = -1;
       }else{
-        iRes = vdbeSorterCompare(pTask, 
-            pReadr1->aKey, pReadr1->nKey, pKey2, pReadr2->nKey
+        iRes = pTask->xCompare(pTask, &bCached,
+            pReadr1->aKey, pReadr1->nKey, pReadr2->aKey, pReadr2->nKey
         );
       }
 
@@ -78618,9 +79544,9 @@ static int vdbeMergeEngineStep(
       if( iRes<0 || (iRes==0 && pReadr1<pReadr2) ){
         pMerger->aTree[i] = (int)(pReadr1 - pMerger->aReadr);
         pReadr2 = &pMerger->aReadr[ pMerger->aTree[i ^ 0x0001] ];
-        pKey2 = pReadr2->aKey;
+        bCached = 0;
       }else{
-        if( pReadr1->pFd ) pKey2 = 0;
+        if( pReadr1->pFd ) bCached = 0;
         pMerger->aTree[i] = (int)(pReadr2 - pMerger->aReadr);
         pReadr1 = &pMerger->aReadr[ pMerger->aTree[i ^ 0x0001] ];
       }
@@ -78727,6 +79653,16 @@ SQLITE_PRIVATE int sqlite3VdbeSorterWrite(
   int bFlush;                     /* True to flush contents of memory to PMA */
   int nReq;                       /* Bytes of memory required */
   int nPMA;                       /* Bytes of PMA space required */
+  int t;                          /* serial type of first record field */
+
+  getVarint32((const u8*)&pVal->z[1], t);
+  if( t>0 && t<10 && t!=7 ){
+    pSorter->typeMask &= SORTER_TYPE_INTEGER;
+  }else if( t>10 && (t & 0x01) ){
+    pSorter->typeMask &= SORTER_TYPE_TEXT;
+  }else{
+    pSorter->typeMask = 0;
+  }
 
   assert( pSorter );
 
@@ -78992,10 +79928,12 @@ static void vdbeMergeEngineCompare(
   }else if( p2->pFd==0 ){
     iRes = i1;
   }else{
+    SortSubtask *pTask = pMerger->pTask;
+    int bCached = 0;
     int res;
-    assert( pMerger->pTask->pUnpacked!=0 );  /* from vdbeSortSubtaskMain() */
-    res = vdbeSorterCompare(
-        pMerger->pTask, p1->aKey, p1->nKey, p2->aKey, p2->nKey
+    assert( pTask->pUnpacked!=0 );  /* from vdbeSortSubtaskMain() */
+    res = pTask->xCompare(
+        pTask, &bCached, p1->aKey, p1->nKey, p2->aKey, p2->nKey
     );
     if( res<=0 ){
       iRes = i1;
@@ -79019,11 +79957,12 @@ static void vdbeMergeEngineCompare(
 #define INCRINIT_TASK   1
 #define INCRINIT_ROOT   2
 
-/* Forward reference.
-** The vdbeIncrMergeInit() and vdbePmaReaderIncrMergeInit() routines call each
-** other (when building a merge tree).
+/* 
+** Forward reference required as the vdbeIncrMergeInit() and
+** vdbePmaReaderIncrInit() routines are called mutually recursively when
+** building a merge tree.
 */
-static int vdbePmaReaderIncrMergeInit(PmaReader *pReadr, int eMode);
+static int vdbePmaReaderIncrInit(PmaReader *pReadr, int eMode);
 
 /*
 ** Initialize the MergeEngine object passed as the second argument. Once this
@@ -79070,7 +80009,7 @@ static int vdbeMergeEngineInit(
       ** better advantage of multi-processor hardware. */
       rc = vdbePmaReaderNext(&pMerger->aReadr[nTree-i-1]);
     }else{
-      rc = vdbePmaReaderIncrMergeInit(&pMerger->aReadr[i], INCRINIT_NORMAL);
+      rc = vdbePmaReaderIncrInit(&pMerger->aReadr[i], INCRINIT_NORMAL);
     }
     if( rc!=SQLITE_OK ) return rc;
   }
@@ -79082,17 +80021,15 @@ static int vdbeMergeEngineInit(
 }
 
 /*
-** Initialize the IncrMerge field of a PmaReader.
-**
-** If the PmaReader passed as the first argument is not an incremental-reader
-** (if pReadr->pIncr==0), then this function is a no-op. Otherwise, it serves
-** to open and/or initialize the temp file related fields of the IncrMerge
+** The PmaReader passed as the first argument is guaranteed to be an
+** incremental-reader (pReadr->pIncr!=0). This function serves to open
+** and/or initialize the temp file related fields of the IncrMerge
 ** object at (pReadr->pIncr).
 **
 ** If argument eMode is set to INCRINIT_NORMAL, then all PmaReaders
-** in the sub-tree headed by pReadr are also initialized. Data is then loaded
-** into the buffers belonging to pReadr and it is set to
-** point to the first key in its range.
+** in the sub-tree headed by pReadr are also initialized. Data is then 
+** loaded into the buffers belonging to pReadr and it is set to point to 
+** the first key in its range.
 **
 ** If argument eMode is set to INCRINIT_TASK, then pReadr is guaranteed
 ** to be a multi-threaded PmaReader and this function is being called in a
@@ -79119,59 +80056,62 @@ static int vdbeMergeEngineInit(
 static int vdbePmaReaderIncrMergeInit(PmaReader *pReadr, int eMode){
   int rc = SQLITE_OK;
   IncrMerger *pIncr = pReadr->pIncr;
+  SortSubtask *pTask = pIncr->pTask;
+  sqlite3 *db = pTask->pSorter->db;
 
   /* eMode is always INCRINIT_NORMAL in single-threaded mode */
   assert( SQLITE_MAX_WORKER_THREADS>0 || eMode==INCRINIT_NORMAL );
 
-  if( pIncr ){
-    SortSubtask *pTask = pIncr->pTask;
-    sqlite3 *db = pTask->pSorter->db;
-
-    rc = vdbeMergeEngineInit(pTask, pIncr->pMerger, eMode);
+  rc = vdbeMergeEngineInit(pTask, pIncr->pMerger, eMode);
 
-    /* Set up the required files for pIncr. A multi-theaded IncrMerge object
-    ** requires two temp files to itself, whereas a single-threaded object
-    ** only requires a region of pTask->file2. */
-    if( rc==SQLITE_OK ){
-      int mxSz = pIncr->mxSz;
+  /* Set up the required files for pIncr. A multi-theaded IncrMerge object
+  ** requires two temp files to itself, whereas a single-threaded object
+  ** only requires a region of pTask->file2. */
+  if( rc==SQLITE_OK ){
+    int mxSz = pIncr->mxSz;
 #if SQLITE_MAX_WORKER_THREADS>0
-      if( pIncr->bUseThread ){
-        rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[0].pFd);
-        if( rc==SQLITE_OK ){
-          rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[1].pFd);
-        }
-      }else
+    if( pIncr->bUseThread ){
+      rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[0].pFd);
+      if( rc==SQLITE_OK ){
+        rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[1].pFd);
+      }
+    }else
 #endif
-      /*if( !pIncr->bUseThread )*/{
-        if( pTask->file2.pFd==0 ){
-          assert( pTask->file2.iEof>0 );
-          rc = vdbeSorterOpenTempFile(db, pTask->file2.iEof, &pTask->file2.pFd);
-          pTask->file2.iEof = 0;
-        }
-        if( rc==SQLITE_OK ){
-          pIncr->aFile[1].pFd = pTask->file2.pFd;
-          pIncr->iStartOff = pTask->file2.iEof;
-          pTask->file2.iEof += mxSz;
-        }
+    /*if( !pIncr->bUseThread )*/{
+      if( pTask->file2.pFd==0 ){
+        assert( pTask->file2.iEof>0 );
+        rc = vdbeSorterOpenTempFile(db, pTask->file2.iEof, &pTask->file2.pFd);
+        pTask->file2.iEof = 0;
+      }
+      if( rc==SQLITE_OK ){
+        pIncr->aFile[1].pFd = pTask->file2.pFd;
+        pIncr->iStartOff = pTask->file2.iEof;
+        pTask->file2.iEof += mxSz;
       }
     }
+  }
 
 #if SQLITE_MAX_WORKER_THREADS>0
-    if( rc==SQLITE_OK && pIncr->bUseThread ){
-      /* Use the current thread to populate aFile[1], even though this
-      ** PmaReader is multi-threaded. The reason being that this function
-      ** is already running in background thread pIncr->pTask->thread. */
-      assert( eMode==INCRINIT_ROOT || eMode==INCRINIT_TASK );
-      rc = vdbeIncrPopulate(pIncr);
-    }
+  if( rc==SQLITE_OK && pIncr->bUseThread ){
+    /* Use the current thread to populate aFile[1], even though this
+    ** PmaReader is multi-threaded. If this is an INCRINIT_TASK object,
+    ** then this function is already running in background thread 
+    ** pIncr->pTask->thread. 
+    **
+    ** If this is the INCRINIT_ROOT object, then it is running in the 
+    ** main VDBE thread. But that is Ok, as that thread cannot return
+    ** control to the VDBE or proceed with anything useful until the 
+    ** first results are ready from this merger object anyway.
+    */
+    assert( eMode==INCRINIT_ROOT || eMode==INCRINIT_TASK );
+    rc = vdbeIncrPopulate(pIncr);
+  }
 #endif
 
-    if( rc==SQLITE_OK
-     && (SQLITE_MAX_WORKER_THREADS==0 || eMode!=INCRINIT_TASK)
-    ){
-      rc = vdbePmaReaderNext(pReadr);
-    }
+  if( rc==SQLITE_OK && (SQLITE_MAX_WORKER_THREADS==0 || eMode!=INCRINIT_TASK) ){
+    rc = vdbePmaReaderNext(pReadr);
   }
+
   return rc;
 }
 
@@ -79180,7 +80120,7 @@ static int vdbePmaReaderIncrMergeInit(PmaReader *pReadr, int eMode){
 ** The main routine for vdbePmaReaderIncrMergeInit() operations run in 
 ** background threads.
 */
-static void *vdbePmaReaderBgInit(void *pCtx){
+static void *vdbePmaReaderBgIncrInit(void *pCtx){
   PmaReader *pReader = (PmaReader*)pCtx;
   void *pRet = SQLITE_INT_TO_PTR(
                   vdbePmaReaderIncrMergeInit(pReader,INCRINIT_TASK)
@@ -79188,20 +80128,36 @@ static void *vdbePmaReaderBgInit(void *pCtx){
   pReader->pIncr->pTask->bDone = 1;
   return pRet;
 }
+#endif
 
 /*
-** Use a background thread to invoke vdbePmaReaderIncrMergeInit(INCRINIT_TASK) 
-** on the PmaReader object passed as the first argument.
-**
-** This call will initialize the various fields of the pReadr->pIncr 
-** structure and, if it is a multi-threaded IncrMerger, launch a 
-** background thread to populate aFile[1].
+** If the PmaReader passed as the first argument is not an incremental-reader
+** (if pReadr->pIncr==0), then this function is a no-op. Otherwise, it invokes
+** the vdbePmaReaderIncrMergeInit() function with the parameters passed to
+** this routine to initialize the incremental merge.
+** 
+** If the IncrMerger object is multi-threaded (IncrMerger.bUseThread==1), 
+** then a background thread is launched to call vdbePmaReaderIncrMergeInit().
+** Or, if the IncrMerger is single threaded, the same function is called
+** using the current thread.
 */
-static int vdbePmaReaderBgIncrInit(PmaReader *pReadr){
-  void *pCtx = (void*)pReadr;
-  return vdbeSorterCreateThread(pReadr->pIncr->pTask, vdbePmaReaderBgInit, pCtx);
-}
+static int vdbePmaReaderIncrInit(PmaReader *pReadr, int eMode){
+  IncrMerger *pIncr = pReadr->pIncr;   /* Incremental merger */
+  int rc = SQLITE_OK;                  /* Return code */
+  if( pIncr ){
+#if SQLITE_MAX_WORKER_THREADS>0
+    assert( pIncr->bUseThread==0 || eMode==INCRINIT_TASK );
+    if( pIncr->bUseThread ){
+      void *pCtx = (void*)pReadr;
+      rc = vdbeSorterCreateThread(pIncr->pTask, vdbePmaReaderBgIncrInit, pCtx);
+    }else
 #endif
+    {
+      rc = vdbePmaReaderIncrMergeInit(pReadr, eMode);
+    }
+  }
+  return rc;
+}
 
 /*
 ** Allocate a new MergeEngine object to merge the contents of nPMA level-0
@@ -79413,6 +80369,11 @@ static int vdbeSorterSetupMerge(VdbeSorter *pSorter){
   MergeEngine *pMain = 0;
 #if SQLITE_MAX_WORKER_THREADS
   sqlite3 *db = pTask0->pSorter->db;
+  int i;
+  SorterCompare xCompare = vdbeSorterGetCompare(pSorter);
+  for(i=0; i<pSorter->nTask; i++){
+    pSorter->aTask[i].xCompare = xCompare;
+  }
 #endif
 
   rc = vdbeSorterMergeTreeBuild(pSorter, &pMain);
@@ -79441,15 +80402,21 @@ static int vdbeSorterSetupMerge(VdbeSorter *pSorter){
             }
           }
           for(iTask=0; rc==SQLITE_OK && iTask<pSorter->nTask; iTask++){
+            /* Check that:
+            **   
+            **   a) The incremental merge object is configured to use the
+            **      right task, and
+            **   b) If it is using task (nTask-1), it is configured to run
+            **      in single-threaded mode. This is important, as the
+            **      root merge (INCRINIT_ROOT) will be using the same task
+            **      object.
+            */
             PmaReader *p = &pMain->aReadr[iTask];
-            assert( p->pIncr==0 || p->pIncr->pTask==&pSorter->aTask[iTask] );
-            if( p->pIncr ){ 
-              if( iTask==pSorter->nTask-1 ){
-                rc = vdbePmaReaderIncrMergeInit(p, INCRINIT_TASK);
-              }else{
-                rc = vdbePmaReaderBgIncrInit(p);
-              }
-            }
+            assert( p->pIncr==0 || (
+                (p->pIncr->pTask==&pSorter->aTask[iTask])             /* a */
+             && (iTask!=pSorter->nTask-1 || p->pIncr->bUseThread==0)  /* b */
+            ));
+            rc = vdbePmaReaderIncrInit(p, INCRINIT_TASK);
           }
         }
         pMain = 0;
@@ -80404,7 +81371,7 @@ static void incrAggFunctionDepth(Expr *pExpr, int N){
 **     SELECT a+b, c+d FROM t1 ORDER BY (a+b) COLLATE nocase;
 **
 ** The nSubquery parameter specifies how many levels of subquery the
-** alias is removed from the original expression.  The usually value is
+** alias is removed from the original expression.  The usual value is
 ** zero but it might be more if the alias is contained within a subquery
 ** of the original expression.  The Expr.op2 field of TK_AGG_FUNCTION
 ** structures must be increased by the nSubquery amount.
@@ -80424,7 +81391,6 @@ static void resolveAlias(
   assert( iCol>=0 && iCol<pEList->nExpr );
   pOrig = pEList->a[iCol].pExpr;
   assert( pOrig!=0 );
-  assert( pOrig->flags & EP_Resolved );
   db = pParse->db;
   pDup = sqlite3ExprDup(db, pOrig, 0);
   if( pDup==0 ) return;
@@ -80572,9 +81538,10 @@ static int lookupName(
     testcase( pNC->ncFlags & NC_PartIdx );
     testcase( pNC->ncFlags & NC_IsCheck );
     if( (pNC->ncFlags & (NC_PartIdx|NC_IsCheck))!=0 ){
-      /* Silently ignore database qualifiers inside CHECK constraints and partial
-      ** indices.  Do not raise errors because that might break legacy and
-      ** because it does not hurt anything to just ignore the database name. */
+      /* Silently ignore database qualifiers inside CHECK constraints and
+      ** partial indices.  Do not raise errors because that might break
+      ** legacy and because it does not hurt anything to just ignore the
+      ** database name. */
       zDb = 0;
     }else{
       for(i=0; i<db->nDb; i++){
@@ -80645,7 +81612,8 @@ static int lookupName(
       if( pMatch ){
         pExpr->iTable = pMatch->iCursor;
         pExpr->pTab = pMatch->pTab;
-        assert( (pMatch->jointype & JT_RIGHT)==0 ); /* RIGHT JOIN not (yet) supported */
+        /* RIGHT JOIN not (yet) supported */
+        assert( (pMatch->jointype & JT_RIGHT)==0 );
         if( (pMatch->jointype & JT_LEFT)!=0 ){
           ExprSetProperty(pExpr, EP_CanBeNull);
         }
@@ -80966,7 +81934,8 @@ static int resolveExprStep(Walker *pWalker, Expr *pExpr){
       pExpr->affinity = SQLITE_AFF_INTEGER;
       break;
     }
-#endif /* defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY) */
+#endif /* defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT)
+          && !defined(SQLITE_OMIT_SUBQUERY) */
 
     /* A lone identifier is the name of a column.
     */
@@ -81031,19 +82000,20 @@ static int resolveExprStep(Walker *pWalker, Expr *pExpr){
           if( n==2 ){
             pExpr->iTable = exprProbability(pList->a[1].pExpr);
             if( pExpr->iTable<0 ){
-              sqlite3ErrorMsg(pParse, "second argument to likelihood() must be a "
-                                      "constant between 0.0 and 1.0");
+              sqlite3ErrorMsg(pParse,
+                "second argument to likelihood() must be a "
+                "constant between 0.0 and 1.0");
               pNC->nErr++;
             }
           }else{
-            /* EVIDENCE-OF: R-61304-29449 The unlikely(X) function is equivalent to
-            ** likelihood(X, 0.0625).
-            ** EVIDENCE-OF: R-01283-11636 The unlikely(X) function is short-hand for
-            ** likelihood(X,0.0625).
-            ** EVIDENCE-OF: R-36850-34127 The likely(X) function is short-hand for
-            ** likelihood(X,0.9375).
-            ** EVIDENCE-OF: R-53436-40973 The likely(X) function is equivalent to
-            ** likelihood(X,0.9375). */
+            /* EVIDENCE-OF: R-61304-29449 The unlikely(X) function is
+            ** equivalent to likelihood(X, 0.0625).
+            ** EVIDENCE-OF: R-01283-11636 The unlikely(X) function is
+            ** short-hand for likelihood(X,0.0625).
+            ** EVIDENCE-OF: R-36850-34127 The likely(X) function is short-hand
+            ** for likelihood(X,0.9375).
+            ** EVIDENCE-OF: R-53436-40973 The likely(X) function is equivalent
+            ** to likelihood(X,0.9375). */
             /* TUNING: unlikely() probability is 0.0625.  likely() is 0.9375 */
             pExpr->iTable = pDef->zName[0]=='u' ? 8388608 : 125829120;
           }             
@@ -81060,7 +82030,9 @@ static int resolveExprStep(Walker *pWalker, Expr *pExpr){
           return WRC_Prune;
         }
 #endif
-        if( pDef->funcFlags & SQLITE_FUNC_CONSTANT ) ExprSetProperty(pExpr,EP_Constant);
+        if( pDef->funcFlags & SQLITE_FUNC_CONSTANT ){
+          ExprSetProperty(pExpr,EP_ConstFunc);
+        }
       }
       if( is_agg && (pNC->ncFlags & NC_AllowAgg)==0 ){
         sqlite3ErrorMsg(pParse, "misuse of aggregate function %.*s()", nId,zId);
@@ -81312,9 +82284,11 @@ static int resolveCompoundOrderBy(
         if( pItem->pExpr==pE ){
           pItem->pExpr = pNew;
         }else{
-          assert( pItem->pExpr->op==TK_COLLATE );
-          assert( pItem->pExpr->pLeft==pE );
-          pItem->pExpr->pLeft = pNew;
+          Expr *pParent = pItem->pExpr;
+          assert( pParent->op==TK_COLLATE );
+          while( pParent->pLeft->op==TK_COLLATE ) pParent = pParent->pLeft;
+          assert( pParent->pLeft==pE );
+          pParent->pLeft = pNew;
         }
         sqlite3ExprDelete(db, pE);
         pItem->u.x.iOrderByCol = (u16)iCol;
@@ -81371,7 +82345,8 @@ SQLITE_PRIVATE int sqlite3ResolveOrderGroupBy(
         resolveOutOfRangeError(pParse, zType, i+1, pEList->nExpr);
         return 1;
       }
-      resolveAlias(pParse, pEList, pItem->u.x.iOrderByCol-1, pItem->pExpr, zType,0);
+      resolveAlias(pParse, pEList, pItem->u.x.iOrderByCol-1, pItem->pExpr,
+                   zType,0);
     }
   }
   return 0;
@@ -81504,6 +82479,20 @@ static int resolveSelectStep(Walker *pWalker, Select *p){
         sqlite3ResolveExprNames(&sNC, p->pOffset) ){
       return WRC_Abort;
     }
+
+    /* If the SF_Converted flags is set, then this Select object was
+    ** was created by the convertCompoundSelectToSubquery() function.
+    ** In this case the ORDER BY clause (p->pOrderBy) should be resolved
+    ** as if it were part of the sub-query, not the parent. This block
+    ** moves the pOrderBy down to the sub-query. It will be moved back
+    ** after the names have been resolved.  */
+    if( p->selFlags & SF_Converted ){
+      Select *pSub = p->pSrc->a[0].pSelect;
+      assert( p->pSrc->nSrc==1 && p->pOrderBy );
+      assert( pSub->pPrior && pSub->pOrderBy==0 );
+      pSub->pOrderBy = p->pOrderBy;
+      p->pOrderBy = 0;
+    }
   
     /* Recursively resolve names in all subqueries
     */
@@ -81586,12 +82575,30 @@ static int resolveSelectStep(Walker *pWalker, Select *p){
     sNC.pNext = 0;
     sNC.ncFlags |= NC_AllowAgg;
 
+    /* If this is a converted compound query, move the ORDER BY clause from 
+    ** the sub-query back to the parent query. At this point each term
+    ** within the ORDER BY clause has been transformed to an integer value.
+    ** These integers will be replaced by copies of the corresponding result
+    ** set expressions by the call to resolveOrderGroupBy() below.  */
+    if( p->selFlags & SF_Converted ){
+      Select *pSub = p->pSrc->a[0].pSelect;
+      p->pOrderBy = pSub->pOrderBy;
+      pSub->pOrderBy = 0;
+    }
+
     /* Process the ORDER BY clause for singleton SELECT statements.
     ** The ORDER BY clause for compounds SELECT statements is handled
     ** below, after all of the result-sets for all of the elements of
     ** the compound have been resolved.
+    **
+    ** If there is an ORDER BY clause on a term of a compound-select other
+    ** than the right-most term, then that is a syntax error.  But the error
+    ** is not detected until much later, and so we need to go ahead and
+    ** resolve those symbols on the incorrect ORDER BY for consistency.
     */
-    if( !isCompound && resolveOrderGroupBy(&sNC, p, p->pOrderBy, "ORDER") ){
+    if( isCompound<=nCompound  /* Defer right-most ORDER BY of a compound */
+     && resolveOrderGroupBy(&sNC, p, p->pOrderBy, "ORDER")
+    ){
       return WRC_Abort;
     }
     if( db->mallocFailed ){
@@ -81861,10 +82868,11 @@ SQLITE_PRIVATE char sqlite3ExprAffinity(Expr *pExpr){
 SQLITE_PRIVATE Expr *sqlite3ExprAddCollateToken(
   Parse *pParse,           /* Parsing context */
   Expr *pExpr,             /* Add the "COLLATE" clause to this expression */
-  const Token *pCollName   /* Name of collating sequence */
+  const Token *pCollName,  /* Name of collating sequence */
+  int dequote              /* True to dequote pCollName */
 ){
   if( pCollName->n>0 ){
-    Expr *pNew = sqlite3ExprAlloc(pParse->db, TK_COLLATE, pCollName, 1);
+    Expr *pNew = sqlite3ExprAlloc(pParse->db, TK_COLLATE, pCollName, dequote);
     if( pNew ){
       pNew->pLeft = pExpr;
       pNew->flags |= EP_Collate|EP_Skip;
@@ -81878,7 +82886,7 @@ SQLITE_PRIVATE Expr *sqlite3ExprAddCollateString(Parse *pParse, Expr *pExpr, con
   assert( zC!=0 );
   s.z = zC;
   s.n = sqlite3Strlen30(s.z);
-  return sqlite3ExprAddCollateToken(pParse, pExpr, &s);
+  return sqlite3ExprAddCollateToken(pParse, pExpr, &s, 0);
 }
 
 /*
@@ -81924,9 +82932,9 @@ SQLITE_PRIVATE CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr){
       pColl = sqlite3GetCollSeq(pParse, ENC(db), 0, p->u.zToken);
       break;
     }
-    if( p->pTab!=0
-     && (op==TK_AGG_COLUMN || op==TK_COLUMN
+    if( (op==TK_AGG_COLUMN || op==TK_COLUMN
           || op==TK_REGISTER || op==TK_TRIGGER)
+     && p->pTab!=0
     ){
       /* op==TK_REGISTER && p->pTab!=0 happens when pExpr was originally
       ** a TK_COLUMN but was previously evaluated and cached in a register */
@@ -81938,10 +82946,25 @@ SQLITE_PRIVATE CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr){
       break;
     }
     if( p->flags & EP_Collate ){
-      if( ALWAYS(p->pLeft) && (p->pLeft->flags & EP_Collate)!=0 ){
+      if( p->pLeft && (p->pLeft->flags & EP_Collate)!=0 ){
         p = p->pLeft;
       }else{
-        p = p->pRight;
+        Expr *pNext  = p->pRight;
+        /* The Expr.x union is never used at the same time as Expr.pRight */
+        assert( p->x.pList==0 || p->pRight==0 );
+        /* p->flags holds EP_Collate and p->pLeft->flags does not.  And
+        ** p->x.pSelect cannot.  So if p->x.pLeft exists, it must hold at
+        ** least one EP_Collate. Thus the following two ALWAYS. */
+        if( p->x.pList!=0 && ALWAYS(!ExprHasProperty(p, EP_xIsSelect)) ){
+          int i;
+          for(i=0; ALWAYS(i<p->x.pList->nExpr); i++){
+            if( ExprHasProperty(p->x.pList->a[i].pExpr, EP_Collate) ){
+              pNext = p->x.pList->a[i].pExpr;
+              break;
+            }
+          }
+        }
+        p = pNext;
       }
     }else{
       break;
@@ -82147,6 +83170,9 @@ static void heightOfSelect(Select *p, int *pnHeight){
 ** Expr.pSelect member has a height of 1. Any other expression
 ** has a height equal to the maximum height of any other 
 ** referenced Expr plus one.
+**
+** Also propagate EP_Propagate flags up from Expr.x.pList to Expr.flags,
+** if appropriate.
 */
 static void exprSetHeight(Expr *p){
   int nHeight = 0;
@@ -82154,8 +83180,9 @@ static void exprSetHeight(Expr *p){
   heightOfExpr(p->pRight, &nHeight);
   if( ExprHasProperty(p, EP_xIsSelect) ){
     heightOfSelect(p->x.pSelect, &nHeight);
-  }else{
+  }else if( p->x.pList ){
     heightOfExprList(p->x.pList, &nHeight);
+    p->flags |= EP_Propagate & sqlite3ExprListFlags(p->x.pList);
   }
   p->nHeight = nHeight + 1;
 }
@@ -82164,8 +83191,12 @@ static void exprSetHeight(Expr *p){
 ** Set the Expr.nHeight variable using the exprSetHeight() function. If
 ** the height is greater than the maximum allowed expression depth,
 ** leave an error in pParse.
+**
+** Also propagate all EP_Propagate flags from the Expr.x.pList into
+** Expr.flags. 
 */
-SQLITE_PRIVATE void sqlite3ExprSetHeight(Parse *pParse, Expr *p){
+SQLITE_PRIVATE void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p){
+  if( pParse->nErr ) return;
   exprSetHeight(p);
   sqlite3ExprCheckHeight(pParse, p->nHeight);
 }
@@ -82179,8 +83210,17 @@ SQLITE_PRIVATE int sqlite3SelectExprHeight(Select *p){
   heightOfSelect(p, &nHeight);
   return nHeight;
 }
-#else
-  #define exprSetHeight(y)
+#else /* ABOVE:  Height enforcement enabled.  BELOW: Height enforcement off */
+/*
+** Propagate all EP_Propagate flags from the Expr.x.pList into
+** Expr.flags. 
+*/
+SQLITE_PRIVATE void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p){
+  if( p && p->x.pList && !ExprHasProperty(p, EP_xIsSelect) ){
+    p->flags |= EP_Propagate & sqlite3ExprListFlags(p->x.pList);
+  }
+}
+#define exprSetHeight(y)
 #endif /* SQLITE_MAX_EXPR_DEPTH>0 */
 
 /*
@@ -82282,11 +83322,11 @@ SQLITE_PRIVATE void sqlite3ExprAttachSubtrees(
   }else{
     if( pRight ){
       pRoot->pRight = pRight;
-      pRoot->flags |= EP_Collate & pRight->flags;
+      pRoot->flags |= EP_Propagate & pRight->flags;
     }
     if( pLeft ){
       pRoot->pLeft = pLeft;
-      pRoot->flags |= EP_Collate & pLeft->flags;
+      pRoot->flags |= EP_Propagate & pLeft->flags;
     }
     exprSetHeight(pRoot);
   }
@@ -82386,7 +83426,7 @@ SQLITE_PRIVATE Expr *sqlite3ExprFunction(Parse *pParse, ExprList *pList, Token *
   }
   pNew->x.pList = pList;
   assert( !ExprHasProperty(pNew, EP_xIsSelect) );
-  sqlite3ExprSetHeight(pParse, pNew);
+  sqlite3ExprSetHeightAndFlags(pParse, pNew);
   return pNew;
 }
 
@@ -83001,6 +84041,22 @@ SQLITE_PRIVATE void sqlite3ExprListDelete(sqlite3 *db, ExprList *pList){
   sqlite3DbFree(db, pList);
 }
 
+/*
+** Return the bitwise-OR of all Expr.flags fields in the given
+** ExprList.
+*/
+SQLITE_PRIVATE u32 sqlite3ExprListFlags(const ExprList *pList){
+  int i;
+  u32 m = 0;
+  if( pList ){
+    for(i=0; i<pList->nExpr; i++){
+       Expr *pExpr = pList->a[i].pExpr;
+       if( ALWAYS(pExpr) ) m |= pExpr->flags;
+    }
+  }
+  return m;
+}
+
 /*
 ** These routines are Walker callbacks used to check expressions to
 ** see if they are "constant" for some definition of constant.  The
@@ -83041,7 +84097,7 @@ static int exprNodeIsConstant(Walker *pWalker, Expr *pExpr){
     ** and either pWalker->eCode==4 or 5 or the function has the
     ** SQLITE_FUNC_CONST flag. */
     case TK_FUNCTION:
-      if( pWalker->eCode>=4 || ExprHasProperty(pExpr,EP_Constant) ){
+      if( pWalker->eCode>=4 || ExprHasProperty(pExpr,EP_ConstFunc) ){
         return WRC_Continue;
       }else{
         pWalker->eCode = 0;
@@ -83435,7 +84491,7 @@ SQLITE_PRIVATE int sqlite3FindInIndex(Parse *pParse, Expr *pX, u32 inFlags, int
   ** ephemeral table.
   */
   p = (ExprHasProperty(pX, EP_xIsSelect) ? pX->x.pSelect : 0);
-  if( ALWAYS(pParse->nErr==0) && isCandidateForInOpt(p) ){
+  if( pParse->nErr==0 && isCandidateForInOpt(p) ){
     sqlite3 *db = pParse->db;              /* Database connection */
     Table *pTab;                           /* Table <table>. */
     Expr *pExpr;                           /* Expression <column> */
@@ -83760,6 +84816,7 @@ SQLITE_PRIVATE int sqlite3CodeSubselect(
       pSel->pLimit = sqlite3PExpr(pParse, TK_INTEGER, 0, 0,
                                   &sqlite3IntTokens[1]);
       pSel->iLimit = 0;
+      pSel->selFlags &= ~SF_MultiValue;
       if( sqlite3Select(pParse, pSel, &dest) ){
         return 0;
       }
@@ -84048,7 +85105,8 @@ SQLITE_PRIVATE void sqlite3ExprCacheStore(Parse *pParse, int iTab, int iCol, int
   int idxLru;
   struct yColCache *p;
 
-  assert( iReg>0 );  /* Register numbers are always positive */
+  /* Unless an error has occurred, register numbers are always positive. */
+  assert( iReg>0 || pParse->nErr || pParse->db->mallocFailed );
   assert( iCol>=-1 && iCol<32768 );  /* Finite column numbers */
 
   /* The SQLITE_ColumnCache flag disables the column cache.  This is used
@@ -85124,7 +86182,7 @@ SQLITE_PRIVATE void sqlite3TreeViewExpr(TreeView *pView, const Expr *pExpr, u8 m
       break;
     }
     case TK_ID: {
-      sqlite3TreeViewLine(pView,"ID %Q", pExpr->u.zToken);
+      sqlite3TreeViewLine(pView,"ID \"%w\"", pExpr->u.zToken);
       break;
     }
 #ifndef SQLITE_OMIT_CAST
@@ -85759,7 +86817,7 @@ SQLITE_PRIVATE int sqlite3ExprCompare(Expr *pA, Expr *pB, int iTab){
     if( sqlite3ExprCompare(pA->pLeft, pB->pLeft, iTab) ) return 2;
     if( sqlite3ExprCompare(pA->pRight, pB->pRight, iTab) ) return 2;
     if( sqlite3ExprListCompare(pA->x.pList, pB->x.pList, iTab) ) return 2;
-    if( ALWAYS((combinedFlags & EP_Reduced)==0) ){
+    if( ALWAYS((combinedFlags & EP_Reduced)==0) && pA->op!=TK_STRING ){
       if( pA->iColumn!=pB->iColumn ) return 2;
       if( pA->iTable!=pB->iTable 
        && (pA->iTable!=iTab || NEVER(pB->iTable>=0)) ) return 2;
@@ -86291,6 +87349,7 @@ static void renameParentFunc(
         n = sqlite3GetToken(z, &token);
       }while( token==TK_SPACE );
 
+      if( token==TK_ILLEGAL ) break;
       zParent = sqlite3DbStrNDup(db, (const char *)z, n);
       if( zParent==0 ) break;
       sqlite3Dequote(zParent);
@@ -86855,7 +87914,10 @@ SQLITE_PRIVATE void sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef){
   */
   if( pDflt ){
     sqlite3_value *pVal = 0;
-    if( sqlite3ValueFromExpr(db, pDflt, SQLITE_UTF8, SQLITE_AFF_NONE, &pVal) ){
+    int rc;
+    rc = sqlite3ValueFromExpr(db, pDflt, SQLITE_UTF8, SQLITE_AFF_NONE, &pVal);
+    assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );
+    if( rc!=SQLITE_OK ){
       db->mallocFailed = 1;
       return;
     }
@@ -88514,14 +89576,17 @@ static int analysisLoader(void *pData, int argc, char **argv, char **NotUsed){
   z = argv[2];
 
   if( pIndex ){
+    tRowcnt *aiRowEst = 0;
     int nCol = pIndex->nKeyCol+1;
 #ifdef SQLITE_ENABLE_STAT3_OR_STAT4
-    tRowcnt * const aiRowEst = pIndex->aiRowEst = (tRowcnt*)sqlite3MallocZero(
-        sizeof(tRowcnt) * nCol
-    );
-    if( aiRowEst==0 ) pInfo->db->mallocFailed = 1;
-#else
-    tRowcnt * const aiRowEst = 0;
+    /* Index.aiRowEst may already be set here if there are duplicate 
+    ** sqlite_stat1 entries for this index. In that case just clobber
+    ** the old data with the new instead of allocating a new array.  */
+    if( pIndex->aiRowEst==0 ){
+      pIndex->aiRowEst = (tRowcnt*)sqlite3MallocZero(sizeof(tRowcnt) * nCol);
+      if( pIndex->aiRowEst==0 ) pInfo->db->mallocFailed = 1;
+    }
+    aiRowEst = pIndex->aiRowEst;
 #endif
     pIndex->bUnordered = 0;
     decodeIntArray((char*)z, nCol, aiRowEst, pIndex->aiRowLogEst, pIndex);
@@ -89077,7 +90142,7 @@ static void attachFunc(
       case SQLITE_NULL:
         /* No key specified.  Use the key from the main database */
         sqlite3CodecGetKey(db, 0, (void**)&zKey, &nKey);
-        if( nKey>0 || sqlite3BtreeGetReserve(db->aDb[0].pBt)>0 ){
+        if( nKey>0 || sqlite3BtreeGetOptimalReserve(db->aDb[0].pBt)>0 ){
           rc = sqlite3CodecAttach(db, db->nDb-1, zKey, nKey);
         }
         break;
@@ -89184,7 +90249,7 @@ static void detachFunc(
   sqlite3BtreeClose(pDb->pBt);
   pDb->pBt = 0;
   pDb->pSchema = 0;
-  sqlite3ResetAllSchemasOfConnection(db);
+  sqlite3CollapseDatabaseArray(db);
   return;
 
 detach_error:
@@ -89218,7 +90283,6 @@ static void codeAttach(
       SQLITE_OK!=(rc = resolveAttachExpr(&sName, pDbname)) ||
       SQLITE_OK!=(rc = resolveAttachExpr(&sName, pKey))
   ){
-    pParse->nErr++;
     goto attach_end;
   }
 
@@ -89540,7 +90604,7 @@ SQLITE_PRIVATE int sqlite3FixTriggerStep(
 ** Setting the auth function to NULL disables this hook.  The default
 ** setting of the auth function is NULL.
 */
-SQLITE_API int sqlite3_set_authorizer(
+SQLITE_API int SQLITE_STDCALL sqlite3_set_authorizer(
   sqlite3 *db,
   int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),
   void *pArg
@@ -89877,9 +90941,11 @@ SQLITE_PRIVATE void sqlite3FinishCoding(Parse *pParse){
 
   assert( pParse->pToplevel==0 );
   db = pParse->db;
-  if( db->mallocFailed ) return;
   if( pParse->nested ) return;
-  if( pParse->nErr ) return;
+  if( db->mallocFailed || pParse->nErr ){
+    if( pParse->rc==SQLITE_OK ) pParse->rc = SQLITE_ERROR;
+    return;
+  }
 
   /* Begin by generating some termination code at the end of the
   ** vdbe program
@@ -89961,7 +91027,7 @@ SQLITE_PRIVATE void sqlite3FinishCoding(Parse *pParse){
 
   /* Get the VDBE program ready for execution
   */
-  if( v && ALWAYS(pParse->nErr==0) && !db->mallocFailed ){
+  if( v && pParse->nErr==0 && !db->mallocFailed ){
     assert( pParse->iCacheLevel==0 );  /* Disables and re-enables match */
     /* A minimum of one cursor is required if autoincrement is used
     *  See ticket [a696379c1f08866] */
@@ -90043,10 +91109,6 @@ SQLITE_PRIVATE Table *sqlite3FindTable(sqlite3 *db, const char *zName, const cha
   Table *p = 0;
   int i;
 
-#ifdef SQLITE_ENABLE_API_ARMOR
-  if( !sqlite3SafetyCheckOk(db) || zName==0 ) return 0;
-#endif
-
   /* All mutexes are required for schema access.  Make sure we hold them. */
   assert( zDatabase!=0 || sqlite3BtreeHoldsAllMutexes(db) );
 #if SQLITE_USER_AUTHENTICATION
@@ -90500,14 +91562,12 @@ SQLITE_PRIVATE int sqlite3TwoPartName(
   if( ALWAYS(pName2!=0) && pName2->n>0 ){
     if( db->init.busy ) {
       sqlite3ErrorMsg(pParse, "corrupt database");
-      pParse->nErr++;
       return -1;
     }
     *pUnqual = pName2;
     iDb = sqlite3FindDb(db, pName1);
     if( iDb<0 ){
       sqlite3ErrorMsg(pParse, "unknown database %T", pName1);
-      pParse->nErr++;
       return -1;
     }
   }else{
@@ -90666,7 +91726,7 @@ SQLITE_PRIVATE void sqlite3StartTable(
       if( !noErr ){
         sqlite3ErrorMsg(pParse, "table %T already exists", pName);
       }else{
-        assert( !db->init.busy );
+        assert( !db->init.busy || CORRUPT_DB );
         sqlite3CodeVerifySchema(pParse, iDb);
       }
       goto begin_table_error;
@@ -90955,7 +92015,8 @@ SQLITE_PRIVATE void sqlite3AddColumnType(Parse *pParse, Token *pType){
   p = pParse->pNewTable;
   if( p==0 || NEVER(p->nCol<1) ) return;
   pCol = &p->aCol[p->nCol-1];
-  assert( pCol->zType==0 );
+  assert( pCol->zType==0 || CORRUPT_DB );
+  sqlite3DbFree(pParse->db, pCol->zType);
   pCol->zType = sqlite3NameFromToken(pParse->db, pType);
   pCol->affinity = sqlite3AffinityType(pCol->zType, &pCol->szEst);
 }
@@ -91466,11 +92527,14 @@ static void convertToWithoutRowidTable(Parse *pParse, Table *pTab){
   assert( pPk!=0 );
   nPk = pPk->nKeyCol;
 
-  /* Make sure every column of the PRIMARY KEY is NOT NULL */
-  for(i=0; i<nPk; i++){
-    pTab->aCol[pPk->aiColumn[i]].notNull = 1;
+  /* Make sure every column of the PRIMARY KEY is NOT NULL.  (Except,
+  ** do not enforce this for imposter tables.) */
+  if( !db->init.imposterTable ){
+    for(i=0; i<nPk; i++){
+      pTab->aCol[pPk->aiColumn[i]].notNull = 1;
+    }
+    pPk->uniqNotNull = 1;
   }
-  pPk->uniqNotNull = 1;
 
   /* The root page of the PRIMARY KEY is the table root page */
   pPk->tnum = pTab->tnum;
@@ -92186,6 +93250,7 @@ SQLITE_PRIVATE void sqlite3DropTable(Parse *pParse, SrcList *pName, int isView,
   }
   assert( pParse->nErr==0 );
   assert( pName->nSrc==1 );
+  if( sqlite3ReadSchema(pParse) ) goto exit_drop_table;
   if( noErr ) db->suppressErr++;
   pTab = sqlite3LocateTableItem(pParse, isView, &pName->a[0]);
   if( noErr ) db->suppressErr--;
@@ -92499,7 +93564,8 @@ static void sqlite3RefillIndex(Parse *pParse, Index *pIndex, int memRootPage){
     addr2 = sqlite3VdbeCurrentAddr(v);
   }
   sqlite3VdbeAddOp3(v, OP_SorterData, iSorter, regRecord, iIdx);
-  sqlite3VdbeAddOp3(v, OP_IdxInsert, iIdx, regRecord, 1);
+  sqlite3VdbeAddOp3(v, OP_Last, iIdx, 0, -1);
+  sqlite3VdbeAddOp3(v, OP_IdxInsert, iIdx, regRecord, 0);
   sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);
   sqlite3ReleaseTempReg(pParse, regRecord);
   sqlite3VdbeAddOp2(v, OP_SorterNext, iSorter, addr2); VdbeCoverage(v);
@@ -92592,8 +93658,7 @@ SQLITE_PRIVATE Index *sqlite3CreateIndex(
   char *zExtra = 0;                /* Extra space after the Index object */
   Index *pPk = 0;      /* PRIMARY KEY index for WITHOUT ROWID tables */
 
-  assert( pParse->nErr==0 );      /* Never called with prior errors */
-  if( db->mallocFailed || IN_DECLARE_VTAB ){
+  if( db->mallocFailed || IN_DECLARE_VTAB || pParse->nErr>0 ){
     goto exit_create_index;
   }
   if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){
@@ -92919,6 +93984,7 @@ SQLITE_PRIVATE Index *sqlite3CreateIndex(
             pIdx->onError = pIndex->onError;
           }
         }
+        pRet = pIdx;
         goto exit_create_index;
       }
     }
@@ -93511,7 +94577,6 @@ SQLITE_PRIVATE void sqlite3SrcListIndexedBy(Parse *pParse, SrcList *p, Token *pI
 SQLITE_PRIVATE void sqlite3SrcListShiftJoinType(SrcList *p){
   if( p ){
     int i;
-    assert( p->a || p->nSrc==0 );
     for(i=p->nSrc-1; i>0; i--){
       p->a[i].jointype = p->a[i-1].jointype;
     }
@@ -93758,8 +94823,7 @@ SQLITE_PRIVATE void sqlite3UniqueConstraint(
   StrAccum errMsg;
   Table *pTab = pIdx->pTable;
 
-  sqlite3StrAccumInit(&errMsg, 0, 0, 200);
-  errMsg.db = pParse->db;
+  sqlite3StrAccumInit(&errMsg, pParse->db, 0, 0, 200);
   for(j=0; j<pIdx->nKeyCol; j++){
     char *zCol = pTab->aCol[pIdx->aiColumn[j]].zName;
     if( j ) sqlite3StrAccumAppend(&errMsg, ", ", 2);
@@ -94705,7 +95769,7 @@ SQLITE_PRIVATE Expr *sqlite3LimitWhere(
 
   pInClause->x.pSelect = pSelect;
   pInClause->flags |= EP_xIsSelect;
-  sqlite3ExprSetHeight(pParse, pInClause);
+  sqlite3ExprSetHeightAndFlags(pParse, pInClause);
   return pInClause;
 
   /* something went wrong. clean up anything allocated. */
@@ -95378,7 +96442,9 @@ SQLITE_PRIVATE void sqlite3ResolvePartIdxLabel(Parse *pParse, int iLabel){
 ** Return the collating function associated with a function.
 */
 static CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context){
-  VdbeOp *pOp = &context->pVdbe->aOp[context->iOp-1];
+  VdbeOp *pOp;
+  assert( context->pVdbe!=0 );
+  pOp = &context->pVdbe->aOp[context->iOp-1];
   assert( pOp->opcode==OP_CollSeq );
   assert( pOp->p4type==P4_COLLSEQ );
   return pOp->p4.pColl;
@@ -95586,13 +96652,13 @@ static void printfFunc(
   StrAccum str;
   const char *zFormat;
   int n;
+  sqlite3 *db = sqlite3_context_db_handle(context);
 
   if( argc>=1 && (zFormat = (const char*)sqlite3_value_text(argv[0]))!=0 ){
     x.nArg = argc-1;
     x.nUsed = 0;
     x.apArg = argv+1;
-    sqlite3StrAccumInit(&str, 0, 0, SQLITE_MAX_LENGTH);
-    str.db = sqlite3_context_db_handle(context);
+    sqlite3StrAccumInit(&str, db, 0, 0, db->aLimit[SQLITE_LIMIT_LENGTH]);
     sqlite3XPrintf(&str, SQLITE_PRINTF_SQLFUNC, zFormat, &x);
     n = str.nChar;
     sqlite3_result_text(context, sqlite3StrAccumFinish(&str), n,
@@ -95647,6 +96713,14 @@ static void substrFunc(
       }
     }
   }
+#ifdef SQLITE_SUBSTR_COMPATIBILITY
+  /* If SUBSTR_COMPATIBILITY is defined then substr(X,0,N) work the same as
+  ** as substr(X,1,N) - it returns the first N characters of X.  This
+  ** is essentially a back-out of the bug-fix in check-in [5fc125d362df4b8]
+  ** from 2009-02-02 for compatibility of applications that exploited the
+  ** old buggy behavior. */
+  if( p1==0 ) p1 = 1; /* <rdar://problem/6778339> */
+#endif
   if( argc==3 ){
     p2 = sqlite3_value_int(argv[2]);
     if( p2<0 ){
@@ -95734,7 +96808,7 @@ static void roundFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
 #endif
 
 /*
-** Allocate nByte bytes of space using sqlite3_malloc(). If the
+** Allocate nByte bytes of space using sqlite3Malloc(). If the
 ** allocation fails, call sqlite3_result_error_nomem() to notify
 ** the database handle that malloc() has failed and return NULL.
 ** If nByte is larger than the maximum string or blob length, then
@@ -96108,7 +97182,7 @@ static int patternCompare(
 /*
 ** The sqlite3_strglob() interface.
 */
-SQLITE_API int sqlite3_strglob(const char *zGlobPattern, const char *zString){
+SQLITE_API int SQLITE_STDCALL sqlite3_strglob(const char *zGlobPattern, const char *zString){
   return patternCompare((u8*)zGlobPattern, (u8*)zString, &globInfo, 0)==0;
 }
 
@@ -96403,7 +97477,7 @@ static void charFunc(
 ){
   unsigned char *z, *zOut;
   int i;
-  zOut = z = sqlite3_malloc( argc*4+1 );
+  zOut = z = sqlite3_malloc64( argc*4+1 );
   if( z==0 ){
     sqlite3_result_error_nomem(context);
     return;
@@ -96551,7 +97625,7 @@ static void replaceFunc(
         return;
       }
       zOld = zOut;
-      zOut = sqlite3_realloc(zOut, (int)nOut);
+      zOut = sqlite3_realloc64(zOut, (int)nOut);
       if( zOut==0 ){
         sqlite3_result_error_nomem(context);
         sqlite3_free(zOld);
@@ -96913,8 +97987,7 @@ static void groupConcatStep(
 
   if( pAccum ){
     sqlite3 *db = sqlite3_context_db_handle(context);
-    int firstTerm = pAccum->useMalloc==0;
-    pAccum->useMalloc = 2;
+    int firstTerm = pAccum->mxAlloc==0;
     pAccum->mxAlloc = db->aLimit[SQLITE_LIMIT_LENGTH];
     if( !firstTerm ){
       if( argc==2 ){
@@ -96998,6 +98071,11 @@ SQLITE_PRIVATE void sqlite3RegisterLikeFunctions(sqlite3 *db, int caseSensitive)
 ** then set aWc[0] through aWc[2] to the wildcard characters and
 ** return TRUE.  If the function is not a LIKE-style function then
 ** return FALSE.
+**
+** *pIsNocase is set to true if uppercase and lowercase are equivalent for
+** the function (default for LIKE).  If the function makes the distinction
+** between uppercase and lowercase (as does GLOB) then *pIsNocase is set to
+** false.
 */
 SQLITE_PRIVATE int sqlite3IsLikeFunction(sqlite3 *db, Expr *pExpr, int *pIsNocase, char *aWc){
   FuncDef *pDef;
@@ -98329,7 +99407,8 @@ static Trigger *fkActionTrigger(
 
       iFromCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;
       assert( iFromCol>=0 );
-      tToCol.z = pIdx ? pTab->aCol[pIdx->aiColumn[i]].zName : "oid";
+      assert( pIdx!=0 || (pTab->iPKey>=0 && pTab->iPKey<pTab->nCol) );
+      tToCol.z = pTab->aCol[pIdx ? pIdx->aiColumn[i] : pTab->iPKey].zName;
       tFromCol.z = pFKey->pFrom->aCol[iFromCol].zName;
 
       tToCol.n = sqlite3Strlen30(tToCol.z);
@@ -98341,10 +99420,10 @@ static Trigger *fkActionTrigger(
       ** parent table are used for the comparison. */
       pEq = sqlite3PExpr(pParse, TK_EQ,
           sqlite3PExpr(pParse, TK_DOT, 
-            sqlite3PExpr(pParse, TK_ID, 0, 0, &tOld),
-            sqlite3PExpr(pParse, TK_ID, 0, 0, &tToCol)
+            sqlite3ExprAlloc(db, TK_ID, &tOld, 0),
+            sqlite3ExprAlloc(db, TK_ID, &tToCol, 0)
           , 0),
-          sqlite3PExpr(pParse, TK_ID, 0, 0, &tFromCol)
+          sqlite3ExprAlloc(db, TK_ID, &tFromCol, 0)
       , 0);
       pWhere = sqlite3ExprAnd(db, pWhere, pEq);
 
@@ -98356,12 +99435,12 @@ static Trigger *fkActionTrigger(
       if( pChanges ){
         pEq = sqlite3PExpr(pParse, TK_IS,
             sqlite3PExpr(pParse, TK_DOT, 
-              sqlite3PExpr(pParse, TK_ID, 0, 0, &tOld),
-              sqlite3PExpr(pParse, TK_ID, 0, 0, &tToCol),
+              sqlite3ExprAlloc(db, TK_ID, &tOld, 0),
+              sqlite3ExprAlloc(db, TK_ID, &tToCol, 0),
               0),
             sqlite3PExpr(pParse, TK_DOT, 
-              sqlite3PExpr(pParse, TK_ID, 0, 0, &tNew),
-              sqlite3PExpr(pParse, TK_ID, 0, 0, &tToCol),
+              sqlite3ExprAlloc(db, TK_ID, &tNew, 0),
+              sqlite3ExprAlloc(db, TK_ID, &tToCol, 0),
               0),
             0);
         pWhen = sqlite3ExprAnd(db, pWhen, pEq);
@@ -98371,8 +99450,8 @@ static Trigger *fkActionTrigger(
         Expr *pNew;
         if( action==OE_Cascade ){
           pNew = sqlite3PExpr(pParse, TK_DOT, 
-            sqlite3PExpr(pParse, TK_ID, 0, 0, &tNew),
-            sqlite3PExpr(pParse, TK_ID, 0, 0, &tToCol)
+            sqlite3ExprAlloc(db, TK_ID, &tNew, 0),
+            sqlite3ExprAlloc(db, TK_ID, &tToCol, 0)
           , 0);
         }else if( action==OE_SetDflt ){
           Expr *pDflt = pFKey->pFrom->aCol[iFromCol].pDflt;
@@ -98419,13 +99498,12 @@ static Trigger *fkActionTrigger(
     pTrigger = (Trigger *)sqlite3DbMallocZero(db, 
         sizeof(Trigger) +         /* struct Trigger */
         sizeof(TriggerStep) +     /* Single step in trigger program */
-        nFrom + 1                 /* Space for pStep->target.z */
+        nFrom + 1                 /* Space for pStep->zTarget */
     );
     if( pTrigger ){
       pStep = pTrigger->step_list = (TriggerStep *)&pTrigger[1];
-      pStep->target.z = (char *)&pStep[1];
-      pStep->target.n = nFrom;
-      memcpy((char *)pStep->target.z, zFrom, nFrom);
+      pStep->zTarget = (char *)&pStep[1];
+      memcpy((char *)pStep->zTarget, zFrom, nFrom);
   
       pStep->pWhere = sqlite3ExprDup(db, pWhere, EXPRDUP_REDUCE);
       pStep->pExprList = sqlite3ExprListDup(db, pList, EXPRDUP_REDUCE);
@@ -98890,20 +99968,23 @@ static int xferOptimization(
 /*
 ** This routine is called to handle SQL of the following forms:
 **
-**    insert into TABLE (IDLIST) values(EXPRLIST)
+**    insert into TABLE (IDLIST) values(EXPRLIST),(EXPRLIST),...
 **    insert into TABLE (IDLIST) select
+**    insert into TABLE (IDLIST) default values
 **
 ** The IDLIST following the table name is always optional.  If omitted,
-** then a list of all columns for the table is substituted.  The IDLIST
-** appears in the pColumn parameter.  pColumn is NULL if IDLIST is omitted.
+** then a list of all (non-hidden) columns for the table is substituted.
+** The IDLIST appears in the pColumn parameter.  pColumn is NULL if IDLIST
+** is omitted.
 **
-** The pList parameter holds EXPRLIST in the first form of the INSERT
-** statement above, and pSelect is NULL.  For the second form, pList is
-** NULL and pSelect is a pointer to the select statement used to generate
-** data for the insert.
+** For the pSelect parameter holds the values to be inserted for the
+** first two forms shown above.  A VALUES clause is really just short-hand
+** for a SELECT statement that omits the FROM clause and everything else
+** that follows.  If the pSelect parameter is NULL, that means that the
+** DEFAULT VALUES form of the INSERT statement is intended.
 **
 ** The code generated follows one of four templates.  For a simple
-** insert with data coming from a VALUES clause, the code executes
+** insert with data coming from a single-row VALUES clause, the code executes
 ** once straight down through.  Pseudo-code follows (we call this
 ** the "1st template"):
 **
@@ -99010,7 +100091,7 @@ SQLITE_PRIVATE void sqlite3Insert(
   u8 useTempTable = 0;  /* Store SELECT results in intermediate table */
   u8 appendFlag = 0;    /* True if the insert is likely to be an append */
   u8 withoutRowid;      /* 0 for normal table.  1 for WITHOUT ROWID table */
-  u8 bIdListInOrder = 1; /* True if IDLIST is in table order */
+  u8 bIdListInOrder;    /* True if IDLIST is in table order */
   ExprList *pList = 0;  /* List of VALUES() to be inserted  */
 
   /* Register allocations */
@@ -99035,8 +100116,8 @@ SQLITE_PRIVATE void sqlite3Insert(
   }
 
   /* If the Select object is really just a simple VALUES() list with a
-  ** single row values (the common case) then keep that one row of values
-  ** and go ahead and discard the Select object
+  ** single row (the common case) then keep that one row of values
+  ** and discard the other (unused) parts of the pSelect object
   */
   if( pSelect && (pSelect->selFlags & SF_Values)!=0 && pSelect->pPrior==0 ){
     pList = pSelect->pEList;
@@ -99144,6 +100225,7 @@ SQLITE_PRIVATE void sqlite3Insert(
   ** is appears in the original table.  (The index of the INTEGER
   ** PRIMARY KEY in the original table is pTab->iPKey.)
   */
+  bIdListInOrder = (pTab->tabFlags & TF_OOOHidden)==0;
   if( pColumn ){
     for(i=0; i<pColumn->nId; i++){
       pColumn->a[i].idx = -1;
@@ -99179,7 +100261,8 @@ SQLITE_PRIVATE void sqlite3Insert(
   ** co-routine is the common header to the 3rd and 4th templates.
   */
   if( pSelect ){
-    /* Data is coming from a SELECT.  Generate a co-routine to run the SELECT */
+    /* Data is coming from a SELECT or from a multi-row VALUES clause.
+    ** Generate a co-routine to run the SELECT. */
     int regYield;       /* Register holding co-routine entry-point */
     int addrTop;        /* Top of the co-routine */
     int rc;             /* Result code */
@@ -99192,8 +100275,7 @@ SQLITE_PRIVATE void sqlite3Insert(
     dest.nSdst = pTab->nCol;
     rc = sqlite3Select(pParse, pSelect, &dest);
     regFromSelect = dest.iSdst;
-    assert( pParse->nErr==0 || rc );
-    if( rc || db->mallocFailed ) goto insert_cleanup;
+    if( rc || db->mallocFailed || pParse->nErr ) goto insert_cleanup;
     sqlite3VdbeAddOp1(v, OP_EndCoroutine, regYield);
     sqlite3VdbeJumpHere(v, addrTop - 1);                       /* label B: */
     assert( pSelect->pEList );
@@ -99241,8 +100323,8 @@ SQLITE_PRIVATE void sqlite3Insert(
       sqlite3ReleaseTempReg(pParse, regTempRowid);
     }
   }else{
-    /* This is the case if the data for the INSERT is coming from a VALUES
-    ** clause
+    /* This is the case if the data for the INSERT is coming from a 
+    ** single-row VALUES clause
     */
     NameContext sNC;
     memset(&sNC, 0, sizeof(sNC));
@@ -100313,6 +101395,7 @@ static int xferOptimization(
   int onError,          /* How to handle constraint errors */
   int iDbDest           /* The database of pDest */
 ){
+  sqlite3 *db = pParse->db;
   ExprList *pEList;                /* The result set of the SELECT */
   Table *pSrc;                     /* The table in the FROM clause of SELECT */
   Index *pSrcIdx, *pDestIdx;       /* Source and destination indices */
@@ -100460,11 +101543,11 @@ static int xferOptimization(
   ** the extra complication to make this rule less restrictive is probably
   ** not worth the effort.  Ticket [6284df89debdfa61db8073e062908af0c9b6118e]
   */
-  if( (pParse->db->flags & SQLITE_ForeignKeys)!=0 && pDest->pFKey!=0 ){
+  if( (db->flags & SQLITE_ForeignKeys)!=0 && pDest->pFKey!=0 ){
     return 0;
   }
 #endif
-  if( (pParse->db->flags & SQLITE_CountRows)!=0 ){
+  if( (db->flags & SQLITE_CountRows)!=0 ){
     return 0;  /* xfer opt does not play well with PRAGMA count_changes */
   }
 
@@ -100475,7 +101558,7 @@ static int xferOptimization(
 #ifdef SQLITE_TEST
   sqlite3_xferopt_count++;
 #endif
-  iDbSrc = sqlite3SchemaToIndex(pParse->db, pSrc->pSchema);
+  iDbSrc = sqlite3SchemaToIndex(db, pSrc->pSchema);
   v = sqlite3GetVdbe(pParse);
   sqlite3CodeVerifySchema(pParse, iDbSrc);
   iSrc = pParse->nTab++;
@@ -100485,14 +101568,18 @@ static int xferOptimization(
   regRowid = sqlite3GetTempReg(pParse);
   sqlite3OpenTable(pParse, iDest, iDbDest, pDest, OP_OpenWrite);
   assert( HasRowid(pDest) || destHasUniqueIdx );
-  if( (pDest->iPKey<0 && pDest->pIndex!=0)          /* (1) */
+  if( (db->flags & SQLITE_Vacuum)==0 && (
+      (pDest->iPKey<0 && pDest->pIndex!=0)          /* (1) */
    || destHasUniqueIdx                              /* (2) */
    || (onError!=OE_Abort && onError!=OE_Rollback)   /* (3) */
-  ){
+  )){
     /* In some circumstances, we are able to run the xfer optimization
-    ** only if the destination table is initially empty.  This code makes
-    ** that determination.  Conditions under which the destination must
-    ** be empty:
+    ** only if the destination table is initially empty. Unless the
+    ** SQLITE_Vacuum flag is set, this block generates code to make
+    ** that determination. If SQLITE_Vacuum is set, then the destination
+    ** table is always empty.
+    **
+    ** Conditions under which the destination must be empty:
     **
     ** (1) There is no INTEGER PRIMARY KEY but there are indices.
     **     (If the destination is not initially empty, the rowid fields
@@ -100535,6 +101622,7 @@ static int xferOptimization(
     sqlite3TableLock(pParse, iDbSrc, pSrc->tnum, 0, pSrc->zName);
   }
   for(pDestIdx=pDest->pIndex; pDestIdx; pDestIdx=pDestIdx->pNext){
+    u8 useSeekResult = 0;
     for(pSrcIdx=pSrc->pIndex; ALWAYS(pSrcIdx); pSrcIdx=pSrcIdx->pNext){
       if( xferCompatibleIndex(pDestIdx, pSrcIdx) ) break;
     }
@@ -100548,7 +101636,33 @@ static int xferOptimization(
     VdbeComment((v, "%s", pDestIdx->zName));
     addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iSrc, 0); VdbeCoverage(v);
     sqlite3VdbeAddOp2(v, OP_RowKey, iSrc, regData);
+    if( db->flags & SQLITE_Vacuum ){
+      /* This INSERT command is part of a VACUUM operation, which guarantees
+      ** that the destination table is empty. If all indexed columns use
+      ** collation sequence BINARY, then it can also be assumed that the
+      ** index will be populated by inserting keys in strictly sorted 
+      ** order. In this case, instead of seeking within the b-tree as part
+      ** of every OP_IdxInsert opcode, an OP_Last is added before the
+      ** OP_IdxInsert to seek to the point within the b-tree where each key 
+      ** should be inserted. This is faster.
+      **
+      ** If any of the indexed columns use a collation sequence other than
+      ** BINARY, this optimization is disabled. This is because the user 
+      ** might change the definition of a collation sequence and then run
+      ** a VACUUM command. In that case keys may not be written in strictly
+      ** sorted order.  */
+      for(i=0; i<pSrcIdx->nColumn; i++){
+        char *zColl = pSrcIdx->azColl[i];
+        assert( zColl!=0 );
+        if( sqlite3_stricmp("BINARY", zColl) ) break;
+      }
+      if( i==pSrcIdx->nColumn ){
+        useSeekResult = OPFLAG_USESEEKRESULT;
+        sqlite3VdbeAddOp3(v, OP_Last, iDest, 0, -1);
+      }
+    }
     sqlite3VdbeAddOp3(v, OP_IdxInsert, iDest, regData, 1);
+    sqlite3VdbeChangeP5(v, useSeekResult);
     sqlite3VdbeAddOp2(v, OP_Next, iSrc, addr1+1); VdbeCoverage(v);
     sqlite3VdbeJumpHere(v, addr1);
     sqlite3VdbeAddOp2(v, OP_Close, iSrc, 0);
@@ -100598,7 +101712,7 @@ static int xferOptimization(
 ** argument to xCallback().  If xCallback=NULL then no callback
 ** is invoked, even for queries.
 */
-SQLITE_API int sqlite3_exec(
+SQLITE_API int SQLITE_STDCALL sqlite3_exec(
   sqlite3 *db,                /* The database on which the SQL executes */
   const char *zSql,           /* The SQL to be executed */
   sqlite3_callback xCallback, /* Invoke this callback routine */
@@ -101667,7 +102781,7 @@ static int sqlite3LoadExtension(
   const char *zEntry;
   char *zAltEntry = 0;
   void **aHandle;
-  int nMsg = 300 + sqlite3Strlen30(zFile);
+  u64 nMsg = 300 + sqlite3Strlen30(zFile);
   int ii;
 
   /* Shared library endings to try if zFile cannot be loaded as written */
@@ -101710,7 +102824,7 @@ static int sqlite3LoadExtension(
 #endif
   if( handle==0 ){
     if( pzErrMsg ){
-      *pzErrMsg = zErrmsg = sqlite3_malloc(nMsg);
+      *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);
       if( zErrmsg ){
         sqlite3_snprintf(nMsg, zErrmsg, 
             "unable to open shared library [%s]", zFile);
@@ -101736,7 +102850,7 @@ static int sqlite3LoadExtension(
   if( xInit==0 && zProc==0 ){
     int iFile, iEntry, c;
     int ncFile = sqlite3Strlen30(zFile);
-    zAltEntry = sqlite3_malloc(ncFile+30);
+    zAltEntry = sqlite3_malloc64(ncFile+30);
     if( zAltEntry==0 ){
       sqlite3OsDlClose(pVfs, handle);
       return SQLITE_NOMEM;
@@ -101758,7 +102872,7 @@ static int sqlite3LoadExtension(
   if( xInit==0 ){
     if( pzErrMsg ){
       nMsg += sqlite3Strlen30(zEntry);
-      *pzErrMsg = zErrmsg = sqlite3_malloc(nMsg);
+      *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);
       if( zErrmsg ){
         sqlite3_snprintf(nMsg, zErrmsg,
             "no entry point [%s] in shared library [%s]", zEntry, zFile);
@@ -101793,7 +102907,7 @@ static int sqlite3LoadExtension(
   db->aExtension[db->nExtension++] = handle;
   return SQLITE_OK;
 }
-SQLITE_API int sqlite3_load_extension(
+SQLITE_API int SQLITE_STDCALL sqlite3_load_extension(
   sqlite3 *db,          /* Load the extension into this database connection */
   const char *zFile,    /* Name of the shared library containing extension */
   const char *zProc,    /* Entry point.  Use "sqlite3_extension_init" if 0 */
@@ -101824,7 +102938,7 @@ SQLITE_PRIVATE void sqlite3CloseExtensions(sqlite3 *db){
 ** Enable or disable extension loading.  Extension loading is disabled by
 ** default so as not to open security holes in older applications.
 */
-SQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff){
+SQLITE_API int SQLITE_STDCALL sqlite3_enable_load_extension(sqlite3 *db, int onoff){
   sqlite3_mutex_enter(db->mutex);
   if( onoff ){
     db->flags |= SQLITE_LoadExtension;
@@ -101857,7 +102971,7 @@ static const sqlite3_api_routines sqlite3Apis = { 0 };
 */
 typedef struct sqlite3AutoExtList sqlite3AutoExtList;
 static SQLITE_WSD struct sqlite3AutoExtList {
-  int nExt;              /* Number of entries in aExt[] */          
+  u32 nExt;              /* Number of entries in aExt[] */          
   void (**aExt)(void);   /* Pointers to the extension init functions */
 } sqlite3Autoext = { 0, 0 };
 
@@ -101881,7 +102995,7 @@ static SQLITE_WSD struct sqlite3AutoExtList {
 ** Register a statically linked extension that is automatically
 ** loaded by every new database connection.
 */
-SQLITE_API int sqlite3_auto_extension(void (*xInit)(void)){
+SQLITE_API int SQLITE_STDCALL sqlite3_auto_extension(void (*xInit)(void)){
   int rc = SQLITE_OK;
 #ifndef SQLITE_OMIT_AUTOINIT
   rc = sqlite3_initialize();
@@ -101890,7 +103004,7 @@ SQLITE_API int sqlite3_auto_extension(void (*xInit)(void)){
   }else
 #endif
   {
-    int i;
+    u32 i;
 #if SQLITE_THREADSAFE
     sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);
 #endif
@@ -101900,9 +103014,9 @@ SQLITE_API int sqlite3_auto_extension(void (*xInit)(void)){
       if( wsdAutoext.aExt[i]==xInit ) break;
     }
     if( i==wsdAutoext.nExt ){
-      int nByte = (wsdAutoext.nExt+1)*sizeof(wsdAutoext.aExt[0]);
+      u64 nByte = (wsdAutoext.nExt+1)*sizeof(wsdAutoext.aExt[0]);
       void (**aNew)(void);
-      aNew = sqlite3_realloc(wsdAutoext.aExt, nByte);
+      aNew = sqlite3_realloc64(wsdAutoext.aExt, nByte);
       if( aNew==0 ){
         rc = SQLITE_NOMEM;
       }else{
@@ -101926,7 +103040,7 @@ SQLITE_API int sqlite3_auto_extension(void (*xInit)(void)){
 ** Return 1 if xInit was found on the list and removed.  Return 0 if xInit
 ** was not on the list.
 */
-SQLITE_API int sqlite3_cancel_auto_extension(void (*xInit)(void)){
+SQLITE_API int SQLITE_STDCALL sqlite3_cancel_auto_extension(void (*xInit)(void)){
 #if SQLITE_THREADSAFE
   sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);
 #endif
@@ -101934,7 +103048,7 @@ SQLITE_API int sqlite3_cancel_auto_extension(void (*xInit)(void)){
   int n = 0;
   wsdAutoextInit;
   sqlite3_mutex_enter(mutex);
-  for(i=wsdAutoext.nExt-1; i>=0; i--){
+  for(i=(int)wsdAutoext.nExt-1; i>=0; i--){
     if( wsdAutoext.aExt[i]==xInit ){
       wsdAutoext.nExt--;
       wsdAutoext.aExt[i] = wsdAutoext.aExt[wsdAutoext.nExt];
@@ -101949,7 +103063,7 @@ SQLITE_API int sqlite3_cancel_auto_extension(void (*xInit)(void)){
 /*
 ** Reset the automatic extension loading mechanism.
 */
-SQLITE_API void sqlite3_reset_auto_extension(void){
+SQLITE_API void SQLITE_STDCALL sqlite3_reset_auto_extension(void){
 #ifndef SQLITE_OMIT_AUTOINIT
   if( sqlite3_initialize()==SQLITE_OK )
 #endif
@@ -101972,7 +103086,7 @@ SQLITE_API void sqlite3_reset_auto_extension(void){
 ** If anything goes wrong, set an error in the database connection.
 */
 SQLITE_PRIVATE void sqlite3AutoLoadExtensions(sqlite3 *db){
-  int i;
+  u32 i;
   int go = 1;
   int rc;
   int (*xInit)(sqlite3*,char**,const sqlite3_api_routines*);
@@ -102031,11 +103145,18 @@ SQLITE_PRIVATE void sqlite3AutoLoadExtensions(sqlite3 *db){
 #endif
 
 /***************************************************************************
-** The next block of code, including the PragTyp_XXXX macro definitions and
-** the aPragmaName[] object is composed of generated code. DO NOT EDIT.
-**
-** To add new pragmas, edit the code in ../tool/mkpragmatab.tcl and rerun
-** that script.  Then copy/paste the output in place of the following:
+** The "pragma.h" include file is an automatically generated file that
+** that includes the PragType_XXXX macro definitions and the aPragmaName[]
+** object.  This ensures that the aPragmaName[] table is arranged in
+** lexicographical order to facility a binary search of the pragma name.
+** Do not edit pragma.h directly.  Edit and rerun the script in at 
+** ../tool/mkpragmatab.tcl. */
+/************** Include pragma.h in the middle of pragma.c *******************/
+/************** Begin file pragma.h ******************************************/
+/* DO NOT EDIT!
+** This file is automatically generated by the script at
+** ../tool/mkpragmatab.tcl.  To update the set of pragmas, edit
+** that script and rerun it.
 */
 #define PragTyp_HEADER_VALUE                   0
 #define PragTyp_AUTO_VACUUM                    1
@@ -102270,6 +103391,10 @@ static const struct sPragmaNames {
     /* ePragTyp:  */ PragTyp_INDEX_LIST,
     /* ePragFlag: */ PragFlag_NeedSchema,
     /* iArg:      */ 0 },
+  { /* zName:     */ "index_xinfo",
+    /* ePragTyp:  */ PragTyp_INDEX_INFO,
+    /* ePragFlag: */ PragFlag_NeedSchema,
+    /* iArg:      */ 1 },
 #endif
 #if !defined(SQLITE_OMIT_INTEGRITY_CHECK)
   { /* zName:     */ "integrity_check",
@@ -102486,9 +103611,10 @@ static const struct sPragmaNames {
     /* iArg:      */ SQLITE_WriteSchema|SQLITE_RecoveryMode },
 #endif
 };
-/* Number of pragmas: 58 on by default, 71 total. */
-/* End of the automatically generated pragma table.
-***************************************************************************/
+/* Number of pragmas: 59 on by default, 72 total. */
+
+/************** End of pragma.h **********************************************/
+/************** Continuing where we left off in pragma.c *********************/
 
 /*
 ** Interpret the given string as a safety level.  Return 0 for OFF,
@@ -102624,15 +103750,15 @@ static int changeTempStorage(Parse *pParse, const char *zStorageType){
 */
 static void returnSingleInt(Parse *pParse, const char *zLabel, i64 value){
   Vdbe *v = sqlite3GetVdbe(pParse);
-  int mem = ++pParse->nMem;
+  int nMem = ++pParse->nMem;
   i64 *pI64 = sqlite3DbMallocRaw(pParse->db, sizeof(value));
   if( pI64 ){
     memcpy(pI64, &value, sizeof(value));
   }
-  sqlite3VdbeAddOp4(v, OP_Int64, 0, mem, 0, (char*)pI64, P4_INT64);
+  sqlite3VdbeAddOp4(v, OP_Int64, 0, nMem, 0, (char*)pI64, P4_INT64);
   sqlite3VdbeSetNumCols(v, 1);
   sqlite3VdbeSetColName(v, 0, COLNAME_NAME, zLabel, SQLITE_STATIC);
-  sqlite3VdbeAddOp2(v, OP_ResultRow, mem, 1);
+  sqlite3VdbeAddOp2(v, OP_ResultRow, nMem, 1);
 }
 
 
@@ -102741,6 +103867,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
   sqlite3 *db = pParse->db;    /* The database connection */
   Db *pDb;                     /* The specific database being pragmaed */
   Vdbe *v = sqlite3GetVdbe(pParse);  /* Prepared statement */
+  const struct sPragmaNames *pPragma;
 
   if( v==0 ) return;
   sqlite3VdbeRunOnlyOnce(v);
@@ -102776,6 +103903,17 @@ SQLITE_PRIVATE void sqlite3Pragma(
   /* Send an SQLITE_FCNTL_PRAGMA file-control to the underlying VFS
   ** connection.  If it returns SQLITE_OK, then assume that the VFS
   ** handled the pragma and generate a no-op prepared statement.
+  **
+  ** IMPLEMENTATION-OF: R-12238-55120 Whenever a PRAGMA statement is parsed,
+  ** an SQLITE_FCNTL_PRAGMA file control is sent to the open sqlite3_file
+  ** object corresponding to the database file to which the pragma
+  ** statement refers.
+  **
+  ** IMPLEMENTATION-OF: R-29875-31678 The argument to the SQLITE_FCNTL_PRAGMA
+  ** file control is an array of pointers to strings (char**) in which the
+  ** second element of the array is the name of the pragma and the third
+  ** element is the argument to the pragma or NULL if the pragma has no
+  ** argument.
   */
   aFcntl[0] = 0;
   aFcntl[1] = zLeft;
@@ -102785,11 +103923,11 @@ SQLITE_PRIVATE void sqlite3Pragma(
   rc = sqlite3_file_control(db, zDb, SQLITE_FCNTL_PRAGMA, (void*)aFcntl);
   if( rc==SQLITE_OK ){
     if( aFcntl[0] ){
-      int mem = ++pParse->nMem;
-      sqlite3VdbeAddOp4(v, OP_String8, 0, mem, 0, aFcntl[0], 0);
+      int nMem = ++pParse->nMem;
+      sqlite3VdbeAddOp4(v, OP_String8, 0, nMem, 0, aFcntl[0], 0);
       sqlite3VdbeSetNumCols(v, 1);
       sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "result", SQLITE_STATIC);
-      sqlite3VdbeAddOp2(v, OP_ResultRow, mem, 1);
+      sqlite3VdbeAddOp2(v, OP_ResultRow, nMem, 1);
       sqlite3_free(aFcntl[0]);
     }
     goto pragma_out;
@@ -102818,14 +103956,15 @@ SQLITE_PRIVATE void sqlite3Pragma(
     }
   }
   if( lwr>upr ) goto pragma_out;
+  pPragma = &aPragmaNames[mid];
 
   /* Make sure the database schema is loaded if the pragma requires that */
-  if( (aPragmaNames[mid].mPragFlag & PragFlag_NeedSchema)!=0 ){
+  if( (pPragma->mPragFlag & PragFlag_NeedSchema)!=0 ){
     if( sqlite3ReadSchema(pParse) ) goto pragma_out;
   }
 
   /* Jump to the appropriate pragma handler */
-  switch( aPragmaNames[mid].ePragTyp ){
+  switch( pPragma->ePragTyp ){
   
 #if !defined(SQLITE_OMIT_PAGER_PRAGMAS) && !defined(SQLITE_OMIT_DEPRECATED)
   /*
@@ -103393,7 +104532,9 @@ SQLITE_PRIVATE void sqlite3Pragma(
         sqlite3ErrorMsg(pParse, 
             "Safety level may not be changed inside a transaction");
       }else{
-        pDb->safety_level = getSafetyLevel(zRight,0,1)+1;
+        int iLevel = (getSafetyLevel(zRight,0,1)+1) & PAGER_SYNCHRONOUS_MASK;
+        if( iLevel==0 ) iLevel = 1;
+        pDb->safety_level = iLevel;
         setAllPagerFlags(db);
       }
     }
@@ -103404,10 +104545,9 @@ SQLITE_PRIVATE void sqlite3Pragma(
 #ifndef SQLITE_OMIT_FLAG_PRAGMAS
   case PragTyp_FLAG: {
     if( zRight==0 ){
-      returnSingleInt(pParse, aPragmaNames[mid].zName,
-                     (db->flags & aPragmaNames[mid].iArg)!=0 );
+      returnSingleInt(pParse, pPragma->zName, (db->flags & pPragma->iArg)!=0 );
     }else{
-      int mask = aPragmaNames[mid].iArg;    /* Mask of bits to set or clear. */
+      int mask = pPragma->iArg;    /* Mask of bits to set or clear. */
       if( db->autoCommit==0 ){
         /* Foreign key support may not be enabled or disabled while not
         ** in auto-commit mode.  */
@@ -103489,7 +104629,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
         }else if( pPk==0 ){
           k = 1;
         }else{
-          for(k=1; ALWAYS(k<=pTab->nCol) && pPk->aiColumn[k-1]!=i; k++){}
+          for(k=1; k<=pTab->nCol && pPk->aiColumn[k-1]!=i; k++){}
         }
         sqlite3VdbeAddOp2(v, OP_Integer, k, 6);
         sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 6);
@@ -103536,20 +104676,42 @@ SQLITE_PRIVATE void sqlite3Pragma(
     pIdx = sqlite3FindIndex(db, zRight, zDb);
     if( pIdx ){
       int i;
+      int mx;
+      if( pPragma->iArg ){
+        /* PRAGMA index_xinfo (newer version with more rows and columns) */
+        mx = pIdx->nColumn;
+        pParse->nMem = 6;
+      }else{
+        /* PRAGMA index_info (legacy version) */
+        mx = pIdx->nKeyCol;
+        pParse->nMem = 3;
+      }
       pTab = pIdx->pTable;
-      sqlite3VdbeSetNumCols(v, 3);
-      pParse->nMem = 3;
+      sqlite3VdbeSetNumCols(v, pParse->nMem);
       sqlite3CodeVerifySchema(pParse, iDb);
       sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "seqno", SQLITE_STATIC);
       sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "cid", SQLITE_STATIC);
       sqlite3VdbeSetColName(v, 2, COLNAME_NAME, "name", SQLITE_STATIC);
-      for(i=0; i<pIdx->nKeyCol; i++){
+      if( pPragma->iArg ){
+        sqlite3VdbeSetColName(v, 3, COLNAME_NAME, "desc", SQLITE_STATIC);
+        sqlite3VdbeSetColName(v, 4, COLNAME_NAME, "coll", SQLITE_STATIC);
+        sqlite3VdbeSetColName(v, 5, COLNAME_NAME, "key", SQLITE_STATIC);
+      }
+      for(i=0; i<mx; i++){
         i16 cnum = pIdx->aiColumn[i];
         sqlite3VdbeAddOp2(v, OP_Integer, i, 1);
         sqlite3VdbeAddOp2(v, OP_Integer, cnum, 2);
-        assert( pTab->nCol>cnum );
-        sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, pTab->aCol[cnum].zName, 0);
-        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3);
+        if( cnum<0 ){
+          sqlite3VdbeAddOp2(v, OP_Null, 0, 3);
+        }else{
+          sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, pTab->aCol[cnum].zName, 0);
+        }
+        if( pPragma->iArg ){
+          sqlite3VdbeAddOp2(v, OP_Integer, pIdx->aSortOrder[i], 4);
+          sqlite3VdbeAddOp4(v, OP_String8, 0, 5, 0, pIdx->azColl[i], 0);
+          sqlite3VdbeAddOp2(v, OP_Integer, i<pIdx->nKeyCol, 6);
+        }
+        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, pParse->nMem);
       }
     }
   }
@@ -103562,17 +104724,22 @@ SQLITE_PRIVATE void sqlite3Pragma(
     pTab = sqlite3FindTable(db, zRight, zDb);
     if( pTab ){
       v = sqlite3GetVdbe(pParse);
-      sqlite3VdbeSetNumCols(v, 3);
-      pParse->nMem = 3;
+      sqlite3VdbeSetNumCols(v, 5);
+      pParse->nMem = 5;
       sqlite3CodeVerifySchema(pParse, iDb);
       sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "seq", SQLITE_STATIC);
       sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "name", SQLITE_STATIC);
       sqlite3VdbeSetColName(v, 2, COLNAME_NAME, "unique", SQLITE_STATIC);
+      sqlite3VdbeSetColName(v, 3, COLNAME_NAME, "origin", SQLITE_STATIC);
+      sqlite3VdbeSetColName(v, 4, COLNAME_NAME, "partial", SQLITE_STATIC);
       for(pIdx=pTab->pIndex, i=0; pIdx; pIdx=pIdx->pNext, i++){
+        const char *azOrigin[] = { "c", "u", "pk" };
         sqlite3VdbeAddOp2(v, OP_Integer, i, 1);
         sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, pIdx->zName, 0);
         sqlite3VdbeAddOp2(v, OP_Integer, IsUniqueIndex(pIdx), 3);
-        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3);
+        sqlite3VdbeAddOp4(v, OP_String8, 0, 4, 0, azOrigin[pIdx->idxType], 0);
+        sqlite3VdbeAddOp2(v, OP_Integer, pIdx->pPartIdxWhere!=0, 5);
+        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 5);
       }
     }
   }
@@ -104142,9 +105309,9 @@ SQLITE_PRIVATE void sqlite3Pragma(
   ** applications for any purpose.
   */
   case PragTyp_HEADER_VALUE: {
-    int iCookie = aPragmaNames[mid].iArg;  /* Which cookie to read or write */
+    int iCookie = pPragma->iArg;  /* Which cookie to read or write */
     sqlite3VdbeUsesBtree(v, iDb);
-    if( zRight && (aPragmaNames[mid].mPragFlag & PragFlag_ReadOnly)==0 ){
+    if( zRight && (pPragma->mPragFlag & PragFlag_ReadOnly)==0 ){
       /* Write the specified cookie value */
       static const VdbeOpList setCookie[] = {
         { OP_Transaction,    0,  1,  0},    /* 0 */
@@ -104246,8 +105413,9 @@ SQLITE_PRIVATE void sqlite3Pragma(
   /*
   **  PRAGMA shrink_memory
   **
-  ** This pragma attempts to free as much memory as possible from the
-  ** current database connection.
+  ** IMPLEMENTATION-OF: R-23445-46109 This pragma causes the database
+  ** connection on which it is invoked to free up as much memory as it
+  ** can, by calling sqlite3_db_release_memory().
   */
   case PragTyp_SHRINK_MEMORY: {
     sqlite3_db_release_memory(db);
@@ -104264,7 +105432,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
   ** disables the timeout.
   */
   /*case PragTyp_BUSY_TIMEOUT*/ default: {
-    assert( aPragmaNames[mid].ePragTyp==PragTyp_BUSY_TIMEOUT );
+    assert( pPragma->ePragTyp==PragTyp_BUSY_TIMEOUT );
     if( zRight ){
       sqlite3_busy_timeout(db, sqlite3Atoi(zRight));
     }
@@ -104276,8 +105444,12 @@ SQLITE_PRIVATE void sqlite3Pragma(
   **   PRAGMA soft_heap_limit
   **   PRAGMA soft_heap_limit = N
   **
-  ** Call sqlite3_soft_heap_limit64(N).  Return the result.  If N is omitted,
-  ** use -1.
+  ** IMPLEMENTATION-OF: R-26343-45930 This pragma invokes the
+  ** sqlite3_soft_heap_limit64() interface with the argument N, if N is
+  ** specified and is a non-negative integer.
+  ** IMPLEMENTATION-OF: R-64451-07163 The soft_heap_limit pragma always
+  ** returns the same integer that would be returned by the
+  ** sqlite3_soft_heap_limit64(-1) C-language function.
   */
   case PragTyp_SOFT_HEAP_LIMIT: {
     sqlite3_int64 N;
@@ -104463,7 +105635,7 @@ SQLITE_PRIVATE int sqlite3InitCallback(void *pInit, int argc, char **argv, char
   if( argv==0 ) return 0;   /* Might happen if EMPTY_RESULT_CALLBACKS are on */
   if( argv[1]==0 ){
     corruptSchema(pData, argv[0], 0);
-  }else if( argv[2] && argv[2][0] ){
+  }else if( sqlite3_strnicmp(argv[2],"create ",7)==0 ){
     /* Call the parser to process a CREATE TABLE, INDEX or VIEW.
     ** But because db->init.busy is set to 1, no VDBE code is generated
     ** or executed.  All the parser does is build the internal data
@@ -104494,8 +105666,8 @@ SQLITE_PRIVATE int sqlite3InitCallback(void *pInit, int argc, char **argv, char
       }
     }
     sqlite3_finalize(pStmt);
-  }else if( argv[0]==0 ){
-    corruptSchema(pData, 0, 0);
+  }else if( argv[0]==0 || (argv[2]!=0 && argv[2][0]!=0) ){
+    corruptSchema(pData, argv[0], 0);
   }else{
     /* If the SQL column is blank it means this is an index that
     ** was created to be the PRIMARY KEY or to fulfill a UNIQUE
@@ -105173,7 +106345,7 @@ SQLITE_PRIVATE int sqlite3Reprepare(Vdbe *p){
 ** and the statement is automatically recompiled if an schema change
 ** occurs.
 */
-SQLITE_API int sqlite3_prepare(
+SQLITE_API int SQLITE_STDCALL sqlite3_prepare(
   sqlite3 *db,              /* Database handle. */
   const char *zSql,         /* UTF-8 encoded SQL statement. */
   int nBytes,               /* Length of zSql in bytes. */
@@ -105185,7 +106357,7 @@ SQLITE_API int sqlite3_prepare(
   assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */
   return rc;
 }
-SQLITE_API int sqlite3_prepare_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_prepare_v2(
   sqlite3 *db,              /* Database handle. */
   const char *zSql,         /* UTF-8 encoded SQL statement. */
   int nBytes,               /* Length of zSql in bytes. */
@@ -105261,7 +106433,7 @@ static int sqlite3Prepare16(
 ** and the statement is automatically recompiled if an schema change
 ** occurs.
 */
-SQLITE_API int sqlite3_prepare16(
+SQLITE_API int SQLITE_STDCALL sqlite3_prepare16(
   sqlite3 *db,              /* Database handle. */ 
   const void *zSql,         /* UTF-16 encoded SQL statement. */
   int nBytes,               /* Length of zSql in bytes. */
@@ -105273,7 +106445,7 @@ SQLITE_API int sqlite3_prepare16(
   assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */
   return rc;
 }
-SQLITE_API int sqlite3_prepare16_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_prepare16_v2(
   sqlite3 *db,              /* Database handle. */ 
   const void *zSql,         /* UTF-16 encoded SQL statement. */
   int nBytes,               /* Length of zSql in bytes. */
@@ -105402,7 +106574,6 @@ SQLITE_PRIVATE Select *sqlite3SelectNew(
   Select standin;
   sqlite3 *db = pParse->db;
   pNew = sqlite3DbMallocZero(db, sizeof(*pNew) );
-  assert( db->mallocFailed || !pOffset || pLimit ); /* OFFSET implies LIMIT */
   if( pNew==0 ){
     assert( db->mallocFailed );
     pNew = &standin;
@@ -105422,7 +106593,7 @@ SQLITE_PRIVATE Select *sqlite3SelectNew(
   pNew->op = TK_SELECT;
   pNew->pLimit = pLimit;
   pNew->pOffset = pOffset;
-  assert( pOffset==0 || pLimit!=0 );
+  assert( pOffset==0 || pLimit!=0 || pParse->nErr>0 || db->mallocFailed!=0 );
   pNew->addrOpenEphm[0] = -1;
   pNew->addrOpenEphm[1] = -1;
   if( db->mallocFailed ) {
@@ -105854,20 +107025,17 @@ static void pushOntoSorter(
   }
   sqlite3VdbeAddOp2(v, op, pSort->iECursor, regRecord);
   if( pSelect->iLimit ){
-    int addr1, addr2;
+    int addr;
     int iLimit;
     if( pSelect->iOffset ){
       iLimit = pSelect->iOffset+1;
     }else{
       iLimit = pSelect->iLimit;
     }
-    addr1 = sqlite3VdbeAddOp1(v, OP_IfZero, iLimit); VdbeCoverage(v);
-    sqlite3VdbeAddOp2(v, OP_AddImm, iLimit, -1);
-    addr2 = sqlite3VdbeAddOp0(v, OP_Goto);
-    sqlite3VdbeJumpHere(v, addr1);
+    addr = sqlite3VdbeAddOp3(v, OP_IfNotZero, iLimit, 0, -1); VdbeCoverage(v);
     sqlite3VdbeAddOp1(v, OP_Last, pSort->iECursor);
     sqlite3VdbeAddOp1(v, OP_Delete, pSort->iECursor);
-    sqlite3VdbeJumpHere(v, addr2);
+    sqlite3VdbeJumpHere(v, addr);
   }
 }
 
@@ -106264,7 +107432,7 @@ static void selectInnerLoop(
   ** the output for us.
   */
   if( pSort==0 && p->iLimit ){
-    sqlite3VdbeAddOp3(v, OP_IfZero, p->iLimit, iBreak, -1); VdbeCoverage(v);
+    sqlite3VdbeAddOp2(v, OP_DecrJumpZero, p->iLimit, iBreak); VdbeCoverage(v);
   }
 }
 
@@ -106675,7 +107843,7 @@ static const char *columnTypeImpl(
         ** of the SELECT statement. Return the declaration type and origin
         ** data for the result-set column of the sub-select.
         */
-        if( iCol>=0 && ALWAYS(iCol<pS->pEList->nExpr) ){
+        if( iCol>=0 && iCol<pS->pEList->nExpr ){
           /* If iCol is less than zero, then the expression requests the
           ** rowid of the sub-select or view. This expression is legal (see 
           ** test case misc2.2.2) - it always evaluates to NULL.
@@ -106995,12 +108163,14 @@ static void selectAddColumnTypeAndCollation(
   a = pSelect->pEList->a;
   for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){
     p = a[i].pExpr;
-    pCol->zType = sqlite3DbStrDup(db, columnType(&sNC, p,0,0,0, &pCol->szEst));
+    if( pCol->zType==0 ){
+      pCol->zType = sqlite3DbStrDup(db, columnType(&sNC, p,0,0,0, &pCol->szEst));
+    }
     szAll += pCol->szEst;
     pCol->affinity = sqlite3ExprAffinity(p);
     if( pCol->affinity==0 ) pCol->affinity = SQLITE_AFF_NONE;
     pColl = sqlite3ExprCollSeq(pParse, p);
-    if( pColl ){
+    if( pColl && pCol->zColl==0 ){
       pCol->zColl = sqlite3DbStrDup(db, pColl->zName);
     }
   }
@@ -107117,7 +108287,7 @@ static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){
       sqlite3ExprCode(pParse, p->pLimit, iLimit);
       sqlite3VdbeAddOp1(v, OP_MustBeInt, iLimit); VdbeCoverage(v);
       VdbeComment((v, "LIMIT counter"));
-      sqlite3VdbeAddOp2(v, OP_IfZero, iLimit, iBreak); VdbeCoverage(v);
+      sqlite3VdbeAddOp2(v, OP_IfNot, iLimit, iBreak); VdbeCoverage(v);
     }
     if( p->pOffset ){
       p->iOffset = iOffset = ++pParse->nMem;
@@ -107336,7 +108506,7 @@ static void generateWithRecursiveQuery(
   selectInnerLoop(pParse, p, p->pEList, iCurrent,
       0, 0, pDest, addrCont, addrBreak);
   if( regLimit ){
-    sqlite3VdbeAddOp3(v, OP_IfZero, regLimit, addrBreak, -1);
+    sqlite3VdbeAddOp2(v, OP_DecrJumpZero, regLimit, addrBreak);
     VdbeCoverage(v);
   }
   sqlite3VdbeResolveLabel(v, addrCont);
@@ -107402,8 +108572,7 @@ static int multiSelectValues(
   int nExpr = p->pEList->nExpr;
   int nRow = 1;
   int rc = 0;
-  assert( p->pNext==0 );
-  assert( p->selFlags & SF_AllValues );
+  assert( p->selFlags & SF_MultiValue );
   do{
     assert( p->selFlags & SF_Values );
     assert( p->op==TK_ALL || (p->op==TK_SELECT && p->pPrior==0) );
@@ -107512,7 +108681,7 @@ static int multiSelect(
 
   /* Special handling for a compound-select that originates as a VALUES clause.
   */
-  if( p->selFlags & SF_AllValues ){
+  if( p->selFlags & SF_MultiValue ){
     rc = multiSelectValues(pParse, p, &dest);
     goto multi_select_end;
   }
@@ -107561,7 +108730,7 @@ static int multiSelect(
       p->iLimit = pPrior->iLimit;
       p->iOffset = pPrior->iOffset;
       if( p->iLimit ){
-        addr = sqlite3VdbeAddOp1(v, OP_IfZero, p->iLimit); VdbeCoverage(v);
+        addr = sqlite3VdbeAddOp1(v, OP_IfNot, p->iLimit); VdbeCoverage(v);
         VdbeComment((v, "Jump ahead if LIMIT reached"));
       }
       explainSetInteger(iSub2, pParse->iNextSelectId);
@@ -107897,7 +109066,7 @@ static int generateOutputSubroutine(
     */
     case SRT_Set: {
       int r1;
-      assert( pIn->nSdst==1 );
+      assert( pIn->nSdst==1 || pParse->nErr>0 );
       pDest->affSdst = 
          sqlite3CompareAffinity(p->pEList->a[0].pExpr, pDest->affSdst);
       r1 = sqlite3GetTempReg(pParse);
@@ -107923,7 +109092,7 @@ static int generateOutputSubroutine(
     ** of the scan loop.
     */
     case SRT_Mem: {
-      assert( pIn->nSdst==1 );
+      assert( pIn->nSdst==1 || pParse->nErr>0 );  testcase( pIn->nSdst!=1 );
       sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSDParm, 1);
       /* The LIMIT clause will jump out of the loop for us */
       break;
@@ -107938,7 +109107,7 @@ static int generateOutputSubroutine(
         pDest->iSdst = sqlite3GetTempRange(pParse, pIn->nSdst);
         pDest->nSdst = pIn->nSdst;
       }
-      sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSdst, pDest->nSdst);
+      sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSdst, pIn->nSdst);
       sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);
       break;
     }
@@ -107962,7 +109131,7 @@ static int generateOutputSubroutine(
   /* Jump to the end of the loop if the LIMIT is reached.
   */
   if( p->iLimit ){
-    sqlite3VdbeAddOp3(v, OP_IfZero, p->iLimit, iBreak, -1); VdbeCoverage(v);
+    sqlite3VdbeAddOp2(v, OP_DecrJumpZero, p->iLimit, iBreak); VdbeCoverage(v);
   }
 
   /* Generate the subroutine return
@@ -108154,8 +109323,10 @@ static int multiSelectOrderBy(
   if( aPermute ){
     struct ExprList_item *pItem;
     for(i=0, pItem=pOrderBy->a; i<nOrderBy; i++, pItem++){
-      assert( pItem->u.x.iOrderByCol>0
-          && pItem->u.x.iOrderByCol<=p->pEList->nExpr );
+      assert( pItem->u.x.iOrderByCol>0 );
+      /* assert( pItem->u.x.iOrderByCol<=p->pEList->nExpr ) is also true
+      ** but only for well-formed SELECT statements. */
+      testcase( pItem->u.x.iOrderByCol > p->pEList->nExpr );
       aPermute[i] = pItem->u.x.iOrderByCol - 1;
     }
     pKeyMerge = multiSelectOrderByKeyInfo(pParse, p, 1);
@@ -108365,7 +109536,7 @@ static int multiSelectOrderBy(
   /*** TBD:  Insert subroutine calls to close cursors on incomplete
   **** subqueries ****/
   explainComposite(pParse, p->op, iSub1, iSub2, 0);
-  return SQLITE_OK;
+  return pParse->nErr!=0;
 }
 #endif
 
@@ -108485,7 +109656,10 @@ static void substSelect(
 **
 **   (1)  The subquery and the outer query do not both use aggregates.
 **
-**   (2)  The subquery is not an aggregate or the outer query is not a join.
+**   (2)  The subquery is not an aggregate or (2a) the outer query is not a join
+**        and (2b) the outer query does not use subqueries other than the one
+**        FROM-clause subquery that is a candidate for flattening.  (2b is
+**        due to ticket [2f7170d73bf9abf80] from 2015-02-09.)
 **
 **   (3)  The subquery is not the right operand of a left outer join
 **        (Originally ticket #306.  Strengthened by ticket #3300)
@@ -108622,8 +109796,17 @@ static int flattenSubquery(
   iParent = pSubitem->iCursor;
   pSub = pSubitem->pSelect;
   assert( pSub!=0 );
-  if( isAgg && subqueryIsAgg ) return 0;                 /* Restriction (1)  */
-  if( subqueryIsAgg && pSrc->nSrc>1 ) return 0;          /* Restriction (2)  */
+  if( subqueryIsAgg ){
+    if( isAgg ) return 0;                                /* Restriction (1)   */
+    if( pSrc->nSrc>1 ) return 0;                         /* Restriction (2a)  */
+    if( (p->pWhere && ExprHasProperty(p->pWhere,EP_Subquery))
+     || (sqlite3ExprListFlags(p->pEList) & EP_Subquery)!=0
+     || (sqlite3ExprListFlags(p->pOrderBy) & EP_Subquery)!=0
+    ){
+      return 0;                                          /* Restriction (2b)  */
+    }
+  }
+    
   pSubSrc = pSub->pSrc;
   assert( pSubSrc );
   /* Prior to version 3.1.2, when LIMIT and OFFSET had to be simple constants,
@@ -109165,7 +110348,10 @@ static int convertCompoundSelectToSubquery(Walker *pWalker, Select *p){
   pNew->pOrderBy = 0;
   p->pPrior = 0;
   p->pNext = 0;
+  p->pWith = 0;
   p->selFlags &= ~SF_Compound;
+  assert( (p->selFlags & SF_Converted)==0 );
+  p->selFlags |= SF_Converted;
   assert( pNew->pPrior!=0 );
   pNew->pPrior->pNext = pNew;
   pNew->pLimit = 0;
@@ -109317,7 +110503,7 @@ static int withExpand(
     for(pLeft=pSel; pLeft->pPrior; pLeft=pLeft->pPrior);
     pEList = pLeft->pEList;
     if( pCte->pCols ){
-      if( pEList->nExpr!=pCte->pCols->nExpr ){
+      if( pEList && pEList->nExpr!=pCte->pCols->nExpr ){
         sqlite3ErrorMsg(pParse, "table %s has %d values for %d columns",
             pCte->zName, pEList->nExpr, pCte->pCols->nExpr
         );
@@ -109444,7 +110630,7 @@ static int selectExpander(Walker *pWalker, Select *p){
       /* A sub-query in the FROM clause of a SELECT */
       assert( pSel!=0 );
       assert( pFrom->pTab==0 );
-      sqlite3WalkSelect(pWalker, pSel);
+      if( sqlite3WalkSelect(pWalker, pSel) ) return WRC_Abort;
       pFrom->pTab = pTab = sqlite3DbMallocZero(db, sizeof(Table));
       if( pTab==0 ) return WRC_Abort;
       pTab->nRef = 1;
@@ -109701,7 +110887,7 @@ static void sqlite3SelectExpand(Parse *pParse, Select *pSelect){
     sqlite3WalkSelect(&w, pSelect);
   }
   w.xSelectCallback = selectExpander;
-  if( (pSelect->selFlags & SF_AllValues)==0 ){
+  if( (pSelect->selFlags & SF_MultiValue)==0 ){
     w.xSelectCallback2 = selectPopWith;
   }
   sqlite3WalkSelect(&w, pSelect);
@@ -109887,7 +111073,8 @@ static void updateAccumulator(Parse *pParse, AggInfo *pAggInfo){
     }
     if( pF->iDistinct>=0 ){
       addrNext = sqlite3VdbeMakeLabel(v);
-      assert( nArg==1 );
+      testcase( nArg==0 );  /* Error condition */
+      testcase( nArg>1 );   /* Also an error */
       codeDistinct(pParse, pF->iDistinct, addrNext, 1, regAgg);
     }
     if( pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL ){
@@ -110043,6 +111230,13 @@ SQLITE_PRIVATE int sqlite3Select(
   }
   isAgg = (p->selFlags & SF_Aggregate)!=0;
   assert( pEList!=0 );
+#if SELECTTRACE_ENABLED
+  if( sqlite3SelectTrace & 0x100 ){
+    SELECTTRACE(0x100,pParse,p, ("after name resolution:\n"));
+    sqlite3TreeViewSelect(0, p, 0);
+  }
+#endif
+
 
   /* Begin generating code.
   */
@@ -110755,10 +111949,9 @@ SQLITE_PRIVATE int sqlite3Select(
   */
   sqlite3VdbeResolveLabel(v, iEnd);
 
-  /* The SELECT was successfully coded.   Set the return code to 0
-  ** to indicate no errors.
-  */
-  rc = 0;
+  /* The SELECT has been coded. If there is an error in the Parse structure,
+  ** set the return code to 1. Otherwise 0. */
+  rc = (pParse->nErr>0);
 
   /* Control jumps to here if an error is encountered above, or upon
   ** successful coding of the SELECT.
@@ -110788,9 +111981,9 @@ SQLITE_PRIVATE int sqlite3Select(
 SQLITE_PRIVATE void sqlite3TreeViewSelect(TreeView *pView, const Select *p, u8 moreToFollow){
   int n = 0;
   pView = sqlite3TreeViewPush(pView, moreToFollow);
-  sqlite3TreeViewLine(pView, "SELECT%s%s",
+  sqlite3TreeViewLine(pView, "SELECT%s%s (0x%p)",
     ((p->selFlags & SF_Distinct) ? " DISTINCT" : ""),
-    ((p->selFlags & SF_Aggregate) ? " agg_flag" : "")
+    ((p->selFlags & SF_Aggregate) ? " agg_flag" : ""), p
   );
   if( p->pSrc && p->pSrc->nSrc ) n++;
   if( p->pWhere ) n++;
@@ -110809,7 +112002,7 @@ SQLITE_PRIVATE void sqlite3TreeViewSelect(TreeView *pView, const Select *p, u8 m
       struct SrcList_item *pItem = &p->pSrc->a[i];
       StrAccum x;
       char zLine[100];
-      sqlite3StrAccumInit(&x, zLine, sizeof(zLine), 0);
+      sqlite3StrAccumInit(&x, 0, zLine, sizeof(zLine), 0);
       sqlite3XPrintf(&x, 0, "{%d,*}", pItem->iCursor);
       if( pItem->zDatabase ){
         sqlite3XPrintf(&x, 0, " %s.%s", pItem->zDatabase, pItem->zName);
@@ -110968,7 +112161,7 @@ static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){
         z = 0;
       }else{
         int n = sqlite3Strlen30(argv[i])+1;
-        z = sqlite3_malloc( n );
+        z = sqlite3_malloc64( n );
         if( z==0 ) goto malloc_failed;
         memcpy(z, argv[i], n);
       }
@@ -110993,7 +112186,7 @@ static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){
 ** Instead, the entire table should be passed to sqlite3_free_table() when
 ** the calling procedure is finished using it.
 */
-SQLITE_API int sqlite3_get_table(
+SQLITE_API int SQLITE_STDCALL sqlite3_get_table(
   sqlite3 *db,                /* The database on which the SQL executes */
   const char *zSql,           /* The SQL to be executed */
   char ***pazResult,          /* Write the result table here */
@@ -111017,7 +112210,7 @@ SQLITE_API int sqlite3_get_table(
   res.nData = 1;
   res.nAlloc = 20;
   res.rc = SQLITE_OK;
-  res.azResult = sqlite3_malloc(sizeof(char*)*res.nAlloc );
+  res.azResult = sqlite3_malloc64(sizeof(char*)*res.nAlloc );
   if( res.azResult==0 ){
      db->errCode = SQLITE_NOMEM;
      return SQLITE_NOMEM;
@@ -111045,7 +112238,7 @@ SQLITE_API int sqlite3_get_table(
   }
   if( res.nAlloc>res.nData ){
     char **azNew;
-    azNew = sqlite3_realloc( res.azResult, sizeof(char*)*res.nData );
+    azNew = sqlite3_realloc64( res.azResult, sizeof(char*)*res.nData );
     if( azNew==0 ){
       sqlite3_free_table(&res.azResult[1]);
       db->errCode = SQLITE_NOMEM;
@@ -111062,7 +112255,7 @@ SQLITE_API int sqlite3_get_table(
 /*
 ** This routine frees the space the sqlite3_get_table() malloced.
 */
-SQLITE_API void sqlite3_free_table(
+SQLITE_API void SQLITE_STDCALL sqlite3_free_table(
   char **azResult            /* Result returned from sqlite3_get_table() */
 ){
   if( azResult ){
@@ -111273,7 +112466,6 @@ SQLITE_PRIVATE void sqlite3BeginTrigger(
   /* Do not create a trigger on a system table */
   if( sqlite3StrNICmp(pTab->zName, "sqlite_", 7)==0 ){
     sqlite3ErrorMsg(pParse, "cannot create trigger on system table");
-    pParse->nErr++;
     goto trigger_cleanup;
   }
 
@@ -111453,12 +112645,12 @@ static TriggerStep *triggerStepAllocate(
 ){
   TriggerStep *pTriggerStep;
 
-  pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep) + pName->n);
+  pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep) + pName->n + 1);
   if( pTriggerStep ){
     char *z = (char*)&pTriggerStep[1];
     memcpy(z, pName->z, pName->n);
-    pTriggerStep->target.z = z;
-    pTriggerStep->target.n = pName->n;
+    sqlite3Dequote(z);
+    pTriggerStep->zTarget = z;
     pTriggerStep->op = op;
   }
   return pTriggerStep;
@@ -111741,7 +112933,7 @@ SQLITE_PRIVATE Trigger *sqlite3TriggersExist(
 }
 
 /*
-** Convert the pStep->target token into a SrcList and return a pointer
+** Convert the pStep->zTarget string into a SrcList and return a pointer
 ** to that SrcList.
 **
 ** This routine adds a specific database name, if needed, to the target when
@@ -111754,17 +112946,17 @@ static SrcList *targetSrcList(
   Parse *pParse,       /* The parsing context */
   TriggerStep *pStep   /* The trigger containing the target token */
 ){
+  sqlite3 *db = pParse->db;
   int iDb;             /* Index of the database to use */
   SrcList *pSrc;       /* SrcList to be returned */
 
-  pSrc = sqlite3SrcListAppend(pParse->db, 0, &pStep->target, 0);
+  pSrc = sqlite3SrcListAppend(db, 0, 0, 0);
   if( pSrc ){
     assert( pSrc->nSrc>0 );
-    assert( pSrc->a!=0 );
-    iDb = sqlite3SchemaToIndex(pParse->db, pStep->pTrig->pSchema);
+    pSrc->a[pSrc->nSrc-1].zName = sqlite3DbStrDup(db, pStep->zTarget);
+    iDb = sqlite3SchemaToIndex(db, pStep->pTrig->pSchema);
     if( iDb==0 || iDb>=2 ){
-      sqlite3 *db = pParse->db;
-      assert( iDb<pParse->db->nDb );
+      assert( iDb<db->nDb );
       pSrc->a[pSrc->nSrc-1].zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zName);
     }
   }
@@ -111876,6 +113068,7 @@ static void transferParseError(Parse *pTo, Parse *pFrom){
   if( pTo->nErr==0 ){
     pTo->zErrMsg = pFrom->zErrMsg;
     pTo->nErr = pFrom->nErr;
+    pTo->rc = pFrom->rc;
   }else{
     sqlite3DbFree(pFrom->db, pFrom->zErrMsg);
   }
@@ -113160,7 +114353,7 @@ SQLITE_PRIVATE int sqlite3RunVacuum(char **pzErrMsg, sqlite3 *db){
   ** cause problems for the call to BtreeSetPageSize() below.  */
   sqlite3BtreeCommit(pTemp);
 
-  nRes = sqlite3BtreeGetReserve(pMain);
+  nRes = sqlite3BtreeGetOptimalReserve(pMain);
 
   /* A VACUUM cannot change the pagesize of an encrypted database. */
 #ifdef SQLITE_HAS_CODEC
@@ -113226,6 +114419,8 @@ SQLITE_PRIVATE int sqlite3RunVacuum(char **pzErrMsg, sqlite3 *db){
   ** an "INSERT INTO vacuum_db.xxx SELECT * FROM main.xxx;" to copy
   ** the contents to the temporary database.
   */
+  assert( (db->flags & SQLITE_Vacuum)==0 );
+  db->flags |= SQLITE_Vacuum;
   rc = execExecSql(db, pzErrMsg,
       "SELECT 'INSERT INTO vacuum_db.' || quote(name) "
       "|| ' SELECT * FROM main.' || quote(name) || ';'"
@@ -113233,6 +114428,8 @@ SQLITE_PRIVATE int sqlite3RunVacuum(char **pzErrMsg, sqlite3 *db){
       "WHERE type = 'table' AND name!='sqlite_sequence' "
       "  AND coalesce(rootpage,1)>0"
   );
+  assert( (db->flags & SQLITE_Vacuum)!=0 );
+  db->flags &= ~SQLITE_Vacuum;
   if( rc!=SQLITE_OK ) goto end_of_vacuum;
 
   /* Copy over the sequence table
@@ -113371,6 +114568,8 @@ SQLITE_PRIVATE int sqlite3RunVacuum(char **pzErrMsg, sqlite3 *db){
 struct VtabCtx {
   VTable *pVTable;    /* The virtual table being constructed */
   Table *pTab;        /* The Table object to which the virtual table belongs */
+  VtabCtx *pPrior;    /* Parent context (if any) */
+  int bDeclared;      /* True after sqlite3_declare_vtab() is called */
 };
 
 /*
@@ -113422,7 +114621,7 @@ static int createModule(
 /*
 ** External API function used to create a new virtual-table module.
 */
-SQLITE_API int sqlite3_create_module(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_module(
   sqlite3 *db,                    /* Database in which module is registered */
   const char *zName,              /* Name assigned to this module */
   const sqlite3_module *pModule,  /* The definition of the module */
@@ -113437,7 +114636,7 @@ SQLITE_API int sqlite3_create_module(
 /*
 ** External API function used to create a new virtual-table module.
 */
-SQLITE_API int sqlite3_create_module_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_module_v2(
   sqlite3 *db,                    /* Database in which module is registered */
   const char *zName,              /* Name assigned to this module */
   const sqlite3_module *pModule,  /* The definition of the module */
@@ -113736,6 +114935,7 @@ SQLITE_PRIVATE void sqlite3VtabFinishParse(Parse *pParse, Token *pEnd){
     char *zStmt;
     char *zWhere;
     int iDb;
+    int iReg;
     Vdbe *v;
 
     /* Compute the complete text of the CREATE VIRTUAL TABLE statement */
@@ -113770,8 +114970,10 @@ SQLITE_PRIVATE void sqlite3VtabFinishParse(Parse *pParse, Token *pEnd){
     sqlite3VdbeAddOp2(v, OP_Expire, 0, 0);
     zWhere = sqlite3MPrintf(db, "name='%q' AND type='table'", pTab->zName);
     sqlite3VdbeAddParseSchemaOp(v, iDb, zWhere);
-    sqlite3VdbeAddOp4(v, OP_VCreate, iDb, 0, 0, 
-                         pTab->zName, sqlite3Strlen30(pTab->zName) + 1);
+
+    iReg = ++pParse->nMem;
+    sqlite3VdbeAddOp4(v, OP_String8, 0, iReg, 0, pTab->zName, 0);
+    sqlite3VdbeAddOp2(v, OP_VCreate, iDb, iReg);
   }
 
   /* If we are rereading the sqlite_master table create the in-memory
@@ -113814,7 +115016,7 @@ SQLITE_PRIVATE void sqlite3VtabArgExtend(Parse *pParse, Token *p){
     pArg->z = p->z;
     pArg->n = p->n;
   }else{
-    assert(pArg->z < p->z);
+    assert(pArg->z <= p->z);
     pArg->n = (int)(&p->z[p->n] - pArg->z);
   }
 }
@@ -113831,15 +115033,27 @@ static int vtabCallConstructor(
   int (*xConstruct)(sqlite3*,void*,int,const char*const*,sqlite3_vtab**,char**),
   char **pzErr
 ){
-  VtabCtx sCtx, *pPriorCtx;
+  VtabCtx sCtx;
   VTable *pVTable;
   int rc;
   const char *const*azArg = (const char *const*)pTab->azModuleArg;
   int nArg = pTab->nModuleArg;
   char *zErr = 0;
-  char *zModuleName = sqlite3MPrintf(db, "%s", pTab->zName);
+  char *zModuleName;
   int iDb;
+  VtabCtx *pCtx;
+
+  /* Check that the virtual-table is not already being initialized */
+  for(pCtx=db->pVtabCtx; pCtx; pCtx=pCtx->pPrior){
+    if( pCtx->pTab==pTab ){
+      *pzErr = sqlite3MPrintf(db, 
+          "vtable constructor called recursively: %s", pTab->zName
+      );
+      return SQLITE_LOCKED;
+    }
+  }
 
+  zModuleName = sqlite3MPrintf(db, "%s", pTab->zName);
   if( !zModuleName ){
     return SQLITE_NOMEM;
   }
@@ -113860,11 +115074,13 @@ static int vtabCallConstructor(
   assert( xConstruct );
   sCtx.pTab = pTab;
   sCtx.pVTable = pVTable;
-  pPriorCtx = db->pVtabCtx;
+  sCtx.pPrior = db->pVtabCtx;
+  sCtx.bDeclared = 0;
   db->pVtabCtx = &sCtx;
   rc = xConstruct(db, pMod->pAux, nArg, azArg, &pVTable->pVtab, &zErr);
-  db->pVtabCtx = pPriorCtx;
+  db->pVtabCtx = sCtx.pPrior;
   if( rc==SQLITE_NOMEM ) db->mallocFailed = 1;
+  assert( sCtx.pTab==pTab );
 
   if( SQLITE_OK!=rc ){
     if( zErr==0 ){
@@ -113880,13 +115096,14 @@ static int vtabCallConstructor(
     memset(pVTable->pVtab, 0, sizeof(pVTable->pVtab[0]));
     pVTable->pVtab->pModule = pMod->pModule;
     pVTable->nRef = 1;
-    if( sCtx.pTab ){
+    if( sCtx.bDeclared==0 ){
       const char *zFormat = "vtable constructor did not declare schema: %s";
       *pzErr = sqlite3MPrintf(db, zFormat, pTab->zName);
       sqlite3VtabUnlock(pVTable);
       rc = SQLITE_ERROR;
     }else{
       int iCol;
+      u8 oooHidden = 0;
       /* If everything went according to plan, link the new VTable structure
       ** into the linked list headed by pTab->pVTable. Then loop through the 
       ** columns of the table to see if any of them contain the token "hidden".
@@ -113899,7 +115116,10 @@ static int vtabCallConstructor(
         char *zType = pTab->aCol[iCol].zType;
         int nType;
         int i = 0;
-        if( !zType ) continue;
+        if( !zType ){
+          pTab->tabFlags |= oooHidden;
+          continue;
+        }
         nType = sqlite3Strlen30(zType);
         if( sqlite3StrNICmp("hidden", zType, 6)||(zType[6] && zType[6]!=' ') ){
           for(i=0; i<nType; i++){
@@ -113922,6 +115142,9 @@ static int vtabCallConstructor(
             zType[i-1] = '\0';
           }
           pTab->aCol[iCol].colFlags |= COLFLAG_HIDDEN;
+          oooHidden = TF_OOOHidden;
+        }else{
+          pTab->tabFlags |= oooHidden;
         }
       }
     }
@@ -114049,22 +115272,26 @@ SQLITE_PRIVATE int sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab,
 ** valid to call this function from within the xCreate() or xConnect() of a
 ** virtual table module.
 */
-SQLITE_API int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){
+SQLITE_API int SQLITE_STDCALL sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){
+  VtabCtx *pCtx;
   Parse *pParse;
-
   int rc = SQLITE_OK;
   Table *pTab;
   char *zErr = 0;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
-  if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
+  if( !sqlite3SafetyCheckOk(db) || zCreateTable==0 ){
+    return SQLITE_MISUSE_BKPT;
+  }
 #endif
   sqlite3_mutex_enter(db->mutex);
-  if( !db->pVtabCtx || !(pTab = db->pVtabCtx->pTab) ){
+  pCtx = db->pVtabCtx;
+  if( !pCtx || pCtx->bDeclared ){
     sqlite3Error(db, SQLITE_MISUSE);
     sqlite3_mutex_leave(db->mutex);
     return SQLITE_MISUSE_BKPT;
   }
+  pTab = pCtx->pTab;
   assert( (pTab->tabFlags & TF_Virtual)!=0 );
 
   pParse = sqlite3StackAllocZero(db, sizeof(*pParse));
@@ -114087,7 +115314,7 @@ SQLITE_API int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){
         pParse->pNewTable->nCol = 0;
         pParse->pNewTable->aCol = 0;
       }
-      db->pVtabCtx->pTab = 0;
+      pCtx->bDeclared = 1;
     }else{
       sqlite3ErrorWithMsg(db, SQLITE_ERROR, (zErr ? "%s" : 0), zErr);
       sqlite3DbFree(db, zErr);
@@ -114122,11 +115349,15 @@ SQLITE_PRIVATE int sqlite3VtabCallDestroy(sqlite3 *db, int iDb, const char *zTab
 
   pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zName);
   if( ALWAYS(pTab!=0 && pTab->pVTable!=0) ){
-    VTable *p = vtabDisconnectAll(db, pTab);
-
-    assert( rc==SQLITE_OK );
+    VTable *p;
+    for(p=pTab->pVTable; p; p=p->pNext){
+      assert( p->pVtab );
+      if( p->pVtab->nRef>0 ){
+        return SQLITE_LOCKED;
+      }
+    }
+    p = vtabDisconnectAll(db, pTab);
     rc = p->pMod->pModule->xDestroy(p->pVtab);
-
     /* Remove the sqlite3_vtab* from the aVTrans[] array, if applicable */
     if( rc==SQLITE_OK ){
       assert( pTab->pVTable==p && p->pNext==0 );
@@ -114277,7 +115508,7 @@ SQLITE_PRIVATE int sqlite3VtabSavepoint(sqlite3 *db, int op, int iSavepoint){
   int rc = SQLITE_OK;
 
   assert( op==SAVEPOINT_RELEASE||op==SAVEPOINT_ROLLBACK||op==SAVEPOINT_BEGIN );
-  assert( iSavepoint>=0 );
+  assert( iSavepoint>=-1 );
   if( db->aVTrans ){
     int i;
     for(i=0; rc==SQLITE_OK && i<db->nVTrans; i++){
@@ -114395,7 +115626,7 @@ SQLITE_PRIVATE void sqlite3VtabMakeWritable(Parse *pParse, Table *pTab){
     if( pTab==pToplevel->apVtabLock[i] ) return;
   }
   n = (pToplevel->nVtabLock+1)*sizeof(pToplevel->apVtabLock[0]);
-  apVtabLock = sqlite3_realloc(pToplevel->apVtabLock, n);
+  apVtabLock = sqlite3_realloc64(pToplevel->apVtabLock, n);
   if( apVtabLock ){
     pToplevel->apVtabLock = apVtabLock;
     pToplevel->apVtabLock[pToplevel->nVtabLock++] = pTab;
@@ -114411,7 +115642,7 @@ SQLITE_PRIVATE void sqlite3VtabMakeWritable(Parse *pParse, Table *pTab){
 ** The results of this routine are undefined unless it is called from
 ** within an xUpdate method.
 */
-SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *db){
+SQLITE_API int SQLITE_STDCALL sqlite3_vtab_on_conflict(sqlite3 *db){
   static const unsigned char aMap[] = { 
     SQLITE_ROLLBACK, SQLITE_ABORT, SQLITE_FAIL, SQLITE_IGNORE, SQLITE_REPLACE 
   };
@@ -114429,7 +115660,7 @@ SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *db){
 ** the SQLite core with additional information about the behavior
 ** of the virtual table being implemented.
 */
-SQLITE_API int sqlite3_vtab_config(sqlite3 *db, int op, ...){
+SQLITE_API int SQLITE_CDECL sqlite3_vtab_config(sqlite3 *db, int op, ...){
   va_list ap;
   int rc = SQLITE_OK;
 
@@ -114555,6 +115786,8 @@ struct WhereLevel {
   int addrCont;         /* Jump here to continue with the next loop cycle */
   int addrFirst;        /* First instruction of interior of the loop */
   int addrBody;         /* Beginning of the body of this loop */
+  int iLikeRepCntr;     /* LIKE range processing counter register */
+  int addrLikeRep;      /* LIKE range processing address */
   u8 iFrom;             /* Which entry in the FROM clause */
   u8 op, p3, p5;        /* Opcode, P3 & P5 of the opcode that ends the loop */
   int p1, p2;           /* Operands of the opcode used to ends the loop */
@@ -114739,7 +115972,7 @@ struct WhereTerm {
   } u;
   LogEst truthProb;       /* Probability of truth for this expression */
   u16 eOperator;          /* A WO_xx value describing <op> */
-  u8 wtFlags;             /* TERM_xxx bit flags.  See below */
+  u16 wtFlags;            /* TERM_xxx bit flags.  See below */
   u8 nChild;              /* Number of children that must disable us */
   WhereClause *pWC;       /* The clause this term is part of */
   Bitmask prereqRight;    /* Bitmask of tables used by pExpr->pRight */
@@ -114761,6 +115994,9 @@ struct WhereTerm {
 #else
 #  define TERM_VNULL    0x00   /* Disabled if not using stat3 */
 #endif
+#define TERM_LIKEOPT    0x100  /* Virtual terms from the LIKE optimization */
+#define TERM_LIKECOND   0x200  /* Conditionally this LIKE operator term */
+#define TERM_LIKE       0x400  /* The original LIKE operator */
 
 /*
 ** An instance of the WhereScan object is used as an iterator for locating
@@ -115136,7 +116372,7 @@ static void whereClauseClear(WhereClause *pWC){
 ** calling this routine.  Such pointers may be reinitialized by referencing
 ** the pWC->a[] array.
 */
-static int whereClauseInsert(WhereClause *pWC, Expr *p, u8 wtFlags){
+static int whereClauseInsert(WhereClause *pWC, Expr *p, u16 wtFlags){
   WhereTerm *pTerm;
   int idx;
   testcase( wtFlags & TERM_VIRTUAL );
@@ -115189,13 +116425,14 @@ static int whereClauseInsert(WhereClause *pWC, Expr *p, u8 wtFlags){
 ** all terms of the WHERE clause.
 */
 static void whereSplit(WhereClause *pWC, Expr *pExpr, u8 op){
+  Expr *pE2 = sqlite3ExprSkipCollate(pExpr);
   pWC->op = op;
-  if( pExpr==0 ) return;
-  if( pExpr->op!=op ){
+  if( pE2==0 ) return;
+  if( pE2->op!=op ){
     whereClauseInsert(pWC, pExpr, 0);
   }else{
-    whereSplit(pWC, pExpr->pLeft, op);
-    whereSplit(pWC, pExpr->pRight, op);
+    whereSplit(pWC, pE2->pLeft, op);
+    whereSplit(pWC, pE2->pRight, op);
   }
 }
 
@@ -115561,7 +116798,11 @@ static void exprAnalyzeAll(
 ** so and false if not.
 **
 ** In order for the operator to be optimizible, the RHS must be a string
-** literal that does not begin with a wildcard.  
+** literal that does not begin with a wildcard.  The LHS must be a column
+** that may only be NULL, a string, or a BLOB, never a number. (This means
+** that virtual tables cannot participate in the LIKE optimization.)  If the
+** collating sequence for the column on the LHS must be appropriate for
+** the operator.
 */
 static int isLikeOrGlob(
   Parse *pParse,    /* Parsing and code generating context */
@@ -115590,7 +116831,7 @@ static int isLikeOrGlob(
   pLeft = pList->a[1].pExpr;
   if( pLeft->op!=TK_COLUMN 
    || sqlite3ExprAffinity(pLeft)!=SQLITE_AFF_TEXT 
-   || IsVirtual(pLeft->pTab)
+   || IsVirtual(pLeft->pTab)  /* Value might be numeric */
   ){
     /* IMP: R-02065-49465 The left-hand side of the LIKE or GLOB operator must
     ** be the name of an indexed column with TEXT affinity. */
@@ -115700,6 +116941,79 @@ static void markTermAsChild(WhereClause *pWC, int iChild, int iParent){
   pWC->a[iParent].nChild++;
 }
 
+/*
+** Return the N-th AND-connected subterm of pTerm.  Or if pTerm is not
+** a conjunction, then return just pTerm when N==0.  If N is exceeds
+** the number of available subterms, return NULL.
+*/
+static WhereTerm *whereNthSubterm(WhereTerm *pTerm, int N){
+  if( pTerm->eOperator!=WO_AND ){
+    return N==0 ? pTerm : 0;
+  }
+  if( N<pTerm->u.pAndInfo->wc.nTerm ){
+    return &pTerm->u.pAndInfo->wc.a[N];
+  }
+  return 0;
+}
+
+/*
+** Subterms pOne and pTwo are contained within WHERE clause pWC.  The
+** two subterms are in disjunction - they are OR-ed together.
+**
+** If these two terms are both of the form:  "A op B" with the same
+** A and B values but different operators and if the operators are
+** compatible (if one is = and the other is <, for example) then
+** add a new virtual AND term to pWC that is the combination of the
+** two.
+**
+** Some examples:
+**
+**    x<y OR x=y    -->     x<=y
+**    x=y OR x=y    -->     x=y
+**    x<=y OR x<y   -->     x<=y
+**
+** The following is NOT generated:
+**
+**    x<y OR x>y    -->     x!=y     
+*/
+static void whereCombineDisjuncts(
+  SrcList *pSrc,         /* the FROM clause */
+  WhereClause *pWC,      /* The complete WHERE clause */
+  WhereTerm *pOne,       /* First disjunct */
+  WhereTerm *pTwo        /* Second disjunct */
+){
+  u16 eOp = pOne->eOperator | pTwo->eOperator;
+  sqlite3 *db;           /* Database connection (for malloc) */
+  Expr *pNew;            /* New virtual expression */
+  int op;                /* Operator for the combined expression */
+  int idxNew;            /* Index in pWC of the next virtual term */
+
+  if( (pOne->eOperator & (WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE))==0 ) return;
+  if( (pTwo->eOperator & (WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE))==0 ) return;
+  if( (eOp & (WO_EQ|WO_LT|WO_LE))!=eOp
+   && (eOp & (WO_EQ|WO_GT|WO_GE))!=eOp ) return;
+  assert( pOne->pExpr->pLeft!=0 && pOne->pExpr->pRight!=0 );
+  assert( pTwo->pExpr->pLeft!=0 && pTwo->pExpr->pRight!=0 );
+  if( sqlite3ExprCompare(pOne->pExpr->pLeft, pTwo->pExpr->pLeft, -1) ) return;
+  if( sqlite3ExprCompare(pOne->pExpr->pRight, pTwo->pExpr->pRight, -1) )return;
+  /* If we reach this point, it means the two subterms can be combined */
+  if( (eOp & (eOp-1))!=0 ){
+    if( eOp & (WO_LT|WO_LE) ){
+      eOp = WO_LE;
+    }else{
+      assert( eOp & (WO_GT|WO_GE) );
+      eOp = WO_GE;
+    }
+  }
+  db = pWC->pWInfo->pParse->db;
+  pNew = sqlite3ExprDup(db, pOne->pExpr, 0);
+  if( pNew==0 ) return;
+  for(op=TK_EQ; eOp!=(WO_EQ<<(op-TK_EQ)); op++){ assert( op<TK_GE ); }
+  pNew->op = op;
+  idxNew = whereClauseInsert(pWC, pNew, TERM_VIRTUAL|TERM_DYNAMIC);
+  exprAnalyze(pSrc, pWC, idxNew);
+}
+
 #if !defined(SQLITE_OMIT_OR_OPTIMIZATION) && !defined(SQLITE_OMIT_SUBQUERY)
 /*
 ** Analyze a term that consists of two or more OR-connected
@@ -115724,6 +117038,7 @@ static void markTermAsChild(WhereClause *pWC, int iChild, int iParent){
 **     (C)     t1.x=t2.y OR (t1.x=t2.z AND t1.y=15)
 **     (D)     x=expr1 OR (y>11 AND y<22 AND z LIKE '*hello*')
 **     (E)     (p.a=1 AND q.b=2 AND r.c=3) OR (p.x=4 AND q.y=5 AND r.z=6)
+**     (F)     x>A OR (x=A AND y>=B)
 **
 ** CASE 1:
 **
@@ -115740,6 +117055,16 @@ static void markTermAsChild(WhereClause *pWC, int iChild, int iParent){
 **
 ** CASE 2:
 **
+** If there are exactly two disjuncts one side has x>A and the other side
+** has x=A (for the same x and A) then add a new virtual conjunct term to the
+** WHERE clause of the form "x>=A".  Example:
+**
+**      x>A OR (x=A AND y>B)    adds:    x>=A
+**
+** The added conjunct can sometimes be helpful in query planning.
+**
+** CASE 3:
+**
 ** If all subterms are indexable by a single table T, then set
 **
 **     WhereTerm.eOperator              =  WO_OR
@@ -115866,12 +117191,26 @@ static void exprAnalyzeOrTerm(
   }
 
   /*
-  ** Record the set of tables that satisfy case 2.  The set might be
+  ** Record the set of tables that satisfy case 3.  The set might be
   ** empty.
   */
   pOrInfo->indexable = indexable;
   pTerm->eOperator = indexable==0 ? 0 : WO_OR;
 
+  /* For a two-way OR, attempt to implementation case 2.
+  */
+  if( indexable && pOrWc->nTerm==2 ){
+    int iOne = 0;
+    WhereTerm *pOne;
+    while( (pOne = whereNthSubterm(&pOrWc->a[0],iOne++))!=0 ){
+      int iTwo = 0;
+      WhereTerm *pTwo;
+      while( (pTwo = whereNthSubterm(&pOrWc->a[1],iTwo++))!=0 ){
+        whereCombineDisjuncts(pSrc, pWC, pOne, pTwo);
+      }
+    }
+  }
+
   /*
   ** chngToIN holds a set of tables that *might* satisfy case 1.  But
   ** we have to do some additional checking to see if case 1 really
@@ -116001,7 +117340,7 @@ static void exprAnalyzeOrTerm(
       }else{
         sqlite3ExprListDelete(db, pList);
       }
-      pTerm->eOperator = WO_NOOP;  /* case 1 trumps case 2 */
+      pTerm->eOperator = WO_NOOP;  /* case 1 trumps case 3 */
     }
   }
 }
@@ -116039,7 +117378,7 @@ static void exprAnalyze(
   Bitmask extraRight = 0;          /* Extra dependencies on LEFT JOIN */
   Expr *pStr1 = 0;                 /* RHS of LIKE/GLOB operator */
   int isComplete = 0;              /* RHS of LIKE/GLOB ends with wildcard */
-  int noCase = 0;                  /* LIKE/GLOB distinguishes case */
+  int noCase = 0;                  /* uppercase equivalent to lowercase */
   int op;                          /* Top-level operator.  pExpr->op */
   Parse *pParse = pWInfo->pParse;  /* Parsing context */
   sqlite3 *db = pParse->db;        /* Database connection */
@@ -116177,12 +117516,15 @@ static void exprAnalyze(
   /* Add constraints to reduce the search space on a LIKE or GLOB
   ** operator.
   **
-  ** A like pattern of the form "x LIKE 'abc%'" is changed into constraints
+  ** A like pattern of the form "x LIKE 'aBc%'" is changed into constraints
   **
-  **          x>='abc' AND x<'abd' AND x LIKE 'abc%'
+  **          x>='ABC' AND x<'abd' AND x LIKE 'aBc%'
   **
   ** The last character of the prefix "abc" is incremented to form the
-  ** termination condition "abd".
+  ** termination condition "abd".  If case is not significant (the default
+  ** for LIKE) then the lower-bound is made all uppercase and the upper-
+  ** bound is made all lowercase so that the bounds also work when comparing
+  ** BLOBs.
   */
   if( pWC->op==TK_AND 
    && isLikeOrGlob(pParse, pExpr, &pStr1, &isComplete, &noCase)
@@ -116193,10 +117535,26 @@ static void exprAnalyze(
     Expr *pNewExpr2;
     int idxNew1;
     int idxNew2;
-    Token sCollSeqName;  /* Name of collating sequence */
+    const char *zCollSeqName;     /* Name of collating sequence */
+    const u16 wtFlags = TERM_LIKEOPT | TERM_VIRTUAL | TERM_DYNAMIC;
 
     pLeft = pExpr->x.pList->a[1].pExpr;
     pStr2 = sqlite3ExprDup(db, pStr1, 0);
+
+    /* Convert the lower bound to upper-case and the upper bound to
+    ** lower-case (upper-case is less than lower-case in ASCII) so that
+    ** the range constraints also work for BLOBs
+    */
+    if( noCase && !pParse->db->mallocFailed ){
+      int i;
+      char c;
+      pTerm->wtFlags |= TERM_LIKE;
+      for(i=0; (c = pStr1->u.zToken[i])!=0; i++){
+        pStr1->u.zToken[i] = sqlite3Toupper(c);
+        pStr2->u.zToken[i] = sqlite3Tolower(c);
+      }
+    }
+
     if( !db->mallocFailed ){
       u8 c, *pC;       /* Last character before the first wildcard */
       pC = (u8*)&pStr2->u.zToken[sqlite3Strlen30(pStr2->u.zToken)-1];
@@ -116213,22 +117571,21 @@ static void exprAnalyze(
       }
       *pC = c + 1;
     }
-    sCollSeqName.z = noCase ? "NOCASE" : "BINARY";
-    sCollSeqName.n = 6;
+    zCollSeqName = noCase ? "NOCASE" : "BINARY";
     pNewExpr1 = sqlite3ExprDup(db, pLeft, 0);
-    pNewExpr1 = sqlite3PExpr(pParse, TK_GE, 
-           sqlite3ExprAddCollateToken(pParse,pNewExpr1,&sCollSeqName),
+    pNewExpr1 = sqlite3PExpr(pParse, TK_GE,
+           sqlite3ExprAddCollateString(pParse,pNewExpr1,zCollSeqName),
            pStr1, 0);
     transferJoinMarkings(pNewExpr1, pExpr);
-    idxNew1 = whereClauseInsert(pWC, pNewExpr1, TERM_VIRTUAL|TERM_DYNAMIC);
+    idxNew1 = whereClauseInsert(pWC, pNewExpr1, wtFlags);
     testcase( idxNew1==0 );
     exprAnalyze(pSrc, pWC, idxNew1);
     pNewExpr2 = sqlite3ExprDup(db, pLeft, 0);
     pNewExpr2 = sqlite3PExpr(pParse, TK_LT,
-           sqlite3ExprAddCollateToken(pParse,pNewExpr2,&sCollSeqName),
+           sqlite3ExprAddCollateString(pParse,pNewExpr2,zCollSeqName),
            pStr2, 0);
     transferJoinMarkings(pNewExpr2, pExpr);
-    idxNew2 = whereClauseInsert(pWC, pNewExpr2, TERM_VIRTUAL|TERM_DYNAMIC);
+    idxNew2 = whereClauseInsert(pWC, pNewExpr2, wtFlags);
     testcase( idxNew2==0 );
     exprAnalyze(pSrc, pWC, idxNew2);
     pTerm = &pWC->a[idxTerm];
@@ -116346,7 +117703,7 @@ static int findIndexCol(
      && p->iTable==iBase
     ){
       CollSeq *pColl = sqlite3ExprCollSeq(pParse, pList->a[i].pExpr);
-      if( ALWAYS(pColl) && 0==sqlite3StrICmp(pColl->zName, zColl) ){
+      if( pColl && 0==sqlite3StrICmp(pColl->zName, zColl) ){
         return i;
       }
     }
@@ -116546,11 +117903,16 @@ static void constructAutomaticIndex(
   pLoop = pLevel->pWLoop;
   idxCols = 0;
   for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){
+    Expr *pExpr = pTerm->pExpr;
+    assert( !ExprHasProperty(pExpr, EP_FromJoin)    /* prereq always non-zero */
+         || pExpr->iRightJoinTable!=pSrc->iCursor   /*   for the right-hand   */
+         || pLoop->prereq!=0 );                     /*   table of a LEFT JOIN */
     if( pLoop->prereq==0
      && (pTerm->wtFlags & TERM_VIRTUAL)==0
-     && sqlite3ExprIsTableConstant(pTerm->pExpr, pSrc->iCursor) ){
+     && !ExprHasProperty(pExpr, EP_FromJoin)
+     && sqlite3ExprIsTableConstant(pExpr, pSrc->iCursor) ){
       pPartial = sqlite3ExprAnd(pParse->db, pPartial,
-                                sqlite3ExprDup(pParse->db, pTerm->pExpr, 0));
+                                sqlite3ExprDup(pParse->db, pExpr, 0));
     }
     if( termCanDriveIndex(pTerm, pSrc, notReady) ){
       int iCol = pTerm->u.leftColumn;
@@ -116615,7 +117977,7 @@ static void constructAutomaticIndex(
         idxCols |= cMask;
         pIdx->aiColumn[n] = pTerm->u.leftColumn;
         pColl = sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pX->pRight);
-        pIdx->azColl[n] = ALWAYS(pColl) ? pColl->zName : "BINARY";
+        pIdx->azColl[n] = pColl ? pColl->zName : "BINARY";
         n++;
       }
     }
@@ -116837,11 +118199,14 @@ static int vtabBestIndex(Parse *pParse, Table *pTab, sqlite3_index_info *p){
 ** Estimate the location of a particular key among all keys in an
 ** index.  Store the results in aStat as follows:
 **
-**    aStat[0]      Est. number of rows less than pVal
-**    aStat[1]      Est. number of rows equal to pVal
+**    aStat[0]      Est. number of rows less than pRec
+**    aStat[1]      Est. number of rows equal to pRec
 **
 ** Return the index of the sample that is the smallest sample that
-** is greater than or equal to pRec.
+** is greater than or equal to pRec. Note that this index is not an index
+** into the aSample[] array - it is an index into a virtual set of samples
+** based on the contents of aSample[] and the number of fields in record 
+** pRec. 
 */
 static int whereKeyStats(
   Parse *pParse,              /* Database connection */
@@ -116852,67 +118217,158 @@ static int whereKeyStats(
 ){
   IndexSample *aSample = pIdx->aSample;
   int iCol;                   /* Index of required stats in anEq[] etc. */
+  int i;                      /* Index of first sample >= pRec */
+  int iSample;                /* Smallest sample larger than or equal to pRec */
   int iMin = 0;               /* Smallest sample not yet tested */
-  int i = pIdx->nSample;      /* Smallest sample larger than or equal to pRec */
   int iTest;                  /* Next sample to test */
   int res;                    /* Result of comparison operation */
+  int nField;                 /* Number of fields in pRec */
+  tRowcnt iLower = 0;         /* anLt[] + anEq[] of largest sample pRec is > */
 
 #ifndef SQLITE_DEBUG
   UNUSED_PARAMETER( pParse );
 #endif
   assert( pRec!=0 );
-  iCol = pRec->nField - 1;
   assert( pIdx->nSample>0 );
-  assert( pRec->nField>0 && iCol<pIdx->nSampleCol );
+  assert( pRec->nField>0 && pRec->nField<=pIdx->nSampleCol );
+
+  /* Do a binary search to find the first sample greater than or equal
+  ** to pRec. If pRec contains a single field, the set of samples to search
+  ** is simply the aSample[] array. If the samples in aSample[] contain more
+  ** than one fields, all fields following the first are ignored.
+  **
+  ** If pRec contains N fields, where N is more than one, then as well as the
+  ** samples in aSample[] (truncated to N fields), the search also has to
+  ** consider prefixes of those samples. For example, if the set of samples
+  ** in aSample is:
+  **
+  **     aSample[0] = (a, 5) 
+  **     aSample[1] = (a, 10) 
+  **     aSample[2] = (b, 5) 
+  **     aSample[3] = (c, 100) 
+  **     aSample[4] = (c, 105)
+  **
+  ** Then the search space should ideally be the samples above and the 
+  ** unique prefixes [a], [b] and [c]. But since that is hard to organize, 
+  ** the code actually searches this set:
+  **
+  **     0: (a) 
+  **     1: (a, 5) 
+  **     2: (a, 10) 
+  **     3: (a, 10) 
+  **     4: (b) 
+  **     5: (b, 5) 
+  **     6: (c) 
+  **     7: (c, 100) 
+  **     8: (c, 105)
+  **     9: (c, 105)
+  **
+  ** For each sample in the aSample[] array, N samples are present in the
+  ** effective sample array. In the above, samples 0 and 1 are based on 
+  ** sample aSample[0]. Samples 2 and 3 on aSample[1] etc.
+  **
+  ** Often, sample i of each block of N effective samples has (i+1) fields.
+  ** Except, each sample may be extended to ensure that it is greater than or
+  ** equal to the previous sample in the array. For example, in the above, 
+  ** sample 2 is the first sample of a block of N samples, so at first it 
+  ** appears that it should be 1 field in size. However, that would make it 
+  ** smaller than sample 1, so the binary search would not work. As a result, 
+  ** it is extended to two fields. The duplicates that this creates do not 
+  ** cause any problems.
+  */
+  nField = pRec->nField;
+  iCol = 0;
+  iSample = pIdx->nSample * nField;
   do{
-    iTest = (iMin+i)/2;
-    res = sqlite3VdbeRecordCompare(aSample[iTest].n, aSample[iTest].p, pRec);
+    int iSamp;                    /* Index in aSample[] of test sample */
+    int n;                        /* Number of fields in test sample */
+
+    iTest = (iMin+iSample)/2;
+    iSamp = iTest / nField;
+    if( iSamp>0 ){
+      /* The proposed effective sample is a prefix of sample aSample[iSamp].
+      ** Specifically, the shortest prefix of at least (1 + iTest%nField) 
+      ** fields that is greater than the previous effective sample.  */
+      for(n=(iTest % nField) + 1; n<nField; n++){
+        if( aSample[iSamp-1].anLt[n-1]!=aSample[iSamp].anLt[n-1] ) break;
+      }
+    }else{
+      n = iTest + 1;
+    }
+
+    pRec->nField = n;
+    res = sqlite3VdbeRecordCompare(aSample[iSamp].n, aSample[iSamp].p, pRec);
     if( res<0 ){
+      iLower = aSample[iSamp].anLt[n-1] + aSample[iSamp].anEq[n-1];
+      iMin = iTest+1;
+    }else if( res==0 && n<nField ){
+      iLower = aSample[iSamp].anLt[n-1];
       iMin = iTest+1;
+      res = -1;
     }else{
-      i = iTest;
+      iSample = iTest;
+      iCol = n-1;
     }
-  }while( res && iMin<i );
+  }while( res && iMin<iSample );
+  i = iSample / nField;
 
 #ifdef SQLITE_DEBUG
   /* The following assert statements check that the binary search code
   ** above found the right answer. This block serves no purpose other
   ** than to invoke the asserts.  */
-  if( res==0 ){
-    /* If (res==0) is true, then sample $i must be equal to pRec */
-    assert( i<pIdx->nSample );
-    assert( 0==sqlite3VdbeRecordCompare(aSample[i].n, aSample[i].p, pRec)
-         || pParse->db->mallocFailed );
-  }else{
-    /* Otherwise, pRec must be smaller than sample $i and larger than
-    ** sample ($i-1).  */
-    assert( i==pIdx->nSample 
-         || sqlite3VdbeRecordCompare(aSample[i].n, aSample[i].p, pRec)>0
-         || pParse->db->mallocFailed );
-    assert( i==0
-         || sqlite3VdbeRecordCompare(aSample[i-1].n, aSample[i-1].p, pRec)<0
-         || pParse->db->mallocFailed );
+  if( pParse->db->mallocFailed==0 ){
+    if( res==0 ){
+      /* If (res==0) is true, then pRec must be equal to sample i. */
+      assert( i<pIdx->nSample );
+      assert( iCol==nField-1 );
+      pRec->nField = nField;
+      assert( 0==sqlite3VdbeRecordCompare(aSample[i].n, aSample[i].p, pRec) 
+           || pParse->db->mallocFailed 
+      );
+    }else{
+      /* Unless i==pIdx->nSample, indicating that pRec is larger than
+      ** all samples in the aSample[] array, pRec must be smaller than the
+      ** (iCol+1) field prefix of sample i.  */
+      assert( i<=pIdx->nSample && i>=0 );
+      pRec->nField = iCol+1;
+      assert( i==pIdx->nSample 
+           || sqlite3VdbeRecordCompare(aSample[i].n, aSample[i].p, pRec)>0
+           || pParse->db->mallocFailed );
+
+      /* if i==0 and iCol==0, then record pRec is smaller than all samples
+      ** in the aSample[] array. Otherwise, if (iCol>0) then pRec must
+      ** be greater than or equal to the (iCol) field prefix of sample i.
+      ** If (i>0), then pRec must also be greater than sample (i-1).  */
+      if( iCol>0 ){
+        pRec->nField = iCol;
+        assert( sqlite3VdbeRecordCompare(aSample[i].n, aSample[i].p, pRec)<=0
+             || pParse->db->mallocFailed );
+      }
+      if( i>0 ){
+        pRec->nField = nField;
+        assert( sqlite3VdbeRecordCompare(aSample[i-1].n, aSample[i-1].p, pRec)<0
+             || pParse->db->mallocFailed );
+      }
+    }
   }
 #endif /* ifdef SQLITE_DEBUG */
 
-  /* At this point, aSample[i] is the first sample that is greater than
-  ** or equal to pVal.  Or if i==pIdx->nSample, then all samples are less
-  ** than pVal.  If aSample[i]==pVal, then res==0.
-  */
   if( res==0 ){
+    /* Record pRec is equal to sample i */
+    assert( iCol==nField-1 );
     aStat[0] = aSample[i].anLt[iCol];
     aStat[1] = aSample[i].anEq[iCol];
   }else{
-    tRowcnt iLower, iUpper, iGap;
-    if( i==0 ){
-      iLower = 0;
-      iUpper = aSample[0].anLt[iCol];
+    /* At this point, the (iCol+1) field prefix of aSample[i] is the first 
+    ** sample that is greater than pRec. Or, if i==pIdx->nSample then pRec
+    ** is larger than all samples in the array. */
+    tRowcnt iUpper, iGap;
+    if( i>=pIdx->nSample ){
+      iUpper = sqlite3LogEstToInt(pIdx->aiRowLogEst[0]);
     }else{
-      i64 nRow0 = sqlite3LogEstToInt(pIdx->aiRowLogEst[0]);
-      iUpper = i>=pIdx->nSample ? nRow0 : aSample[i].anLt[iCol];
-      iLower = aSample[i-1].anEq[iCol] + aSample[i-1].anLt[iCol];
+      iUpper = aSample[i].anLt[iCol];
     }
-    aStat[1] = pIdx->aAvgEq[iCol];
+
     if( iLower>=iUpper ){
       iGap = 0;
     }else{
@@ -116924,7 +118380,11 @@ static int whereKeyStats(
       iGap = iGap/3;
     }
     aStat[0] = iLower + iGap;
+    aStat[1] = pIdx->aAvgEq[iCol];
   }
+
+  /* Restore the pRec->nField value before returning.  */
+  pRec->nField = nField;
   return i;
 }
 #endif /* SQLITE_ENABLE_STAT3_OR_STAT4 */
@@ -117398,20 +118858,43 @@ static int whereInScanEst(
 ** but joins might run a little slower.  The trick is to disable as much
 ** as we can without disabling too much.  If we disabled in (1), we'd get
 ** the wrong answer.  See ticket #813.
+**
+** If all the children of a term are disabled, then that term is also
+** automatically disabled.  In this way, terms get disabled if derived
+** virtual terms are tested first.  For example:
+**
+**      x GLOB 'abc*' AND x>='abc' AND x<'acd'
+**      \___________/     \______/     \_____/
+**         parent          child1       child2
+**
+** Only the parent term was in the original WHERE clause.  The child1
+** and child2 terms were added by the LIKE optimization.  If both of
+** the virtual child terms are valid, then testing of the parent can be 
+** skipped.
+**
+** Usually the parent term is marked as TERM_CODED.  But if the parent
+** term was originally TERM_LIKE, then the parent gets TERM_LIKECOND instead.
+** The TERM_LIKECOND marking indicates that the term should be coded inside
+** a conditional such that is only evaluated on the second pass of a
+** LIKE-optimization loop, when scanning BLOBs instead of strings.
 */
 static void disableTerm(WhereLevel *pLevel, WhereTerm *pTerm){
-  if( pTerm
+  int nLoop = 0;
+  while( pTerm
       && (pTerm->wtFlags & TERM_CODED)==0
       && (pLevel->iLeftJoin==0 || ExprHasProperty(pTerm->pExpr, EP_FromJoin))
       && (pLevel->notReady & pTerm->prereqAll)==0
   ){
-    pTerm->wtFlags |= TERM_CODED;
-    if( pTerm->iParent>=0 ){
-      WhereTerm *pOther = &pTerm->pWC->a[pTerm->iParent];
-      if( (--pOther->nChild)==0 ){
-        disableTerm(pLevel, pOther);
-      }
+    if( nLoop && (pTerm->wtFlags & TERM_LIKE)!=0 ){
+      pTerm->wtFlags |= TERM_LIKECOND;
+    }else{
+      pTerm->wtFlags |= TERM_CODED;
     }
+    if( pTerm->iParent<0 ) break;
+    pTerm = &pTerm->pWC->a[pTerm->iParent];
+    pTerm->nChild--;
+    if( pTerm->nChild!=0 ) break;
+    nLoop++;
   }
 }
 
@@ -117790,8 +119273,7 @@ static int explainOneScan(
             || ((flags&WHERE_VIRTUALTABLE)==0 && (pLoop->u.btree.nEq>0))
             || (wctrlFlags&(WHERE_ORDERBY_MIN|WHERE_ORDERBY_MAX));
 
-    sqlite3StrAccumInit(&str, zBuf, sizeof(zBuf), SQLITE_MAX_LENGTH);
-    str.db = db;
+    sqlite3StrAccumInit(&str, db, zBuf, sizeof(zBuf), SQLITE_MAX_LENGTH);
     sqlite3StrAccumAppendAll(&str, isSearch ? "SEARCH" : "SCAN");
     if( pItem->pSelect ){
       sqlite3XPrintf(&str, 0, " SUBQUERY %d", pItem->iSelectId);
@@ -117895,7 +119377,34 @@ static void addScanStatus(
 # define addScanStatus(a, b, c, d) ((void)d)
 #endif
 
-
+/*
+** If the most recently coded instruction is a constant range contraint
+** that originated from the LIKE optimization, then change the P3 to be
+** pLoop->iLikeRepCntr and set P5.
+**
+** The LIKE optimization trys to evaluate "x LIKE 'abc%'" as a range
+** expression: "x>='ABC' AND x<'abd'".  But this requires that the range
+** scan loop run twice, once for strings and a second time for BLOBs.
+** The OP_String opcodes on the second pass convert the upper and lower
+** bound string contants to blobs.  This routine makes the necessary changes
+** to the OP_String opcodes for that to happen.
+*/
+static void whereLikeOptimizationStringFixup(
+  Vdbe *v,                /* prepared statement under construction */
+  WhereLevel *pLevel,     /* The loop that contains the LIKE operator */
+  WhereTerm *pTerm        /* The upper or lower bound just coded */
+){
+  if( pTerm->wtFlags & TERM_LIKEOPT ){
+    VdbeOp *pOp;
+    assert( pLevel->iLikeRepCntr>0 );
+    pOp = sqlite3VdbeGetOp(v, -1);
+    assert( pOp!=0 );
+    assert( pOp->opcode==OP_String8 
+            || pTerm->pWC->pWInfo->pParse->db->mallocFailed );
+    pOp->p3 = pLevel->iLikeRepCntr;
+    pOp->p5 = 1;
+  }
+}
 
 /*
 ** Generate code for the start of the iLevel-th loop in the WHERE clause
@@ -118225,10 +119734,25 @@ static Bitmask codeOneLoopStart(
     if( pLoop->wsFlags & WHERE_BTM_LIMIT ){
       pRangeStart = pLoop->aLTerm[j++];
       nExtraReg = 1;
+      /* Like optimization range constraints always occur in pairs */
+      assert( (pRangeStart->wtFlags & TERM_LIKEOPT)==0 || 
+              (pLoop->wsFlags & WHERE_TOP_LIMIT)!=0 );
     }
     if( pLoop->wsFlags & WHERE_TOP_LIMIT ){
       pRangeEnd = pLoop->aLTerm[j++];
       nExtraReg = 1;
+      if( (pRangeEnd->wtFlags & TERM_LIKEOPT)!=0 ){
+        assert( pRangeStart!=0 );                     /* LIKE opt constraints */
+        assert( pRangeStart->wtFlags & TERM_LIKEOPT );   /* occur in pairs */
+        pLevel->iLikeRepCntr = ++pParse->nMem;
+        testcase( bRev );
+        testcase( pIdx->aSortOrder[nEq]==SQLITE_SO_DESC );
+        sqlite3VdbeAddOp2(v, OP_Integer,
+                          bRev ^ (pIdx->aSortOrder[nEq]==SQLITE_SO_DESC),
+                          pLevel->iLikeRepCntr);
+        VdbeComment((v, "LIKE loop counter"));
+        pLevel->addrLikeRep = sqlite3VdbeCurrentAddr(v);
+      }
       if( pRangeStart==0
        && (j = pIdx->aiColumn[nEq])>=0 
        && pIdx->pTable->aCol[j].notNull==0
@@ -118271,6 +119795,7 @@ static Bitmask codeOneLoopStart(
     if( pRangeStart ){
       Expr *pRight = pRangeStart->pExpr->pRight;
       sqlite3ExprCode(pParse, pRight, regBase+nEq);
+      whereLikeOptimizationStringFixup(v, pLevel, pRangeStart);
       if( (pRangeStart->wtFlags & TERM_VNULL)==0
        && sqlite3ExprCanBeNull(pRight)
       ){
@@ -118316,6 +119841,7 @@ static Bitmask codeOneLoopStart(
       Expr *pRight = pRangeEnd->pExpr->pRight;
       sqlite3ExprCacheRemove(pParse, regBase+nEq, 1);
       sqlite3ExprCode(pParse, pRight, regBase+nEq);
+      whereLikeOptimizationStringFixup(v, pLevel, pRangeEnd);
       if( (pRangeEnd->wtFlags & TERM_VNULL)==0
        && sqlite3ExprCanBeNull(pRight)
       ){
@@ -118543,7 +120069,8 @@ static Bitmask codeOneLoopStart(
     */
     wctrlFlags =  WHERE_OMIT_OPEN_CLOSE
                 | WHERE_FORCE_TABLE
-                | WHERE_ONETABLE_ONLY;
+                | WHERE_ONETABLE_ONLY
+                | WHERE_NO_AUTOINDEX;
     for(ii=0; ii<pOrWc->nTerm; ii++){
       WhereTerm *pOrTerm = &pOrWc->a[ii];
       if( pOrTerm->leftCursor==iCur || (pOrTerm->eOperator & WO_AND)!=0 ){
@@ -118705,6 +120232,7 @@ static Bitmask codeOneLoopStart(
   */
   for(pTerm=pWC->a, j=pWC->nTerm; j>0; j--, pTerm++){
     Expr *pE;
+    int skipLikeAddr = 0;
     testcase( pTerm->wtFlags & TERM_VIRTUAL );
     testcase( pTerm->wtFlags & TERM_CODED );
     if( pTerm->wtFlags & (TERM_VIRTUAL|TERM_CODED) ) continue;
@@ -118719,7 +120247,13 @@ static Bitmask codeOneLoopStart(
     if( pLevel->iLeftJoin && !ExprHasProperty(pE, EP_FromJoin) ){
       continue;
     }
+    if( pTerm->wtFlags & TERM_LIKECOND ){
+      assert( pLevel->iLikeRepCntr>0 );
+      skipLikeAddr = sqlite3VdbeAddOp1(v, OP_IfNot, pLevel->iLikeRepCntr);
+      VdbeCoverage(v);
+    }
     sqlite3ExprIfFalse(pParse, pE, addrCont, SQLITE_JUMPIFNULL);
+    if( skipLikeAddr ) sqlite3VdbeJumpHere(v, skipLikeAddr);
     pTerm->wtFlags |= TERM_CODED;
   }
 
@@ -118938,6 +120472,13 @@ static void whereLoopDelete(sqlite3 *db, WhereLoop *p){
 */
 static void whereInfoFree(sqlite3 *db, WhereInfo *pWInfo){
   if( ALWAYS(pWInfo) ){
+    int i;
+    for(i=0; i<pWInfo->nLevel; i++){
+      WhereLevel *pLevel = &pWInfo->a[i];
+      if( pLevel->pWLoop && (pLevel->pWLoop->wsFlags & WHERE_IN_ABLE) ){
+        sqlite3DbFree(db, pLevel->u.in.aInLoop);
+      }
+    }
     whereClauseClear(&pWInfo->sWC);
     while( pWInfo->pLoops ){
       WhereLoop *p = pWInfo->pLoops;
@@ -119384,6 +120925,10 @@ static int whereLoopAddBtreeIndex(
     }
     if( pTerm->prereqRight & pNew->maskSelf ) continue;
 
+    /* Do not allow the upper bound of a LIKE optimization range constraint
+    ** to mix with a lower range bound from some other source */
+    if( pTerm->wtFlags & TERM_LIKEOPT && pTerm->eOperator==WO_LT ) continue;
+
     pNew->wsFlags = saved_wsFlags;
     pNew->u.btree.nEq = saved_nEq;
     pNew->nLTerm = saved_nLTerm;
@@ -119413,7 +120958,7 @@ static int whereLoopAddBtreeIndex(
     }else if( eOp & (WO_EQ) ){
       pNew->wsFlags |= WHERE_COLUMN_EQ;
       if( iCol<0 || (nInMul==0 && pNew->u.btree.nEq==pProbe->nKeyCol-1) ){
-        if( iCol>=0 && !IsUniqueIndex(pProbe) ){
+        if( iCol>=0 && pProbe->uniqNotNull==0 ){
           pNew->wsFlags |= WHERE_UNQ_WANTED;
         }else{
           pNew->wsFlags |= WHERE_ONEROW;
@@ -119427,6 +120972,17 @@ static int whereLoopAddBtreeIndex(
       pNew->wsFlags |= WHERE_COLUMN_RANGE|WHERE_BTM_LIMIT;
       pBtm = pTerm;
       pTop = 0;
+      if( pTerm->wtFlags & TERM_LIKEOPT ){
+        /* Range contraints that come from the LIKE optimization are
+        ** always used in pairs. */
+        pTop = &pTerm[1];
+        assert( (pTop-(pTerm->pWC->a))<pTerm->pWC->nTerm );
+        assert( pTop->wtFlags & TERM_LIKEOPT );
+        assert( pTop->eOperator==WO_LT );
+        if( whereLoopResize(db, pNew, pNew->nLTerm+1) ) break; /* OOM */
+        pNew->aLTerm[pNew->nLTerm++] = pTop;
+        pNew->wsFlags |= WHERE_TOP_LIMIT;
+      }
     }else{
       assert( eOp & (WO_LT|WO_LE) );
       testcase( eOp & WO_LT );
@@ -119628,7 +121184,12 @@ static int whereUsablePartialIndex(int iTab, WhereClause *pWC, Expr *pWhere){
   int i;
   WhereTerm *pTerm;
   for(i=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){
-    if( sqlite3ExprImpliesExpr(pTerm->pExpr, pWhere, iTab) ) return 1;
+    Expr *pExpr = pTerm->pExpr;
+    if( sqlite3ExprImpliesExpr(pExpr, pWhere, iTab) 
+     && (!ExprHasProperty(pExpr, EP_FromJoin) || pExpr->iRightJoinTable==iTab)
+    ){
+      return 1;
+    }
   }
   return 0;
 }
@@ -119732,6 +121293,7 @@ static int whereLoopAddBtree(
 #ifndef SQLITE_OMIT_AUTOMATIC_INDEX
   /* Automatic indexes */
   if( !pBuilder->pOrSet
+   && (pWInfo->wctrlFlags & WHERE_NO_AUTOINDEX)==0
    && (pWInfo->pParse->db->flags & SQLITE_AutoIndex)!=0
    && pSrc->pIndex==0
    && !pSrc->viaCoroutine
@@ -120615,10 +122177,10 @@ static int wherePathSolver(WhereInfo *pWInfo, LogEst nRowEst){
 
   /* Seed the search with a single WherePath containing zero WhereLoops.
   **
-  ** TUNING: Do not let the number of iterations go above 25.  If the cost
-  ** of computing an automatic index is not paid back within the first 25
+  ** TUNING: Do not let the number of iterations go above 28.  If the cost
+  ** of computing an automatic index is not paid back within the first 28
   ** rows, then do not use the automatic index. */
-  aFrom[0].nRow = MIN(pParse->nQueryLoop, 46);  assert( 46==sqlite3LogEst(25) );
+  aFrom[0].nRow = MIN(pParse->nQueryLoop, 48);  assert( 48==sqlite3LogEst(28) );
   nFrom = 1;
   assert( aFrom[0].isOrdered==0 );
   if( nOrderBy ){
@@ -120856,7 +122418,7 @@ static int wherePathSolver(WhereInfo *pWInfo, LogEst nRowEst){
       pWInfo->revMask = pFrom->revLoop;
     }
     if( (pWInfo->wctrlFlags & WHERE_SORTBYGROUP)
-        && pWInfo->nOBSat==pWInfo->pOrderBy->nExpr
+        && pWInfo->nOBSat==pWInfo->pOrderBy->nExpr && nLoop>0
     ){
       Bitmask revMask = 0;
       int nOrder = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pOrderBy, 
@@ -121261,7 +122823,6 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
   }
 #ifdef WHERETRACE_ENABLED /* !=0 */
   if( sqlite3WhereTrace ){
-    int ii;
     sqlite3DebugPrintf("---- Solution nRow=%d", pWInfo->nRowOut);
     if( pWInfo->nOBSat>0 ){
       sqlite3DebugPrintf(" ORDERBY=%d,0x%llx", pWInfo->nOBSat, pWInfo->revMask);
@@ -121416,6 +122977,12 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
       if( op ){
         sqlite3VdbeAddOp3(v, op, iIndexCur, pIx->tnum, iDb);
         sqlite3VdbeSetP4KeyInfo(pParse, pIx);
+        if( (pLoop->wsFlags & WHERE_CONSTRAINT)!=0
+         && (pLoop->wsFlags & (WHERE_COLUMN_RANGE|WHERE_SKIPSCAN))==0
+         && (pWInfo->wctrlFlags&WHERE_ORDERBY_MIN)==0
+        ){
+          sqlite3VdbeChangeP5(v, OPFLAG_SEEKEQ); /* Hint to COMDB2 */
+        }
         VdbeComment((v, "%s", pIx->zName));
       }
     }
@@ -121508,7 +123075,6 @@ SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo *pWInfo){
         VdbeCoverageIf(v, pIn->eEndLoopOp==OP_NextIfOpen);
         sqlite3VdbeJumpHere(v, pIn->addrInTop-1);
       }
-      sqlite3DbFree(db, pLevel->u.in.aInLoop);
     }
     sqlite3VdbeResolveLabel(v, pLevel->addrBrk);
     if( pLevel->addrSkip ){
@@ -121517,6 +123083,16 @@ SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo *pWInfo){
       sqlite3VdbeJumpHere(v, pLevel->addrSkip);
       sqlite3VdbeJumpHere(v, pLevel->addrSkip-2);
     }
+    if( pLevel->addrLikeRep ){
+      int op;
+      if( sqlite3VdbeGetOp(v, pLevel->addrLikeRep-1)->p1 ){
+        op = OP_DecrJumpZero;
+      }else{
+        op = OP_JumpZeroIncr;
+      }
+      sqlite3VdbeAddOp2(v, op, pLevel->iLikeRepCntr, pLevel->addrLikeRep);
+      VdbeCoverage(v);
+    }
     if( pLevel->iLeftJoin ){
       addr = sqlite3VdbeAddOp1(v, OP_IfPos, pLevel->iLeftJoin); VdbeCoverage(v);
       assert( (pLoop->wsFlags & WHERE_IDX_ONLY)==0
@@ -121710,6 +123286,28 @@ struct TrigEvent { int a; IdList * b; };
 struct AttachKey { int type;  Token key; };
 
 
+  /*
+  ** For a compound SELECT statement, make sure p->pPrior->pNext==p for
+  ** all elements in the list.  And make sure list length does not exceed
+  ** SQLITE_LIMIT_COMPOUND_SELECT.
+  */
+  static void parserDoubleLinkSelect(Parse *pParse, Select *p){
+    if( p->pPrior ){
+      Select *pNext = 0, *pLoop;
+      int mxSelect, cnt = 0;
+      for(pLoop=p; pLoop; pNext=pLoop, pLoop=pLoop->pPrior, cnt++){
+        pLoop->pNext = pNext;
+        pLoop->selFlags |= SF_Compound;
+      }
+      if( (p->selFlags & SF_MultiValue)==0 && 
+        (mxSelect = pParse->db->aLimit[SQLITE_LIMIT_COMPOUND_SELECT])>0 &&
+        cnt>mxSelect
+      ){
+        sqlite3ErrorMsg(pParse, "too many terms in compound SELECT");
+      }
+    }
+  }
+
   /* This is a utility routine used to set the ExprSpan.zStart and
   ** ExprSpan.zEnd values of pOut so that the span covers the complete
   ** range of text beginning with pStart and going to the end of pEnd.
@@ -124026,27 +125624,10 @@ static void yy_reduce(
         break;
       case 112: /* select ::= with selectnowith */
 {
-  Select *p = yymsp[0].minor.yy3, *pNext, *pLoop;
+  Select *p = yymsp[0].minor.yy3;
   if( p ){
-    int cnt = 0, mxSelect;
     p->pWith = yymsp[-1].minor.yy59;
-    if( p->pPrior ){
-      u16 allValues = SF_Values;
-      pNext = 0;
-      for(pLoop=p; pLoop; pNext=pLoop, pLoop=pLoop->pPrior, cnt++){
-        pLoop->pNext = pNext;
-        pLoop->selFlags |= SF_Compound;
-        allValues &= pLoop->selFlags;
-      }
-      if( allValues ){
-        p->selFlags |= SF_AllValues;
-      }else if(
-        (mxSelect = pParse->db->aLimit[SQLITE_LIMIT_COMPOUND_SELECT])>0
-        && cnt>mxSelect
-      ){
-        sqlite3ErrorMsg(pParse, "too many terms in compound SELECT");
-      }
-    }
+    parserDoubleLinkSelect(pParse, p);
   }else{
     sqlite3WithDelete(pParse->db, yymsp[-1].minor.yy59);
   }
@@ -124064,12 +125645,14 @@ static void yy_reduce(
     SrcList *pFrom;
     Token x;
     x.n = 0;
+    parserDoubleLinkSelect(pParse, pRhs);
     pFrom = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&x,pRhs,0,0);
     pRhs = sqlite3SelectNew(pParse,0,pFrom,0,0,0,0,0,0,0);
   }
   if( pRhs ){
     pRhs->op = (u8)yymsp[-1].minor.yy328;
     pRhs->pPrior = yymsp[-2].minor.yy3;
+    pRhs->selFlags &= ~SF_MultiValue;
     if( yymsp[-1].minor.yy328!=TK_ALL ) pParse->hasCompound = 1;
   }else{
     sqlite3SelectDelete(pParse->db, yymsp[-2].minor.yy3);
@@ -124116,13 +125699,16 @@ static void yy_reduce(
         break;
       case 121: /* values ::= values COMMA LP exprlist RP */
 {
-  Select *pRight = sqlite3SelectNew(pParse,yymsp[-1].minor.yy14,0,0,0,0,0,SF_Values,0,0);
+  Select *pRight, *pLeft = yymsp[-4].minor.yy3;
+  pRight = sqlite3SelectNew(pParse,yymsp[-1].minor.yy14,0,0,0,0,0,SF_Values|SF_MultiValue,0,0);
+  if( ALWAYS(pLeft) ) pLeft->selFlags &= ~SF_MultiValue;
   if( pRight ){
     pRight->op = TK_ALL;
-    pRight->pPrior = yymsp[-4].minor.yy3;
+    pLeft = yymsp[-4].minor.yy3;
+    pRight->pPrior = pLeft;
     yygotominor.yy3 = pRight;
   }else{
-    yygotominor.yy3 = yymsp[-4].minor.yy3;
+    yygotominor.yy3 = pLeft;
   }
 }
         break;
@@ -124407,7 +125993,7 @@ static void yy_reduce(
         break;
       case 193: /* expr ::= expr COLLATE ID|STRING */
 {
-  yygotominor.yy346.pExpr = sqlite3ExprAddCollateToken(pParse, yymsp[-2].minor.yy346.pExpr, &yymsp[0].minor.yy0);
+  yygotominor.yy346.pExpr = sqlite3ExprAddCollateToken(pParse, yymsp[-2].minor.yy346.pExpr, &yymsp[0].minor.yy0, 1);
   yygotominor.yy346.zStart = yymsp[-2].minor.yy346.zStart;
   yygotominor.yy346.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
 }
@@ -124570,7 +126156,7 @@ static void yy_reduce(
       yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy346.pExpr, 0, 0);
       if( yygotominor.yy346.pExpr ){
         yygotominor.yy346.pExpr->x.pList = yymsp[-1].minor.yy14;
-        sqlite3ExprSetHeight(pParse, yygotominor.yy346.pExpr);
+        sqlite3ExprSetHeightAndFlags(pParse, yygotominor.yy346.pExpr);
       }else{
         sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy14);
       }
@@ -124585,8 +126171,8 @@ static void yy_reduce(
     yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_SELECT, 0, 0, 0);
     if( yygotominor.yy346.pExpr ){
       yygotominor.yy346.pExpr->x.pSelect = yymsp[-1].minor.yy3;
-      ExprSetProperty(yygotominor.yy346.pExpr, EP_xIsSelect);
-      sqlite3ExprSetHeight(pParse, yygotominor.yy346.pExpr);
+      ExprSetProperty(yygotominor.yy346.pExpr, EP_xIsSelect|EP_Subquery);
+      sqlite3ExprSetHeightAndFlags(pParse, yygotominor.yy346.pExpr);
     }else{
       sqlite3SelectDelete(pParse->db, yymsp[-1].minor.yy3);
     }
@@ -124599,8 +126185,8 @@ static void yy_reduce(
     yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy346.pExpr, 0, 0);
     if( yygotominor.yy346.pExpr ){
       yygotominor.yy346.pExpr->x.pSelect = yymsp[-1].minor.yy3;
-      ExprSetProperty(yygotominor.yy346.pExpr, EP_xIsSelect);
-      sqlite3ExprSetHeight(pParse, yygotominor.yy346.pExpr);
+      ExprSetProperty(yygotominor.yy346.pExpr, EP_xIsSelect|EP_Subquery);
+      sqlite3ExprSetHeightAndFlags(pParse, yygotominor.yy346.pExpr);
     }else{
       sqlite3SelectDelete(pParse->db, yymsp[-1].minor.yy3);
     }
@@ -124615,8 +126201,8 @@ static void yy_reduce(
     yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_IN, yymsp[-3].minor.yy346.pExpr, 0, 0);
     if( yygotominor.yy346.pExpr ){
       yygotominor.yy346.pExpr->x.pSelect = sqlite3SelectNew(pParse, 0,pSrc,0,0,0,0,0,0,0);
-      ExprSetProperty(yygotominor.yy346.pExpr, EP_xIsSelect);
-      sqlite3ExprSetHeight(pParse, yygotominor.yy346.pExpr);
+      ExprSetProperty(yygotominor.yy346.pExpr, EP_xIsSelect|EP_Subquery);
+      sqlite3ExprSetHeightAndFlags(pParse, yygotominor.yy346.pExpr);
     }else{
       sqlite3SrcListDelete(pParse->db, pSrc);
     }
@@ -124630,8 +126216,8 @@ static void yy_reduce(
     Expr *p = yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_EXISTS, 0, 0, 0);
     if( p ){
       p->x.pSelect = yymsp[-1].minor.yy3;
-      ExprSetProperty(p, EP_xIsSelect);
-      sqlite3ExprSetHeight(pParse, p);
+      ExprSetProperty(p, EP_xIsSelect|EP_Subquery);
+      sqlite3ExprSetHeightAndFlags(pParse, p);
     }else{
       sqlite3SelectDelete(pParse->db, yymsp[-1].minor.yy3);
     }
@@ -124644,7 +126230,7 @@ static void yy_reduce(
   yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_CASE, yymsp[-3].minor.yy132, 0, 0);
   if( yygotominor.yy346.pExpr ){
     yygotominor.yy346.pExpr->x.pList = yymsp[-1].minor.yy132 ? sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy14,yymsp[-1].minor.yy132) : yymsp[-2].minor.yy14;
-    sqlite3ExprSetHeight(pParse, yygotominor.yy346.pExpr);
+    sqlite3ExprSetHeightAndFlags(pParse, yygotominor.yy346.pExpr);
   }else{
     sqlite3ExprListDelete(pParse->db, yymsp[-2].minor.yy14);
     sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy132);
@@ -124687,7 +126273,7 @@ static void yy_reduce(
         break;
       case 244: /* idxlist ::= idxlist COMMA nm collate sortorder */
 {
-  Expr *p = sqlite3ExprAddCollateToken(pParse, 0, &yymsp[-1].minor.yy0);
+  Expr *p = sqlite3ExprAddCollateToken(pParse, 0, &yymsp[-1].minor.yy0, 1);
   yygotominor.yy14 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy14, p);
   sqlite3ExprListSetName(pParse,yygotominor.yy14,&yymsp[-2].minor.yy0,1);
   sqlite3ExprListCheckLength(pParse, yygotominor.yy14, "index");
@@ -124696,7 +126282,7 @@ static void yy_reduce(
         break;
       case 245: /* idxlist ::= nm collate sortorder */
 {
-  Expr *p = sqlite3ExprAddCollateToken(pParse, 0, &yymsp[-1].minor.yy0);
+  Expr *p = sqlite3ExprAddCollateToken(pParse, 0, &yymsp[-1].minor.yy0, 1);
   yygotominor.yy14 = sqlite3ExprListAppend(pParse,0, p);
   sqlite3ExprListSetName(pParse, yygotominor.yy14, &yymsp[-2].minor.yy0, 1);
   sqlite3ExprListCheckLength(pParse, yygotominor.yy14, "index");
@@ -125886,10 +127472,7 @@ SQLITE_PRIVATE int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzEr
   sqlite3 *db = pParse->db;       /* The database connection */
   int mxSqlLen;                   /* Max length of an SQL string */
 
-
-#ifdef SQLITE_ENABLE_API_ARMOR
-  if( zSql==0 || pzErrMsg==0 ) return SQLITE_MISUSE_BKPT;
-#endif
+  assert( zSql!=0 );
   mxSqlLen = db->aLimit[SQLITE_LIMIT_SQL_LENGTH];
   if( db->nVdbeActive==0 ){
     db->u1.isInterrupted = 0;
@@ -125929,10 +127512,8 @@ SQLITE_PRIVATE int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzEr
         break;
       }
       case TK_ILLEGAL: {
-        sqlite3DbFree(db, *pzErrMsg);
-        *pzErrMsg = sqlite3MPrintf(db, "unrecognized token: \"%T\"",
+        sqlite3ErrorMsg(pParse, "unrecognized token: \"%T\"",
                         &pParse->sLastToken);
-        nErr++;
         goto abort_parse;
       }
       case TK_SEMI: {
@@ -125950,17 +127531,22 @@ SQLITE_PRIVATE int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzEr
     }
   }
 abort_parse:
-  if( zSql[i]==0 && nErr==0 && pParse->rc==SQLITE_OK ){
+  assert( nErr==0 );
+  if( zSql[i]==0 && pParse->rc==SQLITE_OK && db->mallocFailed==0 ){
     if( lastTokenParsed!=TK_SEMI ){
       sqlite3Parser(pEngine, TK_SEMI, pParse->sLastToken, pParse);
       pParse->zTail = &zSql[i];
     }
-    sqlite3Parser(pEngine, 0, pParse->sLastToken, pParse);
+    if( pParse->rc==SQLITE_OK && db->mallocFailed==0 ){
+      sqlite3Parser(pEngine, 0, pParse->sLastToken, pParse);
+    }
   }
 #ifdef YYTRACKMAXSTACKDEPTH
+  sqlite3_mutex_enter(sqlite3MallocMutex());
   sqlite3StatusSet(SQLITE_STATUS_PARSER_STACK,
       sqlite3ParserStackPeak(pEngine)
   );
+  sqlite3_mutex_leave(sqlite3MallocMutex());
 #endif /* YYDEBUG */
   sqlite3ParserFree(pEngine, sqlite3_free);
   db->lookaside.bEnabled = enableLookaside;
@@ -126014,9 +127600,7 @@ SQLITE_PRIVATE int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzEr
     pParse->pZombieTab = p->pNextZombie;
     sqlite3DeleteTable(db, p);
   }
-  if( nErr>0 && pParse->rc==SQLITE_OK ){
-    pParse->rc = SQLITE_ERROR;
-  }
+  assert( nErr==0 || pParse->rc!=SQLITE_OK );
   return nErr;
 }
 
@@ -126124,7 +127708,7 @@ SQLITE_PRIVATE const char sqlite3IsEbcdicIdChar[];
 ** to recognize the end of a trigger can be omitted.  All we have to do
 ** is look for a semicolon that is not part of an string or comment.
 */
-SQLITE_API int sqlite3_complete(const char *zSql){
+SQLITE_API int SQLITE_STDCALL sqlite3_complete(const char *zSql){
   u8 state = 0;   /* Current state, using numbers defined in header comment */
   u8 token;       /* Value of the next token */
 
@@ -126289,10 +127873,10 @@ SQLITE_API int sqlite3_complete(const char *zSql){
 ** above, except that the parameter is required to be UTF-16 encoded, not
 ** UTF-8.
 */
-SQLITE_API int sqlite3_complete16(const void *zSql){
+SQLITE_API int SQLITE_STDCALL sqlite3_complete16(const void *zSql){
   sqlite3_value *pVal;
   char const *zSql8;
-  int rc = SQLITE_NOMEM;
+  int rc;
 
 #ifndef SQLITE_OMIT_AUTOINIT
   rc = sqlite3_initialize();
@@ -126439,24 +128023,36 @@ SQLITE_API const char sqlite3_version[] = SQLITE_VERSION;
 /* IMPLEMENTATION-OF: R-53536-42575 The sqlite3_libversion() function returns
 ** a pointer to the to the sqlite3_version[] string constant. 
 */
-SQLITE_API const char *sqlite3_libversion(void){ return sqlite3_version; }
+SQLITE_API const char *SQLITE_STDCALL sqlite3_libversion(void){ return sqlite3_version; }
 
 /* IMPLEMENTATION-OF: R-63124-39300 The sqlite3_sourceid() function returns a
 ** pointer to a string constant whose value is the same as the
 ** SQLITE_SOURCE_ID C preprocessor macro. 
 */
-SQLITE_API const char *sqlite3_sourceid(void){ return SQLITE_SOURCE_ID; }
+SQLITE_API const char *SQLITE_STDCALL sqlite3_sourceid(void){ return SQLITE_SOURCE_ID; }
 
 /* IMPLEMENTATION-OF: R-35210-63508 The sqlite3_libversion_number() function
 ** returns an integer equal to SQLITE_VERSION_NUMBER.
 */
-SQLITE_API int sqlite3_libversion_number(void){ return SQLITE_VERSION_NUMBER; }
+SQLITE_API int SQLITE_STDCALL sqlite3_libversion_number(void){ return SQLITE_VERSION_NUMBER; }
 
 /* IMPLEMENTATION-OF: R-20790-14025 The sqlite3_threadsafe() function returns
 ** zero if and only if SQLite was compiled with mutexing code omitted due to
 ** the SQLITE_THREADSAFE compile-time option being set to 0.
 */
-SQLITE_API int sqlite3_threadsafe(void){ return SQLITE_THREADSAFE; }
+SQLITE_API int SQLITE_STDCALL sqlite3_threadsafe(void){ return SQLITE_THREADSAFE; }
+
+/*
+** When compiling the test fixture or with debugging enabled (on Win32),
+** this variable being set to non-zero will cause OSTRACE macros to emit
+** extra diagnostic information.
+*/
+#ifdef SQLITE_HAVE_OS_TRACE
+# ifndef SQLITE_DEBUG_OS_TRACE
+#   define SQLITE_DEBUG_OS_TRACE 0
+# endif
+  int sqlite3OSTrace = SQLITE_DEBUG_OS_TRACE;
+#endif
 
 #if !defined(SQLITE_OMIT_TRACE) && defined(SQLITE_ENABLE_IOTRACE)
 /*
@@ -126465,7 +128061,7 @@ SQLITE_API int sqlite3_threadsafe(void){ return SQLITE_THREADSAFE; }
 ** I/O active are written using this function.  These messages
 ** are intended for debugging activity only.
 */
-/* not-private */ void (*sqlite3IoTrace)(const char*, ...) = 0;
+SQLITE_API void (SQLITE_CDECL *sqlite3IoTrace)(const char*, ...) = 0;
 #endif
 
 /*
@@ -126517,7 +128113,7 @@ SQLITE_API char *sqlite3_data_directory = 0;
 **    *  Recursive calls to this routine from thread X return immediately
 **       without blocking.
 */
-SQLITE_API int sqlite3_initialize(void){
+SQLITE_API int SQLITE_STDCALL sqlite3_initialize(void){
   MUTEX_LOGIC( sqlite3_mutex *pMaster; )       /* The main static mutex */
   int rc;                                      /* Result code */
 #ifdef SQLITE_EXTRA_INIT
@@ -126531,6 +128127,11 @@ SQLITE_API int sqlite3_initialize(void){
   }
 #endif
 
+  /* If the following assert() fails on some obscure processor/compiler
+  ** combination, the work-around is to set the correct pointer
+  ** size at compile-time using -DSQLITE_PTRSIZE=n compile-time option */
+  assert( SQLITE_PTRSIZE==sizeof(char*) );
+
   /* If SQLite is already completely initialized, then this call
   ** to sqlite3_initialize() should be a no-op.  But the initialization
   ** must be complete.  So isInit must not be set until the very end
@@ -126673,7 +128274,7 @@ SQLITE_API int sqlite3_initialize(void){
 ** on when SQLite is already shut down.  If SQLite is already shut down
 ** when this routine is invoked, then this routine is a harmless no-op.
 */
-SQLITE_API int sqlite3_shutdown(void){
+SQLITE_API int SQLITE_STDCALL sqlite3_shutdown(void){
 #ifdef SQLITE_OMIT_WSD
   int rc = sqlite3_wsd_init(4096, 24);
   if( rc!=SQLITE_OK ){
@@ -126727,7 +128328,7 @@ SQLITE_API int sqlite3_shutdown(void){
 ** threadsafe.  Failure to heed these warnings can lead to unpredictable
 ** behavior.
 */
-SQLITE_API int sqlite3_config(int op, ...){
+SQLITE_API int SQLITE_CDECL sqlite3_config(int op, ...){
   va_list ap;
   int rc = SQLITE_OK;
 
@@ -126743,26 +128344,28 @@ SQLITE_API int sqlite3_config(int op, ...){
     */
 #if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0  /* IMP: R-54466-46756 */
     case SQLITE_CONFIG_SINGLETHREAD: {
-      /* Disable all mutexing */
-      sqlite3GlobalConfig.bCoreMutex = 0;
-      sqlite3GlobalConfig.bFullMutex = 0;
+      /* EVIDENCE-OF: R-02748-19096 This option sets the threading mode to
+      ** Single-thread. */
+      sqlite3GlobalConfig.bCoreMutex = 0;  /* Disable mutex on core */
+      sqlite3GlobalConfig.bFullMutex = 0;  /* Disable mutex on connections */
       break;
     }
 #endif
 #if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0 /* IMP: R-20520-54086 */
     case SQLITE_CONFIG_MULTITHREAD: {
-      /* Disable mutexing of database connections */
-      /* Enable mutexing of core data structures */
-      sqlite3GlobalConfig.bCoreMutex = 1;
-      sqlite3GlobalConfig.bFullMutex = 0;
+      /* EVIDENCE-OF: R-14374-42468 This option sets the threading mode to
+      ** Multi-thread. */
+      sqlite3GlobalConfig.bCoreMutex = 1;  /* Enable mutex on core */
+      sqlite3GlobalConfig.bFullMutex = 0;  /* Disable mutex on connections */
       break;
     }
 #endif
 #if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0 /* IMP: R-59593-21810 */
     case SQLITE_CONFIG_SERIALIZED: {
-      /* Enable all mutexing */
-      sqlite3GlobalConfig.bCoreMutex = 1;
-      sqlite3GlobalConfig.bFullMutex = 1;
+      /* EVIDENCE-OF: R-41220-51800 This option sets the threading mode to
+      ** Serialized. */
+      sqlite3GlobalConfig.bCoreMutex = 1;  /* Enable mutex on core */
+      sqlite3GlobalConfig.bFullMutex = 1;  /* Enable mutex on connections */
       break;
     }
 #endif
@@ -126874,7 +128477,8 @@ SQLITE_API int sqlite3_config(int op, ...){
     case SQLITE_CONFIG_HEAP: {
       /* EVIDENCE-OF: R-19854-42126 There are three arguments to
       ** SQLITE_CONFIG_HEAP: An 8-byte aligned pointer to the memory, the
-      ** number of bytes in the memory buffer, and the minimum allocation size. */
+      ** number of bytes in the memory buffer, and the minimum allocation size.
+      */
       sqlite3GlobalConfig.pHeap = va_arg(ap, void*);
       sqlite3GlobalConfig.nHeap = va_arg(ap, int);
       sqlite3GlobalConfig.mnReq = va_arg(ap, int);
@@ -126979,7 +128583,9 @@ SQLITE_API int sqlite3_config(int op, ...){
       ** compile-time maximum mmap size set by the SQLITE_MAX_MMAP_SIZE
       ** compile-time option.
       */
-      if( mxMmap<0 || mxMmap>SQLITE_MAX_MMAP_SIZE ) mxMmap = SQLITE_MAX_MMAP_SIZE;
+      if( mxMmap<0 || mxMmap>SQLITE_MAX_MMAP_SIZE ){
+        mxMmap = SQLITE_MAX_MMAP_SIZE;
+      }
       if( szMmap<0 ) szMmap = SQLITE_DEFAULT_MMAP_SIZE;
       if( szMmap>mxMmap) szMmap = mxMmap;
       sqlite3GlobalConfig.mxMmap = mxMmap;
@@ -127079,7 +128685,7 @@ static int setupLookaside(sqlite3 *db, void *pBuf, int sz, int cnt){
 /*
 ** Return the mutex associated with a database connection.
 */
-SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3 *db){
+SQLITE_API sqlite3_mutex *SQLITE_STDCALL sqlite3_db_mutex(sqlite3 *db){
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
     (void)SQLITE_MISUSE_BKPT;
@@ -127093,7 +128699,7 @@ SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3 *db){
 ** Free up as much memory as we can from the given database
 ** connection.
 */
-SQLITE_API int sqlite3_db_release_memory(sqlite3 *db){
+SQLITE_API int SQLITE_STDCALL sqlite3_db_release_memory(sqlite3 *db){
   int i;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
@@ -127116,7 +128722,7 @@ SQLITE_API int sqlite3_db_release_memory(sqlite3 *db){
 /*
 ** Configuration settings for an individual database connection
 */
-SQLITE_API int sqlite3_db_config(sqlite3 *db, int op, ...){
+SQLITE_API int SQLITE_CDECL sqlite3_db_config(sqlite3 *db, int op, ...){
   va_list ap;
   int rc;
   va_start(ap, op);
@@ -127235,7 +128841,7 @@ static int nocaseCollatingFunc(
 /*
 ** Return the ROWID of the most recent insert
 */
-SQLITE_API sqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db){
+SQLITE_API sqlite_int64 SQLITE_STDCALL sqlite3_last_insert_rowid(sqlite3 *db){
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
     (void)SQLITE_MISUSE_BKPT;
@@ -127248,7 +128854,7 @@ SQLITE_API sqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db){
 /*
 ** Return the number of changes in the most recent call to sqlite3_exec().
 */
-SQLITE_API int sqlite3_changes(sqlite3 *db){
+SQLITE_API int SQLITE_STDCALL sqlite3_changes(sqlite3 *db){
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
     (void)SQLITE_MISUSE_BKPT;
@@ -127261,7 +128867,7 @@ SQLITE_API int sqlite3_changes(sqlite3 *db){
 /*
 ** Return the number of changes since the database handle was opened.
 */
-SQLITE_API int sqlite3_total_changes(sqlite3 *db){
+SQLITE_API int SQLITE_STDCALL sqlite3_total_changes(sqlite3 *db){
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
     (void)SQLITE_MISUSE_BKPT;
@@ -127403,8 +129009,8 @@ static int sqlite3Close(sqlite3 *db, int forceZombie){
 ** unclosed resources, and arranges for deallocation when the last
 ** prepare statement or sqlite3_backup closes.
 */
-SQLITE_API int sqlite3_close(sqlite3 *db){ return sqlite3Close(db,0); }
-SQLITE_API int sqlite3_close_v2(sqlite3 *db){ return sqlite3Close(db,1); }
+SQLITE_API int SQLITE_STDCALL sqlite3_close(sqlite3 *db){ return sqlite3Close(db,0); }
+SQLITE_API int SQLITE_STDCALL sqlite3_close_v2(sqlite3 *db){ return sqlite3Close(db,1); }
 
 
 /*
@@ -127587,7 +129193,7 @@ SQLITE_PRIVATE void sqlite3RollbackAll(sqlite3 *db, int tripCode){
 ** Return a static string containing the name corresponding to the error code
 ** specified in the argument.
 */
-#if (defined(SQLITE_DEBUG) && SQLITE_OS_WIN) || defined(SQLITE_TEST)
+#if defined(SQLITE_NEED_ERR_NAME)
 SQLITE_PRIVATE const char *sqlite3ErrName(int rc){
   const char *zName = 0;
   int i, origRc = rc;
@@ -127811,13 +129417,13 @@ SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler *p){
 ** This routine sets the busy callback for an Sqlite database to the
 ** given callback function with the given argument.
 */
-SQLITE_API int sqlite3_busy_handler(
+SQLITE_API int SQLITE_STDCALL sqlite3_busy_handler(
   sqlite3 *db,
   int (*xBusy)(void*,int),
   void *pArg
 ){
 #ifdef SQLITE_ENABLE_API_ARMOR
-  if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE;
+  if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
 #endif
   sqlite3_mutex_enter(db->mutex);
   db->busyHandler.xFunc = xBusy;
@@ -127834,7 +129440,7 @@ SQLITE_API int sqlite3_busy_handler(
 ** given callback function with the given argument. The progress callback will
 ** be invoked every nOps opcodes.
 */
-SQLITE_API void sqlite3_progress_handler(
+SQLITE_API void SQLITE_STDCALL sqlite3_progress_handler(
   sqlite3 *db, 
   int nOps,
   int (*xProgress)(void*), 
@@ -127865,7 +129471,7 @@ SQLITE_API void sqlite3_progress_handler(
 ** This routine installs a default busy handler that waits for the
 ** specified number of milliseconds before returning 0.
 */
-SQLITE_API int sqlite3_busy_timeout(sqlite3 *db, int ms){
+SQLITE_API int SQLITE_STDCALL sqlite3_busy_timeout(sqlite3 *db, int ms){
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
 #endif
@@ -127881,7 +129487,7 @@ SQLITE_API int sqlite3_busy_timeout(sqlite3 *db, int ms){
 /*
 ** Cause any pending operation to stop at its earliest opportunity.
 */
-SQLITE_API void sqlite3_interrupt(sqlite3 *db){
+SQLITE_API void SQLITE_STDCALL sqlite3_interrupt(sqlite3 *db){
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
     (void)SQLITE_MISUSE_BKPT;
@@ -127998,7 +129604,7 @@ SQLITE_PRIVATE int sqlite3CreateFunc(
 /*
 ** Create new user functions.
 */
-SQLITE_API int sqlite3_create_function(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_function(
   sqlite3 *db,
   const char *zFunc,
   int nArg,
@@ -128012,7 +129618,7 @@ SQLITE_API int sqlite3_create_function(
                                     xFinal, 0);
 }
 
-SQLITE_API int sqlite3_create_function_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_function_v2(
   sqlite3 *db,
   const char *zFunc,
   int nArg,
@@ -128055,7 +129661,7 @@ SQLITE_API int sqlite3_create_function_v2(
 }
 
 #ifndef SQLITE_OMIT_UTF16
-SQLITE_API int sqlite3_create_function16(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_function16(
   sqlite3 *db,
   const void *zFunctionName,
   int nArg,
@@ -128095,7 +129701,7 @@ SQLITE_API int sqlite3_create_function16(
 ** A global function must exist in order for name resolution to work
 ** properly.
 */
-SQLITE_API int sqlite3_overload_function(
+SQLITE_API int SQLITE_STDCALL sqlite3_overload_function(
   sqlite3 *db,
   const char *zName,
   int nArg
@@ -128127,7 +129733,7 @@ SQLITE_API int sqlite3_overload_function(
 ** trace is a pointer to a function that is invoked at the start of each
 ** SQL statement.
 */
-SQLITE_API void *sqlite3_trace(sqlite3 *db, void (*xTrace)(void*,const char*), void *pArg){
+SQLITE_API void *SQLITE_STDCALL sqlite3_trace(sqlite3 *db, void (*xTrace)(void*,const char*), void *pArg){
   void *pOld;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
@@ -128151,7 +129757,7 @@ SQLITE_API void *sqlite3_trace(sqlite3 *db, void (*xTrace)(void*,const char*), v
 ** profile is a pointer to a function that is invoked at the conclusion of
 ** each SQL statement that is run.
 */
-SQLITE_API void *sqlite3_profile(
+SQLITE_API void *SQLITE_STDCALL sqlite3_profile(
   sqlite3 *db,
   void (*xProfile)(void*,const char*,sqlite_uint64),
   void *pArg
@@ -128178,7 +129784,7 @@ SQLITE_API void *sqlite3_profile(
 ** If the invoked function returns non-zero, then the commit becomes a
 ** rollback.
 */
-SQLITE_API void *sqlite3_commit_hook(
+SQLITE_API void *SQLITE_STDCALL sqlite3_commit_hook(
   sqlite3 *db,              /* Attach the hook to this database */
   int (*xCallback)(void*),  /* Function to invoke on each commit */
   void *pArg                /* Argument to the function */
@@ -128203,7 +129809,7 @@ SQLITE_API void *sqlite3_commit_hook(
 ** Register a callback to be invoked each time a row is updated,
 ** inserted or deleted using this database connection.
 */
-SQLITE_API void *sqlite3_update_hook(
+SQLITE_API void *SQLITE_STDCALL sqlite3_update_hook(
   sqlite3 *db,              /* Attach the hook to this database */
   void (*xCallback)(void*,int,char const *,char const *,sqlite_int64),
   void *pArg                /* Argument to the function */
@@ -128228,7 +129834,7 @@ SQLITE_API void *sqlite3_update_hook(
 ** Register a callback to be invoked each time a transaction is rolled
 ** back by this database connection.
 */
-SQLITE_API void *sqlite3_rollback_hook(
+SQLITE_API void *SQLITE_STDCALL sqlite3_rollback_hook(
   sqlite3 *db,              /* Attach the hook to this database */
   void (*xCallback)(void*), /* Callback function */
   void *pArg                /* Argument to the function */
@@ -128282,7 +129888,7 @@ SQLITE_PRIVATE int sqlite3WalDefaultHook(
 ** using sqlite3_wal_hook() disables the automatic checkpoint mechanism
 ** configured by this function.
 */
-SQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int nFrame){
+SQLITE_API int SQLITE_STDCALL sqlite3_wal_autocheckpoint(sqlite3 *db, int nFrame){
 #ifdef SQLITE_OMIT_WAL
   UNUSED_PARAMETER(db);
   UNUSED_PARAMETER(nFrame);
@@ -128303,7 +129909,7 @@ SQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int nFrame){
 ** Register a callback to be invoked each time a transaction is written
 ** into the write-ahead-log by this database connection.
 */
-SQLITE_API void *sqlite3_wal_hook(
+SQLITE_API void *SQLITE_STDCALL sqlite3_wal_hook(
   sqlite3 *db,                    /* Attach the hook to this db handle */
   int(*xCallback)(void *, sqlite3*, const char*, int),
   void *pArg                      /* First argument passed to xCallback() */
@@ -128330,7 +129936,7 @@ SQLITE_API void *sqlite3_wal_hook(
 /*
 ** Checkpoint database zDb.
 */
-SQLITE_API int sqlite3_wal_checkpoint_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_wal_checkpoint_v2(
   sqlite3 *db,                    /* Database handle */
   const char *zDb,                /* Name of attached database (or NULL) */
   int eMode,                      /* SQLITE_CHECKPOINT_* value */
@@ -128369,6 +129975,7 @@ SQLITE_API int sqlite3_wal_checkpoint_v2(
     rc = SQLITE_ERROR;
     sqlite3ErrorWithMsg(db, SQLITE_ERROR, "unknown database: %s", zDb);
   }else{
+    db->busyHandler.nBusy = 0;
     rc = sqlite3Checkpoint(db, iDb, eMode, pnLog, pnCkpt);
     sqlite3Error(db, rc);
   }
@@ -128384,7 +129991,7 @@ SQLITE_API int sqlite3_wal_checkpoint_v2(
 ** to contains a zero-length string, all attached databases are 
 ** checkpointed.
 */
-SQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb){
+SQLITE_API int SQLITE_STDCALL sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb){
   /* EVIDENCE-OF: R-41613-20553 The sqlite3_wal_checkpoint(D,X) is equivalent to
   ** sqlite3_wal_checkpoint_v2(D,X,SQLITE_CHECKPOINT_PASSIVE,0,0). */
   return sqlite3_wal_checkpoint_v2(db,zDb,SQLITE_CHECKPOINT_PASSIVE,0,0);
@@ -128473,7 +130080,7 @@ SQLITE_PRIVATE int sqlite3TempInMemory(const sqlite3 *db){
 ** Return UTF-8 encoded English language explanation of the most recent
 ** error.
 */
-SQLITE_API const char *sqlite3_errmsg(sqlite3 *db){
+SQLITE_API const char *SQLITE_STDCALL sqlite3_errmsg(sqlite3 *db){
   const char *z;
   if( !db ){
     return sqlite3ErrStr(SQLITE_NOMEM);
@@ -128501,7 +130108,7 @@ SQLITE_API const char *sqlite3_errmsg(sqlite3 *db){
 ** Return UTF-16 encoded English language explanation of the most recent
 ** error.
 */
-SQLITE_API const void *sqlite3_errmsg16(sqlite3 *db){
+SQLITE_API const void *SQLITE_STDCALL sqlite3_errmsg16(sqlite3 *db){
   static const u16 outOfMem[] = {
     'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', 0
   };
@@ -128546,7 +130153,7 @@ SQLITE_API const void *sqlite3_errmsg16(sqlite3 *db){
 ** Return the most recent error code generated by an SQLite routine. If NULL is
 ** passed to this function, we assume a malloc() failed during sqlite3_open().
 */
-SQLITE_API int sqlite3_errcode(sqlite3 *db){
+SQLITE_API int SQLITE_STDCALL sqlite3_errcode(sqlite3 *db){
   if( db && !sqlite3SafetyCheckSickOrOk(db) ){
     return SQLITE_MISUSE_BKPT;
   }
@@ -128555,7 +130162,7 @@ SQLITE_API int sqlite3_errcode(sqlite3 *db){
   }
   return db->errCode & db->errMask;
 }
-SQLITE_API int sqlite3_extended_errcode(sqlite3 *db){
+SQLITE_API int SQLITE_STDCALL sqlite3_extended_errcode(sqlite3 *db){
   if( db && !sqlite3SafetyCheckSickOrOk(db) ){
     return SQLITE_MISUSE_BKPT;
   }
@@ -128570,7 +130177,7 @@ SQLITE_API int sqlite3_extended_errcode(sqlite3 *db){
 ** argument.  For now, this simply calls the internal sqlite3ErrStr()
 ** function.
 */
-SQLITE_API const char *sqlite3_errstr(int rc){
+SQLITE_API const char *SQLITE_STDCALL sqlite3_errstr(int rc){
   return sqlite3ErrStr(rc);
 }
 
@@ -128718,7 +130325,7 @@ static const int aHardLimit[] = {
 ** It merely prevents new constructs that exceed the limit
 ** from forming.
 */
-SQLITE_API int sqlite3_limit(sqlite3 *db, int limitId, int newLimit){
+SQLITE_API int SQLITE_STDCALL sqlite3_limit(sqlite3 *db, int limitId, int newLimit){
   int oldLimit;
 
 #ifdef SQLITE_ENABLE_API_ARMOR
@@ -128811,18 +130418,30 @@ SQLITE_PRIVATE int sqlite3ParseUri(
     int eState;                   /* Parser state when parsing URI */
     int iIn;                      /* Input character index */
     int iOut = 0;                 /* Output character index */
-    int nByte = nUri+2;           /* Bytes of space to allocate */
+    u64 nByte = nUri+2;           /* Bytes of space to allocate */
 
     /* Make sure the SQLITE_OPEN_URI flag is set to indicate to the VFS xOpen 
     ** method that there may be extra parameters following the file-name.  */
     flags |= SQLITE_OPEN_URI;
 
     for(iIn=0; iIn<nUri; iIn++) nByte += (zUri[iIn]=='&');
-    zFile = sqlite3_malloc(nByte);
+    zFile = sqlite3_malloc64(nByte);
     if( !zFile ) return SQLITE_NOMEM;
 
     iIn = 5;
-#ifndef SQLITE_ALLOW_URI_AUTHORITY
+#ifdef SQLITE_ALLOW_URI_AUTHORITY
+    if( strncmp(zUri+5, "///", 3)==0 ){
+      iIn = 7;
+      /* The following condition causes URIs with five leading / characters
+      ** like file://///host/path to be converted into UNCs like //host/path.
+      ** The correct URI for that UNC has only two or four leading / characters
+      ** file://host/path or file:////host/path.  But 5 leading slashes is a 
+      ** common error, we are told, so we handle it as a special case. */
+      if( strncmp(zUri+7, "///", 3)==0 ){ iIn++; }
+    }else if( strncmp(zUri+5, "//localhost/", 12)==0 ){
+      iIn = 16;
+    }
+#else
     /* Discard the scheme and authority segments of the URI. */
     if( zUri[5]=='/' && zUri[6]=='/' ){
       iIn = 7;
@@ -128972,7 +130591,7 @@ SQLITE_PRIVATE int sqlite3ParseUri(
     }
 
   }else{
-    zFile = sqlite3_malloc(nUri+2);
+    zFile = sqlite3_malloc64(nUri+2);
     if( !zFile ) return SQLITE_NOMEM;
     memcpy(zFile, zUri, nUri);
     zFile[nUri] = '\0';
@@ -129109,6 +130728,9 @@ static int openDatabase(
 #if !defined(SQLITE_DEFAULT_AUTOMATIC_INDEX) || SQLITE_DEFAULT_AUTOMATIC_INDEX
                  | SQLITE_AutoIndex
 #endif
+#if SQLITE_DEFAULT_CKPTFULLFSYNC
+                 | SQLITE_CkptFullFSync
+#endif
 #if SQLITE_DEFAULT_FILE_FORMAT<4
                  | SQLITE_LegacyFileFmt
 #endif
@@ -129241,6 +130863,13 @@ static int openDatabase(
   }
 #endif
 
+#ifdef SQLITE_ENABLE_DBSTAT_VTAB
+  if( !db->mallocFailed && rc==SQLITE_OK){
+    int sqlite3_dbstat_register(sqlite3*);
+    rc = sqlite3_dbstat_register(db);
+  }
+#endif
+
   /* -DSQLITE_DEFAULT_LOCKING_MODE=1 makes EXCLUSIVE the default locking
   ** mode.  -DSQLITE_DEFAULT_LOCKING_MODE=0 make NORMAL the default locking
   ** mode.  Doing nothing at all also makes NORMAL the default.
@@ -129262,7 +130891,8 @@ static int openDatabase(
 opendb_out:
   sqlite3_free(zOpen);
   if( db ){
-    assert( db->mutex!=0 || isThreadsafe==0 || sqlite3GlobalConfig.bFullMutex==0 );
+    assert( db->mutex!=0 || isThreadsafe==0
+           || sqlite3GlobalConfig.bFullMutex==0 );
     sqlite3_mutex_leave(db->mutex);
   }
   rc = sqlite3_errcode(db);
@@ -129287,14 +130917,14 @@ static int openDatabase(
 /*
 ** Open a new database handle.
 */
-SQLITE_API int sqlite3_open(
+SQLITE_API int SQLITE_STDCALL sqlite3_open(
   const char *zFilename, 
   sqlite3 **ppDb 
 ){
   return openDatabase(zFilename, ppDb,
                       SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, 0);
 }
-SQLITE_API int sqlite3_open_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_open_v2(
   const char *filename,   /* Database filename (UTF-8) */
   sqlite3 **ppDb,         /* OUT: SQLite db handle */
   int flags,              /* Flags */
@@ -129307,7 +130937,7 @@ SQLITE_API int sqlite3_open_v2(
 /*
 ** Open a new database handle.
 */
-SQLITE_API int sqlite3_open16(
+SQLITE_API int SQLITE_STDCALL sqlite3_open16(
   const void *zFilename, 
   sqlite3 **ppDb
 ){
@@ -129346,7 +130976,7 @@ SQLITE_API int sqlite3_open16(
 /*
 ** Register a new collation sequence with the database handle db.
 */
-SQLITE_API int sqlite3_create_collation(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_collation(
   sqlite3* db, 
   const char *zName, 
   int enc, 
@@ -129359,7 +130989,7 @@ SQLITE_API int sqlite3_create_collation(
 /*
 ** Register a new collation sequence with the database handle db.
 */
-SQLITE_API int sqlite3_create_collation_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_collation_v2(
   sqlite3* db, 
   const char *zName, 
   int enc, 
@@ -129384,7 +131014,7 @@ SQLITE_API int sqlite3_create_collation_v2(
 /*
 ** Register a new collation sequence with the database handle db.
 */
-SQLITE_API int sqlite3_create_collation16(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_collation16(
   sqlite3* db, 
   const void *zName,
   int enc, 
@@ -129414,7 +131044,7 @@ SQLITE_API int sqlite3_create_collation16(
 ** Register a collation sequence factory callback with the database handle
 ** db. Replace any previously installed collation sequence factory.
 */
-SQLITE_API int sqlite3_collation_needed(
+SQLITE_API int SQLITE_STDCALL sqlite3_collation_needed(
   sqlite3 *db, 
   void *pCollNeededArg, 
   void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*)
@@ -129435,7 +131065,7 @@ SQLITE_API int sqlite3_collation_needed(
 ** Register a collation sequence factory callback with the database handle
 ** db. Replace any previously installed collation sequence factory.
 */
-SQLITE_API int sqlite3_collation_needed16(
+SQLITE_API int SQLITE_STDCALL sqlite3_collation_needed16(
   sqlite3 *db, 
   void *pCollNeededArg, 
   void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*)
@@ -129457,7 +131087,7 @@ SQLITE_API int sqlite3_collation_needed16(
 ** This function is now an anachronism. It used to be used to recover from a
 ** malloc() failure, but SQLite now does this automatically.
 */
-SQLITE_API int sqlite3_global_recover(void){
+SQLITE_API int SQLITE_STDCALL sqlite3_global_recover(void){
   return SQLITE_OK;
 }
 #endif
@@ -129468,7 +131098,7 @@ SQLITE_API int sqlite3_global_recover(void){
 ** by default.  Autocommit is disabled by a BEGIN statement and reenabled
 ** by the next COMMIT or ROLLBACK.
 */
-SQLITE_API int sqlite3_get_autocommit(sqlite3 *db){
+SQLITE_API int SQLITE_STDCALL sqlite3_get_autocommit(sqlite3 *db){
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
     (void)SQLITE_MISUSE_BKPT;
@@ -129520,7 +131150,7 @@ SQLITE_PRIVATE int sqlite3CantopenError(int lineno){
 ** SQLite no longer uses thread-specific data so this routine is now a
 ** no-op.  It is retained for historical compatibility.
 */
-SQLITE_API void sqlite3_thread_cleanup(void){
+SQLITE_API void SQLITE_STDCALL sqlite3_thread_cleanup(void){
 }
 #endif
 
@@ -129528,7 +131158,7 @@ SQLITE_API void sqlite3_thread_cleanup(void){
 ** Return meta information about a specific column of a database table.
 ** See comment in sqlite3.h (sqlite.h.in) for details.
 */
-SQLITE_API int sqlite3_table_column_metadata(
+SQLITE_API int SQLITE_STDCALL sqlite3_table_column_metadata(
   sqlite3 *db,                /* Connection handle */
   const char *zDbName,        /* Database name or NULL */
   const char *zTableName,     /* Table name */
@@ -129544,13 +131174,19 @@ SQLITE_API int sqlite3_table_column_metadata(
   Table *pTab = 0;
   Column *pCol = 0;
   int iCol = 0;
-
   char const *zDataType = 0;
   char const *zCollSeq = 0;
   int notnull = 0;
   int primarykey = 0;
   int autoinc = 0;
 
+
+#ifdef SQLITE_ENABLE_API_ARMOR
+  if( !sqlite3SafetyCheckOk(db) || zTableName==0 ){
+    return SQLITE_MISUSE_BKPT;
+  }
+#endif
+
   /* Ensure the database schema has been loaded */
   sqlite3_mutex_enter(db->mutex);
   sqlite3BtreeEnterAll(db);
@@ -129640,7 +131276,7 @@ SQLITE_API int sqlite3_table_column_metadata(
 /*
 ** Sleep for a little while.  Return the amount of time slept.
 */
-SQLITE_API int sqlite3_sleep(int ms){
+SQLITE_API int SQLITE_STDCALL sqlite3_sleep(int ms){
   sqlite3_vfs *pVfs;
   int rc;
   pVfs = sqlite3_vfs_find(0);
@@ -129656,7 +131292,7 @@ SQLITE_API int sqlite3_sleep(int ms){
 /*
 ** Enable or disable the extended result codes.
 */
-SQLITE_API int sqlite3_extended_result_codes(sqlite3 *db, int onoff){
+SQLITE_API int SQLITE_STDCALL sqlite3_extended_result_codes(sqlite3 *db, int onoff){
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
 #endif
@@ -129669,7 +131305,7 @@ SQLITE_API int sqlite3_extended_result_codes(sqlite3 *db, int onoff){
 /*
 ** Invoke the xFileControl method on a particular database.
 */
-SQLITE_API int sqlite3_file_control(sqlite3 *db, const char *zDbName, int op, void *pArg){
+SQLITE_API int SQLITE_STDCALL sqlite3_file_control(sqlite3 *db, const char *zDbName, int op, void *pArg){
   int rc = SQLITE_ERROR;
   Btree *pBtree;
 
@@ -129697,13 +131333,13 @@ SQLITE_API int sqlite3_file_control(sqlite3 *db, const char *zDbName, int op, vo
     sqlite3BtreeLeave(pBtree);
   }
   sqlite3_mutex_leave(db->mutex);
-  return rc;   
+  return rc;
 }
 
 /*
 ** Interface to the testing logic.
 */
-SQLITE_API int sqlite3_test_control(int op, ...){
+SQLITE_API int SQLITE_CDECL sqlite3_test_control(int op, ...){
   int rc = 0;
 #ifndef SQLITE_OMIT_BUILTIN_TEST
   va_list ap;
@@ -130000,6 +131636,35 @@ SQLITE_API int sqlite3_test_control(int op, ...){
       if( sqlite3GlobalConfig.isInit==0 ) rc = SQLITE_ERROR;
       break;
     }
+
+    /*  sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, db, dbName, onOff, tnum);
+    **
+    ** This test control is used to create imposter tables.  "db" is a pointer
+    ** to the database connection.  dbName is the database name (ex: "main" or
+    ** "temp") which will receive the imposter.  "onOff" turns imposter mode on
+    ** or off.  "tnum" is the root page of the b-tree to which the imposter
+    ** table should connect.
+    **
+    ** Enable imposter mode only when the schema has already been parsed.  Then
+    ** run a single CREATE TABLE statement to construct the imposter table in
+    ** the parsed schema.  Then turn imposter mode back off again.
+    **
+    ** If onOff==0 and tnum>0 then reset the schema for all databases, causing
+    ** the schema to be reparsed the next time it is needed.  This has the
+    ** effect of erasing all imposter tables.
+    */
+    case SQLITE_TESTCTRL_IMPOSTER: {
+      sqlite3 *db = va_arg(ap, sqlite3*);
+      sqlite3_mutex_enter(db->mutex);
+      db->init.iDb = sqlite3FindDbName(db, va_arg(ap,const char*));
+      db->init.busy = db->init.imposterTable = va_arg(ap,int);
+      db->init.newTnum = va_arg(ap,int);
+      if( db->init.busy==0 && db->init.newTnum>0 ){
+        sqlite3ResetAllSchemasOfConnection(db);
+      }
+      sqlite3_mutex_leave(db->mutex);
+      break;
+    }
   }
   va_end(ap);
 #endif /* SQLITE_OMIT_BUILTIN_TEST */
@@ -130017,7 +131682,7 @@ SQLITE_API int sqlite3_test_control(int op, ...){
 ** parameter if it exists.  If the parameter does not exist, this routine
 ** returns a NULL pointer.
 */
-SQLITE_API const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam){
+SQLITE_API const char *SQLITE_STDCALL sqlite3_uri_parameter(const char *zFilename, const char *zParam){
   if( zFilename==0 || zParam==0 ) return 0;
   zFilename += sqlite3Strlen30(zFilename) + 1;
   while( zFilename[0] ){
@@ -130032,7 +131697,7 @@ SQLITE_API const char *sqlite3_uri_parameter(const char *zFilename, const char *
 /*
 ** Return a boolean value for a query parameter.
 */
-SQLITE_API int sqlite3_uri_boolean(const char *zFilename, const char *zParam, int bDflt){
+SQLITE_API int SQLITE_STDCALL sqlite3_uri_boolean(const char *zFilename, const char *zParam, int bDflt){
   const char *z = sqlite3_uri_parameter(zFilename, zParam);
   bDflt = bDflt!=0;
   return z ? sqlite3GetBoolean(z, bDflt) : bDflt;
@@ -130041,7 +131706,7 @@ SQLITE_API int sqlite3_uri_boolean(const char *zFilename, const char *zParam, in
 /*
 ** Return a 64-bit integer value for a query parameter.
 */
-SQLITE_API sqlite3_int64 sqlite3_uri_int64(
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_uri_int64(
   const char *zFilename,    /* Filename as passed to xOpen */
   const char *zParam,       /* URI parameter sought */
   sqlite3_int64 bDflt       /* return if parameter is missing */
@@ -130073,7 +131738,7 @@ SQLITE_PRIVATE Btree *sqlite3DbNameToBtree(sqlite3 *db, const char *zDbName){
 ** Return the filename of the database associated with a database
 ** connection.
 */
-SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName){
+SQLITE_API const char *SQLITE_STDCALL sqlite3_db_filename(sqlite3 *db, const char *zDbName){
   Btree *pBt;
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
@@ -130089,7 +131754,7 @@ SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName){
 ** Return 1 if database is read-only or 0 if read/write.  Return -1 if
 ** no such database exists.
 */
-SQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName){
+SQLITE_API int SQLITE_STDCALL sqlite3_db_readonly(sqlite3 *db, const char *zDbName){
   Btree *pBt;
 #ifdef SQLITE_ENABLE_API_ARMOR
   if( !sqlite3SafetyCheckOk(db) ){
@@ -130248,7 +131913,7 @@ static void leaveMutex(void){
 ** on the same "db".  If xNotify==0 then any prior callbacks are immediately
 ** cancelled.
 */
-SQLITE_API int sqlite3_unlock_notify(
+SQLITE_API int SQLITE_STDCALL sqlite3_unlock_notify(
   sqlite3 *db,
   void (*xNotify)(void **, int),
   void *pArg
@@ -131142,6 +132807,11 @@ SQLITE_PRIVATE Fts3HashElem *sqlite3Fts3HashFindElem(const Fts3Hash *, const voi
 #ifdef SQLITE_COVERAGE_TEST
 # define ALWAYS(x) (1)
 # define NEVER(X)  (0)
+#elif defined(SQLITE_DEBUG)
+# define ALWAYS(x) sqlite3Fts3Always((x)!=0)
+# define NEVER(x) sqlite3Fts3Never((x)!=0)
+SQLITE_PRIVATE int sqlite3Fts3Always(int b);
+SQLITE_PRIVATE int sqlite3Fts3Never(int b);
 #else
 # define ALWAYS(x) (x)
 # define NEVER(x)  (x)
@@ -131383,6 +133053,11 @@ struct Fts3Phrase {
   int bIncr;                 /* True if doclist is loaded incrementally */
   int iDoclistToken;
 
+  /* Used by sqlite3Fts3EvalPhrasePoslist() if this is a descendent of an
+  ** OR condition.  */
+  char *pOrPoslist;
+  i64 iOrDocid;
+
   /* Variables below this point are populated by fts3_expr.c when parsing 
   ** a MATCH expression. Everything above is part of the evaluation phase. 
   */
@@ -131537,6 +133212,7 @@ SQLITE_PRIVATE int sqlite3Fts3Incrmerge(Fts3Table*,int,int);
 )
 
 /* fts3.c */
+SQLITE_PRIVATE void sqlite3Fts3ErrMsg(char**,const char*,...);
 SQLITE_PRIVATE int sqlite3Fts3PutVarint(char *, sqlite3_int64);
 SQLITE_PRIVATE int sqlite3Fts3GetVarint(const char *, sqlite_int64 *);
 SQLITE_PRIVATE int sqlite3Fts3GetVarint32(const char *, int *);
@@ -131626,6 +133302,13 @@ static int fts3EvalStart(Fts3Cursor *pCsr);
 static int fts3TermSegReaderCursor(
     Fts3Cursor *, const char *, int, int, Fts3MultiSegReader **);
 
+#ifndef SQLITE_AMALGAMATION
+# if defined(SQLITE_DEBUG)
+SQLITE_PRIVATE int sqlite3Fts3Always(int b) { assert( b ); return b; }
+SQLITE_PRIVATE int sqlite3Fts3Never(int b)  { assert( !b ); return b; }
+# endif
+#endif
+
 /* 
 ** Write a 64-bit variable-length integer to memory starting at p[0].
 ** The length of data written will be between 1 and FTS3_VARINT_MAX bytes.
@@ -131735,7 +133418,7 @@ SQLITE_PRIVATE void sqlite3Fts3Dequote(char *z){
     /* If the first byte was a '[', then the close-quote character is a ']' */
     if( quote=='[' ) quote = ']';  
 
-    while( ALWAYS(z[iIn]) ){
+    while( z[iIn] ){
       if( z[iIn]==quote ){
         if( z[iIn+1]!=quote ) break;
         z[iOut++] = quote;
@@ -131814,6 +133497,17 @@ static int fts3DisconnectMethod(sqlite3_vtab *pVtab){
   return SQLITE_OK;
 }
 
+/*
+** Write an error message into *pzErr
+*/
+SQLITE_PRIVATE void sqlite3Fts3ErrMsg(char **pzErr, const char *zFormat, ...){
+  va_list ap;
+  sqlite3_free(*pzErr);
+  va_start(ap, zFormat);
+  *pzErr = sqlite3_vmprintf(zFormat, ap);
+  va_end(ap);
+}
+
 /*
 ** Construct one or more SQL statements from the format string given
 ** and then evaluate those statements. The success code is written
@@ -132223,11 +133917,16 @@ static char *fts3WriteExprList(Fts3Table *p, const char *zFunc, int *pRc){
 ** This function is used when parsing the "prefix=" FTS4 parameter.
 */
 static int fts3GobbleInt(const char **pp, int *pnOut){
+  const int MAX_NPREFIX = 10000000;
   const char *p;                  /* Iterator pointer */
   int nInt = 0;                   /* Output value */
 
   for(p=*pp; p[0]>='0' && p[0]<='9'; p++){
     nInt = nInt * 10 + (p[0] - '0');
+    if( nInt>MAX_NPREFIX ){
+      nInt = 0;
+      break;
+    }
   }
   if( p==*pp ) return SQLITE_ERROR;
   *pnOut = nInt;
@@ -132270,7 +133969,6 @@ static int fts3PrefixParameter(
 
   aIndex = sqlite3_malloc(sizeof(struct Fts3Index) * nIndex);
   *apIndex = aIndex;
-  *pnIndex = nIndex;
   if( !aIndex ){
     return SQLITE_NOMEM;
   }
@@ -132280,13 +133978,20 @@ static int fts3PrefixParameter(
     const char *p = zParam;
     int i;
     for(i=1; i<nIndex; i++){
-      int nPrefix;
+      int nPrefix = 0;
       if( fts3GobbleInt(&p, &nPrefix) ) return SQLITE_ERROR;
-      aIndex[i].nPrefix = nPrefix;
+      assert( nPrefix>=0 );
+      if( nPrefix==0 ){
+        nIndex--;
+        i--;
+      }else{
+        aIndex[i].nPrefix = nPrefix;
+      }
       p++;
     }
   }
 
+  *pnIndex = nIndex;
   return SQLITE_OK;
 }
 
@@ -132321,7 +134026,8 @@ static int fts3ContentColumns(
   const char *zTbl,               /* Name of content table */
   const char ***pazCol,           /* OUT: Malloc'd array of column names */
   int *pnCol,                     /* OUT: Size of array *pazCol */
-  int *pnStr                      /* OUT: Bytes of string content */
+  int *pnStr,                     /* OUT: Bytes of string content */
+  char **pzErr                    /* OUT: error message */
 ){
   int rc = SQLITE_OK;             /* Return code */
   char *zSql;                     /* "SELECT *" statement on zTbl */  
@@ -132332,6 +134038,9 @@ static int fts3ContentColumns(
     rc = SQLITE_NOMEM;
   }else{
     rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);
+    if( rc!=SQLITE_OK ){
+      sqlite3Fts3ErrMsg(pzErr, "%s", sqlite3_errmsg(db));
+    }
   }
   sqlite3_free(zSql);
 
@@ -132410,7 +134119,7 @@ static int fts3InitVtab(
   const char **aCol;              /* Array of column names */
   sqlite3_tokenizer *pTokenizer = 0;        /* Tokenizer for this table */
 
-  int nIndex;                     /* Size of aIndex[] array */
+  int nIndex = 0;                 /* Size of aIndex[] array */
   struct Fts3Index *aIndex = 0;   /* Array of indexes for this table */
 
   /* The results of parsing supported FTS4 key=value options: */
@@ -132498,13 +134207,13 @@ static int fts3InitVtab(
           }
         }
         if( iOpt==SizeofArray(aFts4Opt) ){
-          *pzErr = sqlite3_mprintf("unrecognized parameter: %s", z);
+          sqlite3Fts3ErrMsg(pzErr, "unrecognized parameter: %s", z);
           rc = SQLITE_ERROR;
         }else{
           switch( iOpt ){
             case 0:               /* MATCHINFO */
               if( strlen(zVal)!=4 || sqlite3_strnicmp(zVal, "fts3", 4) ){
-                *pzErr = sqlite3_mprintf("unrecognized matchinfo: %s", zVal);
+                sqlite3Fts3ErrMsg(pzErr, "unrecognized matchinfo: %s", zVal);
                 rc = SQLITE_ERROR;
               }
               bNoDocsize = 1;
@@ -132532,7 +134241,7 @@ static int fts3InitVtab(
               if( (strlen(zVal)!=3 || sqlite3_strnicmp(zVal, "asc", 3)) 
                && (strlen(zVal)!=4 || sqlite3_strnicmp(zVal, "desc", 4)) 
               ){
-                *pzErr = sqlite3_mprintf("unrecognized order: %s", zVal);
+                sqlite3Fts3ErrMsg(pzErr, "unrecognized order: %s", zVal);
                 rc = SQLITE_ERROR;
               }
               bDescIdx = (zVal[0]=='d' || zVal[0]=='D');
@@ -132583,7 +134292,7 @@ static int fts3InitVtab(
     if( nCol==0 ){
       sqlite3_free((void*)aCol); 
       aCol = 0;
-      rc = fts3ContentColumns(db, argv[1], zContent, &aCol, &nCol, &nString);
+      rc = fts3ContentColumns(db, argv[1], zContent,&aCol,&nCol,&nString,pzErr);
 
       /* If a languageid= option was specified, remove the language id
       ** column from the aCol[] array. */ 
@@ -132618,7 +134327,7 @@ static int fts3InitVtab(
   rc = fts3PrefixParameter(zPrefix, &nIndex, &aIndex);
   if( rc==SQLITE_ERROR ){
     assert( zPrefix );
-    *pzErr = sqlite3_mprintf("error parsing prefix parameter: %s", zPrefix);
+    sqlite3Fts3ErrMsg(pzErr, "error parsing prefix parameter: %s", zPrefix);
   }
   if( rc!=SQLITE_OK ) goto fts3_init_out;
 
@@ -132700,7 +134409,7 @@ static int fts3InitVtab(
   }
   for(i=0; i<nNotindexed; i++){
     if( azNotindexed[i] ){
-      *pzErr = sqlite3_mprintf("no such column: %s", azNotindexed[i]);
+      sqlite3Fts3ErrMsg(pzErr, "no such column: %s", azNotindexed[i]);
       rc = SQLITE_ERROR;
     }
   }
@@ -132708,7 +134417,7 @@ static int fts3InitVtab(
   if( rc==SQLITE_OK && (zCompress==0)!=(zUncompress==0) ){
     char const *zMiss = (zCompress==0 ? "compress" : "uncompress");
     rc = SQLITE_ERROR;
-    *pzErr = sqlite3_mprintf("missing %s parameter in fts4 constructor", zMiss);
+    sqlite3Fts3ErrMsg(pzErr, "missing %s parameter in fts4 constructor", zMiss);
   }
   p->zReadExprlist = fts3ReadExprList(p, zUncompress, &rc);
   p->zWriteExprlist = fts3WriteExprList(p, zCompress, &rc);
@@ -133804,26 +135513,33 @@ static int fts3DoclistOrMerge(
 **
 ** The right-hand input doclist is overwritten by this function.
 */
-static void fts3DoclistPhraseMerge(
+static int fts3DoclistPhraseMerge(
   int bDescDoclist,               /* True if arguments are desc */
   int nDist,                      /* Distance from left to right (1=adjacent) */
   char *aLeft, int nLeft,         /* Left doclist */
-  char *aRight, int *pnRight      /* IN/OUT: Right/output doclist */
+  char **paRight, int *pnRight    /* IN/OUT: Right/output doclist */
 ){
   sqlite3_int64 i1 = 0;
   sqlite3_int64 i2 = 0;
   sqlite3_int64 iPrev = 0;
+  char *aRight = *paRight;
   char *pEnd1 = &aLeft[nLeft];
   char *pEnd2 = &aRight[*pnRight];
   char *p1 = aLeft;
   char *p2 = aRight;
   char *p;
   int bFirstOut = 0;
-  char *aOut = aRight;
+  char *aOut;
 
   assert( nDist>0 );
-
+  if( bDescDoclist ){
+    aOut = sqlite3_malloc(*pnRight + FTS3_VARINT_MAX);
+    if( aOut==0 ) return SQLITE_NOMEM;
+  }else{
+    aOut = aRight;
+  }
   p = aOut;
+
   fts3GetDeltaVarint3(&p1, pEnd1, 0, &i1);
   fts3GetDeltaVarint3(&p2, pEnd2, 0, &i2);
 
@@ -133852,6 +135568,12 @@ static void fts3DoclistPhraseMerge(
   }
 
   *pnRight = (int)(p - aOut);
+  if( bDescDoclist ){
+    sqlite3_free(aRight);
+    *paRight = aOut;
+  }
+
+  return SQLITE_OK;
 }
 
 /*
@@ -133976,8 +135698,22 @@ static int fts3TermSelectMerge(
 ){
   if( pTS->aaOutput[0]==0 ){
     /* If this is the first term selected, copy the doclist to the output
-    ** buffer using memcpy(). */
-    pTS->aaOutput[0] = sqlite3_malloc(nDoclist);
+    ** buffer using memcpy(). 
+    **
+    ** Add FTS3_VARINT_MAX bytes of unused space to the end of the 
+    ** allocation. This is so as to ensure that the buffer is big enough
+    ** to hold the current doclist AND'd with any other doclist. If the
+    ** doclists are stored in order=ASC order, this padding would not be
+    ** required (since the size of [doclistA AND doclistB] is always less
+    ** than or equal to the size of [doclistA] in that case). But this is
+    ** not true for order=DESC. For example, a doclist containing (1, -1) 
+    ** may be smaller than (-1), as in the first example the -1 may be stored
+    ** as a single-byte delta, whereas in the second it must be stored as a
+    ** FTS3_VARINT_MAX byte varint.
+    **
+    ** Similar padding is added in the fts3DoclistOrMerge() function.
+    */
+    pTS->aaOutput[0] = sqlite3_malloc(nDoclist + FTS3_VARINT_MAX + 1);
     pTS->anOutput[0] = nDoclist;
     if( pTS->aaOutput[0] ){
       memcpy(pTS->aaOutput[0], aDoclist, nDoclist);
@@ -134074,7 +135810,7 @@ static int fts3SegReaderCursor(
   ** calls out here.  */
   if( iLevel<0 && p->aIndex ){
     Fts3SegReader *pSeg = 0;
-    rc = sqlite3Fts3SegReaderPending(p, iIndex, zTerm, nTerm, isPrefix, &pSeg);
+    rc = sqlite3Fts3SegReaderPending(p, iIndex, zTerm, nTerm, isPrefix||isScan, &pSeg);
     if( rc==SQLITE_OK && pSeg ){
       rc = fts3SegReaderCursorAppend(pCsr, pSeg);
     }
@@ -134477,10 +136213,17 @@ static int fts3FilterMethod(
   ** row by docid.
   */
   if( eSearch==FTS3_FULLSCAN_SEARCH ){
-    zSql = sqlite3_mprintf(
-        "SELECT %s ORDER BY rowid %s",
-        p->zReadExprlist, (pCsr->bDesc ? "DESC" : "ASC")
-    );
+    if( pDocidGe || pDocidLe ){
+      zSql = sqlite3_mprintf(
+          "SELECT %s WHERE rowid BETWEEN %lld AND %lld ORDER BY rowid %s",
+          p->zReadExprlist, pCsr->iMinDocid, pCsr->iMaxDocid,
+          (pCsr->bDesc ? "DESC" : "ASC")
+      );
+    }else{
+      zSql = sqlite3_mprintf("SELECT %s ORDER BY rowid %s", 
+          p->zReadExprlist, (pCsr->bDesc ? "DESC" : "ASC")
+      );
+    }
     if( zSql ){
       rc = sqlite3_prepare_v2(p->db, zSql, -1, &pCsr->pStmt, 0);
       sqlite3_free(zSql);
@@ -134716,11 +136459,31 @@ static void fts3ReversePoslist(char *pStart, char **ppPoslist){
   char *p = &(*ppPoslist)[-2];
   char c = 0;
 
+  /* Skip backwards passed any trailing 0x00 bytes added by NearTrim() */
   while( p>pStart && (c=*p--)==0 );
+
+  /* Search backwards for a varint with value zero (the end of the previous 
+  ** poslist). This is an 0x00 byte preceded by some byte that does not
+  ** have the 0x80 bit set.  */
   while( p>pStart && (*p & 0x80) | c ){ 
     c = *p--; 
   }
-  if( p>pStart ){ p = &p[2]; }
+  assert( p==pStart || c==0 );
+
+  /* At this point p points to that preceding byte without the 0x80 bit
+  ** set. So to find the start of the poslist, skip forward 2 bytes then
+  ** over a varint. 
+  **
+  ** Normally. The other case is that p==pStart and the poslist to return
+  ** is the first in the doclist. In this case do not skip forward 2 bytes.
+  ** The second part of the if condition (c==0 && *ppPoslist>&p[2])
+  ** is required for cases where the first byte of a doclist and the
+  ** doclist is empty. For example, if the first docid is 10, a doclist
+  ** that begins with:
+  **
+  **   0x0A 0x00 <next docid delta varint>
+  */
+  if( p>pStart || (c==0 && *ppPoslist>&p[2]) ){ p = &p[2]; }
   while( *p++&0x80 );
   *ppPoslist = p;
 }
@@ -134791,6 +136554,8 @@ static void fts3SnippetFunc(
   }
   if( !zEllipsis || !zEnd || !zStart ){
     sqlite3_result_error_nomem(pContext);
+  }else if( nToken==0 ){
+    sqlite3_result_text(pContext, "", -1, SQLITE_STATIC);
   }else if( SQLITE_OK==fts3CursorSeek(pContext, pCsr) ){
     sqlite3Fts3Snippet(pContext, pCsr, zStart, zEnd, zEllipsis, iCol, nToken);
   }
@@ -135226,14 +136991,17 @@ static void fts3EvalAllocateReaders(
 ** This function assumes that pList points to a buffer allocated using
 ** sqlite3_malloc(). This function takes responsibility for eventually
 ** freeing the buffer.
+**
+** SQLITE_OK is returned if successful, or SQLITE_NOMEM if an error occurs.
 */
-static void fts3EvalPhraseMergeToken(
+static int fts3EvalPhraseMergeToken(
   Fts3Table *pTab,                /* FTS Table pointer */
   Fts3Phrase *p,                  /* Phrase to merge pList/nList into */
   int iToken,                     /* Token pList/nList corresponds to */
   char *pList,                    /* Pointer to doclist */
   int nList                       /* Number of bytes in pList */
 ){
+  int rc = SQLITE_OK;
   assert( iToken!=p->iDoclistToken );
 
   if( pList==0 ){
@@ -135272,13 +137040,16 @@ static void fts3EvalPhraseMergeToken(
       nDiff = p->iDoclistToken - iToken;
     }
 
-    fts3DoclistPhraseMerge(pTab->bDescIdx, nDiff, pLeft, nLeft, pRight,&nRight);
+    rc = fts3DoclistPhraseMerge(
+        pTab->bDescIdx, nDiff, pLeft, nLeft, &pRight, &nRight
+    );
     sqlite3_free(pLeft);
     p->doclist.aAll = pRight;
     p->doclist.nAll = nRight;
   }
 
   if( iToken>p->iDoclistToken ) p->iDoclistToken = iToken;
+  return rc;
 }
 
 /*
@@ -135304,7 +137075,7 @@ static int fts3EvalPhraseLoad(
       char *pThis = 0;
       rc = fts3TermSelect(pTab, pToken, p->iColumn, &nThis, &pThis);
       if( rc==SQLITE_OK ){
-        fts3EvalPhraseMergeToken(pTab, p, iToken, pThis, nThis);
+        rc = fts3EvalPhraseMergeToken(pTab, p, iToken, pThis, nThis);
       }
     }
     assert( pToken->pSegcsr==0 );
@@ -135846,12 +137617,14 @@ static void fts3EvalStartReaders(
 ){
   if( pExpr && SQLITE_OK==*pRc ){
     if( pExpr->eType==FTSQUERY_PHRASE ){
-      int i;
       int nToken = pExpr->pPhrase->nToken;
-      for(i=0; i<nToken; i++){
-        if( pExpr->pPhrase->aToken[i].pDeferred==0 ) break;
+      if( nToken ){
+        int i;
+        for(i=0; i<nToken; i++){
+          if( pExpr->pPhrase->aToken[i].pDeferred==0 ) break;
+        }
+        pExpr->bDeferred = (i==nToken);
       }
-      pExpr->bDeferred = (i==nToken);
       *pRc = fts3EvalPhraseStart(pCsr, 1, pExpr->pPhrase);
     }else{
       fts3EvalStartReaders(pCsr, pExpr->pLeft, pRc);
@@ -136106,9 +137879,13 @@ static int fts3EvalSelectDeferred(
         char *pList = 0;
         rc = fts3TermSelect(pTab, pToken, pTC->iCol, &nList, &pList);
         assert( rc==SQLITE_OK || pList==0 );
+        if( rc==SQLITE_OK ){
+          rc = fts3EvalPhraseMergeToken(
+              pTab, pTC->pPhrase, pTC->iToken,pList,nList
+          );
+        }
         if( rc==SQLITE_OK ){
           int nCount;
-          fts3EvalPhraseMergeToken(pTab, pTC->pPhrase, pTC->iToken,pList,nList);
           nCount = fts3DoclistCountDocids(
               pTC->pPhrase->doclist.aAll, pTC->pPhrase->doclist.nAll
           );
@@ -136333,6 +138110,22 @@ static void fts3EvalNextRow(
           }
           pExpr->iDocid = pLeft->iDocid;
           pExpr->bEof = (pLeft->bEof || pRight->bEof);
+          if( pExpr->eType==FTSQUERY_NEAR && pExpr->bEof ){
+            if( pRight->pPhrase && pRight->pPhrase->doclist.aAll ){
+              Fts3Doclist *pDl = &pRight->pPhrase->doclist;
+              while( *pRc==SQLITE_OK && pRight->bEof==0 ){
+                memset(pDl->pList, 0, pDl->nList);
+                fts3EvalNextRow(pCsr, pRight, pRc);
+              }
+            }
+            if( pLeft->pPhrase && pLeft->pPhrase->doclist.aAll ){
+              Fts3Doclist *pDl = &pLeft->pPhrase->doclist;
+              while( *pRc==SQLITE_OK && pLeft->bEof==0 ){
+                memset(pDl->pList, 0, pDl->nList);
+                fts3EvalNextRow(pCsr, pLeft, pRc);
+              }
+            }
+          }
         }
         break;
       }
@@ -136705,6 +138498,7 @@ static void fts3EvalRestart(
       }
       pPhrase->doclist.pNextDocid = 0;
       pPhrase->doclist.iDocid = 0;
+      pPhrase->pOrPoslist = 0;
     }
 
     pExpr->iDocid = 0;
@@ -136950,8 +138744,8 @@ SQLITE_PRIVATE int sqlite3Fts3EvalPhrasePoslist(
   iDocid = pExpr->iDocid;
   pIter = pPhrase->doclist.pList;
   if( iDocid!=pCsr->iPrevId || pExpr->bEof ){
+    int rc = SQLITE_OK;
     int bDescDoclist = pTab->bDescIdx;      /* For DOCID_CMP macro */
-    int iMul;                     /* +1 if csr dir matches index dir, else -1 */
     int bOr = 0;
     u8 bEof = 0;
     u8 bTreeEof = 0;
@@ -136975,72 +138769,44 @@ SQLITE_PRIVATE int sqlite3Fts3EvalPhrasePoslist(
     ** an incremental phrase. Load the entire doclist for the phrase
     ** into memory in this case.  */
     if( pPhrase->bIncr ){
-      int rc = SQLITE_OK;
-      int bEofSave = pExpr->bEof;
-      fts3EvalRestart(pCsr, pExpr, &rc);
-      while( rc==SQLITE_OK && !pExpr->bEof ){
-        fts3EvalNextRow(pCsr, pExpr, &rc);
-        if( bEofSave==0 && pExpr->iDocid==iDocid ) break;
+      int bEofSave = pNear->bEof;
+      fts3EvalRestart(pCsr, pNear, &rc);
+      while( rc==SQLITE_OK && !pNear->bEof ){
+        fts3EvalNextRow(pCsr, pNear, &rc);
+        if( bEofSave==0 && pNear->iDocid==iDocid ) break;
       }
-      pIter = pPhrase->doclist.pList;
       assert( rc!=SQLITE_OK || pPhrase->bIncr==0 );
-      if( rc!=SQLITE_OK ) return rc;
     }
-    
-    iMul = ((pCsr->bDesc==bDescDoclist) ? 1 : -1);
-    while( bTreeEof==1 
-        && pNear->bEof==0
-        && (DOCID_CMP(pNear->iDocid, pCsr->iPrevId) * iMul)<0
-    ){
-      int rc = SQLITE_OK;
-      fts3EvalNextRow(pCsr, pExpr, &rc);
-      if( rc!=SQLITE_OK ) return rc;
-      iDocid = pExpr->iDocid;
-      pIter = pPhrase->doclist.pList;
+    if( bTreeEof ){
+      while( rc==SQLITE_OK && !pNear->bEof ){
+        fts3EvalNextRow(pCsr, pNear, &rc);
+      }
     }
+    if( rc!=SQLITE_OK ) return rc;
 
-    bEof = (pPhrase->doclist.nAll==0);
-    assert( bDescDoclist==0 || bDescDoclist==1 );
-    assert( pCsr->bDesc==0 || pCsr->bDesc==1 );
-
-    if( bEof==0 ){
-      if( pCsr->bDesc==bDescDoclist ){
+    pIter = pPhrase->pOrPoslist;
+    iDocid = pPhrase->iOrDocid;
+    if( pCsr->bDesc==bDescDoclist ){
+      bEof = !pPhrase->doclist.nAll ||
+                 (pIter >= (pPhrase->doclist.aAll + pPhrase->doclist.nAll));
+      while( (pIter==0 || DOCID_CMP(iDocid, pCsr->iPrevId)<0 ) && bEof==0 ){
+        sqlite3Fts3DoclistNext(
+            bDescDoclist, pPhrase->doclist.aAll, pPhrase->doclist.nAll, 
+            &pIter, &iDocid, &bEof
+        );
+      }
+    }else{
+      bEof = !pPhrase->doclist.nAll || (pIter && pIter<=pPhrase->doclist.aAll);
+      while( (pIter==0 || DOCID_CMP(iDocid, pCsr->iPrevId)>0 ) && bEof==0 ){
         int dummy;
-        if( pNear->bEof ){
-          /* This expression is already at EOF. So position it to point to the
-          ** last entry in the doclist at pPhrase->doclist.aAll[]. Variable
-          ** iDocid is already set for this entry, so all that is required is
-          ** to set pIter to point to the first byte of the last position-list
-          ** in the doclist. 
-          **
-          ** It would also be correct to set pIter and iDocid to zero. In
-          ** this case, the first call to sqltie3Fts4DoclistPrev() below
-          ** would also move the iterator to point to the last entry in the 
-          ** doclist. However, this is expensive, as to do so it has to 
-          ** iterate through the entire doclist from start to finish (since
-          ** it does not know the docid for the last entry).  */
-          pIter = &pPhrase->doclist.aAll[pPhrase->doclist.nAll-1];
-          fts3ReversePoslist(pPhrase->doclist.aAll, &pIter);
-        }
-        while( (pIter==0 || DOCID_CMP(iDocid, pCsr->iPrevId)>0 ) && bEof==0 ){
-          sqlite3Fts3DoclistPrev(
-              bDescDoclist, pPhrase->doclist.aAll, pPhrase->doclist.nAll, 
-              &pIter, &iDocid, &dummy, &bEof
-          );
-        }
-      }else{
-        if( pNear->bEof ){
-          pIter = 0;
-          iDocid = 0;
-        }
-        while( (pIter==0 || DOCID_CMP(iDocid, pCsr->iPrevId)<0 ) && bEof==0 ){
-          sqlite3Fts3DoclistNext(
-              bDescDoclist, pPhrase->doclist.aAll, pPhrase->doclist.nAll, 
-              &pIter, &iDocid, &bEof
-          );
-        }
+        sqlite3Fts3DoclistPrev(
+            bDescDoclist, pPhrase->doclist.aAll, pPhrase->doclist.nAll, 
+            &pIter, &iDocid, &dummy, &bEof
+        );
       }
     }
+    pPhrase->pOrPoslist = pIter;
+    pPhrase->iOrDocid = iDocid;
 
     if( bEof || iDocid!=pCsr->iPrevId ) pIter = 0;
   }
@@ -137054,10 +138820,13 @@ SQLITE_PRIVATE int sqlite3Fts3EvalPhrasePoslist(
   }
   while( iThis<iCol ){
     fts3ColumnlistCopy(0, &pIter);
-    if( *pIter==0x00 ) return 0;
+    if( *pIter==0x00 ) return SQLITE_OK;
     pIter++;
     pIter += fts3GetVarint32(pIter, &iThis);
   }
+  if( *pIter==0x00 ){
+    pIter = 0;
+  }
 
   *ppOut = ((iCol==iThis)?pIter:0);
   return SQLITE_OK;
@@ -137100,7 +138869,7 @@ SQLITE_PRIVATE int sqlite3Fts3Corrupt(){
 #ifdef _WIN32
 __declspec(dllexport)
 #endif
-SQLITE_API int sqlite3_fts3_init(
+SQLITE_API int SQLITE_STDCALL sqlite3_fts3_init(
   sqlite3 *db, 
   char **pzErrMsg,
   const sqlite3_api_routines *pApi
@@ -137231,7 +139000,7 @@ static int fts3auxConnectMethod(
   return SQLITE_OK;
 
  bad_args:
-  *pzErr = sqlite3_mprintf("invalid arguments to fts4aux constructor");
+  sqlite3Fts3ErrMsg(pzErr, "invalid arguments to fts4aux constructor");
   return SQLITE_ERROR;
 }
 
@@ -138689,13 +140458,13 @@ SQLITE_PRIVATE int sqlite3Fts3ExprParse(
     sqlite3Fts3ExprFree(*ppExpr);
     *ppExpr = 0;
     if( rc==SQLITE_TOOBIG ){
-      *pzErr = sqlite3_mprintf(
+      sqlite3Fts3ErrMsg(pzErr,
           "FTS expression tree is too large (maximum depth %d)", 
           SQLITE_FTS3_MAX_EXPR_DEPTH
       );
       rc = SQLITE_ERROR;
     }else if( rc==SQLITE_ERROR ){
-      *pzErr = sqlite3_mprintf("malformed MATCH expression: [%s]", z);
+      sqlite3Fts3ErrMsg(pzErr, "malformed MATCH expression: [%s]", z);
     }
   }
 
@@ -140068,7 +141837,7 @@ static void scalarFunc(
   if( argc==2 ){
     void *pOld;
     int n = sqlite3_value_bytes(argv[1]);
-    if( n!=sizeof(pPtr) ){
+    if( zName==0 || n!=sizeof(pPtr) ){
       sqlite3_result_error(context, "argument type mismatch", -1);
       return;
     }
@@ -140079,7 +141848,9 @@ static void scalarFunc(
       return;
     }
   }else{
-    pPtr = sqlite3Fts3HashFind(pHash, zName, nName);
+    if( zName ){
+      pPtr = sqlite3Fts3HashFind(pHash, zName, nName);
+    }
     if( !pPtr ){
       char *zErr = sqlite3_mprintf("unknown tokenizer: %s", zName);
       sqlite3_result_error(context, zErr, -1);
@@ -140160,12 +141931,16 @@ SQLITE_PRIVATE int sqlite3Fts3InitTokenizer(
   zEnd = &zCopy[strlen(zCopy)];
 
   z = (char *)sqlite3Fts3NextToken(zCopy, &n);
+  if( z==0 ){
+    assert( n==0 );
+    z = zCopy;
+  }
   z[n] = '\0';
   sqlite3Fts3Dequote(z);
 
   m = (sqlite3_tokenizer_module *)sqlite3Fts3HashFind(pHash,z,(int)strlen(z)+1);
   if( !m ){
-    *pzErr = sqlite3_mprintf("unknown tokenizer: %s", z);
+    sqlite3Fts3ErrMsg(pzErr, "unknown tokenizer: %s", z);
     rc = SQLITE_ERROR;
   }else{
     char const **aArg = 0;
@@ -140188,7 +141963,7 @@ SQLITE_PRIVATE int sqlite3Fts3InitTokenizer(
     rc = m->xCreate(iArg, aArg, ppTok);
     assert( rc!=SQLITE_OK || *ppTok );
     if( rc!=SQLITE_OK ){
-      *pzErr = sqlite3_mprintf("unknown tokenizer");
+      sqlite3Fts3ErrMsg(pzErr, "unknown tokenizer");
     }else{
       (*ppTok)->pModule = m; 
     }
@@ -140272,9 +142047,9 @@ static void testFunc(
   p = (sqlite3_tokenizer_module *)sqlite3Fts3HashFind(pHash, zName, nName+1);
 
   if( !p ){
-    char *zErr = sqlite3_mprintf("unknown tokenizer: %s", zName);
-    sqlite3_result_error(context, zErr, -1);
-    sqlite3_free(zErr);
+    char *zErr2 = sqlite3_mprintf("unknown tokenizer: %s", zName);
+    sqlite3_result_error(context, zErr2, -1);
+    sqlite3_free(zErr2);
     return;
   }
 
@@ -140809,7 +142584,7 @@ static int fts3tokQueryTokenizer(
 
   p = (sqlite3_tokenizer_module *)sqlite3Fts3HashFind(pHash, zName, nName+1);
   if( !p ){
-    *pzErr = sqlite3_mprintf("unknown tokenizer: %s", zName);
+    sqlite3Fts3ErrMsg(pzErr, "unknown tokenizer: %s", zName);
     return SQLITE_ERROR;
   }
 
@@ -141506,7 +143281,7 @@ static int fts3SqlStmt(
 /* 25 */  "",
 
 /* 26 */ "DELETE FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ?",
-/* 27 */ "SELECT DISTINCT level / (1024 * ?) FROM %Q.'%q_segdir'",
+/* 27 */ "SELECT ? UNION SELECT level / (1024 * ?) FROM %Q.'%q_segdir'",
 
 /* This statement is used to determine which level to read the input from
 ** when performing an incremental merge. It returns the absolute level number
@@ -142805,7 +144580,10 @@ SQLITE_PRIVATE int sqlite3Fts3SegReaderNew(
 ** an array of pending terms by term. This occurs as part of flushing
 ** the contents of the pending-terms hash table to the database.
 */
-static int fts3CompareElemByTerm(const void *lhs, const void *rhs){
+static int SQLITE_CDECL fts3CompareElemByTerm(
+  const void *lhs,
+  const void *rhs
+){
   char *z1 = fts3HashKey(*(Fts3HashElem **)lhs);
   char *z2 = fts3HashKey(*(Fts3HashElem **)rhs);
   int n1 = fts3HashKeysize(*(Fts3HashElem **)lhs);
@@ -144621,7 +146399,8 @@ static int fts3DoOptimize(Fts3Table *p, int bReturnDone){
   rc = fts3SqlStmt(p, SQL_SELECT_ALL_LANGID, &pAllLangid, 0);
   if( rc==SQLITE_OK ){
     int rc2;
-    sqlite3_bind_int(pAllLangid, 1, p->nIndex);
+    sqlite3_bind_int(pAllLangid, 1, p->iPrevLangid);
+    sqlite3_bind_int(pAllLangid, 2, p->nIndex);
     while( sqlite3_step(pAllLangid)==SQLITE_ROW ){
       int i;
       int iLangid = sqlite3_column_int(pAllLangid, 0);
@@ -145953,7 +147732,7 @@ static int fts3IncrmergeHintPop(Blob *pHint, i64 *piAbsLevel, int *pnInput){
   pHint->n = i;
   i += sqlite3Fts3GetVarint(&pHint->a[i], piAbsLevel);
   i += fts3GetVarint32(&pHint->a[i], pnInput);
-  if( i!=nHint ) return SQLITE_CORRUPT_VTAB;
+  if( i!=nHint ) return FTS_CORRUPT_VTAB;
 
   return SQLITE_OK;
 }
@@ -146321,7 +148100,8 @@ static int fts3IntegrityCheck(Fts3Table *p, int *pbOk){
   rc = fts3SqlStmt(p, SQL_SELECT_ALL_LANGID, &pAllLangid, 0);
   if( rc==SQLITE_OK ){
     int rc2;
-    sqlite3_bind_int(pAllLangid, 1, p->nIndex);
+    sqlite3_bind_int(pAllLangid, 1, p->iPrevLangid);
+    sqlite3_bind_int(pAllLangid, 2, p->nIndex);
     while( rc==SQLITE_OK && sqlite3_step(pAllLangid)==SQLITE_ROW ){
       int iLangid = sqlite3_column_int(pAllLangid, 0);
       int i;
@@ -146334,7 +148114,6 @@ static int fts3IntegrityCheck(Fts3Table *p, int *pbOk){
   }
 
   /* This block calculates the checksum according to the %_content table */
-  rc = fts3SqlStmt(p, SQL_SELECT_ALL_LANGID, &pAllLangid, 0);
   if( rc==SQLITE_OK ){
     sqlite3_tokenizer_module const *pModule = p->pTokenizer->pModule;
     sqlite3_stmt *pStmt = 0;
@@ -146431,7 +148210,7 @@ static int fts3DoIntegrityCheck(
   int rc;
   int bOk = 0;
   rc = fts3IntegrityCheck(p, &bOk);
-  if( rc==SQLITE_OK && bOk==0 ) rc = SQLITE_CORRUPT_VTAB;
+  if( rc==SQLITE_OK && bOk==0 ) rc = FTS_CORRUPT_VTAB;
   return rc;
 }
 
@@ -146869,6 +148648,7 @@ SQLITE_PRIVATE int sqlite3Fts3Optimize(Fts3Table *p){
 #define FTS3_MATCHINFO_LENGTH    'l'        /* nCol values */
 #define FTS3_MATCHINFO_LCS       's'        /* nCol values */
 #define FTS3_MATCHINFO_HITS      'x'        /* 3*nCol*nPhrase values */
+#define FTS3_MATCHINFO_LHITS     'y'        /* nCol*nPhrase values */
 
 /*
 ** The default value for the second argument to matchinfo(). 
@@ -147284,37 +149064,39 @@ static int fts3BestSnippet(
   sIter.nSnippet = nSnippet;
   sIter.nPhrase = nList;
   sIter.iCurrent = -1;
-  (void)fts3ExprIterate(pCsr->pExpr, fts3SnippetFindPositions, (void *)&sIter);
+  rc = fts3ExprIterate(pCsr->pExpr, fts3SnippetFindPositions, (void *)&sIter);
+  if( rc==SQLITE_OK ){
 
-  /* Set the *pmSeen output variable. */
-  for(i=0; i<nList; i++){
-    if( sIter.aPhrase[i].pHead ){
-      *pmSeen |= (u64)1 << i;
+    /* Set the *pmSeen output variable. */
+    for(i=0; i<nList; i++){
+      if( sIter.aPhrase[i].pHead ){
+        *pmSeen |= (u64)1 << i;
+      }
     }
-  }
 
-  /* Loop through all candidate snippets. Store the best snippet in 
-  ** *pFragment. Store its associated 'score' in iBestScore.
-  */
-  pFragment->iCol = iCol;
-  while( !fts3SnippetNextCandidate(&sIter) ){
-    int iPos;
-    int iScore;
-    u64 mCover;
-    u64 mHighlight;
-    fts3SnippetDetails(&sIter, mCovered, &iPos, &iScore, &mCover, &mHighlight);
-    assert( iScore>=0 );
-    if( iScore>iBestScore ){
-      pFragment->iPos = iPos;
-      pFragment->hlmask = mHighlight;
-      pFragment->covered = mCover;
-      iBestScore = iScore;
+    /* Loop through all candidate snippets. Store the best snippet in 
+     ** *pFragment. Store its associated 'score' in iBestScore.
+     */
+    pFragment->iCol = iCol;
+    while( !fts3SnippetNextCandidate(&sIter) ){
+      int iPos;
+      int iScore;
+      u64 mCover;
+      u64 mHighlite;
+      fts3SnippetDetails(&sIter, mCovered, &iPos, &iScore, &mCover,&mHighlite);
+      assert( iScore>=0 );
+      if( iScore>iBestScore ){
+        pFragment->iPos = iPos;
+        pFragment->hlmask = mHighlite;
+        pFragment->covered = mCover;
+        iBestScore = iScore;
+      }
     }
-  }
 
+    *piScore = iBestScore;
+  }
   sqlite3_free(sIter.aPhrase);
-  *piScore = iBestScore;
-  return SQLITE_OK;
+  return rc;
 }
 
 
@@ -147522,8 +149304,12 @@ static int fts3SnippetText(
       ** required. They are required if (a) this is not the first fragment,
       ** or (b) this fragment does not begin at position 0 of its column. 
       */
-      if( rc==SQLITE_OK && (iPos>0 || iFragment>0) ){
-        rc = fts3StringAppend(pOut, zEllipsis, -1);
+      if( rc==SQLITE_OK ){
+        if( iPos>0 || iFragment>0 ){
+          rc = fts3StringAppend(pOut, zEllipsis, -1);
+        }else if( iBegin ){
+          rc = fts3StringAppend(pOut, zDoc, iBegin);
+        }
       }
       if( rc!=SQLITE_OK || iCurrent<iPos ) continue;
     }
@@ -147645,6 +149431,51 @@ static int fts3ExprLocalHitsCb(
   return rc;
 }
 
+/*
+** fts3ExprIterate() callback used to gather information for the matchinfo
+** directive 'y'.
+*/
+static int fts3ExprLHitsCb(
+  Fts3Expr *pExpr,                /* Phrase expression node */
+  int iPhrase,                    /* Phrase number */
+  void *pCtx                      /* Pointer to MatchInfo structure */
+){
+  MatchInfo *p = (MatchInfo *)pCtx;
+  Fts3Table *pTab = (Fts3Table *)p->pCursor->base.pVtab;
+  int rc = SQLITE_OK;
+  int iStart = iPhrase * p->nCol;
+  Fts3Expr *pEof;                 /* Ancestor node already at EOF */
+  
+  /* This must be a phrase */
+  assert( pExpr->pPhrase );
+
+  /* Initialize all output integers to zero. */
+  memset(&p->aMatchinfo[iStart], 0, sizeof(u32) * p->nCol);
+
+  /* Check if this or any parent node is at EOF. If so, then all output
+  ** values are zero.  */
+  for(pEof=pExpr; pEof && pEof->bEof==0; pEof=pEof->pParent);
+
+  if( pEof==0 && pExpr->iDocid==p->pCursor->iPrevId ){
+    Fts3Phrase *pPhrase = pExpr->pPhrase;
+    char *pIter = pPhrase->doclist.pList;
+    int iCol = 0;
+
+    while( 1 ){
+      int nHit = fts3ColumnlistCount(&pIter);
+      if( (pPhrase->iColumn>=pTab->nColumn || pPhrase->iColumn==iCol) ){
+        p->aMatchinfo[iStart + iCol] = (u32)nHit;
+      }
+      assert( *pIter==0x00 || *pIter==0x01 );
+      if( *pIter!=0x01 ) break;
+      pIter++;
+      pIter += fts3GetVarint32(pIter, &iCol);
+    }
+  }
+
+  return rc;
+}
+
 static int fts3MatchinfoCheck(
   Fts3Table *pTab, 
   char cArg,
@@ -147657,10 +149488,11 @@ static int fts3MatchinfoCheck(
    || (cArg==FTS3_MATCHINFO_LENGTH && pTab->bHasDocsize)
    || (cArg==FTS3_MATCHINFO_LCS)
    || (cArg==FTS3_MATCHINFO_HITS)
+   || (cArg==FTS3_MATCHINFO_LHITS)
   ){
     return SQLITE_OK;
   }
-  *pzErr = sqlite3_mprintf("unrecognized matchinfo request: %c", cArg);
+  sqlite3Fts3ErrMsg(pzErr, "unrecognized matchinfo request: %c", cArg);
   return SQLITE_ERROR;
 }
 
@@ -147680,6 +149512,10 @@ static int fts3MatchinfoSize(MatchInfo *pInfo, char cArg){
       nVal = pInfo->nCol;
       break;
 
+    case FTS3_MATCHINFO_LHITS:
+      nVal = pInfo->nCol * pInfo->nPhrase;
+      break;
+
     default:
       assert( cArg==FTS3_MATCHINFO_HITS );
       nVal = pInfo->nCol * pInfo->nPhrase * 3;
@@ -147934,6 +149770,10 @@ static int fts3MatchinfoValues(
         }
         break;
 
+      case FTS3_MATCHINFO_LHITS:
+        (void)fts3ExprIterate(pCsr->pExpr, fts3ExprLHitsCb, (void*)pInfo);
+        break;
+
       default: {
         Fts3Expr *pExpr;
         assert( zArg[i]==FTS3_MATCHINFO_HITS );
@@ -148089,7 +149929,7 @@ SQLITE_PRIVATE void sqlite3Fts3Snippet(
       */
       for(iRead=0; iRead<pTab->nColumn; iRead++){
         SnippetFragment sF = {0, 0, 0, 0};
-        int iS;
+        int iS = 0;
         if( iCol>=0 && iRead!=iCol ) continue;
 
         /* Find the best snippet of nFToken tokens in column iRead. */
@@ -151946,11 +153786,19 @@ static int rtreeUpdate(
   if( nData>1 ){
     int ii;
 
-    /* Populate the cell.aCoord[] array. The first coordinate is azData[3]. */
-    assert( nData==(pRtree->nDim*2 + 3) );
+    /* Populate the cell.aCoord[] array. The first coordinate is azData[3].
+    **
+    ** NB: nData can only be less than nDim*2+3 if the rtree is mis-declared
+    ** with "column" that are interpreted as table constraints.
+    ** Example:  CREATE VIRTUAL TABLE bad USING rtree(x,y,CHECK(y>5));
+    ** This problem was discovered after years of use, so we silently ignore
+    ** these kinds of misdeclared tables to avoid breaking any legacy.
+    */
+    assert( nData<=(pRtree->nDim*2 + 3) );
+
 #ifndef SQLITE_RTREE_INT_ONLY
     if( pRtree->eCoordType==RTREE_COORD_REAL32 ){
-      for(ii=0; ii<(pRtree->nDim*2); ii+=2){
+      for(ii=0; ii<nData-4; ii+=2){
         cell.aCoord[ii].f = rtreeValueDown(azData[ii+3]);
         cell.aCoord[ii+1].f = rtreeValueUp(azData[ii+4]);
         if( cell.aCoord[ii].f>cell.aCoord[ii+1].f ){
@@ -151961,7 +153809,7 @@ static int rtreeUpdate(
     }else
 #endif
     {
-      for(ii=0; ii<(pRtree->nDim*2); ii+=2){
+      for(ii=0; ii<nData-4; ii+=2){
         cell.aCoord[ii].i = sqlite3_value_int(azData[ii+3]);
         cell.aCoord[ii+1].i = sqlite3_value_int(azData[ii+4]);
         if( cell.aCoord[ii].i>cell.aCoord[ii+1].i ){
@@ -152532,7 +154380,7 @@ static void geomCallback(sqlite3_context *ctx, int nArg, sqlite3_value **aArg){
 /*
 ** Register a new geometry function for use with the r-tree MATCH operator.
 */
-SQLITE_API int sqlite3_rtree_geometry_callback(
+SQLITE_API int SQLITE_STDCALL sqlite3_rtree_geometry_callback(
   sqlite3 *db,                  /* Register SQL function on this connection */
   const char *zGeom,            /* Name of the new SQL function */
   int (*xGeom)(sqlite3_rtree_geometry*,int,RtreeDValue*,int*), /* Callback */
@@ -152556,7 +154404,7 @@ SQLITE_API int sqlite3_rtree_geometry_callback(
 ** Register a new 2nd-generation geometry function for use with the
 ** r-tree MATCH operator.
 */
-SQLITE_API int sqlite3_rtree_query_callback(
+SQLITE_API int SQLITE_STDCALL sqlite3_rtree_query_callback(
   sqlite3 *db,                 /* Register SQL function on this connection */
   const char *zQueryFunc,      /* Name of new SQL function */
   int (*xQueryFunc)(sqlite3_rtree_query_info*), /* Callback */
@@ -152581,7 +154429,7 @@ SQLITE_API int sqlite3_rtree_query_callback(
 #ifdef _WIN32
 __declspec(dllexport)
 #endif
-SQLITE_API int sqlite3_rtree_init(
+SQLITE_API int SQLITE_STDCALL sqlite3_rtree_init(
   sqlite3 *db,
   char **pzErrMsg,
   const sqlite3_api_routines *pApi
@@ -153086,7 +154934,7 @@ SQLITE_PRIVATE int sqlite3IcuInit(sqlite3 *db){
 #ifdef _WIN32
 __declspec(dllexport)
 #endif
-SQLITE_API int sqlite3_icu_init(
+SQLITE_API int SQLITE_STDCALL sqlite3_icu_init(
   sqlite3 *db, 
   char **pzErrMsg,
   const sqlite3_api_routines *pApi
@@ -153361,3 +155209,631 @@ SQLITE_PRIVATE void sqlite3Fts3IcuTokenizerModule(
 #endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3) */
 
 /************** End of fts3_icu.c ********************************************/
+/************** Begin file dbstat.c ******************************************/
+/*
+** 2010 July 12
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+**
+** This file contains an implementation of the "dbstat" virtual table.
+**
+** The dbstat virtual table is used to extract low-level formatting
+** information from an SQLite database in order to implement the
+** "sqlite3_analyzer" utility.  See the ../tool/spaceanal.tcl script
+** for an example implementation.
+*/
+
+#if (defined(SQLITE_ENABLE_DBSTAT_VTAB) || defined(SQLITE_TEST)) \
+    && !defined(SQLITE_OMIT_VIRTUALTABLE)
+
+/*
+** Page paths:
+** 
+**   The value of the 'path' column describes the path taken from the 
+**   root-node of the b-tree structure to each page. The value of the 
+**   root-node path is '/'.
+**
+**   The value of the path for the left-most child page of the root of
+**   a b-tree is '/000/'. (Btrees store content ordered from left to right
+**   so the pages to the left have smaller keys than the pages to the right.)
+**   The next to left-most child of the root page is
+**   '/001', and so on, each sibling page identified by a 3-digit hex 
+**   value. The children of the 451st left-most sibling have paths such
+**   as '/1c2/000/, '/1c2/001/' etc.
+**
+**   Overflow pages are specified by appending a '+' character and a 
+**   six-digit hexadecimal value to the path to the cell they are linked
+**   from. For example, the three overflow pages in a chain linked from 
+**   the left-most cell of the 450th child of the root page are identified
+**   by the paths:
+**
+**      '/1c2/000+000000'         // First page in overflow chain
+**      '/1c2/000+000001'         // Second page in overflow chain
+**      '/1c2/000+000002'         // Third page in overflow chain
+**
+**   If the paths are sorted using the BINARY collation sequence, then
+**   the overflow pages associated with a cell will appear earlier in the
+**   sort-order than its child page:
+**
+**      '/1c2/000/'               // Left-most child of 451st child of root
+*/
+#define VTAB_SCHEMA                                                         \
+  "CREATE TABLE xx( "                                                       \
+  "  name       STRING,           /* Name of table or index */"             \
+  "  path       INTEGER,          /* Path to page from root */"             \
+  "  pageno     INTEGER,          /* Page number */"                        \
+  "  pagetype   STRING,           /* 'internal', 'leaf' or 'overflow' */"   \
+  "  ncell      INTEGER,          /* Cells on page (0 for overflow) */"     \
+  "  payload    INTEGER,          /* Bytes of payload on this page */"      \
+  "  unused     INTEGER,          /* Bytes of unused space on this page */" \
+  "  mx_payload INTEGER,          /* Largest payload size of all cells */"  \
+  "  pgoffset   INTEGER,          /* Offset of page in file */"             \
+  "  pgsize     INTEGER           /* Size of the page */"                   \
+  ");"
+
+
+typedef struct StatTable StatTable;
+typedef struct StatCursor StatCursor;
+typedef struct StatPage StatPage;
+typedef struct StatCell StatCell;
+
+struct StatCell {
+  int nLocal;                     /* Bytes of local payload */
+  u32 iChildPg;                   /* Child node (or 0 if this is a leaf) */
+  int nOvfl;                      /* Entries in aOvfl[] */
+  u32 *aOvfl;                     /* Array of overflow page numbers */
+  int nLastOvfl;                  /* Bytes of payload on final overflow page */
+  int iOvfl;                      /* Iterates through aOvfl[] */
+};
+
+struct StatPage {
+  u32 iPgno;
+  DbPage *pPg;
+  int iCell;
+
+  char *zPath;                    /* Path to this page */
+
+  /* Variables populated by statDecodePage(): */
+  u8 flags;                       /* Copy of flags byte */
+  int nCell;                      /* Number of cells on page */
+  int nUnused;                    /* Number of unused bytes on page */
+  StatCell *aCell;                /* Array of parsed cells */
+  u32 iRightChildPg;              /* Right-child page number (or 0) */
+  int nMxPayload;                 /* Largest payload of any cell on this page */
+};
+
+struct StatCursor {
+  sqlite3_vtab_cursor base;
+  sqlite3_stmt *pStmt;            /* Iterates through set of root pages */
+  int isEof;                      /* After pStmt has returned SQLITE_DONE */
+
+  StatPage aPage[32];
+  int iPage;                      /* Current entry in aPage[] */
+
+  /* Values to return. */
+  char *zName;                    /* Value of 'name' column */
+  char *zPath;                    /* Value of 'path' column */
+  u32 iPageno;                    /* Value of 'pageno' column */
+  char *zPagetype;                /* Value of 'pagetype' column */
+  int nCell;                      /* Value of 'ncell' column */
+  int nPayload;                   /* Value of 'payload' column */
+  int nUnused;                    /* Value of 'unused' column */
+  int nMxPayload;                 /* Value of 'mx_payload' column */
+  i64 iOffset;                    /* Value of 'pgOffset' column */
+  int szPage;                     /* Value of 'pgSize' column */
+};
+
+struct StatTable {
+  sqlite3_vtab base;
+  sqlite3 *db;
+};
+
+#ifndef get2byte
+# define get2byte(x)   ((x)[0]<<8 | (x)[1])
+#endif
+
+/*
+** Connect to or create a statvfs virtual table.
+*/
+static int statConnect(
+  sqlite3 *db,
+  void *pAux,
+  int argc, const char *const*argv,
+  sqlite3_vtab **ppVtab,
+  char **pzErr
+){
+  StatTable *pTab = 0;
+  int rc = SQLITE_OK;
+
+  rc = sqlite3_declare_vtab(db, VTAB_SCHEMA);
+  if( rc==SQLITE_OK ){
+    pTab = (StatTable *)sqlite3_malloc64(sizeof(StatTable));
+    if( pTab==0 ) rc = SQLITE_NOMEM;
+  }
+
+  assert( rc==SQLITE_OK || pTab==0 );
+  if( rc==SQLITE_OK ){
+    memset(pTab, 0, sizeof(StatTable));
+    pTab->db = db;
+  }
+
+  *ppVtab = (sqlite3_vtab*)pTab;
+  return rc;
+}
+
+/*
+** Disconnect from or destroy a statvfs virtual table.
+*/
+static int statDisconnect(sqlite3_vtab *pVtab){
+  sqlite3_free(pVtab);
+  return SQLITE_OK;
+}
+
+/*
+** There is no "best-index". This virtual table always does a linear
+** scan of the binary VFS log file.
+*/
+static int statBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){
+
+  /* Records are always returned in ascending order of (name, path). 
+  ** If this will satisfy the client, set the orderByConsumed flag so that 
+  ** SQLite does not do an external sort.
+  */
+  if( ( pIdxInfo->nOrderBy==1
+     && pIdxInfo->aOrderBy[0].iColumn==0
+     && pIdxInfo->aOrderBy[0].desc==0
+     ) ||
+      ( pIdxInfo->nOrderBy==2
+     && pIdxInfo->aOrderBy[0].iColumn==0
+     && pIdxInfo->aOrderBy[0].desc==0
+     && pIdxInfo->aOrderBy[1].iColumn==1
+     && pIdxInfo->aOrderBy[1].desc==0
+     )
+  ){
+    pIdxInfo->orderByConsumed = 1;
+  }
+
+  pIdxInfo->estimatedCost = 10.0;
+  return SQLITE_OK;
+}
+
+/*
+** Open a new statvfs cursor.
+*/
+static int statOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){
+  StatTable *pTab = (StatTable *)pVTab;
+  StatCursor *pCsr;
+  int rc;
+
+  pCsr = (StatCursor *)sqlite3_malloc64(sizeof(StatCursor));
+  if( pCsr==0 ){
+    rc = SQLITE_NOMEM;
+  }else{
+    memset(pCsr, 0, sizeof(StatCursor));
+    pCsr->base.pVtab = pVTab;
+
+    rc = sqlite3_prepare_v2(pTab->db, 
+        "SELECT 'sqlite_master' AS name, 1 AS rootpage, 'table' AS type"
+        "  UNION ALL  "
+        "SELECT name, rootpage, type FROM sqlite_master WHERE rootpage!=0"
+        "  ORDER BY name", -1,
+        &pCsr->pStmt, 0
+        );
+    if( rc!=SQLITE_OK ){
+      sqlite3_free(pCsr);
+      pCsr = 0;
+    }
+  }
+
+  *ppCursor = (sqlite3_vtab_cursor *)pCsr;
+  return rc;
+}
+
+static void statClearPage(StatPage *p){
+  int i;
+  if( p->aCell ){
+    for(i=0; i<p->nCell; i++){
+      sqlite3_free(p->aCell[i].aOvfl);
+    }
+    sqlite3_free(p->aCell);
+  }
+  sqlite3PagerUnref(p->pPg);
+  sqlite3_free(p->zPath);
+  memset(p, 0, sizeof(StatPage));
+}
+
+static void statResetCsr(StatCursor *pCsr){
+  int i;
+  sqlite3_reset(pCsr->pStmt);
+  for(i=0; i<ArraySize(pCsr->aPage); i++){
+    statClearPage(&pCsr->aPage[i]);
+  }
+  pCsr->iPage = 0;
+  sqlite3_free(pCsr->zPath);
+  pCsr->zPath = 0;
+}
+
+/*
+** Close a statvfs cursor.
+*/
+static int statClose(sqlite3_vtab_cursor *pCursor){
+  StatCursor *pCsr = (StatCursor *)pCursor;
+  statResetCsr(pCsr);
+  sqlite3_finalize(pCsr->pStmt);
+  sqlite3_free(pCsr);
+  return SQLITE_OK;
+}
+
+static void getLocalPayload(
+  int nUsable,                    /* Usable bytes per page */
+  u8 flags,                       /* Page flags */
+  int nTotal,                     /* Total record (payload) size */
+  int *pnLocal                    /* OUT: Bytes stored locally */
+){
+  int nLocal;
+  int nMinLocal;
+  int nMaxLocal;
+ 
+  if( flags==0x0D ){              /* Table leaf node */
+    nMinLocal = (nUsable - 12) * 32 / 255 - 23;
+    nMaxLocal = nUsable - 35;
+  }else{                          /* Index interior and leaf nodes */
+    nMinLocal = (nUsable - 12) * 32 / 255 - 23;
+    nMaxLocal = (nUsable - 12) * 64 / 255 - 23;
+  }
+
+  nLocal = nMinLocal + (nTotal - nMinLocal) % (nUsable - 4);
+  if( nLocal>nMaxLocal ) nLocal = nMinLocal;
+  *pnLocal = nLocal;
+}
+
+static int statDecodePage(Btree *pBt, StatPage *p){
+  int nUnused;
+  int iOff;
+  int nHdr;
+  int isLeaf;
+  int szPage;
+
+  u8 *aData = sqlite3PagerGetData(p->pPg);
+  u8 *aHdr = &aData[p->iPgno==1 ? 100 : 0];
+
+  p->flags = aHdr[0];
+  p->nCell = get2byte(&aHdr[3]);
+  p->nMxPayload = 0;
+
+  isLeaf = (p->flags==0x0A || p->flags==0x0D);
+  nHdr = 12 - isLeaf*4 + (p->iPgno==1)*100;
+
+  nUnused = get2byte(&aHdr[5]) - nHdr - 2*p->nCell;
+  nUnused += (int)aHdr[7];
+  iOff = get2byte(&aHdr[1]);
+  while( iOff ){
+    nUnused += get2byte(&aData[iOff+2]);
+    iOff = get2byte(&aData[iOff]);
+  }
+  p->nUnused = nUnused;
+  p->iRightChildPg = isLeaf ? 0 : sqlite3Get4byte(&aHdr[8]);
+  szPage = sqlite3BtreeGetPageSize(pBt);
+
+  if( p->nCell ){
+    int i;                        /* Used to iterate through cells */
+    int nUsable;                  /* Usable bytes per page */
+
+    sqlite3BtreeEnter(pBt);
+    nUsable = szPage - sqlite3BtreeGetReserveNoMutex(pBt);
+    sqlite3BtreeLeave(pBt);
+    p->aCell = sqlite3_malloc64((p->nCell+1) * sizeof(StatCell));
+    if( p->aCell==0 ) return SQLITE_NOMEM;
+    memset(p->aCell, 0, (p->nCell+1) * sizeof(StatCell));
+
+    for(i=0; i<p->nCell; i++){
+      StatCell *pCell = &p->aCell[i];
+
+      iOff = get2byte(&aData[nHdr+i*2]);
+      if( !isLeaf ){
+        pCell->iChildPg = sqlite3Get4byte(&aData[iOff]);
+        iOff += 4;
+      }
+      if( p->flags==0x05 ){
+        /* A table interior node. nPayload==0. */
+      }else{
+        u32 nPayload;             /* Bytes of payload total (local+overflow) */
+        int nLocal;               /* Bytes of payload stored locally */
+        iOff += getVarint32(&aData[iOff], nPayload);
+        if( p->flags==0x0D ){
+          u64 dummy;
+          iOff += sqlite3GetVarint(&aData[iOff], &dummy);
+        }
+        if( nPayload>(u32)p->nMxPayload ) p->nMxPayload = nPayload;
+        getLocalPayload(nUsable, p->flags, nPayload, &nLocal);
+        pCell->nLocal = nLocal;
+        assert( nLocal>=0 );
+        assert( nPayload>=(u32)nLocal );
+        assert( nLocal<=(nUsable-35) );
+        if( nPayload>(u32)nLocal ){
+          int j;
+          int nOvfl = ((nPayload - nLocal) + nUsable-4 - 1) / (nUsable - 4);
+          pCell->nLastOvfl = (nPayload-nLocal) - (nOvfl-1) * (nUsable-4);
+          pCell->nOvfl = nOvfl;
+          pCell->aOvfl = sqlite3_malloc64(sizeof(u32)*nOvfl);
+          if( pCell->aOvfl==0 ) return SQLITE_NOMEM;
+          pCell->aOvfl[0] = sqlite3Get4byte(&aData[iOff+nLocal]);
+          for(j=1; j<nOvfl; j++){
+            int rc;
+            u32 iPrev = pCell->aOvfl[j-1];
+            DbPage *pPg = 0;
+            rc = sqlite3PagerGet(sqlite3BtreePager(pBt), iPrev, &pPg);
+            if( rc!=SQLITE_OK ){
+              assert( pPg==0 );
+              return rc;
+            } 
+            pCell->aOvfl[j] = sqlite3Get4byte(sqlite3PagerGetData(pPg));
+            sqlite3PagerUnref(pPg);
+          }
+        }
+      }
+    }
+  }
+
+  return SQLITE_OK;
+}
+
+/*
+** Populate the pCsr->iOffset and pCsr->szPage member variables. Based on
+** the current value of pCsr->iPageno.
+*/
+static void statSizeAndOffset(StatCursor *pCsr){
+  StatTable *pTab = (StatTable *)((sqlite3_vtab_cursor *)pCsr)->pVtab;
+  Btree *pBt = pTab->db->aDb[0].pBt;
+  Pager *pPager = sqlite3BtreePager(pBt);
+  sqlite3_file *fd;
+  sqlite3_int64 x[2];
+
+  /* The default page size and offset */
+  pCsr->szPage = sqlite3BtreeGetPageSize(pBt);
+  pCsr->iOffset = (i64)pCsr->szPage * (pCsr->iPageno - 1);
+
+  /* If connected to a ZIPVFS backend, override the page size and
+  ** offset with actual values obtained from ZIPVFS.
+  */
+  fd = sqlite3PagerFile(pPager);
+  x[0] = pCsr->iPageno;
+  if( sqlite3OsFileControl(fd, 230440, &x)==SQLITE_OK ){
+    pCsr->iOffset = x[0];
+    pCsr->szPage = (int)x[1];
+  }
+}
+
+/*
+** Move a statvfs cursor to the next entry in the file.
+*/
+static int statNext(sqlite3_vtab_cursor *pCursor){
+  int rc;
+  int nPayload;
+  StatCursor *pCsr = (StatCursor *)pCursor;
+  StatTable *pTab = (StatTable *)pCursor->pVtab;
+  Btree *pBt = pTab->db->aDb[0].pBt;
+  Pager *pPager = sqlite3BtreePager(pBt);
+
+  sqlite3_free(pCsr->zPath);
+  pCsr->zPath = 0;
+
+statNextRestart:
+  if( pCsr->aPage[0].pPg==0 ){
+    rc = sqlite3_step(pCsr->pStmt);
+    if( rc==SQLITE_ROW ){
+      int nPage;
+      u32 iRoot = (u32)sqlite3_column_int64(pCsr->pStmt, 1);
+      sqlite3PagerPagecount(pPager, &nPage);
+      if( nPage==0 ){
+        pCsr->isEof = 1;
+        return sqlite3_reset(pCsr->pStmt);
+      }
+      rc = sqlite3PagerGet(pPager, iRoot, &pCsr->aPage[0].pPg);
+      pCsr->aPage[0].iPgno = iRoot;
+      pCsr->aPage[0].iCell = 0;
+      pCsr->aPage[0].zPath = sqlite3_mprintf("/");
+      pCsr->iPage = 0;
+    }else{
+      pCsr->isEof = 1;
+      return sqlite3_reset(pCsr->pStmt);
+    }
+  }else{
+
+    /* Page p itself has already been visited. */
+    StatPage *p = &pCsr->aPage[pCsr->iPage];
+
+    while( p->iCell<p->nCell ){
+      StatCell *pCell = &p->aCell[p->iCell];
+      if( pCell->iOvfl<pCell->nOvfl ){
+        int nUsable;
+        sqlite3BtreeEnter(pBt);
+        nUsable = sqlite3BtreeGetPageSize(pBt) - 
+                        sqlite3BtreeGetReserveNoMutex(pBt);
+        sqlite3BtreeLeave(pBt);
+        pCsr->zName = (char *)sqlite3_column_text(pCsr->pStmt, 0);
+        pCsr->iPageno = pCell->aOvfl[pCell->iOvfl];
+        pCsr->zPagetype = "overflow";
+        pCsr->nCell = 0;
+        pCsr->nMxPayload = 0;
+        pCsr->zPath = sqlite3_mprintf(
+            "%s%.3x+%.6x", p->zPath, p->iCell, pCell->iOvfl
+        );
+        if( pCell->iOvfl<pCell->nOvfl-1 ){
+          pCsr->nUnused = 0;
+          pCsr->nPayload = nUsable - 4;
+        }else{
+          pCsr->nPayload = pCell->nLastOvfl;
+          pCsr->nUnused = nUsable - 4 - pCsr->nPayload;
+        }
+        pCell->iOvfl++;
+        statSizeAndOffset(pCsr);
+        return SQLITE_OK;
+      }
+      if( p->iRightChildPg ) break;
+      p->iCell++;
+    }
+
+    if( !p->iRightChildPg || p->iCell>p->nCell ){
+      statClearPage(p);
+      if( pCsr->iPage==0 ) return statNext(pCursor);
+      pCsr->iPage--;
+      goto statNextRestart; /* Tail recursion */
+    }
+    pCsr->iPage++;
+    assert( p==&pCsr->aPage[pCsr->iPage-1] );
+
+    if( p->iCell==p->nCell ){
+      p[1].iPgno = p->iRightChildPg;
+    }else{
+      p[1].iPgno = p->aCell[p->iCell].iChildPg;
+    }
+    rc = sqlite3PagerGet(pPager, p[1].iPgno, &p[1].pPg);
+    p[1].iCell = 0;
+    p[1].zPath = sqlite3_mprintf("%s%.3x/", p->zPath, p->iCell);
+    p->iCell++;
+  }
+
+
+  /* Populate the StatCursor fields with the values to be returned
+  ** by the xColumn() and xRowid() methods.
+  */
+  if( rc==SQLITE_OK ){
+    int i;
+    StatPage *p = &pCsr->aPage[pCsr->iPage];
+    pCsr->zName = (char *)sqlite3_column_text(pCsr->pStmt, 0);
+    pCsr->iPageno = p->iPgno;
+
+    rc = statDecodePage(pBt, p);
+    if( rc==SQLITE_OK ){
+      statSizeAndOffset(pCsr);
+
+      switch( p->flags ){
+        case 0x05:             /* table internal */
+        case 0x02:             /* index internal */
+          pCsr->zPagetype = "internal";
+          break;
+        case 0x0D:             /* table leaf */
+        case 0x0A:             /* index leaf */
+          pCsr->zPagetype = "leaf";
+          break;
+        default:
+          pCsr->zPagetype = "corrupted";
+          break;
+      }
+      pCsr->nCell = p->nCell;
+      pCsr->nUnused = p->nUnused;
+      pCsr->nMxPayload = p->nMxPayload;
+      pCsr->zPath = sqlite3_mprintf("%s", p->zPath);
+      nPayload = 0;
+      for(i=0; i<p->nCell; i++){
+        nPayload += p->aCell[i].nLocal;
+      }
+      pCsr->nPayload = nPayload;
+    }
+  }
+
+  return rc;
+}
+
+static int statEof(sqlite3_vtab_cursor *pCursor){
+  StatCursor *pCsr = (StatCursor *)pCursor;
+  return pCsr->isEof;
+}
+
+static int statFilter(
+  sqlite3_vtab_cursor *pCursor, 
+  int idxNum, const char *idxStr,
+  int argc, sqlite3_value **argv
+){
+  StatCursor *pCsr = (StatCursor *)pCursor;
+
+  statResetCsr(pCsr);
+  return statNext(pCursor);
+}
+
+static int statColumn(
+  sqlite3_vtab_cursor *pCursor, 
+  sqlite3_context *ctx, 
+  int i
+){
+  StatCursor *pCsr = (StatCursor *)pCursor;
+  switch( i ){
+    case 0:            /* name */
+      sqlite3_result_text(ctx, pCsr->zName, -1, SQLITE_STATIC);
+      break;
+    case 1:            /* path */
+      sqlite3_result_text(ctx, pCsr->zPath, -1, SQLITE_TRANSIENT);
+      break;
+    case 2:            /* pageno */
+      sqlite3_result_int64(ctx, pCsr->iPageno);
+      break;
+    case 3:            /* pagetype */
+      sqlite3_result_text(ctx, pCsr->zPagetype, -1, SQLITE_STATIC);
+      break;
+    case 4:            /* ncell */
+      sqlite3_result_int(ctx, pCsr->nCell);
+      break;
+    case 5:            /* payload */
+      sqlite3_result_int(ctx, pCsr->nPayload);
+      break;
+    case 6:            /* unused */
+      sqlite3_result_int(ctx, pCsr->nUnused);
+      break;
+    case 7:            /* mx_payload */
+      sqlite3_result_int(ctx, pCsr->nMxPayload);
+      break;
+    case 8:            /* pgoffset */
+      sqlite3_result_int64(ctx, pCsr->iOffset);
+      break;
+    case 9:            /* pgsize */
+      sqlite3_result_int(ctx, pCsr->szPage);
+      break;
+  }
+  return SQLITE_OK;
+}
+
+static int statRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){
+  StatCursor *pCsr = (StatCursor *)pCursor;
+  *pRowid = pCsr->iPageno;
+  return SQLITE_OK;
+}
+
+/*
+** Invoke this routine to register the "dbstat" virtual table module
+*/
+SQLITE_API int SQLITE_STDCALL sqlite3_dbstat_register(sqlite3 *db){
+  static sqlite3_module dbstat_module = {
+    0,                            /* iVersion */
+    statConnect,                  /* xCreate */
+    statConnect,                  /* xConnect */
+    statBestIndex,                /* xBestIndex */
+    statDisconnect,               /* xDisconnect */
+    statDisconnect,               /* xDestroy */
+    statOpen,                     /* xOpen - open a cursor */
+    statClose,                    /* xClose - close a cursor */
+    statFilter,                   /* xFilter - configure scan constraints */
+    statNext,                     /* xNext - advance a cursor */
+    statEof,                      /* xEof - check for end of scan */
+    statColumn,                   /* xColumn - read data */
+    statRowid,                    /* xRowid - read data */
+    0,                            /* xUpdate */
+    0,                            /* xBegin */
+    0,                            /* xSync */
+    0,                            /* xCommit */
+    0,                            /* xRollback */
+    0,                            /* xFindMethod */
+    0,                            /* xRename */
+  };
+  return sqlite3_create_module(db, "dbstat", &dbstat_module, 0);
+}
+#endif /* SQLITE_ENABLE_DBSTAT_VTAB */
+
+/************** End of dbstat.c **********************************************/
diff --git a/TMessagesProj/jni/sqlite/sqlite3.h b/TMessagesProj/jni/sqlite/sqlite3.h
index 07406477d..edb9e9c4b 100644
--- a/TMessagesProj/jni/sqlite/sqlite3.h
+++ b/TMessagesProj/jni/sqlite/sqlite3.h
@@ -43,16 +43,20 @@ extern "C" {
 
 
 /*
-** Add the ability to override 'extern'
+** Provide the ability to override linkage features of the interface.
 */
 #ifndef SQLITE_EXTERN
 # define SQLITE_EXTERN extern
 #endif
-
 #ifndef SQLITE_API
 # define SQLITE_API
 #endif
-
+#ifndef SQLITE_CDECL
+# define SQLITE_CDECL
+#endif
+#ifndef SQLITE_STDCALL
+# define SQLITE_STDCALL
+#endif
 
 /*
 ** These no-op macros are used in front of interfaces to mark those
@@ -107,9 +111,9 @@ extern "C" {
 ** [sqlite3_libversion_number()], [sqlite3_sourceid()],
 ** [sqlite_version()] and [sqlite_source_id()].
 */
-#define SQLITE_VERSION        "3.8.8.1"
-#define SQLITE_VERSION_NUMBER 3008008
-#define SQLITE_SOURCE_ID      "2015-01-20 16:51:25 f73337e3e289915a76ca96e7a05a1a8d4e890d55"
+#define SQLITE_VERSION        "3.8.10"
+#define SQLITE_VERSION_NUMBER 3008010
+#define SQLITE_SOURCE_ID      "2015-05-07 11:53:08 cf975957b9ae671f34bb65f049acf351e650d437"
 
 /*
 ** CAPI3REF: Run-Time Library Version Numbers
@@ -142,9 +146,9 @@ extern "C" {
 ** See also: [sqlite_version()] and [sqlite_source_id()].
 */
 SQLITE_API SQLITE_EXTERN const char sqlite3_version[];
-SQLITE_API const char *sqlite3_libversion(void);
-SQLITE_API const char *sqlite3_sourceid(void);
-SQLITE_API int sqlite3_libversion_number(void);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_libversion(void);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_sourceid(void);
+SQLITE_API int SQLITE_STDCALL sqlite3_libversion_number(void);
 
 /*
 ** CAPI3REF: Run-Time Library Compilation Options Diagnostics
@@ -169,8 +173,8 @@ SQLITE_API int sqlite3_libversion_number(void);
 ** [sqlite_compileoption_get()] and the [compile_options pragma].
 */
 #ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
-SQLITE_API int sqlite3_compileoption_used(const char *zOptName);
-SQLITE_API const char *sqlite3_compileoption_get(int N);
+SQLITE_API int SQLITE_STDCALL sqlite3_compileoption_used(const char *zOptName);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_compileoption_get(int N);
 #endif
 
 /*
@@ -209,7 +213,7 @@ SQLITE_API const char *sqlite3_compileoption_get(int N);
 **
 ** See the [threading mode] documentation for additional information.
 */
-SQLITE_API int sqlite3_threadsafe(void);
+SQLITE_API int SQLITE_STDCALL sqlite3_threadsafe(void);
 
 /*
 ** CAPI3REF: Database Connection Handle
@@ -266,6 +270,7 @@ typedef sqlite_uint64 sqlite3_uint64;
 
 /*
 ** CAPI3REF: Closing A Database Connection
+** DESTRUCTOR: sqlite3
 **
 ** ^The sqlite3_close() and sqlite3_close_v2() routines are destructors
 ** for the [sqlite3] object.
@@ -305,8 +310,8 @@ typedef sqlite_uint64 sqlite3_uint64;
 ** ^Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointer
 ** argument is a harmless no-op.
 */
-SQLITE_API int sqlite3_close(sqlite3*);
-SQLITE_API int sqlite3_close_v2(sqlite3*);
+SQLITE_API int SQLITE_STDCALL sqlite3_close(sqlite3*);
+SQLITE_API int SQLITE_STDCALL sqlite3_close_v2(sqlite3*);
 
 /*
 ** The type for a callback function.
@@ -317,6 +322,7 @@ typedef int (*sqlite3_callback)(void*,int,char**, char**);
 
 /*
 ** CAPI3REF: One-Step Query Execution Interface
+** METHOD: sqlite3
 **
 ** The sqlite3_exec() interface is a convenience wrapper around
 ** [sqlite3_prepare_v2()], [sqlite3_step()], and [sqlite3_finalize()],
@@ -376,7 +382,7 @@ typedef int (*sqlite3_callback)(void*,int,char**, char**);
 **      the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.
 ** </ul>
 */
-SQLITE_API int sqlite3_exec(
+SQLITE_API int SQLITE_STDCALL sqlite3_exec(
   sqlite3*,                                  /* An open database */
   const char *sql,                           /* SQL to be evaluated */
   int (*callback)(void*,int,char**,char**),  /* Callback function */
@@ -756,14 +762,16 @@ struct sqlite3_io_methods {
 ** of the [sqlite3_io_methods] object and for the [sqlite3_file_control()]
 ** interface.
 **
+** <ul>
+** <li>[[SQLITE_FCNTL_LOCKSTATE]]
 ** The [SQLITE_FCNTL_LOCKSTATE] opcode is used for debugging.  This
 ** opcode causes the xFileControl method to write the current state of
 ** the lock (one of [SQLITE_LOCK_NONE], [SQLITE_LOCK_SHARED],
 ** [SQLITE_LOCK_RESERVED], [SQLITE_LOCK_PENDING], or [SQLITE_LOCK_EXCLUSIVE])
 ** into an integer that the pArg argument points to. This capability
-** is used during testing and only needs to be supported when SQLITE_TEST
-** is defined.
-** <ul>
+** is used during testing and is only available when the SQLITE_TEST
+** compile-time option is used.
+**
 ** <li>[[SQLITE_FCNTL_SIZE_HINT]]
 ** The [SQLITE_FCNTL_SIZE_HINT] opcode is used by SQLite to give the VFS
 ** layer a hint of how large the database file will grow to be during the
@@ -888,7 +896,9 @@ struct sqlite3_io_methods {
 ** [PRAGMA] processing continues.  ^If the [SQLITE_FCNTL_PRAGMA]
 ** file control returns [SQLITE_OK], then the parser assumes that the
 ** VFS has handled the PRAGMA itself and the parser generates a no-op
-** prepared statement.  ^If the [SQLITE_FCNTL_PRAGMA] file control returns
+** prepared statement if result string is NULL, or that returns a copy
+** of the result string if the string is non-NULL.
+** ^If the [SQLITE_FCNTL_PRAGMA] file control returns
 ** any result code other than [SQLITE_OK] or [SQLITE_NOTFOUND], that means
 ** that the VFS encountered an error while handling the [PRAGMA] and the
 ** compilation of the PRAGMA fails with an error.  ^The [SQLITE_FCNTL_PRAGMA]
@@ -946,12 +956,19 @@ struct sqlite3_io_methods {
 ** pointed to by the pArg argument.  This capability is used during testing
 ** and only needs to be supported when SQLITE_TEST is defined.
 **
+** <li>[[SQLITE_FCNTL_WAL_BLOCK]]
+** The [SQLITE_FCNTL_WAL_BLOCK] is a signal to the VFS layer that it might
+** be advantageous to block on the next WAL lock if the lock is not immediately
+** available.  The WAL subsystem issues this signal during rare
+** circumstances in order to fix a problem with priority inversion.
+** Applications should <em>not</em> use this file-control.
+**
 ** </ul>
 */
 #define SQLITE_FCNTL_LOCKSTATE               1
-#define SQLITE_GET_LOCKPROXYFILE             2
-#define SQLITE_SET_LOCKPROXYFILE             3
-#define SQLITE_LAST_ERRNO                    4
+#define SQLITE_FCNTL_GET_LOCKPROXYFILE       2
+#define SQLITE_FCNTL_SET_LOCKPROXYFILE       3
+#define SQLITE_FCNTL_LAST_ERRNO              4
 #define SQLITE_FCNTL_SIZE_HINT               5
 #define SQLITE_FCNTL_CHUNK_SIZE              6
 #define SQLITE_FCNTL_FILE_POINTER            7
@@ -970,6 +987,13 @@ struct sqlite3_io_methods {
 #define SQLITE_FCNTL_SYNC                   21
 #define SQLITE_FCNTL_COMMIT_PHASETWO        22
 #define SQLITE_FCNTL_WIN32_SET_HANDLE       23
+#define SQLITE_FCNTL_WAL_BLOCK              24
+
+/* deprecated names */
+#define SQLITE_GET_LOCKPROXYFILE      SQLITE_FCNTL_GET_LOCKPROXYFILE
+#define SQLITE_SET_LOCKPROXYFILE      SQLITE_FCNTL_SET_LOCKPROXYFILE
+#define SQLITE_LAST_ERRNO             SQLITE_FCNTL_LAST_ERRNO
+
 
 /*
 ** CAPI3REF: Mutex Handle
@@ -1318,10 +1342,10 @@ struct sqlite3_vfs {
 ** must return [SQLITE_OK] on success and some other [error code] upon
 ** failure.
 */
-SQLITE_API int sqlite3_initialize(void);
-SQLITE_API int sqlite3_shutdown(void);
-SQLITE_API int sqlite3_os_init(void);
-SQLITE_API int sqlite3_os_end(void);
+SQLITE_API int SQLITE_STDCALL sqlite3_initialize(void);
+SQLITE_API int SQLITE_STDCALL sqlite3_shutdown(void);
+SQLITE_API int SQLITE_STDCALL sqlite3_os_init(void);
+SQLITE_API int SQLITE_STDCALL sqlite3_os_end(void);
 
 /*
 ** CAPI3REF: Configuring The SQLite Library
@@ -1352,10 +1376,11 @@ SQLITE_API int sqlite3_os_end(void);
 ** ^If the option is unknown or SQLite is unable to set the option
 ** then this routine returns a non-zero [error code].
 */
-SQLITE_API int sqlite3_config(int, ...);
+SQLITE_API int SQLITE_CDECL sqlite3_config(int, ...);
 
 /*
 ** CAPI3REF: Configure database connections
+** METHOD: sqlite3
 **
 ** The sqlite3_db_config() interface is used to make configuration
 ** changes to a [database connection].  The interface is similar to
@@ -1370,7 +1395,7 @@ SQLITE_API int sqlite3_config(int, ...);
 ** ^Calls to sqlite3_db_config() return SQLITE_OK if and only if
 ** the call is considered successful.
 */
-SQLITE_API int sqlite3_db_config(sqlite3*, int op, ...);
+SQLITE_API int SQLITE_CDECL sqlite3_db_config(sqlite3*, int op, ...);
 
 /*
 ** CAPI3REF: Memory Allocation Routines
@@ -1530,7 +1555,7 @@ struct sqlite3_mem_methods {
 **   <li> [sqlite3_memory_used()]
 **   <li> [sqlite3_memory_highwater()]
 **   <li> [sqlite3_soft_heap_limit64()]
-**   <li> [sqlite3_status()]
+**   <li> [sqlite3_status64()]
 **   </ul>)^
 ** ^Memory allocation statistics are enabled by default unless SQLite is
 ** compiled with [SQLITE_DEFAULT_MEMSTATUS]=0 in which case memory
@@ -1741,7 +1766,6 @@ struct sqlite3_mem_methods {
 ** compiled for Windows with the [SQLITE_WIN32_MALLOC] pre-processor macro
 ** defined. ^SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer value
 ** that specifies the maximum size of the created heap.
-** </dl>
 **
 ** [[SQLITE_CONFIG_PCACHE_HDRSZ]]
 ** <dt>SQLITE_CONFIG_PCACHE_HDRSZ
@@ -1854,15 +1878,17 @@ struct sqlite3_mem_methods {
 
 /*
 ** CAPI3REF: Enable Or Disable Extended Result Codes
+** METHOD: sqlite3
 **
 ** ^The sqlite3_extended_result_codes() routine enables or disables the
 ** [extended result codes] feature of SQLite. ^The extended result
 ** codes are disabled by default for historical compatibility.
 */
-SQLITE_API int sqlite3_extended_result_codes(sqlite3*, int onoff);
+SQLITE_API int SQLITE_STDCALL sqlite3_extended_result_codes(sqlite3*, int onoff);
 
 /*
 ** CAPI3REF: Last Insert Rowid
+** METHOD: sqlite3
 **
 ** ^Each entry in most SQLite tables (except for [WITHOUT ROWID] tables)
 ** has a unique 64-bit signed
@@ -1910,10 +1936,11 @@ SQLITE_API int sqlite3_extended_result_codes(sqlite3*, int onoff);
 ** unpredictable and might not equal either the old or the new
 ** last insert [rowid].
 */
-SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_last_insert_rowid(sqlite3*);
 
 /*
 ** CAPI3REF: Count The Number Of Rows Modified
+** METHOD: sqlite3
 **
 ** ^This function returns the number of rows modified, inserted or
 ** deleted by the most recently completed INSERT, UPDATE or DELETE
@@ -1962,10 +1989,11 @@ SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);
 ** while [sqlite3_changes()] is running then the value returned
 ** is unpredictable and not meaningful.
 */
-SQLITE_API int sqlite3_changes(sqlite3*);
+SQLITE_API int SQLITE_STDCALL sqlite3_changes(sqlite3*);
 
 /*
 ** CAPI3REF: Total Number Of Rows Modified
+** METHOD: sqlite3
 **
 ** ^This function returns the total number of rows inserted, modified or
 ** deleted by all [INSERT], [UPDATE] or [DELETE] statements completed
@@ -1985,10 +2013,11 @@ SQLITE_API int sqlite3_changes(sqlite3*);
 ** while [sqlite3_total_changes()] is running then the value
 ** returned is unpredictable and not meaningful.
 */
-SQLITE_API int sqlite3_total_changes(sqlite3*);
+SQLITE_API int SQLITE_STDCALL sqlite3_total_changes(sqlite3*);
 
 /*
 ** CAPI3REF: Interrupt A Long-Running Query
+** METHOD: sqlite3
 **
 ** ^This function causes any pending database operation to abort and
 ** return at its earliest opportunity. This routine is typically
@@ -2024,7 +2053,7 @@ SQLITE_API int sqlite3_total_changes(sqlite3*);
 ** If the database connection closes while [sqlite3_interrupt()]
 ** is running then bad things will likely happen.
 */
-SQLITE_API void sqlite3_interrupt(sqlite3*);
+SQLITE_API void SQLITE_STDCALL sqlite3_interrupt(sqlite3*);
 
 /*
 ** CAPI3REF: Determine If An SQL Statement Is Complete
@@ -2059,12 +2088,13 @@ SQLITE_API void sqlite3_interrupt(sqlite3*);
 ** The input to [sqlite3_complete16()] must be a zero-terminated
 ** UTF-16 string in native byte order.
 */
-SQLITE_API int sqlite3_complete(const char *sql);
-SQLITE_API int sqlite3_complete16(const void *sql);
+SQLITE_API int SQLITE_STDCALL sqlite3_complete(const char *sql);
+SQLITE_API int SQLITE_STDCALL sqlite3_complete16(const void *sql);
 
 /*
 ** CAPI3REF: Register A Callback To Handle SQLITE_BUSY Errors
 ** KEYWORDS: {busy-handler callback} {busy handler}
+** METHOD: sqlite3
 **
 ** ^The sqlite3_busy_handler(D,X,P) routine sets a callback function X
 ** that might be invoked with argument P whenever
@@ -2120,10 +2150,11 @@ SQLITE_API int sqlite3_complete16(const void *sql);
 ** A busy handler must not close the database connection
 ** or [prepared statement] that invoked the busy handler.
 */
-SQLITE_API int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);
+SQLITE_API int SQLITE_STDCALL sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);
 
 /*
 ** CAPI3REF: Set A Busy Timeout
+** METHOD: sqlite3
 **
 ** ^This routine sets a [sqlite3_busy_handler | busy handler] that sleeps
 ** for a specified amount of time when a table is locked.  ^The handler
@@ -2142,10 +2173,11 @@ SQLITE_API int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);
 **
 ** See also:  [PRAGMA busy_timeout]
 */
-SQLITE_API int sqlite3_busy_timeout(sqlite3*, int ms);
+SQLITE_API int SQLITE_STDCALL sqlite3_busy_timeout(sqlite3*, int ms);
 
 /*
 ** CAPI3REF: Convenience Routines For Running Queries
+** METHOD: sqlite3
 **
 ** This is a legacy interface that is preserved for backwards compatibility.
 ** Use of this interface is not recommended.
@@ -2216,7 +2248,7 @@ SQLITE_API int sqlite3_busy_timeout(sqlite3*, int ms);
 ** reflected in subsequent calls to [sqlite3_errcode()] or
 ** [sqlite3_errmsg()].
 */
-SQLITE_API int sqlite3_get_table(
+SQLITE_API int SQLITE_STDCALL sqlite3_get_table(
   sqlite3 *db,          /* An open database */
   const char *zSql,     /* SQL to be evaluated */
   char ***pazResult,    /* Results of the query */
@@ -2224,13 +2256,17 @@ SQLITE_API int sqlite3_get_table(
   int *pnColumn,        /* Number of result columns written here */
   char **pzErrmsg       /* Error msg written here */
 );
-SQLITE_API void sqlite3_free_table(char **result);
+SQLITE_API void SQLITE_STDCALL sqlite3_free_table(char **result);
 
 /*
 ** CAPI3REF: Formatted String Printing Functions
 **
 ** These routines are work-alikes of the "printf()" family of functions
 ** from the standard C library.
+** These routines understand most of the common K&R formatting options,
+** plus some additional non-standard formats, detailed below.
+** Note that some of the more obscure formatting options from recent
+** C-library standards are omitted from this implementation.
 **
 ** ^The sqlite3_mprintf() and sqlite3_vmprintf() routines write their
 ** results into memory obtained from [sqlite3_malloc()].
@@ -2263,7 +2299,7 @@ SQLITE_API void sqlite3_free_table(char **result);
 ** These routines all implement some additional formatting
 ** options that are useful for constructing SQL statements.
 ** All of the usual printf() formatting options apply.  In addition, there
-** is are "%q", "%Q", and "%z" options.
+** is are "%q", "%Q", "%w" and "%z" options.
 **
 ** ^(The %q option works like %s in that it substitutes a nul-terminated
 ** string from the argument list.  But %q also doubles every '\'' character.
@@ -2316,14 +2352,20 @@ SQLITE_API void sqlite3_free_table(char **result);
 ** The code above will render a correct SQL statement in the zSQL
 ** variable even if the zText variable is a NULL pointer.
 **
+** ^(The "%w" formatting option is like "%q" except that it expects to
+** be contained within double-quotes instead of single quotes, and it
+** escapes the double-quote character instead of the single-quote
+** character.)^  The "%w" formatting option is intended for safely inserting
+** table and column names into a constructed SQL statement.
+**
 ** ^(The "%z" formatting option works like "%s" but with the
 ** addition that after the string has been read and copied into
 ** the result, [sqlite3_free()] is called on the input string.)^
 */
-SQLITE_API char *sqlite3_mprintf(const char*,...);
-SQLITE_API char *sqlite3_vmprintf(const char*, va_list);
-SQLITE_API char *sqlite3_snprintf(int,char*,const char*, ...);
-SQLITE_API char *sqlite3_vsnprintf(int,char*,const char*, va_list);
+SQLITE_API char *SQLITE_CDECL sqlite3_mprintf(const char*,...);
+SQLITE_API char *SQLITE_STDCALL sqlite3_vmprintf(const char*, va_list);
+SQLITE_API char *SQLITE_CDECL sqlite3_snprintf(int,char*,const char*, ...);
+SQLITE_API char *SQLITE_STDCALL sqlite3_vsnprintf(int,char*,const char*, va_list);
 
 /*
 ** CAPI3REF: Memory Allocation Subsystem
@@ -2413,12 +2455,12 @@ SQLITE_API char *sqlite3_vsnprintf(int,char*,const char*, va_list);
 ** a block of memory after it has been released using
 ** [sqlite3_free()] or [sqlite3_realloc()].
 */
-SQLITE_API void *sqlite3_malloc(int);
-SQLITE_API void *sqlite3_malloc64(sqlite3_uint64);
-SQLITE_API void *sqlite3_realloc(void*, int);
-SQLITE_API void *sqlite3_realloc64(void*, sqlite3_uint64);
-SQLITE_API void sqlite3_free(void*);
-SQLITE_API sqlite3_uint64 sqlite3_msize(void*);
+SQLITE_API void *SQLITE_STDCALL sqlite3_malloc(int);
+SQLITE_API void *SQLITE_STDCALL sqlite3_malloc64(sqlite3_uint64);
+SQLITE_API void *SQLITE_STDCALL sqlite3_realloc(void*, int);
+SQLITE_API void *SQLITE_STDCALL sqlite3_realloc64(void*, sqlite3_uint64);
+SQLITE_API void SQLITE_STDCALL sqlite3_free(void*);
+SQLITE_API sqlite3_uint64 SQLITE_STDCALL sqlite3_msize(void*);
 
 /*
 ** CAPI3REF: Memory Allocator Statistics
@@ -2443,8 +2485,8 @@ SQLITE_API sqlite3_uint64 sqlite3_msize(void*);
 ** by [sqlite3_memory_highwater(1)] is the high-water mark
 ** prior to the reset.
 */
-SQLITE_API sqlite3_int64 sqlite3_memory_used(void);
-SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag);
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_memory_used(void);
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_memory_highwater(int resetFlag);
 
 /*
 ** CAPI3REF: Pseudo-Random Number Generator
@@ -2467,10 +2509,11 @@ SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag);
 ** internally and without recourse to the [sqlite3_vfs] xRandomness
 ** method.
 */
-SQLITE_API void sqlite3_randomness(int N, void *P);
+SQLITE_API void SQLITE_STDCALL sqlite3_randomness(int N, void *P);
 
 /*
 ** CAPI3REF: Compile-Time Authorization Callbacks
+** METHOD: sqlite3
 **
 ** ^This routine registers an authorizer callback with a particular
 ** [database connection], supplied in the first argument.
@@ -2549,7 +2592,7 @@ SQLITE_API void sqlite3_randomness(int N, void *P);
 ** as stated in the previous paragraph, sqlite3_step() invokes
 ** sqlite3_prepare_v2() to reprepare a statement after a schema change.
 */
-SQLITE_API int sqlite3_set_authorizer(
+SQLITE_API int SQLITE_STDCALL sqlite3_set_authorizer(
   sqlite3*,
   int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),
   void *pUserData
@@ -2627,6 +2670,7 @@ SQLITE_API int sqlite3_set_authorizer(
 
 /*
 ** CAPI3REF: Tracing And Profiling Functions
+** METHOD: sqlite3
 **
 ** These routines register callback functions that can be used for
 ** tracing and profiling the execution of SQL statements.
@@ -2653,12 +2697,13 @@ SQLITE_API int sqlite3_set_authorizer(
 ** sqlite3_profile() function is considered experimental and is
 ** subject to change in future versions of SQLite.
 */
-SQLITE_API void *sqlite3_trace(sqlite3*, void(*xTrace)(void*,const char*), void*);
-SQLITE_API SQLITE_EXPERIMENTAL void *sqlite3_profile(sqlite3*,
+SQLITE_API void *SQLITE_STDCALL sqlite3_trace(sqlite3*, void(*xTrace)(void*,const char*), void*);
+SQLITE_API SQLITE_EXPERIMENTAL void *SQLITE_STDCALL sqlite3_profile(sqlite3*,
    void(*xProfile)(void*,const char*,sqlite3_uint64), void*);
 
 /*
 ** CAPI3REF: Query Progress Callbacks
+** METHOD: sqlite3
 **
 ** ^The sqlite3_progress_handler(D,N,X,P) interface causes the callback
 ** function X to be invoked periodically during long running calls to
@@ -2688,10 +2733,11 @@ SQLITE_API SQLITE_EXPERIMENTAL void *sqlite3_profile(sqlite3*,
 ** database connections for the meaning of "modify" in this paragraph.
 **
 */
-SQLITE_API void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);
+SQLITE_API void SQLITE_STDCALL sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);
 
 /*
 ** CAPI3REF: Opening A New Database Connection
+** CONSTRUCTOR: sqlite3
 **
 ** ^These routines open an SQLite database file as specified by the 
 ** filename argument. ^The filename argument is interpreted as UTF-8 for
@@ -2916,15 +2962,15 @@ SQLITE_API void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);
 **
 ** See also: [sqlite3_temp_directory]
 */
-SQLITE_API int sqlite3_open(
+SQLITE_API int SQLITE_STDCALL sqlite3_open(
   const char *filename,   /* Database filename (UTF-8) */
   sqlite3 **ppDb          /* OUT: SQLite db handle */
 );
-SQLITE_API int sqlite3_open16(
+SQLITE_API int SQLITE_STDCALL sqlite3_open16(
   const void *filename,   /* Database filename (UTF-16) */
   sqlite3 **ppDb          /* OUT: SQLite db handle */
 );
-SQLITE_API int sqlite3_open_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_open_v2(
   const char *filename,   /* Database filename (UTF-8) */
   sqlite3 **ppDb,         /* OUT: SQLite db handle */
   int flags,              /* Flags */
@@ -2970,19 +3016,22 @@ SQLITE_API int sqlite3_open_v2(
 ** VFS method, then the behavior of this routine is undefined and probably
 ** undesirable.
 */
-SQLITE_API const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam);
-SQLITE_API int sqlite3_uri_boolean(const char *zFile, const char *zParam, int bDefault);
-SQLITE_API sqlite3_int64 sqlite3_uri_int64(const char*, const char*, sqlite3_int64);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_uri_parameter(const char *zFilename, const char *zParam);
+SQLITE_API int SQLITE_STDCALL sqlite3_uri_boolean(const char *zFile, const char *zParam, int bDefault);
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_uri_int64(const char*, const char*, sqlite3_int64);
 
 
 /*
 ** CAPI3REF: Error Codes And Messages
-**
-** ^The sqlite3_errcode() interface returns the numeric [result code] or
-** [extended result code] for the most recent failed sqlite3_* API call
-** associated with a [database connection]. If a prior API call failed
-** but the most recent API call succeeded, the return value from
-** sqlite3_errcode() is undefined.  ^The sqlite3_extended_errcode()
+** METHOD: sqlite3
+**
+** ^If the most recent sqlite3_* API call associated with 
+** [database connection] D failed, then the sqlite3_errcode(D) interface
+** returns the numeric [result code] or [extended result code] for that
+** API call.
+** If the most recent API call was successful,
+** then the return value from sqlite3_errcode() is undefined.
+** ^The sqlite3_extended_errcode()
 ** interface is the same except that it always returns the 
 ** [extended result code] even when extended result codes are
 ** disabled.
@@ -3013,40 +3062,41 @@ SQLITE_API sqlite3_int64 sqlite3_uri_int64(const char*, const char*, sqlite3_int
 ** was invoked incorrectly by the application.  In that case, the
 ** error code and message may or may not be set.
 */
-SQLITE_API int sqlite3_errcode(sqlite3 *db);
-SQLITE_API int sqlite3_extended_errcode(sqlite3 *db);
-SQLITE_API const char *sqlite3_errmsg(sqlite3*);
-SQLITE_API const void *sqlite3_errmsg16(sqlite3*);
-SQLITE_API const char *sqlite3_errstr(int);
+SQLITE_API int SQLITE_STDCALL sqlite3_errcode(sqlite3 *db);
+SQLITE_API int SQLITE_STDCALL sqlite3_extended_errcode(sqlite3 *db);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_errmsg(sqlite3*);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_errmsg16(sqlite3*);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_errstr(int);
 
 /*
-** CAPI3REF: SQL Statement Object
+** CAPI3REF: Prepared Statement Object
 ** KEYWORDS: {prepared statement} {prepared statements}
 **
-** An instance of this object represents a single SQL statement.
-** This object is variously known as a "prepared statement" or a
-** "compiled SQL statement" or simply as a "statement".
+** An instance of this object represents a single SQL statement that
+** has been compiled into binary form and is ready to be evaluated.
 **
-** The life of a statement object goes something like this:
+** Think of each SQL statement as a separate computer program.  The
+** original SQL text is source code.  A prepared statement object 
+** is the compiled object code.  All SQL must be converted into a
+** prepared statement before it can be run.
+**
+** The life-cycle of a prepared statement object usually goes like this:
 **
 ** <ol>
-** <li> Create the object using [sqlite3_prepare_v2()] or a related
-**      function.
-** <li> Bind values to [host parameters] using the sqlite3_bind_*()
+** <li> Create the prepared statement object using [sqlite3_prepare_v2()].
+** <li> Bind values to [parameters] using the sqlite3_bind_*()
 **      interfaces.
 ** <li> Run the SQL by calling [sqlite3_step()] one or more times.
-** <li> Reset the statement using [sqlite3_reset()] then go back
+** <li> Reset the prepared statement using [sqlite3_reset()] then go back
 **      to step 2.  Do this zero or more times.
 ** <li> Destroy the object using [sqlite3_finalize()].
 ** </ol>
-**
-** Refer to documentation on individual methods above for additional
-** information.
 */
 typedef struct sqlite3_stmt sqlite3_stmt;
 
 /*
 ** CAPI3REF: Run-time Limits
+** METHOD: sqlite3
 **
 ** ^(This interface allows the size of various constructs to be limited
 ** on a connection by connection basis.  The first parameter is the
@@ -3084,7 +3134,7 @@ typedef struct sqlite3_stmt sqlite3_stmt;
 **
 ** New run-time limit categories may be added in future releases.
 */
-SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
+SQLITE_API int SQLITE_STDCALL sqlite3_limit(sqlite3*, int id, int newVal);
 
 /*
 ** CAPI3REF: Run-Time Limit Categories
@@ -3158,6 +3208,8 @@ SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
 /*
 ** CAPI3REF: Compiling An SQL Statement
 ** KEYWORDS: {SQL statement compiler}
+** METHOD: sqlite3
+** CONSTRUCTOR: sqlite3_stmt
 **
 ** To execute an SQL query, it must first be compiled into a byte-code
 ** program using one of these routines.
@@ -3171,16 +3223,14 @@ SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
 ** interfaces use UTF-8, and sqlite3_prepare16() and sqlite3_prepare16_v2()
 ** use UTF-16.
 **
-** ^If the nByte argument is less than zero, then zSql is read up to the
-** first zero terminator. ^If nByte is non-negative, then it is the maximum
-** number of  bytes read from zSql.  ^When nByte is non-negative, the
-** zSql string ends at either the first '\000' or '\u0000' character or
-** the nByte-th byte, whichever comes first. If the caller knows
-** that the supplied string is nul-terminated, then there is a small
-** performance advantage to be gained by passing an nByte parameter that
-** is equal to the number of bytes in the input string <i>including</i>
-** the nul-terminator bytes as this saves SQLite from having to
-** make a copy of the input string.
+** ^If the nByte argument is negative, then zSql is read up to the
+** first zero terminator. ^If nByte is positive, then it is the
+** number of bytes read from zSql.  ^If nByte is zero, then no prepared
+** statement is generated.
+** If the caller knows that the supplied string is nul-terminated, then
+** there is a small performance advantage to passing an nByte parameter that
+** is the number of bytes in the input string <i>including</i>
+** the nul-terminator.
 **
 ** ^If pzTail is not NULL then *pzTail is made to point to the first byte
 ** past the end of the first SQL statement in zSql.  These routines only
@@ -3236,28 +3286,28 @@ SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
 ** </li>
 ** </ol>
 */
-SQLITE_API int sqlite3_prepare(
+SQLITE_API int SQLITE_STDCALL sqlite3_prepare(
   sqlite3 *db,            /* Database handle */
   const char *zSql,       /* SQL statement, UTF-8 encoded */
   int nByte,              /* Maximum length of zSql in bytes. */
   sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
   const char **pzTail     /* OUT: Pointer to unused portion of zSql */
 );
-SQLITE_API int sqlite3_prepare_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_prepare_v2(
   sqlite3 *db,            /* Database handle */
   const char *zSql,       /* SQL statement, UTF-8 encoded */
   int nByte,              /* Maximum length of zSql in bytes. */
   sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
   const char **pzTail     /* OUT: Pointer to unused portion of zSql */
 );
-SQLITE_API int sqlite3_prepare16(
+SQLITE_API int SQLITE_STDCALL sqlite3_prepare16(
   sqlite3 *db,            /* Database handle */
   const void *zSql,       /* SQL statement, UTF-16 encoded */
   int nByte,              /* Maximum length of zSql in bytes. */
   sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
   const void **pzTail     /* OUT: Pointer to unused portion of zSql */
 );
-SQLITE_API int sqlite3_prepare16_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_prepare16_v2(
   sqlite3 *db,            /* Database handle */
   const void *zSql,       /* SQL statement, UTF-16 encoded */
   int nByte,              /* Maximum length of zSql in bytes. */
@@ -3267,15 +3317,17 @@ SQLITE_API int sqlite3_prepare16_v2(
 
 /*
 ** CAPI3REF: Retrieving Statement SQL
+** METHOD: sqlite3_stmt
 **
 ** ^This interface can be used to retrieve a saved copy of the original
 ** SQL text used to create a [prepared statement] if that statement was
 ** compiled using either [sqlite3_prepare_v2()] or [sqlite3_prepare16_v2()].
 */
-SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_sql(sqlite3_stmt *pStmt);
 
 /*
 ** CAPI3REF: Determine If An SQL Statement Writes The Database
+** METHOD: sqlite3_stmt
 **
 ** ^The sqlite3_stmt_readonly(X) interface returns true (non-zero) if
 ** and only if the [prepared statement] X makes no direct changes to
@@ -3303,10 +3355,11 @@ SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt);
 ** change the configuration of a database connection, they do not make 
 ** changes to the content of the database files on disk.
 */
-SQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt);
+SQLITE_API int SQLITE_STDCALL sqlite3_stmt_readonly(sqlite3_stmt *pStmt);
 
 /*
 ** CAPI3REF: Determine If A Prepared Statement Has Been Reset
+** METHOD: sqlite3_stmt
 **
 ** ^The sqlite3_stmt_busy(S) interface returns true (non-zero) if the
 ** [prepared statement] S has been stepped at least once using 
@@ -3322,7 +3375,7 @@ SQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt);
 ** for example, in diagnostic routines to search for prepared 
 ** statements that are holding a transaction open.
 */
-SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt*);
+SQLITE_API int SQLITE_STDCALL sqlite3_stmt_busy(sqlite3_stmt*);
 
 /*
 ** CAPI3REF: Dynamically Typed Value Object
@@ -3381,6 +3434,7 @@ typedef struct sqlite3_context sqlite3_context;
 ** CAPI3REF: Binding Values To Prepared Statements
 ** KEYWORDS: {host parameter} {host parameters} {host parameter name}
 ** KEYWORDS: {SQL parameter} {SQL parameters} {parameter binding}
+** METHOD: sqlite3_stmt
 **
 ** ^(In the SQL statement text input to [sqlite3_prepare_v2()] and its variants,
 ** literals may be replaced by a [parameter] that matches one of following
@@ -3483,22 +3537,23 @@ typedef struct sqlite3_context sqlite3_context;
 ** See also: [sqlite3_bind_parameter_count()],
 ** [sqlite3_bind_parameter_name()], and [sqlite3_bind_parameter_index()].
 */
-SQLITE_API int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
-SQLITE_API int sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64,
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64,
                         void(*)(void*));
-SQLITE_API int sqlite3_bind_double(sqlite3_stmt*, int, double);
-SQLITE_API int sqlite3_bind_int(sqlite3_stmt*, int, int);
-SQLITE_API int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);
-SQLITE_API int sqlite3_bind_null(sqlite3_stmt*, int);
-SQLITE_API int sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));
-SQLITE_API int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));
-SQLITE_API int sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_double(sqlite3_stmt*, int, double);
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_int(sqlite3_stmt*, int, int);
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_null(sqlite3_stmt*, int);
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,
                          void(*)(void*), unsigned char encoding);
-SQLITE_API int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
-SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
 
 /*
 ** CAPI3REF: Number Of SQL Parameters
+** METHOD: sqlite3_stmt
 **
 ** ^This routine can be used to find the number of [SQL parameters]
 ** in a [prepared statement].  SQL parameters are tokens of the
@@ -3515,10 +3570,11 @@ SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
 ** [sqlite3_bind_parameter_name()], and
 ** [sqlite3_bind_parameter_index()].
 */
-SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt*);
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_parameter_count(sqlite3_stmt*);
 
 /*
 ** CAPI3REF: Name Of A Host Parameter
+** METHOD: sqlite3_stmt
 **
 ** ^The sqlite3_bind_parameter_name(P,N) interface returns
 ** the name of the N-th [SQL parameter] in the [prepared statement] P.
@@ -3542,10 +3598,11 @@ SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt*);
 ** [sqlite3_bind_parameter_count()], and
 ** [sqlite3_bind_parameter_index()].
 */
-SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_bind_parameter_name(sqlite3_stmt*, int);
 
 /*
 ** CAPI3REF: Index Of A Parameter With A Given Name
+** METHOD: sqlite3_stmt
 **
 ** ^Return the index of an SQL parameter given its name.  ^The
 ** index value returned is suitable for use as the second
@@ -3558,19 +3615,21 @@ SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);
 ** [sqlite3_bind_parameter_count()], and
 ** [sqlite3_bind_parameter_index()].
 */
-SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);
+SQLITE_API int SQLITE_STDCALL sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);
 
 /*
 ** CAPI3REF: Reset All Bindings On A Prepared Statement
+** METHOD: sqlite3_stmt
 **
 ** ^Contrary to the intuition of many, [sqlite3_reset()] does not reset
 ** the [sqlite3_bind_blob | bindings] on a [prepared statement].
 ** ^Use this routine to reset all host parameters to NULL.
 */
-SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt*);
+SQLITE_API int SQLITE_STDCALL sqlite3_clear_bindings(sqlite3_stmt*);
 
 /*
 ** CAPI3REF: Number Of Columns In A Result Set
+** METHOD: sqlite3_stmt
 **
 ** ^Return the number of columns in the result set returned by the
 ** [prepared statement]. ^This routine returns 0 if pStmt is an SQL
@@ -3578,10 +3637,11 @@ SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt*);
 **
 ** See also: [sqlite3_data_count()]
 */
-SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt);
+SQLITE_API int SQLITE_STDCALL sqlite3_column_count(sqlite3_stmt *pStmt);
 
 /*
 ** CAPI3REF: Column Names In A Result Set
+** METHOD: sqlite3_stmt
 **
 ** ^These routines return the name assigned to a particular column
 ** in the result set of a [SELECT] statement.  ^The sqlite3_column_name()
@@ -3606,11 +3666,12 @@ SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt);
 ** then the name of the column is unspecified and may change from
 ** one release of SQLite to the next.
 */
-SQLITE_API const char *sqlite3_column_name(sqlite3_stmt*, int N);
-SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt*, int N);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_column_name(sqlite3_stmt*, int N);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_name16(sqlite3_stmt*, int N);
 
 /*
 ** CAPI3REF: Source Of Data In A Query Result
+** METHOD: sqlite3_stmt
 **
 ** ^These routines provide a means to determine the database, table, and
 ** table column that is the origin of a particular result column in
@@ -3654,15 +3715,16 @@ SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt*, int N);
 ** for the same [prepared statement] and result column
 ** at the same time then the results are undefined.
 */
-SQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt*,int);
-SQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt*,int);
-SQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt*,int);
-SQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt*,int);
-SQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt*,int);
-SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt*,int);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_column_database_name(sqlite3_stmt*,int);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_database_name16(sqlite3_stmt*,int);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_column_table_name(sqlite3_stmt*,int);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_table_name16(sqlite3_stmt*,int);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_column_origin_name(sqlite3_stmt*,int);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_origin_name16(sqlite3_stmt*,int);
 
 /*
 ** CAPI3REF: Declared Datatype Of A Query Result
+** METHOD: sqlite3_stmt
 **
 ** ^(The first parameter is a [prepared statement].
 ** If this statement is a [SELECT] statement and the Nth column of the
@@ -3690,11 +3752,12 @@ SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt*,int);
 ** is associated with individual values, not with the containers
 ** used to hold those values.
 */
-SQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt*,int);
-SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_column_decltype(sqlite3_stmt*,int);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_decltype16(sqlite3_stmt*,int);
 
 /*
 ** CAPI3REF: Evaluate An SQL Statement
+** METHOD: sqlite3_stmt
 **
 ** After a [prepared statement] has been prepared using either
 ** [sqlite3_prepare_v2()] or [sqlite3_prepare16_v2()] or one of the legacy
@@ -3770,10 +3833,11 @@ SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int);
 ** then the more specific [error codes] are returned directly
 ** by sqlite3_step().  The use of the "v2" interface is recommended.
 */
-SQLITE_API int sqlite3_step(sqlite3_stmt*);
+SQLITE_API int SQLITE_STDCALL sqlite3_step(sqlite3_stmt*);
 
 /*
 ** CAPI3REF: Number of columns in a result set
+** METHOD: sqlite3_stmt
 **
 ** ^The sqlite3_data_count(P) interface returns the number of columns in the
 ** current row of the result set of [prepared statement] P.
@@ -3790,7 +3854,7 @@ SQLITE_API int sqlite3_step(sqlite3_stmt*);
 **
 ** See also: [sqlite3_column_count()]
 */
-SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
+SQLITE_API int SQLITE_STDCALL sqlite3_data_count(sqlite3_stmt *pStmt);
 
 /*
 ** CAPI3REF: Fundamental Datatypes
@@ -3827,6 +3891,7 @@ SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
 /*
 ** CAPI3REF: Result Values From A Query
 ** KEYWORDS: {column access functions}
+** METHOD: sqlite3_stmt
 **
 ** These routines form the "result set" interface.
 **
@@ -3986,19 +4051,20 @@ SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
 ** pointer.  Subsequent calls to [sqlite3_errcode()] will return
 ** [SQLITE_NOMEM].)^
 */
-SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);
-SQLITE_API int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
-SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
-SQLITE_API double sqlite3_column_double(sqlite3_stmt*, int iCol);
-SQLITE_API int sqlite3_column_int(sqlite3_stmt*, int iCol);
-SQLITE_API sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);
-SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
-SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);
-SQLITE_API int sqlite3_column_type(sqlite3_stmt*, int iCol);
-SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_blob(sqlite3_stmt*, int iCol);
+SQLITE_API int SQLITE_STDCALL sqlite3_column_bytes(sqlite3_stmt*, int iCol);
+SQLITE_API int SQLITE_STDCALL sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
+SQLITE_API double SQLITE_STDCALL sqlite3_column_double(sqlite3_stmt*, int iCol);
+SQLITE_API int SQLITE_STDCALL sqlite3_column_int(sqlite3_stmt*, int iCol);
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_column_int64(sqlite3_stmt*, int iCol);
+SQLITE_API const unsigned char *SQLITE_STDCALL sqlite3_column_text(sqlite3_stmt*, int iCol);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_column_text16(sqlite3_stmt*, int iCol);
+SQLITE_API int SQLITE_STDCALL sqlite3_column_type(sqlite3_stmt*, int iCol);
+SQLITE_API sqlite3_value *SQLITE_STDCALL sqlite3_column_value(sqlite3_stmt*, int iCol);
 
 /*
 ** CAPI3REF: Destroy A Prepared Statement Object
+** DESTRUCTOR: sqlite3_stmt
 **
 ** ^The sqlite3_finalize() function is called to delete a [prepared statement].
 ** ^If the most recent evaluation of the statement encountered no errors
@@ -4022,10 +4088,11 @@ SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);
 ** statement after it has been finalized can result in undefined and
 ** undesirable behavior such as segfaults and heap corruption.
 */
-SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt);
+SQLITE_API int SQLITE_STDCALL sqlite3_finalize(sqlite3_stmt *pStmt);
 
 /*
 ** CAPI3REF: Reset A Prepared Statement Object
+** METHOD: sqlite3_stmt
 **
 ** The sqlite3_reset() function is called to reset a [prepared statement]
 ** object back to its initial state, ready to be re-executed.
@@ -4048,13 +4115,14 @@ SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt);
 ** ^The [sqlite3_reset(S)] interface does not change the values
 ** of any [sqlite3_bind_blob|bindings] on the [prepared statement] S.
 */
-SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt);
+SQLITE_API int SQLITE_STDCALL sqlite3_reset(sqlite3_stmt *pStmt);
 
 /*
 ** CAPI3REF: Create Or Redefine SQL Functions
 ** KEYWORDS: {function creation routines}
 ** KEYWORDS: {application-defined SQL function}
 ** KEYWORDS: {application-defined SQL functions}
+** METHOD: sqlite3
 **
 ** ^These functions (collectively known as "function creation routines")
 ** are used to add SQL functions or aggregates or to redefine the behavior
@@ -4147,7 +4215,7 @@ SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt);
 ** close the database connection nor finalize or reset the prepared
 ** statement in which the function is running.
 */
-SQLITE_API int sqlite3_create_function(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_function(
   sqlite3 *db,
   const char *zFunctionName,
   int nArg,
@@ -4157,7 +4225,7 @@ SQLITE_API int sqlite3_create_function(
   void (*xStep)(sqlite3_context*,int,sqlite3_value**),
   void (*xFinal)(sqlite3_context*)
 );
-SQLITE_API int sqlite3_create_function16(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_function16(
   sqlite3 *db,
   const void *zFunctionName,
   int nArg,
@@ -4167,7 +4235,7 @@ SQLITE_API int sqlite3_create_function16(
   void (*xStep)(sqlite3_context*,int,sqlite3_value**),
   void (*xFinal)(sqlite3_context*)
 );
-SQLITE_API int sqlite3_create_function_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_function_v2(
   sqlite3 *db,
   const char *zFunctionName,
   int nArg,
@@ -4209,21 +4277,22 @@ SQLITE_API int sqlite3_create_function_v2(
 ** These functions are [deprecated].  In order to maintain
 ** backwards compatibility with older code, these functions continue 
 ** to be supported.  However, new applications should avoid
-** the use of these functions.  To help encourage people to avoid
-** using these functions, we are not going to tell you what they do.
+** the use of these functions.  To encourage programmers to avoid
+** these functions, we will not explain what they do.
 */
 #ifndef SQLITE_OMIT_DEPRECATED
-SQLITE_API SQLITE_DEPRECATED int sqlite3_aggregate_count(sqlite3_context*);
-SQLITE_API SQLITE_DEPRECATED int sqlite3_expired(sqlite3_stmt*);
-SQLITE_API SQLITE_DEPRECATED int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);
-SQLITE_API SQLITE_DEPRECATED int sqlite3_global_recover(void);
-SQLITE_API SQLITE_DEPRECATED void sqlite3_thread_cleanup(void);
-SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*,sqlite3_int64,int),
+SQLITE_API SQLITE_DEPRECATED int SQLITE_STDCALL sqlite3_aggregate_count(sqlite3_context*);
+SQLITE_API SQLITE_DEPRECATED int SQLITE_STDCALL sqlite3_expired(sqlite3_stmt*);
+SQLITE_API SQLITE_DEPRECATED int SQLITE_STDCALL sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);
+SQLITE_API SQLITE_DEPRECATED int SQLITE_STDCALL sqlite3_global_recover(void);
+SQLITE_API SQLITE_DEPRECATED void SQLITE_STDCALL sqlite3_thread_cleanup(void);
+SQLITE_API SQLITE_DEPRECATED int SQLITE_STDCALL sqlite3_memory_alarm(void(*)(void*,sqlite3_int64,int),
                       void*,sqlite3_int64);
 #endif
 
 /*
 ** CAPI3REF: Obtaining SQL Function Parameter Values
+** METHOD: sqlite3_value
 **
 ** The C-language implementation of SQL functions and aggregates uses
 ** this set of interface routines to access the parameter values on
@@ -4267,21 +4336,22 @@ SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*,sqlite3_int6
 ** These routines must be called from the same thread as
 ** the SQL function that supplied the [sqlite3_value*] parameters.
 */
-SQLITE_API const void *sqlite3_value_blob(sqlite3_value*);
-SQLITE_API int sqlite3_value_bytes(sqlite3_value*);
-SQLITE_API int sqlite3_value_bytes16(sqlite3_value*);
-SQLITE_API double sqlite3_value_double(sqlite3_value*);
-SQLITE_API int sqlite3_value_int(sqlite3_value*);
-SQLITE_API sqlite3_int64 sqlite3_value_int64(sqlite3_value*);
-SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value*);
-SQLITE_API const void *sqlite3_value_text16(sqlite3_value*);
-SQLITE_API const void *sqlite3_value_text16le(sqlite3_value*);
-SQLITE_API const void *sqlite3_value_text16be(sqlite3_value*);
-SQLITE_API int sqlite3_value_type(sqlite3_value*);
-SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_value_blob(sqlite3_value*);
+SQLITE_API int SQLITE_STDCALL sqlite3_value_bytes(sqlite3_value*);
+SQLITE_API int SQLITE_STDCALL sqlite3_value_bytes16(sqlite3_value*);
+SQLITE_API double SQLITE_STDCALL sqlite3_value_double(sqlite3_value*);
+SQLITE_API int SQLITE_STDCALL sqlite3_value_int(sqlite3_value*);
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_value_int64(sqlite3_value*);
+SQLITE_API const unsigned char *SQLITE_STDCALL sqlite3_value_text(sqlite3_value*);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_value_text16(sqlite3_value*);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_value_text16le(sqlite3_value*);
+SQLITE_API const void *SQLITE_STDCALL sqlite3_value_text16be(sqlite3_value*);
+SQLITE_API int SQLITE_STDCALL sqlite3_value_type(sqlite3_value*);
+SQLITE_API int SQLITE_STDCALL sqlite3_value_numeric_type(sqlite3_value*);
 
 /*
 ** CAPI3REF: Obtain Aggregate Function Context
+** METHOD: sqlite3_context
 **
 ** Implementations of aggregate SQL functions use this
 ** routine to allocate memory for storing their state.
@@ -4322,10 +4392,11 @@ SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*);
 ** This routine must be called from the same thread in which
 ** the aggregate SQL function is running.
 */
-SQLITE_API void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);
+SQLITE_API void *SQLITE_STDCALL sqlite3_aggregate_context(sqlite3_context*, int nBytes);
 
 /*
 ** CAPI3REF: User Data For Functions
+** METHOD: sqlite3_context
 **
 ** ^The sqlite3_user_data() interface returns a copy of
 ** the pointer that was the pUserData parameter (the 5th parameter)
@@ -4336,10 +4407,11 @@ SQLITE_API void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);
 ** This routine must be called from the same thread in which
 ** the application-defined function is running.
 */
-SQLITE_API void *sqlite3_user_data(sqlite3_context*);
+SQLITE_API void *SQLITE_STDCALL sqlite3_user_data(sqlite3_context*);
 
 /*
 ** CAPI3REF: Database Connection For Functions
+** METHOD: sqlite3_context
 **
 ** ^The sqlite3_context_db_handle() interface returns a copy of
 ** the pointer to the [database connection] (the 1st parameter)
@@ -4347,10 +4419,11 @@ SQLITE_API void *sqlite3_user_data(sqlite3_context*);
 ** and [sqlite3_create_function16()] routines that originally
 ** registered the application defined function.
 */
-SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context*);
+SQLITE_API sqlite3 *SQLITE_STDCALL sqlite3_context_db_handle(sqlite3_context*);
 
 /*
 ** CAPI3REF: Function Auxiliary Data
+** METHOD: sqlite3_context
 **
 ** These functions may be used by (non-aggregate) SQL functions to
 ** associate metadata with argument values. If the same value is passed to
@@ -4399,8 +4472,8 @@ SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context*);
 ** These routines must be called from the same thread in which
 ** the SQL function is running.
 */
-SQLITE_API void *sqlite3_get_auxdata(sqlite3_context*, int N);
-SQLITE_API void sqlite3_set_auxdata(sqlite3_context*, int N, void*, void (*)(void*));
+SQLITE_API void *SQLITE_STDCALL sqlite3_get_auxdata(sqlite3_context*, int N);
+SQLITE_API void SQLITE_STDCALL sqlite3_set_auxdata(sqlite3_context*, int N, void*, void (*)(void*));
 
 
 /*
@@ -4423,6 +4496,7 @@ typedef void (*sqlite3_destructor_type)(void*);
 
 /*
 ** CAPI3REF: Setting The Result Of An SQL Function
+** METHOD: sqlite3_context
 **
 ** These routines are used by the xFunc or xFinal callbacks that
 ** implement SQL functions and aggregates.  See
@@ -4535,29 +4609,30 @@ typedef void (*sqlite3_destructor_type)(void*);
 ** than the one containing the application-defined function that received
 ** the [sqlite3_context] pointer, the results are undefined.
 */
-SQLITE_API void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));
-SQLITE_API void sqlite3_result_blob64(sqlite3_context*,const void*,
+SQLITE_API void SQLITE_STDCALL sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));
+SQLITE_API void SQLITE_STDCALL sqlite3_result_blob64(sqlite3_context*,const void*,
                            sqlite3_uint64,void(*)(void*));
-SQLITE_API void sqlite3_result_double(sqlite3_context*, double);
-SQLITE_API void sqlite3_result_error(sqlite3_context*, const char*, int);
-SQLITE_API void sqlite3_result_error16(sqlite3_context*, const void*, int);
-SQLITE_API void sqlite3_result_error_toobig(sqlite3_context*);
-SQLITE_API void sqlite3_result_error_nomem(sqlite3_context*);
-SQLITE_API void sqlite3_result_error_code(sqlite3_context*, int);
-SQLITE_API void sqlite3_result_int(sqlite3_context*, int);
-SQLITE_API void sqlite3_result_int64(sqlite3_context*, sqlite3_int64);
-SQLITE_API void sqlite3_result_null(sqlite3_context*);
-SQLITE_API void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));
-SQLITE_API void sqlite3_result_text64(sqlite3_context*, const char*,sqlite3_uint64,
+SQLITE_API void SQLITE_STDCALL sqlite3_result_double(sqlite3_context*, double);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_error(sqlite3_context*, const char*, int);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_error16(sqlite3_context*, const void*, int);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_error_toobig(sqlite3_context*);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_error_nomem(sqlite3_context*);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_error_code(sqlite3_context*, int);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_int(sqlite3_context*, int);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_int64(sqlite3_context*, sqlite3_int64);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_null(sqlite3_context*);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));
+SQLITE_API void SQLITE_STDCALL sqlite3_result_text64(sqlite3_context*, const char*,sqlite3_uint64,
                            void(*)(void*), unsigned char encoding);
-SQLITE_API void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*));
-SQLITE_API void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));
-SQLITE_API void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));
-SQLITE_API void sqlite3_result_value(sqlite3_context*, sqlite3_value*);
-SQLITE_API void sqlite3_result_zeroblob(sqlite3_context*, int n);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*));
+SQLITE_API void SQLITE_STDCALL sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));
+SQLITE_API void SQLITE_STDCALL sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));
+SQLITE_API void SQLITE_STDCALL sqlite3_result_value(sqlite3_context*, sqlite3_value*);
+SQLITE_API void SQLITE_STDCALL sqlite3_result_zeroblob(sqlite3_context*, int n);
 
 /*
 ** CAPI3REF: Define New Collating Sequences
+** METHOD: sqlite3
 **
 ** ^These functions add, remove, or modify a [collation] associated
 ** with the [database connection] specified as the first argument.
@@ -4635,14 +4710,14 @@ SQLITE_API void sqlite3_result_zeroblob(sqlite3_context*, int n);
 **
 ** See also:  [sqlite3_collation_needed()] and [sqlite3_collation_needed16()].
 */
-SQLITE_API int sqlite3_create_collation(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_collation(
   sqlite3*, 
   const char *zName, 
   int eTextRep, 
   void *pArg,
   int(*xCompare)(void*,int,const void*,int,const void*)
 );
-SQLITE_API int sqlite3_create_collation_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_collation_v2(
   sqlite3*, 
   const char *zName, 
   int eTextRep, 
@@ -4650,7 +4725,7 @@ SQLITE_API int sqlite3_create_collation_v2(
   int(*xCompare)(void*,int,const void*,int,const void*),
   void(*xDestroy)(void*)
 );
-SQLITE_API int sqlite3_create_collation16(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_collation16(
   sqlite3*, 
   const void *zName,
   int eTextRep, 
@@ -4660,6 +4735,7 @@ SQLITE_API int sqlite3_create_collation16(
 
 /*
 ** CAPI3REF: Collation Needed Callbacks
+** METHOD: sqlite3
 **
 ** ^To avoid having to register all collation sequences before a database
 ** can be used, a single callback function may be registered with the
@@ -4684,12 +4760,12 @@ SQLITE_API int sqlite3_create_collation16(
 ** [sqlite3_create_collation()], [sqlite3_create_collation16()], or
 ** [sqlite3_create_collation_v2()].
 */
-SQLITE_API int sqlite3_collation_needed(
+SQLITE_API int SQLITE_STDCALL sqlite3_collation_needed(
   sqlite3*, 
   void*, 
   void(*)(void*,sqlite3*,int eTextRep,const char*)
 );
-SQLITE_API int sqlite3_collation_needed16(
+SQLITE_API int SQLITE_STDCALL sqlite3_collation_needed16(
   sqlite3*, 
   void*,
   void(*)(void*,sqlite3*,int eTextRep,const void*)
@@ -4703,11 +4779,11 @@ SQLITE_API int sqlite3_collation_needed16(
 ** The code to implement this API is not available in the public release
 ** of SQLite.
 */
-SQLITE_API int sqlite3_key(
+SQLITE_API int SQLITE_STDCALL sqlite3_key(
   sqlite3 *db,                   /* Database to be rekeyed */
   const void *pKey, int nKey     /* The key */
 );
-SQLITE_API int sqlite3_key_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_key_v2(
   sqlite3 *db,                   /* Database to be rekeyed */
   const char *zDbName,           /* Name of the database */
   const void *pKey, int nKey     /* The key */
@@ -4721,11 +4797,11 @@ SQLITE_API int sqlite3_key_v2(
 ** The code to implement this API is not available in the public release
 ** of SQLite.
 */
-SQLITE_API int sqlite3_rekey(
+SQLITE_API int SQLITE_STDCALL sqlite3_rekey(
   sqlite3 *db,                   /* Database to be rekeyed */
   const void *pKey, int nKey     /* The new key */
 );
-SQLITE_API int sqlite3_rekey_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_rekey_v2(
   sqlite3 *db,                   /* Database to be rekeyed */
   const char *zDbName,           /* Name of the database */
   const void *pKey, int nKey     /* The new key */
@@ -4735,7 +4811,7 @@ SQLITE_API int sqlite3_rekey_v2(
 ** Specify the activation key for a SEE database.  Unless 
 ** activated, none of the SEE routines will work.
 */
-SQLITE_API void sqlite3_activate_see(
+SQLITE_API void SQLITE_STDCALL sqlite3_activate_see(
   const char *zPassPhrase        /* Activation phrase */
 );
 #endif
@@ -4745,7 +4821,7 @@ SQLITE_API void sqlite3_activate_see(
 ** Specify the activation key for a CEROD database.  Unless 
 ** activated, none of the CEROD routines will work.
 */
-SQLITE_API void sqlite3_activate_cerod(
+SQLITE_API void SQLITE_STDCALL sqlite3_activate_cerod(
   const char *zPassPhrase        /* Activation phrase */
 );
 #endif
@@ -4767,7 +4843,7 @@ SQLITE_API void sqlite3_activate_cerod(
 ** all, then the behavior of sqlite3_sleep() may deviate from the description
 ** in the previous paragraphs.
 */
-SQLITE_API int sqlite3_sleep(int);
+SQLITE_API int SQLITE_STDCALL sqlite3_sleep(int);
 
 /*
 ** CAPI3REF: Name Of The Folder Holding Temporary Files
@@ -4867,6 +4943,7 @@ SQLITE_API SQLITE_EXTERN char *sqlite3_data_directory;
 /*
 ** CAPI3REF: Test For Auto-Commit Mode
 ** KEYWORDS: {autocommit mode}
+** METHOD: sqlite3
 **
 ** ^The sqlite3_get_autocommit() interface returns non-zero or
 ** zero if the given database connection is or is not in autocommit mode,
@@ -4885,10 +4962,11 @@ SQLITE_API SQLITE_EXTERN char *sqlite3_data_directory;
 ** connection while this routine is running, then the return value
 ** is undefined.
 */
-SQLITE_API int sqlite3_get_autocommit(sqlite3*);
+SQLITE_API int SQLITE_STDCALL sqlite3_get_autocommit(sqlite3*);
 
 /*
 ** CAPI3REF: Find The Database Handle Of A Prepared Statement
+** METHOD: sqlite3_stmt
 **
 ** ^The sqlite3_db_handle interface returns the [database connection] handle
 ** to which a [prepared statement] belongs.  ^The [database connection]
@@ -4897,10 +4975,11 @@ SQLITE_API int sqlite3_get_autocommit(sqlite3*);
 ** to the [sqlite3_prepare_v2()] call (or its variants) that was used to
 ** create the statement in the first place.
 */
-SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt*);
+SQLITE_API sqlite3 *SQLITE_STDCALL sqlite3_db_handle(sqlite3_stmt*);
 
 /*
 ** CAPI3REF: Return The Filename For A Database Connection
+** METHOD: sqlite3
 **
 ** ^The sqlite3_db_filename(D,N) interface returns a pointer to a filename
 ** associated with database N of connection D.  ^The main database file
@@ -4913,19 +4992,21 @@ SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt*);
 ** will be an absolute pathname, even if the filename used
 ** to open the database originally was a URI or relative pathname.
 */
-SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName);
+SQLITE_API const char *SQLITE_STDCALL sqlite3_db_filename(sqlite3 *db, const char *zDbName);
 
 /*
 ** CAPI3REF: Determine if a database is read-only
+** METHOD: sqlite3
 **
 ** ^The sqlite3_db_readonly(D,N) interface returns 1 if the database N
 ** of connection D is read-only, 0 if it is read/write, or -1 if N is not
 ** the name of a database on connection D.
 */
-SQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName);
+SQLITE_API int SQLITE_STDCALL sqlite3_db_readonly(sqlite3 *db, const char *zDbName);
 
 /*
 ** CAPI3REF: Find the next prepared statement
+** METHOD: sqlite3
 **
 ** ^This interface returns a pointer to the next [prepared statement] after
 ** pStmt associated with the [database connection] pDb.  ^If pStmt is NULL
@@ -4937,10 +5018,11 @@ SQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName);
 ** [sqlite3_next_stmt(D,S)] must refer to an open database
 ** connection and in particular must not be a NULL pointer.
 */
-SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);
+SQLITE_API sqlite3_stmt *SQLITE_STDCALL sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);
 
 /*
 ** CAPI3REF: Commit And Rollback Notification Callbacks
+** METHOD: sqlite3
 **
 ** ^The sqlite3_commit_hook() interface registers a callback
 ** function to be invoked whenever a transaction is [COMMIT | committed].
@@ -4985,11 +5067,12 @@ SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);
 **
 ** See also the [sqlite3_update_hook()] interface.
 */
-SQLITE_API void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);
-SQLITE_API void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);
+SQLITE_API void *SQLITE_STDCALL sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);
+SQLITE_API void *SQLITE_STDCALL sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);
 
 /*
 ** CAPI3REF: Data Change Notification Callbacks
+** METHOD: sqlite3
 **
 ** ^The sqlite3_update_hook() interface registers a callback function
 ** with the [database connection] identified by the first argument
@@ -5036,7 +5119,7 @@ SQLITE_API void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);
 ** See also the [sqlite3_commit_hook()] and [sqlite3_rollback_hook()]
 ** interfaces.
 */
-SQLITE_API void *sqlite3_update_hook(
+SQLITE_API void *SQLITE_STDCALL sqlite3_update_hook(
   sqlite3*, 
   void(*)(void *,int ,char const *,char const *,sqlite3_int64),
   void*
@@ -5066,12 +5149,17 @@ SQLITE_API void *sqlite3_update_hook(
 ** future releases of SQLite.  Applications that care about shared
 ** cache setting should set it explicitly.
 **
+** Note: This method is disabled on MacOS X 10.7 and iOS version 5.0
+** and will always return SQLITE_MISUSE. On those systems, 
+** shared cache mode should be enabled per-database connection via 
+** [sqlite3_open_v2()] with [SQLITE_OPEN_SHAREDCACHE].
+**
 ** This interface is threadsafe on processors where writing a
 ** 32-bit integer is atomic.
 **
 ** See Also:  [SQLite Shared-Cache Mode]
 */
-SQLITE_API int sqlite3_enable_shared_cache(int);
+SQLITE_API int SQLITE_STDCALL sqlite3_enable_shared_cache(int);
 
 /*
 ** CAPI3REF: Attempt To Free Heap Memory
@@ -5087,10 +5175,11 @@ SQLITE_API int sqlite3_enable_shared_cache(int);
 **
 ** See also: [sqlite3_db_release_memory()]
 */
-SQLITE_API int sqlite3_release_memory(int);
+SQLITE_API int SQLITE_STDCALL sqlite3_release_memory(int);
 
 /*
 ** CAPI3REF: Free Memory Used By A Database Connection
+** METHOD: sqlite3
 **
 ** ^The sqlite3_db_release_memory(D) interface attempts to free as much heap
 ** memory as possible from database connection D. Unlike the
@@ -5100,7 +5189,7 @@ SQLITE_API int sqlite3_release_memory(int);
 **
 ** See also: [sqlite3_release_memory()]
 */
-SQLITE_API int sqlite3_db_release_memory(sqlite3*);
+SQLITE_API int SQLITE_STDCALL sqlite3_db_release_memory(sqlite3*);
 
 /*
 ** CAPI3REF: Impose A Limit On Heap Size
@@ -5152,7 +5241,7 @@ SQLITE_API int sqlite3_db_release_memory(sqlite3*);
 ** The circumstances under which SQLite will enforce the soft heap limit may
 ** changes in future releases of SQLite.
 */
-SQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 N);
+SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_soft_heap_limit64(sqlite3_int64 N);
 
 /*
 ** CAPI3REF: Deprecated Soft Heap Limit Interface
@@ -5163,11 +5252,12 @@ SQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 N);
 ** only.  All new applications should use the
 ** [sqlite3_soft_heap_limit64()] interface rather than this one.
 */
-SQLITE_API SQLITE_DEPRECATED void sqlite3_soft_heap_limit(int N);
+SQLITE_API SQLITE_DEPRECATED void SQLITE_STDCALL sqlite3_soft_heap_limit(int N);
 
 
 /*
 ** CAPI3REF: Extract Metadata About A Column Of A Table
+** METHOD: sqlite3
 **
 ** ^(The sqlite3_table_column_metadata(X,D,T,C,....) routine returns
 ** information about column C of table T in database D
@@ -5232,7 +5322,7 @@ SQLITE_API SQLITE_DEPRECATED void sqlite3_soft_heap_limit(int N);
 ** parsed, if that has not already been done, and returns an error if
 ** any errors are encountered while loading the schema.
 */
-SQLITE_API int sqlite3_table_column_metadata(
+SQLITE_API int SQLITE_STDCALL sqlite3_table_column_metadata(
   sqlite3 *db,                /* Connection handle */
   const char *zDbName,        /* Database name or NULL */
   const char *zTableName,     /* Table name */
@@ -5246,6 +5336,7 @@ SQLITE_API int sqlite3_table_column_metadata(
 
 /*
 ** CAPI3REF: Load An Extension
+** METHOD: sqlite3
 **
 ** ^This interface loads an SQLite extension library from the named file.
 **
@@ -5278,7 +5369,7 @@ SQLITE_API int sqlite3_table_column_metadata(
 **
 ** See also the [load_extension() SQL function].
 */
-SQLITE_API int sqlite3_load_extension(
+SQLITE_API int SQLITE_STDCALL sqlite3_load_extension(
   sqlite3 *db,          /* Load the extension into this database connection */
   const char *zFile,    /* Name of the shared library containing extension */
   const char *zProc,    /* Entry point.  Derived from zFile if 0 */
@@ -5287,6 +5378,7 @@ SQLITE_API int sqlite3_load_extension(
 
 /*
 ** CAPI3REF: Enable Or Disable Extension Loading
+** METHOD: sqlite3
 **
 ** ^So as not to open security holes in older applications that are
 ** unprepared to deal with [extension loading], and as a means of disabling
@@ -5298,7 +5390,7 @@ SQLITE_API int sqlite3_load_extension(
 ** to turn extension loading on and call it with onoff==0 to turn
 ** it back off again.
 */
-SQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff);
+SQLITE_API int SQLITE_STDCALL sqlite3_enable_load_extension(sqlite3 *db, int onoff);
 
 /*
 ** CAPI3REF: Automatically Load Statically Linked Extensions
@@ -5336,7 +5428,7 @@ SQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff);
 ** See also: [sqlite3_reset_auto_extension()]
 ** and [sqlite3_cancel_auto_extension()]
 */
-SQLITE_API int sqlite3_auto_extension(void (*xEntryPoint)(void));
+SQLITE_API int SQLITE_STDCALL sqlite3_auto_extension(void (*xEntryPoint)(void));
 
 /*
 ** CAPI3REF: Cancel Automatic Extension Loading
@@ -5348,7 +5440,7 @@ SQLITE_API int sqlite3_auto_extension(void (*xEntryPoint)(void));
 ** unregistered and it returns 0 if X was not on the list of initialization
 ** routines.
 */
-SQLITE_API int sqlite3_cancel_auto_extension(void (*xEntryPoint)(void));
+SQLITE_API int SQLITE_STDCALL sqlite3_cancel_auto_extension(void (*xEntryPoint)(void));
 
 /*
 ** CAPI3REF: Reset Automatic Extension Loading
@@ -5356,7 +5448,7 @@ SQLITE_API int sqlite3_cancel_auto_extension(void (*xEntryPoint)(void));
 ** ^This interface disables all automatic extensions previously
 ** registered using [sqlite3_auto_extension()].
 */
-SQLITE_API void sqlite3_reset_auto_extension(void);
+SQLITE_API void SQLITE_STDCALL sqlite3_reset_auto_extension(void);
 
 /*
 ** The interface to the virtual-table mechanism is currently considered
@@ -5536,6 +5628,7 @@ struct sqlite3_index_info {
 
 /*
 ** CAPI3REF: Register A Virtual Table Implementation
+** METHOD: sqlite3
 **
 ** ^These routines are used to register a new [virtual table module] name.
 ** ^Module names must be registered before
@@ -5559,13 +5652,13 @@ struct sqlite3_index_info {
 ** interface is equivalent to sqlite3_create_module_v2() with a NULL
 ** destructor.
 */
-SQLITE_API int sqlite3_create_module(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_module(
   sqlite3 *db,               /* SQLite connection to register module with */
   const char *zName,         /* Name of the module */
   const sqlite3_module *p,   /* Methods for the module */
   void *pClientData          /* Client data for xCreate/xConnect */
 );
-SQLITE_API int sqlite3_create_module_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_create_module_v2(
   sqlite3 *db,               /* SQLite connection to register module with */
   const char *zName,         /* Name of the module */
   const sqlite3_module *p,   /* Methods for the module */
@@ -5593,7 +5686,7 @@ SQLITE_API int sqlite3_create_module_v2(
 */
 struct sqlite3_vtab {
   const sqlite3_module *pModule;  /* The module for this virtual table */
-  int nRef;                       /* NO LONGER USED */
+  int nRef;                       /* Number of open cursors */
   char *zErrMsg;                  /* Error message from sqlite3_mprintf() */
   /* Virtual table implementations will typically add additional fields */
 };
@@ -5628,10 +5721,11 @@ struct sqlite3_vtab_cursor {
 ** to declare the format (the names and datatypes of the columns) of
 ** the virtual tables they implement.
 */
-SQLITE_API int sqlite3_declare_vtab(sqlite3*, const char *zSQL);
+SQLITE_API int SQLITE_STDCALL sqlite3_declare_vtab(sqlite3*, const char *zSQL);
 
 /*
 ** CAPI3REF: Overload A Function For A Virtual Table
+** METHOD: sqlite3
 **
 ** ^(Virtual tables can provide alternative implementations of functions
 ** using the [xFindFunction] method of the [virtual table module].  
@@ -5646,7 +5740,7 @@ SQLITE_API int sqlite3_declare_vtab(sqlite3*, const char *zSQL);
 ** purpose is to be a placeholder function that can be overloaded
 ** by a [virtual table].
 */
-SQLITE_API int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);
+SQLITE_API int SQLITE_STDCALL sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);
 
 /*
 ** The interface to the virtual-table mechanism defined above (back up
@@ -5674,6 +5768,8 @@ typedef struct sqlite3_blob sqlite3_blob;
 
 /*
 ** CAPI3REF: Open A BLOB For Incremental I/O
+** METHOD: sqlite3
+** CONSTRUCTOR: sqlite3_blob
 **
 ** ^(This interfaces opens a [BLOB handle | handle] to the BLOB located
 ** in row iRow, column zColumn, table zTable in database zDb;
@@ -5743,7 +5839,7 @@ typedef struct sqlite3_blob sqlite3_blob;
 ** To avoid a resource leak, every open [BLOB handle] should eventually
 ** be released by a call to [sqlite3_blob_close()].
 */
-SQLITE_API int sqlite3_blob_open(
+SQLITE_API int SQLITE_STDCALL sqlite3_blob_open(
   sqlite3*,
   const char *zDb,
   const char *zTable,
@@ -5755,6 +5851,7 @@ SQLITE_API int sqlite3_blob_open(
 
 /*
 ** CAPI3REF: Move a BLOB Handle to a New Row
+** METHOD: sqlite3_blob
 **
 ** ^This function is used to move an existing blob handle so that it points
 ** to a different row of the same database table. ^The new row is identified
@@ -5775,10 +5872,11 @@ SQLITE_API int sqlite3_blob_open(
 **
 ** ^This function sets the database handle error code and message.
 */
-SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64);
+SQLITE_API SQLITE_EXPERIMENTAL int SQLITE_STDCALL sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64);
 
 /*
 ** CAPI3REF: Close A BLOB Handle
+** DESTRUCTOR: sqlite3_blob
 **
 ** ^This function closes an open [BLOB handle]. ^(The BLOB handle is closed
 ** unconditionally.  Even if this routine returns an error code, the 
@@ -5797,10 +5895,11 @@ SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_i
 ** is passed a valid open blob handle, the values returned by the 
 ** sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.
 */
-SQLITE_API int sqlite3_blob_close(sqlite3_blob *);
+SQLITE_API int SQLITE_STDCALL sqlite3_blob_close(sqlite3_blob *);
 
 /*
 ** CAPI3REF: Return The Size Of An Open BLOB
+** METHOD: sqlite3_blob
 **
 ** ^Returns the size in bytes of the BLOB accessible via the 
 ** successfully opened [BLOB handle] in its only argument.  ^The
@@ -5812,10 +5911,11 @@ SQLITE_API int sqlite3_blob_close(sqlite3_blob *);
 ** been closed by [sqlite3_blob_close()].  Passing any other pointer in
 ** to this routine results in undefined and probably undesirable behavior.
 */
-SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *);
+SQLITE_API int SQLITE_STDCALL sqlite3_blob_bytes(sqlite3_blob *);
 
 /*
 ** CAPI3REF: Read Data From A BLOB Incrementally
+** METHOD: sqlite3_blob
 **
 ** ^(This function is used to read data from an open [BLOB handle] into a
 ** caller-supplied buffer. N bytes of data are copied into buffer Z
@@ -5840,10 +5940,11 @@ SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *);
 **
 ** See also: [sqlite3_blob_write()].
 */
-SQLITE_API int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);
+SQLITE_API int SQLITE_STDCALL sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);
 
 /*
 ** CAPI3REF: Write Data Into A BLOB Incrementally
+** METHOD: sqlite3_blob
 **
 ** ^(This function is used to write data into an open [BLOB handle] from a
 ** caller-supplied buffer. N bytes of data are copied from the buffer Z
@@ -5881,7 +5982,7 @@ SQLITE_API int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);
 **
 ** See also: [sqlite3_blob_read()].
 */
-SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);
+SQLITE_API int SQLITE_STDCALL sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);
 
 /*
 ** CAPI3REF: Virtual File System Objects
@@ -5912,9 +6013,9 @@ SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOff
 ** ^(If the default VFS is unregistered, another VFS is chosen as
 ** the default.  The choice for the new VFS is arbitrary.)^
 */
-SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName);
-SQLITE_API int sqlite3_vfs_register(sqlite3_vfs*, int makeDflt);
-SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs*);
+SQLITE_API sqlite3_vfs *SQLITE_STDCALL sqlite3_vfs_find(const char *zVfsName);
+SQLITE_API int SQLITE_STDCALL sqlite3_vfs_register(sqlite3_vfs*, int makeDflt);
+SQLITE_API int SQLITE_STDCALL sqlite3_vfs_unregister(sqlite3_vfs*);
 
 /*
 ** CAPI3REF: Mutexes
@@ -6027,11 +6128,11 @@ SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs*);
 **
 ** See also: [sqlite3_mutex_held()] and [sqlite3_mutex_notheld()].
 */
-SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int);
-SQLITE_API void sqlite3_mutex_free(sqlite3_mutex*);
-SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex*);
-SQLITE_API int sqlite3_mutex_try(sqlite3_mutex*);
-SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex*);
+SQLITE_API sqlite3_mutex *SQLITE_STDCALL sqlite3_mutex_alloc(int);
+SQLITE_API void SQLITE_STDCALL sqlite3_mutex_free(sqlite3_mutex*);
+SQLITE_API void SQLITE_STDCALL sqlite3_mutex_enter(sqlite3_mutex*);
+SQLITE_API int SQLITE_STDCALL sqlite3_mutex_try(sqlite3_mutex*);
+SQLITE_API void SQLITE_STDCALL sqlite3_mutex_leave(sqlite3_mutex*);
 
 /*
 ** CAPI3REF: Mutex Methods Object
@@ -6141,8 +6242,8 @@ struct sqlite3_mutex_methods {
 ** interface should also return 1 when given a NULL pointer.
 */
 #ifndef NDEBUG
-SQLITE_API int sqlite3_mutex_held(sqlite3_mutex*);
-SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex*);
+SQLITE_API int SQLITE_STDCALL sqlite3_mutex_held(sqlite3_mutex*);
+SQLITE_API int SQLITE_STDCALL sqlite3_mutex_notheld(sqlite3_mutex*);
 #endif
 
 /*
@@ -6171,6 +6272,7 @@ SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex*);
 
 /*
 ** CAPI3REF: Retrieve the mutex for a database connection
+** METHOD: sqlite3
 **
 ** ^This interface returns a pointer the [sqlite3_mutex] object that 
 ** serializes access to the [database connection] given in the argument
@@ -6178,10 +6280,11 @@ SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex*);
 ** ^If the [threading mode] is Single-thread or Multi-thread then this
 ** routine returns a NULL pointer.
 */
-SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3*);
+SQLITE_API sqlite3_mutex *SQLITE_STDCALL sqlite3_db_mutex(sqlite3*);
 
 /*
 ** CAPI3REF: Low-Level Control Of Database Files
+** METHOD: sqlite3
 **
 ** ^The [sqlite3_file_control()] interface makes a direct call to the
 ** xFileControl method for the [sqlite3_io_methods] object associated
@@ -6212,7 +6315,7 @@ SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3*);
 **
 ** See also: [SQLITE_FCNTL_LOCKSTATE]
 */
-SQLITE_API int sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*);
+SQLITE_API int SQLITE_STDCALL sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*);
 
 /*
 ** CAPI3REF: Testing Interface
@@ -6231,7 +6334,7 @@ SQLITE_API int sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*
 ** Unlike most of the SQLite API, this function is not guaranteed to
 ** operate consistently from one release to the next.
 */
-SQLITE_API int sqlite3_test_control(int op, ...);
+SQLITE_API int SQLITE_CDECL sqlite3_test_control(int op, ...);
 
 /*
 ** CAPI3REF: Testing Interface Operation Codes
@@ -6265,12 +6368,13 @@ SQLITE_API int sqlite3_test_control(int op, ...);
 #define SQLITE_TESTCTRL_BYTEORDER               22
 #define SQLITE_TESTCTRL_ISINIT                  23
 #define SQLITE_TESTCTRL_SORTER_MMAP             24
-#define SQLITE_TESTCTRL_LAST                    24
+#define SQLITE_TESTCTRL_IMPOSTER                25
+#define SQLITE_TESTCTRL_LAST                    25
 
 /*
 ** CAPI3REF: SQLite Runtime Status
 **
-** ^This interface is used to retrieve runtime status information
+** ^These interfaces are used to retrieve runtime status information
 ** about the performance of SQLite, and optionally to reset various
 ** highwater marks.  ^The first argument is an integer code for
 ** the specific parameter to measure.  ^(Recognized integer codes
@@ -6284,19 +6388,22 @@ SQLITE_API int sqlite3_test_control(int op, ...);
 ** ^(Other parameters record only the highwater mark and not the current
 ** value.  For these latter parameters nothing is written into *pCurrent.)^
 **
-** ^The sqlite3_status() routine returns SQLITE_OK on success and a
-** non-zero [error code] on failure.
+** ^The sqlite3_status() and sqlite3_status64() routines return
+** SQLITE_OK on success and a non-zero [error code] on failure.
 **
-** This routine is threadsafe but is not atomic.  This routine can be
-** called while other threads are running the same or different SQLite
-** interfaces.  However the values returned in *pCurrent and
-** *pHighwater reflect the status of SQLite at different points in time
-** and it is possible that another thread might change the parameter
-** in between the times when *pCurrent and *pHighwater are written.
+** If either the current value or the highwater mark is too large to
+** be represented by a 32-bit integer, then the values returned by
+** sqlite3_status() are undefined.
 **
 ** See also: [sqlite3_db_status()]
 */
-SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag);
+SQLITE_API int SQLITE_STDCALL sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag);
+SQLITE_API int SQLITE_STDCALL sqlite3_status64(
+  int op,
+  sqlite3_int64 *pCurrent,
+  sqlite3_int64 *pHighwater,
+  int resetFlag
+);
 
 
 /*
@@ -6394,6 +6501,7 @@ SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetF
 
 /*
 ** CAPI3REF: Database Connection Status
+** METHOD: sqlite3
 **
 ** ^This interface is used to retrieve runtime status information 
 ** about a single [database connection].  ^The first argument is the
@@ -6414,7 +6522,7 @@ SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetF
 **
 ** See also: [sqlite3_status()] and [sqlite3_stmt_status()].
 */
-SQLITE_API int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg);
+SQLITE_API int SQLITE_STDCALL sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg);
 
 /*
 ** CAPI3REF: Status Parameters for database connections
@@ -6522,6 +6630,7 @@ SQLITE_API int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int r
 
 /*
 ** CAPI3REF: Prepared Statement Status
+** METHOD: sqlite3_stmt
 **
 ** ^(Each prepared statement maintains various
 ** [SQLITE_STMTSTATUS counters] that measure the number
@@ -6543,7 +6652,7 @@ SQLITE_API int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int r
 **
 ** See also: [sqlite3_status()] and [sqlite3_db_status()].
 */
-SQLITE_API int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);
+SQLITE_API int SQLITE_STDCALL sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);
 
 /*
 ** CAPI3REF: Status Parameters for prepared statements
@@ -6966,20 +7075,20 @@ typedef struct sqlite3_backup sqlite3_backup;
 ** is not a permanent error and does not affect the return value of
 ** sqlite3_backup_finish().
 **
-** [[sqlite3_backup__remaining()]] [[sqlite3_backup_pagecount()]]
+** [[sqlite3_backup_remaining()]] [[sqlite3_backup_pagecount()]]
 ** <b>sqlite3_backup_remaining() and sqlite3_backup_pagecount()</b>
 **
-** ^Each call to sqlite3_backup_step() sets two values inside
-** the [sqlite3_backup] object: the number of pages still to be backed
-** up and the total number of pages in the source database file.
-** The sqlite3_backup_remaining() and sqlite3_backup_pagecount() interfaces
-** retrieve these two values, respectively.
-**
-** ^The values returned by these functions are only updated by
-** sqlite3_backup_step(). ^If the source database is modified during a backup
-** operation, then the values are not updated to account for any extra
-** pages that need to be updated or the size of the source database file
-** changing.
+** ^The sqlite3_backup_remaining() routine returns the number of pages still
+** to be backed up at the conclusion of the most recent sqlite3_backup_step().
+** ^The sqlite3_backup_pagecount() routine returns the total number of pages
+** in the source database at the conclusion of the most recent
+** sqlite3_backup_step().
+** ^(The values returned by these functions are only updated by
+** sqlite3_backup_step(). If the source database is modified in a way that
+** changes the size of the source database or the number of pages remaining,
+** those changes are not reflected in the output of sqlite3_backup_pagecount()
+** and sqlite3_backup_remaining() until after the next
+** sqlite3_backup_step().)^
 **
 ** <b>Concurrent Usage of Database Handles</b>
 **
@@ -7012,19 +7121,20 @@ typedef struct sqlite3_backup sqlite3_backup;
 ** same time as another thread is invoking sqlite3_backup_step() it is
 ** possible that they return invalid values.
 */
-SQLITE_API sqlite3_backup *sqlite3_backup_init(
+SQLITE_API sqlite3_backup *SQLITE_STDCALL sqlite3_backup_init(
   sqlite3 *pDest,                        /* Destination database handle */
   const char *zDestName,                 /* Destination database name */
   sqlite3 *pSource,                      /* Source database handle */
   const char *zSourceName                /* Source database name */
 );
-SQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage);
-SQLITE_API int sqlite3_backup_finish(sqlite3_backup *p);
-SQLITE_API int sqlite3_backup_remaining(sqlite3_backup *p);
-SQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p);
+SQLITE_API int SQLITE_STDCALL sqlite3_backup_step(sqlite3_backup *p, int nPage);
+SQLITE_API int SQLITE_STDCALL sqlite3_backup_finish(sqlite3_backup *p);
+SQLITE_API int SQLITE_STDCALL sqlite3_backup_remaining(sqlite3_backup *p);
+SQLITE_API int SQLITE_STDCALL sqlite3_backup_pagecount(sqlite3_backup *p);
 
 /*
 ** CAPI3REF: Unlock Notification
+** METHOD: sqlite3
 **
 ** ^When running in shared-cache mode, a database operation may fail with
 ** an [SQLITE_LOCKED] error if the required locks on the shared-cache or
@@ -7137,7 +7247,7 @@ SQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p);
 ** the special "DROP TABLE/INDEX" case, the extended error code is just 
 ** SQLITE_LOCKED.)^
 */
-SQLITE_API int sqlite3_unlock_notify(
+SQLITE_API int SQLITE_STDCALL sqlite3_unlock_notify(
   sqlite3 *pBlocked,                          /* Waiting connection */
   void (*xNotify)(void **apArg, int nArg),    /* Callback function to invoke */
   void *pNotifyArg                            /* Argument to pass to xNotify */
@@ -7152,8 +7262,8 @@ SQLITE_API int sqlite3_unlock_notify(
 ** strings in a case-independent fashion, using the same definition of "case
 ** independence" that SQLite uses internally when comparing identifiers.
 */
-SQLITE_API int sqlite3_stricmp(const char *, const char *);
-SQLITE_API int sqlite3_strnicmp(const char *, const char *, int);
+SQLITE_API int SQLITE_STDCALL sqlite3_stricmp(const char *, const char *);
+SQLITE_API int SQLITE_STDCALL sqlite3_strnicmp(const char *, const char *, int);
 
 /*
 ** CAPI3REF: String Globbing
@@ -7168,7 +7278,7 @@ SQLITE_API int sqlite3_strnicmp(const char *, const char *, int);
 ** Note that this routine returns zero on a match and non-zero if the strings
 ** do not match, the same as [sqlite3_stricmp()] and [sqlite3_strnicmp()].
 */
-SQLITE_API int sqlite3_strglob(const char *zGlob, const char *zStr);
+SQLITE_API int SQLITE_STDCALL sqlite3_strglob(const char *zGlob, const char *zStr);
 
 /*
 ** CAPI3REF: Error Logging Interface
@@ -7191,10 +7301,11 @@ SQLITE_API int sqlite3_strglob(const char *zGlob, const char *zStr);
 ** a few hundred characters, it will be truncated to the length of the
 ** buffer.
 */
-SQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...);
+SQLITE_API void SQLITE_CDECL sqlite3_log(int iErrCode, const char *zFormat, ...);
 
 /*
 ** CAPI3REF: Write-Ahead Log Commit Hook
+** METHOD: sqlite3
 **
 ** ^The [sqlite3_wal_hook()] function is used to register a callback that
 ** is invoked each time data is committed to a database in wal mode.
@@ -7226,7 +7337,7 @@ SQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...);
 ** [wal_autocheckpoint pragma] both invoke [sqlite3_wal_hook()] and will
 ** those overwrite any prior [sqlite3_wal_hook()] settings.
 */
-SQLITE_API void *sqlite3_wal_hook(
+SQLITE_API void *SQLITE_STDCALL sqlite3_wal_hook(
   sqlite3*, 
   int(*)(void *,sqlite3*,const char*,int),
   void*
@@ -7234,6 +7345,7 @@ SQLITE_API void *sqlite3_wal_hook(
 
 /*
 ** CAPI3REF: Configure an auto-checkpoint
+** METHOD: sqlite3
 **
 ** ^The [sqlite3_wal_autocheckpoint(D,N)] is a wrapper around
 ** [sqlite3_wal_hook()] that causes any database on [database connection] D
@@ -7260,10 +7372,11 @@ SQLITE_API void *sqlite3_wal_hook(
 ** is only necessary if the default setting is found to be suboptimal
 ** for a particular application.
 */
-SQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int N);
+SQLITE_API int SQLITE_STDCALL sqlite3_wal_autocheckpoint(sqlite3 *db, int N);
 
 /*
 ** CAPI3REF: Checkpoint a database
+** METHOD: sqlite3
 **
 ** ^(The sqlite3_wal_checkpoint(D,X) is equivalent to
 ** [sqlite3_wal_checkpoint_v2](D,X,[SQLITE_CHECKPOINT_PASSIVE],0,0).)^
@@ -7281,10 +7394,11 @@ SQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int N);
 ** start a callback but which do not need the full power (and corresponding
 ** complication) of [sqlite3_wal_checkpoint_v2()].
 */
-SQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb);
+SQLITE_API int SQLITE_STDCALL sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb);
 
 /*
 ** CAPI3REF: Checkpoint a database
+** METHOD: sqlite3
 **
 ** ^(The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint
 ** operation on database X of [database connection] D in mode M.  Status
@@ -7374,7 +7488,7 @@ SQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb);
 ** ^The [PRAGMA wal_checkpoint] command can be used to invoke this interface
 ** from SQL.
 */
-SQLITE_API int sqlite3_wal_checkpoint_v2(
+SQLITE_API int SQLITE_STDCALL sqlite3_wal_checkpoint_v2(
   sqlite3 *db,                    /* Database handle */
   const char *zDb,                /* Name of attached database (or NULL) */
   int eMode,                      /* SQLITE_CHECKPOINT_* value */
@@ -7410,7 +7524,7 @@ SQLITE_API int sqlite3_wal_checkpoint_v2(
 ** this function. (See [SQLITE_VTAB_CONSTRAINT_SUPPORT].)  Further options
 ** may be added in the future.
 */
-SQLITE_API int sqlite3_vtab_config(sqlite3*, int op, ...);
+SQLITE_API int SQLITE_CDECL sqlite3_vtab_config(sqlite3*, int op, ...);
 
 /*
 ** CAPI3REF: Virtual Table Configuration Options
@@ -7463,7 +7577,7 @@ SQLITE_API int sqlite3_vtab_config(sqlite3*, int op, ...);
 ** of the SQL statement that triggered the call to the [xUpdate] method of the
 ** [virtual table].
 */
-SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *);
+SQLITE_API int SQLITE_STDCALL sqlite3_vtab_on_conflict(sqlite3 *);
 
 /*
 ** CAPI3REF: Conflict resolution modes
@@ -7539,6 +7653,7 @@ SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *);
 
 /*
 ** CAPI3REF: Prepared Statement Scan Status
+** METHOD: sqlite3_stmt
 **
 ** This interface returns information about the predicted and measured
 ** performance for pStmt.  Advanced applications can use this
@@ -7567,7 +7682,7 @@ SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *);
 **
 ** See also: [sqlite3_stmt_scanstatus_reset()]
 */
-SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_stmt_scanstatus(
+SQLITE_API SQLITE_EXPERIMENTAL int SQLITE_STDCALL sqlite3_stmt_scanstatus(
   sqlite3_stmt *pStmt,      /* Prepared statement for which info desired */
   int idx,                  /* Index of loop to report on */
   int iScanStatusOp,        /* Information desired.  SQLITE_SCANSTAT_* */
@@ -7576,13 +7691,14 @@ SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_stmt_scanstatus(
 
 /*
 ** CAPI3REF: Zero Scan-Status Counters
+** METHOD: sqlite3_stmt
 **
 ** ^Zero all [sqlite3_stmt_scanstatus()] related event counters.
 **
 ** This API is only available if the library is built with pre-processor
 ** symbol [SQLITE_ENABLE_STMT_SCANSTATUS] defined.
 */
-SQLITE_API SQLITE_EXPERIMENTAL void sqlite3_stmt_scanstatus_reset(sqlite3_stmt*);
+SQLITE_API SQLITE_EXPERIMENTAL void SQLITE_STDCALL sqlite3_stmt_scanstatus_reset(sqlite3_stmt*);
 
 
 /*
@@ -7637,7 +7753,7 @@ typedef struct sqlite3_rtree_query_info sqlite3_rtree_query_info;
 **
 **   SELECT ... FROM <rtree> WHERE <rtree col> MATCH $zGeom(... params ...)
 */
-SQLITE_API int sqlite3_rtree_geometry_callback(
+SQLITE_API int SQLITE_STDCALL sqlite3_rtree_geometry_callback(
   sqlite3 *db,
   const char *zGeom,
   int (*xGeom)(sqlite3_rtree_geometry*, int, sqlite3_rtree_dbl*,int*),
@@ -7663,7 +7779,7 @@ struct sqlite3_rtree_geometry {
 **
 **   SELECT ... FROM <rtree> WHERE <rtree col> MATCH $zQueryFunc(... params ...)
 */
-SQLITE_API int sqlite3_rtree_query_callback(
+SQLITE_API int SQLITE_STDCALL sqlite3_rtree_query_callback(
   sqlite3 *db,
   const char *zQueryFunc,
   int (*xQueryFunc)(sqlite3_rtree_query_info*),
diff --git a/TMessagesProj/libs/armeabi-v7a/libtmessages.8.so b/TMessagesProj/libs/armeabi-v7a/libtmessages.8.so
index 29c750d68..b73f401f3 100755
Binary files a/TMessagesProj/libs/armeabi-v7a/libtmessages.8.so and b/TMessagesProj/libs/armeabi-v7a/libtmessages.8.so differ
diff --git a/TMessagesProj/libs/armeabi/libtmessages.8.so b/TMessagesProj/libs/armeabi/libtmessages.8.so
index ae7110a48..b720a57b4 100755
Binary files a/TMessagesProj/libs/armeabi/libtmessages.8.so and b/TMessagesProj/libs/armeabi/libtmessages.8.so differ
diff --git a/TMessagesProj/libs/x86/libtmessages.8.so b/TMessagesProj/libs/x86/libtmessages.8.so
index 2cf7dc77c..0b3e8df01 100755
Binary files a/TMessagesProj/libs/x86/libtmessages.8.so and b/TMessagesProj/libs/x86/libtmessages.8.so differ
diff --git a/TMessagesProj/src/main/AndroidManifest.xml b/TMessagesProj/src/main/AndroidManifest.xml
index dd3c5fc25..2009cf46a 100644
--- a/TMessagesProj/src/main/AndroidManifest.xml
+++ b/TMessagesProj/src/main/AndroidManifest.xml
@@ -123,6 +123,18 @@
             android:windowSoftInputMode="adjustResize|stateHidden">
         </activity>
 
+        <receiver android:name="org.telegram.android.AutoMessageHeardReceiver">
+            <intent-filter>
+                <action android:name="org.telegram.messenger.ACTION_MESSAGE_HEARD"/>
+            </intent-filter>
+        </receiver>
+
+        <receiver android:name="org.telegram.android.AutoMessageReplyReceiver">
+            <intent-filter>
+                <action android:name="org.telegram.messenger.ACTION_MESSAGE_REPLY"/>
+            </intent-filter>
+        </receiver>
+
         <receiver android:name="org.telegram.android.SmsListener">
             <intent-filter>
                 <action android:name="android.provider.Telephony.SMS_RECEIVED" />
@@ -168,6 +180,8 @@
         <meta-data android:name="com.sec.android.multiwindow.MINIMUM_SIZE_W" android:value="632dp" />
         <meta-data android:name="com.sec.android.multiwindow.MINIMUM_SIZE_H" android:value="598dp" />
 
+        <meta-data android:name="com.google.android.gms.car.application" android:resource="@xml/automotive_app_desc" />
+
     </application>
 
 </manifest>
diff --git a/TMessagesProj/src/main/java/org/telegram/PhoneFormat/CallingCodeInfo.java b/TMessagesProj/src/main/java/org/telegram/PhoneFormat/CallingCodeInfo.java
index 666d508a0..33a53fbf9 100644
--- a/TMessagesProj/src/main/java/org/telegram/PhoneFormat/CallingCodeInfo.java
+++ b/TMessagesProj/src/main/java/org/telegram/PhoneFormat/CallingCodeInfo.java
@@ -27,11 +27,11 @@
 import java.util.ArrayList;
 
 public class CallingCodeInfo {
-    public ArrayList<String> countries = new ArrayList<String>();
+    public ArrayList<String> countries = new ArrayList<>();
     public String callingCode = "";
-    public ArrayList<String> trunkPrefixes = new ArrayList<String>();
-    public ArrayList<String> intlPrefixes = new ArrayList<String>();
-    public ArrayList<RuleSet> ruleSets = new ArrayList<RuleSet>();
+    public ArrayList<String> trunkPrefixes = new ArrayList<>();
+    public ArrayList<String> intlPrefixes = new ArrayList<>();
+    public ArrayList<RuleSet> ruleSets = new ArrayList<>();
     //public ArrayList formatStrings;
 
     String matchingAccessCode(String str) {
@@ -107,14 +107,14 @@ boolean isValidPhoneNumber(String orig) {
         for (RuleSet set : ruleSets) {
             boolean valid = set.isValid(str, intlPrefix, trunkPrefix, true);
             if (valid) {
-                return valid;
+                return true;
             }
         }
 
         for (RuleSet set : ruleSets) {
             boolean valid = set.isValid(str, intlPrefix, trunkPrefix, false);
             if (valid) {
-                return valid;
+                return true;
             }
         }
 
diff --git a/TMessagesProj/src/main/java/org/telegram/android/AndroidUtilities.java b/TMessagesProj/src/main/java/org/telegram/android/AndroidUtilities.java
index 1e8111f08..17acc3426 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/AndroidUtilities.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/AndroidUtilities.java
@@ -8,19 +8,26 @@
 
 package org.telegram.android;
 
+import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.app.AlertDialog;
+import android.content.ContentUris;
 import android.content.Context;
 import android.content.DialogInterface;
+import android.content.Intent;
 import android.content.pm.ActivityInfo;
 import android.content.res.Configuration;
+import android.database.Cursor;
 import android.graphics.Color;
 import android.graphics.Point;
 import android.graphics.Rect;
 import android.graphics.Typeface;
 import android.graphics.drawable.Drawable;
+import android.net.Uri;
 import android.os.Build;
 import android.os.Environment;
+import android.provider.DocumentsContract;
+import android.provider.MediaStore;
 import android.text.Spannable;
 import android.text.SpannableStringBuilder;
 import android.text.Spanned;
@@ -39,6 +46,11 @@
 import android.widget.ProgressBar;
 import android.widget.TextView;
 
+import net.hockeyapp.android.CrashManager;
+import net.hockeyapp.android.CrashManagerListener;
+import net.hockeyapp.android.UpdateManager;
+
+import org.telegram.messenger.BuildVars;
 import org.telegram.messenger.ConnectionsManager;
 import org.telegram.messenger.FileLog;
 import org.telegram.messenger.R;
@@ -53,11 +65,20 @@
 import org.telegram.ui.Components.NumberPicker;
 import org.telegram.ui.Components.TypefaceSpan;
 
+import java.io.ByteArrayOutputStream;
 import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
+import java.text.SimpleDateFormat;
 import java.util.ArrayList;
+import java.util.Date;
 import java.util.Hashtable;
+import java.util.Locale;
 
 public class AndroidUtilities {
 
@@ -159,7 +180,7 @@ public static Typeface getTypeface(String assetPath) {
     }
 
     public static boolean isWaitingForSms() {
-        boolean value = false;
+        boolean value;
         synchronized (smsLock) {
             value = waitingForSms;
         }
@@ -575,11 +596,12 @@ public static void setListViewEdgeEffectColor(AbsListView listView, int color) {
         }
     }
 
+    @SuppressLint("NewApi")
     public static void clearDrawableAnimation(View view) {
         if (Build.VERSION.SDK_INT < 21 || view == null) {
             return;
         }
-        Drawable drawable = null;
+        Drawable drawable;
         if (view instanceof ListView) {
             drawable = ((ListView) view).getSelector();
             if (drawable != null) {
@@ -596,9 +618,9 @@ public static void clearDrawableAnimation(View view) {
 
     public static Spannable replaceTags(String str) {
         try {
-            int start = -1;
+            int start;
             int startColor = -1;
-            int end = -1;
+            int end;
             StringBuilder stringBuilder = new StringBuilder(str);
             while ((start = stringBuilder.indexOf("<br>")) != -1) {
                 stringBuilder.replace(start, start + 4, "\n");
@@ -608,7 +630,7 @@ public static Spannable replaceTags(String str) {
             }
             ArrayList<Integer> bolds = new ArrayList<>();
             ArrayList<Integer> colors = new ArrayList<>();
-            while ((start = stringBuilder.indexOf("<b>")) != -1 || (startColor = stringBuilder.indexOf("<c")) != -1) {
+            while ((start = stringBuilder.indexOf("<b>")) != -1 || (startColor = stringBuilder.indexOf("<c#")) != -1) {
                 if (start != -1) {
                     stringBuilder.replace(start, start + 3, "");
                     end = stringBuilder.indexOf("</b>");
@@ -628,6 +650,7 @@ public static Spannable replaceTags(String str) {
                     colors.add(startColor);
                     colors.add(end);
                     colors.add(color);
+                    startColor = -1;
                 }
             }
             SpannableStringBuilder spannableStringBuilder = new SpannableStringBuilder(stringBuilder);
@@ -726,4 +749,290 @@ public void onAnimationEnd(Object animation) {
             window.clearFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
         }
     }*/
+
+    public static void checkForCrashes(Activity context) {
+        CrashManager.register(context, BuildVars.HOCKEY_APP_HASH, new CrashManagerListener() {
+            @Override
+            public boolean includeDeviceData() {
+                return true;
+            }
+        });
+    }
+
+    public static void checkForUpdates(Activity context) {
+        if (BuildVars.DEBUG_VERSION) {
+            UpdateManager.register(context, BuildVars.HOCKEY_APP_HASH);
+        }
+    }
+
+    public static void unregisterUpdates() {
+        if (BuildVars.DEBUG_VERSION) {
+            UpdateManager.unregister();
+        }
+    }
+
+    public static void addMediaToGallery(String fromPath) {
+        if (fromPath == null) {
+            return;
+        }
+        File f = new File(fromPath);
+        Uri contentUri = Uri.fromFile(f);
+        addMediaToGallery(contentUri);
+    }
+
+    public static void addMediaToGallery(Uri uri) {
+        if (uri == null) {
+            return;
+        }
+        Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);
+        mediaScanIntent.setData(uri);
+        ApplicationLoader.applicationContext.sendBroadcast(mediaScanIntent);
+    }
+
+    private static File getAlbumDir() {
+        File storageDir = null;
+        if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
+            storageDir = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES), "Telegram");
+            if (!storageDir.mkdirs()) {
+                if (!storageDir.exists()){
+                    FileLog.d("tmessages", "failed to create directory");
+                    return null;
+                }
+            }
+        } else {
+            FileLog.d("tmessages", "External storage is not mounted READ/WRITE.");
+        }
+
+        return storageDir;
+    }
+
+    @SuppressLint("NewApi")
+    public static String getPath(final Uri uri) {
+        try {
+            final boolean isKitKat = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
+            if (isKitKat && DocumentsContract.isDocumentUri(ApplicationLoader.applicationContext, uri)) {
+                if (isExternalStorageDocument(uri)) {
+                    final String docId = DocumentsContract.getDocumentId(uri);
+                    final String[] split = docId.split(":");
+                    final String type = split[0];
+                    if ("primary".equalsIgnoreCase(type)) {
+                        return Environment.getExternalStorageDirectory() + "/" + split[1];
+                    }
+                } else if (isDownloadsDocument(uri)) {
+                    final String id = DocumentsContract.getDocumentId(uri);
+                    final Uri contentUri = ContentUris.withAppendedId(Uri.parse("content://downloads/public_downloads"), Long.valueOf(id));
+                    return getDataColumn(ApplicationLoader.applicationContext, contentUri, null, null);
+                } else if (isMediaDocument(uri)) {
+                    final String docId = DocumentsContract.getDocumentId(uri);
+                    final String[] split = docId.split(":");
+                    final String type = split[0];
+
+                    Uri contentUri = null;
+                    switch (type) {
+                        case "image":
+                            contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
+                            break;
+                        case "video":
+                            contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;
+                            break;
+                        case "audio":
+                            contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
+                            break;
+                    }
+
+                    final String selection = "_id=?";
+                    final String[] selectionArgs = new String[] {
+                            split[1]
+                    };
+
+                    return getDataColumn(ApplicationLoader.applicationContext, contentUri, selection, selectionArgs);
+                }
+            } else if ("content".equalsIgnoreCase(uri.getScheme())) {
+                return getDataColumn(ApplicationLoader.applicationContext, uri, null, null);
+            } else if ("file".equalsIgnoreCase(uri.getScheme())) {
+                return uri.getPath();
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+        return null;
+    }
+
+    public static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) {
+
+        Cursor cursor = null;
+        final String column = "_data";
+        final String[] projection = {
+                column
+        };
+
+        try {
+            cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, null);
+            if (cursor != null && cursor.moveToFirst()) {
+                final int column_index = cursor.getColumnIndexOrThrow(column);
+                return cursor.getString(column_index);
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+        return null;
+    }
+
+    public static boolean isExternalStorageDocument(Uri uri) {
+        return "com.android.externalstorage.documents".equals(uri.getAuthority());
+    }
+
+    public static boolean isDownloadsDocument(Uri uri) {
+        return "com.android.providers.downloads.documents".equals(uri.getAuthority());
+    }
+
+    public static boolean isMediaDocument(Uri uri) {
+        return "com.android.providers.media.documents".equals(uri.getAuthority());
+    }
+
+    public static File generatePicturePath() {
+        try {
+            File storageDir = getAlbumDir();
+            String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(new Date());
+            return new File(storageDir, "IMG_" + timeStamp + ".jpg");
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+        return null;
+    }
+
+    public static CharSequence generateSearchName(String name, String name2, String q) {
+        if (name == null && name2 == null) {
+            return "";
+        }
+        SpannableStringBuilder builder = new SpannableStringBuilder();
+        String wholeString = name;
+        if (wholeString == null || wholeString.length() == 0) {
+            wholeString = name2;
+        } else if (name2 != null && name2.length() != 0) {
+            wholeString += " " + name2;
+        }
+        wholeString = wholeString.trim();
+        String lower = " " + wholeString.toLowerCase();
+
+        int index;
+        int lastIndex = 0;
+        while ((index = lower.indexOf(" " + q, lastIndex)) != -1) {
+            int idx = index - (index == 0 ? 0 : 1);
+            int end = q.length() + (index == 0 ? 0 : 1) + idx;
+
+            if (lastIndex != 0 && lastIndex != idx + 1) {
+                builder.append(wholeString.substring(lastIndex, idx));
+            } else if (lastIndex == 0 && idx != 0) {
+                builder.append(wholeString.substring(0, idx));
+            }
+
+            String query = wholeString.substring(idx, end);
+            if (query.startsWith(" ")) {
+                builder.append(" ");
+            }
+            query = query.trim();
+            builder.append(AndroidUtilities.replaceTags("<c#ff4d83b3>" + query + "</c>"));
+
+            lastIndex = end;
+        }
+
+        if (lastIndex != -1 && lastIndex != wholeString.length()) {
+            builder.append(wholeString.substring(lastIndex, wholeString.length()));
+        }
+
+        return builder;
+    }
+
+    public static File generateVideoPath() {
+        try {
+            File storageDir = getAlbumDir();
+            String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(new Date());
+            return new File(storageDir, "VID_" + timeStamp + ".mp4");
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+        return null;
+    }
+
+    public static String formatFileSize(long size) {
+        if (size < 1024) {
+            return String.format("%d B", size);
+        } else if (size < 1024 * 1024) {
+            return String.format("%.1f KB", size / 1024.0f);
+        } else if (size < 1024 * 1024 * 1024) {
+            return String.format("%.1f MB", size / 1024.0f / 1024.0f);
+        } else {
+            return String.format("%.1f GB", size / 1024.0f / 1024.0f / 1024.0f);
+        }
+    }
+
+    public static byte[] decodeQuotedPrintable(final byte[] bytes) {
+        if (bytes == null) {
+            return null;
+        }
+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        for (int i = 0; i < bytes.length; i++) {
+            final int b = bytes[i];
+            if (b == '=') {
+                try {
+                    final int u = Character.digit((char) bytes[++i], 16);
+                    final int l = Character.digit((char) bytes[++i], 16);
+                    buffer.write((char) ((u << 4) + l));
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                    return null;
+                }
+            } else {
+                buffer.write(b);
+            }
+        }
+        byte[] array = buffer.toByteArray();
+        try {
+            buffer.close();
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+        return array;
+    }
+
+    public static boolean copyFile(InputStream sourceFile, File destFile) throws IOException {
+        OutputStream out = new FileOutputStream(destFile);
+        byte[] buf = new byte[4096];
+        int len;
+        while ((len = sourceFile.read(buf)) > 0) {
+            Thread.yield();
+            out.write(buf, 0, len);
+        }
+        out.close();
+        return true;
+    }
+
+    public static boolean copyFile(File sourceFile, File destFile) throws IOException {
+        if (!destFile.exists()) {
+            destFile.createNewFile();
+        }
+        FileInputStream source = null;
+        FileOutputStream destination = null;
+        try {
+            source = new FileInputStream(sourceFile);
+            destination = new FileOutputStream(destFile);
+            destination.getChannel().transferFrom(source.getChannel(), 0, source.getChannel().size());
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+            return false;
+        } finally {
+            if (source != null) {
+                source.close();
+            }
+            if (destination != null) {
+                destination.close();
+            }
+        }
+        return true;
+    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/android/AutoMessageHeardReceiver.java b/TMessagesProj/src/main/java/org/telegram/android/AutoMessageHeardReceiver.java
new file mode 100644
index 000000000..825bcd565
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/AutoMessageHeardReceiver.java
@@ -0,0 +1,26 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.android;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+
+public class AutoMessageHeardReceiver extends BroadcastReceiver {
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        long dialog_id = intent.getLongExtra("dialog_id", 0);
+        int max_id = intent.getIntExtra("max_id", 0);
+        if (dialog_id == 0 || max_id == 0) {
+            return;
+        }
+        MessagesController.getInstance().markDialogAsRead(dialog_id, max_id, max_id, 0, 0, true, false);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/AutoMessageReplyReceiver.java b/TMessagesProj/src/main/java/org/telegram/android/AutoMessageReplyReceiver.java
new file mode 100644
index 000000000..c8411de73
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/AutoMessageReplyReceiver.java
@@ -0,0 +1,37 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2014.
+ */
+
+package org.telegram.android;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.RemoteInput;
+
+public class AutoMessageReplyReceiver extends BroadcastReceiver {
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        Bundle remoteInput = RemoteInput.getResultsFromIntent(intent);
+        if (remoteInput == null) {
+            return;
+        }
+        CharSequence text = remoteInput.getCharSequence(NotificationsController.EXTRA_VOICE_REPLY);
+        if (text == null || text.length() == 0) {
+            return;
+        }
+        long dialog_id = intent.getLongExtra("dialog_id", 0);
+        int max_id = intent.getIntExtra("max_id", 0);
+        if (dialog_id == 0 || max_id == 0) {
+            return;
+        }
+        SendMessagesHelper.getInstance().sendMessage(text.toString(), dialog_id, null, null, true);
+        MessagesController.getInstance().markDialogAsRead(dialog_id, max_id, max_id, 0, 0, true, false);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Emoji.java b/TMessagesProj/src/main/java/org/telegram/android/Emoji.java
index 90246b810..84180b306 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/Emoji.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/Emoji.java
@@ -223,7 +223,7 @@
 
 	private static void loadEmoji(final int page) {
 		try {
-            float scale = 1.0f;
+            float scale;
             int imageResize = 1;
             if (AndroidUtilities.density <= 1.0f) {
                 scale = 2.0f;
@@ -259,7 +259,7 @@ private static void loadEmoji(final int page) {
             imageFile = ApplicationLoader.applicationContext.getFileStreamPath(imageName);
             if (!imageFile.exists()) {
                 InputStream is = ApplicationLoader.applicationContext.getAssets().open("emoji/" + imageName);
-                Utilities.copyFile(is, imageFile);
+                AndroidUtilities.copyFile(is, imageFile);
                 is.close();
             }
 
@@ -278,7 +278,7 @@ private static void loadEmoji(final int page) {
             imageFile = ApplicationLoader.applicationContext.getFileStreamPath(imageName);
             if (!imageFile.exists()) {
                 InputStream is = ApplicationLoader.applicationContext.getAssets().open("emoji/" + imageName);
-                Utilities.copyFile(is, imageFile);
+                AndroidUtilities.copyFile(is, imageFile);
                 is.close();
             }
 
diff --git a/TMessagesProj/src/main/java/org/telegram/android/ImageLoader.java b/TMessagesProj/src/main/java/org/telegram/android/ImageLoader.java
index 2cc360353..9bbefe8e4 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/ImageLoader.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/ImageLoader.java
@@ -67,11 +67,12 @@
     private DispatchQueue cacheThumbOutQueue = new DispatchQueue("cacheThumbOutQueue");
     private DispatchQueue thumbGeneratingQueue = new DispatchQueue("thumbGeneratingQueue");
     private DispatchQueue imageLoadQueue = new DispatchQueue("imageLoadQueue");
-    private DispatchQueue recycleQueue = new DispatchQueue("recycleQueue");
     private ConcurrentHashMap<String, Float> fileProgresses = new ConcurrentHashMap<>();
     private HashMap<String, ThumbGenerateTask> thumbGenerateTasks = new HashMap<>();
     private static byte[] bytes;
     private static byte[] bytesThumb;
+    private static byte[] header = new byte[12];
+    private static byte[] headerThumb = new byte[12];
     private int currentHttpTasksCount = 0;
 
     private LinkedList<HttpFileTask> httpFileLoadTasks = new LinkedList<>();
@@ -116,8 +117,24 @@ protected Boolean doInBackground(Void... voids) {
             try {
                 URL downloadUrl = new URL(url);
                 httpConnection = downloadUrl.openConnection();
+                httpConnection.addRequestProperty("User-Agent", "Mozilla/5.0 (Linux; Android 4.4; Nexus 5 Build/_BuildID_) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/30.0.0.0 Mobile Safari/537.36");
+                httpConnection.addRequestProperty("Referer", "google.com");
                 httpConnection.setConnectTimeout(5000);
                 httpConnection.setReadTimeout(5000);
+                if (httpConnection instanceof HttpURLConnection) {
+                    HttpURLConnection httpURLConnection = (HttpURLConnection) httpConnection;
+                    httpURLConnection.setInstanceFollowRedirects(true);
+                    int status = httpURLConnection.getResponseCode();
+                    if (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER) {
+                        String newUrl = httpURLConnection.getHeaderField("Location");
+                        String cookies = httpURLConnection.getHeaderField("Set-Cookie");
+                        downloadUrl = new URL(newUrl);
+                        httpConnection = downloadUrl.openConnection();
+                        httpConnection.setRequestProperty("Cookie", cookies);
+                        httpConnection.addRequestProperty("User-Agent", "Mozilla/5.0 (Linux; Android 4.4; Nexus 5 Build/_BuildID_) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/30.0.0.0 Mobile Safari/537.36");
+                        httpConnection.addRequestProperty("Referer", "google.com");
+                    }
+                }
                 httpConnection.connect();
                 httpConnectionStream = httpConnection.getInputStream();
 
@@ -137,29 +154,31 @@ protected Boolean doInBackground(Void... voids) {
                 FileLog.e("tmessages", e);
             }
 
-            try {
-                byte[] data = new byte[1024 * 4];
-                while (true) {
-                    if (isCancelled()) {
-                        break;
-                    }
-                    try {
-                        int readed = httpConnectionStream.read(data);
-                        if (readed > 0) {
-                            fileOutputStream.write(data, 0, readed);
-                        } else if (readed == -1) {
-                            done = true;
+            if (httpConnectionStream != null) {
+                try {
+                    byte[] data = new byte[1024 * 4];
+                    while (true) {
+                        if (isCancelled()) {
                             break;
-                        } else {
+                        }
+                        try {
+                            int read = httpConnectionStream.read(data);
+                            if (read > 0) {
+                                fileOutputStream.write(data, 0, read);
+                            } else if (read == -1) {
+                                done = true;
+                                break;
+                            } else {
+                                break;
+                            }
+                        } catch (Exception e) {
+                            FileLog.e("tmessages", e);
                             break;
                         }
-                    } catch (Exception e) {
-                        FileLog.e("tmessages", e);
-                        break;
                     }
+                } catch (Throwable e) {
+                    FileLog.e("tmessages", e);
                 }
-            } catch (Throwable e) {
-                FileLog.e("tmessages", e);
             }
 
             try {
@@ -175,7 +194,6 @@ protected Boolean doInBackground(Void... voids) {
                 if (httpConnectionStream != null) {
                     httpConnectionStream.close();
                 }
-                httpConnectionStream = null;
             } catch (Throwable e) {
                 FileLog.e("tmessages", e);
             }
@@ -235,12 +253,16 @@ protected Boolean doInBackground(Void... voids) {
                 try {
                     URL downloadUrl = new URL(cacheImage.httpUrl);
                     httpConnection = downloadUrl.openConnection();
+                    httpConnection.addRequestProperty("User-Agent", "Mozilla/5.0 (Linux; Android 4.4; Nexus 5 Build/_BuildID_) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/30.0.0.0 Mobile Safari/537.36");
+                    httpConnection.addRequestProperty("Referer", "google.com");
                     httpConnection.setConnectTimeout(5000);
                     httpConnection.setReadTimeout(5000);
+                    if (httpConnection instanceof HttpURLConnection) {
+                        ((HttpURLConnection) httpConnection).setInstanceFollowRedirects(true);
+                    }
                     if (!isCancelled()) {
                         httpConnection.connect();
                         httpConnectionStream = httpConnection.getInputStream();
-
                         fileOutputStream = new RandomAccessFile(cacheImage.tempFilePath, "rws");
                     }
                 } catch (Throwable e) {
@@ -260,37 +282,39 @@ protected Boolean doInBackground(Void... voids) {
                     FileLog.e("tmessages", e);
                 }
 
-                try {
-                    byte[] data = new byte[1024 * 2];
-                    int totalLoaded = 0;
-                    while (true) {
-                        if (isCancelled()) {
-                            break;
-                        }
-                        try {
-                            int readed = httpConnectionStream.read(data);
-                            if (readed > 0) {
-                                totalLoaded += readed;
-                                fileOutputStream.write(data, 0, readed);
-                                if (imageSize != 0) {
-                                    reportProgress(totalLoaded / (float) imageSize);
-                                }
-                            } else if (readed == -1) {
-                                done = true;
-                                if (imageSize != 0) {
-                                    reportProgress(1.0f);
-                                }
+                if (httpConnectionStream != null) {
+                    try {
+                        byte[] data = new byte[1024 * 2];
+                        int totalLoaded = 0;
+                        while (true) {
+                            if (isCancelled()) {
                                 break;
-                            } else {
+                            }
+                            try {
+                                int read = httpConnectionStream.read(data);
+                                if (read > 0) {
+                                    totalLoaded += read;
+                                    fileOutputStream.write(data, 0, read);
+                                    if (imageSize != 0) {
+                                        reportProgress(totalLoaded / (float) imageSize);
+                                    }
+                                } else if (read == -1) {
+                                    done = true;
+                                    if (imageSize != 0) {
+                                        reportProgress(1.0f);
+                                    }
+                                    break;
+                                } else {
+                                    break;
+                                }
+                            } catch (Exception e) {
+                                FileLog.e("tmessages", e);
                                 break;
                             }
-                        } catch (Exception e) {
-                            FileLog.e("tmessages", e);
-                            break;
                         }
+                    } catch (Throwable e) {
+                        FileLog.e("tmessages", e);
                     }
-                } catch (Throwable e) {
-                    FileLog.e("tmessages", e);
                 }
             }
 
@@ -307,7 +331,6 @@ protected Boolean doInBackground(Void... voids) {
                 if (httpConnectionStream != null) {
                     httpConnectionStream.close();
                 }
-                httpConnectionStream = null;
             } catch (Throwable e) {
                 FileLog.e("tmessages", e);
             }
@@ -446,7 +469,6 @@ public void run() {
                 Bitmap scaledBitmap = Bitmap.createScaledBitmap(originalBitmap, (int) (w / scaleFactor), (int) (h / scaleFactor), true);
                 if (scaledBitmap != originalBitmap) {
                     originalBitmap.recycle();
-                    callGC();
                 }
                 originalBitmap = scaledBitmap;
                 FileOutputStream stream = new FileOutputStream(thumbFile);
@@ -513,14 +535,41 @@ public void run() {
             Bitmap image = null;
             File cacheFileFinal = cacheImage.finalFilePath;
             boolean canDeleteFile = true;
-            boolean isWebp = false;
+            boolean useNativeWebpLoaded = false;
 
-            if (cacheFileFinal.toString().endsWith("webp")) {
-                isWebp = true;
+            if (Build.VERSION.SDK_INT < 18) {
+                RandomAccessFile randomAccessFile = null;
+                try {
+                    randomAccessFile = new RandomAccessFile(cacheFileFinal, "r");
+                    byte[] bytes;
+                    if (cacheImage.thumb) {
+                        bytes = headerThumb;
+                    } else {
+                        bytes = header;
+                    }
+                    randomAccessFile.readFully(bytes, 0, bytes.length);
+                    String str = new String(bytes);
+                    if (str != null) {
+                        str = str.toLowerCase();
+                        if (str.startsWith("riff") && str.endsWith("webp")) {
+                            useNativeWebpLoaded = true;
+                        }
+                    }
+                    randomAccessFile.close();
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                } finally {
+                    if (randomAccessFile != null) {
+                        try {
+                            randomAccessFile.close();
+                        } catch (Exception e) {
+                            FileLog.e("tmessages", e);
+                        }
+                    }
+                }
             }
 
             if (cacheImage.thumb) {
-
                 int blurType = 0;
                 if (cacheImage.filter != null) {
                     if (cacheImage.filter.contains("b2")) {
@@ -543,11 +592,11 @@ public void run() {
                     BitmapFactory.Options opts = new BitmapFactory.Options();
                     opts.inSampleSize = 1;
 
-                    if (!isWebp && Build.VERSION.SDK_INT > 10 && Build.VERSION.SDK_INT < 21) {
+                    if (!useNativeWebpLoaded && Build.VERSION.SDK_INT > 10 && Build.VERSION.SDK_INT < 21) {
                         opts.inPurgeable = true;
                     }
 
-                    if (isWebp) {
+                    if (useNativeWebpLoaded) {
                         RandomAccessFile file = new RandomAccessFile(cacheFileFinal, "r");
                         ByteBuffer buffer = file.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, cacheFileFinal.length());
                         image = Utilities.loadWebpImage(buffer, buffer.limit(), null);
@@ -570,20 +619,18 @@ public void run() {
                     }
 
                     if (image == null) {
-                        if (canDeleteFile && (cacheFileFinal.length() == 0 || cacheImage.filter == null)) {
+                        if (cacheFileFinal.length() == 0 || cacheImage.filter == null) {
                             cacheFileFinal.delete();
                         }
                     } else {
-                        if (image != null) {
-                            if (blurType == 1) {
-                                Utilities.blurBitmap(image, 3, opts.inPurgeable ? 0 : 1);
-                            } else if (blurType == 2) {
-                                Utilities.blurBitmap(image, 1, opts.inPurgeable ? 0 : 1);
-                            } else if (blurType == 3) {
-                                Utilities.blurBitmap(image, 7, opts.inPurgeable ? 0 : 1);
-                                Utilities.blurBitmap(image, 7, opts.inPurgeable ? 0 : 1);
-                                Utilities.blurBitmap(image, 7, opts.inPurgeable ? 0 : 1);
-                            }
+                        if (blurType == 1) {
+                            Utilities.blurBitmap(image, 3, opts.inPurgeable ? 0 : 1);
+                        } else if (blurType == 2) {
+                            Utilities.blurBitmap(image, 1, opts.inPurgeable ? 0 : 1);
+                        } else if (blurType == 3) {
+                            Utilities.blurBitmap(image, 7, opts.inPurgeable ? 0 : 1);
+                            Utilities.blurBitmap(image, 7, opts.inPurgeable ? 0 : 1);
+                            Utilities.blurBitmap(image, 7, opts.inPurgeable ? 0 : 1);
                         }
                         if (blurType == 0 && opts.inPurgeable) {
                             Utilities.pinBitmap(image);
@@ -685,7 +732,7 @@ public void run() {
                     } else {
                         opts.inPreferredConfig = Bitmap.Config.RGB_565;
                     }
-                    if (!isWebp && Build.VERSION.SDK_INT > 10 && Build.VERSION.SDK_INT < 21) {
+                    if (!useNativeWebpLoaded && Build.VERSION.SDK_INT > 10 && Build.VERSION.SDK_INT < 21) {
                         opts.inPurgeable = true;
                     }
 
@@ -698,7 +745,7 @@ public void run() {
                         }
                     }
                     if (image == null) {
-                        if (isWebp) {
+                        if (useNativeWebpLoaded) {
                             RandomAccessFile file = new RandomAccessFile(cacheFileFinal, "r");
                             ByteBuffer buffer = file.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, cacheFileFinal.length());
                             image = Utilities.loadWebpImage(buffer, buffer.limit(), null);
@@ -734,7 +781,6 @@ public void run() {
                                 Bitmap scaledBitmap = Bitmap.createScaledBitmap(image, (int) w_filter, (int) (bitmapH / scaleFactor), true);
                                 if (image != scaledBitmap) {
                                     image.recycle();
-                                    callGC();
                                     image = scaledBitmap;
                                 }
                             }
@@ -746,7 +792,7 @@ public void run() {
                         if (!blured && opts.inPurgeable) {
                             Utilities.pinBitmap(image);
                         }
-                        if (runtimeHack != null) {
+                        if (runtimeHack != null && image != null) {
                             runtimeHack.trackFree(image.getRowBytes() * image.getHeight());
                         }
                     }
@@ -774,7 +820,6 @@ public void run() {
                                 runtimeHack.trackAlloc(image.getRowBytes() * image.getHeight());
                             }
                             image.recycle();
-                            callGC();
                         }
                     }
                     final BitmapDrawable toSetFinal = toSet;
@@ -853,6 +898,7 @@ public VMRuntimeHack() {
         protected String key;
         protected String url;
         protected String filter;
+        protected String ext;
         protected TLObject location;
 
         protected File finalFilePath;
@@ -897,7 +943,7 @@ public void removeImageReceiver(ImageReceiver imageReceiver) {
                 imageReceiverArray.clear();
                 if (location != null) {
                     if (location instanceof TLRPC.FileLocation) {
-                        FileLoader.getInstance().cancelLoadFile((TLRPC.FileLocation) location);
+                        FileLoader.getInstance().cancelLoadFile((TLRPC.FileLocation) location, ext);
                     } else if (location instanceof TLRPC.Document) {
                         FileLoader.getInstance().cancelLoadFile((TLRPC.Document) location);
                     }
@@ -1019,11 +1065,16 @@ public void run() {
             }
 
             @Override
-            public void fileDidUploaded(final String location, final TLRPC.InputFile inputFile, final TLRPC.InputEncryptedFile inputEncryptedFile) {
+            public void fileDidUploaded(final String location, final TLRPC.InputFile inputFile, final TLRPC.InputEncryptedFile inputEncryptedFile, final byte[] key, final byte[] iv) {
                 Utilities.stageQueue.postRunnable(new Runnable() {
                     @Override
                     public void run() {
-                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.FileDidUpload, location, inputFile, inputEncryptedFile);
+                        AndroidUtilities.runOnUIThread(new Runnable() {
+                            @Override
+                            public void run() {
+                                NotificationCenter.getInstance().postNotificationName(NotificationCenter.FileDidUpload, location, inputFile, inputEncryptedFile, key, iv);
+                            }
+                        });
                         fileProgresses.remove(location);
                     }
                 });
@@ -1034,7 +1085,12 @@ public void fileDidFailedUpload(final String location, final boolean isEncrypted
                 Utilities.stageQueue.postRunnable(new Runnable() {
                     @Override
                     public void run() {
-                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.FileDidFailUpload, location, isEncrypted);
+                        AndroidUtilities.runOnUIThread(new Runnable() {
+                            @Override
+                            public void run() {
+                                NotificationCenter.getInstance().postNotificationName(NotificationCenter.FileDidFailUpload, location, isEncrypted);
+                            }
+                        });
                         fileProgresses.remove(location);
                     }
                 });
@@ -1049,7 +1105,7 @@ public void run() {
                         if (location != null) {
                             if (MediaController.getInstance().canSaveToGallery() && telegramPath != null && finalFile != null && finalFile.exists() && (location.endsWith(".mp4") || location.endsWith(".jpg"))) {
                                 if (finalFile.toString().startsWith(telegramPath.toString())) {
-                                    Utilities.addMediaToGallery(finalFile.toString());
+                                    AndroidUtilities.addMediaToGallery(finalFile.toString());
                                 }
                             }
                         }
@@ -1250,17 +1306,6 @@ public void incrementUseCount(String key) {
         }
     }
 
-    public void callGC() {
-        if (Build.VERSION.SDK_INT > 13) {
-            recycleQueue.postRunnable(new Runnable() {
-                @Override
-                public void run() {
-                    //System.gc();
-                }
-            });
-        }
-    }
-
     public boolean decrementUseCount(String key) {
         Integer count = bitmapUseCounts.get(key);
         if (count == null) {
@@ -1394,7 +1439,7 @@ private void generateThumb(int mediaType, File originalPath, TLRPC.FileLocation
         }
     }
 
-    private void createLoadOperationForImageReceiver(final ImageReceiver imageReceiver, final String key, final String url, final TLObject imageLocation, final String httpLocation, final String filter, final int size, final boolean cacheOnly, final int thumb) {
+    private void createLoadOperationForImageReceiver(final ImageReceiver imageReceiver, final String key, final String url, final String ext, final TLObject imageLocation, final String httpLocation, final String filter, final int size, final boolean cacheOnly, final int thumb) {
         if (imageReceiver == null || url == null || key == null) {
             return;
         }
@@ -1510,6 +1555,7 @@ public void run() {
                         img.key = key;
                         img.filter = filter;
                         img.httpUrl = httpLocation;
+                        img.ext = ext;
                         img.addImageReceiver(imageReceiver);
                         if (onlyCache || cacheFile.exists()) {
                             img.finalFilePath = cacheFile;
@@ -1527,7 +1573,7 @@ public void run() {
                             if (httpLocation == null) {
                                 if (imageLocation instanceof TLRPC.FileLocation) {
                                     TLRPC.FileLocation location = (TLRPC.FileLocation) imageLocation;
-                                    FileLoader.getInstance().loadFile(location, size, size == 0 || location.key != null || cacheOnly);
+                                    FileLoader.getInstance().loadFile(location, ext, size, size == 0 || location.key != null || cacheOnly);
                                 } else if (imageLocation instanceof TLRPC.Document) {
                                     FileLoader.getInstance().loadFile((TLRPC.Document) imageLocation, true, true);
                                 }
@@ -1584,7 +1630,10 @@ public void loadImageForImageReceiver(ImageReceiver imageReceiver) {
         String thumbUrl = null;
         key = null;
         thumbKey = null;
-        String ext = null;
+        String ext = imageReceiver.getExt();
+        if (ext == null) {
+            ext = "jpg";
+        }
         if (httpLocation != null) {
             key = Utilities.MD5(httpLocation);
             url = key + "." + getHttpUrlExtension(httpLocation);
@@ -1592,9 +1641,8 @@ public void loadImageForImageReceiver(ImageReceiver imageReceiver) {
             if (imageLocation instanceof TLRPC.FileLocation) {
                 TLRPC.FileLocation location = (TLRPC.FileLocation) imageLocation;
                 key = location.volume_id + "_" + location.local_id;
-                ext = "." + (location.ext != null ? location.ext : "jpg");
-                url = key + ext;
-                if (location.ext != null || location.key != null || location.volume_id == Integer.MIN_VALUE && location.local_id < 0) {
+                url = key + "." + ext;
+                if (imageReceiver.getExt() != null || location.key != null || location.volume_id == Integer.MIN_VALUE && location.local_id < 0) {
                     saveImageToCache = true;
                 }
             } else if (imageLocation instanceof TLRPC.Document) {
@@ -1603,10 +1651,19 @@ public void loadImageForImageReceiver(ImageReceiver imageReceiver) {
                     return;
                 }
                 key = location.dc_id + "_" + location.id;
-                ext = ".webp";
-                url = key + ext;
+                String docExt = FileLoader.getDocumentFileName(location);
+                int idx;
+                if (docExt == null || (idx = docExt.lastIndexOf(".")) == -1) {
+                    docExt = "";
+                } else {
+                    docExt = docExt.substring(idx);
+                    if (docExt.length() <= 1) {
+                        docExt = "";
+                    }
+                }
+                url = key + docExt;
                 if (thumbKey != null) {
-                    thumbUrl = thumbKey + ext;
+                    thumbUrl = thumbKey + "." + ext;
                 }
                 saveImageToCache = true;
             }
@@ -1619,11 +1676,7 @@ public void loadImageForImageReceiver(ImageReceiver imageReceiver) {
 
         if (thumbLocation != null) {
             thumbKey = thumbLocation.volume_id + "_" + thumbLocation.local_id;
-            if (ext != null) {
-                thumbUrl = thumbKey + ext;
-            } else {
-                thumbUrl = thumbKey + "." + (thumbLocation.ext != null ? thumbLocation.ext : "jpg");
-            }
+            thumbUrl = thumbKey + "." + ext;
         }
 
         String filter = imageReceiver.getFilter();
@@ -1636,10 +1689,10 @@ public void loadImageForImageReceiver(ImageReceiver imageReceiver) {
         }
 
         if (httpLocation != null) {
-            createLoadOperationForImageReceiver(imageReceiver, key, url, null, httpLocation, filter, 0, true, 0);
+            createLoadOperationForImageReceiver(imageReceiver, key, url, ext, null, httpLocation, filter, 0, true, 0);
         } else {
-            createLoadOperationForImageReceiver(imageReceiver, thumbKey, thumbUrl, thumbLocation, null, thumbFilter, 0, true, thumbSet ? 2 : 1);
-            createLoadOperationForImageReceiver(imageReceiver, key, url, imageLocation, null, filter, imageReceiver.getSize(), saveImageToCache || imageReceiver.getCacheOnly(), 0);
+            createLoadOperationForImageReceiver(imageReceiver, thumbKey, thumbUrl, ext, thumbLocation, null, thumbFilter, 0, true, thumbSet ? 2 : 1);
+            createLoadOperationForImageReceiver(imageReceiver, key, url, ext, imageLocation, null, filter, imageReceiver.getSize(), saveImageToCache || imageReceiver.getCacheOnly(), 0);
         }
     }
 
@@ -1682,6 +1735,7 @@ public void run() {
                         cacheImage.key = img.key;
                         cacheImage.httpUrl = img.httpUrl;
                         cacheImage.thumb = img.thumb;
+                        cacheImage.ext = img.ext;
                         cacheImage.cacheTask = task = new CacheOutTask(cacheImage);
                         cacheImage.filter = img.filter;
                         imageLoadingByKeys.put(cacheImage.key, cacheImage);
@@ -1821,7 +1875,7 @@ public static Bitmap loadBitmap(String path, Uri uri, float maxWidth, float maxH
                 path = uri.getPath();
             } else {
                 try {
-                    path = Utilities.getPath(uri);
+                    path = AndroidUtilities.getPath(uri);
                 } catch (Throwable e) {
                     FileLog.e("tmessages", e);
                 }
@@ -1861,7 +1915,7 @@ public static Bitmap loadBitmap(String path, Uri uri, float maxWidth, float maxH
         if (path != null) {
             exifPath = path;
         } else if (uri != null) {
-            exifPath = Utilities.getPath(uri);
+            exifPath = AndroidUtilities.getPath(uri);
         }
 
         Matrix matrix = null;
@@ -1919,9 +1973,7 @@ public static Bitmap loadBitmap(String path, Uri uri, float maxWidth, float maxH
                 FileLog.e("tmessages", e);
             } finally {
                 try {
-                    if (parcelFD != null) {
-                        parcelFD.close();
-                    }
+                    parcelFD.close();
                 } catch (Throwable e) {
                     FileLog.e("tmessages", e);
                 }
@@ -1931,8 +1983,25 @@ public static Bitmap loadBitmap(String path, Uri uri, float maxWidth, float maxH
         return b;
     }
 
+    public static void fillPhotoSizeWithBytes(TLRPC.PhotoSize photoSize) {
+        if (photoSize == null || photoSize.bytes != null) {
+            return;
+        }
+        File file = FileLoader.getPathToAttach(photoSize, true);
+        try {
+            RandomAccessFile f = new RandomAccessFile(file, "r");
+            int len = (int) f.length();
+            if (len < 20000) {
+                photoSize.bytes = new byte[(int) f.length()];
+                f.readFully(photoSize.bytes, 0, photoSize.bytes.length);
+            }
+        } catch (Throwable e) {
+            FileLog.e("tmessages", e);
+        }
+    }
+
     private static TLRPC.PhotoSize scaleAndSaveImageInternal(Bitmap bitmap, int w, int h, float photoW, float photoH, float scaleFactor, int quality, boolean cache, boolean scaleAnyway) throws Exception {
-        Bitmap scaledBitmap = null;
+        Bitmap scaledBitmap;
         if (scaleFactor > 1 || scaleAnyway) {
             scaledBitmap = Bitmap.createScaledBitmap(bitmap, w, h, true);
         } else {
@@ -2055,12 +2124,6 @@ public static void saveMessageThumbs(TLRPC.Message message) {
         } else if (message.media instanceof TLRPC.TL_messageMediaDocument) {
             if (message.media.document.thumb instanceof TLRPC.TL_photoCachedSize) {
                 photoSize = message.media.document.thumb;
-                for (TLRPC.DocumentAttribute attribute : message.media.document.attributes) {
-                    if (attribute instanceof TLRPC.TL_documentAttributeSticker) {
-                        photoSize.location.ext = "webp";
-                        break;
-                    }
-                }
             }
         } else if (message.media instanceof TLRPC.TL_messageMediaWebPage) {
             if (message.media.webpage.photo != null) {
diff --git a/TMessagesProj/src/main/java/org/telegram/android/ImageReceiver.java b/TMessagesProj/src/main/java/org/telegram/android/ImageReceiver.java
index 1d0eb8b4c..b73778a24 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/ImageReceiver.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/ImageReceiver.java
@@ -43,6 +43,7 @@
         public String thumbFilter;
         public int size;
         public boolean cacheOnly;
+        public String ext;
     }
 
     private View parentView;
@@ -59,6 +60,7 @@
     private String currentHttpUrl;
     private String currentFilter;
     private String currentThumbFilter;
+    private String currentExt;
     private TLRPC.FileLocation currentThumbLocation;
     private int currentSize;
     private boolean currentCacheOnly;
@@ -68,6 +70,7 @@
 
     private boolean needsQualityThumb;
     private boolean shouldGenerateQualityThumb;
+    private boolean invalidateAll;
 
     private int imageX, imageY, imageW, imageH;
     private Rect drawRegion = new Rect();
@@ -104,27 +107,27 @@ public void cancelLoadImage() {
         canceledLoading = true;
     }
 
-    public void setImage(TLObject path, String filter, Drawable thumb, boolean cacheOnly) {
-        setImage(path, null, filter, thumb, null, null, 0, cacheOnly);
+    public void setImage(TLObject path, String filter, Drawable thumb, String ext, boolean cacheOnly) {
+        setImage(path, null, filter, thumb, null, null, 0, ext, cacheOnly);
     }
 
-    public void setImage(TLObject path, String filter, Drawable thumb, int size, boolean cacheOnly) {
-        setImage(path, null, filter, thumb, null, null, size, cacheOnly);
+    public void setImage(TLObject path, String filter, Drawable thumb, int size, String ext, boolean cacheOnly) {
+        setImage(path, null, filter, thumb, null, null, size, ext, cacheOnly);
     }
 
-    public void setImage(String httpUrl, String filter, Drawable thumb, int size) {
-        setImage(null, httpUrl, filter, thumb, null, null, size, true);
+    public void setImage(String httpUrl, String filter, Drawable thumb, String ext, int size) {
+        setImage(null, httpUrl, filter, thumb, null, null, size, ext, true);
     }
 
-    public void setImage(TLObject fileLocation, String filter, TLRPC.FileLocation thumbLocation, String thumbFilter, boolean cacheOnly) {
-        setImage(fileLocation, null, filter, null, thumbLocation, thumbFilter, 0, cacheOnly);
+    public void setImage(TLObject fileLocation, String filter, TLRPC.FileLocation thumbLocation, String thumbFilter, String ext, boolean cacheOnly) {
+        setImage(fileLocation, null, filter, null, thumbLocation, thumbFilter, 0, ext, cacheOnly);
     }
 
-    public void setImage(TLObject fileLocation, String filter, TLRPC.FileLocation thumbLocation, String thumbFilter, int size, boolean cacheOnly) {
-        setImage(fileLocation, null, filter, null, thumbLocation, thumbFilter, size, cacheOnly);
+    public void setImage(TLObject fileLocation, String filter, TLRPC.FileLocation thumbLocation, String thumbFilter, int size, String ext, boolean cacheOnly) {
+        setImage(fileLocation, null, filter, null, thumbLocation, thumbFilter, size, ext, cacheOnly);
     }
 
-    public void setImage(TLObject fileLocation, String httpUrl, String filter, Drawable thumb, TLRPC.FileLocation thumbLocation, String thumbFilter, int size, boolean cacheOnly) {
+    public void setImage(TLObject fileLocation, String httpUrl, String filter, Drawable thumb, TLRPC.FileLocation thumbLocation, String thumbFilter, int size, String ext, boolean cacheOnly) {
         if (setImageBackup != null) {
             setImageBackup.fileLocation = null;
             setImageBackup.httpUrl = null;
@@ -139,6 +142,7 @@ public void setImage(TLObject fileLocation, String httpUrl, String filter, Drawa
             recycleBitmap(null, false);
             recycleBitmap(null, true);
             currentKey = null;
+            currentExt = ext;
             currentThumbKey = null;
             currentThumbFilter = null;
             currentImageLocation = null;
@@ -153,7 +157,11 @@ public void setImage(TLObject fileLocation, String httpUrl, String filter, Drawa
             bitmapShader = null;
             ImageLoader.getInstance().cancelLoadingForImageReceiver(this, 0);
             if (parentView != null) {
-                parentView.invalidate(imageX, imageY, imageX + imageW, imageY + imageH);
+                if (invalidateAll) {
+                    parentView.invalidate();
+                } else {
+                    parentView.invalidate(imageX, imageY, imageX + imageW, imageY + imageH);
+                }
             }
             if (delegate != null) {
                 delegate.didSetImage(this, currentImage != null || currentThumb != null || staticThumb != null, currentImage == null);
@@ -207,6 +215,7 @@ public void setImage(TLObject fileLocation, String httpUrl, String filter, Drawa
 
         currentThumbKey = thumbKey;
         currentKey = key;
+        currentExt = ext;
         currentImageLocation = fileLocation;
         currentHttpUrl = httpUrl;
         currentFilter = filter;
@@ -224,7 +233,11 @@ public void setImage(TLObject fileLocation, String httpUrl, String filter, Drawa
 
         ImageLoader.getInstance().loadImageForImageReceiver(this);
         if (parentView != null) {
-            parentView.invalidate(imageX, imageY, imageX + imageW, imageY + imageH);
+            if (invalidateAll) {
+                parentView.invalidate();
+            } else {
+                parentView.invalidate(imageX, imageY, imageX + imageW, imageY + imageH);
+            }
         }
     }
 
@@ -249,6 +262,10 @@ public void setOrientation(int angle, boolean center) {
         centerRotation = center;
     }
 
+    public void setInvalidateAll(boolean value) {
+        invalidateAll = value;
+    }
+
     public int getOrientation() {
         return orientation;
     }
@@ -264,6 +281,7 @@ public void setImageBitmap(Drawable bitmap) {
         staticThumb = bitmap;
         currentThumbLocation = null;
         currentKey = null;
+        currentExt = null;
         currentThumbKey = null;
         currentImage = null;
         currentThumbFilter = null;
@@ -284,7 +302,11 @@ public void setImageBitmap(Drawable bitmap) {
             delegate.didSetImage(this, currentImage != null || currentThumb != null || staticThumb != null, currentImage == null);
         }
         if (parentView != null) {
-            parentView.invalidate(imageX, imageY, imageX + imageW, imageY + imageH);
+            if (invalidateAll) {
+                parentView.invalidate();
+            } else {
+                parentView.invalidate(imageX, imageY, imageX + imageW, imageY + imageH);
+            }
         }
     }
 
@@ -309,6 +331,7 @@ public void onDetachedFromWindow() {
             setImageBackup.thumbLocation = currentThumbLocation;
             setImageBackup.thumbFilter = currentThumbFilter;
             setImageBackup.size = currentSize;
+            setImageBackup.ext = currentExt;
             setImageBackup.cacheOnly = currentCacheOnly;
         }
         NotificationCenter.getInstance().removeObserver(this, NotificationCenter.didReplacedPhotoInMemCache);
@@ -318,7 +341,7 @@ public void onDetachedFromWindow() {
     public boolean onAttachedToWindow() {
         NotificationCenter.getInstance().addObserver(this, NotificationCenter.didReplacedPhotoInMemCache);
         if (setImageBackup != null && (setImageBackup.fileLocation != null || setImageBackup.httpUrl != null || setImageBackup.thumbLocation != null || setImageBackup.thumb != null)) {
-            setImage(setImageBackup.fileLocation, setImageBackup.httpUrl, setImageBackup.filter, setImageBackup.thumb, setImageBackup.thumbLocation, setImageBackup.thumbFilter, setImageBackup.size, setImageBackup.cacheOnly);
+            setImage(setImageBackup.fileLocation, setImageBackup.httpUrl, setImageBackup.filter, setImageBackup.thumb, setImageBackup.thumbLocation, setImageBackup.thumbFilter, setImageBackup.size, setImageBackup.ext, setImageBackup.cacheOnly);
             return true;
         }
         return false;
@@ -332,10 +355,8 @@ private void drawDrawable(Canvas canvas, Drawable drawable, int alpha) {
             boolean hasFilter = paint != null && paint.getColorFilter() != null;
             if (hasFilter && !isPressed) {
                 bitmapDrawable.setColorFilter(null);
-                hasFilter = false;
             } else if (!hasFilter && isPressed) {
                 bitmapDrawable.setColorFilter(new PorterDuffColorFilter(0xffdddddd, PorterDuff.Mode.MULTIPLY));
-                hasFilter = true;
             }
             if (colorFilter != null) {
                 bitmapDrawable.setColorFilter(colorFilter);
@@ -353,8 +374,6 @@ private void drawDrawable(Canvas canvas, Drawable drawable, int alpha) {
             } else {
                 int bitmapW;
                 int bitmapH;
-                int originalW = bitmapDrawable.getIntrinsicWidth();
-                int originalH = bitmapDrawable.getIntrinsicHeight();
                 if (orientation == 90 || orientation == 270) {
                     bitmapW = bitmapDrawable.getIntrinsicHeight();
                     bitmapH = bitmapDrawable.getIntrinsicWidth();
@@ -383,7 +402,7 @@ private void drawDrawable(Canvas canvas, Drawable drawable, int alpha) {
                             ImageLoader.getInstance().removeImage(currentThumbKey);
                             currentThumbKey = null;
                         }
-                        setImage(currentImageLocation, currentHttpUrl, currentFilter, currentThumb, currentThumbLocation, currentThumbFilter, currentSize, currentCacheOnly);
+                        setImage(currentImageLocation, currentHttpUrl, currentFilter, currentThumb, currentThumbLocation, currentThumbFilter, currentSize, currentExt, currentCacheOnly);
                         FileLog.e("tmessages", e);
                     }
                     canvas.restore();
@@ -402,11 +421,9 @@ private void drawDrawable(Canvas canvas, Drawable drawable, int alpha) {
 
                         if (bitmapW / scaleH > imageW) {
                             bitmapW /= scaleH;
-                            originalW /= scaleH;
                             drawRegion.set(imageX - (bitmapW - imageW) / 2, imageY, imageX + (bitmapW + imageW) / 2, imageY + imageH);
                         } else {
                             bitmapH /= scaleW;
-                            originalH /= scaleW;
                             drawRegion.set(imageX, imageY - (bitmapH - imageH) / 2, imageX + imageW, imageY + (bitmapH + imageH) / 2);
                         }
                         if (orientation == 90 || orientation == 270) {
@@ -430,7 +447,7 @@ private void drawDrawable(Canvas canvas, Drawable drawable, int alpha) {
                                     ImageLoader.getInstance().removeImage(currentThumbKey);
                                     currentThumbKey = null;
                                 }
-                                setImage(currentImageLocation, currentHttpUrl, currentFilter, currentThumb, currentThumbLocation, currentThumbFilter, currentSize, currentCacheOnly);
+                                setImage(currentImageLocation, currentHttpUrl, currentFilter, currentThumb, currentThumbLocation, currentThumbFilter, currentSize, currentExt, currentCacheOnly);
                                 FileLog.e("tmessages", e);
                             }
                         }
@@ -467,7 +484,7 @@ private void drawDrawable(Canvas canvas, Drawable drawable, int alpha) {
                                     ImageLoader.getInstance().removeImage(currentThumbKey);
                                     currentThumbKey = null;
                                 }
-                                setImage(currentImageLocation, currentHttpUrl, currentFilter, currentThumb, currentThumbLocation, currentThumbFilter, currentSize, currentCacheOnly);
+                                setImage(currentImageLocation, currentHttpUrl, currentFilter, currentThumb, currentThumbLocation, currentThumbFilter, currentSize, currentExt, currentCacheOnly);
                                 FileLog.e("tmessages", e);
                             }
                         }
@@ -498,7 +515,11 @@ private void checkAlphaAnimation() {
             }
             lastUpdateAlphaTime = System.currentTimeMillis();
             if (parentView != null) {
-                parentView.invalidate(imageX, imageY, imageX + imageW, imageY + imageH);
+                if (invalidateAll) {
+                    parentView.invalidate();
+                } else {
+                    parentView.invalidate(imageX, imageY, imageX + imageW, imageY + imageH);
+                }
             }
         }
     }
@@ -577,7 +598,11 @@ public void setVisible(boolean value, boolean invalidate) {
         }
         isVisible = value;
         if (invalidate && parentView != null) {
-            parentView.invalidate(imageX, imageY, imageX + imageW, imageY + imageH);
+            if (invalidateAll) {
+                parentView.invalidate();
+            } else {
+                parentView.invalidate(imageX, imageY, imageX + imageW, imageY + imageH);
+            }
         }
     }
 
@@ -636,6 +661,10 @@ public int getImageHeight() {
         return imageH;
     }
 
+    public String getExt() {
+        return currentExt;
+    }
+
     public boolean isInsideImage(float x, float y) {
         return x >= imageX && x <= imageX + imageW && y >= imageY && y <= imageY + imageH;
     }
@@ -782,7 +811,11 @@ protected void setImageBitmapByKey(BitmapDrawable bitmap, String key, boolean th
             }
 
             if (parentView != null) {
-                parentView.invalidate(imageX, imageY, imageX + imageW, imageY + imageH);
+                if (invalidateAll) {
+                    parentView.invalidate();
+                } else {
+                    parentView.invalidate(imageX, imageY, imageX + imageW, imageY + imageH);
+                }
             }
         } else if (currentThumb == null && (currentImage == null || forcePreview)) {
             if (currentThumbKey == null || !key.equals(currentThumbKey)) {
@@ -801,7 +834,11 @@ protected void setImageBitmapByKey(BitmapDrawable bitmap, String key, boolean th
             }
 
             if (!(staticThumb instanceof BitmapDrawable) && parentView != null) {
-                parentView.invalidate(imageX, imageY, imageX + imageW, imageY + imageH);
+                if (invalidateAll) {
+                    parentView.invalidate();
+                } else {
+                    parentView.invalidate(imageX, imageY, imageX + imageW, imageY + imageH);
+                }
             }
         }
 
@@ -841,7 +878,6 @@ private void recycleBitmap(String newKey, boolean thumb) {
             }
             if (canDelete) {
                 bitmap.recycle();
-                ImageLoader.getInstance().callGC();
             }
         }
         if (thumb) {
@@ -866,7 +902,11 @@ public void didReceivedNotification(int id, Object... args) {
                     staticThumb = null;
                 }
                 if (parentView != null) {
-                    parentView.invalidate(imageX, imageY, imageX + imageW, imageY + imageH);
+                    if (invalidateAll) {
+                        parentView.invalidate();
+                    } else {
+                        parentView.invalidate(imageX, imageY, imageX + imageW, imageY + imageH);
+                    }
                 }
             }
         } else if (id == NotificationCenter.didReplacedPhotoInMemCache) {
diff --git a/TMessagesProj/src/main/java/org/telegram/android/LocaleController.java b/TMessagesProj/src/main/java/org/telegram/android/LocaleController.java
index 5e82e4070..cf89fe20f 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/LocaleController.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/LocaleController.java
@@ -23,7 +23,6 @@
 import org.telegram.messenger.FileLog;
 import org.telegram.messenger.R;
 import org.telegram.messenger.TLRPC;
-import org.telegram.messenger.Utilities;
 import org.telegram.messenger.ApplicationLoader;
 import org.xmlpull.v1.XmlPullParser;
 
@@ -359,7 +358,7 @@ public boolean applyLanguageFile(File file) {
                 }
 
                 File finalFile = new File(ApplicationLoader.applicationContext.getFilesDir(), languageCode + ".xml");
-                if (!Utilities.copyFile(file, finalFile)) {
+                if (!AndroidUtilities.copyFile(file, finalFile)) {
                     return false;
                 }
 
@@ -494,7 +493,6 @@ private void loadOtherLanguages() {
             try {
                 if (stream != null) {
                     stream.close();
-                    stream = null;
                 }
             } catch (Exception e) {
                 FileLog.e("tmessages", e);
@@ -512,7 +510,7 @@ public void applyLanguage(LocaleInfo localeInfo, boolean override, boolean fromF
             return;
         }
         try {
-            Locale newLocale = null;
+            Locale newLocale;
             if (localeInfo.shortName != null) {
                 String[] args = localeInfo.shortName.split("_");
                 if (args.length == 1) {
@@ -682,50 +680,60 @@ public static String formatDateChat(long date) {
     }
 
     public static String formatDate(long date) {
-        Calendar rightNow = Calendar.getInstance();
-        int day = rightNow.get(Calendar.DAY_OF_YEAR);
-        int year = rightNow.get(Calendar.YEAR);
-        rightNow.setTimeInMillis(date * 1000);
-        int dateDay = rightNow.get(Calendar.DAY_OF_YEAR);
-        int dateYear = rightNow.get(Calendar.YEAR);
-
-        if (dateDay == day && year == dateYear) {
-            return formatterDay.format(new Date(date * 1000));
-        } else if (dateDay + 1 == day && year == dateYear) {
-            return getString("Yesterday", R.string.Yesterday);
-        } else if (year == dateYear) {
-            return formatterMonth.format(new Date(date * 1000));
-        } else {
-            return formatterYear.format(new Date(date * 1000));
+        try {
+            Calendar rightNow = Calendar.getInstance();
+            int day = rightNow.get(Calendar.DAY_OF_YEAR);
+            int year = rightNow.get(Calendar.YEAR);
+            rightNow.setTimeInMillis(date * 1000);
+            int dateDay = rightNow.get(Calendar.DAY_OF_YEAR);
+            int dateYear = rightNow.get(Calendar.YEAR);
+
+            if (dateDay == day && year == dateYear) {
+                return formatterDay.format(new Date(date * 1000));
+            } else if (dateDay + 1 == day && year == dateYear) {
+                return getString("Yesterday", R.string.Yesterday);
+            } else if (year == dateYear) {
+                return formatterMonth.format(new Date(date * 1000));
+            } else {
+                return formatterYear.format(new Date(date * 1000));
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
         }
+        return "LOC_ERR";
     }
 
     public static String formatDateOnline(long date) {
-        Calendar rightNow = Calendar.getInstance();
-        int day = rightNow.get(Calendar.DAY_OF_YEAR);
-        int year = rightNow.get(Calendar.YEAR);
-        rightNow.setTimeInMillis(date * 1000);
-        int dateDay = rightNow.get(Calendar.DAY_OF_YEAR);
-        int dateYear = rightNow.get(Calendar.YEAR);
-
-        if (dateDay == day && year == dateYear) {
-            return String.format("%s %s %s", LocaleController.getString("LastSeen", R.string.LastSeen), LocaleController.getString("TodayAt", R.string.TodayAt), formatterDay.format(new Date(date * 1000)));
-        } else if (dateDay + 1 == day && year == dateYear) {
-            return String.format("%s %s %s", LocaleController.getString("LastSeen", R.string.LastSeen), LocaleController.getString("YesterdayAt", R.string.YesterdayAt), formatterDay.format(new Date(date * 1000)));
-        } else if (year == dateYear) {
-            String format = LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, formatterMonth.format(new Date(date * 1000)), formatterDay.format(new Date(date * 1000)));
-            return String.format("%s %s", LocaleController.getString("LastSeenDate", R.string.LastSeenDate), format);
-        } else {
-            String format = LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, formatterYear.format(new Date(date * 1000)), formatterDay.format(new Date(date * 1000)));
-            return String.format("%s %s", LocaleController.getString("LastSeenDate", R.string.LastSeenDate), format);
+        try {
+            Calendar rightNow = Calendar.getInstance();
+            int day = rightNow.get(Calendar.DAY_OF_YEAR);
+            int year = rightNow.get(Calendar.YEAR);
+            rightNow.setTimeInMillis(date * 1000);
+            int dateDay = rightNow.get(Calendar.DAY_OF_YEAR);
+            int dateYear = rightNow.get(Calendar.YEAR);
+
+            if (dateDay == day && year == dateYear) {
+                return String.format("%s %s %s", LocaleController.getString("LastSeen", R.string.LastSeen), LocaleController.getString("TodayAt", R.string.TodayAt), formatterDay.format(new Date(date * 1000)));
+            } else if (dateDay + 1 == day && year == dateYear) {
+                return String.format("%s %s %s", LocaleController.getString("LastSeen", R.string.LastSeen), LocaleController.getString("YesterdayAt", R.string.YesterdayAt), formatterDay.format(new Date(date * 1000)));
+            } else if (year == dateYear) {
+                String format = LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, formatterMonth.format(new Date(date * 1000)), formatterDay.format(new Date(date * 1000)));
+                return String.format("%s %s", LocaleController.getString("LastSeenDate", R.string.LastSeenDate), format);
+            } else {
+                String format = LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, formatterYear.format(new Date(date * 1000)), formatterDay.format(new Date(date * 1000)));
+                return String.format("%s %s", LocaleController.getString("LastSeenDate", R.string.LastSeenDate), format);
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
         }
+        return "LOC_ERR";
     }
 
     private FastDateFormat createFormatter(Locale locale, String format, String defaultFormat) {
         if (format == null || format.length() == 0) {
             format = defaultFormat;
         }
-        FastDateFormat formatter = null;
+        FastDateFormat formatter;
         try {
             formatter = FastDateFormat.getInstance(format, locale);
         } catch (Exception e) {
@@ -758,25 +766,30 @@ public void recreateFormatters() {
     }
 
     public static String stringForMessageListDate(long date) {
-        Calendar rightNow = Calendar.getInstance();
-        int day = rightNow.get(Calendar.DAY_OF_YEAR);
-        int year = rightNow.get(Calendar.YEAR);
-        rightNow.setTimeInMillis(date * 1000);
-        int dateDay = rightNow.get(Calendar.DAY_OF_YEAR);
-        int dateYear = rightNow.get(Calendar.YEAR);
-
-        if (year != dateYear) {
-            return formatterYear.format(new Date(date * 1000));
-        } else {
-            int dayDiff = dateDay - day;
-            if(dayDiff == 0 || dayDiff == -1 && (int)(System.currentTimeMillis() / 1000) - date < 60 * 60 * 8) {
-                return formatterDay.format(new Date(date * 1000));
-            } else if(dayDiff > -7 && dayDiff <= -1) {
-                return formatterWeek.format(new Date(date * 1000));
+        try {
+            Calendar rightNow = Calendar.getInstance();
+            int day = rightNow.get(Calendar.DAY_OF_YEAR);
+            int year = rightNow.get(Calendar.YEAR);
+            rightNow.setTimeInMillis(date * 1000);
+            int dateDay = rightNow.get(Calendar.DAY_OF_YEAR);
+            int dateYear = rightNow.get(Calendar.YEAR);
+
+            if (year != dateYear) {
+                return formatterYear.format(new Date(date * 1000));
             } else {
-                return formatterMonth.format(new Date(date * 1000));
+                int dayDiff = dateDay - day;
+                if(dayDiff == 0 || dayDiff == -1 && (int)(System.currentTimeMillis() / 1000) - date < 60 * 60 * 8) {
+                    return formatterDay.format(new Date(date * 1000));
+                } else if(dayDiff > -7 && dayDiff <= -1) {
+                    return formatterWeek.format(new Date(date * 1000));
+                } else {
+                    return formatterMonth.format(new Date(date * 1000));
+                }
             }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
         }
+        return "LOC_ERR";
     }
 
     public static String formatUserStatus(TLRPC.User user) {
diff --git a/TMessagesProj/src/main/java/org/telegram/android/LruCache.java b/TMessagesProj/src/main/java/org/telegram/android/LruCache.java
index 3ed7d3c64..d4870cc96 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/LruCache.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/LruCache.java
@@ -107,7 +107,6 @@ public BitmapDrawable put(String key, BitmapDrawable value) {
 
         if (previous != null) {
             entryRemoved(false, key, previous, value);
-            ImageLoader.getInstance().callGC();
         }
 
         trimToSize(maxSize, key);
@@ -148,7 +147,6 @@ private void trimToSize(int maxSize, String justAdded) {
 
                 entryRemoved(true, key, value, null);
             }
-            ImageLoader.getInstance().callGC();
         }
     }
 
@@ -183,7 +181,6 @@ public final BitmapDrawable remove(String key) {
             }
 
             entryRemoved(false, key, previous, null);
-            ImageLoader.getInstance().callGC();
         }
 
         return previous;
diff --git a/TMessagesProj/src/main/java/org/telegram/android/MediaController.java b/TMessagesProj/src/main/java/org/telegram/android/MediaController.java
index 9a088bcd0..a0ff51259 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/MediaController.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/MediaController.java
@@ -8,6 +8,7 @@
 
 package org.telegram.android;
 
+import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.app.Activity;
 import android.app.ProgressDialog;
@@ -243,6 +244,7 @@ public PhotoEntry(int bucketId, int imageId, long dateTaken, String path, int or
     private Timer progressTimer = null;
     private final Object progressTimerSync = new Object();
     private boolean useFrontSpeaker;
+    private int buffersWrited;
 
     private AudioRecord audioRecorder = null;
     private TLRPC.TL_audio recordingAudio = null;
@@ -271,7 +273,7 @@ public PhotoEntry(int bucketId, int imageId, long dateTaken, String path, int or
         @Override
         public void run() {
             if (audioRecorder != null) {
-                ByteBuffer buffer = null;
+                ByteBuffer buffer;
                 if (!recordBuffers.isEmpty()) {
                     buffer = recordBuffers.get(0);
                     recordBuffers.remove(0);
@@ -691,7 +693,7 @@ protected void processDownloadObjects(int type, ArrayList<DownloadObject> object
             if (downloadObject.object instanceof TLRPC.Audio) {
                 FileLoader.getInstance().loadFile((TLRPC.Audio)downloadObject.object, false);
             } else if (downloadObject.object instanceof TLRPC.PhotoSize) {
-                FileLoader.getInstance().loadFile((TLRPC.PhotoSize)downloadObject.object, false);
+                FileLoader.getInstance().loadFile((TLRPC.PhotoSize)downloadObject.object, null, false);
             } else if (downloadObject.object instanceof TLRPC.Video) {
                 FileLoader.getInstance().loadFile((TLRPC.Video)downloadObject.object, false);
             } else if (downloadObject.object instanceof TLRPC.Document) {
@@ -727,7 +729,7 @@ private void checkDownloadFinished(String fileName, int state) {
         if (downloadObject != null) {
             downloadQueueKeys.remove(fileName);
             if (state == 0 || state == 2) {
-                MessagesStorage.getInstance().removeFromDownloadQueue(downloadObject.id, downloadObject.type, state != 0);
+                MessagesStorage.getInstance().removeFromDownloadQueue(downloadObject.id, downloadObject.type, false /*state != 0*/);
             }
             if (downloadObject.type == AUTODOWNLOAD_MASK_PHOTO) {
                 photoDownloadQueue.remove(downloadObject);
@@ -1106,10 +1108,12 @@ public void run() {
                     } catch (Exception e) {
                         FileLog.e("tmessages", e);
                     }
+                    buffersWrited++;
 
                     if (count > 0) {
                         final long pcm = buffer.pcmOffset;
-                        final int marker = buffer.finished == 1 ? buffer.size : -1;
+                        final int marker = buffer.finished == 1 ? count : -1;
+                        final int finalBuffersWrited = buffersWrited;
                         AndroidUtilities.runOnUIThread(new Runnable() {
                             @Override
                             public void run() {
@@ -1118,6 +1122,9 @@ public void run() {
                                     if (audioTrackPlayer != null) {
                                         audioTrackPlayer.setNotificationMarkerPosition(1);
                                     }
+                                    if (finalBuffersWrited == 1) {
+                                        clenupPlayer(true);
+                                    }
                                 }
                             }
                         });
@@ -1140,12 +1147,17 @@ public void run() {
         });
     }
 
+    private boolean isNearToSensor(float value) {
+        return value < 5.0f && value != proximitySensor.getMaximumRange();
+    }
+
     @Override
     public void onSensorChanged(SensorEvent event) {
-        if (proximitySensor != null && audioTrackPlayer == null && audioPlayer == null || isPaused || (useFrontSpeaker == (event.values[0] < proximitySensor.getMaximumRange() / 10))) {
+        FileLog.e("tmessages", "proximity changed to " + event.values[0]);
+        if (proximitySensor != null && audioTrackPlayer == null && audioPlayer == null || isPaused || (useFrontSpeaker == isNearToSensor(event.values[0]))) {
             return;
         }
-        boolean newValue = event.values[0] < proximitySensor.getMaximumRange() / 10;
+        boolean newValue = isNearToSensor(event.values[0]);
         try {
             if (newValue && NotificationsController.getInstance().audioManager.isWiredHeadsetOn()) {
                 return;
@@ -1230,6 +1242,7 @@ private void clenupPlayer(boolean notify) {
             }
             stopProgressTimer();
             lastProgress = 0;
+            buffersWrited = 0;
             isPaused = false;
             MessageObject lastFile = playingMessageObject;
             playingMessageObject.audioProgress = 0.0f;
@@ -1464,6 +1477,7 @@ public boolean pauseAudio(MessageObject messageObject) {
         if (audioTrackPlayer == null && audioPlayer == null || messageObject == null || playingMessageObject == null || playingMessageObject != null && playingMessageObject.getId() != messageObject.getId()) {
             return false;
         }
+        stopProgressTimer();
         try {
             if (audioPlayer != null) {
                 audioPlayer.pause();
@@ -1480,11 +1494,12 @@ public boolean pauseAudio(MessageObject messageObject) {
     }
 
     public boolean resumeAudio(MessageObject messageObject) {
-        startProximitySensor();
         if (audioTrackPlayer == null && audioPlayer == null || messageObject == null || playingMessageObject == null || playingMessageObject != null && playingMessageObject.getId() != messageObject.getId()) {
             return false;
         }
+        startProximitySensor();
         try {
+            startProgressTimer();
             if (audioPlayer != null) {
                 audioPlayer.start();
             } else if (audioTrackPlayer != null) {
@@ -1706,9 +1721,9 @@ public void run() {
                     try {
                         File destFile = null;
                         if (type == 0) {
-                            destFile = Utilities.generatePicturePath();
+                            destFile = AndroidUtilities.generatePicturePath();
                         } else if (type == 1) {
-                            destFile = Utilities.generateVideoPath();
+                            destFile = AndroidUtilities.generateVideoPath();
                         } else if (type == 2) {
                             File f = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);
                             destFile = new File(f, name);
@@ -1725,8 +1740,8 @@ public void run() {
                             source = new FileInputStream(sourceFile).getChannel();
                             destination = new FileOutputStream(destFile).getChannel();
                             long size = source.size();
-                            for (long a = 0; a < size; a += 1024) {
-                                destination.transferFrom(source, a, Math.min(1024, size - a));
+                            for (long a = 0; a < size; a += 4096) {
+                                destination.transferFrom(source, a, Math.min(4096, size - a));
                                 if (finalProgress != null) {
                                     if (lastProgress <= System.currentTimeMillis() - 500) {
                                         lastProgress = System.currentTimeMillis();
@@ -1757,7 +1772,7 @@ public void run() {
                         }
 
                         if (result && (type == 0 || type == 1)) {
-                            Utilities.addMediaToGallery(Uri.fromFile(destFile));
+                            AndroidUtilities.addMediaToGallery(Uri.fromFile(destFile));
                         }
                     } catch (Exception e) {
                         FileLog.e("tmessages", e);
@@ -2185,6 +2200,7 @@ private void startVideoConvertFromQueue() {
         }
     }
 
+    @SuppressLint("NewApi")
     public static MediaCodecInfo selectCodec(String mimeType) {
         int numCodecs = MediaCodecList.getCodecCount();
         MediaCodecInfo lastCodecInfo = null;
@@ -2221,6 +2237,7 @@ private static boolean isRecognizedFormat(int colorFormat) {
         }
     }
 
+    @SuppressLint("NewApi")
     public static int selectColorFormat(MediaCodecInfo codecInfo, String mimeType) {
         MediaCodecInfo.CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(mimeType);
         int lastColorFormat = 0;
@@ -2373,7 +2390,7 @@ public void run() {
     }
 
     private void checkConversionCanceled() throws Exception {
-        boolean cancelConversion = false;
+        boolean cancelConversion;
         synchronized (videoConvertSync) {
             cancelConversion = cancelCurrentVideoConversion;
         }
@@ -2384,15 +2401,15 @@ private void checkConversionCanceled() throws Exception {
 
     @TargetApi(16)
     private boolean convertVideo(final MessageObject messageObject) {
-        String videoPath = messageObject.messageOwner.videoEditedInfo.originalPath;
-        long startTime = messageObject.messageOwner.videoEditedInfo.startTime;
-        long endTime = messageObject.messageOwner.videoEditedInfo.endTime;
-        int resultWidth = messageObject.messageOwner.videoEditedInfo.resultWidth;
-        int resultHeight = messageObject.messageOwner.videoEditedInfo.resultHeight;
-        int rotationValue = messageObject.messageOwner.videoEditedInfo.rotationValue;
-        int originalWidth = messageObject.messageOwner.videoEditedInfo.originalWidth;
-        int originalHeight = messageObject.messageOwner.videoEditedInfo.originalHeight;
-        int bitrate = messageObject.messageOwner.videoEditedInfo.bitrate;
+        String videoPath = messageObject.videoEditedInfo.originalPath;
+        long startTime = messageObject.videoEditedInfo.startTime;
+        long endTime = messageObject.videoEditedInfo.endTime;
+        int resultWidth = messageObject.videoEditedInfo.resultWidth;
+        int resultHeight = messageObject.videoEditedInfo.resultHeight;
+        int rotationValue = messageObject.videoEditedInfo.rotationValue;
+        int originalWidth = messageObject.videoEditedInfo.originalWidth;
+        int originalHeight = messageObject.videoEditedInfo.originalHeight;
+        int bitrate = messageObject.videoEditedInfo.bitrate;
         int rotateRender = 0;
         File cacheFile = new File(messageObject.messageOwner.attachPath);
 
@@ -2455,7 +2472,7 @@ private boolean convertVideo(final MessageObject messageObject) {
                 checkConversionCanceled();
 
                 if (resultWidth != originalWidth || resultHeight != originalHeight) {
-                    int videoIndex = -5;
+                    int videoIndex;
                     videoIndex = selectTrack(extractor, false);
                     if (videoIndex >= 0) {
                         MediaCodec decoder = null;
@@ -2471,7 +2488,7 @@ private boolean convertVideo(final MessageObject messageObject) {
                             int swapUV = 0;
                             int videoTrackIndex = -5;
 
-                            int colorFormat = 0;
+                            int colorFormat;
                             int processorType = PROCESSOR_TYPE_OTHER;
                             String manufacturer = Build.MANUFACTURER.toLowerCase();
                             if (Build.VERSION.SDK_INT < 18) {
@@ -2590,7 +2607,7 @@ private boolean convertVideo(final MessageObject messageObject) {
                                     if (index == videoIndex) {
                                         int inputBufIndex = decoder.dequeueInputBuffer(TIMEOUT_USEC);
                                         if (inputBufIndex >= 0) {
-                                            ByteBuffer inputBuf = null;
+                                            ByteBuffer inputBuf;
                                             if (Build.VERSION.SDK_INT < 21) {
                                                 inputBuf = decoderInputBuffers[inputBufIndex];
                                             } else {
@@ -2636,7 +2653,7 @@ private boolean convertVideo(final MessageObject messageObject) {
                                     } else if (encoderStatus < 0) {
                                         throw new RuntimeException("unexpected result from encoder.dequeueOutputBuffer: " + encoderStatus);
                                     } else {
-                                        ByteBuffer encodedData = null;
+                                        ByteBuffer encodedData;
                                         if (Build.VERSION.SDK_INT < 21) {
                                             encodedData = encoderOutputBuffers[encoderStatus];
                                         } else {
@@ -2698,7 +2715,7 @@ private boolean convertVideo(final MessageObject messageObject) {
                                         } else if (decoderStatus < 0) {
                                             throw new RuntimeException("unexpected result from decoder.dequeueOutputBuffer: " + decoderStatus);
                                         } else {
-                                            boolean doRender = false;
+                                            boolean doRender;
                                             if (Build.VERSION.SDK_INT >= 18) {
                                                 doRender = info.size != 0;
                                             } else {
@@ -2775,21 +2792,17 @@ private boolean convertVideo(final MessageObject messageObject) {
 
                         if (outputSurface != null) {
                             outputSurface.release();
-                            outputSurface = null;
                         }
                         if (inputSurface != null) {
                             inputSurface.release();
-                            inputSurface = null;
                         }
                         if (decoder != null) {
                             decoder.stop();
                             decoder.release();
-                            decoder = null;
                         }
                         if (encoder != null) {
                             encoder.stop();
                             encoder.release();
-                            encoder = null;
                         }
 
                         checkConversionCanceled();
@@ -2809,7 +2822,6 @@ private boolean convertVideo(final MessageObject messageObject) {
             } finally {
                 if (extractor != null) {
                     extractor.release();
-                    extractor = null;
                 }
                 if (mediaMuxer != null) {
                     try {
@@ -2817,7 +2829,6 @@ private boolean convertVideo(final MessageObject messageObject) {
                     } catch (Exception e) {
                         FileLog.e("tmessages", e);
                     }
-                    mediaMuxer = null;
                 }
                 FileLog.e("tmessages", "time = " + (System.currentTimeMillis() - time));
             }
diff --git a/TMessagesProj/src/main/java/org/telegram/android/MessageObject.java b/TMessagesProj/src/main/java/org/telegram/android/MessageObject.java
index 45673ea72..ed916003e 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/MessageObject.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/MessageObject.java
@@ -25,6 +25,7 @@
 import org.telegram.messenger.R;
 import org.telegram.messenger.UserConfig;
 import org.telegram.ui.Components.URLSpanNoUnderline;
+import org.telegram.ui.Components.URLSpanNoUnderlineBold;
 
 import java.util.AbstractMap;
 import java.util.ArrayList;
@@ -48,10 +49,11 @@
     public int contentType;
     public String dateKey;
     public String monthKey;
-    public boolean deleted = false;
+    public boolean deleted;
     public float audioProgress;
     public int audioProgressSec;
     public ArrayList<TLRPC.PhotoSize> photoThumbs;
+    public VideoEditedInfo videoEditedInfo;
 
     public static TextPaint textPaint;
     public int lastLineWidth;
@@ -147,7 +149,7 @@ public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> use
                     if (whoUser != null && fromUser != null) {
                         if (whoUser.id == fromUser.id) {
                             if (isOut()) {
-                                messageText = LocaleController.getString("ActionAddUserSelf", R.string.ActionAddUserSelf).replace("un1", LocaleController.getString("FromYou", R.string.FromYou));
+                                messageText = LocaleController.getString("ActionAddUserSelfYou", R.string.ActionAddUserSelfYou);
                             } else {
                                 messageText = replaceWithLink(LocaleController.getString("ActionAddUserSelf", R.string.ActionAddUserSelf), "un1", fromUser);
                             }
@@ -331,6 +333,9 @@ public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> use
         if (message instanceof TLRPC.TL_message || message instanceof TLRPC.TL_messageForwarded_old2) {
             if (isMediaEmpty()) {
                 contentType = type = 0;
+                if (messageText.length() == 0) {
+                    messageText = "Empty message";
+                }
             } else if (message.media instanceof TLRPC.TL_messageMediaPhoto) {
                 contentType = type = 1;
             } else if (message.media instanceof TLRPC.TL_messageMediaGeo || message.media instanceof TLRPC.TL_messageMediaVenue) {
@@ -351,9 +356,6 @@ public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> use
                         type = 8;
                     } else if (message.media.document.mime_type.equals("image/webp") && isSticker()) {
                         type = 13;
-                        if (messageOwner.media.document.thumb != null && messageOwner.media.document.thumb.location != null) {
-                            messageOwner.media.document.thumb.location.ext = "webp";
-                        }
                     } else {
                         type = 9;
                     }
@@ -393,6 +395,11 @@ public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> use
             monthKey = String.format("%d_%02d", dateYear, dateMonth);
         }
 
+        if (messageOwner.message != null && messageOwner.id < 0 && messageOwner.message.length() > 6 && messageOwner.media instanceof TLRPC.TL_messageMediaVideo) {
+            videoEditedInfo = new VideoEditedInfo();
+            videoEditedInfo.parseString(messageOwner.message);
+        }
+
         generateCaption();
         if (generateLayout) {
             generateLayout();
@@ -458,7 +465,7 @@ public void generateThumbs(boolean update) {
                 if (messageOwner.media.webpage.photo != null) {
                     if (!update || photoThumbs == null) {
                         photoThumbs = new ArrayList<>(messageOwner.media.webpage.photo.sizes);
-                    } else if (photoThumbs != null && !photoThumbs.isEmpty()) {
+                    } else if (!photoThumbs.isEmpty()) {
                         for (TLRPC.PhotoSize photoObject : photoThumbs) {
                             for (TLRPC.PhotoSize size : messageOwner.media.webpage.photo.sizes) {
                                 if (size instanceof TLRPC.TL_photoSizeEmpty) {
@@ -479,7 +486,7 @@ public void generateThumbs(boolean update) {
     public CharSequence replaceWithLink(CharSequence source, String param, TLRPC.User user) {
         String name = ContactsController.formatName(user.first_name, user.last_name);
         int start = TextUtils.indexOf(source, param);
-        URLSpanNoUnderline span = new URLSpanNoUnderline("" + user.id);
+        URLSpanNoUnderlineBold span = new URLSpanNoUnderlineBold("" + user.id);
         SpannableStringBuilder builder = new SpannableStringBuilder(TextUtils.replace(source, new String[]{param}, new String[]{name}));
         builder.setSpan(span, start, start + name.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
         return builder;
@@ -664,7 +671,7 @@ private void generateLayout() {
             }
         }
 
-        StaticLayout textLayout = null;
+        StaticLayout textLayout;
 
         try {
             textLayout = new StaticLayout(messageText, textPaint, maxWidth, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
@@ -783,7 +790,6 @@ private void generateLayout() {
                     if (a == blocksCount - 1) {
                         lastLineWidth = lastLineWidthWithLeft;
                     }
-                    linesMaxWidth = linesMaxWidthWithLeft;
                 } else if (a == blocksCount - 1) {
                     lastLineWidth = linesMaxWidth;
                 }
@@ -939,6 +945,20 @@ public static boolean isStickerMessage(TLRPC.Message message) {
         return false;
     }
 
+    public static TLRPC.InputStickerSet getInputStickerSet(TLRPC.Message message) {
+        if (message.media != null && message.media.document != null) {
+            for (TLRPC.DocumentAttribute attribute : message.media.document.attributes) {
+                if (attribute instanceof TLRPC.TL_documentAttributeSticker) {
+                    if (attribute.stickerset instanceof TLRPC.TL_inputStickerSetEmpty) {
+                        return null;
+                    }
+                    return attribute.stickerset;
+                }
+            }
+        }
+        return null;
+    }
+
     public String getStrickerChar() {
         if (messageOwner.media != null && messageOwner.media.document != null) {
             for (TLRPC.DocumentAttribute attribute : messageOwner.media.document.attributes) {
@@ -991,8 +1011,8 @@ public int getApproximateHeight() {
             }
             return photoHeight + AndroidUtilities.dp(14);
         } else {
-            int photoHeight = 0;
-            int photoWidth = 0;
+            int photoHeight;
+            int photoWidth;
 
             if (AndroidUtilities.isTablet()) {
                 photoWidth = (int) (AndroidUtilities.getMinTabletSide() * 0.7f);
@@ -1010,35 +1030,22 @@ public int getApproximateHeight() {
 
             if (currentPhotoObject != null) {
                 float scale = (float) currentPhotoObject.w / (float) photoWidth;
-                int w = (int) (currentPhotoObject.w / scale);
                 int h = (int) (currentPhotoObject.h / scale);
-                if (w == 0) {
-                    w = AndroidUtilities.dp(100);
-                }
                 if (h == 0) {
                     h = AndroidUtilities.dp(100);
                 }
                 if (h > photoHeight) {
-                    float scale2 = h;
                     h = photoHeight;
-                    scale2 /= h;
-                    w = (int) (w / scale2);
                 } else if (h < AndroidUtilities.dp(120)) {
                     h = AndroidUtilities.dp(120);
-                    float hScale = (float) currentPhotoObject.h / h;
-                    if (currentPhotoObject.w / hScale < photoWidth) {
-                        w = (int) (currentPhotoObject.w / hScale);
-                    }
                 }
                 if (isSecretPhoto()) {
                     if (AndroidUtilities.isTablet()) {
-                        w = h = (int) (AndroidUtilities.getMinTabletSide() * 0.5f);
+                        h = (int) (AndroidUtilities.getMinTabletSide() * 0.5f);
                     } else {
-                        w = h = (int) (Math.min(AndroidUtilities.displaySize.x, AndroidUtilities.displaySize.y) * 0.5f);
+                        h = (int) (Math.min(AndroidUtilities.displaySize.x, AndroidUtilities.displaySize.y) * 0.5f);
                     }
                 }
-
-                photoWidth = w;
                 photoHeight = h;
             }
             return photoHeight + AndroidUtilities.dp(14);
@@ -1049,6 +1056,10 @@ public boolean isSticker() {
         return isStickerMessage(messageOwner);
     }
 
+    public TLRPC.InputStickerSet getInputStickerSet() {
+        return getInputStickerSet(messageOwner);
+    }
+
     public boolean isForwarded() {
         return (messageOwner.flags & TLRPC.MESSAGE_FLAG_FWD) != 0;
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/android/MessagesController.java b/TMessagesProj/src/main/java/org/telegram/android/MessagesController.java
index f4b2437b0..01b18bb9a 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/MessagesController.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/MessagesController.java
@@ -10,9 +10,12 @@
 
 import android.app.Activity;
 import android.app.AlertDialog;
+import android.app.ProgressDialog;
+import android.content.DialogInterface;
 import android.content.SharedPreferences;
 import android.content.pm.PackageInfo;
 import android.os.Build;
+import android.os.Bundle;
 import android.util.Base64;
 import android.util.SparseArray;
 
@@ -28,6 +31,8 @@
 import org.telegram.messenger.Utilities;
 import org.telegram.messenger.ApplicationLoader;
 import org.telegram.ui.ActionBar.BaseFragment;
+import org.telegram.ui.ChatActivity;
+import org.telegram.ui.ProfileActivity;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -129,6 +134,7 @@
     }
 
     private static volatile MessagesController Instance = null;
+
     public static MessagesController getInstance() {
         MessagesController localInstance = Instance;
         if (localInstance == null) {
@@ -200,7 +206,7 @@ public void run() {
                         disabledFeature.serializeToStream(data);
                     }
                     String string = Base64.encodeToString(data.toByteArray(), Base64.DEFAULT);
-                    if (string != null && string.length() != 0) {
+                    if (string.length() != 0) {
                         editor.putString("disabledFeatures", string);
                     }
                 } catch (Exception e) {
@@ -223,7 +229,7 @@ public static boolean isFeatureEnabled(String feature, BaseFragment fragment) {
                     builder.setTitle("Oops!");
                     builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
                     builder.setMessage(disabledFeature.description);
-                    fragment.showAlertDialog(builder);
+                    fragment.showDialog(builder.create());
                 }
                 return false;
             }
@@ -255,7 +261,7 @@ public void addSupportUser() {
         if (user == null) {
             return null;
         }
-        TLRPC.InputUser inputUser = null;
+        TLRPC.InputUser inputUser;
         if (user.id == UserConfig.getClientUserId()) {
             inputUser = new TLRPC.TL_inputUserSelf();
         } else if (user instanceof TLRPC.TL_userForeign || user instanceof TLRPC.TL_userRequest) {
@@ -272,9 +278,8 @@ public void addSupportUser() {
     @Override
     public void didReceivedNotification(int id, Object... args) {
         if (id == NotificationCenter.FileDidUpload) {
-            final String location = (String)args[0];
-            final TLRPC.InputFile file = (TLRPC.InputFile)args[1];
-            final TLRPC.InputEncryptedFile encryptedFile = (TLRPC.InputEncryptedFile)args[2];
+            final String location = (String) args[0];
+            final TLRPC.InputFile file = (TLRPC.InputFile) args[1];
 
             if (uploadingAvatar != null && uploadingAvatar.equals(location)) {
                 TLRPC.TL_photos_uploadProfilePhoto req = new TLRPC.TL_photos_uploadProfilePhoto();
@@ -327,16 +332,14 @@ public void run() {
             }
         } else if (id == NotificationCenter.FileDidFailUpload) {
             final String location = (String) args[0];
-            final boolean enc = (Boolean) args[1];
-
             if (uploadingAvatar != null && uploadingAvatar.equals(location)) {
                 uploadingAvatar = null;
             }
         } else if (id == NotificationCenter.messageReceivedByServer) {
-            Integer msgId = (Integer)args[0];
+            Integer msgId = (Integer) args[0];
             MessageObject obj = dialogMessage.get(msgId);
             if (obj != null) {
-                Integer newMsgId = (Integer)args[1];
+                Integer newMsgId = (Integer) args[1];
                 dialogMessage.remove(msgId);
                 dialogMessage.put(newMsgId, obj);
                 obj.messageOwner.id = newMsgId;
@@ -360,9 +363,6 @@ public void run() {
                 }
                 NotificationCenter.getInstance().postNotificationName(NotificationCenter.dialogsNeedReload);
             }
-        } else {
-            NotificationCenter.getInstance().addObserver(this, NotificationCenter.FileDidLoaded);
-            NotificationCenter.getInstance().addObserver(this, NotificationCenter.FileDidFailedLoad);
         }
     }
 
@@ -431,7 +431,10 @@ public void cleanUp() {
     }
 
     public TLRPC.User getUser(String username) {
-        return usersByUsernames.get(username);
+        if (username == null || username.length() == 0) {
+            return null;
+        }
+        return usersByUsernames.get(username.toLowerCase());
     }
 
     public ConcurrentHashMap<Integer, TLRPC.User> getUsers() {
@@ -458,8 +461,8 @@ public void cleanUp() {
                 FileLog.e("tmessages", e);
             }
             if (result.size() == 2) {
-                chat = (TLRPC.EncryptedChat)result.get(0);
-                TLRPC.User user = (TLRPC.User)result.get(1);
+                chat = (TLRPC.EncryptedChat) result.get(0);
+                TLRPC.User user = (TLRPC.User) result.get(1);
                 putEncryptedChat(chat, false);
                 putUser(user, true);
             }
@@ -471,10 +474,6 @@ public void cleanUp() {
         return exportedChats.get(chat_id);
     }
 
-    public void putExportedInvite(int chat_id, TLRPC.TL_chatInviteExported invite) {
-        exportedChats.put(chat_id, invite);
-    }
-
     public boolean putUser(TLRPC.User user, boolean fromCache) {
         if (user == null) {
             return false;
@@ -485,7 +484,7 @@ public boolean putUser(TLRPC.User user, boolean fromCache) {
             usersByUsernames.remove(oldUser.username);
         }
         if (user.username != null && user.username.length() > 0) {
-            usersByUsernames.put(user.username, user);
+            usersByUsernames.put(user.username.toLowerCase(), user);
         }
         if (!fromCache) {
             users.put(user.id, user);
@@ -637,7 +636,7 @@ public void run() {
                             loadingFullUsers.remove((Integer) user.id);
                             loadedFullUsers.add(user.id);
                             String names = user.first_name + user.last_name + user.username;
-                            TLRPC.TL_userFull userFull = (TLRPC.TL_userFull)response;
+                            TLRPC.TL_userFull userFull = (TLRPC.TL_userFull) response;
                             ArrayList<TLRPC.User> users = new ArrayList<>();
                             users.add(userFull.user);
                             putUsers(users, false);
@@ -651,7 +650,7 @@ public void run() {
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
                         public void run() {
-                            loadingFullUsers.remove((Integer)user.id);
+                            loadingFullUsers.remove((Integer) user.id);
                         }
                     });
                 }
@@ -710,7 +709,7 @@ protected void processNewDifferenceParams(int seq, int pts, int date, int pts_co
                 MessagesStorage.lastPtsValue = pts;
                 MessagesStorage.getInstance().saveDiffParams(MessagesStorage.lastSeqValue, MessagesStorage.lastPtsValue, MessagesStorage.lastDateValue, MessagesStorage.lastQtsValue);
             } else if (MessagesStorage.lastPtsValue != pts) {
-                if (gettingDifference || updatesStartWaitTimePts == 0 || updatesStartWaitTimePts != 0 && updatesStartWaitTimePts + 1500 > System.currentTimeMillis()) {
+                if (gettingDifference || updatesStartWaitTimePts == 0 || updatesStartWaitTimePts + 1500 > System.currentTimeMillis()) {
                     FileLog.e("tmessages", "ADD UPDATE TO QUEUE pts = " + pts + " pts_count = " + pts_count);
                     if (updatesStartWaitTimePts == 0) {
                         updatesStartWaitTimePts = System.currentTimeMillis();
@@ -733,7 +732,7 @@ protected void processNewDifferenceParams(int seq, int pts, int date, int pts_co
                 }
                 MessagesStorage.getInstance().saveDiffParams(MessagesStorage.lastSeqValue, MessagesStorage.lastPtsValue, MessagesStorage.lastDateValue, MessagesStorage.lastQtsValue);
             } else if (MessagesStorage.lastSeqValue != seq) {
-                if (gettingDifference || updatesStartWaitTimeSeq == 0 || updatesStartWaitTimeSeq != 0 && updatesStartWaitTimeSeq + 1500 > System.currentTimeMillis()) {
+                if (gettingDifference || updatesStartWaitTimeSeq == 0 || updatesStartWaitTimeSeq + 1500 > System.currentTimeMillis()) {
                     FileLog.e("tmessages", "ADD UPDATE TO QUEUE seq = " + seq);
                     if (updatesStartWaitTimeSeq == 0) {
                         updatesStartWaitTimeSeq = System.currentTimeMillis();
@@ -826,7 +825,7 @@ public void run() {
                             }
                         };
                         int currentServerTime = ConnectionsManager.getInstance().getCurrentTime();
-                        Utilities.stageQueue.postRunnable(currentDeleteTaskRunnable, (long)Math.abs(currentServerTime - currentDeletingTaskTime) * 1000);
+                        Utilities.stageQueue.postRunnable(currentDeleteTaskRunnable, (long) Math.abs(currentServerTime - currentDeletingTaskTime) * 1000);
                     }
                 } else {
                     currentDeletingTaskTime = 0;
@@ -847,14 +846,14 @@ public void loadUserPhotos(final int uid, final int offset, final int count, fin
             TLRPC.TL_photos_getUserPhotos req = new TLRPC.TL_photos_getUserPhotos();
             req.limit = count;
             req.offset = offset;
-            req.max_id = (int)max_id;
+            req.max_id = (int) max_id;
             req.user_id = getInputUser(user);
             long reqId = ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
                 @Override
                 public void run(TLObject response, TLRPC.TL_error error) {
                     if (error == null) {
                         TLRPC.photos_Photos res = (TLRPC.photos_Photos) response;
-                        processLoadedUserPhotos(res, uid, offset, count, max_id, fromCache, classGuid);
+                        processLoadedUserPhotos(res, uid, offset, count, max_id, false, classGuid);
                     }
                 }
             });
@@ -917,7 +916,7 @@ public void run(TLObject response, TLRPC.TL_error error) {
                     ArrayList<Integer> blocked = new ArrayList<>();
                     ArrayList<TLRPC.User> users = null;
                     if (error == null) {
-                        final TLRPC.contacts_Blocked res = (TLRPC.contacts_Blocked)response;
+                        final TLRPC.contacts_Blocked res = (TLRPC.contacts_Blocked) response;
                         for (TLRPC.TL_contactBlocked contactBlocked : res.blocked) {
                             blocked.add(contactBlocked.user_id);
                         }
@@ -965,9 +964,7 @@ public void deleteUserPhoto(TLRPC.InputPhoto photo) {
             if (user == null) {
                 return;
             }
-            if (user != null) {
-                user.photo = UserConfig.getCurrentUser().photo;
-            }
+            user.photo = UserConfig.getCurrentUser().photo;
             NotificationCenter.getInstance().postNotificationName(NotificationCenter.mainUserInfoChanged);
             NotificationCenter.getInstance().postNotificationName(NotificationCenter.updateInterfaces, MessagesController.UPDATE_MASK_ALL);
             ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
@@ -1077,8 +1074,8 @@ public void run(TLObject response, TLRPC.TL_error error) {
     }
 
     public void deleteDialog(final long did, int offset, final boolean onlyHistory) {
-        int lower_part = (int)did;
-        int high_id = (int)(did >> 32);
+        int lower_part = (int) did;
+        int high_id = (int) (did >> 32);
 
         if (offset == 0) {
             TLRPC.TL_dialog dialog = dialogs_dict.get(did);
@@ -1414,8 +1411,8 @@ public void sendTyping(final long dialog_id, final int action, int classGuid) {
             typings = new HashMap<>();
             sendingTypings.put(action, typings);
         }
-        int lower_part = (int)dialog_id;
-        int high_id = (int)(dialog_id >> 32);
+        int lower_part = (int) dialog_id;
+        int high_id = (int) (dialog_id >> 32);
         if (lower_part != 0) {
             if (high_id == 1) {
                 return;
@@ -1505,7 +1502,7 @@ public void run() {
     }
 
     public void loadMessages(final long dialog_id, final int count, final int max_id, boolean fromCache, int midDate, final int classGuid, final int load_type, final int last_message_id, final int first_message_id, final boolean allowCache) {
-        int lower_part = (int)dialog_id;
+        int lower_part = (int) dialog_id;
         if (fromCache || lower_part == 0) {
             MessagesStorage.getInstance().getMessages(dialog_id, count, max_id, midDate, classGuid, load_type);
         } else {
@@ -1515,6 +1512,9 @@ public void loadMessages(final long dialog_id, final int count, final int max_id
                 req.peer.chat_id = -lower_part;
             } else {
                 TLRPC.User user = getUser(lower_part);
+                if (user == null) {
+                    return;
+                }
                 if (user instanceof TLRPC.TL_userForeign || user instanceof TLRPC.TL_userRequest) {
                     req.peer = new TLRPC.TL_inputPeerForeign();
                     req.peer.user_id = user.id;
@@ -1785,7 +1785,7 @@ public void run() {
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
                         public void run() {
-                            putUsers(dialogsRes.users, isCache);
+                            putUsers(dialogsRes.users, true);
                             loadingDialogs = false;
                             if (resetEnd) {
                                 dialogsEndReached = false;
@@ -1936,8 +1936,8 @@ public void markMessageAsRead(final long dialog_id, final long random_id, int tt
         if (random_id == 0 || dialog_id == 0 || ttl <= 0) {
             return;
         }
-        int lower_part = (int)dialog_id;
-        int high_id = (int)(dialog_id >> 32);
+        int lower_part = (int) dialog_id;
+        int high_id = (int) (dialog_id >> 32);
         if (lower_part != 0) {
             return;
         }
@@ -1953,8 +1953,8 @@ public void markMessageAsRead(final long dialog_id, final long random_id, int tt
     }
 
     public void markDialogAsRead(final long dialog_id, final int max_id, final int max_positive_id, final int offset, final int max_date, final boolean was, final boolean popup) {
-        int lower_part = (int)dialog_id;
-        int high_id = (int)(dialog_id >> 32);
+        int lower_part = (int) dialog_id;
+        int high_id = (int) (dialog_id >> 32);
 
         if (lower_part != 0) {
             if (max_positive_id == 0 && offset == 0 || high_id == 1) {
@@ -2079,7 +2079,7 @@ public long createChat(String title, ArrayList<Integer> selectedContacts, boolea
             chat.title = title;
             chat.photo = new TLRPC.TL_chatPhotoEmpty();
             chat.participants_count = selectedContacts.size();
-            chat.date = (int)(System.currentTimeMillis() / 1000);
+            chat.date = (int) (System.currentTimeMillis() / 1000);
             chat.left = false;
             chat.version = 1;
             UserConfig.lastBroadcastId--;
@@ -2096,7 +2096,7 @@ public long createChat(String title, ArrayList<Integer> selectedContacts, boolea
                 TLRPC.TL_chatParticipant participant = new TLRPC.TL_chatParticipant();
                 participant.user_id = id;
                 participant.inviter_id = UserConfig.getClientUserId();
-                participant.date = (int)(System.currentTimeMillis() / 1000);
+                participant.date = (int) (System.currentTimeMillis() / 1000);
                 participants.participants.add(participant);
             }
             MessagesStorage.getInstance().updateChatInfo(chat.id, participants, false);
@@ -2246,20 +2246,18 @@ public void run() {
                 MessagesStorage.getInstance().putUsersAndChats(null, chatArrayList, true, true);
 
                 boolean changed = false;
-                if (info != null) {
-                    for (int a = 0; a < info.participants.size(); a++) {
-                        TLRPC.TL_chatParticipant p = info.participants.get(a);
-                        if (p.user_id == user.id) {
-                            info.participants.remove(a);
-                            changed = true;
-                            break;
-                        }
-                    }
-                    if (changed) {
-                        MessagesStorage.getInstance().updateChatInfo(info.chat_id, info, true);
-                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatInfoDidLoaded, info.chat_id, info);
+                for (int a = 0; a < info.participants.size(); a++) {
+                    TLRPC.TL_chatParticipant p = info.participants.get(a);
+                    if (p.user_id == user.id) {
+                        info.participants.remove(a);
+                        changed = true;
+                        break;
                     }
                 }
+                if (changed) {
+                    MessagesStorage.getInstance().updateChatInfo(info.chat_id, info, true);
+                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatInfoDidLoaded, info.chat_id, info);
+                }
                 NotificationCenter.getInstance().postNotificationName(NotificationCenter.updateInterfaces, UPDATE_MASK_CHAT_MEMBERS);
             }
         }
@@ -2325,14 +2323,27 @@ public void run(TLObject response, TLRPC.TL_error error) {
         }
     }
 
-    public void logOut() {
-        TLRPC.TL_auth_logOut req = new TLRPC.TL_auth_logOut();
-        ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
-            @Override
-            public void run(TLObject response, TLRPC.TL_error error) {
-                ConnectionsManager.getInstance().cleanUp();
-            }
-        });
+    public void performLogout(boolean byUser) {
+        SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Activity.MODE_PRIVATE);
+        SharedPreferences.Editor editor = preferences.edit();
+        editor.clear().commit();
+        if (byUser) {
+            unregistedPush();
+            TLRPC.TL_auth_logOut req = new TLRPC.TL_auth_logOut();
+            ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+                @Override
+                public void run(TLObject response, TLRPC.TL_error error) {
+                    ConnectionsManager.getInstance().cleanUp();
+                }
+            });
+        } else {
+            ConnectionsManager.getInstance().cleanUp();
+        }
+        UserConfig.clearConfig();
+        NotificationCenter.getInstance().postNotificationName(NotificationCenter.appDidLogout);
+        MessagesStorage.getInstance().cleanUp(false);
+        cleanUp();
+        ContactsController.getInstance().deleteAllAppAccounts();
     }
 
     public void generateUpdateMessage() {
@@ -2343,6 +2354,9 @@ public void run() {
                     String build = LocaleController.getString("updateBuild", R.string.updateBuild);
                     if (build != null) {
                         int version = Utilities.parseInt(build);
+                        if (version == 0) {
+                            version = 524;
+                        }
                         if (version <= UserConfig.lastUpdateVersion) {
                             return;
                         }
@@ -2378,20 +2392,13 @@ public void registerForPush(final String regid) {
         req.app_sandbox = false;
         try {
             req.lang_code = LocaleController.getLocaleString(LocaleController.getInstance().getSystemDefaultLocale());
-            if (req.lang_code == null || req.lang_code.length() == 0) {
+            if (req.lang_code.length() == 0) {
                 req.lang_code = "en";
             }
             req.device_model = Build.MANUFACTURER + Build.MODEL;
-            if (req.device_model == null) {
-                req.device_model = "Android unknown";
-            }
             req.system_version = "SDK " + Build.VERSION.SDK_INT;
             PackageInfo pInfo = ApplicationLoader.applicationContext.getPackageManager().getPackageInfo(ApplicationLoader.applicationContext.getPackageName(), 0);
             req.app_version = pInfo.versionName + " (" + pInfo.versionCode + ")";
-            if (req.app_version == null) {
-                req.app_version = "App version unknown";
-            }
-
         } catch (Exception e) {
             FileLog.e("tmessages", e);
             req.lang_code = "en";
@@ -2505,15 +2512,15 @@ private int isValidUpdate(TLRPC.Updates updates, int type) {
         } else if (type == 1) {
             if (updates.pts <= MessagesStorage.lastPtsValue) {
                 return 2;
-            }  else if (MessagesStorage.lastPtsValue + updates.pts_count == updates.pts) {
+            } else if (MessagesStorage.lastPtsValue + updates.pts_count == updates.pts) {
                 return 0;
             } else {
                 return 1;
             }
         } else if (type == 2) {
-            if (updates.qts <= MessagesStorage.lastQtsValue) {
+            if (updates.pts <= MessagesStorage.lastQtsValue) {
                 return 2;
-            }  else if (MessagesStorage.lastQtsValue + updates.updates.size() == updates.qts) {
+            } else if (MessagesStorage.lastQtsValue + updates.updates.size() == updates.pts) {
                 return 0;
             } else {
                 return 1;
@@ -2545,11 +2552,11 @@ public int compare(TLRPC.Updates updates, TLRPC.Updates updates2) {
             Collections.sort(updatesQueue, new Comparator<TLRPC.Updates>() {
                 @Override
                 public int compare(TLRPC.Updates updates, TLRPC.Updates updates2) {
-                    return AndroidUtilities.compare(updates.qts, updates2.qts);
+                    return AndroidUtilities.compare(updates.pts, updates2.pts);
                 }
             });
         }
-        if (!updatesQueue.isEmpty()) {
+        if (updatesQueue != null && !updatesQueue.isEmpty()) {
             boolean anyProceed = false;
             if (state == 2) {
                 TLRPC.Updates updates = updatesQueue.get(0);
@@ -2557,8 +2564,8 @@ public int compare(TLRPC.Updates updates, TLRPC.Updates updates2) {
                     MessagesStorage.lastSeqValue = getUpdateSeq(updates);
                 } else if (type == 1) {
                     MessagesStorage.lastPtsValue = updates.pts;
-                } else if (type == 2) {
-                    MessagesStorage.lastQtsValue = updates.qts;
+                } else {
+                    MessagesStorage.lastQtsValue = updates.pts;
                 }
             }
             for (int a = 0; a < updatesQueue.size(); a++) {
@@ -2707,15 +2714,6 @@ public void run() {
                                         for (TLRPC.Message message : res.new_messages) {
                                             MessageObject obj = new MessageObject(message, usersDict, true);
 
-                                            long dialog_id = obj.messageOwner.dialog_id;
-                                            if (dialog_id == 0) {
-                                                if (obj.messageOwner.to_id.chat_id != 0) {
-                                                    dialog_id = -obj.messageOwner.to_id.chat_id;
-                                                } else {
-                                                    dialog_id = obj.messageOwner.to_id.user_id;
-                                                }
-                                            }
-
                                             if (!obj.isOut() && obj.isUnread()) {
                                                 pushMessages.add(obj);
                                             }
@@ -2773,7 +2771,7 @@ public void run() {
                                         SecretChatHelper.getInstance().processPendingEncMessages();
                                     }
 
-                                    if (res != null && !res.other_updates.isEmpty()) {
+                                    if (!res.other_updates.isEmpty()) {
                                         processUpdateArray(res.other_updates, res.users, res.chats);
                                     }
 
@@ -2886,7 +2884,7 @@ public void processUpdates(final TLRPC.Updates updates, boolean fromQueue) {
                 needFwdUser = true;
             }
 
-            boolean missingData = false;
+            boolean missingData;
             if (updates instanceof TLRPC.TL_updateShortMessage) {
                 missingData = user == null || needFwdUser && user2 == null;
             } else {
@@ -2985,7 +2983,7 @@ public void run() {
                     MessagesStorage.getInstance().putMessages(arr, false, true, false, 0);
                 } else if (MessagesStorage.lastPtsValue != updates.pts) {
                     FileLog.e("tmessages", "need get diff short message, pts: " + MessagesStorage.lastPtsValue + " " + updates.pts + " count = " + updates.pts_count);
-                    if (gettingDifference || updatesStartWaitTimePts == 0 || updatesStartWaitTimePts != 0 && updatesStartWaitTimePts + 1500 > System.currentTimeMillis()) {
+                    if (gettingDifference || updatesStartWaitTimePts == 0 || updatesStartWaitTimePts + 1500 > System.currentTimeMillis()) {
                         if (updatesStartWaitTimePts == 0) {
                             updatesStartWaitTimePts = System.currentTimeMillis();
                         }
@@ -3054,24 +3052,24 @@ public int compare(TLRPC.Update lhs, TLRPC.Update rhs) {
                 } else if (getUpdateType(update) == 1) {
                     TLRPC.TL_updates updatesNew = new TLRPC.TL_updates();
                     updatesNew.updates.add(update);
-                    updatesNew.qts = update.qts;
+                    updatesNew.pts = update.qts;
                     for (int b = a + 1; b < updates.updates.size(); b++) {
                         TLRPC.Update update2 = updates.updates.get(b);
-                        if (getUpdateType(update2) == 1 && updatesNew.qts + 1 == update2.qts) {
+                        if (getUpdateType(update2) == 1 && updatesNew.pts + 1 == update2.qts) {
                             updatesNew.updates.add(update2);
-                            updatesNew.qts = update2.qts;
+                            updatesNew.pts = update2.qts;
                             updates.updates.remove(b);
                             b--;
                         } else {
                             break;
                         }
                     }
-                    if (MessagesStorage.lastQtsValue == 0 || MessagesStorage.lastQtsValue + updatesNew.updates.size() == updatesNew.qts) {
+                    if (MessagesStorage.lastQtsValue == 0 || MessagesStorage.lastQtsValue + updatesNew.updates.size() == updatesNew.pts) {
                         processUpdateArray(updatesNew.updates, updates.users, updates.chats);
-                        MessagesStorage.lastQtsValue = updatesNew.qts;
+                        MessagesStorage.lastQtsValue = updatesNew.pts;
                         needReceivedQueue = true;
-                    } else if (MessagesStorage.lastPtsValue != updatesNew.qts) {
-                        FileLog.e("tmessages", update + " need get diff, qts: " + MessagesStorage.lastQtsValue + " " + updatesNew.qts);
+                    } else if (MessagesStorage.lastPtsValue != updatesNew.pts) {
+                        FileLog.e("tmessages", update + " need get diff, qts: " + MessagesStorage.lastQtsValue + " " + updatesNew.pts);
                         if (gettingDifference || updatesStartWaitTimeQts == 0 || updatesStartWaitTimeQts != 0 && updatesStartWaitTimeQts + 1500 > System.currentTimeMillis()) {
                             if (updatesStartWaitTimeQts == 0) {
                                 updatesStartWaitTimeQts = System.currentTimeMillis();
@@ -3089,7 +3087,7 @@ public int compare(TLRPC.Update lhs, TLRPC.Update rhs) {
                 a--;
             }
 
-            boolean processUpdate = false;
+            boolean processUpdate;
             if (updates instanceof TLRPC.TL_updatesCombined) {
                 processUpdate = MessagesStorage.lastSeqValue + 1 == updates.seq_start || MessagesStorage.lastSeqValue == updates.seq_start;
             } else {
@@ -3110,7 +3108,7 @@ public int compare(TLRPC.Update lhs, TLRPC.Update rhs) {
                     FileLog.e("tmessages", "need get diff TL_updates, seq: " + MessagesStorage.lastSeqValue + " " + updates.seq);
                 }
 
-                if (gettingDifference || updatesStartWaitTimeSeq == 0 || updatesStartWaitTimeSeq != 0 && updatesStartWaitTimeSeq + 1500 > System.currentTimeMillis()) {
+                if (gettingDifference || updatesStartWaitTimeSeq == 0 || updatesStartWaitTimeSeq + 1500 > System.currentTimeMillis()) {
                     if (updatesStartWaitTimeSeq == 0) {
                         updatesStartWaitTimeSeq = System.currentTimeMillis();
                     }
@@ -3142,7 +3140,7 @@ public int compare(TLRPC.Update lhs, TLRPC.Update rhs) {
                     } else if (a == 2) {
                         updatesQueue = updatesQueueQts;
                     }
-                    if (!updatesQueue.isEmpty()) {
+                    if (updatesQueue != null && !updatesQueue.isEmpty()) {
                         processUpdatesQueue(a, 0);
                     }
                 }
@@ -3226,7 +3224,7 @@ public void run() {
 
         for (TLRPC.Update update : updates) {
             if (update instanceof TLRPC.TL_updateNewMessage) {
-                TLRPC.TL_updateNewMessage upd = (TLRPC.TL_updateNewMessage)update;
+                TLRPC.TL_updateNewMessage upd = (TLRPC.TL_updateNewMessage) update;
                 if (checkForUsers) {
                     TLRPC.User user = getUser(upd.message.from_id);
                     if (usersDict.get(upd.message.from_id) == null && user == null || upd.message.to_id.chat_id != 0 && chatsDict.get(upd.message.to_id.chat_id) == null && getChat(upd.message.to_id.chat_id) == null) {
@@ -3419,7 +3417,7 @@ public void run() {
             } else if (update instanceof TLRPC.TL_updateNewEncryptedMessage) {
                 ArrayList<TLRPC.Message> decryptedMessages = SecretChatHelper.getInstance().decryptMessage(((TLRPC.TL_updateNewEncryptedMessage) update).message);
                 if (decryptedMessages != null && !decryptedMessages.isEmpty()) {
-                    int cid = ((TLRPC.TL_updateNewEncryptedMessage)update).message.chat_id;
+                    int cid = ((TLRPC.TL_updateNewEncryptedMessage) update).message.chat_id;
                     long uid = ((long) cid) << 32;
                     ArrayList<MessageObject> arr = messages.get(uid);
                     if (arr == null) {
@@ -3475,7 +3473,7 @@ public void run() {
             } else if (update instanceof TLRPC.TL_updateEncryption) {
                 SecretChatHelper.getInstance().processUpdateEncryption((TLRPC.TL_updateEncryption) update, usersDict);
             } else if (update instanceof TLRPC.TL_updateUserBlocked) {
-                final TLRPC.TL_updateUserBlocked finalUpdate = (TLRPC.TL_updateUserBlocked)update;
+                final TLRPC.TL_updateUserBlocked finalUpdate = (TLRPC.TL_updateUserBlocked) update;
                 if (finalUpdate.blocked) {
                     ArrayList<Integer> ids = new ArrayList<>();
                     ids.add(finalUpdate.user_id);
@@ -3514,7 +3512,7 @@ public void run() {
                 newMessage.to_id.user_id = UserConfig.getClientUserId();
                 newMessage.dialog_id = 777000;
                 newMessage.media = update.media;
-                newMessage.message = ((TLRPC.TL_updateServiceNotification)update).message;
+                newMessage.message = ((TLRPC.TL_updateServiceNotification) update).message;
 
                 messagesArr.add(newMessage);
                 MessageObject obj = new MessageObject(newMessage, usersDict, true);
@@ -3575,7 +3573,6 @@ public void run() {
             public void run() {
                 int updateMask = interfaceUpdateMaskFinal;
 
-                boolean avatarsUpdate = false;
                 if (!updatesOnMainThread.isEmpty()) {
                     ArrayList<TLRPC.User> dbUsers = new ArrayList<>();
                     ArrayList<TLRPC.User> dbUsersStatus = new ArrayList<>();
@@ -3627,7 +3624,6 @@ public void run() {
                             if (currentUser != null) {
                                 currentUser.photo = update.photo;
                             }
-                            avatarsUpdate = true;
                             toDbUser.photo = update.photo;
                             dbUsers.add(toDbUser);
                         } else if (update instanceof TLRPC.TL_updateUserPhone) {
@@ -3643,14 +3639,15 @@ public void run() {
                             toDbUser.phone = update.phone;
                             dbUsers.add(toDbUser);
                         } else if (update instanceof TLRPC.TL_updateNotifySettings) {
-                            if (update.notify_settings instanceof TLRPC.TL_peerNotifySettings && update.peer instanceof TLRPC.TL_notifyPeer) {
+                            TLRPC.TL_updateNotifySettings updateNotifySettings = (TLRPC.TL_updateNotifySettings) update;
+                            if (update.notify_settings instanceof TLRPC.TL_peerNotifySettings && updateNotifySettings.peer instanceof TLRPC.TL_notifyPeer) {
                                 if (editor == null) {
                                     SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Activity.MODE_PRIVATE);
                                     editor = preferences.edit();
                                 }
-                                long dialog_id = update.peer.peer.user_id;
+                                long dialog_id = updateNotifySettings.peer.peer.user_id;
                                 if (dialog_id == 0) {
-                                    dialog_id = -update.peer.peer.chat_id;
+                                    dialog_id = -updateNotifySettings.peer.peer.chat_id;
                                 }
                                 TLRPC.TL_dialog dialog = dialogs_dict.get(dialog_id);
                                 if (dialog != null) {
@@ -3671,7 +3668,7 @@ public void run() {
                                             dialog.notify_settings.mute_until = until;
                                         }
                                     }
-                                    MessagesStorage.getInstance().setDialogFlags(dialog_id, ((long)until << 32) | 1);
+                                    MessagesStorage.getInstance().setDialogFlags(dialog_id, ((long) until << 32) | 1);
                                 } else {
                                     if (dialog != null) {
                                         dialog.notify_settings.mute_until = 0;
@@ -3888,19 +3885,25 @@ protected void updateInterfaceWithMessages(long uid, ArrayList<MessageObject> me
     }
 
     protected void updateInterfaceWithMessages(final long uid, final ArrayList<MessageObject> messages, boolean isBroadcast) {
-        MessageObject lastMessage = null;
-        TLRPC.TL_dialog dialog = dialogs_dict.get(uid);
-
-        boolean isEncryptedChat = ((int)uid) == 0;
-
-        NotificationCenter.getInstance().postNotificationName(NotificationCenter.didReceivedNewMessages, uid, messages);
+        if (messages == null || messages.isEmpty()) {
+            return;
+        }
 
+        boolean isEncryptedChat = ((int) uid) == 0;
+        MessageObject lastMessage = null;
         for (MessageObject message : messages) {
             if (lastMessage == null || (!isEncryptedChat && message.getId() > lastMessage.getId() || (isEncryptedChat || message.getId() < 0 && lastMessage.getId() < 0) && message.getId() < lastMessage.getId()) || message.messageOwner.date > lastMessage.messageOwner.date) {
                 lastMessage = message;
             }
         }
 
+        TLRPC.TL_dialog dialog = dialogs_dict.get(uid);
+        NotificationCenter.getInstance().postNotificationName(NotificationCenter.didReceivedNewMessages, uid, messages);
+
+        if (lastMessage == null) {
+            return;
+        }
+
         boolean changed = false;
 
         if (dialog == null) {
@@ -3958,13 +3961,88 @@ public int compare(TLRPC.TL_dialog tl_dialog, TLRPC.TL_dialog tl_dialog2) {
                 }
             });
             for (TLRPC.TL_dialog d : dialogs) {
-                int high_id = (int)(d.id >> 32);
-                if ((int)d.id != 0 && high_id != 1) {
+                int high_id = (int) (d.id >> 32);
+                if ((int) d.id != 0 && high_id != 1) {
                     dialogsServerOnly.add(d);
                 }
             }
         }
     }
 
+    public static void openByUserName(String username, final BaseFragment fragment, final int type) {
+        if (username == null || fragment == null) {
+            return;
+        }
+        TLRPC.User user = MessagesController.getInstance().getUser(username);
+        if (user != null) {
+            Bundle args = new Bundle();
+            args.putInt("user_id", user.id);
+            if (type == 0) {
+                fragment.presentFragment(new ProfileActivity(args));
+            } else {
+                fragment.presentFragment(new ChatActivity(args));
+            }
+        } else {
+            if (fragment.getParentActivity() == null) {
+                return;
+            }
+            final ProgressDialog progressDialog = new ProgressDialog(fragment.getParentActivity());
+            progressDialog.setMessage(LocaleController.getString("Loading", R.string.Loading));
+            progressDialog.setCanceledOnTouchOutside(false);
+            progressDialog.setCancelable(false);
 
+            TLRPC.TL_contacts_resolveUsername req = new TLRPC.TL_contacts_resolveUsername();
+            req.username = username;
+            final long reqId = ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+                @Override
+                public void run(final TLObject response, final TLRPC.TL_error error) {
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            try {
+                                progressDialog.dismiss();
+                            } catch (Exception e) {
+                                FileLog.e("tmessages", e);
+                            }
+                            if (fragment != null) {
+                                fragment.setVisibleDialog(null);
+                            }
+                            if (error == null) {
+                                TLRPC.User user = (TLRPC.User) response;
+                                MessagesController.getInstance().putUser(user, false);
+                                ArrayList<TLRPC.User> users = new ArrayList<>();
+                                users.add(user);
+                                MessagesStorage.getInstance().putUsersAndChats(users, null, false, true);
+                                Bundle args = new Bundle();
+                                args.putInt("user_id", user.id);
+                                if (fragment != null) {
+                                    if (type == 0) {
+                                        fragment.presentFragment(new ProfileActivity(args));
+                                    } else if (type == 1) {
+                                        fragment.presentFragment(new ChatActivity(args));
+                                    }
+                                }
+                            }
+                        }
+                    });
+                }
+            });
+            progressDialog.setButton(DialogInterface.BUTTON_NEGATIVE, LocaleController.getString("Cancel", R.string.Cancel), new DialogInterface.OnClickListener() {
+                @Override
+                public void onClick(DialogInterface dialog, int which) {
+                    ConnectionsManager.getInstance().cancelRpc(reqId, true);
+                    try {
+                        dialog.dismiss();
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
+                    }
+                    if (fragment != null) {
+                        fragment.setVisibleDialog(null);
+                    }
+                }
+            });
+            fragment.setVisibleDialog(progressDialog);
+            progressDialog.show();
+        }
+    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/android/MessagesStorage.java b/TMessagesProj/src/main/java/org/telegram/android/MessagesStorage.java
index 9f445c515..7cde65697 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/MessagesStorage.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/MessagesStorage.java
@@ -282,7 +282,7 @@ public void run() {
                         database.executeFast("PRAGMA user_version = 4").stepThis().dispose();
                         version = 4;
                     }
-                    if (version == 4 && version < 6) {
+                    if (version == 4) {
                         database.executeFast("CREATE TABLE IF NOT EXISTS enc_tasks_v2(mid INTEGER PRIMARY KEY, date INTEGER)").stepThis().dispose();
                         database.executeFast("CREATE INDEX IF NOT EXISTS date_idx_enc_tasks_v2 ON enc_tasks_v2(date);").stepThis().dispose();
                         database.beginTransaction();
@@ -290,7 +290,7 @@ public void run() {
                         SQLitePreparedStatement state = database.executeFast("REPLACE INTO enc_tasks_v2 VALUES(?, ?)");
                         if (cursor.next()) {
                             int date = cursor.intValue(0);
-                            int length = 0;
+                            int length;
                             ByteBufferDesc data = buffersStorage.getFreeBuffer(cursor.byteArrayLength(1));
                             if ((length = cursor.byteBufferValue(1, data.buffer)) != 0) {
                                 for (int a = 0; a < length / 4; a++) {
@@ -313,7 +313,7 @@ public void run() {
                         database.executeFast("PRAGMA user_version = 6").stepThis().dispose();
                         version = 6;
                     }
-                    if (version == 6 && version < 7) {
+                    if (version == 6) {
                         database.executeFast("CREATE TABLE IF NOT EXISTS messages_seq(mid INTEGER PRIMARY KEY, seq_in INTEGER, seq_out INTEGER);").stepThis().dispose();
                         database.executeFast("CREATE INDEX IF NOT EXISTS seq_idx_messages_seq ON messages_seq(seq_in, seq_out);").stepThis().dispose();
                         database.executeFast("ALTER TABLE enc_chats ADD COLUMN layer INTEGER default 0").stepThis().dispose();
@@ -333,7 +333,7 @@ public void run() {
                         database.executeFast("PRAGMA user_version = 9").stepThis().dispose();
                         version = 9;
                     }*/
-                    if ((version == 7 || version == 8 || version == 9) && version < 10) {
+                    if (version == 7 || version == 8 || version == 9) {
                         database.executeFast("ALTER TABLE enc_chats ADD COLUMN use_count INTEGER default 0").stepThis().dispose();
                         database.executeFast("ALTER TABLE enc_chats ADD COLUMN exchange_id INTEGER default 0").stepThis().dispose();
                         database.executeFast("ALTER TABLE enc_chats ADD COLUMN key_date INTEGER default 0").stepThis().dispose();
@@ -343,17 +343,17 @@ public void run() {
                         database.executeFast("PRAGMA user_version = 10").stepThis().dispose();
                         version = 10;
                     }
-                    if (version == 10 && version < 11) {
+                    if (version == 10) {
                         database.executeFast("CREATE TABLE IF NOT EXISTS web_recent_v3(id TEXT, type INTEGER, image_url TEXT, thumb_url TEXT, local_url TEXT, width INTEGER, height INTEGER, size INTEGER, date INTEGER, PRIMARY KEY (id, type));").stepThis().dispose();
                         database.executeFast("PRAGMA user_version = 11").stepThis().dispose();
                         version = 11;
                     }
-                    if (version == 11 && version < 12) {
+                    if (version == 11) {
                         database.executeFast("CREATE TABLE IF NOT EXISTS stickers(id INTEGER PRIMARY KEY, data BLOB, date INTEGER);").stepThis().dispose();
                         database.executeFast("PRAGMA user_version = 12").stepThis().dispose();
                         version = 12;
                     }
-                    if (version == 12 && version < 13) {
+                    if (version == 12) {
                         database.executeFast("DROP INDEX IF EXISTS uid_mid_idx_media;").stepThis().dispose();
                         database.executeFast("DROP INDEX IF EXISTS mid_idx_media;").stepThis().dispose();
                         database.executeFast("DROP INDEX IF EXISTS uid_date_mid_idx_media;").stepThis().dispose();
@@ -370,26 +370,26 @@ public void run() {
                         database.executeFast("PRAGMA user_version = 13").stepThis().dispose();
                         version = 13;
                     }
-                    if (version == 13 && version < 14) {
+                    if (version == 13) {
                         database.executeFast("ALTER TABLE messages ADD COLUMN replydata BLOB default NULL").stepThis().dispose();
                         database.executeFast("PRAGMA user_version = 14").stepThis().dispose();
                         version = 14;
                     }
-                    if (version == 14 && version < 15) {
+                    if (version == 14) {
                         database.executeFast("CREATE TABLE IF NOT EXISTS hashtag_recent_v2(id TEXT PRIMARY KEY, date INTEGER);").stepThis().dispose();
                         database.executeFast("PRAGMA user_version = 15").stepThis().dispose();
                         version = 15;
                     }
-                    if (version == 15 && version < 16) {
+                    if (version == 15) {
                         database.executeFast("CREATE TABLE IF NOT EXISTS webpage_pending(id INTEGER, mid INTEGER, PRIMARY KEY (id, mid));").stepThis().dispose();
                         database.executeFast("PRAGMA user_version = 16").stepThis().dispose();
                         version = 16;
                     }
-                    if (version == 16 && version < 17) {
+                    if (version == 16) {
                         database.executeFast("ALTER TABLE dialogs ADD COLUMN inbox_max INTEGER default 0").stepThis().dispose();
                         database.executeFast("ALTER TABLE dialogs ADD COLUMN outbox_max INTEGER default 0").stepThis().dispose();
                         database.executeFast("PRAGMA user_version = 17").stepThis().dispose();
-                        version = 17;
+                        //version = 17;
                     }
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
@@ -764,7 +764,7 @@ public void getWallpapers() {
             public void run() {
                 try {
                     SQLiteCursor cursor = database.queryFinalized("SELECT data FROM wallpapers WHERE 1");
-                    ArrayList<TLRPC.WallPaper> wallPapers = new ArrayList<>();
+                    final ArrayList<TLRPC.WallPaper> wallPapers = new ArrayList<>();
                     while (cursor.next()) {
                         ByteBufferDesc data = buffersStorage.getFreeBuffer(cursor.byteArrayLength(0));
                         if (data != null && cursor.byteBufferValue(0, data.buffer) != 0) {
@@ -774,7 +774,12 @@ public void run() {
                         buffersStorage.reuseFreeBuffer(data);
                     }
                     cursor.dispose();
-                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.wallpapersDidLoaded, wallPapers);
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            NotificationCenter.getInstance().postNotificationName(NotificationCenter.wallpapersDidLoaded, wallPapers);
+                        }
+                    });
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
                 }
@@ -1069,7 +1074,7 @@ public void run() {
                     int minDate = Integer.MAX_VALUE;
                     SparseArray<ArrayList<Integer>> messages = new SparseArray<>();
                     StringBuilder mids = new StringBuilder();
-                    SQLiteCursor cursor = null;
+                    SQLiteCursor cursor;
                     if (random_ids == null) {
                         cursor = database.queryFinalized(String.format(Locale.US, "SELECT mid, ttl FROM messages WHERE uid = %d AND out = %d AND read_state != 0 AND ttl > 0 AND date <= %d AND send_state = 0 AND media != 1", ((long) chat_id) << 32, isOut, time));
                     } else {
@@ -1763,7 +1768,7 @@ public void run() {
                     ArrayList<Integer> replyMessages = new ArrayList<>();
                     HashMap<Integer, ArrayList<TLRPC.Message>> replyMessageOwners = new HashMap<>();
 
-                    SQLiteCursor cursor = null;
+                    SQLiteCursor cursor;
                     int lower_id = (int)dialog_id;
 
                     if (lower_id != 0) {
@@ -3241,7 +3246,6 @@ private Integer updateMessageStateAndIdInternal(long random_id, Integer _oldId,
             } finally {
                 if (state != null) {
                     state.dispose();
-                    state = null;
                 }
             }
 
@@ -3351,12 +3355,12 @@ private void markMessagesAsReadInternal(HashMap<Integer, Integer> inbox, HashMap
         try {
             if (inbox != null) {
                 for (HashMap.Entry<Integer, Integer> entry : inbox.entrySet()) {
-                    database.executeFast(String.format(Locale.US, "UPDATE messages SET read_state = read_state | 1 WHERE uid = %d AND mid <= %d AND read_state IN(0,2) AND out = 0", entry.getKey(), entry.getValue())).stepThis().dispose();
+                    database.executeFast(String.format(Locale.US, "UPDATE messages SET read_state = read_state | 1 WHERE uid = %d AND mid > 0 AND mid <= %d AND read_state IN(0,2) AND out = 0", entry.getKey(), entry.getValue())).stepThis().dispose();
                 }
             }
             if (outbox != null) {
                 for (HashMap.Entry<Integer, Integer> entry : outbox.entrySet()) {
-                    database.executeFast(String.format(Locale.US, "UPDATE messages SET read_state = read_state | 1 WHERE uid = %d AND mid <= %d AND read_state IN(0,2) AND out = 1", entry.getKey(), entry.getValue())).stepThis().dispose();
+                    database.executeFast(String.format(Locale.US, "UPDATE messages SET read_state = read_state | 1 WHERE uid = %d AND mid > 0 AND mid <= %d AND read_state IN(0,2) AND out = 1", entry.getKey(), entry.getValue())).stepThis().dispose();
                 }
             }
             if (encryptedMessages != null && !encryptedMessages.isEmpty()) {
diff --git a/TMessagesProj/src/main/java/org/telegram/android/NotificationCenter.java b/TMessagesProj/src/main/java/org/telegram/android/NotificationCenter.java
index a75a4f64e..2092d378c 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/NotificationCenter.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/NotificationCenter.java
@@ -8,6 +8,10 @@
 
 package org.telegram.android;
 
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.BuildVars;
+import org.telegram.messenger.FileLog;
+
 import java.util.ArrayList;
 import java.util.HashMap;
 
@@ -51,7 +55,6 @@
     public static final int didSetPasscode = totalEvents++;
     public static final int didSetTwoStepPassword = totalEvents++;
     public static final int screenStateChanged = totalEvents++;
-    public static final int appSwitchedToForeground = totalEvents++;
     public static final int didLoadedReplyMessages = totalEvents++;
     public static final int newSessionReceived = totalEvents++;
     public static final int didReceivedWebpages = totalEvents++;
@@ -94,14 +97,31 @@
     public static final int audioDidStarted = totalEvents++;
     public static final int audioRouteChanged = totalEvents++;
 
-    final private HashMap<Integer, ArrayList<Object>> observers = new HashMap<>();
-
-    final private HashMap<Integer, Object> removeAfterBroadcast = new HashMap<>();
-    final private HashMap<Integer, Object> addAfterBroadcast = new HashMap<>();
+    private HashMap<Integer, ArrayList<Object>> observers = new HashMap<>();
+    private HashMap<Integer, Object> removeAfterBroadcast = new HashMap<>();
+    private HashMap<Integer, Object> addAfterBroadcast = new HashMap<>();
+    private ArrayList<DelayedPost> delayedPosts = new ArrayList<>(10);
 
     private int broadcasting = 0;
+    private boolean animationInProgress;
+
+    public interface NotificationCenterDelegate {
+        void didReceivedNotification(int id, Object... args);
+    }
+
+    private class DelayedPost {
+
+        private DelayedPost(int id, Object[] args) {
+            this.id = id;
+            this.args = args;
+        }
+
+        private int id;
+        private Object[] args;
+    }
 
     private static volatile NotificationCenter Instance = null;
+
     public static NotificationCenter getInstance() {
         NotificationCenter localInstance = Instance;
         if (localInstance == null) {
@@ -115,66 +135,97 @@ public static NotificationCenter getInstance() {
         return localInstance;
     }
 
-    public interface NotificationCenterDelegate {
-        void didReceivedNotification(int id, Object... args);
+    public void setAnimationInProgress(boolean value) {
+        animationInProgress = value;
+        if (!animationInProgress && !delayedPosts.isEmpty()) {
+            for (DelayedPost delayedPost : delayedPosts) {
+                postNotificationNameInternal(delayedPost.id, true, delayedPost.args);
+            }
+            delayedPosts.clear();
+        }
     }
 
     public void postNotificationName(int id, Object... args) {
-        synchronized (observers) {
-            broadcasting++;
-            ArrayList<Object> objects = observers.get(id);
-            if (objects != null) {
-                for (Object obj : objects) {
-                    ((NotificationCenterDelegate)obj).didReceivedNotification(id, args);
-                }
+        boolean allowDuringAnimation = false;
+        if (id == dialogsNeedReload || id == closeChats || id == messagesDidLoaded || id == mediaCountDidLoaded || id == mediaDidLoaded) {
+            allowDuringAnimation = true;
+        }
+        postNotificationNameInternal(id, allowDuringAnimation, args);
+    }
+
+    public void postNotificationNameInternal(int id, boolean allowDuringAnimation, Object... args) {
+        if (BuildVars.DEBUG_VERSION) {
+            if (Thread.currentThread() != ApplicationLoader.applicationHandler.getLooper().getThread()) {
+                throw new RuntimeException("postNotificationName allowed only from MAIN thread");
+            }
+        }
+        if (!allowDuringAnimation && animationInProgress) {
+            DelayedPost delayedPost = new DelayedPost(id, args);
+            delayedPosts.add(delayedPost);
+            if (BuildVars.DEBUG_VERSION) {
+                FileLog.e("tmessages", "delay post notification " + id + " with args count = " + args.length);
             }
-            broadcasting--;
-            if (broadcasting == 0) {
-                if (!removeAfterBroadcast.isEmpty()) {
-                    for (HashMap.Entry<Integer, Object> entry : removeAfterBroadcast.entrySet()) {
-                        removeObserver(entry.getValue(), entry.getKey());
-                    }
-                    removeAfterBroadcast.clear();
+            return;
+        }
+        broadcasting++;
+        ArrayList<Object> objects = observers.get(id);
+        if (objects != null) {
+            for (Object obj : objects) {
+                ((NotificationCenterDelegate) obj).didReceivedNotification(id, args);
+            }
+        }
+        broadcasting--;
+        if (broadcasting == 0) {
+            if (!removeAfterBroadcast.isEmpty()) {
+                for (HashMap.Entry<Integer, Object> entry : removeAfterBroadcast.entrySet()) {
+                    removeObserver(entry.getValue(), entry.getKey());
                 }
-                if (!addAfterBroadcast.isEmpty()) {
-                    for (HashMap.Entry<Integer, Object> entry : addAfterBroadcast.entrySet()) {
-                        addObserver(entry.getValue(), entry.getKey());
-                    }
-                    addAfterBroadcast.clear();
+                removeAfterBroadcast.clear();
+            }
+            if (!addAfterBroadcast.isEmpty()) {
+                for (HashMap.Entry<Integer, Object> entry : addAfterBroadcast.entrySet()) {
+                    addObserver(entry.getValue(), entry.getKey());
                 }
+                addAfterBroadcast.clear();
             }
         }
     }
 
     public void addObserver(Object observer, int id) {
-        synchronized (observers) {
-            if (broadcasting != 0) {
-                addAfterBroadcast.put(id, observer);
-                return;
+        if (BuildVars.DEBUG_VERSION) {
+            if (Thread.currentThread() != ApplicationLoader.applicationHandler.getLooper().getThread()) {
+                throw new RuntimeException("addObserver allowed only from MAIN thread");
             }
-            ArrayList<Object> objects = observers.get(id);
-            if (objects == null) {
-                observers.put(id, (objects = new ArrayList<>()));
-            }
-            if (objects.contains(observer)) {
-                return;
-            }
-            objects.add(observer);
         }
+        if (broadcasting != 0) {
+            addAfterBroadcast.put(id, observer);
+            return;
+        }
+        ArrayList<Object> objects = observers.get(id);
+        if (objects == null) {
+            observers.put(id, (objects = new ArrayList<>()));
+        }
+        if (objects.contains(observer)) {
+            return;
+        }
+        objects.add(observer);
     }
 
     public void removeObserver(Object observer, int id) {
-        synchronized (observers) {
-            if (broadcasting != 0) {
-                removeAfterBroadcast.put(id, observer);
-                return;
+        if (BuildVars.DEBUG_VERSION) {
+            if (Thread.currentThread() != ApplicationLoader.applicationHandler.getLooper().getThread()) {
+                throw new RuntimeException("removeObserver allowed only from MAIN thread");
             }
-            ArrayList<Object> objects = observers.get(id);
-            if (objects != null) {
-                objects.remove(observer);
-                if (objects.size() == 0) {
-                    observers.remove(id);
-                }
+        }
+        if (broadcasting != 0) {
+            removeAfterBroadcast.put(id, observer);
+            return;
+        }
+        ArrayList<Object> objects = observers.get(id);
+        if (objects != null) {
+            objects.remove(observer);
+            if (objects.size() == 0) {
+                observers.remove(id);
             }
         }
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/android/NotificationsController.java b/TMessagesProj/src/main/java/org/telegram/android/NotificationsController.java
index 2192b3663..67fb8fb3f 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/NotificationsController.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/NotificationsController.java
@@ -8,6 +8,7 @@
 
 package org.telegram.android;
 
+import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.app.AlarmManager;
 import android.app.PendingIntent;
@@ -59,9 +60,11 @@
     private HashMap<Long, Point> smartNotificationsDialogs = new HashMap<>();
     private NotificationManagerCompat notificationManager = null;
     private HashMap<Long, Integer> pushDialogs = new HashMap<>();
-    private HashMap<Long, Integer> wearNoticationsIds = new HashMap<>();
+    private HashMap<Long, Integer> wearNotificationsIds = new HashMap<>();
+    private HashMap<Long, Integer> autoNotificationsIds = new HashMap<>();
     private HashMap<Long, Integer> pushDialogsOverrideMention = new HashMap<>();
     private int wearNotificationId = 10000;
+    private int autoNotificationId = 20000;
     public ArrayList<MessageObject> popupMessages = new ArrayList<>();
     private long openned_dialog_id = 0;
     private int total_unread_count = 0;
@@ -70,10 +73,10 @@
     private int lastOnlineFromOtherDevice = 0;
     private boolean inChatSoundEnabled = true;
     private int lastBadgeCount;
+    private String launcherClassName;
 
     private long lastSoundPlay;
-    //private MediaPlayer mediaPlayerIn;
-    //private MediaPlayer mediaPlayerOut;
+    private long lastSoundOutPlay;
     private SoundPool soundPool;
     private int soundIn;
     private int soundOut;
@@ -100,7 +103,6 @@ public NotificationsController() {
 
         try {
             audioManager = (AudioManager) ApplicationLoader.applicationContext.getSystemService(Context.AUDIO_SERVICE);
-            //mediaPlayer = new MediaPlayer();
         } catch (Exception e) {
             FileLog.e("tmessages", e);
         }
@@ -114,7 +116,8 @@ public void cleanup() {
         pushMessagesDict.clear();
         pushDialogs.clear();
         popupMessages.clear();
-        wearNoticationsIds.clear();
+        wearNotificationsIds.clear();
+        autoNotificationsIds.clear();
         notifyCheck = false;
         lastBadgeCount = 0;
         SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Context.MODE_PRIVATE);
@@ -376,13 +379,13 @@ private void showOrUpdateNotification(boolean notifyAboutLast) {
             int needVibrate = 0;
             String choosenSoundPath = null;
             int ledColor = 0xff00ff00;
-            boolean inAppSounds = false;
-            boolean inAppVibrate = false;
+            boolean inAppSounds;
+            boolean inAppVibrate;
             boolean inAppPreview = false;
-            boolean inAppPriority = false;
+            boolean inAppPriority;
             int priority = 0;
-            int priorityOverride = 0;
-            int vibrateOverride = 0;
+            int priorityOverride;
+            int vibrateOverride;
 
             SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Context.MODE_PRIVATE);
             int notifyOverride = getNotifyOverride(preferences, override_dialog_id);
@@ -517,7 +520,7 @@ private void showOrUpdateNotification(boolean notifyAboutLast) {
             }
             PendingIntent contentIntent = PendingIntent.getActivity(ApplicationLoader.applicationContext, 0, intent, PendingIntent.FLAG_ONE_SHOT);
 
-            String name = null;
+            String name;
             boolean replace = true;
             if ((int)dialog_id == 0 || pushDialogs.size() > 1 || AndroidUtilities.needShowPasscode(false) || UserConfig.isWaitingForPasscodeEnter) {
                 name = LocaleController.getString("AppName", R.string.AppName);
@@ -530,7 +533,7 @@ private void showOrUpdateNotification(boolean notifyAboutLast) {
                 }
             }
 
-            String detailText = null;
+            String detailText;
             if (pushDialogs.size() == 1) {
                 detailText = LocaleController.formatPluralString("NewMessages", total_unread_count);
             } else {
@@ -547,12 +550,16 @@ private void showOrUpdateNotification(boolean notifyAboutLast) {
                     .setGroupSummary(true)
                     .setColor(0xff2ca5e0);
 
-            if (priority == 0) {
-                mBuilder.setPriority(NotificationCompat.PRIORITY_DEFAULT);
-            } else if (priority == 1) {
-                mBuilder.setPriority(NotificationCompat.PRIORITY_HIGH);
-            } else if (priority == 2) {
-                mBuilder.setPriority(NotificationCompat.PRIORITY_MAX);
+            if (!notifyAboutLast) {
+                mBuilder.setPriority(NotificationCompat.PRIORITY_LOW);
+            } else {
+                if (priority == 0) {
+                    mBuilder.setPriority(NotificationCompat.PRIORITY_DEFAULT);
+                } else if (priority == 1) {
+                    mBuilder.setPriority(NotificationCompat.PRIORITY_HIGH);
+                } else if (priority == 2) {
+                    mBuilder.setPriority(NotificationCompat.PRIORITY_MAX);
+                }
             }
 
             mBuilder.setCategory(NotificationCompat.CATEGORY_MESSAGE);
@@ -649,18 +656,20 @@ private void showOrUpdateNotification(boolean notifyAboutLast) {
                 mBuilder.setVibrate(new long[]{0, 0});
             }
 
+            showExtraNotifications(mBuilder, notifyAboutLast);
             notificationManager.notify(1, mBuilder.build());
             if (preferences.getBoolean("EnablePebbleNotifications", false)) {
                 sendAlertToPebble(lastMessageFull);
             }
-            showWearNotifications(notifyAboutLast);
+
             scheduleNotificationRepeat();
         } catch (Exception e) {
             FileLog.e("tmessages", e);
         }
     }
 
-    public void showWearNotifications(boolean notifyAboutLast) {
+    @SuppressLint("InlinedApi")
+    public void showExtraNotifications(NotificationCompat.Builder notificationBuilder, boolean notifyAboutLast) {
         if (Build.VERSION.SDK_INT < 19) {
             return;
         }
@@ -681,16 +690,21 @@ public void showWearNotifications(boolean notifyAboutLast) {
             arrayList.add(messageObject);
         }
 
-        HashMap<Long, Integer> oldIds = new HashMap<>();
-        oldIds.putAll(wearNoticationsIds);
-        wearNoticationsIds.clear();
+        HashMap<Long, Integer> oldIdsWear = new HashMap<>();
+        oldIdsWear.putAll(wearNotificationsIds);
+        wearNotificationsIds.clear();
+
+        HashMap<Long, Integer> oldIdsAuto = new HashMap<>();
+        oldIdsAuto.putAll(autoNotificationsIds);
+        autoNotificationsIds.clear();
 
         for (long dialog_id : sortedDialogs) {
             ArrayList<MessageObject> messageObjects = messagesByDialogs.get(dialog_id);
             int max_id = messageObjects.get(0).getId();
+            int max_date = messageObjects.get(0).messageOwner.date;
             TLRPC.Chat chat = null;
             TLRPC.User user = null;
-            String name = null;
+            String name;
             if (dialog_id > 0) {
                 user = MessagesController.getInstance().getUser((int)dialog_id);
                 if (user == null) {
@@ -708,28 +722,56 @@ public void showWearNotifications(boolean notifyAboutLast) {
                 name = ContactsController.formatName(user.first_name, user.last_name);
             }
 
-            Integer notificationId = oldIds.get(dialog_id);
-            if (notificationId == null) {
-                notificationId = wearNotificationId++;
+            Integer notificationIdWear = oldIdsWear.get(dialog_id);
+            if (notificationIdWear == null) {
+                notificationIdWear = wearNotificationId++;
+            } else {
+                oldIdsWear.remove(dialog_id);
+            }
+
+            Integer notificationIdAuto = oldIdsAuto.get(dialog_id);
+            if (notificationIdAuto == null) {
+                notificationIdAuto = autoNotificationId++;
             } else {
-                oldIds.remove(dialog_id);
+                oldIdsAuto.remove(dialog_id);
             }
 
             Intent replyIntent = new Intent(ApplicationLoader.applicationContext, WearReplyReceiver.class);
             replyIntent.putExtra("dialog_id", dialog_id);
             replyIntent.putExtra("max_id", max_id);
-            PendingIntent replyPendingIntent = PendingIntent.getBroadcast(ApplicationLoader.applicationContext, notificationId, replyIntent, PendingIntent.FLAG_UPDATE_CURRENT);
-            RemoteInput remoteInput = new RemoteInput.Builder(EXTRA_VOICE_REPLY).setLabel(LocaleController.getString("Reply", R.string.Reply)).build();
+            PendingIntent replyPendingIntent = PendingIntent.getBroadcast(ApplicationLoader.applicationContext, notificationIdWear, replyIntent, PendingIntent.FLAG_UPDATE_CURRENT);
+            RemoteInput remoteInputWear = new RemoteInput.Builder(EXTRA_VOICE_REPLY).setLabel(LocaleController.getString("Reply", R.string.Reply)).build();
             String replyToString;
             if (chat != null) {
                 replyToString = LocaleController.formatString("ReplyToGroup", R.string.ReplyToGroup, name);
             } else {
                 replyToString = LocaleController.formatString("ReplyToUser", R.string.ReplyToUser, name);
             }
-            NotificationCompat.Action action = new NotificationCompat.Action.Builder(R.drawable.ic_reply_icon, replyToString, replyPendingIntent).addRemoteInput(remoteInput).build();
+            NotificationCompat.Action action = new NotificationCompat.Action.Builder(R.drawable.ic_reply_icon, replyToString, replyPendingIntent).addRemoteInput(remoteInputWear).build();
+
+            Intent msgHeardIntent = new Intent();
+            msgHeardIntent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);
+            msgHeardIntent.setAction("org.telegram.messenger.ACTION_MESSAGE_HEARD");
+            msgHeardIntent.putExtra("dialog_id", dialog_id);
+            msgHeardIntent.putExtra("max_id", max_id);
+            PendingIntent msgHeardPendingIntent = PendingIntent.getBroadcast(ApplicationLoader.applicationContext, notificationIdAuto, msgHeardIntent, PendingIntent.FLAG_UPDATE_CURRENT);
+
+            Intent msgReplyIntent = new Intent();
+            msgReplyIntent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);
+            msgReplyIntent.setAction("org.telegram.messenger.ACTION_MESSAGE_REPLY");
+            msgReplyIntent.putExtra("dialog_id", dialog_id);
+            msgReplyIntent.putExtra("max_id", max_id);
+            PendingIntent msgReplyPendingIntent = PendingIntent.getBroadcast(ApplicationLoader.applicationContext, notificationIdAuto, msgReplyIntent, PendingIntent.FLAG_UPDATE_CURRENT);
+            RemoteInput remoteInputAuto = new RemoteInput.Builder(NotificationsController.EXTRA_VOICE_REPLY).setLabel(LocaleController.getString("Reply", R.string.Reply)).build();
+
+            NotificationCompat.CarExtender.UnreadConversation.Builder unreadConvBuilder = new NotificationCompat.CarExtender.UnreadConversation.Builder(name)
+            .setReadPendingIntent(msgHeardPendingIntent)
+            .setReplyAction(msgReplyPendingIntent, remoteInputAuto)
+            .setLatestTimestamp((long) max_date * 1000);
 
             String text = "";
-            for (MessageObject messageObject : messageObjects) {
+            for (int a = messageObjects.size() - 1; a >= 0; a--) {
+                MessageObject messageObject = messageObjects.get(a);
                 String message = getStringForMessage(messageObject, false);
                 if (message == null) {
                     continue;
@@ -743,8 +785,40 @@ public void showWearNotifications(boolean notifyAboutLast) {
                     text += "\n\n";
                 }
                 text += message;
+
+                unreadConvBuilder.addMessage(message);
             }
 
+
+
+            TLRPC.FileLocation photoPath = null;
+            if (chat != null) {
+                if (chat.photo != null && chat.photo.photo_small != null && chat.photo.photo_small.volume_id != 0 && chat.photo.photo_small.local_id != 0) {
+                    photoPath = chat.photo.photo_small;
+                }
+            } else {
+                if (user.photo != null && user.photo.photo_small != null && user.photo.photo_small.volume_id != 0 && user.photo.photo_small.local_id != 0) {
+                    photoPath = user.photo.photo_small;
+                }
+            }
+            //notificationBuilder.extend(new NotificationCompat.CarExtender().setUnreadConversation(unreadConvBuilder.build()));
+            NotificationCompat.Builder builderAuto = new NotificationCompat.Builder(ApplicationLoader.applicationContext)
+                    .setSmallIcon(R.drawable.notification)
+                    .setColor(0xff2ca5e0)
+                    .setGroup("messages")
+                    .setLocalOnly(true)
+                    //.setGroupSummary(false)
+                    //.setCategory(NotificationCompat.CATEGORY_MESSAGE)
+                    .extend(new NotificationCompat.CarExtender().setUnreadConversation(unreadConvBuilder.build()));
+            if (photoPath != null) {
+                BitmapDrawable img = ImageLoader.getInstance().getImageFromMemory(photoPath, null, "50_50");
+                if (img != null) {
+                    builderAuto.setLargeIcon(img.getBitmap());
+                }
+            }
+            notificationManager.notify("android_auto", notificationIdAuto, builderAuto.build());
+            autoNotificationsIds.put(dialog_id, notificationIdAuto);
+
             Intent intent = new Intent(ApplicationLoader.applicationContext, LaunchActivity.class);
             intent.setAction("com.tmessages.openchat" + Math.random() + Integer.MAX_VALUE);
             intent.setFlags(32768);
@@ -760,20 +834,30 @@ public void showWearNotifications(boolean notifyAboutLast) {
                     .setSmallIcon(R.drawable.notification)
                     .setGroup("messages")
                     .setContentText(text)
+                    .setColor(0xff2ca5e0)
                     .setGroupSummary(false)
                     .setContentIntent(contentIntent)
                     .extend(new NotificationCompat.WearableExtender().addAction(action))
                     .setCategory(NotificationCompat.CATEGORY_MESSAGE);
+            if (photoPath != null) {
+                BitmapDrawable img = ImageLoader.getInstance().getImageFromMemory(photoPath, null, "50_50");
+                if (img != null) {
+                    builder.setLargeIcon(img.getBitmap());
+                }
+            }
 
             if (chat == null && user != null && user.phone != null && user.phone.length() > 0) {
                 builder.addPerson("tel:+" + user.phone);
             }
 
-            notificationManager.notify(notificationId, builder.build());
-            wearNoticationsIds.put(dialog_id, notificationId);
+            notificationManager.notify(notificationIdWear, builder.build());
+            wearNotificationsIds.put(dialog_id, notificationIdWear);
         }
 
-        for (HashMap.Entry<Long, Integer> entry : oldIds.entrySet()) {
+        for (HashMap.Entry<Long, Integer> entry : oldIdsAuto.entrySet()) {
+            notificationManager.cancel(entry.getValue());
+        }
+        for (HashMap.Entry<Long, Integer> entry : oldIdsWear.entrySet()) {
             notificationManager.cancel(entry.getValue());
         }
     }
@@ -783,6 +867,14 @@ private void dismissNotification() {
             notificationManager.cancel(1);
             pushMessages.clear();
             pushMessagesDict.clear();
+            for (HashMap.Entry<Long, Integer> entry : autoNotificationsIds.entrySet()) {
+                notificationManager.cancel(entry.getValue());
+            }
+            autoNotificationsIds.clear();
+            for (HashMap.Entry<Long, Integer> entry : wearNotificationsIds.entrySet()) {
+                notificationManager.cancel(entry.getValue());
+            }
+            wearNotificationsIds.clear();
             NotificationCenter.getInstance().postNotificationName(NotificationCenter.pushMessagesUpdated);
         } catch (Exception e) {
             FileLog.e("tmessages", e);
@@ -893,29 +985,19 @@ public void run() {
                     try {
                         if (soundPool == null) {
                             soundPool = new SoundPool(4, AudioManager.STREAM_SYSTEM, 0);
+                            soundPool.setOnLoadCompleteListener(new SoundPool.OnLoadCompleteListener() {
+                                @Override
+                                public void onLoadComplete(SoundPool soundPool, int sampleId, int status) {
+                                    if (status == 0) {
+                                        soundPool.play(sampleId, 1.0f, 1.0f, 1, 0, 1.0f);
+                                    }
+                                }
+                            });
                         }
                         if (soundIn == 0) {
                             soundIn = soundPool.load(ApplicationLoader.applicationContext, R.raw.sound_in, 1);
                         }
                         soundPool.play(soundIn, 1.0f, 1.0f, 1, 0, 1.0f);
-                        /*if (mediaPlayerIn == null) {
-                            AssetFileDescriptor assetFileDescriptor = ApplicationLoader.applicationContext.getResources().openRawResourceFd(R.raw.sound_in);
-                            if (assetFileDescriptor != null) {
-                                mediaPlayerIn = new MediaPlayer();
-                                mediaPlayerIn.setAudioStreamType(AudioManager.STREAM_SYSTEM);
-                                mediaPlayerIn.setDataSource(assetFileDescriptor.getFileDescriptor(), assetFileDescriptor.getStartOffset(), assetFileDescriptor.getLength());
-                                mediaPlayerIn.setLooping(false);
-                                assetFileDescriptor.close();
-                                mediaPlayerIn.prepare();
-                            }
-                        }
-                        try {
-                            mediaPlayerIn.pause();
-                            mediaPlayerIn.seekTo(0);
-                        } catch (Exception e) {
-                            FileLog.e("tmessages", e);
-                        }
-                        mediaPlayerIn.start();*/
                     } catch (Exception e) {
                         FileLog.e("tmessages", e);
                     }
@@ -941,31 +1023,25 @@ public void playOutChatSound() {
             @Override
             public void run() {
                 try {
+                    if (lastSoundOutPlay > System.currentTimeMillis() - 100) {
+                        return;
+                    }
+                    lastSoundOutPlay = System.currentTimeMillis();
                     if (soundPool == null) {
                         soundPool = new SoundPool(4, AudioManager.STREAM_SYSTEM, 0);
+                        soundPool.setOnLoadCompleteListener(new SoundPool.OnLoadCompleteListener() {
+                            @Override
+                            public void onLoadComplete(SoundPool soundPool, int sampleId, int status) {
+                                if (status == 0) {
+                                    soundPool.play(sampleId, 1.0f, 1.0f, 1, 0, 1.0f);
+                                }
+                            }
+                        });
                     }
                     if (soundOut == 0) {
                         soundOut = soundPool.load(ApplicationLoader.applicationContext, R.raw.sound_out, 1);
                     }
                     soundPool.play(soundOut, 1.0f, 1.0f, 1, 0, 1.0f);
-                    /*if (mediaPlayerOut == null) {
-                        AssetFileDescriptor assetFileDescriptor = ApplicationLoader.applicationContext.getResources().openRawResourceFd(R.raw.sound_out);
-                        if (assetFileDescriptor != null) {
-                            mediaPlayerOut = new MediaPlayer();
-                            mediaPlayerOut.setAudioStreamType(AudioManager.STREAM_SYSTEM);
-                            mediaPlayerOut.setDataSource(assetFileDescriptor.getFileDescriptor(), assetFileDescriptor.getStartOffset(), assetFileDescriptor.getLength());
-                            mediaPlayerOut.setLooping(false);
-                            assetFileDescriptor.close();
-                            mediaPlayerOut.prepare();
-                        }
-                    }
-                    try {
-                        mediaPlayerOut.pause();
-                        mediaPlayerOut.seekTo(0);
-                    } catch (Exception e) {
-                        FileLog.e("tmessages", e);
-                    }
-                    mediaPlayerOut.start();*/
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
                 }
@@ -1109,13 +1185,9 @@ public void processDialogsUpdateRead(final HashMap<Long, Integer> dialogsToUpdat
                 delayedPushMessages.clear();
                 showOrUpdateNotification(notifyCheck);
             } else {
-                showOrUpdateNotification(false);
                 scheduleNotificationDelay(lastOnlineFromOtherDevice > ConnectionsManager.getInstance().getCurrentTime());
             }
         }
-        /*if (old_unread_count != total_unread_count) {
-            showOrUpdateNotification(notifyCheck);
-        }*/
         notifyCheck = false;
         if (preferences.getBoolean("badgeNumber", true)) {
             setBadge(ApplicationLoader.applicationContext, total_unread_count);
@@ -1217,15 +1289,24 @@ public void run() {
                      //ignore
                 }
                 try {
-                    String launcherClassName = getLauncherClassName(context);
+                    launcherClassName = getLauncherClassName(context);
                     if (launcherClassName == null) {
                         return;
                     }
-                    Intent intent = new Intent("android.intent.action.BADGE_COUNT_UPDATE");
-                    intent.putExtra("badge_count", count);
-                    intent.putExtra("badge_count_package_name", context.getPackageName());
-                    intent.putExtra("badge_count_class_name", launcherClassName);
-                    context.sendBroadcast(intent);
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            try {
+                                Intent intent = new Intent("android.intent.action.BADGE_COUNT_UPDATE");
+                                intent.putExtra("badge_count", count);
+                                intent.putExtra("badge_count_package_name", context.getPackageName());
+                                intent.putExtra("badge_count_class_name", launcherClassName);
+                                context.sendBroadcast(intent);
+                            } catch (Exception e) {
+                                FileLog.e("tmessages", e);
+                            }
+                        }
+                    });
                 } catch (Throwable e) {
                     FileLog.e("tmessages", e);
                 }
diff --git a/TMessagesProj/src/main/java/org/telegram/android/ScreenReceiver.java b/TMessagesProj/src/main/java/org/telegram/android/ScreenReceiver.java
index d7824f18b..90c1e2bf1 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/ScreenReceiver.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/ScreenReceiver.java
@@ -17,6 +17,7 @@
 import org.telegram.messenger.ApplicationLoader;
 
 public class ScreenReceiver extends BroadcastReceiver {
+
     @Override
     public void onReceive(Context context, Intent intent) {
         if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {
diff --git a/TMessagesProj/src/main/java/org/telegram/android/SecretChatHelper.java b/TMessagesProj/src/main/java/org/telegram/android/SecretChatHelper.java
index 2866763ac..5d793ea3d 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/SecretChatHelper.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/SecretChatHelper.java
@@ -48,6 +48,7 @@
     private boolean startingSecretChat = false;
 
     private static volatile SecretChatHelper Instance = null;
+
     public static SecretChatHelper getInstance() {
         SecretChatHelper localInstance = Instance;
         if (localInstance == null) {
@@ -87,7 +88,7 @@ protected void processPendingEncMessages() {
         newMsg.local_id = newMsg.id = UserConfig.getNewMessageId();
         newMsg.from_id = UserConfig.getClientUserId();
         newMsg.flags = TLRPC.MESSAGE_FLAG_UNREAD | TLRPC.MESSAGE_FLAG_OUT;
-        newMsg.dialog_id = ((long)encryptedChat.id) << 32;
+        newMsg.dialog_id = ((long) encryptedChat.id) << 32;
         newMsg.to_id = new TLRPC.TL_peerUser();
         newMsg.send_state = MessageObject.MESSAGE_SEND_STATE_SENDING;
         if (encryptedChat.participant_id == UserConfig.getClientUserId()) {
@@ -114,7 +115,7 @@ public void sendMessagesReadMessage(TLRPC.EncryptedChat encryptedChat, ArrayList
         if (!(encryptedChat instanceof TLRPC.TL_encryptedChat)) {
             return;
         }
-        TLRPC.TL_decryptedMessageService reqSend = null;
+        TLRPC.TL_decryptedMessageService reqSend;
         if (AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
             reqSend = new TLRPC.TL_decryptedMessageService();
         } else {
@@ -123,7 +124,7 @@ public void sendMessagesReadMessage(TLRPC.EncryptedChat encryptedChat, ArrayList
             Utilities.random.nextBytes(reqSend.random_bytes);
         }
 
-        TLRPC.Message message = null;
+        TLRPC.Message message;
 
         if (resendMessage != null) {
             message = resendMessage;
@@ -140,7 +141,7 @@ public void sendMessagesReadMessage(TLRPC.EncryptedChat encryptedChat, ArrayList
 
     protected void processUpdateEncryption(TLRPC.TL_updateEncryption update, ConcurrentHashMap<Integer, TLRPC.User> usersDict) {
         final TLRPC.EncryptedChat newChat = update.chat;
-        long dialog_id = ((long)newChat.id) << 32;
+        long dialog_id = ((long) newChat.id) << 32;
         TLRPC.EncryptedChat existingChat = MessagesController.getInstance().getEncryptedChatDB(newChat.id);
 
         if (newChat instanceof TLRPC.TL_encryptedChatRequested && existingChat == null) {
@@ -219,7 +220,7 @@ public void sendMessagesDeleteMessage(TLRPC.EncryptedChat encryptedChat, ArrayLi
         if (!(encryptedChat instanceof TLRPC.TL_encryptedChat)) {
             return;
         }
-        TLRPC.TL_decryptedMessageService reqSend = null;
+        TLRPC.TL_decryptedMessageService reqSend;
         if (AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
             reqSend = new TLRPC.TL_decryptedMessageService();
         } else {
@@ -228,7 +229,7 @@ public void sendMessagesDeleteMessage(TLRPC.EncryptedChat encryptedChat, ArrayLi
             Utilities.random.nextBytes(reqSend.random_bytes);
         }
 
-        TLRPC.Message message = null;
+        TLRPC.Message message;
 
         if (resendMessage != null) {
             message = resendMessage;
@@ -247,7 +248,7 @@ public void sendClearHistoryMessage(TLRPC.EncryptedChat encryptedChat, TLRPC.Mes
         if (!(encryptedChat instanceof TLRPC.TL_encryptedChat)) {
             return;
         }
-        TLRPC.TL_decryptedMessageService reqSend = null;
+        TLRPC.TL_decryptedMessageService reqSend;
         if (AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
             reqSend = new TLRPC.TL_decryptedMessageService();
         } else {
@@ -256,7 +257,7 @@ public void sendClearHistoryMessage(TLRPC.EncryptedChat encryptedChat, TLRPC.Mes
             Utilities.random.nextBytes(reqSend.random_bytes);
         }
 
-        TLRPC.Message message = null;
+        TLRPC.Message message;
 
         if (resendMessage != null) {
             message = resendMessage;
@@ -278,7 +279,7 @@ public void sendNotifyLayerMessage(final TLRPC.EncryptedChat encryptedChat, TLRP
             return;
         }
         sendingNotifyLayer.add(encryptedChat.id);
-        TLRPC.TL_decryptedMessageService reqSend = null;
+        TLRPC.TL_decryptedMessageService reqSend;
         if (AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
             reqSend = new TLRPC.TL_decryptedMessageService();
         } else {
@@ -287,7 +288,7 @@ public void sendNotifyLayerMessage(final TLRPC.EncryptedChat encryptedChat, TLRP
             Utilities.random.nextBytes(reqSend.random_bytes);
         }
 
-        TLRPC.Message message = null;
+        TLRPC.Message message;
 
         if (resendMessage != null) {
             message = resendMessage;
@@ -307,7 +308,7 @@ public void sendRequestKeyMessage(final TLRPC.EncryptedChat encryptedChat, TLRPC
             return;
         }
 
-        TLRPC.TL_decryptedMessageService reqSend = null;
+        TLRPC.TL_decryptedMessageService reqSend;
         if (AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
             reqSend = new TLRPC.TL_decryptedMessageService();
         } else {
@@ -316,7 +317,7 @@ public void sendRequestKeyMessage(final TLRPC.EncryptedChat encryptedChat, TLRPC
             Utilities.random.nextBytes(reqSend.random_bytes);
         }
 
-        TLRPC.Message message = null;
+        TLRPC.Message message;
 
         if (resendMessage != null) {
             message = resendMessage;
@@ -338,7 +339,7 @@ public void sendAcceptKeyMessage(final TLRPC.EncryptedChat encryptedChat, TLRPC.
             return;
         }
 
-        TLRPC.TL_decryptedMessageService reqSend = null;
+        TLRPC.TL_decryptedMessageService reqSend;
         if (AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
             reqSend = new TLRPC.TL_decryptedMessageService();
         } else {
@@ -347,7 +348,7 @@ public void sendAcceptKeyMessage(final TLRPC.EncryptedChat encryptedChat, TLRPC.
             Utilities.random.nextBytes(reqSend.random_bytes);
         }
 
-        TLRPC.Message message = null;
+        TLRPC.Message message;
 
         if (resendMessage != null) {
             message = resendMessage;
@@ -370,7 +371,7 @@ public void sendCommitKeyMessage(final TLRPC.EncryptedChat encryptedChat, TLRPC.
             return;
         }
 
-        TLRPC.TL_decryptedMessageService reqSend = null;
+        TLRPC.TL_decryptedMessageService reqSend;
         if (AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
             reqSend = new TLRPC.TL_decryptedMessageService();
         } else {
@@ -379,7 +380,7 @@ public void sendCommitKeyMessage(final TLRPC.EncryptedChat encryptedChat, TLRPC.
             Utilities.random.nextBytes(reqSend.random_bytes);
         }
 
-        TLRPC.Message message = null;
+        TLRPC.Message message;
 
         if (resendMessage != null) {
             message = resendMessage;
@@ -401,7 +402,7 @@ public void sendAbortKeyMessage(final TLRPC.EncryptedChat encryptedChat, TLRPC.M
             return;
         }
 
-        TLRPC.TL_decryptedMessageService reqSend = null;
+        TLRPC.TL_decryptedMessageService reqSend;
         if (AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
             reqSend = new TLRPC.TL_decryptedMessageService();
         } else {
@@ -410,7 +411,7 @@ public void sendAbortKeyMessage(final TLRPC.EncryptedChat encryptedChat, TLRPC.M
             Utilities.random.nextBytes(reqSend.random_bytes);
         }
 
-        TLRPC.Message message = null;
+        TLRPC.Message message;
 
         if (resendMessage != null) {
             message = resendMessage;
@@ -431,7 +432,7 @@ public void sendNoopMessage(final TLRPC.EncryptedChat encryptedChat, TLRPC.Messa
             return;
         }
 
-        TLRPC.TL_decryptedMessageService reqSend = null;
+        TLRPC.TL_decryptedMessageService reqSend;
         if (AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
             reqSend = new TLRPC.TL_decryptedMessageService();
         } else {
@@ -440,7 +441,7 @@ public void sendNoopMessage(final TLRPC.EncryptedChat encryptedChat, TLRPC.Messa
             Utilities.random.nextBytes(reqSend.random_bytes);
         }
 
-        TLRPC.Message message = null;
+        TLRPC.Message message;
 
         if (resendMessage != null) {
             message = resendMessage;
@@ -459,7 +460,7 @@ public void sendTTLMessage(TLRPC.EncryptedChat encryptedChat, TLRPC.Message rese
             return;
         }
 
-        TLRPC.TL_decryptedMessageService reqSend = null;
+        TLRPC.TL_decryptedMessageService reqSend;
         if (AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
             reqSend = new TLRPC.TL_decryptedMessageService();
         } else {
@@ -468,7 +469,7 @@ public void sendTTLMessage(TLRPC.EncryptedChat encryptedChat, TLRPC.Message rese
             Utilities.random.nextBytes(reqSend.random_bytes);
         }
 
-        TLRPC.Message message = null;
+        TLRPC.Message message;
 
         if (resendMessage != null) {
             message = resendMessage;
@@ -495,7 +496,7 @@ public void sendScreenshotMessage(TLRPC.EncryptedChat encryptedChat, ArrayList<L
             return;
         }
 
-        TLRPC.TL_decryptedMessageService reqSend = null;
+        TLRPC.TL_decryptedMessageService reqSend;
         if (AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
             reqSend = new TLRPC.TL_decryptedMessageService();
         } else {
@@ -504,7 +505,7 @@ public void sendScreenshotMessage(TLRPC.EncryptedChat encryptedChat, ArrayList<L
             Utilities.random.nextBytes(reqSend.random_bytes);
         }
 
-        TLRPC.Message message = null;
+        TLRPC.Message message;
 
         if (resendMessage != null) {
             message = resendMessage;
@@ -654,7 +655,7 @@ protected void performSendEncryptedRequest(final TLRPC.DecryptedMessage req, fin
         Utilities.stageQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
-                TLObject toEncryptObject = null;
+                TLObject toEncryptObject;
                 if (AndroidUtilities.getPeerLayerVersion(chat.layer) >= 17) {
                     TLRPC.TL_decryptedMessageLayer layer = new TLRPC.TL_decryptedMessageLayer();
                     int myLayer = Math.max(17, AndroidUtilities.getMyLayerVersion(chat.layer));
@@ -710,7 +711,7 @@ public void run() {
                 byte[] messageKey = new byte[16];
                 System.arraycopy(messageKeyFull, messageKeyFull.length - 16, messageKey, 0, 16);
 
-                MessageKeyData keyData = Utilities.generateMessageKeyData(chat.auth_key, messageKey, false);
+                MessageKeyData keyData = MessageKeyData.generateMessageKeyData(chat.auth_key, messageKey, false);
 
                 len = toEncrypt.length();
                 int extraLen = len % 16 != 0 ? 16 - len % 16 : 0;
@@ -734,7 +735,7 @@ public void run() {
                 BuffersStorage.getInstance().reuseFreeBuffer(dataForEncryption);
                 data.position(0);
 
-                TLObject reqToSend = null;
+                TLObject reqToSend;
 
                 if (encryptedFile == null) {
                     if (req instanceof TLRPC.TL_decryptedMessageService) {
@@ -770,7 +771,7 @@ public void run(TLObject response, TLRPC.TL_error error) {
                         if (error == null) {
                             if (req.action instanceof TLRPC.TL_decryptedMessageActionNotifyLayer) {
                                 TLRPC.EncryptedChat currentChat = MessagesController.getInstance().getEncryptedChat(chat.id);
-                                sendingNotifyLayer.remove((Integer)currentChat.id);
+                                sendingNotifyLayer.remove((Integer) currentChat.id);
                                 currentChat.layer = AndroidUtilities.setMyLayerVersion(currentChat.layer, CURRENT_SECRET_CHAT_LAYER);
                                 MessagesStorage.getInstance().updateEncryptedChatLayer(currentChat);
                             }
@@ -857,8 +858,8 @@ public void run() {
             }
 
             if (object instanceof TLRPC.TL_decryptedMessage) {
-                TLRPC.TL_decryptedMessage decryptedMessage = (TLRPC.TL_decryptedMessage)object;
-                TLRPC.TL_message newMessage = null;
+                TLRPC.TL_decryptedMessage decryptedMessage = (TLRPC.TL_decryptedMessage) object;
+                TLRPC.TL_message newMessage;
                 if (AndroidUtilities.getPeerLayerVersion(chat.layer) >= 17) {
                     newMessage = new TLRPC.TL_message_secret();
                     newMessage.ttl = decryptedMessage.ttl;
@@ -875,7 +876,7 @@ public void run() {
                 newMessage.random_id = random_id;
                 newMessage.to_id.user_id = UserConfig.getClientUserId();
                 newMessage.flags = TLRPC.MESSAGE_FLAG_UNREAD;
-                newMessage.dialog_id = ((long)chat.id) << 32;
+                newMessage.dialog_id = ((long) chat.id) << 32;
                 if (decryptedMessage.media instanceof TLRPC.TL_decryptedMessageMediaEmpty) {
                     newMessage.media = new TLRPC.TL_messageMediaEmpty();
                 } else if (decryptedMessage.media instanceof TLRPC.TL_decryptedMessageMediaContact) {
@@ -899,11 +900,12 @@ public void run() {
                     newMessage.media.photo.user_id = newMessage.from_id;
                     newMessage.media.photo.date = newMessage.date;
                     newMessage.media.photo.geo = new TLRPC.TL_geoPointEmpty();
-                    if (decryptedMessage.media.thumb.length != 0 && decryptedMessage.media.thumb.length <= 6000 && decryptedMessage.media.thumb_w <= 100 && decryptedMessage.media.thumb_h <= 100) {
+                    byte[] thumb = ((TLRPC.TL_decryptedMessageMediaPhoto) decryptedMessage.media).thumb;
+                    if (thumb != null && thumb.length != 0 && thumb.length <= 6000 && decryptedMessage.media.thumb_w <= 100 && decryptedMessage.media.thumb_h <= 100) {
                         TLRPC.TL_photoCachedSize small = new TLRPC.TL_photoCachedSize();
                         small.w = decryptedMessage.media.thumb_w;
                         small.h = decryptedMessage.media.thumb_h;
-                        small.bytes = decryptedMessage.media.thumb;
+                        small.bytes = thumb;
                         small.type = "s";
                         small.location = new TLRPC.TL_fileLocationUnavailable();
                         newMessage.media.photo.sizes.add(small);
@@ -929,9 +931,10 @@ public void run() {
                     newMessage.media = new TLRPC.TL_messageMediaVideo();
                     newMessage.media.caption = "";
                     newMessage.media.video = new TLRPC.TL_videoEncrypted();
-                    if (decryptedMessage.media.thumb.length != 0 && decryptedMessage.media.thumb.length <= 6000 && decryptedMessage.media.thumb_w <= 100 && decryptedMessage.media.thumb_h <= 100) {
+                    byte[] thumb = ((TLRPC.TL_decryptedMessageMediaVideo) decryptedMessage.media).thumb;
+                    if (thumb != null && thumb.length != 0 && thumb.length <= 6000 && decryptedMessage.media.thumb_w <= 100 && decryptedMessage.media.thumb_h <= 100) {
                         newMessage.media.video.thumb = new TLRPC.TL_photoCachedSize();
-                        newMessage.media.video.thumb.bytes = decryptedMessage.media.thumb;
+                        newMessage.media.video.thumb.bytes = thumb;
                         newMessage.media.video.thumb.w = decryptedMessage.media.thumb_w;
                         newMessage.media.video.thumb.h = decryptedMessage.media.thumb_h;
                         newMessage.media.video.thumb.type = "s";
@@ -975,9 +978,10 @@ public void run() {
                     newMessage.media.document.size = file.size;
                     newMessage.media.document.key = decryptedMessage.media.key;
                     newMessage.media.document.iv = decryptedMessage.media.iv;
-                    if (decryptedMessage.media.thumb.length != 0 && decryptedMessage.media.thumb.length <= 6000 && decryptedMessage.media.thumb_w <= 100 && decryptedMessage.media.thumb_h <= 100) {
+                    byte[] thumb = ((TLRPC.TL_decryptedMessageMediaDocument) decryptedMessage.media).thumb;
+                    if (thumb != null && thumb.length != 0 && thumb.length <= 6000 && decryptedMessage.media.thumb_w <= 100 && decryptedMessage.media.thumb_h <= 100) {
                         newMessage.media.document.thumb = new TLRPC.TL_photoCachedSize();
-                        newMessage.media.document.thumb.bytes = decryptedMessage.media.thumb;
+                        newMessage.media.document.thumb.bytes = thumb;
                         newMessage.media.document.thumb.w = decryptedMessage.media.thumb_w;
                         newMessage.media.document.thumb.h = decryptedMessage.media.thumb_h;
                         newMessage.media.document.thumb.type = "s";
@@ -997,7 +1001,7 @@ public void run() {
                     newMessage.media.document.mime_type = decryptedMessage.media.mime_type;
                     newMessage.media.document.dc_id = decryptedMessage.media.dc_id;
                     newMessage.media.document.size = decryptedMessage.media.size;
-                    newMessage.media.document.thumb = decryptedMessage.media.thumbImage;
+                    newMessage.media.document.thumb = ((TLRPC.TL_decryptedMessageMediaExternalDocument) decryptedMessage.media).thumb;
                 } else if (decryptedMessage.media instanceof TLRPC.TL_decryptedMessageMediaAudio) {
                     if (decryptedMessage.media.key == null || decryptedMessage.media.key.length != 32 || decryptedMessage.media.iv == null || decryptedMessage.media.iv.length != 32) {
                         return null;
@@ -1025,7 +1029,7 @@ public void run() {
                 }
                 return newMessage;
             } else if (object instanceof TLRPC.TL_decryptedMessageService) {
-                final TLRPC.TL_decryptedMessageService serviceMessage = (TLRPC.TL_decryptedMessageService)object;
+                final TLRPC.TL_decryptedMessageService serviceMessage = (TLRPC.TL_decryptedMessageService) object;
                 if (serviceMessage.action instanceof TLRPC.TL_decryptedMessageActionSetMessageTTL || serviceMessage.action instanceof TLRPC.TL_decryptedMessageActionScreenshotMessages) {
                     TLRPC.TL_messageService newMessage = new TLRPC.TL_messageService();
                     if (serviceMessage.action instanceof TLRPC.TL_decryptedMessageActionSetMessageTTL) {
@@ -1047,10 +1051,10 @@ public void run() {
                     newMessage.from_id = from_id;
                     newMessage.to_id = new TLRPC.TL_peerUser();
                     newMessage.to_id.user_id = UserConfig.getClientUserId();
-                    newMessage.dialog_id = ((long)chat.id) << 32;
+                    newMessage.dialog_id = ((long) chat.id) << 32;
                     return newMessage;
                 } else if (serviceMessage.action instanceof TLRPC.TL_decryptedMessageActionFlushHistory) {
-                    final long did = ((long)chat.id) << 32;
+                    final long did = ((long) chat.id) << 32;
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
                         public void run() {
@@ -1314,7 +1318,7 @@ public int compare(TLRPC.TL_decryptedMessageHolder lhs, TLRPC.TL_decryptedMessag
 
         if (keyToDecrypt != null) {
             byte[] messageKey = is.readData(16, false);
-            MessageKeyData keyData = Utilities.generateMessageKeyData(keyToDecrypt, messageKey, false);
+            MessageKeyData keyData = MessageKeyData.generateMessageKeyData(keyToDecrypt, messageKey, false);
 
             Utilities.aesIgeEncryption(is.buffer, keyData.aesKey, keyData.aesIv, false, false, 24, is.limit() - 24);
 
@@ -1327,19 +1331,14 @@ public int compare(TLRPC.TL_decryptedMessageHolder lhs, TLRPC.TL_decryptedMessag
                 return null;
             }
 
-            TLObject object = null;
-            try {
-                object = TLClassStore.Instance().TLdeserialize(is, is.readInt32(true), true);
-            } catch (Exception e) {
-                FileLog.e("tmessages", e);
-            }
+            TLObject object = TLClassStore.Instance().TLdeserialize(is, is.readInt32(false), false);
 
             BuffersStorage.getInstance().reuseFreeBuffer(is);
             if (!new_key_used && AndroidUtilities.getPeerLayerVersion(chat.layer) >= 20) {
                 chat.key_use_count_in++;
             }
             if (object instanceof TLRPC.TL_decryptedMessageLayer) {
-                final TLRPC.TL_decryptedMessageLayer layer = (TLRPC.TL_decryptedMessageLayer)object;
+                final TLRPC.TL_decryptedMessageLayer layer = (TLRPC.TL_decryptedMessageLayer) object;
                 if (chat.seq_in == 0 && chat.seq_out == 0) {
                     if (chat.admin_id == UserConfig.getClientUserId()) {
                         chat.seq_out = 1;
diff --git a/TMessagesProj/src/main/java/org/telegram/android/SendMessagesHelper.java b/TMessagesProj/src/main/java/org/telegram/android/SendMessagesHelper.java
index 8cef20598..3aa324556 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/SendMessagesHelper.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/SendMessagesHelper.java
@@ -56,9 +56,11 @@
         public String httpLocation;
         public MessageObject obj;
         public TLRPC.EncryptedChat encryptedChat;
+        public VideoEditedInfo videoEditedInfo;
     }
 
     private static volatile SendMessagesHelper Instance = null;
+
     public static SendMessagesHelper getInstance() {
         SendMessagesHelper localInstance = Instance;
         if (localInstance == null) {
@@ -94,113 +96,100 @@ public void setCurrentChatInfo(TLRPC.ChatParticipants info) {
     }
 
     @Override
-    public void didReceivedNotification(int id, Object... args) {
+    public void didReceivedNotification(int id, final Object... args) {
         if (id == NotificationCenter.FileDidUpload) {
-            final String location = (String)args[0];
-            final TLRPC.InputFile file = (TLRPC.InputFile)args[1];
-            final TLRPC.InputEncryptedFile encryptedFile = (TLRPC.InputEncryptedFile)args[2];
-
-            AndroidUtilities.runOnUIThread(new Runnable() {
-                @Override
-                public void run() {
-                    ArrayList<DelayedMessage> arr = delayedMessages.get(location);
-                    if (arr != null) {
-                        for (int a = 0; a < arr.size(); a++) {
-                            DelayedMessage message = arr.get(a);
-                            TLRPC.InputMedia media = null;
-                            if (message.sendRequest instanceof TLRPC.TL_messages_sendMedia) {
-                                media = ((TLRPC.TL_messages_sendMedia)message.sendRequest).media;
-                            } else if (message.sendRequest instanceof TLRPC.TL_messages_sendBroadcast) {
-                                media = ((TLRPC.TL_messages_sendBroadcast)message.sendRequest).media;
-                            }
+            final String location = (String) args[0];
+            final TLRPC.InputFile file = (TLRPC.InputFile) args[1];
+            final TLRPC.InputEncryptedFile encryptedFile = (TLRPC.InputEncryptedFile) args[2];
+            ArrayList<DelayedMessage> arr = delayedMessages.get(location);
+            if (arr != null) {
+                for (int a = 0; a < arr.size(); a++) {
+                    DelayedMessage message = arr.get(a);
+                    TLRPC.InputMedia media = null;
+                    if (message.sendRequest instanceof TLRPC.TL_messages_sendMedia) {
+                        media = ((TLRPC.TL_messages_sendMedia) message.sendRequest).media;
+                    } else if (message.sendRequest instanceof TLRPC.TL_messages_sendBroadcast) {
+                        media = ((TLRPC.TL_messages_sendBroadcast) message.sendRequest).media;
+                    }
 
-                            if (file != null && media != null) {
-                                if (message.type == 0) {
-                                    media.file = file;
+                    if (file != null && media != null) {
+                        if (message.type == 0) {
+                            media.file = file;
+                            performSendMessageRequest(message.sendRequest, message.obj.messageOwner, message.originalPath);
+                        } else if (message.type == 1) {
+                            if (media.file == null) {
+                                media.file = file;
+                                if (media.thumb == null && message.location != null) {
+                                    performSendDelayedMessage(message);
+                                } else {
                                     performSendMessageRequest(message.sendRequest, message.obj.messageOwner, message.originalPath);
-                                } else if (message.type == 1) {
-                                    if (media.file == null) {
-                                        media.file = file;
-                                        if (media.thumb == null && message.location != null) {
-                                            performSendDelayedMessage(message);
-                                        } else {
-                                            performSendMessageRequest(message.sendRequest, message.obj.messageOwner, message.originalPath);
-                                        }
-                                    } else {
-                                        media.thumb = file;
-                                        performSendMessageRequest(message.sendRequest, message.obj.messageOwner, message.originalPath);
-                                    }
-                                } else if (message.type == 2) {
-                                    if (media.file == null) {
-                                        media.file = file;
-                                        if (media.thumb == null && message.location != null) {
-                                            performSendDelayedMessage(message);
-                                        } else {
-                                            performSendMessageRequest(message.sendRequest, message.obj.messageOwner, message.originalPath);
-                                        }
-                                    } else {
-                                        media.thumb = file;
-                                        performSendMessageRequest(message.sendRequest, message.obj.messageOwner, message.originalPath);
-                                    }
-                                } else if (message.type == 3) {
-                                    media.file = file;
+                                }
+                            } else {
+                                media.thumb = file;
+                                performSendMessageRequest(message.sendRequest, message.obj.messageOwner, message.originalPath);
+                            }
+                        } else if (message.type == 2) {
+                            if (media.file == null) {
+                                media.file = file;
+                                if (media.thumb == null && message.location != null) {
+                                    performSendDelayedMessage(message);
+                                } else {
                                     performSendMessageRequest(message.sendRequest, message.obj.messageOwner, message.originalPath);
                                 }
-                                arr.remove(a);
-                                a--;
-                            } else if (encryptedFile != null && message.sendEncryptedRequest != null) {
-                                message.sendEncryptedRequest.media.key = encryptedFile.key;
-                                message.sendEncryptedRequest.media.iv = encryptedFile.iv;
-                                SecretChatHelper.getInstance().performSendEncryptedRequest(message.sendEncryptedRequest, message.obj.messageOwner, message.encryptedChat, encryptedFile, message.originalPath);
-                                arr.remove(a);
-                                a--;
+                            } else {
+                                media.thumb = file;
+                                performSendMessageRequest(message.sendRequest, message.obj.messageOwner, message.originalPath);
                             }
+                        } else if (message.type == 3) {
+                            media.file = file;
+                            performSendMessageRequest(message.sendRequest, message.obj.messageOwner, message.originalPath);
                         }
-                        if (arr.isEmpty()) {
-                            delayedMessages.remove(location);
-                        }
+                        arr.remove(a);
+                        a--;
+                    } else if (encryptedFile != null && message.sendEncryptedRequest != null) {
+                        message.sendEncryptedRequest.media.key = (byte[]) args[3];
+                        message.sendEncryptedRequest.media.iv = (byte[]) args[4];
+                        SecretChatHelper.getInstance().performSendEncryptedRequest(message.sendEncryptedRequest, message.obj.messageOwner, message.encryptedChat, encryptedFile, message.originalPath);
+                        arr.remove(a);
+                        a--;
                     }
                 }
-            });
+                if (arr.isEmpty()) {
+                    delayedMessages.remove(location);
+                }
+            }
         } else if (id == NotificationCenter.FileDidFailUpload) {
             final String location = (String) args[0];
             final boolean enc = (Boolean) args[1];
-
-            AndroidUtilities.runOnUIThread(new Runnable() {
-                @Override
-                public void run() {
-                    ArrayList<DelayedMessage> arr = delayedMessages.get(location);
-                    if (arr != null) {
-                        for (int a = 0; a < arr.size(); a++) {
-                            DelayedMessage obj = arr.get(a);
-                            if (enc && obj.sendEncryptedRequest != null || !enc && obj.sendRequest != null) {
-                                MessagesStorage.getInstance().markMessageAsSendError(obj.obj.getId());
-                                obj.obj.messageOwner.send_state = MessageObject.MESSAGE_SEND_STATE_SEND_ERROR;
-                                arr.remove(a);
-                                a--;
-                                NotificationCenter.getInstance().postNotificationName(NotificationCenter.messageSendError, obj.obj.getId());
-                                processSentMessage(obj.obj.getId());
-                            }
-                        }
-                        if (arr.isEmpty()) {
-                            delayedMessages.remove(location);
-                        }
+            ArrayList<DelayedMessage> arr = delayedMessages.get(location);
+            if (arr != null) {
+                for (int a = 0; a < arr.size(); a++) {
+                    DelayedMessage obj = arr.get(a);
+                    if (enc && obj.sendEncryptedRequest != null || !enc && obj.sendRequest != null) {
+                        MessagesStorage.getInstance().markMessageAsSendError(obj.obj.getId());
+                        obj.obj.messageOwner.send_state = MessageObject.MESSAGE_SEND_STATE_SEND_ERROR;
+                        arr.remove(a);
+                        a--;
+                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.messageSendError, obj.obj.getId());
+                        processSentMessage(obj.obj.getId());
                     }
                 }
-            });
+                if (arr.isEmpty()) {
+                    delayedMessages.remove(location);
+                }
+            }
         } else if (id == NotificationCenter.FilePreparingStarted) {
-            MessageObject messageObject = (MessageObject)args[0];
-            String finalPath = (String)args[1];
+            MessageObject messageObject = (MessageObject) args[0];
+            String finalPath = (String) args[1];
 
             ArrayList<DelayedMessage> arr = delayedMessages.get(messageObject.messageOwner.attachPath);
             if (arr != null) {
                 for (int a = 0; a < arr.size(); a++) {
                     DelayedMessage message = arr.get(a);
                     if (message.obj == messageObject) {
-                        message.videoLocation.videoEditedInfo = null;
+                        message.videoEditedInfo = null;
                         performSendDelayedMessage(message);
                         arr.remove(a);
-                        a--;
                         break;
                     }
                 }
@@ -209,19 +198,19 @@ public void run() {
                 }
             }
         } else if (id == NotificationCenter.FileNewChunkAvailable) {
-            MessageObject messageObject = (MessageObject)args[0];
-            String finalPath = (String)args[1];
-            long finalSize = (Long)args[2];
-            boolean isEncrypted = ((int)messageObject.getDialogId()) == 0;
+            MessageObject messageObject = (MessageObject) args[0];
+            String finalPath = (String) args[1];
+            long finalSize = (Long) args[2];
+            boolean isEncrypted = ((int) messageObject.getDialogId()) == 0;
             FileLoader.getInstance().checkUploadNewDataAvailable(finalPath, isEncrypted, finalSize);
             if (finalSize != 0) {
                 ArrayList<DelayedMessage> arr = delayedMessages.get(messageObject.messageOwner.attachPath);
                 if (arr != null) {
                     for (DelayedMessage message : arr) {
                         if (message.obj == messageObject) {
-                            message.obj.messageOwner.videoEditedInfo = null;
+                            message.obj.videoEditedInfo = null;
                             message.obj.messageOwner.message = "-1";
-                            message.obj.messageOwner.media.video.size = (int)finalSize;
+                            message.obj.messageOwner.media.video.size = (int) finalSize;
 
                             ArrayList<TLRPC.Message> messages = new ArrayList<>();
                             messages.add(message.obj.messageOwner);
@@ -235,8 +224,8 @@ public void run() {
                 }
             }
         } else if (id == NotificationCenter.FilePreparingFailed) {
-            MessageObject messageObject = (MessageObject)args[0];
-            String finalPath = (String)args[1];
+            MessageObject messageObject = (MessageObject) args[0];
+            String finalPath = (String) args[1];
             stopVideoService(messageObject.messageOwner.attachPath);
 
             ArrayList<DelayedMessage> arr = delayedMessages.get(finalPath);
@@ -257,8 +246,8 @@ public void run() {
                 }
             }
         } else if (id == NotificationCenter.httpFileDidLoaded) {
-            String path = (String)args[0];
-            String file = (String)args[1];
+            String path = (String) args[0];
+            String file = (String) args[1];
             ArrayList<DelayedMessage> arr = delayedMessages.get(path);
             if (arr != null) {
                 for (final DelayedMessage message : arr) {
@@ -334,7 +323,7 @@ public void run() {
                 delayedMessages.remove(path);
             }
         } else if (id == NotificationCenter.httpFileDidFailedLoad) {
-            String path = (String)args[0];
+            String path = (String) args[0];
 
             ArrayList<DelayedMessage> arr = delayedMessages.get(path);
             if (arr != null) {
@@ -454,8 +443,7 @@ public void processForwardFromMyName(MessageObject messageObject, long did) {
                 sendMessage((TLRPC.TL_audio) messageObject.messageOwner.media.audio, messageObject.messageOwner.attachPath, did, messageObject.replyMessageObject);
             } else if (messageObject.messageOwner.media.video instanceof TLRPC.TL_video) {
                 TLRPC.TL_video video = (TLRPC.TL_video) messageObject.messageOwner.media.video;
-                video.videoEditedInfo = messageObject.messageOwner.videoEditedInfo;
-                sendMessage(video, null, messageObject.messageOwner.attachPath, did, messageObject.replyMessageObject);
+                sendMessage(video, messageObject.videoEditedInfo, null, messageObject.messageOwner.attachPath, did, messageObject.replyMessageObject);
             } else if (messageObject.messageOwner.media.document instanceof TLRPC.TL_document) {
                 sendMessage((TLRPC.TL_document) messageObject.messageOwner.media.document, null, messageObject.messageOwner.attachPath, did, messageObject.replyMessageObject);
             } else if (messageObject.messageOwner.media instanceof TLRPC.TL_messageMediaVenue || messageObject.messageOwner.media instanceof TLRPC.TL_messageMediaGeo) {
@@ -527,7 +515,7 @@ public void sendSticker(TLRPC.Document document, long peer, MessageObject replyi
     }
 
     public void sendMessage(TLRPC.User user, long peer, MessageObject reply_to_msg) {
-        sendMessage(null, null, null, null, null, user, null, null, null, peer, false, null, reply_to_msg, null, true);
+        sendMessage(null, null, null, null, null, null, user, null, null, null, peer, false, null, reply_to_msg, null, true);
     }
 
     public void sendMessage(ArrayList<MessageObject> messages, long peer) {
@@ -703,38 +691,38 @@ public void run() {
     }
 
     public void sendMessage(MessageObject message) {
-        sendMessage(null, null, null, null, message, null, null, null, null, message.getDialogId(), true, message.messageOwner.attachPath, null, null, true);
+        sendMessage(null, null, null, null, null, message, null, null, null, null, message.getDialogId(), true, message.messageOwner.attachPath, null, null, true);
     }
 
     public void sendMessage(MessageObject message, long peer) {
-        sendMessage(null, null, null, null, message, null, null, null, null, peer, false, message.messageOwner.attachPath, null, null, true);
+        sendMessage(null, null, null, null, null, message, null, null, null, null, peer, false, message.messageOwner.attachPath, null, null, true);
     }
 
     public void sendMessage(TLRPC.TL_document document, String originalPath, String path, long peer, MessageObject reply_to_msg) {
-        sendMessage(null, null, null, null, null, null, document, null, originalPath, peer, false, path, reply_to_msg, null, true);
+        sendMessage(null, null, null, null, null, null, null, document, null, originalPath, peer, false, path, reply_to_msg, null, true);
     }
 
     public void sendMessage(String message, long peer, MessageObject reply_to_msg, TLRPC.WebPage webPage, boolean searchLinks) {
-        sendMessage(message, null, null, null, null, null, null, null, null, peer, false, null, reply_to_msg, webPage, searchLinks);
+        sendMessage(message, null, null, null, null, null, null, null, null, null, peer, false, null, reply_to_msg, webPage, searchLinks);
     }
 
     public void sendMessage(TLRPC.MessageMedia location, long peer, MessageObject reply_to_msg) {
-        sendMessage(null, location, null, null, null, null, null, null, null, peer, false, null, reply_to_msg, null, true);
+        sendMessage(null, location, null, null, null, null, null, null, null, null, peer, false, null, reply_to_msg, null, true);
     }
 
     public void sendMessage(TLRPC.TL_photo photo, String originalPath, String path, long peer, MessageObject reply_to_msg) {
-        sendMessage(null, null, photo, null, null, null, null, null, originalPath, peer, false, path, reply_to_msg, null, true);
+        sendMessage(null, null, photo, null, null, null, null, null, null, originalPath, peer, false, path, reply_to_msg, null, true);
     }
 
-    public void sendMessage(TLRPC.TL_video video, String originalPath, String path, long peer, MessageObject reply_to_msg) {
-        sendMessage(null, null, null, video, null, null, null, null, originalPath, peer, false, path, reply_to_msg, null, true);
+    public void sendMessage(TLRPC.TL_video video, VideoEditedInfo videoEditedInfo, String originalPath, String path, long peer, MessageObject reply_to_msg) {
+        sendMessage(null, null, null, video, videoEditedInfo, null, null, null, null, originalPath, peer, false, path, reply_to_msg, null, true);
     }
 
     public void sendMessage(TLRPC.TL_audio audio, String path, long peer, MessageObject reply_to_msg) {
-        sendMessage(null, null, null, null, null, null, null, audio, null, peer, false, path, reply_to_msg, null, true);
+        sendMessage(null, null, null, null, null, null, null, null, audio, null, peer, false, path, reply_to_msg, null, true);
     }
 
-    private void sendMessage(String message, TLRPC.MessageMedia location, TLRPC.TL_photo photo, TLRPC.TL_video video, MessageObject msgObj, TLRPC.User user, TLRPC.TL_document document, TLRPC.TL_audio audio, String originalPath, long peer, boolean retry, String path, MessageObject reply_to_msg, TLRPC.WebPage webPage, boolean searchLinks) {
+    private void sendMessage(String message, TLRPC.MessageMedia location, TLRPC.TL_photo photo, TLRPC.TL_video video, VideoEditedInfo videoEditedInfo, MessageObject msgObj, TLRPC.User user, TLRPC.TL_document document, TLRPC.TL_audio audio, String originalPath, long peer, boolean retry, String path, MessageObject reply_to_msg, TLRPC.WebPage webPage, boolean searchLinks) {
         if (peer == 0) {
             return;
         }
@@ -776,7 +764,6 @@ private void sendMessage(String message, TLRPC.MessageMedia location, TLRPC.TL_p
                 } else {
                     type = 3;
                     video = (TLRPC.TL_video) newMsg.media.video;
-                    video.videoEditedInfo = newMsg.videoEditedInfo;
                 }
             } else if (msgObj.type == 12) {
                 user = new TLRPC.TL_userRequest();
@@ -842,12 +829,11 @@ private void sendMessage(String message, TLRPC.MessageMedia location, TLRPC.TL_p
                 newMsg.media = new TLRPC.TL_messageMediaVideo();
                 newMsg.media.caption = video.caption != null ? video.caption : "";
                 newMsg.media.video = video;
-                newMsg.videoEditedInfo = video.videoEditedInfo;
                 type = 3;
-                if (video.videoEditedInfo == null) {
+                if (videoEditedInfo == null) {
                     newMsg.message = "-1";
                 } else {
-                    newMsg.message = video.videoEditedInfo.getString();
+                    newMsg.message = videoEditedInfo.getString();
                 }
                 newMsg.attachPath = path;
             } else if (msgObj != null) {
@@ -1093,6 +1079,7 @@ private void sendMessage(String message, TLRPC.MessageMedia location, TLRPC.TL_p
                             delayedMessage.obj = newMsgObj;
                             delayedMessage.location = video.thumb.location;
                             delayedMessage.videoLocation = video;
+                            delayedMessage.videoEditedInfo = videoEditedInfo;
                         } else {
                             TLRPC.TL_inputMediaVideo media = new TLRPC.TL_inputMediaVideo();
                             media.id = new TLRPC.TL_inputVideo();
@@ -1149,7 +1136,7 @@ private void sendMessage(String message, TLRPC.MessageMedia location, TLRPC.TL_p
                         }
                     }
 
-                    TLObject reqSend = null;
+                    TLObject reqSend;
 
                     if (sendToPeers != null) {
                         TLRPC.TL_messages_sendBroadcast request = new TLRPC.TL_messages_sendBroadcast();
@@ -1229,7 +1216,12 @@ private void sendMessage(String message, TLRPC.MessageMedia location, TLRPC.TL_p
                         TLRPC.PhotoSize small = photo.sizes.get(0);
                         TLRPC.PhotoSize big = photo.sizes.get(photo.sizes.size() - 1);
                         reqSend.media = new TLRPC.TL_decryptedMessageMediaPhoto();
-                        reqSend.media.thumb = small.bytes;
+                        ImageLoader.fillPhotoSizeWithBytes(small);
+                        if (small.bytes != null) {
+                            ((TLRPC.TL_decryptedMessageMediaPhoto) reqSend.media).thumb = small.bytes;
+                        } else {
+                            ((TLRPC.TL_decryptedMessageMediaPhoto) reqSend.media).thumb = new byte[0];
+                        }
                         reqSend.media.thumb_h = small.h;
                         reqSend.media.thumb_w = small.w;
                         reqSend.media.w = big.w;
@@ -1257,16 +1249,26 @@ private void sendMessage(String message, TLRPC.MessageMedia location, TLRPC.TL_p
                             SecretChatHelper.getInstance().performSendEncryptedRequest(reqSend, newMsgObj.messageOwner, encryptedChat, encryptedFile, null);
                         }
                     } else if (type == 3) {
+                        ImageLoader.fillPhotoSizeWithBytes(video.thumb);
                         if (AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
                             reqSend.media = new TLRPC.TL_decryptedMessageMediaVideo();
+                            if (video.thumb != null && video.thumb.bytes != null) {
+                                ((TLRPC.TL_decryptedMessageMediaVideo) reqSend.media).thumb = video.thumb.bytes;
+                            } else {
+                                ((TLRPC.TL_decryptedMessageMediaVideo) reqSend.media).thumb = new byte[0];
+                            }
                         } else {
                             reqSend.media = new TLRPC.TL_decryptedMessageMediaVideo_old();
+                            if (video.thumb != null && video.thumb.bytes != null) {
+                                ((TLRPC.TL_decryptedMessageMediaVideo_old) reqSend.media).thumb = video.thumb.bytes;
+                            } else {
+                                ((TLRPC.TL_decryptedMessageMediaVideo_old) reqSend.media).thumb = new byte[0];
+                            }
                         }
                         reqSend.media.duration = video.duration;
                         reqSend.media.size = video.size;
                         reqSend.media.w = video.w;
                         reqSend.media.h = video.h;
-                        reqSend.media.thumb = video.thumb.bytes;
                         reqSend.media.thumb_h = video.thumb.h;
                         reqSend.media.thumb_w = video.thumb.w;
                         reqSend.media.mime_type = "video/mp4";
@@ -1278,6 +1280,7 @@ private void sendMessage(String message, TLRPC.MessageMedia location, TLRPC.TL_p
                             delayedMessage.obj = newMsgObj;
                             delayedMessage.encryptedChat = encryptedChat;
                             delayedMessage.videoLocation = video;
+                            delayedMessage.videoEditedInfo = videoEditedInfo;
                             performSendDelayedMessage(delayedMessage);
                         } else {
                             TLRPC.TL_inputEncryptedFile encryptedFile = new TLRPC.TL_inputEncryptedFile();
@@ -1305,21 +1308,27 @@ private void sendMessage(String message, TLRPC.MessageMedia location, TLRPC.TL_p
                             reqSend.media = new TLRPC.TL_decryptedMessageMediaExternalDocument();
                             reqSend.media.id = document.id;
                             reqSend.media.date = document.date;
+                            reqSend.media.access_hash = document.access_hash;
                             reqSend.media.mime_type = document.mime_type;
                             reqSend.media.size = document.size;
-                            ((TLRPC.TL_decryptedMessageMediaExternalDocument) reqSend.media).thumbImage = document.thumb;
                             reqSend.media.dc_id = document.dc_id;
                             reqSend.media.attributes = document.attributes;
+                            if (document.thumb == null) {
+                                ((TLRPC.TL_decryptedMessageMediaExternalDocument) reqSend.media).thumb = new TLRPC.TL_photoSizeEmpty();
+                            } else {
+                                ((TLRPC.TL_decryptedMessageMediaExternalDocument) reqSend.media).thumb = document.thumb;
+                            }
                             SecretChatHelper.getInstance().performSendEncryptedRequest(reqSend, newMsgObj.messageOwner, encryptedChat, null, null);
                         } else {
+                            ImageLoader.fillPhotoSizeWithBytes(document.thumb);
                             reqSend.media = new TLRPC.TL_decryptedMessageMediaDocument();
                             reqSend.media.size = document.size;
-                            if (!(document.thumb instanceof TLRPC.TL_photoSizeEmpty)) {
-                                reqSend.media.thumb = document.thumb.bytes;
+                            if (document.thumb != null && document.thumb.bytes != null) {
+                                ((TLRPC.TL_decryptedMessageMediaDocument) reqSend.media).thumb = document.thumb.bytes;
                                 reqSend.media.thumb_h = document.thumb.h;
                                 reqSend.media.thumb_w = document.thumb.w;
                             } else {
-                                reqSend.media.thumb = new byte[0];
+                                ((TLRPC.TL_decryptedMessageMediaDocument) reqSend.media).thumb = new byte[0];
                                 reqSend.media.thumb_h = 0;
                                 reqSend.media.thumb_w = 0;
                             }
@@ -1401,7 +1410,7 @@ private void performSendDelayedMessage(final DelayedMessage message) {
                 }
             }
         } else if (message.type == 1) {
-            if (message.videoLocation.videoEditedInfo != null) {
+            if (message.videoEditedInfo != null) {
                 String location = message.obj.messageOwner.attachPath;
                 if (location == null) {
                     location = FileLoader.getInstance().getDirectory(FileLoader.MEDIA_DIR_CACHE) + "/" + message.videoLocation.id + ".mp4";
@@ -1410,10 +1419,10 @@ private void performSendDelayedMessage(final DelayedMessage message) {
                 MediaController.getInstance().scheduleVideoConvert(message.obj);
             } else {
                 if (message.sendRequest != null) {
-                    TLRPC.InputMedia media = null;
+                    TLRPC.InputMedia media;
                     if (message.sendRequest instanceof TLRPC.TL_messages_sendMedia) {
                         media = ((TLRPC.TL_messages_sendMedia) message.sendRequest).media;
-                    } else if (message.sendRequest instanceof TLRPC.TL_messages_sendBroadcast) {
+                    } else {
                         media = ((TLRPC.TL_messages_sendBroadcast) message.sendRequest).media;
                     }
                     if (media.file == null) {
@@ -1422,7 +1431,7 @@ private void performSendDelayedMessage(final DelayedMessage message) {
                             location = FileLoader.getInstance().getDirectory(FileLoader.MEDIA_DIR_CACHE) + "/" + message.videoLocation.id + ".mp4";
                         }
                         putToDelayedMessages(location, message);
-                        if (message.obj.messageOwner.videoEditedInfo != null) {
+                        if (message.obj.videoEditedInfo != null) {
                             FileLoader.getInstance().uploadFile(location, false, false, message.videoLocation.size);
                         } else {
                             FileLoader.getInstance().uploadFile(location, false, false);
@@ -1438,7 +1447,7 @@ private void performSendDelayedMessage(final DelayedMessage message) {
                         location = FileLoader.getInstance().getDirectory(FileLoader.MEDIA_DIR_CACHE) + "/" + message.videoLocation.id + ".mp4";
                     }
                     putToDelayedMessages(location, message);
-                    if (message.obj.messageOwner.videoEditedInfo != null) {
+                    if (message.obj.videoEditedInfo != null) {
                         FileLoader.getInstance().uploadFile(location, true, false, message.videoLocation.size);
                     } else {
                         FileLoader.getInstance().uploadFile(location, true, false);
@@ -1451,10 +1460,10 @@ private void performSendDelayedMessage(final DelayedMessage message) {
                 ImageLoader.getInstance().loadHttpFile(message.httpLocation, "gif");
             } else {
                 if (message.sendRequest != null) {
-                    TLRPC.InputMedia media = null;
+                    TLRPC.InputMedia media;
                     if (message.sendRequest instanceof TLRPC.TL_messages_sendMedia) {
                         media = ((TLRPC.TL_messages_sendMedia) message.sendRequest).media;
-                    } else if (message.sendRequest instanceof TLRPC.TL_messages_sendBroadcast) {
+                    } else {
                         media = ((TLRPC.TL_messages_sendBroadcast) message.sendRequest).media;
                     }
                     if (media.file == null) {
@@ -1575,7 +1584,7 @@ public void run() {
                                                 ArrayList<MessageObject> arr = new ArrayList<>();
                                                 MessageObject messageObject = new MessageObject(message, null, false);
                                                 arr.add(messageObject);
-                                                MessagesController.getInstance().updateInterfaceWithMessages(messageObject.getDialogId(), arr, isBroadcast);
+                                                MessagesController.getInstance().updateInterfaceWithMessages(messageObject.getDialogId(), arr, true);
                                             }
                                             NotificationCenter.getInstance().postNotificationName(NotificationCenter.dialogsNeedReload);
                                         }
@@ -1632,18 +1641,21 @@ private void processSentMessage(TLRPC.Message newMsg, TLRPC.Message sentMessage,
             MessagesStorage.getInstance().putSentFile(originalPath, sentMessage.media.photo, 0);
 
             for (TLRPC.PhotoSize size : sentMessage.media.photo.sizes) {
-                if (size instanceof TLRPC.TL_photoSizeEmpty) {
+                if (size == null || size instanceof TLRPC.TL_photoSizeEmpty || size.type == null) {
                     continue;
                 }
                 for (TLRPC.PhotoSize size2 : newMsg.media.photo.sizes) {
-                    if (size2.location != null && size2.location.volume_id == Integer.MIN_VALUE && size.type.equals(size2.type) || size.w == size2.w && size.h == size2.h) {
+                    if (size2 == null || size2.location == null || size2.type == null) {
+                        continue;
+                    }
+                    if (size2.location.volume_id == Integer.MIN_VALUE && size.type.equals(size2.type) || size.w == size2.w && size.h == size2.h) {
                         String fileName = size2.location.volume_id + "_" + size2.location.local_id;
                         String fileName2 = size.location.volume_id + "_" + size.location.local_id;
                         if (fileName.equals(fileName2)) {
                             break;
                         }
                         File cacheFile = new File(FileLoader.getInstance().getDirectory(FileLoader.MEDIA_DIR_CACHE), fileName + ".jpg");
-                        File cacheFile2 = null;
+                        File cacheFile2;
                         if (sentMessage.media.photo.sizes.size() == 1 || size.w > 90 || size.h > 90) {
                             cacheFile2 = FileLoader.getPathToAttach(size);
                         } else {
@@ -1842,13 +1854,10 @@ private static boolean prepareSendingDocumentInternal(String path, String origin
             return false;
         }
 
-        boolean isEncrypted = (int)dialog_id == 0;
+        boolean isEncrypted = (int) dialog_id == 0;
         boolean allowSticker = !isEncrypted;
 
         String name = f.getName();
-        if (name == null) {
-            name = "noname";
-        }
         String ext = "";
         int idx = path.lastIndexOf(".");
         if (idx != -1) {
@@ -1872,7 +1881,7 @@ private static boolean prepareSendingDocumentInternal(String path, String origin
             TLRPC.TL_documentAttributeFilename fileName = new TLRPC.TL_documentAttributeFilename();
             fileName.file_name = name;
             document.attributes.add(fileName);
-            document.size = (int)f.length();
+            document.size = (int) f.length();
             document.dc_id = 0;
             if (ext.length() != 0) {
                 if (ext.toLowerCase().equals("webp")) {
@@ -1911,12 +1920,13 @@ private static boolean prepareSendingDocumentInternal(String path, String origin
                     FileLog.e("tmessages", e);
                 }
                 if (bmOptions.outWidth != 0 && bmOptions.outHeight != 0 && bmOptions.outWidth <= 800 && bmOptions.outHeight <= 800) {
-                    TLRPC.TL_documentAttributeSticker attributeSticker = null;
+                    TLRPC.TL_documentAttributeSticker attributeSticker;
                     if (isEncrypted) {
                         attributeSticker = new TLRPC.TL_documentAttributeSticker_old();
                     } else {
                         attributeSticker = new TLRPC.TL_documentAttributeSticker();
                         attributeSticker.alt = "";
+                        attributeSticker.stickerset = new TLRPC.TL_inputStickerSetEmpty();
                     }
                     document.attributes.add(attributeSticker);
                     TLRPC.TL_documentAttributeImageSize attributeImageSize = new TLRPC.TL_documentAttributeImageSize();
@@ -2023,7 +2033,7 @@ public static void prepareSendingPhotosSearch(final ArrayList<MediaController.Se
         new Thread(new Runnable() {
             @Override
             public void run() {
-                boolean isEncrypted = (int)dialog_id == 0;
+                boolean isEncrypted = (int) dialog_id == 0;
                 for (int a = 0; a < photos.size(); a++) {
                     final MediaController.SearchImage searchImage = photos.get(a);
                     if (searchImage.type == 1) {
@@ -2034,7 +2044,7 @@ public void run() {
                         String md5 = Utilities.MD5(searchImage.imageUrl) + "." + ImageLoader.getHttpUrlExtension(searchImage.imageUrl);
                         File cacheFile = new File(FileLoader.getInstance().getDirectory(FileLoader.MEDIA_DIR_CACHE), md5);
                         if (document == null) {
-                            File thumbFile = null;
+                            File thumbFile;
                             document = new TLRPC.TL_document();
                             document.id = 0;
                             document.date = ConnectionsManager.getInstance().getCurrentTime();
@@ -2091,15 +2101,19 @@ public void run() {
                         if (photo == null) {
                             String md5 = Utilities.MD5(searchImage.imageUrl) + "." + ImageLoader.getHttpUrlExtension(searchImage.imageUrl);
                             File cacheFile = new File(FileLoader.getInstance().getDirectory(FileLoader.MEDIA_DIR_CACHE), md5);
-                            if (cacheFile.exists()) {
+                            if (cacheFile.exists() && cacheFile.length() != 0) {
                                 photo = SendMessagesHelper.getInstance().generatePhotoSizes(cacheFile.toString(), null);
-                                needDownloadHttp = false;
-                            } else {
+                                if (photo != null) {
+                                    needDownloadHttp = false;
+                                }
+                            }
+                            if (photo == null) {
                                 md5 = Utilities.MD5(searchImage.thumbUrl) + "." + ImageLoader.getHttpUrlExtension(searchImage.thumbUrl);
                                 cacheFile = new File(FileLoader.getInstance().getDirectory(FileLoader.MEDIA_DIR_CACHE), md5);
                                 if (cacheFile.exists()) {
                                     photo = SendMessagesHelper.getInstance().generatePhotoSizes(cacheFile.toString(), null);
-                                } else {
+                                }
+                                if (photo == null) {
                                     photo = new TLRPC.TL_photo();
                                     photo.user_id = UserConfig.getClientUserId();
                                     photo.date = ConnectionsManager.getInstance().getCurrentTime();
@@ -2174,7 +2188,7 @@ public static void prepareSendingPhotos(ArrayList<String> paths, ArrayList<Uri>
         new Thread(new Runnable() {
             @Override
             public void run() {
-                boolean isEncrypted = (int)dialog_id == 0;
+                boolean isEncrypted = (int) dialog_id == 0;
 
                 ArrayList<String> sendAsDocuments = null;
                 ArrayList<String> sendAsDocumentsOriginal = null;
@@ -2192,7 +2206,7 @@ public void run() {
                     String originalPath = path;
                     String tempPath = path;
                     if (tempPath == null && uri != null) {
-                        tempPath = Utilities.getPath(uri);
+                        tempPath = AndroidUtilities.getPath(uri);
                         originalPath = uri.toString();
                     }
 
@@ -2236,7 +2250,7 @@ public void run() {
                         if (!isEncrypted) {
                             photo = (TLRPC.TL_photo) MessagesStorage.getInstance().getSentFile(originalPath, !isEncrypted ? 0 : 3);
                             if (photo == null && uri != null) {
-                                photo = (TLRPC.TL_photo) MessagesStorage.getInstance().getSentFile(Utilities.getPath(uri), !isEncrypted ? 0 : 3);
+                                photo = (TLRPC.TL_photo) MessagesStorage.getInstance().getSentFile(AndroidUtilities.getPath(uri), !isEncrypted ? 0 : 3);
                             }
                         }
                         if (photo == null) {
@@ -2266,7 +2280,7 @@ public void run() {
         }).start();
     }
 
-    public static void prepareSendingVideo(final String videoPath, final long estimatedSize, final long duration, final int width, final int height, final TLRPC.VideoEditedInfo videoEditedInfo, final long dialog_id, final MessageObject reply_to_msg) {
+    public static void prepareSendingVideo(final String videoPath, final long estimatedSize, final long duration, final int width, final int height, final VideoEditedInfo videoEditedInfo, final long dialog_id, final MessageObject reply_to_msg) {
         if (videoPath == null || videoPath.length() == 0) {
             return;
         }
@@ -2274,7 +2288,7 @@ public static void prepareSendingVideo(final String videoPath, final long estima
             @Override
             public void run() {
 
-                boolean isEncrypted = (int)dialog_id == 0;
+                boolean isEncrypted = (int) dialog_id == 0;
 
                 if (videoEditedInfo != null || videoPath.endsWith("mp4")) {
                     String path = videoPath;
@@ -2316,14 +2330,13 @@ public void run() {
                                 video.h = height;
                             }
                             video.size = (int) estimatedSize;
-                            video.videoEditedInfo = videoEditedInfo;
                             String fileName = Integer.MIN_VALUE + "_" + UserConfig.lastLocalId + ".mp4";
                             UserConfig.lastLocalId--;
                             File cacheFile = new File(FileLoader.getInstance().getDirectory(FileLoader.MEDIA_DIR_CACHE), fileName);
                             UserConfig.saveConfig(false);
                             path = cacheFile.getAbsolutePath();
                         } else {
-                            if (temp != null && temp.exists()) {
+                            if (temp.exists()) {
                                 video.size = (int) temp.length();
                             }
                             boolean infoObtained = false;
@@ -2351,7 +2364,6 @@ public void run() {
                                     try {
                                         if (mediaMetadataRetriever != null) {
                                             mediaMetadataRetriever.release();
-                                            mediaMetadataRetriever = null;
                                         }
                                     } catch (Exception e) {
                                         FileLog.e("tmessages", e);
@@ -2379,7 +2391,7 @@ public void run() {
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
                         public void run() {
-                            SendMessagesHelper.getInstance().sendMessage(videoFinal, originalPathFinal, finalPath, dialog_id, reply_to_msg);
+                            SendMessagesHelper.getInstance().sendMessage(videoFinal, videoEditedInfo, originalPathFinal, finalPath, dialog_id, reply_to_msg);
                         }
                     });
                 } else {
diff --git a/TMessagesProj/src/main/java/org/telegram/android/SmsListener.java b/TMessagesProj/src/main/java/org/telegram/android/SmsListener.java
index 78e179605..0c1df4802 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/SmsListener.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/SmsListener.java
@@ -44,11 +44,16 @@ public void onReceive(Context context, Intent intent) {
 
                     try {
                         Pattern pattern = Pattern.compile("[0-9]+");
-                        Matcher matcher = pattern.matcher(wholeString);
+                        final Matcher matcher = pattern.matcher(wholeString);
                         if (matcher.find()) {
                             String str = matcher.group(0);
                             if (str.length() >= 3) {
-                                NotificationCenter.getInstance().postNotificationName(NotificationCenter.didReceiveSmsCode, matcher.group(0));
+                                AndroidUtilities.runOnUIThread(new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.didReceiveSmsCode, matcher.group(0));
+                                    }
+                                });
                             }
                         }
                     } catch (Throwable e) {
diff --git a/TMessagesProj/src/main/java/org/telegram/android/VideoEditedInfo.java b/TMessagesProj/src/main/java/org/telegram/android/VideoEditedInfo.java
new file mode 100644
index 000000000..ef14750e3
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/VideoEditedInfo.java
@@ -0,0 +1,51 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2014.
+ */
+
+package org.telegram.android;
+
+import java.util.Locale;
+
+public class VideoEditedInfo {
+    public long startTime;
+    public long endTime;
+    public int rotationValue;
+    public int originalWidth;
+    public int originalHeight;
+    public int resultWidth;
+    public int resultHeight;
+    public int bitrate;
+    public String originalPath;
+
+    public String getString() {
+        return String.format(Locale.US, "-1_%d_%d_%d_%d_%d_%d_%d_%d_%s", startTime, endTime, rotationValue, originalWidth, originalHeight, bitrate, resultWidth, resultHeight, originalPath);
+    }
+
+    public void parseString(String string) {
+        if (string.length() < 6) {
+            return;
+        }
+        String args[] = string.split("_");
+        if (args.length >= 10) {
+            startTime = Long.parseLong(args[1]);
+            endTime = Long.parseLong(args[2]);
+            rotationValue = Integer.parseInt(args[3]);
+            originalWidth = Integer.parseInt(args[4]);
+            originalHeight = Integer.parseInt(args[5]);
+            bitrate = Integer.parseInt(args[6]);
+            resultWidth = Integer.parseInt(args[7]);
+            resultHeight = Integer.parseInt(args[8]);
+            for (int a = 9; a < args.length; a++) {
+                if (originalPath == null) {
+                    originalPath = args[a];
+                } else {
+                    originalPath += "_" + args[a];
+                }
+            }
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/query/StickersQuery.java b/TMessagesProj/src/main/java/org/telegram/android/query/StickersQuery.java
index 6c8c45288..9b247d8e8 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/query/StickersQuery.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/query/StickersQuery.java
@@ -8,20 +8,33 @@
 
 package org.telegram.android.query;
 
+import android.app.AlertDialog;
+import android.app.ProgressDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.os.Message;
+import android.widget.Toast;
+
 import org.telegram.SQLite.SQLiteCursor;
 import org.telegram.SQLite.SQLitePreparedStatement;
 import org.telegram.android.AndroidUtilities;
+import org.telegram.android.LocaleController;
 import org.telegram.android.MessagesStorage;
 import org.telegram.android.NotificationCenter;
 import org.telegram.messenger.ByteBufferDesc;
 import org.telegram.messenger.ConnectionsManager;
 import org.telegram.messenger.FileLog;
+import org.telegram.messenger.R;
 import org.telegram.messenger.RPCRequest;
 import org.telegram.messenger.TLObject;
 import org.telegram.messenger.TLRPC;
 import org.telegram.messenger.Utilities;
+import org.telegram.ui.ActionBar.BaseFragment;
+import org.telegram.ui.Components.StickersAlert;
 
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
 import java.util.HashMap;
 
 public class StickersQuery {
@@ -30,19 +43,54 @@
     private static int loadDate;
     private static ArrayList<TLRPC.Document> stickers = new ArrayList<>();
     private static HashMap<String, ArrayList<TLRPC.Document>> allStickers = new HashMap<>();
+    private static ArrayList<TLRPC.TL_stickerPack> stickerPacks = new ArrayList<>();
+    private static ArrayList<TLRPC.TL_stickerSet> stickerSets = new ArrayList<>();
+    private static HashMap<Long, ArrayList<TLRPC.Document>> stickersBySets = new HashMap<>();
+    private static HashMap<Long, String> stickersByEmoji = new HashMap<>();
     private static boolean loadingStickers;
+    private static boolean stickersLoaded;
+    private static boolean hideMainStickersPack;
 
     public static void checkStickers() {
-        if (!loadingStickers && (allStickers.isEmpty() || loadDate < (System.currentTimeMillis() / 1000 - 60 * 60))) {
-            loadStickers(true);
+        if (!loadingStickers && (!stickersLoaded || loadDate < (System.currentTimeMillis() / 1000 - 60 * 60))) {
+            loadStickers(true, false);
         }
     }
 
+    public static boolean isLoadingStickers() {
+        return loadingStickers;
+    }
+
+    public static HashMap<String, ArrayList<TLRPC.Document>> getAllStickers() {
+        return allStickers;
+    }
+
+    public static ArrayList<TLRPC.Document> getStickersForSet(long id) {
+        return stickersBySets.get(id);
+    }
+
+    public static ArrayList<TLRPC.TL_stickerPack> getStickerPacks() {
+        return stickerPacks;
+    }
+
     public static ArrayList<TLRPC.Document> getStickers() {
         return stickers;
     }
 
-    private static void loadStickers(boolean cache) {
+    public static ArrayList<TLRPC.TL_stickerSet> getStickerSets() {
+        return stickerSets;
+    }
+
+    public static boolean isStickerPackInstalled(long id) {
+        return stickersBySets.containsKey(id);
+    }
+
+    public static String getEmojiForSticker(long id) {
+        String value = stickersByEmoji.get(id);
+        return value != null ? value : "";
+    }
+
+    public static void loadStickers(boolean cache, boolean force) {
         if (loadingStickers) {
             return;
         }
@@ -54,7 +102,14 @@ public void run() {
                     TLRPC.messages_AllStickers result = null;
                     int date = 0;
                     try {
-                        SQLiteCursor cursor = MessagesStorage.getInstance().getDatabase().queryFinalized("SELECT data, date FROM stickers WHERE 1");
+                        SQLiteCursor cursor = MessagesStorage.getInstance().getDatabase().queryFinalized("SELECT value FROM keyvalue WHERE id = 'hide_stickers'");
+                        if (cursor.next()) {
+                            int value = Utilities.parseInt(cursor.stringValue(0));
+                            hideMainStickersPack = value == 1;
+                        }
+                        cursor.dispose();
+
+                        cursor = MessagesStorage.getInstance().getDatabase().queryFinalized("SELECT data, date FROM stickers WHERE 1");
                         ArrayList<TLRPC.User> loadedUsers = new ArrayList<>();
                         if (cursor.next()) {
                             ByteBufferDesc data = MessagesStorage.getInstance().getBuffersStorage().getFreeBuffer(cursor.byteArrayLength(0));
@@ -73,10 +128,7 @@ public void run() {
             });
         } else {
             TLRPC.TL_messages_getAllStickers req = new TLRPC.TL_messages_getAllStickers();
-            req.hash = hash;
-            if (req.hash == null) {
-                req.hash = "";
-            }
+            req.hash = hash == null || force ? "" : hash;
             ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
                 @Override
                 public void run(final TLObject response, final TLRPC.TL_error error) {
@@ -113,11 +165,24 @@ public void run() {
         });
     }
 
+    private static long getStickerSetId(TLRPC.Document document) {
+        for (TLRPC.DocumentAttribute attribute : document.attributes) {
+            if (attribute instanceof TLRPC.TL_documentAttributeSticker) {
+                if (attribute.stickerset instanceof TLRPC.TL_inputStickerSetID) {
+                    return attribute.stickerset.id;
+                }
+                break;
+            }
+        }
+        return -1;
+    }
+
     private static void processLoadedStickers(final TLRPC.messages_AllStickers res, final boolean cache, final int date) {
         AndroidUtilities.runOnUIThread(new Runnable() {
             @Override
             public void run() {
                 loadingStickers = false;
+                stickersLoaded = true;
             }
         });
         Utilities.stageQueue.postRunnable(new Runnable() {
@@ -127,7 +192,7 @@ public void run() {
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
                         public void run() {
-                            loadStickers(false);
+                            loadStickers(false, false);
                         }
                     });
                     if (res == null) {
@@ -135,18 +200,41 @@ public void run() {
                     }
                 }
                 if (res instanceof TLRPC.TL_messages_allStickers) {
-                    if (!cache) {
-                        putStickersToCache((TLRPC.TL_messages_allStickers) res);
-                    }
                     HashMap<Long, TLRPC.Document> documents = new HashMap<>();
+                    final HashMap<Long, ArrayList<TLRPC.Document>> sets = new HashMap<>();
+                    final ArrayList<TLRPC.Document> allDocuments = new ArrayList<>();
+                    final HashMap<Long, String> stickersEmoji = new HashMap<>();
                     for (TLRPC.Document document : res.documents) {
                         if (document == null) {
                             continue;
                         }
+
                         documents.put(document.id, document);
-                        if (document.thumb != null && document.thumb.location != null) {
-                            document.thumb.location.ext = "webp";
+                        long setId = getStickerSetId(document);
+                        if (setId != -1 || setId == -1 && !hideMainStickersPack) {
+                            allDocuments.add(document);
                         }
+                        ArrayList<TLRPC.Document> docs = sets.get(setId);
+                        if (docs == null) {
+                            docs = new ArrayList<>();
+                            sets.put(setId, docs);
+                            if (setId == -1) {
+                                boolean contain = false;
+                                for (TLRPC.TL_stickerSet set : res.sets) {
+                                    if (set.id == setId) {
+                                        contain = true;
+                                        break;
+                                    }
+                                }
+                                if (!contain) {
+                                    TLRPC.TL_stickerSet set = new TLRPC.TL_stickerSet();
+                                    set.title = set.short_name = "";
+                                    set.id = -1;
+                                    res.sets.add(0, set);
+                                }
+                            }
+                        }
+                        docs.add(document);
                     }
                     final HashMap<String, ArrayList<TLRPC.Document>> result = new HashMap<>();
                     for (TLRPC.TL_stickerPack stickerPack : res.packs) {
@@ -154,8 +242,16 @@ public void run() {
                             stickerPack.emoticon = stickerPack.emoticon.replace("\uFE0F", "");
                             ArrayList<TLRPC.Document> arrayList = result.get(stickerPack.emoticon);
                             for (Long id : stickerPack.documents) {
+                                if (!stickersEmoji.containsKey(id)) {
+                                    stickersEmoji.put(id, stickerPack.emoticon);
+                                }
                                 TLRPC.Document document = documents.get(id);
                                 if (document != null) {
+                                    long setId = getStickerSetId(document);
+                                    if (setId == -1 && hideMainStickersPack) {
+                                        continue;
+                                    }
+
                                     if (arrayList == null) {
                                         arrayList = new ArrayList<>();
                                         result.put(stickerPack.emoticon, arrayList);
@@ -165,11 +261,30 @@ public void run() {
                             }
                         }
                     }
+                    Collections.sort(allDocuments, new Comparator<TLRPC.Document>() {
+                        @Override
+                        public int compare(TLRPC.Document lhs, TLRPC.Document rhs) {
+                            long lid = getStickerSetId(lhs);
+                            long rid = getStickerSetId(rhs);
+                            if (lid < rid) {
+                                return -1;
+                            } else if (lid > rid) {
+                                return 1;
+                            }
+                            return 0;
+                        }
+                    });
+                    if (!cache) {
+                        putStickersToCache((TLRPC.TL_messages_allStickers) res);
+                    }
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
                         public void run() {
+                            stickerSets = res.sets;
                             allStickers = result;
-                            stickers = res.documents;
+                            stickers = allDocuments;
+                            stickersBySets = sets;
+                            stickersByEmoji = stickersEmoji;
                             hash = res.hash;
                             loadDate = date;
                             NotificationCenter.getInstance().postNotificationName(NotificationCenter.stickersDidLoaded);
@@ -179,4 +294,144 @@ public void run() {
             }
         });
     }
+
+    public static void loadStickers(final BaseFragment fragment, final TLRPC.InputStickerSet stickerSet) {
+        if (fragment == null || stickerSet == null) {
+            return;
+        }
+
+        final ProgressDialog progressDialog = new ProgressDialog(fragment.getParentActivity());
+        progressDialog.setMessage(LocaleController.getString("Loading", R.string.Loading));
+        progressDialog.setCanceledOnTouchOutside(false);
+        progressDialog.setCancelable(false);
+
+        TLRPC.TL_messages_getStickerSet req = new TLRPC.TL_messages_getStickerSet();
+        req.stickerset = stickerSet;
+
+        final long reqId = ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+            @Override
+            public void run(final TLObject response, final TLRPC.TL_error error) {
+                AndroidUtilities.runOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        try {
+                            progressDialog.dismiss();
+                        } catch (Exception e) {
+                            FileLog.e("tmessages", e);
+                        }
+                        if (fragment != null && fragment.getParentActivity() != null && !fragment.getParentActivity().isFinishing()) {
+                            if (error == null) {
+                                final TLRPC.TL_messages_stickerSet res = (TLRPC.TL_messages_stickerSet) response;
+
+                                StickersAlert alert = new StickersAlert(fragment.getParentActivity(), res.set, res.documents);
+                                if (res.set == null || !StickersQuery.isStickerPackInstalled(res.set.id)) {
+                                    alert.setButton(AlertDialog.BUTTON_POSITIVE, LocaleController.getString("AddStickers", R.string.AddStickers), new DialogInterface.OnClickListener() {
+                                        @Override
+                                        public void onClick(DialogInterface dialog, int which) {
+                                            TLRPC.TL_messages_installStickerSet req = new TLRPC.TL_messages_installStickerSet();
+                                            req.stickerset = stickerSet;
+                                            ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+                                                @Override
+                                                public void run(TLObject response, final TLRPC.TL_error error) {
+                                                    AndroidUtilities.runOnUIThread(new Runnable() {
+                                                        @Override
+                                                        public void run() {
+                                                            if (fragment != null && fragment.getParentActivity() != null) {
+                                                                if (error == null) {
+                                                                    Toast.makeText(fragment.getParentActivity(), LocaleController.getString("AddStickersInstalled", R.string.AddStickersInstalled), Toast.LENGTH_SHORT).show();
+                                                                } else {
+                                                                    Toast.makeText(fragment.getParentActivity(), LocaleController.getString("ErrorOccurred", R.string.ErrorOccurred), Toast.LENGTH_SHORT).show();
+                                                                }
+                                                            }
+                                                            loadStickers(false, true);
+                                                        }
+                                                    });
+                                                }
+                                            });
+                                        }
+                                    });
+                                } else {
+                                    alert.setButton(AlertDialog.BUTTON_NEUTRAL, LocaleController.getString("StickersRemove", R.string.StickersRemove), new DialogInterface.OnClickListener() {
+                                        @Override
+                                        public void onClick(DialogInterface dialog, int which) {
+                                            removeStickersSet(fragment.getParentActivity(), res.set);
+                                        }
+                                    });
+                                }
+                                alert.setButton(AlertDialog.BUTTON_NEGATIVE, LocaleController.getString("Close", R.string.Close), (Message) null);
+                                fragment.setVisibleDialog(alert);
+                                alert.show();
+                            } else {
+                                Toast.makeText(fragment.getParentActivity(), LocaleController.getString("AddStickersNotFound", R.string.AddStickersNotFound), Toast.LENGTH_SHORT).show();
+                            }
+                        }
+                    }
+                });
+            }
+        });
+
+        progressDialog.setButton(DialogInterface.BUTTON_NEGATIVE, LocaleController.getString("Cancel", R.string.Cancel), new DialogInterface.OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialog, int which) {
+                ConnectionsManager.getInstance().cancelRpc(reqId, true);
+                try {
+                    dialog.dismiss();
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+        });
+        fragment.setVisibleDialog(progressDialog);
+        progressDialog.show();
+    }
+
+    public static void setHideMainStickersPack(final boolean value) {
+        hideMainStickersPack = value;
+        MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    SQLitePreparedStatement state = MessagesStorage.getInstance().getDatabase().executeFast("REPLACE INTO keyvalue VALUES(?, ?)");
+                    state.requery();
+                    state.bindString(1, "hide_stickers");
+                    state.bindString(2, value ? "1" : "0");
+                    state.step();
+                    state.dispose();
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+        });
+    }
+
+    public static void removeStickersSet(final Context context, TLRPC.TL_stickerSet stickerSet) {
+        TLRPC.TL_messages_uninstallStickerSet req = new TLRPC.TL_messages_uninstallStickerSet();
+        req.stickerset = new TLRPC.TL_inputStickerSetID();
+        req.stickerset.access_hash = stickerSet.access_hash;
+        req.stickerset.id = stickerSet.id;
+        ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+            @Override
+            public void run(TLObject response, final TLRPC.TL_error error) {
+                AndroidUtilities.runOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        try {
+                            if (error == null) {
+                                Toast.makeText(context, LocaleController.getString("StickersRemoved", R.string.StickersRemoved), Toast.LENGTH_SHORT).show();
+                            } else {
+                                Toast.makeText(context, LocaleController.getString("ErrorOccurred", R.string.ErrorOccurred), Toast.LENGTH_SHORT).show();
+                            }
+                        } catch (Exception e) {
+                            FileLog.e("tmessages", e);
+                        }
+                        loadStickers(false, true);
+                    }
+                });
+            }
+        });
+    }
+
+    public static boolean getHideMainStickersPack() {
+        return hideMainStickersPack;
+    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/android/support/widget/RecyclerView.java b/TMessagesProj/src/main/java/org/telegram/android/support/widget/RecyclerView.java
index ebb4e89ba..c5a0fe725 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/support/widget/RecyclerView.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/support/widget/RecyclerView.java
@@ -58,6 +58,8 @@
 import android.view.accessibility.AccessibilityManager;
 import android.view.animation.Interpolator;
 
+import org.telegram.android.AndroidUtilities;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/AbsSerializedData.java b/TMessagesProj/src/main/java/org/telegram/messenger/AbsSerializedData.java
index 1e24cd4e1..ae3863940 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/AbsSerializedData.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/AbsSerializedData.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.x.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Action.java b/TMessagesProj/src/main/java/org/telegram/messenger/Action.java
index 61ed9b70d..dc0c669a4 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Action.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/Action.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java b/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java
index 70a9b6f1d..c7b0937a6 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -157,6 +157,7 @@ public static void postInitApplication() {
         }
 
         UserConfig.loadConfig();
+        MessagesController.getInstance();
         if (UserConfig.getCurrentUser() != null) {
             MessagesController.getInstance().putUser(UserConfig.getCurrentUser(), true);
             ConnectionsManager.getInstance().applyCountryPortNumber(UserConfig.getCurrentUser().phone);
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/BuffersStorage.java b/TMessagesProj/src/main/java/org/telegram/messenger/BuffersStorage.java
index db28c5c73..d6e733709 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/BuffersStorage.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/BuffersStorage.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.x.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -37,12 +37,12 @@ public static BuffersStorage getInstance() {
 
     public BuffersStorage(boolean threadSafe) {
         isThreadSafe = threadSafe;
-        freeBuffers128 = new ArrayList<ByteBufferDesc>();
-        freeBuffers1024 = new ArrayList<ByteBufferDesc>();
-        freeBuffers4096 = new ArrayList<ByteBufferDesc>();
-        freeBuffers16384 = new ArrayList<ByteBufferDesc>();
-        freeBuffers32768 = new ArrayList<ByteBufferDesc>();
-        freeBuffersBig = new ArrayList<ByteBufferDesc>();
+        freeBuffers128 = new ArrayList<>();
+        freeBuffers1024 = new ArrayList<>();
+        freeBuffers4096 = new ArrayList<>();
+        freeBuffers16384 = new ArrayList<>();
+        freeBuffers32768 = new ArrayList<>();
+        freeBuffersBig = new ArrayList<>();
 
         for (int a = 0; a < 5; a++) {
             freeBuffers128.add(new ByteBufferDesc(128));
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/BuildVars.java b/TMessagesProj/src/main/java/org/telegram/messenger/BuildVars.java
index 9507d40e1..38c0e7ca0 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/BuildVars.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/BuildVars.java
@@ -10,7 +10,7 @@
 
 public class BuildVars {
     public static boolean DEBUG_VERSION = false;
-    public static int BUILD_VERSION = 521;
+    public static int BUILD_VERSION = 542;
     public static int APP_ID = 0; //obtain your own APP_ID at https://core.telegram.org/api/obtaining_api_id
     public static String APP_HASH = ""; //obtain your own APP_HASH at https://core.telegram.org/api/obtaining_api_id
     public static String HOCKEY_APP_HASH = "your-hockeyapp-api-key-here";
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ByteArrayOutputStreamExpand.java b/TMessagesProj/src/main/java/org/telegram/messenger/ByteArrayOutputStreamExpand.java
index b82131fef..a4dac2968 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ByteArrayOutputStreamExpand.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ByteArrayOutputStreamExpand.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ByteBufferDesc.java b/TMessagesProj/src/main/java/org/telegram/messenger/ByteBufferDesc.java
index ca366b0b1..4a63cac25 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ByteBufferDesc.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ByteBufferDesc.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.x.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ConnectionContext.java b/TMessagesProj/src/main/java/org/telegram/messenger/ConnectionContext.java
index b32127dbc..06e654576 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ConnectionContext.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ConnectionContext.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.4.x.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ConnectionsManager.java b/TMessagesProj/src/main/java/org/telegram/messenger/ConnectionsManager.java
index b0a32b642..658896f07 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ConnectionsManager.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ConnectionsManager.java
@@ -1,13 +1,14 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
 
+import android.annotation.SuppressLint;
 import android.content.Context;
 import android.content.SharedPreferences;
 import android.content.pm.PackageInfo;
@@ -24,7 +25,13 @@
 import org.telegram.android.NotificationCenter;
 
 import java.io.File;
+import java.net.Inet4Address;
+import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.InterfaceAddress;
+import java.net.NetworkInterface;
 import java.util.ArrayList;
+import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Locale;
 import java.util.concurrent.ConcurrentHashMap;
@@ -444,67 +451,143 @@ private void fillDatacenters() {
             if (isTestBackend == 0) {
                 Datacenter datacenter = new Datacenter();
                 datacenter.datacenterId = 1;
-                datacenter.addAddressAndPort("149.154.175.50", 443);
+                datacenter.addAddressAndPort("149.154.175.50", 443, 0);
+                datacenter.addAddressAndPort("2001:b28:f23d:f001:0000:0000:0000:000a", 443, 1);
                 datacenters.put(datacenter.datacenterId, datacenter);
 
                 datacenter = new Datacenter();
                 datacenter.datacenterId = 2;
-                datacenter.addAddressAndPort("149.154.167.51", 443);
+                datacenter.addAddressAndPort("149.154.167.51", 443, 0);
+                datacenter.addAddressAndPort("2001:67c:4e8:f002:0000:0000:0000:000a", 443, 1);
                 datacenters.put(datacenter.datacenterId, datacenter);
 
                 datacenter = new Datacenter();
                 datacenter.datacenterId = 3;
-                datacenter.addAddressAndPort("149.154.175.100", 443);
+                datacenter.addAddressAndPort("149.154.175.100", 443, 0);
+                datacenter.addAddressAndPort("2001:b28:f23d:f003:0000:0000:0000:000a", 443, 1);
                 datacenters.put(datacenter.datacenterId, datacenter);
 
                 datacenter = new Datacenter();
                 datacenter.datacenterId = 4;
-                datacenter.addAddressAndPort("149.154.167.91", 443);
+                datacenter.addAddressAndPort("149.154.167.91", 443, 0);
+                datacenter.addAddressAndPort("2001:67c:4e8:f004:0000:0000:0000:000a", 443, 1);
                 datacenters.put(datacenter.datacenterId, datacenter);
 
                 datacenter = new Datacenter();
                 datacenter.datacenterId = 5;
-                datacenter.addAddressAndPort("149.154.171.5", 443);
+                datacenter.addAddressAndPort("149.154.171.5", 443, 0);
+                datacenter.addAddressAndPort("2001:b28:f23f:f005:0000:0000:0000:000a", 443, 1);
                 datacenters.put(datacenter.datacenterId, datacenter);
             } else {
                 Datacenter datacenter = new Datacenter();
                 datacenter.datacenterId = 1;
-                datacenter.addAddressAndPort("149.154.175.10", 443);
+                datacenter.addAddressAndPort("149.154.175.10", 443, 0);
+                datacenter.addAddressAndPort("2001:b28:f23d:f001:0000:0000:0000:000e", 443, 1);
                 datacenters.put(datacenter.datacenterId, datacenter);
 
                 datacenter = new Datacenter();
                 datacenter.datacenterId = 2;
-                datacenter.addAddressAndPort("149.154.167.40", 443);
+                datacenter.addAddressAndPort("149.154.167.40", 443, 0);
+                datacenter.addAddressAndPort("2001:67c:4e8:f002:0000:0000:0000:000e", 443, 1);
                 datacenters.put(datacenter.datacenterId, datacenter);
 
                 datacenter = new Datacenter();
                 datacenter.datacenterId = 3;
-                datacenter.addAddressAndPort("149.154.175.117", 443);
+                datacenter.addAddressAndPort("149.154.175.117", 443, 0);
+                datacenter.addAddressAndPort("2001:b28:f23d:f003:0000:0000:0000:000e", 443, 1);
                 datacenters.put(datacenter.datacenterId, datacenter);
             }
         } else if (datacenters.size() == 1) {
             Datacenter datacenter = new Datacenter();
             datacenter.datacenterId = 2;
-            datacenter.addAddressAndPort("149.154.167.51", 443);
+            datacenter.addAddressAndPort("149.154.167.51", 443, 0);
+            datacenter.addAddressAndPort("2001:67c:4e8:f002:0000:0000:0000:000a", 443, 1);
             datacenters.put(datacenter.datacenterId, datacenter);
 
             datacenter = new Datacenter();
             datacenter.datacenterId = 3;
-            datacenter.addAddressAndPort("149.154.175.100", 443);
+            datacenter.addAddressAndPort("149.154.175.100", 443, 0);
+            datacenter.addAddressAndPort("2001:b28:f23d:f003:0000:0000:0000:000a", 443, 1);
             datacenters.put(datacenter.datacenterId, datacenter);
 
             datacenter = new Datacenter();
             datacenter.datacenterId = 4;
-            datacenter.addAddressAndPort("149.154.167.91", 443);
+            datacenter.addAddressAndPort("149.154.167.91", 443, 0);
+            datacenter.addAddressAndPort("2001:67c:4e8:f004:0000:0000:0000:000a", 443, 1);
             datacenters.put(datacenter.datacenterId, datacenter);
 
             datacenter = new Datacenter();
             datacenter.datacenterId = 5;
-            datacenter.addAddressAndPort("149.154.171.5", 443);
+            datacenter.addAddressAndPort("149.154.171.5", 443, 0);
+            datacenter.addAddressAndPort("2001:b28:f23f:f005:0000:0000:0000:000a", 443, 1);
             datacenters.put(datacenter.datacenterId, datacenter);
         }
     }
 
+    @SuppressLint("NewApi")
+    protected static boolean useIpv6Address() {
+        if (BuildVars.DEBUG_VERSION && Build.VERSION.SDK_INT >= 19) {
+            try {
+                NetworkInterface networkInterface;
+                Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
+                while (networkInterfaces.hasMoreElements()) {
+                    networkInterface = networkInterfaces.nextElement();
+                    if (!networkInterface.isUp() || networkInterface.isLoopback() || networkInterface.getInterfaceAddresses().isEmpty()) {
+                        continue;
+                    }
+                    FileLog.e("tmessages", "valid interface: " + networkInterface);
+                    for (InterfaceAddress address : networkInterface.getInterfaceAddresses()) {
+                        InetAddress inetAddress = address.getAddress();
+                        if (BuildVars.DEBUG_VERSION) {
+                            FileLog.e("tmessages", "address: " + inetAddress.getHostAddress());
+                        }
+                        if (inetAddress.isLinkLocalAddress() || inetAddress.isLoopbackAddress() || inetAddress.isMulticastAddress()) {
+                            continue;
+                        }
+                        if (BuildVars.DEBUG_VERSION) {
+                            FileLog.e("tmessages", "address is good");
+                        }
+                    }
+                }
+            } catch (Throwable e) {
+                FileLog.e("tmessages", e);
+            }
+        }
+        if (Build.VERSION.SDK_INT < 50) {
+            return false;
+        }
+        try {
+            NetworkInterface networkInterface;
+            Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
+            while (networkInterfaces.hasMoreElements()) {
+                networkInterface = networkInterfaces.nextElement();
+                if (!networkInterface.isUp() || networkInterface.isLoopback()) {
+                    continue;
+                }
+                boolean hasIpv4 = false;
+                boolean hasIpv6 = false;
+                for (InterfaceAddress address : networkInterface.getInterfaceAddresses()) {
+                    InetAddress inetAddress = address.getAddress();
+                    if (inetAddress.isLinkLocalAddress() || inetAddress.isLoopbackAddress() || inetAddress.isMulticastAddress()) {
+                        continue;
+                    }
+                    if (inetAddress instanceof Inet6Address) {
+                        hasIpv6 = true;
+                    } else if (inetAddress instanceof Inet4Address) {
+                        hasIpv4 = true;
+                    }
+                }
+                if (!hasIpv4 && hasIpv6) {
+                    return true;
+                }
+            }
+        } catch (Throwable e) {
+            FileLog.e("tmessages", e);
+        }
+
+        return false;
+    }
+
     private void saveSession() {
         Utilities.stageQueue.postRunnable(new Runnable() {
             @Override
@@ -698,7 +781,7 @@ public void run() {
                     HashMap<String, Integer> ports = new HashMap<>();
                     addresses.add(ip_address);
                     ports.put(ip_address, port);
-                    exist.replaceAddressesAndPorts(addresses, ports);
+                    exist.replaceAddressesAndPorts(addresses, ports, 0);
                     exist.suspendConnections();
                     updateDcSettings(dc);
                 }
@@ -783,7 +866,7 @@ public void run(TLObject response, TLRPC.TL_error error) {
                             datacentersArr.add(existing);
                             datacenterMap.put(existing.datacenterId, existing);
                         }
-                        existing.addAddressAndPort(datacenterDesc.ip_address, datacenterDesc.port);
+                        existing.addAddressAndPort(datacenterDesc.ip_address, datacenterDesc.port, datacenterDesc.flags);
                     }
 
                     if (!datacentersArr.isEmpty()) {
@@ -792,7 +875,10 @@ public void run(TLObject response, TLRPC.TL_error error) {
                             if (exist == null) {
                                 datacenters.put(datacenter.datacenterId, datacenter);
                             } else {
-                                exist.replaceAddressesAndPorts(datacenter.addresses, datacenter.ports);
+                                exist.replaceAddressesAndPorts(datacenter.addressesIpv4, datacenter.ports, 0);
+                                exist.replaceAddressesAndPorts(datacenter.addressesIpv6, datacenter.ports, 1);
+                                exist.replaceAddressesAndPorts(datacenter.addressesIpv4Download, datacenter.ports, 2);
+                                exist.replaceAddressesAndPorts(datacenter.addressesIpv6Download, datacenter.ports, 3);
                             }
                             if (datacenter.datacenterId == movingToDatacenterId) {
                                 movingToDatacenterId = DEFAULT_DATACENTER_ID;
@@ -821,18 +907,12 @@ private TLObject wrapInLayer(TLObject object, int datacenterId, RPCRequest reque
                 invoke.api_id = BuildVars.APP_ID;
                 try {
                     invoke.lang_code = LocaleController.getLocaleString(LocaleController.getInstance().getSystemDefaultLocale());
-                    if (invoke.lang_code == null || invoke.lang_code.length() == 0) {
+                    if (invoke.lang_code.length() == 0) {
                         invoke.lang_code = "en";
                     }
                     invoke.device_model = Build.MANUFACTURER + Build.MODEL;
-                    if (invoke.device_model == null) {
-                        invoke.device_model = "Android unknown";
-                    }
                     PackageInfo pInfo = ApplicationLoader.applicationContext.getPackageManager().getPackageInfo(ApplicationLoader.applicationContext.getPackageName(), 0);
                     invoke.app_version = pInfo.versionName + " (" + pInfo.versionCode + ")";
-                    if (invoke.app_version == null) {
-                        invoke.app_version = "App version unknown";
-                    }
                     invoke.system_version = "SDK " + Build.VERSION.SDK_INT;
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
@@ -1729,7 +1809,7 @@ ByteBufferDesc createConnectionData(ArrayList<NetworkMessage> messages, ArrayLis
             data.cleanup();
         }
 
-        MessageKeyData keyData = Utilities.generateMessageKeyData(datacenter.authKey, messageKey, false);
+        MessageKeyData keyData = MessageKeyData.generateMessageKeyData(datacenter.authKey, messageKey, false);
 
         int zeroCount = 0;
         if (innerOs.limit() % 16 != 0) {
@@ -1841,20 +1921,13 @@ private void registerForPush() {
         req.app_sandbox = false;
         try {
             req.lang_code = LocaleController.getLocaleString(LocaleController.getInstance().getSystemDefaultLocale());
-            if (req.lang_code == null || req.lang_code.length() == 0) {
+            if (req.lang_code.length() == 0) {
                 req.lang_code = "en";
             }
             req.device_model = Build.MANUFACTURER + Build.MODEL;
-            if (req.device_model == null) {
-                req.device_model = "Android unknown";
-            }
             req.system_version = "SDK " + Build.VERSION.SDK_INT;
             PackageInfo pInfo = ApplicationLoader.applicationContext.getPackageManager().getPackageInfo(ApplicationLoader.applicationContext.getPackageName(), 0);
             req.app_version = pInfo.versionName + " (" + pInfo.versionCode + ")";
-            if (req.app_version == null) {
-                req.app_version = "App version unknown";
-            }
-
         } catch (Exception e) {
             FileLog.e("tmessages", e);
             req.lang_code = "en";
@@ -2191,7 +2264,7 @@ public void run() {
                                         AndroidUtilities.runOnUIThread(new Runnable() {
                                             @Override
                                             public void run() {
-                                                NotificationCenter.getInstance().postNotificationName(NotificationCenter.appDidLogout);
+                                                MessagesController.getInstance().performLogout(false);
                                             }
                                         });
                                     }
@@ -2428,13 +2501,13 @@ private ByteBufferDesc generatePingData(TcpConnection connection) {
     }
 
     void generatePing(Datacenter datacenter, boolean push) {
-        TcpConnection connection = null;
+        TcpConnection connection;
         if (push) {
             connection = datacenter.pushConnection;
         } else {
             connection = datacenter.connection;
         }
-        if (connection != null && (push || !push && connection.channelToken != 0)) {
+        if (connection != null && (push || connection.channelToken != 0)) {
             ByteBufferDesc transportData = generatePingData(connection);
             if (transportData != null) {
                 if (push) {
@@ -2607,7 +2680,7 @@ public void run() {
             }
 
             byte[] messageKey = data.readData(16, false);
-            MessageKeyData keyData = Utilities.generateMessageKeyData(datacenter.authKey, messageKey, true);
+            MessageKeyData keyData = MessageKeyData.generateMessageKeyData(datacenter.authKey, messageKey, true);
 
             Utilities.aesIgeEncryption(data.buffer, keyData.aesKey, keyData.aesIv, false, false, data.position(), length - 24);
 
@@ -2671,10 +2744,15 @@ public void run() {
     }
 
     protected TLObject deserialize(TLObject request, AbsSerializedData data, boolean exception) {
-        int constructor = data.readInt32(exception);
+        int constructor = 0;
+        try {
+            constructor = data.readInt32(exception);
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
         TLObject message = null;
         try {
-            message = TLClassStore.Instance().TLdeserialize(data, constructor, request, exception);
+            message = TLClassStore.Instance().TLdeserialize(data, constructor, exception);
         } catch (Exception e) {
             FileLog.e("tmessages", e);
         }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Datacenter.java b/TMessagesProj/src/main/java/org/telegram/messenger/Datacenter.java
index 04ffccfab..cb28e751a 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Datacenter.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/Datacenter.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -17,10 +17,13 @@
 import java.util.HashMap;
 
 public class Datacenter {
-    private static final int DATA_VERSION = 4;
+    private static final int DATA_VERSION = 5;
 
     public int datacenterId;
-    public ArrayList<String> addresses = new ArrayList<>();
+    public ArrayList<String> addressesIpv4 = new ArrayList<>();
+    public ArrayList<String> addressesIpv6 = new ArrayList<>();
+    public ArrayList<String> addressesIpv4Download = new ArrayList<>();
+    public ArrayList<String> addressesIpv6Download = new ArrayList<>();
     public HashMap<String, Integer> ports = new HashMap<>();
     public int[] defaultPorts =   new int[] {-1, 80, -1, 443, -1, 443, -1, 80, -1, 443, -1};
     public int[] defaultPorts8888 = new int[] {-1, 8888, -1, 443, -1, 8888,  -1, 80, -1, 8888,  -1};
@@ -29,8 +32,15 @@
     public long authKeyId;
     public int lastInitVersion = 0;
     public int overridePort = -1;
-    private volatile int currentPortNum = 0;
-    private volatile int currentAddressNum = 0;
+
+    private volatile int currentPortNumIpv4 = 0;
+    private volatile int currentAddressNumIpv4 = 0;
+    private volatile int currentPortNumIpv6 = 0;
+    private volatile int currentAddressNumIpv6 = 0;
+    private volatile int currentPortNumIpv4Download = 0;
+    private volatile int currentAddressNumIpv4Download = 0;
+    private volatile int currentPortNumIpv6Download = 0;
+    private volatile int currentAddressNumIpv6Download = 0;
 
     public TcpConnection connection;
     private TcpConnection downloadConnection;
@@ -47,7 +57,7 @@ public Datacenter(SerializedData data, int version) {
         if (version == 0) {
             datacenterId = data.readInt32(false);
             String address = data.readString(false);
-            addresses.add(address);
+            addressesIpv4.add(address);
             int port = data.readInt32(false);
             ports.put(address, port);
             int len = data.readInt32(false);
@@ -72,7 +82,7 @@ public Datacenter(SerializedData data, int version) {
             }
         } else if (version == 1) {
             int currentVersion = data.readInt32(false);
-            if (currentVersion == 2 || currentVersion == 3 || currentVersion == 4) {
+            if (currentVersion >= 2 && currentVersion <= 5) {
                 datacenterId = data.readInt32(false);
                 if (currentVersion >= 3) {
                     lastInitVersion = data.readInt32(false);
@@ -80,15 +90,35 @@ public Datacenter(SerializedData data, int version) {
                 int len = data.readInt32(false);
                 for (int a = 0; a < len; a++) {
                     String address = data.readString(false);
-                    addresses.add(address);
+                    addressesIpv4.add(address);
                     ports.put(address, data.readInt32(false));
                 }
+                if (currentVersion >= 5) {
+                    len = data.readInt32(false);
+                    for (int a = 0; a < len; a++) {
+                        String address = data.readString(false);
+                        addressesIpv6.add(address);
+                        ports.put(address, data.readInt32(false));
+                    }
+                    len = data.readInt32(false);
+                    for (int a = 0; a < len; a++) {
+                        String address = data.readString(false);
+                        addressesIpv4Download.add(address);
+                        ports.put(address, data.readInt32(false));
+                    }
+                    len = data.readInt32(false);
+                    for (int a = 0; a < len; a++) {
+                        String address = data.readString(false);
+                        addressesIpv6Download.add(address);
+                        ports.put(address, data.readInt32(false));
+                    }
+                }
 
                 len = data.readInt32(false);
                 if (len != 0) {
                     authKey = data.readData(len, false);
                 }
-                if (currentVersion == 4) {
+                if (currentVersion >= 4) {
                     authKeyId = data.readInt64(false);
                 } else {
                     len = data.readInt32(false);
@@ -116,26 +146,79 @@ public Datacenter(SerializedData data, int version) {
     }
 
     public void switchTo443Port() {
-        for (int a = 0; a < addresses.size(); a++) {
-            if (ports.get(addresses.get(a)) == 443) {
-                currentAddressNum = a;
-                currentPortNum = 0;
+        for (int a = 0; a < addressesIpv4.size(); a++) {
+            if (ports.get(addressesIpv4.get(a)) == 443) {
+                currentAddressNumIpv4 = a;
+                currentPortNumIpv4 = 0;
+                break;
+            }
+        }
+        for (int a = 0; a < addressesIpv6.size(); a++) {
+            if (ports.get(addressesIpv6.get(a)) == 443) {
+                currentAddressNumIpv6 = a;
+                currentPortNumIpv6 = 0;
+                break;
+            }
+        }
+        for (int a = 0; a < addressesIpv4Download.size(); a++) {
+            if (ports.get(addressesIpv4Download.get(a)) == 443) {
+                currentAddressNumIpv4Download = a;
+                currentPortNumIpv4Download = 0;
+                break;
+            }
+        }
+        for (int a = 0; a < addressesIpv6Download.size(); a++) {
+            if (ports.get(addressesIpv6Download.get(a)) == 443) {
+                currentAddressNumIpv6Download = a;
+                currentPortNumIpv6Download = 0;
                 break;
             }
         }
     }
 
-    public String getCurrentAddress() {
+    public String getCurrentAddress(int flags) {
+        int currentAddressNum;
+        ArrayList<String> addresses;
+        if ((flags & 2) != 0) {
+            if ((flags & 1) != 0) {
+                currentAddressNum = currentAddressNumIpv6Download;
+                addresses = addressesIpv6Download;
+            } else {
+                currentAddressNum = currentAddressNumIpv4Download;
+                addresses = addressesIpv4Download;
+            }
+        } else {
+            if ((flags & 1) != 0) {
+                currentAddressNum = currentAddressNumIpv6;
+                addresses = addressesIpv6;
+            } else {
+                currentAddressNum = currentAddressNumIpv4;
+                addresses = addressesIpv4;
+            }
+        }
         if (addresses.isEmpty()) {
             return null;
         }
         if (currentAddressNum >= addresses.size()) {
             currentAddressNum = 0;
+            if ((flags & 2) != 0) {
+                if ((flags & 1) != 0) {
+                    currentAddressNumIpv6Download = currentAddressNum;
+                } else {
+                    currentAddressNumIpv4Download = currentAddressNum;
+                }
+            } else {
+                if ((flags & 1) != 0) {
+                    currentAddressNumIpv6 = currentAddressNum;
+                } else {
+                    currentAddressNumIpv4 = currentAddressNum;
+                }
+            }
         }
         return addresses.get(currentAddressNum);
     }
 
-    public int getCurrentPort() {
+    public int getCurrentPort(int flags) {
         if (ports.isEmpty()) {
             return overridePort == -1 ? 443 : overridePort;
         }
@@ -146,21 +229,64 @@ public int getCurrentPort() {
             portsArray = defaultPorts8888;
         }
 
+        int currentPortNum;
+        ArrayList<String> addresses;
+        if ((flags & 2) != 0) {
+            if ((flags & 1) != 0) {
+                currentPortNum = currentPortNumIpv6Download;
+            } else {
+                currentPortNum = currentPortNumIpv4Download;
+            }
+        } else {
+            if ((flags & 1) != 0) {
+                currentPortNum = currentPortNumIpv6;
+            } else {
+                currentPortNum = currentPortNumIpv4;
+            }
+        }
+
         if (currentPortNum >= defaultPorts.length) {
             currentPortNum = 0;
+            if ((flags & 2) != 0) {
+                if ((flags & 1) != 0) {
+                    currentPortNumIpv6Download = currentPortNum;
+                } else {
+                    currentPortNumIpv4Download = currentPortNum;
+                }
+            } else {
+                if ((flags & 1) != 0) {
+                    currentPortNumIpv6 = currentPortNum;
+                } else {
+                    currentPortNumIpv4 = currentPortNum;
+                }
+            }
         }
         int port = portsArray[currentPortNum];
         if (port == -1) {
             if (overridePort != -1) {
                 return overridePort;
             }
-            String address = getCurrentAddress();
+            String address = getCurrentAddress(flags);
             return ports.get(address);
         }
         return port;
     }
 
-    public void addAddressAndPort(String address, int port) {
+    public void addAddressAndPort(String address, int port, int flags) {
+        ArrayList<String> addresses;
+        if ((flags & 2) != 0) {
+            if ((flags & 1) != 0) {
+                addresses = addressesIpv6Download;
+            } else {
+                addresses = addressesIpv4Download;
+            }
+        } else {
+            if ((flags & 1) != 0) {
+                addresses = addressesIpv6;
+            } else {
+                addresses = addressesIpv4;
+            }
+        }
         if (addresses.contains(address)) {
             return;
         }
@@ -168,7 +294,31 @@ public void addAddressAndPort(String address, int port) {
         ports.put(address, port);
     }
 
-    public void nextAddressOrPort() {
+    public void nextAddressOrPort(int flags) {
+        int currentPortNum;
+        int currentAddressNum;
+        ArrayList<String> addresses;
+        if ((flags & 2) != 0) {
+            if ((flags & 1) != 0) {
+                currentPortNum = currentPortNumIpv6Download;
+                currentAddressNum = currentAddressNumIpv6Download;
+                addresses = addressesIpv6Download;
+            } else {
+                currentPortNum = currentPortNumIpv4Download;
+                currentAddressNum = currentAddressNumIpv4Download;
+                addresses = addressesIpv4Download;
+            }
+        } else {
+            if ((flags & 1) != 0) {
+                currentPortNum = currentPortNumIpv6;
+                currentAddressNum = currentAddressNumIpv6;
+                addresses = addressesIpv6;
+            } else {
+                currentPortNum = currentPortNumIpv4;
+                currentAddressNum = currentAddressNumIpv4;
+                addresses = addressesIpv4;
+            }
+        }
         if (currentPortNum + 1 < defaultPorts.length) {
             currentPortNum++;
         } else {
@@ -179,6 +329,23 @@ public void nextAddressOrPort() {
             }
             currentPortNum = 0;
         }
+        if ((flags & 2) != 0) {
+            if ((flags & 1) != 0) {
+                currentPortNumIpv6Download = currentPortNum;
+                currentAddressNumIpv6Download = currentAddressNum;
+            } else {
+                currentPortNumIpv4Download = currentPortNum;
+                currentAddressNumIpv4Download = currentAddressNum;
+            }
+        } else {
+            if ((flags & 1) != 0) {
+                currentPortNumIpv6 = currentPortNum;
+                currentAddressNumIpv6 = currentAddressNum;
+            } else {
+                currentPortNumIpv4 = currentPortNum;
+                currentAddressNumIpv4 = currentAddressNum;
+            }
+        }
     }
 
     public void storeCurrentAddressAndPortNum() {
@@ -187,8 +354,14 @@ public void storeCurrentAddressAndPortNum() {
             public void run() {
                 SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("dataconfig", Context.MODE_PRIVATE);
                 SharedPreferences.Editor editor = preferences.edit();
-                editor.putInt("dc" + datacenterId + "port", currentPortNum);
-                editor.putInt("dc" + datacenterId + "address", currentAddressNum);
+                editor.putInt("dc" + datacenterId + "port", currentPortNumIpv4);
+                editor.putInt("dc" + datacenterId + "address", currentAddressNumIpv4);
+                editor.putInt("dc" + datacenterId + "port6", currentPortNumIpv6);
+                editor.putInt("dc" + datacenterId + "address6", currentAddressNumIpv6);
+                editor.putInt("dc" + datacenterId + "portD", currentPortNumIpv4Download);
+                editor.putInt("dc" + datacenterId + "addressD", currentAddressNumIpv4Download);
+                editor.putInt("dc" + datacenterId + "port6D", currentPortNumIpv6Download);
+                editor.putInt("dc" + datacenterId + "address6D", currentAddressNumIpv6Download);
                 editor.commit();
             }
         });
@@ -196,21 +369,71 @@ public void run() {
 
     private void readCurrentAddressAndPortNum() {
         SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("dataconfig", Context.MODE_PRIVATE);
-        currentPortNum = preferences.getInt("dc" + datacenterId + "port", 0);
-        currentAddressNum = preferences.getInt("dc" + datacenterId + "address", 0);
+        currentPortNumIpv4 = preferences.getInt("dc" + datacenterId + "port", 0);
+        currentAddressNumIpv4 = preferences.getInt("dc" + datacenterId + "address", 0);
+        currentPortNumIpv6 = preferences.getInt("dc" + datacenterId + "port6", 0);
+        currentAddressNumIpv6 = preferences.getInt("dc" + datacenterId + "address6", 0);
+        currentPortNumIpv4Download = preferences.getInt("dc" + datacenterId + "portD", 0);
+        currentAddressNumIpv4Download = preferences.getInt("dc" + datacenterId + "addressD", 0);
+        currentPortNumIpv6Download = preferences.getInt("dc" + datacenterId + "port6D", 0);
+        currentAddressNumIpv6Download = preferences.getInt("dc" + datacenterId + "address6D", 0);
     }
 
-    public void replaceAddressesAndPorts(ArrayList<String> newAddresses, HashMap<String, Integer> newPorts) {
-        addresses = newAddresses;
-        ports = newPorts;
+    public void replaceAddressesAndPorts(ArrayList<String> newAddresses, HashMap<String, Integer> newPorts, int flags) {
+        ArrayList<String> addresses;
+        if ((flags & 2) != 0) {
+            if ((flags & 1) != 0) {
+                addresses = addressesIpv6Download;
+            } else {
+                addresses = addressesIpv4Download;
+            }
+        } else {
+            if ((flags & 1) != 0) {
+                addresses = addressesIpv6;
+            } else {
+                addresses = addressesIpv4;
+            }
+        }
+        for (String address : addresses) {
+            ports.remove(address);
+        }
+        if ((flags & 2) != 0) {
+            if ((flags & 1) != 0) {
+                addressesIpv6Download = newAddresses;
+            } else {
+                addressesIpv4Download = newAddresses;
+            }
+        } else {
+            if ((flags & 1) != 0) {
+                addressesIpv6 = newAddresses;
+            } else {
+                addressesIpv4 = newAddresses;
+            }
+        }
+        ports.putAll(newPorts);
     }
 
     public void SerializeToStream(SerializedData stream) {
         stream.writeInt32(DATA_VERSION);
         stream.writeInt32(datacenterId);
         stream.writeInt32(lastInitVersion);
-        stream.writeInt32(addresses.size());
-        for (String address : addresses) {
+        stream.writeInt32(addressesIpv4.size());
+        for (String address : addressesIpv4) {
+            stream.writeString(address);
+            stream.writeInt32(ports.get(address));
+        }
+        stream.writeInt32(addressesIpv6.size());
+        for (String address : addressesIpv6) {
+            stream.writeString(address);
+            stream.writeInt32(ports.get(address));
+        }
+        stream.writeInt32(addressesIpv4Download.size());
+        for (String address : addressesIpv4Download) {
+            stream.writeString(address);
+            stream.writeInt32(ports.get(address));
+        }
+        stream.writeInt32(addressesIpv6Download.size());
+        for (String address : addressesIpv6Download) {
             stream.writeString(address);
             stream.writeInt32(ports.get(address));
         }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/DispatchQueue.java b/TMessagesProj/src/main/java/org/telegram/messenger/DispatchQueue.java
index 2c68fdf6e..529cbdbc5 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/DispatchQueue.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/DispatchQueue.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ExportAuthorizationAction.java b/TMessagesProj/src/main/java/org/telegram/messenger/ExportAuthorizationAction.java
index 51367696d..603032c29 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ExportAuthorizationAction.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ExportAuthorizationAction.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/FileLoadOperation.java b/TMessagesProj/src/main/java/org/telegram/messenger/FileLoadOperation.java
index 62f217442..2a006d37b 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/FileLoadOperation.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/FileLoadOperation.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -60,7 +60,7 @@
         void didChangedLoadProgress(FileLoadOperation operation, float progress);
     }
 
-    public FileLoadOperation(TLRPC.FileLocation photoLocation, int size) {
+    public FileLoadOperation(TLRPC.FileLocation photoLocation, String extension, int size) {
         if (photoLocation instanceof TLRPC.TL_fileEncryptedLocation) {
             location = new TLRPC.TL_inputEncryptedFileLocation();
             location.id = photoLocation.volume_id;
@@ -79,10 +79,7 @@ public FileLoadOperation(TLRPC.FileLocation photoLocation, int size) {
             datacenter_id = photoLocation.dc_id;
         }
         totalBytesCount = size;
-        ext = photoLocation.ext;
-        if (ext == null) {
-            ext = "jpg";
-        }
+        ext = extension != null ? extension : "jpg";
     }
 
     public FileLoadOperation(TLRPC.Video videoLocation) {
@@ -140,7 +137,7 @@ public FileLoadOperation(TLRPC.Document documentLocation) {
         }
         totalBytesCount = documentLocation.size;
         ext = FileLoader.getDocumentFileName(documentLocation);
-        int idx = -1;
+        int idx;
         if (ext == null || (idx = ext.lastIndexOf(".")) == -1) {
             ext = "";
         } else {
@@ -179,8 +176,8 @@ public void run() {
             return;
         }
         Long mediaId = null;
-        String fileNameFinal = null;
-        String fileNameTemp = null;
+        String fileNameFinal;
+        String fileNameTemp;
         String fileNameIv = null;
         if (location.volume_id != 0 && location.local_id != 0) {
             fileNameTemp = location.volume_id + "_" + location.local_id + "_temp." + ext;
@@ -219,7 +216,6 @@ public void run() {
         cacheFileFinal = new File(storePath, fileNameFinal);
         boolean exist = cacheFileFinal.exists();
         if (exist && totalBytesCount != 0 && totalBytesCount != cacheFileFinal.length()) {
-            exist = false;
             cacheFileFinal.delete();
         }
 
@@ -388,7 +384,6 @@ private void processRequestResult(RequestInfo requestInfo, TLRPC.TL_error error)
                         processRequestResult(delayedRequestInfo, null);
                         delayedRequestInfo.response.disableFree = false;
                         delayedRequestInfo.response.freeResources();
-                        delayedRequestInfo = null;
                         break;
                     }
                 }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/FileLoader.java b/TMessagesProj/src/main/java/org/telegram/messenger/FileLoader.java
index 8dbed3e4c..2860c3cc9 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/FileLoader.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/FileLoader.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -21,10 +21,15 @@
 
     public interface FileLoaderDelegate {
         void fileUploadProgressChanged(String location, float progress, boolean isEncrypted);
-        void fileDidUploaded(String location, TLRPC.InputFile inputFile, TLRPC.InputEncryptedFile inputEncryptedFile);
+
+        void fileDidUploaded(String location, TLRPC.InputFile inputFile, TLRPC.InputEncryptedFile inputEncryptedFile, byte[] key, byte[] iv);
+
         void fileDidFailedUpload(String location, boolean isEncrypted);
+
         void fileDidLoaded(String location, File finalFile, int type);
+
         void fileDidFailedLoad(String location, int state);
+
         void fileLoadProgressChanged(String location, float progress);
     }
 
@@ -56,6 +61,7 @@
     private int currentUploadSmallOperationsCount = 0;
 
     private static volatile FileLoader Instance = null;
+
     public static FileLoader getInstance() {
         FileLoader localInstance = Instance;
         if (localInstance == null) {
@@ -92,7 +98,7 @@ public void cancelUploadFile(final String location, final boolean enc) {
         fileLoaderQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
-                FileUploadOperation operation = null;
+                FileUploadOperation operation;
                 if (!enc) {
                     operation = uploadOperationPaths.get(location);
                 } else {
@@ -112,7 +118,7 @@ public void checkUploadNewDataAvailable(final String location, final boolean enc
         fileLoaderQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
-                FileUploadOperation operation = null;
+                FileUploadOperation operation;
                 if (encrypted) {
                     operation = uploadOperationPathsEnc.get(location);
                 } else {
@@ -163,7 +169,7 @@ public void run() {
                 }
                 operation.delegate = new FileUploadOperation.FileUploadOperationDelegate() {
                     @Override
-                    public void didFinishUploadingFile(FileUploadOperation operation, final TLRPC.InputFile inputFile, final TLRPC.InputEncryptedFile inputEncryptedFile) {
+                    public void didFinishUploadingFile(FileUploadOperation operation, final TLRPC.InputFile inputFile, final TLRPC.InputEncryptedFile inputEncryptedFile, final byte[] key, final byte[] iv) {
                         fileLoaderQueue.postRunnable(new Runnable() {
                             @Override
                             public void run() {
@@ -192,7 +198,7 @@ public void run() {
                                     }
                                 }
                                 if (delegate != null) {
-                                    delegate.fileDidUploaded(location, inputFile, inputEncryptedFile);
+                                    delegate.fileDidUploaded(location, inputFile, inputEncryptedFile, key, iv);
                                 }
                             }
                         });
@@ -261,26 +267,26 @@ public void didChangedUploadProgress(FileUploadOperation operation, final float
     }
 
     public void cancelLoadFile(TLRPC.Video video) {
-        cancelLoadFile(video, null, null, null);
+        cancelLoadFile(video, null, null, null, null);
     }
 
     public void cancelLoadFile(TLRPC.Document document) {
-        cancelLoadFile(null, document, null, null);
+        cancelLoadFile(null, document, null, null, null);
     }
 
     public void cancelLoadFile(TLRPC.Audio audio) {
-        cancelLoadFile(null, null, audio, null);
+        cancelLoadFile(null, null, audio, null, null);
     }
 
     public void cancelLoadFile(TLRPC.PhotoSize photo) {
-        cancelLoadFile(null, null, null, photo.location);
+        cancelLoadFile(null, null, null, photo.location, null);
     }
 
-    public void cancelLoadFile(TLRPC.FileLocation location) {
-        cancelLoadFile(null, null, null, location);
+    public void cancelLoadFile(TLRPC.FileLocation location, String ext) {
+        cancelLoadFile(null, null, null, location, ext);
     }
 
-    private void cancelLoadFile(final TLRPC.Video video, final TLRPC.Document document, final TLRPC.Audio audio, final TLRPC.FileLocation location) {
+    private void cancelLoadFile(final TLRPC.Video video, final TLRPC.Document document, final TLRPC.Audio audio, final TLRPC.FileLocation location, final String locationExt) {
         if (video == null && location == null && document == null && audio == null) {
             return;
         }
@@ -291,7 +297,7 @@ public void run() {
                 if (video != null) {
                     fileName = getAttachFileName(video);
                 } else if (location != null) {
-                    fileName = getAttachFileName(location);
+                    fileName = getAttachFileName(location, locationExt);
                 } else if (document != null) {
                     fileName = getAttachFileName(document);
                 } else if (audio != null) {
@@ -335,26 +341,26 @@ public void run() {
     }
 
     public void loadFile(TLRPC.Video video, boolean force) {
-        loadFile(video, null, null, null, 0, force, video != null && video.key != null);
+        loadFile(video, null, null, null, null, 0, force, video != null && video.key != null);
     }
 
-    public void loadFile(TLRPC.PhotoSize photo, boolean cacheOnly) {
-        loadFile(null, null, null, photo.location, photo.size, false, cacheOnly || (photo != null && photo.size == 0 || photo.location.key != null));
+    public void loadFile(TLRPC.PhotoSize photo, String ext, boolean cacheOnly) {
+        loadFile(null, null, null, photo.location, ext, photo.size, false, cacheOnly || (photo != null && photo.size == 0 || photo.location.key != null));
     }
 
     public void loadFile(TLRPC.Document document, boolean force, boolean cacheOnly) {
-        loadFile(null, document, null, null, 0, force, cacheOnly || document != null && document.key != null);
+        loadFile(null, document, null, null, null, 0, force, cacheOnly || document != null && document.key != null);
     }
 
     public void loadFile(TLRPC.Audio audio, boolean force) {
-        loadFile(null, null, audio, null, 0, false, audio != null && audio.key != null);
+        loadFile(null, null, audio, null, null, 0, false, audio != null && audio.key != null);
     }
 
-    public void loadFile(TLRPC.FileLocation location, int size, boolean cacheOnly) {
-        loadFile(null, null, null, location, size, true, cacheOnly || size == 0 || (location != null && location.key != null));
+    public void loadFile(TLRPC.FileLocation location, String ext, int size, boolean cacheOnly) {
+        loadFile(null, null, null, location, ext, size, true, cacheOnly || size == 0 || (location != null && location.key != null));
     }
 
-    private void loadFile(final TLRPC.Video video, final TLRPC.Document document, final TLRPC.Audio audio, final TLRPC.FileLocation location, final int locationSize, final boolean force, final boolean cacheOnly) {
+    private void loadFile(final TLRPC.Video video, final TLRPC.Document document, final TLRPC.Audio audio, final TLRPC.FileLocation location, final String locationExt, final int locationSize, final boolean force, final boolean cacheOnly) {
         fileLoaderQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
@@ -362,7 +368,7 @@ public void run() {
                 if (video != null) {
                     fileName = getAttachFileName(video);
                 } else if (location != null) {
-                    fileName = getAttachFileName(location);
+                    fileName = getAttachFileName(location, locationExt);
                 } else if (document != null) {
                     fileName = getAttachFileName(document);
                 } else if (audio != null) {
@@ -372,11 +378,11 @@ public void run() {
                     return;
                 }
 
-                FileLoadOperation operation = null;
+                FileLoadOperation operation;
                 operation = loadOperationPaths.get(fileName);
                 if (operation != null) {
                     if (force) {
-                        LinkedList<FileLoadOperation> downloadQueue = null;
+                        LinkedList<FileLoadOperation> downloadQueue;
                         if (audio != null) {
                             downloadQueue = audioLoadOperationQueue;
                         } else if (location != null) {
@@ -404,7 +410,7 @@ public void run() {
                     operation = new FileLoadOperation(video);
                     type = MEDIA_DIR_VIDEO;
                 } else if (location != null) {
-                    operation = new FileLoadOperation(location, locationSize);
+                    operation = new FileLoadOperation(location, locationExt, locationSize);
                     type = MEDIA_DIR_IMAGE;
                 } else if (document != null) {
                     operation = new FileLoadOperation(document);
@@ -489,7 +495,7 @@ private void checkDownloadQueue(final TLRPC.Audio audio, final TLRPC.FileLocatio
             @Override
             public void run() {
                 loadOperationPaths.remove(arg1);
-                FileLoadOperation operation = null;
+                FileLoadOperation operation;
                 if (audio != null) {
                     currentAudioLoadOperationsCount--;
                     if (!audioLoadOperationQueue.isEmpty()) {
@@ -583,51 +589,59 @@ public static File getExistPathToAttach(TLObject attach) {
     }
 
     public static File getPathToAttach(TLObject attach) {
-        return getPathToAttach(attach, false);
+        return getPathToAttach(attach, null, false);
     }
 
     public static File getPathToAttach(TLObject attach, boolean forceCache) {
+        return getPathToAttach(attach, null, forceCache);
+    }
+
+    public static File getPathToAttach(TLObject attach, String ext, boolean forceCache) {
         File dir = null;
-        if (attach instanceof TLRPC.Video) {
-            TLRPC.Video video = (TLRPC.Video)attach;
-            if (forceCache || video.key != null) {
-                dir = getInstance().getDirectory(MEDIA_DIR_CACHE);
-            } else {
-                dir = getInstance().getDirectory(MEDIA_DIR_VIDEO);
-            }
-        } else if (attach instanceof TLRPC.Document) {
-            TLRPC.Document document = (TLRPC.Document)attach;
-            if (forceCache || document.key != null) {
-                dir = getInstance().getDirectory(MEDIA_DIR_CACHE);
-            } else {
-                dir = getInstance().getDirectory(MEDIA_DIR_DOCUMENT);
-            }
-        } else if (attach instanceof TLRPC.PhotoSize) {
-            TLRPC.PhotoSize photoSize = (TLRPC.PhotoSize)attach;
-            if (forceCache || photoSize.location == null || photoSize.location.key != null || photoSize.location.volume_id == Integer.MIN_VALUE && photoSize.location.local_id < 0) {
-                dir = getInstance().getDirectory(MEDIA_DIR_CACHE);
-            } else {
-                dir = getInstance().getDirectory(MEDIA_DIR_IMAGE);
-            }
-        } else if (attach instanceof TLRPC.Audio) {
-            TLRPC.Audio audio = (TLRPC.Audio)attach;
-            if (forceCache || audio.key != null) {
-                dir = getInstance().getDirectory(MEDIA_DIR_CACHE);
-            } else {
-                dir = getInstance().getDirectory(MEDIA_DIR_AUDIO);
-            }
-        } else if (attach instanceof TLRPC.FileLocation) {
-            TLRPC.FileLocation fileLocation = (TLRPC.FileLocation)attach;
-            if (forceCache || fileLocation.key != null || fileLocation.volume_id == Integer.MIN_VALUE && fileLocation.local_id < 0) {
-                dir = getInstance().getDirectory(MEDIA_DIR_CACHE);
-            } else {
-                dir = getInstance().getDirectory(MEDIA_DIR_IMAGE);
+        if (forceCache) {
+            dir = getInstance().getDirectory(MEDIA_DIR_CACHE);
+        } else {
+            if (attach instanceof TLRPC.Video) {
+                TLRPC.Video video = (TLRPC.Video) attach;
+                if (video.key != null) {
+                    dir = getInstance().getDirectory(MEDIA_DIR_CACHE);
+                } else {
+                    dir = getInstance().getDirectory(MEDIA_DIR_VIDEO);
+                }
+            } else if (attach instanceof TLRPC.Document) {
+                TLRPC.Document document = (TLRPC.Document) attach;
+                if (document.key != null) {
+                    dir = getInstance().getDirectory(MEDIA_DIR_CACHE);
+                } else {
+                    dir = getInstance().getDirectory(MEDIA_DIR_DOCUMENT);
+                }
+            } else if (attach instanceof TLRPC.PhotoSize) {
+                TLRPC.PhotoSize photoSize = (TLRPC.PhotoSize) attach;
+                if (photoSize.location == null || photoSize.location.key != null || photoSize.location.volume_id == Integer.MIN_VALUE && photoSize.location.local_id < 0) {
+                    dir = getInstance().getDirectory(MEDIA_DIR_CACHE);
+                } else {
+                    dir = getInstance().getDirectory(MEDIA_DIR_IMAGE);
+                }
+            } else if (attach instanceof TLRPC.Audio) {
+                TLRPC.Audio audio = (TLRPC.Audio) attach;
+                if (audio.key != null) {
+                    dir = getInstance().getDirectory(MEDIA_DIR_CACHE);
+                } else {
+                    dir = getInstance().getDirectory(MEDIA_DIR_AUDIO);
+                }
+            } else if (attach instanceof TLRPC.FileLocation) {
+                TLRPC.FileLocation fileLocation = (TLRPC.FileLocation) attach;
+                if (fileLocation.key != null || fileLocation.volume_id == Integer.MIN_VALUE && fileLocation.local_id < 0) {
+                    dir = getInstance().getDirectory(MEDIA_DIR_CACHE);
+                } else {
+                    dir = getInstance().getDirectory(MEDIA_DIR_IMAGE);
+                }
             }
         }
         if (dir == null) {
             return new File("");
         }
-        return new File(dir, getAttachFileName(attach));
+        return new File(dir, getAttachFileName(attach, ext));
     }
 
     public static TLRPC.PhotoSize getClosestPhotoSizeWithSize(ArrayList<TLRPC.PhotoSize> sizes, int side) {
@@ -663,6 +677,9 @@ public static File getPathToAttach(TLObject attach, boolean forceCache) {
 
     public static String getDocumentFileName(TLRPC.Document document) {
         if (document != null) {
+            if (document.file_name != null) {
+                return document.file_name;
+            }
             for (TLRPC.DocumentAttribute documentAttribute : document.attributes) {
                 if (documentAttribute instanceof TLRPC.TL_documentAttributeFilename) {
                     return documentAttribute.file_name;
@@ -673,35 +690,39 @@ public static String getDocumentFileName(TLRPC.Document document) {
     }
 
     public static String getAttachFileName(TLObject attach) {
+        return getAttachFileName(attach, null);
+    }
+
+    public static String getAttachFileName(TLObject attach, String ext) {
         if (attach instanceof TLRPC.Video) {
-            TLRPC.Video video = (TLRPC.Video)attach;
-            return video.dc_id + "_" + video.id + ".mp4";
+            TLRPC.Video video = (TLRPC.Video) attach;
+            return video.dc_id + "_" + video.id + "." + (ext != null ? ext : "mp4");
         } else if (attach instanceof TLRPC.Document) {
-            TLRPC.Document document = (TLRPC.Document)attach;
-            String ext = getDocumentFileName(document);
-            int idx = -1;
-            if (ext == null || (idx = ext.lastIndexOf(".")) == -1) {
-                ext = "";
+            TLRPC.Document document = (TLRPC.Document) attach;
+            String docExt = getDocumentFileName(document);
+            int idx;
+            if (docExt == null || (idx = docExt.lastIndexOf(".")) == -1) {
+                docExt = "";
             } else {
-                ext = ext.substring(idx);
+                docExt = docExt.substring(idx);
             }
-            if (ext.length() > 1) {
-                return document.dc_id + "_" + document.id + ext;
+            if (docExt.length() > 1) {
+                return document.dc_id + "_" + document.id + docExt;
             } else {
                 return document.dc_id + "_" + document.id;
             }
         } else if (attach instanceof TLRPC.PhotoSize) {
-            TLRPC.PhotoSize photo = (TLRPC.PhotoSize)attach;
+            TLRPC.PhotoSize photo = (TLRPC.PhotoSize) attach;
             if (photo.location == null) {
                 return "";
             }
-            return photo.location.volume_id + "_" + photo.location.local_id + "." + (photo.location.ext != null ? photo.location.ext : "jpg");
+            return photo.location.volume_id + "_" + photo.location.local_id + "." + (ext != null ? ext : "jpg");
         } else if (attach instanceof TLRPC.Audio) {
-            TLRPC.Audio audio = (TLRPC.Audio)attach;
-            return audio.dc_id + "_" + audio.id + ".ogg";
+            TLRPC.Audio audio = (TLRPC.Audio) attach;
+            return audio.dc_id + "_" + audio.id + "." + (ext != null ? ext : "ogg");
         } else if (attach instanceof TLRPC.FileLocation) {
-            TLRPC.FileLocation location = (TLRPC.FileLocation)attach;
-            return location.volume_id + "_" + location.local_id + "." + (location.ext != null ? location.ext : "jpg");
+            TLRPC.FileLocation location = (TLRPC.FileLocation) attach;
+            return location.volume_id + "_" + location.local_id + "." + (ext != null ? ext : "jpg");
         }
         return "";
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/FileLog.java b/TMessagesProj/src/main/java/org/telegram/messenger/FileLog.java
index e72408acc..b54bff7a4 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/FileLog.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/FileLog.java
@@ -1,14 +1,13 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
 
-import android.net.Uri;
 import android.util.Log;
 
 import org.telegram.android.time.FastDateFormat;
@@ -16,7 +15,6 @@
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.OutputStreamWriter;
-import java.util.ArrayList;
 import java.util.Locale;
 
 public class FileLog {
@@ -50,14 +48,8 @@ public FileLog() {
                 return;
             }
             File dir = new File(sdCard.getAbsolutePath() + "/logs");
-            if (dir == null) {
-                return;
-            }
             dir.mkdirs();
             currentFile = new File(dir, dateFormat.format(System.currentTimeMillis()) + ".txt");
-            if (currentFile == null) {
-                return;
-            }
         } catch (Exception e) {
             e.printStackTrace();
         }
@@ -181,7 +173,6 @@ public void run() {
     }
 
     public static void cleanupLogs() {
-        ArrayList<Uri> uris = new ArrayList<>();
         File sdCard = ApplicationLoader.applicationContext.getExternalFilesDir(null);
         File dir = new File (sdCard.getAbsolutePath() + "/logs");
         File[] files = dir.listFiles();
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/FileUploadOperation.java b/TMessagesProj/src/main/java/org/telegram/messenger/FileUploadOperation.java
index 788a202a4..1faeda79f 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/FileUploadOperation.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/FileUploadOperation.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -46,7 +46,7 @@
     private boolean started = false;
 
     public interface FileUploadOperationDelegate {
-        void didFinishUploadingFile(FileUploadOperation operation, TLRPC.InputFile inputFile, TLRPC.InputEncryptedFile inputEncryptedFile);
+        void didFinishUploadingFile(FileUploadOperation operation, TLRPC.InputFile inputFile, TLRPC.InputEncryptedFile inputEncryptedFile, byte[] key, byte[] iv);
         void didFailedUploadingFile(FileUploadOperation operation);
         void didChangedUploadProgress(FileUploadOperation operation, float progress);
     }
@@ -190,8 +190,12 @@ private void startUploadRequest() {
                         if (ivString != null && keyString != null) {
                             key = Utilities.hexToBytes(keyString);
                             iv = Utilities.hexToBytes(ivString);
-                            ivChange = new byte[32];
-                            System.arraycopy(iv, 0, ivChange, 0, 32);
+                            if (key != null && iv != null && key.length == 32 && iv.length == 32) {
+                                ivChange = new byte[32];
+                                System.arraycopy(iv, 0, ivChange, 0, 32);
+                            } else {
+                                rewrite = true;
+                            }
                         } else {
                             rewrite = true;
                         }
@@ -234,6 +238,11 @@ private void startUploadRequest() {
                                         String ivcString = preferences.getString(fileKey + "_ivc", null);
                                         if (ivcString != null) {
                                             ivChange = Utilities.hexToBytes(ivcString);
+                                            if (ivChange == null || ivChange.length != 32) {
+                                                rewrite = true;
+                                                currentUploaded = 0;
+                                                currentPartNum = 0;
+                                            }
                                         } else {
                                             rewrite = true;
                                             currentUploaded = 0;
@@ -369,7 +378,7 @@ public void run(TLObject response, TLRPC.TL_error error) {
                                 result.parts = currentPartNum;
                                 result.id = currentFileId;
                                 result.name = uploadingFilePath.substring(uploadingFilePath.lastIndexOf("/") + 1);
-                                delegate.didFinishUploadingFile(FileUploadOperation.this, result, null);
+                                delegate.didFinishUploadingFile(FileUploadOperation.this, result, null, null, null);
                                 cleanup();
                             } else {
                                 TLRPC.InputEncryptedFile result;
@@ -382,9 +391,7 @@ public void run(TLObject response, TLRPC.TL_error error) {
                                 result.parts = currentPartNum;
                                 result.id = currentFileId;
                                 result.key_fingerprint = fingerprint;
-                                result.iv = iv;
-                                result.key = key;
-                                delegate.didFinishUploadingFile(FileUploadOperation.this, null, result);
+                                delegate.didFinishUploadingFile(FileUploadOperation.this, null, result, key, iv);
                                 cleanup();
                             }
                         } else {
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/HandshakeAction.java b/TMessagesProj/src/main/java/org/telegram/messenger/HandshakeAction.java
index cf64c98e0..eb225c09c 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/HandshakeAction.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/HandshakeAction.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/MessageKeyData.java b/TMessagesProj/src/main/java/org/telegram/messenger/MessageKeyData.java
index 6aef7a298..669f3a029 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/MessageKeyData.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/MessageKeyData.java
@@ -1,14 +1,68 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
 
 public class MessageKeyData {
+
     public byte[] aesKey;
     public byte[] aesIv;
+
+    public static MessageKeyData generateMessageKeyData(byte[] authKey, byte[] messageKey, boolean incoming) {
+        MessageKeyData keyData = new MessageKeyData();
+        if (authKey == null || authKey.length == 0) {
+            keyData.aesIv = null;
+            keyData.aesKey = null;
+            return keyData;
+        }
+
+        int x = incoming ? 8 : 0;
+
+        SerializedData data = new SerializedData();
+        data.writeRaw(messageKey);
+        data.writeRaw(authKey, x, 32);
+        byte[] sha1_a = Utilities.computeSHA1(data.toByteArray());
+        data.cleanup();
+
+        data = new SerializedData();
+        data.writeRaw(authKey, 32 + x, 16);
+        data.writeRaw(messageKey);
+        data.writeRaw(authKey, 48 + x, 16);
+        byte[] sha1_b = Utilities.computeSHA1(data.toByteArray());
+        data.cleanup();
+
+        data = new SerializedData();
+        data.writeRaw(authKey, 64 + x, 32);
+        data.writeRaw(messageKey);
+        byte[] sha1_c = Utilities.computeSHA1(data.toByteArray());
+        data.cleanup();
+
+        data = new SerializedData();
+        data.writeRaw(messageKey);
+        data.writeRaw(authKey, 96 + x, 32);
+        byte[] sha1_d = Utilities.computeSHA1(data.toByteArray());
+        data.cleanup();
+
+        data = new SerializedData();
+        data.writeRaw(sha1_a, 0, 8);
+        data.writeRaw(sha1_b, 8, 12);
+        data.writeRaw(sha1_c, 4, 12);
+        keyData.aesKey = data.toByteArray();
+        data.cleanup();
+
+        data = new SerializedData();
+        data.writeRaw(sha1_a, 8, 12);
+        data.writeRaw(sha1_b, 0, 8);
+        data.writeRaw(sha1_c, 16, 4);
+        data.writeRaw(sha1_d, 0, 8);
+        keyData.aesIv = data.toByteArray();
+        data.cleanup();
+
+        return keyData;
+    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/NetworkMessage.java b/TMessagesProj/src/main/java/org/telegram/messenger/NetworkMessage.java
index a44ef7664..67cd93cf4 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/NetworkMessage.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/NetworkMessage.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/RPCRequest.java b/TMessagesProj/src/main/java/org/telegram/messenger/RPCRequest.java
index 180c9446b..63dd660f4 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/RPCRequest.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/RPCRequest.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/SerializedData.java b/TMessagesProj/src/main/java/org/telegram/messenger/SerializedData.java
index f01309425..d23048322 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/SerializedData.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/SerializedData.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ServerSalt.java b/TMessagesProj/src/main/java/org/telegram/messenger/ServerSalt.java
index 33ca53ea2..88aa01958 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ServerSalt.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ServerSalt.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/TLClassStore.java b/TMessagesProj/src/main/java/org/telegram/messenger/TLClassStore.java
index 8b433f284..1c855859e 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/TLClassStore.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/TLClassStore.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -13,7 +13,7 @@
 public class TLClassStore {
     private HashMap<Integer, Class> classStore;
 
-    public TLClassStore () {
+    public TLClassStore() {
         classStore = new HashMap<>();
 
         classStore.put(TLRPC.TL_futuresalts.constructor, TLRPC.TL_futuresalts.class);
@@ -108,26 +108,18 @@ public static TLClassStore Instance() {
     }
 
     public TLObject TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-        try {
-            return TLdeserialize(stream, constructor, null, exception);
-        } catch (Exception e) {
-            return null;
-        }
-    }
-
-    public TLObject TLdeserialize(AbsSerializedData stream, int constructor, TLObject request, boolean exception) {
         Class objClass = classStore.get(constructor);
         if (objClass != null) {
+            TLObject response;
             try {
-                TLObject response = (TLObject)objClass.newInstance();
-                response.readParams(stream, exception);
-                return response;
+                response = (TLObject) objClass.newInstance();
             } catch (Throwable e) {
-                FileLog.e("tmessages", "can't create class");
+                FileLog.e("tmessages", e);
                 return null;
             }
-        } else {
-            return null;
+            response.readParams(stream, exception);
+            return response;
         }
+        return null;
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/TLObject.java b/TMessagesProj/src/main/java/org/telegram/messenger/TLObject.java
index 17c493070..12cb748fe 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/TLObject.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/TLObject.java
@@ -1,14 +1,15 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
 
 public class TLObject {
+
     public boolean disableFree = false;
 
     public TLObject() {
@@ -19,10 +20,6 @@ public void readParams(AbsSerializedData stream, boolean exception) {
 
     }
 
-    public byte[] serialize() {
-        return null;
-    }
-
     public void serializeToStream(AbsSerializedData stream) {
 
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/TLRPC.java b/TMessagesProj/src/main/java/org/telegram/messenger/TLRPC.java
index cd093459a..32d39df40 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/TLRPC.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/TLRPC.java
@@ -1,15 +1,14 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
 
 import java.util.ArrayList;
-import java.util.Locale;
 
 @SuppressWarnings("unchecked")
 public class TLRPC {
@@ -20,7 +19,7 @@
     public static final int MESSAGE_FLAG_REPLY = 8;
     public static final int MESSAGE_FLAG_MENTION = 16;
     public static final int MESSAGE_FLAG_CONTENT_UNREAD = 32;
-    public static final int LAYER = 28;
+    public static final int LAYER = 30;
 
     public static class TL_inputEncryptedChat extends TLObject {
         public static int constructor = 0xf141b5e1;
@@ -247,6 +246,39 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class InputEncryptedFile extends TLObject {
+        public long id;
+        public long access_hash;
+        public int parts;
+        public int key_fingerprint;
+        public String md5_checksum;
+
+        public static InputEncryptedFile TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            InputEncryptedFile result = null;
+            switch(constructor) {
+                case 0x5a17b5e5:
+                    result = new TL_inputEncryptedFile();
+                    break;
+                case 0x2dc173c8:
+                    result = new TL_inputEncryptedFileBigUploaded();
+                    break;
+                case 0x1837c364:
+                    result = new TL_inputEncryptedFileEmpty();
+                    break;
+                case 0x64bd0306:
+                    result = new TL_inputEncryptedFileUploaded();
+                    break;
+            }
+            if (result == null && exception) {
+                throw new RuntimeException(String.format("can't parse magic %x in InputEncryptedFile", constructor));
+            }
+            if (result != null) {
+                result.readParams(stream, exception);
+            }
+            return result;
+        }
+    }
+
     public static class TL_inputEncryptedFile extends InputEncryptedFile {
         public static int constructor = 0x5a17b5e5;
 
@@ -482,9 +514,24 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class TL_messageEmpty extends Message {
+        public static int constructor = 0x83e5de54;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt32(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt32(id);
+        }
+    }
+
     public static class TL_messageService extends Message {
         public static int constructor = 0x1d86f70e;
 
+
         public void readParams(AbsSerializedData stream, boolean exception) {
             flags = stream.readInt32(exception);
             id = stream.readInt32(exception);
@@ -505,17 +552,75 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_messageEmpty extends Message {
-        public static int constructor = 0x83e5de54;
+    public static class TL_messages_stickerSet extends TLObject {
+        public static int constructor = 0xb60a24a6;
+
+        public TL_stickerSet set;
+        public ArrayList<TL_stickerPack> packs = new ArrayList<>();
+        public ArrayList<Document> documents = new ArrayList<>();
 
+        public static TL_messages_stickerSet TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            if (TL_messages_stickerSet.constructor != constructor) {
+                if (exception) {
+                    throw new RuntimeException(String.format("can't parse magic %x in TL_messages_stickerSet", constructor));
+                } else {
+                    return null;
+                }
+            }
+            TL_messages_stickerSet result = new TL_messages_stickerSet();
+            result.readParams(stream, exception);
+            return result;
+        }
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
+            set = TL_stickerSet.TLdeserialize(stream, stream.readInt32(exception), exception);
+            int magic = stream.readInt32(exception);
+            if (magic != 0x1cb5c415) {
+                if (exception) {
+                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+                }
+                return;
+            }
+            int count = stream.readInt32(exception);
+            for (int a = 0; a < count; a++) {
+                TL_stickerPack object = TL_stickerPack.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                packs.add(object);
+            }
+            magic = stream.readInt32(exception);
+            if (magic != 0x1cb5c415) {
+                if (exception) {
+                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+                }
+                return;
+            }
+            count = stream.readInt32(exception);
+            for (int a = 0; a < count; a++) {
+                Document object = Document.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                documents.add(object);
+            }
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            stream.writeInt32(id);
+            set.serializeToStream(stream);
+            stream.writeInt32(0x1cb5c415);
+            int count = packs.size();
+            stream.writeInt32(count);
+            for (int a = 0; a < count; a++) {
+                packs.get(a).serializeToStream(stream);
+            }
+            stream.writeInt32(0x1cb5c415);
+            count = documents.size();
+            stream.writeInt32(count);
+            for (int a = 0; a < count; a++) {
+                documents.get(a).serializeToStream(stream);
+            }
         }
     }
 
@@ -823,7 +928,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                attributes.add(DocumentAttribute.TLdeserialize(stream, stream.readInt32(exception), exception));
+                DocumentAttribute object = DocumentAttribute.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                attributes.add(object);
             }
         }
 
@@ -1029,7 +1138,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                attributes.add(DocumentAttribute.TLdeserialize(stream, stream.readInt32(exception), exception));
+                DocumentAttribute object = DocumentAttribute.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                attributes.add(object);
             }
         }
 
@@ -1095,7 +1208,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                chats.add(Chat.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                chats.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -1106,7 +1223,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
             seq = stream.readInt32(exception);
         }
@@ -1171,7 +1292,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                dialogs.add(TL_dialog.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_dialog object = TL_dialog.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                dialogs.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -1182,7 +1307,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                messages.add(Message.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Message object = Message.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                messages.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -1193,7 +1322,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                chats.add(Chat.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                chats.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -1204,7 +1337,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -1252,7 +1389,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                dialogs.add(TL_dialog.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_dialog object = TL_dialog.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                dialogs.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -1263,7 +1404,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                messages.add(Message.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Message object = Message.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                messages.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -1274,7 +1419,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                chats.add(Chat.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                chats.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -1285,7 +1434,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -1411,7 +1564,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(InputUser.TLdeserialize(stream, stream.readInt32(exception), exception));
+                InputUser object = InputUser.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -1476,7 +1633,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(InputUser.TLdeserialize(stream, stream.readInt32(exception), exception));
+                InputUser object = InputUser.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -1564,7 +1725,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                photos.add(Photo.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Photo object = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                photos.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -1575,7 +1740,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -1611,7 +1780,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                photos.add(Photo.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Photo object = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                photos.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -1622,7 +1795,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -1687,6 +1864,55 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class UserStatus extends TLObject {
+        public int expires;
+
+        public static UserStatus TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            UserStatus result = null;
+            switch(constructor) {
+                case 0x8c703f:
+                    result = new TL_userStatusOffline();
+                    break;
+                case 0x7bf09fc:
+                    result = new TL_userStatusLastWeek();
+                    break;
+                case 0x9d05049:
+                    result = new TL_userStatusEmpty();
+                    break;
+                case 0x77ebc742:
+                    result = new TL_userStatusLastMonth();
+                    break;
+                case 0xedb93949:
+                    result = new TL_userStatusOnline();
+                    break;
+                case 0xe26f42f1:
+                    result = new TL_userStatusRecently();
+                    break;
+            }
+            if (result == null && exception) {
+                throw new RuntimeException(String.format("can't parse magic %x in UserStatus", constructor));
+            }
+            if (result != null) {
+                result.readParams(stream, exception);
+            }
+            return result;
+        }
+    }
+
+    public static class TL_userStatusOffline extends UserStatus {
+        public static int constructor = 0x8c703f;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            expires = stream.readInt32(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt32(expires);
+        }
+    }
+
     public static class TL_userStatusLastWeek extends UserStatus {
         public static int constructor = 0x7bf09fc;
 
@@ -2011,7 +2237,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                participants.add(TL_chatParticipant.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_chatParticipant object = TL_chatParticipant.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                participants.add(object);
             }
             version = stream.readInt32(exception);
         }
@@ -2072,6 +2302,40 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class DecryptedMessage extends TLObject {
+        public long random_id;
+        public DecryptedMessageAction action;
+        public byte[] random_bytes;
+        public String message;
+        public DecryptedMessageMedia media;
+        public int ttl;
+
+        public static DecryptedMessage TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            DecryptedMessage result = null;
+            switch(constructor) {
+                case 0x73164160:
+                    result = new TL_decryptedMessageService();
+                    break;
+                case 0x1f814f1f:
+                    result = new TL_decryptedMessage_old();
+                    break;
+                case 0x204d3878:
+                    result = new TL_decryptedMessage();
+                    break;
+                case 0xaa48327d:
+                    result = new TL_decryptedMessageService_old();
+                    break;
+            }
+            if (result == null && exception) {
+                throw new RuntimeException(String.format("can't parse magic %x in DecryptedMessage", constructor));
+            }
+            if (result != null) {
+                result.readParams(stream, exception);
+            }
+            return result;
+        }
+    }
+
     public static class TL_decryptedMessageService extends DecryptedMessage {
         public static int constructor = 0x73164160;
 
@@ -2088,6 +2352,26 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class TL_decryptedMessage_old extends TL_decryptedMessage {
+        public static int constructor = 0x1f814f1f;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            random_id = stream.readInt64(exception);
+            random_bytes = stream.readByteArray(exception);
+            message = stream.readString(exception);
+            media = DecryptedMessageMedia.TLdeserialize(stream, stream.readInt32(exception), exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt64(random_id);
+            stream.writeByteArray(random_bytes);
+            stream.writeString(message);
+            media.serializeToStream(stream);
+        }
+    }
+
     public static class TL_decryptedMessage extends DecryptedMessage {
         public static int constructor = 0x204d3878;
 
@@ -2108,6 +2392,24 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class TL_decryptedMessageService_old extends TL_decryptedMessageService {
+        public static int constructor = 0xaa48327d;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            random_id = stream.readInt64(exception);
+            random_bytes = stream.readByteArray(exception);
+            action = DecryptedMessageAction.TLdeserialize(stream, stream.readInt32(exception), exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt64(random_id);
+            stream.writeByteArray(random_bytes);
+            action.serializeToStream(stream);
+        }
+    }
+
     public static class messages_Messages extends TLObject {
         public ArrayList<Message> messages = new ArrayList<>();
         public ArrayList<Chat> chats = new ArrayList<>();
@@ -2148,7 +2450,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                messages.add(Message.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Message object = Message.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                messages.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -2159,7 +2465,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                chats.add(Chat.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                chats.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -2170,7 +2480,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -2212,7 +2526,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                messages.add(Message.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Message object = Message.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                messages.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -2223,7 +2541,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                chats.add(Chat.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                chats.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -2234,7 +2556,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -2326,21 +2652,98 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_decryptedMessageMediaDocument extends DecryptedMessageMedia {
-        public static int constructor = 0xb095434b;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            thumb = stream.readByteArray(exception);
-            thumb_w = stream.readInt32(exception);
-            thumb_h = stream.readInt32(exception);
-            file_name = stream.readString(exception);
-            mime_type = stream.readString(exception);
-            size = stream.readInt32(exception);
-            key = stream.readByteArray(exception);
-            iv = stream.readByteArray(exception);
-        }
-
+    public static class DecryptedMessageMedia extends TLObject {
+        public int thumb_w;
+        public int thumb_h;
+        public String file_name;
+        public String mime_type;
+        public int size;
+        public byte[] key;
+        public byte[] iv;
+        public long id;
+        public long access_hash;
+        public int date;
+        public int dc_id;
+        public ArrayList<DocumentAttribute> attributes = new ArrayList<>();
+        public int duration;
+        public double lat;
+        public double _long;
+        public int w;
+        public int h;
+        public String phone_number;
+        public String first_name;
+        public String last_name;
+        public int user_id;
+
+        public static DecryptedMessageMedia TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            DecryptedMessageMedia result = null;
+            switch(constructor) {
+                case 0x89f5c4a:
+                    result = new TL_decryptedMessageMediaEmpty();
+                    break;
+                case 0xb095434b:
+                    result = new TL_decryptedMessageMediaDocument();
+                    break;
+                case 0xfa95b0dd:
+                    result = new TL_decryptedMessageMediaExternalDocument();
+                    break;
+                case 0x6080758f:
+                    result = new TL_decryptedMessageMediaAudio_old();
+                    break;
+                case 0x35480a59:
+                    result = new TL_decryptedMessageMediaGeoPoint();
+                    break;
+                case 0x57e0a9cb:
+                    result = new TL_decryptedMessageMediaAudio();
+                    break;
+                case 0x524a415d:
+                    result = new TL_decryptedMessageMediaVideo();
+                    break;
+                case 0x588a0a97:
+                    result = new TL_decryptedMessageMediaContact();
+                    break;
+                case 0x32798a8c:
+                    result = new TL_decryptedMessageMediaPhoto();
+                    break;
+                case 0x4cee6ef3:
+                    result = new TL_decryptedMessageMediaVideo_old();
+                    break;
+            }
+            if (result == null && exception) {
+                throw new RuntimeException(String.format("can't parse magic %x in DecryptedMessageMedia", constructor));
+            }
+            if (result != null) {
+                result.readParams(stream, exception);
+            }
+            return result;
+        }
+    }
+
+    public static class TL_decryptedMessageMediaEmpty extends DecryptedMessageMedia {
+        public static int constructor = 0x89f5c4a;
+
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+        }
+    }
+
+    public static class TL_decryptedMessageMediaDocument extends DecryptedMessageMedia {
+        public static int constructor = 0xb095434b;
+
+        public byte[] thumb;
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            thumb = stream.readByteArray(exception);
+            thumb_w = stream.readInt32(exception);
+            thumb_h = stream.readInt32(exception);
+            file_name = stream.readString(exception);
+            mime_type = stream.readString(exception);
+            size = stream.readInt32(exception);
+            key = stream.readByteArray(exception);
+            iv = stream.readByteArray(exception);
+        }
+
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
             stream.writeByteArray(thumb);
@@ -2354,6 +2757,74 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class TL_decryptedMessageMediaExternalDocument extends DecryptedMessageMedia {
+        public static int constructor = 0xfa95b0dd;
+
+        public PhotoSize thumb;
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt64(exception);
+            access_hash = stream.readInt64(exception);
+            date = stream.readInt32(exception);
+            mime_type = stream.readString(exception);
+            size = stream.readInt32(exception);
+            thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
+            dc_id = stream.readInt32(exception);
+            int magic = stream.readInt32(exception);
+            if (magic != 0x1cb5c415) {
+                if (exception) {
+                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+                }
+                return;
+            }
+            int count = stream.readInt32(exception);
+            for (int a = 0; a < count; a++) {
+                DocumentAttribute object = DocumentAttribute.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                attributes.add(object);
+            }
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt64(id);
+            stream.writeInt64(access_hash);
+            stream.writeInt32(date);
+            stream.writeString(mime_type);
+            stream.writeInt32(size);
+            thumb.serializeToStream(stream);
+            stream.writeInt32(dc_id);
+            stream.writeInt32(0x1cb5c415);
+            int count = attributes.size();
+            stream.writeInt32(count);
+            for (int a = 0; a < count; a++) {
+                attributes.get(a).serializeToStream(stream);
+            }
+        }
+    }
+
+    public static class TL_decryptedMessageMediaAudio_old extends TL_decryptedMessageMediaAudio {
+        public static int constructor = 0x6080758f;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            duration = stream.readInt32(exception);
+            size = stream.readInt32(exception);
+            key = stream.readByteArray(exception);
+            iv = stream.readByteArray(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt32(duration);
+            stream.writeInt32(size);
+            stream.writeByteArray(key);
+            stream.writeByteArray(iv);
+        }
+    }
+
     public static class TL_decryptedMessageMediaGeoPoint extends DecryptedMessageMedia {
         public static int constructor = 0x35480a59;
 
@@ -2395,6 +2866,7 @@ public void serializeToStream(AbsSerializedData stream) {
     public static class TL_decryptedMessageMediaVideo extends DecryptedMessageMedia {
         public static int constructor = 0x524a415d;
 
+        public byte[] thumb;
 
         public void readParams(AbsSerializedData stream, boolean exception) {
             thumb = stream.readByteArray(exception);
@@ -2444,23 +2916,45 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_decryptedMessageMediaEmpty extends DecryptedMessageMedia {
-        public static int constructor = 0x89f5c4a;
+    public static class TL_decryptedMessageMediaPhoto extends DecryptedMessageMedia {
+        public static int constructor = 0x32798a8c;
+
+        public byte[] thumb;
 
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            thumb = stream.readByteArray(exception);
+            thumb_w = stream.readInt32(exception);
+            thumb_h = stream.readInt32(exception);
+            w = stream.readInt32(exception);
+            h = stream.readInt32(exception);
+            size = stream.readInt32(exception);
+            key = stream.readByteArray(exception);
+            iv = stream.readByteArray(exception);
+        }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
+            stream.writeByteArray(thumb);
+            stream.writeInt32(thumb_w);
+            stream.writeInt32(thumb_h);
+            stream.writeInt32(w);
+            stream.writeInt32(h);
+            stream.writeInt32(size);
+            stream.writeByteArray(key);
+            stream.writeByteArray(iv);
         }
     }
 
-    public static class TL_decryptedMessageMediaPhoto extends DecryptedMessageMedia {
-        public static int constructor = 0x32798a8c;
+    public static class TL_decryptedMessageMediaVideo_old extends TL_decryptedMessageMediaVideo {
+        public static int constructor = 0x4cee6ef3;
 
+        public byte[] thumb;
 
         public void readParams(AbsSerializedData stream, boolean exception) {
             thumb = stream.readByteArray(exception);
             thumb_w = stream.readInt32(exception);
             thumb_h = stream.readInt32(exception);
+            duration = stream.readInt32(exception);
             w = stream.readInt32(exception);
             h = stream.readInt32(exception);
             size = stream.readInt32(exception);
@@ -2473,6 +2967,7 @@ public void serializeToStream(AbsSerializedData stream) {
             stream.writeByteArray(thumb);
             stream.writeInt32(thumb_w);
             stream.writeInt32(thumb_h);
+            stream.writeInt32(duration);
             stream.writeInt32(w);
             stream.writeInt32(h);
             stream.writeInt32(size);
@@ -2481,15 +2976,75 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_userContact extends User {
-        public static int constructor = 0xcab35e18;
+    public static class User extends TLObject {
+        public int id;
+        public String first_name;
+        public String last_name;
+        public long access_hash;
+        public String phone;
+        public UserProfilePhoto photo;
+        public UserStatus status;
+        public boolean inactive;
+        public String username;
+
+        public static User TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            User result = null;
+            switch(constructor) {
+                case 0xf2fb8319:
+                    result = new TL_userContact_old();
+                    break;
+                case 0x720535ec:
+                    result = new TL_userSelf_old();
+                    break;
+                case 0xcab35e18:
+                    result = new TL_userContact();
+                    break;
+                case 0x1c60e608:
+                    result = new TL_userSelf();
+                    break;
+                case 0x75cf7a8:
+                    result = new TL_userForeign();
+                    break;
+                case 0x200250ba:
+                    result = new TL_userEmpty();
+                    break;
+                case 0x22e8ceb0:
+                    result = new TL_userRequest_old();
+                    break;
+                case 0x5214c89d:
+                    result = new TL_userForeign_old();
+                    break;
+                case 0xd9ccc4ef:
+                    result = new TL_userRequest();
+                    break;
+                case 0x7007b451:
+                    result = new TL_userSelf_old2();
+                    break;
+                case 0xb29ad7cc:
+                    result = new TL_userDeleted_old();
+                    break;
+                case 0xd6016d7a:
+                    result = new TL_userDeleted();
+                    break;
+            }
+            if (result == null && exception) {
+                throw new RuntimeException(String.format("can't parse magic %x in User", constructor));
+            }
+            if (result != null) {
+                result.readParams(stream, exception);
+            }
+            return result;
+        }
+    }
+
+    public static class TL_userContact_old extends TL_userContact {
+        public static int constructor = 0xf2fb8319;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
             id = stream.readInt32(exception);
             first_name = stream.readString(exception);
             last_name = stream.readString(exception);
-            username = stream.readString(exception);
             access_hash = stream.readInt64(exception);
             phone = stream.readString(exception);
             photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
@@ -2501,7 +3056,6 @@ public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(id);
             stream.writeString(first_name);
             stream.writeString(last_name);
-            stream.writeString(username);
             stream.writeInt64(access_hash);
             stream.writeString(phone);
             photo.serializeToStream(stream);
@@ -2509,19 +3063,18 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_userRequest extends User {
-        public static int constructor = 0xd9ccc4ef;
+    public static class TL_userSelf_old extends TL_userSelf {
+        public static int constructor = 0x720535ec;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
             id = stream.readInt32(exception);
             first_name = stream.readString(exception);
             last_name = stream.readString(exception);
-            username = stream.readString(exception);
-            access_hash = stream.readInt64(exception);
             phone = stream.readString(exception);
             photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
             status = UserStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
+            inactive = stream.readBool(exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
@@ -2529,16 +3082,15 @@ public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(id);
             stream.writeString(first_name);
             stream.writeString(last_name);
-            stream.writeString(username);
-            stream.writeInt64(access_hash);
             stream.writeString(phone);
             photo.serializeToStream(stream);
             status.serializeToStream(stream);
+            stream.writeBool(inactive);
         }
     }
 
-    public static class TL_userForeign extends User {
-        public static int constructor = 0x75cf7a8;
+    public static class TL_userContact extends User {
+        public static int constructor = 0xcab35e18;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
@@ -2547,6 +3099,7 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             last_name = stream.readString(exception);
             username = stream.readString(exception);
             access_hash = stream.readInt64(exception);
+            phone = stream.readString(exception);
             photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
             status = UserStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
         }
@@ -2558,13 +3111,14 @@ public void serializeToStream(AbsSerializedData stream) {
             stream.writeString(last_name);
             stream.writeString(username);
             stream.writeInt64(access_hash);
+            stream.writeString(phone);
             photo.serializeToStream(stream);
             status.serializeToStream(stream);
         }
     }
 
-    public static class TL_userDeleted extends User {
-        public static int constructor = 0xd6016d7a;
+    public static class TL_userSelf extends User {
+        public static int constructor = 0x1c60e608;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
@@ -2572,6 +3126,9 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             first_name = stream.readString(exception);
             last_name = stream.readString(exception);
             username = stream.readString(exception);
+            phone = stream.readString(exception);
+            photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
+            status = UserStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
@@ -2580,11 +3137,14 @@ public void serializeToStream(AbsSerializedData stream) {
             stream.writeString(first_name);
             stream.writeString(last_name);
             stream.writeString(username);
+            stream.writeString(phone);
+            photo.serializeToStream(stream);
+            status.serializeToStream(stream);
         }
     }
 
-    public static class TL_userSelf extends User {
-        public static int constructor = 0x1c60e608;
+    public static class TL_userForeign extends User {
+        public static int constructor = 0x75cf7a8;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
@@ -2592,7 +3152,7 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             first_name = stream.readString(exception);
             last_name = stream.readString(exception);
             username = stream.readString(exception);
-            phone = stream.readString(exception);
+            access_hash = stream.readInt64(exception);
             photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
             status = UserStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
         }
@@ -2603,148 +3163,282 @@ public void serializeToStream(AbsSerializedData stream) {
             stream.writeString(first_name);
             stream.writeString(last_name);
             stream.writeString(username);
+            stream.writeInt64(access_hash);
+            photo.serializeToStream(stream);
+            status.serializeToStream(stream);
+        }
+    }
+
+    public static class TL_userRequest_old extends TL_userRequest {
+        public static int constructor = 0x22e8ceb0;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt32(exception);
+            first_name = stream.readString(exception);
+            last_name = stream.readString(exception);
+            access_hash = stream.readInt64(exception);
+            phone = stream.readString(exception);
+            photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
+            status = UserStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt32(id);
+            stream.writeString(first_name);
+            stream.writeString(last_name);
+            stream.writeInt64(access_hash);
             stream.writeString(phone);
             photo.serializeToStream(stream);
             status.serializeToStream(stream);
         }
     }
 
-    public static class TL_messageMediaVideo extends MessageMedia {
-        public static int constructor = 0x5bcf1675;
+    public static class TL_userForeign_old extends TL_userForeign {
+        public static int constructor = 0x5214c89d;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            video = Video.TLdeserialize(stream, stream.readInt32(exception), exception);
-            caption = stream.readString(exception);
+            id = stream.readInt32(exception);
+            first_name = stream.readString(exception);
+            last_name = stream.readString(exception);
+            access_hash = stream.readInt64(exception);
+            photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
+            status = UserStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            video.serializeToStream(stream);
-            stream.writeString(caption);
+            stream.writeInt32(id);
+            stream.writeString(first_name);
+            stream.writeString(last_name);
+            stream.writeInt64(access_hash);
+            photo.serializeToStream(stream);
+            status.serializeToStream(stream);
         }
     }
 
-    public static class TL_messageMediaPhoto extends MessageMedia {
-        public static int constructor = 0x3d8ce53d;
+    public static class TL_userRequest extends User {
+        public static int constructor = 0xd9ccc4ef;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            photo = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
-            caption = stream.readString(exception);
+            id = stream.readInt32(exception);
+            first_name = stream.readString(exception);
+            last_name = stream.readString(exception);
+            username = stream.readString(exception);
+            access_hash = stream.readInt64(exception);
+            phone = stream.readString(exception);
+            photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
+            status = UserStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
+            stream.writeInt32(id);
+            stream.writeString(first_name);
+            stream.writeString(last_name);
+            stream.writeString(username);
+            stream.writeInt64(access_hash);
+            stream.writeString(phone);
             photo.serializeToStream(stream);
-            stream.writeString(caption);
+            status.serializeToStream(stream);
         }
     }
 
-    public static class TL_messageMediaWebPage extends MessageMedia {
-        public static int constructor = 0xa32dd600;
+    public static class TL_userSelf_old2 extends TL_userSelf {
+        public static int constructor = 0x7007b451;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            webpage = WebPage.TLdeserialize(stream, stream.readInt32(exception), exception);
+            id = stream.readInt32(exception);
+            first_name = stream.readString(exception);
+            last_name = stream.readString(exception);
+            username = stream.readString(exception);
+            phone = stream.readString(exception);
+            photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
+            status = UserStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
+            inactive = stream.readBool(exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            webpage.serializeToStream(stream);
+            stream.writeInt32(id);
+            stream.writeString(first_name);
+            stream.writeString(last_name);
+            stream.writeString(username);
+            stream.writeString(phone);
+            photo.serializeToStream(stream);
+            status.serializeToStream(stream);
+            stream.writeBool(inactive);
         }
     }
 
-    public static class TL_messageMediaDocument extends MessageMedia {
-        public static int constructor = 0x2fda2204;
+    public static class TL_userDeleted_old extends TL_userDeleted {
+        public static int constructor = 0xb29ad7cc;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            document = Document.TLdeserialize(stream, stream.readInt32(exception), exception);
+            id = stream.readInt32(exception);
+            first_name = stream.readString(exception);
+            last_name = stream.readString(exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            document.serializeToStream(stream);
+            stream.writeInt32(id);
+            stream.writeString(first_name);
+            stream.writeString(last_name);
         }
     }
 
-    public static class TL_messageMediaGeo extends MessageMedia {
-        public static int constructor = 0x56e0d474;
+    public static class TL_userDeleted extends User {
+        public static int constructor = 0xd6016d7a;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            geo = GeoPoint.TLdeserialize(stream, stream.readInt32(exception), exception);
+            id = stream.readInt32(exception);
+            first_name = stream.readString(exception);
+            last_name = stream.readString(exception);
+            username = stream.readString(exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            geo.serializeToStream(stream);
+            stream.writeInt32(id);
+            stream.writeString(first_name);
+            stream.writeString(last_name);
+            stream.writeString(username);
         }
     }
 
-    public static class TL_messageMediaEmpty extends MessageMedia {
-        public static int constructor = 0x3ded6320;
+    public static class MessageMedia extends TLObject {
+        public byte[] bytes;
+        public Video video;
+        public String caption;
+        public Photo photo;
+        public Audio audio;
+        public GeoPoint geo;
+        public String title;
+        public String address;
+        public String provider;
+        public String venue_id;
+        public Document document;
+        public String phone_number;
+        public String first_name;
+        public String last_name;
+        public int user_id;
+        public WebPage webpage;
+
+        public static MessageMedia TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            MessageMedia result = null;
+            switch(constructor) {
+                case 0x29632a36:
+                    result = new TL_messageMediaUnsupported_old();
+                    break;
+                case 0x5bcf1675:
+                    result = new TL_messageMediaVideo();
+                    break;
+                case 0xc8c45a2a:
+                    result = new TL_messageMediaPhoto_old();
+                    break;
+                case 0xc6b68300:
+                    result = new TL_messageMediaAudio();
+                    break;
+                case 0x9f84f49e:
+                    result = new TL_messageMediaUnsupported();
+                    break;
+                case 0x3ded6320:
+                    result = new TL_messageMediaEmpty();
+                    break;
+                case 0x7912b71f:
+                    result = new TL_messageMediaVenue();
+                    break;
+                case 0xa2d24290:
+                    result = new TL_messageMediaVideo_old();
+                    break;
+                case 0x2fda2204:
+                    result = new TL_messageMediaDocument();
+                    break;
+                case 0x5e7d2f39:
+                    result = new TL_messageMediaContact();
+                    break;
+                case 0x3d8ce53d:
+                    result = new TL_messageMediaPhoto();
+                    break;
+                case 0xa32dd600:
+                    result = new TL_messageMediaWebPage();
+                    break;
+                case 0x56e0d474:
+                    result = new TL_messageMediaGeo();
+                    break;
+            }
+            if (result == null && exception) {
+                throw new RuntimeException(String.format("can't parse magic %x in MessageMedia", constructor));
+            }
+            if (result != null) {
+                result.readParams(stream, exception);
+            }
+            return result;
+        }
+    }
+
+    public static class TL_messageMediaUnsupported_old extends TL_messageMediaUnsupported {
+        public static int constructor = 0x29632a36;
 
 
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            bytes = stream.readByteArray(exception);
+        }
+
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
+            stream.writeByteArray(bytes);
         }
     }
 
-    public static class TL_messageMediaAudio extends MessageMedia {
-        public static int constructor = 0xc6b68300;
+    public static class TL_messageMediaVideo extends MessageMedia {
+        public static int constructor = 0x5bcf1675;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            audio = Audio.TLdeserialize(stream, stream.readInt32(exception), exception);
+            video = Video.TLdeserialize(stream, stream.readInt32(exception), exception);
+            caption = stream.readString(exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            audio.serializeToStream(stream);
+            video.serializeToStream(stream);
+            stream.writeString(caption);
         }
     }
 
-    public static class TL_messageMediaVenue extends MessageMedia {
-        public static int constructor = 0x7912b71f;
+    public static class TL_messageMediaPhoto_old extends TL_messageMediaPhoto {
+        public static int constructor = 0xc8c45a2a;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            geo = GeoPoint.TLdeserialize(stream, stream.readInt32(exception), exception);
-            title = stream.readString(exception);
-            address = stream.readString(exception);
-            provider = stream.readString(exception);
-            venue_id = stream.readString(exception);
+            photo = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            geo.serializeToStream(stream);
-            stream.writeString(title);
-            stream.writeString(address);
-            stream.writeString(provider);
-            stream.writeString(venue_id);
+            photo.serializeToStream(stream);
         }
     }
 
-    public static class TL_messageMediaContact extends MessageMedia {
-        public static int constructor = 0x5e7d2f39;
+    public static class TL_messageMediaAudio extends MessageMedia {
+        public static int constructor = 0xc6b68300;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            phone_number = stream.readString(exception);
-            first_name = stream.readString(exception);
-            last_name = stream.readString(exception);
-            user_id = stream.readInt32(exception);
+            audio = Audio.TLdeserialize(stream, stream.readInt32(exception), exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            stream.writeString(phone_number);
-            stream.writeString(first_name);
-            stream.writeString(last_name);
-            stream.writeInt32(user_id);
+            audio.serializeToStream(stream);
         }
     }
 
@@ -2757,15 +3451,138 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_nearestDc extends TLObject {
-        public static int constructor = 0x8e1a1775;
+    public static class TL_messageMediaEmpty extends MessageMedia {
+        public static int constructor = 0x3ded6320;
 
-        public String country;
-        public int this_dc;
-        public int nearest_dc;
 
-        public static TL_nearestDc TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            if (TL_nearestDc.constructor != constructor) {
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+        }
+    }
+
+    public static class TL_messageMediaVenue extends MessageMedia {
+        public static int constructor = 0x7912b71f;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            geo = GeoPoint.TLdeserialize(stream, stream.readInt32(exception), exception);
+            title = stream.readString(exception);
+            address = stream.readString(exception);
+            provider = stream.readString(exception);
+            venue_id = stream.readString(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            geo.serializeToStream(stream);
+            stream.writeString(title);
+            stream.writeString(address);
+            stream.writeString(provider);
+            stream.writeString(venue_id);
+        }
+    }
+
+    public static class TL_messageMediaVideo_old extends TL_messageMediaVideo {
+        public static int constructor = 0xa2d24290;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            video = Video.TLdeserialize(stream, stream.readInt32(exception), exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            video.serializeToStream(stream);
+        }
+    }
+
+    public static class TL_messageMediaDocument extends MessageMedia {
+        public static int constructor = 0x2fda2204;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            document = Document.TLdeserialize(stream, stream.readInt32(exception), exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            document.serializeToStream(stream);
+        }
+    }
+
+    public static class TL_messageMediaContact extends MessageMedia {
+        public static int constructor = 0x5e7d2f39;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            phone_number = stream.readString(exception);
+            first_name = stream.readString(exception);
+            last_name = stream.readString(exception);
+            user_id = stream.readInt32(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeString(phone_number);
+            stream.writeString(first_name);
+            stream.writeString(last_name);
+            stream.writeInt32(user_id);
+        }
+    }
+
+    public static class TL_messageMediaPhoto extends MessageMedia {
+        public static int constructor = 0x3d8ce53d;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            photo = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
+            caption = stream.readString(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            photo.serializeToStream(stream);
+            stream.writeString(caption);
+        }
+    }
+
+    public static class TL_messageMediaWebPage extends MessageMedia {
+        public static int constructor = 0xa32dd600;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            webpage = WebPage.TLdeserialize(stream, stream.readInt32(exception), exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            webpage.serializeToStream(stream);
+        }
+    }
+
+    public static class TL_messageMediaGeo extends MessageMedia {
+        public static int constructor = 0x56e0d474;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            geo = GeoPoint.TLdeserialize(stream, stream.readInt32(exception), exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            geo.serializeToStream(stream);
+        }
+    }
+
+    public static class TL_nearestDc extends TLObject {
+        public static int constructor = 0x8e1a1775;
+
+        public String country;
+        public int this_dc;
+        public int nearest_dc;
+
+        public static TL_nearestDc TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            if (TL_nearestDc.constructor != constructor) {
                 if (exception) {
                     throw new RuntimeException(String.format("can't parse magic %x in TL_nearestDc", constructor));
                 } else {
@@ -2882,7 +3699,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                results.add(TL_contactSuggested.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_contactSuggested object = TL_contactSuggested.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                results.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -2893,7 +3714,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -2957,7 +3782,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                sizes.add(PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception));
+                PhotoSize object = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                sizes.add(object);
             }
             color = stream.readInt32(exception);
         }
@@ -3201,7 +4030,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -3361,7 +4194,6 @@ public void serializeToStream(AbsSerializedData stream) {
         public boolean previous;
         public int inviter_id;
         public UserStatus status;
-        public NotifyPeer peer;
 
         public static Update TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
             Update result = null;
@@ -3598,6 +4430,8 @@ public void serializeToStream(AbsSerializedData stream) {
     public static class TL_updateNotifySettings extends Update {
         public static int constructor = 0xbec268ef;
 
+        public NotifyPeer peer;
+
         public void readParams(AbsSerializedData stream, boolean exception) {
             peer = NotifyPeer.TLdeserialize(stream, stream.readInt32(exception), exception);
             notify_settings = PeerNotifySettings.TLdeserialize(stream, stream.readInt32(exception), exception);
@@ -3730,7 +4564,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                dc_options.add(TL_dcOption.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_dcOption object = TL_dcOption.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                dc_options.add(object);
             }
         }
 
@@ -3854,7 +4692,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                rules.add(PrivacyRule.TLdeserialize(stream, stream.readInt32(exception), exception));
+                PrivacyRule object = PrivacyRule.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                rules.add(object);
             }
         }
 
@@ -4074,7 +4916,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                dc_options.add(TL_dcOption.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_dcOption object = TL_dcOption.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                dc_options.add(object);
             }
             chat_size_max = stream.readInt32(exception);
             broadcast_size_max = stream.readInt32(exception);
@@ -4097,7 +4943,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                disabled_features.add(TL_disabledFeature.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_disabledFeature object = TL_disabledFeature.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                disabled_features.add(object);
             }
         }
 
@@ -4402,7 +5252,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                links.add(TL_contacts_link.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_contacts_link object = TL_contacts_link.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                links.add(object);
             }
             seq = stream.readInt32(exception);
         }
@@ -4648,6 +5502,37 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class FileLocation extends TLObject {
+        public int dc_id;
+        public long volume_id;
+        public int local_id;
+        public long secret;
+        public byte[] key;
+        public byte[] iv;
+
+        public static FileLocation TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            FileLocation result = null;
+            switch(constructor) {
+                case 0x53d69076:
+                    result = new TL_fileLocation();
+                    break;
+                case 0x55555554:
+                    result = new TL_fileEncryptedLocation();
+                    break;
+                case 0x7c596b46:
+                    result = new TL_fileLocationUnavailable();
+                    break;
+            }
+            if (result == null && exception) {
+                throw new RuntimeException(String.format("can't parse magic %x in FileLocation", constructor));
+            }
+            if (result != null) {
+                result.readParams(stream, exception);
+            }
+            return result;
+        }
+    }
+
     public static class TL_fileLocation extends FileLocation {
         public static int constructor = 0x53d69076;
 
@@ -4668,6 +5553,30 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class TL_fileEncryptedLocation extends FileLocation {
+        public static int constructor = 0x55555554;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            dc_id = stream.readInt32(exception);
+            volume_id = stream.readInt64(exception);
+            local_id = stream.readInt32(exception);
+            secret = stream.readInt64(exception);
+            key = stream.readByteArray(exception);
+            iv = stream.readByteArray(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt32(dc_id);
+            stream.writeInt64(volume_id);
+            stream.writeInt32(local_id);
+            stream.writeInt64(secret);
+            stream.writeByteArray(key);
+            stream.writeByteArray(iv);
+        }
+    }
+
     public static class TL_fileLocationUnavailable extends FileLocation {
         public static int constructor = 0x7c596b46;
 
@@ -4686,6 +5595,43 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class TL_stickerSet extends TLObject {
+        public static int constructor = 0xa7a43b17;
+
+        public long id;
+        public long access_hash;
+        public String title;
+        public String short_name;
+
+        public static TL_stickerSet TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            if (TL_stickerSet.constructor != constructor) {
+                if (exception) {
+                    throw new RuntimeException(String.format("can't parse magic %x in TL_stickerSet", constructor));
+                } else {
+                    return null;
+                }
+            }
+            TL_stickerSet result = new TL_stickerSet();
+            result.readParams(stream, exception);
+            return result;
+        }
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt64(exception);
+            access_hash = stream.readInt64(exception);
+            title = stream.readString(exception);
+            short_name = stream.readString(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt64(id);
+            stream.writeInt64(access_hash);
+            stream.writeString(title);
+            stream.writeString(short_name);
+        }
+    }
+
     public static class TL_pong extends TLObject {
         public static int constructor = 0x347773c5;
 
@@ -4785,7 +5731,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                chats.add(Chat.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                chats.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -4796,7 +5746,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -5166,10 +6120,10 @@ public void serializeToStream(AbsSerializedData stream) {
     }
 
     public static class TL_dcOption extends TLObject {
-        public static int constructor = 0x2ec2a43c;
+        public static int constructor = 0x5d8c6cc;
 
+        public int flags;
         public int id;
-        public String hostname;
         public String ip_address;
         public int port;
 
@@ -5187,16 +6141,16 @@ public static TL_dcOption TLdeserialize(AbsSerializedData stream, int constructo
         }
 
         public void readParams(AbsSerializedData stream, boolean exception) {
+            flags = stream.readInt32(exception);
             id = stream.readInt32(exception);
-            hostname = stream.readString(exception);
             ip_address = stream.readString(exception);
             port = stream.readInt32(exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
+            stream.writeInt32(flags);
             stream.writeInt32(id);
-            stream.writeString(hostname);
             stream.writeString(ip_address);
             stream.writeInt32(port);
         }
@@ -5521,7 +6475,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                rules.add(PrivacyRule.TLdeserialize(stream, stream.readInt32(exception), exception));
+                PrivacyRule object = PrivacyRule.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                rules.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -5532,7 +6490,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -5791,27 +6753,77 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_photo extends Photo {
-        public static int constructor = 0xc3838076;
-
+    public static class Photo extends TLObject {
+        public long id;
+        public long access_hash;
+        public int user_id;
+        public int date;
+        public GeoPoint geo;
+        public ArrayList<PhotoSize> sizes = new ArrayList<>();
+        public String caption;
 
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt64(exception);
-            access_hash = stream.readInt64(exception);
-            user_id = stream.readInt32(exception);
-            date = stream.readInt32(exception);
-            geo = GeoPoint.TLdeserialize(stream, stream.readInt32(exception), exception);
-            int magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            int count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                sizes.add(PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception));
-            }
+        public static Photo TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            Photo result = null;
+            switch(constructor) {
+                case 0x2331b22d:
+                    result = new TL_photoEmpty();
+                    break;
+                case 0xc3838076:
+                    result = new TL_photo();
+                    break;
+                case 0x22b56751:
+                    result = new TL_photo_old();
+                    break;
+            }
+            if (result == null && exception) {
+                throw new RuntimeException(String.format("can't parse magic %x in Photo", constructor));
+            }
+            if (result != null) {
+                result.readParams(stream, exception);
+            }
+            return result;
+        }
+    }
+
+    public static class TL_photoEmpty extends Photo {
+        public static int constructor = 0x2331b22d;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt64(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt64(id);
+        }
+    }
+
+    public static class TL_photo extends Photo {
+        public static int constructor = 0xc3838076;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt64(exception);
+            access_hash = stream.readInt64(exception);
+            user_id = stream.readInt32(exception);
+            date = stream.readInt32(exception);
+            geo = GeoPoint.TLdeserialize(stream, stream.readInt32(exception), exception);
+            int magic = stream.readInt32(exception);
+            if (magic != 0x1cb5c415) {
+                if (exception) {
+                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+                }
+                return;
+            }
+            int count = stream.readInt32(exception);
+            for (int a = 0; a < count; a++) {
+                PhotoSize object = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                sizes.add(object);
+            }
         }
 
         public void serializeToStream(AbsSerializedData stream) {
@@ -5830,17 +6842,48 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_photoEmpty extends Photo {
-        public static int constructor = 0x2331b22d;
+    public static class TL_photo_old extends TL_photo {
+        public static int constructor = 0x22b56751;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
             id = stream.readInt64(exception);
+            access_hash = stream.readInt64(exception);
+            user_id = stream.readInt32(exception);
+            date = stream.readInt32(exception);
+            caption = stream.readString(exception);
+            geo = GeoPoint.TLdeserialize(stream, stream.readInt32(exception), exception);
+            int magic = stream.readInt32(exception);
+            if (magic != 0x1cb5c415) {
+                if (exception) {
+                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+                }
+                return;
+            }
+            int count = stream.readInt32(exception);
+            for (int a = 0; a < count; a++) {
+                PhotoSize object = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                sizes.add(object);
+            }
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
             stream.writeInt64(id);
+            stream.writeInt64(access_hash);
+            stream.writeInt32(user_id);
+            stream.writeInt32(date);
+            stream.writeString(caption);
+            geo.serializeToStream(stream);
+            stream.writeInt32(0x1cb5c415);
+            int count = sizes.size();
+            stream.writeInt32(count);
+            for (int a = 0; a < count; a++) {
+                sizes.get(a).serializeToStream(stream);
+            }
         }
     }
 
@@ -6183,54 +7226,124 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_messageActionChatEditPhoto extends MessageAction {
-        public static int constructor = 0x7fcb13a8;
-
+    public static class MessageAction extends TLObject {
+        public String title;
+        public String address;
+        public int user_id;
+        public int inviter_id;
+        public DecryptedMessageAction encryptedAction;
+        public int ttl;
+        public UserProfilePhoto newUserPhoto;
+        public Photo photo;
+        public ArrayList<Integer> users = new ArrayList<>();
 
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            photo = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
+        public static MessageAction TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            MessageAction result = null;
+            switch(constructor) {
+                case 0xc7d53de:
+                    result = new TL_messageActionGeoChatCheckin();
+                    break;
+                case 0x55555557:
+                    result = new TL_messageActionCreatedBroadcastList();
+                    break;
+                case 0xb5a1ce5a:
+                    result = new TL_messageActionChatEditTitle();
+                    break;
+                case 0x555555F5:
+                    result = new TL_messageActionLoginUnknownLocation();
+                    break;
+                case 0x5e3cfc4b:
+                    result = new TL_messageActionChatAddUser();
+                    break;
+                case 0xf89cf5e8:
+                    result = new TL_messageActionChatJoinedByLink();
+                    break;
+                case 0x55555550:
+                    result = new TL_messageActionUserJoined();
+                    break;
+                case 0x555555F7:
+                    result = new TL_messageEncryptedAction();
+                    break;
+                case 0x55555552:
+                    result = new TL_messageActionTTLChange();
+                    break;
+                case 0x55555551:
+                    result = new TL_messageActionUserUpdatedPhoto();
+                    break;
+                case 0xb6aef7b0:
+                    result = new TL_messageActionEmpty();
+                    break;
+                case 0x95e3fbef:
+                    result = new TL_messageActionChatDeletePhoto();
+                    break;
+                case 0xb2ae9b0c:
+                    result = new TL_messageActionChatDeleteUser();
+                    break;
+                case 0x7fcb13a8:
+                    result = new TL_messageActionChatEditPhoto();
+                    break;
+                case 0xa6638b9a:
+                    result = new TL_messageActionChatCreate();
+                    break;
+                case 0x6f038ebc:
+                    result = new TL_messageActionGeoChatCreate();
+                    break;
+            }
+            if (result == null && exception) {
+                throw new RuntimeException(String.format("can't parse magic %x in MessageAction", constructor));
+            }
+            if (result != null) {
+                result.readParams(stream, exception);
+            }
+            return result;
         }
+    }
+
+    public static class TL_messageActionGeoChatCheckin extends MessageAction {
+        public static int constructor = 0xc7d53de;
+
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            photo.serializeToStream(stream);
         }
     }
 
-    public static class TL_messageActionChatDeleteUser extends MessageAction {
-        public static int constructor = 0xb2ae9b0c;
-
+    public static class TL_messageActionCreatedBroadcastList extends MessageAction {
+        public static int constructor = 0x55555557;
 
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            user_id = stream.readInt32(exception);
-        }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            stream.writeInt32(user_id);
         }
     }
 
-    public static class TL_messageActionChatJoinedByLink extends MessageAction {
-        public static int constructor = 0xf89cf5e8;
+    public static class TL_messageActionChatEditTitle extends MessageAction {
+        public static int constructor = 0xb5a1ce5a;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            inviter_id = stream.readInt32(exception);
+            title = stream.readString(exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            stream.writeInt32(inviter_id);
+            stream.writeString(title);
         }
     }
 
-    public static class TL_messageActionChatDeletePhoto extends MessageAction {
-        public static int constructor = 0x95e3fbef;
+    public static class TL_messageActionLoginUnknownLocation extends MessageAction {
+        public static int constructor = 0x555555F5;
+
 
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            title = stream.readString(exception);
+            address = stream.readString(exception);
+        }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
+            stream.writeString(title);
+            stream.writeString(address);
         }
     }
 
@@ -6248,39 +7361,22 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_messageActionChatCreate extends MessageAction {
-        public static int constructor = 0xa6638b9a;
+    public static class TL_messageActionChatJoinedByLink extends MessageAction {
+        public static int constructor = 0xf89cf5e8;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            title = stream.readString(exception);
-            int magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            int count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                users.add(stream.readInt32(exception));
-            }
+            inviter_id = stream.readInt32(exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            stream.writeString(title);
-            stream.writeInt32(0x1cb5c415);
-            int count = users.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                stream.writeInt32(users.get(a));
-            }
+            stream.writeInt32(inviter_id);
         }
     }
 
-    public static class TL_messageActionEmpty extends MessageAction {
-        public static int constructor = 0xb6aef7b0;
+    public static class TL_messageActionUserJoined extends MessageAction {
+        public static int constructor = 0x55555550;
 
 
         public void serializeToStream(AbsSerializedData stream) {
@@ -6288,55 +7384,151 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_messageActionChatEditTitle extends MessageAction {
-        public static int constructor = 0xb5a1ce5a;
+    public static class TL_messageEncryptedAction extends MessageAction {
+        public static int constructor = 0x555555F7;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            title = stream.readString(exception);
+            encryptedAction = DecryptedMessageAction.TLdeserialize(stream, stream.readInt32(exception), exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            stream.writeString(title);
+            encryptedAction.serializeToStream(stream);
         }
     }
 
-    public static class TL_messageActionGeoChatCreate extends MessageAction {
-        public static int constructor = 0x6f038ebc;
+    public static class TL_messageActionTTLChange extends MessageAction {
+        public static int constructor = 0x55555552;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            title = stream.readString(exception);
-            address = stream.readString(exception);
+            ttl = stream.readInt32(exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            stream.writeString(title);
-            stream.writeString(address);
+            stream.writeInt32(ttl);
         }
     }
 
-    public static class TL_messageActionGeoChatCheckin extends MessageAction {
-        public static int constructor = 0xc7d53de;
+    public static class TL_messageActionUserUpdatedPhoto extends MessageAction {
+        public static int constructor = 0x55555551;
+
 
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            newUserPhoto = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
+        }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
+            newUserPhoto.serializeToStream(stream);
         }
     }
 
-    public static class DecryptedMessageAction extends TLObject {
-        public int ttl_seconds;
-        public int layer;
-        public ArrayList<Long> random_ids = new ArrayList<>();
-        public long exchange_id;
-        public long key_fingerprint;
-        public SendMessageAction action;
-        public byte[] g_b;
-        public int start_seq_no;
-        public int end_seq_no;
+    public static class TL_messageActionEmpty extends MessageAction {
+        public static int constructor = 0xb6aef7b0;
+
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+        }
+    }
+
+    public static class TL_messageActionChatDeletePhoto extends MessageAction {
+        public static int constructor = 0x95e3fbef;
+
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+        }
+    }
+
+    public static class TL_messageActionChatDeleteUser extends MessageAction {
+        public static int constructor = 0xb2ae9b0c;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            user_id = stream.readInt32(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt32(user_id);
+        }
+    }
+
+    public static class TL_messageActionChatEditPhoto extends MessageAction {
+        public static int constructor = 0x7fcb13a8;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            photo = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            photo.serializeToStream(stream);
+        }
+    }
+
+    public static class TL_messageActionChatCreate extends MessageAction {
+        public static int constructor = 0xa6638b9a;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            title = stream.readString(exception);
+            int magic = stream.readInt32(exception);
+            if (magic != 0x1cb5c415) {
+                if (exception) {
+                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+                }
+                return;
+            }
+            int count = stream.readInt32(exception);
+            for (int a = 0; a < count; a++) {
+                users.add(stream.readInt32(exception));
+            }
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeString(title);
+            stream.writeInt32(0x1cb5c415);
+            int count = users.size();
+            stream.writeInt32(count);
+            for (int a = 0; a < count; a++) {
+                stream.writeInt32(users.get(a));
+            }
+        }
+    }
+
+    public static class TL_messageActionGeoChatCreate extends MessageAction {
+        public static int constructor = 0x6f038ebc;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            title = stream.readString(exception);
+            address = stream.readString(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeString(title);
+            stream.writeString(address);
+        }
+    }
+
+    public static class DecryptedMessageAction extends TLObject {
+        public int ttl_seconds;
+        public int layer;
+        public ArrayList<Long> random_ids = new ArrayList<>();
+        public long exchange_id;
+        public long key_fingerprint;
+        public SendMessageAction action;
+        public byte[] g_b;
+        public int start_seq_no;
+        public int end_seq_no;
         public byte[] g_a;
 
         public static DecryptedMessageAction TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
@@ -6821,17 +8013,21 @@ public void serializeToStream(AbsSerializedData stream) {
     public static class messages_AllStickers extends TLObject {
         public String hash;
         public ArrayList<TL_stickerPack> packs = new ArrayList<>();
+        public ArrayList<TL_stickerSet> sets = new ArrayList<>();
         public ArrayList<Document> documents = new ArrayList<>();
 
         public static messages_AllStickers TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
             messages_AllStickers result = null;
             switch(constructor) {
-                case 0xdcef3102:
+                case 0x5ce352ec:
                     result = new TL_messages_allStickers();
                     break;
                 case 0xe86602c3:
                     result = new TL_messages_allStickersNotModified();
                     break;
+                case 0xdcef3102:
+                    result = new TL_messages_allStickers_old();
+                    break;
             }
             if (result == null && exception) {
                 throw new RuntimeException(String.format("can't parse magic %x in messages_AllStickers", constructor));
@@ -6844,7 +8040,7 @@ public static messages_AllStickers TLdeserialize(AbsSerializedData stream, int c
     }
 
     public static class TL_messages_allStickers extends messages_AllStickers {
-        public static int constructor = 0xdcef3102;
+        public static int constructor = 0x5ce352ec;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
@@ -6858,7 +8054,26 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                packs.add(TL_stickerPack.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_stickerPack object = TL_stickerPack.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                packs.add(object);
+            }
+            magic = stream.readInt32(exception);
+            if (magic != 0x1cb5c415) {
+                if (exception) {
+                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+                }
+                return;
+            }
+            count = stream.readInt32(exception);
+            for (int a = 0; a < count; a++) {
+                TL_stickerSet object = TL_stickerSet.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                sets.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -6869,7 +8084,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                documents.add(Document.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Document object = Document.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                documents.add(object);
             }
         }
 
@@ -6883,6 +8102,12 @@ public void serializeToStream(AbsSerializedData stream) {
                 packs.get(a).serializeToStream(stream);
             }
             stream.writeInt32(0x1cb5c415);
+            count = sets.size();
+            stream.writeInt32(count);
+            for (int a = 0; a < count; a++) {
+                sets.get(a).serializeToStream(stream);
+            }
+            stream.writeInt32(0x1cb5c415);
             count = documents.size();
             stream.writeInt32(count);
             for (int a = 0; a < count; a++) {
@@ -6900,6 +8125,62 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class TL_messages_allStickers_old extends TL_messages_allStickers {
+        public static int constructor = 0xdcef3102;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            hash = stream.readString(exception);
+            int magic = stream.readInt32(exception);
+            if (magic != 0x1cb5c415) {
+                if (exception) {
+                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+                }
+                return;
+            }
+            int count = stream.readInt32(exception);
+            for (int a = 0; a < count; a++) {
+                TL_stickerPack object = TL_stickerPack.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                packs.add(object);
+            }
+            magic = stream.readInt32(exception);
+            if (magic != 0x1cb5c415) {
+                if (exception) {
+                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+                }
+                return;
+            }
+            count = stream.readInt32(exception);
+            for (int a = 0; a < count; a++) {
+                Document object = Document.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                documents.add(object);
+            }
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeString(hash);
+            stream.writeInt32(0x1cb5c415);
+            int count = packs.size();
+            stream.writeInt32(count);
+            for (int a = 0; a < count; a++) {
+                packs.get(a).serializeToStream(stream);
+            }
+            stream.writeInt32(0x1cb5c415);
+            count = documents.size();
+            stream.writeInt32(count);
+            for (int a = 0; a < count; a++) {
+                documents.get(a).serializeToStream(stream);
+            }
+        }
+    }
+
     public static class TL_auth_checkedPhone extends TLObject {
         public static int constructor = 0x811ea28e;
 
@@ -6928,6 +8209,34 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class UserProfilePhoto extends TLObject {
+        public long photo_id;
+        public FileLocation photo_small;
+        public FileLocation photo_big;
+
+        public static UserProfilePhoto TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            UserProfilePhoto result = null;
+            switch(constructor) {
+                case 0x4f11bae1:
+                    result = new TL_userProfilePhotoEmpty();
+                    break;
+                case 0xd559d8c8:
+                    result = new TL_userProfilePhoto();
+                    break;
+                case 0x990d1493:
+                    result = new TL_userProfilePhoto_old();
+                    break;
+            }
+            if (result == null && exception) {
+                throw new RuntimeException(String.format("can't parse magic %x in UserProfilePhoto", constructor));
+            }
+            if (result != null) {
+                result.readParams(stream, exception);
+            }
+            return result;
+        }
+    }
+
     public static class TL_userProfilePhotoEmpty extends UserProfilePhoto {
         public static int constructor = 0x4f11bae1;
 
@@ -6955,6 +8264,22 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class TL_userProfilePhoto_old extends TL_userProfilePhoto {
+        public static int constructor = 0x990d1493;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            photo_small = FileLocation.TLdeserialize(stream, stream.readInt32(exception), exception);
+            photo_big = FileLocation.TLdeserialize(stream, stream.readInt32(exception), exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            photo_small.serializeToStream(stream);
+            photo_big.serializeToStream(stream);
+        }
+    }
+
     public static class TL_authorization extends TLObject {
         public static int constructor = 0x7bf2e6f6;
 
@@ -7149,7 +8474,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                results.add(TL_chatLocated.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_chatLocated object = TL_chatLocated.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                results.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -7160,7 +8489,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                messages.add(GeoChatMessage.TLdeserialize(stream, stream.readInt32(exception), exception));
+                GeoChatMessage object = GeoChatMessage.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                messages.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -7171,7 +8504,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                chats.add(Chat.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                chats.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -7182,7 +8519,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -7300,7 +8641,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                blocked.add(TL_contactBlocked.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_contactBlocked object = TL_contactBlocked.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                blocked.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -7311,7 +8656,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -7347,7 +8696,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                blocked.add(TL_contactBlocked.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_contactBlocked object = TL_contactBlocked.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                blocked.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -7358,7 +8711,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -7380,8 +8737,8 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_encryptedChatWaiting extends EncryptedChat {
-        public static int constructor = 0x3bf703dc;
+    public static class TL_encryptedChatRequested_old extends TL_encryptedChatRequested {
+        public static int constructor = 0xfda9a7b7;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
@@ -7390,6 +8747,8 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             date = stream.readInt32(exception);
             admin_id = stream.readInt32(exception);
             participant_id = stream.readInt32(exception);
+            g_a = stream.readByteArray(exception);
+            nonce = stream.readByteArray(exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
@@ -7399,34 +8758,32 @@ public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(date);
             stream.writeInt32(admin_id);
             stream.writeInt32(participant_id);
+            stream.writeByteArray(g_a);
+            stream.writeByteArray(nonce);
         }
     }
 
-    public static class TL_encryptedChatEmpty extends EncryptedChat {
-        public static int constructor = 0xab7ec0a0;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(id);
-        }
-    }
-
-    public static class TL_encryptedChatDiscarded extends EncryptedChat {
-        public static int constructor = 0x13d6dd27;
+    public static class TL_encryptedChatRequested extends EncryptedChat {
+        public static int constructor = 0xc878527e;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
             id = stream.readInt32(exception);
+            access_hash = stream.readInt64(exception);
+            date = stream.readInt32(exception);
+            admin_id = stream.readInt32(exception);
+            participant_id = stream.readInt32(exception);
+            g_a = stream.readByteArray(exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
             stream.writeInt32(id);
+            stream.writeInt64(access_hash);
+            stream.writeInt32(date);
+            stream.writeInt32(admin_id);
+            stream.writeInt32(participant_id);
+            stream.writeByteArray(g_a);
         }
     }
 
@@ -7456,8 +8813,8 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_encryptedChatRequested extends EncryptedChat {
-        public static int constructor = 0xc878527e;
+    public static class TL_encryptedChat_old extends TL_encryptedChat {
+        public static int constructor = 0x6601d14f;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
@@ -7466,7 +8823,9 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             date = stream.readInt32(exception);
             admin_id = stream.readInt32(exception);
             participant_id = stream.readInt32(exception);
-            g_a = stream.readByteArray(exception);
+            g_a_or_b = stream.readByteArray(exception);
+            nonce = stream.readByteArray(exception);
+            key_fingerprint = stream.readInt64(exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
@@ -7476,7 +8835,59 @@ public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(date);
             stream.writeInt32(admin_id);
             stream.writeInt32(participant_id);
-            stream.writeByteArray(g_a);
+            stream.writeByteArray(g_a_or_b);
+            stream.writeByteArray(nonce);
+            stream.writeInt64(key_fingerprint);
+        }
+    }
+
+    public static class TL_encryptedChatEmpty extends EncryptedChat {
+        public static int constructor = 0xab7ec0a0;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt32(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt32(id);
+        }
+    }
+
+    public static class TL_encryptedChatWaiting extends EncryptedChat {
+        public static int constructor = 0x3bf703dc;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt32(exception);
+            access_hash = stream.readInt64(exception);
+            date = stream.readInt32(exception);
+            admin_id = stream.readInt32(exception);
+            participant_id = stream.readInt32(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt32(id);
+            stream.writeInt64(access_hash);
+            stream.writeInt32(date);
+            stream.writeInt32(admin_id);
+            stream.writeInt32(participant_id);
+        }
+    }
+
+    public static class TL_encryptedChatDiscarded extends EncryptedChat {
+        public static int constructor = 0x13d6dd27;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt32(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt32(id);
         }
     }
 
@@ -7583,7 +8994,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                stickers.add(Document.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Document object = Document.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                stickers.add(object);
             }
         }
 
@@ -7599,6 +9014,51 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class Video extends TLObject {
+        public long id;
+        public long access_hash;
+        public int user_id;
+        public int date;
+        public int duration;
+        public int size;
+        public PhotoSize thumb;
+        public int dc_id;
+        public int w;
+        public int h;
+        public String caption;
+        public byte[] key;
+        public byte[] iv;
+        public String mime_type;
+
+        public static Video TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            Video result = null;
+            switch(constructor) {
+                case 0xee9f4a4d:
+                    result = new TL_video();
+                    break;
+                case 0x55555553:
+                    result = new TL_videoEncrypted();
+                    break;
+                case 0x5a04a49f:
+                    result = new TL_video_old();
+                    break;
+                case 0x388fa391:
+                    result = new TL_video_old2();
+                    break;
+                case 0xc10658a8:
+                    result = new TL_videoEmpty();
+                    break;
+            }
+            if (result == null && exception) {
+                throw new RuntimeException(String.format("can't parse magic %x in Video", constructor));
+            }
+            if (result != null) {
+                result.readParams(stream, exception);
+            }
+            return result;
+        }
+    }
+
     public static class TL_video extends Video {
         public static int constructor = 0xee9f4a4d;
 
@@ -7631,6 +9091,114 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class TL_videoEncrypted extends TL_video {
+        public static int constructor = 0x55555553;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt64(exception);
+            access_hash = stream.readInt64(exception);
+            user_id = stream.readInt32(exception);
+            date = stream.readInt32(exception);
+            caption = stream.readString(exception);
+            duration = stream.readInt32(exception);
+            size = stream.readInt32(exception);
+            thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
+            dc_id = stream.readInt32(exception);
+            w = stream.readInt32(exception);
+            h = stream.readInt32(exception);
+            key = stream.readByteArray(exception);
+            iv = stream.readByteArray(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt64(id);
+            stream.writeInt64(access_hash);
+            stream.writeInt32(user_id);
+            stream.writeInt32(date);
+            stream.writeString(caption);
+            stream.writeInt32(duration);
+            stream.writeInt32(size);
+            thumb.serializeToStream(stream);
+            stream.writeInt32(dc_id);
+            stream.writeInt32(w);
+            stream.writeInt32(h);
+            stream.writeByteArray(key);
+            stream.writeByteArray(iv);
+        }
+    }
+
+    public static class TL_video_old extends TL_video {
+        public static int constructor = 0x5a04a49f;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt64(exception);
+            access_hash = stream.readInt64(exception);
+            user_id = stream.readInt32(exception);
+            date = stream.readInt32(exception);
+            caption = stream.readString(exception);
+            duration = stream.readInt32(exception);
+            size = stream.readInt32(exception);
+            thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
+            dc_id = stream.readInt32(exception);
+            w = stream.readInt32(exception);
+            h = stream.readInt32(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt64(id);
+            stream.writeInt64(access_hash);
+            stream.writeInt32(user_id);
+            stream.writeInt32(date);
+            stream.writeString(caption);
+            stream.writeInt32(duration);
+            stream.writeInt32(size);
+            thumb.serializeToStream(stream);
+            stream.writeInt32(dc_id);
+            stream.writeInt32(w);
+            stream.writeInt32(h);
+        }
+    }
+
+    public static class TL_video_old2 extends TL_video {
+        public static int constructor = 0x388fa391;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt64(exception);
+            access_hash = stream.readInt64(exception);
+            user_id = stream.readInt32(exception);
+            date = stream.readInt32(exception);
+            caption = stream.readString(exception);
+            duration = stream.readInt32(exception);
+            mime_type = stream.readString(exception);
+            size = stream.readInt32(exception);
+            thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
+            dc_id = stream.readInt32(exception);
+            w = stream.readInt32(exception);
+            h = stream.readInt32(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt64(id);
+            stream.writeInt64(access_hash);
+            stream.writeInt32(user_id);
+            stream.writeInt32(date);
+            stream.writeString(caption);
+            stream.writeInt32(duration);
+            stream.writeString(mime_type);
+            stream.writeInt32(size);
+            thumb.serializeToStream(stream);
+            stream.writeInt32(dc_id);
+            stream.writeInt32(w);
+            stream.writeInt32(h);
+        }
+    }
+
     public static class TL_videoEmpty extends Video {
         public static int constructor = 0xc10658a8;
 
@@ -7717,7 +9285,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                messages.add(GeoChatMessage.TLdeserialize(stream, stream.readInt32(exception), exception));
+                GeoChatMessage object = GeoChatMessage.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                messages.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -7728,7 +9300,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                chats.add(Chat.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                chats.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -7739,7 +9315,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -7781,7 +9361,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                messages.add(GeoChatMessage.TLdeserialize(stream, stream.readInt32(exception), exception));
+                GeoChatMessage object = GeoChatMessage.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                messages.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -7792,7 +9376,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                chats.add(Chat.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                chats.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -7803,7 +9391,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -7907,44 +9499,26 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class storage_FileType extends TLObject {
+    public static class InputStickerSet extends TLObject {
+        public long id;
+        public long access_hash;
+        public String short_name;
 
-        public static storage_FileType TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            storage_FileType result = null;
+        public static InputStickerSet TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            InputStickerSet result = null;
             switch(constructor) {
-                case 0xaa963b05:
-                    result = new TL_storage_fileUnknown();
-                    break;
-                case 0xb3cea0e4:
-                    result = new TL_storage_fileMp4();
-                    break;
-                case 0x1081464c:
-                    result = new TL_storage_fileWebp();
-                    break;
-                case 0xa4f63c0:
-                    result = new TL_storage_filePng();
-                    break;
-                case 0xcae1aadf:
-                    result = new TL_storage_fileGif();
-                    break;
-                case 0xae1e508d:
-                    result = new TL_storage_filePdf();
-                    break;
-                case 0x528a0677:
-                    result = new TL_storage_fileMp3();
+                case 0xffb62b95:
+                    result = new TL_inputStickerSetEmpty();
                     break;
-                case 0x7efe0e:
-                    result = new TL_storage_fileJpeg();
-                    break;
-                case 0x4b09ebbc:
-                    result = new TL_storage_fileMov();
+                case 0x9de7a269:
+                    result = new TL_inputStickerSetID();
                     break;
-                case 0x40bc6f52:
-                    result = new TL_storage_filePartial();
+                case 0x861cc8a0:
+                    result = new TL_inputStickerSetShortName();
                     break;
             }
             if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in storage_FileType", constructor));
+                throw new RuntimeException(String.format("can't parse magic %x in InputStickerSet", constructor));
             }
             if (result != null) {
                 result.readParams(stream, exception);
@@ -7953,8 +9527,8 @@ public static storage_FileType TLdeserialize(AbsSerializedData stream, int const
         }
     }
 
-    public static class TL_storage_fileUnknown extends storage_FileType {
-        public static int constructor = 0xaa963b05;
+    public static class TL_inputStickerSetEmpty extends InputStickerSet {
+        public static int constructor = 0xffb62b95;
 
 
         public void serializeToStream(AbsSerializedData stream) {
@@ -7962,14 +9536,99 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_storage_fileMp4 extends storage_FileType {
-        public static int constructor = 0xb3cea0e4;
+    public static class TL_inputStickerSetID extends InputStickerSet {
+        public static int constructor = 0x9de7a269;
 
 
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-        }
-    }
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt64(exception);
+            access_hash = stream.readInt64(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt64(id);
+            stream.writeInt64(access_hash);
+        }
+    }
+
+    public static class TL_inputStickerSetShortName extends InputStickerSet {
+        public static int constructor = 0x861cc8a0;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            short_name = stream.readString(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeString(short_name);
+        }
+    }
+
+    public static class storage_FileType extends TLObject {
+
+        public static storage_FileType TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            storage_FileType result = null;
+            switch(constructor) {
+                case 0xaa963b05:
+                    result = new TL_storage_fileUnknown();
+                    break;
+                case 0xb3cea0e4:
+                    result = new TL_storage_fileMp4();
+                    break;
+                case 0x1081464c:
+                    result = new TL_storage_fileWebp();
+                    break;
+                case 0xa4f63c0:
+                    result = new TL_storage_filePng();
+                    break;
+                case 0xcae1aadf:
+                    result = new TL_storage_fileGif();
+                    break;
+                case 0xae1e508d:
+                    result = new TL_storage_filePdf();
+                    break;
+                case 0x528a0677:
+                    result = new TL_storage_fileMp3();
+                    break;
+                case 0x7efe0e:
+                    result = new TL_storage_fileJpeg();
+                    break;
+                case 0x4b09ebbc:
+                    result = new TL_storage_fileMov();
+                    break;
+                case 0x40bc6f52:
+                    result = new TL_storage_filePartial();
+                    break;
+            }
+            if (result == null && exception) {
+                throw new RuntimeException(String.format("can't parse magic %x in storage_FileType", constructor));
+            }
+            if (result != null) {
+                result.readParams(stream, exception);
+            }
+            return result;
+        }
+    }
+
+    public static class TL_storage_fileUnknown extends storage_FileType {
+        public static int constructor = 0xaa963b05;
+
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+        }
+    }
+
+    public static class TL_storage_fileMp4 extends storage_FileType {
+        public static int constructor = 0xb3cea0e4;
+
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+        }
+    }
 
     public static class TL_storage_fileWebp extends storage_FileType {
         public static int constructor = 0x1081464c;
@@ -8071,7 +9730,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                authorizations.add(TL_authorization.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_authorization object = TL_authorization.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                authorizations.add(object);
             }
         }
 
@@ -8225,7 +9888,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                contacts.add(TL_contact.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_contact object = TL_contact.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                contacts.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -8236,7 +9903,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -8307,7 +9978,6 @@ public void serializeToStream(AbsSerializedData stream) {
         public int user_id;
         public Update update;
         public int seq_start;
-        public int qts;
 
         public static Updates TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
             Updates result = null;
@@ -8401,7 +10071,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                updates.add(Update.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Update object = Update.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                updates.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -8412,7 +10086,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -8423,7 +10101,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                chats.add(Chat.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                chats.add(object);
             }
             date = stream.readInt32(exception);
             seq = stream.readInt32(exception);
@@ -8528,7 +10210,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                updates.add(Update.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Update object = Update.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                updates.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -8539,7 +10225,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -8550,7 +10240,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                chats.add(Chat.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                chats.add(object);
             }
             date = stream.readInt32(exception);
             seq_start = stream.readInt32(exception);
@@ -8727,7 +10421,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                new_messages.add(Message.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Message object = Message.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                new_messages.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -8738,7 +10436,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                new_encrypted_messages.add(EncryptedMessage.TLdeserialize(stream, stream.readInt32(exception), exception));
+                EncryptedMessage object = EncryptedMessage.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                new_encrypted_messages.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -8749,7 +10451,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                other_updates.add(Update.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Update object = Update.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                other_updates.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -8760,7 +10466,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                chats.add(Chat.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                chats.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -8771,7 +10481,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
             intermediate_state = TL_updates_state.TLdeserialize(stream, stream.readInt32(exception), exception);
         }
@@ -8826,7 +10540,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                new_messages.add(Message.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Message object = Message.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                new_messages.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -8837,7 +10555,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                new_encrypted_messages.add(EncryptedMessage.TLdeserialize(stream, stream.readInt32(exception), exception));
+                EncryptedMessage object = EncryptedMessage.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                new_encrypted_messages.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -8848,7 +10570,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                other_updates.add(Update.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Update object = Update.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                other_updates.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -8859,7 +10585,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                chats.add(Chat.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                chats.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -8870,7 +10600,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
             state = TL_updates_state.TLdeserialize(stream, stream.readInt32(exception), exception);
         }
@@ -9000,17 +10734,67 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_audioEmpty extends Audio {
-        public static int constructor = 0x586988d8;
+    public static class Audio extends TLObject {
+        public long id;
+        public long access_hash;
+        public int user_id;
+        public int date;
+        public int duration;
+        public int size;
+        public int dc_id;
+        public String mime_type;
+        public byte[] key;
+        public byte[] iv;
+
+        public static Audio TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            Audio result = null;
+            switch(constructor) {
+                case 0x427425e7:
+                    result = new TL_audio_old();
+                    break;
+                case 0xc7ac6496:
+                    result = new TL_audio();
+                    break;
+                case 0x555555F6:
+                    result = new TL_audioEncrypted();
+                    break;
+                case 0x586988d8:
+                    result = new TL_audioEmpty();
+                    break;
+            }
+            if (result == null && exception) {
+                throw new RuntimeException(String.format("can't parse magic %x in Audio", constructor));
+            }
+            if (result != null) {
+                result.readParams(stream, exception);
+            }
+            return result;
+        }
+    }
+
+    public static class TL_audio_old extends TL_audio {
+        public static int constructor = 0x427425e7;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
             id = stream.readInt64(exception);
+            access_hash = stream.readInt64(exception);
+            user_id = stream.readInt32(exception);
+            date = stream.readInt32(exception);
+            duration = stream.readInt32(exception);
+            size = stream.readInt32(exception);
+            dc_id = stream.readInt32(exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
             stream.writeInt64(id);
+            stream.writeInt64(access_hash);
+            stream.writeInt32(user_id);
+            stream.writeInt32(date);
+            stream.writeInt32(duration);
+            stream.writeInt32(size);
+            stream.writeInt32(dc_id);
         }
     }
 
@@ -9042,6 +10826,50 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class TL_audioEncrypted extends TL_audio {
+        public static int constructor = 0x555555F6;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt64(exception);
+            access_hash = stream.readInt64(exception);
+            user_id = stream.readInt32(exception);
+            date = stream.readInt32(exception);
+            duration = stream.readInt32(exception);
+            size = stream.readInt32(exception);
+            dc_id = stream.readInt32(exception);
+            key = stream.readByteArray(exception);
+            iv = stream.readByteArray(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt64(id);
+            stream.writeInt64(access_hash);
+            stream.writeInt32(user_id);
+            stream.writeInt32(date);
+            stream.writeInt32(duration);
+            stream.writeInt32(size);
+            stream.writeInt32(dc_id);
+            stream.writeByteArray(key);
+            stream.writeByteArray(iv);
+        }
+    }
+
+    public static class TL_audioEmpty extends Audio {
+        public static int constructor = 0x586988d8;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt64(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt64(id);
+        }
+    }
+
     public static class TL_contacts_found extends TLObject {
         public static int constructor = 0x566000e;
 
@@ -9071,7 +10899,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                results.add(TL_contactFound.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_contactFound object = TL_contactFound.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                results.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -9082,7 +10914,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -9103,33 +10939,191 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_documentEmpty extends Document {
-        public static int constructor = 0x36f8c871;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt64(exception);
-        }
+    public static class Document extends TLObject {
+        public long id;
+        public long access_hash;
+        public int user_id;
+        public int date;
+        public String file_name;
+        public String mime_type;
+        public int size;
+        public PhotoSize thumb;
+        public int dc_id;
+        public byte[] key;
+        public byte[] iv;
+        public ArrayList<DocumentAttribute> attributes = new ArrayList<>();
 
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt64(id);
+        public static Document TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            Document result = null;
+            switch(constructor) {
+                case 0x55555556:
+                    result = new TL_documentEncrypted_old();
+                    break;
+                case 0x9efc6326:
+                    result = new TL_document_old();
+                    break;
+                case 0x36f8c871:
+                    result = new TL_documentEmpty();
+                    break;
+                case 0x55555558:
+                    result = new TL_documentEncrypted();
+                    break;
+                case 0xf9a39f4f:
+                    result = new TL_document();
+                    break;
+            }
+            if (result == null && exception) {
+                throw new RuntimeException(String.format("can't parse magic %x in Document", constructor));
+            }
+            if (result != null) {
+                result.readParams(stream, exception);
+            }
+            return result;
         }
     }
 
-    public static class TL_document extends Document {
-        public static int constructor = 0xf9a39f4f;
+    public static class TL_documentEncrypted_old extends TL_document {
+        public static int constructor = 0x55555556;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
             id = stream.readInt64(exception);
             access_hash = stream.readInt64(exception);
+            user_id = stream.readInt32(exception);
             date = stream.readInt32(exception);
+            file_name = stream.readString(exception);
             mime_type = stream.readString(exception);
             size = stream.readInt32(exception);
             thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
             dc_id = stream.readInt32(exception);
-            int magic = stream.readInt32(exception);
+            key = stream.readByteArray(exception);
+            iv = stream.readByteArray(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt64(id);
+            stream.writeInt64(access_hash);
+            stream.writeInt32(user_id);
+            stream.writeInt32(date);
+            stream.writeString(file_name);
+            stream.writeString(mime_type);
+            stream.writeInt32(size);
+            thumb.serializeToStream(stream);
+            stream.writeInt32(dc_id);
+            stream.writeByteArray(key);
+            stream.writeByteArray(iv);
+        }
+    }
+
+    public static class TL_document_old extends TL_document {
+        public static int constructor = 0x9efc6326;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt64(exception);
+            access_hash = stream.readInt64(exception);
+            user_id = stream.readInt32(exception);
+            date = stream.readInt32(exception);
+            file_name = stream.readString(exception);
+            mime_type = stream.readString(exception);
+            size = stream.readInt32(exception);
+            thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
+            dc_id = stream.readInt32(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt64(id);
+            stream.writeInt64(access_hash);
+            stream.writeInt32(user_id);
+            stream.writeInt32(date);
+            stream.writeString(file_name);
+            stream.writeString(mime_type);
+            stream.writeInt32(size);
+            thumb.serializeToStream(stream);
+            stream.writeInt32(dc_id);
+        }
+    }
+
+    public static class TL_documentEmpty extends Document {
+        public static int constructor = 0x36f8c871;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt64(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt64(id);
+        }
+    }
+
+    public static class TL_documentEncrypted extends Document {
+        public static int constructor = 0x55555558;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt64(exception);
+            access_hash = stream.readInt64(exception);
+            date = stream.readInt32(exception);
+            mime_type = stream.readString(exception);
+            size = stream.readInt32(exception);
+            thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
+            dc_id = stream.readInt32(exception);
+            int magic = stream.readInt32(exception);
+            if (magic != 0x1cb5c415) {
+                if (exception) {
+                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+                }
+                return;
+            }
+            int count = stream.readInt32(exception);
+            for (int a = 0; a < count; a++) {
+                DocumentAttribute object = DocumentAttribute.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                attributes.add(object);
+            }
+            key = stream.readByteArray(exception);
+            iv = stream.readByteArray(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt64(id);
+            stream.writeInt64(access_hash);
+            stream.writeInt32(date);
+            stream.writeString(mime_type);
+            stream.writeInt32(size);
+            thumb.serializeToStream(stream);
+            stream.writeInt32(dc_id);
+            stream.writeInt32(0x1cb5c415);
+            int count = attributes.size();
+            stream.writeInt32(count);
+            for (int a = 0; a < count; a++) {
+                attributes.get(a).serializeToStream(stream);
+            }
+            stream.writeByteArray(key);
+            stream.writeByteArray(iv);
+        }
+    }
+
+    public static class TL_document extends Document {
+        public static int constructor = 0xf9a39f4f;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            id = stream.readInt64(exception);
+            access_hash = stream.readInt64(exception);
+            date = stream.readInt32(exception);
+            mime_type = stream.readString(exception);
+            size = stream.readInt32(exception);
+            thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
+            dc_id = stream.readInt32(exception);
+            int magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
                 if (exception) {
                     throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
@@ -9138,7 +11132,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                attributes.add(DocumentAttribute.TLdeserialize(stream, stream.readInt32(exception), exception));
+                DocumentAttribute object = DocumentAttribute.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                attributes.add(object);
             }
         }
 
@@ -9566,7 +11564,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                chats.add(Chat.TLdeserialize(stream, stream.readInt32(exception), exception));
+                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                chats.add(object);
             }
         }
 
@@ -9685,6 +11687,65 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class SendMessageAction extends TLObject {
+        public int progress;
+
+        public static SendMessageAction TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            SendMessageAction result = null;
+            switch(constructor) {
+                case 0xd52f73f7:
+                    result = new TL_sendMessageRecordAudioAction();
+                    break;
+                case 0x92042ff7:
+                    result = new TL_sendMessageUploadVideoAction_old();
+                    break;
+                case 0xe6ac8a6f:
+                    result = new TL_sendMessageUploadAudioAction_old();
+                    break;
+                case 0xf351d7ab:
+                    result = new TL_sendMessageUploadAudioAction();
+                    break;
+                case 0xd1d34a26:
+                    result = new TL_sendMessageUploadPhotoAction();
+                    break;
+                case 0x8faee98e:
+                    result = new TL_sendMessageUploadDocumentAction_old();
+                    break;
+                case 0xe9763aec:
+                    result = new TL_sendMessageUploadVideoAction();
+                    break;
+                case 0xfd5ec8f5:
+                    result = new TL_sendMessageCancelAction();
+                    break;
+                case 0x176f8ba1:
+                    result = new TL_sendMessageGeoLocationAction();
+                    break;
+                case 0x628cbc6f:
+                    result = new TL_sendMessageChooseContactAction();
+                    break;
+                case 0x16bf744e:
+                    result = new TL_sendMessageTypingAction();
+                    break;
+                case 0x990a3c1a:
+                    result = new TL_sendMessageUploadPhotoAction_old();
+                    break;
+                case 0xaa0cd9e4:
+                    result = new TL_sendMessageUploadDocumentAction();
+                    break;
+                case 0xa187d66f:
+                    result = new TL_sendMessageRecordVideoAction();
+                    break;
+            }
+            if (result == null && exception) {
+                throw new RuntimeException(String.format("can't parse magic %x in SendMessageAction", constructor));
+            }
+            if (result != null) {
+                result.readParams(stream, exception);
+            }
+            return result;
+        }
+    }
+
     public static class TL_sendMessageRecordAudioAction extends SendMessageAction {
         public static int constructor = 0xd52f73f7;
 
@@ -9694,6 +11755,28 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class TL_sendMessageUploadVideoAction_old extends TL_sendMessageUploadVideoAction {
+        public static int constructor = 0x92042ff7;
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+        }
+    }
+
+    public static class TL_sendMessageUploadAudioAction_old extends TL_sendMessageUploadAudioAction {
+        public static int constructor = 0xe6ac8a6f;
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+        }
+    }
+
     public static class TL_sendMessageUploadAudioAction extends SendMessageAction {
         public static int constructor = 0xf351d7ab;
 
@@ -9722,6 +11805,17 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class TL_sendMessageUploadDocumentAction_old extends TL_sendMessageUploadDocumentAction {
+        public static int constructor = 0x8faee98e;
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+        }
+    }
+
     public static class TL_sendMessageUploadVideoAction extends SendMessageAction {
         public static int constructor = 0xe9763aec;
 
@@ -9772,6 +11866,17 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class TL_sendMessageUploadPhotoAction_old extends TL_sendMessageUploadPhotoAction {
+        public static int constructor = 0x990a3c1a;
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+        }
+    }
+
     public static class TL_sendMessageUploadDocumentAction extends SendMessageAction {
         public static int constructor = 0xaa0cd9e4;
 
@@ -9919,74 +12024,133 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_documentAttributeAnimated extends DocumentAttribute {
-        public static int constructor = 0x11b58939;
-
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-        }
-    }
-
-    public static class TL_documentAttributeImageSize extends DocumentAttribute {
-        public static int constructor = 0x6c37c15c;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            w = stream.readInt32(exception);
-            h = stream.readInt32(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(w);
-            stream.writeInt32(h);
-        }
-    }
+    public static class DocumentAttribute extends TLObject {
+        public int w;
+        public int h;
+        public String file_name;
+        public String alt;
+        public InputStickerSet stickerset;
+        public int duration;
 
-    public static class TL_documentAttributeFilename extends DocumentAttribute {
-        public static int constructor = 0x15590068;
+        public static DocumentAttribute TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            DocumentAttribute result = null;
+            switch(constructor) {
+                case 0x11b58939:
+                    result = new TL_documentAttributeAnimated();
+                    break;
+                case 0xfb0a5727:
+                    result = new TL_documentAttributeSticker_old();
+                    break;
+                case 0x6c37c15c:
+                    result = new TL_documentAttributeImageSize();
+                    break;
+                case 0x15590068:
+                    result = new TL_documentAttributeFilename();
+                    break;
+                case 0x3a556302:
+                    result = new TL_documentAttributeSticker();
+                    break;
+                case 0x5910cccb:
+                    result = new TL_documentAttributeVideo();
+                    break;
+                case 0x51448e5:
+                    result = new TL_documentAttributeAudio();
+                    break;
+                case 0x994c9882:
+                    result = new TL_documentAttributeSticker_old2();
+                    break;
+            }
+            if (result == null && exception) {
+                throw new RuntimeException(String.format("can't parse magic %x in DocumentAttribute", constructor));
+            }
+            if (result != null) {
+                result.readParams(stream, exception);
+            }
+            return result;
+        }
+    }
+
+    public static class TL_documentAttributeAnimated extends DocumentAttribute {
+        public static int constructor = 0x11b58939;
+
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+        }
+    }
 
+    public static class TL_documentAttributeSticker_old extends TL_documentAttributeSticker {
+        public static int constructor = 0xfb0a5727;
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            file_name = stream.readString(exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            stream.writeString(file_name);
         }
     }
 
-    public static class TL_documentAttributeVideo extends DocumentAttribute {
-        public static int constructor = 0x5910cccb;
+    public static class TL_documentAttributeImageSize extends DocumentAttribute {
+        public static int constructor = 0x6c37c15c;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            duration = stream.readInt32(exception);
             w = stream.readInt32(exception);
             h = stream.readInt32(exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            stream.writeInt32(duration);
             stream.writeInt32(w);
             stream.writeInt32(h);
         }
     }
 
+    public static class TL_documentAttributeFilename extends DocumentAttribute {
+        public static int constructor = 0x15590068;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            file_name = stream.readString(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeString(file_name);
+        }
+    }
+
     public static class TL_documentAttributeSticker extends DocumentAttribute {
-        public static int constructor = 0x994c9882;
+        public static int constructor = 0x3a556302;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
             alt = stream.readString(exception);
+            stickerset = InputStickerSet.TLdeserialize(stream, stream.readInt32(exception), exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
             stream.writeString(alt);
+            stickerset.serializeToStream(stream);
+        }
+    }
+
+    public static class TL_documentAttributeVideo extends DocumentAttribute {
+        public static int constructor = 0x5910cccb;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            duration = stream.readInt32(exception);
+            w = stream.readInt32(exception);
+            h = stream.readInt32(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt32(duration);
+            stream.writeInt32(w);
+            stream.writeInt32(h);
         }
     }
 
@@ -10004,6 +12168,20 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
+    public static class TL_documentAttributeSticker_old2 extends TL_documentAttributeSticker {
+        public static int constructor = 0x994c9882;
+
+
+        public void readParams(AbsSerializedData stream, boolean exception) {
+            alt = stream.readString(exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeString(alt);
+        }
+    }
+
     public static class TL_contacts_importedContacts extends TLObject {
         public static int constructor = 0xad524315;
 
@@ -10034,7 +12212,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                imported.add(TL_importedContact.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_importedContact object = TL_importedContact.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                imported.add(object);
             }
             magic = stream.readInt32(exception);
             if (magic != 0x1cb5c415) {
@@ -10056,7 +12238,11 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             }
             count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                users.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
             }
         }
 
@@ -10273,7 +12459,11 @@ public static TL_destroy_sessions_res TLdeserialize(AbsSerializedData stream, in
         public void readParams(AbsSerializedData stream, boolean exception) {
             int count = stream.readInt32(exception);
             for (int a = 0; a < count; a++) {
-                destroy_results.add(DestroySessionRes.TLdeserialize(stream, stream.readInt32(exception), exception));
+                DestroySessionRes object = DestroySessionRes.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                destroy_results.add(object);
             }
         }
 
@@ -10685,7 +12875,11 @@ public TLObject deserializeResponse(AbsSerializedData stream, int constructor, b
             Vector vector = new Vector();
             int size = stream.readInt32(exception);
             for (int a = 0; a < size; a++) {
-                vector.objects.add(WallPaper.TLdeserialize(stream, stream.readInt32(exception), exception));
+                WallPaper object = WallPaper.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return vector;
+                }
+                vector.objects.add(object);
             }
             return vector;
         }
@@ -10704,7 +12898,11 @@ public TLObject deserializeResponse(AbsSerializedData stream, int constructor, b
             Vector vector = new Vector();
             int size = stream.readInt32(exception);
             for (int a = 0; a < size; a++) {
-                vector.objects.add(User.TLdeserialize(stream, stream.readInt32(exception), exception));
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return vector;
+                }
+                vector.objects.add(object);
             }
             return vector;
         }
@@ -10743,7 +12941,11 @@ public TLObject deserializeResponse(AbsSerializedData stream, int constructor, b
             Vector vector = new Vector();
             int size = stream.readInt32(exception);
             for (int a = 0; a < size; a++) {
-                vector.objects.add(TL_contactStatus.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_contactStatus object = TL_contactStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return vector;
+                }
+                vector.objects.add(object);
             }
             return vector;
         }
@@ -11079,7 +13281,11 @@ public TLObject deserializeResponse(AbsSerializedData stream, int constructor, b
             Vector vector = new Vector();
             int size = stream.readInt32(exception);
             for (int a = 0; a < size; a++) {
-                vector.objects.add(TL_receivedNotifyMessage.TLdeserialize(stream, stream.readInt32(exception), exception));
+                TL_receivedNotifyMessage object = TL_receivedNotifyMessage.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return vector;
+                }
+                vector.objects.add(object);
             }
             return vector;
         }
@@ -12381,76 +14587,52 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    //manually created
+    public static class TL_messages_getStickerSet extends TLObject {
+        public static int constructor = 0x2619a90e;
 
-    //Photo start
-    public static class Photo extends TLObject {
-        public long id;
-        public long access_hash;
-        public int user_id;
-        public int date;
-        public GeoPoint geo;
-        public ArrayList<PhotoSize> sizes = new ArrayList<>();
-        public String caption; //custom
+        public InputStickerSet stickerset;
 
-        public static Photo TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            Photo result = null;
-            switch(constructor) {
-                case 0xc3838076:
-                    result = new TL_photo();
-                    break;
-                case 0x2331b22d:
-                    result = new TL_photoEmpty();
-                    break;
-                case 0x22b56751:
-                    result = new TL_photo_old(); //custom
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in Photo", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
+        public TLObject deserializeResponse(AbsSerializedData stream, int constructor, boolean exception) {
+            return TL_messages_stickerSet.TLdeserialize(stream, constructor, exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stickerset.serializeToStream(stream);
         }
     }
 
-    public static class TL_photo_old extends TL_photo {
-        public static int constructor = 0x22b56751;
+    public static class TL_messages_installStickerSet extends TLObject {
+        public static int constructor = 0xefbbfae9;
 
+        public InputStickerSet stickerset;
 
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt64(exception);
-            access_hash = stream.readInt64(exception);
-            user_id = stream.readInt32(exception);
-            date = stream.readInt32(exception);
-            caption = stream.readString(exception);
-            geo = GeoPoint.TLdeserialize(stream, stream.readInt32(exception), exception);
-            stream.readInt32(exception);
-            int count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                sizes.add(PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception));
-            }
+        public TLObject deserializeResponse(AbsSerializedData stream, int constructor, boolean exception) {
+            return Bool.TLdeserialize(stream, constructor, exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            stream.writeInt64(id);
-            stream.writeInt64(access_hash);
-            stream.writeInt32(user_id);
-            stream.writeInt32(date);
-            stream.writeString(caption);
-            geo.serializeToStream(stream);
-            stream.writeInt32(0x1cb5c415);
-            int count = sizes.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                sizes.get(a).serializeToStream(stream);
-            }
+            stickerset.serializeToStream(stream);
+        }
+    }
+
+    public static class TL_messages_uninstallStickerSet extends TLObject {
+        public static int constructor = 0xf96e55de;
+
+        public InputStickerSet stickerset;
+
+        public TLObject deserializeResponse(AbsSerializedData stream, int constructor, boolean exception) {
+            return Bool.TLdeserialize(stream, constructor, exception);
+        }
+
+        public void serializeToStream(AbsSerializedData stream) {
+            stream.writeInt32(constructor);
+            stickerset.serializeToStream(stream);
         }
     }
-    //Photo end
+
+    //manually created
 
     //EncryptedChat start
     public static class EncryptedChat extends TLObject {
@@ -12459,9 +14641,10 @@ public void serializeToStream(AbsSerializedData stream) {
         public int date;
         public int admin_id;
         public int participant_id;
+        public byte[] g_a;
+        public byte[] nonce;
         public byte[] g_a_or_b;
         public long key_fingerprint;
-        public byte[] g_a;
         public byte[] a_or_b; //custom
         public byte[] auth_key; //custom
         public int user_id; //custom
@@ -12480,26 +14663,26 @@ public void serializeToStream(AbsSerializedData stream) {
         public static EncryptedChat TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
             EncryptedChat result = null;
             switch(constructor) {
-                case 0x3bf703dc:
-                    result = new TL_encryptedChatWaiting();
-                    break;
-                case 0xab7ec0a0:
-                    result = new TL_encryptedChatEmpty();
+                case 0xfda9a7b7:
+                    result = new TL_encryptedChatRequested_old();
                     break;
-                case 0x13d6dd27:
-                    result = new TL_encryptedChatDiscarded();
+                case 0xc878527e:
+                    result = new TL_encryptedChatRequested();
                     break;
                 case 0xfa56ce36:
                     result = new TL_encryptedChat();
                     break;
-                case 0xc878527e:
-                    result = new TL_encryptedChatRequested();
-                    break;
                 case 0x6601d14f:
-                    result = new TL_encryptedChat_old(); //custom
+                    result = new TL_encryptedChat_old();
                     break;
-                case 0xfda9a7b7:
-                    result = new TL_encryptedChatRequested_old(); //custom
+                case 0xab7ec0a0:
+                    result = new TL_encryptedChatEmpty();
+                    break;
+                case 0x3bf703dc:
+                    result = new TL_encryptedChatWaiting();
+                    break;
+                case 0x13d6dd27:
+                    result = new TL_encryptedChatDiscarded();
                     break;
             }
             if (result == null && exception) {
@@ -12511,58 +14694,6 @@ public static EncryptedChat TLdeserialize(AbsSerializedData stream, int construc
             return result;
         }
     }
-
-    public static class TL_encryptedChat_old extends TL_encryptedChat {
-        public static int constructor = 0x6601d14f;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
-            access_hash = stream.readInt64(exception);
-            date = stream.readInt32(exception);
-            admin_id = stream.readInt32(exception);
-            participant_id = stream.readInt32(exception);
-            g_a_or_b = stream.readByteArray(exception);
-            stream.readByteArray(exception);
-            key_fingerprint = stream.readInt64(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(TL_encryptedChat.constructor);
-            stream.writeInt32(id);
-            stream.writeInt64(access_hash);
-            stream.writeInt32(date);
-            stream.writeInt32(admin_id);
-            stream.writeInt32(participant_id);
-            stream.writeByteArray(g_a_or_b);
-            stream.writeInt64(key_fingerprint);
-        }
-    }
-
-    public static class TL_encryptedChatRequested_old extends EncryptedChat {
-        public static int constructor = 0xfda9a7b7;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
-            access_hash = stream.readInt64(exception);
-            date = stream.readInt32(exception);
-            admin_id = stream.readInt32(exception);
-            participant_id = stream.readInt32(exception);
-            g_a = stream.readByteArray(exception);
-            stream.readByteArray(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(TL_encryptedChatRequested.constructor);
-            stream.writeInt32(id);
-            stream.writeInt64(access_hash);
-            stream.writeInt32(date);
-            stream.writeInt32(admin_id);
-            stream.writeInt32(participant_id);
-            stream.writeByteArray(g_a);
-        }
-    }
     //EncryptedChat end
 
     //Message start
@@ -12590,7 +14721,6 @@ public void serializeToStream(AbsSerializedData stream) {
         public int seq_in; //custom
         public int seq_out; //custom
         public TLRPC.Message replyMessage; //custom
-        public VideoEditedInfo videoEditedInfo = null; //custom
 
         public static Message TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
             Message result = null;
@@ -12654,10 +14784,6 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             if (id < 0 || (media != null && !(media instanceof TL_messageMediaEmpty) && message != null && message.length() != 0 && message.startsWith("-1"))) {
                 attachPath = stream.readString(exception);
             }
-            if (id < 0 && message.length() > 6 && media instanceof TL_messageMediaVideo) {
-                videoEditedInfo = new VideoEditedInfo();
-                videoEditedInfo.parseString(message);
-            }
         }
 
         public void serializeToStream(AbsSerializedData stream) {
@@ -12701,10 +14827,6 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             if (id < 0 || (media != null && !(media instanceof TL_messageMediaEmpty) && message != null && message.length() != 0 && message.startsWith("-1"))) {
                 attachPath = stream.readString(exception);
             }
-            if (id < 0 && message.length() > 6 && media instanceof TL_messageMediaVideo) {
-                videoEditedInfo = new VideoEditedInfo();
-                videoEditedInfo.parseString(message);
-            }
             if ((flags & MESSAGE_FLAG_FWD) != 0 && id < 0) {
                 fwd_msg_id = stream.readInt32(exception);
             }
@@ -12750,10 +14872,6 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             if (id < 0 || (media != null && !(media instanceof TL_messageMediaEmpty) && message != null && message.length() != 0 && message.startsWith("-1"))) {
                 attachPath = stream.readString(exception);
             }
-            if (id < 0 && message.length() > 6 && media instanceof TL_messageMediaVideo) {
-                videoEditedInfo = new VideoEditedInfo();
-                videoEditedInfo.parseString(message);
-            }
         }
 
         public void serializeToStream(AbsSerializedData stream) {
@@ -12817,10 +14935,6 @@ public void readParams(AbsSerializedData stream, boolean exception) {
             if (id < 0 || (media != null && !(media instanceof TL_messageMediaEmpty) && message != null && message.length() != 0 && message.startsWith("-1"))) {
                 attachPath = stream.readString(exception);
             }
-            if (id < 0 && message.length() > 6 && media instanceof TL_messageMediaVideo) {
-                videoEditedInfo = new VideoEditedInfo();
-                videoEditedInfo.parseString(message);
-            }
         }
 
         public void serializeToStream(AbsSerializedData stream) {
@@ -12842,1633 +14956,152 @@ public void serializeToStream(AbsSerializedData stream) {
         }
     }
 
-    public static class TL_message_old extends TL_message {
-        public static int constructor = 0x22eb6aba;
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
-            from_id = stream.readInt32(exception);
-            to_id = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
-            flags |= stream.readBool(exception) ? MESSAGE_FLAG_OUT : 0;
-            flags |= stream.readBool(exception) ? MESSAGE_FLAG_UNREAD : 0;
-            date = stream.readInt32(exception);
-            message = stream.readString(exception);
-            media = MessageMedia.TLdeserialize(stream, stream.readInt32(exception), exception);
-            if (id < 0 || (media != null && !(media instanceof TL_messageMediaEmpty) && message != null && message.length() != 0 && message.startsWith("-1"))) {
-                attachPath = stream.readString(exception);
-            }
-            if (id < 0 && message.length() > 6 && media instanceof TL_messageMediaVideo) {
-                videoEditedInfo = new VideoEditedInfo();
-                videoEditedInfo.parseString(message);
-            }
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(id);
-            stream.writeInt32(from_id);
-            to_id.serializeToStream(stream);
-            stream.writeBool((flags & MESSAGE_FLAG_OUT) != 0);
-            stream.writeBool((flags & MESSAGE_FLAG_UNREAD) != 0);
-            stream.writeInt32(date);
-            stream.writeString(message);
-            media.serializeToStream(stream);
-            stream.writeString(attachPath);
-        }
-    }
-
-    public static class TL_message_secret extends TL_message {
-        public static int constructor = 0x555555F8;
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            flags = stream.readInt32(exception);
-            id = stream.readInt32(exception);
-            ttl = stream.readInt32(exception);
-            from_id = stream.readInt32(exception);
-            to_id = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
-            date = stream.readInt32(exception);
-            message = stream.readString(exception);
-            media = MessageMedia.TLdeserialize(stream, stream.readInt32(exception), exception);
-            if (id < 0 || (media != null && !(media instanceof TL_messageMediaEmpty) && message != null && message.length() != 0 && message.startsWith("-1"))) {
-                attachPath = stream.readString(exception);
-            }
-            if (id < 0 && message.length() > 6 && media instanceof TL_messageMediaVideo) {
-                videoEditedInfo = new VideoEditedInfo();
-                videoEditedInfo.parseString(message);
-            }
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(flags);
-            stream.writeInt32(id);
-            stream.writeInt32(ttl);
-            stream.writeInt32(from_id);
-            to_id.serializeToStream(stream);
-            stream.writeInt32(date);
-            stream.writeString(message);
-            media.serializeToStream(stream);
-            stream.writeString(attachPath);
-        }
-    }
-    //Message end
-
-    //MessageAction start
-    public static class MessageAction extends TLObject {
-        public Photo photo;
-        public int user_id;
-        public int inviter_id;
-        public String title;
-        public ArrayList<Integer> users = new ArrayList<>();
-        public String address;
-        public int ttl;
-        public DecryptedMessageAction encryptedAction;
-        public UserProfilePhoto newUserPhoto;
-
-        public static MessageAction TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            MessageAction result = null;
-            switch(constructor) {
-                case 0x7fcb13a8:
-                    result = new TL_messageActionChatEditPhoto();
-                    break;
-                case 0xb2ae9b0c:
-                    result = new TL_messageActionChatDeleteUser();
-                    break;
-                case 0xf89cf5e8:
-                    result = new TL_messageActionChatJoinedByLink();
-                    break;
-                case 0x95e3fbef:
-                    result = new TL_messageActionChatDeletePhoto();
-                    break;
-                case 0x5e3cfc4b:
-                    result = new TL_messageActionChatAddUser();
-                    break;
-                case 0xa6638b9a:
-                    result = new TL_messageActionChatCreate();
-                    break;
-                case 0xb6aef7b0:
-                    result = new TL_messageActionEmpty();
-                    break;
-                case 0xb5a1ce5a:
-                    result = new TL_messageActionChatEditTitle();
-                    break;
-                case 0x6f038ebc:
-                    result = new TL_messageActionGeoChatCreate();
-                    break;
-                case 0xc7d53de:
-                    result = new TL_messageActionGeoChatCheckin();
-                    break;
-                case 0x55555552:
-                    result = new TL_messageActionTTLChange(); //custom
-                    break;
-                case 0x55555557:
-                    result = new TL_messageActionCreatedBroadcastList(); //custom
-                    break;
-                case 0x55555551:
-                    result = new TL_messageActionUserUpdatedPhoto(); //custom
-                    break;
-                case 0x55555550:
-                    result = new TL_messageActionUserJoined(); //custom
-                    break;
-                case 0x555555F5:
-                    result = new TL_messageActionLoginUnknownLocation(); //custom
-                    break;
-                case 0x555555F7:
-                    result = new TL_messageEncryptedAction(); //custom
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in MessageAction", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
-
-    public static class TL_messageActionTTLChange extends MessageAction {
-        public static int constructor = 0x55555552;
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            ttl = stream.readInt32(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(ttl);
-        }
-    }
-
-    public static class TL_messageActionCreatedBroadcastList extends MessageAction {
-        public static int constructor = 0x55555557;
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-        }
-    }
-
-    public static class TL_messageActionUserUpdatedPhoto extends MessageAction {
-        public static int constructor = 0x55555551;
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            newUserPhoto = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            newUserPhoto.serializeToStream(stream);
-        }
-    }
-
-    public static class TL_messageActionUserJoined extends MessageAction {
-        public static int constructor = 0x55555550;
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-        }
-    }
-
-    public static class TL_messageActionLoginUnknownLocation extends MessageAction {
-        public static int constructor = 0x555555F5;
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            title = stream.readString(exception);
-            address = stream.readString(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeString(title);
-            stream.writeString(address);
-        }
-    }
-
-    public static class TL_messageEncryptedAction extends MessageAction {
-        public static int constructor = 0x555555F7;
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            encryptedAction = DecryptedMessageAction.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            encryptedAction.serializeToStream(stream);
-        }
-    }
-    //MessageAction end
-
-    //InputEncryptedFile start
-    public static class InputEncryptedFile extends TLObject {
-        public long id;
-        public long access_hash;
-        public int parts;
-        public int key_fingerprint;
-        public String md5_checksum;
-        public byte[] key; //custom
-        public byte[] iv; //custom
-
-        public static InputEncryptedFile TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            InputEncryptedFile result = null;
-            switch(constructor) {
-                case 0x5a17b5e5:
-                    result = new TL_inputEncryptedFile();
-                    break;
-                case 0x2dc173c8:
-                    result = new TL_inputEncryptedFileBigUploaded();
-                    break;
-                case 0x1837c364:
-                    result = new TL_inputEncryptedFileEmpty();
-                    break;
-                case 0x64bd0306:
-                    result = new TL_inputEncryptedFileUploaded();
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in InputEncryptedFile", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
-    //InputEncryptedFile end
-
-    //UserStatus start
-    public static class UserStatus extends TLObject {
-        public int expires;
-
-        public static UserStatus TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            UserStatus result = null;
-            switch(constructor) {
-                case 0x8c703f:
-                    result = new TL_userStatusOffline();
-                    break;
-                case 0x7bf09fc:
-                    result = new TL_userStatusLastWeek();
-                    break;
-                case 0x9d05049:
-                    result = new TL_userStatusEmpty();
-                    break;
-                case 0x77ebc742:
-                    result = new TL_userStatusLastMonth();
-                    break;
-                case 0xedb93949:
-                    result = new TL_userStatusOnline();
-                    break;
-                case 0xe26f42f1:
-                    result = new TL_userStatusRecently();
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in UserStatus", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
-
-    public static class TL_userStatusOffline extends UserStatus {
-        public static int constructor = 0x8c703f;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            expires = stream.readInt32(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(expires);
-        }
-    }
-    //UserStatus end
-
-    //TL_dialog start
-    public static class TL_dialog extends TLObject {
-        public static int constructor = 0xc1dd804a;
-
-        public Peer peer;
-        public int top_message;
-        public int read_inbox_max_id;
-        public int unread_count;
-        public PeerNotifySettings notify_settings;
-        public int last_message_date; //custom
-        public long id; //custom
-        public int last_read; //custom
-
-        public static TL_dialog TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            if (TL_dialog.constructor != constructor) {
-                if (exception) {
-                    throw new RuntimeException(String.format("can't parse magic %x in TL_dialog", constructor));
-                } else {
-                    return null;
-                }
-            }
-            TL_dialog result = new TL_dialog();
-            result.readParams(stream, exception);
-            return result;
-        }
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            peer = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
-            top_message = stream.readInt32(exception);
-            read_inbox_max_id = stream.readInt32(exception);
-            unread_count = stream.readInt32(exception);
-            notify_settings = PeerNotifySettings.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            peer.serializeToStream(stream);
-            stream.writeInt32(top_message);
-            stream.writeInt32(read_inbox_max_id);
-            stream.writeInt32(unread_count);
-            notify_settings.serializeToStream(stream);
-        }
-    }
-    //TL_dialog end
-
-    //User start
-    public static class User extends TLObject {
-        public int id;
-        public String first_name;
-        public String last_name;
-        public String username;
-        public long access_hash;
-        public String phone;
-        public UserProfilePhoto photo;
-        public UserStatus status;
-
-        public static User TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            User result = null;
-            switch(constructor) {
-                case 0xcab35e18:
-                    result = new TL_userContact();
-                    break;
-                case 0xd9ccc4ef:
-                    result = new TL_userRequest();
-                    break;
-                case 0x75cf7a8:
-                    result = new TL_userForeign();
-                    break;
-                case 0xd6016d7a:
-                    result = new TL_userDeleted();
-                    break;
-                case 0x1c60e608:
-                    result = new TL_userSelf();
-                    break;
-                case 0x200250ba:
-                    result = new TL_userEmpty();
-                    break;
-                case 0xb29ad7cc:
-                    result = new TL_userDeleted_old(); //custom
-                    break;
-                case 0x5214c89d:
-                    result = new TL_userForeign_old(); //custom
-                    break;
-                case 0x22e8ceb0:
-                    result = new TL_userRequest_old(); //custom
-                    break;
-                case 0xf2fb8319:
-                    result = new TL_userContact_old(); //custom
-                    break;
-                case 0x7007b451:
-                    result = new TL_userSelf_old2(); //custom
-                    break;
-                case 0x720535ec:
-                    result = new TL_userSelf_old(); //custom
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in User", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
-
-    public static class TL_userEmpty extends User {
-        public static int constructor = 0x200250ba;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
-
-            first_name = "DELETED";
-            last_name = "";
-            phone = "";
-            status = new TL_userStatusEmpty();
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(id);
-        }
-    }
-
-    public static class TL_userDeleted_old extends TL_userDeleted {
-        public static int constructor = 0xb29ad7cc;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
-            first_name = stream.readString(exception);
-            last_name = stream.readString(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(id);
-            stream.writeString(first_name);
-            stream.writeString(last_name);
-        }
-    }
-
-    public static class TL_userForeign_old extends TL_userForeign {
-        public static int constructor = 0x5214c89d;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
-            first_name = stream.readString(exception);
-            last_name = stream.readString(exception);
-            access_hash = stream.readInt64(exception);
-            photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
-            status = UserStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(id);
-            stream.writeString(first_name);
-            stream.writeString(last_name);
-            stream.writeInt64(access_hash);
-            photo.serializeToStream(stream);
-            status.serializeToStream(stream);
-        }
-    }
-
-    public static class TL_userRequest_old extends TL_userRequest {
-        public static int constructor = 0x22e8ceb0;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
-            first_name = stream.readString(exception);
-            last_name = stream.readString(exception);
-            access_hash = stream.readInt64(exception);
-            phone = stream.readString(exception);
-            photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
-            status = UserStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(id);
-            stream.writeString(first_name);
-            stream.writeString(last_name);
-            stream.writeInt64(access_hash);
-            stream.writeString(phone);
-            photo.serializeToStream(stream);
-            status.serializeToStream(stream);
-        }
-    }
-
-    public static class TL_userContact_old extends TL_userContact {
-        public static int constructor = 0xf2fb8319;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
-            first_name = stream.readString(exception);
-            last_name = stream.readString(exception);
-            access_hash = stream.readInt64(exception);
-            phone = stream.readString(exception);
-            photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
-            status = UserStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(id);
-            stream.writeString(first_name);
-            stream.writeString(last_name);
-            stream.writeInt64(access_hash);
-            stream.writeString(phone);
-            photo.serializeToStream(stream);
-            status.serializeToStream(stream);
-        }
-    }
-
-    public static class TL_userSelf_old2 extends TL_userSelf {
-        public static int constructor = 0x7007b451;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
-            first_name = stream.readString(exception);
-            last_name = stream.readString(exception);
-            username = stream.readString(exception);
-            phone = stream.readString(exception);
-            photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
-            status = UserStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
-            stream.readBool(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(id);
-            stream.writeString(first_name);
-            stream.writeString(last_name);
-            stream.writeString(username);
-            stream.writeString(phone);
-            photo.serializeToStream(stream);
-            status.serializeToStream(stream);
-            stream.writeBool(false);
-        }
-    }
-
-    public static class TL_userSelf_old extends TL_userSelf {
-        public static int constructor = 0x720535ec;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
-            first_name = stream.readString(exception);
-            last_name = stream.readString(exception);
-            phone = stream.readString(exception);
-            photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
-            status = UserStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
-            stream.readBool(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(id);
-            stream.writeString(first_name);
-            stream.writeString(last_name);
-            stream.writeString(phone);
-            photo.serializeToStream(stream);
-            status.serializeToStream(stream);
-            stream.writeBool(false);
-        }
-    }
-    //User end
-
-    //Video start
-    public static class Video extends TLObject {
-        public long id;
-        public long access_hash;
-        public int user_id;
-        public int date;
-        public int duration;
-        public int size;
-        public PhotoSize thumb;
-        public int dc_id;
-        public int w;
-        public int h;
-        public String caption;
-        public String mime_type;
-        public byte[] key; //custom
-        public byte[] iv; //custom
-        public VideoEditedInfo videoEditedInfo = null; //custom
-
-        public static Video TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            Video result = null;
-            switch(constructor) {
-                case 0xee9f4a4d:
-                    result = new TL_video();
-                    break;
-                case 0xc10658a8:
-                    result = new TL_videoEmpty();
-                    break;
-                case 0x5a04a49f:
-                    result = new TL_video_old(); //custom
-                    break;
-                case 0x55555553:
-                    result = new TL_videoEncrypted(); //custom
-                    break;
-                case 0x388fa391:
-                    result = new TL_video_old2(); //custom
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in Video", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
-
-    public static class TL_video_old extends TL_video {
-        public static int constructor = 0x5a04a49f;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt64(exception);
-            access_hash = stream.readInt64(exception);
-            user_id = stream.readInt32(exception);
-            date = stream.readInt32(exception);
-            caption = stream.readString(exception);
-            duration = stream.readInt32(exception);
-            size = stream.readInt32(exception);
-            thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
-            dc_id = stream.readInt32(exception);
-            w = stream.readInt32(exception);
-            h = stream.readInt32(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt64(id);
-            stream.writeInt64(access_hash);
-            stream.writeInt32(user_id);
-            stream.writeInt32(date);
-            stream.writeString(caption);
-            stream.writeInt32(duration);
-            stream.writeInt32(size);
-            thumb.serializeToStream(stream);
-            stream.writeInt32(dc_id);
-            stream.writeInt32(w);
-            stream.writeInt32(h);
-        }
-    }
-
-    public static class TL_video_old2 extends TL_video {
-        public static int constructor = 0x388fa391;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt64(exception);
-            access_hash = stream.readInt64(exception);
-            user_id = stream.readInt32(exception);
-            date = stream.readInt32(exception);
-            caption = stream.readString(exception);
-            duration = stream.readInt32(exception);
-            mime_type = stream.readString(exception);
-            size = stream.readInt32(exception);
-            thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
-            dc_id = stream.readInt32(exception);
-            w = stream.readInt32(exception);
-            h = stream.readInt32(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt64(id);
-            stream.writeInt64(access_hash);
-            stream.writeInt32(user_id);
-            stream.writeInt32(date);
-            stream.writeString(caption);
-            stream.writeInt32(duration);
-            stream.writeString(mime_type);
-            stream.writeInt32(size);
-            thumb.serializeToStream(stream);
-            stream.writeInt32(dc_id);
-            stream.writeInt32(w);
-            stream.writeInt32(h);
-        }
-    }
-
-    public static class TL_videoEncrypted extends TL_video {
-        public static int constructor = 0x55555553;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt64(exception);
-            access_hash = stream.readInt64(exception);
-            user_id = stream.readInt32(exception);
-            date = stream.readInt32(exception);
-            caption = stream.readString(exception);
-            duration = stream.readInt32(exception);
-            size = stream.readInt32(exception);
-            thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
-            dc_id = stream.readInt32(exception);
-            w = stream.readInt32(exception);
-            h = stream.readInt32(exception);
-            key = stream.readByteArray(exception);
-            iv = stream.readByteArray(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt64(id);
-            stream.writeInt64(access_hash);
-            stream.writeInt32(user_id);
-            stream.writeInt32(date);
-            stream.writeString(caption);
-            stream.writeInt32(duration);
-            stream.writeInt32(size);
-            thumb.serializeToStream(stream);
-            stream.writeInt32(dc_id);
-            stream.writeInt32(w);
-            stream.writeInt32(h);
-            stream.writeByteArray(key);
-            stream.writeByteArray(iv);
-        }
-    }
-
-    public static class VideoEditedInfo {
-        public long startTime;
-        public long endTime;
-        public int rotationValue;
-        public int originalWidth;
-        public int originalHeight;
-        public int resultWidth;
-        public int resultHeight;
-        public int bitrate;
-        public String originalPath;
-
-        public String getString() {
-            return String.format(Locale.US, "-1_%d_%d_%d_%d_%d_%d_%d_%d_%s", startTime, endTime, rotationValue, originalWidth, originalHeight, bitrate, resultWidth, resultHeight, originalPath);
-        }
-
-        public void parseString(String string) {
-            if (string.length() < 6) {
-                return;
-            }
-            String args[] = string.split("_");
-            if (args.length >= 10) {
-                startTime = Long.parseLong(args[1]);
-                endTime = Long.parseLong(args[2]);
-                rotationValue = Integer.parseInt(args[3]);
-                originalWidth = Integer.parseInt(args[4]);
-                originalHeight = Integer.parseInt(args[5]);
-                bitrate = Integer.parseInt(args[6]);
-                resultWidth = Integer.parseInt(args[7]);
-                resultHeight = Integer.parseInt(args[8]);
-                for (int a = 9; a < args.length; a++) {
-                    if (originalPath == null) {
-                        originalPath = args[a];
-                    } else {
-                        originalPath += "_" + args[a];
-                    }
-                }
-            }
-        }
-    }
-    //Video end
-
-    //Document start
-    public static class Document extends TLObject {
-        public long id;
-        public long access_hash;
-        public int date;
-        public String mime_type;
-        public int size;
-        public PhotoSize thumb;
-        public int dc_id;
-        public ArrayList<DocumentAttribute> attributes = new ArrayList<>();
-        public byte[] key; //custom
-        public byte[] iv; //custom
-
-        public static Document TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            Document result = null;
-            switch(constructor) {
-                case 0x36f8c871:
-                    result = new TL_documentEmpty();
-                    break;
-                case 0xf9a39f4f:
-                    result = new TL_document();
-                    break;
-                case 0x55555558:
-                    result = new TL_documentEncrypted(); //custom
-                    break;
-                case 0x55555556:
-                    result = new TL_documentEncrypted_old(); //custom
-                    break;
-                case 0x9efc6326:
-                    result = new TL_document_old(); //custom
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in Document", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
-
-    public static class TL_documentEncrypted extends TL_document {
-        public static int constructor = 0x55555558;
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt64(exception);
-            access_hash = stream.readInt64(exception);
-            date = stream.readInt32(exception);
-            mime_type = stream.readString(exception);
-            size = stream.readInt32(exception);
-            thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
-            dc_id = stream.readInt32(exception);
-            stream.readInt32(exception);
-            int count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                attributes.add(DocumentAttribute.TLdeserialize(stream, stream.readInt32(exception), exception));
-            }
-            key = stream.readByteArray(exception);
-            iv = stream.readByteArray(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt64(id);
-            stream.writeInt64(access_hash);
-            stream.writeInt32(date);
-            stream.writeString(mime_type);
-            stream.writeInt32(size);
-            thumb.serializeToStream(stream);
-            stream.writeInt32(dc_id);
-            stream.writeInt32(0x1cb5c415);
-            int count = attributes.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                attributes.get(a).serializeToStream(stream);
-            }
-            stream.writeByteArray(key);
-            stream.writeByteArray(iv);
-        }
-    }
-
-    public static class TL_documentEncrypted_old extends TL_document {
-        public static int constructor = 0x55555556;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt64(exception);
-            access_hash = stream.readInt64(exception);
-            stream.readInt32(exception);
-            date = stream.readInt32(exception);
-            TL_documentAttributeFilename fileName = new TL_documentAttributeFilename();
-            fileName.file_name = stream.readString(exception);
-            attributes.add(fileName);
-            mime_type = stream.readString(exception);
-            size = stream.readInt32(exception);
-            thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
-            dc_id = stream.readInt32(exception);
-            key = stream.readByteArray(exception);
-            iv = stream.readByteArray(exception);
-        }
-    }
-
-    public static class TL_document_old extends TL_document {
-        public static int constructor = 0x9efc6326;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt64(exception);
-            access_hash = stream.readInt64(exception);
-            stream.readInt32(exception);
-            date = stream.readInt32(exception);
-            TL_documentAttributeFilename fileName = new TL_documentAttributeFilename();
-            fileName.file_name = stream.readString(exception);
-            attributes.add(fileName);
-            mime_type = stream.readString(exception);
-            size = stream.readInt32(exception);
-            thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
-            dc_id = stream.readInt32(exception);
-        }
-    }
-    //Document end
-
-    //Audio start
-    public static class Audio extends TLObject {
-        public long id;
-        public long access_hash;
-        public int user_id;
-        public int date;
-        public int duration;
-        public String mime_type;
-        public int size;
-        public int dc_id;
-        public byte[] key;
-        public byte[] iv;
-
-        public static Audio TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            Audio result = null;
-            switch(constructor) {
-                case 0x586988d8:
-                    result = new TL_audioEmpty();
-                    break;
-                case 0xc7ac6496:
-                    result = new TL_audio();
-                    break;
-                case 0x555555F6:
-                    result = new TL_audioEncrypted(); //custom
-                    break;
-                case 0x427425e7:
-                    result = new TL_audio_old(); //custom
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in Audio", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
-
-    public static class TL_audioEncrypted extends TL_audio {
-        public static int constructor = 0x555555F6;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt64(exception);
-            access_hash = stream.readInt64(exception);
-            user_id = stream.readInt32(exception);
-            date = stream.readInt32(exception);
-            duration = stream.readInt32(exception);
-            size = stream.readInt32(exception);
-            dc_id = stream.readInt32(exception);
-            key = stream.readByteArray(exception);
-            iv = stream.readByteArray(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt64(id);
-            stream.writeInt64(access_hash);
-            stream.writeInt32(user_id);
-            stream.writeInt32(date);
-            stream.writeInt32(duration);
-            stream.writeInt32(size);
-            stream.writeInt32(dc_id);
-            stream.writeByteArray(key);
-            stream.writeByteArray(iv);
-        }
-    }
-
-    public static class TL_audio_old extends TL_audio {
-        public static int constructor = 0x427425e7;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt64(exception);
-            access_hash = stream.readInt64(exception);
-            user_id = stream.readInt32(exception);
-            date = stream.readInt32(exception);
-            duration = stream.readInt32(exception);
-            size = stream.readInt32(exception);
-            dc_id = stream.readInt32(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt64(id);
-            stream.writeInt64(access_hash);
-            stream.writeInt32(user_id);
-            stream.writeInt32(date);
-            stream.writeInt32(duration);
-            stream.writeInt32(size);
-            stream.writeInt32(dc_id);
-        }
-    }
-    //Audio end
-
-    //SendMessageAction start
-    public static class SendMessageAction extends TLObject {
-        public int progress;
-
-        public static SendMessageAction TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            SendMessageAction result = null;
-            switch(constructor) {
-                case 0xd52f73f7:
-                    result = new TL_sendMessageRecordAudioAction();
-                    break;
-                case 0xf351d7ab:
-                    result = new TL_sendMessageUploadAudioAction();
-                    break;
-                case 0xd1d34a26:
-                    result = new TL_sendMessageUploadPhotoAction();
-                    break;
-                case 0xe9763aec:
-                    result = new TL_sendMessageUploadVideoAction();
-                    break;
-                case 0xfd5ec8f5:
-                    result = new TL_sendMessageCancelAction();
-                    break;
-                case 0x176f8ba1:
-                    result = new TL_sendMessageGeoLocationAction();
-                    break;
-                case 0x628cbc6f:
-                    result = new TL_sendMessageChooseContactAction();
-                    break;
-                case 0x16bf744e:
-                    result = new TL_sendMessageTypingAction();
-                    break;
-                case 0xaa0cd9e4:
-                    result = new TL_sendMessageUploadDocumentAction();
-                    break;
-                case 0xa187d66f:
-                    result = new TL_sendMessageRecordVideoAction();
-                    break;
-                case 0x92042ff7:
-                    result = new TL_sendMessageUploadVideoAction_old(); //custom
-                    break;
-                case 0xe6ac8a6f:
-                    result = new TL_sendMessageUploadAudioAction_old(); //custom
-                    break;
-                case 0x990a3c1a:
-                    result = new TL_sendMessageUploadPhotoAction_old(); //custom
-                    break;
-                case 0x8faee98e:
-                    result = new TL_sendMessageUploadDocumentAction_old(); //custom
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in SendMessageAction", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
-
-    public static class TL_sendMessageUploadDocumentAction_old extends TL_sendMessageUploadDocumentAction {
-        public static int constructor = 0x8faee98e;
-
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-        }
-    }
-
-    public static class TL_sendMessageUploadVideoAction_old extends TL_sendMessageUploadVideoAction {
-        public static int constructor = 0x92042ff7;
-
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-        }
-    }
-
-    public static class TL_sendMessageUploadPhotoAction_old extends TL_sendMessageUploadPhotoAction {
-        public static int constructor = 0x990a3c1a;
-
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-        }
-    }
-
-    public static class TL_sendMessageUploadAudioAction_old extends TL_sendMessageUploadAudioAction {
-        public static int constructor = 0xe6ac8a6f;
-
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-        }
-    }
-    //SendMessageAction end
-
-    //FileLocation start
-    public static class FileLocation extends TLObject {
-        public int dc_id;
-        public long volume_id;
-        public int local_id;
-        public long secret;
-        public String ext; //custom
-        public byte[] key; //custom
-        public byte[] iv; //custom
-
-        public static FileLocation TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            FileLocation result = null;
-            switch(constructor) {
-                case 0x53d69076:
-                    result = new TL_fileLocation();
-                    break;
-                case 0x7c596b46:
-                    result = new TL_fileLocationUnavailable();
-                    break;
-                case 0x55555554:
-                    result = new TL_fileEncryptedLocation(); //custom
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in FileLocation", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
-
-    public static class TL_fileEncryptedLocation extends FileLocation {
-        public static int constructor = 0x55555554;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            dc_id = stream.readInt32(exception);
-            volume_id = stream.readInt64(exception);
-            local_id = stream.readInt32(exception);
-            secret = stream.readInt64(exception);
-            key = stream.readByteArray(exception);
-            iv = stream.readByteArray(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(dc_id);
-            stream.writeInt64(volume_id);
-            stream.writeInt32(local_id);
-            stream.writeInt64(secret);
-            stream.writeByteArray(key);
-            stream.writeByteArray(iv);
-        }
-    }
-    //FileLocation end
-
-    //DocumentAttribute start
-    public static class DocumentAttribute extends TLObject {
-        public int w;
-        public int h;
-        public String file_name;
-        public int duration;
-        public String alt;
-
-        public static DocumentAttribute TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            DocumentAttribute result = null;
-            switch(constructor) {
-                case 0x11b58939:
-                    result = new TL_documentAttributeAnimated();
-                    break;
-                case 0x6c37c15c:
-                    result = new TL_documentAttributeImageSize();
-                    break;
-                case 0x15590068:
-                    result = new TL_documentAttributeFilename();
-                    break;
-                case 0x5910cccb:
-                    result = new TL_documentAttributeVideo();
-                    break;
-                case 0x994c9882:
-                    result = new TL_documentAttributeSticker();
-                    break;
-                case 0x51448e5:
-                    result = new TL_documentAttributeAudio();
-                    break;
-                case 0xfb0a5727:
-                    result = new TL_documentAttributeSticker_old(); //custom
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in DocumentAttribute", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
-
-    public static class TL_documentAttributeSticker_old extends TL_documentAttributeSticker {
-        public static int constructor = 0xfb0a5727;
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-        }
-    }
-    //DocumentAttribute end
-
-    //MessageMedia start
-    public static class MessageMedia extends TLObject {
-        public Video video;
-        public String caption;
-        public Photo photo;
-        public WebPage webpage;
-        public Document document;
-        public GeoPoint geo;
-        public Audio audio;
-        public String title;
-        public String address;
-        public String provider;
-        public String venue_id;
-        public String phone_number;
-        public String first_name;
-        public String last_name;
-        public int user_id;
-        public byte[] bytes; //custom
-
-        public static MessageMedia TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            MessageMedia result = null;
-            switch(constructor) {
-                case 0x5bcf1675:
-                    result = new TL_messageMediaVideo();
-                    break;
-                case 0x3d8ce53d:
-                    result = new TL_messageMediaPhoto();
-                    break;
-                case 0xa32dd600:
-                    result = new TL_messageMediaWebPage();
-                    break;
-                case 0x2fda2204:
-                    result = new TL_messageMediaDocument();
-                    break;
-                case 0x56e0d474:
-                    result = new TL_messageMediaGeo();
-                    break;
-                case 0x3ded6320:
-                    result = new TL_messageMediaEmpty();
-                    break;
-                case 0xc6b68300:
-                    result = new TL_messageMediaAudio();
-                    break;
-                case 0x7912b71f:
-                    result = new TL_messageMediaVenue();
-                    break;
-                case 0x5e7d2f39:
-                    result = new TL_messageMediaContact();
-                    break;
-                case 0x9f84f49e:
-                    result = new TL_messageMediaUnsupported();
-                    break;
-                case 0xa2d24290:
-                    result = new TL_messageMediaVideo_old(); //custom
-                    break;
-                case 0xc8c45a2a:
-                    result = new TL_messageMediaPhoto_old(); //custom
-                    break;
-                case 0x29632a36:
-                    result = new TL_messageMediaUnsupported_old(); //custom
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in MessageMedia", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
-
-    public static class TL_messageMediaUnsupported_old extends TL_messageMediaUnsupported {
-        public static int constructor = 0x29632a36;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            bytes = stream.readByteArray(exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeByteArray(bytes);
-        }
-    }
-
-    public static class TL_messageMediaPhoto_old extends TL_messageMediaPhoto {
-        public static int constructor = 0xc8c45a2a;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            photo = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            photo.serializeToStream(stream);
-        }
-    }
-
-    public static class TL_messageMediaVideo_old extends TL_messageMediaVideo {
-        public static int constructor = 0xa2d24290;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            video = Video.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            video.serializeToStream(stream);
-        }
-    }
-    //MessageMedia end
-
-    //DecryptedMessage start
-    public static class DecryptedMessage extends TLObject {
-        public long random_id;
-        public DecryptedMessageAction action;
-        public int ttl;
-        public String message;
-        public DecryptedMessageMedia media;
-        public byte[] random_bytes; //custom
-
-        public static DecryptedMessage TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            DecryptedMessage result = null;
-            switch(constructor) {
-                case 0x73164160:
-                    result = new TL_decryptedMessageService();
-                    break;
-                case 0x204d3878:
-                    result = new TL_decryptedMessage();
-                    break;
-                case 0xaa48327d:
-                    result = new TL_decryptedMessageService_old(); //custom
-                    break;
-                case 0x1f814f1f:
-                    result = new TL_decryptedMessage_old(); //custom
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in DecryptedMessage", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
-
-    public static class TL_decryptedMessageService_old extends TL_decryptedMessageService {
-        public static int constructor = 0xaa48327d;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            random_id = stream.readInt64(exception);
-            random_bytes = stream.readByteArray(exception);
-            action = DecryptedMessageAction.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt64(random_id);
-            stream.writeByteArray(random_bytes);
-            action.serializeToStream(stream);
-        }
-    }
-
-    public static class TL_decryptedMessage_old extends TL_decryptedMessage {
-        public static int constructor = 0x1f814f1f;
-
-
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            random_id = stream.readInt64(exception);
-            random_bytes = stream.readByteArray(exception);
-            message = stream.readString(exception);
-            media = DecryptedMessageMedia.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
-
-        public void serializeToStream(AbsSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt64(random_id);
-            stream.writeByteArray(random_bytes);
-            stream.writeString(message);
-            media.serializeToStream(stream);
-        }
-    }
-    //DecryptedMessage end
-
-    //Chat start
-    public static class TL_chatEmpty extends Chat {
-        public static int constructor = 0x9ba2d800;
-
+    public static class TL_message_old extends TL_message {
+        public static int constructor = 0x22eb6aba;
 
         public void readParams(AbsSerializedData stream, boolean exception) {
             id = stream.readInt32(exception);
-
-            title = "DELETED";
+            from_id = stream.readInt32(exception);
+            to_id = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
+            flags |= stream.readBool(exception) ? MESSAGE_FLAG_OUT : 0;
+            flags |= stream.readBool(exception) ? MESSAGE_FLAG_UNREAD : 0;
+            date = stream.readInt32(exception);
+            message = stream.readString(exception);
+            media = MessageMedia.TLdeserialize(stream, stream.readInt32(exception), exception);
+            if (id < 0 || (media != null && !(media instanceof TL_messageMediaEmpty) && message != null && message.length() != 0 && message.startsWith("-1"))) {
+                attachPath = stream.readString(exception);
+            }
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
             stream.writeInt32(id);
+            stream.writeInt32(from_id);
+            to_id.serializeToStream(stream);
+            stream.writeBool((flags & MESSAGE_FLAG_OUT) != 0);
+            stream.writeBool((flags & MESSAGE_FLAG_UNREAD) != 0);
+            stream.writeInt32(date);
+            stream.writeString(message);
+            media.serializeToStream(stream);
+            stream.writeString(attachPath);
         }
     }
-    //Chat end
-
-    //UserProfilePhoto start
-    public static class UserProfilePhoto extends TLObject {
-        public long photo_id;
-        public FileLocation photo_small;
-        public FileLocation photo_big;
-
-        public static UserProfilePhoto TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            UserProfilePhoto result = null;
-            switch(constructor) {
-                case 0x4f11bae1:
-                    result = new TL_userProfilePhotoEmpty();
-                    break;
-                case 0xd559d8c8:
-                    result = new TL_userProfilePhoto();
-                    break;
-                case 0x990d1493:
-                    result = new TL_userProfilePhotoOld();
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in UserProfilePhoto", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
-
-    public static class TL_userProfilePhotoOld extends UserProfilePhoto {
-        public static int constructor = 0x990d1493;
 
+    public static class TL_message_secret extends TL_message {
+        public static int constructor = 0x555555F8;
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            photo_small = FileLocation.TLdeserialize(stream, stream.readInt32(exception), exception);
-            photo_big = FileLocation.TLdeserialize(stream, stream.readInt32(exception), exception);
+            flags = stream.readInt32(exception);
+            id = stream.readInt32(exception);
+            ttl = stream.readInt32(exception);
+            from_id = stream.readInt32(exception);
+            to_id = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
+            date = stream.readInt32(exception);
+            message = stream.readString(exception);
+            media = MessageMedia.TLdeserialize(stream, stream.readInt32(exception), exception);
+            if (id < 0 || (media != null && !(media instanceof TL_messageMediaEmpty) && message != null && message.length() != 0 && message.startsWith("-1"))) {
+                attachPath = stream.readString(exception);
+            }
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            photo_small.serializeToStream(stream);
-            photo_big.serializeToStream(stream);
+            stream.writeInt32(flags);
+            stream.writeInt32(id);
+            stream.writeInt32(ttl);
+            stream.writeInt32(from_id);
+            to_id.serializeToStream(stream);
+            stream.writeInt32(date);
+            stream.writeString(message);
+            media.serializeToStream(stream);
+            stream.writeString(attachPath);
         }
     }
-    //UserProfilePhoto end
+    //Message end
 
-    //DecryptedMessageMedia start
-    public static class DecryptedMessageMedia extends TLObject {
-        public long id;
-        public long access_hash;
-        public int date;
-        public String mime_type;
-        public int size;
-        public int dc_id;
-        public ArrayList<DocumentAttribute> attributes = new ArrayList<>();
-        public int thumb_w;
-        public int thumb_h;
-        public String file_name;
-        public byte[] key;
-        public byte[] iv;
-        public double lat;
-        public double _long;
-        public int duration;
-        public int w;
-        public int h;
-        public String phone_number;
-        public String first_name;
-        public String last_name;
-        public int user_id;
-        public byte[] thumb; //custom
-        public PhotoSize thumbImage; //custom
+    //TL_dialog start
+    public static class TL_dialog extends TLObject {
+        public static int constructor = 0xc1dd804a;
 
-        public static DecryptedMessageMedia TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
-            DecryptedMessageMedia result = null;
-            switch(constructor) {
-                case 0xfa95b0dd:
-                    result = new TL_decryptedMessageMediaExternalDocument();
-                    break;
-                case 0xb095434b:
-                    result = new TL_decryptedMessageMediaDocument();
-                    break;
-                case 0x35480a59:
-                    result = new TL_decryptedMessageMediaGeoPoint();
-                    break;
-                case 0x57e0a9cb:
-                    result = new TL_decryptedMessageMediaAudio();
-                    break;
-                case 0x524a415d:
-                    result = new TL_decryptedMessageMediaVideo();
-                    break;
-                case 0x588a0a97:
-                    result = new TL_decryptedMessageMediaContact();
-                    break;
-                case 0x89f5c4a:
-                    result = new TL_decryptedMessageMediaEmpty();
-                    break;
-                case 0x32798a8c:
-                    result = new TL_decryptedMessageMediaPhoto();
-                    break;
-                case 0x4cee6ef3:
-                    result = new TL_decryptedMessageMediaVideo_old(); //custom
-                    break;
-                case 0x6080758f:
-                    result = new TL_decryptedMessageMediaAudio_old(); //custom
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in DecryptedMessageMedia", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
+        public Peer peer;
+        public int top_message;
+        public int read_inbox_max_id;
+        public int unread_count;
+        public PeerNotifySettings notify_settings;
+        public int last_message_date; //custom
+        public long id; //custom
+        public int last_read; //custom
+
+        public static TL_dialog TLdeserialize(AbsSerializedData stream, int constructor, boolean exception) {
+            if (TL_dialog.constructor != constructor) {
+                if (exception) {
+                    throw new RuntimeException(String.format("can't parse magic %x in TL_dialog", constructor));
+                } else {
+                    return null;
+                }
             }
+            TL_dialog result = new TL_dialog();
+            result.readParams(stream, exception);
             return result;
         }
-    }
-
-    public static class TL_decryptedMessageMediaExternalDocument extends DecryptedMessageMedia {
-        public static int constructor = 0xfa95b0dd;
-
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            id = stream.readInt64(exception);
-            access_hash = stream.readInt64(exception);
-            date = stream.readInt32(exception);
-            mime_type = stream.readString(exception);
-            size = stream.readInt32(exception);
-            thumbImage = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
-            dc_id = stream.readInt32(exception);
-            int magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            int count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                attributes.add(DocumentAttribute.TLdeserialize(stream, stream.readInt32(exception), exception));
-            }
+            peer = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
+            top_message = stream.readInt32(exception);
+            read_inbox_max_id = stream.readInt32(exception);
+            unread_count = stream.readInt32(exception);
+            notify_settings = PeerNotifySettings.TLdeserialize(stream, stream.readInt32(exception), exception);
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            stream.writeInt64(id);
-            stream.writeInt64(access_hash);
-            stream.writeInt32(date);
-            stream.writeString(mime_type);
-            stream.writeInt32(size);
-            thumbImage.serializeToStream(stream);
-            stream.writeInt32(dc_id);
-            stream.writeInt32(0x1cb5c415);
-            int count = attributes.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                attributes.get(a).serializeToStream(stream);
-            }
+            peer.serializeToStream(stream);
+            stream.writeInt32(top_message);
+            stream.writeInt32(read_inbox_max_id);
+            stream.writeInt32(unread_count);
+            notify_settings.serializeToStream(stream);
         }
     }
+    //TL_dialog end
 
-    public static class TL_decryptedMessageMediaVideo_old extends TL_decryptedMessageMediaVideo {
-        public static int constructor = 0x4cee6ef3;
+    //User start
+    public static class TL_userEmpty extends User {
+        public static int constructor = 0x200250ba;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            thumb = stream.readByteArray(exception);
-            thumb_w = stream.readInt32(exception);
-            thumb_h = stream.readInt32(exception);
-            duration = stream.readInt32(exception);
-            w = stream.readInt32(exception);
-            h = stream.readInt32(exception);
-            size = stream.readInt32(exception);
-            key = stream.readByteArray(exception);
-            iv = stream.readByteArray(exception);
+            id = stream.readInt32(exception);
+
+            first_name = "DELETED";
+            last_name = "";
+            phone = "";
+            status = new TL_userStatusEmpty();
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            stream.writeByteArray(thumb);
-            stream.writeInt32(thumb_w);
-            stream.writeInt32(thumb_h);
-            stream.writeInt32(duration);
-            stream.writeInt32(w);
-            stream.writeInt32(h);
-            stream.writeInt32(size);
-            stream.writeByteArray(key);
-            stream.writeByteArray(iv);
+            stream.writeInt32(id);
         }
     }
+    //User end
 
-    public static class TL_decryptedMessageMediaAudio_old extends TL_decryptedMessageMediaAudio {
-        public static int constructor = 0x6080758f;
+    //Chat start
+    public static class TL_chatEmpty extends Chat {
+        public static int constructor = 0x9ba2d800;
 
 
         public void readParams(AbsSerializedData stream, boolean exception) {
-            duration = stream.readInt32(exception);
-            size = stream.readInt32(exception);
-            key = stream.readByteArray(exception);
-            iv = stream.readByteArray(exception);
+            id = stream.readInt32(exception);
+
+            title = "DELETED";
         }
 
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
-            stream.writeInt32(duration);
-            stream.writeInt32(size);
-            stream.writeByteArray(key);
-            stream.writeByteArray(iv);
+            stream.writeInt32(id);
         }
     }
-    //DecryptedMessageMedia end
+    //Chat end
 
     //functions memory optimize
     public static class TL_upload_saveFilePart extends TLObject {
@@ -14879,10 +15512,6 @@ public TLObject deserializeResponse(AbsSerializedData stream, int constructor, b
             return RpcDropAnswer.TLdeserialize(stream, constructor, exception);
         }
 
-        public void readParams(AbsSerializedData stream, boolean exception) {
-            req_msg_id = stream.readInt64(exception);
-        }
-
         public void serializeToStream(AbsSerializedData stream) {
             stream.writeInt32(constructor);
             stream.writeInt64(req_msg_id);
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/TcpConnection.java b/TMessagesProj/src/main/java/org/telegram/messenger/TcpConnection.java
index 3772ed52c..217e63fb1 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/TcpConnection.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/TcpConnection.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -20,6 +20,7 @@
 import jawnae.pyronet.PyroSelector;
 
 public class TcpConnection extends ConnectionContext {
+
     public enum TcpConnectionState {
         TcpConnectionStageIdle,
         TcpConnectionStageConnecting,
@@ -30,8 +31,11 @@
 
     public interface TcpConnectionDelegate {
         void tcpConnectionClosed(TcpConnection connection);
+
         void tcpConnectionConnected(TcpConnection connection);
+
         void tcpConnectionQuiackAckReceived(TcpConnection connection, int ack);
+
         void tcpConnectionReceivedData(TcpConnection connection, ByteBufferDesc data, int length);
     }
 
@@ -41,6 +45,7 @@
     public volatile int channelToken = 0;
     private String hostAddress;
     private int hostPort;
+    private int currentAddressFlag;
     private int datacenterId;
     private int failedConnectionCount;
     public TcpConnectionDelegate delegate;
@@ -62,13 +67,14 @@ public TcpConnection(int did) {
         if (selector == null) {
             selector = new PyroSelector();
             selector.spawnNetworkThread("network thread");
-            BuffersStorage storage = BuffersStorage.getInstance();
+            BuffersStorage.getInstance();
         }
         datacenterId = did;
         connectionState = TcpConnectionState.TcpConnectionStageIdle;
     }
 
     static volatile Integer nextChannelToken = 1;
+
     static int generateChannelToken() {
         return nextChannelToken++;
     }
@@ -101,8 +107,30 @@ public void run() {
                 connectionState = TcpConnectionState.TcpConnectionStageConnecting;
                 try {
                     Datacenter datacenter = ConnectionsManager.getInstance().datacenterWithId(datacenterId);
-                    hostAddress = datacenter.getCurrentAddress();
-                    hostPort = datacenter.getCurrentPort();
+                    boolean isIpv6 = ConnectionsManager.useIpv6Address();
+                    if (transportRequestClass == RPCRequest.RPCRequestClassDownloadMedia) {
+                        currentAddressFlag = 2;
+                        hostAddress = datacenter.getCurrentAddress(currentAddressFlag | (isIpv6 ? 1 : 0));
+                        if (hostAddress == null) {
+                            currentAddressFlag = 0;
+                            hostAddress = datacenter.getCurrentAddress(currentAddressFlag | (isIpv6 ? 1 : 0));
+                        }
+                        if (hostAddress == null && isIpv6) {
+                            currentAddressFlag = 2;
+                            hostAddress = datacenter.getCurrentAddress(currentAddressFlag);
+                            if (hostAddress == null) {
+                                currentAddressFlag = 0;
+                                hostAddress = datacenter.getCurrentAddress(currentAddressFlag);
+                            }
+                        }
+                    } else {
+                        currentAddressFlag = 0;
+                        hostAddress = datacenter.getCurrentAddress(currentAddressFlag | (isIpv6 ? 1 : 0));
+                        if (isIpv6 && hostAddress == null) {
+                            hostAddress = datacenter.getCurrentAddress(currentAddressFlag);
+                        }
+                    }
+                    hostPort = datacenter.getCurrentPort(currentAddressFlag);
 
                     try {
                         synchronized (timerSync) {
@@ -163,7 +191,7 @@ private void handleConnectionError(Exception e) {
         } catch (Exception e2) {
             FileLog.e("tmessages", e2);
         }
-        connectionState =  TcpConnectionState.TcpConnectionStageReconnecting;
+        connectionState = TcpConnectionState.TcpConnectionStageReconnecting;
         if (delegate != null) {
             final TcpConnectionDelegate finalDelegate = delegate;
             Utilities.stageQueue.postRunnable(new Runnable() {
@@ -186,7 +214,7 @@ public void run() {
             isNextPort = true;
             if (failedConnectionCount > willRetryConnectCount) {
                 Datacenter datacenter = ConnectionsManager.getInstance().datacenterWithId(datacenterId);
-                datacenter.nextAddressOrPort();
+                datacenter.nextAddressOrPort(currentAddressFlag);
                 failedConnectionCount = 0;
             }
         }
@@ -319,7 +347,7 @@ public void run() {
 
                 ByteBufferDesc buffer = BuffersStorage.getInstance().getFreeBuffer(bufferLen);
                 if (firstPacket) {
-                    buffer.writeByte((byte)0xef);
+                    buffer.writeByte((byte) 0xef);
                     firstPacket = false;
                 }
                 if (packetLength < 0x7f) {
@@ -354,12 +382,10 @@ private void readData(ByteBuffer buffer) throws Exception {
         ByteBuffer parseLaterBuffer = null;
         if (restOfTheData != null) {
             if (lastPacketLength == 0) {
-                //FileLog.e("tmessages", this +  " write addition data to restOfTheData");
                 if (restOfTheData.capacity() - restOfTheData.position() >= buffer.limit()) {
                     restOfTheData.limit(restOfTheData.position() + buffer.limit());
                     restOfTheData.put(buffer);
                     buffer = restOfTheData.buffer;
-                    //FileLog.e("tmessages", this +  " no need to recreate buffer");
                 } else {
                     ByteBufferDesc newBuffer = BuffersStorage.getInstance().getFreeBuffer(restOfTheData.limit() + buffer.limit());
                     restOfTheData.rewind();
@@ -368,30 +394,23 @@ private void readData(ByteBuffer buffer) throws Exception {
                     buffer = newBuffer.buffer;
                     BuffersStorage.getInstance().reuseFreeBuffer(restOfTheData);
                     restOfTheData = newBuffer;
-                    //FileLog.e("tmessages", this +  " NEED to recreate buffer");
                 }
             } else {
-                //FileLog.e("tmessages", this +  " write buffer to restOfTheData buffer of len = " + lastPacketLength);
-                int len = 0;
+                int len;
                 if (lastPacketLength - restOfTheData.position() <= buffer.limit()) {
                     len = lastPacketLength - restOfTheData.position();
-                    //FileLog.e("tmessages", this +  " received buffer - OK!");
                 } else {
                     len = buffer.limit();
-                    //FileLog.e("tmessages", this +  " received buffer less than need");
                 }
                 int oldLimit = buffer.limit();
                 buffer.limit(len);
                 restOfTheData.put(buffer);
                 buffer.limit(oldLimit);
                 if (restOfTheData.position() != lastPacketLength) {
-                    //FileLog.e("tmessages", this +  " don't get much data to restOfTheData");
                     return;
                 } else {
-                    //FileLog.e("tmessages", this +  " get much data to restOfTheData - OK!");
                     if (buffer.hasRemaining()) {
                         parseLaterBuffer = buffer;
-                        //FileLog.e("tmessages", this +  " something remain in the received buffer");
                     } else {
                         parseLaterBuffer = null;
                     }
@@ -427,10 +446,8 @@ private void readData(ByteBuffer buffer) throws Exception {
                     restOfTheData.put(buffer);
                     restOfTheData.limit(restOfTheData.position());
                     lastPacketLength = 0;
-                    //FileLog.e("tmessages", this +  " 1 - size less than 4 bytes - write to free buffer");
                     if (reuseLater != null) {
                         BuffersStorage.getInstance().reuseFreeBuffer(reuseLater);
-                        //FileLog.e("tmessages", this +  " 1 - reuse later buffer1");
                     }
                     break;
                 }
@@ -450,11 +467,10 @@ public void run() {
             }
 
             if (fByte != 0x7f) {
-                currentPacketLength = ((int)fByte) * 4;
+                currentPacketLength = ((int) fByte) * 4;
             } else {
                 buffer.reset();
                 if (buffer.remaining() < 4) {
-                    //FileLog.e("tmessages", this +  " 2 - size less than 4 bytes - write to free buffer");
                     if (restOfTheData == null || restOfTheData != null && restOfTheData.position() != 0) {
                         ByteBufferDesc reuseLater = restOfTheData;
                         restOfTheData = BuffersStorage.getInstance().getFreeBuffer(16384);
@@ -463,7 +479,6 @@ public void run() {
                         lastPacketLength = 0;
                         if (reuseLater != null) {
                             BuffersStorage.getInstance().reuseFreeBuffer(reuseLater);
-                            //FileLog.e("tmessages", this +  " 2 - reuse later buffer1");
                         }
                     } else {
                         restOfTheData.position(restOfTheData.limit());
@@ -491,10 +506,8 @@ public void run() {
                 if (restOfTheData != null && restOfTheData.capacity() < len) {
                     reuseLater = restOfTheData;
                     restOfTheData = null;
-                    //FileLog.e("tmessages", this +  " not enough space for len, recreate buffer = " + len);
                 }
                 if (restOfTheData == null) {
-                    //FileLog.e("tmessages", this +  " write to restOfTheData, get buffer len = " + len);
                     buffer.reset();
                     restOfTheData = BuffersStorage.getInstance().getFreeBuffer(len);
                     restOfTheData.put(buffer);
@@ -505,7 +518,6 @@ public void run() {
                 lastPacketLength = len;
                 if (reuseLater != null) {
                     BuffersStorage.getInstance().reuseFreeBuffer(reuseLater);
-                    //FileLog.e("tmessages", this +  " 3 - reuse later buffer1");
                 }
                 return;
             }
@@ -533,17 +545,14 @@ public void run() {
                 if (lastPacketLength != 0 && restOfTheData.position() == lastPacketLength || lastPacketLength == 0 && !restOfTheData.hasRemaining()) {
                     BuffersStorage.getInstance().reuseFreeBuffer(restOfTheData);
                     restOfTheData = null;
-                    //FileLog.e("tmessages", this +  " restOfTheData parsed null it");
                 } else {
                     restOfTheData.compact();
                     restOfTheData.limit(restOfTheData.position());
                     restOfTheData.position(0);
-                    //FileLog.e("tmessages", this +  " restOfTheData NOT parsed, compact");
                 }
             }
 
             if (parseLaterBuffer != null) {
-                //FileLog.e("tmessages", this +  " there is parseLaterBuffer");
                 buffer = parseLaterBuffer;
                 parseLaterBuffer = null;
             }
@@ -597,7 +606,7 @@ public void run() {
                 isNextPort = true;
                 if (failedConnectionCount > willRetryConnectCount || switchToNextPort) {
                     Datacenter datacenter = ConnectionsManager.getInstance().datacenterWithId(datacenterId);
-                    datacenter.nextAddressOrPort();
+                    datacenter.nextAddressOrPort(currentAddressFlag);
                     failedConnectionCount = 0;
                 }
             }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/UserConfig.java b/TMessagesProj/src/main/java/org/telegram/messenger/UserConfig.java
index 2ae522fb4..31b0ffce5 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/UserConfig.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/UserConfig.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -17,6 +17,7 @@
 import java.io.File;
 
 public class UserConfig {
+
     private static TLRPC.User currentUser;
     public static boolean registeredForPush = false;
     public static boolean registeredForInternalPush = false;
@@ -31,6 +32,7 @@
     public static boolean saveIncomingPhotos = false;
     public static int contactsVersion = 1;
     public static String passcodeHash = "";
+    public static byte[] passcodeSalt = new byte[0];
     public static boolean appLocked = false;
     public static int passcodeType = 0;
     public static int autoLockIn = 60 * 60;
@@ -68,6 +70,7 @@ public static void saveConfig(boolean withFile, File oldFile) {
                 editor.putBoolean("registeredForInternalPush", registeredForInternalPush);
                 editor.putBoolean("blockedUsersLoaded", blockedUsersLoaded);
                 editor.putString("passcodeHash1", passcodeHash);
+                editor.putString("passcodeSalt", passcodeSalt.length > 0 ? Base64.encodeToString(passcodeSalt, Base64.DEFAULT) : "");
                 editor.putBoolean("appLocked", appLocked);
                 editor.putInt("passcodeType", passcodeType);
                 editor.putInt("autoLockIn", autoLockIn);
@@ -85,6 +88,7 @@ public static void saveConfig(boolean withFile, File oldFile) {
                 } else {
                     editor.remove("user");
                 }
+
                 editor.commit();
                 if (oldFile != null) {
                     oldFile.delete();
@@ -211,8 +215,49 @@ public void run() {
                         data.cleanup();
                     }
                 }
+                String passcodeSaltString = preferences.getString("passcodeSalt", "");
+                if (passcodeSaltString.length() > 0) {
+                    passcodeSalt = Base64.decode(passcodeSaltString, Base64.DEFAULT);
+                } else {
+                    passcodeSalt = new byte[0];
+                }
+            }
+        }
+    }
+
+    public static boolean checkPasscode(String passcode) {
+        if (passcodeSalt.length == 0) {
+            boolean result = Utilities.MD5(passcode).equals(passcodeHash);
+            if (result) {
+                try {
+                    passcodeSalt = new byte[16];
+                    Utilities.random.nextBytes(passcodeSalt);
+                    byte[] passcodeBytes = passcode.getBytes("UTF-8");
+                    byte[] bytes = new byte[32 + passcodeBytes.length];
+                    System.arraycopy(passcodeSalt, 0, bytes, 0, 16);
+                    System.arraycopy(passcodeBytes, 0, bytes, 16, passcodeBytes.length);
+                    System.arraycopy(passcodeSalt, 0, bytes, passcodeBytes.length + 16, 16);
+                    passcodeHash = Utilities.bytesToHex(Utilities.computeSHA256(bytes, 0, bytes.length));
+                    saveConfig(false);
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+            return result;
+        } else {
+            try {
+                byte[] passcodeBytes = passcode.getBytes("UTF-8");
+                byte[] bytes = new byte[32 + passcodeBytes.length];
+                System.arraycopy(passcodeSalt, 0, bytes, 0, 16);
+                System.arraycopy(passcodeBytes, 0, bytes, 16, passcodeBytes.length);
+                System.arraycopy(passcodeSalt, 0, bytes, passcodeBytes.length + 16, 16);
+                String hash = Utilities.bytesToHex(Utilities.computeSHA256(bytes, 0, bytes.length));
+                return passcodeHash.equals(hash);
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
             }
         }
+        return false;
     }
 
     public static void clearConfig() {
@@ -229,6 +274,7 @@ public static void clearConfig() {
         appLocked = false;
         passcodeType = 0;
         passcodeHash = "";
+        passcodeSalt = new byte[0];
         autoLockIn = 60 * 60;
         lastPauseTime = 0;
         isWaitingForPasscodeEnter = false;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java b/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
index 2b1ac08eb..73326ac0c 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
@@ -1,43 +1,24 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 2.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
 
-import android.app.Activity;
-import android.content.ContentUris;
 import android.content.Context;
-import android.content.Intent;
 import android.content.SharedPreferences;
-import android.database.Cursor;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
-import android.net.Uri;
-import android.os.Build;
-import android.os.Environment;
-import android.provider.DocumentsContract;
-import android.provider.MediaStore;
-import android.text.SpannableStringBuilder;
 import android.util.Base64;
 
-import net.hockeyapp.android.CrashManager;
-import net.hockeyapp.android.CrashManagerListener;
-import net.hockeyapp.android.UpdateManager;
-
-import org.telegram.android.AndroidUtilities;
-
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
-import java.io.FileOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
 import java.math.BigInteger;
 import java.nio.ByteBuffer;
 import java.security.KeyFactory;
@@ -45,9 +26,7 @@
 import java.security.PublicKey;
 import java.security.SecureRandom;
 import java.security.spec.RSAPublicKeySpec;
-import java.text.SimpleDateFormat;
 import java.util.ArrayList;
-import java.util.Date;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import java.util.zip.GZIPInputStream;
@@ -56,6 +35,7 @@
 import javax.crypto.Cipher;
 
 public class Utilities {
+
     public static Pattern pattern = Pattern.compile("[0-9]+");
     public static SecureRandom random = new SecureRandom();
 
@@ -111,13 +91,19 @@
     }
 
     public native static long doPQNative(long _what);
+
     public native static void loadBitmap(String path, Bitmap bitmap, int scale, int width, int height, int stride);
+
     public native static int pinBitmap(Bitmap bitmap);
+
     public native static void blurBitmap(Object bitmap, int radius, int unpin);
+
     public native static void calcCDT(ByteBuffer hsvBuffer, int width, int height, ByteBuffer buffer);
+
     public native static Bitmap loadWebpImage(ByteBuffer buffer, int len, BitmapFactory.Options options);
-    public native static Bitmap loadBpgImage(ByteBuffer buffer, int len, BitmapFactory.Options options);
+
     public native static int convertVideoFrame(ByteBuffer src, ByteBuffer dest, int destFormat, int width, int height, int padding, int swap);
+
     private native static void aesIgeEncryption(ByteBuffer buffer, byte[] key, byte[] iv, boolean encrypt, int offset, int length);
 
     public static void aesIgeEncryption(ByteBuffer buffer, byte[] key, byte[] iv, boolean encrypt, boolean changeIv, int offset, int length) {
@@ -287,12 +273,13 @@ public static boolean arraysEquals(byte[] arr1, int offset1, byte[] arr2, int of
         if (arr1 == null || arr2 == null || arr1.length - offset1 != arr2.length - offset2 || arr1.length - offset1 < 0) {
             return false;
         }
+        boolean result = true;
         for (int a = offset1; a < arr1.length; a++) {
             if (arr1[a + offset1] != arr2[a + offset2]) {
-                return false;
+                result = false;
             }
         }
-        return true;
+        return result;
     }
 
     public static byte[] computeSHA1(byte[] convertme, int offset, int len) {
@@ -321,7 +308,7 @@ public static boolean arraysEquals(byte[] arr1, int offset1, byte[] arr2, int of
             convertme.limit(oldl);
             convertme.position(oldp);
         }
-        return null;
+        return new byte[0];
     }
 
     public static byte[] computeSHA1(ByteBuffer convertme) {
@@ -362,59 +349,6 @@ public static long bytesToLong(byte[] bytes) {
                 + (((long) bytes[3] & 0xFF) << 24) + (((long) bytes[2] & 0xFF) << 16) + (((long) bytes[1] & 0xFF) << 8) + ((long) bytes[0] & 0xFF);
     }
 
-    public static MessageKeyData generateMessageKeyData(byte[] authKey, byte[] messageKey, boolean incoming) {
-        MessageKeyData keyData = new MessageKeyData();
-        if (authKey == null || authKey.length == 0) {
-            keyData.aesIv = null;
-            keyData.aesKey = null;
-            return keyData;
-        }
-
-        int x = incoming ? 8 : 0;
-
-        SerializedData data = new SerializedData();
-        data.writeRaw(messageKey);
-        data.writeRaw(authKey, x, 32);
-        byte[] sha1_a = Utilities.computeSHA1(data.toByteArray());
-        data.cleanup();
-
-        data = new SerializedData();
-        data.writeRaw(authKey, 32 + x, 16);
-        data.writeRaw(messageKey);
-        data.writeRaw(authKey, 48 + x, 16);
-        byte[] sha1_b = Utilities.computeSHA1(data.toByteArray());
-        data.cleanup();
-
-        data = new SerializedData();
-        data.writeRaw(authKey, 64 + x, 32);
-        data.writeRaw(messageKey);
-        byte[] sha1_c = Utilities.computeSHA1(data.toByteArray());
-        data.cleanup();
-
-        data = new SerializedData();
-        data.writeRaw(messageKey);
-        data.writeRaw(authKey, 96 + x, 32);
-        byte[] sha1_d = Utilities.computeSHA1(data.toByteArray());
-        data.cleanup();
-
-        data = new SerializedData();
-        data.writeRaw(sha1_a, 0, 8);
-        data.writeRaw(sha1_b, 8, 12);
-        data.writeRaw(sha1_c, 4, 12);
-        keyData.aesKey = data.toByteArray();
-        data.cleanup();
-
-        data = new SerializedData();
-        data.writeRaw(sha1_a, 8, 12);
-        data.writeRaw(sha1_b, 0, 8);
-        data.writeRaw(sha1_c, 16, 4);
-        data.writeRaw(sha1_d, 0, 8);
-        keyData.aesIv = data.toByteArray();
-        data.cleanup();
-
-        return keyData;
-    }
-
     public static TLObject decompress(byte[] data, TLObject parentObject, boolean exception) {
         final int BUFFER_SIZE = 16384;
         ByteArrayInputStream is = new ByteArrayInputStream(data);
@@ -477,42 +411,6 @@ public static TLObject decompress(byte[] data, TLObject parentObject, boolean ex
         return packedData;
     }
 
-    public static boolean copyFile(InputStream sourceFile, File destFile) throws IOException {
-        OutputStream out = new FileOutputStream(destFile);
-        byte[] buf = new byte[4096];
-        int len;
-        while ((len = sourceFile.read(buf)) > 0) {
-            Thread.yield();
-            out.write(buf, 0, len);
-        }
-        out.close();
-        return true;
-    }
-
-    public static boolean copyFile(File sourceFile, File destFile) throws IOException {
-        if (!destFile.exists()) {
-            destFile.createNewFile();
-        }
-        FileInputStream source = null;
-        FileOutputStream destination = null;
-        try {
-            source = new FileInputStream(sourceFile);
-            destination = new FileOutputStream(destFile);
-            destination.getChannel().transferFrom(source.getChannel(), 0, source.getChannel().size());
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-            return false;
-        } finally {
-            if (source != null) {
-                source.close();
-            }
-            if (destination != null) {
-                destination.close();
-            }
-        }
-        return true;
-    }
-
     public static String MD5(String md5) {
         if (md5 == null) {
             return null;
@@ -530,249 +428,4 @@ public static String MD5(String md5) {
         }
         return null;
     }
-
-    public static void addMediaToGallery(String fromPath) {
-        if (fromPath == null) {
-            return;
-        }
-        File f = new File(fromPath);
-        Uri contentUri = Uri.fromFile(f);
-        addMediaToGallery(contentUri);
-    }
-
-    public static void addMediaToGallery(Uri uri) {
-        if (uri == null) {
-            return;
-        }
-        Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);
-        mediaScanIntent.setData(uri);
-        ApplicationLoader.applicationContext.sendBroadcast(mediaScanIntent);
-    }
-
-    private static File getAlbumDir() {
-        File storageDir = null;
-        if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
-            storageDir = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES), "Telegram");
-            if (storageDir != null) {
-                if (!storageDir.mkdirs()) {
-                    if (!storageDir.exists()){
-                        FileLog.d("tmessages", "failed to create directory");
-                        return null;
-                    }
-                }
-            }
-        } else {
-            FileLog.d("tmessages", "External storage is not mounted READ/WRITE.");
-        }
-
-        return storageDir;
-    }
-
-    public static String getPath(final Uri uri) {
-        try {
-            final boolean isKitKat = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
-            if (isKitKat && DocumentsContract.isDocumentUri(ApplicationLoader.applicationContext, uri)) {
-                if (isExternalStorageDocument(uri)) {
-                    final String docId = DocumentsContract.getDocumentId(uri);
-                    final String[] split = docId.split(":");
-                    final String type = split[0];
-                    if ("primary".equalsIgnoreCase(type)) {
-                        return Environment.getExternalStorageDirectory() + "/" + split[1];
-                    }
-                } else if (isDownloadsDocument(uri)) {
-                    final String id = DocumentsContract.getDocumentId(uri);
-                    final Uri contentUri = ContentUris.withAppendedId(Uri.parse("content://downloads/public_downloads"), Long.valueOf(id));
-                    return getDataColumn(ApplicationLoader.applicationContext, contentUri, null, null);
-                } else if (isMediaDocument(uri)) {
-                    final String docId = DocumentsContract.getDocumentId(uri);
-                    final String[] split = docId.split(":");
-                    final String type = split[0];
-
-                    Uri contentUri = null;
-                    switch (type) {
-                        case "image":
-                            contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
-                            break;
-                        case "video":
-                            contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;
-                            break;
-                        case "audio":
-                            contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
-                            break;
-                    }
-
-                    final String selection = "_id=?";
-                    final String[] selectionArgs = new String[] {
-                            split[1]
-                    };
-
-                    return getDataColumn(ApplicationLoader.applicationContext, contentUri, selection, selectionArgs);
-                }
-            } else if ("content".equalsIgnoreCase(uri.getScheme())) {
-                return getDataColumn(ApplicationLoader.applicationContext, uri, null, null);
-            } else if ("file".equalsIgnoreCase(uri.getScheme())) {
-                return uri.getPath();
-            }
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-        }
-        return null;
-    }
-
-    public static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) {
-
-        Cursor cursor = null;
-        final String column = "_data";
-        final String[] projection = {
-                column
-        };
-
-        try {
-            cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, null);
-            if (cursor != null && cursor.moveToFirst()) {
-                final int column_index = cursor.getColumnIndexOrThrow(column);
-                return cursor.getString(column_index);
-            }
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-        return null;
-    }
-
-    public static boolean isExternalStorageDocument(Uri uri) {
-        return "com.android.externalstorage.documents".equals(uri.getAuthority());
-    }
-
-    public static boolean isDownloadsDocument(Uri uri) {
-        return "com.android.providers.downloads.documents".equals(uri.getAuthority());
-    }
-
-    public static boolean isMediaDocument(Uri uri) {
-        return "com.android.providers.media.documents".equals(uri.getAuthority());
-    }
-
-    public static File generatePicturePath() {
-        try {
-            File storageDir = getAlbumDir();
-            String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
-            return new File(storageDir, "IMG_" + timeStamp + ".jpg");
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-        }
-        return null;
-    }
-
-    public static CharSequence generateSearchName(String name, String name2, String q) {
-        if (name == null && name2 == null) {
-            return "";
-        }
-        SpannableStringBuilder builder = new SpannableStringBuilder();
-        String wholeString = name;
-        if (wholeString == null || wholeString.length() == 0) {
-            wholeString = name2;
-        } else if (name2 != null && name2.length() != 0) {
-            wholeString += " " + name2;
-        }
-        wholeString = wholeString.trim();
-        String lower = " " + wholeString.toLowerCase();
-
-        int index = -1;
-        int lastIndex = 0;
-        while ((index = lower.indexOf(" " + q, lastIndex)) != -1) {
-            int idx = index - (index == 0 ? 0 : 1);
-            int end = q.length() + (index == 0 ? 0 : 1) + idx;
-
-            if (lastIndex != 0 && lastIndex != idx + 1) {
-                builder.append(wholeString.substring(lastIndex, idx));
-            } else if (lastIndex == 0 && idx != 0) {
-                builder.append(wholeString.substring(0, idx));
-            }
-
-            String query = wholeString.substring(idx, end);
-            if (query.startsWith(" ")) {
-                builder.append(" ");
-            }
-            query = query.trim();
-            builder.append(AndroidUtilities.replaceTags("<c#ff4d83b3>" + query + "</c>"));
-
-            lastIndex = end;
-        }
-
-        if (lastIndex != -1 && lastIndex != wholeString.length()) {
-            builder.append(wholeString.substring(lastIndex, wholeString.length()));
-        }
-
-        return builder;
-    }
-
-    public static File generateVideoPath() {
-        try {
-            File storageDir = getAlbumDir();
-            String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
-            return new File(storageDir, "VID_" + timeStamp + ".mp4");
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-        }
-        return null;
-    }
-
-    public static String formatFileSize(long size) {
-        if (size < 1024) {
-            return String.format("%d B", size);
-        } else if (size < 1024 * 1024) {
-            return String.format("%.1f KB", size / 1024.0f);
-        } else if (size < 1024 * 1024 * 1024) {
-            return String.format("%.1f MB", size / 1024.0f / 1024.0f);
-        } else {
-            return String.format("%.1f GB", size / 1024.0f / 1024.0f / 1024.0f);
-        }
-    }
-
-    public static byte[] decodeQuotedPrintable(final byte[] bytes) {
-        if (bytes == null) {
-            return null;
-        }
-        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
-        for (int i = 0; i < bytes.length; i++) {
-            final int b = bytes[i];
-            if (b == '=') {
-                try {
-                    final int u = Character.digit((char) bytes[++i], 16);
-                    final int l = Character.digit((char) bytes[++i], 16);
-                    buffer.write((char) ((u << 4) + l));
-                } catch (Exception e) {
-                    FileLog.e("tmessages", e);
-                    return null;
-                }
-            } else {
-                buffer.write(b);
-            }
-        }
-        byte[] array = buffer.toByteArray();
-        try {
-            buffer.close();
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-        }
-        return array;
-    }
-
-    public static void checkForCrashes(Activity context) {
-        CrashManager.register(context, BuildVars.HOCKEY_APP_HASH, new CrashManagerListener() {
-            @Override
-            public boolean includeDeviceData() {
-                return true;
-            }
-        });
-    }
-
-    public static void checkForUpdates(Activity context) {
-        if (BuildVars.DEBUG_VERSION) {
-            UpdateManager.register(context, BuildVars.HOCKEY_APP_HASH);
-        }
-    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBar.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBar.java
index 03942a068..7ddad2ce3 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBar.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBar.java
@@ -88,7 +88,7 @@ private void positionTitle(int width, int height) {
         }
         int maxTextWidth = 0;
 
-        LayoutParams layoutParams = null;
+        LayoutParams layoutParams;
 
         if (titleTextView != null && titleTextView.getVisibility() == VISIBLE) {
             if (!AndroidUtilities.isTablet() && getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
@@ -121,7 +121,7 @@ private void positionTitle(int width, int height) {
             maxTextWidth = Math.max(maxTextWidth, subTitleTextView.getMeasuredWidth());
         }
 
-        int x = 0;
+        int x;
         if (backButtonImageView != null && backButtonImageView.getVisibility() == VISIBLE) {
             x = AndroidUtilities.dp(AndroidUtilities.isTablet() ? 80 : 72);
         } else {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarLayout.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarLayout.java
index 2a7f75c4f..b14f21bfe 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarLayout.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarLayout.java
@@ -71,7 +71,7 @@ protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
                     if (view instanceof ActionBar && view.getVisibility() == VISIBLE) {
                         if (((ActionBar) view).getCastShadows()) {
                             actionBarHeight = view.getMeasuredHeight();
-                            wasActionBar = true;
+                            //wasActionBar = true;
                         }
                         break;
                     }
@@ -424,7 +424,7 @@ public boolean onTouchEvent(MotionEvent ev) {
                         float velX = velocityTracker.getXVelocity();
                         float velY = velocityTracker.getYVelocity();
                         final boolean backAnimation = x < containerView.getMeasuredWidth() / 3.0f && (velX < 3500 || velX < velY);
-                        float distToMove = 0;
+                        float distToMove;
                         if (!backAnimation) {
                             distToMove = containerView.getMeasuredWidth() - x;
                             animatorSet.playTogether(
@@ -674,6 +674,7 @@ public void run() {
                     animators.add(ObjectAnimatorProxy.ofFloat(backgroundView, "alpha", 0.0f, 1.0f));
                 }
 
+                fragment.onOpenAnimationStart();
                 currentAnimation = new AnimatorSetProxy();
                 currentAnimation.playTogether(animators);
                 currentAnimation.setInterpolator(accelerateDecelerateInterpolator);
@@ -703,6 +704,7 @@ public void run() {
                 };
                 ViewProxy.setAlpha(containerView, 0.0f);
                 ViewProxy.setTranslationX(containerView, 48.0f);
+                fragment.onOpenAnimationStart();
                 startLayoutAnimation(true, true);
                 /*currentAnimation = new AnimatorSetProxy();
                 currentAnimation.playTogether(
@@ -733,6 +735,7 @@ public void onAnimationCancel(Object animation) {
                 ViewProxy.setAlpha(backgroundView, 1.0f);
                 backgroundView.setVisibility(VISIBLE);
             }
+            fragment.onOpenAnimationStart();
             fragment.onOpenAnimationEnd();
         }
         return true;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarMenu.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarMenu.java
index ef85bd22f..18ce670aa 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarMenu.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarMenu.java
@@ -10,7 +10,6 @@
 
 import android.content.Context;
 import android.graphics.drawable.Drawable;
-import android.util.AttributeSet;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.widget.LinearLayout;
@@ -32,14 +31,6 @@ public ActionBarMenu(Context context) {
         super(context);
     }
 
-    public ActionBarMenu(Context context, AttributeSet attrs) {
-        super(context, attrs);
-    }
-
-    public ActionBarMenu(Context context, AttributeSet attrs, int defStyleAttr) {
-        super(context, attrs, defStyleAttr);
-    }
-
     public View addItemResource(int id, int resourceId) {
         LayoutInflater li = (LayoutInflater) getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
         View view = li.inflate(resourceId, null);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarMenuItem.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarMenuItem.java
index afbf6b807..6d152b6a2 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarMenuItem.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarMenuItem.java
@@ -42,10 +42,22 @@
 public class ActionBarMenuItem extends FrameLayoutFixed {
 
     public static class ActionBarMenuItemSearchListener {
-        public void onSearchExpand() { }
-        public boolean onSearchCollapse() { return true; }
-        public void onTextChanged(EditText editText) { }
-        public void onSearchPressed(EditText editText) { }
+        public void onSearchExpand() {
+        }
+
+        public boolean onSearchCollapse() {
+            return true;
+        }
+
+        public void onTextChanged(EditText editText) {
+        }
+
+        public void onSearchPressed(EditText editText) {
+        }
+    }
+
+    public interface ActionBarMenuItemDelegate {
+        void onItemClick(int id);
     }
 
     private ActionBarPopupWindow.ActionBarPopupWindowLayout popupLayout;
@@ -63,8 +75,8 @@ public void onSearchPressed(EditText editText) { }
     private Runnable showMenuRunnable;
     private boolean showFromBottom;
     private int menuHeight = AndroidUtilities.dp(16);
-    private boolean needOffset = Build.VERSION.SDK_INT >= 21;
     private int subMenuOpenSide = 0;
+    private ActionBarMenuItemDelegate delegate;
 
     public ActionBarMenuItem(Context context, ActionBarMenu menu, int background) {
         super(context);
@@ -115,8 +127,8 @@ public void run() {
                 for (int a = 0; a < popupLayout.getChildCount(); a++) {
                     View child = popupLayout.getChildAt(a);
                     child.getHitRect(rect);
-                    if ((Integer)child.getTag() < 100) {
-                        if (!rect.contains((int)x, (int)y)) {
+                    if ((Integer) child.getTag() < 100) {
+                        if (!rect.contains((int) x, (int) y)) {
                             child.setPressed(false);
                             child.setSelected(false);
                             if (Build.VERSION.SDK_INT >= 21) {
@@ -137,7 +149,11 @@ public void run() {
         } else if (popupWindow != null && popupWindow.isShowing() && event.getActionMasked() == MotionEvent.ACTION_UP) {
             if (selectedMenuView != null) {
                 selectedMenuView.setSelected(false);
-                parentMenu.onItemClick((Integer) selectedMenuView.getTag());
+                if (parentMenu != null) {
+                    parentMenu.onItemClick((Integer) selectedMenuView.getTag());
+                } else if (delegate != null) {
+                    delegate.onItemClick((Integer) selectedMenuView.getTag());
+                }
             }
             popupWindow.dismiss();
         } else {
@@ -149,12 +165,12 @@ public void run() {
         return super.onTouchEvent(event);
     }
 
-    public void setShowFromBottom(boolean value) {
-        showFromBottom = value;
+    public void setDelegate(ActionBarMenuItemDelegate delegate) {
+        this.delegate = delegate;
     }
 
-    public void setNeedOffset(boolean value) {
-        needOffset = Build.VERSION.SDK_INT >= 21 && value;
+    public void setShowFromBottom(boolean value) {
+        showFromBottom = value;
     }
 
     public void setSubMenuOpenSide(int side) {
@@ -174,7 +190,7 @@ public boolean onTouch(View v, MotionEvent event) {
                     if (event.getActionMasked() == MotionEvent.ACTION_DOWN) {
                         if (popupWindow != null && popupWindow.isShowing()) {
                             v.getHitRect(rect);
-                            if (!rect.contains((int)event.getX(), (int)event.getY())) {
+                            if (!rect.contains((int) event.getX(), (int) event.getY())) {
                                 popupWindow.dismiss();
                             }
                         }
@@ -213,7 +229,7 @@ public void onDispatchKeyEvent(KeyEvent keyEvent) {
             }
         }
         popupLayout.addView(textView);
-        LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams)textView.getLayoutParams();
+        LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) textView.getLayoutParams();
         if (LocaleController.isRTL) {
             layoutParams.gravity = Gravity.RIGHT;
         }
@@ -223,7 +239,11 @@ public void onDispatchKeyEvent(KeyEvent keyEvent) {
         textView.setOnClickListener(new OnClickListener() {
             @Override
             public void onClick(View view) {
-                parentMenu.onItemClick((Integer) view.getTag());
+                if (parentMenu != null) {
+                    parentMenu.onItemClick((Integer) view.getTag());
+                } else if (delegate != null) {
+                    delegate.onItemClick((Integer) view.getTag());
+                }
                 if (popupWindow != null && popupWindow.isShowing()) {
                     popupWindow.dismiss();
                 }
@@ -262,7 +282,7 @@ public void toggleSubMenu() {
             popupWindow.getContentView().setOnKeyListener(new OnKeyListener() {
                 @Override
                 public boolean onKey(View v, int keyCode, KeyEvent event) {
-                    if (keyCode ==  KeyEvent.KEYCODE_MENU && event.getRepeatCount() == 0 && event.getAction() == KeyEvent.ACTION_UP && popupWindow != null && popupWindow.isShowing()) {
+                    if (keyCode == KeyEvent.KEYCODE_MENU && event.getRepeatCount() == 0 && event.getAction() == KeyEvent.ACTION_UP && popupWindow != null && popupWindow.isShowing()) {
                         popupWindow.dismiss();
                         return true;
                     }
@@ -277,8 +297,14 @@ public boolean onKey(View v, int keyCode, KeyEvent event) {
                     popupWindow.showAsDropDown(this, -popupLayout.getMeasuredWidth() + getMeasuredWidth(), getOffsetY());
                     popupWindow.update(this, -popupLayout.getMeasuredWidth() + getMeasuredWidth(), getOffsetY(), -1, -1);
                 } else {
-                    popupWindow.showAsDropDown(this, parentMenu.parentActionBar.getMeasuredWidth() - popupLayout.getMeasuredWidth() - getLeft() - parentMenu.getLeft(), getOffsetY());
-                    popupWindow.update(this, parentMenu.parentActionBar.getMeasuredWidth() - popupLayout.getMeasuredWidth() - getLeft() - parentMenu.getLeft(), getOffsetY(), -1, -1);
+                    if (parentMenu != null) {
+                        popupWindow.showAsDropDown(this, parentMenu.parentActionBar.getMeasuredWidth() - popupLayout.getMeasuredWidth() - getLeft() - parentMenu.getLeft(), getOffsetY());
+                        popupWindow.update(this, parentMenu.parentActionBar.getMeasuredWidth() - popupLayout.getMeasuredWidth() - getLeft() - parentMenu.getLeft(), getOffsetY(), -1, -1);
+                    } else if (getParent() != null) {
+                        View parent = (View) getParent();
+                        popupWindow.showAsDropDown(this, parent.getMeasuredWidth() - popupLayout.getMeasuredWidth() - getLeft() - parent.getLeft(), getOffsetY());
+                        popupWindow.update(this, parent.getMeasuredWidth() - popupLayout.getMeasuredWidth() - getLeft() - parent.getLeft(), getOffsetY(), -1, -1);
+                    }
                 }
             } else {
                 popupWindow.showAsDropDown(this, -AndroidUtilities.dp(8), getOffsetY());
@@ -289,7 +315,12 @@ public boolean onKey(View v, int keyCode, KeyEvent event) {
                 if (showFromBottom) {
                     popupWindow.showAsDropDown(this, -popupLayout.getMeasuredWidth() + getMeasuredWidth(), getOffsetY());
                 } else {
-                    popupWindow.showAsDropDown(this, parentMenu.parentActionBar.getMeasuredWidth() - popupLayout.getMeasuredWidth() - getLeft() - parentMenu.getLeft(), getOffsetY());
+                    if (parentMenu != null) {
+                        popupWindow.showAsDropDown(this, parentMenu.parentActionBar.getMeasuredWidth() - popupLayout.getMeasuredWidth() - getLeft() - parentMenu.getLeft(), getOffsetY());
+                    } else {
+                        View parent = (View) getParent();
+                        popupWindow.showAsDropDown(this, parent.getMeasuredWidth() - popupLayout.getMeasuredWidth() - getLeft() - parent.getLeft(), getOffsetY());
+                    }
                 }
             } else {
                 popupWindow.showAsDropDown(this, -AndroidUtilities.dp(8), getOffsetY());
@@ -305,14 +336,14 @@ private int getOffsetY() {
             if (diff < 0) {
                 y -= diff;
             }
-            return y - (needOffset ? AndroidUtilities.statusBarHeight : 0);
+            return y;
         } else {
-            return -getMeasuredHeight() - (needOffset ? AndroidUtilities.statusBarHeight : 0);
+            return -getMeasuredHeight();
         }
     }
 
     public void openSearch() {
-        if (searchContainer == null || searchContainer.getVisibility() == VISIBLE) {
+        if (searchContainer == null || searchContainer.getVisibility() == VISIBLE || parentMenu == null) {
             return;
         }
         parentMenu.parentActionBar.onSearchFieldVisibilityChanged(toggleSearch());
@@ -357,10 +388,13 @@ public EditText getSearchField() {
     }
 
     public ActionBarMenuItem setIsSearchField(boolean value) {
+        if (parentMenu == null) {
+            return this;
+        }
         if (value && searchContainer == null) {
             searchContainer = new FrameLayout(getContext());
             parentMenu.addView(searchContainer, 0);
-            LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams)searchContainer.getLayoutParams();
+            LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) searchContainer.getLayoutParams();
             layoutParams.weight = 1;
             layoutParams.width = 0;
             layoutParams.height = LayoutHelper.MATCH_PARENT;
@@ -491,7 +525,12 @@ protected void onLayout(boolean changed, int left, int top, int right, int botto
                 if (showFromBottom) {
                     popupWindow.update(this, -popupLayout.getMeasuredWidth() + getMeasuredWidth(), getOffsetY(), -1, -1);
                 } else {
-                    popupWindow.update(this, parentMenu.parentActionBar.getMeasuredWidth() - popupLayout.getMeasuredWidth() - getLeft() - parentMenu.getLeft(), getOffsetY(), -1, -1);
+                    if (parentMenu != null) {
+                        popupWindow.update(this, parentMenu.parentActionBar.getMeasuredWidth() - popupLayout.getMeasuredWidth() - getLeft() - parentMenu.getLeft(), getOffsetY(), -1, -1);
+                    } else {
+                        View parent = (View) getParent();
+                        popupWindow.update(this, parent.getMeasuredWidth() - popupLayout.getMeasuredWidth() - getLeft() - parent.getLeft(), getOffsetY(), -1, -1);
+                    }
                 }
             } else {
                 popupWindow.update(this, -AndroidUtilities.dp(8), getOffsetY(), -1, -1);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarPopupWindow.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarPopupWindow.java
index 479ab5512..759222d1c 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarPopupWindow.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarPopupWindow.java
@@ -11,12 +11,9 @@
 package org.telegram.ui.ActionBar;
 
 import android.content.Context;
-import android.os.Build;
-import android.util.AttributeSet;
 import android.view.KeyEvent;
 import android.view.View;
 import android.view.ViewTreeObserver;
-import android.view.WindowManager;
 import android.widget.LinearLayout;
 import android.widget.PopupWindow;
 
@@ -60,14 +57,6 @@ public ActionBarPopupWindowLayout(Context context) {
             super(context);
         }
 
-        public ActionBarPopupWindowLayout(Context context, AttributeSet attrs) {
-            super(context, attrs);
-        }
-
-        public ActionBarPopupWindowLayout(Context context, AttributeSet attrs, int defStyle) {
-            super(context, attrs, defStyle);
-        }
-
         public void setDispatchKeyEventListener(OnDispatchKeyEventListener listener) {
             mOnDispatchKeyEventListener = listener;
         }
@@ -91,21 +80,6 @@ public ActionBarPopupWindow(Context context) {
         init();
     }
 
-    public ActionBarPopupWindow(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        init();
-    }
-
-    public ActionBarPopupWindow(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-        init();
-    }
-
-    public ActionBarPopupWindow(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
-        super(context, attrs, defStyleAttr, defStyleRes);
-        init();
-    }
-
     public ActionBarPopupWindow(int width, int height) {
         super(width, height);
         init();
@@ -135,15 +109,15 @@ private void init() {
                 mSuperScrollListener = null;
             }
         }
-        if (Build.VERSION.SDK_INT >= 21) {
+        /*if (Build.VERSION.SDK_INT >= 21) {
             try {
                 Field field = PopupWindow.class.getDeclaredField("mWindowLayoutType");
                 field.setAccessible(true);
                 field.set(this, WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
             } catch (Exception e) {
-                /* ignored */
+                //ignored
             }
-        }
+        }*/
     }
 
     private void unregisterListener() {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BaseFragment.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BaseFragment.java
index 2388b7b48..c4414cc87 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BaseFragment.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BaseFragment.java
@@ -9,7 +9,7 @@
 package org.telegram.ui.ActionBar;
 
 import android.app.Activity;
-import android.app.AlertDialog;
+import android.app.Dialog;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
@@ -23,8 +23,9 @@
 import org.telegram.messenger.R;
 
 public class BaseFragment {
+
     private boolean isFinished = false;
-    protected AlertDialog visibleDialog = null;
+    protected Dialog visibleDialog = null;
 
     protected View fragmentView;
     protected ActionBarLayout parentLayout;
@@ -191,7 +192,11 @@ public void onBeginSlide() {
         }
     }
 
-    public void onOpenAnimationEnd() {
+    protected void onOpenAnimationEnd() {
+
+    }
+
+    protected void onOpenAnimationStart() {
 
     }
 
@@ -203,7 +208,7 @@ public boolean needAddActionBar() {
         return true;
     }
 
-    public AlertDialog showAlertDialog(AlertDialog.Builder builder) {
+    public Dialog showDialog(Dialog dialog) {
         if (parentLayout == null || parentLayout.animationInProgress || parentLayout.startedTracking || parentLayout.checkTransitionAnimation()) {
             return null;
         }
@@ -216,7 +221,7 @@ public AlertDialog showAlertDialog(AlertDialog.Builder builder) {
             FileLog.e("tmessages", e);
         }
         try {
-            visibleDialog = builder.show();
+            visibleDialog = dialog;
             visibleDialog.setCanceledOnTouchOutside(true);
             visibleDialog.setOnDismissListener(new DialogInterface.OnDismissListener() {
                 @Override
@@ -225,6 +230,7 @@ public void onDismiss(DialogInterface dialog) {
                     onDialogDismiss();
                 }
             });
+            visibleDialog.show();
             return visibleDialog;
         } catch (Exception e) {
             FileLog.e("tmessages", e);
@@ -235,4 +241,8 @@ public void onDismiss(DialogInterface dialog) {
     protected void onDialogDismiss() {
 
     }
+
+    public void setVisibleDialog(Dialog dialog) {
+        visibleDialog = dialog;
+    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BottomSheet.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BottomSheet.java
new file mode 100644
index 000000000..39ca1cf64
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BottomSheet.java
@@ -0,0 +1,301 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.ActionBar;
+
+import android.app.Dialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.os.Build;
+import android.os.Bundle;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.Window;
+import android.view.WindowManager;
+import android.view.animation.AccelerateInterpolator;
+import android.view.animation.DecelerateInterpolator;
+import android.widget.FrameLayout;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.AnimationCompat.AnimatorListenerAdapterProxy;
+import org.telegram.android.AnimationCompat.AnimatorSetProxy;
+import org.telegram.android.AnimationCompat.ObjectAnimatorProxy;
+import org.telegram.android.LocaleController;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.R;
+import org.telegram.ui.Components.LayoutHelper;
+
+public class BottomSheet extends Dialog {
+
+    private LinearLayout linearLayout;
+    private FrameLayout container;
+    private boolean dismissed;
+
+    private DialogInterface.OnClickListener onClickListener;
+
+    private CharSequence[] items;
+    private View customView;
+    private boolean overrideTabletWidth = true;
+
+    private BottomSheetDelegate delegate;
+
+    public interface BottomSheetDelegate {
+        void onOpenAnimationEnd();
+    }
+
+    private static class BottomSheetRow extends FrameLayout {
+
+        private TextView textView;
+
+        public BottomSheetRow(Context context) {
+            super(context);
+
+            setBackgroundResource(R.drawable.list_selector);
+            setPadding(AndroidUtilities.dp(16), 0, AndroidUtilities.dp(16), 0);
+
+            textView = new TextView(context);
+            textView.setTextColor(0xff212121);
+            textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
+            addView(textView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL));
+        }
+
+        @Override
+        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+            super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(48), MeasureSpec.EXACTLY));
+        }
+    }
+
+    public BottomSheet(Context context) {
+        super(context);
+
+        container = new FrameLayout(getContext());
+        container.setOnTouchListener(new View.OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                dismiss();
+                return false;
+            }
+        });
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        /*
+        <item name="android:windowFrame">@null</item>
+        <item name="android:textColor">@null</item>
+        <item name="android:layout_width">fill_parent</item>
+        <item name="android:windowBackground">@android:color/transparent</item>
+        <item name="android:windowIsFloating">true</item>
+        <item name="android:windowContentOverlay">@null</item>
+        <item name="android:windowIsTranslucent">true</item>
+        <item name="android:windowAnimationStyle">@style/BottomSheet.Animation</item>
+        <item name="android:textColorPrimary">#DD000000</item>
+        <item name="android:textColorSecondary">#8A000000</item>
+        <item name="android:textColorHint">#42000000</item>
+         */
+
+        Window window = getWindow();
+        window.setBackgroundDrawableResource(R.drawable.transparent);
+        window.requestFeature(Window.FEATURE_NO_TITLE);
+
+        setContentView(container);
+
+        linearLayout = new LinearLayout(getContext());
+        linearLayout.setOrientation(LinearLayout.VERTICAL);
+        if (AndroidUtilities.isTablet() && !overrideTabletWidth) {
+            container.addView(linearLayout, 0, LayoutHelper.createFrame(320, LayoutHelper.WRAP_CONTENT, Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL));
+        } else {
+            container.addView(linearLayout, 0, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.BOTTOM));
+        }
+
+        View shadow = new View(getContext());
+        shadow.setBackgroundResource(R.drawable.header_shadow_reverse);
+        linearLayout.addView(shadow, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 3));
+
+        LinearLayout containerView = new LinearLayout(getContext());
+        containerView.setBackgroundColor(0xffffffff);
+        containerView.setOrientation(LinearLayout.VERTICAL);
+        containerView.setPadding(0, AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8));
+        linearLayout.addView(containerView, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT));
+
+        if (items != null) {
+            for (int a = 0; a < items.length; a++) {
+                CharSequence charSequence = items[a];
+                BottomSheetRow row = new BottomSheetRow(getContext());
+                row.textView.setText(charSequence);
+                containerView.addView(row, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 48));
+                row.setTag(a);
+                row.setOnClickListener(new View.OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        dismissWithButtonClick((Integer) v.getTag());
+                    }
+                });
+            }
+        }
+        if (customView != null) {
+            containerView.addView(customView, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT));
+        }
+
+        WindowManager.LayoutParams params = getWindow().getAttributes();
+        params.height = ViewGroup.LayoutParams.MATCH_PARENT;
+        params.width = ViewGroup.LayoutParams.MATCH_PARENT;
+        params.gravity = Gravity.TOP | Gravity.LEFT;
+        params.dimAmount = 0.2f;
+        params.flags |= WindowManager.LayoutParams.FLAG_DIM_BEHIND | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
+        if (Build.VERSION.SDK_INT >= 21) {
+            params.flags |= WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;
+            params.type = WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;
+        }
+        getWindow().setAttributes(params);
+
+        setOnShowListener(new OnShowListener() {
+            @Override
+            public void onShow(DialogInterface dialog) {
+                AnimatorSetProxy animatorSetProxy = new AnimatorSetProxy();
+                animatorSetProxy.playTogether(
+                        ObjectAnimatorProxy.ofFloat(linearLayout, "translationY", linearLayout.getHeight(), 0));
+                animatorSetProxy.setDuration(180);
+                animatorSetProxy.setInterpolator(new DecelerateInterpolator());
+                animatorSetProxy.addListener(new AnimatorListenerAdapterProxy() {
+                    @Override
+                    public void onAnimationEnd(Object animation) {
+                        if (delegate != null) {
+                            delegate.onOpenAnimationEnd();
+                        }
+                    }
+                });
+                animatorSetProxy.start();
+            }
+        });
+    }
+
+    public void setDelegate(BottomSheetDelegate delegate) {
+        this.delegate = delegate;
+    }
+
+    public FrameLayout getContainer() {
+        return container;
+    }
+
+    public LinearLayout getSheetContainer() {
+        return linearLayout;
+    }
+
+    private void dismissWithButtonClick(final int item) {
+        if (dismissed) {
+            return;
+        }
+        AnimatorSetProxy animatorSetProxy = new AnimatorSetProxy();
+        animatorSetProxy.playTogether(
+                ObjectAnimatorProxy.ofFloat(linearLayout, "translationY", linearLayout.getHeight() + AndroidUtilities.dp(10))
+        );
+        animatorSetProxy.setDuration(180);
+        animatorSetProxy.setInterpolator(new AccelerateInterpolator());
+        animatorSetProxy.addListener(new AnimatorListenerAdapterProxy() {
+            @Override
+            public void onAnimationEnd(Object animation) {
+                if (onClickListener != null) {
+                    onClickListener.onClick(BottomSheet.this, item);
+                }
+                AndroidUtilities.runOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        try {
+                            BottomSheet.super.dismiss();
+                        } catch (Exception e) {
+                            FileLog.e("tmessages", e);
+                        }
+                    }
+                });
+            }
+
+            @Override
+            public void onAnimationCancel(Object animation) {
+                onAnimationEnd(animation);
+            }
+        });
+        animatorSetProxy.start();
+    }
+
+    @Override
+    public void dismiss() {
+        if (dismissed) {
+            return;
+        }
+        dismissed = true;
+        AnimatorSetProxy animatorSetProxy = new AnimatorSetProxy();
+        animatorSetProxy.playTogether(
+                ObjectAnimatorProxy.ofFloat(linearLayout, "translationY", linearLayout.getHeight() + AndroidUtilities.dp(10))
+                );
+        animatorSetProxy.setDuration(180);
+        animatorSetProxy.setInterpolator(new AccelerateInterpolator());
+        animatorSetProxy.addListener(new AnimatorListenerAdapterProxy() {
+            @Override
+            public void onAnimationEnd(Object animation) {
+                AndroidUtilities.runOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        try {
+                            BottomSheet.super.dismiss();
+                        } catch (Exception e) {
+                            FileLog.e("tmessages", e);
+                        }
+                    }
+                });
+            }
+
+            @Override
+            public void onAnimationCancel(Object animation) {
+                onAnimationEnd(animation);
+            }
+        });
+        animatorSetProxy.start();
+    }
+
+    public static class Builder {
+
+        private BottomSheet bottomSheet;
+
+        public Builder(Context context) {
+            bottomSheet = new BottomSheet(context);
+        }
+
+        public Builder setItems(CharSequence[] items, final OnClickListener onClickListener) {
+            bottomSheet.items = items;
+            bottomSheet.onClickListener = onClickListener;
+            return this;
+        }
+
+        public Builder setCustomView(View view) {
+            bottomSheet.customView = view;
+            return this;
+        }
+
+        public BottomSheet create() {
+            return bottomSheet;
+        }
+
+        public BottomSheet show() {
+            bottomSheet.show();
+            return bottomSheet;
+        }
+
+        public BottomSheet setOverrideTabletWidth(boolean value) {
+            bottomSheet.overrideTabletWidth = value;
+            return bottomSheet;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSearchAdapterRecycler.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSearchAdapterRecycler.java
new file mode 100644
index 000000000..4f24e7635
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSearchAdapterRecycler.java
@@ -0,0 +1,210 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Adapters;
+
+import org.telegram.SQLite.SQLiteCursor;
+import org.telegram.SQLite.SQLitePreparedStatement;
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.MessagesStorage;
+import org.telegram.android.support.widget.RecyclerView;
+import org.telegram.messenger.ConnectionsManager;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.RPCRequest;
+import org.telegram.messenger.TLObject;
+import org.telegram.messenger.TLRPC;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public abstract class BaseSearchAdapterRecycler extends RecyclerView.Adapter {
+
+    protected static class HashtagObject {
+        String hashtag;
+        int date;
+    }
+
+    protected ArrayList<TLRPC.User> globalSearch = new ArrayList<>();
+    private long reqId = 0;
+    private int lastReqId;
+    protected String lastFoundUsername = null;
+
+    protected ArrayList<HashtagObject> hashtags;
+    protected HashMap<String, HashtagObject> hashtagsByText;
+    protected boolean hashtagsLoadedFromDb = false;
+
+    public void queryServerSearch(final String query) {
+        if (reqId != 0) {
+            ConnectionsManager.getInstance().cancelRpc(reqId, true);
+            reqId = 0;
+        }
+        if (query == null || query.length() < 5) {
+            globalSearch.clear();
+            lastReqId = 0;
+            notifyDataSetChanged();
+            return;
+        }
+        TLRPC.TL_contacts_search req = new TLRPC.TL_contacts_search();
+        req.q = query;
+        req.limit = 50;
+        final int currentReqId = ++lastReqId;
+        reqId = ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+            @Override
+            public void run(final TLObject response, final TLRPC.TL_error error) {
+                AndroidUtilities.runOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        if (currentReqId == lastReqId) {
+                            if (error == null) {
+                                TLRPC.TL_contacts_found res = (TLRPC.TL_contacts_found) response;
+                                globalSearch = res.users;
+                                lastFoundUsername = query;
+                                notifyDataSetChanged();
+                            }
+                        }
+                        reqId = 0;
+                    }
+                });
+            }
+        }, true, RPCRequest.RPCRequestClassGeneric | RPCRequest.RPCRequestClassFailOnServerErrors);
+    }
+
+    public void loadRecentHashtags() {
+        MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    SQLiteCursor cursor = MessagesStorage.getInstance().getDatabase().queryFinalized("SELECT id, date FROM hashtag_recent_v2 WHERE 1");
+                    final ArrayList<HashtagObject> arrayList = new ArrayList<>();
+                    final HashMap<String, HashtagObject> hashMap = new HashMap<>();
+                    while (cursor.next()) {
+                        HashtagObject hashtagObject = new HashtagObject();
+                        hashtagObject.hashtag = cursor.stringValue(0);
+                        hashtagObject.date = cursor.intValue(1);
+                        arrayList.add(hashtagObject);
+                        hashMap.put(hashtagObject.hashtag, hashtagObject);
+                    }
+                    cursor.dispose();
+                    Collections.sort(arrayList, new Comparator<HashtagObject>() {
+                        @Override
+                        public int compare(HashtagObject lhs, HashtagObject rhs) {
+                            if (lhs.date < rhs.date) {
+                                return 1;
+                            } else if (lhs.date > rhs.date) {
+                                return -1;
+                            } else {
+                                return 0;
+                            }
+                        }
+                    });
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            setHashtags(arrayList, hashMap);
+                        }
+                    });
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+        });
+    }
+
+    public void addHashtagsFromMessage(String message) {
+        if (message == null) {
+            return;
+        }
+        boolean changed = false;
+        Pattern pattern = Pattern.compile("(^|\\s)#[\\w@\\.]+");
+        Matcher matcher = pattern.matcher(message);
+        while (matcher.find()) {
+            int start = matcher.start();
+            int end = matcher.end();
+            if (message.charAt(start) != '@' && message.charAt(start) != '#') {
+                start++;
+            }
+            String hashtag = message.substring(start, end);
+            if (hashtagsByText == null) {
+                hashtagsByText = new HashMap<>();
+                hashtags = new ArrayList<>();
+            }
+            HashtagObject hashtagObject = hashtagsByText.get(hashtag);
+            if (hashtagObject == null) {
+                hashtagObject = new HashtagObject();
+                hashtagObject.hashtag = hashtag;
+                hashtagsByText.put(hashtagObject.hashtag, hashtagObject);
+            } else {
+                hashtags.remove(hashtagObject);
+            }
+            hashtagObject.date = (int) (System.currentTimeMillis() / 1000);
+            hashtags.add(0, hashtagObject);
+            changed = true;
+        }
+        if (changed) {
+            putRecentHashtags(hashtags);
+        }
+    }
+
+    private void putRecentHashtags(final ArrayList<HashtagObject> arrayList) {
+        MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    MessagesStorage.getInstance().getDatabase().beginTransaction();
+                    SQLitePreparedStatement state = MessagesStorage.getInstance().getDatabase().executeFast("REPLACE INTO hashtag_recent_v2 VALUES(?, ?)");
+                    for (int a = 0; a < arrayList.size(); a++) {
+                        if (a == 100) {
+                            break;
+                        }
+                        HashtagObject hashtagObject = arrayList.get(a);
+                        state.requery();
+                        state.bindString(1, hashtagObject.hashtag);
+                        state.bindInteger(2, hashtagObject.date);
+                        state.step();
+                    }
+                    state.dispose();
+                    MessagesStorage.getInstance().getDatabase().commitTransaction();
+                    if (arrayList.size() >= 100) {
+                        MessagesStorage.getInstance().getDatabase().beginTransaction();
+                        for (int a = 100; a < arrayList.size(); a++) {
+                            MessagesStorage.getInstance().getDatabase().executeFast("DELETE FROM hashtag_recent_v2 WHERE id = '" + arrayList.get(a).hashtag + "'").stepThis().dispose();
+                        }
+                        MessagesStorage.getInstance().getDatabase().commitTransaction();
+                    }
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+        });
+    }
+
+    public void clearRecentHashtags() {
+        hashtags = new ArrayList<>();
+        hashtagsByText = new HashMap<>();
+        MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    MessagesStorage.getInstance().getDatabase().executeFast("DELETE FROM hashtag_recent_v2 WHERE 1").stepThis().dispose();
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+        });
+    }
+
+    protected void setHashtags(ArrayList<HashtagObject> arrayList, HashMap<String, HashtagObject> hashMap) {
+        hashtags = arrayList;
+        hashtagsByText = hashMap;
+        hashtagsLoadedFromDb = true;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ChatActivityAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ChatActivityAdapter.java
index 0fd986614..afe18248d 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ChatActivityAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ChatActivityAdapter.java
@@ -294,7 +294,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                                         }
                                     }
                             );
-                            showAlertDialog(builder);
+                            showDialog(builder.create());
                         }
                     });
                 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DialogsAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DialogsAdapter.java
index e8884689c..56508d07a 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DialogsAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DialogsAdapter.java
@@ -14,17 +14,25 @@
 
 import org.telegram.android.AndroidUtilities;
 import org.telegram.android.MessagesController;
+import org.telegram.android.support.widget.RecyclerView;
 import org.telegram.messenger.TLRPC;
 import org.telegram.ui.Cells.DialogCell;
 import org.telegram.ui.Cells.LoadingCell;
 
-public class DialogsAdapter extends BaseFragmentAdapter {
+public class DialogsAdapter extends RecyclerView.Adapter {
 
     private Context mContext;
     private boolean serverOnly;
     private long openedDialogId;
     private int currentCount;
 
+    private class Holder extends RecyclerView.ViewHolder {
+
+        public Holder(View itemView) {
+            super(itemView);
+        }
+    }
+
     public DialogsAdapter(Context context, boolean onlyFromServer) {
         mContext = context;
         serverOnly = onlyFromServer;
@@ -36,21 +44,11 @@ public void setOpenedDialogId(long id) {
 
     public boolean isDataSetChanged() {
         int current = currentCount;
-        return current != getCount();
-    }
-
-    @Override
-    public boolean areAllItemsEnabled() {
-        return true;
-    }
-
-    @Override
-    public boolean isEnabled(int i) {
-        return true;
+        return current != getItemCount();
     }
 
     @Override
-    public int getCount() {
+    public int getItemCount() {
         int count;
         if (serverOnly) {
             count = MessagesController.getInstance().dialogsServerOnly.size();
@@ -67,7 +65,6 @@ public int getCount() {
         return count;
     }
 
-    @Override
     public TLRPC.TL_dialog getItem(int i) {
         if (serverOnly) {
             if (i < 0 || i >= MessagesController.getInstance().dialogsServerOnly.size()) {
@@ -88,41 +85,32 @@ public long getItemId(int i) {
     }
 
     @Override
-    public boolean hasStableIds() {
-        return true;
+    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
+        View view = null;
+        if (viewType == 0) {
+            view = new DialogCell(mContext);
+        } else if (viewType == 1) {
+            view = new LoadingCell(mContext);
+        }
+        return new Holder(view);
     }
 
     @Override
-    public View getView(int i, View view, ViewGroup viewGroup) {
-        int type = getItemViewType(i);
-        if (type == 1) {
-            if (view == null) {
-                view = new LoadingCell(mContext);
-            }
-        } else if (type == 0) {
-            if (view == null) {
-                view = new DialogCell(mContext);
-            }
-            if (view instanceof DialogCell) { //TODO finally i need to find this crash
-                ((DialogCell) view).useSeparator = (i != getCount() - 1);
-                TLRPC.TL_dialog dialog = null;
-                if (serverOnly) {
-                    dialog = MessagesController.getInstance().dialogsServerOnly.get(i);
-                } else {
-                    dialog = MessagesController.getInstance().dialogs.get(i);
-                    if (AndroidUtilities.isTablet()) {
-                        if (dialog.id == openedDialogId) {
-                            view.setBackgroundColor(0x0f000000);
-                        } else {
-                            view.setBackgroundColor(0);
-                        }
-                    }
+    public void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int i) {
+        if (viewHolder.getItemViewType() == 0) {
+            DialogCell cell = (DialogCell) viewHolder.itemView;
+            cell.useSeparator = (i != getItemCount() - 1);
+            TLRPC.TL_dialog dialog;
+            if (serverOnly) {
+                dialog = MessagesController.getInstance().dialogsServerOnly.get(i);
+            } else {
+                dialog = MessagesController.getInstance().dialogs.get(i);
+                if (AndroidUtilities.isTablet()) {
+                    cell.setDialogSelected(dialog.id == openedDialogId);
                 }
-                ((DialogCell) view).setDialog(dialog, i, serverOnly);
             }
+            cell.setDialog(dialog, i, serverOnly);
         }
-
-        return view;
     }
 
     @Override
@@ -132,26 +120,4 @@ public int getItemViewType(int i) {
         }
         return 0;
     }
-
-    @Override
-    public int getViewTypeCount() {
-        return 2;
-    }
-
-    @Override
-    public boolean isEmpty() {
-        int count;
-        if (serverOnly) {
-            count = MessagesController.getInstance().dialogsServerOnly.size();
-        } else {
-            count = MessagesController.getInstance().dialogs.size();
-        }
-        if (count == 0 && MessagesController.getInstance().loadingDialogs) {
-            return true;
-        }
-        if (!MessagesController.getInstance().dialogsEndReached) {
-            count++;
-        }
-        return count == 0;
-    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DialogsSearchAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DialogsSearchAdapter.java
index 03497da97..0aae2b086 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DialogsSearchAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DialogsSearchAdapter.java
@@ -20,6 +20,7 @@
 import org.telegram.android.MessageObject;
 import org.telegram.android.MessagesController;
 import org.telegram.android.MessagesStorage;
+import org.telegram.android.support.widget.RecyclerView;
 import org.telegram.messenger.ByteBufferDesc;
 import org.telegram.messenger.ConnectionsManager;
 import org.telegram.messenger.FileLog;
@@ -27,7 +28,6 @@
 import org.telegram.messenger.RPCRequest;
 import org.telegram.messenger.TLObject;
 import org.telegram.messenger.TLRPC;
-import org.telegram.messenger.Utilities;
 import org.telegram.ui.Cells.DialogCell;
 import org.telegram.ui.Cells.GreySectionCell;
 import org.telegram.ui.Cells.HashtagSearchCell;
@@ -42,7 +42,7 @@
 import java.util.Timer;
 import java.util.TimerTask;
 
-public class DialogsSearchAdapter extends BaseSearchAdapter {
+public class DialogsSearchAdapter extends BaseSearchAdapterRecycler {
 
     private Context mContext;
     private Timer searchTimer;
@@ -59,6 +59,13 @@
     private String lastMessagesSearchString;
     private int lastSearchId = 0;
 
+    private class Holder extends RecyclerView.ViewHolder {
+
+        public Holder(View itemView) {
+            super(itemView);
+        }
+    }
+
     private class DialogSearchResult {
         public TLObject object;
         public int date;
@@ -246,9 +253,9 @@ public void run() {
                                             user.status.expires = cursor.intValue(1);
                                         }
                                         if (found == 1) {
-                                            dialogSearchResult.name = Utilities.generateSearchName(user.first_name, user.last_name, q);
+                                            dialogSearchResult.name = AndroidUtilities.generateSearchName(user.first_name, user.last_name, q);
                                         } else {
-                                            dialogSearchResult.name = Utilities.generateSearchName("@" + user.username, null, "@" + q);
+                                            dialogSearchResult.name = AndroidUtilities.generateSearchName("@" + user.username, null, "@" + q);
                                         }
                                         dialogSearchResult.object = user;
                                         resultCount++;
@@ -281,7 +288,7 @@ public void run() {
                                             dialog_id = AndroidUtilities.makeBroadcastId(chat.id);
                                         }
                                         DialogSearchResult dialogSearchResult = dialogsResult.get(dialog_id);
-                                        dialogSearchResult.name = Utilities.generateSearchName(chat.title, null, q);
+                                        dialogSearchResult.name = AndroidUtilities.generateSearchName(chat.title, null, q);
                                         dialogSearchResult.object = chat;
                                         resultCount++;
                                     }
@@ -345,7 +352,7 @@ public void run() {
                                         if (found == 1) {
                                             dialogSearchResult.name = AndroidUtilities.replaceTags("<c#ff00a60e>" + ContactsController.formatName(user.first_name, user.last_name) + "</c>");
                                         } else {
-                                            dialogSearchResult.name = Utilities.generateSearchName("@" + user.username, null, "@" + q);
+                                            dialogSearchResult.name = AndroidUtilities.generateSearchName("@" + user.username, null, "@" + q);
                                         }
                                         dialogSearchResult.object = chat;
                                         encUsers.add(user);
@@ -418,9 +425,9 @@ public int compare(DialogSearchResult lhs, DialogSearchResult rhs) {
                                         user.status.expires = cursor.intValue(1);
                                     }
                                     if (found == 1) {
-                                        resultArrayNames.add(Utilities.generateSearchName(user.first_name, user.last_name, q));
+                                        resultArrayNames.add(AndroidUtilities.generateSearchName(user.first_name, user.last_name, q));
                                     } else {
-                                        resultArrayNames.add(Utilities.generateSearchName("@" + user.username, null, "@" + q));
+                                        resultArrayNames.add(AndroidUtilities.generateSearchName("@" + user.username, null, "@" + q));
                                     }
                                     resultArray.add(user);
                                 }
@@ -567,30 +574,7 @@ public void run() {
     }
 
     @Override
-    public boolean areAllItemsEnabled() {
-        return false;
-    }
-
-    @Override
-    public boolean isEnabled(int i) {
-        if (!searchResultHashtags.isEmpty()) {
-            return i != 0;
-        }
-        int localCount = searchResult.size();
-        int globalCount = globalSearch.isEmpty() ? 0 : globalSearch.size() + 1;
-        int messagesCount = searchResultMessages.isEmpty() ? 0 : searchResultMessages.size() + 1;
-        if (i >= 0 && i < localCount || i > localCount && i < globalCount + localCount) {
-            return true;
-        } else if (i > globalCount + localCount && i < globalCount + localCount + messagesCount) {
-            return true;
-        } else if (messagesCount != 0 && i == globalCount + localCount + messagesCount) {
-            return true;
-        }
-        return false;
-    }
-
-    @Override
-    public int getCount() {
+    public int getItemCount() {
         if (!searchResultHashtags.isEmpty()) {
             return searchResultHashtags.size() + 1;
         }
@@ -606,7 +590,6 @@ public int getCount() {
         return count;
     }
 
-    @Override
     public Object getItem(int i) {
         if (!searchResultHashtags.isEmpty()) {
             return searchResultHashtags.get(i - 1);
@@ -630,96 +613,107 @@ public long getItemId(int i) {
     }
 
     @Override
-    public boolean hasStableIds() {
-        return true;
+    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+        View view = null;
+        switch (viewType) {
+            case 0:
+                view = new ProfileSearchCell(mContext);
+                view.setBackgroundResource(R.drawable.list_selector);
+                break;
+            case 1:
+                view = new GreySectionCell(mContext);
+                break;
+            case 2:
+                view = new DialogCell(mContext);
+                break;
+            case 3:
+                view = new LoadingCell(mContext);
+                break;
+            case 4:
+                view = new HashtagSearchCell(mContext);
+                break;
+        }
+        return new Holder(view);
     }
 
     @Override
-    public View getView(int i, View view, ViewGroup viewGroup) {
-        int type = getItemViewType(i);
-
-        if (type == 1) {
-            if (view == null) {
-                view = new GreySectionCell(mContext);
-            }
-            if (!searchResultHashtags.isEmpty()) {
-                ((GreySectionCell) view).setText(LocaleController.getString("Hashtags", R.string.Hashtags).toUpperCase());
-            }  else if (!globalSearch.isEmpty() && i == searchResult.size()) {
-                ((GreySectionCell) view).setText(LocaleController.getString("GlobalSearch", R.string.GlobalSearch));
-            } else {
-                ((GreySectionCell) view).setText(LocaleController.getString("SearchMessages", R.string.SearchMessages));
-            }
-        } else if (type == 0) {
-            if (view == null) {
-                view = new ProfileSearchCell(mContext);
-            }
+    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
+        switch (holder.getItemViewType()) {
+            case 0: {
+                ProfileSearchCell cell = (ProfileSearchCell) holder.itemView;
 
-            TLRPC.User user = null;
-            TLRPC.Chat chat = null;
-            TLRPC.EncryptedChat encryptedChat = null;
+                TLRPC.User user = null;
+                TLRPC.Chat chat = null;
+                TLRPC.EncryptedChat encryptedChat = null;
 
-            int localCount = searchResult.size();
-            int globalCount = globalSearch.isEmpty() ? 0 : globalSearch.size() + 1;
+                int localCount = searchResult.size();
+                int globalCount = globalSearch.isEmpty() ? 0 : globalSearch.size() + 1;
 
-            ((ProfileSearchCell) view).useSeparator = (i != getCount() - 1 && i != localCount - 1 && i != localCount + globalCount - 1);
-            Object obj = getItem(i);
-            if (obj instanceof TLRPC.User) {
-                /*user = MessagesController.getInstance().getUser(((TLRPC.User) obj).id);
-                if (user == null) {
+                cell.useSeparator = (position != getItemCount() - 1 && position != localCount - 1 && position != localCount + globalCount - 1);
+                Object obj = getItem(position);
+                if (obj instanceof TLRPC.User) {
                     user = (TLRPC.User) obj;
-                }*/
-                user = (TLRPC.User) obj;
-            } else if (obj instanceof TLRPC.Chat) {
-                chat = MessagesController.getInstance().getChat(((TLRPC.Chat) obj).id);
-            } else if (obj instanceof TLRPC.EncryptedChat) {
-                encryptedChat = MessagesController.getInstance().getEncryptedChat(((TLRPC.EncryptedChat) obj).id);
-                user = MessagesController.getInstance().getUser(encryptedChat.user_id);
-            }
+                } else if (obj instanceof TLRPC.Chat) {
+                    chat = MessagesController.getInstance().getChat(((TLRPC.Chat) obj).id);
+                } else if (obj instanceof TLRPC.EncryptedChat) {
+                    encryptedChat = MessagesController.getInstance().getEncryptedChat(((TLRPC.EncryptedChat) obj).id);
+                    user = MessagesController.getInstance().getUser(encryptedChat.user_id);
+                }
 
-            CharSequence username = null;
-            CharSequence name = null;
-            if (i < searchResult.size()) {
-                name = searchResultNames.get(i);
-                if (name != null && user != null && user.username != null && user.username.length() > 0) {
-                    if (name.toString().startsWith("@" + user.username)) {
-                        username = name;
-                        name = null;
+                CharSequence username = null;
+                CharSequence name = null;
+                if (position < searchResult.size()) {
+                    name = searchResultNames.get(position);
+                    if (name != null && user != null && user.username != null && user.username.length() > 0) {
+                        if (name.toString().startsWith("@" + user.username)) {
+                            username = name;
+                            name = null;
+                        }
+                    }
+                } else if (position > searchResult.size() && user != null && user.username != null) {
+                    String foundUserName = lastFoundUsername;
+                    if (foundUserName.startsWith("@")) {
+                        foundUserName = foundUserName.substring(1);
+                    }
+                    try {
+                        username = AndroidUtilities.replaceTags(String.format("<c#ff4d83b3>@%s</c>%s", user.username.substring(0, foundUserName.length()), user.username.substring(foundUserName.length())));
+                    } catch (Exception e) {
+                        username = user.username;
+                        FileLog.e("tmessages", e);
                     }
                 }
-            } else if (i > searchResult.size() && user != null && user.username != null) {
-                String foundUserName = lastFoundUsername;
-                if (foundUserName.startsWith("@")) {
-                    foundUserName = foundUserName.substring(1);
-                }
-                try {
-                    username = AndroidUtilities.replaceTags(String.format("<c#ff4d83b3>@%s</c>%s", user.username.substring(0, foundUserName.length()), user.username.substring(foundUserName.length())));
-                } catch (Exception e) {
-                    username = user.username;
-                    FileLog.e("tmessages", e);
+
+                cell.setData(user, chat, encryptedChat, name, username);
+                break;
+            }
+            case 1: {
+                GreySectionCell cell = (GreySectionCell) holder.itemView;
+                if (!searchResultHashtags.isEmpty()) {
+                    cell.setText(LocaleController.getString("Hashtags", R.string.Hashtags).toUpperCase());
+                }  else if (!globalSearch.isEmpty() && position == searchResult.size()) {
+                    cell.setText(LocaleController.getString("GlobalSearch", R.string.GlobalSearch));
+                } else {
+                    cell.setText(LocaleController.getString("SearchMessages", R.string.SearchMessages));
                 }
+                break;
             }
-
-            ((ProfileSearchCell) view).setData(user, chat, encryptedChat, name, username);
-        } else if (type == 2) {
-            if (view == null) {
-                view = new DialogCell(mContext);
+            case 2: {
+                DialogCell cell = (DialogCell) holder.itemView;
+                cell.useSeparator = (position != getItemCount() - 1);
+                MessageObject messageObject = (MessageObject)getItem(position);
+                cell.setDialog(messageObject.getDialogId(), messageObject, messageObject.messageOwner.date);
+                break;
             }
-            ((DialogCell) view).useSeparator = (i != getCount() - 1);
-            MessageObject messageObject = (MessageObject)getItem(i);
-            ((DialogCell) view).setDialog(messageObject.getDialogId(), messageObject, messageObject.messageOwner.date);
-        } else if (type == 3) {
-            if (view == null) {
-                view = new LoadingCell(mContext);
+            case 3: {
+                break;
             }
-        } else if (type == 4) {
-            if (view == null) {
-                view = new HashtagSearchCell(mContext);
+            case 4: {
+                HashtagSearchCell cell = (HashtagSearchCell) holder.itemView;
+                cell.setText(searchResultHashtags.get(position - 1));
+                cell.setNeedDivider(position != searchResultHashtags.size());
+                break;
             }
-            ((HashtagSearchCell) view).setText(searchResultHashtags.get(i - 1));
-            ((HashtagSearchCell) view).setNeedDivider(i != searchResultHashtags.size());
         }
-
-        return view;
     }
 
     @Override
@@ -739,14 +733,4 @@ public int getItemViewType(int i) {
         }
         return 1;
     }
-
-    @Override
-    public int getViewTypeCount() {
-        return 5;
-    }
-
-    @Override
-    public boolean isEmpty() {
-        return searchResult.isEmpty() && globalSearch.isEmpty() && searchResultMessages.isEmpty() && searchResultHashtags.isEmpty();
-    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/SearchAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/SearchAdapter.java
index cf7ce7c1f..9894b9592 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/SearchAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/SearchAdapter.java
@@ -138,9 +138,9 @@ public void run() {
 
                                 if (found != 0) {
                                     if (found == 1) {
-                                        resultArrayNames.add(Utilities.generateSearchName(user.first_name, user.last_name, q));
+                                        resultArrayNames.add(AndroidUtilities.generateSearchName(user.first_name, user.last_name, q));
                                     } else {
-                                        resultArrayNames.add(Utilities.generateSearchName("@" + user.username, null, "@" + q));
+                                        resultArrayNames.add(AndroidUtilities.generateSearchName("@" + user.username, null, "@" + q));
                                     }
                                     resultArray.add(user);
                                     break;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/StickersAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/StickersAdapter.java
index 2acda7a59..38bb738f5 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/StickersAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/StickersAdapter.java
@@ -12,20 +12,11 @@
 import android.view.View;
 import android.view.ViewGroup;
 
-import org.telegram.SQLite.SQLiteCursor;
-import org.telegram.SQLite.SQLitePreparedStatement;
-import org.telegram.android.AndroidUtilities;
-import org.telegram.android.MessagesStorage;
 import org.telegram.android.NotificationCenter;
+import org.telegram.android.query.StickersQuery;
 import org.telegram.android.support.widget.RecyclerView;
-import org.telegram.messenger.ByteBufferDesc;
-import org.telegram.messenger.ConnectionsManager;
 import org.telegram.messenger.FileLoader;
-import org.telegram.messenger.FileLog;
-import org.telegram.messenger.RPCRequest;
-import org.telegram.messenger.TLObject;
 import org.telegram.messenger.TLRPC;
-import org.telegram.messenger.Utilities;
 import org.telegram.ui.Cells.StickerCell;
 
 import java.io.File;
@@ -34,11 +25,6 @@
 
 public class StickersAdapter extends RecyclerView.Adapter implements NotificationCenter.NotificationCenterDelegate {
 
-    private static boolean loadingStickers;
-    private static String hash = "";
-    private static int loadDate = 0;
-    private static HashMap<String, ArrayList<TLRPC.Document>> allStickers;
-
     private Context mContext;
     private ArrayList<TLRPC.Document> stickers;
     private ArrayList<String> stickersToLoad = new ArrayList<>();
@@ -60,9 +46,7 @@ public Holder(View itemView) {
     public StickersAdapter(Context context, StickersAdapterDelegate delegate) {
         mContext = context;
         this.delegate = delegate;
-        if (!loadingStickers && (allStickers == null || loadDate < (System.currentTimeMillis() / 1000 - 60 * 60))) {
-            loadStickers(true);
-        }
+        StickersQuery.checkStickers();
         NotificationCenter.getInstance().addObserver(this, NotificationCenter.FileDidLoaded);
         NotificationCenter.getInstance().addObserver(this, NotificationCenter.FileDidFailedLoad);
     }
@@ -75,64 +59,13 @@ public void destroy() {
     @Override
     public void didReceivedNotification(int id, final Object... args) {
         if (id == NotificationCenter.FileDidLoaded || id == NotificationCenter.FileDidFailedLoad) {
-            AndroidUtilities.runOnUIThread(new Runnable() {
-                @Override
-                public void run() {
-                    if (stickers != null && !stickers.isEmpty() && !stickersToLoad.isEmpty() && visible) {
-                        String fileName = (String) args[0];
-                        stickersToLoad.remove(fileName);
-                        if (stickersToLoad.isEmpty()) {
-                            delegate.needChangePanelVisibility(stickers != null && !stickers.isEmpty() && stickersToLoad.isEmpty());
-                        }
-                    }
-                }
-            });
-        }
-    }
-
-    private void loadStickers(boolean cache) {
-        if (loadingStickers) {
-            return;
-        }
-        loadingStickers = true;
-        if (cache) {
-            MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
-                @Override
-                public void run() {
-                    TLRPC.messages_AllStickers result = null;
-                    int date = 0;
-                    try {
-                        SQLiteCursor cursor = MessagesStorage.getInstance().getDatabase().queryFinalized("SELECT data, date FROM stickers WHERE 1");
-                        ArrayList<TLRPC.User> loadedUsers = new ArrayList<>();
-                        if (cursor.next()) {
-                            ByteBufferDesc data = MessagesStorage.getInstance().getBuffersStorage().getFreeBuffer(cursor.byteArrayLength(0));
-                            if (data != null && cursor.byteBufferValue(0, data.buffer) != 0) {
-                                result = TLRPC.messages_AllStickers.TLdeserialize(data, data.readInt32(false), false);
-                            }
-                            date = cursor.intValue(1);
-                            MessagesStorage.getInstance().getBuffersStorage().reuseFreeBuffer(data);
-                        }
-                        cursor.dispose();
-                    } catch (Exception e) {
-                        FileLog.e("tmessages", e);
-                    }
-                    processLoadedStickers(result, true, date);
-                }
-            });
-        } else {
-            TLRPC.TL_messages_getAllStickers req = new TLRPC.TL_messages_getAllStickers();
-            req.hash = hash;
-            ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
-                @Override
-                public void run(final TLObject response, final TLRPC.TL_error error) {
-                    AndroidUtilities.runOnUIThread(new Runnable() {
-                        @Override
-                        public void run() {
-                            processLoadedStickers((TLRPC.messages_AllStickers) response, false, (int)(System.currentTimeMillis() / 1000));
-                        }
-                    });
+            if (stickers != null && !stickers.isEmpty() && !stickersToLoad.isEmpty() && visible) {
+                String fileName = (String) args[0];
+                stickersToLoad.remove(fileName);
+                if (stickersToLoad.isEmpty()) {
+                    delegate.needChangePanelVisibility(stickers != null && !stickers.isEmpty() && stickersToLoad.isEmpty());
                 }
-            });
+            }
         }
     }
 
@@ -144,109 +77,20 @@ private boolean checkStickerFilesExistAndDownload() {
         int size = Math.min(10, stickers.size());
         for (int a = 0; a < size; a++) {
             TLRPC.Document document = stickers.get(a);
-            File f = FileLoader.getPathToAttach(document.thumb, true);
+            File f = FileLoader.getPathToAttach(document.thumb, "webp", true);
             if (!f.exists()) {
-                stickersToLoad.add(FileLoader.getAttachFileName(document.thumb));
-                FileLoader.getInstance().loadFile(document.thumb.location, 0, true);
+                stickersToLoad.add(FileLoader.getAttachFileName(document.thumb, "webp"));
+                FileLoader.getInstance().loadFile(document.thumb.location, "webp", 0, true);
             }
         }
         return stickersToLoad.isEmpty();
     }
 
-    private void putStickersToCache(final TLRPC.TL_messages_allStickers stickers) {
-        MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    SQLitePreparedStatement state = MessagesStorage.getInstance().getDatabase().executeFast("REPLACE INTO stickers VALUES(?, ?, ?)");
-                    state.requery();
-                    ByteBufferDesc data = MessagesStorage.getInstance().getBuffersStorage().getFreeBuffer(stickers.getObjectSize());
-                    stickers.serializeToStream(data);
-                    state.bindInteger(1, 1);
-                    state.bindByteBuffer(2, data.buffer);
-                    state.bindInteger(3, (int) (System.currentTimeMillis() / 1000));
-                    state.step();
-                    MessagesStorage.getInstance().getBuffersStorage().reuseFreeBuffer(data);
-                    state.dispose();
-                } catch (Exception e) {
-                    FileLog.e("tmessages", e);
-                }
-            }
-        });
-    }
-
-    private void processLoadedStickers(final TLRPC.messages_AllStickers res, final boolean cache, final int date) {
-        AndroidUtilities.runOnUIThread(new Runnable() {
-            @Override
-            public void run() {
-                loadingStickers = false;
-            }
-        });
-        Utilities.stageQueue.postRunnable(new Runnable() {
-            @Override
-            public void run() {
-                if ((res == null || date < (int) (System.currentTimeMillis() / 1000 - 60 * 60)) && cache) {
-                    AndroidUtilities.runOnUIThread(new Runnable() {
-                        @Override
-                        public void run() {
-                            loadStickers(false);
-                        }
-                    });
-                    if (res == null) {
-                        return;
-                    }
-                }
-                if (res instanceof TLRPC.TL_messages_allStickers) {
-                    if (!cache) {
-                        putStickersToCache((TLRPC.TL_messages_allStickers) res);
-                    }
-                    HashMap<Long, TLRPC.Document> documents = new HashMap<>();
-                    for (TLRPC.Document document : res.documents) {
-                        if (document == null) {
-                            continue;
-                        }
-                        documents.put(document.id, document);
-                        if (document.thumb != null && document.thumb.location != null) {
-                            document.thumb.location.ext = "webp";
-                        }
-                    }
-                    final HashMap<String, ArrayList<TLRPC.Document>> result = new HashMap<>();
-                    for (TLRPC.TL_stickerPack stickerPack : res.packs) {
-                        if (stickerPack != null && stickerPack.emoticon != null) {
-                            stickerPack.emoticon = stickerPack.emoticon.replace("\uFE0F", "");
-                            ArrayList<TLRPC.Document> arrayList = result.get(stickerPack.emoticon);
-                            for (Long id : stickerPack.documents) {
-                                TLRPC.Document document = documents.get(id);
-                                if (document != null) {
-                                    if (arrayList == null) {
-                                        arrayList = new ArrayList<>();
-                                        result.put(stickerPack.emoticon, arrayList);
-                                    }
-                                    arrayList.add(document);
-                                }
-                            }
-                        }
-                    }
-                    AndroidUtilities.runOnUIThread(new Runnable() {
-                        @Override
-                        public void run() {
-                            allStickers = result;
-                            hash = res.hash;
-                            loadDate = date;
-                            if (lastSticker != null) {
-                                loadStikersForEmoji(lastSticker);
-                            }
-                        }
-                    });
-                }
-            }
-        });
-    }
-
     public void loadStikersForEmoji(CharSequence emoji) {
         boolean search = emoji != null && emoji.length() != 0 && emoji.length() <= 2;
         if (search) {
             lastSticker = emoji.toString();
+            HashMap<String, ArrayList<TLRPC.Document>> allStickers = StickersQuery.getAllStickers();
             if (allStickers != null) {
                 ArrayList<TLRPC.Document> newStickers = allStickers.get(lastSticker);
                 if (stickers != null && newStickers == null) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/BlockedUsersActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/BlockedUsersActivity.java
index b0c4d1434..1c1699d13 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/BlockedUsersActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/BlockedUsersActivity.java
@@ -98,12 +98,7 @@ public void onItemClick(int id) {
         emptyTextView.setGravity(Gravity.CENTER);
         emptyTextView.setVisibility(View.INVISIBLE);
         emptyTextView.setText(LocaleController.getString("NoBlocked", R.string.NoBlocked));
-        frameLayout.addView(emptyTextView);
-        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) emptyTextView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.gravity = Gravity.TOP;
-        emptyTextView.setLayoutParams(layoutParams);
+        frameLayout.addView(emptyTextView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT));
         emptyTextView.setOnTouchListener(new View.OnTouchListener() {
             @Override
             public boolean onTouch(View v, MotionEvent event) {
@@ -112,19 +107,10 @@ public boolean onTouch(View v, MotionEvent event) {
         });
 
         progressView = new FrameLayout(context);
-        frameLayout.addView(progressView);
-        layoutParams = (FrameLayout.LayoutParams) progressView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        progressView.setLayoutParams(layoutParams);
+        frameLayout.addView(progressView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
 
         ProgressBar progressBar = new ProgressBar(context);
-        progressView.addView(progressBar);
-        layoutParams = (FrameLayout.LayoutParams) progressView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.gravity = Gravity.CENTER;
-        progressView.setLayoutParams(layoutParams);
+        progressView.addView(progressBar, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER));
 
         listView = new ListView(context);
         listView.setEmptyView(emptyTextView);
@@ -135,11 +121,7 @@ public boolean onTouch(View v, MotionEvent event) {
         if (Build.VERSION.SDK_INT >= 11) {
             listView.setVerticalScrollbarPosition(LocaleController.isRTL ? ListView.SCROLLBAR_POSITION_LEFT : ListView.SCROLLBAR_POSITION_RIGHT);
         }
-        frameLayout.addView(listView);
-        layoutParams = (FrameLayout.LayoutParams) listView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        listView.setLayoutParams(layoutParams);
+        frameLayout.addView(listView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
 
         listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
             @Override
@@ -170,7 +152,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         }
                     }
                 });
-                showAlertDialog(builder);
+                showDialog(builder.create());
 
                 return true;
             }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatActionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatActionCell.java
index ce31697b2..12c749222 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatActionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatActionCell.java
@@ -98,11 +98,11 @@ public void setMessageObject(MessageObject messageObject) {
             }
             avatarDrawable.setInfo(id, null, null, false);
             if (currentMessageObject.messageOwner.action instanceof TLRPC.TL_messageActionUserUpdatedPhoto) {
-                imageReceiver.setImage(currentMessageObject.messageOwner.action.newUserPhoto.photo_small, "50_50", avatarDrawable, false);
+                imageReceiver.setImage(currentMessageObject.messageOwner.action.newUserPhoto.photo_small, "50_50", avatarDrawable, null, false);
             } else {
                 TLRPC.PhotoSize photo = FileLoader.getClosestPhotoSizeWithSize(currentMessageObject.photoThumbs, AndroidUtilities.dp(64));
                 if (photo != null) {
-                    imageReceiver.setImage(photo.location, "50_50", avatarDrawable, false);
+                    imageReceiver.setImage(photo.location, "50_50", avatarDrawable, null, false);
                 } else {
                     imageReceiver.setImageBitmap(avatarDrawable);
                 }
@@ -225,7 +225,7 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
             try {
                 int linesCount = textLayout.getLineCount();
                 for (int a = 0; a < linesCount; a++) {
-                    float lineWidth = 0;
+                    float lineWidth;
                     float lineLeft = 0;
                     try {
                         lineWidth = textLayout.getLineWidth(a);
@@ -257,7 +257,7 @@ protected void onDraw(Canvas canvas) {
             return;
         }
 
-        Drawable backgroundDrawable = null;
+        Drawable backgroundDrawable;
         if (ApplicationLoader.isCustomTheme()) {
             backgroundDrawable = ResourceLoader.backgroundBlack;
         } else {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatAudioCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatAudioCell.java
index 09bc6fcd1..66862c623 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatAudioCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatAudioCell.java
@@ -165,7 +165,7 @@ public void updateProgress() {
             seekBar.setProgress(currentMessageObject.audioProgress);
         }
 
-        int duration = 0;
+        int duration;
         if (!MediaController.getInstance().isPlayingAudio(currentMessageObject)) {
             duration = currentMessageObject.messageOwner.media.audio.duration;
         } else {
@@ -307,11 +307,6 @@ public void setMessageObject(MessageObject messageObject) {
                 backgroundWidth = Math.min(AndroidUtilities.displaySize.x - AndroidUtilities.dp(isChat ? 102 : 50), AndroidUtilities.dp(300));
             }
 
-            int uid = messageObject.messageOwner.media.audio.user_id;
-            if (uid == 0) {
-                uid = messageObject.messageOwner.from_id;
-            }
-
             if (messageObject.isOut()) {
                 seekBar.type = 0;
                 progressView.setProgressColors(0xffb4e396, 0xff6ac453);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatBaseCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatBaseCell.java
index 72589d5d0..5b8f96c46 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatBaseCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatBaseCell.java
@@ -47,6 +47,7 @@
         void didLongPressed(ChatBaseCell cell);
         void didPressReplyMessage(ChatBaseCell cell, int id);
         void didPressUrl(String url);
+        void needOpenWebView(String url, String title, String originalUrl, int w, int h);
         boolean canPerformActions();
     }
 
@@ -196,6 +197,9 @@ public ChatBaseCell(Context context) {
             replyTextPaint.linkColor = 0xff316f9f;
 
             replyLinePaint = new Paint();
+
+            urlPaint = new Paint();
+            urlPaint.setColor(0x33316f9f);
         }
         avatarImage = new ImageReceiver(this);
         avatarImage.setRoundRadius(AndroidUtilities.dp(21));
@@ -347,7 +351,7 @@ public void setMessageObject(MessageObject messageObject) {
                 currentPhoto = null;
                 avatarDrawable.setInfo(messageObject.messageOwner.from_id, null, null, false);
             }
-            avatarImage.setImage(currentPhoto, "50_50", avatarDrawable, false);
+            avatarImage.setImage(currentPhoto, "50_50", avatarDrawable, null, false);
         }
 
         if (!media) {
@@ -461,7 +465,7 @@ public void setMessageObject(MessageObject messageObject) {
                     needReplyImage = false;
                 } else {
                     currentReplyPhoto = photoSize.location;
-                    replyImageReceiver.setImage(photoSize.location, "50_50", null, true);
+                    replyImageReceiver.setImage(photoSize.location, "50_50", null, null, true);
                     needReplyImage = true;
                     maxWidth -= AndroidUtilities.dp(44);
                 }
@@ -653,7 +657,7 @@ protected void onDraw(Canvas canvas) {
             avatarImage.draw(canvas);
         }
 
-        Drawable currentBackgroundDrawable = null;
+        Drawable currentBackgroundDrawable;
         if (currentMessageObject.isOut()) {
             if (isPressed() && isCheckPressed || !isCheckPressed && isPressed || isHighlighted) {
                 if (!media) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatContactCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatContactCell.java
index 45907c708..129348b60 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatContactCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatContactCell.java
@@ -195,7 +195,7 @@ public void setMessageObject(MessageObject messageObject) {
                 currentPhoto = null;
                 avatarDrawable.setInfo(uid, null, null, false);
             }
-            avatarImage.setImage(currentPhoto, "50_50", avatarDrawable, false);
+            avatarImage.setImage(currentPhoto, "50_50", avatarDrawable, null, false);
 
             String currentNameString = ContactsController.formatName(messageObject.messageOwner.media.first_name, messageObject.messageOwner.media.last_name);
             int nameWidth = Math.min((int) Math.ceil(namePaint.measureText(currentNameString)), maxWidth);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMediaCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMediaCell.java
index 69cd4052c..df409c4b7 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMediaCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMediaCell.java
@@ -34,7 +34,6 @@
 import org.telegram.messenger.FileLog;
 import org.telegram.messenger.R;
 import org.telegram.messenger.TLRPC;
-import org.telegram.messenger.Utilities;
 import org.telegram.android.MessageObject;
 import org.telegram.ui.Components.RadialProgress;
 import org.telegram.ui.Components.ResourceLoader;
@@ -407,7 +406,7 @@ private void didPressedButton(boolean animated) {
             cancelLoading = false;
             radialProgress.setProgress(0, false);
             if (currentMessageObject.type == 1) {
-                photoImage.setImage(currentPhotoObject.location, currentPhotoFilter, currentPhotoObjectThumb != null ? currentPhotoObjectThumb.location : null, currentPhotoFilter, currentPhotoObject.size, false);
+                photoImage.setImage(currentPhotoObject.location, currentPhotoFilter, currentPhotoObjectThumb != null ? currentPhotoObjectThumb.location : null, currentPhotoFilter, currentPhotoObject.size, null, false);
             } else if (currentMessageObject.type == 8 || currentMessageObject.type == 9) {
                 FileLoader.getInstance().loadFile(currentMessageObject.messageOwner.media.document, true, false);
                 lastDownloadedGifMessage = currentMessageObject;
@@ -527,7 +526,7 @@ public void setMessageObject(MessageObject messageObject) {
                 }
                 ext = ext.toUpperCase();
 
-                String str = Utilities.formatFileSize(messageObject.messageOwner.media.document.size) + " " + ext;
+                String str = AndroidUtilities.formatFileSize(messageObject.messageOwner.media.document.size) + " " + ext;
 
                 if (currentInfoString == null || !currentInfoString.equals(str)) {
                     currentInfoString = str;
@@ -539,7 +538,7 @@ public void setMessageObject(MessageObject messageObject) {
             } else if (messageObject.type == 8) {
                 gifDrawable = MediaController.getInstance().getGifDrawable(this, false);
 
-                String str = Utilities.formatFileSize(messageObject.messageOwner.media.document.size);
+                String str = AndroidUtilities.formatFileSize(messageObject.messageOwner.media.document.size);
                 if (currentInfoString == null || !currentInfoString.equals(str)) {
                     currentInfoString = str;
                     infoOffset = 0;
@@ -552,7 +551,7 @@ public void setMessageObject(MessageObject messageObject) {
                 int duration = messageObject.messageOwner.media.video.duration;
                 int minutes = duration / 60;
                 int seconds = duration - minutes * 60;
-                String str = String.format("%d:%02d, %s", minutes, seconds, Utilities.formatFileSize(messageObject.messageOwner.media.video.size));
+                String str = String.format("%d:%02d, %s", minutes, seconds, AndroidUtilities.formatFileSize(messageObject.messageOwner.media.video.size));
                 if (currentInfoString == null || !currentInfoString.equals(str)) {
                     currentInfoString = str;
                     infoOffset = ResourceLoader.videoIconDrawable.getIntrinsicWidth() + AndroidUtilities.dp(4);
@@ -578,7 +577,7 @@ public void setMessageObject(MessageObject messageObject) {
                 photoImage.setParentMessageObject(messageObject);
                 if (currentPhotoObject != null) {
                     currentPhotoFilter = String.format(Locale.US, "%d_%d_b", photoWidth, photoHeight);
-                    photoImage.setImage(null, null, null, null, currentPhotoObject.location, currentPhotoFilter, 0, true);
+                    photoImage.setImage(null, null, null, null, currentPhotoObject.location, currentPhotoFilter, 0, null, true);
                 } else {
                     photoImage.setImageBitmap((BitmapDrawable) null);
                 }
@@ -605,7 +604,6 @@ public void setMessageObject(MessageObject messageObject) {
                         maxWidth = (int) Math.max(maxWidth, nameLayout.getLineWidth(a) + AndroidUtilities.dp(16));
                     }
                     if (infoLayout != null) {
-                        lineCount = infoLayout.getLineCount();
                         for (int a = 0; a < infoLayout.getLineCount(); a++) {
                             maxWidth = (int) Math.max(maxWidth, infoLayout.getLineWidth(a) + AndroidUtilities.dp(16));
                         }
@@ -622,7 +620,7 @@ public void setMessageObject(MessageObject messageObject) {
                 photoImage.setNeedsQualityThumb(false);
                 photoImage.setShouldGenerateQualityThumb(false);
                 photoImage.setParentMessageObject(null);
-                photoImage.setImage(currentUrl, null, messageObject.isOut() ? ResourceLoader.geoOutDrawable : ResourceLoader.geoInDrawable, 0);
+                photoImage.setImage(currentUrl, null, messageObject.isOut() ? ResourceLoader.geoOutDrawable : ResourceLoader.geoInDrawable, null, 0);
             } else if (messageObject.type == 13) { //webp
                 drawBackground = false;
                 for (TLRPC.DocumentAttribute attribute : messageObject.messageOwner.media.document.attributes) {
@@ -664,7 +662,7 @@ public void setMessageObject(MessageObject messageObject) {
                                 null,
                                 currentPhotoObjectThumb != null ? currentPhotoObjectThumb.location : null,
                                 "b1",
-                                messageObject.messageOwner.media.document.size, true);
+                                messageObject.messageOwner.media.document.size, "webp", true);
                     }
                 } else if (messageObject.messageOwner.media.document.id != 0) {
                     photoImage.setImage(messageObject.messageOwner.media.document, null,
@@ -672,7 +670,7 @@ public void setMessageObject(MessageObject messageObject) {
                             null,
                             currentPhotoObjectThumb != null ? currentPhotoObjectThumb.location : null,
                             "b1",
-                            messageObject.messageOwner.media.document.size, true);
+                            messageObject.messageOwner.media.document.size, "webp", true);
                 }
             } else {
                 if (AndroidUtilities.isTablet()) {
@@ -803,22 +801,22 @@ public void setMessageObject(MessageObject messageObject) {
                         if (photoExist || MediaController.getInstance().canDownloadMedia(MediaController.AUTODOWNLOAD_MASK_PHOTO) || FileLoader.getInstance().isLoadingFile(fileName)) {
                             if (allowedToSetPhoto || ImageLoader.getInstance().getImageFromMemory(currentPhotoObject.location, null, currentPhotoFilter) != null) {
                                 allowedToSetPhoto = true;
-                                photoImage.setImage(currentPhotoObject.location, currentPhotoFilter, currentPhotoObjectThumb != null ? currentPhotoObjectThumb.location : null, currentPhotoFilter, noSize ? 0 : currentPhotoObject.size, false);
+                                photoImage.setImage(currentPhotoObject.location, currentPhotoFilter, currentPhotoObjectThumb != null ? currentPhotoObjectThumb.location : null, currentPhotoFilter, noSize ? 0 : currentPhotoObject.size, null, false);
                             } else if (currentPhotoObjectThumb != null) {
-                                photoImage.setImage(null, null, currentPhotoObjectThumb.location, currentPhotoFilter, 0, false);
+                                photoImage.setImage(null, null, currentPhotoObjectThumb.location, currentPhotoFilter, 0, null, false);
                             } else {
                                 photoImage.setImageBitmap((Drawable) null);
                             }
                         } else {
                             photoNotSet = true;
                             if (currentPhotoObjectThumb != null) {
-                                photoImage.setImage(null, null, currentPhotoObjectThumb.location, currentPhotoFilter, 0, false);
+                                photoImage.setImage(null, null, currentPhotoObjectThumb.location, currentPhotoFilter, 0, null, false);
                             } else {
                                 photoImage.setImageBitmap((Drawable) null);
                             }
                         }
                     } else {
-                        photoImage.setImage(null, null, currentPhotoObject.location, currentPhotoFilter, 0, false);
+                        photoImage.setImage(null, null, currentPhotoObject.location, currentPhotoFilter, 0, null, false);
                     }
                 } else {
                     photoImage.setImageBitmap((Bitmap) null);
@@ -998,7 +996,7 @@ protected void onAfterBackgroundDraw(Canvas canvas) {
         radialProgress.setHideCurrentDrawable(false);
 
         if (currentMessageObject.type == 9) {
-            Drawable menuDrawable = null;
+            Drawable menuDrawable;
             if (currentMessageObject.isOut()) {
                 infoPaint.setColor(0xff70b15c);
                 docBackPaint.setColor(0xffdaf5c3);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java
index 00a9477a4..8e5924c37 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java
@@ -14,6 +14,7 @@
 import android.graphics.Paint;
 import android.graphics.drawable.Drawable;
 import android.net.Uri;
+import android.os.Build;
 import android.provider.Browser;
 import android.text.Layout;
 import android.text.Spannable;
@@ -36,6 +37,7 @@
 import org.telegram.ui.Components.StaticLayoutEx;
 import org.telegram.ui.Components.URLSpanNoUnderline;
 
+import java.io.File;
 import java.util.Locale;
 
 public class ChatMessageCell extends ChatBaseCell {
@@ -56,6 +58,9 @@
     private boolean isInstagram;
     private int descriptionY;
     private int durationWidth;
+    private int descriptionX;
+    private int titleX;
+    private int authorX;
     private StaticLayout siteNameLayout;
     private StaticLayout titleLayout;
     private StaticLayout descriptionLayout;
@@ -69,10 +74,6 @@ public ChatMessageCell(Context context) {
         super(context);
         drawForwardedName = true;
         linkImageView = new ImageReceiver(this);
-        if (urlPaint == null) {
-            urlPaint = new Paint();
-            urlPaint.setColor(0x33316f9f);
-        }
     }
 
     @Override
@@ -152,7 +153,7 @@ public boolean onTouchEvent(MotionEvent event) {
                         } else {
                             if (descriptionLayout != null && y >= descriptionY) {
                                 try {
-                                    x -= textX + AndroidUtilities.dp(10);
+                                    x -= textX + AndroidUtilities.dp(10) + descriptionX;
                                     y -= descriptionY;
                                     final int line = descriptionLayout.getLineForVertical(y);
                                     final int off = descriptionLayout.getOffsetForHorizontal(line, x);
@@ -191,10 +192,15 @@ public boolean onTouchEvent(MotionEvent event) {
                             if (pressedLink != null) {
                                 pressedLink.onClick(this);
                             } else {
-                                Uri uri = Uri.parse(currentMessageObject.messageOwner.media.webpage.url);
-                                Intent intent = new Intent(Intent.ACTION_VIEW, uri);
-                                intent.putExtra(Browser.EXTRA_APPLICATION_ID, getContext().getPackageName());
-                                getContext().startActivity(intent);
+                                TLRPC.WebPage webPage = currentMessageObject.messageOwner.media.webpage;
+                                if (Build.VERSION.SDK_INT >= 16 && webPage.embed_url != null && webPage.embed_url.length() != 0) {
+                                    delegate.needOpenWebView(webPage.embed_url, webPage.site_name, webPage.url, webPage.embed_width, webPage.embed_height);
+                                } else {
+                                    Uri uri = Uri.parse(webPage.url);
+                                    Intent intent = new Intent(Intent.ACTION_VIEW, uri);
+                                    intent.putExtra(Browser.EXTRA_APPLICATION_ID, getContext().getPackageName());
+                                    getContext().startActivity(intent);
+                                }
                             }
                         } catch (Exception e) {
                             FileLog.e("tmessages", e);
@@ -260,6 +266,9 @@ private StaticLayout generateStaticLayout(CharSequence text, TextPaint paint, in
         int addedChars = 0;
         StaticLayout layout = new StaticLayout(text, paint, smallWidth, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
         for (int a = 0; a < linesCount; a++) {
+            if (layout.getLineLeft(a) != 0) {
+                maxWidth = smallWidth;
+            }
             int pos = layout.getLineEnd(a);
             if (pos == text.length()) {
                 break;
@@ -348,6 +357,7 @@ public void setMessageObject(MessageObject messageObject) {
             maxChildWidth = Math.max(maxChildWidth, forwardedNameWidth);
             maxChildWidth = Math.max(maxChildWidth, replyNameWidth);
             maxChildWidth = Math.max(maxChildWidth, replyTextWidth);
+            int maxWebWidth = 0;
 
             int timeMore = timeWidth + AndroidUtilities.dp(6);
             if (messageObject.isOut()) {
@@ -387,9 +397,7 @@ public void setMessageObject(MessageObject messageObject) {
                     currentMessageObject.generateThumbs(true);
                 }
 
-                if (MediaController.getInstance().canDownloadMedia(MediaController.AUTODOWNLOAD_MASK_PHOTO)) {
-                    isSmallImage = webPage.description != null && webPage.type != null && (webPage.type.equals("app") || webPage.type.equals("profile") || webPage.type.equals("article")) && currentMessageObject.photoThumbs != null;
-                }
+                isSmallImage = webPage.description != null && webPage.type != null && (webPage.type.equals("app") || webPage.type.equals("profile") || webPage.type.equals("article")) && currentMessageObject.photoThumbs != null;
 
                 if (webPage.site_name != null) {
                     try {
@@ -399,35 +407,54 @@ public void setMessageObject(MessageObject messageObject) {
                         linkPreviewHeight += height;
                         totalHeight += height;
                         additionalHeight += height;
+                        width = siteNameLayout.getWidth();
                         maxChildWidth = Math.max(maxChildWidth, width + additinalWidth);
+                        maxWebWidth = Math.max(maxWebWidth, width + additinalWidth);
                     } catch (Exception e) {
                         FileLog.e("tmessages", e);
                     }
                 }
 
+                boolean titleIsRTL = false;
                 if (webPage.title != null) {
                     try {
+                        titleX = 0;
                         if (linkPreviewHeight != 0) {
                             linkPreviewHeight += AndroidUtilities.dp(2);
                             totalHeight += AndroidUtilities.dp(2);
                         }
                         int restLines = 0;
                         if (!isSmallImage || webPage.description == null) {
-                            titleLayout = StaticLayoutEx.createStaticLayout(webPage.title, replyNamePaint, linkPreviewMaxWidth, Layout.Alignment.ALIGN_NORMAL, 1.0f, AndroidUtilities.dp(1), false, TextUtils.TruncateAt.END, linkPreviewMaxWidth, 2);
+                            titleLayout = StaticLayoutEx.createStaticLayout(webPage.title, replyNamePaint, linkPreviewMaxWidth, Layout.Alignment.ALIGN_NORMAL, 1.0f, AndroidUtilities.dp(1), false, TextUtils.TruncateAt.END, linkPreviewMaxWidth, 4);
                         } else {
                             restLines = restLinesCount;
-                            titleLayout = generateStaticLayout(webPage.title, replyNamePaint, linkPreviewMaxWidth, linkPreviewMaxWidth - AndroidUtilities.dp(48 + 2), restLinesCount, 2);
+                            titleLayout = generateStaticLayout(webPage.title, replyNamePaint, linkPreviewMaxWidth, linkPreviewMaxWidth - AndroidUtilities.dp(48 + 2), restLinesCount, 4);
                             restLinesCount -= titleLayout.getLineCount();
                         }
                         int height = titleLayout.getLineBottom(titleLayout.getLineCount() - 1);
                         linkPreviewHeight += height;
                         totalHeight += height;
                         for (int a = 0; a < titleLayout.getLineCount(); a++) {
-                            int width = (int) Math.ceil(titleLayout.getLineWidth(a));
-                            if (a < restLines) {
+                            int lineLeft = (int) titleLayout.getLineLeft(a);
+                            if (lineLeft != 0) {
+                                titleIsRTL = true;
+                                if (titleX == 0) {
+                                    titleX = -lineLeft;
+                                } else {
+                                    titleX = Math.max(titleX, -lineLeft);
+                                }
+                            }
+                            int width;
+                            if (lineLeft != 0) {
+                                width = titleLayout.getWidth() - lineLeft;
+                            } else {
+                                width = (int) Math.ceil(titleLayout.getLineWidth(a));
+                            }
+                            if (a < restLines || lineLeft != 0 && isSmallImage) {
                                 width += AndroidUtilities.dp(48 + 2);
                             }
                             maxChildWidth = Math.max(maxChildWidth, width + additinalWidth);
+                            maxWebWidth = Math.max(maxWebWidth, width + additinalWidth);
                         }
                     } catch (Exception e) {
                         FileLog.e("tmessages", e);
@@ -450,7 +477,10 @@ public void setMessageObject(MessageObject messageObject) {
                         int height = authorLayout.getLineBottom(authorLayout.getLineCount() - 1);
                         linkPreviewHeight += height;
                         totalHeight += height;
+                        int lineLeft = (int) authorLayout.getLineLeft(0);
+                        authorX = -lineLeft;
                         maxChildWidth = Math.max(maxChildWidth, width + additinalWidth);
+                        maxWebWidth = Math.max(maxWebWidth, width + additinalWidth);
                     } catch (Exception e) {
                         FileLog.e("tmessages", e);
                     }
@@ -458,6 +488,7 @@ public void setMessageObject(MessageObject messageObject) {
 
                 if (webPage.description != null) {
                     try {
+                        descriptionX = 0;
                         currentMessageObject.generateLinkDescription();
                         if (linkPreviewHeight != 0) {
                             linkPreviewHeight += AndroidUtilities.dp(2);
@@ -474,10 +505,28 @@ public void setMessageObject(MessageObject messageObject) {
                         linkPreviewHeight += height;
                         totalHeight += height;
                         for (int a = 0; a < descriptionLayout.getLineCount(); a++) {
-                            int width = (int) Math.ceil(descriptionLayout.getLineWidth(a));
-                            if (a < restLines) {
+                            int lineLeft = (int) Math.ceil(descriptionLayout.getLineLeft(a));
+                            if (descriptionX == 0) {
+                                descriptionX = -lineLeft;
+                            } else {
+                                descriptionX = Math.max(descriptionX, -lineLeft);
+                            }
+
+                            int width;
+                            if (lineLeft != 0) {
+                                width = descriptionLayout.getWidth() - lineLeft;
+                            } else {
+                                width = (int) Math.ceil(descriptionLayout.getLineWidth(a));
+                            }
+                            if (a < restLines || lineLeft != 0 && isSmallImage) {
                                 width += AndroidUtilities.dp(48 + 2);
                             }
+                            if (maxWebWidth < width + additinalWidth) {
+                                if (titleIsRTL) {
+                                    titleX += (width + additinalWidth - maxWebWidth);
+                                }
+                                maxWebWidth = width + additinalWidth;
+                            }
                             maxChildWidth = Math.max(maxChildWidth, width + additinalWidth);
                         }
                     } catch (Exception e) {
@@ -485,7 +534,7 @@ public void setMessageObject(MessageObject messageObject) {
                     }
                 }
 
-                if (webPage.photo != null && MediaController.getInstance().canDownloadMedia(MediaController.AUTODOWNLOAD_MASK_PHOTO)) {
+                if (webPage.photo != null) {
                     boolean smallImage = webPage.type != null && (webPage.type.equals("app") || webPage.type.equals("profile") || webPage.type.equals("article"));
                     if (smallImage && descriptionLayout != null && descriptionLayout.getLineCount() == 1) {
                         smallImage = false;
@@ -537,7 +586,26 @@ public void setMessageObject(MessageObject messageObject) {
                         }
 
                         linkImageView.setImageCoords(0, 0, width, height);
-                        linkImageView.setImage(currentPhotoObject.location, String.format(Locale.US, "%d_%d", width, height), currentPhotoObjectThumb != null ? currentPhotoObjectThumb.location : null, String.format(Locale.US, "%d_%d_b", width, height), 0, false);
+
+                        String fileName = FileLoader.getAttachFileName(currentPhotoObject);
+
+                        boolean photoExist = true;
+                        File cacheFile = FileLoader.getPathToAttach(currentPhotoObject, true);
+                        if (!cacheFile.exists()) {
+                            photoExist = false;
+                        }
+
+                        String filter = String.format(Locale.US, "%d_%d", width, height);
+
+                        if (photoExist || MediaController.getInstance().canDownloadMedia(MediaController.AUTODOWNLOAD_MASK_PHOTO) || FileLoader.getInstance().isLoadingFile(fileName)) {
+                            linkImageView.setImage(currentPhotoObject.location, filter, currentPhotoObjectThumb != null ? currentPhotoObjectThumb.location : null, String.format(Locale.US, "%d_%d_b", width, height), 0, null, false);
+                        } else {
+                            if (currentPhotoObjectThumb != null) {
+                                linkImageView.setImage(null, null, currentPhotoObjectThumb.location, String.format(Locale.US, "%d_%d_b", width, height), 0, null, false);
+                            } else {
+                                linkImageView.setImageBitmap((Drawable) null);
+                            }
+                        }
                         drawLinkImageView = true;
 
                         if (webPage.site_name != null) {
@@ -659,7 +727,7 @@ protected void onDraw(Canvas canvas) {
                 replyNamePaint.setColor(0xff000000);
                 smallImageStartY = linkPreviewY - AndroidUtilities.dp(1);
                 canvas.save();
-                canvas.translate(textX + AndroidUtilities.dp(10), linkPreviewY - AndroidUtilities.dp(3));
+                canvas.translate(textX + AndroidUtilities.dp(10) + titleX, linkPreviewY - AndroidUtilities.dp(3));
                 titleLayout.draw(canvas);
                 canvas.restore();
                 linkPreviewY += titleLayout.getLineBottom(titleLayout.getLineCount() - 1);
@@ -674,7 +742,7 @@ protected void onDraw(Canvas canvas) {
                 }
                 replyNamePaint.setColor(0xff000000);
                 canvas.save();
-                canvas.translate(textX + AndroidUtilities.dp(10), linkPreviewY - AndroidUtilities.dp(3));
+                canvas.translate(textX + AndroidUtilities.dp(10) + authorX, linkPreviewY - AndroidUtilities.dp(3));
                 authorLayout.draw(canvas);
                 canvas.restore();
                 linkPreviewY += authorLayout.getLineBottom(authorLayout.getLineCount() - 1);
@@ -690,7 +758,7 @@ protected void onDraw(Canvas canvas) {
                 replyTextPaint.setColor(0xff000000);
                 descriptionY = linkPreviewY - AndroidUtilities.dp(3);
                 canvas.save();
-                canvas.translate(textX + AndroidUtilities.dp(10), descriptionY);
+                canvas.translate(textX + AndroidUtilities.dp(10) + descriptionX, descriptionY);
                 if (pressedLink != null && linkBlockNum == -10) {
                     canvas.drawPath(urlPath, urlPaint);
                 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/DialogCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/DialogCell.java
index 10f96292c..41a469e9e 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/DialogCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/DialogCell.java
@@ -12,10 +12,12 @@
 import android.graphics.Canvas;
 import android.graphics.Paint;
 import android.graphics.drawable.Drawable;
+import android.os.Build;
 import android.text.Layout;
 import android.text.StaticLayout;
 import android.text.TextPaint;
 import android.text.TextUtils;
+import android.view.MotionEvent;
 
 import org.telegram.android.AndroidUtilities;
 import org.telegram.PhoneFormat.PhoneFormat;
@@ -52,6 +54,7 @@
     private static Drawable muteDrawable;
 
     private static Paint linePaint;
+    private static Paint backPaint;
 
     private long currentDialogId;
     private boolean isDialogCell;
@@ -74,7 +77,6 @@
 
     public boolean useSeparator = false;
 
-
     private int nameLeft;
     private StaticLayout nameLayout;
     private boolean drawNameLock;
@@ -111,7 +113,11 @@
 
     private int avatarTop = AndroidUtilities.dp(10);
 
-    private void init() {
+    private boolean isSelected;
+
+    public DialogCell(Context context) {
+        super(context);
+
         if (namePaint == null) {
             namePaint = new TextPaint(TextPaint.ANTI_ALIAS_FLAG);
             namePaint.setTextSize(AndroidUtilities.dp(17));
@@ -136,6 +142,9 @@ private void init() {
             linePaint = new Paint();
             linePaint.setColor(0xffdcdcdc);
 
+            backPaint = new Paint();
+            backPaint.setColor(0x0f000000);
+
             messagePrintingPaint = new TextPaint(TextPaint.ANTI_ALIAS_FLAG);
             messagePrintingPaint.setTextSize(AndroidUtilities.dp(16));
             messagePrintingPaint.setColor(0xff4d83b3);
@@ -159,11 +168,9 @@ private void init() {
             broadcastDrawable = getResources().getDrawable(R.drawable.list_broadcast);
             muteDrawable = getResources().getDrawable(R.drawable.mute_grey);
         }
-    }
 
-    public DialogCell(Context context) {
-        super(context);
-        init();
+        setBackgroundResource(R.drawable.list_selector);
+
         avatarImage = new ImageReceiver(this);
         avatarImage.setRoundRadius(AndroidUtilities.dp(26));
         avatarDrawable = new AvatarDrawable();
@@ -208,7 +215,7 @@ protected void onAttachedToWindow() {
 
     @Override
     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        setMeasuredDimension(MeasureSpec.getSize(widthMeasureSpec), AndroidUtilities.dp(72));
+        setMeasuredDimension(MeasureSpec.getSize(widthMeasureSpec), AndroidUtilities.dp(72) + (useSeparator ? 1 : 0));
     }
 
     @Override
@@ -222,6 +229,16 @@ protected void onLayout(boolean changed, int left, int top, int right, int botto
         }
     }
 
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        if (Build.VERSION.SDK_INT >= 21 && getBackground() != null) {
+            if (event.getAction() == MotionEvent.ACTION_DOWN || event.getAction() == MotionEvent.ACTION_MOVE) {
+                getBackground().setHotspot(event.getX(), event.getY());
+            }
+        }
+        return super.onTouchEvent(event);
+    }
+
     public void buildLayout() {
         String nameString = "";
         String timeString = "";
@@ -568,8 +585,8 @@ public void buildLayout() {
             FileLog.e("tmessages", e);
         }
 
-        double widthpx = 0;
-        float left = 0;
+        double widthpx;
+        float left;
         if (LocaleController.isRTL) {
             if (nameLayout != null && nameLayout.getLineCount() > 0) {
                 left = nameLayout.getLineLeft(0);
@@ -617,6 +634,13 @@ public void buildLayout() {
         }
     }
 
+    public void setDialogSelected(boolean value) {
+        if (isSelected != value) {
+            invalidate();
+        }
+        isSelected = value;
+    }
+
     public void checkCurrentDialogIndex() {
         TLRPC.TL_dialog dialog = null;
         if (isServerOnly) {
@@ -740,7 +764,7 @@ public void update(int mask) {
             }
             avatarDrawable.setInfo(chat);
         }
-        avatarImage.setImage(photo, "50_50", avatarDrawable, false);
+        avatarImage.setImage(photo, "50_50", avatarDrawable, null, false);
 
         if (getMeasuredWidth() != 0 || getMeasuredHeight() != 0) {
             buildLayout();
@@ -757,6 +781,10 @@ protected void onDraw(Canvas canvas) {
             return;
         }
 
+        if (isSelected) {
+            canvas.drawRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), backPaint);
+        }
+
         if (drawNameLock) {
             setDrawableBounds(lockDrawable, nameLockLeft, nameLockTop);
             lockDrawable.draw(canvas);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/DrawerActionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/DrawerActionCell.java
index 3e127c02c..49c9c5514 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/DrawerActionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/DrawerActionCell.java
@@ -33,14 +33,7 @@ public DrawerActionCell(Context context) {
         textView.setSingleLine(true);
         textView.setGravity(Gravity.LEFT | Gravity.CENTER_VERTICAL);
         textView.setCompoundDrawablePadding(AndroidUtilities.dp(34));
-        addView(textView);
-        LayoutParams layoutParams = (LayoutParams) textView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.gravity = Gravity.LEFT;
-        layoutParams.leftMargin = AndroidUtilities.dp(14);
-        layoutParams.rightMargin = AndroidUtilities.dp(16);
-        textView.setLayoutParams(layoutParams);
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.LEFT | Gravity.TOP, 14, 0, 16, 0));
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/DrawerProfileCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/DrawerProfileCell.java
index afe12f393..1d2692c6a 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/DrawerProfileCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/DrawerProfileCell.java
@@ -27,6 +27,7 @@
 import org.telegram.android.AndroidUtilities;
 import org.telegram.android.ContactsController;
 import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.FileLog;
 import org.telegram.messenger.R;
 import org.telegram.messenger.TLRPC;
 import org.telegram.ui.Components.AvatarDrawable;
@@ -51,23 +52,11 @@ public DrawerProfileCell(Context context) {
         shadowView.setVisibility(INVISIBLE);
         shadowView.setScaleType(ImageView.ScaleType.FIT_XY);
         shadowView.setImageResource(R.drawable.bottom_shadow);
-        addView(shadowView);
-        LayoutParams layoutParams = (FrameLayout.LayoutParams) shadowView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = AndroidUtilities.dp(70);
-        layoutParams.gravity = Gravity.LEFT | Gravity.BOTTOM;
-        shadowView.setLayoutParams(layoutParams);
+        addView(shadowView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 70, Gravity.LEFT | Gravity.BOTTOM));
 
         avatarImageView = new BackupImageView(context);
         avatarImageView.getImageReceiver().setRoundRadius(AndroidUtilities.dp(32));
-        addView(avatarImageView);
-        layoutParams = (LayoutParams) avatarImageView.getLayoutParams();
-        layoutParams.width = AndroidUtilities.dp(64);
-        layoutParams.height = AndroidUtilities.dp(64);
-        layoutParams.gravity = Gravity.LEFT | Gravity.BOTTOM;
-        layoutParams.leftMargin = AndroidUtilities.dp(16);
-        layoutParams.bottomMargin = AndroidUtilities.dp(67);
-        avatarImageView.setLayoutParams(layoutParams);
+        addView(avatarImageView, LayoutHelper.createFrame(64, 64, Gravity.LEFT | Gravity.BOTTOM, 16, 0, 0, 67));
 
         nameTextView = new TextView(context);
         nameTextView.setTextColor(0xffffffff);
@@ -77,15 +66,7 @@ public DrawerProfileCell(Context context) {
         nameTextView.setMaxLines(1);
         nameTextView.setSingleLine(true);
         nameTextView.setGravity(Gravity.LEFT);
-        addView(nameTextView);
-        layoutParams = (FrameLayout.LayoutParams) nameTextView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.gravity = Gravity.LEFT | Gravity.BOTTOM;
-        layoutParams.leftMargin = AndroidUtilities.dp(16);
-        layoutParams.bottomMargin = AndroidUtilities.dp(28);
-        layoutParams.rightMargin = AndroidUtilities.dp(16);
-        nameTextView.setLayoutParams(layoutParams);
+        addView(nameTextView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.BOTTOM, 16, 0, 16, 28));
 
         phoneTextView = new TextView(context);
         phoneTextView.setTextColor(0xffc2e5ff);
@@ -94,15 +75,7 @@ public DrawerProfileCell(Context context) {
         phoneTextView.setMaxLines(1);
         phoneTextView.setSingleLine(true);
         phoneTextView.setGravity(Gravity.LEFT);
-        addView(phoneTextView);
-        layoutParams = (FrameLayout.LayoutParams) phoneTextView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.gravity = Gravity.LEFT | Gravity.BOTTOM;
-        layoutParams.leftMargin = AndroidUtilities.dp(16);
-        layoutParams.bottomMargin = AndroidUtilities.dp(9);
-        layoutParams.rightMargin = AndroidUtilities.dp(16);
-        phoneTextView.setLayoutParams(layoutParams);
+        addView(phoneTextView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.BOTTOM, 16, 0, 16, 9));
     }
 
     @Override
@@ -110,7 +83,11 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
         if (Build.VERSION.SDK_INT >= 21) {
             super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(148) + AndroidUtilities.statusBarHeight, MeasureSpec.EXACTLY));
         } else {
-            super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(148), MeasureSpec.EXACTLY));
+            try {
+                super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(148), MeasureSpec.EXACTLY));
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
         }
     }
 
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/GreySectionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/GreySectionCell.java
index 43a5132e8..c38def2a2 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/GreySectionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/GreySectionCell.java
@@ -31,19 +31,12 @@ public GreySectionCell(Context context) {
         textView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
         textView.setTextColor(0xff8a8a8a);
         textView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL);
-        addView(textView);
-        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams)textView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(16);
-        layoutParams.rightMargin = AndroidUtilities.dp(16);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        textView.setLayoutParams(layoutParams);
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, 16, 0, 16, 0));
     }
 
     @Override
     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(36), MeasureSpec.EXACTLY));
+        super.onMeasure(MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(36), MeasureSpec.EXACTLY));
     }
 
     public void setText(String text) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/HashtagSearchCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/HashtagSearchCell.java
index ccb8dbcef..6655015ef 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/HashtagSearchCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/HashtagSearchCell.java
@@ -11,11 +11,14 @@
 import android.content.Context;
 import android.graphics.Canvas;
 import android.graphics.Paint;
+import android.os.Build;
 import android.util.TypedValue;
 import android.view.Gravity;
+import android.view.MotionEvent;
 import android.widget.TextView;
 
 import org.telegram.android.AndroidUtilities;
+import org.telegram.messenger.R;
 
 public class HashtagSearchCell extends TextView {
 
@@ -32,6 +35,18 @@ public HashtagSearchCell(Context context) {
             paint = new Paint();
             paint.setColor(0xffdcdcdc);
         }
+
+        setBackgroundResource(R.drawable.list_selector);
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        if (Build.VERSION.SDK_INT >= 21 && getBackground() != null) {
+            if (event.getAction() == MotionEvent.ACTION_DOWN || event.getAction() == MotionEvent.ACTION_MOVE) {
+                getBackground().setHotspot(event.getX(), event.getY());
+            }
+        }
+        return super.onTouchEvent(event);
     }
 
     public void setNeedDivider(boolean value) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/HeaderCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/HeaderCell.java
index dd4a8eb20..bfc725fa0 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/HeaderCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/HeaderCell.java
@@ -9,7 +9,6 @@
 package org.telegram.ui.Cells;
 
 import android.content.Context;
-import android.util.AttributeSet;
 import android.util.TypedValue;
 import android.view.Gravity;
 import android.widget.FrameLayout;
@@ -23,41 +22,15 @@
 
     private TextView textView;
 
-    private void init() {
+    public HeaderCell(Context context) {
+        super(context);
+
         textView = new TextView(getContext());
         textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15);
         textView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
         textView.setTextColor(0xff3e90cf);
         textView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL);
-        addView(textView);
-        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams)textView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(17);
-        layoutParams.rightMargin = AndroidUtilities.dp(17);
-        layoutParams.topMargin = AndroidUtilities.dp(15);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        textView.setLayoutParams(layoutParams);
-    }
-
-    public HeaderCell(Context context) {
-        super(context);
-        init();
-    }
-
-    public HeaderCell(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        init();
-    }
-
-    public HeaderCell(Context context, AttributeSet attrs, int defStyleAttr) {
-        super(context, attrs, defStyleAttr);
-        init();
-    }
-
-    public HeaderCell(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
-        super(context, attrs, defStyleAttr, defStyleRes);
-        init();
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, 17, 15, 17, 0));
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LetterSectionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LetterSectionCell.java
index 18ac212bb..4ff29231f 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LetterSectionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LetterSectionCell.java
@@ -31,11 +31,7 @@ public LetterSectionCell(Context context) {
         textView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
         textView.setTextColor(0xff808080);
         textView.setGravity(Gravity.CENTER);
-        addView(textView);
-        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams)textView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        textView.setLayoutParams(layoutParams);
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
     }
 
     public void setLetter(String letter) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LoadingCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LoadingCell.java
index aad139aa8..fe1f545c0 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LoadingCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LoadingCell.java
@@ -22,16 +22,11 @@ public LoadingCell(Context context) {
         super(context);
 
         ProgressBar progressBar = new ProgressBar(context);
-        addView(progressBar);
-        LayoutParams layoutParams = (FrameLayout.LayoutParams) progressBar.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.gravity = Gravity.CENTER;
-        progressBar.setLayoutParams(layoutParams);
+        addView(progressBar, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER));
     }
 
     @Override
     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(54), MeasureSpec.EXACTLY));
+        super.onMeasure(MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(54), MeasureSpec.EXACTLY));
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/MentionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/MentionCell.java
index 05cd5b6b9..7a477eafb 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/MentionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/MentionCell.java
@@ -39,13 +39,7 @@ public MentionCell(Context context) {
 
         imageView = new BackupImageView(context);
         imageView.setRoundRadius(AndroidUtilities.dp(14));
-        addView(imageView);
-        LayoutParams layoutParams = (LayoutParams) imageView.getLayoutParams();
-        layoutParams.leftMargin = AndroidUtilities.dp(12);
-        layoutParams.topMargin = AndroidUtilities.dp(4);
-        layoutParams.width = AndroidUtilities.dp(28);
-        layoutParams.height = AndroidUtilities.dp(28);
-        imageView.setLayoutParams(layoutParams);
+        addView(imageView, LayoutHelper.createLinear(28, 28, 12, 4, 0, 0));
 
         nameTextView = new TextView(context);
         nameTextView.setTextColor(0xff000000);
@@ -53,13 +47,7 @@ public MentionCell(Context context) {
         nameTextView.setSingleLine(true);
         nameTextView.setGravity(Gravity.LEFT);
         nameTextView.setEllipsize(TextUtils.TruncateAt.END);
-        addView(nameTextView);
-        layoutParams = (LayoutParams) nameTextView.getLayoutParams();
-        layoutParams.leftMargin = AndroidUtilities.dp(12);
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.gravity = Gravity.CENTER_VERTICAL;
-        nameTextView.setLayoutParams(layoutParams);
+        addView(nameTextView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER_VERTICAL, 12, 0, 0, 0));
 
         usernameTextView = new TextView(context);
         usernameTextView.setTextColor(0xff999999);
@@ -67,13 +55,7 @@ public MentionCell(Context context) {
         usernameTextView.setSingleLine(true);
         usernameTextView.setGravity(Gravity.LEFT);
         usernameTextView.setEllipsize(TextUtils.TruncateAt.END);
-        addView(usernameTextView);
-        layoutParams = (LayoutParams) usernameTextView.getLayoutParams();
-        layoutParams.leftMargin = AndroidUtilities.dp(12);
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.gravity = Gravity.CENTER_VERTICAL;
-        usernameTextView.setLayoutParams(layoutParams);
+        addView(usernameTextView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER_VERTICAL, 12, 0, 0, 0));
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoEditToolCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoEditToolCell.java
index f723a5371..55d39ec94 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoEditToolCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoEditToolCell.java
@@ -30,12 +30,7 @@ public PhotoEditToolCell(Context context) {
 
         iconImage = new ImageView(context);
         iconImage.setScaleType(ImageView.ScaleType.CENTER);
-        addView(iconImage);
-        LayoutParams layoutParams = (LayoutParams) iconImage.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.bottomMargin = AndroidUtilities.dp(12);
-        iconImage.setLayoutParams(layoutParams);
+        addView(iconImage, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT, 0, 0, 0, 12));
 
         nameTextView = new TextView(context);
         nameTextView.setGravity(Gravity.CENTER);
@@ -45,27 +40,13 @@ public PhotoEditToolCell(Context context) {
         nameTextView.setMaxLines(1);
         nameTextView.setSingleLine(true);
         nameTextView.setEllipsize(TextUtils.TruncateAt.END);
-        addView(nameTextView);
-        layoutParams = (LayoutParams) nameTextView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.gravity = Gravity.LEFT | Gravity.BOTTOM;
-        layoutParams.leftMargin = AndroidUtilities.dp(4);
-        layoutParams.rightMargin = AndroidUtilities.dp(4);
-        nameTextView.setLayoutParams(layoutParams);
+        addView(nameTextView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.BOTTOM, 4, 0, 4, 0));
 
         valueTextView = new TextView(context);
         valueTextView.setTextColor(0xff6cc3ff);
         valueTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 11);
         valueTextView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
-        addView(valueTextView);
-        layoutParams = (LayoutParams) valueTextView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.gravity = Gravity.LEFT | Gravity.TOP;
-        layoutParams.leftMargin = AndroidUtilities.dp(57);
-        layoutParams.topMargin = AndroidUtilities.dp(3);
-        valueTextView.setLayoutParams(layoutParams);
+        addView(valueTextView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.TOP, 57, 3, 0, 0));
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerAlbumsCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerAlbumsCell.java
index d469e9503..caff290ca 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerAlbumsCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerAlbumsCell.java
@@ -47,21 +47,12 @@ public AlbumView(Context context) {
             super(context);
 
             imageView = new BackupImageView(context);
-            addView(imageView);
-            LayoutParams layoutParams = (LayoutParams) imageView.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = LayoutHelper.MATCH_PARENT;
-            imageView.setLayoutParams(layoutParams);
+            addView(imageView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
 
             LinearLayout linearLayout = new LinearLayout(context);
             linearLayout.setOrientation(LinearLayout.HORIZONTAL);
             linearLayout.setBackgroundColor(0x7f000000);
-            addView(linearLayout);
-            layoutParams = (LayoutParams) linearLayout.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = AndroidUtilities.dp(28);
-            layoutParams.gravity = Gravity.BOTTOM;
-            linearLayout.setLayoutParams(layoutParams);
+            addView(linearLayout, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 28, Gravity.LEFT | Gravity.BOTTOM));
 
             nameTextView = new TextView(context);
             nameTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13);
@@ -70,13 +61,7 @@ public AlbumView(Context context) {
             nameTextView.setEllipsize(TextUtils.TruncateAt.END);
             nameTextView.setMaxLines(1);
             nameTextView.setGravity(Gravity.CENTER_VERTICAL);
-            linearLayout.addView(nameTextView);
-            LinearLayout.LayoutParams layoutParams1 = (LinearLayout.LayoutParams) nameTextView.getLayoutParams();
-            layoutParams1.width = 0;
-            layoutParams1.height = LayoutHelper.MATCH_PARENT;
-            layoutParams1.leftMargin = AndroidUtilities.dp(8);
-            layoutParams1.weight = 1;
-            nameTextView.setLayoutParams(layoutParams1);
+            linearLayout.addView(nameTextView, LayoutHelper.createLinear(0, LayoutHelper.MATCH_PARENT, 1.0f, 8, 0, 0, 0));
 
             countTextView = new TextView(context);
             countTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13);
@@ -85,21 +70,11 @@ public AlbumView(Context context) {
             countTextView.setEllipsize(TextUtils.TruncateAt.END);
             countTextView.setMaxLines(1);
             countTextView.setGravity(Gravity.CENTER_VERTICAL);
-            linearLayout.addView(countTextView);
-            layoutParams1 = (LinearLayout.LayoutParams) countTextView.getLayoutParams();
-            layoutParams1.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams1.height = LayoutHelper.MATCH_PARENT;
-            layoutParams1.leftMargin = AndroidUtilities.dp(4);
-            layoutParams1.rightMargin = AndroidUtilities.dp(4);
-            countTextView.setLayoutParams(layoutParams1);
+            linearLayout.addView(countTextView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, 4, 0, 4, 0));
 
             selector = new View(context);
             selector.setBackgroundResource(R.drawable.list_selector);
-            addView(selector);
-            layoutParams = (LayoutParams) selector.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = LayoutHelper.MATCH_PARENT;
-            selector.setLayoutParams(layoutParams);
+            addView(selector, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
         }
 
         @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerPhotoCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerPhotoCell.java
index 40005597d..94f85c207 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerPhotoCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerPhotoCell.java
@@ -29,33 +29,17 @@ public PhotoPickerPhotoCell(Context context) {
         super(context);
 
         photoImage = new BackupImageView(context);
-        addView(photoImage);
-        LayoutParams layoutParams = (LayoutParams) photoImage.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        photoImage.setLayoutParams(layoutParams);
+        addView(photoImage, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
 
         checkFrame = new FrameLayout(context);
-        addView(checkFrame);
-        layoutParams = (LayoutParams) checkFrame.getLayoutParams();
-        layoutParams.width = AndroidUtilities.dp(42);
-        layoutParams.height = AndroidUtilities.dp(42);
-        layoutParams.gravity = Gravity.RIGHT | Gravity.TOP;
-        checkFrame.setLayoutParams(layoutParams);
+        addView(checkFrame, LayoutHelper.createFrame(42, 42, Gravity.RIGHT | Gravity.TOP));
 
         checkBox = new CheckBox(context, R.drawable.checkbig);
         checkBox.setSize(30);
         checkBox.setCheckOffset(AndroidUtilities.dp(1));
         checkBox.setDrawBackground(true);
         checkBox.setColor(0xff3ccaef);
-        addView(checkBox);
-        layoutParams = (LayoutParams) checkBox.getLayoutParams();
-        layoutParams.width = AndroidUtilities.dp(30);
-        layoutParams.height = AndroidUtilities.dp(30);
-        layoutParams.gravity = Gravity.RIGHT | Gravity.TOP;
-        layoutParams.topMargin = AndroidUtilities.dp(6);
-        layoutParams.rightMargin = AndroidUtilities.dp(6);
-        checkBox.setLayoutParams(layoutParams);
+        addView(checkBox, LayoutHelper.createFrame(30, 30, Gravity.RIGHT | Gravity.TOP, 0, 6, 6, 0));
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerSearchCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerSearchCell.java
index bc3ce4f10..81c007e45 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerSearchCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerSearchCell.java
@@ -45,20 +45,11 @@ public SearchButton(Context context) {
 
             selector = new View(context);
             selector.setBackgroundResource(R.drawable.list_selector);
-            addView(selector);
-            FrameLayout.LayoutParams layoutParams1 = (FrameLayout.LayoutParams) selector.getLayoutParams();
-            layoutParams1.width = LayoutHelper.MATCH_PARENT;
-            layoutParams1.height = LayoutHelper.MATCH_PARENT;
-            selector.setLayoutParams(layoutParams1);
+            addView(selector, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
 
             imageView = new ImageView(context);
             imageView.setScaleType(ImageView.ScaleType.CENTER);
-            addView(imageView);
-            FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) imageView.getLayoutParams();
-            layoutParams.height = AndroidUtilities.dp(48);
-            layoutParams.width = AndroidUtilities.dp(48);
-            layoutParams1.gravity = Gravity.LEFT | Gravity.TOP;
-            imageView.setLayoutParams(layoutParams);
+            addView(imageView, LayoutHelper.createFrame(48, 48, Gravity.LEFT | Gravity.TOP));
 
             textView1 = new TextView(context);
             textView1.setGravity(Gravity.CENTER_VERTICAL);
@@ -67,15 +58,7 @@ public SearchButton(Context context) {
             textView1.setTextColor(0xffffffff);
             textView1.setSingleLine(true);
             textView1.setEllipsize(TextUtils.TruncateAt.END);
-            addView(textView1);
-            layoutParams1 = (FrameLayout.LayoutParams) textView1.getLayoutParams();
-            layoutParams1.width = LayoutHelper.MATCH_PARENT;
-            layoutParams1.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams1.gravity = Gravity.TOP | Gravity.LEFT;
-            layoutParams1.rightMargin = AndroidUtilities.dp(4);
-            layoutParams1.leftMargin = AndroidUtilities.dp(51);
-            layoutParams1.topMargin = AndroidUtilities.dp(8);
-            textView1.setLayoutParams(layoutParams1);
+            addView(textView1, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.TOP | Gravity.LEFT, 51, 8, 4, 0));
 
             textView2 = new TextView(context);
             textView2.setGravity(Gravity.CENTER_VERTICAL);
@@ -84,15 +67,7 @@ public SearchButton(Context context) {
             textView2.setTextColor(0xff666666);
             textView2.setSingleLine(true);
             textView2.setEllipsize(TextUtils.TruncateAt.END);
-            addView(textView2);
-            layoutParams1 = (FrameLayout.LayoutParams) textView2.getLayoutParams();
-            layoutParams1.width = LayoutHelper.MATCH_PARENT;
-            layoutParams1.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams1.gravity = Gravity.TOP | Gravity.LEFT;
-            layoutParams1.leftMargin = AndroidUtilities.dp(51);
-            layoutParams1.rightMargin = AndroidUtilities.dp(4);
-            layoutParams1.topMargin = AndroidUtilities.dp(26);
-            textView2.setLayoutParams(layoutParams1);
+            addView(textView2, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.TOP | Gravity.LEFT, 51, 26, 4, 0));
         }
 
         @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ProfileSearchCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ProfileSearchCell.java
index 80bfa4f28..cc7537594 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ProfileSearchCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ProfileSearchCell.java
@@ -12,10 +12,12 @@
 import android.graphics.Canvas;
 import android.graphics.Paint;
 import android.graphics.drawable.Drawable;
+import android.os.Build;
 import android.text.Layout;
 import android.text.StaticLayout;
 import android.text.TextPaint;
 import android.text.TextUtils;
+import android.view.MotionEvent;
 
 import org.telegram.PhoneFormat.PhoneFormat;
 import org.telegram.android.AndroidUtilities;
@@ -70,13 +72,7 @@
 
     public ProfileSearchCell(Context context) {
         super(context);
-        init();
-        avatarImage = new ImageReceiver(this);
-        avatarImage.setRoundRadius(AndroidUtilities.dp(26));
-        avatarDrawable = new AvatarDrawable();
-    }
 
-    private void init() {
         if (namePaint == null) {
             namePaint = new TextPaint(TextPaint.ANTI_ALIAS_FLAG);
             namePaint.setTextSize(AndroidUtilities.dp(17));
@@ -103,6 +99,20 @@ private void init() {
             lockDrawable = getResources().getDrawable(R.drawable.list_secret);
             groupDrawable = getResources().getDrawable(R.drawable.list_group);
         }
+
+        avatarImage = new ImageReceiver(this);
+        avatarImage.setRoundRadius(AndroidUtilities.dp(26));
+        avatarDrawable = new AvatarDrawable();
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        if (Build.VERSION.SDK_INT >= 21 && getBackground() != null) {
+            if (event.getAction() == MotionEvent.ACTION_DOWN || event.getAction() == MotionEvent.ACTION_MOVE) {
+                getBackground().setHotspot(event.getX(), event.getY());
+            }
+        }
+        return super.onTouchEvent(event);
     }
 
     public void setData(TLRPC.User u, TLRPC.Chat c, TLRPC.EncryptedChat ec, CharSequence n, CharSequence s) {
@@ -143,7 +153,7 @@ protected void onLayout(boolean changed, int left, int top, int right, int botto
     }
 
     public void buildLayout() {
-        CharSequence nameString = "";
+        CharSequence nameString;
         TextPaint currentNamePaint;
 
         drawNameBroadcast = false;
@@ -235,7 +245,7 @@ public void buildLayout() {
                 onlineLeft = AndroidUtilities.dp(11);
             }
 
-            CharSequence onlineString = "";
+            CharSequence onlineString;
             TextPaint currentOnlinePaint = offlinePaint;
 
             if (subLabel != null) {
@@ -265,8 +275,8 @@ public void buildLayout() {
 
         avatarImage.setImageCoords(avatarLeft, AndroidUtilities.dp(10), AndroidUtilities.dp(52), AndroidUtilities.dp(52));
 
-        double widthpx = 0;
-        float left = 0;
+        double widthpx;
+        float left;
         if (LocaleController.isRTL) {
             if (nameLayout.getLineCount() > 0) {
                 left = nameLayout.getLineLeft(0);
@@ -370,7 +380,7 @@ public void update(int mask) {
 
 
         lastAvatar = photo;
-        avatarImage.setImage(photo, "50_50", avatarDrawable, false);
+        avatarImage.setImage(photo, "50_50", avatarDrawable, null, false);
 
         if (getMeasuredWidth() != 0 || getMeasuredHeight() != 0) {
             buildLayout();
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SessionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SessionCell.java
index a76d1e389..4555b276b 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SessionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SessionCell.java
@@ -47,15 +47,7 @@ public SessionCell(Context context) {
         LinearLayout linearLayout = new LinearLayout(context);
         linearLayout.setOrientation(LinearLayout.HORIZONTAL);
         linearLayout.setWeightSum(1);
-        addView(linearLayout);
-        LayoutParams layoutParams = (LayoutParams) linearLayout.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = AndroidUtilities.dp(30);
-        layoutParams.leftMargin = AndroidUtilities.dp(17);
-        layoutParams.rightMargin = AndroidUtilities.dp(17);
-        layoutParams.topMargin = AndroidUtilities.dp(11);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        linearLayout.setLayoutParams(layoutParams);
+        addView(linearLayout, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 30, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, 17, 11, 11, 0));
 
         nameTextView = new TextView(context);
         nameTextView.setTextColor(0xff212121);
@@ -72,32 +64,13 @@ public SessionCell(Context context) {
         onlineTextView.setGravity((LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.TOP);
 
         if (LocaleController.isRTL) {
-            linearLayout.addView(onlineTextView);
-            linearLayout.addView(nameTextView);
+            linearLayout.addView(onlineTextView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, Gravity.LEFT | Gravity.TOP, 0, 2, 0, 0));
+            linearLayout.addView(nameTextView, LayoutHelper.createLinear(0, LayoutHelper.MATCH_PARENT, 1.0f, Gravity.RIGHT | Gravity.TOP, 10, 0, 0, 0));
         } else {
-            linearLayout.addView(nameTextView);
-            linearLayout.addView(onlineTextView);
+            linearLayout.addView(nameTextView, LayoutHelper.createLinear(0, LayoutHelper.MATCH_PARENT, 1.0f, Gravity.LEFT | Gravity.TOP, 0, 0, 10, 0));
+            linearLayout.addView(onlineTextView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, Gravity.RIGHT | Gravity.TOP, 0, 2, 0, 0));
         }
 
-        LinearLayout.LayoutParams layoutParams2 = (LinearLayout.LayoutParams) nameTextView.getLayoutParams();
-        layoutParams2.width = 0;
-        layoutParams2.height = LayoutHelper.MATCH_PARENT;
-        layoutParams2.weight = 1;
-        if (LocaleController.isRTL) {
-            layoutParams2.leftMargin = AndroidUtilities.dp(10);
-        } else {
-            layoutParams2.rightMargin = AndroidUtilities.dp(10);
-        }
-        layoutParams2.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        nameTextView.setLayoutParams(layoutParams2);
-
-        layoutParams2 = (LinearLayout.LayoutParams) onlineTextView.getLayoutParams();
-        layoutParams2.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams2.height = LayoutHelper.MATCH_PARENT;
-        layoutParams2.topMargin = AndroidUtilities.dp(2);
-        layoutParams2.gravity = (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.TOP;
-        onlineTextView.setLayoutParams(layoutParams2);
-
         detailTextView = new TextView(context);
         detailTextView.setTextColor(0xff212121);
         detailTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
@@ -106,15 +79,7 @@ public SessionCell(Context context) {
         detailTextView.setSingleLine(true);
         detailTextView.setEllipsize(TextUtils.TruncateAt.END);
         detailTextView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP);
-        addView(detailTextView);
-        layoutParams = (LayoutParams) detailTextView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(17);
-        layoutParams.rightMargin = AndroidUtilities.dp(17);
-        layoutParams.topMargin = AndroidUtilities.dp(36);
-        layoutParams.gravity = (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP;
-        detailTextView.setLayoutParams(layoutParams);
+        addView(detailTextView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, 17, 36, 17, 0));
 
         detailExTextView = new TextView(context);
         detailExTextView.setTextColor(0xff999999);
@@ -124,15 +89,7 @@ public SessionCell(Context context) {
         detailExTextView.setSingleLine(true);
         detailExTextView.setEllipsize(TextUtils.TruncateAt.END);
         detailExTextView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP);
-        addView(detailExTextView);
-        layoutParams = (LayoutParams) detailExTextView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(17);
-        layoutParams.rightMargin = AndroidUtilities.dp(17);
-        layoutParams.topMargin = AndroidUtilities.dp(59);
-        layoutParams.gravity = (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP;
-        detailExTextView.setLayoutParams(layoutParams);
+        addView(detailExTextView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, 17, 59, 17, 0));
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShadowBottomSectionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShadowBottomSectionCell.java
index 39a4dfca2..ed0998b50 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShadowBottomSectionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShadowBottomSectionCell.java
@@ -9,7 +9,6 @@
 package org.telegram.ui.Cells;
 
 import android.content.Context;
-import android.util.AttributeSet;
 import android.view.View;
 
 import org.telegram.android.AndroidUtilities;
@@ -17,28 +16,9 @@
 
 public class ShadowBottomSectionCell extends View {
 
-    private void init() {
-        setBackgroundResource(R.drawable.greydivider_bottom);
-    }
-
     public ShadowBottomSectionCell(Context context) {
         super(context);
-        init();
-    }
-
-    public ShadowBottomSectionCell(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        init();
-    }
-
-    public ShadowBottomSectionCell(Context context, AttributeSet attrs, int defStyleAttr) {
-        super(context, attrs, defStyleAttr);
-        init();
-    }
-
-    public ShadowBottomSectionCell(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
-        super(context, attrs, defStyleAttr, defStyleRes);
-        init();
+        setBackgroundResource(R.drawable.greydivider_bottom);
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShadowSectionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShadowSectionCell.java
index b8c7ce118..ad130f9bd 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShadowSectionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShadowSectionCell.java
@@ -9,7 +9,6 @@
 package org.telegram.ui.Cells;
 
 import android.content.Context;
-import android.util.AttributeSet;
 import android.view.View;
 
 import org.telegram.android.AndroidUtilities;
@@ -17,28 +16,9 @@
 
 public class ShadowSectionCell extends View {
 
-    private void init() {
-        setBackgroundResource(R.drawable.greydivider);
-    }
-
     public ShadowSectionCell(Context context) {
         super(context);
-        init();
-    }
-
-    public ShadowSectionCell(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        init();
-    }
-
-    public ShadowSectionCell(Context context, AttributeSet attrs, int defStyleAttr) {
-        super(context, attrs, defStyleAttr);
-        init();
-    }
-
-    public ShadowSectionCell(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
-        super(context, attrs, defStyleAttr, defStyleRes);
-        init();
+        setBackgroundResource(R.drawable.greydivider);
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedDocumentCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedDocumentCell.java
index 92f83da3d..4c2e46a36 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedDocumentCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedDocumentCell.java
@@ -28,7 +28,6 @@
 import org.telegram.messenger.FileLoader;
 import org.telegram.messenger.R;
 import org.telegram.messenger.TLRPC;
-import org.telegram.messenger.Utilities;
 import org.telegram.ui.Components.BackupImageView;
 import org.telegram.ui.Components.CheckBox;
 import org.telegram.ui.Components.LayoutHelper;
@@ -77,15 +76,7 @@ public SharedDocumentCell(Context context) {
         TAG = MediaController.getInstance().generateObserverTag();
 
         placeholderImabeView = new ImageView(context);
-        addView(placeholderImabeView);
-        LayoutParams layoutParams = (LayoutParams) placeholderImabeView.getLayoutParams();
-        layoutParams.width = AndroidUtilities.dp(40);
-        layoutParams.height = AndroidUtilities.dp(40);
-        layoutParams.leftMargin = LocaleController.isRTL ? 0 : AndroidUtilities.dp(12);
-        layoutParams.rightMargin = LocaleController.isRTL ? AndroidUtilities.dp(12) : 0;
-        layoutParams.topMargin = AndroidUtilities.dp(8);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        placeholderImabeView.setLayoutParams(layoutParams);
+        addView(placeholderImabeView, LayoutHelper.createFrame(40, 40, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 0 : 12, 8, LocaleController.isRTL ? 12 : 0, 0));
 
         extTextView = new TextView(context);
         extTextView.setTextColor(0xffffffff);
@@ -96,17 +87,10 @@ public SharedDocumentCell(Context context) {
         extTextView.setSingleLine(true);
         extTextView.setGravity(Gravity.CENTER);
         extTextView.setEllipsize(TextUtils.TruncateAt.END);
-        addView(extTextView);
-        layoutParams = (LayoutParams) extTextView.getLayoutParams();
-        layoutParams.width = AndroidUtilities.dp(32);
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.topMargin = AndroidUtilities.dp(22);
-        layoutParams.leftMargin = LocaleController.isRTL ? 0 : AndroidUtilities.dp(16);
-        layoutParams.rightMargin = LocaleController.isRTL ? AndroidUtilities.dp(16) : 0;
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        extTextView.setLayoutParams(layoutParams);
+        addView(extTextView, LayoutHelper.createFrame(32, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 0 : 16, 22, LocaleController.isRTL ? 16 : 0, 0));
 
         thumbImageView = new BackupImageView(context);
+        addView(thumbImageView, LayoutHelper.createFrame(40, 40, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 0 : 12, 8, LocaleController.isRTL ? 12 : 0, 0));
         thumbImageView.getImageReceiver().setDelegate(new ImageReceiver.ImageReceiverDelegate() {
             @Override
             public void didSetImage(ImageReceiver imageReceiver, boolean set, boolean thumb) {
@@ -114,15 +98,6 @@ public void didSetImage(ImageReceiver imageReceiver, boolean set, boolean thumb)
                 placeholderImabeView.setVisibility(set ? INVISIBLE : VISIBLE);
             }
         });
-        addView(thumbImageView);
-        layoutParams = (LayoutParams) thumbImageView.getLayoutParams();
-        layoutParams.width = AndroidUtilities.dp(40);
-        layoutParams.height = AndroidUtilities.dp(40);
-        layoutParams.leftMargin = LocaleController.isRTL ? 0 : AndroidUtilities.dp(12);
-        layoutParams.rightMargin = LocaleController.isRTL ? AndroidUtilities.dp(12) : 0;
-        layoutParams.topMargin = AndroidUtilities.dp(8);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        thumbImageView.setLayoutParams(layoutParams);
 
         nameTextView = new TextView(context);
         nameTextView.setTextColor(0xff222222);
@@ -133,27 +108,11 @@ public void didSetImage(ImageReceiver imageReceiver, boolean set, boolean thumb)
         nameTextView.setSingleLine(true);
         nameTextView.setEllipsize(TextUtils.TruncateAt.END);
         nameTextView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL);
-        addView(nameTextView);
-        layoutParams = (LayoutParams) nameTextView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.topMargin = AndroidUtilities.dp(5);
-        layoutParams.leftMargin = LocaleController.isRTL ? AndroidUtilities.dp(8) : AndroidUtilities.dp(72);
-        layoutParams.rightMargin = LocaleController.isRTL ? AndroidUtilities.dp(72) : AndroidUtilities.dp(8);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        nameTextView.setLayoutParams(layoutParams);
+        addView(nameTextView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 8 : 72, 5, LocaleController.isRTL ? 72 : 8, 0));
 
         statusImageView = new ImageView(context);
         statusImageView.setVisibility(INVISIBLE);
-        addView(statusImageView);
-        layoutParams = (LayoutParams) statusImageView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.topMargin = AndroidUtilities.dp(35);
-        layoutParams.leftMargin = LocaleController.isRTL ? AndroidUtilities.dp(8) : AndroidUtilities.dp(72);
-        layoutParams.rightMargin = LocaleController.isRTL ? AndroidUtilities.dp(72) : AndroidUtilities.dp(8);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        statusImageView.setLayoutParams(layoutParams);
+        addView(statusImageView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 8 : 72, 35, LocaleController.isRTL ? 72 : 8, 0));
 
         dateTextView = new TextView(context);
         dateTextView.setTextColor(0xff999999);
@@ -163,38 +122,14 @@ public void didSetImage(ImageReceiver imageReceiver, boolean set, boolean thumb)
         dateTextView.setSingleLine(true);
         dateTextView.setEllipsize(TextUtils.TruncateAt.END);
         dateTextView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL);
-        addView(dateTextView);
-        layoutParams = (LayoutParams) dateTextView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.topMargin = AndroidUtilities.dp(30);
-        layoutParams.leftMargin = LocaleController.isRTL ? AndroidUtilities.dp(8) : AndroidUtilities.dp(72);
-        layoutParams.rightMargin = LocaleController.isRTL ? AndroidUtilities.dp(72) : AndroidUtilities.dp(8);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        dateTextView.setLayoutParams(layoutParams);
+        addView(dateTextView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 8 : 72, 30, LocaleController.isRTL ? 72 : 8, 0));
 
         progressView = new LineProgressView(context);
-        addView(progressView);
-        layoutParams = (LayoutParams) progressView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = AndroidUtilities.dp(2);
-        layoutParams.topMargin = AndroidUtilities.dp(54);
-        layoutParams.leftMargin = LocaleController.isRTL ? 0 : AndroidUtilities.dp(72);
-        layoutParams.rightMargin = LocaleController.isRTL ? AndroidUtilities.dp(72) : 0;
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        progressView.setLayoutParams(layoutParams);
+        addView(progressView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 2, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 0 : 72, 54, LocaleController.isRTL ? 72 : 0, 0));
 
         checkBox = new CheckBox(context, R.drawable.round_check2);
         checkBox.setVisibility(INVISIBLE);
-        addView(checkBox);
-        layoutParams = (LayoutParams) checkBox.getLayoutParams();
-        layoutParams.width = AndroidUtilities.dp(22);
-        layoutParams.height = AndroidUtilities.dp(22);
-        layoutParams.topMargin = AndroidUtilities.dp(30);
-        layoutParams.leftMargin = LocaleController.isRTL ? 0 : AndroidUtilities.dp(34);
-        layoutParams.rightMargin = LocaleController.isRTL ? AndroidUtilities.dp(34) : 0;
-        layoutParams.gravity = (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
-        checkBox.setLayoutParams(layoutParams);
+        addView(checkBox, LayoutHelper.createFrame(22, 22, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 0 : 34, 30, LocaleController.isRTL ? 34 : 0, 0));
     }
 
     private int getThumbForNameOrMime(String name, String mime) {
@@ -270,7 +205,7 @@ public void setDocument(MessageObject document, boolean divider) {
         loading = false;
 
         if (document != null && document.messageOwner.media != null) {
-            int idx = -1;
+            int idx;
             String name = FileLoader.getDocumentFileName(document.messageOwner.media.document);
             placeholderImabeView.setVisibility(VISIBLE);
             extTextView.setVisibility(VISIBLE);
@@ -285,7 +220,7 @@ public void setDocument(MessageObject document, boolean divider) {
                 thumbImageView.setImage(document.messageOwner.media.document.thumb.location, "40_40", (Drawable) null);
             }
             long date = (long) document.messageOwner.date * 1000;
-            dateTextView.setText(String.format("%s, %s", Utilities.formatFileSize(document.messageOwner.media.document.size), LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, LocaleController.formatterYear.format(new Date(date)), LocaleController.formatterDay.format(new Date(date)))));
+            dateTextView.setText(String.format("%s, %s", AndroidUtilities.formatFileSize(document.messageOwner.media.document.size), LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, LocaleController.formatterYear.format(new Date(date)), LocaleController.formatterDay.format(new Date(date)))));
         } else {
             nameTextView.setText("");
             extTextView.setText("");
@@ -304,7 +239,7 @@ public void setDocument(MessageObject document, boolean divider) {
     public void updateFileExistIcon() {
         if (message != null && message.messageOwner.media != null) {
             String fileName = null;
-            File cacheFile = null;
+            File cacheFile;
             if (message.messageOwner.attachPath == null || message.messageOwner.attachPath.length() == 0 || !(new File(message.messageOwner.attachPath).exists())) {
                 cacheFile = FileLoader.getPathToMessage(message.messageOwner);
                 if (!cacheFile.exists()) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedMediaSectionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedMediaSectionCell.java
index 7c39b0bf8..1646b509b 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedMediaSectionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedMediaSectionCell.java
@@ -30,14 +30,7 @@ public SharedMediaSectionCell(Context context) {
         textView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
         textView.setTextColor(0xff222222);
         textView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL);
-        addView(textView);
-        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams)textView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(13);
-        layoutParams.rightMargin = AndroidUtilities.dp(13);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        textView.setLayoutParams(layoutParams);
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, 13, 0, 13, 0));
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedPhotoVideoCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedPhotoVideoCell.java
index 954632263..879043844 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedPhotoVideoCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedPhotoVideoCell.java
@@ -69,11 +69,7 @@ public PhotoVideoView(Context context) {
 
             ImageView imageView1 = new ImageView(context);
             imageView1.setImageResource(R.drawable.ic_video);
-            videoInfoContainer.addView(imageView1);
-            LinearLayout.LayoutParams layoutParams1 = (LinearLayout.LayoutParams) imageView1.getLayoutParams();
-            layoutParams1.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams1.height = LayoutHelper.WRAP_CONTENT;
-            imageView1.setLayoutParams(layoutParams1);
+            videoInfoContainer.addView(imageView1, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT));
 
             videoTextView = new TextView(context);
             videoTextView.setTextColor(0xffffffff);
@@ -186,14 +182,14 @@ public void setItem(int a, int index, MessageObject messageObject) {
                 photoVideoView.videoTextView.setText(String.format("%d:%02d", minutes, seconds));
                 if (messageObject.messageOwner.media.video.thumb != null) {
                     TLRPC.FileLocation location = messageObject.messageOwner.media.video.thumb.location;
-                    photoVideoView.imageView.setImage(null, null, null, ApplicationLoader.applicationContext.getResources().getDrawable(R.drawable.photo_placeholder_in), null, location, "b", 0);
+                    photoVideoView.imageView.setImage(null, null, null, ApplicationLoader.applicationContext.getResources().getDrawable(R.drawable.photo_placeholder_in), null, location, "b", null, 0);
                 } else {
                     photoVideoView.imageView.setImageResource(R.drawable.photo_placeholder_in);
                 }
             } else if (messageObject.messageOwner.media instanceof TLRPC.TL_messageMediaPhoto && messageObject.messageOwner.media.photo != null && !messageObject.photoThumbs.isEmpty()) {
                 photoVideoView.videoInfoContainer.setVisibility(INVISIBLE);
                 TLRPC.PhotoSize photoSize = FileLoader.getClosestPhotoSizeWithSize(messageObject.photoThumbs, 80);
-                photoVideoView.imageView.setImage(null, null, null, ApplicationLoader.applicationContext.getResources().getDrawable(R.drawable.photo_placeholder_in), null, photoSize.location, "b", 0);
+                photoVideoView.imageView.setImage(null, null, null, ApplicationLoader.applicationContext.getResources().getDrawable(R.drawable.photo_placeholder_in), null, photoSize.location, "b", null, 0);
             } else {
                 photoVideoView.videoInfoContainer.setVisibility(INVISIBLE);
                 photoVideoView.imageView.setImageResource(R.drawable.photo_placeholder_in);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerCell.java
index 34e04c69b..04e79938f 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerCell.java
@@ -9,7 +9,6 @@
 package org.telegram.ui.Cells;
 
 import android.content.Context;
-import android.graphics.drawable.Drawable;
 import android.view.Gravity;
 
 import org.telegram.android.AndroidUtilities;
@@ -17,6 +16,7 @@
 import org.telegram.messenger.TLRPC;
 import org.telegram.ui.Components.BackupImageView;
 import org.telegram.ui.Components.FrameLayoutFixed;
+import org.telegram.ui.Components.LayoutHelper;
 
 public class StickerCell extends FrameLayoutFixed {
 
@@ -27,13 +27,7 @@ public StickerCell(Context context) {
 
         imageView = new BackupImageView(context);
         imageView.setAspectFit(true);
-        addView(imageView);
-        LayoutParams layoutParams = (LayoutParams) imageView.getLayoutParams();
-        layoutParams.width = AndroidUtilities.dp(66);
-        layoutParams.height = AndroidUtilities.dp(66);
-        layoutParams.gravity = Gravity.CENTER_HORIZONTAL;
-        layoutParams.topMargin = AndroidUtilities.dp(5);
-        imageView.setLayoutParams(layoutParams);
+        addView(imageView, LayoutHelper.createFrame(66, 66, Gravity.CENTER_HORIZONTAL, 0, 5, 0, 0));
     }
 
     @Override
@@ -52,8 +46,7 @@ public void setPressed(boolean pressed) {
 
     public void setSticker(TLRPC.Document document, int side) {
         if (document != null) {
-            document.thumb.location.ext = "webp";
-            imageView.setImage(document.thumb.location, null, (Drawable) null);
+            imageView.setImage(document.thumb.location, null, "webp", null);
         }
         if (side == -1) {
             setBackgroundResource(R.drawable.stickers_back_left);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerEmojiCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerEmojiCell.java
index 72b8db653..ce803d315 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerEmojiCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerEmojiCell.java
@@ -9,10 +9,14 @@
 package org.telegram.ui.Cells;
 
 import android.content.Context;
-import android.graphics.drawable.Drawable;
+import android.util.TypedValue;
 import android.view.Gravity;
 import android.widget.FrameLayout;
+import android.widget.TextView;
 
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.Emoji;
+import org.telegram.android.query.StickersQuery;
 import org.telegram.messenger.TLRPC;
 import org.telegram.ui.Components.BackupImageView;
 import org.telegram.ui.Components.LayoutHelper;
@@ -21,6 +25,7 @@
 
     private BackupImageView imageView;
     private TLRPC.Document sticker;
+    private TextView emojiTextView;
 
     public StickerEmojiCell(Context context) {
         super(context);
@@ -28,6 +33,10 @@ public StickerEmojiCell(Context context) {
         imageView = new BackupImageView(context);
         imageView.setAspectFit(true);
         addView(imageView, LayoutHelper.createFrame(66, 66, Gravity.CENTER));
+
+        emojiTextView = new TextView(context);
+        emojiTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
+        addView(emojiTextView, LayoutHelper.createFrame(28, 28, Gravity.BOTTOM | Gravity.RIGHT));
     }
 
     @Override
@@ -43,11 +52,30 @@ public void setPressed(boolean pressed) {
         return sticker;
     }
 
-    public void setSticker(TLRPC.Document document) {
+    public void setSticker(TLRPC.Document document, boolean showEmoji) {
         if (document != null) {
             sticker = document;
-            document.thumb.location.ext = "webp";
-            imageView.setImage(document.thumb.location, null, (Drawable) null);
+            imageView.setImage(document.thumb.location, null, "webp", null);
+
+
+            if (showEmoji) {
+                boolean set = false;
+                for (TLRPC.DocumentAttribute attribute : document.attributes) {
+                    if (attribute instanceof TLRPC.TL_documentAttributeSticker) {
+                        if (attribute.alt != null && attribute.alt.length() > 0) {
+                            emojiTextView.setText(Emoji.replaceEmoji(attribute.alt, emojiTextView.getPaint().getFontMetricsInt(), AndroidUtilities.dp(16)));
+                            set = true;
+                        }
+                        break;
+                    }
+                }
+                if (!set) {
+                    emojiTextView.setText(Emoji.replaceEmoji(StickersQuery.getEmojiForSticker(sticker.id), emojiTextView.getPaint().getFontMetricsInt(), AndroidUtilities.dp(16)));
+                }
+                emojiTextView.setVisibility(VISIBLE);
+            } else {
+                emojiTextView.setVisibility(INVISIBLE);
+            }
         }
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerSetCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerSetCell.java
new file mode 100644
index 000000000..03699a64a
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerSetCell.java
@@ -0,0 +1,144 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2014.
+ */
+
+package org.telegram.ui.Cells;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.text.TextUtils;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.AnimationCompat.ViewProxy;
+import org.telegram.android.LocaleController;
+import org.telegram.android.query.StickersQuery;
+import org.telegram.messenger.R;
+import org.telegram.messenger.TLRPC;
+import org.telegram.ui.Components.BackupImageView;
+import org.telegram.ui.Components.LayoutHelper;
+
+import java.util.ArrayList;
+
+public class StickerSetCell extends FrameLayout {
+
+    private TextView textView;
+    private TextView valueTextView;
+    private BackupImageView imageView;
+    private boolean needDivider;
+    private ImageView optionsButton;
+    private TLRPC.TL_stickerSet stickersSet;
+
+    private static Paint paint;
+
+    public StickerSetCell(Context context) {
+        super(context);
+
+        if (paint == null) {
+            paint = new Paint();
+            paint.setColor(0xffd9d9d9);
+        }
+
+        textView = new TextView(context);
+        textView.setTextColor(0xff212121);
+        textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
+        textView.setLines(1);
+        textView.setMaxLines(1);
+        textView.setSingleLine(true);
+        textView.setEllipsize(TextUtils.TruncateAt.END);
+        textView.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT, LocaleController.isRTL ? 40 : 71, 10, LocaleController.isRTL ? 40 : 71, 0));
+
+        valueTextView = new TextView(context);
+        valueTextView.setTextColor(0xff8a8a8a);
+        valueTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13);
+        valueTextView.setLines(1);
+        valueTextView.setMaxLines(1);
+        valueTextView.setSingleLine(true);
+        valueTextView.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
+        addView(valueTextView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT, LocaleController.isRTL ? 40 : 71, 35, LocaleController.isRTL ? 40 : 71, 0));
+
+        imageView = new BackupImageView(context);
+        imageView.setAspectFit(true);
+        addView(imageView, LayoutHelper.createFrame(48, 48, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 0 : 12, 8, LocaleController.isRTL ? 12 : 0, 0));
+
+        optionsButton = new ImageView(context);
+        optionsButton.setBackgroundResource(R.drawable.bar_selector_grey);
+        optionsButton.setImageResource(R.drawable.doc_actions_b);
+        optionsButton.setScaleType(ImageView.ScaleType.CENTER);
+        addView(optionsButton, LayoutHelper.createFrame(40, 40, (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.TOP));
+
+        /*ActionBarMenuItem menuItem = new ActionBarMenuItem(context, null, R.drawable.bar_selector_grey);
+        menuItem.setIcon(R.drawable.doc_actions_b);
+        addView(menuItem, LayoutHelper.createFrame(40, 40, (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.TOP, LocaleController.isRTL ? 40 : 0, 0, LocaleController.isRTL ? 0 : 40, 0));
+        menuItem.addSubItem(1, "test", 0);
+        menuItem.addSubItem(2, "test", 0);
+        menuItem.addSubItem(3, "test", 0);
+        menuItem.addSubItem(4, "test", 0);
+        menuItem.addSubItem(5, "test", 0);
+        menuItem.addSubItem(6, "test", 0);
+        menuItem.addSubItem(7, "test", 0);*/
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(64) + (needDivider ? 1 : 0), MeasureSpec.EXACTLY));
+    }
+
+    public void setStickersSet(TLRPC.TL_stickerSet set, boolean divider) {
+        needDivider = divider;
+        stickersSet = set;
+
+        if (stickersSet.id == -1) {
+            textView.setText(LocaleController.getString("GeniusStickerPackName", R.string.GeniusStickerPackName));
+            if (StickersQuery.getHideMainStickersPack()) {
+                ViewProxy.setAlpha(textView, 0.5f);
+                ViewProxy.setAlpha(valueTextView, 0.5f);
+                ViewProxy.setAlpha(imageView, 0.5f);
+            } else {
+                ViewProxy.setAlpha(textView, 1.0f);
+                ViewProxy.setAlpha(valueTextView, 1.0f);
+                ViewProxy.setAlpha(imageView, 1.0f);
+            }
+        } else {
+            textView.setText(stickersSet.title);
+            ViewProxy.setAlpha(textView, 1.0f);
+            ViewProxy.setAlpha(valueTextView, 1.0f);
+            ViewProxy.setAlpha(imageView, 1.0f);
+        }
+        ArrayList<TLRPC.Document> documents = StickersQuery.getStickersForSet(stickersSet.id);
+        if (documents != null) {
+            valueTextView.setText(LocaleController.formatPluralString("Stickers", documents.size()));
+            TLRPC.Document document = documents.get(0);
+            if (document.thumb != null && document.thumb.location != null) {
+                imageView.setImage(document.thumb.location, null, "webp", null);
+            }
+        } else {
+            valueTextView.setText(LocaleController.formatPluralString("Stickers", 0));
+        }
+    }
+
+    public void setOnOptionsClick(OnClickListener listener) {
+        optionsButton.setOnClickListener(listener);
+    }
+
+    public TLRPC.TL_stickerSet getStickersSet() {
+        return stickersSet;
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        if (needDivider) {
+            canvas.drawLine(0, getHeight() - 1, getWidth() - getPaddingRight(), getHeight() - 1, paint);
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextCell.java
index e6dfa544b..d43cb7580 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextCell.java
@@ -39,14 +39,7 @@ public TextCell(Context context) {
         textView.setSingleLine(true);
         textView.setEllipsize(TextUtils.TruncateAt.END);
         textView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL);
-        addView(textView);
-        LayoutParams layoutParams = (LayoutParams) textView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? 16 : 71);
-        layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? 71 : 16);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        textView.setLayoutParams(layoutParams);
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 16 : 71, 0, LocaleController.isRTL ? 71 : 16, 0));
 
         valueTextView = new TextView(context);
         valueTextView.setTextColor(0xff2f8cc9);
@@ -55,36 +48,15 @@ public TextCell(Context context) {
         valueTextView.setMaxLines(1);
         valueTextView.setSingleLine(true);
         valueTextView.setGravity((LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.CENTER_VERTICAL);
-        addView(valueTextView);
-        layoutParams = (LayoutParams) valueTextView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? 24 : 0);
-        layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? 0 : 24);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT;
-        valueTextView.setLayoutParams(layoutParams);
+        addView(valueTextView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.TOP, LocaleController.isRTL ? 24 : 0, 0, LocaleController.isRTL ? 0 : 24, 0));
 
         imageView = new ImageView(context);
         imageView.setScaleType(ImageView.ScaleType.CENTER);
-        addView(imageView);
-        layoutParams = (LayoutParams) imageView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? 0 : 16);
-        layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? 16 : 0);
-        layoutParams.gravity = (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL;
-        imageView.setLayoutParams(layoutParams);
+        addView(imageView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL, LocaleController.isRTL ? 0 : 16, 0, LocaleController.isRTL ? 16 : 0, 0));
 
         valueImageView = new ImageView(context);
         valueImageView.setScaleType(ImageView.ScaleType.CENTER);
-        addView(valueImageView);
-        layoutParams = (LayoutParams) valueImageView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? 24 : 0);
-        layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? 0 : 24);
-        layoutParams.gravity = (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.CENTER_VERTICAL;
-        valueImageView.setLayoutParams(layoutParams);
+        addView(valueImageView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.CENTER_VERTICAL, LocaleController.isRTL ? 24 : 0, 0, LocaleController.isRTL ? 0 : 24, 0));
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextCheckCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextCheckCell.java
index 6734071ec..a36f01ff0 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextCheckCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextCheckCell.java
@@ -45,28 +45,14 @@ public TextCheckCell(Context context) {
         textView.setMaxLines(1);
         textView.setSingleLine(true);
         textView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL);
-        addView(textView);
-        LayoutParams layoutParams = (LayoutParams) textView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(17);
-        layoutParams.rightMargin = AndroidUtilities.dp(17);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        textView.setLayoutParams(layoutParams);
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, 17, 0, 17, 0));
 
         checkBox = new Switch(context);
         checkBox.setDuplicateParentStateEnabled(false);
         checkBox.setFocusable(false);
         checkBox.setFocusableInTouchMode(false);
         checkBox.setClickable(false);
-        addView(checkBox);
-        layoutParams = (LayoutParams) checkBox.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(14);
-        layoutParams.rightMargin = AndroidUtilities.dp(14);
-        layoutParams.gravity = (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.CENTER_VERTICAL;
-        checkBox.setLayoutParams(layoutParams);
+        addView(checkBox, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.CENTER_VERTICAL, 14, 0, 14, 0));
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextColorCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextColorCell.java
index 348e5b7b5..2fb0de5c6 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextColorCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextColorCell.java
@@ -25,12 +25,14 @@
 import org.telegram.ui.Components.LayoutHelper;
 
 public class TextColorCell extends FrameLayout {
+
     private TextView textView;
-    private Drawable colorDrawable;
-    private static Paint paint;
     private boolean needDivider;
     private int currentColor;
 
+    private static Drawable colorDrawable;
+    private static Paint paint;
+
     public TextColorCell(Context context) {
         super(context);
 
@@ -38,6 +40,8 @@ public TextColorCell(Context context) {
             paint = new Paint();
             paint.setColor(0xffd9d9d9);
             paint.setStrokeWidth(1);
+
+            colorDrawable = getResources().getDrawable(R.drawable.switch_to_on2);
         }
 
         textView = new TextView(context);
@@ -47,16 +51,7 @@ public TextColorCell(Context context) {
         textView.setMaxLines(1);
         textView.setSingleLine(true);
         textView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL);
-        addView(textView);
-        LayoutParams layoutParams = (LayoutParams) textView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(17);
-        layoutParams.rightMargin = AndroidUtilities.dp(17);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        textView.setLayoutParams(layoutParams);
-
-        colorDrawable = getResources().getDrawable(R.drawable.switch_to_on2);
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, 17, 0, 17, 0));
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextDetailCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextDetailCell.java
index e44654ef0..7889b7803 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextDetailCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextDetailCell.java
@@ -36,15 +36,7 @@ public TextDetailCell(Context context) {
         textView.setMaxLines(1);
         textView.setSingleLine(true);
         textView.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
-        addView(textView);
-        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) textView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.topMargin = AndroidUtilities.dp(10);
-        layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? 16 : 71);
-        layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? 71 : 16);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        textView.setLayoutParams(layoutParams);
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT, LocaleController.isRTL ? 16 : 71, 10, LocaleController.isRTL ? 16 : 71, 0));
 
         valueTextView = new TextView(context);
         valueTextView.setTextColor(0xff8a8a8a);
@@ -53,26 +45,11 @@ public TextDetailCell(Context context) {
         valueTextView.setMaxLines(1);
         valueTextView.setSingleLine(true);
         valueTextView.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
-        addView(valueTextView);
-        layoutParams = (FrameLayout.LayoutParams) valueTextView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.topMargin = AndroidUtilities.dp(35);
-        layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? 16 : 71);
-        layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? 71 : 16);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        valueTextView.setLayoutParams(layoutParams);
+        addView(valueTextView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT, LocaleController.isRTL ? 16 : 71, 35, LocaleController.isRTL ? 16 : 71, 0));
 
         imageView = new ImageView(context);
         imageView.setScaleType(ImageView.ScaleType.CENTER);
-        addView(imageView);
-        layoutParams = (LayoutParams) imageView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? 0 : 16);
-        layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? 16 : 0);
-        layoutParams.gravity = (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL;
-        imageView.setLayoutParams(layoutParams);
+        addView(imageView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL, LocaleController.isRTL ? 0 : 16, 0, LocaleController.isRTL ? 16 : 0, 0));
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextDetailSettingsCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextDetailSettingsCell.java
index 1ac52592a..1d9a9a062 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextDetailSettingsCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextDetailSettingsCell.java
@@ -44,15 +44,7 @@ public TextDetailSettingsCell(Context context) {
         textView.setMaxLines(1);
         textView.setSingleLine(true);
         textView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL);
-        addView(textView);
-        LayoutParams layoutParams = (LayoutParams) textView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.topMargin = AndroidUtilities.dp(10);
-        layoutParams.leftMargin = AndroidUtilities.dp(17);
-        layoutParams.rightMargin = AndroidUtilities.dp(17);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        textView.setLayoutParams(layoutParams);
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, 17, 10, 17, 0));
 
         valueTextView = new TextView(context);
         valueTextView.setTextColor(0xff8a8a8a);
@@ -62,15 +54,7 @@ public TextDetailSettingsCell(Context context) {
         valueTextView.setMaxLines(1);
         valueTextView.setSingleLine(true);
         valueTextView.setPadding(0, 0, 0, 0);
-        addView(valueTextView);
-        layoutParams = (LayoutParams) valueTextView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.topMargin = AndroidUtilities.dp(35);
-        layoutParams.leftMargin = AndroidUtilities.dp(17);
-        layoutParams.rightMargin = AndroidUtilities.dp(17);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        valueTextView.setLayoutParams(layoutParams);
+        addView(valueTextView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, 17, 35, 17, 0));
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextInfoCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextInfoCell.java
index 236cff202..1e0f3ceec 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextInfoCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextInfoCell.java
@@ -29,14 +29,7 @@ public TextInfoCell(Context context) {
         textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13);
         textView.setGravity(Gravity.CENTER);
         textView.setPadding(0, AndroidUtilities.dp(19), 0, AndroidUtilities.dp(19));
-        addView(textView);
-        LayoutParams layoutParams = (LayoutParams) textView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(17);
-        layoutParams.rightMargin = AndroidUtilities.dp(17);
-        layoutParams.gravity = Gravity.CENTER;
-        textView.setLayoutParams(layoutParams);
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER, 17, 0, 17, 0));
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextInfoPrivacyCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextInfoPrivacyCell.java
index 8ba0f7232..579917310 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextInfoPrivacyCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextInfoPrivacyCell.java
@@ -9,6 +9,7 @@
 package org.telegram.ui.Cells;
 
 import android.content.Context;
+import android.text.method.LinkMovementMethod;
 import android.util.TypedValue;
 import android.view.Gravity;
 import android.widget.FrameLayout;
@@ -27,17 +28,12 @@ public TextInfoPrivacyCell(Context context) {
 
         textView = new TextView(context);
         textView.setTextColor(0xff808080);
+        textView.setLinkTextColor(0xff316f9f);
         textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
         textView.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
         textView.setPadding(0, AndroidUtilities.dp(10), 0, AndroidUtilities.dp(17));
-        addView(textView);
-        LayoutParams layoutParams = (LayoutParams) textView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(17);
-        layoutParams.rightMargin = AndroidUtilities.dp(17);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        textView.setLayoutParams(layoutParams);
+        textView.setMovementMethod(LinkMovementMethod.getInstance());
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, 17, 0, 17, 0));
     }
 
     @Override
@@ -45,7 +41,7 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
         super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));
     }
 
-    public void setText(String text) {
+    public void setText(CharSequence text) {
         textView.setText(text);
     }
 
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextSettingsCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextSettingsCell.java
index b9b295e55..fdda610f4 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextSettingsCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextSettingsCell.java
@@ -47,14 +47,7 @@ public TextSettingsCell(Context context) {
         textView.setSingleLine(true);
         textView.setEllipsize(TextUtils.TruncateAt.END);
         textView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL);
-        addView(textView);
-        LayoutParams layoutParams = (LayoutParams) textView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(17);
-        layoutParams.rightMargin = AndroidUtilities.dp(17);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-        textView.setLayoutParams(layoutParams);
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, 17, 0, 17, 0));
 
         valueTextView = new TextView(context);
         valueTextView.setTextColor(0xff2f8cc9);
@@ -64,26 +57,12 @@ public TextSettingsCell(Context context) {
         valueTextView.setSingleLine(true);
         valueTextView.setEllipsize(TextUtils.TruncateAt.END);
         valueTextView.setGravity((LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.CENTER_VERTICAL);
-        addView(valueTextView);
-        layoutParams = (LayoutParams) valueTextView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(17);
-        layoutParams.rightMargin = AndroidUtilities.dp(17);
-        layoutParams.gravity = LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT;
-        valueTextView.setLayoutParams(layoutParams);
+        addView(valueTextView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.TOP, 17, 0, 17, 0));
 
         valueImageView = new ImageView(context);
         valueImageView.setScaleType(ImageView.ScaleType.CENTER);
         valueImageView.setVisibility(INVISIBLE);
-        addView(valueImageView);
-        layoutParams = (LayoutParams) valueImageView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? 17 : 0);
-        layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? 0 : 17);
-        layoutParams.gravity = (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.CENTER_VERTICAL;
-        valueImageView.setLayoutParams(layoutParams);
+        addView(valueImageView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.CENTER_VERTICAL, 17, 0, 17, 0));
     }
 
     @Override
@@ -127,6 +106,7 @@ public void setTextAndValue(String text, String value, boolean divider) {
         }
         needDivider = divider;
         setWillNotDraw(!divider);
+        requestLayout();
     }
 
     public void setTextAndIcon(String text, int resId, boolean divider) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/WallpaperCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/WallpaperCell.java
new file mode 100644
index 000000000..5dce6aaf4
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/WallpaperCell.java
@@ -0,0 +1,75 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Cells;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.view.Gravity;
+import android.view.View;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.messenger.FileLoader;
+import org.telegram.messenger.R;
+import org.telegram.messenger.TLRPC;
+import org.telegram.ui.Components.BackupImageView;
+import org.telegram.ui.Components.LayoutHelper;
+
+public class WallpaperCell extends FrameLayout {
+
+    private BackupImageView imageView;
+    private View selectionView;
+    private ImageView imageView2;
+
+    public WallpaperCell(Context context) {
+        super(context);
+
+        imageView = new BackupImageView(context);
+        addView(imageView, LayoutHelper.createFrame(100, 100, Gravity.LEFT | Gravity.BOTTOM));
+
+        imageView2 = new ImageView(context);
+        imageView2.setImageResource(R.drawable.ic_gallery_background);
+        imageView2.setScaleType(ImageView.ScaleType.CENTER);
+        addView(imageView2, LayoutHelper.createFrame(100, 100, Gravity.LEFT | Gravity.BOTTOM));
+
+        selectionView = new View(context);
+        selectionView.setBackgroundResource(R.drawable.wall_selection);
+        addView(selectionView, LayoutHelper.createFrame(100, 102));
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(100), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(102), MeasureSpec.EXACTLY));
+    }
+
+    public void setWallpaper(TLRPC.WallPaper wallpaper, int selectedBackground) {
+        if (wallpaper == null) {
+            imageView.setVisibility(INVISIBLE);
+            imageView2.setVisibility(VISIBLE);
+            selectionView.setVisibility(selectedBackground == -1 ? View.VISIBLE : INVISIBLE);
+            imageView2.setBackgroundColor(selectedBackground == -1 || selectedBackground == 1000001 ? 0x5a475866 : 0x5a000000);
+        } else {
+            imageView.setVisibility(VISIBLE);
+            imageView2.setVisibility(INVISIBLE);
+            selectionView.setVisibility(selectedBackground == wallpaper.id ? View.VISIBLE : INVISIBLE);
+
+            if (wallpaper instanceof TLRPC.TL_wallPaperSolid) {
+                imageView.setImageBitmap(null);
+                imageView.setBackgroundColor(0xff000000 | wallpaper.bg_color);
+            } else {
+                TLRPC.PhotoSize size = FileLoader.getClosestPhotoSizeWithSize(wallpaper.sizes, AndroidUtilities.dp(100));
+                if (size != null && size.location != null) {
+                    imageView.setImage(size.location, "100_100", (Drawable) null);
+                }
+                imageView.setBackgroundColor(0x5a475866);
+            }
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChangeChatNameActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChangeChatNameActivity.java
index 66d3b748e..8eb72c7e1 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChangeChatNameActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChangeChatNameActivity.java
@@ -80,7 +80,8 @@ public void onItemClick(int id) {
 
         TLRPC.Chat currentChat = MessagesController.getInstance().getChat(chat_id);
 
-        fragmentView = new LinearLayout(context);
+        LinearLayout linearLayout = new LinearLayout(context);
+        fragmentView = linearLayout;
         fragmentView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
         ((LinearLayout) fragmentView).setOrientation(LinearLayout.VERTICAL);
         fragmentView.setOnTouchListener(new View.OnTouchListener() {
@@ -113,14 +114,7 @@ public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
             }
         });
 
-        ((LinearLayout) fragmentView).addView(firstNameField);
-        LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) firstNameField.getLayoutParams();
-        layoutParams.topMargin = AndroidUtilities.dp(24);
-        layoutParams.height = AndroidUtilities.dp(36);
-        layoutParams.leftMargin = AndroidUtilities.dp(24);
-        layoutParams.rightMargin = AndroidUtilities.dp(24);
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        firstNameField.setLayoutParams(layoutParams);
+        linearLayout.addView(firstNameField, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 36, 24, 24, 24, 0));
 
         if (chat_id > 0) {
             firstNameField.setHint(LocaleController.getString("GroupName", R.string.GroupName));
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChangeNameActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChangeNameActivity.java
index 490aa76dc..5c0088490 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChangeNameActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChangeNameActivity.java
@@ -76,7 +76,8 @@ public void onItemClick(int id) {
             user = UserConfig.getCurrentUser();
         }
 
-        fragmentView = new LinearLayout(context);
+        LinearLayout linearLayout = new LinearLayout(context);
+        fragmentView = linearLayout;
         fragmentView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
         ((LinearLayout) fragmentView).setOrientation(LinearLayout.VERTICAL);
         fragmentView.setOnTouchListener(new View.OnTouchListener() {
@@ -98,14 +99,7 @@ public boolean onTouch(View v, MotionEvent event) {
         firstNameField.setImeOptions(EditorInfo.IME_ACTION_NEXT);
         firstNameField.setHint(LocaleController.getString("FirstName", R.string.FirstName));
         AndroidUtilities.clearCursorDrawable(firstNameField);
-        ((LinearLayout) fragmentView).addView(firstNameField);
-        LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) firstNameField.getLayoutParams();
-        layoutParams.topMargin = AndroidUtilities.dp(24);
-        layoutParams.height = AndroidUtilities.dp(36);
-        layoutParams.leftMargin = AndroidUtilities.dp(24);
-        layoutParams.rightMargin = AndroidUtilities.dp(24);
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        firstNameField.setLayoutParams(layoutParams);
+        linearLayout.addView(firstNameField, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 36, 24, 24, 24, 0));
         firstNameField.setOnEditorActionListener(new TextView.OnEditorActionListener() {
             @Override
             public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
@@ -130,14 +124,7 @@ public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
         lastNameField.setImeOptions(EditorInfo.IME_ACTION_DONE);
         lastNameField.setHint(LocaleController.getString("LastName", R.string.LastName));
         AndroidUtilities.clearCursorDrawable(lastNameField);
-        ((LinearLayout) fragmentView).addView(lastNameField);
-        layoutParams = (LinearLayout.LayoutParams) lastNameField.getLayoutParams();
-        layoutParams.topMargin = AndroidUtilities.dp(16);
-        layoutParams.height = AndroidUtilities.dp(36);
-        layoutParams.leftMargin = AndroidUtilities.dp(24);
-        layoutParams.rightMargin = AndroidUtilities.dp(24);
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        lastNameField.setLayoutParams(layoutParams);
+        linearLayout.addView(lastNameField, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 36, 24, 16, 24, 0));
         lastNameField.setOnEditorActionListener(new TextView.OnEditorActionListener() {
             @Override
             public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChangePhoneActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChangePhoneActivity.java
index 0841e4a7c..1887a03b0 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChangePhoneActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChangePhoneActivity.java
@@ -8,6 +8,7 @@
 
 package org.telegram.ui;
 
+import android.annotation.SuppressLint;
 import android.app.AlertDialog;
 import android.app.ProgressDialog;
 import android.content.Context;
@@ -132,27 +133,11 @@ public void onItemClick(int id) {
 
         views[0] = new PhoneView(context);
         views[0].setVisibility(View.VISIBLE);
-        frameLayout.addView(views[0]);
-        FrameLayout.LayoutParams layoutParams1 = (FrameLayout.LayoutParams) views[0].getLayoutParams();
-        layoutParams1.width = LayoutHelper.MATCH_PARENT;
-        layoutParams1.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams1.leftMargin = AndroidUtilities.dp(16);
-        layoutParams1.rightMargin = AndroidUtilities.dp(16);
-        layoutParams1.topMargin = AndroidUtilities.dp(30);
-        layoutParams1.gravity = Gravity.TOP | Gravity.LEFT;
-        views[0].setLayoutParams(layoutParams1);
+        frameLayout.addView(views[0], LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.TOP | Gravity.LEFT, 16, 30, 16, 0));
 
         views[1] = new LoginActivitySmsView(context);
         views[1].setVisibility(View.GONE);
-        frameLayout.addView(views[1]);
-        layoutParams1 = (FrameLayout.LayoutParams) views[1].getLayoutParams();
-        layoutParams1.width = LayoutHelper.MATCH_PARENT;
-        layoutParams1.height = LayoutHelper.MATCH_PARENT;
-        layoutParams1.leftMargin = AndroidUtilities.dp(16);
-        layoutParams1.rightMargin = AndroidUtilities.dp(16);
-        layoutParams1.topMargin = AndroidUtilities.dp(30);
-        layoutParams1.gravity = Gravity.TOP | Gravity.LEFT;
-        views[1].setLayoutParams(layoutParams1);
+        frameLayout.addView(views[1], LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT, 16, 30, 16, 0));
 
         try {
             if (views[0] == null || views[1] == null) {
@@ -209,7 +194,7 @@ public void needShowAlert(final String text) {
         builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
         builder.setMessage(text);
         builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
-        showAlertDialog(builder);
+        showDialog(builder.create());
     }
 
     public void needShowProgress() {
@@ -258,6 +243,7 @@ public void onAnimationStart(Object animation) {
                     newView.setVisibility(View.VISIBLE);
                 }
 
+                @SuppressLint("NewApi")
                 @Override
                 public void onAnimationEnd(Object animation) {
                     outView.setVisibility(View.GONE);
@@ -1066,18 +1052,13 @@ public void onShow() {
         @Override
         public void didReceivedNotification(int id, final Object... args) {
             if (id == NotificationCenter.didReceiveSmsCode) {
-                AndroidUtilities.runOnUIThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        if (!waitingForSms) {
-                            return;
-                        }
-                        if (codeField != null) {
-                            codeField.setText("" + args[0]);
-                            onNextPressed();
-                        }
-                    }
-                });
+                if (!waitingForSms) {
+                    return;
+                }
+                if (codeField != null) {
+                    codeField.setText("" + args[0]);
+                    onNextPressed();
+                }
             }
         }
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChangePhoneHelpActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChangePhoneHelpActivity.java
index 362d91294..e4077ef3b 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChangePhoneHelpActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChangePhoneHelpActivity.java
@@ -148,7 +148,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                     }
                 });
                 builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                showAlertDialog(builder);
+                showDialog(builder.create());
             }
         });
 
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChangeUsernameActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChangeUsernameActivity.java
index 6e1d20ca8..0e40b1a41 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChangeUsernameActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChangeUsernameActivity.java
@@ -215,7 +215,7 @@ private void showErrorAlert(String error) {
                 break;
         }
         builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
-        showAlertDialog(builder);
+        showDialog(builder.create());
     }
 
     private boolean checkUserName(final String name, boolean alert) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
index 11eb1f3f1..133143686 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
@@ -10,7 +10,6 @@
 
 import android.app.Activity;
 import android.app.AlertDialog;
-import android.app.ProgressDialog;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
@@ -44,7 +43,6 @@
 import android.widget.LinearLayout;
 import android.widget.ListView;
 import android.widget.ProgressBar;
-import android.widget.RelativeLayout;
 import android.widget.TextView;
 import android.widget.Toast;
 
@@ -57,7 +55,9 @@
 import org.telegram.android.NotificationsController;
 import org.telegram.android.SecretChatHelper;
 import org.telegram.android.SendMessagesHelper;
+import org.telegram.android.VideoEditedInfo;
 import org.telegram.android.query.ReplyMessageQuery;
+import org.telegram.android.query.StickersQuery;
 import org.telegram.android.support.widget.LinearLayoutManager;
 import org.telegram.android.support.widget.RecyclerView;
 import org.telegram.messenger.ApplicationLoader;
@@ -74,7 +74,7 @@
 import org.telegram.android.NotificationCenter;
 import org.telegram.messenger.R;
 import org.telegram.messenger.UserConfig;
-import org.telegram.messenger.Utilities;
+import org.telegram.ui.ActionBar.BottomSheet;
 import org.telegram.ui.Adapters.MentionsAdapter;
 import org.telegram.ui.Adapters.StickersAdapter;
 import org.telegram.android.AnimationCompat.AnimatorListenerAdapterProxy;
@@ -98,13 +98,13 @@
 import org.telegram.ui.Components.FrameLayoutFixed;
 import org.telegram.ui.Components.LayoutHelper;
 import org.telegram.ui.Components.RecordStatusDrawable;
-import org.telegram.ui.Components.RecyclerExListView;
 import org.telegram.ui.Components.RecyclerListView;
 import org.telegram.ui.Components.ResourceLoader;
 import org.telegram.ui.Components.SendingFileExDrawable;
-import org.telegram.ui.Components.SizeNotifierRelativeLayout;
+import org.telegram.ui.Components.SizeNotifierFrameLayout;
 import org.telegram.ui.Components.TimerDrawable;
 import org.telegram.ui.Components.TypingDotsDrawable;
+import org.telegram.ui.Components.WebFrameLayout;
 
 import java.io.File;
 import java.util.ArrayList;
@@ -133,7 +133,7 @@
     private ActionBarMenuItem attachItem;
     private ActionBarMenuItem headerItem;
     private TextView addContactItem;
-    private RecyclerExListView chatListView;
+    private RecyclerListView chatListView;
     private LinearLayoutManager chatLayoutManager;
     private ChatActivityAdapter chatAdapter;
     private BackupImageView avatarImageView;
@@ -258,7 +258,7 @@
 
     private final static int id_chat_compose_panel = 1000;
 
-    RecyclerExListView.OnItemLongClickListener onItemLongClickListener = new RecyclerExListView.OnItemLongClickListener() {
+    RecyclerListView.OnItemLongClickListener onItemLongClickListener = new RecyclerListView.OnItemLongClickListener() {
         @Override
         public void onItemClick(View view, int position) {
             if (!actionBar.isActionModeShowed()) {
@@ -267,7 +267,7 @@ public void onItemClick(View view, int position) {
         }
     };
 
-    RecyclerExListView.OnItemClickListener onItemClickListener = new RecyclerExListView.OnItemClickListener() {
+    RecyclerListView.OnItemClickListener onItemClickListener = new RecyclerListView.OnItemClickListener() {
         @Override
         public void onItemClick(View view, int position) {
             if (actionBar.isActionModeShowed()) {
@@ -543,7 +543,7 @@ public View createView(Context context, LayoutInflater inflater) {
             @Override
             public void onItemClick(final int id) {
                 if (id == attach_photo || id == attach_gallery || id == attach_document || id == attach_video) {
-                    String action = null;
+                    String action;
                     if (currentChat != null) {
                         if (currentChat.participants_count > MessagesController.getInstance().groupBigSize) {
                             if (id == attach_photo || id == attach_gallery) {
@@ -582,7 +582,7 @@ public void onItemClick(final int id) {
                 } else if (id == attach_photo) {
                     try {
                         Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
-                        File image = Utilities.generatePicturePath();
+                        File image = AndroidUtilities.generatePicturePath();
                         if (image != null) {
                             takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(image));
                             currentPicturePath = image.getAbsolutePath();
@@ -635,7 +635,7 @@ public boolean didSelectVideo(String path) {
                 } else if (id == attach_video) {
                     try {
                         Intent takeVideoIntent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);
-                        File video = Utilities.generateVideoPath();
+                        File video = AndroidUtilities.generateVideoPath();
                         if (video != null) {
                             if (Build.VERSION.SDK_INT >= 18) {
                                 takeVideoIntent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(video));
@@ -745,7 +745,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (id == forward) {
                     Bundle args = new Bundle();
                     args.putBoolean("onlySelect", true);
@@ -757,7 +757,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                     if (getParentActivity() == null) {
                         return;
                     }
-                    showAlertDialog(AndroidUtilities.buildTTLAlert(getParentActivity(), currentEncryptedChat));
+                    showDialog(AndroidUtilities.buildTTLAlert(getParentActivity(), currentEncryptedChat).create());
                 } else if (id == clear_history || id == delete_chat) {
                     if (getParentActivity() == null) {
                         return;
@@ -779,7 +779,11 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         public void onClick(DialogInterface dialogInterface, int i) {
                             if (id != clear_history) {
                                 if (isChat) {
-                                    MessagesController.getInstance().deleteUserFromChat((int) -dialog_id, MessagesController.getInstance().getUser(UserConfig.getClientUserId()), null);
+                                    if (currentChat.left || currentChat instanceof TLRPC.TL_chatForbidden) {
+                                        MessagesController.getInstance().deleteDialog(dialog_id, 0, false);
+                                    } else {
+                                        MessagesController.getInstance().deleteUserFromChat((int) -dialog_id, MessagesController.getInstance().getUser(UserConfig.getClientUserId()), null);
+                                    }
                                 } else {
                                     MessagesController.getInstance().deleteDialog(dialog_id, 0, false);
                                 }
@@ -790,7 +794,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (id == share_contact) {
                     if (currentUser == null || getParentActivity() == null) {
                         return;
@@ -813,7 +817,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                             }
                         });
                         builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                        showAlertDialog(builder);
+                        showDialog(builder.create());
                     }
                 } else if (id == mute) {
                     boolean muted = MessagesController.getInstance().isDialogMuted(dialog_id);
@@ -842,7 +846,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
 
                                         SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Activity.MODE_PRIVATE);
                                         SharedPreferences.Editor editor = preferences.edit();
-                                        long flags = 0;
+                                        long flags;
                                         if (i == 3) {
                                             editor.putInt("notify2_" + dialog_id, 2);
                                             flags = 1;
@@ -863,7 +867,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                                 }
                         );
                         builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                        showAlertDialog(builder);
+                        showDialog(builder.create());
                     } else {
                         SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Activity.MODE_PRIVATE);
                         SharedPreferences.Editor editor = preferences.edit();
@@ -942,7 +946,7 @@ public void onClick(View v) {
                     if (getParentActivity() == null) {
                         return;
                     }
-                    showAlertDialog(AndroidUtilities.buildTTLAlert(getParentActivity(), currentEncryptedChat));
+                    showDialog(AndroidUtilities.buildTTLAlert(getParentActivity(), currentEncryptedChat).create());
                 }
             });
         }
@@ -1047,29 +1051,117 @@ public boolean onTouch(View v, MotionEvent event) {
         }
         checkActionBarMenu();
 
-        fragmentView = new SizeNotifierRelativeLayout(context);
-
-        /*
-         {
+        fragmentView = new SizeNotifierFrameLayout(context) {
             @Override
             protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-                if (chatActivityEnterView chatActivityEnterView.isEmojiPopupShowing()) {
-                    int height = MeasureSpec.getSize(heightMeasureSpec);
-                    heightMeasureSpec = MeasureSpec.makeMeasureSpec(height - chatActivityEnterView.getEmojiHeight(), MeasureSpec.getMode(heightMeasureSpec));
+                int widthMode = MeasureSpec.getMode(widthMeasureSpec);
+                int heightMode = MeasureSpec.getMode(heightMeasureSpec);
+                int widthSize = MeasureSpec.getSize(widthMeasureSpec);
+                int heightSize = MeasureSpec.getSize(heightMeasureSpec);
+
+                setMeasuredDimension(widthSize, heightSize);
+                heightSize -= getPaddingBottom();
+
+                int inputFieldHeight = 0;
+
+                int childCount = getChildCount();
+                for (int i = 0; i < childCount; i++) {
+                    View child = getChildAt(i);
+                    if (child == chatActivityEnterView) {
+                        measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
+                        inputFieldHeight = child.getMeasuredHeight();
+                        break;
+                    }
+                }
+                for (int i = 0; i < childCount; i++) {
+                    View child = getChildAt(i);
+                    if (child.getVisibility() == GONE || child == chatActivityEnterView) {
+                        continue;
+                    }
+
+                    LayoutParams lp = (LayoutParams) child.getLayoutParams();
+                    if (child == chatListView) {
+                        int contentWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY);
+                        int contentHeightSpec = MeasureSpec.makeMeasureSpec(Math.max(AndroidUtilities.dp(10), heightSize - inputFieldHeight + AndroidUtilities.dp(2)), MeasureSpec.EXACTLY);
+                        child.measure(contentWidthSpec, contentHeightSpec);
+                    } else {
+                        measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
+                    }
                 }
-                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+            }
+
+            @Override
+            protected void onLayout(boolean changed, int l, int t, int r, int b) {
+                final int count = getChildCount();
+
+                for (int i = 0; i < count; i++) {
+                    final View child = getChildAt(i);
+                    if (child.getVisibility() == GONE) {
+                        continue;
+                    }
+                    final LayoutParams lp = (LayoutParams) child.getLayoutParams();
+
+                    final int width = child.getMeasuredWidth();
+                    final int height = child.getMeasuredHeight();
+
+                    int childLeft;
+                    int childTop;
+
+                    int gravity = lp.gravity;
+                    if (gravity == -1) {
+                        gravity = Gravity.TOP | Gravity.LEFT;
+                    }
+
+                    final int absoluteGravity = gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
+                    final int verticalGravity = gravity & Gravity.VERTICAL_GRAVITY_MASK;
+
+                    switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
+                        case Gravity.CENTER_HORIZONTAL:
+                            childLeft = (r - l - width) / 2 + lp.leftMargin - lp.rightMargin;
+                            break;
+                        case Gravity.RIGHT:
+                            childLeft = r - width - lp.rightMargin;
+                            break;
+                        case Gravity.LEFT:
+                        default:
+                            childLeft = lp.leftMargin;
+                    }
+
+                    switch (verticalGravity) {
+                        case Gravity.TOP:
+                            childTop = lp.topMargin;
+                            break;
+                        case Gravity.CENTER_VERTICAL:
+                            childTop = ((b - getPaddingBottom()) - t - height) / 2 + lp.topMargin - lp.bottomMargin;
+                            break;
+                        case Gravity.BOTTOM:
+                            childTop = ((b - getPaddingBottom()) - t) - height - lp.bottomMargin;
+                            break;
+                        default:
+                            childTop = lp.topMargin;
+                    }
+
+                    if (child == mentionListView) {
+                        childTop -= chatActivityEnterView.getMeasuredHeight() - AndroidUtilities.dp(2);
+                    } else if (child == pagedownButton) {
+                        childTop -= chatActivityEnterView.getMeasuredHeight();
+                    }
+                    child.layout(childLeft, childTop, childLeft + width, childTop + height);
+                }
+
+                notifyHeightChanged();
             }
         };
-         */
 
-        SizeNotifierRelativeLayout contentView = (SizeNotifierRelativeLayout) fragmentView;
+
+        SizeNotifierFrameLayout contentView = (SizeNotifierFrameLayout) fragmentView;
 
         contentView.setBackgroundImage(ApplicationLoader.getCachedWallpaper());
 
         emptyViewContainer = new FrameLayout(context);
         emptyViewContainer.setPadding(0, 0, 0, AndroidUtilities.dp(48));
         emptyViewContainer.setVisibility(View.INVISIBLE);
-        contentView.addView(emptyViewContainer, new RelativeLayout.LayoutParams(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
+        contentView.addView(emptyViewContainer, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
         emptyViewContainer.setOnTouchListener(new View.OnTouchListener() {
             @Override
             public boolean onTouch(View v, MotionEvent event) {
@@ -1079,7 +1171,7 @@ public boolean onTouch(View v, MotionEvent event) {
 
         if (currentEncryptedChat == null) {
             TextView emptyView = new TextView(context);
-            if (currentUser != null && currentUser.id != 777000 && (currentUser.id / 1000 == 333 || currentUser.id % 1000 == 0)) {
+            if (currentUser != null && currentUser.id != 777000 && currentUser.id != 429000 && (currentUser.id / 1000 == 333 || currentUser.id % 1000 == 0)) {
                 emptyView.setText(LocaleController.getString("GotAQuestion", R.string.GotAQuestion));
             } else {
                 emptyView.setText(LocaleController.getString("NoMessages", R.string.NoMessages));
@@ -1164,7 +1256,12 @@ public boolean onTouch(View v, MotionEvent event) {
             }
         }
 
-        chatListView = (RecyclerExListView) inflater.inflate(R.layout.recycler_view, null);
+        if (chatActivityEnterView != null) {
+            chatActivityEnterView.onDestroy();
+        }
+
+        chatListView = new RecyclerListView(context);
+        chatListView.setVerticalScrollBarEnabled(true);
         chatListView.setAdapter(chatAdapter = new ChatActivityAdapter(context));
         chatListView.setClipToPadding(false);
         chatListView.setPadding(0, AndroidUtilities.dp(4), 0, AndroidUtilities.dp(3));
@@ -1179,7 +1276,7 @@ public boolean supportsPredictiveItemAnimations() {
         chatLayoutManager.setOrientation(LinearLayoutManager.VERTICAL);
         chatLayoutManager.setStackFromEnd(true);
         chatListView.setLayoutManager(chatLayoutManager);
-        contentView.addView(chatListView, LayoutHelper.createRelative(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, 0, 0, 0, -3, RelativeLayout.ABOVE, id_chat_compose_panel));
+        contentView.addView(chatListView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
         chatListView.setOnItemLongClickListener(onItemLongClickListener);
         chatListView.setOnItemClickListener(onItemClickListener);
         chatListView.setOnScrollListener(new RecyclerView.OnScrollListener() {
@@ -1271,7 +1368,7 @@ public void run() {
                 return false;
             }
         });
-        chatListView.setOnInterceptTouchListener(new RecyclerExListView.OnInterceptTouchListener() {
+        chatListView.setOnInterceptTouchListener(new RecyclerListView.OnInterceptTouchListener() {
             @Override
             public boolean onInterceptTouchEvent(MotionEvent event) {
                 if (actionBar.isActionModeShowed()) {
@@ -1295,7 +1392,7 @@ public boolean onInterceptTouchEvent(MotionEvent event) {
                         }
                         final ChatMediaCell cell = (ChatMediaCell) view;
                         final MessageObject messageObject = cell.getMessageObject();
-                        if (messageObject == null || !messageObject.isSecretPhoto() || !cell.getPhotoImage().isInsideImage(x, y - top)) {
+                        if (messageObject == null || messageObject.isSending() || !messageObject.isSecretPhoto() || !cell.getPhotoImage().isInsideImage(x, y - top)) {
                             break;
                         }
                         File file = FileLoader.getPathToMessage(messageObject.messageOwner);
@@ -1332,7 +1429,7 @@ public void run() {
 
         progressView = new FrameLayout(context);
         progressView.setVisibility(View.INVISIBLE);
-        contentView.addView(progressView, LayoutHelper.createRelative(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, 0, 0, 0, 48));
+        contentView.addView(progressView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT, 0, 0, 0, 48));
 
         View view = new View(context);
         view.setBackgroundResource(ApplicationLoader.isCustomTheme() ? R.drawable.system_loader2 : R.drawable.system_loader1);
@@ -1359,13 +1456,13 @@ public void run() {
             if (Build.VERSION.SDK_INT > 8) {
                 mentionListView.setOverScrollMode(ListView.OVER_SCROLL_NEVER);
             }
-            contentView.addView(mentionListView, LayoutHelper.createRelative(LayoutHelper.MATCH_PARENT, 110, 0, -108, 0, 0, RelativeLayout.ALIGN_TOP, id_chat_compose_panel));
+            contentView.addView(mentionListView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 110, Gravity.LEFT | Gravity.BOTTOM));
 
             mentionListView.setAdapter(mentionsAdapter = new MentionsAdapter(context, false, new MentionsAdapter.MentionsAdapterDelegate() {
                 @Override
                 public void needChangePanelVisibility(boolean show) {
                     if (show) {
-                        RelativeLayout.LayoutParams layoutParams3 = (RelativeLayout.LayoutParams) mentionListView.getLayoutParams();
+                        FrameLayout.LayoutParams layoutParams3 = (FrameLayout.LayoutParams) mentionListView.getLayoutParams();
                         int height = 36 * Math.min(3, mentionsAdapter.getCount()) + (mentionsAdapter.getCount() > 3 ? 18 : 0);
                         layoutParams3.height = AndroidUtilities.dp(2 + height);
                         layoutParams3.topMargin = -AndroidUtilities.dp(height);
@@ -1470,7 +1567,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                             }
                         });
                         builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                        showAlertDialog(builder);
+                        showDialog(builder.create());
                         return true;
                     }
                     return false;
@@ -1478,14 +1575,11 @@ public void onClick(DialogInterface dialogInterface, int i) {
             });
         }
 
-        if (chatActivityEnterView != null) {
-            chatActivityEnterView.onDestroy();
-        }
         chatActivityEnterView = new ChatActivityEnterView(getParentActivity(), contentView, this, true);
         chatActivityEnterView.setDialogId(dialog_id);
         chatActivityEnterView.addToAttachLayout(menuItem);
         chatActivityEnterView.setId(id_chat_compose_panel);
-        contentView.addView(chatActivityEnterView, LayoutHelper.createRelative(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, RelativeLayout.ALIGN_PARENT_BOTTOM));
+        contentView.addView(chatActivityEnterView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.BOTTOM));
         chatActivityEnterView.setDelegate(new ChatActivityEnterView.ChatActivityEnterViewDelegate() {
             @Override
             public void onMessageSend(String message) {
@@ -1494,9 +1588,6 @@ public void onMessageSend(String message) {
                 if (mentionsAdapter != null) {
                     mentionsAdapter.addHashtagsFromMessage(message);
                 }
-                if (message != null) {
-                    NotificationsController.getInstance().playOutChatSound();
-                }
             }
 
             @Override
@@ -1629,9 +1720,10 @@ public void onClick(View v) {
 
         stickersPanel = new FrameLayout(context);
         stickersPanel.setVisibility(View.GONE);
-        contentView.addView(stickersPanel, LayoutHelper.createRelative(LayoutHelper.WRAP_CONTENT, 81.5f, 0, 0, 0, 38, RelativeLayout.ALIGN_BOTTOM, id_chat_compose_panel));
+        contentView.addView(stickersPanel, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, 81.5f, Gravity.LEFT | Gravity.BOTTOM, 0, 0, 0, 38));
 
         stickersListView = new RecyclerListView(context);
+        stickersListView.setDisallowInterceptTouchEvents(true);
         LinearLayoutManager layoutManager = new LinearLayoutManager(context);
         layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);
         stickersListView.setLayoutManager(layoutManager);
@@ -1686,7 +1778,7 @@ public void onAnimationEnd(Object animation) {
                     }
                 }
             }));
-            stickersListView.addOnItemTouchListener(new RecyclerListView.RecyclerListViewItemClickListener(context, new RecyclerListView.OnItemClickListener() {
+            stickersListView.setOnItemClickListener(new RecyclerListView.OnItemClickListener() {
                 @Override
                 public void onItemClick(View view, int position) {
                     TLRPC.Document document = stickersAdapter.getItem(position);
@@ -1696,7 +1788,7 @@ public void onItemClick(View view, int position) {
                     }
                     chatActivityEnterView.setFieldText("");
                 }
-            }));
+            });
         }
 
         imageView = new ImageView(context);
@@ -1709,7 +1801,7 @@ public void onItemClick(View view, int position) {
         bottomOverlay.setFocusable(true);
         bottomOverlay.setFocusableInTouchMode(true);
         bottomOverlay.setClickable(true);
-        contentView.addView(bottomOverlay, LayoutHelper.createRelative(LayoutHelper.MATCH_PARENT, 48, RelativeLayout.ALIGN_PARENT_BOTTOM));
+        contentView.addView(bottomOverlay, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 48, Gravity.BOTTOM));
 
         bottomOverlayText = new TextView(context);
         bottomOverlayText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
@@ -1719,7 +1811,7 @@ public void onItemClick(View view, int position) {
         bottomOverlayChat = new FrameLayout(context);
         bottomOverlayChat.setBackgroundColor(0xfffbfcfd);
         bottomOverlayChat.setVisibility(View.INVISIBLE);
-        contentView.addView(bottomOverlayChat, LayoutHelper.createRelative(LayoutHelper.MATCH_PARENT, 48, RelativeLayout.ALIGN_PARENT_BOTTOM));
+        contentView.addView(bottomOverlayChat, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 48, Gravity.BOTTOM));
         bottomOverlayChat.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View view) {
@@ -1747,7 +1839,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                     });
                 }
                 builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                showAlertDialog(builder);
+                showDialog(builder.create());
             }
         });
 
@@ -1759,7 +1851,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
         pagedownButton = new ImageView(context);
         pagedownButton.setVisibility(View.INVISIBLE);
         pagedownButton.setImageResource(R.drawable.pagedown);
-        contentView.addView(pagedownButton, LayoutHelper.createRelative(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, 0, 0, 6, 4, RelativeLayout.ALIGN_PARENT_RIGHT, RelativeLayout.ABOVE, id_chat_compose_panel));
+        contentView.addView(pagedownButton, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.RIGHT | Gravity.BOTTOM, 0, 0, 6, 4));
         pagedownButton.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View view) {
@@ -1786,6 +1878,33 @@ public void onClick(View view) {
         return fragmentView;
     }
 
+    private boolean searchForHttpInText(CharSequence string) {
+        int len = string.length();
+        int seqLen = 0;
+        for (int a = 0; a < len; a++) {
+            char ch = string.charAt(a);
+            if (seqLen == 0 && (ch == 'h' || ch == 'H')) {
+                seqLen++;
+            } else if ((seqLen == 1 || seqLen == 2) && (ch == 't' || ch == 'T')) {
+                seqLen++;
+            } else if (seqLen == 3 && (ch == 'p' || ch == 'P')) {
+                seqLen++;
+            } else if (seqLen == 4 && (ch == 's' || ch == 'S')) {
+                seqLen++;
+            } else if ((seqLen == 4 || seqLen == 5) && ch == ':') {
+                seqLen++;
+            } else if ((seqLen == 5 || seqLen == 6 || seqLen == 7) && ch == '/') {
+                if (seqLen == 6 || seqLen == 7) {
+                    return true;
+                }
+                seqLen++;
+            } else if (seqLen != 0) {
+                seqLen = 0;
+            }
+        }
+        return false;
+    }
+
     private void searchLinks(CharSequence charSequence, boolean force) {
         if (currentEncryptedChat != null) {
             return;
@@ -1814,7 +1933,7 @@ private void searchLinks(CharSequence charSequence, boolean force) {
             pendingLinkSearchString = null;
             showReplyPanel(false, null, null, foundWebPage, false, true);
         }
-        if (charSequence.length() < 13 || TextUtils.indexOf(charSequence, "http://") == -1 && TextUtils.indexOf(charSequence, "https://") == -1) {
+        if (charSequence.length() < 13 || !searchForHttpInText(charSequence)) {
             return;
         }
         final TLRPC.TL_messages_getWebPagePreview req = new TLRPC.TL_messages_getWebPagePreview();
@@ -1982,7 +2101,7 @@ public void showReplyPanel(boolean show, MessageObject messageObject, ArrayList<
                         replyObjectTextView.setText(LocaleController.formatPluralString("ForwardedSticker", messageObjects.size()));
                     } else if (type == 8 || type == 9) {
                         if (messageObjects.size() == 1) {
-                            String name = null;
+                            String name;
                             if ((name = FileLoader.getDocumentFileName(messageObjects.get(0).messageOwner.media.document)).length() != 0) {
                                 replyObjectTextView.setText(name);
                             }
@@ -2309,7 +2428,7 @@ private int getMessageType(MessageObject messageObject) {
                     if (!messageObject.isMediaEmpty()) {
                         return 0;
                     } else {
-                        return 7;
+                        return 20;
                     }
                 } else {
                     return -1;
@@ -2327,6 +2446,12 @@ private int getMessageType(MessageObject messageObject) {
                         if (messageObject.messageOwner.media instanceof TLRPC.TL_messageMediaVideo ||
                                 messageObject.messageOwner.media instanceof TLRPC.TL_messageMediaPhoto ||
                                 messageObject.messageOwner.media instanceof TLRPC.TL_messageMediaDocument) {
+                            if (messageObject.isSticker()) {
+                                TLRPC.InputStickerSet inputStickerSet = messageObject.getInputStickerSet();
+                                if (inputStickerSet != null && !StickersQuery.isStickerPackInstalled(inputStickerSet.id)) {
+                                    return 7;
+                                }
+                            }
                             boolean canSave = false;
                             if (messageObject.messageOwner.attachPath != null && messageObject.messageOwner.attachPath.length() != 0) {
                                 File f = new File(messageObject.messageOwner.attachPath);
@@ -2370,7 +2495,7 @@ private int getMessageType(MessageObject messageObject) {
                 if (!messageObject.isMediaEmpty()) {
                     return 0;
                 } else {
-                    return 7;
+                    return 20;
                 }
             } else if (messageObject.type == 10 || messageObject.type == 11) {
                 if (messageObject.getId() == 0 || messageObject.isSending()) {
@@ -2383,6 +2508,12 @@ private int getMessageType(MessageObject messageObject) {
                     if (messageObject.messageOwner.media instanceof TLRPC.TL_messageMediaVideo ||
                             messageObject.messageOwner.media instanceof TLRPC.TL_messageMediaPhoto ||
                             messageObject.messageOwner.media instanceof TLRPC.TL_messageMediaDocument) {
+                        if (messageObject.isSticker()) {
+                            TLRPC.InputStickerSet inputStickerSet = messageObject.getInputStickerSet();
+                            if (inputStickerSet != null && !StickersQuery.isStickerPackInstalled(inputStickerSet.id)) {
+                                return 7;
+                            }
+                        }
                         boolean canSave = false;
                         if (messageObject.messageOwner.attachPath != null && messageObject.messageOwner.attachPath.length() != 0) {
                             File f = new File(messageObject.messageOwner.attachPath);
@@ -2449,7 +2580,7 @@ private void processRowSelect(View view) {
 
         int type = getMessageType(message);
 
-        if (type < 2 || type == 7) {
+        if (type < 2 || type == 8) {
             return;
         }
         addToSelectedMessages(message);
@@ -2651,7 +2782,7 @@ public boolean openVideoEditor(String videoPath, boolean removeLast, boolean ani
         fragment.setDelegate(new VideoEditorActivity.VideoEditorActivityDelegate() {
             @Override
             public void didFinishEditVideo(String videoPath, long startTime, long endTime, int resultWidth, int resultHeight, int rotationValue, int originalWidth, int originalHeight, int bitrate, long estimatedSize, long estimatedDuration) {
-                TLRPC.VideoEditedInfo videoEditedInfo = new TLRPC.VideoEditedInfo();
+                VideoEditedInfo videoEditedInfo = new VideoEditedInfo();
                 videoEditedInfo.startTime = startTime;
                 videoEditedInfo.endTime = endTime;
                 videoEditedInfo.rotationValue = rotationValue;
@@ -2722,7 +2853,7 @@ public void sendButtonPressed(int index) {
                         }
                     }
                 }, this);
-                Utilities.addMediaToGallery(currentPicturePath);
+                AndroidUtilities.addMediaToGallery(currentPicturePath);
                 currentPicturePath = null;
             } else if (requestCode == 1) {
                 if (data == null || data.getData() == null) {
@@ -2733,7 +2864,7 @@ public void sendButtonPressed(int index) {
                 if (uri.toString().contains("video")) {
                     String videoPath = null;
                     try {
-                        videoPath = Utilities.getPath(uri);
+                        videoPath = AndroidUtilities.getPath(uri);
                     } catch (Exception e) {
                         FileLog.e("tmessages", e);
                     }
@@ -2763,7 +2894,7 @@ public void sendButtonPressed(int index) {
                     } else {
                         videoPath = currentPicturePath;
                     }
-                    Utilities.addMediaToGallery(currentPicturePath);
+                    AndroidUtilities.addMediaToGallery(currentPicturePath);
                     currentPicturePath = null;
                 }
                 if (videoPath == null && currentPicturePath != null) {
@@ -2788,7 +2919,7 @@ public void sendButtonPressed(int index) {
                     showAttachmentError();
                     return;
                 }
-                String tempPath = Utilities.getPath(data.getData());
+                String tempPath = AndroidUtilities.getPath(data.getData());
                 String originalPath = tempPath;
                 if (tempPath == null) {
                     originalPath = data.toString();
@@ -3157,7 +3288,7 @@ public void run() {
                             builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
                             builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
                             builder.setMessage(LocaleController.formatString("CompatibilityChat", R.string.CompatibilityChat, currentUser.first_name, currentUser.first_name));
-                            showAlertDialog(builder);
+                            showDialog(builder.create());
                         }
                     }
                 }
@@ -3459,6 +3590,7 @@ public void run() {
                 if (mediaUpdated && chatLayoutManager.findLastVisibleItemPosition() >= messages.size() - 1) {
                     moveScrollToLastMessage();
                 }
+                NotificationsController.getInstance().playOutChatSound();
             }
         } else if (id == NotificationCenter.messageReceivedByAck) {
             Integer msgId = (Integer) args[0];
@@ -3692,7 +3824,13 @@ public void run() {
     }
 
     @Override
-    public void onOpenAnimationEnd() {
+    protected void onOpenAnimationStart() {
+        NotificationCenter.getInstance().setAnimationInProgress(true);
+    }
+
+    @Override
+    protected void onOpenAnimationEnd() {
+        NotificationCenter.getInstance().setAnimationInProgress(false);
         openAnimationEnded = true;
         int count = chatListView.getChildCount();
         for (int a = 0; a < count; a++) {
@@ -3985,7 +4123,7 @@ public void createMenu(View v, boolean single) {
         selectedMessagesIds.clear();
         actionBar.hideActionMode();
 
-        if (single || type < 2 || type == 7) {
+        if (single || type < 2 || type == 20) {
             if (type >= 0) {
                 selectedObject = message;
                 if (getParentActivity() == null) {
@@ -4007,7 +4145,7 @@ public void createMenu(View v, boolean single) {
                         items = new CharSequence[]{LocaleController.getString("Delete", R.string.Delete)};
                         options = new int[]{1};
                     }
-                } else if (type == 7) {
+                } else if (type == 20) {
                     items = new CharSequence[]{LocaleController.getString("Retry", R.string.Retry), LocaleController.getString("Copy", R.string.Copy), LocaleController.getString("Delete", R.string.Delete)};
                     options = new int[]{0, 3, 1};
                 } else {
@@ -4021,17 +4159,21 @@ public void createMenu(View v, boolean single) {
                                 options = new int[]{8, 2, 3, 1};
                             } else if (type == 4) {
                                 if (selectedObject.messageOwner.media instanceof TLRPC.TL_messageMediaDocument) {
-                                    items = new CharSequence[]{LocaleController.getString("Reply", R.string.Reply), LocaleController.getString("ShareFile", R.string.ShareFile), LocaleController.getString("Forward", R.string.Forward), LocaleController.getString("Delete", R.string.Delete)};
+                                    items = new CharSequence[]{LocaleController.getString("Reply", R.string.Reply), LocaleController.getString("SaveToDownloads", R.string.SaveToDownloads), LocaleController.getString("ShareFile", R.string.ShareFile), LocaleController.getString("Forward", R.string.Forward), LocaleController.getString("Delete", R.string.Delete)};
+                                    options = new int[]{8, 10, 4, 2, 1};
                                 } else {
                                     items = new CharSequence[]{LocaleController.getString("Reply", R.string.Reply), LocaleController.getString("SaveToGallery", R.string.SaveToGallery), LocaleController.getString("Forward", R.string.Forward), LocaleController.getString("Delete", R.string.Delete)};
+                                    options = new int[]{8, 4, 2, 1};
                                 }
-                                options = new int[]{8, 4, 2, 1};
                             } else if (type == 5) {
                                 items = new CharSequence[]{LocaleController.getString("Reply", R.string.Reply), LocaleController.getString("ApplyLocalizationFile", R.string.ApplyLocalizationFile), LocaleController.getString("ShareFile", R.string.ShareFile), LocaleController.getString("Forward", R.string.Forward), LocaleController.getString("Delete", R.string.Delete)};
                                 options = new int[]{8, 5, 4, 2, 1};
                             } else if (type == 6) {
-                                items = new CharSequence[]{LocaleController.getString("Reply", R.string.Reply), LocaleController.getString("SaveToGallery", R.string.SaveToGallery), LocaleController.getString("ShareFile", R.string.ShareFile), LocaleController.getString("Forward", R.string.Forward), LocaleController.getString("Delete", R.string.Delete)};
-                                options = new int[]{8, 7, 6, 2, 1};
+                                items = new CharSequence[]{LocaleController.getString("Reply", R.string.Reply), LocaleController.getString("SaveToGallery", R.string.SaveToGallery), LocaleController.getString("SaveToDownloads", R.string.SaveToDownloads), LocaleController.getString("ShareFile", R.string.ShareFile), LocaleController.getString("Forward", R.string.Forward), LocaleController.getString("Delete", R.string.Delete)};
+                                options = new int[]{8, 7, 10, 6, 2, 1};
+                            } else if (type == 7) {
+                                items = new CharSequence[]{LocaleController.getString("Reply", R.string.Reply), LocaleController.getString("Forward", R.string.Forward), LocaleController.getString("AddToStickers", R.string.AddToStickers), LocaleController.getString("Delete", R.string.Delete)};
+                                options = new int[]{8, 2, 9, 1};
                             }
                         } else {
                             if (type == 2) {
@@ -4042,17 +4184,21 @@ public void createMenu(View v, boolean single) {
                                 options = new int[]{2, 3, 1};
                             } else if (type == 4) {
                                 if (selectedObject.messageOwner.media instanceof TLRPC.TL_messageMediaDocument) {
-                                    items = new CharSequence[]{LocaleController.getString("ShareFile", R.string.ShareFile), LocaleController.getString("Forward", R.string.Forward), LocaleController.getString("Delete", R.string.Delete)};
+                                    items = new CharSequence[]{LocaleController.getString("SaveToDownloads", R.string.SaveToDownloads), LocaleController.getString("ShareFile", R.string.ShareFile), LocaleController.getString("Forward", R.string.Forward), LocaleController.getString("Delete", R.string.Delete)};
+                                    options = new int[]{10, 4, 2, 1};
                                 } else {
                                     items = new CharSequence[]{LocaleController.getString("SaveToGallery", R.string.SaveToGallery), LocaleController.getString("Forward", R.string.Forward), LocaleController.getString("Delete", R.string.Delete)};
+                                    options = new int[]{4, 2, 1};
                                 }
-                                options = new int[]{4, 2, 1};
                             } else if (type == 5) {
                                 items = new CharSequence[]{LocaleController.getString("ApplyLocalizationFile", R.string.ApplyLocalizationFile), LocaleController.getString("ShareFile", R.string.ShareFile), LocaleController.getString("Forward", R.string.Forward), LocaleController.getString("Delete", R.string.Delete)};
                                 options = new int[]{5, 4, 2, 1};
                             } else if (type == 6) {
-                                items = new CharSequence[]{LocaleController.getString("SaveToGallery", R.string.SaveToGallery), LocaleController.getString("ShareFile", R.string.ShareFile), LocaleController.getString("Forward", R.string.Forward), LocaleController.getString("Delete", R.string.Delete)};
-                                options = new int[]{7, 6, 2, 1};
+                                items = new CharSequence[]{LocaleController.getString("SaveToGallery", R.string.SaveToGallery), LocaleController.getString("SaveToDownloads", R.string.SaveToDownloads), LocaleController.getString("ShareFile", R.string.ShareFile), LocaleController.getString("Forward", R.string.Forward), LocaleController.getString("Delete", R.string.Delete)};
+                                options = new int[]{7, 10, 6, 2, 1};
+                            } else if (type == 7) {
+                                items = new CharSequence[]{LocaleController.getString("Reply", R.string.Reply), LocaleController.getString("Forward", R.string.Forward), LocaleController.getString("AddToStickers", R.string.AddToStickers), LocaleController.getString("Delete", R.string.Delete)};
+                                options = new int[]{8, 2, 9, 1};
                             }
                         }
                     } else {
@@ -4064,14 +4210,18 @@ public void createMenu(View v, boolean single) {
                             options = new int[]{3, 1};
                         } else if (type == 4) {
                             if (selectedObject.messageOwner.media instanceof TLRPC.TL_messageMediaDocument) {
-                                items = new CharSequence[]{LocaleController.getString("ShareFile", R.string.ShareFile), LocaleController.getString("Delete", R.string.Delete)};
+                                items = new CharSequence[]{LocaleController.getString("SaveToDownloads", R.string.SaveToDownloads), LocaleController.getString("ShareFile", R.string.ShareFile), LocaleController.getString("Delete", R.string.Delete)};
+                                options = new int[]{10, 4, 1};
                             } else {
                                 items = new CharSequence[]{LocaleController.getString("SaveToGallery", R.string.SaveToGallery), LocaleController.getString("Delete", R.string.Delete)};
+                                options = new int[]{4, 1};
                             }
-                            options = new int[]{4, 1};
                         } else if (type == 5) {
                             items = new CharSequence[]{LocaleController.getString("ApplyLocalizationFile", R.string.ApplyLocalizationFile), LocaleController.getString("Delete", R.string.Delete)};
                             options = new int[]{5, 1};
+                        } else if (type == 7) {
+                            items = new CharSequence[]{LocaleController.getString("Reply", R.string.Reply), LocaleController.getString("Forward", R.string.Forward), LocaleController.getString("AddToStickers", R.string.AddToStickers), LocaleController.getString("Delete", R.string.Delete)};
+                            options = new int[]{8, 2, 9, 1};
                         }
                     }
                 }
@@ -4088,7 +4238,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                 });
 
                 builder.setTitle(LocaleController.getString("Message", R.string.Message));
-                showAlertDialog(builder);
+                showDialog(builder.create());
             }
             return;
         }
@@ -4144,7 +4294,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                 }
             });
             builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-            showAlertDialog(builder);
+            showDialog(builder.create());
         } else if (option == 2) {
             forwaringMessage = selectedObject;
             Bundle args = new Bundle();
@@ -4209,7 +4359,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                     builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
                     builder.setMessage(LocaleController.getString("IncorrectLocalization", R.string.IncorrectLocalization));
                     builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 }
             }
         } else if (option == 6 || option == 7) {
@@ -4236,77 +4386,31 @@ public void onClick(DialogInterface dialogInterface, int i) {
             }
         } else if (option == 8) {
             showReplyPanel(true, selectedObject, null, null, false, true);
-        }
-        selectedObject = null;
-    }
-
-    private void openProfileWithUsername(String username) {
-        TLRPC.User user = MessagesController.getInstance().getUser(username);
-        if (user != null) {
-            Bundle args = new Bundle();
-            args.putInt("user_id", user.id);
-            presentFragment(new ProfileActivity(args));
-        } else {
-            if (getParentActivity() == null) {
-                return;
+        } else if (option == 9) {
+            StickersQuery.loadStickers(this, selectedObject.getInputStickerSet());
+        } else if (option == 10) {
+            String fileName = FileLoader.getDocumentFileName(selectedObject.messageOwner.media.document);
+            if (fileName == null || fileName.length() == 0) {
+                fileName = selectedObject.getFileName();
             }
-            final ProgressDialog progressDialog = new ProgressDialog(getParentActivity());
-            progressDialog.setMessage(LocaleController.getString("Loading", R.string.Loading));
-            progressDialog.setCanceledOnTouchOutside(false);
-            progressDialog.setCancelable(false);
-
-            TLRPC.TL_contacts_resolveUsername req = new TLRPC.TL_contacts_resolveUsername();
-            req.username = username;
-            final long reqId = ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
-                @Override
-                public void run(final TLObject response, final TLRPC.TL_error error) {
-                    AndroidUtilities.runOnUIThread(new Runnable() {
-                        @Override
-                        public void run() {
-                            try {
-                                progressDialog.dismiss();
-                            } catch (Exception e) {
-                                FileLog.e("tmessages", e);
-                            }
-                            visibleDialog = null;
-                            if (error == null) {
-                                TLRPC.User user = (TLRPC.User) response;
-                                MessagesController.getInstance().putUser(user, false);
-                                ArrayList<TLRPC.User> users = new ArrayList<>();
-                                users.add(user);
-                                MessagesStorage.getInstance().putUsersAndChats(users, null, false, true);
-                                Bundle args = new Bundle();
-                                args.putInt("user_id", user.id);
-                                presentFragment(new ProfileActivity(args));
-                            }
-                        }
-                    });
-                }
-            });
-            progressDialog.setButton(DialogInterface.BUTTON_NEGATIVE, LocaleController.getString("Cancel", R.string.Cancel), new DialogInterface.OnClickListener() {
-                @Override
-                public void onClick(DialogInterface dialog, int which) {
-                    ConnectionsManager.getInstance().cancelRpc(reqId, true);
-                    try {
-                        dialog.dismiss();
-                    } catch (Exception e) {
-                        FileLog.e("tmessages", e);
-                    }
-                    visibleDialog = null;
+            String path = selectedObject.messageOwner.attachPath;
+            if (path != null && path.length() > 0) {
+                File temp = new File(path);
+                if (!temp.exists()) {
+                    path = null;
                 }
-            });
-            visibleDialog = progressDialog;
-            progressDialog.show();
+            }
+            if (path == null || path.length() == 0) {
+                path = FileLoader.getPathToMessage(selectedObject.messageOwner).toString();
+            }
+            MediaController.saveFile(path, getParentActivity(), 2, fileName);
         }
+        selectedObject = null;
     }
 
     @Override
     public void didSelectDialog(MessagesActivity activity, long did, boolean param) {
         if (dialog_id != 0 && (forwaringMessage != null || !selectedMessagesIds.isEmpty())) {
-            if (isBroadcast) {
-                param = true;
-            }
-
             ArrayList<MessageObject> fmessages = new ArrayList<>();
             if (forwaringMessage != null) {
                 fmessages.add(forwaringMessage);
@@ -4404,7 +4508,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                 }
             });
             builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-            showAlertDialog(builder);
+            showDialog(builder.create());
             return false;
         }
     }
@@ -4452,7 +4556,7 @@ private void alertUserOpenError(MessageObject message) {
         } else {
             builder.setMessage(LocaleController.formatString("NoHandleAppInstalled", R.string.NoHandleAppInstalled, message.messageOwner.media.document.mime_type));
         }
-        showAlertDialog(builder);
+        showDialog(builder.create());
     }
 
     @Override
@@ -4569,7 +4673,7 @@ public int getItemCount() {
 
         @Override
         public long getItemId(int i) {
-            return RecyclerExListView.NO_ID;
+            return RecyclerListView.NO_ID;
         }
 
         @Override
@@ -4640,7 +4744,7 @@ public boolean canPerformActions() {
                     @Override
                     public void didPressUrl(String url) {
                         if (url.startsWith("@")) {
-                            openProfileWithUsername(url.substring(1));
+                            MessagesController.openByUserName(url.substring(1), ChatActivity.this, 0);
                         } else if (url.startsWith("#")) {
                             MessagesActivity fragment = new MessagesActivity(null);
                             fragment.setSearchString(url);
@@ -4648,6 +4752,14 @@ public void didPressUrl(String url) {
                         }
                     }
 
+                    @Override
+                    public void needOpenWebView(String url, String title, String originalUrl, int w, int h) {
+                        BottomSheet.Builder builder = new BottomSheet.Builder(mContext);
+                        builder.setCustomView(new WebFrameLayout(mContext, builder.create(), title, originalUrl, url, w, h));
+                        builder.setOverrideTabletWidth(true);
+                        showDialog(builder.create());
+                    }
+
                     @Override
                     public void didPressReplyMessage(ChatBaseCell cell, int id) {
                         scrollToMessageId(id, cell.getMessageObject().getId(), true);
@@ -4798,7 +4910,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                                         }
                                     }
                             );
-                            showAlertDialog(builder);
+                            showDialog(builder.create());
                         }
                     });
                 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/AvatarUpdater.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/AvatarUpdater.java
index b8001641c..57e0b98a5 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/AvatarUpdater.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/AvatarUpdater.java
@@ -24,7 +24,6 @@
 import org.telegram.messenger.FileLog;
 import org.telegram.android.NotificationCenter;
 import org.telegram.messenger.UserConfig;
-import org.telegram.messenger.Utilities;
 import org.telegram.ui.LaunchActivity;
 import org.telegram.ui.PhotoAlbumPickerActivity;
 import org.telegram.ui.PhotoCropActivity;
@@ -62,7 +61,7 @@ public void clear() {
     public void openCamera() {
         try {
             Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
-            File image = Utilities.generatePicturePath();
+            File image = AndroidUtilities.generatePicturePath();
             if (image != null) {
                 takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(image));
                 currentPicturePath = image.getAbsolutePath();
@@ -163,7 +162,7 @@ public void sendButtonPressed(int index) {
                         processBitmap(bitmap);
                     }
                 }, null);
-                Utilities.addMediaToGallery(currentPicturePath);
+                AndroidUtilities.addMediaToGallery(currentPicturePath);
                 currentPicturePath = null;
             } else if (requestCode == 14) {
                 if (data == null || data.getData() == null) {
@@ -205,37 +204,27 @@ public void didReceivedNotification(int id, final Object... args) {
         if (id == NotificationCenter.FileDidUpload) {
             String location = (String)args[0];
             if (uploadingAvatar != null && location.equals(uploadingAvatar)) {
-                AndroidUtilities.runOnUIThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        NotificationCenter.getInstance().removeObserver(AvatarUpdater.this, NotificationCenter.FileDidUpload);
-                        NotificationCenter.getInstance().removeObserver(AvatarUpdater.this, NotificationCenter.FileDidFailUpload);
-                        if (delegate != null) {
-                            delegate.didUploadedPhoto((TLRPC.InputFile)args[1], smallPhoto, bigPhoto);
-                        }
-                        uploadingAvatar = null;
-                        if (clearAfterUpdate) {
-                            parentFragment = null;
-                            delegate = null;
-                        }
-                    }
-                });
+                NotificationCenter.getInstance().removeObserver(AvatarUpdater.this, NotificationCenter.FileDidUpload);
+                NotificationCenter.getInstance().removeObserver(AvatarUpdater.this, NotificationCenter.FileDidFailUpload);
+                if (delegate != null) {
+                    delegate.didUploadedPhoto((TLRPC.InputFile)args[1], smallPhoto, bigPhoto);
+                }
+                uploadingAvatar = null;
+                if (clearAfterUpdate) {
+                    parentFragment = null;
+                    delegate = null;
+                }
             }
         } else if (id == NotificationCenter.FileDidFailUpload) {
             String location = (String)args[0];
             if (uploadingAvatar != null && location.equals(uploadingAvatar)) {
-                AndroidUtilities.runOnUIThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        NotificationCenter.getInstance().removeObserver(AvatarUpdater.this, NotificationCenter.FileDidUpload);
-                        NotificationCenter.getInstance().removeObserver(AvatarUpdater.this, NotificationCenter.FileDidFailUpload);
-                        uploadingAvatar = null;
-                        if (clearAfterUpdate) {
-                            parentFragment = null;
-                            delegate = null;
-                        }
-                    }
-                });
+                NotificationCenter.getInstance().removeObserver(AvatarUpdater.this, NotificationCenter.FileDidUpload);
+                NotificationCenter.getInstance().removeObserver(AvatarUpdater.this, NotificationCenter.FileDidFailUpload);
+                uploadingAvatar = null;
+                if (clearAfterUpdate) {
+                    parentFragment = null;
+                    delegate = null;
+                }
             }
         }
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/BackupImageView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/BackupImageView.java
index 3d991dde3..5fa640c07 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/BackupImageView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/BackupImageView.java
@@ -45,39 +45,43 @@ private void init() {
         imageReceiver = new ImageReceiver(this);
     }
 
+    public void setImage(TLObject path, String filter, String ext, Drawable thumb) {
+        setImage(path, null, filter, thumb, null, null, null, ext, 0);
+    }
+
     public void setImage(TLObject path, String filter, Drawable thumb) {
-        setImage(path, null, filter, thumb, null, null, null, 0);
+        setImage(path, null, filter, thumb, null, null, null, null, 0);
     }
 
     public void setImage(TLObject path, String filter, Bitmap thumb) {
-        setImage(path, null, filter, null, thumb, null, null, 0);
+        setImage(path, null, filter, null, thumb, null, null, null, 0);
     }
 
     public void setImage(TLObject path, String filter, Drawable thumb, int size) {
-        setImage(path, null, filter, thumb, null, null, null, size);
+        setImage(path, null, filter, thumb, null, null, null, null, size);
     }
 
     public void setImage(TLObject path, String filter, Bitmap thumb, int size) {
-        setImage(path, null, filter, null, thumb, null, null, size);
+        setImage(path, null, filter, null, thumb, null, null, null, size);
     }
 
     public void setImage(TLObject path, String filter, TLRPC.FileLocation thumb, int size) {
-        setImage(path, null, filter, null, null, thumb, null, size);
+        setImage(path, null, filter, null, null, thumb, null, null, size);
     }
 
     public void setImage(String path, String filter, Drawable thumb) {
-        setImage(null, path, filter, thumb, null, null, null, 0);
+        setImage(null, path, filter, thumb, null, null, null, null, 0);
     }
 
     public void setOrientation(int angle, boolean center) {
         imageReceiver.setOrientation(angle, center);
     }
 
-    public void setImage(TLObject path, String httpUrl, String filter, Drawable thumb, Bitmap thumbBitmap, TLRPC.FileLocation thumbLocation, String thumbFilter, int size) {
+    public void setImage(TLObject path, String httpUrl, String filter, Drawable thumb, Bitmap thumbBitmap, TLRPC.FileLocation thumbLocation, String thumbFilter, String ext, int size) {
         if (thumbBitmap != null) {
             thumb = new BitmapDrawable(null, thumbBitmap);
         }
-        imageReceiver.setImage(path, httpUrl, filter, thumb, thumbLocation, thumbFilter, size, false);
+        imageReceiver.setImage(path, httpUrl, filter, thumb, thumbLocation, thumbFilter, size, ext, false);
     }
 
     public void setImageBitmap(Bitmap bitmap) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatActivityEnterView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatActivityEnterView.java
index 233374b32..4d6580a2e 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatActivityEnterView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatActivityEnterView.java
@@ -73,7 +73,7 @@
     private ImageView audioSendButton;
     private FrameLayout recordPanel;
     private LinearLayout slideText;
-    private SizeNotifierRelativeLayout sizeNotifierRelativeLayout;
+    private View sizeNotifierLayout;
     private FrameLayout attachButton;
     private LinearLayout textFieldContainer;
     private View topView;
@@ -118,7 +118,7 @@
     private boolean allowShowTopView;
     private AnimatorSetProxy currentTopViewAnimation;
 
-    public ChatActivityEnterView(Activity context, SizeNotifierRelativeLayout parent, BaseFragment fragment, boolean isChat) {
+    public ChatActivityEnterView(Activity context, View parent, BaseFragment fragment, boolean isChat) {
         super(context);
         setBackgroundResource(R.drawable.compose_panel);
         setFocusable(true);
@@ -135,8 +135,12 @@ public ChatActivityEnterView(Activity context, SizeNotifierRelativeLayout parent
         NotificationCenter.getInstance().addObserver(this, NotificationCenter.audioRouteChanged);
         parentActivity = context;
         parentFragment = fragment;
-        sizeNotifierRelativeLayout = parent;
-        sizeNotifierRelativeLayout.setDelegate(this);
+        sizeNotifierLayout = parent;
+        if (sizeNotifierLayout instanceof SizeNotifierRelativeLayout) {
+            ((SizeNotifierRelativeLayout) sizeNotifierLayout).setDelegate(this);
+        } else if (sizeNotifierLayout instanceof SizeNotifierFrameLayout) {
+            ((SizeNotifierFrameLayout) sizeNotifierLayout).setDelegate(this);
+        }
         SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("mainconfig", Activity.MODE_PRIVATE);
         sendByEnter = preferences.getBoolean("send_by_enter", false);
 
@@ -155,7 +159,7 @@ public boolean onPreDraw() {
                 } else if (keyboardTransitionState == 2) {
                     if (!keyboardVisible || framesDroped >= 60) {
                         int currentHeight = AndroidUtilities.displaySize.x > AndroidUtilities.displaySize.y ? keyboardHeightLand : keyboardHeight;
-                        sizeNotifierRelativeLayout.setPadding(0, 0, 0, currentHeight);
+                        sizeNotifierLayout.setPadding(0, 0, 0, currentHeight);
                         keyboardTransitionState = 0;
                     }
                     framesDroped++;
@@ -433,8 +437,8 @@ public void afterTextChanged(Editable editable) {
             public boolean onTouch(View view, MotionEvent motionEvent) {
                 if (motionEvent.getAction() == MotionEvent.ACTION_DOWN) {
                     if (parentFragment != null) {
-                        String action = null;
-                        TLRPC.Chat currentChat = null;
+                        String action;
+                        TLRPC.Chat currentChat;
                         if ((int) dialog_id < 0) {
                             currentChat = MessagesController.getInstance().getChat(-(int) dialog_id);
                             if (currentChat != null && currentChat.participants_count > MessagesController.getInstance().groupBigSize) {
@@ -535,14 +539,14 @@ private void setKeyboardTransitionState(int state) {
 
             } else if (state == 2) {
                 int currentHeight = AndroidUtilities.displaySize.x > AndroidUtilities.displaySize.y ? keyboardHeightLand : keyboardHeight;
-                sizeNotifierRelativeLayout.setPadding(0, 0, 0, currentHeight);
+                sizeNotifierLayout.setPadding(0, 0, 0, currentHeight);
                 keyboardTransitionState = 0;
             }
         } else {
             framesDroped = 0;
             keyboardTransitionState = state;
             if (state == 1) {
-                sizeNotifierRelativeLayout.setPadding(0, 0, 0, 0);
+                sizeNotifierLayout.setPadding(0, 0, 0, 0);
             }
         }
     }
@@ -591,9 +595,7 @@ public void showTopView(boolean animated) {
         topViewShowed = true;
         if (allowShowTopView) {
             topView.setVisibility(VISIBLE);
-            float resumeValue = 0.0f;
             if (currentTopViewAnimation != null) {
-                resumeValue = topViewAnimation;
                 currentTopViewAnimation.cancel();
                 currentTopViewAnimation = null;
             }
@@ -706,7 +708,7 @@ public void onDestroy() {
         NotificationCenter.getInstance().removeObserver(this, NotificationCenter.emojiDidLoaded);
         NotificationCenter.getInstance().removeObserver(this, NotificationCenter.hideEmojiKeyboard);
         NotificationCenter.getInstance().removeObserver(this, NotificationCenter.audioRouteChanged);
-        sizeNotifierRelativeLayout.getViewTreeObserver().removeOnPreDrawListener(onPreDrawListener);
+        sizeNotifierLayout.getViewTreeObserver().removeOnPreDrawListener(onPreDrawListener);
         if (mWakeLock != null) {
             try {
                 mWakeLock.release();
@@ -715,8 +717,12 @@ public void onDestroy() {
                 FileLog.e("tmessages", e);
             }
         }
-        if (sizeNotifierRelativeLayout != null) {
-            sizeNotifierRelativeLayout.setDelegate(null);
+        if (sizeNotifierLayout != null) {
+            if (sizeNotifierLayout instanceof SizeNotifierRelativeLayout) {
+                ((SizeNotifierRelativeLayout) sizeNotifierLayout).setDelegate(null);
+            } else if (sizeNotifierLayout instanceof SizeNotifierFrameLayout) {
+                ((SizeNotifierFrameLayout) sizeNotifierLayout).setDelegate(null);
+            }
         }
     }
 
@@ -739,8 +745,8 @@ public boolean isMessageWebPageSearchEnabled() {
 
     private void sendMessage() {
         if (parentFragment != null) {
-            String action = null;
-            TLRPC.Chat currentChat = null;
+            String action;
+            TLRPC.Chat currentChat;
             if ((int) dialog_id < 0) {
                 currentChat = MessagesController.getInstance().getChat(-(int) dialog_id);
                 if (currentChat != null && currentChat.participants_count > MessagesController.getInstance().groupBigSize) {
@@ -1066,8 +1072,8 @@ public void onEmojiSelected(String symbol) {
                         if (i < 0) {
                             i = 0;
                         }
-                        try {
-                            CharSequence localCharSequence = Emoji.replaceEmoji(symbol, messageEditText.getPaint().getFontMetricsInt(), AndroidUtilities.dp(20));
+                        try {//TODO check
+                            CharSequence localCharSequence = Emoji.replaceEmoji(symbol/* + "\uFE0F"*/, messageEditText.getPaint().getFontMetricsInt(), AndroidUtilities.dp(20));
                             messageEditText.setText(messageEditText.getText().insert(i, localCharSequence));
                             int j = i + localCharSequence.length();
                             messageEditText.setSelection(j, j);
@@ -1095,18 +1101,18 @@ public void onStickerSelected(TLRPC.Document sticker) {
             int currentHeight = AndroidUtilities.displaySize.x > AndroidUtilities.displaySize.y ? keyboardHeightLand : keyboardHeight;
             FileLog.e("tmessages", "show emoji with height = " + currentHeight);
             emojiPopup.setHeight(View.MeasureSpec.makeMeasureSpec(currentHeight, View.MeasureSpec.EXACTLY));
-            if (sizeNotifierRelativeLayout != null) {
+            if (sizeNotifierLayout != null) {
                 emojiPopup.setWidth(View.MeasureSpec.makeMeasureSpec(AndroidUtilities.displaySize.x, View.MeasureSpec.EXACTLY));
             }
 
             emojiPopup.showAtLocation(parentActivity.getWindow().getDecorView(), Gravity.BOTTOM | Gravity.LEFT, 0, 0);
 
             if (!keyboardVisible) {
-                if (sizeNotifierRelativeLayout != null) {
-                    sizeNotifierRelativeLayout.setPadding(0, 0, 0, currentHeight);
+                if (sizeNotifierLayout != null) {
+                    sizeNotifierLayout.setPadding(0, 0, 0, currentHeight);
                     emojiButton.setImageResource(R.drawable.ic_msg_panel_hide);
                     showKeyboardOnEmojiButton = false;
-                    onWindowSizeChanged(sizeNotifierRelativeLayout.getHeight() - sizeNotifierRelativeLayout.getPaddingBottom());
+                    onWindowSizeChanged(sizeNotifierLayout.getHeight() - sizeNotifierLayout.getPaddingBottom());
                 }
                 return;
             } else {
@@ -1129,19 +1135,19 @@ public void onStickerSelected(TLRPC.Document sticker) {
             }
         }
         if (keyboardTransitionState == 0) {
-            if (sizeNotifierRelativeLayout != null) {
+            if (sizeNotifierLayout != null) {
                 if (post) {
-                    sizeNotifierRelativeLayout.post(new Runnable() {
+                    sizeNotifierLayout.post(new Runnable() {
                         public void run() {
-                            if (sizeNotifierRelativeLayout != null) {
-                                sizeNotifierRelativeLayout.setPadding(0, 0, 0, 0);
-                                onWindowSizeChanged(sizeNotifierRelativeLayout.getHeight());
+                            if (sizeNotifierLayout != null) {
+                                sizeNotifierLayout.setPadding(0, 0, 0, 0);
+                                onWindowSizeChanged(sizeNotifierLayout.getHeight());
                             }
                         }
                     });
                 } else {
-                    sizeNotifierRelativeLayout.setPadding(0, 0, 0, 0);
-                    onWindowSizeChanged(sizeNotifierRelativeLayout.getHeight());
+                    sizeNotifierLayout.setPadding(0, 0, 0, 0);
+                    onWindowSizeChanged(sizeNotifierLayout.getHeight());
                 }
             }
         }
@@ -1262,12 +1268,7 @@ public void onSizeChanged(int height, boolean isWidthGreater) {
         }
 
         if (emojiPopup != null && emojiPopup.isShowing()) {
-            int newHeight = 0;
-            if (isWidthGreater) {
-                newHeight = keyboardHeightLand;
-            } else {
-                newHeight = keyboardHeight;
-            }
+            int newHeight = isWidthGreater ? keyboardHeightLand : keyboardHeight;
             final WindowManager.LayoutParams layoutParams = (WindowManager.LayoutParams) emojiPopup.getContentView().getLayoutParams();
             FileLog.e("tmessages", "update emoji height to = " + newHeight);
             if (layoutParams.width != AndroidUtilities.displaySize.x || layoutParams.height != newHeight) {
@@ -1277,10 +1278,10 @@ public void onSizeChanged(int height, boolean isWidthGreater) {
                 if (wm != null) {
                     wm.updateViewLayout(emojiPopup.getContentView(), layoutParams);
                     if (!keyboardVisible) {
-                        if (sizeNotifierRelativeLayout != null) {
-                            sizeNotifierRelativeLayout.setPadding(0, 0, 0, layoutParams.height);
-                            sizeNotifierRelativeLayout.requestLayout();
-                            onWindowSizeChanged(sizeNotifierRelativeLayout.getHeight() - sizeNotifierRelativeLayout.getPaddingBottom());
+                        if (sizeNotifierLayout != null) {
+                            sizeNotifierLayout.setPadding(0, 0, 0, layoutParams.height);
+                            sizeNotifierLayout.requestLayout();
+                            onWindowSizeChanged(sizeNotifierLayout.getHeight() - sizeNotifierLayout.getPaddingBottom());
                         }
                     }
                 }
@@ -1289,13 +1290,13 @@ public void onSizeChanged(int height, boolean isWidthGreater) {
 
         boolean oldValue = keyboardVisible;
         keyboardVisible = height > 0;
-        if (keyboardVisible && (sizeNotifierRelativeLayout.getPaddingBottom() > 0 || keyboardTransitionState == 1)) {
+        if (keyboardVisible && (sizeNotifierLayout.getPaddingBottom() > 0 || keyboardTransitionState == 1)) {
             setKeyboardTransitionState(1);
         } else if (keyboardTransitionState != 2 && !keyboardVisible && keyboardVisible != oldValue && emojiPopup != null && emojiPopup.isShowing()) {
             showEmojiPopup(false, true);
         }
         if (keyboardTransitionState == 0) {
-            onWindowSizeChanged(sizeNotifierRelativeLayout.getHeight() - sizeNotifierRelativeLayout.getPaddingBottom());
+            onWindowSizeChanged(sizeNotifierLayout.getHeight() - sizeNotifierLayout.getPaddingBottom());
         }
     }
 
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/EmojiView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/EmojiView.java
index 2800d68a9..260b398c1 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/EmojiView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/EmojiView.java
@@ -8,7 +8,9 @@
 
 package org.telegram.ui.Components;
 
+import android.app.Activity;
 import android.content.Context;
+import android.content.SharedPreferences;
 import android.database.DataSetObserver;
 import android.support.v4.view.PagerAdapter;
 import android.support.v4.view.ViewPager;
@@ -30,11 +32,15 @@
 import org.telegram.android.LocaleController;
 import org.telegram.android.NotificationCenter;
 import org.telegram.android.query.StickersQuery;
+import org.telegram.messenger.FileLog;
 import org.telegram.messenger.R;
 import org.telegram.messenger.TLRPC;
 import org.telegram.ui.Cells.StickerEmojiCell;
 
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
 
 public class EmojiView extends LinearLayout implements NotificationCenter.NotificationCenterDelegate {
 
@@ -46,6 +52,9 @@
 
     private ArrayList<EmojiGridAdapter> adapters = new ArrayList<>();
     private StickersGridAdapter stickersGridAdapter;
+    private HashMap<Long, Integer> stickersUseHistory = new HashMap<>();
+    private ArrayList<TLRPC.Document> stickers;
+
     private int[] icons = {
             R.drawable.ic_emoji_recent,
             R.drawable.ic_emoji_smile,
@@ -58,15 +67,19 @@
     private Listener listener;
     private ViewPager pager;
     private FrameLayout recentsWrap;
+    private FrameLayout emojiWrap;
     private ArrayList<GridView> views = new ArrayList<>();
     private ImageView backspaceButton;
 
     private boolean backspacePressed;
     private boolean backspaceOnce;
+    private boolean showStickers;
 
     public EmojiView(boolean needStickers, Context context) {
         super(context);
 
+        showStickers = needStickers;
+
         setOrientation(LinearLayout.VERTICAL);
         for (int i = 0; i < Emoji.data.length; i++) {
             GridView gridView = new GridView(context);
@@ -84,7 +97,9 @@ public EmojiView(boolean needStickers, Context context) {
             adapters.add(emojiGridAdapter);
         }
 
-        if (needStickers) {
+        if (showStickers) {
+            StickersQuery.checkStickers();
+            stickers = StickersQuery.getStickers();
             GridView gridView = new GridView(context);
             gridView.setColumnWidth(AndroidUtilities.dp(72));
             gridView.setNumColumns(-1);
@@ -157,6 +172,19 @@ public boolean onTouchEvent(MotionEvent event) {
         recentsWrap.addView(textView);
         views.get(0).setEmptyView(textView);
 
+        if (views.size() > 6) {
+            emojiWrap = new FrameLayout(context);
+            emojiWrap.addView(views.get(6));
+
+            textView = new TextView(context);
+            textView.setText(LocaleController.getString("NoStickers", R.string.NoStickers));
+            textView.setTextSize(18);
+            textView.setTextColor(0xff888888);
+            textView.setGravity(Gravity.CENTER);
+            emojiWrap.addView(textView);
+            views.get(6).setEmptyView(textView);
+        }
+
         addView(pager);
 
         loadRecents();
@@ -223,37 +251,103 @@ private String convert(long paramLong) {
     }
 
     private void saveRecents() {
-        ArrayList<Long> localArrayList = new ArrayList<>();
-        long[] arrayOfLong = Emoji.data[0];
-        int i = arrayOfLong.length;
-        for (int j = 0; ; j++) {
-            if (j >= i) {
-                getContext().getSharedPreferences("emoji", 0).edit().putString("recents", TextUtils.join(",", localArrayList)).commit();
-                return;
+        ArrayList<Long> arrayList = new ArrayList<>(Emoji.data[0].length);
+        for (int j = 0; j < Emoji.data[0].length; j++) {
+            arrayList.add(Emoji.data[0][j]);
+        }
+        getContext().getSharedPreferences("emoji", 0).edit().putString("recents", TextUtils.join(",", arrayList)).commit();
+    }
+
+    private void saveRecentStickers() {
+        SharedPreferences preferences = getContext().getSharedPreferences("emoji", Activity.MODE_PRIVATE);
+        StringBuilder stringBuilder = new StringBuilder();
+        for (HashMap.Entry<Long, Integer> entry : stickersUseHistory.entrySet()) {
+            if (stringBuilder.length() != 0) {
+                stringBuilder.append(",");
             }
-            localArrayList.add(arrayOfLong[j]);
+            stringBuilder.append(entry.getKey());
+            stringBuilder.append("=");
+            stringBuilder.append(entry.getValue());
         }
+        getContext().getSharedPreferences("emoji", 0).edit().putString("stickers", stringBuilder.toString()).commit();
     }
 
-    public void loadRecents() {
-        String str = getContext().getSharedPreferences("emoji", 0).getString("recents", "");
-        String[] arrayOfString = null;
-        if (str != null && str.length() > 0) {
-            arrayOfString = str.split(",");
-            Emoji.data[0] = new long[arrayOfString.length];
-            for (int i = 0; i < arrayOfString.length; i++) {
-                Emoji.data[0][i] = Long.parseLong(arrayOfString[i]);
+    private void sortStickers() {
+        HashMap<Long, Integer> hashMap = new HashMap<>();
+        for (TLRPC.Document document : stickers) {
+            Integer count = stickersUseHistory.get(document.id);
+            if (count != null) {
+                hashMap.put(document.id, count);
+                stickersUseHistory.remove(document.id);
             }
+        }
+        if (!stickersUseHistory.isEmpty()) {
+            stickersUseHistory = hashMap;
+            saveRecents();
         } else {
-            Emoji.data[0] = new long[]{0x00000000D83DDE02L, 0x00000000D83DDE18L, 0x0000000000002764L, 0x00000000D83DDE0DL, 0x00000000D83DDE0AL, 0x00000000D83DDE01L,
-                    0x00000000D83DDC4DL, 0x000000000000263AL, 0x00000000D83DDE14L, 0x00000000D83DDE04L, 0x00000000D83DDE2DL, 0x00000000D83DDC8BL,
-                    0x00000000D83DDE12L, 0x00000000D83DDE33L, 0x00000000D83DDE1CL, 0x00000000D83DDE48L, 0x00000000D83DDE09L, 0x00000000D83DDE03L,
-                    0x00000000D83DDE22L, 0x00000000D83DDE1DL, 0x00000000D83DDE31L, 0x00000000D83DDE21L, 0x00000000D83DDE0FL, 0x00000000D83DDE1EL,
-                    0x00000000D83DDE05L, 0x00000000D83DDE1AL, 0x00000000D83DDE4AL, 0x00000000D83DDE0CL, 0x00000000D83DDE00L, 0x00000000D83DDE0BL,
-                    0x00000000D83DDE06L, 0x00000000D83DDC4CL, 0x00000000D83DDE10L, 0x00000000D83DDE15L};
+            stickersUseHistory = hashMap;
+        }
+        Collections.sort(stickers, new Comparator<TLRPC.Document>() {
+            @Override
+            public int compare(TLRPC.Document lhs, TLRPC.Document rhs) {
+                Integer count1 = stickersUseHistory.get(lhs.id);
+                Integer count2 = stickersUseHistory.get(rhs.id);
+                if (count1 == null) {
+                    count1 = 0;
+                }
+                if (count2 == null) {
+                    count2 = 0;
+                }
+                if (count1 > count2) {
+                    return -1;
+                } else if (count1 < count2) {
+                    return 1;
+                }
+                return 0;
+            }
+        });
+    }
+
+    public void loadRecents() {
+        SharedPreferences preferences = getContext().getSharedPreferences("emoji", Activity.MODE_PRIVATE);
+        String str = preferences.getString("recents", "");
+        try {
+            if (str != null && str.length() > 0) {
+                String[] args = str.split(",");
+                Emoji.data[0] = new long[args.length];
+                for (int i = 0; i < args.length; i++) {
+                    Emoji.data[0][i] = Long.parseLong(args[i]);
+                }
+            } else {
+                Emoji.data[0] = new long[]{0x00000000D83DDE02L, 0x00000000D83DDE18L, 0x0000000000002764L, 0x00000000D83DDE0DL, 0x00000000D83DDE0AL, 0x00000000D83DDE01L,
+                        0x00000000D83DDC4DL, 0x000000000000263AL, 0x00000000D83DDE14L, 0x00000000D83DDE04L, 0x00000000D83DDE2DL, 0x00000000D83DDC8BL,
+                        0x00000000D83DDE12L, 0x00000000D83DDE33L, 0x00000000D83DDE1CL, 0x00000000D83DDE48L, 0x00000000D83DDE09L, 0x00000000D83DDE03L,
+                        0x00000000D83DDE22L, 0x00000000D83DDE1DL, 0x00000000D83DDE31L, 0x00000000D83DDE21L, 0x00000000D83DDE0FL, 0x00000000D83DDE1EL,
+                        0x00000000D83DDE05L, 0x00000000D83DDE1AL, 0x00000000D83DDE4AL, 0x00000000D83DDE0CL, 0x00000000D83DDE00L, 0x00000000D83DDE0BL,
+                        0x00000000D83DDE06L, 0x00000000D83DDC4CL, 0x00000000D83DDE10L, 0x00000000D83DDE15L};
+            }
+            adapters.get(0).data = Emoji.data[0];
+            adapters.get(0).notifyDataSetChanged();
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+
+        if (showStickers) {
+            try {
+                stickersUseHistory.clear();
+                str = preferences.getString("stickers", "");
+                if (str != null && str.length() > 0) {
+                    String[] args = str.split(",");
+                    for (String arg : args) {
+                        String[] args2 = arg.split("=");
+                        stickersUseHistory.put(Long.parseLong(args2[0]), Integer.parseInt(args2[1]));
+                    }
+                }
+                sortStickers();
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
         }
-        adapters.get(0).data = Emoji.data[0];
-        adapters.get(0).notifyDataSetChanged();
     }
 
     public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
@@ -277,6 +371,9 @@ protected void onAttachedToWindow() {
         super.onAttachedToWindow();
         if (stickersGridAdapter != null) {
             NotificationCenter.getInstance().addObserver(this, NotificationCenter.stickersDidLoaded);
+            stickers = StickersQuery.getStickers();
+            sortStickers();
+            stickersGridAdapter.notifyDataSetChanged();
         }
     }
 
@@ -301,19 +398,18 @@ public void didReceivedNotification(int id, Object... args) {
 
         public StickersGridAdapter(Context context) {
             this.context = context;
-            StickersQuery.checkStickers();
         }
 
         public int getCount() {
-            return StickersQuery.getStickers().size();
+            return stickers.size();
         }
 
         public Object getItem(int i) {
-            return StickersQuery.getStickers().get(i);
+            return stickers.get(i);
         }
 
         public long getItemId(int i) {
-            return StickersQuery.getStickers().get(i).id;
+            return stickers.get(i).id;
         }
 
         public View getView(int i, View view, ViewGroup viewGroup) {
@@ -327,12 +423,19 @@ public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
                     @Override
                     public void onClick(View v) {
                         if (listener != null) {
-                            listener.onStickerSelected(((StickerEmojiCell) v).getSticker());
+                            TLRPC.Document document = ((StickerEmojiCell) v).getSticker();
+                            Integer count = stickersUseHistory.get(document.id);
+                            if (count == null) {
+                                count = 0;
+                            }
+                            stickersUseHistory.put(document.id, ++count);
+                            saveRecentStickers();
+                            listener.onStickerSelected(document);
                         }
                     }
                 });
             }
-            ((StickerEmojiCell) view).setSticker(StickersQuery.getStickers().get(i));
+            ((StickerEmojiCell) view).setSticker(stickers.get(i), false);
             return view;
         }
 
@@ -401,6 +504,8 @@ public void destroyItem(ViewGroup paramViewGroup, int paramInt, Object paramObje
             View localObject;
             if (paramInt == 0) {
                 localObject = recentsWrap;
+            } else if (paramInt == 6) {
+                localObject = emojiWrap;
             } else {
                 localObject = views.get(paramInt);
             }
@@ -419,6 +524,8 @@ public Object instantiateItem(ViewGroup paramViewGroup, int paramInt) {
             View localObject;
             if (paramInt == 0) {
                 localObject = recentsWrap;
+            } else if (paramInt == 6) {
+                localObject = emojiWrap;
             } else {
                 localObject = views.get(paramInt);
             }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/EmptyTextProgressView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/EmptyTextProgressView.java
new file mode 100644
index 000000000..0e38769e6
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/EmptyTextProgressView.java
@@ -0,0 +1,103 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.content.Context;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.View;
+import android.widget.FrameLayout;
+import android.widget.ProgressBar;
+import android.widget.TextView;
+
+import org.telegram.android.LocaleController;
+import org.telegram.messenger.R;
+
+public class EmptyTextProgressView extends FrameLayout {
+
+    private TextView textView;
+    private ProgressBar progressBar;
+    private boolean inLayout;
+    private boolean showAtCenter;
+
+    public EmptyTextProgressView(Context context) {
+        super(context);
+
+        progressBar = new ProgressBar(context);
+        progressBar.setVisibility(INVISIBLE);
+        addView(progressBar, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT));
+
+        textView = new TextView(context);
+        textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20);
+        textView.setTextColor(0xff808080);
+        textView.setGravity(Gravity.CENTER);
+        textView.setVisibility(INVISIBLE);
+        textView.setText(LocaleController.getString("NoResult", R.string.NoResult));
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT));
+
+        setOnTouchListener(new View.OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                return true;
+            }
+        });
+    }
+
+    public void showProgress() {
+        textView.setVisibility(INVISIBLE);
+        progressBar.setVisibility(VISIBLE);
+    }
+
+    public void showTextView() {
+        textView.setVisibility(VISIBLE);
+        progressBar.setVisibility(INVISIBLE);
+    }
+
+    public void setText(String text) {
+        textView.setText(text);
+    }
+
+    public void setShowAtCenter(boolean value) {
+        showAtCenter = value;
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int l, int t, int r, int b) {
+        inLayout = true;
+        int width = r - l;
+        int height = b - t;
+        int childCount = getChildCount();
+        for (int i = 0; i < childCount; i++) {
+            View child = getChildAt(i);
+
+            if (child.getVisibility() == GONE) {
+                continue;
+            }
+
+            LayoutParams lp = (LayoutParams) child.getLayoutParams();
+            int x = (width - child.getMeasuredWidth()) / 2;
+            int y;
+            if (showAtCenter) {
+                y = (height / 2 - child.getMeasuredHeight()) / 2;
+            } else {
+                y = (height - child.getMeasuredHeight()) / 2;
+            }
+            child.layout(x, y, x + child.getMeasuredWidth(), y + child.getMeasuredHeight());
+        }
+        inLayout = false;
+    }
+
+    @Override
+    public void requestLayout() {
+        if (!inLayout) {
+            super.requestLayout();
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/ForegroundDetector.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/ForegroundDetector.java
index a1f4cf2f6..26323f5e9 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/ForegroundDetector.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/ForegroundDetector.java
@@ -8,6 +8,7 @@
 
 package org.telegram.ui.Components;
 
+import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.app.Application;
 import android.os.Build;
@@ -17,6 +18,7 @@
 
 import java.util.concurrent.CopyOnWriteArrayList;
 
+@SuppressLint("NewApi")
 public class ForegroundDetector implements Application.ActivityLifecycleCallbacks {
 
     public interface Listener {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/HorizontalListView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/HorizontalListView.java
deleted file mode 100644
index 973a775a5..000000000
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/HorizontalListView.java
+++ /dev/null
@@ -1,389 +0,0 @@
-/*
- * This is the source code of Telegram for Android v. 1.3.2.
- * It is licensed under GNU GPL v. 2 or later.
- * You should have received a copy of the license in this archive (see LICENSE).
- *
- * Copyright Nikolai Kudashov, 2013.
- */
-package org.telegram.ui.Components;
-
-import java.util.HashMap;
-import java.util.LinkedList;
-
-import android.annotation.SuppressLint;
-import android.content.Context;
-import android.database.DataSetObserver;
-import android.graphics.Rect;
-import android.util.AttributeSet;
-import android.view.GestureDetector;
-import android.view.GestureDetector.OnGestureListener;
-import android.view.MotionEvent;
-import android.view.View;
-import android.widget.AdapterView;
-import android.widget.ListAdapter;
-import android.widget.Scroller;
-
-public class HorizontalListView extends AdapterView<ListAdapter> {
-
-    public boolean mAlwaysOverrideTouch = true;
-    protected ListAdapter mAdapter;
-    private int mLeftViewIndex = -1;
-    private int mRightViewIndex = 0;
-    protected int mCurrentX;
-    protected int mNextX;
-    private int mMaxX = Integer.MAX_VALUE;
-    private int mDisplayOffset = 0;
-    protected Scroller mScroller;
-    private GestureDetector mGesture;
-    private HashMap<Integer, LinkedList<View>> mRemovedViewQueue = new HashMap<>();
-    private OnItemSelectedListener mOnItemSelected;
-    private OnItemClickListener mOnItemClicked;
-    private OnItemLongClickListener mOnItemLongClicked;
-    private boolean mDataChanged = false;
-
-    public HorizontalListView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        initView();
-    }
-
-    private synchronized void initView() {
-        mLeftViewIndex = -1;
-        mRightViewIndex = 0;
-        mDisplayOffset = 0;
-        mCurrentX = 0;
-        mNextX = 0;
-        mMaxX = Integer.MAX_VALUE;
-        mScroller = new Scroller(getContext());
-        mGesture = new GestureDetector(getContext(), mOnGesture);
-    }
-
-    @Override
-    public void setOnItemSelectedListener(AdapterView.OnItemSelectedListener listener) {
-        mOnItemSelected = listener;
-    }
-
-    @Override
-    public void setOnItemClickListener(AdapterView.OnItemClickListener listener) {
-        mOnItemClicked = listener;
-    }
-
-    @Override
-    public void setOnItemLongClickListener(AdapterView.OnItemLongClickListener listener) {
-        mOnItemLongClicked = listener;
-    }
-
-    private DataSetObserver mDataObserver = new DataSetObserver() {
-        @Override
-        public void onChanged() {
-            synchronized (HorizontalListView.this) {
-                mDataChanged = true;
-            }
-            invalidate();
-            requestLayout();
-        }
-
-        @Override
-        public void onInvalidated() {
-            reset();
-            invalidate();
-            requestLayout();
-        }
-    };
-
-    @Override
-    public ListAdapter getAdapter() {
-        return mAdapter;
-    }
-
-    @Override
-    public View getSelectedView() {
-
-        return null;
-    }
-
-    @Override
-    public void setSelection(int position) {
-
-    }
-
-    @Override
-    public void setAdapter(ListAdapter adapter) {
-        if (mAdapter != null && mDataObserver != null) {
-            mAdapter.unregisterDataSetObserver(mDataObserver);
-        }
-        mAdapter = adapter;
-        mAdapter.registerDataSetObserver(mDataObserver);
-        reset();
-    }
-
-    private synchronized void reset() {
-        initView();
-        mRemovedViewQueue.clear();
-        removeAllViewsInLayout();
-        requestLayout();
-    }
-
-    private void addAndMeasureChild(final View child, int viewPos) {
-        LayoutParams params = child.getLayoutParams();
-        if (params == null) {
-            params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutHelper.MATCH_PARENT);
-        }
-        addViewInLayout(child, viewPos, params, true);
-        child.measure(MeasureSpec.makeMeasureSpec(getWidth(), MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec(getHeight(), MeasureSpec.AT_MOST));
-    }
-
-
-    @SuppressLint("DrawAllocation")
-    @Override
-    protected synchronized void onLayout(boolean changed, int left, int top, int right, int bottom) {
-        super.onLayout(changed, left, top, right, bottom);
-
-        if (mAdapter == null) {
-            return;
-        }
-
-        if (mDataChanged) {
-            int oldCurrentX = mCurrentX;
-            initView();
-            removeAllViewsInLayout();
-            mNextX = oldCurrentX;
-            mDataChanged = false;
-        }
-
-        if (mScroller.computeScrollOffset()) {
-            mNextX = mScroller.getCurrX();
-        }
-
-        if (mNextX <= 0) {
-            mNextX = 0;
-            mScroller.forceFinished(true);
-        }
-        if (mNextX >= mMaxX) {
-            mNextX = mMaxX;
-            mScroller.forceFinished(true);
-        }
-
-        int dx = mCurrentX - mNextX;
-
-        removeNonVisibleItems(dx);
-        fillList(dx);
-        positionItems(dx);
-
-        mCurrentX = mNextX;
-
-        if (!mScroller.isFinished()) {
-            post(new Runnable() {
-                @Override
-                public void run() {
-                    requestLayout();
-                }
-            });
-        }
-    }
-
-    private void fillList(final int dx) {
-        int edge = 0;
-        View child = getChildAt(getChildCount() - 1);
-        if (child != null) {
-            edge = child.getRight();
-        }
-        fillListRight(edge, dx);
-
-        edge = 0;
-        child = getChildAt(0);
-        if (child != null) {
-            edge = child.getLeft();
-        }
-        fillListLeft(edge, dx);
-    }
-
-    private void fillListRight(int rightEdge, final int dx) {
-        while (rightEdge + dx < getWidth() && mRightViewIndex < mAdapter.getCount()) {
-
-            View v = null;
-            int type = mAdapter.getItemViewType(mRightViewIndex);
-            LinkedList<View> list = mRemovedViewQueue.get(type);
-            if (list != null) {
-                v = list.poll();
-            }
-            View child = mAdapter.getView(mRightViewIndex, v, this);
-            child.setTag(type);
-
-            addAndMeasureChild(child, -1);
-            rightEdge += child.getMeasuredWidth();
-            child.invalidate();
-
-            if (mRightViewIndex == mAdapter.getCount() - 1) {
-                mMaxX = mCurrentX + rightEdge - getWidth() + getPaddingLeft();
-            }
-
-            if (mMaxX < 0) {
-                mMaxX = 0;
-            }
-            mRightViewIndex++;
-        }
-
-    }
-
-    private void fillListLeft(int leftEdge, final int dx) {
-        while (leftEdge + dx > 0 && mLeftViewIndex >= 0) {
-            View v = null;
-            int type = mAdapter.getItemViewType(mLeftViewIndex);
-            LinkedList<View> list = mRemovedViewQueue.get(type);
-            if (list != null) {
-                v = list.poll();
-            }
-            View child = mAdapter.getView(mLeftViewIndex, v, this);
-            child.setTag(type);
-
-            addAndMeasureChild(child, 0);
-            leftEdge -= child.getMeasuredWidth();
-            mLeftViewIndex--;
-            mDisplayOffset -= child.getMeasuredWidth();
-        }
-    }
-
-    private void removeNonVisibleItems(final int dx) {
-        View child = getChildAt(0);
-        while (child != null && child.getRight() + dx <= 0) {
-            mDisplayOffset += child.getMeasuredWidth();
-
-            int type = (Integer) child.getTag();
-            LinkedList<View> list = mRemovedViewQueue.get(type);
-            if (list == null) {
-                list = new LinkedList<>();
-                mRemovedViewQueue.put(type, list);
-            }
-            list.add(child);
-
-            removeViewInLayout(child);
-            mLeftViewIndex++;
-            child = getChildAt(0);
-        }
-
-        child = getChildAt(getChildCount() - 1);
-        while (child != null && child.getLeft() + dx >= getWidth()) {
-            int type = (Integer) child.getTag();
-            LinkedList<View> list = mRemovedViewQueue.get(type);
-            if (list == null) {
-                list = new LinkedList<>();
-                mRemovedViewQueue.put(type, list);
-            }
-            list.add(child);
-
-            removeViewInLayout(child);
-            mRightViewIndex--;
-            child = getChildAt(getChildCount() - 1);
-        }
-    }
-
-    private void positionItems(final int dx) {
-        if (getChildCount() > 0) {
-            mDisplayOffset += dx;
-            int left = mDisplayOffset;
-            for (int i = 0; i < getChildCount(); i++) {
-                View child = getChildAt(i);
-                int childWidth = child.getMeasuredWidth();
-                child.layout(left + getPaddingLeft(), 0, left + childWidth + getPaddingLeft(), child.getMeasuredHeight());
-                left += childWidth + child.getPaddingRight();
-            }
-        }
-    }
-
-    public synchronized void scrollTo(int x) {
-        mScroller.startScroll(mNextX, 0, x - mNextX, 0);
-        requestLayout();
-    }
-
-    @Override
-    public boolean dispatchTouchEvent(MotionEvent ev) {
-        boolean handled = super.dispatchTouchEvent(ev);
-        handled |= mGesture.onTouchEvent(ev);
-        return handled;
-    }
-
-    @Override
-    public boolean onInterceptTouchEvent(MotionEvent ev) {
-        requestDisallowInterceptTouchEvent(true);
-        return super.onInterceptTouchEvent(ev);
-    }
-
-    protected boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
-        synchronized (HorizontalListView.this) {
-            mScroller.fling(mNextX, 0, (int) -velocityX, 0, 0, mMaxX, 0, 0);
-        }
-        requestLayout();
-
-        return true;
-    }
-
-    protected boolean onDown(MotionEvent e) {
-        mScroller.forceFinished(true);
-        return true;
-    }
-
-    private OnGestureListener mOnGesture = new GestureDetector.SimpleOnGestureListener() {
-
-        @Override
-        public boolean onDown(MotionEvent e) {
-            return HorizontalListView.this.onDown(e);
-        }
-
-        @Override
-        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
-            return HorizontalListView.this.onFling(e1, e2, velocityX, velocityY);
-        }
-
-        @Override
-        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
-            synchronized (HorizontalListView.this) {
-                mNextX += (int) distanceX;
-            }
-            requestLayout();
-            return true;
-        }
-
-        @Override
-        public boolean onSingleTapUp(MotionEvent e) {
-            for (int i = 0; i < getChildCount(); i++) {
-                View child = getChildAt(i);
-                if (isEventWithinView(e, child)) {
-                    if (mOnItemClicked != null) {
-                        mOnItemClicked.onItemClick(HorizontalListView.this, child, mLeftViewIndex + 1 + i, mAdapter.getItemId(mLeftViewIndex + 1 + i));
-                    }
-                    if (mOnItemSelected != null) {
-                        mOnItemSelected.onItemSelected(HorizontalListView.this, child, mLeftViewIndex + 1 + i, mAdapter.getItemId(mLeftViewIndex + 1 + i));
-                    }
-                    break;
-                }
-            }
-            return true;
-        }
-
-        @Override
-        public void onLongPress(MotionEvent e) {
-            int childCount = getChildCount();
-            for (int i = 0; i < childCount; i++) {
-                View child = getChildAt(i);
-                if (isEventWithinView(e, child)) {
-                    if (mOnItemLongClicked != null) {
-                        mOnItemLongClicked.onItemLongClick(HorizontalListView.this, child, mLeftViewIndex + 1 + i, mAdapter.getItemId(mLeftViewIndex + 1 + i));
-                    }
-                    break;
-                }
-            }
-        }
-
-        private boolean isEventWithinView(MotionEvent e, View child) {
-            Rect viewRect = new Rect();
-            int[] childPosition = new int[2];
-            child.getLocationOnScreen(childPosition);
-            int left = childPosition[0];
-            int right = left + child.getWidth();
-            int top = childPosition[1];
-            int bottom = top + child.getHeight();
-            viewRect.set(left, top, right, bottom);
-            return viewRect.contains((int) e.getRawX(), (int) e.getRawY());
-        }
-    };
-}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/LayoutHelper.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/LayoutHelper.java
index f449daf27..2446115da 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/LayoutHelper.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/LayoutHelper.java
@@ -23,7 +23,7 @@ private static int getSize(float size) {
         return (int) (size < 0 ? size : AndroidUtilities.dp(size));
     }
 
-    public static FrameLayout.LayoutParams createFrame(int width, int height, int gravity, float leftMargin, float topMargin, float rightMargin, float bottomMargin) {
+    public static FrameLayout.LayoutParams createFrame(int width, float height, int gravity, float leftMargin, float topMargin, float rightMargin, float bottomMargin) {
         FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(getSize(width), getSize(height), gravity);
         layoutParams.setMargins(AndroidUtilities.dp(leftMargin), AndroidUtilities.dp(topMargin), AndroidUtilities.dp(rightMargin), AndroidUtilities.dp(bottomMargin));
         return layoutParams;
@@ -33,7 +33,7 @@ private static int getSize(float size) {
         return new FrameLayout.LayoutParams(getSize(width), getSize(height), gravity);
     }
 
-    public static FrameLayout.LayoutParams createFrame(int width, int height) {
+    public static FrameLayout.LayoutParams createFrame(int width, float height) {
         return new FrameLayout.LayoutParams(getSize(width), getSize(height));
     }
 
@@ -87,6 +87,12 @@ private static int getSize(float size) {
         return layoutParams;
     }
 
+    public static LinearLayout.LayoutParams createLinear(int width, int height, float weight, int leftMargin, int topMargin, int rightMargin, int bottomMargin) {
+        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(getSize(width), getSize(height), weight);
+        layoutParams.setMargins(AndroidUtilities.dp(leftMargin), AndroidUtilities.dp(topMargin), AndroidUtilities.dp(rightMargin), AndroidUtilities.dp(bottomMargin));
+        return layoutParams;
+    }
+
     public static LinearLayout.LayoutParams createLinear(int width, int height, int gravity, int leftMargin, int topMargin, int rightMargin, int bottomMargin) {
         LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(getSize(width), getSize(height));
         layoutParams.setMargins(AndroidUtilities.dp(leftMargin), AndroidUtilities.dp(topMargin), AndroidUtilities.dp(rightMargin), AndroidUtilities.dp(bottomMargin));
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/PasscodeView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/PasscodeView.java
index b5898e18c..22f7a4326 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/PasscodeView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/PasscodeView.java
@@ -47,7 +47,6 @@
 import org.telegram.messenger.FileLog;
 import org.telegram.messenger.R;
 import org.telegram.messenger.UserConfig;
-import org.telegram.messenger.Utilities;
 import org.telegram.android.AnimationCompat.AnimatorListenerAdapterProxy;
 import org.telegram.android.AnimationCompat.AnimatorSetProxy;
 import org.telegram.android.AnimationCompat.ObjectAnimatorProxy;
@@ -675,55 +674,42 @@ public void onClick(View v) {
                     int key = KeyEvent.KEYCODE_DEL;
                     switch (tag) {
                         case 0:
-                            key = KeyEvent.KEYCODE_0;
                             passwordEditText2.appendCharacter("0");
                             break;
                         case 1:
-                            key = KeyEvent.KEYCODE_1;
                             passwordEditText2.appendCharacter("1");
                             break;
                         case 2:
-                            key = KeyEvent.KEYCODE_2;
                             passwordEditText2.appendCharacter("2");
                             break;
                         case 3:
-                            key = KeyEvent.KEYCODE_3;
                             passwordEditText2.appendCharacter("3");
                             break;
                         case 4:
-                            key = KeyEvent.KEYCODE_4;
                             passwordEditText2.appendCharacter("4");
                             break;
                         case 5:
-                            key = KeyEvent.KEYCODE_5;
                             passwordEditText2.appendCharacter("5");
                             break;
                         case 6:
-                            key = KeyEvent.KEYCODE_6;
                             passwordEditText2.appendCharacter("6");
                             break;
                         case 7:
-                            key = KeyEvent.KEYCODE_7;
                             passwordEditText2.appendCharacter("7");
                             break;
                         case 8:
-                            key = KeyEvent.KEYCODE_8;
                             passwordEditText2.appendCharacter("8");
                             break;
                         case 9:
-                            key = KeyEvent.KEYCODE_9;
                             passwordEditText2.appendCharacter("9");
                             break;
                         case 10:
-                            key = KeyEvent.KEYCODE_DEL;
                             passwordEditText2.eraseLastCharacter();
                             break;
                     }
                     if (passwordEditText2.lenght() == 4) {
                         processDone();
                     }
-                    //passwordEditText.dispatchKeyEvent(new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, key, 0));
-                    //passwordEditText.dispatchKeyEvent(new KeyEvent(0, 0, KeyEvent.ACTION_UP, key, 0));
                 }
             });
             numberFrameLayouts.add(frameLayout);
@@ -754,7 +740,7 @@ private void processDone() {
             onPasscodeError();
             return;
         }
-        if (!Utilities.MD5(password).equals(UserConfig.passcodeHash)) {
+        if (!UserConfig.checkPasscode(password)) {
             passwordEditText.setText("");
             passwordEditText2.eraseAllCharacters(true);
             onPasscodeError();
@@ -866,7 +852,6 @@ public void onShow() {
             backgroundDrawable = ApplicationLoader.getCachedWallpaper();
             if (backgroundDrawable != null) {
                 backgroundFrameLayout.setBackgroundColor(0xbf000000);
-                customTheme = true;
             } else {
                 backgroundFrameLayout.setBackgroundColor(0xff517c9e);
             }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoFilterView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoFilterView.java
index 319286ca5..ced235b6a 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoFilterView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoFilterView.java
@@ -8,6 +8,7 @@
 
 package org.telegram.ui.Components;
 
+import android.annotation.SuppressLint;
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
@@ -55,6 +56,7 @@
 import javax.microedition.khronos.opengles.GL;
 import javax.microedition.khronos.opengles.GL10;
 
+@SuppressLint("NewApi")
 public class PhotoFilterView extends FrameLayout {
 
     private boolean showOriginal;
@@ -1459,58 +1461,58 @@ public void valueChanged(Point centerPoint, float falloff, float size, float ang
         layoutParams.height = AndroidUtilities.dp(60);
         layoutParams.gravity = Gravity.LEFT | Gravity.TOP;
         recyclerListView.setLayoutParams(layoutParams);
-        recyclerListView.addOnItemTouchListener(new RecyclerListView.RecyclerListViewItemClickListener(context, new RecyclerListView.OnItemClickListener() {
+        recyclerListView.setOnItemClickListener(new RecyclerListView.OnItemClickListener() {
             @Override
-            public void onItemClick(View view, int i) {
-                selectedTool = i;
-                if (i == enhanceTool) {
+            public void onItemClick(View view, int position) {
+                selectedTool = position;
+                if (position == enhanceTool) {
                     previousValue = enhanceValue;
                     valueSeekBar.setMinMax(0, 100);
                     paramTextView.setText(LocaleController.getString("Enhance", R.string.Enhance));
-                } else if (i == highlightsTool) {
+                } else if (position == highlightsTool) {
                     previousValue = highlightsValue;
                     valueSeekBar.setMinMax(0, 100);
                     paramTextView.setText(LocaleController.getString("Highlights", R.string.Highlights));
-                } else if (i == contrastTool) {
+                } else if (position == contrastTool) {
                     previousValue = contrastValue;
                     valueSeekBar.setMinMax(-100, 100);
                     paramTextView.setText(LocaleController.getString("Contrast", R.string.Contrast));
-                } else if (i == exposureTool) {
+                } else if (position == exposureTool) {
                     previousValue = exposureValue;
                     valueSeekBar.setMinMax(-100, 100);
                     paramTextView.setText(LocaleController.getString("Exposure", R.string.Exposure));
-                } else if (i == warmthTool) {
+                } else if (position == warmthTool) {
                     previousValue = warmthValue;
                     valueSeekBar.setMinMax(-100, 100);
                     paramTextView.setText(LocaleController.getString("Warmth", R.string.Warmth));
-                } else if (i == saturationTool) {
+                } else if (position == saturationTool) {
                     previousValue = saturationValue;
                     valueSeekBar.setMinMax(-100, 100);
                     paramTextView.setText(LocaleController.getString("Saturation", R.string.Saturation));
-                } else if (i == vignetteTool) {
+                } else if (position == vignetteTool) {
                     previousValue = vignetteValue;
                     valueSeekBar.setMinMax(0, 100);
                     paramTextView.setText(LocaleController.getString("Vignette", R.string.Vignette));
-                } else if (i == shadowsTool) {
+                } else if (position == shadowsTool) {
                     previousValue = shadowsValue;
                     valueSeekBar.setMinMax(0, 100);
                     paramTextView.setText(LocaleController.getString("Shadows", R.string.Shadows));
-                } else if (i == grainTool) {
+                } else if (position == grainTool) {
                     previousValue = grainValue;
                     valueSeekBar.setMinMax(0, 100);
                     paramTextView.setText(LocaleController.getString("Grain", R.string.Grain));
-                } else if (i == sharpenTool) {
+                } else if (position == sharpenTool) {
                     previousValue = sharpenValue;
                     valueSeekBar.setMinMax(0, 100);
                     paramTextView.setText(LocaleController.getString("Sharpen", R.string.Sharpen));
-                } else if (i == blurTool) {
+                } else if (position == blurTool) {
                     previousValue = blurType;
                 }
                 valueSeekBar.setProgress((int) previousValue, false);
                 updateValueTextView();
                 switchToOrFromEditMode();
             }
-        }));
+        });
 
         editView = new FrameLayout(context);
         editView.setVisibility(GONE);
@@ -1925,8 +1927,8 @@ private void fixLayout(int viewWidth, int viewHeight) {
         viewWidth -= AndroidUtilities.dp(28);
         viewHeight -= AndroidUtilities.dp(14 + 140);
 
-        float bitmapW = bitmapToEdit.getWidth();
-        float bitmapH = bitmapToEdit.getHeight();
+        float bitmapW;
+        float bitmapH;
         if (orientation == 90 || orientation == 270) {
             bitmapW = bitmapToEdit.getHeight();
             bitmapH = bitmapToEdit.getWidth();
@@ -2020,7 +2022,7 @@ private float getSaturationValue() {
         if (parameterValue > 0) {
             parameterValue *= 1.05f;
         }
-        return parameterValue += 1;
+        return parameterValue + 1;
     }
 
     public FrameLayout getToolsView() {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerExListView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerExListView.java
deleted file mode 100644
index 09e818588..000000000
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerExListView.java
+++ /dev/null
@@ -1,292 +0,0 @@
-/*
- * This is the source code of Telegram for Android v. 2.x
- * It is licensed under GNU GPL v. 2 or later.
- * You should have received a copy of the license in this archive (see LICENSE).
- *
- * Copyright Nikolai Kudashov, 2013-2015.
- */
-
-package org.telegram.ui.Components;
-
-import android.content.Context;
-import android.util.AttributeSet;
-import android.view.GestureDetector;
-import android.view.HapticFeedbackConstants;
-import android.view.MotionEvent;
-import android.view.SoundEffectConstants;
-import android.view.View;
-import android.view.ViewConfiguration;
-
-import org.telegram.android.AndroidUtilities;
-import org.telegram.android.support.widget.RecyclerView;
-
-public class RecyclerExListView extends RecyclerView {
-
-    private OnItemClickListener onItemClickListener;
-    private OnItemLongClickListener onItemLongClickListener;
-    private RecyclerView.OnScrollListener onScrollListener;
-    private OnInterceptTouchListener onInterceptTouchListener;
-    private View emptyView;
-    private Runnable selectChildRunnable;
-
-    private GestureDetector mGestureDetector;
-    private View currentChildView;
-    private int currentChildPosition;
-    private boolean interceptedByChild;
-    private boolean wasPressed;
-
-    public interface OnItemClickListener {
-        void onItemClick(View view, int position);
-    }
-
-    public interface OnItemLongClickListener {
-        void onItemClick(View view, int position);
-    }
-
-    public interface OnInterceptTouchListener {
-        boolean onInterceptTouchEvent(MotionEvent event);
-    }
-
-    private class RecyclerListViewItemClickListener implements RecyclerView.OnItemTouchListener {
-
-        public RecyclerListViewItemClickListener(Context context) {
-            mGestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() {
-                @Override
-                public boolean onSingleTapUp(MotionEvent e) {
-                    if (currentChildView != null && onItemClickListener != null) {
-                        currentChildView.playSoundEffect(SoundEffectConstants.CLICK);
-                        onItemClickListener.onItemClick(currentChildView, currentChildPosition);
-                        if (selectChildRunnable != null) {
-                            currentChildView.setPressed(true);
-                            final View view = currentChildView;
-                            AndroidUtilities.runOnUIThread(new Runnable() {
-                                @Override
-                                public void run() {
-                                    if (view != null) {
-                                        view.setPressed(false);
-                                    }
-                                }
-                            }, ViewConfiguration.getPressedStateDuration());
-                            AndroidUtilities.cancelRunOnUIThread(selectChildRunnable);
-                            selectChildRunnable = null;
-                            currentChildView = null;
-                            interceptedByChild = false;
-                        }
-                    }
-                    return true;
-                }
-
-                @Override
-                public void onLongPress(MotionEvent e) {
-                    if (currentChildView != null && onItemLongClickListener != null) {
-                        currentChildView.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
-                        onItemLongClickListener.onItemClick(currentChildView, currentChildPosition);
-                    }
-                }
-            });
-        }
-
-        @Override
-        public boolean onInterceptTouchEvent(RecyclerView view, MotionEvent e) {
-            int action = e.getActionMasked();
-            boolean isScrollIdle = RecyclerExListView.this.getScrollState() == RecyclerExListView.SCROLL_STATE_IDLE;
-
-            if ((action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_DOWN) && currentChildView == null && isScrollIdle) {
-                currentChildView = view.findChildViewUnder(e.getX(), e.getY());
-                currentChildPosition = -1;
-                if (currentChildView != null) {
-                    currentChildPosition = view.getChildPosition(currentChildView);
-                    MotionEvent childEvent = MotionEvent.obtain(0, 0, e.getActionMasked(), e.getX() - currentChildView.getLeft(), e.getY() - currentChildView.getTop(), 0);
-                    if (currentChildView.onTouchEvent(childEvent)) {
-                        interceptedByChild = true;
-                    }
-                    childEvent.recycle();
-                }
-            }
-
-            if (currentChildView != null && !interceptedByChild) {
-                mGestureDetector.onTouchEvent(e);
-            }
-
-            if (action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_DOWN) {
-                if (!interceptedByChild && currentChildView != null) {
-                    selectChildRunnable = new Runnable() {
-                        @Override
-                        public void run() {
-                            if (selectChildRunnable != null && currentChildView != null) {
-                                currentChildView.setPressed(true);
-                                selectChildRunnable = null;
-                            }
-                        }
-                    };
-                    AndroidUtilities.runOnUIThread(selectChildRunnable, ViewConfiguration.getTapTimeout());
-                }
-            } else if (currentChildView != null && (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_CANCEL || !isScrollIdle)) {
-                if (selectChildRunnable != null) {
-                    AndroidUtilities.cancelRunOnUIThread(selectChildRunnable);
-                    selectChildRunnable = null;
-                }
-                currentChildView.setPressed(false);
-                currentChildView = null;
-                interceptedByChild = false;
-            }
-            return false;
-        }
-
-        @Override
-        public void onTouchEvent(RecyclerView view, MotionEvent e) {
-
-        }
-    }
-
-    private AdapterDataObserver observer = new AdapterDataObserver() {
-        @Override
-        public void onChanged() {
-            checkIfEmpty();
-        }
-
-        @Override
-        public void onItemRangeInserted(int positionStart, int itemCount) {
-            checkIfEmpty();
-        }
-
-        @Override
-        public void onItemRangeRemoved(int positionStart, int itemCount) {
-            checkIfEmpty();
-        }
-    };
-
-    public void init(Context context) {
-        super.setOnScrollListener(new OnScrollListener() {
-            @Override
-            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
-                if (newState != SCROLL_STATE_IDLE && currentChildView != null) {
-                    if (selectChildRunnable != null) {
-                        AndroidUtilities.cancelRunOnUIThread(selectChildRunnable);
-                        selectChildRunnable = null;
-                    }
-                    MotionEvent event = MotionEvent.obtain(0, 0, MotionEvent.ACTION_CANCEL, 0, 0, 0);
-                    mGestureDetector.onTouchEvent(event);
-                    currentChildView.onTouchEvent(event);
-                    event.recycle();
-                    currentChildView.setPressed(false);
-                    currentChildView = null;
-                    interceptedByChild = false;
-                }
-                if (onScrollListener != null) {
-                    onScrollListener.onScrollStateChanged(recyclerView, newState);
-                }
-            }
-
-            @Override
-            public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
-                if (onScrollListener != null) {
-                    onScrollListener.onScrolled(recyclerView, dx, dy);
-                }
-            }
-        });
-        addOnItemTouchListener(new RecyclerListViewItemClickListener(context));
-    }
-
-    public RecyclerExListView(Context context) {
-        super(context);
-
-        /*setVerticalScrollBarEnabled(true);
-        try {
-            TypedArray a = context.getTheme().obtainStyledAttributes(new int[0]);
-            Method initializeScrollbars = android.view.View.class.getDeclaredMethod("initializeScrollbars", TypedArray.class);
-            initializeScrollbars.invoke(this, a);
-            a.recycle();
-        } catch (Throwable e) {
-            FileLog.e("tmessages", e);
-        }*/
-
-        init(context);
-    }
-
-    public RecyclerExListView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        init(context);
-    }
-
-    public RecyclerExListView(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-        init(context);
-    }
-
-    public void setOnItemClickListener(OnItemClickListener listener) {
-        onItemClickListener = listener;
-    }
-
-    public void setOnItemLongClickListener(OnItemLongClickListener listener) {
-        onItemLongClickListener = listener;
-    }
-
-    public void setEmptyView(View view) {
-        if (emptyView == view) {
-            return;
-        }
-        emptyView = view;
-        checkIfEmpty();
-    }
-
-    public View getEmptyView() {
-        return emptyView;
-    }
-
-    public void invalidateViews() {
-        int count = getChildCount();
-        for (int a = 0; a < count; a++) {
-            getChildAt(a).invalidate();
-        }
-    }
-
-    @Override
-    public boolean onInterceptTouchEvent(MotionEvent e) {
-        return onInterceptTouchListener != null && onInterceptTouchListener.onInterceptTouchEvent(e) || super.onInterceptTouchEvent(e);
-    }
-
-    private void checkIfEmpty() {
-        if (emptyView == null || getAdapter() == null) {
-            return;
-        }
-        boolean emptyViewVisible = getAdapter().getItemCount() == 0;
-        emptyView.setVisibility(emptyViewVisible ? VISIBLE : INVISIBLE);
-        setVisibility(emptyViewVisible ? INVISIBLE : VISIBLE);
-    }
-
-    @Override
-    public void setOnScrollListener(OnScrollListener listener) {
-        onScrollListener = listener;
-    }
-
-    public void setOnInterceptTouchListener(OnInterceptTouchListener listener) {
-        onInterceptTouchListener = listener;
-    }
-
-    @Override
-    public void setAdapter(Adapter adapter) {
-        final Adapter oldAdapter = getAdapter();
-        if (oldAdapter != null) {
-            oldAdapter.unregisterAdapterDataObserver(observer);
-        }
-        super.setAdapter(adapter);
-        if (adapter != null) {
-            adapter.registerAdapterDataObserver(observer);
-        }
-        checkIfEmpty();
-    }
-
-    @Override
-    public void stopScroll() {
-        try {
-            super.stopScroll();
-        } catch (NullPointerException exception) {
-            /**
-             *  The mLayout has been disposed of before the
-             *  RecyclerView and this stops the application
-             *  from crashing.
-             */
-        }
-    }
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerListView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerListView.java
index 3f1e8f9ba..55a75b2f3 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerListView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerListView.java
@@ -1,62 +1,158 @@
 /*
- * This is the source code of Telegram for Android v. 2.0.x.
+ * This is the source code of Telegram for Android v. 2.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
 
 import android.content.Context;
-import org.telegram.android.support.widget.RecyclerView;
-
-import android.util.AttributeSet;
+import android.content.res.TypedArray;
 import android.view.GestureDetector;
+import android.view.HapticFeedbackConstants;
 import android.view.MotionEvent;
+import android.view.SoundEffectConstants;
 import android.view.View;
+import android.view.ViewConfiguration;
 
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.support.widget.RecyclerView;
 import org.telegram.messenger.FileLog;
 
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+
 public class RecyclerListView extends RecyclerView {
 
+    private OnItemClickListener onItemClickListener;
+    private OnItemLongClickListener onItemLongClickListener;
+    private RecyclerView.OnScrollListener onScrollListener;
+    private OnInterceptTouchListener onInterceptTouchListener;
+    private View emptyView;
+    private Runnable selectChildRunnable;
+
+    private GestureDetector mGestureDetector;
+    private View currentChildView;
+    private int currentChildPosition;
+    private boolean interceptedByChild;
+    private boolean wasPressed;
+    private boolean disallowInterceptTouchEvents;
+    private boolean instantClick;
+
+    private static int[] attributes;
+    private static boolean gotAttributes;
+
     public interface OnItemClickListener {
         void onItemClick(View view, int position);
     }
 
-    public static class RecyclerListViewItemClickListener implements RecyclerView.OnItemTouchListener {
-        private OnItemClickListener mListener;
+    public interface OnItemLongClickListener {
+        void onItemClick(View view, int position);
+    }
+
+    public interface OnInterceptTouchListener {
+        boolean onInterceptTouchEvent(MotionEvent event);
+    }
 
-        GestureDetector mGestureDetector;
+    private class RecyclerListViewItemClickListener implements RecyclerView.OnItemTouchListener {
 
-        public RecyclerListViewItemClickListener(Context context, OnItemClickListener listener) {
-            mListener = listener;
+        public RecyclerListViewItemClickListener(Context context) {
             mGestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() {
                 @Override
                 public boolean onSingleTapUp(MotionEvent e) {
+                    if (currentChildView != null && onItemClickListener != null) {
+                        currentChildView.setPressed(true);
+                        final View view = currentChildView;
+                        if (instantClick) {
+                            view.playSoundEffect(SoundEffectConstants.CLICK);
+                            onItemClickListener.onItemClick(view, currentChildPosition);
+                        }
+                        AndroidUtilities.runOnUIThread(new Runnable() {
+                            @Override
+                            public void run() {
+                                if (view != null) {
+                                    view.setPressed(false);
+                                    if (!instantClick) {
+                                        view.playSoundEffect(SoundEffectConstants.CLICK);
+                                        if (onItemClickListener != null) {
+                                            onItemClickListener.onItemClick(view, currentChildPosition);
+                                        }
+                                    }
+                                }
+                            }
+                        }, ViewConfiguration.getPressedStateDuration());
+
+                        if (selectChildRunnable != null) {
+                            AndroidUtilities.cancelRunOnUIThread(selectChildRunnable);
+                            selectChildRunnable = null;
+                            currentChildView = null;
+                            interceptedByChild = false;
+                        }
+                    }
                     return true;
                 }
+
+                @Override
+                public void onLongPress(MotionEvent e) {
+                    if (currentChildView != null && onItemLongClickListener != null) {
+                        currentChildView.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
+                        onItemLongClickListener.onItemClick(currentChildView, currentChildPosition);
+                    }
+                }
             });
         }
 
         @Override
         public boolean onInterceptTouchEvent(RecyclerView view, MotionEvent e) {
-            View childView = view.findChildViewUnder(e.getX(), e.getY());
-            if (childView != null) {
-                if (mListener != null && mGestureDetector.onTouchEvent(e)) {
-                    mListener.onItemClick(childView, view.getChildPosition(childView));
+            int action = e.getActionMasked();
+            boolean isScrollIdle = RecyclerListView.this.getScrollState() == RecyclerListView.SCROLL_STATE_IDLE;
+
+            if ((action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_DOWN) && currentChildView == null && isScrollIdle) {
+                currentChildView = view.findChildViewUnder(e.getX(), e.getY());
+                currentChildPosition = -1;
+                if (currentChildView != null) {
+                    currentChildPosition = view.getChildPosition(currentChildView);
+                    MotionEvent childEvent = MotionEvent.obtain(0, 0, e.getActionMasked(), e.getX() - currentChildView.getLeft(), e.getY() - currentChildView.getTop(), 0);
+                    if (currentChildView.onTouchEvent(childEvent)) {
+                        interceptedByChild = true;
+                    }
+                    childEvent.recycle();
                 }
-                /*int action = e.getAction();
-                if (action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_MOVE) {
-                    childView.setPressed(true);
-                } else if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {
-                    childView.setPressed(false);
-                }*/
-            } else {
-                /*int count = view.getChildCount();
-                for (int a = 0; a < count; a++) {
-                    view.getChildAt(a).setPressed(false);
-                }*/
+            }
+
+            if (currentChildView != null && !interceptedByChild) {
+                try {
+                    if (e != null) {
+                        mGestureDetector.onTouchEvent(e);
+                    }
+                } catch (Exception ev) {
+                    FileLog.e("tmessages", ev);
+                }
+            }
+
+            if (action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_DOWN) {
+                if (!interceptedByChild && currentChildView != null) {
+                    selectChildRunnable = new Runnable() {
+                        @Override
+                        public void run() {
+                            if (selectChildRunnable != null && currentChildView != null) {
+                                currentChildView.setPressed(true);
+                                selectChildRunnable = null;
+                            }
+                        }
+                    };
+                    AndroidUtilities.runOnUIThread(selectChildRunnable, ViewConfiguration.getTapTimeout());
+                }
+            } else if (currentChildView != null && (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_CANCEL || !isScrollIdle)) {
+                if (selectChildRunnable != null) {
+                    AndroidUtilities.cancelRunOnUIThread(selectChildRunnable);
+                    selectChildRunnable = null;
+                }
+                currentChildView.setPressed(false);
+                currentChildView = null;
+                interceptedByChild = false;
             }
             return false;
         }
@@ -67,31 +163,165 @@ public void onTouchEvent(RecyclerView view, MotionEvent e) {
         }
     }
 
+    private AdapterDataObserver observer = new AdapterDataObserver() {
+        @Override
+        public void onChanged() {
+            checkIfEmpty();
+        }
+
+        @Override
+        public void onItemRangeInserted(int positionStart, int itemCount) {
+            checkIfEmpty();
+        }
+
+        @Override
+        public void onItemRangeRemoved(int positionStart, int itemCount) {
+            checkIfEmpty();
+        }
+    };
+
+    public int[] getResourceDeclareStyleableIntArray(String packageName, String name) {
+        try {
+            Field f = Class.forName(packageName + ".R$styleable").getField(name);
+            if (f != null) {
+                return (int[]) f.get(null);
+            }
+        } catch (Throwable t) {
+            //ignore
+        }
+        return null;
+    }
+
     public RecyclerListView(Context context) {
         super(context);
+
+        try {
+            if (!gotAttributes) {
+                attributes = getResourceDeclareStyleableIntArray("com.android.internal", "View");
+                gotAttributes = true;
+            }
+            TypedArray a = context.getTheme().obtainStyledAttributes(attributes);
+            Method initializeScrollbars = android.view.View.class.getDeclaredMethod("initializeScrollbars", TypedArray.class);
+            initializeScrollbars.invoke(this, a);
+            a.recycle();
+        } catch (Throwable e) {
+            FileLog.e("tmessages", e);
+        }
+
+        super.setOnScrollListener(new OnScrollListener() {
+            @Override
+            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
+                if (newState != SCROLL_STATE_IDLE && currentChildView != null) {
+                    if (selectChildRunnable != null) {
+                        AndroidUtilities.cancelRunOnUIThread(selectChildRunnable);
+                        selectChildRunnable = null;
+                    }
+                    MotionEvent event = MotionEvent.obtain(0, 0, MotionEvent.ACTION_CANCEL, 0, 0, 0);
+                    try {
+                        mGestureDetector.onTouchEvent(event);
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
+                    }
+                    currentChildView.onTouchEvent(event);
+                    event.recycle();
+                    currentChildView.setPressed(false);
+                    currentChildView = null;
+                    interceptedByChild = false;
+                }
+                if (onScrollListener != null) {
+                    onScrollListener.onScrollStateChanged(recyclerView, newState);
+                }
+            }
+
+            @Override
+            public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
+                if (onScrollListener != null) {
+                    onScrollListener.onScrolled(recyclerView, dx, dy);
+                }
+            }
+        });
+        addOnItemTouchListener(new RecyclerListViewItemClickListener(context));
+    }
+
+    @Override
+    public void setVerticalScrollBarEnabled(boolean verticalScrollBarEnabled) {
+        if (attributes != null) {
+            super.setVerticalScrollBarEnabled(verticalScrollBarEnabled);
+        }
+    }
+
+    public void setOnItemClickListener(OnItemClickListener listener) {
+        onItemClickListener = listener;
+    }
+
+    public void setOnItemLongClickListener(OnItemLongClickListener listener) {
+        onItemLongClickListener = listener;
+    }
+
+    public void setEmptyView(View view) {
+        if (emptyView == view) {
+            return;
+        }
+        emptyView = view;
+        checkIfEmpty();
     }
 
-    public RecyclerListView(Context context, AttributeSet attrs) {
-        super(context, attrs);
+    public View getEmptyView() {
+        return emptyView;
     }
 
-    public RecyclerListView(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
+    public void invalidateViews() {
+        int count = getChildCount();
+        for (int a = 0; a < count; a++) {
+            getChildAt(a).invalidate();
+        }
     }
 
     @Override
     public boolean onInterceptTouchEvent(MotionEvent e) {
-        requestDisallowInterceptTouchEvent(true);
-        return super.onInterceptTouchEvent(e);
+        if (disallowInterceptTouchEvents) {
+            requestDisallowInterceptTouchEvent(true);
+        }
+        return onInterceptTouchListener != null && onInterceptTouchListener.onInterceptTouchEvent(e) || super.onInterceptTouchEvent(e);
+    }
+
+    private void checkIfEmpty() {
+        if (emptyView == null || getAdapter() == null) {
+            return;
+        }
+        boolean emptyViewVisible = getAdapter().getItemCount() == 0;
+        emptyView.setVisibility(emptyViewVisible ? VISIBLE : INVISIBLE);
+        setVisibility(emptyViewVisible ? INVISIBLE : VISIBLE);
     }
 
     @Override
-    protected void onLayout(boolean changed, int l, int t, int r, int b) {
-        try {
-            super.onLayout(changed, l, t, r, b);
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
+    public void setOnScrollListener(OnScrollListener listener) {
+        onScrollListener = listener;
+    }
+
+    public void setOnInterceptTouchListener(OnInterceptTouchListener listener) {
+        onInterceptTouchListener = listener;
+    }
+
+    public void setInstantClick(boolean value) {
+        instantClick = value;
+    }
+
+    public void setDisallowInterceptTouchEvents(boolean value) {
+        disallowInterceptTouchEvents = value;
+    }
+
+    @Override
+    public void setAdapter(Adapter adapter) {
+        final Adapter oldAdapter = getAdapter();
+        if (oldAdapter != null) {
+            oldAdapter.unregisterAdapterDataObserver(observer);
+        }
+        super.setAdapter(adapter);
+        if (adapter != null) {
+            adapter.registerAdapterDataObserver(observer);
         }
+        checkIfEmpty();
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/SizeNotifierFrameLayout.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/SizeNotifierFrameLayout.java
new file mode 100644
index 000000000..864e9e1ea
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/SizeNotifierFrameLayout.java
@@ -0,0 +1,111 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Rect;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.view.View;
+import android.widget.FrameLayout;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.messenger.FileLog;
+
+public class SizeNotifierFrameLayout extends FrameLayout {
+
+    private Rect rect = new Rect();
+    private Drawable backgroundDrawable;
+    private int keyboardHeight;
+    private SizeNotifierRelativeLayout.SizeNotifierRelativeLayoutDelegate delegate;
+
+    public SizeNotifierFrameLayout(Context context) {
+        super(context);
+        setWillNotDraw(false);
+    }
+
+    public SizeNotifierFrameLayout(Context context, android.util.AttributeSet attrs) {
+        super(context, attrs);
+        setWillNotDraw(false);
+    }
+
+    public SizeNotifierFrameLayout(Context context, android.util.AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        setWillNotDraw(false);
+    }
+
+    public void setBackgroundImage(int resourceId) {
+        try {
+            backgroundDrawable = getResources().getDrawable(resourceId);
+        } catch (Throwable e) {
+            FileLog.e("tmessages", e);
+        }
+    }
+
+    public void setBackgroundImage(Drawable bitmap) {
+        backgroundDrawable = bitmap;
+    }
+
+    public Drawable getBackgroundImage() {
+        return backgroundDrawable;
+    }
+
+    public void setDelegate(SizeNotifierRelativeLayout.SizeNotifierRelativeLayoutDelegate delegate) {
+        this.delegate = delegate;
+    }
+
+    @SuppressLint("DrawAllocation")
+    @Override
+    protected void onLayout(boolean changed, int l, int t, int r, int b) {
+        super.onLayout(changed, l, t, r, b);
+        notifyHeightChanged();
+    }
+
+    public void notifyHeightChanged() {
+        if (delegate != null) {
+            View rootView = this.getRootView();
+            int usableViewHeight = rootView.getHeight() - AndroidUtilities.statusBarHeight - AndroidUtilities.getViewInset(rootView);
+            this.getWindowVisibleDisplayFrame(rect);
+            keyboardHeight = usableViewHeight - (rect.bottom - rect.top);
+            final boolean isWidthGreater = AndroidUtilities.displaySize.x > AndroidUtilities.displaySize.y;
+            post(new Runnable() {
+                @Override
+                public void run() {
+                    if (delegate != null) {
+                        delegate.onSizeChanged(keyboardHeight, isWidthGreater);
+                    }
+                }
+            });
+        }
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        if (backgroundDrawable != null) {
+            if (backgroundDrawable instanceof ColorDrawable) {
+                backgroundDrawable.setBounds(0, 0, getMeasuredWidth(), getMeasuredHeight());
+                backgroundDrawable.draw(canvas);
+            } else {
+                float scaleX = (float) getMeasuredWidth() / (float) backgroundDrawable.getIntrinsicWidth();
+                float scaleY = (float) (getMeasuredHeight() + keyboardHeight) / (float) backgroundDrawable.getIntrinsicHeight();
+                float scale = scaleX < scaleY ? scaleY : scaleX;
+                int width = (int) Math.ceil(backgroundDrawable.getIntrinsicWidth() * scale);
+                int height = (int) Math.ceil(backgroundDrawable.getIntrinsicHeight() * scale);
+                int x = (getMeasuredWidth() - width) / 2;
+                int y = (getMeasuredHeight() - height + keyboardHeight) / 2;
+                backgroundDrawable.setBounds(x, y, x + width, y + height);
+                backgroundDrawable.draw(canvas);
+            }
+        } else {
+            super.onDraw(canvas);
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/StaticLayoutEx.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/StaticLayoutEx.java
index d904f7c00..f918c1b3c 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/StaticLayoutEx.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/StaticLayoutEx.java
@@ -109,7 +109,13 @@ public static StaticLayout createStaticLayout(CharSequence source, int bufstart,
                 if (layout.getLineCount() <= maxLines) {
                     return layout;
                 } else {
-                    int off = layout.getOffsetForHorizontal(maxLines - 1, layout.getLineWidth(maxLines - 1));
+                    int off;
+                    float left = layout.getLineLeft(maxLines - 1);
+                    if (left != 0) {
+                        off = layout.getOffsetForHorizontal(maxLines - 1, left);
+                    } else {
+                        off = layout.getOffsetForHorizontal(maxLines - 1, layout.getLineWidth(maxLines - 1));
+                    }
                     SpannableStringBuilder stringBuilder = new SpannableStringBuilder(source.subSequence(0, Math.max(0, off - 1)));
                     stringBuilder.append("\u2026");
                     return new StaticLayout(stringBuilder, paint, outerWidth, align, spacingMult, spacingAdd, includePad);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/StickersAlert.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/StickersAlert.java
new file mode 100644
index 000000000..49ace5b72
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/StickersAlert.java
@@ -0,0 +1,138 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.database.DataSetObserver;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.BaseAdapter;
+import android.widget.FrameLayout;
+import android.widget.GridView;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.LocaleController;
+import org.telegram.android.NotificationCenter;
+import org.telegram.messenger.R;
+import org.telegram.messenger.TLRPC;
+import org.telegram.ui.Cells.StickerEmojiCell;
+
+import java.util.ArrayList;
+
+public class StickersAlert extends AlertDialog implements NotificationCenter.NotificationCenterDelegate {
+
+    private ArrayList<TLRPC.Document> stickers;
+    private GridView gridView;
+
+    public StickersAlert(Context context, TLRPC.TL_stickerSet set, ArrayList<TLRPC.Document> arrayList) {
+        super(context);
+        stickers = arrayList;
+
+        FrameLayout container = new FrameLayout(context) {
+            @Override
+            protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+                super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec((int) Math.min(Math.ceil(stickers.size() / 4.0f) * AndroidUtilities.dp(82), AndroidUtilities.displaySize.y / 5 * 3), MeasureSpec.EXACTLY));
+            }
+        };
+        setView(container, AndroidUtilities.dp(16), 0, AndroidUtilities.dp(16), 0);
+
+        gridView = new GridView(context);
+        gridView.setNumColumns(4);
+        gridView.setAdapter(new GridAdapter(context));
+        gridView.setVerticalScrollBarEnabled(false);
+        container.addView(gridView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
+
+        if (set.id == -1) {
+            setTitle(LocaleController.getString("GeniusStickerPackName", R.string.GeniusStickerPackName));
+        } else {
+            setTitle(set.title);
+        }
+
+        NotificationCenter.getInstance().addObserver(this, NotificationCenter.emojiDidLoaded);
+
+        setOnShowListener(new OnShowListener() {
+            @Override
+            public void onShow(DialogInterface arg0) {
+                if (getButton(AlertDialog.BUTTON_NEUTRAL) != null) {
+                    getButton(AlertDialog.BUTTON_NEUTRAL).setTextColor(0xffcd5a5a);
+                }
+                if (getButton(AlertDialog.BUTTON_POSITIVE) != null) {
+                    getButton(AlertDialog.BUTTON_POSITIVE).setTextColor(0xff37a919);
+                }
+            }
+        });
+    }
+
+    @Override
+    public void dismiss() {
+        super.dismiss();
+        NotificationCenter.getInstance().removeObserver(this, NotificationCenter.emojiDidLoaded);
+    }
+
+    @Override
+    public void didReceivedNotification(int id, Object... args) {
+        if (id == NotificationCenter.emojiDidLoaded) {
+            if (gridView != null) {
+                gridView.invalidateViews();
+            }
+        }
+    }
+
+    private class GridAdapter extends BaseAdapter {
+
+        Context context;
+
+        public GridAdapter(Context context) {
+            this.context = context;
+        }
+
+        public int getCount() {
+            return stickers.size();
+        }
+
+        public Object getItem(int i) {
+            return stickers.get(i);
+        }
+
+        public long getItemId(int i) {
+            return stickers.get(i).id;
+        }
+
+        @Override
+        public boolean areAllItemsEnabled() {
+            return false;
+        }
+
+        @Override
+        public boolean isEnabled(int position) {
+            return false;
+        }
+
+        public View getView(int i, View view, ViewGroup viewGroup) {
+            if (view == null) {
+                view = new StickerEmojiCell(context) {
+                    public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+                        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(82), MeasureSpec.EXACTLY));
+                    }
+                };
+            }
+            ((StickerEmojiCell) view).setSticker(stickers.get(i), true);
+            return view;
+        }
+
+        @Override
+        public void unregisterDataSetObserver(DataSetObserver observer) {
+            if (observer != null) {
+                super.unregisterDataSetObserver(observer);
+            }
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanNoUnderlineBold.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanNoUnderlineBold.java
new file mode 100644
index 000000000..42f98f0e8
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanNoUnderlineBold.java
@@ -0,0 +1,26 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.text.TextPaint;
+
+import org.telegram.android.AndroidUtilities;
+
+public class URLSpanNoUnderlineBold extends URLSpanNoUnderline {
+    public URLSpanNoUnderlineBold(String url) {
+        super(url);
+    }
+
+    @Override
+    public void updateDrawState(TextPaint ds) {
+        super.updateDrawState(ds);
+        ds.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
+        ds.setUnderlineText(false);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/WebFrameLayout.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/WebFrameLayout.java
new file mode 100644
index 000000000..7d597cce6
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/WebFrameLayout.java
@@ -0,0 +1,232 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Build;
+import android.provider.Browser;
+import android.text.TextUtils;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.View;
+import android.webkit.CookieManager;
+import android.webkit.WebChromeClient;
+import android.webkit.WebSettings;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+import android.widget.FrameLayout;
+import android.widget.LinearLayout;
+import android.widget.ProgressBar;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.LocaleController;
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.R;
+import org.telegram.ui.ActionBar.BottomSheet;
+
+import java.util.HashMap;
+
+public class WebFrameLayout extends FrameLayout {
+
+    private WebView webView;
+    private BottomSheet dialog;
+    private View customView;
+    private FrameLayout fullscreenVideoContainer;
+    private WebChromeClient.CustomViewCallback customViewCallback;
+    private ProgressBar progressBar;
+
+    private int width;
+    private int height;
+    private String openUrl;
+
+    @SuppressLint("SetJavaScriptEnabled")
+    public WebFrameLayout(Context context, BottomSheet parentDialog, String title, String originalUrl, final String url, int w, int h) {
+        super(context);
+
+        openUrl = originalUrl;
+        width = w;
+        height = h;
+        dialog = parentDialog;
+
+        fullscreenVideoContainer = new FrameLayout(context);
+        fullscreenVideoContainer.setBackgroundColor(0xff000000);
+        dialog.getContainer().addView(fullscreenVideoContainer, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
+        fullscreenVideoContainer.setVisibility(INVISIBLE);
+
+        LinearLayout linearLayout = new LinearLayout(context);
+        linearLayout.setOrientation(LinearLayout.HORIZONTAL);
+        addView(linearLayout, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 32, Gravity.LEFT | Gravity.TOP));
+
+        TextView textView = new TextView(context);
+        textView.setTextColor(0xff666666);
+        textView.setText(title);
+        textView.setSingleLine(true);
+        textView.setEllipsize(TextUtils.TruncateAt.END);
+        textView.setGravity(Gravity.CENTER_VERTICAL);
+        textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18);
+        linearLayout.addView(textView, LayoutHelper.createLinear(0, LayoutHelper.MATCH_PARENT, 1.0f, 16, 0, 0, 0));
+
+        textView = new TextView(context);
+        textView.setTextColor(0xff999999);
+        textView.setText(LocaleController.getString("OpenInBrowser", R.string.OpenInBrowser));
+        textView.setGravity(Gravity.CENTER_VERTICAL);
+        textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 12);
+        linearLayout.addView(textView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, 16, 0, 0, 0));
+        textView.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                Uri uri = Uri.parse(openUrl);
+                Intent intent = new Intent(Intent.ACTION_VIEW, uri);
+                intent.putExtra(Browser.EXTRA_APPLICATION_ID, getContext().getPackageName());
+                getContext().startActivity(intent);
+                if (dialog != null) {
+                    dialog.dismiss();
+                }
+            }
+        });
+
+        textView = new TextView(context);
+        textView.setTextColor(0xff999999);
+        textView.setText(LocaleController.getString("CopyUrl", R.string.CopyUrl));
+        textView.setGravity(Gravity.CENTER_VERTICAL);
+        textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 12);
+        linearLayout.addView(textView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, 16, 0, 16, 0));
+        textView.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                if (Build.VERSION.SDK_INT < 11) {
+                    android.text.ClipboardManager clipboard = (android.text.ClipboardManager) ApplicationLoader.applicationContext.getSystemService(Context.CLIPBOARD_SERVICE);
+                    clipboard.setText(openUrl);
+                } else {
+                    android.content.ClipboardManager clipboard = (android.content.ClipboardManager) ApplicationLoader.applicationContext.getSystemService(Context.CLIPBOARD_SERVICE);
+                    android.content.ClipData clip = android.content.ClipData.newPlainText("label", openUrl);
+                    clipboard.setPrimaryClip(clip);
+                }
+                Toast.makeText(getContext(), LocaleController.getString("LinkCopied", R.string.LinkCopied), Toast.LENGTH_SHORT).show();
+                if (dialog != null) {
+                    dialog.dismiss();
+                }
+            }
+        });
+
+        View lineView = new View(context);
+        lineView.setBackgroundColor(0xffcdcdcd);
+        addView(lineView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 1, Gravity.TOP | Gravity.LEFT, 0, 40, 0, 0));
+
+        webView = new WebView(context);
+        webView.getSettings().setJavaScriptEnabled(true);
+        String userAgent = webView.getSettings().getUserAgentString();
+        if (userAgent != null) {
+            userAgent = userAgent.replace("Android", "");
+            webView.getSettings().setUserAgentString(userAgent);
+        }
+        if (Build.VERSION.SDK_INT >= 21) {
+            webView.getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);
+            CookieManager cookieManager = CookieManager.getInstance();
+            cookieManager.setAcceptThirdPartyCookies(webView, true);
+        }
+
+        webView.setWebChromeClient(new WebChromeClient() {
+
+            @Override
+            public void onShowCustomView(View view, int requestedOrientation, CustomViewCallback callback) {
+                onShowCustomView(view, callback);
+            }
+
+            @Override
+            public void onShowCustomView(View view, CustomViewCallback callback) {
+                if (customView != null) {
+                    callback.onCustomViewHidden();
+                    return;
+                }
+                customView = view;
+                if (dialog != null) {
+                    dialog.getSheetContainer().setVisibility(INVISIBLE);
+                    fullscreenVideoContainer.setVisibility(VISIBLE);
+                    fullscreenVideoContainer.addView(view, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
+                }
+                customViewCallback = callback;
+            }
+
+            @Override
+            public void onHideCustomView() {
+                super.onHideCustomView();
+                if (customView == null) {
+                    return;
+                }
+                if (dialog != null) {
+                    dialog.getSheetContainer().setVisibility(VISIBLE);
+                    fullscreenVideoContainer.setVisibility(INVISIBLE);
+                    fullscreenVideoContainer.removeView(customView);
+                }
+                if (customViewCallback != null && !customViewCallback.getClass().getName().contains(".chromium.")) {
+                    customViewCallback.onCustomViewHidden();
+                }
+                customView = null;
+            }
+        });
+
+        webView.setWebViewClient(new WebViewClient() {
+            @Override
+            public void onLoadResource(WebView view, String url) {
+                super.onLoadResource(view, url);
+            }
+
+
+            @Override
+            public void onPageFinished(WebView view, String url) {
+                super.onPageFinished(view, url);
+                progressBar.setVisibility(INVISIBLE);
+            }
+        });
+
+        addView(webView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT, 8, 49, 8, 0));
+
+        progressBar = new ProgressBar(context);
+        addView(progressBar, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER, 8, 24, 8, 0));
+
+        setOnTouchListener(new OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                return true;
+            }
+        });
+
+        parentDialog.setDelegate(new BottomSheet.BottomSheetDelegate() {
+            @Override
+            public void onOpenAnimationEnd() {
+                HashMap<String, String> args = new HashMap<>();
+                args.put("Referer", "http://youtube.com");
+                webView.loadUrl(url, args);
+            }
+        });
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        webView.stopLoading();
+        webView.loadUrl("about:blank");
+        webView.destroy();
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        int parentWidth = MeasureSpec.getSize(widthMeasureSpec);
+        float scale = width / parentWidth;
+        int h = (int) Math.min(height / scale, AndroidUtilities.displaySize.y / 2);
+        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(h + AndroidUtilities.dp(49), MeasureSpec.EXACTLY));
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ContactsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ContactsActivity.java
index 793629602..99a4b4475 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ContactsActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ContactsActivity.java
@@ -376,7 +376,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                                 }
                             });
                             builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                            showAlertDialog(builder);
+                            showDialog(builder.create());
                         }
                     }
                 }
@@ -427,7 +427,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                 }
             });
             builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-            showAlertDialog(builder);
+            showDialog(builder.create());
             ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams)editText.getLayoutParams();
             if (layoutParams != null) {
                 if (layoutParams instanceof FrameLayout.LayoutParams) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/DocumentSelectActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/DocumentSelectActivity.java
index cf02ca29f..260092182 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/DocumentSelectActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/DocumentSelectActivity.java
@@ -8,6 +8,7 @@
 
 package org.telegram.ui;
 
+import android.annotation.SuppressLint;
 import android.app.AlertDialog;
 import android.content.BroadcastReceiver;
 import android.content.Context;
@@ -32,7 +33,6 @@
 import org.telegram.messenger.FileLog;
 import org.telegram.android.LocaleController;
 import org.telegram.messenger.R;
-import org.telegram.messenger.Utilities;
 import org.telegram.ui.Adapters.BaseFragmentAdapter;
 import org.telegram.ui.ActionBar.ActionBar;
 import org.telegram.ui.ActionBar.ActionBarMenu;
@@ -234,7 +234,7 @@ public boolean onItemLongClick(AdapterView<?> parent, View view, int i, long id)
                     }
                     if (sizeLimit != 0) {
                         if (file.length() > sizeLimit) {
-                            showErrorBox(LocaleController.formatString("FileUploadLimit", R.string.FileUploadLimit, Utilities.formatFileSize(sizeLimit)));
+                            showErrorBox(LocaleController.formatString("FileUploadLimit", R.string.FileUploadLimit, AndroidUtilities.formatFileSize(sizeLimit)));
                             return false;
                         }
                     }
@@ -298,7 +298,7 @@ public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
                     he.scrollItem = listView.getFirstVisiblePosition();
                     he.scrollOffset = listView.getChildAt(0).getTop();
                     he.dir = currentDir;
-                    he.title = actionBar.getTitle().toString();
+                    he.title = actionBar.getTitle();
                     history.add(he);
                     if (!listFiles(file)) {
                         history.remove(he);
@@ -313,7 +313,7 @@ public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
                     }
                     if (sizeLimit != 0) {
                         if (file.length() > sizeLimit) {
-                            showErrorBox(LocaleController.formatString("FileUploadLimit", R.string.FileUploadLimit, Utilities.formatFileSize(sizeLimit)));
+                            showErrorBox(LocaleController.formatString("FileUploadLimit", R.string.FileUploadLimit, AndroidUtilities.formatFileSize(sizeLimit)));
                             return;
                         }
                     }
@@ -404,7 +404,7 @@ private boolean listFiles(File dir) {
             return false;
         }
         emptyView.setText(LocaleController.getString("NoFiles", R.string.NoFiles));
-        File[] files = null;
+        File[] files;
         try {
             files = dir.listFiles();
         } catch(Exception e) {
@@ -449,7 +449,7 @@ public int compare(File lhs, File rhs) {
                 String fname = file.getName();
                 String[] sp = fname.split("\\.");
                 item.ext = sp.length > 1 ? sp[sp.length - 1] : "?";
-                item.subtitle = Utilities.formatFileSize(file.length());
+                item.subtitle = AndroidUtilities.formatFileSize(file.length());
                 fname = fname.toLowerCase();
                 if (fname.endsWith(".jpg") || fname.endsWith(".png") || fname.endsWith(".gif") || fname.endsWith(".jpeg")) {
                     item.thumb = file.getAbsolutePath();
@@ -485,6 +485,7 @@ private void showErrorBox(String error) {
         new AlertDialog.Builder(getParentActivity()).setTitle(LocaleController.getString("AppName", R.string.AppName)).setMessage(error).setPositiveButton(LocaleController.getString("OK", R.string.OK), null).show();
     }
 
+    @SuppressLint("NewApi")
     private void listRoots() {
         currentDir = null;
         items.clear();
@@ -582,7 +583,7 @@ private String getRootSubtitle(String path) {
         if (total == 0) {
             return "";
         }
-        return LocaleController.formatString("FreeOfTotal", R.string.FreeOfTotal, Utilities.formatFileSize(free), Utilities.formatFileSize(total));
+        return LocaleController.formatString("FreeOfTotal", R.string.FreeOfTotal, AndroidUtilities.formatFileSize(free), AndroidUtilities.formatFileSize(total));
     }
 
     private class ListAdapter extends BaseFragmentAdapter {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateActivity.java
index ba5470f4b..d26744043 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateActivity.java
@@ -376,7 +376,7 @@ public boolean onTouch(View v, MotionEvent event) {
         listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
             @Override
             public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
-                TLRPC.User user = null;
+                TLRPC.User user;
                 if (searching && searchWas) {
                     user = searchListViewAdapter.getItem(i);
                 } else {
@@ -482,12 +482,7 @@ public void didReceivedNotification(int id, Object... args) {
                 updateVisibleRows(mask);
             }
         } else if (id == NotificationCenter.chatDidCreated) {
-            AndroidUtilities.runOnUIThread(new Runnable() {
-                @Override
-                public void run() {
-                    removeSelfFromStack();
-                }
-            });
+            removeSelfFromStack();
         }
     }
 
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateFinalActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateFinalActivity.java
index a0aecf567..93aaffa07 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateFinalActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateFinalActivity.java
@@ -255,7 +255,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                             }
                         }
                     });
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 }
             });
         }
@@ -393,26 +393,21 @@ public void didReceivedNotification(int id, final Object... args) {
             }
             donePressed = false;
         } else if (id == NotificationCenter.chatDidCreated) {
-            AndroidUtilities.runOnUIThread(new Runnable() {
-                @Override
-                public void run() {
-                    if (progressDialog != null) {
-                        try {
-                            progressDialog.dismiss();
-                        } catch (Exception e) {
-                            FileLog.e("tmessages", e);
-                        }
-                    }
-                    int chat_id = (Integer)args[0];
-                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.closeChats);
-                    Bundle args2 = new Bundle();
-                    args2.putInt("chat_id", chat_id);
-                    presentFragment(new ChatActivity(args2), true);
-                    if (uploadedAvatar != null) {
-                        MessagesController.getInstance().changeChatAvatar(chat_id, uploadedAvatar);
-                    }
+            if (progressDialog != null) {
+                try {
+                    progressDialog.dismiss();
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
                 }
-            });
+            }
+            int chat_id = (Integer)args[0];
+            NotificationCenter.getInstance().postNotificationName(NotificationCenter.closeChats);
+            Bundle args2 = new Bundle();
+            args2.putInt("chat_id", chat_id);
+            presentFragment(new ChatActivity(args2), true);
+            if (uploadedAvatar != null) {
+                MessagesController.getInstance().changeChatAvatar(chat_id, uploadedAvatar);
+            }
         }
     }
 
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/GroupInviteActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/GroupInviteActivity.java
index 7af61e6a9..1ea12de42 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/GroupInviteActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/GroupInviteActivity.java
@@ -167,7 +167,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 }
             }
         });
@@ -225,7 +225,7 @@ public void run() {
                                 builder.setMessage(LocaleController.getString("RevokeAlertNewLink", R.string.RevokeAlertNewLink));
                                 builder.setTitle(LocaleController.getString("RevokeLink", R.string.RevokeLink));
                                 builder.setNegativeButton(LocaleController.getString("OK", R.string.OK), null);
-                                showAlertDialog(builder);
+                                showDialog(builder.create());
                             }
                         }
                         loading = false;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/IntroActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/IntroActivity.java
index 2d3599521..57766ebc6 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/IntroActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/IntroActivity.java
@@ -30,7 +30,6 @@
 import org.telegram.android.AndroidUtilities;
 import org.telegram.android.LocaleController;
 import org.telegram.messenger.R;
-import org.telegram.messenger.Utilities;
 
 public class IntroActivity extends Activity {
     private ViewPager viewPager;
@@ -236,8 +235,14 @@ protected void onResume() {
             }
             justCreated = false;
         }
-        Utilities.checkForCrashes(this);
-        Utilities.checkForUpdates(this);
+        AndroidUtilities.checkForCrashes(this);
+        AndroidUtilities.checkForUpdates(this);
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        AndroidUtilities.unregisterUpdates();
     }
 
     private class IntroAdapter extends PagerAdapter {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/LanguageSelectActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/LanguageSelectActivity.java
index 0e17c33d2..f7f1bd2d1 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/LanguageSelectActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/LanguageSelectActivity.java
@@ -215,7 +215,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                     }
                 });
                 builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                showAlertDialog(builder);
+                showDialog(builder.create());
                 return true;
             }
         });
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/LastSeenActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/LastSeenActivity.java
index fcc8ace2a..1b1f81c04 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/LastSeenActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/LastSeenActivity.java
@@ -129,7 +129,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                                 }
                             });
                             builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                            showAlertDialog(builder);
+                            showDialog(builder.create());
                             return;
                         }
                     }
@@ -179,7 +179,7 @@ public void onItemClick(AdapterView<?> adapterView, View view, final int i, long
                     currentType = newType;
                     updateRows();
                 } else if (i == neverShareRow || i == alwaysShareRow) {
-                    ArrayList<Integer> createFromArray = null;
+                    ArrayList<Integer> createFromArray;
                     if (i == neverShareRow) {
                         createFromArray = currentMinus;
                     } else {
@@ -323,7 +323,7 @@ private void showErrorAlert() {
         builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
         builder.setMessage(LocaleController.getString("PrivacyFloodControlError", R.string.PrivacyFloodControlError));
         builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
-        showAlertDialog(builder);
+        showDialog(builder.create());
     }
 
     private void checkPrivacy() {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/LastSeenUsersActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/LastSeenUsersActivity.java
index b4d4c93d0..b476860fc 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/LastSeenUsersActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/LastSeenUsersActivity.java
@@ -186,7 +186,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         }
                     }
                 });
-                showAlertDialog(builder);
+                showDialog(builder.create());
                 return true;
             }
         });
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java
index 6d517a28a..42abf382a 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java
@@ -45,6 +45,7 @@
 import org.telegram.android.MessagesController;
 import org.telegram.android.MessagesStorage;
 import org.telegram.android.SendMessagesHelper;
+import org.telegram.android.query.StickersQuery;
 import org.telegram.messenger.ApplicationLoader;
 import org.telegram.messenger.ConnectionsManager;
 import org.telegram.messenger.FileLog;
@@ -55,7 +56,6 @@
 import org.telegram.messenger.TLObject;
 import org.telegram.messenger.TLRPC;
 import org.telegram.messenger.UserConfig;
-import org.telegram.messenger.Utilities;
 import org.telegram.ui.Adapters.DrawerLayoutAdapter;
 import org.telegram.ui.ActionBar.ActionBarLayout;
 import org.telegram.ui.ActionBar.BaseFragment;
@@ -131,6 +131,7 @@ protected void onCreate(Bundle savedInstanceState) {
         setTheme(R.style.Theme_TMessages);
         getWindow().setBackgroundDrawableResource(R.drawable.transparent);
 
+
         super.onCreate(savedInstanceState);
 
         if (UserConfig.passcodeHash.length() != 0 && UserConfig.appLocked) {
@@ -340,8 +341,6 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
         NotificationCenter.getInstance().addObserver(this, NotificationCenter.didUpdatedConnectionState);
         if (Build.VERSION.SDK_INT < 14) {
             NotificationCenter.getInstance().addObserver(this, NotificationCenter.screenStateChanged);
-        } else {
-            NotificationCenter.getInstance().addObserver(this, NotificationCenter.appSwitchedToForeground);
         }
 
         if (actionBarLayout.fragmentsStack.isEmpty()) {
@@ -402,11 +401,12 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
                 FileLog.e("tmessages", e);
             }
         } else {
-            boolean allowOpen = false;
+            boolean allowOpen = true;
             if (AndroidUtilities.isTablet()) {
                 allowOpen = actionBarLayout.fragmentsStack.size() <= 1 && layersActionBarLayout.fragmentsStack.isEmpty();
-            } else {
-                allowOpen = actionBarLayout.fragmentsStack.size() <= 1;
+                if (layersActionBarLayout.fragmentsStack.size() == 1 && layersActionBarLayout.fragmentsStack.get(0) instanceof LoginActivity) {
+                    allowOpen = false;
+                }
             }
             if (actionBarLayout.fragmentsStack.size() == 1 && actionBarLayout.fragmentsStack.get(0) instanceof LoginActivity) {
                 allowOpen = false;
@@ -478,22 +478,7 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
                     if (Intent.ACTION_SEND.equals(intent.getAction())) {
                         boolean error = false;
                         String type = intent.getType();
-                        if (type != null && (type.equals("text/plain") || type.equals("message/rfc822")) && (intent.getStringExtra(Intent.EXTRA_TEXT) != null || intent.getCharSequenceExtra(Intent.EXTRA_TEXT) != null)) {
-                            String text = intent.getStringExtra(Intent.EXTRA_TEXT);
-                            if (text == null) {
-                                text = intent.getCharSequenceExtra(Intent.EXTRA_TEXT).toString();
-                            }
-                            String subject = intent.getStringExtra(Intent.EXTRA_SUBJECT);
-
-                            if (text != null && text.length() != 0) {
-                                if ((text.startsWith("http://") || text.startsWith("https://")) && subject != null && subject.length() != 0) {
-                                    text = subject + "\n" + text;
-                                }
-                                sendingText = text;
-                            } else {
-                                error = true;
-                            }
-                        } else if (type != null && type.equals(ContactsContract.Contacts.CONTENT_VCARD_TYPE)) {
+                        if (type != null && type.equals(ContactsContract.Contacts.CONTENT_VCARD_TYPE)) {
                             try {
                                 Uri uri = (Uri) intent.getExtras().get(Intent.EXTRA_STREAM);
                                 if (uri != null) {
@@ -505,7 +490,7 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
                                     String nameCharset = null;
                                     ArrayList<String> phones = new ArrayList<>();
                                     BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(stream, "UTF-8"));
-                                    String line = null;
+                                    String line;
                                     while ((line = bufferedReader.readLine()) != null) {
                                         String[] args = line.split(":");
                                         if (args.length != 2) {
@@ -534,7 +519,7 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
                                                     }
                                                     name += line;
                                                 }
-                                                byte[] bytes = Utilities.decodeQuotedPrintable(name.getBytes());
+                                                byte[] bytes = AndroidUtilities.decodeQuotedPrintable(name.getBytes());
                                                 if (bytes != null && bytes.length != 0) {
                                                     String decodedName = new String(bytes, nameCharset);
                                                     if (decodedName != null) {
@@ -574,21 +559,40 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
                                 error = true;
                             }
                         } else {
+                            if (type != null && (type.equals("text/plain") || type.equals("message/rfc822")) && (intent.getStringExtra(Intent.EXTRA_TEXT) != null || intent.getCharSequenceExtra(Intent.EXTRA_TEXT) != null)) {
+                                String text = intent.getStringExtra(Intent.EXTRA_TEXT);
+                                if (text == null) {
+                                    text = intent.getCharSequenceExtra(Intent.EXTRA_TEXT).toString();
+                                }
+                                String subject = intent.getStringExtra(Intent.EXTRA_SUBJECT);
+
+                                if (text != null && text.length() != 0) {
+                                    if ((text.startsWith("http://") || text.startsWith("https://")) && subject != null && subject.length() != 0) {
+                                        text = subject + "\n" + text;
+                                    }
+                                    sendingText = text;
+                                    if (sendingText.contains("WhatsApp")) { //who needs this sent from ...?
+                                        sendingText = null;
+                                    }
+                                } else {
+                                    error = true;
+                                }
+                            }
                             Parcelable parcelable = intent.getParcelableExtra(Intent.EXTRA_STREAM);
                             if (parcelable != null) {
-                                String path = null;
+                                String path;
                                 if (!(parcelable instanceof Uri)) {
                                     parcelable = Uri.parse(parcelable.toString());
                                 }
                                 Uri uri = (Uri) parcelable;
-                                if (uri != null && type != null && type.startsWith("image/")) {
-                                    String tempPath = Utilities.getPath(uri);
+                                if (uri != null && (type != null && type.startsWith("image/") || uri.toString().toLowerCase().endsWith(".jpg"))) {
+                                    String tempPath = AndroidUtilities.getPath(uri);
                                     if (photoPathsArray == null) {
                                         photoPathsArray = new ArrayList<>();
                                     }
                                     photoPathsArray.add(uri);
                                 } else {
-                                    path = Utilities.getPath(uri);
+                                    path = AndroidUtilities.getPath(uri);
                                     if (path != null) {
                                         if (path.startsWith("file:")) {
                                             path = path.replace("file://", "");
@@ -611,12 +615,12 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
                                         documentsMimeType = type;
                                     }
                                 }
-                            } else {
+                            } else if (sendingText == null) {
                                 error = true;
                             }
-                            if (error) {
-                                Toast.makeText(this, "Unsupported content", Toast.LENGTH_SHORT).show();
-                            }
+                        }
+                        if (error) {
+                            Toast.makeText(this, "Unsupported content", Toast.LENGTH_SHORT).show();
                         }
                     } else if (intent.getAction().equals(Intent.ACTION_SEND_MULTIPLE)) {
                         boolean error = false;
@@ -640,7 +644,7 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
                                         if (!(parcelable instanceof Uri)) {
                                             parcelable = Uri.parse(parcelable.toString());
                                         }
-                                        String path = Utilities.getPath((Uri) parcelable);
+                                        String path = AndroidUtilities.getPath((Uri) parcelable);
                                         String originalPath = parcelable.toString();
                                         if (originalPath == null) {
                                             originalPath = path;
@@ -673,6 +677,7 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
                         if (data != null) {
                             String username = null;
                             String group = null;
+                            String sticker = null;
                             String scheme = data.getScheme();
                             if (scheme != null) {
                                 if ((scheme.equals("http") || scheme.equals("https"))) {
@@ -683,6 +688,8 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
                                             path = path.substring(1);
                                             if (path.startsWith("joinchat/")) {
                                                 group = path.replace("joinchat/", "");
+                                            } else if (path.startsWith("addstickers/")) {
+                                                sticker = path.replace("addstickers/", "");
                                             } else {
                                                 username = path;
                                             }
@@ -698,11 +705,15 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
                                         url = url.replace("tg:join", "tg://telegram.org").replace("tg://join", "tg://telegram.org");
                                         data = Uri.parse(url);
                                         group = data.getQueryParameter("invite");
+                                    } else if (url.startsWith("tg:addstickers") || url.startsWith("tg://addstickers")) {
+                                        url = url.replace("tg:addstickers", "tg://telegram.org").replace("tg://addstickers", "tg://telegram.org");
+                                        data = Uri.parse(url);
+                                        sticker = data.getQueryParameter("set");
                                     }
                                 }
                             }
-                            if (username != null || group != null) {
-                                runLinkRequest(username, group, 0);
+                            if (username != null || group != null || sticker != null) {
+                                runLinkRequest(username, group, sticker, 0);
                             } else {
                                 try {
                                     Cursor cursor = getContentResolver().query(intent.getData(), null, null, null, null);
@@ -742,15 +753,11 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
             }
 
             if (push_user_id != 0) {
-                if (push_user_id == UserConfig.getClientUserId()) {
-                    open_settings = 1;
-                } else {
-                    Bundle args = new Bundle();
-                    args.putInt("user_id", push_user_id);
-                    ChatActivity fragment = new ChatActivity(args);
-                    if (actionBarLayout.presentFragment(fragment, false, true, true)) {
-                        pushOpened = true;
-                    }
+                Bundle args = new Bundle();
+                args.putInt("user_id", push_user_id);
+                ChatActivity fragment = new ChatActivity(args);
+                if (actionBarLayout.presentFragment(fragment, false, true, true)) {
+                    pushOpened = true;
                 }
             } else if (push_chat_id != 0) {
                 Bundle args = new Bundle();
@@ -790,7 +797,7 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
                 args.putString("selectAlertStringGroup", LocaleController.getString("SendMessagesToGroup", R.string.SendMessagesToGroup));
                 MessagesActivity fragment = new MessagesActivity(args);
                 fragment.setDelegate(this);
-                boolean removeLast = false;
+                boolean removeLast;
                 if (AndroidUtilities.isTablet()) {
                     removeLast = layersActionBarLayout.fragmentsStack.size() > 0 && layersActionBarLayout.fragmentsStack.get(layersActionBarLayout.fragmentsStack.size() - 1) instanceof MessagesActivity;
                 } else {
@@ -858,7 +865,7 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
         return false;
     }
 
-    private void runLinkRequest(final String username, final String group, final int state) {
+    private void runLinkRequest(final String username, final String group, final String sticker, final int state) {
         final ProgressDialog progressDialog = new ProgressDialog(this);
         progressDialog.setMessage(LocaleController.getString("Loading", R.string.Loading));
         progressDialog.setCanceledOnTouchOutside(false);
@@ -932,7 +939,7 @@ public void run() {
                                             builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
                                                 @Override
                                                 public void onClick(DialogInterface dialogInterface, int i) {
-                                                    runLinkRequest(username, group, 1);
+                                                    runLinkRequest(username, group, sticker, 1);
                                                 }
                                             });
                                             builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
@@ -999,6 +1006,13 @@ public void run() {
                     }
                 });
             }
+        } else if (sticker != null) {
+            if (!mainFragmentsStack.isEmpty()) {
+                TLRPC.TL_inputStickerSetShortName stickerset = new TLRPC.TL_inputStickerSetShortName();
+                stickerset.short_name = sticker;
+                StickersQuery.loadStickers(mainFragmentsStack.get(0), stickerset);
+            }
+            return;
         }
 
         final long reqId = requestId;
@@ -1136,8 +1150,6 @@ private void onFinish() {
         NotificationCenter.getInstance().removeObserver(this, NotificationCenter.didUpdatedConnectionState);
         if (Build.VERSION.SDK_INT < 14) {
             NotificationCenter.getInstance().removeObserver(this, NotificationCenter.screenStateChanged);
-        } else {
-            NotificationCenter.getInstance().removeObserver(this, NotificationCenter.appSwitchedToForeground);
         }
     }
 
@@ -1274,6 +1286,7 @@ protected void onPause() {
         }
         ApplicationLoader.mainInterfacePaused = true;
         ConnectionsManager.getInstance().setAppPaused(true, false);
+        AndroidUtilities.unregisterUpdates();
     }
 
     @Override
@@ -1305,8 +1318,8 @@ protected void onResume() {
         } else {
             passcodeView.onResume();
         }
-        Utilities.checkForCrashes(this);
-        Utilities.checkForUpdates(this);
+        AndroidUtilities.checkForCrashes(this);
+        AndroidUtilities.checkForUpdates(this);
         ApplicationLoader.mainInterfacePaused = false;
         ConnectionsManager.getInstance().setAppPaused(false, false);
         updateCurrentConnectionState();
@@ -1369,8 +1382,6 @@ public void didReceivedNotification(int id, Object... args) {
                     onPasscodeResume();
                 }
             }
-        } else if (id == NotificationCenter.appSwitchedToForeground) {
-            onPasscodeResume();
         }
     }
 
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/LoginActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/LoginActivity.java
index 7dd309e84..2ae84cf47 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/LoginActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/LoginActivity.java
@@ -9,7 +9,9 @@
 package org.telegram.ui;
 
 import android.animation.Animator;
+import android.annotation.SuppressLint;
 import android.app.AlertDialog;
+import android.app.Dialog;
 import android.app.ProgressDialog;
 import android.content.Context;
 import android.content.DialogInterface;
@@ -269,7 +271,7 @@ public boolean onBackPressed() {
         } else if (currentViewNum == 3) {
             views[currentViewNum].onBackPressed();
             setPage(0, true, null, true);
-        }  else if (currentViewNum == 4) {
+        } else if (currentViewNum == 4) {
             views[currentViewNum].onBackPressed();
             setPage(3, true, null, true);
         }
@@ -284,7 +286,7 @@ public void needShowAlert(String title, String text) {
         builder.setTitle(title);
         builder.setMessage(text);
         builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
-        showAlertDialog(builder);
+        showDialog(builder.create());
     }
 
     public void needShowProgress() {
@@ -326,6 +328,7 @@ public void setPage(int page, boolean animated, Bundle params, boolean back) {
                 public void onAnimationStart(Animator animator) {
                 }
 
+                @SuppressLint("NewApi")
                 @Override
                 public void onAnimationEnd(Animator animator) {
                     outView.setVisibility(View.GONE);
@@ -770,6 +773,7 @@ public void onNextPressed() {
                 needShowAlert(LocaleController.getString("AppName", R.string.AppName), LocaleController.getString("InvalidPhoneNumber", R.string.InvalidPhoneNumber));
                 return;
             }
+            ConnectionsManager.getInstance().cleanUp();
             TLRPC.TL_auth_sendCode req = new TLRPC.TL_auth_sendCode();
             String phone = PhoneFormat.stripExceptNumbers("" + codeField.getText() + phoneField.getText());
             ConnectionsManager.getInstance().applyCountryPortNumber(phone);
@@ -1302,18 +1306,13 @@ public void onShow() {
         @Override
         public void didReceivedNotification(int id, final Object... args) {
             if (id == NotificationCenter.didReceiveSmsCode) {
-                AndroidUtilities.runOnUIThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        if (!waitingForSms) {
-                            return;
-                        }
-                        if (codeField != null) {
-                            codeField.setText("" + args[0]);
-                            onNextPressed();
-                        }
-                    }
-                });
+                if (!waitingForSms) {
+                    return;
+                }
+                if (codeField != null) {
+                    codeField.setText("" + args[0]);
+                    onNextPressed();
+                }
             }
         }
 
@@ -1453,7 +1452,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                                                     setPage(4, true, bundle, false);
                                                 }
                                             });
-                                            AlertDialog dialog = showAlertDialog(builder);
+                                            Dialog dialog = showDialog(builder.create());
                                             if (dialog != null) {
                                                 dialog.setCanceledOnTouchOutside(false);
                                                 dialog.setCancelable(false);
@@ -1536,7 +1535,7 @@ public void run() {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 }
             });
 
@@ -1815,7 +1814,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                             setPage(3, true, new Bundle(), true);
                         }
                     });
-                    AlertDialog dialog = showAlertDialog(builder);
+                    Dialog dialog = showDialog(builder.create());
                     if (dialog != null) {
                         dialog.setCanceledOnTouchOutside(false);
                         dialog.setCancelable(false);
@@ -1874,12 +1873,6 @@ public void onNextPressed() {
                 return;
             }
             nextPressed = true;
-            byte[] oldPasswordBytes = null;
-            try {
-                oldPasswordBytes = oldPassword.getBytes("UTF-8");
-            } catch (Exception e) {
-                FileLog.e("tmessages", e);
-            }
 
             String code = codeField.getText().toString();
             if (code.length() == 0) {
@@ -2084,7 +2077,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 }
             });
         }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/MediaActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/MediaActivity.java
index 3f92e3936..cc14a0e98 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/MediaActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/MediaActivity.java
@@ -279,7 +279,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (id == forward) {
                     Bundle args = new Bundle();
                     args.putBoolean("onlySelect", true);
@@ -938,7 +938,7 @@ private void onItemClick(int index, View view, MessageObject message, int a) {
                                 builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
                                 builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
                                 builder.setMessage(LocaleController.formatString("NoHandleAppInstalled", R.string.NoHandleAppInstalled, message.messageOwner.media.document.mime_type));
-                                showAlertDialog(builder);
+                                showDialog(builder.create());
                             }
                         }
                     } else if (!cell.isLoading()) {
@@ -1140,7 +1140,7 @@ public View getItemView(int section, int position, View convertView, ViewGroup p
                     MessageObject messageObject = messageObjects.get(0);
                     ((SharedMediaSectionCell) convertView).setText(LocaleController.formatterMonthYear.format((long) messageObject.messageOwner.date * 1000).toUpperCase());
                 } else {
-                    SharedPhotoVideoCell cell = null;
+                    SharedPhotoVideoCell cell;
                     if (convertView == null) {
                         if (!cellCache.isEmpty()) {
                             convertView = cellCache.get(0);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/MessagesActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/MessagesActivity.java
index 28bc4ca84..ed15ce845 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/MessagesActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/MessagesActivity.java
@@ -10,6 +10,7 @@
 
 import android.animation.ObjectAnimator;
 import android.animation.StateListAnimator;
+import android.annotation.SuppressLint;
 import android.app.AlertDialog;
 import android.content.Context;
 import android.content.DialogInterface;
@@ -17,26 +18,27 @@
 import android.graphics.Outline;
 import android.os.Build;
 import android.os.Bundle;
+import android.util.TypedValue;
 import android.view.Gravity;
 import android.view.LayoutInflater;
 import android.view.MotionEvent;
 import android.view.View;
-import android.view.ViewGroup;
 import android.view.ViewOutlineProvider;
 import android.view.ViewTreeObserver;
 import android.view.animation.AccelerateDecelerateInterpolator;
-import android.widget.AbsListView;
-import android.widget.AdapterView;
-import android.widget.CheckBox;
 import android.widget.EditText;
 import android.widget.FrameLayout;
 import android.widget.ImageView;
+import android.widget.LinearLayout;
 import android.widget.ListView;
+import android.widget.ProgressBar;
 import android.widget.TextView;
 
 import org.telegram.android.AndroidUtilities;
 import org.telegram.android.LocaleController;
 import org.telegram.android.MessageObject;
+import org.telegram.android.support.widget.LinearLayoutManager;
+import org.telegram.android.support.widget.RecyclerView;
 import org.telegram.messenger.FileLog;
 import org.telegram.messenger.TLRPC;
 import org.telegram.android.ContactsController;
@@ -45,7 +47,7 @@
 import org.telegram.android.NotificationCenter;
 import org.telegram.messenger.R;
 import org.telegram.messenger.UserConfig;
-import org.telegram.ui.Adapters.BaseFragmentAdapter;
+import org.telegram.ui.ActionBar.BottomSheet;
 import org.telegram.ui.Adapters.DialogsAdapter;
 import org.telegram.ui.Adapters.DialogsSearchAdapter;
 import org.telegram.android.AnimationCompat.ObjectAnimatorProxy;
@@ -57,19 +59,25 @@
 import org.telegram.ui.ActionBar.ActionBarMenuItem;
 import org.telegram.ui.ActionBar.BaseFragment;
 import org.telegram.ui.ActionBar.MenuDrawable;
+import org.telegram.ui.Components.EmptyTextProgressView;
+import org.telegram.ui.Components.LayoutHelper;
+import org.telegram.ui.Components.RecyclerListView;
 import org.telegram.ui.Components.ResourceLoader;
 
 import java.util.ArrayList;
 
 public class MessagesActivity extends BaseFragment implements NotificationCenter.NotificationCenterDelegate {
-    private ListView messagesListView;
+    
+    private RecyclerListView listView;
+    private LinearLayoutManager layoutManager;
     private DialogsAdapter dialogsAdapter;
     private DialogsSearchAdapter dialogsSearchAdapter;
-    private View searchEmptyView;
-    private View progressView;
-    private View emptyView;
+    private EmptyTextProgressView searchEmptyView;
+    private ProgressBar progressView;
+    private LinearLayout emptyView;
     private ActionBarMenuItem passcodeItem;
     private ImageView floatingButton;
+
     private int prevPosition;
     private int prevTop;
     private boolean scrollUpdated;
@@ -78,21 +86,18 @@
 
     private String selectAlertString;
     private String selectAlertStringGroup;
-    private boolean serverOnly = false;
+    private boolean serverOnly;
 
-    private static boolean dialogsLoaded = false;
-    private boolean searching = false;
-    private boolean searchWas = false;
-    private boolean onlySelect = false;
+    private static boolean dialogsLoaded;
+    private boolean searching;
+    private boolean searchWas;
+    private boolean onlySelect;
     private long selectedDialog;
     private String searchString;
+    private long openedDialogId;
 
     private MessagesActivityDelegate delegate;
 
-    private long openedDialogId = 0;
-
-    private static final int passcode_menu_item = 1;
-
     public interface MessagesActivityDelegate {
         void didSelectDialog(MessagesActivity fragment, long dialog_id, boolean param);
     }
@@ -157,7 +162,7 @@ public void onFragmentDestroy() {
     }
 
     @Override
-    public View createView(Context context, LayoutInflater inflater) {
+    public View createView(final Context context, LayoutInflater inflater) {
         searching = false;
         searchWas = false;
 
@@ -165,22 +170,19 @@ public View createView(Context context, LayoutInflater inflater) {
 
         ActionBarMenu menu = actionBar.createMenu();
         if (!onlySelect && searchString == null) {
-            passcodeItem = menu.addItem(passcode_menu_item, R.drawable.lock_close);
+            passcodeItem = menu.addItem(1, R.drawable.lock_close);
             updatePasscodeButton();
         }
         ActionBarMenuItem item = menu.addItem(0, R.drawable.ic_ab_search).setIsSearchField(true).setActionBarMenuItemSearchListener(new ActionBarMenuItem.ActionBarMenuItemSearchListener() {
             @Override
             public void onSearchExpand() {
                 searching = true;
-                if (messagesListView != null) {
+                if (listView != null) {
                     if (searchString != null) {
-                        messagesListView.setEmptyView(progressView);
-                        searchEmptyView.setVisibility(View.INVISIBLE);
-                    } else {
-                        messagesListView.setEmptyView(searchEmptyView);
+                        listView.setEmptyView(searchEmptyView);
                         progressView.setVisibility(View.INVISIBLE);
+                        emptyView.setVisibility(View.INVISIBLE);
                     }
-                    emptyView.setVisibility(View.INVISIBLE);
                     if (!onlySelect) {
                         floatingButton.setVisibility(View.GONE);
                     }
@@ -196,16 +198,14 @@ public boolean onSearchCollapse() {
                 }
                 searching = false;
                 searchWas = false;
-                if (messagesListView != null) {
+                if (listView != null) {
+                    searchEmptyView.setVisibility(View.INVISIBLE);
                     if (MessagesController.getInstance().loadingDialogs && MessagesController.getInstance().dialogs.isEmpty()) {
-                        searchEmptyView.setVisibility(View.INVISIBLE);
                         emptyView.setVisibility(View.INVISIBLE);
-                        progressView.setVisibility(View.VISIBLE);
-                        messagesListView.setEmptyView(progressView);
+                        listView.setEmptyView(progressView);
                     } else {
-                        messagesListView.setEmptyView(emptyView);
-                        searchEmptyView.setVisibility(View.INVISIBLE);
                         progressView.setVisibility(View.INVISIBLE);
+                        listView.setEmptyView(emptyView);
                     }
                     if (!onlySelect) {
                         floatingButton.setVisibility(View.VISIBLE);
@@ -213,8 +213,8 @@ public boolean onSearchCollapse() {
                         ViewProxy.setTranslationY(floatingButton, AndroidUtilities.dp(100));
                         hideFloatingButton(false);
                     }
-                    if (messagesListView.getAdapter() != dialogsAdapter) {
-                        messagesListView.setAdapter(dialogsAdapter);
+                    if (listView.getAdapter() != dialogsAdapter) {
+                        listView.setAdapter(dialogsAdapter);
                         dialogsAdapter.notifyDataSetChanged();
                     }
                 }
@@ -231,13 +231,14 @@ public void onTextChanged(EditText editText) {
                 if (text.length() != 0) {
                     searchWas = true;
                     if (dialogsSearchAdapter != null) {
-                        messagesListView.setAdapter(dialogsSearchAdapter);
+                        listView.setAdapter(dialogsSearchAdapter);
                         dialogsSearchAdapter.notifyDataSetChanged();
                     }
-                    if (searchEmptyView != null && messagesListView.getEmptyView() == emptyView) {
-                        messagesListView.setEmptyView(searchEmptyView);
+                    if (searchEmptyView != null && listView.getEmptyView() != searchEmptyView) {
                         emptyView.setVisibility(View.INVISIBLE);
                         progressView.setVisibility(View.INVISIBLE);
+                        searchEmptyView.showTextView();
+                        listView.setEmptyView(searchEmptyView);
                     }
                 }
                 if (dialogsSearchAdapter != null) {
@@ -268,7 +269,7 @@ public void onItemClick(int id) {
                     } else if (parentLayout != null) {
                         parentLayout.getDrawerLayoutContainer().openDrawer(false);
                     }
-                } else if (id == passcode_menu_item) {
+                } else if (id == 1) {
                     UserConfig.appLocked = !UserConfig.appLocked;
                     UserConfig.saveConfig(false);
                     updatePasscodeButton();
@@ -276,127 +277,47 @@ public void onItemClick(int id) {
             }
         });
 
-        fragmentView = inflater.inflate(R.layout.messages_list, null, false);
 
-        if (searchString == null) {
-            dialogsAdapter = new DialogsAdapter(context, serverOnly);
-            if (AndroidUtilities.isTablet() && openedDialogId != 0) {
-                dialogsAdapter.setOpenedDialogId(openedDialogId);
-            }
-        }
-        int type = 0;
-        if (searchString != null) {
-            type = 2;
-        } else if (!onlySelect) {
-            type = 1;
-        }
-        dialogsSearchAdapter = new DialogsSearchAdapter(context, type);
-        dialogsSearchAdapter.setDelegate(new DialogsSearchAdapter.MessagesActivitySearchAdapterDelegate() {
+        FrameLayout frameLayout = new FrameLayout(context);
+        fragmentView = frameLayout;
+        
+        listView = new RecyclerListView(context);
+        listView.setVerticalScrollBarEnabled(true);
+        listView.setItemAnimator(null);
+        listView.setInstantClick(true);
+        listView.setLayoutAnimation(null);
+        layoutManager = new LinearLayoutManager(context) {
             @Override
-            public void searchStateChanged(boolean search) {
-                if (searching && searchWas && messagesListView != null) {
-                    progressView.setVisibility(search ? View.VISIBLE : View.INVISIBLE);
-                    searchEmptyView.setVisibility(search ? View.INVISIBLE : View.VISIBLE);
-                    messagesListView.setEmptyView(search ? progressView : searchEmptyView);
-                }
+            public boolean supportsPredictiveItemAnimations() {
+                return false;
             }
-        });
-
-        messagesListView = (ListView) fragmentView.findViewById(R.id.messages_list_view);
-        if (dialogsAdapter != null) {
-            messagesListView.setAdapter(dialogsAdapter);
-        }
+        };
+        layoutManager.setOrientation(LinearLayoutManager.VERTICAL);
+        listView.setLayoutManager(layoutManager);
         if (Build.VERSION.SDK_INT >= 11) {
-            messagesListView.setVerticalScrollbarPosition(LocaleController.isRTL ? ListView.SCROLLBAR_POSITION_LEFT : ListView.SCROLLBAR_POSITION_RIGHT);
-        }
-
-        progressView = fragmentView.findViewById(R.id.progressLayout);
-        searchEmptyView = fragmentView.findViewById(R.id.search_empty_view);
-        searchEmptyView.setOnTouchListener(new View.OnTouchListener() {
-            @Override
-            public boolean onTouch(View v, MotionEvent event) {
-                return true;
-            }
-        });
-        emptyView = fragmentView.findViewById(R.id.list_empty_view);
-        emptyView.setOnTouchListener(new View.OnTouchListener() {
-            @Override
-            public boolean onTouch(View v, MotionEvent event) {
-                return true;
-            }
-        });
-
-
-        TextView textView = (TextView) fragmentView.findViewById(R.id.list_empty_view_text1);
-        textView.setText(LocaleController.getString("NoChats", R.string.NoChats));
-        textView = (TextView) fragmentView.findViewById(R.id.list_empty_view_text2);
-        String help = LocaleController.getString("NoChatsHelp", R.string.NoChatsHelp);
-        if (AndroidUtilities.isTablet() && !AndroidUtilities.isSmallTablet()) {
-            help = help.replace("\n", " ");
-        }
-        textView.setText(help);
-        textView = (TextView) fragmentView.findViewById(R.id.search_empty_text);
-        textView.setText(LocaleController.getString("NoResult", R.string.NoResult));
-
-        floatingButton = (ImageView) fragmentView.findViewById(R.id.floating_button);
-        floatingButton.setVisibility(onlySelect ? View.GONE : View.VISIBLE);
-        floatingButton.setScaleType(ImageView.ScaleType.CENTER);
-        if (Build.VERSION.SDK_INT >= 21) {
-            StateListAnimator animator = new StateListAnimator();
-            animator.addState(new int[]{android.R.attr.state_pressed}, ObjectAnimator.ofFloat(floatingButton, "translationZ", AndroidUtilities.dp(2), AndroidUtilities.dp(4)).setDuration(200));
-            animator.addState(new int[]{}, ObjectAnimator.ofFloat(floatingButton, "translationZ", AndroidUtilities.dp(4), AndroidUtilities.dp(2)).setDuration(200));
-            floatingButton.setStateListAnimator(animator);
-            floatingButton.setOutlineProvider(new ViewOutlineProvider() {
-                @Override
-                public void getOutline(View view, Outline outline) {
-                    outline.setOval(0, 0, AndroidUtilities.dp(56), AndroidUtilities.dp(56));
-                }
-            });
-        }
-        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) floatingButton.getLayoutParams();
-        layoutParams.leftMargin = LocaleController.isRTL ? AndroidUtilities.dp(14) : 0;
-        layoutParams.rightMargin = LocaleController.isRTL ? 0 : AndroidUtilities.dp(14);
-        layoutParams.gravity = (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.BOTTOM;
-        floatingButton.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                Bundle args = new Bundle();
-                args.putBoolean("destroyAfterSelect", true);
-                presentFragment(new ContactsActivity(args));
-            }
-        });
-
-        if (MessagesController.getInstance().loadingDialogs && MessagesController.getInstance().dialogs.isEmpty()) {
-            searchEmptyView.setVisibility(View.INVISIBLE);
-            emptyView.setVisibility(View.INVISIBLE);
-            progressView.setVisibility(View.VISIBLE);
-            messagesListView.setEmptyView(progressView);
-        } else {
-            messagesListView.setEmptyView(emptyView);
-            searchEmptyView.setVisibility(View.INVISIBLE);
-            progressView.setVisibility(View.INVISIBLE);
+            listView.setVerticalScrollbarPosition(LocaleController.isRTL ? ListView.SCROLLBAR_POSITION_LEFT : ListView.SCROLLBAR_POSITION_RIGHT);
         }
-
-        messagesListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+        frameLayout.addView(listView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
+        listView.setOnItemClickListener(new RecyclerListView.OnItemClickListener() {
             @Override
-            public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
-                if (messagesListView == null || messagesListView.getAdapter() == null) {
+            public void onItemClick(View view, int position) {
+                if (listView == null || listView.getAdapter() == null) {
                     return;
                 }
                 long dialog_id = 0;
                 int message_id = 0;
-                BaseFragmentAdapter adapter = (BaseFragmentAdapter) messagesListView.getAdapter();
+                RecyclerView.Adapter adapter = listView.getAdapter();
                 if (adapter == dialogsAdapter) {
-                    TLRPC.TL_dialog dialog = dialogsAdapter.getItem(i);
+                    TLRPC.TL_dialog dialog = dialogsAdapter.getItem(position);
                     if (dialog == null) {
                         return;
                     }
                     dialog_id = dialog.id;
                 } else if (adapter == dialogsSearchAdapter) {
-                    Object obj = dialogsSearchAdapter.getItem(i);
+                    Object obj = dialogsSearchAdapter.getItem(position);
                     if (obj instanceof TLRPC.User) {
                         dialog_id = ((TLRPC.User) obj).id;
-                        if (dialogsSearchAdapter.isGlobalSearch(i)) {
+                        if (dialogsSearchAdapter.isGlobalSearch(position)) {
                             ArrayList<TLRPC.User> users = new ArrayList<>();
                             users.add((TLRPC.User) obj);
                             MessagesController.getInstance().putUsers(users, false);
@@ -468,15 +389,14 @@ public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
                 }
             }
         });
-
-        messagesListView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {
+        listView.setOnItemLongClickListener(new RecyclerListView.OnItemLongClickListener() {
             @Override
-            public boolean onItemLongClick(AdapterView<?> adapterView, View view, int i, long l) {
+            public void onItemClick(View view, int position) {
                 if (onlySelect || searching && searchWas || getParentActivity() == null) {
                     if (searchWas && searching) {
-                        BaseFragmentAdapter adapter = (BaseFragmentAdapter) messagesListView.getAdapter();
+                        RecyclerView.Adapter adapter = listView.getAdapter();
                         if (adapter == dialogsSearchAdapter) {
-                            Object item = adapter.getItem(i);
+                            Object item = dialogsSearchAdapter.getItem(position);
                             if (item instanceof String) {
                                 AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
                                 builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
@@ -488,30 +408,35 @@ public void onClick(DialogInterface dialogInterface, int i) {
                                     }
                                 });
                                 builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                                showAlertDialog(builder);
-                                return true;
+                                showDialog(builder.create());
+                                return;
                             }
                         }
                     }
-                    return false;
+                    return;
                 }
                 TLRPC.TL_dialog dialog;
                 if (serverOnly) {
-                    if (i >= MessagesController.getInstance().dialogsServerOnly.size()) {
-                        return false;
+                    if (position < 0 || position >= MessagesController.getInstance().dialogsServerOnly.size()) {
+                        return;
                     }
-                    dialog = MessagesController.getInstance().dialogsServerOnly.get(i);
+                    dialog = MessagesController.getInstance().dialogsServerOnly.get(position);
                 } else {
-                    if (i >= MessagesController.getInstance().dialogs.size()) {
-                        return false;
+                    if (position < 0 || position >= MessagesController.getInstance().dialogs.size()) {
+                        return;
                     }
-                    dialog = MessagesController.getInstance().dialogs.get(i);
+                    dialog = MessagesController.getInstance().dialogs.get(position);
                 }
                 selectedDialog = dialog.id;
 
-                AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                /*AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
                 builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
 
+
+                builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
+                showDialog(builder.create());*/
+
+                BottomSheet.Builder builder = new BottomSheet.Builder(getParentActivity());
                 int lower_id = (int) selectedDialog;
                 int high_id = (int) (selectedDialog >> 32);
 
@@ -536,7 +461,12 @@ public void onClick(DialogInterface dialog, final int which) {
                             public void onClick(DialogInterface dialogInterface, int i) {
                                 if (which != 0) {
                                     if (isChat) {
-                                        MessagesController.getInstance().deleteUserFromChat((int) -selectedDialog, MessagesController.getInstance().getUser(UserConfig.getClientUserId()), null);
+                                        TLRPC.Chat currentChat = MessagesController.getInstance().getChat((int) -selectedDialog);
+                                        if (currentChat != null && currentChat.left || currentChat instanceof TLRPC.TL_chatForbidden) {
+                                            MessagesController.getInstance().deleteDialog(selectedDialog, 0, false);
+                                        } else {
+                                            MessagesController.getInstance().deleteUserFromChat((int) -selectedDialog, MessagesController.getInstance().getUser(UserConfig.getClientUserId()), null);
+                                        }
                                     } else {
                                         MessagesController.getInstance().deleteDialog(selectedDialog, 0, false);
                                     }
@@ -549,39 +479,111 @@ public void onClick(DialogInterface dialogInterface, int i) {
                             }
                         });
                         builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                        showAlertDialog(builder);
+                        showDialog(builder.create());
                     }
                 });
-                builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                showAlertDialog(builder);
+                showDialog(builder.create());
+            }
+        });
+
+        searchEmptyView = new EmptyTextProgressView(context);
+        searchEmptyView.setVisibility(View.INVISIBLE);
+        searchEmptyView.setShowAtCenter(true);
+        searchEmptyView.setText(LocaleController.getString("NoResult", R.string.NoResult));
+        frameLayout.addView(searchEmptyView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
+
+        emptyView = new LinearLayout(context);
+        emptyView.setOrientation(LinearLayout.VERTICAL);
+        emptyView.setVisibility(View.INVISIBLE);
+        emptyView.setGravity(Gravity.CENTER);
+        frameLayout.addView(emptyView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
+        emptyView.setOnTouchListener(new View.OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
                 return true;
             }
         });
 
-        messagesListView.setOnScrollListener(new AbsListView.OnScrollListener() {
+        TextView textView = new TextView(context);
+        textView.setText(LocaleController.getString("NoChats", R.string.NoChats));
+        textView.setTextColor(0xff959595);
+        textView.setGravity(Gravity.CENTER);
+        textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20);
+        emptyView.addView(textView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT));
+
+        textView = new TextView(context);
+        String help = LocaleController.getString("NoChatsHelp", R.string.NoChatsHelp);
+        if (AndroidUtilities.isTablet() && !AndroidUtilities.isSmallTablet()) {
+            help = help.replace("\n", " ");
+        }
+        textView.setText(help);
+        textView.setTextColor(0xff959595);
+        textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15);
+        textView.setGravity(Gravity.CENTER);
+        textView.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(6), AndroidUtilities.dp(8), 0);
+        textView.setLineSpacing(AndroidUtilities.dp(2), 1);
+        emptyView.addView(textView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT));
+
+        progressView = new ProgressBar(context);
+        progressView.setVisibility(View.INVISIBLE);
+        frameLayout.addView(progressView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER));
+
+        floatingButton = new ImageView(context);
+        floatingButton.setVisibility(onlySelect ? View.GONE : View.VISIBLE);
+        floatingButton.setScaleType(ImageView.ScaleType.CENTER);
+        floatingButton.setBackgroundResource(R.drawable.floating_states);
+        floatingButton.setImageResource(R.drawable.floating_pencil);
+        if (Build.VERSION.SDK_INT >= 21) {
+            StateListAnimator animator = new StateListAnimator();
+            animator.addState(new int[]{android.R.attr.state_pressed}, ObjectAnimator.ofFloat(floatingButton, "translationZ", AndroidUtilities.dp(2), AndroidUtilities.dp(4)).setDuration(200));
+            animator.addState(new int[]{}, ObjectAnimator.ofFloat(floatingButton, "translationZ", AndroidUtilities.dp(4), AndroidUtilities.dp(2)).setDuration(200));
+            floatingButton.setStateListAnimator(animator);
+            floatingButton.setOutlineProvider(new ViewOutlineProvider() {
+                @SuppressLint("NewApi")
+                @Override
+                public void getOutline(View view, Outline outline) {
+                    outline.setOval(0, 0, AndroidUtilities.dp(56), AndroidUtilities.dp(56));
+                }
+            });
+        }
+        frameLayout.addView(floatingButton, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.BOTTOM, LocaleController.isRTL ? 14 : 0, 0, LocaleController.isRTL ? 0 : 14, 14));
+        floatingButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                Bundle args = new Bundle();
+                args.putBoolean("destroyAfterSelect", true);
+                presentFragment(new ContactsActivity(args));
+            }
+        });
+
+        listView.setOnScrollListener(new RecyclerView.OnScrollListener() {
             @Override
-            public void onScrollStateChanged(AbsListView absListView, int i) {
-                if (i == SCROLL_STATE_TOUCH_SCROLL && searching && searchWas) {
+            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
+                if (newState == RecyclerView.SCROLL_STATE_DRAGGING && searching && searchWas) {
                     AndroidUtilities.hideKeyboard(getParentActivity().getCurrentFocus());
                 }
             }
 
             @Override
-            public void onScroll(AbsListView absListView, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
+            public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
+                int firstVisibleItem = layoutManager.findFirstVisibleItemPosition();
+                int visibleItemCount = Math.abs(layoutManager.findLastVisibleItemPosition() - firstVisibleItem) + 1;
+                int totalItemCount = recyclerView.getAdapter().getItemCount();
+
                 if (searching && searchWas) {
-                    if (visibleItemCount > 0 && absListView.getLastVisiblePosition() == totalItemCount - 1 && !dialogsSearchAdapter.isMessagesSearchEndReached()) {
+                    if (visibleItemCount > 0 && layoutManager.findLastVisibleItemPosition() == totalItemCount - 1 && !dialogsSearchAdapter.isMessagesSearchEndReached()) {
                         dialogsSearchAdapter.loadMoreSearchMessages();
                     }
                     return;
                 }
                 if (visibleItemCount > 0) {
-                    if (absListView.getLastVisiblePosition() == MessagesController.getInstance().dialogs.size() && !serverOnly || absListView.getLastVisiblePosition() == MessagesController.getInstance().dialogsServerOnly.size() && serverOnly) {
+                    if (layoutManager.findLastVisibleItemPosition() == MessagesController.getInstance().dialogs.size() && !serverOnly || layoutManager.findLastVisibleItemPosition() == MessagesController.getInstance().dialogsServerOnly.size() && serverOnly) {
                         MessagesController.getInstance().loadDialogs(MessagesController.getInstance().dialogs.size(), MessagesController.getInstance().dialogsServerOnly.size(), 100, true);
                     }
                 }
 
                 if (floatingButton.getVisibility() != View.GONE) {
-                    final View topChild = absListView.getChildAt(0);
+                    final View topChild = recyclerView.getChildAt(0);
                     int firstViewTop = 0;
                     if (topChild != null) {
                         firstViewTop = topChild.getTop();
@@ -605,6 +607,42 @@ public void onScroll(AbsListView absListView, int firstVisibleItem, int visibleI
             }
         });
 
+        if (searchString == null) {
+            dialogsAdapter = new DialogsAdapter(context, serverOnly);
+            if (AndroidUtilities.isTablet() && openedDialogId != 0) {
+                dialogsAdapter.setOpenedDialogId(openedDialogId);
+            }
+            listView.setAdapter(dialogsAdapter);
+        }
+        int type = 0;
+        if (searchString != null) {
+            type = 2;
+        } else if (!onlySelect) {
+            type = 1;
+        }
+        dialogsSearchAdapter = new DialogsSearchAdapter(context, type);
+        dialogsSearchAdapter.setDelegate(new DialogsSearchAdapter.MessagesActivitySearchAdapterDelegate() {
+            @Override
+            public void searchStateChanged(boolean search) {
+                if (searching && searchWas && searchEmptyView != null) {
+                    if (search) {
+                        searchEmptyView.showProgress();
+                    } else {
+                        searchEmptyView.showTextView();
+                    }
+                }
+            }
+        });
+
+        if (MessagesController.getInstance().loadingDialogs && MessagesController.getInstance().dialogs.isEmpty()) {
+            searchEmptyView.setVisibility(View.INVISIBLE);
+            emptyView.setVisibility(View.INVISIBLE);
+            listView.setEmptyView(progressView);
+        } else {
+            searchEmptyView.setVisibility(View.INVISIBLE);
+            progressView.setVisibility(View.INVISIBLE);
+            listView.setEmptyView(emptyView);
+        }
         if (searchString != null) {
             actionBar.openSearchField(searchString);
         }
@@ -658,32 +696,32 @@ public void didReceivedNotification(int id, Object... args) {
             if (dialogsSearchAdapter != null) {
                 dialogsSearchAdapter.notifyDataSetChanged();
             }
-            if (messagesListView != null) {
+            if (listView != null) {
                 try {
                     if (MessagesController.getInstance().loadingDialogs && MessagesController.getInstance().dialogs.isEmpty()) {
                         searchEmptyView.setVisibility(View.INVISIBLE);
                         emptyView.setVisibility(View.INVISIBLE);
-                        messagesListView.setEmptyView(progressView);
+                        listView.setEmptyView(progressView);
                     } else {
+                        progressView.setVisibility(View.INVISIBLE);
                         if (searching && searchWas) {
-                            messagesListView.setEmptyView(searchEmptyView);
                             emptyView.setVisibility(View.INVISIBLE);
+                            listView.setEmptyView(searchEmptyView);
                         } else {
-                            messagesListView.setEmptyView(emptyView);
                             searchEmptyView.setVisibility(View.INVISIBLE);
+                            listView.setEmptyView(emptyView);
                         }
-                        progressView.setVisibility(View.INVISIBLE);
                     }
                 } catch (Exception e) {
                     FileLog.e("tmessages", e); //TODO fix it in other way?
                 }
             }
         } else if (id == NotificationCenter.emojiDidLoaded) {
-            if (messagesListView != null) {
+            if (listView != null) {
                 updateVisibleRows(0);
             }
         } else if (id == NotificationCenter.updateInterfaces) {
-            updateVisibleRows((Integer)args[0]);
+            updateVisibleRows((Integer) args[0]);
         } else if (id == NotificationCenter.appDidLogout) {
             dialogsLoaded = false;
         } else if (id == NotificationCenter.encryptedChatUpdated) {
@@ -692,8 +730,8 @@ public void didReceivedNotification(int id, Object... args) {
             updateVisibleRows(0);
         } else if (id == NotificationCenter.openedChatChanged) {
             if (!serverOnly && AndroidUtilities.isTablet()) {
-                boolean close = (Boolean)args[1];
-                long dialog_id = (Long)args[0];
+                boolean close = (Boolean) args[1];
+                long dialog_id = (Long) args[0];
                 if (close) {
                     if (dialog_id == openedDialogId) {
                         openedDialogId = 0;
@@ -743,22 +781,22 @@ private void hideFloatingButton(boolean hide) {
     }
 
     private void updateVisibleRows(int mask) {
-        if (messagesListView == null) {
+        if (listView == null) {
             return;
         }
-        int count = messagesListView.getChildCount();
+        int count = listView.getChildCount();
         for (int a = 0; a < count; a++) {
-            View child = messagesListView.getChildAt(a);
+            View child = listView.getChildAt(a);
             if (child instanceof DialogCell) {
                 DialogCell cell = (DialogCell) child;
                 if ((mask & MessagesController.UPDATE_MASK_NEW_MESSAGE) != 0) {
                     cell.checkCurrentDialogIndex();
                     if (!serverOnly && AndroidUtilities.isTablet()) {
-                        child.setBackgroundColor(cell.getDialogId() == openedDialogId ? 0x0f000000 : 0);
+                        cell.setDialogSelected(cell.getDialogId() == openedDialogId);
                     }
                 } else if ((mask & MessagesController.UPDATE_MASK_SELECT_DIALOG) != 0) {
                     if (!serverOnly && AndroidUtilities.isTablet()) {
-                        child.setBackgroundColor(cell.getDialogId() == openedDialogId ? 0x0f000000 : 0);
+                        cell.setDialogSelected(cell.getDialogId() == openedDialogId);
                     }
                 } else {
                     cell.update(mask);
@@ -788,8 +826,8 @@ private void didSelectResult(final long dialog_id, boolean useAlert, final boole
             }
             AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
             builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
-            int lower_part = (int)dialog_id;
-            int high_id = (int)(dialog_id >> 32);
+            int lower_part = (int) dialog_id;
+            int high_id = (int) (dialog_id >> 32);
             if (lower_part != 0) {
                 if (high_id == 1) {
                     TLRPC.Chat chat = MessagesController.getInstance().getChat(lower_part);
@@ -820,29 +858,15 @@ private void didSelectResult(final long dialog_id, boolean useAlert, final boole
                 }
                 builder.setMessage(LocaleController.formatStringSimple(selectAlertString, ContactsController.formatName(user.first_name, user.last_name)));
             }
-            CheckBox checkBox = null;
-            /*if (delegate instanceof ChatActivity) {
-                checkBox = new CheckBox(getParentActivity());
-                checkBox.setText(LocaleController.getString("ForwardFromMyName", R.string.ForwardFromMyName));
-                checkBox.setChecked(false);
-                builder.setView(checkBox);
-            }*/
-            final CheckBox checkBoxFinal = checkBox;
+
             builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
                 @Override
                 public void onClick(DialogInterface dialogInterface, int i) {
-                    didSelectResult(dialog_id, false, checkBoxFinal != null && checkBoxFinal.isChecked());
+                    didSelectResult(dialog_id, false, false);
                 }
             });
             builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-            showAlertDialog(builder);
-            if (checkBox != null) {
-                ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams)checkBox.getLayoutParams();
-                if (layoutParams != null) {
-                    layoutParams.rightMargin = layoutParams.leftMargin = AndroidUtilities.dp(10);
-                    checkBox.setLayoutParams(layoutParams);
-                }
-            }
+            showDialog(builder.create());
         } else {
             if (delegate != null) {
                 delegate.didSelectDialog(MessagesActivity.this, dialog_id, param);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/NotificationsSettingsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/NotificationsSettingsActivity.java
index 14868a899..a6d162c9a 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/NotificationsSettingsActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/NotificationsSettingsActivity.java
@@ -19,11 +19,13 @@
 import android.net.Uri;
 import android.os.Build;
 import android.provider.Settings;
+import android.view.Gravity;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.AdapterView;
 import android.widget.FrameLayout;
+import android.widget.LinearLayout;
 import android.widget.ListView;
 import android.widget.Toast;
 
@@ -356,16 +358,17 @@ public void onClick(DialogInterface dialogInterface, int i) {
                             }
                         });
                         builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                        showAlertDialog(builder);
+                        showDialog(builder.create());
                     }
                 } else if (i == messageLedRow || i == groupLedRow) {
                     if (getParentActivity() == null) {
                         return;
                     }
 
-                    LayoutInflater li = (LayoutInflater) getParentActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-                    view = li.inflate(R.layout.settings_color_dialog_layout, null, false);
-                    final ColorPickerView colorPickerView = (ColorPickerView) view.findViewById(R.id.color_picker);
+                    LinearLayout linearLayout = new LinearLayout(getParentActivity());
+                    linearLayout.setOrientation(LinearLayout.VERTICAL);
+                    final ColorPickerView colorPickerView = new ColorPickerView(getParentActivity());
+                    linearLayout.addView(colorPickerView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER));
 
                     SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Activity.MODE_PRIVATE);
                     if (i == messageLedRow) {
@@ -376,7 +379,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
 
                     AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
                     builder.setTitle(LocaleController.getString("LedColor", R.string.LedColor));
-                    builder.setView(view);
+                    builder.setView(linearLayout);
                     builder.setPositiveButton(LocaleController.getString("Set", R.string.Set), new DialogInterface.OnClickListener() {
                         @Override
                         public void onClick(DialogInterface dialogInterface, int which) {
@@ -405,7 +408,7 @@ public void onClick(DialogInterface dialog, int which) {
                             listView.invalidateViews();
                         }
                     });
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (i == messagePopupNotificationRow || i == groupPopupNotificationRow) {
                     AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
                     builder.setTitle(LocaleController.getString("PopupNotification", R.string.PopupNotification));
@@ -431,7 +434,7 @@ public void onClick(DialogInterface dialog, int which) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (i == messageVibrateRow || i == groupVibrateRow) {
                     AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
                     builder.setTitle(LocaleController.getString("Vibrate", R.string.Vibrate));
@@ -468,7 +471,7 @@ public void onClick(DialogInterface dialog, int which) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (i == messagePriorityRow || i == groupPriorityRow) {
                     AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
                     builder.setTitle(LocaleController.getString("NotificationsPriority", R.string.NotificationsPriority));
@@ -491,7 +494,7 @@ public void onClick(DialogInterface dialog, int which) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (i == repeatRow) {
                     AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
                     builder.setTitle(LocaleController.getString("RepeatNotifications", R.string.RepeatNotifications));
@@ -528,7 +531,7 @@ public void onClick(DialogInterface dialog, int which) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 }
                 if (view instanceof TextCheckCell) {
                     ((TextCheckCell) view).setChecked(!enabled);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PasscodeActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/PasscodeActivity.java
index 5cbf1d5ed..49333c45b 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/PasscodeActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/PasscodeActivity.java
@@ -37,7 +37,6 @@
 import android.widget.AdapterView;
 import android.widget.EditText;
 import android.widget.FrameLayout;
-import android.widget.LinearLayout;
 import android.widget.ListView;
 import android.widget.TextView;
 import android.widget.Toast;
@@ -392,7 +391,7 @@ public void onClick(DialogInterface dialog, int which) {
                                 UserConfig.saveConfig(false);
                             }
                         });
-                        showAlertDialog(builder);
+                        showDialog(builder.create());
                     }
                 }
             });
@@ -526,7 +525,20 @@ private void processDone() {
                 passwordEditText.setText("");
                 return;
             }
-            UserConfig.passcodeHash = Utilities.MD5(firstPassword);
+
+            try {
+                UserConfig.passcodeSalt = new byte[16];
+                Utilities.random.nextBytes(UserConfig.passcodeSalt);
+                byte[] passcodeBytes = firstPassword.getBytes("UTF-8");
+                byte[] bytes = new byte[32 + passcodeBytes.length];
+                System.arraycopy(UserConfig.passcodeSalt, 0, bytes, 0, 16);
+                System.arraycopy(passcodeBytes, 0, bytes, 16, passcodeBytes.length);
+                System.arraycopy(UserConfig.passcodeSalt, 0, bytes, passcodeBytes.length + 16, 16);
+                UserConfig.passcodeHash = Utilities.bytesToHex(Utilities.computeSHA256(bytes, 0, bytes.length));
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
+
             UserConfig.passcodeType = currentPasswordType;
             UserConfig.saveConfig(false);
             finishFragment();
@@ -534,7 +546,7 @@ private void processDone() {
             passwordEditText.clearFocus();
             AndroidUtilities.hideKeyboard(passwordEditText);
         } else if (type == 2) {
-            if (!Utilities.MD5(passwordEditText.getText().toString()).equals(UserConfig.passcodeHash)) {
+            if (!UserConfig.checkPasscode(passwordEditText.getText().toString())) {
                 passwordEditText.setText("");
                 onPasscodeError();
                 return;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PhotoAlbumPickerActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/PhotoAlbumPickerActivity.java
index 82c3db435..7b4922103 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/PhotoAlbumPickerActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/PhotoAlbumPickerActivity.java
@@ -534,7 +534,7 @@ public boolean hasStableIds() {
         public View getView(int i, View view, ViewGroup viewGroup) {
             int type = getItemViewType(i);
             if (type == 0) {
-                PhotoPickerAlbumsCell photoPickerAlbumsCell = null;
+                PhotoPickerAlbumsCell photoPickerAlbumsCell;
                 if (view == null) {
                     view = new PhotoPickerAlbumsCell(mContext);
                     photoPickerAlbumsCell = (PhotoPickerAlbumsCell) view;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PhotoPickerActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/PhotoPickerActivity.java
index ee45902c1..c737724f6 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/PhotoPickerActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/PhotoPickerActivity.java
@@ -281,7 +281,7 @@ public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
                         finishFragment();
                     }
                 } else {
-                    ArrayList<Object> arrayList = null;
+                    ArrayList<Object> arrayList;
                     if (selectedAlbum != null) {
                         arrayList = (ArrayList) selectedAlbum.photos;
                     } else {
@@ -319,7 +319,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                             }
                         });
                         builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                        showAlertDialog(builder);
+                        showDialog(builder.create());
                         return true;
                     }
                     return false;
@@ -471,7 +471,7 @@ private PhotoPickerPhotoCell getCellForIndex(int index) {
                         continue;
                     }
                 } else {
-                    ArrayList<MediaController.SearchImage> array = null;
+                    ArrayList<MediaController.SearchImage> array;
                     if (searchResult.isEmpty() && lastSearchString == null) {
                         array = recentImages;
                     } else {
@@ -527,7 +527,7 @@ public void updatePhotoAtIndex(int index) {
                     cell.photoImage.setImageResource(R.drawable.nophotos);
                 }
             } else {
-                ArrayList<MediaController.SearchImage> array = null;
+                ArrayList<MediaController.SearchImage> array;
                 if (searchResult.isEmpty() && lastSearchString == null) {
                     array = recentImages;
                 } else {
@@ -569,7 +569,7 @@ public void willSwitchFromPhoto(MessageObject messageObject, TLRPC.FileLocation
                     continue;
                 }
             } else {
-                ArrayList<MediaController.SearchImage> array = null;
+                ArrayList<MediaController.SearchImage> array;
                 if (searchResult.isEmpty() && lastSearchString == null) {
                     array = recentImages;
                 } else {
@@ -598,7 +598,7 @@ public boolean isPhotoChecked(int index) {
         if (selectedAlbum != null) {
             return !(index < 0 || index >= selectedAlbum.photos.size()) && selectedPhotos.containsKey(selectedAlbum.photos.get(index).imageId);
         } else {
-            ArrayList<MediaController.SearchImage> array = null;
+            ArrayList<MediaController.SearchImage> array;
             if (searchResult.isEmpty() && lastSearchString == null) {
                 array = recentImages;
             } else {
@@ -623,8 +623,8 @@ public void setPhotoChecked(int index) {
                 selectedPhotos.put(photoEntry.imageId, photoEntry);
             }
         } else {
-            MediaController.SearchImage photoEntry = null;
-            ArrayList<MediaController.SearchImage> array = null;
+            MediaController.SearchImage photoEntry;
+            ArrayList<MediaController.SearchImage> array;
             if (searchResult.isEmpty() && lastSearchString == null) {
                 array = recentImages;
             } else {
@@ -671,7 +671,7 @@ public void sendButtonPressed(int index) {
                 selectedPhotos.put(photoEntry.imageId, photoEntry);
             }
         } else if (selectedPhotos.isEmpty()) {
-            ArrayList<MediaController.SearchImage> array = null;
+            ArrayList<MediaController.SearchImage> array;
             if (searchResult.isEmpty() && lastSearchString == null) {
                 array = recentImages;
             } else {
@@ -798,7 +798,7 @@ private void searchBingImages(String query, int offset, int count) {
             if (nextSearchBingString != null) {
                 url = nextSearchBingString;
             } else {
-                boolean adult = false;
+                boolean adult;
                 String phone = UserConfig.getCurrentUser().phone;
                 adult = phone.startsWith("44") || phone.startsWith("49") || phone.startsWith("43") || phone.startsWith("31") || phone.startsWith("1");
                 url = String.format(Locale.US, "https://api.datamarket.azure.com/Bing/Search/v1/Image?Query='%s'&$skip=%d&$top=%d&$format=json%s", URLEncoder.encode(query, "UTF-8"), offset, count, adult ? "" : "&Adult='Off'");
@@ -913,7 +913,7 @@ private void fixLayoutInternal() {
         WindowManager manager = (WindowManager) ApplicationLoader.applicationContext.getSystemService(Activity.WINDOW_SERVICE);
         int rotation = manager.getDefaultDisplay().getRotation();
 
-        int columnsCount = 2;
+        int columnsCount;
         if (AndroidUtilities.isTablet()) {
             columnsCount = 3;
         } else {
@@ -1017,7 +1017,7 @@ public void onClick(View v) {
                                 ((PhotoPickerPhotoCell) v.getParent()).checkBox.setChecked(selectedPhotos.containsKey(photoEntry.imageId), true);
                             } else {
                                 AndroidUtilities.hideKeyboard(getParentActivity().getCurrentFocus());
-                                MediaController.SearchImage photoEntry = null;
+                                MediaController.SearchImage photoEntry;
                                 if (searchResult.isEmpty() && lastSearchString == null) {
                                     photoEntry = recentImages.get((Integer)((View)v.getParent()).getTag());
                                 } else {
@@ -1043,7 +1043,7 @@ public void onClick(View v) {
                 BackupImageView imageView = ((PhotoPickerPhotoCell) view).photoImage;
                 imageView.setTag(i);
                 view.setTag(i);
-                boolean showing = false;
+                boolean showing;
                 imageView.setOrientation(0, true);
 
                 if (selectedAlbum != null) {
@@ -1063,7 +1063,7 @@ public void onClick(View v) {
                     cell.checkBox.setChecked(selectedPhotos.containsKey(photoEntry.imageId), false);
                     showing = PhotoViewer.getInstance().isShowingImage(photoEntry.path);
                 } else {
-                    MediaController.SearchImage photoEntry = null;
+                    MediaController.SearchImage photoEntry;
                     if (searchResult.isEmpty() && lastSearchString == null) {
                         photoEntry = recentImages.get(i);
                     } else {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java b/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java
index 699433b21..270962eda 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java
@@ -991,6 +991,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                     checkImageView.setVisibility(View.GONE);
                     captionDoneItem.setVisibility(View.VISIBLE);
                     pickerView.setVisibility(View.GONE);
+                    captionTextView.clearAnimation();
                     captionTextView.setVisibility(View.INVISIBLE);
                     captionEditText.openKeyboard();
                     lastTitle = actionBar.getTitle();
@@ -1020,7 +1021,6 @@ public boolean canOpenMenu() {
         ActionBarMenu menu = actionBar.createMenu();
 
         menuItem = menu.addItem(0, R.drawable.ic_ab_other);
-        menuItem.setNeedOffset(false);
         menuItem.addSubItem(gallery_menu_showall, LocaleController.getString("ShowAllMedia", R.string.ShowAllMedia), 0);
         menuItem.addSubItem(gallery_menu_save, LocaleController.getString("SaveToGallery", R.string.SaveToGallery), 0);
         menuItem.addSubItem(gallery_menu_delete, LocaleController.getString("Delete", R.string.Delete), 0);
@@ -1181,10 +1181,13 @@ public void onClick(View view) {
 
         centerImage.setParentView(containerView);
         centerImage.setCrossfadeAlpha((byte) 2);
+        centerImage.setInvalidateAll(true);
         leftImage.setParentView(containerView);
         leftImage.setCrossfadeAlpha((byte) 2);
+        leftImage.setInvalidateAll(true);
         rightImage.setParentView(containerView);
         rightImage.setCrossfadeAlpha((byte) 2);
+        rightImage.setInvalidateAll(true);
 
         WindowManager manager = (WindowManager) ApplicationLoader.applicationContext.getSystemService(Activity.WINDOW_SERVICE);
         int rotation = manager.getDefaultDisplay().getRotation();
@@ -2133,6 +2136,7 @@ private void onPhotoShow(final MessageObject messageObject, final TLRPC.FileLoca
         mentionListView.setVisibility(View.GONE);
         editorDoneLayout.setVisibility(View.GONE);
         captionTextView.setTag(null);
+        captionTextView.clearAnimation();
         captionTextView.setVisibility(View.INVISIBLE);
         if (photoCropView != null) {
             photoCropView.clearAnimation();
@@ -2291,7 +2295,7 @@ private void setImageIndex(int index, boolean init) {
             long date = (long) currentMessageObject.messageOwner.date * 1000;
             String dateString = LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, LocaleController.formatterYear.format(new Date(date)), LocaleController.formatterDay.format(new Date(date)));
             if (currentFileNames[0] != null && currentFileNames[0].endsWith("mp4")) {
-                dateTextView.setText(String.format("%s (%s)", dateString, Utilities.formatFileSize(currentMessageObject.messageOwner.media.video.size)));
+                dateTextView.setText(String.format("%s (%s)", dateString, AndroidUtilities.formatFileSize(currentMessageObject.messageOwner.media.video.size)));
             } else {
                 dateTextView.setText(dateString);
             }
@@ -2474,6 +2478,7 @@ private void setCurrentCaption(final CharSequence caption) {
                 @Override
                 public void run() {
                     captionTextViewOld.setTag(null);
+                    captionTextViewOld.clearAnimation();
                     captionTextViewOld.setVisibility(View.INVISIBLE);
                     captionTextViewNew.setVisibility(bottomLayout.getVisibility() == View.VISIBLE || pickerView.getVisibility() == View.VISIBLE ? View.VISIBLE : View.INVISIBLE);
                 }
@@ -2602,7 +2607,7 @@ private void setIndexToImage(ImageReceiver imageReceiver, int index) {
                         imageSize = ((MediaController.SearchImage) object).size;
                     }
                 }
-                imageReceiver.setImage(path, String.format(Locale.US, "%d_%d", size, size), placeHolder != null ? new BitmapDrawable(null, placeHolder) : null, imageSize);
+                imageReceiver.setImage(path, String.format(Locale.US, "%d_%d", size, size), placeHolder != null ? new BitmapDrawable(null, placeHolder) : null, null, imageSize);
             } else {
                 imageReceiver.setImageBitmap((Bitmap) null);
             }
@@ -2628,7 +2633,7 @@ private void setIndexToImage(ImageReceiver imageReceiver, int index) {
                             placeHolder = currentThumb;
                         }
                         TLRPC.PhotoSize thumbLocation = FileLoader.getClosestPhotoSizeWithSize(messageObject.photoThumbs, 100);
-                        imageReceiver.setImage(null, null, null, placeHolder != null ? new BitmapDrawable(null, placeHolder) : null, thumbLocation.location, "b", 0, true);
+                        imageReceiver.setImage(null, null, null, placeHolder != null ? new BitmapDrawable(null, placeHolder) : null, thumbLocation.location, "b", 0, null, true);
                     } else {
                         imageReceiver.setImageBitmap(parentActivity.getResources().getDrawable(R.drawable.photoview_placeholder));
                     }
@@ -2642,7 +2647,7 @@ private void setIndexToImage(ImageReceiver imageReceiver, int index) {
                         size[0] = -1;
                     }
                     TLRPC.PhotoSize thumbLocation = messageObject != null ? FileLoader.getClosestPhotoSizeWithSize(messageObject.photoThumbs, 100) : null;
-                    imageReceiver.setImage(fileLocation, null, null, placeHolder != null ? new BitmapDrawable(null, placeHolder) : null, thumbLocation != null ? thumbLocation.location : null, "b", size[0], avatarsUserId != 0);
+                    imageReceiver.setImage(fileLocation, null, null, placeHolder != null ? new BitmapDrawable(null, placeHolder) : null, thumbLocation != null ? thumbLocation.location : null, "b", size[0], null, avatarsUserId != 0);
                 }
             } else {
                 imageReceiver.setNeedsQualityThumb(false);
@@ -2865,6 +2870,7 @@ public void onAnimationEnd(Object animation) {
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
                         public void run() {
+                            NotificationCenter.getInstance().setAnimationInProgress(false);
                             if (animationEndRunnable != null) {
                                 animationEndRunnable.run();
                                 animationEndRunnable = null;
@@ -2882,6 +2888,7 @@ public void onAnimationCancel(Object animation) {
             AndroidUtilities.runOnUIThread(new Runnable() {
                 @Override
                 public void run() {
+                    NotificationCenter.getInstance().setAnimationInProgress(true);
                     animatorSet.start();
                 }
             });
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PopupNotificationActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/PopupNotificationActivity.java
index 12515c1a5..d06f17a6d 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/PopupNotificationActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/PopupNotificationActivity.java
@@ -493,7 +493,7 @@ public void run() {
     }
 
     private void applyViewsLayoutParams(int xOffset) {
-        FrameLayout.LayoutParams layoutParams = null;
+        FrameLayout.LayoutParams layoutParams;
         int widht = AndroidUtilities.displaySize.x - AndroidUtilities.dp(24);
         if (leftView != null) {
             layoutParams = (FrameLayout.LayoutParams) leftView.getLayoutParams();
@@ -531,7 +531,7 @@ private ViewGroup getViewForMessage(int num, boolean applyOffset) {
         } else if (num == NotificationsController.getInstance().popupMessages.size()) {
             num = 0;
         }
-        ViewGroup view = null;
+        ViewGroup view;
         MessageObject messageObject = NotificationsController.getInstance().popupMessages.get(num);
         if (messageObject.type == 1 || messageObject.type == 4) {
             if (imageViews.size() > 0) {
@@ -595,7 +595,7 @@ public void onClick(View v) {
                 imageView.setImage(currentUrl, null, null);
             }
         } else if (messageObject.type == 2) {
-            PopupAudioView cell = null;
+            PopupAudioView cell;
             if (audioViews.size() > 0) {
                 view = audioViews.get(0);
                 audioViews.remove(0);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PrivacySettingsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/PrivacySettingsActivity.java
index 6fb67435a..6b6449365 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/PrivacySettingsActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/PrivacySettingsActivity.java
@@ -12,7 +12,6 @@
 import android.app.ProgressDialog;
 import android.content.Context;
 import android.content.DialogInterface;
-import android.view.Gravity;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
@@ -115,12 +114,7 @@ public void onItemClick(int id) {
         listView.setDividerHeight(0);
         listView.setVerticalScrollBarEnabled(false);
         listView.setDrawSelectorOnTop(true);
-        frameLayout.addView(listView);
-        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) listView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.gravity = Gravity.TOP;
-        listView.setLayoutParams(layoutParams);
+        frameLayout.addView(listView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
         listView.setAdapter(listAdapter);
         listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
             @Override
@@ -184,7 +178,7 @@ public void run() {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (i == lastSeenRow) {
                     presentFragment(new LastSeenActivity());
                 } else if (i == passwordRow) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ProfileActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ProfileActivity.java
index 84c5df504..980c185be 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ProfileActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ProfileActivity.java
@@ -10,6 +10,7 @@
 
 import android.animation.ObjectAnimator;
 import android.animation.StateListAnimator;
+import android.annotation.SuppressLint;
 import android.app.AlertDialog;
 import android.content.Context;
 import android.content.DialogInterface;
@@ -261,7 +262,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (id == add_contact) {
                     TLRPC.User user = MessagesController.getInstance().getUser(user_id);
                     Bundle args = new Bundle();
@@ -295,7 +296,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (id == add_member) {
                     openAddMember();
                 } else if (id == leave_group) {
@@ -309,7 +310,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (id == edit_name) {
                     Bundle args = new Bundle();
                     args.putInt("chat_id", chat_id);
@@ -427,7 +428,7 @@ public void onItemClick(AdapterView<?> adapterView, View view, final int i, long
                     if (getParentActivity() == null) {
                         return;
                     }
-                    showAlertDialog(AndroidUtilities.buildTTLAlert(getParentActivity(), currentEncryptedChat));
+                    showDialog(AndroidUtilities.buildTTLAlert(getParentActivity(), currentEncryptedChat).create());
                 } else if (i == settingsNotificationsRow) {
                     Bundle args = new Bundle();
                     if (user_id != 0) {
@@ -448,7 +449,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (i == phoneRow) {
                     final TLRPC.User user = MessagesController.getInstance().getUser(user_id);
                     if (user == null || user.phone == null || user.phone.length() == 0 || getParentActivity() == null) {
@@ -479,7 +480,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                             }
                         }
                     });
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (i > emptyRowChat2 && i < membersEndRow) {
                     int user_id = info.participants.get(sortedUsers.get(i - emptyRowChat2 - 1)).user_id;
                     if (user_id == UserConfig.getClientUserId()) {
@@ -522,7 +523,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                                 }
                             }
                         });
-                        showAlertDialog(builder);
+                        showDialog(builder.create());
 
                         return true;
                     }
@@ -555,6 +556,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                 animator.addState(new int[]{}, ObjectAnimator.ofFloat(writeButton, "translationZ", AndroidUtilities.dp(4), AndroidUtilities.dp(2)).setDuration(200));
                 writeButton.setStateListAnimator(animator);
                 writeButton.setOutlineProvider(new ViewOutlineProvider() {
+                    @SuppressLint("NewApi")
                     @Override
                     public void getOutline(View view, Outline outline) {
                         outline.setOval(0, 0, AndroidUtilities.dp(56), AndroidUtilities.dp(56));
@@ -607,7 +609,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                                 }
                             }
                         });
-                        showAlertDialog(builder);
+                        showDialog(builder.create());
                     }
                 }
             });
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ProfileNotificationsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ProfileNotificationsActivity.java
index 9ed9efbf6..103ac0c18 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ProfileNotificationsActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ProfileNotificationsActivity.java
@@ -160,7 +160,7 @@ public void onClick(DialogInterface dialog, int which) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (i == settingsNotificationsRow) {
                     if (getParentActivity() == null) {
                         return;
@@ -193,7 +193,7 @@ public void onClick(DialogInterface d, int which) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (i == settingsSoundRow) {
                     try {
                         Intent tmpIntent = new Intent(RingtoneManager.ACTION_RINGTONE_PICKER);
@@ -228,9 +228,10 @@ public void onClick(DialogInterface d, int which) {
                         return;
                     }
 
-                    LayoutInflater li = (LayoutInflater) getParentActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-                    view = li.inflate(R.layout.settings_color_dialog_layout, null, false);
-                    final ColorPickerView colorPickerView = (ColorPickerView) view.findViewById(R.id.color_picker);
+                    LinearLayout linearLayout = new LinearLayout(getParentActivity());
+                    linearLayout.setOrientation(LinearLayout.VERTICAL);
+                    final ColorPickerView colorPickerView = new ColorPickerView(getParentActivity());
+                    linearLayout.addView(colorPickerView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER));
 
                     SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Activity.MODE_PRIVATE);
                     if (preferences.contains("color_" + dialog_id)) {
@@ -245,7 +246,7 @@ public void onClick(DialogInterface d, int which) {
 
                     AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
                     builder.setTitle(LocaleController.getString("LedColor", R.string.LedColor));
-                    builder.setView(view);
+                    builder.setView(linearLayout);
                     builder.setPositiveButton(LocaleController.getString("Set", R.string.Set), new DialogInterface.OnClickListener() {
                         @Override
                         public void onClick(DialogInterface dialogInterface, int which) {
@@ -276,7 +277,7 @@ public void onClick(DialogInterface dialog, int which) {
                             listView.invalidateViews();
                         }
                     });
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (i == settingsPriorityRow) {
                     AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
                     builder.setTitle(LocaleController.getString("NotificationsPriority", R.string.NotificationsPriority));
@@ -301,7 +302,7 @@ public void onClick(DialogInterface dialog, int which) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (i == smartRow) {
                     if (getParentActivity() == null) {
                         return;
@@ -416,7 +417,7 @@ public void onClick(DialogInterface dialog, int which) {
                             }
                         }
                     });
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 }
             }
         });
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/SecretPhotoViewer.java b/TMessagesProj/src/main/java/org/telegram/ui/SecretPhotoViewer.java
index 682d366bb..368898919 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/SecretPhotoViewer.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/SecretPhotoViewer.java
@@ -265,7 +265,7 @@ public void openPhoto(MessageObject messageObject) {
         BitmapDrawable drawable = ImageLoader.getInstance().getImageFromMemory(sizeFull.location, null, null);
         if (drawable == null) {
             File file = FileLoader.getPathToAttach(sizeFull);
-            Bitmap bitmap = null;
+            Bitmap bitmap;
             try {
                 bitmap = BitmapFactory.decodeFile(file.getAbsolutePath());
             } catch (Throwable e) {
@@ -280,7 +280,7 @@ public void openPhoto(MessageObject messageObject) {
         if (drawable != null) {
             centerImage.setImageBitmap(drawable);
         } else {
-            centerImage.setImage(sizeFull.location, null, null, size, false);
+            centerImage.setImage(sizeFull.location, null, null, size, null, false);
         }
 
         currentMessageObject = messageObject;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/SessionsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/SessionsActivity.java
index c27a0a4c4..a7185bc3d 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/SessionsActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/SessionsActivity.java
@@ -224,7 +224,7 @@ public void run() {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (i >= otherSessionsStartRow && i < otherSessionsEndRow) {
                     AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
                     builder.setMessage(LocaleController.getString("TerminateSessionQuestion", R.string.TerminateSessionQuestion));
@@ -266,7 +266,7 @@ public void run() {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 }
             }
         });
@@ -336,7 +336,11 @@ private void updateRows() {
             currentSessionSectionRow = -1;
         }
         if (sessions.isEmpty()) {
-            noOtherSessionsRow = -1;
+            if (currentSession != null) {
+                noOtherSessionsRow = rowCount++;
+            } else {
+                noOtherSessionsRow = -1;
+            }
             terminateAllSessionsRow = -1;
             terminateAllSessionsDetailRow = -1;
             otherSessionsSectionRow = -1;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/SettingsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/SettingsActivity.java
index d1f33d3c6..2d5937e17 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/SettingsActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/SettingsActivity.java
@@ -10,6 +10,7 @@
 
 import android.animation.ObjectAnimator;
 import android.animation.StateListAnimator;
+import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.app.ProgressDialog;
@@ -118,6 +119,7 @@
     private int messagesSectionRow;
     private int messagesSectionRow2;
     private int textSizeRow;
+    private int stickersRow;
     private int sendByEnterRow;
     private int useSystemEmojiRow;
     private int supportSectionRow;
@@ -177,7 +179,7 @@ public void run(TLObject response, TLRPC.TL_error error) {
                             if (user == null) {
                                 return;
                             }
-                            TLRPC.TL_photos_photo photo = (TLRPC.TL_photos_photo)response;
+                            TLRPC.TL_photos_photo photo = (TLRPC.TL_photos_photo) response;
                             ArrayList<TLRPC.PhotoSize> sizes = photo.photo.sizes;
                             TLRPC.PhotoSize smallSize = FileLoader.getClosestPhotoSizeWithSize(sizes, 100);
                             TLRPC.PhotoSize bigSize = FileLoader.getClosestPhotoSizeWithSize(sizes, 1000);
@@ -232,6 +234,7 @@ public void run() {
         messagesSectionRow = rowCount++;
         messagesSectionRow2 = rowCount++;
         textSizeRow = rowCount++;
+        stickersRow = rowCount++;
         sendByEnterRow = rowCount++;
         useSystemEmojiRow = rowCount++;
         supportSectionRow = rowCount++;
@@ -295,20 +298,11 @@ public void onItemClick(int id) {
                     builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
                         @Override
                         public void onClick(DialogInterface dialogInterface, int i) {
-                            SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Activity.MODE_PRIVATE);
-                            SharedPreferences.Editor editor = preferences.edit();
-                            editor.clear().commit();
-                            MessagesController.getInstance().unregistedPush();
-                            MessagesController.getInstance().logOut();
-                            UserConfig.clearConfig();
-                            NotificationCenter.getInstance().postNotificationName(NotificationCenter.appDidLogout);
-                            MessagesStorage.getInstance().cleanUp(false);
-                            MessagesController.getInstance().cleanUp();
-                            ContactsController.getInstance().deleteAllAppAccounts();
+                            MessagesController.getInstance().performLogout(true);
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 }
             }
         });
@@ -324,15 +318,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
 
         avatarImage = new BackupImageView(context);
         avatarImage.setRoundRadius(AndroidUtilities.dp(30));
-        actionBar.addView(avatarImage);
-        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) avatarImage.getLayoutParams();
-        layoutParams.gravity = (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.BOTTOM;
-        layoutParams.width = AndroidUtilities.dp(60);
-        layoutParams.height = AndroidUtilities.dp(60);
-        layoutParams.leftMargin = LocaleController.isRTL ? 0 : AndroidUtilities.dp(17);
-        layoutParams.rightMargin = LocaleController.isRTL ? AndroidUtilities.dp(17) : 0;
-        layoutParams.bottomMargin = AndroidUtilities.dp(22);
-        avatarImage.setLayoutParams(layoutParams);
+        actionBar.addView(avatarImage, LayoutHelper.createFrame(60, 60, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.BOTTOM, LocaleController.isRTL ? 0 : 17, 0, LocaleController.isRTL ? 17 : 0, 22));
         avatarImage.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
@@ -353,15 +339,7 @@ public void onClick(View v) {
         nameTextView.setEllipsize(TextUtils.TruncateAt.END);
         nameTextView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT));
         nameTextView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
-        actionBar.addView(nameTextView);
-        layoutParams = (FrameLayout.LayoutParams) nameTextView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? 16 : 97);
-        layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? 97 : 16);
-        layoutParams.bottomMargin = AndroidUtilities.dp(51);
-        layoutParams.gravity = (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.BOTTOM;
-        nameTextView.setLayoutParams(layoutParams);
+        actionBar.addView(nameTextView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.BOTTOM, LocaleController.isRTL ? 16 : 97, 0, LocaleController.isRTL ? 97 : 16, 51));
 
         onlineTextView = new TextView(context);
         onlineTextView.setTextColor(AvatarDrawable.getProfileTextColorForId(5));
@@ -371,27 +349,14 @@ public void onClick(View v) {
         onlineTextView.setSingleLine(true);
         onlineTextView.setEllipsize(TextUtils.TruncateAt.END);
         onlineTextView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT));
-        actionBar.addView(onlineTextView);
-        layoutParams = (FrameLayout.LayoutParams) onlineTextView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? 16 : 97);
-        layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? 97 : 16);
-        layoutParams.bottomMargin = AndroidUtilities.dp(30);
-        layoutParams.gravity = (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.BOTTOM;
-        onlineTextView.setLayoutParams(layoutParams);
+        actionBar.addView(onlineTextView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.BOTTOM, LocaleController.isRTL ? 16 : 97, 0, LocaleController.isRTL ? 97 : 16, 30));
 
         listView = new ListView(context);
         listView.setDivider(null);
         listView.setDividerHeight(0);
         listView.setVerticalScrollBarEnabled(false);
         AndroidUtilities.setListViewEdgeEffectColor(listView, AvatarDrawable.getProfileBackColorForId(5));
-        frameLayout.addView(listView);
-        layoutParams = (FrameLayout.LayoutParams) listView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.gravity = Gravity.TOP;
-        listView.setLayoutParams(layoutParams);
+        frameLayout.addView(listView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT));
         listView.setAdapter(listAdapter);
         listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
             @Override
@@ -420,7 +385,7 @@ public void onClick(DialogInterface dialog, int which) {
                             }
                         }
                     });
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (i == enableAnimationsRow) {
                     SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("mainconfig", Activity.MODE_PRIVATE);
                     boolean animations = preferences.getBoolean("view_animations", true);
@@ -453,7 +418,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (i == sendLogsRow) {
                     sendLogs();
                 } else if (i == clearLogsRow) {
@@ -499,7 +464,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (i == telegramFaqRow) {
                     try {
                         Intent pickIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(LocaleController.getString("TelegramFaqUrl", R.string.TelegramFaqUrl)));
@@ -532,7 +497,7 @@ public void onClick(DialogInterface dialog, int which) {
                         }
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (i == wifiDownloadRow || i == mobileDownloadRow || i == roamingDownloadRow) {
                     if (getParentActivity() == null) {
                         return;
@@ -586,7 +551,7 @@ public void onClick(DialogInterface dialog, int which, boolean isChecked) {
 
                                     if (i == mobileDownloadRow) {
                                         editor.putInt("mobileDataDownloadMask", mask);
-                                        mask = MediaController.getInstance().mobileDataDownloadMask = mask;
+                                        MediaController.getInstance().mobileDataDownloadMask = mask;
                                     } else if (i == wifiDownloadRow) {
                                         editor.putInt("wifiDownloadMask", mask);
                                         MediaController.getInstance().wifiDownloadMask = mask;
@@ -601,11 +566,13 @@ public void onClick(DialogInterface dialog, int which, boolean isChecked) {
                                 }
                             });
                     builder.setNegativeButton(LocaleController.getString("OK", R.string.OK), null);
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else if (i == usernameRow) {
                     presentFragment(new ChangeUsernameActivity());
                 } else if (i == numberRow) {
                     presentFragment(new ChangePhoneHelpActivity());
+                } else if (i == stickersRow) {
+                    presentFragment(new StickersActivity());
                 }
             }
         });
@@ -622,20 +589,14 @@ public void onClick(DialogInterface dialog, int which, boolean isChecked) {
             animator.addState(new int[]{}, ObjectAnimator.ofFloat(writeButton, "translationZ", AndroidUtilities.dp(4), AndroidUtilities.dp(2)).setDuration(200));
             writeButton.setStateListAnimator(animator);
             writeButton.setOutlineProvider(new ViewOutlineProvider() {
+                @SuppressLint("NewApi")
                 @Override
                 public void getOutline(View view, Outline outline) {
                     outline.setOval(0, 0, AndroidUtilities.dp(56), AndroidUtilities.dp(56));
                 }
             });
         }
-        frameLayout.addView(writeButton);
-        layoutParams = (FrameLayout.LayoutParams) writeButton.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? 16 : 0);
-        layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? 0 : 16);
-        layoutParams.gravity = (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT);
-        writeButton.setLayoutParams(layoutParams);
+        frameLayout.addView(writeButton, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.TOP, LocaleController.isRTL ? 16 : 0, 0, LocaleController.isRTL ? 0 : 16, 0));
         writeButton.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
@@ -674,7 +635,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         }
                     }
                 });
-                showAlertDialog(builder);
+                showDialog(builder.create());
             }
         });
 
@@ -748,7 +709,8 @@ public Bitmap getThumbForPhoto(MessageObject messageObject, TLRPC.FileLocation f
     }
 
     @Override
-    public void willSwitchFromPhoto(MessageObject messageObject, TLRPC.FileLocation fileLocation, int index) { }
+    public void willSwitchFromPhoto(MessageObject messageObject, TLRPC.FileLocation fileLocation, int index) {
+    }
 
     @Override
     public void willHidePhotoViewer() {
@@ -756,19 +718,26 @@ public void willHidePhotoViewer() {
     }
 
     @Override
-    public boolean isPhotoChecked(int index) { return false; }
+    public boolean isPhotoChecked(int index) {
+        return false;
+    }
 
     @Override
-    public void setPhotoChecked(int index) { }
+    public void setPhotoChecked(int index) {
+    }
 
     @Override
-    public void cancelButtonPressed() { }
+    public void cancelButtonPressed() {
+    }
 
     @Override
-    public void sendButtonPressed(int index) { }
+    public void sendButtonPressed(int index) {
+    }
 
     @Override
-    public int getSelectedCount() { return 0; }
+    public int getSelectedCount() {
+        return 0;
+    }
 
     public void performAskAQuestion() {
         final SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("mainconfig", Activity.MODE_PRIVATE);
@@ -808,7 +777,7 @@ public void performAskAQuestion() {
                 public void run(TLObject response, TLRPC.TL_error error) {
                     if (error == null) {
 
-                        final TLRPC.TL_help_support res = (TLRPC.TL_help_support)response;
+                        final TLRPC.TL_help_support res = (TLRPC.TL_help_support) response;
                         AndroidUtilities.runOnUIThread(new Runnable() {
                             @Override
                             public void run() {
@@ -877,7 +846,7 @@ public void restoreSelfArgs(Bundle args) {
     @Override
     public void didReceivedNotification(int id, Object... args) {
         if (id == NotificationCenter.updateInterfaces) {
-            int mask = (Integer)args[0];
+            int mask = (Integer) args[0];
             if ((mask & MessagesController.UPDATE_MASK_AVATAR) != 0 || (mask & MessagesController.UPDATE_MASK_NAME) != 0) {
                 updateUserData();
             }
@@ -909,14 +878,14 @@ private void needLayout() {
         }
 
         if (avatarImage != null) {
-            float diff = actionBar.getExtraHeight() / (float)AndroidUtilities.dp(88);
+            float diff = actionBar.getExtraHeight() / (float) AndroidUtilities.dp(88);
             float diffm = 1.0f - diff;
 
-            int avatarSize = 42 + (int)(18 * diff);
-            int avatarX = 17 + (int)(47 * diffm);
-            int avatarY = AndroidUtilities.dp(22) - (int)((AndroidUtilities.dp(22) - (AndroidUtilities.getCurrentActionBarHeight() - AndroidUtilities.dp(42)) / 2) * (1.0f - diff));
-            int nameX = 97 + (int)(21 * diffm);
-            int nameEndX = 16 + (int)(32 * diffm);
+            int avatarSize = 42 + (int) (18 * diff);
+            int avatarX = 17 + (int) (47 * diffm);
+            int avatarY = AndroidUtilities.dp(22) - (int) ((AndroidUtilities.dp(22) - (AndroidUtilities.getCurrentActionBarHeight() - AndroidUtilities.dp(42)) / 2) * (1.0f - diff));
+            int nameX = 97 + (int) (21 * diffm);
+            int nameEndX = 16 + (int) (32 * diffm);
             int nameY = avatarY + AndroidUtilities.dp(29 - 13 * diffm);
             int statusY = avatarY + AndroidUtilities.dp(8 - 7 * diffm);
             float scale = 1.0f - 0.12f * diffm;
@@ -998,7 +967,7 @@ private void sendLogs() {
         try {
             ArrayList<Uri> uris = new ArrayList<>();
             File sdCard = ApplicationLoader.applicationContext.getExternalFilesDir(null);
-            File dir = new File (sdCard.getAbsolutePath() + "/logs");
+            File dir = new File(sdCard.getAbsolutePath() + "/logs");
             File[] files = dir.listFiles();
             for (File file : files) {
                 uris.add(Uri.fromFile(file));
@@ -1008,7 +977,7 @@ private void sendLogs() {
                 return;
             }
             Intent i = new Intent(Intent.ACTION_SEND_MULTIPLE);
-            i.setType("message/rfc822") ;
+            i.setType("message/rfc822");
             i.putExtra(Intent.EXTRA_EMAIL, new String[]{BuildVars.SEND_LOGS_EMAIL});
             i.putExtra(Intent.EXTRA_SUBJECT, "last logs");
             i.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uris);
@@ -1036,7 +1005,7 @@ public boolean isEnabled(int i) {
                     i == askQuestionRow || i == sendLogsRow || i == sendByEnterRow || i == privacyRow || i == wifiDownloadRow ||
                     i == mobileDownloadRow || i == clearLogsRow || i == roamingDownloadRow || i == usernameRow ||
                     i == switchBackendButtonRow || i == telegramFaqRow || i == contactsSortRow || i == contactsReimportRow || i == saveToGalleryRow ||
-                    i == useSystemEmojiRow;
+                    i == useSystemEmojiRow || i == stickersRow;
 
         }
 
@@ -1117,6 +1086,8 @@ public View getView(int i, View view, ViewGroup viewGroup) {
                     textCell.setText(LocaleController.getString("TelegramFAQ", R.string.TelegramFaq), true);
                 } else if (i == contactsReimportRow) {
                     textCell.setText(LocaleController.getString("ImportContacts", R.string.ImportContacts), true);
+                } else if (i == stickersRow) {
+                    textCell.setText(LocaleController.getString("Stickers", R.string.Stickers), true);
                 }
             } else if (type == 3) {
                 if (view == null) {
@@ -1166,7 +1137,7 @@ public View getView(int i, View view, ViewGroup viewGroup) {
                 TextDetailSettingsCell textCell = (TextDetailSettingsCell) view;
 
                 if (i == mobileDownloadRow || i == wifiDownloadRow || i == roamingDownloadRow) {
-                    int mask = 0;
+                    int mask;
                     String value;
                     SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("mainconfig", Activity.MODE_PRIVATE);
                     if (i == mobileDownloadRow) {
@@ -1232,11 +1203,12 @@ public View getView(int i, View view, ViewGroup viewGroup) {
         public int getItemViewType(int i) {
             if (i == emptyRow || i == overscrollRow) {
                 return 0;
-            } if (i == settingsSectionRow || i == supportSectionRow || i == messagesSectionRow || i == mediaDownloadSection || i == contactsSectionRow) {
+            }
+            if (i == settingsSectionRow || i == supportSectionRow || i == messagesSectionRow || i == mediaDownloadSection || i == contactsSectionRow) {
                 return 1;
             } else if (i == enableAnimationsRow || i == sendByEnterRow || i == saveToGalleryRow || i == useSystemEmojiRow) {
                 return 3;
-            } else if (i == notificationRow || i == backgroundRow || i == askQuestionRow || i == sendLogsRow || i == privacyRow || i == clearLogsRow || i == switchBackendButtonRow || i == telegramFaqRow || i == contactsReimportRow || i == textSizeRow || i == languageRow || i == contactsSortRow) {
+            } else if (i == notificationRow || i == backgroundRow || i == askQuestionRow || i == sendLogsRow || i == privacyRow || i == clearLogsRow || i == switchBackendButtonRow || i == telegramFaqRow || i == contactsReimportRow || i == textSizeRow || i == languageRow || i == contactsSortRow || i == stickersRow) {
                 return 2;
             } else if (i == versionRow) {
                 return 5;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/StickersActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/StickersActivity.java
new file mode 100644
index 000000000..ce76b2d02
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/StickersActivity.java
@@ -0,0 +1,316 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2014.
+ */
+
+package org.telegram.ui;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.os.Build;
+import android.os.Message;
+import android.text.SpannableStringBuilder;
+import android.text.Spanned;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.FrameLayout;
+import android.widget.ListView;
+import android.widget.Toast;
+
+import org.telegram.android.LocaleController;
+import org.telegram.android.MessagesController;
+import org.telegram.android.NotificationCenter;
+import org.telegram.android.query.StickersQuery;
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.R;
+import org.telegram.messenger.TLRPC;
+import org.telegram.ui.ActionBar.ActionBar;
+import org.telegram.ui.ActionBar.BaseFragment;
+import org.telegram.ui.Adapters.BaseFragmentAdapter;
+import org.telegram.ui.Cells.StickerSetCell;
+import org.telegram.ui.Cells.TextInfoPrivacyCell;
+import org.telegram.ui.Components.LayoutHelper;
+import org.telegram.ui.Components.StickersAlert;
+import org.telegram.ui.Components.URLSpanNoUnderline;
+
+import java.util.ArrayList;
+import java.util.Locale;
+
+public class StickersActivity extends BaseFragment implements NotificationCenter.NotificationCenterDelegate {
+
+    private ListAdapter listAdapter;
+
+    private int stickersStartRow;
+    private int stickersEndRow;
+    private int stickersInfoRow;
+    private int rowCount;
+
+    @Override
+    public boolean onFragmentCreate() {
+        super.onFragmentCreate();
+        StickersQuery.checkStickers();
+        NotificationCenter.getInstance().addObserver(this, NotificationCenter.stickersDidLoaded);
+        updateRows();
+        return true;
+    }
+
+    @Override
+    public void onFragmentDestroy() {
+        super.onFragmentDestroy();
+        NotificationCenter.getInstance().removeObserver(this, NotificationCenter.stickersDidLoaded);
+    }
+
+    @Override
+    public View createView(Context context, LayoutInflater inflater) {
+        actionBar.setBackButtonImage(R.drawable.ic_ab_back);
+        actionBar.setAllowOverlayTitle(true);
+        actionBar.setTitle(LocaleController.getString("Stickers", R.string.Stickers));
+        actionBar.setActionBarMenuOnItemClick(new ActionBar.ActionBarMenuOnItemClick() {
+            @Override
+            public void onItemClick(int id) {
+                if (id == -1) {
+                    finishFragment();
+                }
+            }
+        });
+
+        listAdapter = new ListAdapter(context);
+
+        fragmentView = new FrameLayout(context);
+        FrameLayout frameLayout = (FrameLayout) fragmentView;
+        frameLayout.setBackgroundColor(0xfff0f0f0);
+
+        ListView listView = new ListView(context);
+        listView.setDivider(null);
+        listView.setDividerHeight(0);
+        listView.setVerticalScrollBarEnabled(false);
+        listView.setDrawSelectorOnTop(true);
+        frameLayout.addView(listView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
+        listView.setAdapter(listAdapter);
+        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> adapterView, View view, final int i, long l) {
+                if (i >= stickersStartRow && i < stickersEndRow && getParentActivity() != null) {
+                    final TLRPC.TL_stickerSet stickerSet = StickersQuery.getStickerSets().get(i);
+                    ArrayList<TLRPC.Document> stickers = StickersQuery.getStickersForSet(stickerSet.id);
+                    if (stickers == null) {
+                        return;
+                    }
+                    StickersAlert alert = new StickersAlert(getParentActivity(), stickerSet, stickers);
+                    alert.setButton(AlertDialog.BUTTON_NEGATIVE, LocaleController.getString("Close", R.string.Close), (Message) null);
+                    if (stickerSet.id != -1) {
+                        alert.setButton(AlertDialog.BUTTON_NEUTRAL, LocaleController.getString("StickersRemove", R.string.StickersRemove), new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                StickersQuery.removeStickersSet(getParentActivity(), stickerSet);
+                            }
+                        });
+                    }
+                    setVisibleDialog(alert);
+                    alert.show();
+                }
+            }
+        });
+
+        return fragmentView;
+    }
+
+    @Override
+    public void didReceivedNotification(int id, Object... args) {
+        if (id == NotificationCenter.stickersDidLoaded) {
+            updateRows();
+        }
+    }
+
+    private void updateRows() {
+        rowCount = 0;
+        ArrayList<TLRPC.TL_stickerSet> stickerSets = StickersQuery.getStickerSets();
+        if (!stickerSets.isEmpty()) {
+            stickersStartRow = 0;
+            stickersEndRow = stickerSets.size();
+            rowCount += stickerSets.size();
+        } else {
+            stickersStartRow = -1;
+            stickersEndRow = -1;
+        }
+        stickersInfoRow = rowCount++;
+        if (listAdapter != null) {
+            listAdapter.notifyDataSetChanged();
+        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        if (listAdapter != null) {
+            listAdapter.notifyDataSetChanged();
+        }
+    }
+
+    private class ListAdapter extends BaseFragmentAdapter {
+        private Context mContext;
+
+        public ListAdapter(Context context) {
+            mContext = context;
+        }
+
+        @Override
+        public boolean areAllItemsEnabled() {
+            return false;
+        }
+
+        @Override
+        public boolean isEnabled(int i) {
+            return i >= stickersStartRow && i < stickersEndRow;
+        }
+
+        @Override
+        public int getCount() {
+            return rowCount;
+        }
+
+        @Override
+        public Object getItem(int i) {
+            return null;
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return i;
+        }
+
+        @Override
+        public boolean hasStableIds() {
+            return false;
+        }
+
+        @Override
+        public View getView(int i, View view, ViewGroup viewGroup) {
+            int type = getItemViewType(i);
+            if (type == 0) {
+                if (view == null) {
+                    view = new StickerSetCell(mContext);
+                    view.setBackgroundColor(0xffffffff);
+                    ((StickerSetCell) view).setOnOptionsClick(new View.OnClickListener() {
+                        @Override
+                        public void onClick(View v) {
+                            StickerSetCell cell = (StickerSetCell) v.getParent();
+                            final TLRPC.TL_stickerSet stickerSet = cell.getStickersSet();
+                            AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                            CharSequence[] items;
+                            if (stickerSet.id == -1) {
+                                builder.setTitle(LocaleController.getString("GeniusStickerPackName", R.string.GeniusStickerPackName));
+                                items = new CharSequence[]{
+                                        StickersQuery.getHideMainStickersPack() ? LocaleController.getString("StickersShow", R.string.StickersShow) : LocaleController.getString("StickersHide", R.string.StickersHide)
+                                };
+                            } else {
+                                builder.setTitle(stickerSet.title);
+                                items = new CharSequence[]{
+                                        LocaleController.getString("StickersRemove", R.string.StickersRemove),
+                                        LocaleController.getString("StickersShare", R.string.StickersShare),
+                                        LocaleController.getString("StickersCopy", R.string.StickersCopy),
+                                };
+                            }
+                            builder.setItems(items, new DialogInterface.OnClickListener() {
+                                @Override
+                                public void onClick(DialogInterface dialog, int which) {
+                                    if (which == 0) {
+                                        if (stickerSet.id == -1) {
+                                            StickersQuery.setHideMainStickersPack(!StickersQuery.getHideMainStickersPack());
+                                            listAdapter.notifyDataSetChanged();
+                                            StickersQuery.loadStickers(true, false);
+                                        } else {
+                                            StickersQuery.removeStickersSet(getParentActivity(), stickerSet);
+                                        }
+                                    } else if (which == 1) {
+                                        try {
+                                            Intent intent = new Intent(Intent.ACTION_SEND);
+                                            intent.setType("text/plain");
+                                            intent.putExtra(Intent.EXTRA_TEXT, String.format(Locale.US, "https://telegram.me/addstickers/%s", stickerSet.short_name));
+                                            getParentActivity().startActivityForResult(Intent.createChooser(intent, LocaleController.getString("StickersShare", R.string.StickersShare)), 500);
+                                        } catch (Exception e) {
+                                            FileLog.e("tmessages", e);
+                                        }
+                                    } else if (which == 2) {
+                                        try {
+                                            if (Build.VERSION.SDK_INT < 11) {
+                                                android.text.ClipboardManager clipboard = (android.text.ClipboardManager) ApplicationLoader.applicationContext.getSystemService(Context.CLIPBOARD_SERVICE);
+                                                clipboard.setText(String.format(Locale.US, "https://telegram.me/addstickers/%s", stickerSet.short_name));
+                                            } else {
+                                                android.content.ClipboardManager clipboard = (android.content.ClipboardManager) ApplicationLoader.applicationContext.getSystemService(Context.CLIPBOARD_SERVICE);
+                                                android.content.ClipData clip = android.content.ClipData.newPlainText("label", String.format(Locale.US, "https://telegram.me/addstickers/%s", stickerSet.short_name));
+                                                clipboard.setPrimaryClip(clip);
+                                            }
+                                            Toast.makeText(getParentActivity(), LocaleController.getString("LinkCopied", R.string.LinkCopied), Toast.LENGTH_SHORT).show();
+                                        } catch (Exception e) {
+                                            FileLog.e("tmessages", e);
+                                        }
+                                    }
+                                }
+                            });
+                            //builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
+                            showDialog(builder.create());
+                        }
+                    });
+                }
+                ArrayList<TLRPC.TL_stickerSet> arrayList = StickersQuery.getStickerSets();
+                ((StickerSetCell) view).setStickersSet(arrayList.get(i), i != arrayList.size() - 1);
+            } else if (type == 1) {
+                if (view == null) {
+                    view = new TextInfoPrivacyCell(mContext);
+                    String text = LocaleController.getString("StickersInfo", R.string.StickersInfo);
+                    String botName = "@stickers";
+                    int index = text.indexOf(botName);
+                    if (index != -1) {
+                        try {
+                            SpannableStringBuilder stringBuilder = new SpannableStringBuilder(text);
+                            URLSpanNoUnderline spanNoUnderline = new URLSpanNoUnderline("@stickers") {
+                                @Override
+                                public void onClick(View widget) {
+                                    MessagesController.openByUserName("stickers", StickersActivity.this, 1);
+                                }
+                            };
+                            stringBuilder.setSpan(spanNoUnderline, index, index + botName.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);
+                            ((TextInfoPrivacyCell) view).setText(stringBuilder);
+                        } catch (Exception e) {
+                            FileLog.e("tmessages", e);
+                            ((TextInfoPrivacyCell) view).setText(text);
+                        }
+                    } else {
+                        ((TextInfoPrivacyCell) view).setText(text);
+                    }
+                    view.setBackgroundResource(R.drawable.greydivider_bottom);
+                }
+            }
+            return view;
+        }
+
+        @Override
+        public int getItemViewType(int i) {
+            if (i >= stickersStartRow && i < stickersEndRow) {
+                return 0;
+            } else if (i == stickersInfoRow) {
+                return 1;
+            }
+            return 0;
+        }
+
+        @Override
+        public int getViewTypeCount() {
+            return 2;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return false;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/TwoStepVerificationActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/TwoStepVerificationActivity.java
index b9c8aeb5f..079bf6926 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/TwoStepVerificationActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/TwoStepVerificationActivity.java
@@ -9,6 +9,7 @@
 package org.telegram.ui;
 
 import android.app.AlertDialog;
+import android.app.Dialog;
 import android.app.ProgressDialog;
 import android.content.Context;
 import android.content.DialogInterface;
@@ -314,7 +315,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                                                     presentFragment(fragment);
                                                 }
                                             });
-                                            AlertDialog dialog = showAlertDialog(builder);
+                                            Dialog dialog = showDialog(builder.create());
                                             if (dialog != null) {
                                                 dialog.setCanceledOnTouchOutside(false);
                                                 dialog.setCancelable(false);
@@ -355,7 +356,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                             }
                         });
                         builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                        showAlertDialog(builder);
+                        showDialog(builder.create());
                     }
                 }
             }
@@ -422,7 +423,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                             }
                         });
                         builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                        showAlertDialog(builder);
+                        showDialog(builder.create());
                     }
                 }
             });
@@ -696,7 +697,7 @@ private void showAlertWithText(String title, String text) {
         builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
         builder.setTitle(title);
         builder.setMessage(text);
-        showAlertDialog(builder);
+        showDialog(builder.create());
     }
 
     private void setNewPassword(final boolean clear) {
@@ -707,6 +708,7 @@ private void setNewPassword(final boolean clear) {
             if (waitingForEmail && currentPassword instanceof TLRPC.TL_account_noPassword) {
                 req.new_settings.flags = 2;
                 req.new_settings.email = "";
+                req.current_password_hash = new byte[0];
             } else {
                 req.new_settings.flags = 3;
                 req.new_settings.hint = "";
@@ -766,7 +768,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                                 });
                                 builder.setMessage(LocaleController.getString("YourPasswordSuccessText", R.string.YourPasswordSuccessText));
                                 builder.setTitle(LocaleController.getString("YourPasswordSuccess", R.string.YourPasswordSuccess));
-                                AlertDialog dialog = showAlertDialog(builder);
+                                Dialog dialog = showDialog(builder.create());
                                 if (dialog != null) {
                                     dialog.setCanceledOnTouchOutside(false);
                                     dialog.setCancelable(false);
@@ -784,7 +786,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                                 });
                                 builder.setMessage(LocaleController.getString("YourEmailAlmostThereText", R.string.YourEmailAlmostThereText));
                                 builder.setTitle(LocaleController.getString("YourEmailAlmostThere", R.string.YourEmailAlmostThere));
-                                AlertDialog dialog = showAlertDialog(builder);
+                                Dialog dialog = showDialog(builder.create());
                                 if (dialog != null) {
                                     dialog.setCanceledOnTouchOutside(false);
                                     dialog.setCancelable(false);
@@ -937,7 +939,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                                     });
                                     builder.setMessage(LocaleController.getString("PasswordReset", R.string.PasswordReset));
                                     builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
-                                    AlertDialog dialog = showAlertDialog(builder);
+                                    Dialog dialog = showDialog(builder.create());
                                     if (dialog != null) {
                                         dialog.setCanceledOnTouchOutside(false);
                                         dialog.setCancelable(false);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/VideoEditorActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/VideoEditorActivity.java
index 1c794ab99..37fa05bf4 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/VideoEditorActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/VideoEditorActivity.java
@@ -47,7 +47,6 @@
 import org.telegram.messenger.ApplicationLoader;
 import org.telegram.messenger.FileLog;
 import org.telegram.messenger.R;
-import org.telegram.messenger.Utilities;
 import org.telegram.ui.ActionBar.ActionBar;
 import org.telegram.ui.ActionBar.ActionBarMenu;
 import org.telegram.ui.ActionBar.BaseFragment;
@@ -105,7 +104,7 @@
     private Runnable progressRunnable = new Runnable() {
         @Override
         public void run() {
-            boolean playerCheck = false;
+            boolean playerCheck;
 
             while (true) {
                 synchronized (sync) {
@@ -491,7 +490,7 @@ private void updateVideoOriginalInfo() {
         long duration = (long)Math.ceil(videoDuration);
         int minutes = (int)(duration / 1000 / 60);
         int seconds = (int) Math.ceil(duration / 1000) - minutes * 60;
-        String videoTimeSize = String.format("%d:%02d, %s", minutes, seconds, Utilities.formatFileSize(originalSize));
+        String videoTimeSize = String.format("%d:%02d, %s", minutes, seconds, AndroidUtilities.formatFileSize(originalSize));
         originalSizeTextView.setText(String.format("%s, %s", videoDimension, videoTimeSize));
     }
 
@@ -501,8 +500,8 @@ private void updateVideoEditedInfo() {
         }
         esimatedDuration = (long)Math.ceil((videoTimelineView.getRightProgress() - videoTimelineView.getLeftProgress()) * videoDuration);
 
-        int width = 0;
-        int height = 0;
+        int width;
+        int height;
 
         if (compressVideo.getVisibility() == View.GONE || compressVideo.getVisibility() == View.VISIBLE && !compressVideo.isChecked()) {
             width = rotationValue == 90 || rotationValue == 270 ? originalHeight : originalWidth;
@@ -528,7 +527,7 @@ private void updateVideoEditedInfo() {
         String videoDimension = String.format("%dx%d", width, height);
         int minutes = (int)(esimatedDuration / 1000 / 60);
         int seconds = (int) Math.ceil(esimatedDuration / 1000) - minutes * 60;
-        String videoTimeSize = String.format("%d:%02d, ~%s", minutes, seconds, Utilities.formatFileSize(estimatedSize));
+        String videoTimeSize = String.format("%d:%02d, ~%s", minutes, seconds, AndroidUtilities.formatFileSize(estimatedSize));
         editedSizeTextView.setText(String.format("%s, %s", videoDimension, videoTimeSize));
     }
 
@@ -536,15 +535,15 @@ private void fixVideoSize() {
         if (fragmentView == null || getParentActivity() == null) {
             return;
         }
-        int viewHeight = 0;
+        int viewHeight;
         if (AndroidUtilities.isTablet()) {
             viewHeight = AndroidUtilities.dp(472);
         } else {
             viewHeight = AndroidUtilities.displaySize.y - AndroidUtilities.statusBarHeight - AndroidUtilities.getCurrentActionBarHeight();
         }
 
-        int width = 0;
-        int height = 0;
+        int width;
+        int height;
         if (AndroidUtilities.isTablet()) {
             width = AndroidUtilities.dp(490);
             height = viewHeight - AndroidUtilities.dp(276 + (compressVideo.getVisibility() == View.VISIBLE ? 20 : 0));
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/WallpapersActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/WallpapersActivity.java
index ab3380f21..1689a0e62 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/WallpapersActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/WallpapersActivity.java
@@ -14,24 +14,26 @@
 import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.SharedPreferences;
-import android.content.res.Configuration;
 import android.graphics.Bitmap;
 import android.graphics.Point;
-import android.graphics.drawable.Drawable;
 import android.net.Uri;
+import android.os.Build;
 import android.os.Bundle;
 import android.provider.MediaStore;
+import android.view.Gravity;
 import android.view.LayoutInflater;
+import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewGroup;
-import android.view.ViewTreeObserver;
-import android.widget.AdapterView;
+import android.widget.FrameLayout;
 import android.widget.ImageView;
 import android.widget.ProgressBar;
 
 import org.telegram.android.AndroidUtilities;
 import org.telegram.android.ImageLoader;
 import org.telegram.android.LocaleController;
+import org.telegram.android.support.widget.LinearLayoutManager;
+import org.telegram.android.support.widget.RecyclerView;
 import org.telegram.messenger.ApplicationLoader;
 import org.telegram.messenger.TLObject;
 import org.telegram.messenger.TLRPC;
@@ -42,13 +44,13 @@
 import org.telegram.android.NotificationCenter;
 import org.telegram.messenger.R;
 import org.telegram.messenger.RPCRequest;
-import org.telegram.messenger.Utilities;
-import org.telegram.ui.Adapters.BaseFragmentAdapter;
+
 import org.telegram.ui.ActionBar.ActionBar;
 import org.telegram.ui.ActionBar.ActionBarMenu;
-import org.telegram.ui.Components.BackupImageView;
+import org.telegram.ui.Cells.WallpaperCell;
 import org.telegram.ui.ActionBar.BaseFragment;
-import org.telegram.ui.Components.HorizontalListView;
+import org.telegram.ui.Components.LayoutHelper;
+import org.telegram.ui.Components.RecyclerListView;
 
 import java.io.File;
 import java.io.FileOutputStream;
@@ -57,7 +59,6 @@
 
 public class WallpapersActivity extends BaseFragment implements NotificationCenter.NotificationCenterDelegate {
 
-    private HorizontalListView listView;
     private ListAdapter listAdapter;
     private ImageView backgroundImage;
     private ProgressBar progressBar;
@@ -126,7 +127,7 @@ public void onItemClick(int id) {
                         File f = new File(FileLoader.getInstance().getDirectory(FileLoader.MEDIA_DIR_CACHE), fileName);
                         File toFile = new File(ApplicationLoader.applicationContext.getFilesDir(), "wallpaper.jpg");
                         try {
-                            done = Utilities.copyFile(f, toFile);
+                            done = AndroidUtilities.copyFile(f, toFile);
                         } catch (Exception e) {
                             done = false;
                             FileLog.e("tmessages", e);
@@ -157,17 +158,40 @@ public void onItemClick(int id) {
         ActionBarMenu menu = actionBar.createMenu();
         doneButton = menu.addItemWithWidth(done_button, R.drawable.ic_done, AndroidUtilities.dp(56));
 
-        fragmentView = inflater.inflate(R.layout.settings_wallpapers_layout, null, false);
-        listAdapter = new ListAdapter(context);
+        FrameLayout frameLayout = new FrameLayout(context);
+        fragmentView = frameLayout;
 
-        progressBar = (ProgressBar) fragmentView.findViewById(R.id.action_progress);
-        backgroundImage = (ImageView) fragmentView.findViewById(R.id.background_image);
-        listView = (HorizontalListView) fragmentView.findViewById(R.id.listView);
-        listView.setAdapter(listAdapter);
-        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+        backgroundImage = new ImageView(context);
+        backgroundImage.setScaleType(ImageView.ScaleType.CENTER_CROP);
+        frameLayout.addView(backgroundImage, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
+        backgroundImage.setOnTouchListener(new View.OnTouchListener() {
             @Override
-            public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
-                if (i == 0) {
+            public boolean onTouch(View v, MotionEvent event) {
+                return true;
+            }
+        });
+
+        progressBar = new ProgressBar(context);
+        progressBar.setPadding(AndroidUtilities.dp(6), AndroidUtilities.dp(6), AndroidUtilities.dp(6), AndroidUtilities.dp(6));
+        frameLayout.addView(progressBar, LayoutHelper.createFrame(60, 60, Gravity.CENTER, 0, 0, 0, 52));
+
+        RecyclerListView listView = new RecyclerListView(context);
+        listView.setClipToPadding(false);
+        listView.setPadding(AndroidUtilities.dp(40), 0, AndroidUtilities.dp(40), 0);
+        LinearLayoutManager layoutManager = new LinearLayoutManager(context);
+        layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);
+        listView.setLayoutManager(layoutManager);
+        listView.setClipToPadding(false);
+        listView.setDisallowInterceptTouchEvents(true);
+        if (Build.VERSION.SDK_INT >= 9) {
+            listView.setOverScrollMode(RecyclerListView.OVER_SCROLL_NEVER);
+        }
+        listView.setAdapter(listAdapter = new ListAdapter(context));
+        frameLayout.addView(listView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 102, Gravity.LEFT | Gravity.BOTTOM));
+        listView.setOnItemClickListener(new RecyclerListView.OnItemClickListener() {
+            @Override
+            public void onItemClick(View view, int position) {
+                if (position == 0) {
                     if (getParentActivity() == null) {
                         return;
                     }
@@ -181,7 +205,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                             try {
                                 if (i == 0) {
                                     Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
-                                    File image = Utilities.generatePicturePath();
+                                    File image = AndroidUtilities.generatePicturePath();
                                     if (image != null) {
                                         takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(image));
                                         currentPicturePath = image.getAbsolutePath();
@@ -197,9 +221,12 @@ public void onClick(DialogInterface dialogInterface, int i) {
                             }
                         }
                     });
-                    showAlertDialog(builder);
+                    showDialog(builder.create());
                 } else {
-                    TLRPC.WallPaper wallPaper = wallPapers.get(i - 1);
+                    if (position - 1 < 0 || position - 1 >= wallPapers.size()) {
+                        return;
+                    }
+                    TLRPC.WallPaper wallPaper = wallPapers.get(position - 1);
                     selectedBackground = wallPaper.id;
                     listAdapter.notifyDataSetChanged();
                     processSelectedBackground();
@@ -216,7 +243,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
     public void onActivityResultFragment(int requestCode, int resultCode, Intent data) {
         if (resultCode == Activity.RESULT_OK) {
             if (requestCode == 10) {
-                Utilities.addMediaToGallery(currentPicturePath);
+                AndroidUtilities.addMediaToGallery(currentPicturePath);
                 FileOutputStream stream = null;
                 try {
                     Point screenSize = AndroidUtilities.getRealScreenSize();
@@ -292,7 +319,7 @@ private void processSelectedBackground() {
                 progressBar.setVisibility(View.VISIBLE);
                 loadingSize = size;
                 selectedColor = 0;
-                FileLoader.getInstance().loadFile(size, true);
+                FileLoader.getInstance().loadFile(size, null, true);
                 backgroundImage.setBackgroundColor(0);
             } else {
                 if (loadingFile != null) {
@@ -352,7 +379,7 @@ private void processSelectedBackground() {
     @Override
     public void didReceivedNotification(int id, final Object... args) {
         if (id == NotificationCenter.FileDidFailedLoad) {
-            String location = (String)args[0];
+            String location = (String) args[0];
             if (loadingFile != null && loadingFile.equals(location)) {
                 loadingFileObject = null;
                 loadingFile = null;
@@ -361,7 +388,7 @@ public void didReceivedNotification(int id, final Object... args) {
                 doneButton.setEnabled(false);
             }
         } else if (id == NotificationCenter.FileDidLoaded) {
-            String location = (String)args[0];
+            String location = (String) args[0];
             if (loadingFile != null && loadingFile.equals(location)) {
                 backgroundImage.setImageURI(Uri.fromFile(loadingFileObject));
                 progressBar.setVisibility(View.GONE);
@@ -372,38 +399,27 @@ public void didReceivedNotification(int id, final Object... args) {
                 loadingSize = null;
             }
         } else if (id == NotificationCenter.FileLoadProgressChanged) {
-            String location = (String)args[0];
+            String location = (String) args[0];
             if (loadingFile != null && loadingFile.equals(location)) {
-                Float progress = (Float)args[1];
-                progressBar.setProgress((int)(progress * 100));
+                Float progress = (Float) args[1];
+                progressBar.setProgress((int) (progress * 100));
             }
         } else if (id == NotificationCenter.wallpapersDidLoaded) {
-            AndroidUtilities.runOnUIThread(new Runnable() {
-                @Override
-                public void run() {
-                    wallPapers = (ArrayList<TLRPC.WallPaper>)args[0];
-                    wallpappersByIds.clear();
-                    for (TLRPC.WallPaper wallPaper : wallPapers) {
-                        wallpappersByIds.put(wallPaper.id, wallPaper);
-                    }
-                    if (listAdapter != null) {
-                        listAdapter.notifyDataSetChanged();
-                    }
-                    if (!wallPapers.isEmpty() && backgroundImage != null) {
-                        processSelectedBackground();
-                    }
-                    loadWallpapers();
-                }
-            });
+            wallPapers = (ArrayList<TLRPC.WallPaper>) args[0];
+            wallpappersByIds.clear();
+            for (TLRPC.WallPaper wallPaper : wallPapers) {
+                wallpappersByIds.put(wallPaper.id, wallPaper);
+            }
+            if (listAdapter != null) {
+                listAdapter.notifyDataSetChanged();
+            }
+            if (!wallPapers.isEmpty() && backgroundImage != null) {
+                processSelectedBackground();
+            }
+            loadWallpapers();
         }
     }
 
-    @Override
-    public void onConfigurationChanged(Configuration newConfig) {
-        super.onConfigurationChanged(newConfig);
-        fixLayout();
-    }
-
     private void loadWallpapers() {
         TLRPC.TL_account_getWallPapers req = new TLRPC.TL_account_getWallPapers();
         long reqId = ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
@@ -416,11 +432,11 @@ public void run(final TLObject response, TLRPC.TL_error error) {
                     @Override
                     public void run() {
                         wallPapers.clear();
-                        TLRPC.Vector res = (TLRPC.Vector)response;
+                        TLRPC.Vector res = (TLRPC.Vector) response;
                         wallpappersByIds.clear();
                         for (Object obj : res.objects) {
-                            wallPapers.add((TLRPC.WallPaper)obj);
-                            wallpappersByIds.put(((TLRPC.WallPaper)obj).id, (TLRPC.WallPaper)obj);
+                            wallPapers.add((TLRPC.WallPaper) obj);
+                            wallpappersByIds.put(((TLRPC.WallPaper) obj).id, (TLRPC.WallPaper) obj);
                         }
                         if (listAdapter != null) {
                             listAdapter.notifyDataSetChanged();
@@ -436,28 +452,6 @@ public void run() {
         ConnectionsManager.getInstance().bindRequestToGuid(reqId, classGuid);
     }
 
-    private void fixLayout() {
-        ViewTreeObserver obs = fragmentView.getViewTreeObserver();
-        obs.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
-            @Override
-            public boolean onPreDraw() {
-                fragmentView.getViewTreeObserver().removeOnPreDrawListener(this);
-                if (listAdapter != null) {
-                    listAdapter.notifyDataSetChanged();
-                }
-                if (listView != null) {
-                    listView.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            listView.scrollTo(0);
-                        }
-                    });
-                }
-                return false;
-            }
-        });
-    }
-
     @Override
     public void onResume() {
         super.onResume();
@@ -465,34 +459,26 @@ public void onResume() {
             listAdapter.notifyDataSetChanged();
         }
         processSelectedBackground();
-        fixLayout();
     }
 
-    private class ListAdapter extends BaseFragmentAdapter {
-        private Context mContext;
+    private class ListAdapter extends RecyclerView.Adapter {
 
-        public ListAdapter(Context context) {
-            mContext = context;
-        }
+        private class Holder extends RecyclerView.ViewHolder {
 
-        @Override
-        public boolean areAllItemsEnabled() {
-            return false;
+            public Holder(View itemView) {
+                super(itemView);
+            }
         }
 
-        @Override
-        public boolean isEnabled(int i) {
-            return true;
-        }
+        private Context mContext;
 
-        @Override
-        public int getCount() {
-            return 1 + wallPapers.size();
+        public ListAdapter(Context context) {
+            mContext = context;
         }
 
         @Override
-        public Object getItem(int i) {
-            return null;
+        public int getItemCount() {
+            return 1 + wallPapers.size();
         }
 
         @Override
@@ -501,84 +487,14 @@ public long getItemId(int i) {
         }
 
         @Override
-        public boolean hasStableIds() {
-            return true;
-        }
-
-        @Override
-        public View getView(int i, View view, ViewGroup viewGroup) {
-            int type = getItemViewType(i);
-            if (type == 0) {
-                if (view == null) {
-                    LayoutInflater li = (LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-                    view = li.inflate(R.layout.settings_wallpapers_my_row, viewGroup, false);
-                }
-                View parentView = view.findViewById(R.id.parent);
-                ImageView imageView = (ImageView)view.findViewById(R.id.image);
-                View selection = view.findViewById(R.id.selection);
-                if (i == 0) {
-                    if (selectedBackground == -1 || selectedColor != 0 || selectedBackground == 1000001) {
-                        imageView.setBackgroundColor(0x5A475866);
-                    } else {
-                        imageView.setBackgroundColor(0x5A000000);
-                    }
-                    imageView.setImageResource(R.drawable.ic_gallery_background);
-                    if (selectedBackground == -1) {
-                        selection.setVisibility(View.VISIBLE);
-                    } else {
-                        selection.setVisibility(View.INVISIBLE);
-                    }
-                } else {
-                    imageView.setImageBitmap(null);
-                    TLRPC.WallPaper wallPaper = wallPapers.get(i - 1);
-                    imageView.setBackgroundColor(0xff000000 | wallPaper.bg_color);
-                    if (wallPaper.id == selectedBackground) {
-                        selection.setVisibility(View.VISIBLE);
-                    } else {
-                        selection.setVisibility(View.INVISIBLE);
-                    }
-                }
-            } else if (type == 1) {
-                if (view == null) {
-                    LayoutInflater li = (LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-                    view = li.inflate(R.layout.settings_wallpapers_other_row, viewGroup, false);
-                }
-                BackupImageView image = (BackupImageView)view.findViewById(R.id.image);
-                View selection = view.findViewById(R.id.selection);
-                TLRPC.WallPaper wallPaper = wallPapers.get(i - 1);
-                TLRPC.PhotoSize size = FileLoader.getClosestPhotoSizeWithSize(wallPaper.sizes, AndroidUtilities.dp(100));
-                if (size != null && size.location != null) {
-                    image.setImage(size.location, "100_100", (Drawable)null);
-                }
-                if (wallPaper.id == selectedBackground) {
-                    selection.setVisibility(View.VISIBLE);
-                } else {
-                    selection.setVisibility(View.INVISIBLE);
-                }
-            }
-            return view;
-        }
-
-        @Override
-        public int getItemViewType(int i) {
-            if (i == 0) {
-                return 0;
-            }
-            TLRPC.WallPaper wallPaper = wallPapers.get(i - 1);
-            if (wallPaper instanceof TLRPC.TL_wallPaperSolid) {
-                return 0;
-            }
-            return 1;
-        }
-
-        @Override
-        public int getViewTypeCount() {
-            return 2;
+        public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup viewGroup, int i) {
+            WallpaperCell view = new WallpaperCell(mContext);
+            return new Holder(view);
         }
 
         @Override
-        public boolean isEmpty() {
-            return false;
+        public void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int i) {
+            ((WallpaperCell) viewHolder.itemView).setWallpaper(i == 0 ? null : wallPapers.get(i - 1), selectedBackground);
         }
     }
 }
diff --git a/TMessagesProj/src/main/res/drawable-v21/bar_selector_grey.xml b/TMessagesProj/src/main/res/drawable-v21/bar_selector_grey.xml
new file mode 100644
index 000000000..fc4dddc7f
--- /dev/null
+++ b/TMessagesProj/src/main/res/drawable-v21/bar_selector_grey.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ripple xmlns:android="http://schemas.android.com/apk/res/android"
+    android:color="#2f000000">
+</ripple>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/drawable/bar_selector_grey.xml b/TMessagesProj/src/main/res/drawable/bar_selector_grey.xml
new file mode 100644
index 000000000..f311824b8
--- /dev/null
+++ b/TMessagesProj/src/main/res/drawable/bar_selector_grey.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_pressed="true">
+        <shape android:shape="rectangle">
+            <solid android:color="#0f000000" />
+        </shape>
+    </item>
+    <item android:state_focused="true">
+        <shape android:shape="rectangle">
+            <solid android:color="#0f000000" />
+        </shape>
+    </item>
+    <item android:state_selected="true">
+        <shape android:shape="rectangle">
+            <solid android:color="#0f000000" />
+        </shape>
+    </item>
+    <item android:drawable="@drawable/transparent" />
+</selector>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/layout/messages_list.xml b/TMessagesProj/src/main/res/layout/messages_list.xml
deleted file mode 100644
index 6f6381a86..000000000
--- a/TMessagesProj/src/main/res/layout/messages_list.xml
+++ /dev/null
@@ -1,95 +0,0 @@
-<FrameLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:orientation="vertical">
-
-    <ListView
-        android:layout_width="match_parent"
-        android:layout_height="match_parent"
-        android:id="@+id/messages_list_view"
-        android:fadingEdge="none"
-        android:fadingEdgeLength="0dp"
-        android:divider="@null"
-        android:dividerHeight="0px"
-        android:animationCache="false"/>
-
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="match_parent"
-        android:id="@+id/search_empty_view"
-        android:orientation="vertical"
-        android:gravity="center"
-        android:visibility="gone">
-
-        <TextView
-            android:layout_width="match_parent"
-            android:layout_height="0dp"
-            android:textColor="#808080"
-            android:gravity="center"
-            android:textSize="20dp"
-            android:id="@+id/search_empty_text"
-            android:layout_weight="1"/>
-
-        <FrameLayout
-            android:layout_height="0dp"
-            android:layout_width="match_parent"
-            android:layout_weight="1"/>
-
-    </LinearLayout>
-
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="match_parent"
-        android:id="@+id/list_empty_view"
-        android:orientation="vertical"
-        android:gravity="center"
-        android:visibility="gone">
-
-        <TextView
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:textColor="#959595"
-            android:gravity="center"
-            android:textSize="20dp"
-            android:id="@+id/list_empty_view_text1"/>
-
-        <TextView
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:textColor="#959595"
-            android:gravity="center"
-            android:textSize="15dp"
-            android:paddingTop="6dp"
-            android:paddingLeft="8dp"
-            android:paddingRight="8dp"
-            android:lineSpacingExtra="2dp"
-            android:id="@+id/list_empty_view_text2"/>
-
-    </LinearLayout>
-
-    <LinearLayout
-        android:id="@+id/progressLayout"
-        android:layout_width="match_parent"
-        android:layout_height="match_parent"
-        android:gravity="center"
-        android:orientation="vertical"
-        android:visibility="gone">
-
-        <ProgressBar
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"/>
-
-    </LinearLayout>
-
-    <ImageView
-        android:layout_height="wrap_content"
-        android:layout_width="wrap_content"
-        android:background="@drawable/floating_states"
-        android:src="@drawable/floating_pencil"
-        android:layout_gravity="bottom|right"
-        android:layout_marginRight="14dp"
-        android:layout_marginBottom="14dp"
-        android:id="@+id/floating_button"/>
-
-</FrameLayout>
diff --git a/TMessagesProj/src/main/res/layout/recycler_view.xml b/TMessagesProj/src/main/res/layout/recycler_view.xml
deleted file mode 100644
index 648ce2b19..000000000
--- a/TMessagesProj/src/main/res/layout/recycler_view.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<org.telegram.ui.Components.RecyclerExListView
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:scrollbars="vertical"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent" />
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/layout/settings_color_dialog_layout.xml b/TMessagesProj/src/main/res/layout/settings_color_dialog_layout.xml
deleted file mode 100644
index 981b72c3a..000000000
--- a/TMessagesProj/src/main/res/layout/settings_color_dialog_layout.xml
+++ /dev/null
@@ -1,14 +0,0 @@
-<LinearLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:orientation="vertical"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:layout_gravity="center">
-
-    <org.telegram.ui.Components.ColorPickerView
-        android:id="@+id/color_picker"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:layout_gravity="center"/>
-
-</LinearLayout>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/layout/settings_wallpapers_layout.xml b/TMessagesProj/src/main/res/layout/settings_wallpapers_layout.xml
deleted file mode 100644
index 4f83f96d2..000000000
--- a/TMessagesProj/src/main/res/layout/settings_wallpapers_layout.xml
+++ /dev/null
@@ -1,30 +0,0 @@
-<FrameLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent">
-
-    <ImageView
-        android:layout_height="match_parent"
-        android:layout_width="match_parent"
-        android:scaleType="centerCrop"
-        android:id="@+id/background_image"/>
-
-    <ProgressBar
-        android:layout_width="60dp"
-        android:layout_height="60dp"
-        android:layout_gravity="center"
-        android:id="@+id/action_progress"
-        android:padding="6dp"
-        android:visibility="visible"
-        android:layout_marginBottom="52dp"/>
-
-    <org.telegram.ui.Components.HorizontalListView
-        android:layout_width="match_parent"
-        android:layout_height="102dp"
-        android:layout_gravity="bottom"
-        android:id="@+id/listView"
-        android:clipToPadding="false"
-        android:paddingLeft="40dp"
-        android:paddingRight="40dp"/>
-
-</FrameLayout>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/layout/settings_wallpapers_my_row.xml b/TMessagesProj/src/main/res/layout/settings_wallpapers_my_row.xml
deleted file mode 100644
index d0683c0b1..000000000
--- a/TMessagesProj/src/main/res/layout/settings_wallpapers_my_row.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<FrameLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_height="102dp"
-    android:layout_width="100dp"
-    android:id="@+id/parent">
-
-    <ImageView
-        android:layout_height="100dp"
-        android:layout_width="100dp"
-        android:scaleType="center"
-        android:id="@+id/image"
-        android:layout_gravity="bottom"/>
-
-    <FrameLayout
-        android:layout_height="102dp"
-        android:layout_width="100dp"
-        android:background="@drawable/wall_selection"
-        android:id="@+id/selection"/>
-
-</FrameLayout>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/layout/settings_wallpapers_other_row.xml b/TMessagesProj/src/main/res/layout/settings_wallpapers_other_row.xml
deleted file mode 100644
index 882ae732f..000000000
--- a/TMessagesProj/src/main/res/layout/settings_wallpapers_other_row.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<FrameLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_height="102dp"
-    android:layout_width="100dp">
-
-    <org.telegram.ui.Components.BackupImageView
-        android:layout_height="100dp"
-        android:layout_width="100dp"
-        android:id="@+id/image"
-        android:layout_gravity="bottom"
-        android:background="#5A475866"/>
-
-    <FrameLayout
-        android:layout_height="102dp"
-        android:layout_width="100dp"
-        android:background="@drawable/wall_selection"
-        android:id="@+id/selection"/>
-
-</FrameLayout>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/raw/sound_in.wav b/TMessagesProj/src/main/res/raw/sound_in.wav
index 262201668..dd5921544 100644
Binary files a/TMessagesProj/src/main/res/raw/sound_in.wav and b/TMessagesProj/src/main/res/raw/sound_in.wav differ
diff --git a/TMessagesProj/src/main/res/values/strings.xml b/TMessagesProj/src/main/res/values/strings.xml
index d9820fa55..c3c06125e 100644
--- a/TMessagesProj/src/main/res/values/strings.xml
+++ b/TMessagesProj/src/main/res/values/strings.xml
@@ -126,6 +126,8 @@
     <string name="SetTimer">Set self-destruct timer</string>
     <string name="ServiceNotifications">Service notifications</string>
     <string name="GettingLinkInfo">Getting Link Info...</string>
+    <string name="OpenInBrowser">Open in Browser</string>
+    <string name="CopyUrl">Copy URL</string>
     <!--notification-->
     <string name="MessageLifetimeChanged">%1$s set the self-destruct timer to %2$s</string>
     <string name="MessageLifetimeChangedOutgoing">You set the self-destruct timer to %1$s</string>
@@ -241,6 +243,21 @@
     <string name="UsernameAvailable">%1$s is available.</string>
     <string name="UsernameEmpty">None</string>
     <string name="ErrorOccurred">An error occurred.</string>
+    <!--stickers view-->
+    <string name="Stickers">Stickers</string>
+    <string name="GeniusStickerPackName">Great Minds</string>
+    <string name="StickersInfo">Artists are welcome to add their own sticker packs using our @stickers bot.\n\nUsers can add stickers by tapping on them and choosing \"Add to Stickers\".</string>
+    <string name="AddStickers">Add Stickers</string>
+    <string name="AddToStickers">Add to Stickers</string>
+    <string name="AddStickersNotFound">Stickers not found</string>
+    <string name="StickersRemoved">Stickers removed</string>
+    <string name="AddStickersInstalled">New stickers added</string>
+    <string name="StickersHide">Hide</string>
+    <string name="StickersShow">Show</string>
+    <string name="StickersShare">Share</string>
+    <string name="StickersCopy">Copy link</string>
+    <string name="StickersRemove">Remove</string>
+    <string name="NoStickers">No stickers yet</string>
     <!--settings view-->
     <string name="ResetNotificationsText">Reset all notification settings to default</string>
     <string name="TextSize">Messages Text Size</string>
@@ -518,6 +535,7 @@
     <string name="Done">Done</string>
     <string name="Open">Open</string>
     <string name="Cancel">Cancel</string>
+    <string name="Close">Close</string>
     <string name="Add">Add</string>
     <string name="Edit">Edit</string>
     <string name="Send">Send</string>
@@ -552,6 +570,7 @@
     <string name="ActionKickUserYou">un1 removed you</string>
     <string name="ActionAddUserYou">un1 added you</string>
     <string name="ActionAddUserSelf">un1 returned to the group</string>
+    <string name="ActionAddUserSelfYou">You returned to the group</string>
     <string name="UnsuppotedMedia">This message is not supported on your version of Telegram. Update the app to view: http://telegram.org/update</string>
     <string name="AttachPhoto">Photo</string>
     <string name="AttachVideo">Video</string>
@@ -714,6 +733,12 @@
     <string name="Meters_few">%1$d meters</string>
     <string name="Meters_many">%1$d meters</string>
     <string name="Meters_other">%1$d meters</string>
+    <string name="Stickers_zero">%1$d stickers</string>
+    <string name="Stickers_one">%1$d sticker</string>
+    <string name="Stickers_two">%1$d stickers</string>
+    <string name="Stickers_few">%1$d stickers</string>
+    <string name="Stickers_many">%1$d stickers</string>
+    <string name="Stickers_other">%1$d stickers</string>
     <!--forwarded messages-->
     <string name="ForwardedMessage_zero">%1$d forwarded messages</string>
     <string name="ForwardedMessage_one">Forwarded message</string>
@@ -781,6 +806,6 @@
     <string name="formatterDay12H">h:mm a</string>
     <string name="formatDateAtTime">%1$s at %2$s</string>
     <!--update text-->
-    <string name="updateText">Telegram for Android has been updated. New in version 2.8:\n\n- Places and directions in locations\n- Smart notifications\n- Invite links for group chats\n- Stickers tab in emoji menu\n- Captions for photos\n- \'Listened\' status for voice messages\n- Advanced \'typing\' status: sending photo, recording audio, etc.\n- Improved scrolling and animations for a smooooooooth experience</string>
-    <string name="updateBuild">516</string>
+    <string name="updateText">Telegram for Android has been updated. New in version 2.9:\n\n- Install and share custom sticker sets like this one: https://telegram.me/addstickers/Animals\n- If you\'re an artist, create custom sticker sets using our @stickers bot.\n\n- Use Telegram with Android Auto.</string>
+    <string name="updateBuild">536</string>
 </resources>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/xml/automotive_app_desc.xml b/TMessagesProj/src/main/res/xml/automotive_app_desc.xml
new file mode 100644
index 000000000..b6df3b517
--- /dev/null
+++ b/TMessagesProj/src/main/res/xml/automotive_app_desc.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<automotiveApp>
+    <uses name="notification"/>
+</automotiveApp>
\ No newline at end of file
