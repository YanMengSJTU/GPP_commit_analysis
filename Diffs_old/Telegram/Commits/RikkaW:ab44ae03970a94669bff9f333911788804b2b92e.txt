diff --git a/TMessagesProj/build.gradle b/TMessagesProj/build.gradle
index 9bfcb92ce..7e1e906f4 100644
--- a/TMessagesProj/build.gradle
+++ b/TMessagesProj/build.gradle
@@ -81,7 +81,7 @@ android {
         }
     }
 
-    defaultConfig.versionCode = 851 + 8
+    defaultConfig.versionCode = 851 + 9
 
     sourceSets.debug {
         manifest.srcFile 'config/debug/AndroidManifest.xml'
@@ -121,7 +121,7 @@ android {
     defaultConfig {
         minSdkVersion 21
         targetSdkVersion 25
-        versionName "3.13.1.8"
+        versionName "3.13.1.9"
 
         /*externalNativeBuild {
             ndkBuild {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/AppCompatColorStateListInflater.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/AppCompatColorStateListInflater.java
new file mode 100644
index 000000000..22ef8dcab
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/AppCompatColorStateListInflater.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.ui.Components;
+
+import org.telegram.messenger.R;
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import android.content.res.ColorStateList;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.Color;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.graphics.ColorUtils;
+import android.util.AttributeSet;
+import android.util.StateSet;
+import android.util.Xml;
+
+import java.io.IOException;
+
+final class AppCompatColorStateListInflater {
+
+    private static final int DEFAULT_COLOR = Color.RED;
+
+    private AppCompatColorStateListInflater() {}
+
+    /**
+     * Creates a ColorStateList from an XML document using given a set of
+     * {@link Resources} and a {@link Resources.Theme}.
+     *
+     * @param r Resources against which the ColorStateList should be inflated.
+     * @param parser Parser for the XML document defining the ColorStateList.
+     * @param theme Optional theme to apply to the color state list, may be
+     *              {@code null}.
+     * @return A new color state list.
+     */
+    @NonNull
+    public static ColorStateList createFromXml(@NonNull Resources r, @NonNull XmlPullParser parser,
+                                               @Nullable Resources.Theme theme) throws XmlPullParserException, IOException {
+        final AttributeSet attrs = Xml.asAttributeSet(parser);
+
+        int type;
+        while ((type = parser.next()) != XmlPullParser.START_TAG
+                && type != XmlPullParser.END_DOCUMENT) {
+            // Seek parser to start tag.
+        }
+
+        if (type != XmlPullParser.START_TAG) {
+            throw new XmlPullParserException("No start tag found");
+        }
+
+        return createFromXmlInner(r, parser, attrs, theme);
+    }
+
+    /**
+     * Create from inside an XML document. Called on a parser positioned at a
+     * tag in an XML document, tries to create a ColorStateList from that tag.
+     *
+     * @throws XmlPullParserException if the current tag is not &lt;selector>
+     * @return A new color state list for the current tag.
+     */
+    @NonNull
+    private static ColorStateList createFromXmlInner(@NonNull Resources r,
+                                                     @NonNull XmlPullParser parser, @NonNull AttributeSet attrs,
+                                                     @Nullable Resources.Theme theme)
+            throws XmlPullParserException, IOException {
+        final String name = parser.getName();
+        if (!name.equals("selector")) {
+            throw new XmlPullParserException(
+                    parser.getPositionDescription() + ": invalid color state list tag " + name);
+        }
+
+        return inflate(r, parser, attrs, theme);
+    }
+
+    /**
+     * Fill in this object based on the contents of an XML "selector" element.
+     */
+    private static ColorStateList inflate(@NonNull Resources r, @NonNull XmlPullParser parser,
+                                          @NonNull AttributeSet attrs, @Nullable Resources.Theme theme)
+            throws XmlPullParserException, IOException {
+        final int innerDepth = parser.getDepth() + 1;
+        int depth;
+        int type;
+        int defaultColor = DEFAULT_COLOR;
+
+        int[][] stateSpecList = new int[20][];
+        int[] colorList = new int[stateSpecList.length];
+        int listSize = 0;
+
+        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
+                && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
+            if (type != XmlPullParser.START_TAG || depth > innerDepth
+                    || !parser.getName().equals("item")) {
+                continue;
+            }
+
+            final TypedArray a = obtainAttributes(r, theme, attrs, R.styleable.ColorStateListItem);
+            final int baseColor = a.getColor(R.styleable.ColorStateListItem_android_color,
+                    Color.MAGENTA);
+
+            float alphaMod = 1.0f;
+            if (a.hasValue(R.styleable.ColorStateListItem_android_alpha)) {
+                alphaMod = a.getFloat(R.styleable.ColorStateListItem_android_alpha, alphaMod);
+            } else if (a.hasValue(R.styleable.ColorStateListItem_alpha)) {
+                alphaMod = a.getFloat(R.styleable.ColorStateListItem_alpha, alphaMod);
+            }
+
+            a.recycle();
+
+            // Parse all unrecognized attributes as state specifiers.
+            int j = 0;
+            final int numAttrs = attrs.getAttributeCount();
+            int[] stateSpec = new int[numAttrs];
+            for (int i = 0; i < numAttrs; i++) {
+                final int stateResId = attrs.getAttributeNameResource(i);
+                if (stateResId != android.R.attr.color && stateResId != android.R.attr.alpha
+                        && stateResId != R.attr.alpha) {
+                    // Unrecognized attribute, add to state set
+                    stateSpec[j++] = attrs.getAttributeBooleanValue(i, false)
+                            ? stateResId : -stateResId;
+                }
+            }
+            stateSpec = StateSet.trimStateSet(stateSpec, j);
+
+            // Apply alpha modulation. If we couldn't resolve the color or
+            // alpha yet, the default values leave us enough information to
+            // modulate again during applyTheme().
+            final int color = modulateColorAlpha(baseColor, alphaMod);
+            if (listSize == 0 || stateSpec.length == 0) {
+                defaultColor = color;
+            }
+
+            colorList = GrowingArrayUtils.append(colorList, listSize, color);
+            stateSpecList = GrowingArrayUtils.append(stateSpecList, listSize, stateSpec);
+            listSize++;
+        }
+
+        int[] colors = new int[listSize];
+        int[][] stateSpecs = new int[listSize][];
+        System.arraycopy(colorList, 0, colors, 0, listSize);
+        System.arraycopy(stateSpecList, 0, stateSpecs, 0, listSize);
+
+        return new ColorStateList(stateSpecs, colors);
+    }
+
+    private static TypedArray obtainAttributes(Resources res, Resources.Theme theme,
+                                               AttributeSet set, int[] attrs) {
+        return theme == null ? res.obtainAttributes(set, attrs)
+                : theme.obtainStyledAttributes(set, attrs, 0, 0);
+    }
+
+    private static int modulateColorAlpha(int color, float alphaMod) {
+        return ColorUtils.setAlphaComponent(color, Math.round(Color.alpha(color) * alphaMod));
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/AppCompatResources.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/AppCompatResources.java
new file mode 100644
index 000000000..619657500
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/AppCompatResources.java
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.ui.Components;
+
+import android.content.Context;
+import android.content.res.ColorStateList;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.graphics.drawable.Drawable;
+import android.os.Build;
+import android.support.annotation.ColorRes;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.content.ContextCompat;
+//import android.support.v7.widget.AppCompatDrawableManager;
+import android.util.Log;
+import android.util.SparseArray;
+import android.util.TypedValue;
+
+import org.xmlpull.v1.XmlPullParser;
+
+import java.util.WeakHashMap;
+
+/**
+ * Class for accessing an application's resources through AppCompat, and thus any backward
+ * compatible functionality.
+ */
+public final class AppCompatResources {
+
+    private static final String LOG_TAG = "AppCompatResources";
+    private static final ThreadLocal<TypedValue> TL_TYPED_VALUE = new ThreadLocal<>();
+
+    private static final WeakHashMap<Context, SparseArray<ColorStateListCacheEntry>>
+            sColorStateCaches = new WeakHashMap<>(0);
+
+    private static final Object sColorStateCacheLock = new Object();
+
+    private AppCompatResources() {}
+
+    /**
+     * Returns the {@link ColorStateList} from the given resource. The resource can include
+     * themeable attributes, regardless of API level.
+     *
+     * @param context context to inflate against
+     * @param resId the resource identifier of the ColorStateList to retrieve
+     */
+    public static ColorStateList getColorStateList(@NonNull Context context, @ColorRes int resId) {
+        if (Build.VERSION.SDK_INT >= 23) {
+            // On M+ we can use the framework
+            return context.getColorStateList(resId);
+        }
+
+        // Before that, we'll try handle it ourselves
+        ColorStateList csl = getCachedColorStateList(context, resId);
+        if (csl != null) {
+            return csl;
+        }
+        // Cache miss, so try and inflate it ourselves
+        csl = inflateColorStateList(context, resId);
+        if (csl != null) {
+            // If we inflated it, add it to the cache and return
+            addColorStateListToCache(context, resId, csl);
+            return csl;
+        }
+
+        // If we reach here then we couldn't inflate it, so let the framework handle it
+        return ContextCompat.getColorStateList(context, resId);
+    }
+
+    /**
+     * Return a drawable object associated with a particular resource ID.
+     *
+     * <p>This method supports inflation of {@code <vector>} and {@code <animated-vector>}
+     * resources on devices where platform support is not available.</p>
+     *
+     * @param context context to inflate against
+     * @param resId   The desired resource identifier, as generated by the aapt
+     *                tool. This integer encodes the package, type, and resource
+     *                entry. The value 0 is an invalid identifier.
+     * @return Drawable An object that can be used to draw this resource.
+     * @see ContextCompat#getDrawable(Context, int)
+     */
+    /*@Nullable
+    public static Drawable getDrawable(@NonNull Context context, @DrawableRes int resId) {
+        return AppCompatDrawableManager.get().getDrawable(context, resId);
+    }*/
+
+    /**
+     * Inflates a {@link ColorStateList} from resources, honouring theme attributes.
+     */
+    @Nullable
+    private static ColorStateList inflateColorStateList(Context context, int resId) {
+        if (isColorInt(context, resId)) {
+            // The resource is a color int, we can't handle it so return null
+            return null;
+        }
+
+        final Resources r = context.getResources();
+        final XmlPullParser xml = r.getXml(resId);
+        try {
+            return AppCompatColorStateListInflater.createFromXml(r, xml, context.getTheme());
+        } catch (Exception e) {
+            Log.e(LOG_TAG, "Failed to inflate ColorStateList, leaving it to the framework", e);
+        }
+        return null;
+    }
+
+    @Nullable
+    private static ColorStateList getCachedColorStateList(@NonNull Context context,
+                                                          @ColorRes int resId) {
+        synchronized (sColorStateCacheLock) {
+            final SparseArray<ColorStateListCacheEntry> entries = sColorStateCaches.get(context);
+            if (entries != null && entries.size() > 0) {
+                final ColorStateListCacheEntry entry = entries.get(resId);
+                if (entry != null) {
+                    if (entry.configuration.equals(context.getResources().getConfiguration())) {
+                        // If the current configuration matches the entry's, we can use it
+                        return entry.value;
+                    } else {
+                        // Otherwise we'll remove the entry
+                        entries.remove(resId);
+                    }
+                }
+            }
+        }
+        return null;
+    }
+
+    private static void addColorStateListToCache(@NonNull Context context, @ColorRes int resId,
+                                                 @NonNull ColorStateList value) {
+        synchronized (sColorStateCacheLock) {
+            SparseArray<ColorStateListCacheEntry> entries = sColorStateCaches.get(context);
+            if (entries == null) {
+                entries = new SparseArray<>();
+                sColorStateCaches.put(context, entries);
+            }
+            entries.append(resId, new ColorStateListCacheEntry(value,
+                    context.getResources().getConfiguration()));
+        }
+    }
+
+    private static boolean isColorInt(@NonNull Context context, @ColorRes int resId) {
+        final Resources r = context.getResources();
+
+        final TypedValue value = getTypedValue();
+        r.getValue(resId, value, true);
+
+        return value.type >= TypedValue.TYPE_FIRST_COLOR_INT
+                && value.type <= TypedValue.TYPE_LAST_COLOR_INT;
+    }
+
+    @NonNull
+    private static TypedValue getTypedValue() {
+        TypedValue tv = TL_TYPED_VALUE.get();
+        if (tv == null) {
+            tv = new TypedValue();
+            TL_TYPED_VALUE.set(tv);
+        }
+        return tv;
+    }
+
+    private static class ColorStateListCacheEntry {
+        final ColorStateList value;
+        final Configuration configuration;
+
+        ColorStateListCacheEntry(@NonNull ColorStateList value,
+                                 @NonNull Configuration configuration) {
+            this.value = value;
+            this.configuration = configuration;
+        }
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/GrowingArrayUtils.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/GrowingArrayUtils.java
new file mode 100644
index 000000000..e92bfdbf0
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/GrowingArrayUtils.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.ui.Components;
+
+import java.lang.reflect.Array;
+
+/**
+ * A helper class that aims to provide comparable growth performance to ArrayList, but on primitive
+ * arrays. Common array operations are implemented for efficient use in dynamic containers.
+ *
+ * All methods in this class assume that the length of an array is equivalent to its capacity and
+ * NOT the number of elements in the array. The current size of the array is always passed in as a
+ * parameter.
+ */
+final class GrowingArrayUtils {
+
+    /**
+     * Appends an element to the end of the array, growing the array if there is no more room.
+     * @param array The array to which to append the element. This must NOT be null.
+     * @param currentSize The number of elements in the array. Must be less than or equal to
+     *                    array.length.
+     * @param element The element to append.
+     * @return the array to which the element was appended. This may be different than the given
+     *         array.
+     */
+    public static <T> T[] append(T[] array, int currentSize, T element) {
+        assert currentSize <= array.length;
+
+        if (currentSize + 1 > array.length) {
+            T[] newArray = (T[]) Array.newInstance(array.getClass().getComponentType(),
+                    growSize(currentSize));
+            System.arraycopy(array, 0, newArray, 0, currentSize);
+            array = newArray;
+        }
+        array[currentSize] = element;
+        return array;
+    }
+
+    /**
+     * Primitive int version of {@link #append(Object[], int, Object)}.
+     */
+    public static int[] append(int[] array, int currentSize, int element) {
+        assert currentSize <= array.length;
+
+        if (currentSize + 1 > array.length) {
+            int[] newArray = new int[growSize(currentSize)];
+            System.arraycopy(array, 0, newArray, 0, currentSize);
+            array = newArray;
+        }
+        array[currentSize] = element;
+        return array;
+    }
+
+    /**
+     * Primitive long version of {@link #append(Object[], int, Object)}.
+     */
+    public static long[] append(long[] array, int currentSize, long element) {
+        assert currentSize <= array.length;
+
+        if (currentSize + 1 > array.length) {
+            long[] newArray = new long[growSize(currentSize)];
+            System.arraycopy(array, 0, newArray, 0, currentSize);
+            array = newArray;
+        }
+        array[currentSize] = element;
+        return array;
+    }
+
+    /**
+     * Primitive boolean version of {@link #append(Object[], int, Object)}.
+     */
+    public static boolean[] append(boolean[] array, int currentSize, boolean element) {
+        assert currentSize <= array.length;
+
+        if (currentSize + 1 > array.length) {
+            boolean[] newArray = new boolean[growSize(currentSize)];
+            System.arraycopy(array, 0, newArray, 0, currentSize);
+            array = newArray;
+        }
+        array[currentSize] = element;
+        return array;
+    }
+
+    /**
+     * Inserts an element into the array at the specified index, growing the array if there is no
+     * more room.
+     *
+     * @param array The array to which to append the element. Must NOT be null.
+     * @param currentSize The number of elements in the array. Must be less than or equal to
+     *                    array.length.
+     * @param element The element to insert.
+     * @return the array to which the element was appended. This may be different than the given
+     *         array.
+     */
+    public static <T> T[] insert(T[] array, int currentSize, int index, T element) {
+        assert currentSize <= array.length;
+
+        if (currentSize + 1 <= array.length) {
+            System.arraycopy(array, index, array, index + 1, currentSize - index);
+            array[index] = element;
+            return array;
+        }
+
+        T[] newArray = (T[]) Array.newInstance(array.getClass().getComponentType(),
+                growSize(currentSize));
+        System.arraycopy(array, 0, newArray, 0, index);
+        newArray[index] = element;
+        System.arraycopy(array, index, newArray, index + 1, array.length - index);
+        return newArray;
+    }
+
+    /**
+     * Primitive int version of {@link #insert(Object[], int, int, Object)}.
+     */
+    public static int[] insert(int[] array, int currentSize, int index, int element) {
+        assert currentSize <= array.length;
+
+        if (currentSize + 1 <= array.length) {
+            System.arraycopy(array, index, array, index + 1, currentSize - index);
+            array[index] = element;
+            return array;
+        }
+
+        int[] newArray = new int[growSize(currentSize)];
+        System.arraycopy(array, 0, newArray, 0, index);
+        newArray[index] = element;
+        System.arraycopy(array, index, newArray, index + 1, array.length - index);
+        return newArray;
+    }
+
+    /**
+     * Primitive long version of {@link #insert(Object[], int, int, Object)}.
+     */
+    public static long[] insert(long[] array, int currentSize, int index, long element) {
+        assert currentSize <= array.length;
+
+        if (currentSize + 1 <= array.length) {
+            System.arraycopy(array, index, array, index + 1, currentSize - index);
+            array[index] = element;
+            return array;
+        }
+
+        long[] newArray = new long[growSize(currentSize)];
+        System.arraycopy(array, 0, newArray, 0, index);
+        newArray[index] = element;
+        System.arraycopy(array, index, newArray, index + 1, array.length - index);
+        return newArray;
+    }
+
+    /**
+     * Primitive boolean version of {@link #insert(Object[], int, int, Object)}.
+     */
+    public static boolean[] insert(boolean[] array, int currentSize, int index, boolean element) {
+        assert currentSize <= array.length;
+
+        if (currentSize + 1 <= array.length) {
+            System.arraycopy(array, index, array, index + 1, currentSize - index);
+            array[index] = element;
+            return array;
+        }
+
+        boolean[] newArray = new boolean[growSize(currentSize)];
+        System.arraycopy(array, 0, newArray, 0, index);
+        newArray[index] = element;
+        System.arraycopy(array, index, newArray, index + 1, array.length - index);
+        return newArray;
+    }
+
+    /**
+     * Given the current size of an array, returns an ideal size to which the array should grow.
+     * This is typically double the given size, but should not be relied upon to do so in the
+     * future.
+     */
+    public static int growSize(int currentSize) {
+        return currentSize <= 4 ? 8 : currentSize * 2;
+    }
+
+    // Uninstantiable
+    private GrowingArrayUtils() {}
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/Switch.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/Switch.java
index b94e04b4a..9d17d3240 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/Switch.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/Switch.java
@@ -102,12 +102,12 @@ public Switch(Context context) {
         mThumbDrawable = context.getResources().getDrawable(R.drawable.switch_thumb);
         if (mThumbDrawable != null) {
             mThumbDrawable.setCallback(this);
-            mThumbDrawable.setTintList(ContextCompat.getColorStateList(context, R.color.tint_switch_thumb));
+            mThumbDrawable.setTintList(AppCompatResources.getColorStateList(context, R.color.tint_switch_thumb));
         }
         mTrackDrawable = context.getResources().getDrawable(R.drawable.switch_track);
         if (mTrackDrawable != null) {
             mTrackDrawable.setCallback(this);
-            mTrackDrawable.setTintList(ContextCompat.getColorStateList(context, R.color.tint_switch_track));
+            mTrackDrawable.setTintList(AppCompatResources.getColorStateList(context, R.color.tint_switch_track));
         }
 
         if (AndroidUtilities.density < 1) {
diff --git a/TMessagesProj/src/main/res/values/attrs.xml b/TMessagesProj/src/main/res/values/attrs.xml
index 0e02490b7..410cbfefa 100644
--- a/TMessagesProj/src/main/res/values/attrs.xml
+++ b/TMessagesProj/src/main/res/values/attrs.xml
@@ -4,4 +4,11 @@
         <!-- The color applied to framework switch thumbs in their normal state. -->
         <attr name="colorSwitchThumbNormal" format="color" />
     </declare-styleable>
+
+    <declare-styleable name="ColorStateListItem">
+        <attr name="android:color"/>
+        <attr format="float" name="alpha"/>
+        <attr name="android:alpha"/>
+    </declare-styleable>
+
 </resources>
\ No newline at end of file
