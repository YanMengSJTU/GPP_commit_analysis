diff --git a/.gitignore b/.gitignore
index ba289e7..42af84c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,3 +3,4 @@
 .settings/
 .classpath
 .project
+credentials
\ No newline at end of file
diff --git a/pom.xml b/pom.xml
index 1344e4d..8ec1e0b 100644
--- a/pom.xml
+++ b/pom.xml
@@ -24,4 +24,21 @@
             </plugin>
         </plugins>
     </build>
+    <dependencies>
+        <dependency>
+            <groupId>org.jsoup</groupId>
+            <artifactId>jsoup</artifactId>
+            <version>1.8.2</version>
+        </dependency>
+        <dependency>
+            <groupId>com.google.code.gson</groupId>
+            <artifactId>gson</artifactId>
+            <version>2.3.1</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-lang3</artifactId>
+            <version>3.4</version>
+        </dependency>
+    </dependencies>
 </project>
\ No newline at end of file
diff --git a/src/main/java/com/samczsun/skype4j/PendingLogin.java b/src/main/java/com/samczsun/skype4j/PendingLogin.java
new file mode 100644
index 0000000..592e31f
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/PendingLogin.java
@@ -0,0 +1,38 @@
+package com.samczsun.skype4j;
+
+import com.samczsun.skype4j.exceptions.SkypeException;
+import com.samczsun.skype4j.internal.web.WebSkype;
+
+
+public class PendingLogin {
+    private String username;
+    private String password;
+    private Client clientType;
+
+    private PendingLogin(String username, String password) {
+        this.username = username;
+        this.password = password;
+    }
+
+
+    public PendingLogin client(Client newClient) {
+        this.clientType = newClient;
+        return this;
+    }
+    
+    public Skype login() throws SkypeException {
+        switch (clientType) {
+        case WEB:
+            return new WebSkype(username, password);
+        }
+        throw new IllegalArgumentException("Unknown client type");
+    }
+
+    public static PendingLogin create(String username, String password) {
+        return new PendingLogin(username, password);
+    }
+    
+    public static enum Client {
+        WEB;
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/Skype.java b/src/main/java/com/samczsun/skype4j/Skype.java
new file mode 100644
index 0000000..9ddab89
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/Skype.java
@@ -0,0 +1,30 @@
+package com.samczsun.skype4j;
+
+import java.io.IOException;
+import java.util.List;
+
+import com.samczsun.skype4j.chat.Chat;
+import com.samczsun.skype4j.events.EventDispatcher;
+
+public interface Skype {
+
+    /**
+     * If this Skype client is web-based, this method will subscribe to the
+     * notifications and events will begin. Not sure what this will do on
+     * desktop-based clients yet.
+     * 
+     * @throws IOException
+     *             Thrown if any internal operations go wrong
+     */
+    public void subscribe() throws IOException;
+
+    public String getUsername();
+
+    public Chat getChat(String name);
+
+    public List<Chat> getAllChats();
+
+    public void logout() throws IOException;
+
+    public EventDispatcher getEventDispatcher();
+}
diff --git a/src/main/java/com/samczsun/skype4j/SkypeClient.java b/src/main/java/com/samczsun/skype4j/SkypeClient.java
new file mode 100644
index 0000000..dabbf42
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/SkypeClient.java
@@ -0,0 +1,8 @@
+package com.samczsun.skype4j;
+
+public class SkypeClient {
+    
+    public static PendingLogin create(String username, String password) {
+        return PendingLogin.create(username, password);
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/StreamUtils.java b/src/main/java/com/samczsun/skype4j/StreamUtils.java
new file mode 100644
index 0000000..dca0139
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/StreamUtils.java
@@ -0,0 +1,17 @@
+package com.samczsun.skype4j;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+public class StreamUtils {
+    public static String readFully(InputStream in) throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        byte[] chunk = new byte[2048];
+        int read = 0;
+        while ((read = in.read(chunk)) > 0) {
+            out.write(chunk, 0, read);
+        }
+        return out.toString();
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/chat/Chat.java b/src/main/java/com/samczsun/skype4j/chat/Chat.java
new file mode 100644
index 0000000..7f3cfdd
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/chat/Chat.java
@@ -0,0 +1,101 @@
+package com.samczsun.skype4j.chat;
+
+import java.util.Collection;
+
+import com.samczsun.skype4j.exceptions.SkypeException;
+import com.samczsun.skype4j.formatting.Text;
+
+/**
+ * Represents a single chat. This can be a private message or a group chat.
+ * 
+ * @author samczsun
+ */
+public interface Chat {
+
+    /**
+     * Fetches the list of members in the group, along with roles, and updates
+     * the internal database. If {@link #getType() getType()} returns a type of
+     * {@link Type#GROUP GROUP}, an HTTP request will be made
+     * 
+     * @throws SkypeException
+     */
+    public void updateUsers() throws SkypeException;
+
+    /**
+     * Sends a formatted message to this chat
+     * 
+     * @param message
+     *            The rich text to send
+     * @return The {@link ChatMessage ChatMessage} object representing the
+     *         message
+     * @throws SkypeException
+     */
+    public ChatMessage sendMessage(Text message) throws SkypeException;
+
+    /**
+     * Get the {@link User User} object represented by that username
+     * 
+     * @param username
+     *            The username of the user
+     * @return The user object
+     */
+    public User getUser(String username);
+
+    /**
+     * Get the identity of the chat, or the output of /showname in chat
+     * 
+     * If the return of {@link #getType() getType()} is {@link Type#GROUP GROUP}
+     * , the result will start with "19:" Otherwise, the result will start with
+     * "8:"
+     * 
+     * @return The identity of this chat
+     */
+    public String getIdentity();
+
+    /**
+     * Get the topic of the chat.
+     * 
+     * @return The topic
+     */
+    public String getTopic();
+
+    /**
+     * Set the topic of the chat. This will update it in real time
+     * 
+     * @param topic
+     *            The topic
+     * @throws SkypeException
+     */
+    public void setTopic(String topic) throws SkypeException;
+
+    /**
+     * Return a view of all the users in this chat
+     * 
+     * @return All the users
+     */
+    public Collection<User> getAllUsers();
+
+    /**
+     * Get the type of chat this is
+     * 
+     * @return A enum value of {@link Type Type}
+     */
+    public Type getType();
+
+    /**
+     * An Enum to represent the different types of chats
+     * 
+     * @author samczsun
+     *
+     */
+    public static enum Type {
+        /**
+         * Represents a private chat with one other person
+         */
+        INDIVIDUAL,
+        /**
+         * Represents a group chat with one or more people
+         */
+        GROUP;
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/chat/ChatMessage.java b/src/main/java/com/samczsun/skype4j/chat/ChatMessage.java
new file mode 100644
index 0000000..ba24828
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/chat/ChatMessage.java
@@ -0,0 +1,18 @@
+package com.samczsun.skype4j.chat;
+
+import com.samczsun.skype4j.exceptions.SkypeException;
+import com.samczsun.skype4j.formatting.Text;
+
+public interface ChatMessage {
+    public String getClientId();
+
+    public String getMessage();
+
+    public long getTime();
+
+    public User getSender();
+
+    public void edit(Text newMessage) throws SkypeException;
+
+    public Chat getChat();
+}
diff --git a/src/main/java/com/samczsun/skype4j/chat/User.java b/src/main/java/com/samczsun/skype4j/chat/User.java
new file mode 100644
index 0000000..0cb4afe
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/chat/User.java
@@ -0,0 +1,22 @@
+package com.samczsun.skype4j.chat;
+
+
+public interface User {
+    public String getUsername();
+
+    public String getDisplayName();
+
+    public Role getRole();
+
+    public void setRole(Role role);
+
+    public Chat getChat();
+
+    public static enum Role {
+        ADMIN, USER;
+
+        public boolean isAdmin() {
+            return this == ADMIN;
+        }
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/commands/Command.java b/src/main/java/com/samczsun/skype4j/commands/Command.java
new file mode 100644
index 0000000..a282730
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/commands/Command.java
@@ -0,0 +1,48 @@
+package com.samczsun.skype4j.commands;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import com.samczsun.skype4j.chat.Chat;
+import com.samczsun.skype4j.chat.User;
+
+public abstract class Command {
+    private List<String> aliases = new ArrayList<String>();
+    private String name;
+
+    public Command(String mainCommand, String... aliases) {
+        this.aliases.addAll(Arrays.asList(aliases));
+        this.name = mainCommand;
+    }
+
+    public void load() {
+
+    }
+
+    public void save() {
+
+    }
+
+    public abstract void onCommand(User sender, Chat chat, String command, String[] args);
+
+    public boolean isCorrectCommand(String command) {
+        if (command.equalsIgnoreCase(name))
+            return true;
+        for (String s : aliases) {
+            if (command.equalsIgnoreCase(s)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public List<String> getAliases() {
+        return Collections.unmodifiableList(aliases);
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/events/Event.java b/src/main/java/com/samczsun/skype4j/events/Event.java
new file mode 100644
index 0000000..c754740
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/events/Event.java
@@ -0,0 +1,5 @@
+package com.samczsun.skype4j.events;
+
+public abstract class Event {
+    
+}
diff --git a/src/main/java/com/samczsun/skype4j/events/EventDispatcher.java b/src/main/java/com/samczsun/skype4j/events/EventDispatcher.java
new file mode 100644
index 0000000..8ecfb42
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/events/EventDispatcher.java
@@ -0,0 +1,6 @@
+package com.samczsun.skype4j.events;
+
+public interface EventDispatcher {
+    public void registerListener(Listener l);
+    public void callEvent(Event l);
+}
diff --git a/src/main/java/com/samczsun/skype4j/events/EventHandler.java b/src/main/java/com/samczsun/skype4j/events/EventHandler.java
new file mode 100644
index 0000000..194a818
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/events/EventHandler.java
@@ -0,0 +1,9 @@
+package com.samczsun.skype4j.events;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+public @interface EventHandler {
+
+}
diff --git a/src/main/java/com/samczsun/skype4j/events/Listener.java b/src/main/java/com/samczsun/skype4j/events/Listener.java
new file mode 100644
index 0000000..0b6a81c
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/events/Listener.java
@@ -0,0 +1,5 @@
+package com.samczsun.skype4j.events;
+
+public interface Listener {
+
+}
diff --git a/src/main/java/com/samczsun/skype4j/events/RegisteredListener.java b/src/main/java/com/samczsun/skype4j/events/RegisteredListener.java
new file mode 100644
index 0000000..55542ae
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/events/RegisteredListener.java
@@ -0,0 +1,19 @@
+package com.samczsun.skype4j.events;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+public class RegisteredListener {
+    private Listener listener;
+    private Method method;
+    
+    public RegisteredListener(Listener l, Method m) {
+        this.listener = l;
+        this.method = m;
+        this.method.setAccessible(true);
+    }
+    
+    public void handleEvent(Event e) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
+        this.method.invoke(listener, e);
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/events/SkypeEventDispatcher.java b/src/main/java/com/samczsun/skype4j/events/SkypeEventDispatcher.java
new file mode 100644
index 0000000..680d0aa
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/events/SkypeEventDispatcher.java
@@ -0,0 +1,40 @@
+package com.samczsun.skype4j.events;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class SkypeEventDispatcher implements EventDispatcher {
+    private Map<Class<? extends Event>, List<RegisteredListener>> listeners = new HashMap<>();
+
+    public void registerListener(Listener l) {
+        Class<?> c = l.getClass();
+        for (Method m : c.getMethods()) {
+            if (m.getAnnotation(EventHandler.class) != null && m.getParameterTypes().length == 1 && Event.class.isAssignableFrom(m.getParameterTypes()[0])) {
+                Class<? extends Event> eventType = m.getParameterTypes()[0].asSubclass(Event.class);
+                List<RegisteredListener> methods = listeners.get(eventType);
+                if (methods == null) {
+                    methods = new ArrayList<>();
+                    listeners.put(eventType, methods);
+                }
+                methods.add(new RegisteredListener(l, m));
+            }
+        }
+    }
+
+    public void callEvent(Event e) {
+        List<RegisteredListener> methods = listeners.get(e.getClass());
+        if (methods != null) {
+            for (RegisteredListener method : methods) {
+                try {
+                    method.handleEvent(e);
+                } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e1) {
+                    e1.printStackTrace();
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/events/chat/ChatEvent.java b/src/main/java/com/samczsun/skype4j/events/chat/ChatEvent.java
new file mode 100644
index 0000000..ee473e3
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/events/chat/ChatEvent.java
@@ -0,0 +1,16 @@
+package com.samczsun.skype4j.events.chat;
+
+import com.samczsun.skype4j.chat.Chat;
+import com.samczsun.skype4j.events.Event;
+
+public abstract class ChatEvent extends Event {
+    private Chat chat;
+
+    public ChatEvent(Chat c) {
+        this.chat = c;
+    }
+
+    public Chat getChat() {
+        return chat;
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/events/chat/TopicChangeEvent.java b/src/main/java/com/samczsun/skype4j/events/chat/TopicChangeEvent.java
new file mode 100644
index 0000000..31de0e3
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/events/chat/TopicChangeEvent.java
@@ -0,0 +1,9 @@
+package com.samczsun.skype4j.events.chat;
+
+import com.samczsun.skype4j.chat.Chat;
+
+public class TopicChangeEvent extends ChatEvent {
+    public TopicChangeEvent(Chat c) {
+        super(c);
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/events/chat/message/MessageEvent.java b/src/main/java/com/samczsun/skype4j/events/chat/message/MessageEvent.java
new file mode 100644
index 0000000..060e8ca
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/events/chat/message/MessageEvent.java
@@ -0,0 +1,17 @@
+package com.samczsun.skype4j.events.chat.message;
+
+import com.samczsun.skype4j.chat.ChatMessage;
+import com.samczsun.skype4j.events.chat.ChatEvent;
+
+public abstract class MessageEvent extends ChatEvent {
+    private ChatMessage message;
+
+    public MessageEvent(ChatMessage message) {
+        super(message.getChat());
+        this.message = message;
+    }
+    
+    public ChatMessage getMessage() {
+        return this.message;
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/events/chat/message/MessageReceivedEvent.java b/src/main/java/com/samczsun/skype4j/events/chat/message/MessageReceivedEvent.java
new file mode 100644
index 0000000..d9e0b44
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/events/chat/message/MessageReceivedEvent.java
@@ -0,0 +1,9 @@
+package com.samczsun.skype4j.events.chat.message;
+
+import com.samczsun.skype4j.chat.ChatMessage;
+
+public class MessageReceivedEvent extends MessageEvent {
+    public MessageReceivedEvent(ChatMessage message) {
+        super(message);
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/events/chat/user/RoleUpdateEvent.java b/src/main/java/com/samczsun/skype4j/events/chat/user/RoleUpdateEvent.java
new file mode 100644
index 0000000..40c12e2
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/events/chat/user/RoleUpdateEvent.java
@@ -0,0 +1,9 @@
+package com.samczsun.skype4j.events.chat.user;
+
+import com.samczsun.skype4j.chat.User;
+
+public class RoleUpdateEvent extends UserEvent {
+    public RoleUpdateEvent(User user) {
+        super(user);
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/events/chat/user/UserAddEvent.java b/src/main/java/com/samczsun/skype4j/events/chat/user/UserAddEvent.java
new file mode 100644
index 0000000..533e235
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/events/chat/user/UserAddEvent.java
@@ -0,0 +1,9 @@
+package com.samczsun.skype4j.events.chat.user;
+
+import com.samczsun.skype4j.chat.User;
+
+public class UserAddEvent extends UserEvent {
+    public UserAddEvent(User user) {
+        super(user);
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/events/chat/user/UserEvent.java b/src/main/java/com/samczsun/skype4j/events/chat/user/UserEvent.java
new file mode 100644
index 0000000..c810ac6
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/events/chat/user/UserEvent.java
@@ -0,0 +1,16 @@
+package com.samczsun.skype4j.events.chat.user;
+
+import com.samczsun.skype4j.chat.User;
+import com.samczsun.skype4j.events.chat.ChatEvent;
+
+public abstract class UserEvent extends ChatEvent {
+    private User user;
+    
+    public UserEvent(User user) {
+        super(user.getChat());
+    }
+    
+    public User getUser() {
+        return this.user;
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/events/chat/user/UserRemoveEvent.java b/src/main/java/com/samczsun/skype4j/events/chat/user/UserRemoveEvent.java
new file mode 100644
index 0000000..4170549
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/events/chat/user/UserRemoveEvent.java
@@ -0,0 +1,9 @@
+package com.samczsun.skype4j.events.chat.user;
+
+import com.samczsun.skype4j.chat.User;
+
+public class UserRemoveEvent extends UserEvent {
+    public UserRemoveEvent(User user) {
+        super(user);
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/exceptions/SkypeException.java b/src/main/java/com/samczsun/skype4j/exceptions/SkypeException.java
new file mode 100644
index 0000000..161143b
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/exceptions/SkypeException.java
@@ -0,0 +1,13 @@
+package com.samczsun.skype4j.exceptions;
+
+public class SkypeException extends Exception {
+    private static final long serialVersionUID = -7832042631619998728L;
+    
+    public SkypeException(String message) {
+        super(message);
+    }
+    
+    public SkypeException(String message, Exception wrapped) {
+        super(message, wrapped);
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/formatting/Message.java b/src/main/java/com/samczsun/skype4j/formatting/Message.java
new file mode 100644
index 0000000..7ea64d2
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/formatting/Message.java
@@ -0,0 +1,82 @@
+package com.samczsun.skype4j.formatting;
+
+import java.util.ArrayList;
+
+import org.apache.commons.lang3.StringEscapeUtils;
+
+public class Message {
+    public static Text fromLegacy(String rawText) {
+        return Message.text(rawText);
+    }
+
+    private Message() {
+    }
+
+    protected ArrayList<Text> components = new ArrayList<>();
+
+    public static Text text(String text) {
+        Message message = new Message();
+        Text t = new Text(message, StringEscapeUtils.escapeHtml4(text));
+        message.components.add(t);
+        return t;
+    }
+    
+    public static Text unsafeText(String text) {
+        Message message = new Message();
+        Text t = new Text(message, text);
+        message.components.add(t);
+        return t;
+    }
+
+    public static Text text(String text, Object... args) {
+        return text(String.format(text, args));
+    }
+
+    public static Text text(byte text) {
+        return text(Integer.toString(text));
+    }
+
+    public static Text text(char text) {
+        return text(String.valueOf(text));
+    }
+
+    public static Text text(short text) {
+        return text(Integer.toString(text));
+    }
+
+    public static Text text(double text) {
+        return text(Double.toString(text));
+    }
+
+    public static Text text(float text) {
+        return text(Float.toString(text));
+    }
+
+    public static Text text(int text) {
+        return text(Integer.toString(text));
+    }
+
+    public static Text text(long text) {
+        return text(Long.toString(text));
+    }
+
+    public static Text text(Object text) {
+        return text(text.toString());
+    }
+
+    public static Text newLine() {
+        return text("\n");
+    }
+
+    public String write() {
+        StringBuilder result = new StringBuilder();
+        for (Text t : components) {
+            result.append(t);
+        }
+        return result.toString();
+    }
+
+    public String toString() {
+        return this.write();
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/formatting/Text.java b/src/main/java/com/samczsun/skype4j/formatting/Text.java
new file mode 100644
index 0000000..1ff3dec
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/formatting/Text.java
@@ -0,0 +1,196 @@
+package com.samczsun.skype4j.formatting;
+
+import java.awt.Color;
+
+import org.apache.commons.lang3.StringEscapeUtils;
+
+public class Text {
+    private Message parent;
+
+    private String text = null;
+    private boolean bold = false;
+    private boolean italic = false;
+    private boolean underline = false;
+    private boolean strikethrough = false;
+    private boolean blink = false;
+    private String link = null;
+    private String color = null;
+    private int size = -1;
+
+    public Text(Message parent, String text) {
+        this.text = text;
+        this.parent = parent;
+    }
+
+    public Text bold() {
+        this.bold = true;
+        return this;
+    }
+
+    public Text underline() {
+        this.underline = true;
+        return this;
+    }
+
+    public Text italic() {
+        this.italic = true;
+        return this;
+    }
+
+    public Text strikethrough() {
+        this.strikethrough = true;
+        return this;
+    }
+
+    public Text blink() {
+        this.blink = true;
+        return this;
+    }
+
+    public Text link(String link) {
+        this.link = link;
+        return this;
+    }
+
+    public Text link() {
+        this.link = this.text;
+        return this;
+    }
+
+    public Text color(Color color) {
+        this.color = Integer.toHexString(color.getRGB());
+        this.color = this.color.substring(2, this.color.length());
+        return this;
+    }
+
+    public Text size(int size) {
+        this.size = size;
+        return this;
+    }
+
+    public Text text(String text) {
+        Text t = new Text(parent, StringEscapeUtils.escapeHtml4(text));
+        parent.components.add(t);
+        return t;
+    }
+    
+    public Text unsafeText(String text) {
+        Text t = new Text(parent, text);
+        parent.components.add(t);
+        return t;
+    }
+
+    public Text text(String text, Object... args) {
+        return text(String.format(text, args));
+    }
+
+    public Text text(byte text) {
+        return text(Integer.toString(text));
+    }
+
+    public Text text(char text) {
+        return text(String.valueOf(text));
+    }
+
+    public Text text(short text) {
+        return text(Integer.toString(text));
+    }
+
+    public Text text(double text) {
+        return text(Double.toString(text));
+    }
+
+    public Text text(float text) {
+        return text(Float.toString(text));
+    }
+
+    public Text text(int text) {
+        return text(Integer.toString(text));
+    }
+
+    public Text text(long text) {
+        return text(Long.toString(text));
+    }
+
+    public Text text(Object text) {
+        return text(text.toString());
+    }
+
+    public Text newLine() {
+        return text("\n");
+    }
+    
+    public Text removeLast() {
+        parent.components.remove(parent.components.size() - 1);
+        parent.components.trimToSize();
+        return this;
+    }
+
+    public String write() {
+        if ((bold || italic || underline || strikethrough) && link != null) {
+            throw new IllegalArgumentException("You may not format links with bold/italic/underline/strikethrough");
+        }
+        StringBuilder output = new StringBuilder();
+        if (bold) {
+            output.append("<b>");
+        }
+        if (italic) {
+            output.append("<i>");
+        }
+        if (underline) {
+            output.append("<u>");
+        }
+        if (strikethrough) {
+            output.append("<s>");
+        }
+        if (blink) {
+            output.append("<blink>");
+        }
+        boolean font = size != -1 || color != null;
+        if (font) {
+            output.append("<font ");
+            if (size != -1) {
+                output.append("size=\"").append(size).append("\" ");
+            }
+            if (color != null) {
+                output.append("color=\"#").append(color).append("\" ");
+            }
+            output.setLength(output.length() - 1);
+            output.append(">");
+        }
+        if (this.link != null) {
+            output.append("<a href=\"").append(this.link).append("\">");
+        }
+        output.append(this.text);
+        if (this.link != null) {
+            output.append("</a>");
+        }
+        if (font) {
+            output.append("</font>");
+        }
+        if (blink) {
+            output.append("</blink>");
+        }
+        if (strikethrough) {
+            output.append("</s>");
+        }
+        if (underline) {
+            output.append("</u>");
+        }
+        if (italic) {
+            output.append("</i>");
+        }
+        if (bold) {
+            output.append("</b>");
+        }
+        return output.toString();
+    }
+
+    public String toString() {
+        return this.write();
+    }
+
+    public Message parent() {
+        return this.parent;
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/web/WebChat.java b/src/main/java/com/samczsun/skype4j/internal/web/WebChat.java
new file mode 100644
index 0000000..7326f30
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/web/WebChat.java
@@ -0,0 +1,41 @@
+package com.samczsun.skype4j.internal.web;
+
+import org.jsoup.helper.Validate;
+
+import com.samczsun.skype4j.Skype;
+import com.samczsun.skype4j.chat.Chat;
+
+public abstract class WebChat implements Chat {
+    public static Chat createChat(Skype client, String identity) {
+        Validate.notNull(client, "Client must not be null");
+        Validate.isTrue(client instanceof WebSkype, "Client type must be Web");
+        Validate.notEmpty(identity, "Identity must not be empty");
+        if (identity.startsWith("19:") && identity.endsWith("@thread.skype")) {
+            return new WebChatGroup((WebSkype) client, identity);
+        } else if (identity.startsWith("8:")) {
+            return new WebChatIndividual((WebSkype) client, identity);
+        } else {
+            throw new IllegalArgumentException(String.format("Unknown group type with identity %s", identity));
+        }
+    }
+
+    private final WebSkype client;
+    private final String identity;
+
+    public WebChat(WebSkype client, String identity) {
+        this.client = client;
+        this.identity = identity;
+    }
+
+    public WebSkype getClient() {
+        return this.client;
+    }
+
+    public String getIdentity() {
+        return this.identity;
+    }
+
+    public abstract void addUser(String username);
+
+    public abstract void removeUser(String username);
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/web/WebChatGroup.java b/src/main/java/com/samczsun/skype4j/internal/web/WebChatGroup.java
new file mode 100644
index 0000000..fae8553
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/web/WebChatGroup.java
@@ -0,0 +1,187 @@
+package com.samczsun.skype4j.internal.web;
+
+import java.io.IOException;
+import java.net.URL;
+import java.nio.charset.Charset;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.net.ssl.HttpsURLConnection;
+
+import org.jsoup.Jsoup;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.samczsun.skype4j.StreamUtils;
+import com.samczsun.skype4j.chat.ChatMessage;
+import com.samczsun.skype4j.chat.User;
+import com.samczsun.skype4j.chat.User.Role;
+import com.samczsun.skype4j.exceptions.SkypeException;
+import com.samczsun.skype4j.formatting.Text;
+
+public class WebChatGroup extends WebChat {
+    private AtomicBoolean isLoading = new AtomicBoolean(false);
+
+    private String topic;
+
+    private List<ChatMessage> messages = new CopyOnWriteArrayList<>();
+    private Map<String, User> users = new ConcurrentHashMap<>();
+
+    protected WebChatGroup(WebSkype skype, String identity) {
+        super(skype, identity);
+    }
+
+    @Override
+    public ChatMessage sendMessage(Text message) throws SkypeException {
+        HttpsURLConnection con = null;
+        try {
+            long ms = System.currentTimeMillis();
+            JsonObject obj = new JsonObject();
+            obj.addProperty("content", message.parent().write());
+            obj.addProperty("messagetype", "RichText");
+            obj.addProperty("contenttype", "text");
+            obj.addProperty("clientmessageid", String.valueOf(ms));
+            Gson gson = new GsonBuilder().disableHtmlEscaping().create();
+            URL url = new URL("https://client-s.gateway.messenger.live.com/v1/users/ME/conversations/" + this.getIdentity() + "/messages");
+            con = (HttpsURLConnection) url.openConnection();
+            con.setRequestMethod("POST");
+            con.setDoOutput(true);
+            con.setRequestProperty("RegistrationToken", getClient().getRegistrationToken());
+            con.setRequestProperty("Content-Type", "application/json");
+            con.getOutputStream().write(gson.toJson(obj).getBytes(Charset.forName("UTF-8")));
+            con.getInputStream();
+            return WebChatMessage.createMessage(this, getUser(getClient().getUsername()), null, String.valueOf(ms), ms, Jsoup.parse(message.parent().write()).text());
+        } catch (IOException e) {
+            throw new SkypeException("An error occured while sending a message", e);
+        }
+    }
+
+    @Override
+    public Collection<User> getAllUsers() {
+        return Collections.unmodifiableCollection(users.values());
+    }
+
+    public void updateUsers() throws SkypeException {
+        if (isLoading.get()) {
+            return;
+        }
+        Map<String, User> newUsers = new HashMap<>();
+        isLoading.set(true);
+        HttpsURLConnection con = null;
+        try {
+            URL url = new URL("https://client-s.gateway.messenger.live.com/v1/threads/" + this.getIdentity() + "?view=msnp24Equivalent");
+            con = (HttpsURLConnection) url.openConnection();
+            con.setRequestProperty("RegistrationToken", getClient().getRegistrationToken());
+            con.setRequestProperty("Content-Type", "application/json");
+            String in = StreamUtils.readFully(con.getInputStream());
+            Gson gson = new Gson();
+            JsonObject object = gson.fromJson(in, JsonObject.class);
+            JsonObject props = object.get("properties").getAsJsonObject();
+            if (props.has("topic")) {
+                this.topic = props.get("topic").getAsString();
+            } else {
+                this.topic = props.get("creator").getAsString().substring(2);
+            }
+            JsonArray members = object.get("members").getAsJsonArray();
+            for (JsonElement element : members) {
+                String username = element.getAsJsonObject().get("id").getAsString().substring(2);
+                String role = element.getAsJsonObject().get("role").getAsString();
+                User user = getUser(username);
+                if (user == null) {
+                    user = new WebUser(username, this);
+                }
+                newUsers.put(username, user);
+                if (role.equalsIgnoreCase("admin")) {
+                    user.setRole(Role.ADMIN);
+                } else {
+                    user.setRole(Role.USER);
+                }
+            }
+        } catch (IOException e) {
+            throw new SkypeException("An exception occured while loading users", e);
+        }
+        this.users.clear();
+        this.users.putAll(newUsers);
+        isLoading.set(false);
+    }
+
+    public void addUser(String username) {
+        if (!users.containsKey(username)) {
+            User user = new WebUser(username, this);
+            users.put(username, user);
+        } else {
+            System.out.println(username + " joined twice???");
+        }
+    }
+
+    public void removeUser(String username) {
+        users.remove(username);
+    }
+
+    public void kick(String username) throws SkypeException {
+        HttpsURLConnection con = null;
+        try {
+            URL url = new URL("https://getClient()-s.gateway.messenger.live.com/v1/threads/" + this.getIdentity() + "/members/8:" + username);
+            con = (HttpsURLConnection) url.openConnection();
+            con.setInstanceFollowRedirects(false);
+            con.setRequestMethod("DELETE");
+            con.setRequestProperty("RegistrationToken", getClient().getRegistrationToken());
+            con.setRequestProperty("Content-Type", "application/json");
+            con.getInputStream();
+        } catch (Exception e) {
+            throw new SkypeException("An exception occured while kicking", e);
+        }
+    }
+
+    @Override
+    public String getTopic() {
+        return this.topic;
+    }
+
+    public void setTopic(String topic) throws SkypeException {
+        HttpsURLConnection con = null;
+        try {
+            URL url = new URL("https://client-s.gateway.messenger.live.com/v1/threads/" + this.getIdentity() + "/properties?name=topic");
+            con = (HttpsURLConnection) url.openConnection();
+            con.setInstanceFollowRedirects(false);
+            con.setRequestMethod("PUT");
+            con.setDoOutput(true);
+            con.setRequestProperty("RegistrationToken", getClient().getRegistrationToken());
+            con.setRequestProperty("Content-Type", "application/json");
+            Gson gson = new Gson();
+            JsonObject obj = new JsonObject();
+            obj.addProperty("topic", topic);
+            con.getOutputStream().write(gson.toJson(obj).getBytes(Charset.forName("UTF-8")));
+            con.getOutputStream();
+        } catch (Exception e) {
+            throw new SkypeException("An exception occured while updating the topic", e);
+        }
+    }
+
+    public void updateTopic(String topic) {
+        this.topic = topic;
+    }
+
+    public void onMessage(ChatMessage message) {
+        this.messages.add(message);
+    }
+
+    @Override
+    public Type getType() {
+        return Type.GROUP;
+    }
+
+    @Override
+    public User getUser(String username) {
+        return this.users.get(username);
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/web/WebChatIndividual.java b/src/main/java/com/samczsun/skype4j/internal/web/WebChatIndividual.java
new file mode 100644
index 0000000..1fec43d
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/web/WebChatIndividual.java
@@ -0,0 +1,133 @@
+package com.samczsun.skype4j.internal.web;
+
+import java.io.IOException;
+import java.net.URL;
+import java.nio.charset.Charset;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.net.ssl.HttpsURLConnection;
+
+import org.jsoup.Jsoup;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonObject;
+import com.samczsun.skype4j.chat.ChatMessage;
+import com.samczsun.skype4j.chat.User;
+import com.samczsun.skype4j.exceptions.SkypeException;
+import com.samczsun.skype4j.formatting.Text;
+
+public class WebChatIndividual extends WebChat {
+    private AtomicBoolean isLoading = new AtomicBoolean(false);
+
+    private final Type type = Type.INDIVIDUAL;
+
+    private String topic;
+
+    private List<ChatMessage> messages = new CopyOnWriteArrayList<>();
+    private Map<String, User> users = new ConcurrentHashMap<>();
+
+    protected WebChatIndividual(WebSkype skype, String identity) {
+        super(skype, identity);
+    }
+
+    @Override
+    public ChatMessage sendMessage(Text message) throws SkypeException {
+        HttpsURLConnection con = null;
+        try {
+            long ms = System.currentTimeMillis();
+            JsonObject obj = new JsonObject();
+            obj.addProperty("content", message.parent().write());
+            obj.addProperty("messagetype", "RichText");
+            obj.addProperty("contenttype", "text");
+            obj.addProperty("clientmessageid", String.valueOf(ms));
+            Gson gson = new GsonBuilder().disableHtmlEscaping().create();
+            URL url = new URL("https://client-s.gateway.messenger.live.com/v1/users/ME/conversations/" + this.getIdentity() + "/messages");
+            con = (HttpsURLConnection) url.openConnection();
+            con.setRequestMethod("POST");
+            con.setDoOutput(true);
+            con.setRequestProperty("RegistrationToken", getClient().getRegistrationToken());
+            con.setRequestProperty("Content-Type", "application/json");
+            con.getOutputStream().write(gson.toJson(obj).getBytes(Charset.forName("UTF-8")));
+            con.getInputStream();
+            return WebChatMessage.createMessage(this, getUser(getClient().getUsername()), null, String.valueOf(ms), ms, Jsoup.parse(message.parent().write()).text());
+        } catch (IOException e) {
+            throw new SkypeException("An exception occured while sending a message", e);
+        }
+    }
+
+    @Override
+    public Collection<User> getAllUsers() {
+        return Collections.unmodifiableCollection(users.values());
+    }
+
+    public void updateUsers() {
+        if (isLoading.get()) {
+            return;
+        }
+        isLoading.set(true);
+        Map<String, User> newUsers = new HashMap<>();
+        String username = this.getIdentity().substring(2);
+        this.topic = username;
+        User user = getUser(username);
+        if (user == null) {
+            user = new WebUser(username, this);
+        }
+        newUsers.put(username, user);
+        User me = getUser(getClient().getUsername());
+        if (me == null) {
+            me = new WebUser(getClient().getUsername(), this);
+            newUsers.put(getClient().getUsername(), me);
+        }
+        this.users.clear();
+        this.users.putAll(newUsers);
+        isLoading.set(false);
+    }
+
+    public void addUser(String username) {
+        if (!users.containsKey(username)) {
+            User user = new WebUser(username, this);
+            users.put(username, user);
+        } else {
+            System.out.println(username + " joined twice???");
+        }
+    }
+
+    public void removeUser(String username) {
+        users.remove(username);
+    }
+
+    public boolean kick(String username) {
+        throw new IllegalArgumentException("Cannot kick in individual chats");
+    }
+
+    @Override
+    public String getTopic() {
+        return this.topic;
+    }
+
+    public void setTopic(String topic) {
+        throw new IllegalArgumentException("Cannot set topic in individual chats");
+    }
+
+    public void onMessage(ChatMessage message) {
+        this.messages.add(message);
+    }
+
+    @Override
+    public Type getType() {
+        return this.type;
+    }
+
+    @Override
+    public User getUser(String username) {
+        return this.users.get(username);
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/web/WebChatMessage.java b/src/main/java/com/samczsun/skype4j/internal/web/WebChatMessage.java
new file mode 100644
index 0000000..5138247
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/web/WebChatMessage.java
@@ -0,0 +1,23 @@
+package com.samczsun.skype4j.internal.web;
+
+import org.jsoup.helper.Validate;
+
+import com.samczsun.skype4j.chat.Chat;
+import com.samczsun.skype4j.chat.ChatMessage;
+import com.samczsun.skype4j.chat.User;
+
+public class WebChatMessage {
+    public static ChatMessage createMessage(Chat chat, User user, String id, String clientId, long time, String message) {
+        Validate.notNull(chat, "Chat must not be null");
+        Validate.isTrue(chat instanceof WebChat, "Chat must be instanceof WebChat");
+        Validate.notNull(chat, "User must not be null");
+        Validate.isTrue(user instanceof WebUser, "User must be instanceof WebUser");
+        Validate.notEmpty(clientId, "ClientId must not be null");
+        Validate.notEmpty(message, "Message must not be null");
+        if (((WebChat) chat).getClient().getUsername().equals(user.getUsername())) {
+            return new WebSelfChatMessage(chat, user, id, clientId, time, message);
+        } else {
+            return new WebOtherChatMessage(chat, user, id, clientId, time, message);
+        }
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/web/WebOtherChatMessage.java b/src/main/java/com/samczsun/skype4j/internal/web/WebOtherChatMessage.java
new file mode 100644
index 0000000..5615de0
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/web/WebOtherChatMessage.java
@@ -0,0 +1,50 @@
+package com.samczsun.skype4j.internal.web;
+
+import com.samczsun.skype4j.chat.Chat;
+import com.samczsun.skype4j.chat.ChatMessage;
+import com.samczsun.skype4j.chat.User;
+import com.samczsun.skype4j.formatting.Text;
+
+public class WebOtherChatMessage implements ChatMessage {
+    private String clientId;
+    private String message;
+    private long time;
+    private User sender;
+
+    public WebOtherChatMessage(Chat chat, User user, String id, String clientId, long time, String message) {
+        this.clientId = clientId;
+        this.message = message;
+        this.time = time;
+        this.sender = user;
+    }
+
+    @Override
+    public String getClientId() {
+        return clientId;
+    }
+
+    @Override
+    public String getMessage() {
+        return message;
+    }
+
+    @Override
+    public long getTime() {
+        return time;
+    }
+
+    @Override
+    public User getSender() {
+        return sender;
+    }
+
+    @Override
+    public void edit(Text newMessage) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Chat getChat() {
+        return sender.getChat();
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/web/WebSelfChatMessage.java b/src/main/java/com/samczsun/skype4j/internal/web/WebSelfChatMessage.java
new file mode 100644
index 0000000..34ba16f
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/web/WebSelfChatMessage.java
@@ -0,0 +1,75 @@
+package com.samczsun.skype4j.internal.web;
+
+import java.net.URL;
+
+import javax.net.ssl.HttpsURLConnection;
+
+import com.google.gson.Gson;
+import com.google.gson.JsonObject;
+import com.samczsun.skype4j.chat.Chat;
+import com.samczsun.skype4j.chat.ChatMessage;
+import com.samczsun.skype4j.chat.User;
+import com.samczsun.skype4j.exceptions.SkypeException;
+import com.samczsun.skype4j.formatting.Text;
+
+public class WebSelfChatMessage implements ChatMessage {
+    private String clientId;
+    private String message;
+    private long time;
+    private User sender;
+
+    public WebSelfChatMessage(Chat chat, User user, String id, String clientId, long time, String message) {
+        this.clientId = clientId;
+        this.message = message;
+        this.time = time;
+        this.sender = user;
+    }
+
+    @Override
+    public String getClientId() {
+        return clientId;
+    }
+
+    @Override
+    public String getMessage() {
+        return message;
+    }
+
+    @Override
+    public long getTime() {
+        return time;
+    }
+
+    @Override
+    public User getSender() {
+        return sender;
+    }
+
+    @Override
+    public void edit(Text newMessage) throws SkypeException {
+        HttpsURLConnection con = null;
+        try {
+            JsonObject obj = new JsonObject();
+            obj.addProperty("content", newMessage.parent().write());
+            obj.addProperty("messagetype", "RichText");
+            obj.addProperty("contenttype", "text");
+            obj.addProperty("skypeeditedid", this.clientId);
+            Gson gson = new Gson();
+            URL url = new URL("https://client-s.gateway.messenger.live.com/v1/users/ME/conversations/" + this.sender.getChat().getIdentity() + "/messages");
+            con = (HttpsURLConnection) url.openConnection();
+            con.setRequestMethod("POST");
+            con.setDoOutput(true);
+            con.setRequestProperty("RegistrationToken", ((WebChat) sender.getChat()).getClient().getRegistrationToken());
+            con.setRequestProperty("Content-Type", "application/json");
+            con.getOutputStream().write(gson.toJson(obj).getBytes());
+            con.getInputStream();
+        } catch (Exception e) {
+            throw new SkypeException("An exception occured while editing a message", e);
+        }
+    }
+
+    @Override
+    public Chat getChat() {
+        return sender.getChat();
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/web/WebSkype.java b/src/main/java/com/samczsun/skype4j/internal/web/WebSkype.java
new file mode 100644
index 0000000..c59d03d
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/web/WebSkype.java
@@ -0,0 +1,394 @@
+package com.samczsun.skype4j.internal.web;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.net.URLEncoder;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import javax.net.ssl.HttpsURLConnection;
+
+import org.apache.commons.lang3.StringEscapeUtils;
+import org.jsoup.Connection.Method;
+import org.jsoup.Connection.Response;
+import org.jsoup.Jsoup;
+import org.jsoup.nodes.Document;
+import org.jsoup.nodes.Element;
+import org.jsoup.select.Elements;
+
+import com.google.gson.Gson;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+import com.samczsun.skype4j.Skype;
+import com.samczsun.skype4j.StreamUtils;
+import com.samczsun.skype4j.chat.Chat;
+import com.samczsun.skype4j.chat.ChatMessage;
+import com.samczsun.skype4j.chat.User.Role;
+import com.samczsun.skype4j.events.EventDispatcher;
+import com.samczsun.skype4j.events.SkypeEventDispatcher;
+import com.samczsun.skype4j.events.chat.TopicChangeEvent;
+import com.samczsun.skype4j.events.chat.message.MessageReceivedEvent;
+import com.samczsun.skype4j.events.chat.user.RoleUpdateEvent;
+import com.samczsun.skype4j.events.chat.user.UserAddEvent;
+import com.samczsun.skype4j.events.chat.user.UserRemoveEvent;
+import com.samczsun.skype4j.exceptions.SkypeException;
+
+public class WebSkype implements Skype {
+    private static final String LOGIN_URL = "https://login.skype.com/login?client_id=578134&redirect_uri=https%3A%2F%2Fweb.skype.com";
+    private static final String PING_URL = "https://web.skype.com/api/v1/session-ping";
+    private static final String SUBSCRIPTIONS_URL = "https://client-s.gateway.messenger.live.com/v1/users/ME/endpoints/SELF/subscriptions";
+    private static final String MESSAGINGSERVICE_URL = "https://client-s.gateway.messenger.live.com/v1/users/ME/endpoints/%s/presenceDocs/messagingService";
+    private static final String LOGOUT_URL = "https://login.skype.com/logout?client_id=578134&redirect_uri=https%3A%2F%2Fweb.skype.com&intsrc=client-_-webapp-_-production-_-go-signin";
+
+    private static final Pattern TARGET_PATTERN = Pattern.compile("<target>8:([^<]*)<\\/target>");
+    private static final Pattern ID_PATTERN = Pattern.compile("<id>8:([^<]*)<\\/id><role>([^<]*)<\\/role>");
+    private static final Pattern VALUE_PATTERN = Pattern.compile("<value>([^<]*)<\\/value>");
+    private static final Pattern URL_PATTERN = Pattern.compile("conversations\\/(.*)");
+    private static final Pattern USER_PATTERN = Pattern.compile("8:(.*)");
+
+    private final Map<String, String> cookies = new HashMap<>();
+    private final String skypeToken;
+    private final String registrationToken;
+    private final String endpointId;
+    private final String username;
+
+    private final EventDispatcher eventDispatcher;
+
+    private Thread sessionKeepaliveThread;
+    private Thread pollThread;
+
+    private final ExecutorService scheduler = Executors.newFixedThreadPool(16);
+
+    private final Logger logger = Logger.getLogger("webskype");
+
+    private final Map<String, Chat> allChats = new ConcurrentHashMap<>();
+
+    public WebSkype(String username, String password) throws SkypeException {
+        try {
+            this.username = username;
+            this.eventDispatcher = new SkypeEventDispatcher();
+            final UUID guid = UUID.randomUUID();
+            Response loginResponse = postToLogin(username, password);
+            cookies.putAll(loginResponse.cookies());
+            Document loginResponseDocument = loginResponse.parse();
+            Elements inputs = loginResponseDocument.select("input[name=skypetoken]");
+            if (inputs.size() > 0) {
+                skypeToken = inputs.get(0).attr("value");
+                sessionKeepaliveThread = new Thread(String.format("Skype-%s-Session", username)) {
+                    public void run() {
+                        while (true) {
+                            try {
+                                Jsoup.connect(PING_URL).header("X-Skypetoken", skypeToken).cookies(cookies).data("sessionId", guid.toString()).post();
+                                Thread.sleep(300000);
+                            } catch (IOException | InterruptedException e) {
+                                e.printStackTrace();
+                            }
+                        }
+                    }
+                };
+                sessionKeepaliveThread.start();
+
+                Response getAsm = Jsoup.connect("https://api.asm.skype.com/v1/skypetokenauth").cookies(cookies).data("skypetoken", skypeToken).method(Method.POST).execute();
+                cookies.putAll(getAsm.cookies());
+                HttpsURLConnection getReg = (HttpsURLConnection) new URL("https://client-s.gateway.messenger.live.com/v1/users/ME/endpoints").openConnection();
+                getReg.setRequestProperty("Authentication", "skypetoken=" + skypeToken);
+                getReg.setRequestMethod("POST");
+                getReg.setDoOutput(true);
+                getReg.getOutputStream().write("{}".getBytes());
+                getReg.getInputStream();
+                String[] splits = getReg.getHeaderField("Set-RegistrationToken").split(";");
+                registrationToken = splits[0];
+                endpointId = splits[2].split("=")[1];
+
+                Date now = new Date();
+                now.setDate(now.getDate() - 14);
+
+                Gson gson = new Gson();
+                String urlToUse = "https://client-s.gateway.messenger.live.com/v1/users/ME/conversations?startTime=" + now.getTime() + "&pageSize=100&view=msnp24Equivalent&targetType=Passport|Skype|Lync|Thread";
+                //        while (true) {
+                try {
+                    URL url = new URL(urlToUse);
+                    HttpsURLConnection con = (HttpsURLConnection) url.openConnection();
+                    con.setRequestProperty("RegistrationToken", registrationToken);
+                    String in = StreamUtils.readFully(con.getInputStream());
+                    JsonObject obj = gson.fromJson(in, JsonObject.class);
+
+                    for (JsonElement elem : obj.get("conversations").getAsJsonArray()) {
+                        try {
+                            JsonObject conversation = elem.getAsJsonObject();
+                            String id = conversation.get("id").getAsString();
+                            Chat chat = WebChat.createChat(this, id);
+                            chat.updateUsers();
+                            allChats.put(id, chat);
+                        } catch (Exception e) {
+                            e.printStackTrace();
+                        }
+                    }
+
+                    //                if (obj.get("_metadata").getAsJsonObject().has("backwardLink")) {
+                    //                    urlToUse = obj.get("_metadata").getAsJsonObject().get("backwardLink").getAsString();
+                    //                    System.out.println("Backwards");
+                    //                } else {
+                    //                    break;
+                    //                }
+                } catch (Exception e) {
+                    throw new SkypeException("An exception occured while fetching chats", e);
+                }
+                //        }
+            } else {
+                throw new SkypeException("Login failure");
+            }
+        } catch (IOException e) {
+            throw new SkypeException("An exception occured while logging in", e);
+        }
+    }
+
+    public void subscribe() throws IOException {
+        Gson gson = new Gson();
+        
+        HttpsURLConnection subscribe = (HttpsURLConnection) new URL(SUBSCRIPTIONS_URL).openConnection();
+        subscribe.setRequestMethod("POST");
+        subscribe.setDoOutput(true);
+        subscribe.setRequestProperty("RegistrationToken", registrationToken);
+        subscribe.setRequestProperty("Content-Type", "application/json");
+        subscribe.getOutputStream().write(gson.toJson(buildSubscriptionObject()).getBytes());
+        subscribe.getInputStream();
+
+        HttpsURLConnection registerEndpoint = (HttpsURLConnection) new URL(String.format(MESSAGINGSERVICE_URL, URLEncoder.encode(endpointId, "UTF-8"))).openConnection();
+        registerEndpoint.setRequestMethod("PUT");
+        registerEndpoint.setDoOutput(true);
+        registerEndpoint.setRequestProperty("RegistrationToken", registrationToken);
+        registerEndpoint.setRequestProperty("Content-Type", "application/json");
+        registerEndpoint.getOutputStream().write(gson.toJson(buildRegistrationObject()).getBytes());
+        registerEndpoint.getInputStream();
+        
+        pollThread = new Thread() {
+            public void run() {
+                try {
+                    URL url = new URL("https://client-s.gateway.messenger.live.com/v1/users/ME/endpoints/SELF/subscriptions/0/poll");
+                    Gson gson = new Gson();
+                    HttpsURLConnection c = null;
+                    while (true) {
+                        try {
+                            c = (HttpsURLConnection) url.openConnection();
+                            c.setRequestMethod("POST");
+                            c.setDoOutput(true);
+                            c.addRequestProperty("Content-Type", "application/json");
+                            c.addRequestProperty("RegistrationToken", registrationToken);
+                            c.getOutputStream().write(new byte[0]);
+                            InputStream read = c.getInputStream();
+                            String json = StreamUtils.readFully(read);
+                            if (!json.isEmpty()) {
+                                final JsonObject message = gson.fromJson(json, JsonObject.class);
+                                scheduler.execute(new Runnable() {
+                                    public void run() {
+                                        if (message.has("eventMessages")) {
+                                            JsonArray arr = message.get("eventMessages").getAsJsonArray();
+                                            for (JsonElement event : arr) {
+                                                JsonObject eventObj = event.getAsJsonObject();
+                                                String resourceType = eventObj.get("resourceType").getAsString();
+                                                if (eventObj.get("resourceType").getAsString().equals("NewMessage")) {
+                                                    JsonObject resource = eventObj.get("resource").getAsJsonObject();
+                                                    String messageType = resource.get("messagetype").getAsString();
+                                                    if (resource.get("messagetype").getAsString().equals("RichText") || resource.get("messagetype").getAsString().equals("Text")) {
+                                                        try {
+                                                            String clientid = resource.has("clientmessageid") ? resource.get("clientmessageid").getAsString() : resource.get("skypeeditedid").getAsString();
+                                                            String id = resource.get("id").getAsString();
+                                                            String from = getUser(resource.get("from").getAsString());
+                                                            String url = resource.get("conversationLink").getAsString();
+                                                            Chat c = fromUrl(url);
+                                                            ChatMessage m = WebChatMessage.createMessage(c, c.getUser(from), id, clientid, System.currentTimeMillis(), resource.get("content").getAsString());
+                                                            MessageReceivedEvent evnt = new MessageReceivedEvent(m);
+                                                            eventDispatcher.callEvent(evnt);
+                                                        } catch (NullPointerException e) {
+                                                            logger.log(Level.SEVERE, "An NPE occured while parsing a message");
+                                                            logger.log(Level.SEVERE, message.toString());
+                                                        }
+                                                    } else if (resource.get("messagetype").getAsString().equals("ThreadActivity/AddMember")) {
+                                                        String content = resource.get("content").getAsString();
+                                                        Matcher m = TARGET_PATTERN.matcher(content);
+                                                        m.find();
+                                                        String target = m.group(1);
+                                                        String url = resource.get("conversationLink").getAsString();
+                                                        Chat c = fromUrl(url);
+                                                        ((WebChat) c).addUser(target);
+                                                        UserAddEvent e = new UserAddEvent(c.getUser(target));
+                                                        eventDispatcher.callEvent(e);
+                                                    } else if (resource.get("messagetype").getAsString().equals("ThreadActivity/DeleteMember")) {
+                                                        String content = resource.get("content").getAsString();
+                                                        Matcher m = TARGET_PATTERN.matcher(content);
+                                                        m.find();
+                                                        String target = m.group(1);
+                                                        String url = resource.get("conversationLink").getAsString();
+                                                        Chat c = fromUrl(url);
+                                                        ((WebChat) c).removeUser(target);
+                                                        UserRemoveEvent e = new UserRemoveEvent(c.getUser(target));
+                                                        eventDispatcher.callEvent(e);
+                                                    } else if (resource.get("messagetype").getAsString().equals("ThreadActivity/RoleUpdate")) {
+                                                        String content = resource.get("content").getAsString();
+                                                        Matcher m = ID_PATTERN.matcher(content);
+                                                        m.find();
+                                                        String target = m.group(1);
+                                                        String role = m.group(2);
+                                                        String url = resource.get("conversationLink").getAsString();
+                                                        Chat c = fromUrl(url);
+                                                        ((WebChat) c).getUser(target).setRole(role.equals("admin") ? Role.ADMIN : Role.USER);
+                                                        RoleUpdateEvent e = new RoleUpdateEvent(c.getUser(target));
+                                                        eventDispatcher.callEvent(e);
+                                                    } else if (messageType.equalsIgnoreCase("Control/Typing")) {
+                                                    } else if (messageType.equalsIgnoreCase("Control/ClearTyping")) {
+                                                    } else if (messageType.equalsIgnoreCase("Control/LiveState")) {
+                                                    } else if (messageType.equalsIgnoreCase("ThreadActivity/TopicUpdate")) {
+                                                        String content = resource.get("content").getAsString();
+                                                        Matcher m = VALUE_PATTERN.matcher(content);
+                                                        String url = resource.get("conversationLink").getAsString();
+                                                        Chat c = fromUrl(url);
+                                                        if (c instanceof WebChatGroup) {
+                                                            if (m.find()) {
+                                                                ((WebChatGroup) c).updateTopic(StringEscapeUtils.unescapeHtml4(m.group(1)));
+                                                            } else {
+                                                                ((WebChatGroup) c).updateTopic("");
+                                                            }
+                                                            TopicChangeEvent e = new TopicChangeEvent(c);
+                                                            eventDispatcher.callEvent(e);
+                                                        }
+                                                    } else {
+                                                        logger.severe("Unhandled messageType " + messageType);
+                                                        logger.severe(eventObj.toString());
+                                                    }
+                                                } else if (resourceType.equalsIgnoreCase("EndpointPresence")) {
+                                                } else if (resourceType.equalsIgnoreCase("UserPresence")) {
+                                                } else if (resourceType.equalsIgnoreCase("ConversationUpdate")) {
+                                                } else if (resourceType.equalsIgnoreCase("ThreadUpdate")) {
+                                                } else {
+                                                    logger.severe("Unhandled resourceType " + resourceType);
+                                                    logger.severe(eventObj.toString());
+                                                }
+                                            }
+                                        }
+                                    }
+                                });
+                            }
+                        } catch (IOException e) {
+                            e.printStackTrace();
+                        }
+                    }
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+        };
+        pollThread.start();
+    }
+
+    @Override
+    public Chat getChat(String name) {
+        return allChats.get(name);
+    }
+
+    @Override
+    public List<Chat> getAllChats() {
+        return new ArrayList<>(this.allChats.values());
+    }
+
+    @Override
+    public void logout() throws IOException {
+        Jsoup.connect(LOGOUT_URL).cookies(this.cookies).get();
+    }
+
+    public String getRegistrationToken() {
+        return this.registrationToken;
+    }
+
+    public String getSkypeToken() {
+        return this.skypeToken;
+    }
+
+    @Override
+    public EventDispatcher getEventDispatcher() {
+        return this.eventDispatcher;
+    }
+
+    private Chat fromUrl(String url) {
+        Matcher m = URL_PATTERN.matcher(url);
+        if (m.find()) {
+            return allChats.get(m.group(1));
+        }
+        return null;
+    }
+
+    private String getUser(String url) {
+        Matcher m = USER_PATTERN.matcher(url);
+        if (m.find()) {
+            return m.group(1);
+        }
+        return null;
+    }
+
+    private Response postToLogin(String username, String password) throws IOException {
+        Map<String, String> data = new HashMap<>();
+        Document loginDocument = Jsoup.connect(LOGIN_URL).get();
+        Element loginForm = loginDocument.getElementById("loginForm");
+        for (Element input : loginForm.getElementsByTag("input")) {
+            data.put(input.attr("name"), input.attr("value"));
+        }
+        Date now = new Date();
+        data.put("timezone_field", new SimpleDateFormat("XXX").format(now).replace(':', '|'));
+        data.put("username", username);
+        data.put("password", password);
+        data.put("js_time", String.valueOf(now.getTime() / 1000));
+        return Jsoup.connect(LOGIN_URL).data(data).method(Method.POST).execute();
+    }
+
+    private JsonObject buildSubscriptionObject() {
+        JsonObject subscriptionObject = new JsonObject();
+        subscriptionObject.addProperty("channelType", "httpLongPoll");
+        subscriptionObject.addProperty("template", "raw");
+        JsonArray interestedResources = new JsonArray();
+        interestedResources.add(new JsonPrimitive("/v1/users/ME/conversations/ALL/properties"));
+        interestedResources.add(new JsonPrimitive("/v1/users/ME/conversations/ALL/messages"));
+        interestedResources.add(new JsonPrimitive("/v1/users/ME/contacts/ALL"));
+        interestedResources.add(new JsonPrimitive("/v1/threads/ALL"));
+        subscriptionObject.add("interestedResources", interestedResources);
+        return subscriptionObject;
+    }
+    
+    private JsonObject buildRegistrationObject() {
+        JsonObject registrationObject = new JsonObject();
+        registrationObject.addProperty("id", "messagingService");
+        registrationObject.addProperty("type", "EndpointPresenceDoc");
+        registrationObject.addProperty("selfLink", "uri");
+        JsonObject publicInfo = new JsonObject();
+        publicInfo.addProperty("capabilities", "video|audio");
+        publicInfo.addProperty("type", 1);
+        publicInfo.addProperty("skypeNameVersion", "908/1.5.116/swx-skype.com");
+        publicInfo.addProperty("nodeInfo", "xx");
+        publicInfo.addProperty("version", "908/1.5.116");
+        JsonObject privateInfo = new JsonObject();
+        privateInfo.addProperty("epname", "Skype4J");
+        registrationObject.add("publicInfo", publicInfo);
+        registrationObject.add("privateInfo", privateInfo);
+        return registrationObject;
+    }
+
+    @Override
+    public String getUsername() {
+        return this.username;
+    }
+
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/web/WebUser.java b/src/main/java/com/samczsun/skype4j/internal/web/WebUser.java
new file mode 100644
index 0000000..5c3250a
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/web/WebUser.java
@@ -0,0 +1,70 @@
+package com.samczsun.skype4j.internal.web;
+
+import com.samczsun.skype4j.chat.Chat;
+import com.samczsun.skype4j.chat.User;
+
+public class WebUser implements User {
+    private String username;
+
+    private Chat chat;
+    private Role role = Role.USER;
+
+    public WebUser(String username, Chat chat) {
+        this.username = username;
+        this.chat = chat;
+    }
+
+    public WebUser(Chat chat) {
+        this.chat = chat;
+    }
+
+    @Override
+    public String getUsername() {
+        return username;
+    }
+
+    @Override
+    public String getDisplayName() {
+        return null;
+    }
+
+    @Override
+    public Role getRole() {
+        return this.role;
+    }
+
+    @Override
+    public void setRole(Role role) {
+        this.role = role;
+    }
+
+    @Override
+    public Chat getChat() {
+        return this.chat;
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((username == null) ? 0 : username.hashCode());
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        WebUser other = (WebUser) obj;
+        if (username == null) {
+            if (other.username != null)
+                return false;
+        } else if (!username.equals(other.username))
+            return false;
+        return true;
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/serialize/JsonSerializable.java b/src/main/java/com/samczsun/skype4j/serialize/JsonSerializable.java
new file mode 100644
index 0000000..cab5f92
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/serialize/JsonSerializable.java
@@ -0,0 +1,9 @@
+package com.samczsun.skype4j.serialize;
+
+import com.google.gson.JsonObject;
+
+public interface JsonSerializable {
+    public JsonObject serialize();
+
+    public void deserialize(JsonObject object);
+}
diff --git a/src/main/java/com/samczsun/skype4j/utils/StreamUtils.java b/src/main/java/com/samczsun/skype4j/utils/StreamUtils.java
new file mode 100644
index 0000000..8d93341
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/utils/StreamUtils.java
@@ -0,0 +1,17 @@
+package com.samczsun.skype4j.utils;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+public class StreamUtils {
+    public static String readFully(InputStream in) throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        byte[] chunk = new byte[2048];
+        int read = 0;
+        while ((read = in.read(chunk)) > 0) {
+            out.write(chunk, 0, read);
+        }
+        return out.toString();
+    }
+}
diff --git a/src/test/java/com/samczsun/skype4j/Test.java b/src/test/java/com/samczsun/skype4j/Test.java
new file mode 100644
index 0000000..909d75b
--- /dev/null
+++ b/src/test/java/com/samczsun/skype4j/Test.java
@@ -0,0 +1,23 @@
+package com.samczsun.skype4j;
+
+import java.io.FileInputStream;
+
+import com.samczsun.skype4j.PendingLogin.Client;
+import com.samczsun.skype4j.events.EventHandler;
+import com.samczsun.skype4j.events.Listener;
+import com.samczsun.skype4j.events.chat.message.MessageReceivedEvent;
+
+public class Test {
+    public static void main(String[] args) throws Exception {
+        String[] creds = StreamUtils.readFully(new FileInputStream("credentials")).split(":");
+        Skype skype = SkypeClient.create(creds[0], creds[1]).client(Client.WEB).login();
+        skype.getEventDispatcher().registerListener(new Listener() {
+            @EventHandler
+            public void onUserAdd(MessageReceivedEvent e) {
+                System.out.println("Got message " + e.getMessage().getMessage() + " in " + e.getChat().getIdentity());
+            }
+        });
+        skype.subscribe();
+        System.out.println("Done");
+    }
+}
