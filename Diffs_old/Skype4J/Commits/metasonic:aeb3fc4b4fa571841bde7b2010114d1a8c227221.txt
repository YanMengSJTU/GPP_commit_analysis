diff --git a/pom.xml b/pom.xml
index b2af275..1c9b2ef 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,8 +1,10 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<!--suppress MavenModelInspection -->
+<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
     <groupId>com.samczsun</groupId>
     <artifactId>skype4j</artifactId>
-    <version>0.2.0-SNAPSHOT</version>
+    <version>0.2.11-ARGUS-SNAPSHOT</version>
     <name>Skype4J</name>
     <description>A Skype API written in Java. P2P chats are not supported</description>
     <url>https://github.com/samczsun/Skype4J</url>
@@ -11,6 +13,10 @@
             <name>Sam Sun</name>
             <email>github@samczsun.com</email>
         </developer>
+        <developer>
+            <name>Alexey Semennikov</name>
+            <email>a.semennikov@argustelecom.ru</email>
+        </developer>
     </developers>
     <licenses>
         <license>
@@ -23,20 +29,18 @@
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
     </properties>
     <scm>
-        <url>git@github.com:samczsun/Skype4J.git</url>
-        <connection>scm:git:git@github.com:samczsun/Skype4J.git</connection>
-        <developerConnection>scm:git:git@github.com:samczsun/Skype4J.git</developerConnection>
-      <tag>HEAD</tag>
-  </scm>
+        <url>https://github.com/alsem/Skype4J.git</url>
+        <connection>scm:git:git@github.com:alsem/Skype4J.git</connection>
+        <developerConnection>scm:git:git@github.com:alsem/Skype4J.git</developerConnection>
+        <tag>HEAD</tag>
+    </scm>
     <distributionManagement>
         <snapshotRepository>
-            <id>ossrh</id>
-            <url>https://oss.sonatype.org/content/repositories/snapshots</url>
+            <id>artifactory</id>
+            <name>artifactory-snapshots</name>
+            <url>http://git:8081/artifactory/ext-snapshot-local</url>
         </snapshotRepository>
-        <repository>
-            <id>ossrh</id>
-            <url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>
-        </repository>
+
     </distributionManagement>
     <build>
         <sourceDirectory>src/main/java</sourceDirectory>
@@ -46,6 +50,7 @@
                 <directory>src/main/resources/</directory>
             </resource>
         </resources>
+
         <plugins>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
@@ -69,6 +74,21 @@
                     </execution>
                 </executions>
             </plugin>
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>build-helper-maven-plugin</artifactId>
+                <version>3.0.0</version>
+            </plugin>
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>versions-maven-plugin</artifactId>
+                <version>2.4</version>
+                <configuration>
+                    <newVersion>
+                        ${parsedVersion.majorVersion}.${parsedVersion.minorVersion}.${parsedVersion.nextIncrementalVersion}-${parsedVersion.qualifier}
+                    </newVersion>
+                </configuration>
+            </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-release-plugin</artifactId>
@@ -111,23 +131,16 @@
                     </execution>
                 </executions>
             </plugin>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-gpg-plugin</artifactId>
-                <version>1.6</version>
-                <executions>
-                    <execution>
-                        <id>sign-artifacts</id>
-                        <phase>verify</phase>
-                        <goals>
-                            <goal>sign</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
         </plugins>
+
     </build>
     <dependencies>
+        <!-- https://mvnrepository.com/artifact/log4j/log4j -->
+        <dependency>
+            <groupId>log4j</groupId>
+            <artifactId>log4j</artifactId>
+            <version>1.2.14</version>
+        </dependency>
         <dependency>
             <!-- For parsing Skype responses and HTML nodes -->
             <groupId>org.jsoup</groupId>
@@ -152,6 +165,29 @@
             <artifactId>Java-WebSocket</artifactId>
             <version>1.3.0</version>
         </dependency>
+        <!--MS live -->
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>okhttp</artifactId>
+            <version>3.8.1</version>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup.okio</groupId>
+            <artifactId>okio</artifactId>
+            <version>1.13.0</version>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-lang3</artifactId>
+            <version>3.5</version>
+        </dependency>
+        <dependency>
+            <groupId>org.json</groupId>
+            <artifactId>json</artifactId>
+            <version>20160810</version>
+        </dependency>
+
         <dependency>
             <groupId>org.mockito</groupId>
             <artifactId>mockito-all</artifactId>
diff --git a/src/main/java/com/samczsun/skype4j/LiveLoginSkypeBuilder.java b/src/main/java/com/samczsun/skype4j/LiveLoginSkypeBuilder.java
new file mode 100644
index 0000000..a2822c3
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/LiveLoginSkypeBuilder.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright 2016 Sam Sun <me@samczsun.com>
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+package com.samczsun.skype4j;
+
+import com.samczsun.skype4j.exceptions.handler.ErrorHandler;
+import com.samczsun.skype4j.internal.client.FullClient;
+import com.samczsun.skype4j.internal.client.GuestClient;
+import com.samczsun.skype4j.internal.client.MSFTSkypeClient;
+
+import java.util.*;
+import java.util.logging.Logger;
+
+/**
+ * This class is used to construct a new {@link Skype} instance.
+ */
+public class LiveLoginSkypeBuilder {
+
+    private final String username;
+    private final String password;
+
+    private Set<String> resources = new HashSet<>();
+    private List<ErrorHandler> errorHandlers = new ArrayList<>();
+    private Logger customLogger;
+    private String chatId;
+
+    /**
+     * Construct a SkypeBuilder with the given username and password
+     *
+     * @param username The username
+     * @param password The password
+     */
+    public LiveLoginSkypeBuilder(String username, String password) {
+        this.username = username;
+        this.password = password;
+    }
+
+    /**
+     * Subscribe to all known resources
+     *
+     * @return The same SkypeBuilder
+     */
+    public LiveLoginSkypeBuilder withAllResources() {
+        resources.addAll(Arrays
+                .asList("/v1/users/ME/conversations/ALL/properties", "/v1/users/ME/conversations/ALL/messages",
+                        "/v1/users/ME/contacts/ALL", "/v1/threads/ALL"));
+        return this;
+    }
+
+    /**
+     * Subscribe to a resource which has not been added into the API
+     *
+     * @param resource The resource to subscribe to
+     * @return The same SkypeBuilder
+     */
+    public LiveLoginSkypeBuilder withResource(String resource) {
+        resources.add(resource);
+        return this;
+    }
+
+    /**
+     * Use a custom logger for this Skype instance
+     *
+     * @param logger The custom logger to use
+     * @return The same SkypeBuilder
+     */
+    public LiveLoginSkypeBuilder withLogger(Logger logger) {
+        this.customLogger = logger;
+        return this;
+    }
+
+    /**
+     * Add an exception handler to handle exceptions
+     *
+     * @param errorHandler The exception handler
+     * @return The same SkypeBuilder
+     */
+    public LiveLoginSkypeBuilder withExceptionHandler(ErrorHandler errorHandler) {
+        this.errorHandlers.add(errorHandler);
+        return this;
+    }
+
+    /**
+     * Join a particular chat as a guest. Will have no effect if a password is specified
+     *
+     * @param id The chat id
+     * @return The same SkypeBuilder
+     */
+    public LiveLoginSkypeBuilder withChat(String id) {
+        if (!id.startsWith("19:"))
+            throw new IllegalArgumentException("Invalid chat id");
+        if (password != null)
+            throw new IllegalArgumentException("Not guest account");
+        this.chatId = id;
+        return this;
+    }
+
+    /**
+     * Build the Skype instance!
+     *
+     * @return The Skype instance
+     */
+    public Skype build() {
+        if (resources.isEmpty()) {
+            throw new IllegalArgumentException("No resources selected");
+        }
+
+        if (password != null && !username.contains("@")) {
+            return new FullClient(username, password, resources, customLogger, errorHandlers);
+
+        } else if (chatId != null && !username.contains("@")) {
+            return new GuestClient(username, chatId, resources, customLogger, errorHandlers);
+
+        } else if (username.contains("@")) {
+            return new MSFTSkypeClient(username, password, resources, customLogger, errorHandlers);
+        } else {
+            throw new IllegalArgumentException("No chat specified");
+        }
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/Skype.java b/src/main/java/com/samczsun/skype4j/Skype.java
index 09cbf61..eb98ec1 100644
--- a/src/main/java/com/samczsun/skype4j/Skype.java
+++ b/src/main/java/com/samczsun/skype4j/Skype.java
@@ -32,7 +32,7 @@
  * This class represents a single Skype account, which may or may not have been logged in
  */
 public interface Skype {
-    String VERSION = "908/1.52.0.82//skype.com";
+    String VERSION = "908/1.117.0.21//skype.com";
 
     RuntimeException UNEXPECTED = new RuntimeException("Please open a GitHub issue with this stacktrace, something unexpected happened");
 
@@ -40,7 +40,7 @@
      * Log into Skype. This will perform the following actions:
      * 1) Log into Skype to get a SkypeToken
      * 2) Register an endpoint to get a RegistrationToken
-     *
+     * <p>
      * Note that the SkypeToken technically expires after 24 hours. The vanilla implementation in Skype for Web
      * is to redirect you to the login screen. As such, roughly half an hour before 24 hours is hit, the API
      * will attempt to re-login and, if subscribed, resubscribe.
@@ -49,7 +49,8 @@
      * @throws ConnectionException         If a network error occured while connecting
      * @throws NotParticipatingException   If the guest account cannot log in due to the chat not being open
      */
-    void login() throws InvalidCredentialsException, ConnectionException, NotParticipatingException;
+    void login() throws InvalidCredentialsException, ConnectionException, NotParticipatingException,
+            SkypeAuthenticationException;
 
     /**
      * Subscribe to the HTTP long polling service.
diff --git a/src/main/java/com/samczsun/skype4j/chat/Chat.java b/src/main/java/com/samczsun/skype4j/chat/Chat.java
index f38117a..a89cc15 100644
--- a/src/main/java/com/samczsun/skype4j/chat/Chat.java
+++ b/src/main/java/com/samczsun/skype4j/chat/Chat.java
@@ -23,8 +23,8 @@
 import com.samczsun.skype4j.formatting.IMoji;
 import com.samczsun.skype4j.formatting.Message;
 import com.samczsun.skype4j.participants.Participant;
-import com.samczsun.skype4j.participants.info.Contact;
 import com.samczsun.skype4j.participants.User;
+import com.samczsun.skype4j.participants.info.Contact;
 
 import java.awt.image.BufferedImage;
 import java.io.File;
@@ -69,7 +69,7 @@
      * @param imageType The type of image (jpg, png, etc)
      * @param imageName The name of the image
      * @throws ConnectionException If an error occurs while connecting to the endpoint
-     * @throws IOException If an error occurs while reading the image file
+     * @throws IOException         If an error occurs while reading the image file
      */
     void sendImage(BufferedImage image, String imageType, String imageName) throws ConnectionException, IOException;
 
@@ -78,7 +78,7 @@
      *
      * @param image The file containing the image
      * @throws ConnectionException If an error occurs while connecting to the endpoint
-     * @throws IOException If an error occurs while reading the image file
+     * @throws IOException         If an error occurs while reading the image file
      */
     void sendImage(File image) throws ConnectionException, IOException;
 
@@ -100,7 +100,7 @@
 
     /**
      * Get a participant based on their id. The ID is in the format of {number}:{string}
-     *
+     * <p>
      * For example, a user has id 8:{username} while a bot has id 28:{uuid}
      *
      * @param id The id of the participant
diff --git a/src/main/java/com/samczsun/skype4j/chat/GroupChat.java b/src/main/java/com/samczsun/skype4j/chat/GroupChat.java
index 304c9cf..c078df9 100644
--- a/src/main/java/com/samczsun/skype4j/chat/GroupChat.java
+++ b/src/main/java/com/samczsun/skype4j/chat/GroupChat.java
@@ -60,7 +60,7 @@
      * @param image     The image to upload
      * @param imageType The type of image (png, jpg, etc)
      * @throws ConnectionException If an error occurs while connecting to the endpoint
-     * @throws IOException If an error occurs while converting the image to bytes
+     * @throws IOException         If an error occurs while converting the image to bytes
      */
     void setImage(BufferedImage image, String imageType) throws ConnectionException, IOException;
 
@@ -69,9 +69,9 @@
      * WARNING: This endpoint is not officially supported by Skype.
      * As such, it may or may not be functional in the future
      *
-     * @param file     The image to upload
+     * @param file The image to upload
      * @throws ConnectionException If an error occurs while connecting to the endpoint
-     * @throws IOException If an error occurs while converting the image to bytes
+     * @throws IOException         If an error occurs while converting the image to bytes
      */
     void setImage(File file) throws ConnectionException, IOException;
 
diff --git a/src/main/java/com/samczsun/skype4j/chat/IndividualChat.java b/src/main/java/com/samczsun/skype4j/chat/IndividualChat.java
index 6f49eaa..2d92661 100644
--- a/src/main/java/com/samczsun/skype4j/chat/IndividualChat.java
+++ b/src/main/java/com/samczsun/skype4j/chat/IndividualChat.java
@@ -17,7 +17,6 @@
 package com.samczsun.skype4j.chat;
 
 import com.samczsun.skype4j.participants.Participant;
-import com.samczsun.skype4j.participants.User;
 
 /**
  * Represents a private conversation between the user logged in and one other
diff --git a/src/main/java/com/samczsun/skype4j/chat/messages/ChatMessage.java b/src/main/java/com/samczsun/skype4j/chat/messages/ChatMessage.java
index 014a384..b5dc7b7 100644
--- a/src/main/java/com/samczsun/skype4j/chat/messages/ChatMessage.java
+++ b/src/main/java/com/samczsun/skype4j/chat/messages/ChatMessage.java
@@ -20,7 +20,6 @@
 import com.samczsun.skype4j.chat.Chat;
 import com.samczsun.skype4j.formatting.Message;
 import com.samczsun.skype4j.participants.Participant;
-import com.samczsun.skype4j.participants.User;
 
 /**
  * Represents a single message
diff --git a/src/main/java/com/samczsun/skype4j/chat/objects/ReceivedFile.java b/src/main/java/com/samczsun/skype4j/chat/objects/ReceivedFile.java
index 70bd3cd..ae33432 100644
--- a/src/main/java/com/samczsun/skype4j/chat/objects/ReceivedFile.java
+++ b/src/main/java/com/samczsun/skype4j/chat/objects/ReceivedFile.java
@@ -24,18 +24,21 @@
 
     /**
      * Get the name of the file which has been sent
+     *
      * @return The name of the file
      */
     String getName();
 
     /**
      * Get the size of the file
+     *
      * @return The filesize
      */
     long getSize();
 
     /**
      * Get the tid. Not sure what this does
+     *
      * @return The tid
      */
     long getTid();
diff --git a/src/main/java/com/samczsun/skype4j/events/chat/call/CallReceivedEvent.java b/src/main/java/com/samczsun/skype4j/events/chat/call/CallReceivedEvent.java
index 612891f..5e5e9a0 100644
--- a/src/main/java/com/samczsun/skype4j/events/chat/call/CallReceivedEvent.java
+++ b/src/main/java/com/samczsun/skype4j/events/chat/call/CallReceivedEvent.java
@@ -19,7 +19,6 @@
 import com.samczsun.skype4j.chat.Chat;
 import com.samczsun.skype4j.events.chat.ChatEvent;
 import com.samczsun.skype4j.participants.Participant;
-import com.samczsun.skype4j.participants.User;
 
 public class CallReceivedEvent extends ChatEvent {
     private final Participant sender;
diff --git a/src/main/java/com/samczsun/skype4j/events/chat/participant/ParticipantEvent.java b/src/main/java/com/samczsun/skype4j/events/chat/participant/ParticipantEvent.java
index 1181496..e3e393a 100644
--- a/src/main/java/com/samczsun/skype4j/events/chat/participant/ParticipantEvent.java
+++ b/src/main/java/com/samczsun/skype4j/events/chat/participant/ParticipantEvent.java
@@ -18,7 +18,6 @@
 
 import com.samczsun.skype4j.events.chat.ChatEvent;
 import com.samczsun.skype4j.participants.Participant;
-import com.samczsun.skype4j.participants.User;
 
 public abstract class ParticipantEvent extends ChatEvent {
     private final Participant user;
diff --git a/src/main/java/com/samczsun/skype4j/events/chat/participant/action/ModeratedUpdateEvent.java b/src/main/java/com/samczsun/skype4j/events/chat/participant/action/ModeratedUpdateEvent.java
index 3fde22f..7aeb3df 100644
--- a/src/main/java/com/samczsun/skype4j/events/chat/participant/action/ModeratedUpdateEvent.java
+++ b/src/main/java/com/samczsun/skype4j/events/chat/participant/action/ModeratedUpdateEvent.java
@@ -16,8 +16,6 @@
 
 package com.samczsun.skype4j.events.chat.participant.action;
 
-import com.samczsun.skype4j.chat.Chat;
-import com.samczsun.skype4j.events.chat.ChatEvent;
 import com.samczsun.skype4j.events.chat.participant.ParticipantEvent;
 import com.samczsun.skype4j.participants.Participant;
 
diff --git a/src/main/java/com/samczsun/skype4j/events/chat/sent/ContactReceivedEvent.java b/src/main/java/com/samczsun/skype4j/events/chat/sent/ContactReceivedEvent.java
index d4a5c72..596597b 100644
--- a/src/main/java/com/samczsun/skype4j/events/chat/sent/ContactReceivedEvent.java
+++ b/src/main/java/com/samczsun/skype4j/events/chat/sent/ContactReceivedEvent.java
@@ -20,7 +20,6 @@
 import com.samczsun.skype4j.events.chat.ChatEvent;
 import com.samczsun.skype4j.participants.Participant;
 import com.samczsun.skype4j.participants.info.Contact;
-import com.samczsun.skype4j.participants.User;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -36,13 +35,11 @@ public ContactReceivedEvent(Chat chat, Participant sender, List<Contact> sent) {
         this.sentContacts = new ArrayList<>(sent);
     }
 
-    public Participant getSender()
-    {
+    public Participant getSender() {
         return this.sender;
     }
 
-    public List<Contact> getSentContacts()
-    {
+    public List<Contact> getSentContacts() {
         return Collections.unmodifiableList(sentContacts);
     }
 }
diff --git a/src/main/java/com/samczsun/skype4j/events/chat/sent/FileReceivedEvent.java b/src/main/java/com/samczsun/skype4j/events/chat/sent/FileReceivedEvent.java
index b5c74f1..4cf3899 100644
--- a/src/main/java/com/samczsun/skype4j/events/chat/sent/FileReceivedEvent.java
+++ b/src/main/java/com/samczsun/skype4j/events/chat/sent/FileReceivedEvent.java
@@ -20,7 +20,6 @@
 import com.samczsun.skype4j.chat.objects.ReceivedFile;
 import com.samczsun.skype4j.events.chat.ChatEvent;
 import com.samczsun.skype4j.participants.Participant;
-import com.samczsun.skype4j.participants.User;
 
 import java.util.ArrayList;
 import java.util.List;
diff --git a/src/main/java/com/samczsun/skype4j/events/chat/sent/FlikReceivedEvent.java b/src/main/java/com/samczsun/skype4j/events/chat/sent/FlikReceivedEvent.java
index aadebc2..97bf362 100644
--- a/src/main/java/com/samczsun/skype4j/events/chat/sent/FlikReceivedEvent.java
+++ b/src/main/java/com/samczsun/skype4j/events/chat/sent/FlikReceivedEvent.java
@@ -20,7 +20,6 @@
 import com.samczsun.skype4j.events.chat.ChatEvent;
 import com.samczsun.skype4j.formatting.IMoji;
 import com.samczsun.skype4j.participants.Participant;
-import com.samczsun.skype4j.participants.User;
 
 public class FlikReceivedEvent extends ChatEvent {
     private final Participant sender;
diff --git a/src/main/java/com/samczsun/skype4j/events/chat/sent/LocationReceivedEvent.java b/src/main/java/com/samczsun/skype4j/events/chat/sent/LocationReceivedEvent.java
index b245c24..cf32633 100644
--- a/src/main/java/com/samczsun/skype4j/events/chat/sent/LocationReceivedEvent.java
+++ b/src/main/java/com/samczsun/skype4j/events/chat/sent/LocationReceivedEvent.java
@@ -21,7 +21,6 @@
 import com.samczsun.skype4j.formatting.Message;
 import com.samczsun.skype4j.formatting.Text;
 import com.samczsun.skype4j.participants.Participant;
-import com.samczsun.skype4j.participants.User;
 
 import javax.xml.bind.DatatypeConverter;
 import java.io.UnsupportedEncodingException;
diff --git a/src/main/java/com/samczsun/skype4j/events/chat/sent/PictureReceivedEvent.java b/src/main/java/com/samczsun/skype4j/events/chat/sent/PictureReceivedEvent.java
index 13690d8..1eae133 100644
--- a/src/main/java/com/samczsun/skype4j/events/chat/sent/PictureReceivedEvent.java
+++ b/src/main/java/com/samczsun/skype4j/events/chat/sent/PictureReceivedEvent.java
@@ -19,7 +19,6 @@
 import com.samczsun.skype4j.chat.Chat;
 import com.samczsun.skype4j.events.chat.ChatEvent;
 import com.samczsun.skype4j.participants.Participant;
-import com.samczsun.skype4j.participants.User;
 
 import java.awt.image.BufferedImage;
 
diff --git a/src/main/java/com/samczsun/skype4j/events/chat/sent/TypingReceivedEvent.java b/src/main/java/com/samczsun/skype4j/events/chat/sent/TypingReceivedEvent.java
index 0dcdb63..26e9a1e 100644
--- a/src/main/java/com/samczsun/skype4j/events/chat/sent/TypingReceivedEvent.java
+++ b/src/main/java/com/samczsun/skype4j/events/chat/sent/TypingReceivedEvent.java
@@ -19,7 +19,6 @@
 import com.samczsun.skype4j.chat.Chat;
 import com.samczsun.skype4j.events.chat.ChatEvent;
 import com.samczsun.skype4j.participants.Participant;
-import com.samczsun.skype4j.participants.User;
 
 public class TypingReceivedEvent extends ChatEvent {
     private final Participant sender;
diff --git a/src/main/java/com/samczsun/skype4j/exceptions/ConnectionException.java b/src/main/java/com/samczsun/skype4j/exceptions/ConnectionException.java
index 15552b3..4e47000 100644
--- a/src/main/java/com/samczsun/skype4j/exceptions/ConnectionException.java
+++ b/src/main/java/com/samczsun/skype4j/exceptions/ConnectionException.java
@@ -16,22 +16,16 @@
 
 package com.samczsun.skype4j.exceptions;
 
-import com.samczsun.skype4j.internal.ExceptionHandler;
 import com.samczsun.skype4j.internal.Utils;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.PrintWriter;
-import java.io.StringWriter;
+import java.io.*;
 import java.net.HttpURLConnection;
-import java.nio.charset.StandardCharsets;
 
 /**
  * Thrown when an exception occurs while connecting to an endpoint
  */
 public class ConnectionException extends SkypeException {
+    private static final long serialVersionUID = 6479923597926811460L;
     private int responseCode;
     private String responseMessage;
     private String message;
diff --git a/src/main/java/com/samczsun/skype4j/exceptions/SkypeAuthenticationException.java b/src/main/java/com/samczsun/skype4j/exceptions/SkypeAuthenticationException.java
new file mode 100644
index 0000000..6b22a85
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/exceptions/SkypeAuthenticationException.java
@@ -0,0 +1,16 @@
+package com.samczsun.skype4j.exceptions;
+
+/**
+ * @author a.semennikov
+ */
+public class SkypeAuthenticationException extends SkypeException {
+    private static final long serialVersionUID = -1916850559014704215L;
+
+    public SkypeAuthenticationException(String message) {
+        super(message);
+    }
+
+    public SkypeAuthenticationException(String message, Exception e) {
+        super(message, e);
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/exceptions/SkypeException.java b/src/main/java/com/samczsun/skype4j/exceptions/SkypeException.java
index 893e81b..403295b 100644
--- a/src/main/java/com/samczsun/skype4j/exceptions/SkypeException.java
+++ b/src/main/java/com/samczsun/skype4j/exceptions/SkypeException.java
@@ -29,6 +29,7 @@ public SkypeException() {
     public SkypeException(String message) {
         super(message);
     }
+
     public SkypeException(String message, Exception chain) {
         super(message, chain);
     }
diff --git a/src/main/java/com/samczsun/skype4j/exceptions/handler/ErrorHandler.java b/src/main/java/com/samczsun/skype4j/exceptions/handler/ErrorHandler.java
index d88ad4f..1d58e3b 100644
--- a/src/main/java/com/samczsun/skype4j/exceptions/handler/ErrorHandler.java
+++ b/src/main/java/com/samczsun/skype4j/exceptions/handler/ErrorHandler.java
@@ -6,9 +6,10 @@
 public interface ErrorHandler {
     /**
      * Handle the exception. Any exceptions thrown by this ErrorHandler will be silently swallowed and ignored
+     *
      * @param errorSource The cause of the error
-     * @param error The error, may be null
-     * @param shutdown Whether the API will shut down because this error is unrecoverable
+     * @param error       The error, may be null
+     * @param shutdown    Whether the API will shut down because this error is unrecoverable
      */
     void handle(ErrorSource errorSource, Throwable error, boolean shutdown);
 }
diff --git a/src/main/java/com/samczsun/skype4j/formatting/Generator.java b/src/main/java/com/samczsun/skype4j/formatting/Generator.java
index 90b3733..d809e7f 100644
--- a/src/main/java/com/samczsun/skype4j/formatting/Generator.java
+++ b/src/main/java/com/samczsun/skype4j/formatting/Generator.java
@@ -27,12 +27,7 @@
 import java.io.PrintWriter;
 import java.net.HttpURLConnection;
 import java.net.URL;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Scanner;
-import java.util.Set;
+import java.util.*;
 
 public class Generator {
     private static final String LANG = "en"; //Change to whatever lang you want
diff --git a/src/main/java/com/samczsun/skype4j/formatting/IEmoticon.java b/src/main/java/com/samczsun/skype4j/formatting/IEmoticon.java
index ff3cc60..251ad61 100644
--- a/src/main/java/com/samczsun/skype4j/formatting/IEmoticon.java
+++ b/src/main/java/com/samczsun/skype4j/formatting/IEmoticon.java
@@ -20,7 +20,10 @@
 
 public interface IEmoticon {
     String getId();
+
     List<String> getShortcuts();
+
     String getEtag();
+
     String getDescription();
 }
diff --git a/src/main/java/com/samczsun/skype4j/formatting/Message.java b/src/main/java/com/samczsun/skype4j/formatting/Message.java
index 07a1ac7..4ee1451 100644
--- a/src/main/java/com/samczsun/skype4j/formatting/Message.java
+++ b/src/main/java/com/samczsun/skype4j/formatting/Message.java
@@ -40,6 +40,18 @@ public static Message create() {
         return new Message();
     }
 
+    /**
+     * Parse a message from raw HTML
+     *
+     * @param text The HTML to parse from
+     * @return The message object
+     */
+    public static Message fromHtml(String text) {
+        final Message parsed = create();
+        parsed.with(RichText.fromHtml(text));
+        return parsed;
+    }
+
     /**
      * Add a child to this message
      *
@@ -101,18 +113,6 @@ public Text child(int index) {
         return Collections.unmodifiableList(this.components);
     }
 
-    /**
-     * Parse a message from raw HTML
-     *
-     * @param text The HTML to parse from
-     * @return The message object
-     */
-    public static Message fromHtml(String text) {
-        final Message parsed = create();
-        parsed.with(RichText.fromHtml(text));
-        return parsed;
-    }
-
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
diff --git a/src/main/java/com/samczsun/skype4j/formatting/RichText.java b/src/main/java/com/samczsun/skype4j/formatting/RichText.java
index f18f8b4..babce3c 100644
--- a/src/main/java/com/samczsun/skype4j/formatting/RichText.java
+++ b/src/main/java/com/samczsun/skype4j/formatting/RichText.java
@@ -34,40 +34,6 @@
  */
 public class RichText extends Text {
 
-    public enum Format {
-        BOLD("b", RichText::withBold),
-        ITALIC("i", RichText::withItalic),
-        UNDERLINE("u", RichText::withUnderline),
-        STRIKE_THROUGH("s", RichText::withStrikethrough),
-        CODE("pre", RichText::withCode),
-        BLINK("blink", RichText::withBlink);
-
-        private final String tagName;
-
-        private final Consumer<RichText> apply;
-
-        Format(String tagName, Consumer<RichText> apply) {
-            this.tagName = tagName;
-            this.apply = apply;
-        }
-
-        public String getTagName() {
-            return this.tagName;
-        }
-
-        public Consumer<RichText> getApplicator() {
-            return this.apply;
-        }
-
-        public String getOpenTag() {
-            return "<" + this.tagName + ">";
-        }
-
-        public String getCloseTag() {
-            return "</" + this.tagName + ">";
-        }
-    }
-
     private static final Map<String, BiConsumer<RichText, Element>> TAG_APPLIER = Collections.unmodifiableMap(
             new HashMap<String, BiConsumer<RichText, Element>>() {{
                 Arrays.stream(Format.values()).forEach(format -> put(format.getTagName(), (text, elem) -> format.getApplicator().accept(text)));
@@ -85,7 +51,6 @@ public String getCloseTag() {
                 });
             }}
     );
-
     private static final Map<String, BiPredicate<RichText, Element>> TAG_TEST = Collections.unmodifiableMap(
             new HashMap<String, BiPredicate<RichText, Element>>() {{
                 Arrays.stream(Format.values()).forEach(format -> put(format.getTagName(), (text, elem) -> text.hasFormat(format)));
@@ -117,19 +82,12 @@ public String getCloseTag() {
                 });
             }}
     );
-
     private final Set<Format> formats = EnumSet.noneOf(RichText.Format.class);
-
     private String link = null;
-
     private String color = null;
-
     private int size = -1;
-
     private RichText next;
-
     private RichText previous;
-
     private String text;
 
     RichText(String text) {
@@ -141,6 +99,66 @@ public String getCloseTag() {
         this.text = text;
     }
 
+    public static RichText fromHtml(String html) {
+        Document doc = Jsoup.parse(html);
+        doc.outputSettings().prettyPrint(false);
+        RichText root = new RichText("");
+        parse(root, doc.getElementsByTag("body").get(0));
+        return root;
+    }
+
+    private static RichText parse(RichText root, Node node) {
+        RichText current = root;
+        if (node instanceof Element) {
+            Element elem = (Element) node;
+            applyTag(current, elem);
+            String inner = elem.html();
+            Elements children = elem.children();
+            if (children.size() > 0) {
+                String[] parts = new String[children.size() + 1];
+                int i = 0;
+                int index = 0;
+                for (Element child : children) {
+                    int startChild = inner.indexOf("<" + child.tag().toString(), index);
+                    int endChild = startChild + child.outerHtml().length();
+                    parts[i++] = inner.substring(index, startChild);
+                    index = endChild;
+                }
+                parts[i] = inner.substring(index);
+                Element last = elem;
+                for (int j = 0; j < parts.length; j++) {
+                    if (hasTag(root, last)) {
+                        current.appendText(parts[j]);
+                    } else {
+                        current = current.append(parts[j], true);
+                        current.copyFormat(root);
+                    }
+                    if (j < children.size()) {
+                        Element child = children.get(j);
+                        if (!hasTag(current, child)) {
+                            current = current.append("", true);
+                            current.copyFormat(root);
+                        }
+                        current = parse(current, child);
+                        last = child;
+                    }
+                }
+            } else {
+                current.appendText(inner);
+            }
+        }
+        return current;
+    }
+
+    private static void applyTag(RichText text, Element tag) {
+        RichText.TAG_APPLIER.getOrDefault(tag.tagName(), (t, elem) -> {
+        }).accept(text, tag);
+    }
+
+    private static boolean hasTag(RichText text, Element tag) {
+        return RichText.TAG_TEST.getOrDefault(tag.tagName(), (t, elem) -> true).test(text, tag);
+    }
+
     public String getText() {
         return this.text;
     }
@@ -252,7 +270,6 @@ public boolean hasFormat(Format format) {
         return this.formats.contains(format);
     }
 
-
     public RichText append(String text) {
         return append(text, false);
     }
@@ -378,63 +395,37 @@ public int hashCode0() {
         return result;
     }
 
-    public static RichText fromHtml(String html) {
-        Document doc = Jsoup.parse(html);
-        doc.outputSettings().prettyPrint(false);
-        RichText root = new RichText("");
-        parse(root, doc.getElementsByTag("body").get(0));
-        return root;
-    }
+    public enum Format {
+        BOLD("b", RichText::withBold),
+        ITALIC("i", RichText::withItalic),
+        UNDERLINE("u", RichText::withUnderline),
+        STRIKE_THROUGH("s", RichText::withStrikethrough),
+        CODE("pre", RichText::withCode),
+        BLINK("blink", RichText::withBlink);
 
-    private static RichText parse(RichText root, Node node) {
-        RichText current = root;
-        if (node instanceof Element) {
-            Element elem = (Element) node;
-            applyTag(current, elem);
-            String inner = elem.html();
-            Elements children = elem.children();
-            if (children.size() > 0) {
-                String[] parts = new String[children.size() + 1];
-                int i = 0;
-                int index = 0;
-                for (Element child : children) {
-                    int startChild = inner.indexOf("<" + child.tag().toString(), index);
-                    int endChild = startChild + child.outerHtml().length();
-                    parts[i++] = inner.substring(index, startChild);
-                    index = endChild;
-                }
-                parts[i] = inner.substring(index);
-                Element last = elem;
-                for (int j = 0; j < parts.length; j++) {
-                    if (hasTag(root, last)) {
-                        current.appendText(parts[j]);
-                    } else {
-                        current = current.append(parts[j], true);
-                        current.copyFormat(root);
-                    }
-                    if (j < children.size()) {
-                        Element child = children.get(j);
-                        if (!hasTag(current, child)) {
-                            current = current.append("", true);
-                            current.copyFormat(root);
-                        }
-                        current = parse(current, child);
-                        last = child;
-                    }
-                }
-            } else {
-                current.appendText(inner);
-            }
+        private final String tagName;
+
+        private final Consumer<RichText> apply;
+
+        Format(String tagName, Consumer<RichText> apply) {
+            this.tagName = tagName;
+            this.apply = apply;
         }
-        return current;
-    }
 
-    private static void applyTag(RichText text, Element tag) {
-        RichText.TAG_APPLIER.getOrDefault(tag.tagName(), (t, elem) -> {
-        }).accept(text, tag);
-    }
+        public String getTagName() {
+            return this.tagName;
+        }
 
-    private static boolean hasTag(RichText text, Element tag) {
-        return RichText.TAG_TEST.getOrDefault(tag.tagName(), (t, elem) -> true).test(text, tag);
+        public Consumer<RichText> getApplicator() {
+            return this.apply;
+        }
+
+        public String getOpenTag() {
+            return "<" + this.tagName + ">";
+        }
+
+        public String getCloseTag() {
+            return "</" + this.tagName + ">";
+        }
     }
 }
\ No newline at end of file
diff --git a/src/main/java/com/samczsun/skype4j/formatting/Text.java b/src/main/java/com/samczsun/skype4j/formatting/Text.java
index 30bb407..3f4d846 100644
--- a/src/main/java/com/samczsun/skype4j/formatting/Text.java
+++ b/src/main/java/com/samczsun/skype4j/formatting/Text.java
@@ -35,22 +35,6 @@
      */
     public static final Text BLANK = plain("");
 
-    /**
-     * Get the HTML of this text
-     *
-     * @return The HTML
-     */
-    public abstract String write();
-
-    /**
-     * The equivilant of calling {@code Text#write}
-     *
-     * @return The HTML of this text
-     */
-    public String toString() {
-        return this.write();
-    }
-
     /**
      * Creates a new RichText component
      *
@@ -208,4 +192,20 @@ public static String parseEmojis(String in) {
         }
         return result.toString();
     }
+
+    /**
+     * Get the HTML of this text
+     *
+     * @return The HTML
+     */
+    public abstract String write();
+
+    /**
+     * The equivilant of calling {@code Text#write}
+     *
+     * @return The HTML of this text
+     */
+    public String toString() {
+        return this.write();
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/com/samczsun/skype4j/formatting/lang/DefaultMoji.java b/src/main/java/com/samczsun/skype4j/formatting/lang/DefaultMoji.java
index 685d265..7958c72 100644
--- a/src/main/java/com/samczsun/skype4j/formatting/lang/DefaultMoji.java
+++ b/src/main/java/com/samczsun/skype4j/formatting/lang/DefaultMoji.java
@@ -25,6 +25,14 @@
 
     ;
 
+    private static final Map<String, IMoji> fliks = new HashMap<>();
+
+    static {
+        for (IMoji flik : values()) {
+            fliks.put(flik.getId(), flik);
+        }
+    }
+
     private String id;
     private String etag;
     private String desc;
@@ -35,6 +43,10 @@
         this.desc = desc;
     }
 
+    public static IMoji getById(String id) {
+        return fliks.get(id);
+    }
+
     public String getId() {
         return this.id;
     }
@@ -46,16 +58,4 @@ public String getEtag() {
     public String getDescription() {
         return this.desc;
     }
-
-    private static final Map<String, IMoji> fliks = new HashMap<>();
-
-    static {
-        for (IMoji flik : values()) {
-            fliks.put(flik.getId(), flik);
-        }
-    }
-
-    public static IMoji getById(String id) {
-        return fliks.get(id);
-    }
 }
diff --git a/src/main/java/com/samczsun/skype4j/formatting/lang/en/Emoticon.java b/src/main/java/com/samczsun/skype4j/formatting/lang/en/Emoticon.java
index a0e743f..00bed1c 100644
--- a/src/main/java/com/samczsun/skype4j/formatting/lang/en/Emoticon.java
+++ b/src/main/java/com/samczsun/skype4j/formatting/lang/en/Emoticon.java
@@ -237,6 +237,8 @@
     HEADPHONES("headphones", "3a62dadc-1e79-42f1-9dc5-96c8c159dad2", "Listening to headphones", "(headphones)", "(Headphones)"),
     SHIVERING("shivering", "176ee7a9-094d-43d4-87a2-2193796691ac", "Cold shivering", "(shivering)", "(Shivering)", "(cold)", "(Cold)", "(freezing)", "(Freezing)");
 
+    private static Map<String, Emoticon> dictionary;
+    private static int longestEmoji = -1;
     private final String id;
     private final String etag;
     private final String desc;
@@ -249,25 +251,6 @@
         this.shortcuts = Arrays.asList(shortcuts);
     }
 
-    public String getId() {
-        return this.id;
-    }
-
-    public List<String> getShortcuts() {
-        return Collections.unmodifiableList(this.shortcuts);
-    }
-
-    public String getEtag() {
-        return this.etag;
-    }
-
-    public String getDescription() {
-        return this.desc;
-    }
-
-    private static Map<String, Emoticon> dictionary;
-    private static int longestEmoji = -1;
-
     public static Map<String, Emoticon> getDictionary() {
         if (dictionary == null) { // This is for performance, trust me
             initDictionary();
@@ -299,4 +282,20 @@ private static void initDictionary() {
             }
         }
     }
+
+    public String getId() {
+        return this.id;
+    }
+
+    public List<String> getShortcuts() {
+        return Collections.unmodifiableList(this.shortcuts);
+    }
+
+    public String getEtag() {
+        return this.etag;
+    }
+
+    public String getDescription() {
+        return this.desc;
+    }
 }
diff --git a/src/main/java/com/samczsun/skype4j/formatting/lang/en/Moji.java b/src/main/java/com/samczsun/skype4j/formatting/lang/en/Moji.java
index 0065688..67b6171 100644
--- a/src/main/java/com/samczsun/skype4j/formatting/lang/en/Moji.java
+++ b/src/main/java/com/samczsun/skype4j/formatting/lang/en/Moji.java
@@ -303,6 +303,14 @@
     VICKYDONOR_1("14271874627f4a2d893db568eeff9954", "3c026c7d-aa37-4fe1-8bfb-133460aed512", "Vicky Donor"),
     MOHABBATEIN("b3cffea2fd5044d08db7458e4c373cdf", "5b000c95-f530-4a7f-b302-842675aaa249", "Mohabbatein ");
 
+    private static final Map<String, IMoji> fliks = new HashMap<>();
+
+    static {
+        for (IMoji flik : values()) {
+            fliks.put(flik.getId(), flik);
+        }
+    }
+
     private final String id;
     private final String etag;
     private final String desc;
@@ -313,6 +321,10 @@
         this.desc = desc;
     }
 
+    public static IMoji getById(String id) {
+        return fliks.get(id);
+    }
+
     public String getId() {
         return this.id;
     }
@@ -324,16 +336,4 @@ public String getEtag() {
     public String getDescription() {
         return this.desc;
     }
-
-    private static final Map<String, IMoji> fliks = new HashMap<>();
-
-    static {
-        for (IMoji flik : values()) {
-            fliks.put(flik.getId(), flik);
-        }
-    }
-
-    public static IMoji getById(String id) {
-        return fliks.get(id);
-    }
 }
diff --git a/src/main/java/com/samczsun/skype4j/internal/EndpointConnection.java b/src/main/java/com/samczsun/skype4j/internal/EndpointConnection.java
new file mode 100644
index 0000000..4f8d792
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/EndpointConnection.java
@@ -0,0 +1,305 @@
+package com.samczsun.skype4j.internal;
+
+import com.eclipsesource.json.JsonArray;
+import com.eclipsesource.json.JsonObject;
+import com.eclipsesource.json.JsonValue;
+import com.samczsun.skype4j.exceptions.ConnectionException;
+import com.samczsun.skype4j.internal.utils.Encoder;
+
+import javax.imageio.ImageIO;
+import javax.net.ssl.*;
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.*;
+import java.nio.charset.StandardCharsets;
+import java.security.KeyManagementException;
+import java.security.NoSuchAlgorithmException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.function.Predicate;
+
+/**
+ * @author a.semennikov
+ */
+public class EndpointConnection<E_TYPE> {
+    static Map<Class<?>, Converter<?>> converters = new HashMap<>();
+
+    static {
+        converters.put(InputStream.class, HttpURLConnection::getInputStream);
+        converters.put(HttpURLConnection.class, in -> in);
+        converters.put(JsonObject.class, in -> Utils.parseJsonObject(in.getInputStream()));
+        converters.put(JsonArray.class, in -> Utils.parseJsonArray(in.getInputStream()));
+        converters.put(String.class, in -> StreamUtils.readFully(in.getInputStream()));
+        converters.put(BufferedImage.class, in -> ImageIO.read(in.getInputStream()));
+    }
+
+    private Class<E_TYPE> clazz = (Class<E_TYPE>) HttpURLConnection.class;
+    private Endpoints endpoint;
+    private SkypeImpl skype;
+    private Object[] args;
+    private Map<String, String> headers = new HashMap<>();
+    private Map<String, String> cookies = new HashMap<>();
+    private Map<Predicate<Integer>, UncheckedFunction<E_TYPE>> errors = new HashMap<>();
+    private URL url;
+    private String cause;
+    private boolean dontConnect;
+    private boolean redirect = true;
+
+    EndpointConnection(Endpoints endpoint, SkypeImpl skype, Object[] args) {
+        this.endpoint = endpoint;
+        this.skype = skype;
+        this.args = args;
+        header("User-Agent",
+                "Mozilla/5.0 (Windows NT 10; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36 Skype4J/"
+                        + SkypeImpl.VERSION);
+    }
+
+    public static <T> T convert(Class<?> type, SkypeImpl skype, HttpURLConnection in) throws IOException {
+        return (T) converters.get(type).convert(in);
+    }
+
+    public EndpointConnection<E_TYPE> header(String key, String val) {
+        this.headers.put(key, val);
+        return this;
+    }
+
+    public EndpointConnection<E_TYPE> cookie(String key, String val) {
+        this.cookies.put(key, val);
+        return this;
+    }
+
+    public EndpointConnection<E_TYPE> cookies(Map<String, String> cookies) {
+        this.cookies.putAll(cookies);
+        return this;
+    }
+
+    public EndpointConnection<E_TYPE> on(int code, UncheckedFunction<E_TYPE> action) {
+        return on(x -> x == code, action);
+    }
+
+    public EndpointConnection<E_TYPE> on(Predicate<Integer> check, UncheckedFunction<E_TYPE> result) {
+        this.errors.put(check, result);
+        return this;
+    }
+
+    public EndpointConnection<E_TYPE> expect(int code, String cause) {
+        return expect(x -> x == code, cause);
+    }
+
+    public EndpointConnection<E_TYPE> expect(Predicate<Integer> check, String cause) {
+        this.cause = cause;
+        return on(check, (connection) -> convert(clazz, skype, connection));
+    }
+
+    public EndpointConnection<E_TYPE> noRedirects() {
+        this.redirect = false;
+        return this;
+    }
+
+    public <NEW_E_TYPE> EndpointConnection<NEW_E_TYPE> as(Class<NEW_E_TYPE> clazz) {
+        this.clazz = (Class<E_TYPE>) clazz;
+        return (EndpointConnection<NEW_E_TYPE>) this;
+    }
+
+    public EndpointConnection<E_TYPE> dontConnect() {
+        this.dontConnect = true;
+        return this;
+    }
+
+    public E_TYPE get() throws ConnectionException {
+        return connect("GET", new byte[0]);
+    }
+
+    public E_TYPE delete() throws ConnectionException {
+        return connect("DELETE", new byte[0]);
+    }
+
+    public E_TYPE post() throws ConnectionException {
+        return connect("POST", new byte[0]);
+    }
+
+    public E_TYPE post(String data) throws ConnectionException {
+        return connect("POST", data);
+    }
+
+    public E_TYPE post(JsonValue json) throws ConnectionException {
+        return header("Content-Type", "application/json")
+                .header("Accept", "application/json").connect("POST", json.toString());
+    }
+
+    public E_TYPE put() throws ConnectionException {
+        return connect("PUT", new byte[0]);
+    }
+
+    public E_TYPE put(String data) throws ConnectionException {
+        return connect("PUT", data);
+    }
+
+    public E_TYPE put(JsonValue json) throws ConnectionException {
+        return header("Content-Type", "application/json").connect("PUT", json.toString());
+    }
+
+    public E_TYPE connect(String method, String data) throws ConnectionException {
+        return this.connect(method, data != null ? data.getBytes(StandardCharsets.UTF_8) : new byte[0]);
+    }
+
+    public E_TYPE connect(String method, byte[] rawData) throws ConnectionException {
+        if (!cookies.isEmpty()) {
+            header("Cookie", serializeCookies(cookies));
+        }
+        if (endpoint.isRegTokenRequired()) {
+            header("RegistrationToken", skype.getRegistrationToken());
+        }
+        if (endpoint.isSkypeTokenRequired()) {
+            header("X-SkypeToken", skype.getSkypeToken());
+        }
+
+        if (this.redirect) {
+            this.on(code -> (code >= 301 && code <= 303) || code == 307 || code == 308, connection -> {
+                skype.updateCloud(connection.getHeaderField("Location"));
+                this.url = new URL(connection.getHeaderField("Location"));
+                return this.connect(method, rawData);
+            });
+        }
+        for (Map.Entry<String, Endpoints.Provider<String>> provider : endpoint.providers().entrySet()) {
+            header(provider.getKey(), provider.getValue().provide(skype));
+        }
+        HttpsURLConnection connection = null;
+        try {
+            if (this.url == null) { //todo could fail if cloud is updated?
+                String surl = endpoint.url();
+                this.url = fillRequestArgs(surl);
+            }
+            String PROXY_HOST = System.getProperty("skype.conn.proxy.host", "");
+            String PROXY_PORT = System.getProperty("skype.conn.proxy.port", "");
+            Boolean sslEnabled = !Boolean.parseBoolean(System.getProperty("skype.conn.proxy.ssl.disabled"));
+            Proxy proxy = Proxy.NO_PROXY;
+
+            if (!PROXY_HOST.isEmpty() && !PROXY_PORT.isEmpty()) {
+                proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(PROXY_HOST,
+                        Integer.parseInt(PROXY_PORT)));
+            }
+
+            connection = (HttpsURLConnection) url.openConnection(proxy);
+            connection.setRequestMethod(method);
+            connection.setInstanceFollowRedirects(false);
+            if (sslEnabled) {
+                connection.setSSLSocketFactory(getUnsafeSslSocketFactory());
+                connection.setHostnameVerifier((hostName, session) -> true);
+            }
+            for (Map.Entry<String, String> ent : headers.entrySet()) {
+                connection.setRequestProperty(ent.getKey(), ent.getValue());
+            }
+            if (!method.equalsIgnoreCase("GET")) {
+                connection.setDoOutput(true);
+                if (rawData != null) {
+                    connection.getOutputStream().write(rawData);
+                } else {
+                    connection.getOutputStream().write(new byte[0]);
+                }
+            }
+            if (!this.dontConnect) {
+                if (connection.getHeaderField("Set-RegistrationToken") != null) {
+                    skype.getRegTokenProvider().setRegistrationToken(connection.getHeaderField("Set-RegistrationToken"));
+                }
+                for (Map.Entry<Predicate<Integer>, UncheckedFunction<E_TYPE>> entry : errors.entrySet()) {
+                    if (entry.getKey().test(connection.getResponseCode())) {
+                        try {
+                            return entry.getValue().apply(connection);
+                        } catch (Throwable t) {
+                            Utils.sneakyThrow(t);
+                        }
+                    }
+                }
+                throw ExceptionHandler.generateException(cause == null ? this.url.toString() : cause, connection);
+            } else if (HttpURLConnection.class.isAssignableFrom(clazz)) {
+                return (E_TYPE) connection;
+            } else {
+                throw new IllegalArgumentException(
+                        "DontConnect requested but did not request cast to HttpURLConnection");
+            }
+        } catch (IOException e) {
+            throw ExceptionHandler.generateException(cause, e);
+        } finally {
+            if (clazz != InputStream.class && clazz != HttpURLConnection.class) {
+                if (connection != null) {
+                    connection.disconnect();
+                }
+            }
+        }
+    }
+
+    private URL fillRequestArgs(String surl) throws MalformedURLException {
+        if (endpoint.isLocationRequired()) {
+            Object[] format = new Object[args.length + 1];
+            format[0] = skype.getCloud();
+            for (int i = 1; i < format.length; i++) {
+                format[i] = args[i - 1].toString();
+            }
+            surl = String.format(surl, format);
+        } else if (args.length > 0) {
+            Object[] format = new Object[args.length];
+            for (int i = 0; i < format.length; i++) {
+                format[i] = args[i].toString();
+            }
+            surl = String.format(surl, args);
+        }
+        return new URL(surl);
+    }
+
+    private SSLSocketFactory getUnsafeSslSocketFactory() {
+        try {
+            // Create a trust manager that does not validate certificate chains
+            final TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {
+                @Override
+                public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {
+                }
+
+                @Override
+                public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) {
+                }
+
+                @Override
+                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
+                    return null;
+                }
+            }};
+
+            // Install the all-trusting trust manager
+            final SSLContext sslContext = SSLContext.getInstance("SSL");
+            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
+            // Create an ssl socket factory with our all-trusting manager
+            return sslContext.getSocketFactory();
+        } catch (NoSuchAlgorithmException | KeyManagementException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private String serializeCookies(Map<String, String> cookies) {
+        StringBuilder result = new StringBuilder();
+        for (Map.Entry<String, String> cookie : cookies.entrySet()) {
+            result.append(Encoder.encode(cookie.getKey())).append("=").append(Encoder.encode(cookie.getValue()))
+                    .append(";");
+        }
+        return result.toString();
+    }
+
+    public interface Converter<T> {
+        T convert(HttpURLConnection connection) throws IOException;
+    }
+
+    public interface UncheckedFunction<R> extends Function<HttpURLConnection, R> {
+        default R apply(HttpURLConnection httpURLConnection) {
+            try {
+                return apply0(httpURLConnection);
+            } catch (Throwable t) {
+                Utils.sneakyThrow(t);
+            }
+            return null;
+        }
+
+        R apply0(HttpURLConnection httpURLConnection) throws Throwable;
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/Endpoints.java b/src/main/java/com/samczsun/skype4j/internal/Endpoints.java
index 54b7d29..2119103 100644
--- a/src/main/java/com/samczsun/skype4j/internal/Endpoints.java
+++ b/src/main/java/com/samczsun/skype4j/internal/Endpoints.java
@@ -16,50 +16,21 @@
 
 package com.samczsun.skype4j.internal;
 
-import com.eclipsesource.json.JsonArray;
-import com.eclipsesource.json.JsonObject;
-import com.eclipsesource.json.JsonValue;
-import com.samczsun.skype4j.exceptions.ConnectionException;
-import com.samczsun.skype4j.internal.utils.Encoder;
-
-import javax.imageio.ImageIO;
-import java.awt.image.BufferedImage;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
 import java.net.HttpURLConnection;
-import java.net.URL;
-import java.nio.charset.StandardCharsets;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.Map;
-import java.util.Set;
-import java.util.function.Function;
-import java.util.function.Predicate;
 
 public class Endpoints {
-    private static Map<Class<?>, Converter<?>> converters = new HashMap<>();
-
-    static {
-        converters.put(InputStream.class, HttpURLConnection::getInputStream);
-        converters.put(HttpURLConnection.class, in -> in);
-        converters.put(JsonObject.class, in -> Utils.parseJsonObject(in.getInputStream()));
-        converters.put(JsonArray.class, in -> Utils.parseJsonArray(in.getInputStream()));
-        converters.put(String.class, in -> StreamUtils.readFully(in.getInputStream()));
-        converters.put(BufferedImage.class, in -> ImageIO.read(in.getInputStream()));
-    }
-
-    public static <T> T convert(Class<?> type, SkypeImpl skype, HttpURLConnection in) throws IOException {
-        return (T) converters.get(type).convert(in);
-    }
 
     public static final Provider<String> AUTHORIZATION = skype -> "skype_token " + skype.getSkypeToken();
     public static final Provider<String> COOKIE = skype -> "skypetoken_asm=" + skype.getSkypeToken();
+
     public static final Endpoints ACCEPT_CONTACT_REQUEST = new Endpoints(
-            "https://api.skype.com/users/self/contacts/auth-request/%s/accept").skypetoken();
+            "https://contacts.skype.com/contacts/v2/users/%s/invites/%s/accept").skypetoken();
+    public static final Endpoints DECLINE_CONTACT_REQUEST = new Endpoints(
+            "https://contacts.skype.com/contacts/v2/users/%s/invites/%s/decline").skypetoken();
+
     public static final Endpoints GET_JOIN_URL = new Endpoints("https://api.scheduler.skype.com/threads").skypetoken();
     public static final Endpoints CHAT_INFO_URL = new Endpoints(
             "https://%sclient-s.gateway.messenger.live.com/v1/threads/%s/?view=msnp24Equivalent").cloud().regtoken();
@@ -74,16 +45,26 @@
     public static final Endpoints CONVERSATION_PROPERTY_GLOBAL = new Endpoints(
             "https://%sclient-s.gateway.messenger.live.com/v1/threads/%s/properties?name=%s").cloud().regtoken();
     public static final Endpoints ADD_MEMBER_URL = new Endpoints(
-            "https://client-s.gateway.messenger.live.com/v1/threads/%s/members/8:%s").regtoken();
+            "https://%sclient-s.gateway.messenger.live.com/v1/threads/%s/members/8:%s").cloud().regtoken();
     public static final Endpoints LOGIN_URL = new Endpoints("https://api.skype.com/login/skypetoken");
+    public static final Endpoints REFRESH_LOGIN_URL = new Endpoints("https://login.skype.com/login?client_id=578134&redirect_uri=https%3A%2F%2Fweb.skype.com");
+    public static final Endpoints REFRESH_EXCHANGE_LOGIN_URL =
+            new Endpoints("https://login.skype.com/login/microsoft?client_id=578134&redirect_uri=https%3A%2F%2Fweb.skype.com");
     public static final Endpoints PING_URL = new Endpoints("https://web.skype.com/api/v1/session-ping").skypetoken();
     public static final Endpoints TOKEN_AUTH_URL = new Endpoints("https://api.asm.skype.com/v1/skypetokenauth");
     public static final Endpoints LOGOUT_URL = new Endpoints(
             "https://login.skype.com/logout?client_id=578134&redirect_uri=https%3A%2F%2Fweb.skype.com&intsrc=client-_-webapp-_-production-_-go-signin");
+    //called without regtoken or cloud
     public static final Endpoints ENDPOINTS_URL = new Endpoints(
             "https://client-s.gateway.messenger.live.com/v1/users/ME/endpoints");
+    @Deprecated
     public static final Endpoints AUTH_REQUESTS_URL = new Endpoints(
-            "https://api.skype.com/users/self/contacts/auth-request").skypetoken();
+            "https://api.skype.com/users/self/contacts/refreshToken-request").skypetoken();
+    @Deprecated
+    public static final Endpoints AUTHORIZE_CONTACT = new Endpoints(
+            "https://api.skype.com/users/self/contacts/refreshToken-request/%s/accept").skypetoken();
+    public static final Endpoints GET_CONTACT_REQUESTS = new Endpoints(
+            "https://contacts.skype.com/contacts/v2/users/%s/invites").skypetoken();
     public static final Endpoints TROUTER_URL = new Endpoints("https://go.trouter.io/v2/a");
     public static final Endpoints POLICIES_URL = new Endpoints("https://prod.tpc.skype.com/v1/policies").skypetoken();
     public static final Endpoints REGISTRATIONS = new Endpoints(
@@ -108,10 +89,12 @@
     public static final Endpoints ACTIVE = new Endpoints(
             "https://%sclient-s.gateway.messenger.live.com/v1/users/ME/endpoints/%s/active").cloud().regtoken();
     public static final Endpoints LOAD_CHATS = new Endpoints(
-            "https://client-s.gateway.messenger.live.com/v1/users/ME/conversations?startTime=%s&pageSize=%s&view=msnp24Equivalent&targetType=Passport|Skype|Lync|Thread|PSTN|Agent")
+            "https://%sclient-s.gateway.messenger.live.com/v1/users/ME/conversations?startTime=%s&pageSize=%s&view=msnp24Equivalent&targetType=Passport|Skype|Lync|Thread|PSTN|Agent")
+            .cloud()
             .regtoken();
     public static final Endpoints LOAD_MESSAGES = new Endpoints(
-            "https://client-s.gateway.messenger.live.com/v1/users/ME/conversations/%s/messages?startTime=0&pageSize=%s&view=msnp24Equivalent|supportsMessageProperties&targetType=Passport|Skype|Lync|Thread")
+            "https://%sclient-s.gateway.messenger.live.com/v1/users/ME/conversations/%s/messages?startTime=0&pageSize=%s&view=msnp24Equivalent|supportsMessageProperties&targetType=Passport|Skype|Lync|Thread")
+            .cloud()
             .regtoken();
     public static final Endpoints OBJECTS = new Endpoints("https://api.asm.skype.com/v1/objects").defaultHeader(
             "Authorization", AUTHORIZATION);
@@ -128,24 +111,23 @@
     public static final Endpoints SEARCH_SKYPE_DIRECTORY = new Endpoints(
             "https://api.skype.com/search/users/any?keyWord=%s&contactTypes[]=skype").skypetoken();
     public static final Endpoints GET_ALL_CONTACTS = new Endpoints(
-            "https://contacts.skype.com/contacts/v1/users/%s/contacts?delta&$filter=type%%20eq%%20%%27skype%%27%%20or%%20type%%20eq%%20%%27msn%%27%%20or%%20type%%20eq%%20%%27pstn%%27%%20or%%20type%%20eq%%20%%27agent%%27%%20or%%20type%%20eq%%20%%27lync%%27&reason=%s")
+            "https://contacts.skype.com/contacts/v2/users/%s/contacts?delta&$filter=type%%20eq%%20%%27skype%%27%%20or%%20type%%20eq%%20%%27msn%%27%%20or%%20type%%20eq%%20%%27pstn%%27%%20or%%20type%%20eq%%20%%27agent%%27%%20or%%20type%%20eq%%20%%27lync%%27&reason=%s")
             .skypetoken();
     public static final Endpoints GET_CONTACT_BY_ID = new Endpoints(
-            "https://contacts.skype.com/contacts/v1/users/%s/contacts?$filter=id%%20eq%%20%%27%s%%27&reason=default").skypetoken();
+            "https://contacts.skype.com/contacts/v2/users/%s/contacts?$filter=id%%20eq%%20%%27%s%%27&reason=default").skypetoken();
     public static final Endpoints BLOCK_CONTACT = new Endpoints(
             "https://api.skype.com/users/self/contacts/%s/block").skypetoken();
     public static final Endpoints UNBLOCK_CONTACT = new Endpoints(
             "https://api.skype.com/users/self/contacts/%s/unblock").skypetoken();
-    public static final Endpoints AUTHORIZE_CONTACT = new Endpoints(
-            "https://api.skype.com/users/self/contacts/auth-request/%s/accept").skypetoken();
+    public static final Endpoints AUTHORIZE_CONTACT_SELF = new Endpoints(
+            "https://%sclient-s.gateway.messenger.live.com/v1/users/ME/contacts/%s").cloud().regtoken();
     public static final Endpoints UNAUTHORIZE_CONTACT = new Endpoints(
-            "https://client-s.gateway.messenger.live.com/v1/users/ME/contacts/8:%s").regtoken();
-    public static final Endpoints DECLINE_CONTACT_REQUEST = new Endpoints(
-            "https://api.skype.com/users/self/contacts/auth-request/%s/decline").skypetoken();
+            "https://contacts.skype.com/contacts/v2/users/%s/contacts/%s").skypetoken();
     public static final Endpoints UNAUTHORIZE_CONTACT_SELF = new Endpoints(
-            "https://api.skype.com/users/self/contacts/%s").skypetoken();
-    public static final Endpoints AUTHORIZATION_REQUEST = new Endpoints(
-            "https://api.skype.com/users/self/contacts/auth-request/%s").skypetoken();
+            "https://%sclient-s.gateway.messenger.live.com/v1/users/ME/contacts/%s").cloud().regtoken();
+
+    public static final Endpoints SEND_CONTACT_REQUEST = new Endpoints(
+            "https://contacts.skype.com/contacts/v2/users/%s/contacts").skypetoken();
     @Deprecated
     public static final Endpoints CONTACT_INFO = new Endpoints(
             "https://api.skype.com/users/self/contacts/profiles").skypetoken();
@@ -163,19 +145,12 @@
     public static final Endpoints NEW_KEY = new Endpoints("https://kes.skype.com/v2/swx/newkey").skypetoken();
     public static final Endpoints PETOKEN = new Endpoints("https://static.asm.skype.com/pes/v1/petoken").defaultHeader("Authorization", AUTHORIZATION);
     public static final Endpoints PROFILE = new Endpoints("https://api.skype.com/users/self/profile").skypetoken();
-
+    public Map<String, Provider<String>> providers = new HashMap<>();
     private boolean requiresCloud;
     private boolean requiresRegToken;
     private boolean requiresSkypeToken;
-
-    private Map<String, Provider<String>> providers = new HashMap<>();
-
     private String url;
 
-    public String url() {
-        return this.url;
-    }
-
     private Endpoints(String url) {
         this.url = url;
     }
@@ -187,6 +162,25 @@ private Endpoints(String url) {
         return new EndpointConnection(new Endpoints(url), skype, args).as(HttpURLConnection.class);
     }
 
+    public Map<String, Provider<String>> providers() {
+        return Collections.unmodifiableMap(providers);
+    }
+
+    public String url() {
+        return this.url;
+    }
+
+    @Override
+    public String toString() {
+        final StringBuilder sb = new StringBuilder("Endpoints{");
+        sb.append("requiresCloud=").append(requiresCloud);
+        sb.append(", requiresRegToken=").append(requiresRegToken);
+        sb.append(", requiresSkypeToken=").append(requiresSkypeToken);
+        sb.append(", url='").append(url).append('\'');
+        sb.append('}');
+        return sb.toString();
+    }
+
     public EndpointConnection<HttpURLConnection> open(SkypeImpl skype, Object... args) {
         if (skype.isShutdownRequested()) {
             throw new IllegalStateException("API is shut down");
@@ -199,6 +193,18 @@ private Endpoints cloud() {
         return this;
     }
 
+    public boolean isLocationRequired() {
+        return requiresCloud;
+    }
+
+    public boolean isRegTokenRequired() {
+        return requiresRegToken;
+    }
+
+    public boolean isSkypeTokenRequired() {
+        return requiresSkypeToken;
+    }
+
     private Endpoints regtoken() {
         this.requiresRegToken = true;
         return this;
@@ -214,223 +220,8 @@ private Endpoints defaultHeader(String key, Provider<String> val) {
         return this;
     }
 
-    public static class EndpointConnection<E_TYPE> {
-        private Class<E_TYPE> clazz = (Class<E_TYPE>) HttpURLConnection.class;
-        private Endpoints endpoint;
-        private SkypeImpl skype;
-        private Object[] args;
-        private Map<String, String> headers = new HashMap<>();
-        private Map<String, String> cookies = new HashMap<>();
-        private Map<Predicate<Integer>, UncheckedFunction<E_TYPE>> errors = new HashMap<>();
-        private URL url;
-        private String cause;
-        private boolean dontConnect;
-        private boolean redirect = true;
-
-        private EndpointConnection(Endpoints endpoint, SkypeImpl skype, Object[] args) {
-            this.endpoint = endpoint;
-            this.skype = skype;
-            this.args = args;
-            header("User-Agent",
-                    "Mozilla/5.0 (Windows NT 10; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36 Skype4J/" + SkypeImpl.VERSION);
-        }
-
-        public EndpointConnection<E_TYPE> header(String key, String val) {
-            this.headers.put(key, val);
-            return this;
-        }
-
-        public EndpointConnection<E_TYPE> cookie(String key, String val) {
-            this.cookies.put(key, val);
-            return this;
-        }
-
-        public EndpointConnection<E_TYPE> cookies(Map<String, String> cookies) {
-            this.cookies.putAll(cookies);
-            return this;
-        }
-
-        public EndpointConnection<E_TYPE> on(int code, UncheckedFunction<E_TYPE> action) {
-            return on(x -> x == code, action);
-        }
-
-        public EndpointConnection<E_TYPE> on(Predicate<Integer> check, UncheckedFunction<E_TYPE> result) {
-            this.errors.put(check, result);
-            return this;
-        }
-
-        public EndpointConnection<E_TYPE> expect(int code, String cause) {
-            return expect(x -> x == code, cause);
-        }
-
-        public EndpointConnection<E_TYPE> expect(Predicate<Integer> check, String cause) {
-            this.cause = cause;
-            return on(check, (connection) -> convert(clazz, skype, connection));
-        }
-
-        public EndpointConnection<E_TYPE> noRedirects() {
-            this.redirect = false;
-            return this;
-        }
-
-        public <NEW_E_TYPE> EndpointConnection<NEW_E_TYPE> as(Class<NEW_E_TYPE> clazz) {
-            this.clazz = (Class<E_TYPE>) clazz;
-            return (EndpointConnection<NEW_E_TYPE>) this;
-        }
-
-        public EndpointConnection<E_TYPE> dontConnect() {
-            this.dontConnect = true;
-            return this;
-        }
-
-        public E_TYPE get() throws ConnectionException {
-            return connect("GET", new byte[0]);
-        }
-
-        public E_TYPE delete() throws ConnectionException {
-            return connect("DELETE", new byte[0]);
-        }
-
-        public E_TYPE post() throws ConnectionException {
-            return connect("POST", new byte[0]);
-        }
-
-        public E_TYPE post(String data) throws ConnectionException {
-            return connect("POST", data);
-        }
-
-        public E_TYPE post(JsonValue json) throws ConnectionException {
-            return header("Content-Type", "application/json").connect("POST", json.toString());
-        }
-
-        public E_TYPE put() throws ConnectionException {
-            return connect("PUT", new byte[0]);
-        }
-
-        public E_TYPE put(String data) throws ConnectionException {
-            return connect("PUT", data);
-        }
-
-        public E_TYPE put(JsonValue json) throws ConnectionException {
-            return header("Content-Type", "application/json").connect("PUT", json.toString());
-        }
-
-        public E_TYPE connect(String method, String data) throws ConnectionException {
-            return this.connect(method, data != null ? data.getBytes(StandardCharsets.UTF_8) : new byte[0]);
-        }
-
-        public E_TYPE connect(String method, byte[] rawData) throws ConnectionException {
-            if (!cookies.isEmpty()) {
-                header("Cookie", serializeCookies(cookies));
-            }
-            if (endpoint.requiresRegToken) {
-                header("RegistrationToken", skype.getRegistrationToken());
-            }
-            if (endpoint.requiresSkypeToken) {
-                header("X-SkypeToken", skype.getSkypeToken());
-            }
-            if (this.redirect) {
-                this.on(code -> (code >= 301 && code <= 303) || code == 307 || code == 308, connection -> {
-                    skype.updateCloud(connection.getHeaderField("Location"));
-                    this.url = new URL(connection.getHeaderField("Location"));
-                    return this.connect(method, rawData);
-                });
-            }
-            for (Map.Entry<String, Provider<String>> provider : endpoint.providers.entrySet()) {
-                header(provider.getKey(), provider.getValue().provide(skype));
-            }
-            HttpURLConnection connection = null;
-            try {
-                if (this.url == null) { //todo could fail if cloud is updated?
-                    String surl = endpoint.url;
-                    if (endpoint.requiresCloud) {
-                        Object[] format = new Object[args.length + 1];
-                        format[0] = skype.getCloud();
-                        for (int i = 1; i < format.length; i++) {
-                            format[i] = args[i - 1].toString();
-                        }
-                        surl = String.format(surl, format);
-                    } else if (args.length > 0) {
-                        Object[] format = new Object[args.length];
-                        for (int i = 0; i < format.length; i++) {
-                            format[i] = args[i].toString();
-                        }
-                        surl = String.format(surl, args);
-                    }
-                    this.url = new URL(surl);
-                }
-                connection = (HttpURLConnection) url.openConnection();
-                connection.setRequestMethod(method);
-                connection.setInstanceFollowRedirects(false);
-                for (Map.Entry<String, String> ent : headers.entrySet()) {
-                    connection.setRequestProperty(ent.getKey(), ent.getValue());
-                }
-                if (!method.equalsIgnoreCase("GET")) {
-                    connection.setDoOutput(true);
-                    if (rawData != null) {
-                        connection.getOutputStream().write(rawData);
-                    } else {
-                        connection.getOutputStream().write(new byte[0]);
-                    }
-                }
-                if (!this.dontConnect) {
-                    if (connection.getHeaderField("Set-RegistrationToken") != null) {
-                        skype.setRegistrationToken(connection.getHeaderField("Set-RegistrationToken"));
-                    }
-                    for (Map.Entry<Predicate<Integer>, UncheckedFunction<E_TYPE>> entry : errors.entrySet()) {
-                        if (entry.getKey().test(connection.getResponseCode())) {
-                            try {
-                                return entry.getValue().apply(connection);
-                            } catch (Throwable t) {
-                                Utils.sneakyThrow(t);
-                            }
-                        }
-                    }
-                    throw ExceptionHandler.generateException(cause == null ? this.url.toString() : cause, connection);
-                } else if (HttpURLConnection.class.isAssignableFrom(clazz)) {
-                    return (E_TYPE) connection;
-                } else {
-                    throw new IllegalArgumentException(
-                            "DontConnect requested but did not request cast to HttpURLConnection");
-                }
-            } catch (IOException e) {
-                throw ExceptionHandler.generateException(cause, e);
-            } finally {
-                if (clazz != InputStream.class && clazz != HttpURLConnection.class) {
-                    if (connection != null) {
-                        connection.disconnect();
-                    }
-                }
-            }
-        }
-
-        private String serializeCookies(Map<String, String> cookies) {
-            StringBuilder result = new StringBuilder();
-            for (Map.Entry<String, String> cookie : cookies.entrySet()) {
-                result.append(Encoder.encode(cookie.getKey())).append("=").append(Encoder.encode(cookie.getValue())).append(";");
-            }
-            return result.toString();
-        }
-    }
-
     public interface Provider<T> {
         T provide(SkypeImpl skype);
     }
 
-    public interface Converter<T> {
-        T convert(HttpURLConnection connection) throws IOException;
-    }
-
-    public interface UncheckedFunction<R> extends Function<HttpURLConnection, R> {
-        default R apply(HttpURLConnection httpURLConnection) {
-            try {
-                return apply0(httpURLConnection);
-            } catch (Throwable t) {
-                Utils.sneakyThrow(t);
-            }
-            return null;
-        }
-
-        R apply0(HttpURLConnection httpURLConnection) throws Throwable;
-    }
 }
diff --git a/src/main/java/com/samczsun/skype4j/internal/EventType.java b/src/main/java/com/samczsun/skype4j/internal/EventType.java
index 42060d9..35fa11a 100644
--- a/src/main/java/com/samczsun/skype4j/internal/EventType.java
+++ b/src/main/java/com/samczsun/skype4j/internal/EventType.java
@@ -43,7 +43,7 @@ public void handle(SkypeImpl skype, JsonObject eventObj) throws SkypeException,
     },
     ENDPOINT_PRESENCE("EndpointPresence") {
         @Override
-        public void handle(SkypeImpl skype, JsonObject eventObj) throws SkypeException {
+        public void handle(SkypeImpl skype, JsonObject eventObj) {
             try {
                 JsonObject resource = eventObj.get("resource").asObject();
 
@@ -80,19 +80,19 @@ public void handle(SkypeImpl skype, JsonObject eventObj) throws SkypeException {
     },
     USER_PRESENCE("UserPresence") {
         @Override
-        public void handle(SkypeImpl skype, JsonObject resource) throws SkypeException {
+        public void handle(SkypeImpl skype, JsonObject resource) {
 
         }
     },
     CONVERSATION_UPDATE("ConversationUpdate") {
         @Override
-        public void handle(SkypeImpl skype, JsonObject resource) throws SkypeException {
+        public void handle(SkypeImpl skype, JsonObject resource) {
 
         }
     },
     THREAD_UPDATE("ThreadUpdate") {
         @Override
-        public void handle(SkypeImpl skype, JsonObject resource) throws SkypeException {
+        public void handle(SkypeImpl skype, JsonObject resource) {
             // User add and leave here 25898
         }
     };
@@ -101,29 +101,30 @@ public void handle(SkypeImpl skype, JsonObject resource) throws SkypeException {
 
 
     private static final Map<String, EventType> byValue = new HashMap<>();
+
+    static {
+        for (EventType type : values()) {
+            byValue.put(type.getValue(), type);
+        }
+    }
+
     private final String value;
 
     EventType(String value) {
         this.value = value;
     }
 
-    public String getValue() {
-        return this.value;
-    }
-
     public static EventType getByName(String eventType) {
         return byValue.get(eventType);
     }
 
-    public abstract void handle(SkypeImpl skype, JsonObject resource) throws SkypeException, IOException;
-
-    static {
-        for (EventType type : values()) {
-            byValue.put(type.getValue(), type);
-        }
-    }
-
     private static IllegalArgumentException conformError(String object) {
         return new IllegalArgumentException(String.format("%s did not conform to format expected", object));
     }
+
+    public String getValue() {
+        return this.value;
+    }
+
+    public abstract void handle(SkypeImpl skype, JsonObject resource) throws SkypeException, IOException;
 }
diff --git a/src/main/java/com/samczsun/skype4j/internal/ExceptionHandler.java b/src/main/java/com/samczsun/skype4j/internal/ExceptionHandler.java
index 41c47cd..d74c484 100644
--- a/src/main/java/com/samczsun/skype4j/internal/ExceptionHandler.java
+++ b/src/main/java/com/samczsun/skype4j/internal/ExceptionHandler.java
@@ -17,86 +17,27 @@
 package com.samczsun.skype4j.internal;
 
 import com.samczsun.skype4j.exceptions.ConnectionException;
-import sun.net.www.MessageHeader;
-import sun.net.www.URLConnection;
-import sun.net.www.http.HttpClient;
-import sun.net.www.protocol.https.HttpsURLConnectionImpl;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.lang.reflect.Field;
 import java.net.HttpURLConnection;
-import java.nio.charset.StandardCharsets;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 public class ExceptionHandler {
-    private static final boolean DEBUG;
-    private static Field POSTER_FIELD;
-    private static Field DELEGATE_FIELD;
-    private static Field REQUESTS_FIELD;
-
-    static {
-        DEBUG = AccessController.doPrivileged((PrivilegedAction<Boolean>) () -> Boolean.getBoolean("com.samczsun.skype4j.debugExceptions"));
-        try {
-            POSTER_FIELD = sun.net.www.protocol.http.HttpURLConnection.class.getDeclaredField("poster");
-            POSTER_FIELD.setAccessible(true);
-        } catch (NoSuchFieldException ignored) {
-        }
-        try {
-            DELEGATE_FIELD = sun.net.www.protocol.https.HttpsURLConnectionImpl.class.getDeclaredField("delegate");
-            DELEGATE_FIELD.setAccessible(true);
-        } catch (NoSuchFieldException ignored) {
-        }
-        try {
-            REQUESTS_FIELD = sun.net.www.protocol.http.HttpURLConnection.class.getDeclaredField("requests");
-            REQUESTS_FIELD.setAccessible(true);
-        } catch (NoSuchFieldException ignored) {
-        }
-    }
+    private static final boolean DEBUG =
+            AccessController.doPrivileged((PrivilegedAction<Boolean>) () ->
+                    Boolean.getBoolean("com.samczsun.skype4j.debugExceptions"));
 
     public static ConnectionException generateException(String reason, HttpURLConnection connection) {
         try {
             if (DEBUG) {
-                Object reflect = connection;
-                if (reflect instanceof HttpsURLConnectionImpl && DELEGATE_FIELD != null) {
-                    try {
-                        reflect = DELEGATE_FIELD.get(reflect);
-                    } catch (ReflectiveOperationException ignored) {
-                    }
-                }
                 System.err.println("URL");
                 System.err.println("\t" + connection.getURL());
-                try {
-                    MessageHeader messageHeader = (MessageHeader) REQUESTS_FIELD.get(reflect);
-                    System.err.println("Request headers");
-                    for (Map.Entry<String, List<String>> header : messageHeader.getHeaders(null).entrySet()) {
-                        System.err.println(String.format("\t%s - %s", header.getKey(), header.getValue()));
-                    }
-                } catch (ReflectiveOperationException ignored) {
-
-                }
-                System.err.println("Response headers");
-                for (Map.Entry<String, List<String>> header : connection.getHeaderFields().entrySet()) {
-                    System.err.println(String.format("\t%s - %s", header.getKey(), header.getValue()));
-                }
-                if (reflect instanceof sun.net.www.protocol.http.HttpURLConnection && POSTER_FIELD != null) {
-                    try {
-                        ByteArrayOutputStream poster = (ByteArrayOutputStream) POSTER_FIELD.get(reflect);
-                        if (poster != null) {
-                            System.err.println("Post data");
-                            System.err.println("\t" + new String(poster.toByteArray()));
-                        }
-                    } catch (ReflectiveOperationException ignored) {
-                    }
-                }
+//                printRequestHeaders(connection);
+                printResponseHeaders(connection);
+                printPostData(connection);
             }
             return new ConnectionException(reason, connection);
         } catch (IOException e) {
@@ -106,6 +47,33 @@ public static ConnectionException generateException(String reason, HttpURLConnec
         }
     }
 
+    private static void printPostData(HttpURLConnection connection) {
+
+        System.err.println("Post data");
+        try {
+            System.err.println("\t" + connection.getOutputStream());
+        } catch (IOException ignored) {
+
+        }
+    }
+
+    private static void printResponseHeaders(HttpURLConnection connection) {
+        System.err.println("Response headers");
+        for (Map.Entry<String, List<String>> header : connection.getHeaderFields().entrySet()) {
+            System.err.println(String.format("\t%s - %s", header.getKey(), header.getValue()));
+        }
+    }
+
+    private static void printRequestHeaders(HttpURLConnection connection) {
+        for (String header : connection.getRequestProperties().keySet()) {
+            if (header != null) {
+                for (String value : connection.getRequestProperties().get(header)) {
+                    System.out.println(header + ":" + value);
+                }
+            }
+        }
+    }
+
     public static ConnectionException generateException(String reason, IOException nested) {
         return new ConnectionException(reason, nested);
     }
diff --git a/src/main/java/com/samczsun/skype4j/internal/Factory.java b/src/main/java/com/samczsun/skype4j/internal/Factory.java
index 4483e31..87c28f4 100644
--- a/src/main/java/com/samczsun/skype4j/internal/Factory.java
+++ b/src/main/java/com/samczsun/skype4j/internal/Factory.java
@@ -17,11 +17,9 @@
 package com.samczsun.skype4j.internal;
 
 import com.samczsun.skype4j.chat.Chat;
-import com.samczsun.skype4j.chat.messages.ChatMessage;
 import com.samczsun.skype4j.exceptions.ChatNotFoundException;
 import com.samczsun.skype4j.exceptions.ConnectionException;
 import com.samczsun.skype4j.formatting.Message;
-import com.samczsun.skype4j.internal.SkypeImpl;
 import com.samczsun.skype4j.internal.chat.*;
 import com.samczsun.skype4j.internal.chat.messages.ChatMessageImpl;
 import com.samczsun.skype4j.internal.chat.messages.ReceivedMessageImpl;
@@ -29,7 +27,6 @@
 import com.samczsun.skype4j.internal.participants.BotImpl;
 import com.samczsun.skype4j.internal.participants.ParticipantImpl;
 import com.samczsun.skype4j.internal.participants.UserImpl;
-import com.samczsun.skype4j.participants.Participant;
 import org.jsoup.helper.Validate;
 
 public class Factory {
@@ -80,7 +77,7 @@ public static ParticipantImpl createParticipant(SkypeImpl client, ChatImpl chat,
         throw new IllegalArgumentException(String.format("Unknown participant type with id %s", id));
     }
 
-    public static ChatMessageImpl createMessage(Chat chat, ParticipantImpl user, String id, String clientId, long time, Message message, SkypeImpl skype) throws ConnectionException {
+    public static ChatMessageImpl createMessage(Chat chat, ParticipantImpl user, String id, String clientId, long time, Message message, SkypeImpl skype) {
         Validate.notNull(chat, "Chat must not be null");
         Validate.isTrue(chat instanceof ChatImpl, "Chat must be instanceof ChatImpl");
         Validate.notNull(user, "User must not be null");
diff --git a/src/main/java/com/samczsun/skype4j/internal/MessageType.java b/src/main/java/com/samczsun/skype4j/internal/MessageType.java
index 864b719..8004625 100644
--- a/src/main/java/com/samczsun/skype4j/internal/MessageType.java
+++ b/src/main/java/com/samczsun/skype4j/internal/MessageType.java
@@ -25,16 +25,15 @@
 import com.samczsun.skype4j.chat.objects.ReceivedFile;
 import com.samczsun.skype4j.events.UnsupportedEvent;
 import com.samczsun.skype4j.events.chat.ChatJoinedEvent;
-import com.samczsun.skype4j.events.chat.participant.action.ModeratedUpdateEvent;
 import com.samczsun.skype4j.events.chat.ChatQuitEvent;
 import com.samczsun.skype4j.events.chat.call.CallReceivedEvent;
 import com.samczsun.skype4j.events.chat.message.*;
+import com.samczsun.skype4j.events.chat.participant.LegacyMemberAddedEvent;
+import com.samczsun.skype4j.events.chat.participant.LegacyMemberUpgradedEvent;
+import com.samczsun.skype4j.events.chat.participant.ParticipantAddedEvent;
+import com.samczsun.skype4j.events.chat.participant.ParticipantRemovedEvent;
+import com.samczsun.skype4j.events.chat.participant.action.*;
 import com.samczsun.skype4j.events.chat.sent.*;
-import com.samczsun.skype4j.events.chat.participant.*;
-import com.samczsun.skype4j.events.chat.participant.action.OptionUpdateEvent;
-import com.samczsun.skype4j.events.chat.participant.action.PictureUpdateEvent;
-import com.samczsun.skype4j.events.chat.participant.action.RoleUpdateEvent;
-import com.samczsun.skype4j.events.chat.participant.action.TopicUpdateEvent;
 import com.samczsun.skype4j.exceptions.ChatNotFoundException;
 import com.samczsun.skype4j.exceptions.ConnectionException;
 import com.samczsun.skype4j.exceptions.NoSuchUserException;
@@ -58,8 +57,12 @@
 
 import java.awt.image.BufferedImage;
 import java.io.IOException;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 import java.util.logging.Level;
+import java.util.logging.Logger;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
@@ -68,6 +71,8 @@
     UNKNOWN("Unknown") {
         @Override
         public void handle(SkypeImpl skype, JsonObject resource) {
+            Logger.getLogger("MessageType").log(Level.INFO, resource.asString());
+            System.out.println(resource);
             skype.getEventDispatcher().callEvent(new UnsupportedEvent(name(), resource.toString()));
             throw new IllegalArgumentException("Unknown type!");
         }
@@ -174,7 +179,7 @@ public void handle(final SkypeImpl skype, JsonObject resource) throws SkypeExcep
     },
     RICH_TEXT_CONTACTS("RichText/Contacts") {
         @Override
-        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException, IOException {
+        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException {
             String content = Utils.getString(resource, "content");
             String chatId = Utils.getString(resource, "conversationLink");
             String author = getAuthor(resource);
@@ -212,7 +217,7 @@ public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionExcept
     },
     RICH_TEXT_FILES("RichText/Files") {
         @Override
-        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException, IOException {
+        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException {
             String content = Utils.getString(resource, "content");
             String chatId = Utils.getString(resource, "conversationLink");
             String author = getAuthor(resource);
@@ -240,7 +245,7 @@ public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionExcept
     },
     RICH_TEXT_SMS("RichText/Sms") {
         @Override
-        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException, IOException { //Implemented via fullExperience
+        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException { //Implemented via fullExperience
             String content = resource.get("content").asString();
             String from = resource.get("from").asString();
             String url = resource.get("conversationLink").asString();
@@ -260,7 +265,7 @@ public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionExcept
     },
     RICH_TEXT_LOCATION("RichText/Location") {
         @Override
-        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException, IOException { //Implemented via fullExperience
+        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException { //Implemented via fullExperience
             String content = resource.get("content").asString();
             ChatImpl c = getChat(resource.get("conversationLink").asString(), skype);
             Participant u = getUser(resource.get("from").asString(), c);
@@ -277,7 +282,7 @@ public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionExcept
     },
     RICH_TEXT_URI_OBJECT("RichText/UriObject") {
         @Override
-        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException, IOException {
+        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException {
             String from = resource.get("from").asString();
             String url = resource.get("conversationLink").asString();
             ChatImpl c = getChat(url, skype);
@@ -301,7 +306,7 @@ public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionExcept
                         .cookies(skype.getCookies())
                         .expect(200, "While getting URI object")
                         .get();
-                Endpoints.EndpointConnection<JsonObject> econn = Endpoints
+                EndpointConnection<JsonObject> econn = Endpoints
                         .custom(obj.get("status_location").asString(), skype)
                         .as(JsonObject.class)
                         .expect(200, "While getting URI object")
@@ -341,7 +346,7 @@ public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionExcept
     },
     EVENT_SKYPE_VIDEO_MESSAGE("Event/SkypeVideoMessage") {
         @Override
-        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, IOException, ChatNotFoundException {
+        public void handle(SkypeImpl skype, JsonObject resource) {
 //            ChatImpl chat = getChat(resource, skype);
 //            UserImpl sender = getSender(resource, chat);
 //            String content = Utils.getString(resource, "content");
@@ -525,7 +530,7 @@ public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionExcept
     },
     THREAD_ACTIVITY_LEGACY_MEMBER_ADDED("ThreadActivity/LegacyMemberAdded") {
         @Override
-        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, IOException, ChatNotFoundException {
+        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException {
             String content = Utils.getString(resource, "content");
             String chatId = Utils.getString(resource, "conversationLink");
             if (content == null) {
@@ -548,7 +553,7 @@ public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionExcept
     },
     THREAD_ACTIVITY_LEGACY_MEMBER_UPGRADED("ThreadActivity/LegacyMemberUpgraded") {
         @Override
-        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, IOException, ChatNotFoundException {
+        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException {
             String content = Utils.getString(resource, "content");
             String chatId = Utils.getString(resource, "conversationLink");
             if (content == null) {
@@ -571,7 +576,7 @@ public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionExcept
     },
     EVENT_CALL("Event/Call") {
         @Override
-        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException, IOException {
+        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException {
             String from = resource.get("from").asString();
             String url = resource.get("conversationLink").asString();
             String content = resource.get("content").asString();
@@ -586,7 +591,7 @@ public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionExcept
     },
     CONTROL_TYPING("Control/Typing") {
         @Override
-        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException, IOException {
+        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException {
             String from = resource.get("from").asString();
             String url = resource.get("conversationLink").asString();
 
@@ -598,7 +603,7 @@ public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionExcept
     },
     CONTROL_CLEAR_TYPING("Control/ClearTyping") {
         @Override
-        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException, IOException {
+        public void handle(SkypeImpl skype, JsonObject resource) throws ConnectionException, ChatNotFoundException {
             ChatImpl c = getChat(resource.get("conversationLink").asString(), skype);
             Participant u = getUser(resource.get("from").asString(), c);
             TypingReceivedEvent event = new TypingReceivedEvent(c, u, false);
@@ -617,7 +622,7 @@ public void handle(SkypeImpl skype, JsonObject resource) { //No plans to impleme
     // lol this one's not even implemented by Skype Web yet
     THREAD_ACTIVITY_MODERATED_THREAD_UPDATE("ThreadActivity/ModeratedThreadUpdate") {
         @Override
-        public void handle(SkypeImpl skype, JsonObject resource) throws SkypeException, IOException {
+        public void handle(SkypeImpl skype, JsonObject resource) throws SkypeException {
             String from = resource.get("from").asString();
             String url = resource.get("conversationLink").asString();
 
@@ -636,86 +641,51 @@ public void handle(SkypeImpl skype, JsonObject resource) throws SkypeException,
     };
 
     private static final Map<String, Pattern> METADATA = new HashMap<>();
-
-    static {
-        METADATA.put("text", Pattern.compile("Edited previous message: "));
-        METADATA.put("edited", Pattern.compile("</?[e_m][^<>]+>"));
-        METADATA.put("quoted", Pattern.compile("(<(?:/?)(?:quote|legacyquote)[^>]*>)", Pattern.CASE_INSENSITIVE));
-    }
-
     private static final Pattern NAME = Pattern.compile("/((?:\\d+:|live:)[^/]+)");
     private static final Pattern USERNAME = Pattern.compile("^((\\d+):)+");
     private static final Pattern SINGLE_TARGET = Pattern.compile("<target>(\\d+:[^<]+)</target>");
-    private static final Pattern VIDEOMESSAGE = Pattern.compile("<videomessage[^>]*?\\ssid=\"([a-f0-9]{32})\"",
-            Pattern.CASE_INSENSITIVE);
-    private static final Pattern URIOBJECT = Pattern.compile("<URIObject[^>]*?\\stype=\"([^\"]+?)\"",
-            Pattern.CASE_INSENSITIVE);
-    private static final Pattern URIOBJECT_URI = Pattern.compile("<URIObject[^>]*?\\suri=\"([^\"]+?)\"",
-            Pattern.CASE_INSENSITIVE);
+    private static final Pattern VIDEOMESSAGE = Pattern.compile("<videomessage[^>]*?\\ssid=\"([a-f0-9]{32})\"", Pattern.CASE_INSENSITIVE);
+    private static final Pattern URIOBJECT = Pattern.compile("<URIObject[^>]*?\\stype=\"([^\"]+?)\"", Pattern.CASE_INSENSITIVE);
+    private static final Pattern URIOBJECT_URI = Pattern.compile("<URIObject[^>]*?\\suri=\"([^\"]+?)\"", Pattern.CASE_INSENSITIVE);
     private static final Pattern CONVERSATION = Pattern.compile("/(\\d+:[^?]*)");
     private static final Pattern INITIATOR = Pattern.compile("<initiator>(\\d+:.+)</initiator>");
-
     private static final Map<String, MessageType> byValue = new HashMap<>();
-    private static final Pattern USER_PATTERN = Pattern.compile("8:(.*)", Pattern.CASE_INSENSITIVE);
+    private static final Pattern USER_PATTERN = Pattern.compile("[2,8]:(.*)", Pattern.CASE_INSENSITIVE);
     private static final Pattern STRIP_EDIT_PATTERN = Pattern.compile("</?[e_m][^<>]+>", Pattern.CASE_INSENSITIVE);
-    private static final Pattern STRIP_QUOTE_PATTERN = Pattern.compile("(<(?:/?)(?:quote|legacyquote)[^>]*>)",
-            Pattern.CASE_INSENSITIVE);
-    private static final Pattern STRIP_EMOTICON_PATTERN = Pattern.compile("(<(?:/?)(?:ss)[^>]*>)",
-            Pattern.CASE_INSENSITIVE);
-    private static final Pattern CONTACT_PATTERN = Pattern.compile(
-            "(<c t=\"([^\"]+?)\"( p=\"([^\"]+?)\")?( s=\"([^\"]+?)\")?( f=\"([^\"]+?)\")?/>)",
-            Pattern.CASE_INSENSITIVE);
+    private static final Pattern STRIP_QUOTE_PATTERN = Pattern.compile("(<(?:/?)(?:quote|legacyquote)[^>]*>)", Pattern.CASE_INSENSITIVE);
+    private static final Pattern STRIP_EMOTICON_PATTERN = Pattern.compile("(<(?:/?)(?:ss)[^>]*>)", Pattern.CASE_INSENSITIVE);
+    private static final Pattern CONTACT_PATTERN = Pattern.compile("(<c t=\"([^\"]+?)\"( p=\"([^\"]+?)\")?( s=\"([^\"]+?)\")?( f=\"([^\"]+?)\")?/>)", Pattern.CASE_INSENSITIVE);
     private static final Pattern SMS_PATTERN = Pattern.compile("<sms alt=\"([^\"]+?)\">", Pattern.CASE_INSENSITIVE);
-    private static final Pattern LOCATION_PATTERN = Pattern.compile(
-            "<a[^>]+href=\"https://www.bing.com/maps([^\"]+)\"[^>]*>([^<]*)", Pattern.CASE_INSENSITIVE);
-    private static final Pattern EVENTTIME_PATTERN = Pattern.compile("<eventtime>(\\d+)</eventtime>",
-            Pattern.CASE_INSENSITIVE);
-    private static final Pattern VALUE_PATTERN = Pattern.compile("(?:<value>(.+)</value>|<value />)",
-            Pattern.CASE_INSENSITIVE);
-    private static final Pattern ROLE_UPDATE_PATTERN = Pattern.compile(
-            "<target><id>(\\d+:.+)</id><role>(.+)</role></target>", Pattern.CASE_INSENSITIVE);
-    private static final Pattern BLOBID = Pattern.compile("(0-[a-z]+-d[0-9]-[a-z0-9]{32})");
-
-    private static final Pattern VALUE_BOOLEAN =
-            Pattern.compile("<value>(true|false)</value>");
-
-    private final String value;
+    private static final Pattern LOCATION_PATTERN = Pattern.compile("<a[^>]+href=\"https://www.bing.com/maps([^\"]+)\"[^>]*>([^<]*)", Pattern.CASE_INSENSITIVE);
+    private static final Pattern EVENTTIME_PATTERN = Pattern.compile("<eventtime>(\\d+)</eventtime>", Pattern.CASE_INSENSITIVE);
+    private static final Pattern VALUE_PATTERN = Pattern.compile("(?:<value>(.+)</value>|<value />)", Pattern.CASE_INSENSITIVE);
+    private static final Pattern ROLE_UPDATE_PATTERN = Pattern.compile("<target><id>(\\d+:.+)</id><role>(.+)</role></target>", Pattern.CASE_INSENSITIVE);
+    private static final Pattern BLOBID = Pattern.compile("(0-[a-z]+-d[0-9]{1,2}-[a-z0-9]{32})");
+    private static final Pattern VALUE_BOOLEAN = Pattern.compile("<value>(true|false)</value>");
 
-    MessageType(String value) {
-        this.value = value;
-    }
-
-    public String getValue() {
-        return this.value;
+    static {
+        METADATA.put("text", Pattern.compile("Edited previous message: "));
+        METADATA.put("edited", Pattern.compile("</?[e_m][^<>]+>"));
+        METADATA.put("quoted", Pattern.compile("(<(?:/?)(?:quote|legacyquote)[^>]*>)", Pattern.CASE_INSENSITIVE));
     }
 
-    public abstract void handle(SkypeImpl skype, JsonObject resource) throws SkypeException, IOException;
-
     static {
         for (MessageType type : values()) {
             byValue.put(type.getValue(), type);
         }
     }
 
-    public static MessageType getByName(String messageType) {
-        return byValue.getOrDefault(messageType, MessageType.UNKNOWN);
-    }
+    private final String value;
 
-    public ChatImpl getChat(JsonObject resource, SkypeImpl skype) throws ConnectionException, IOException, ChatNotFoundException {
-        String chatId = Utils.getString(resource, "conversationLink");
-        if (chatId == null) {
-            throw new IllegalArgumentException("Null chat");
-        }
-        return getChat(chatId, skype);
+    MessageType(String value) {
+        this.value = value;
     }
 
-    public ParticipantImpl getSender(JsonObject resource, ChatImpl chat) {
-        String author = getAuthor(resource);
-        String username = author; //getUsername(author);
-        return chat.getParticipant(username);
+    public static MessageType getByName(String messageType) {
+        return byValue.getOrDefault(messageType, MessageType.UNKNOWN);
     }
 
-    public static ChatImpl getChat(String url, SkypeImpl skype) throws ConnectionException, ChatNotFoundException, IOException {
+    public static ChatImpl getChat(String url, SkypeImpl skype) throws ConnectionException, ChatNotFoundException {
         Matcher m = CONVERSATION.matcher(url);
         if (m.find()) {
             return skype.getOrLoadChat(m.group(1));
@@ -758,7 +728,6 @@ private static UserImpl getInitiator(JsonObject resource, ChatImpl chat) {
         throw new IllegalArgumentException("Malformatted content");
     }
 
-
     private static IllegalArgumentException conformError(String object) {
         return new IllegalArgumentException(String.format("%s did not conform to format expected", object));
     }
@@ -770,4 +739,24 @@ public static String stripMetadata(String content) {
         }
         return content;
     }
+
+    public String getValue() {
+        return this.value;
+    }
+
+    public abstract void handle(SkypeImpl skype, JsonObject resource) throws SkypeException, IOException;
+
+    public ChatImpl getChat(JsonObject resource, SkypeImpl skype) throws ConnectionException, ChatNotFoundException {
+        String chatId = Utils.getString(resource, "conversationLink");
+        if (chatId == null) {
+            throw new IllegalArgumentException("Null chat");
+        }
+        return getChat(chatId, skype);
+    }
+
+    public ParticipantImpl getSender(JsonObject resource, ChatImpl chat) {
+        String author = getAuthor(resource);
+        String username = author; //getUsername(author);
+        return chat.getParticipant(username);
+    }
 }
diff --git a/src/main/java/com/samczsun/skype4j/internal/SkypeEventDispatcher.java b/src/main/java/com/samczsun/skype4j/internal/SkypeEventDispatcher.java
index 493adee..8296cb8 100644
--- a/src/main/java/com/samczsun/skype4j/internal/SkypeEventDispatcher.java
+++ b/src/main/java/com/samczsun/skype4j/internal/SkypeEventDispatcher.java
@@ -28,14 +28,13 @@
 import java.util.logging.Level;
 
 public class SkypeEventDispatcher implements EventDispatcher {
+    private final Map<Class<?>, List<RegisteredListener>> listeners = Collections.synchronizedMap(new HashMap<>());
     private Skype instance;
 
     public SkypeEventDispatcher(Skype instance) {
         this.instance = instance;
     }
 
-    private final Map<Class<?>, List<RegisteredListener>> listeners = Collections.synchronizedMap(new HashMap<>());
-
     public void registerListener(Listener l) {
         Class<?> c = l.getClass();
         for (Method m : c.getMethods()) {
diff --git a/src/main/java/com/samczsun/skype4j/internal/SkypeImpl.java b/src/main/java/com/samczsun/skype4j/internal/SkypeImpl.java
index df1a2cc..73dd515 100644
--- a/src/main/java/com/samczsun/skype4j/internal/SkypeImpl.java
+++ b/src/main/java/com/samczsun/skype4j/internal/SkypeImpl.java
@@ -24,13 +24,17 @@
 import com.samczsun.skype4j.chat.Chat;
 import com.samczsun.skype4j.chat.GroupChat;
 import com.samczsun.skype4j.events.EventDispatcher;
-import com.samczsun.skype4j.exceptions.*;
+import com.samczsun.skype4j.exceptions.ChatNotFoundException;
+import com.samczsun.skype4j.exceptions.ConnectionException;
+import com.samczsun.skype4j.exceptions.NoPermissionException;
+import com.samczsun.skype4j.exceptions.SkypeAuthenticationException;
 import com.samczsun.skype4j.exceptions.handler.ErrorHandler;
 import com.samczsun.skype4j.exceptions.handler.ErrorSource;
 import com.samczsun.skype4j.internal.chat.ChatImpl;
+import com.samczsun.skype4j.internal.client.auth.SkypeAuthProvider;
+import com.samczsun.skype4j.internal.client.auth.SkypeRegistrationProvider;
 import com.samczsun.skype4j.internal.participants.info.BotInfoImpl;
 import com.samczsun.skype4j.internal.participants.info.ContactImpl;
-import com.samczsun.skype4j.internal.threads.ActiveThread;
 import com.samczsun.skype4j.internal.threads.AuthenticationChecker;
 import com.samczsun.skype4j.internal.threads.PollThread;
 import com.samczsun.skype4j.internal.threads.ServerPingThread;
@@ -44,9 +48,10 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URLEncoder;
-import java.nio.charset.StandardCharsets;
 import java.security.KeyManagementException;
 import java.security.NoSuchAlgorithmException;
+import java.text.MessageFormat;
+import java.time.Instant;
 import java.util.*;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -57,47 +62,37 @@
 import java.util.regex.Pattern;
 
 public abstract class SkypeImpl implements Skype {
-    public static final String LINE_SEPARATOR = System.getProperty("line.separator");
     public static final Pattern PAGE_SIZE_PATTERN = Pattern.compile("pageSize=([0-9]+)");
-    public static final String VERSION = "0.2.0-SNAPSHOT";
-
+    static final String VERSION = "0.2.9-SNAPSHOT";
+    private static final String LINE_SEPARATOR = System.getProperty("line.separator");
     protected final AtomicBoolean loggedIn = new AtomicBoolean(false);
-    protected final AtomicBoolean shutdownRequested = new AtomicBoolean(false);
-    protected final AtomicBoolean subscribed = new AtomicBoolean(false);
-
-    protected final UUID guid = UUID.randomUUID();
-    protected final Set<String> resources;
-    protected final List<ErrorHandler> errorHandlers;
-    private final String username;
-    protected ExecutorService scheduler;
-    protected ExecutorService shutdownThread;
-    protected EventDispatcher eventDispatcher = new SkypeEventDispatcher(this);
+    protected final Map<String, Contact> allContacts = Collections.synchronizedMap(new HashMap<>());
+    protected final Set<Contact.ContactRequest> allContactRequests = Collections.synchronizedSet(new HashSet<>());
+    private final AtomicBoolean shutdownRequested = new AtomicBoolean(false);
+    private final AtomicBoolean subscribed = new AtomicBoolean(false);
+    private final UUID guid = UUID.randomUUID();
+    private final Set<String> resources;
+    private final List<ErrorHandler> errorHandlers;
+    // Data
+    private final Map<String, ChatImpl> allChats = Collections.synchronizedMap(new HashMap<>());
+    private final Map<String, BotInfoImpl> allBots = Collections.synchronizedMap(new HashMap<>());
+    private final SkypeRegistrationProvider regTokenProvider;
     protected Map<String, String> cookies = new HashMap<>();
-    protected ServerPingThread serverPingThread;
-    protected ActiveThread activeThread;
-    protected AuthenticationChecker reauthThread;
-    protected PollThread pollThread;
-    protected SkypeWebSocket wss;
-    protected String conversationBackwardLink;
-    protected String conversationSyncState;
     protected Logger logger = Logger.getLogger(Skype.class.getCanonicalName());
-    private String skypeToken;
-    private long skypeTokenExpiryTime;
-    private String registrationToken;
-    private long registrationTokenExpiryTime;
+    private ExecutorService scheduler;
+    private ExecutorService shutdownThread;
+    private EventDispatcher eventDispatcher = new SkypeEventDispatcher(this);
+    private ServerPingThread serverPingThread;
+    private AuthenticationChecker reauthThread;
+    private PollThread pollThread;
+    private SkypeWebSocket wss;
+    private String conversationSyncState;
     private String cloud = "";
-    private String endpointId;
     private JsonObject trouterData;
     private int socketId = 1;
 
-    // Data
-    protected final Map<String, ChatImpl> allChats = Collections.synchronizedMap(new HashMap<>());
-    protected final Map<String, Contact> allContacts = Collections.synchronizedMap(new HashMap<>());
-    protected final Map<String, BotInfoImpl> allBots = Collections.synchronizedMap(new HashMap<>());
-    protected final Set<Contact.ContactRequest> allContactRequests = Collections.synchronizedSet(new HashSet<>());
-
-    public SkypeImpl(String username, Set<String> resources, Logger logger, List<ErrorHandler> errorHandlers) {
-        this.username = username;
+    public SkypeImpl(Set<String> resources, Logger logger, List<ErrorHandler> errorHandlers) {
+        this.regTokenProvider = new SkypeRegistrationProvider();
         this.resources = Collections.unmodifiableSet(new HashSet<>(resources));
         this.errorHandlers = Collections.unmodifiableList(new ArrayList<>(errorHandlers));
         if (logger != null) {
@@ -127,13 +122,19 @@ public String format(LogRecord record) {
         }
     }
 
+    public SkypeRegistrationProvider getRegTokenProvider() {
+        return regTokenProvider;
+    }
+
+    protected abstract SkypeAuthProvider getAuthProvider();
+
     @Override
-    public void login() throws ConnectionException, InvalidCredentialsException {
+    public void login() throws ConnectionException, SkypeAuthenticationException {
         Endpoints.ELIGIBILITY_CHECK.open(this)
                 .expect(200, "You are not eligible to use Skype for Web!")
                 .get();
 
-        this.loggedIn.set(true);
+        this.loggedIn.compareAndSet(false, true);
         if (this.serverPingThread != null) {
             this.serverPingThread.kill();
             this.serverPingThread = null;
@@ -142,8 +143,9 @@ public void login() throws ConnectionException, InvalidCredentialsException {
             this.reauthThread.kill();
             this.reauthThread = null;
         }
-        if (scheduler != null) {
+        if (scheduler != null && !scheduler.isTerminated()) {
             scheduler.shutdownNow();
+            //TODO this looks fishy, find alternative
             while (!scheduler.isTerminated()) ;
         }
         shutdownThread = Executors.newSingleThreadExecutor(new SkypeThreadFactory(this, "Shutdown"));
@@ -155,20 +157,15 @@ public void login() throws ConnectionException, InvalidCredentialsException {
     public List<Chat> loadMoreChats(int amount) throws ConnectionException {
         try {
             JsonObject data;
-            if (this.conversationBackwardLink == null) {
-                if (this.conversationSyncState == null) {
-                    InputStream input = Endpoints.LOAD_CHATS
-                            .open(this, System.currentTimeMillis(), amount)
-                            .as(InputStream.class)
-                            .expect(200, "While loading chats")
-                            .get();
-                    data = Utils.parseJsonObject(input);
-                } else {
-                    return Collections.emptyList();
-                }
+            if (this.conversationSyncState == null) {
+                InputStream input = Endpoints.LOAD_CHATS
+                        .open(this, System.currentTimeMillis(), amount)
+                        .as(InputStream.class)
+                        .expect(200, "While loading chats")
+                        .get();
+                data = Utils.parseJsonObject(input);
             } else {
-                Matcher matcher = PAGE_SIZE_PATTERN.matcher(this.conversationBackwardLink);
-                matcher.find();
+                Matcher matcher = PAGE_SIZE_PATTERN.matcher(this.conversationSyncState);
                 String url = matcher.replaceAll("pageSize=" + amount);
                 data = Endpoints
                         .custom(url, this)
@@ -191,19 +188,16 @@ public void login() throws ConnectionException, InvalidCredentialsException {
             }
 
             JsonObject metadata = data.get("_metadata").asObject();
-            if (metadata.get("backwardLink") != null) {
-                this.conversationBackwardLink = metadata.get("backwardLink").asString();
-            } else {
-                this.conversationBackwardLink = null;
+            if (metadata.get("syncState") != null) {
+                this.conversationSyncState = metadata.get("syncState").asString();
             }
-            this.conversationSyncState = metadata.get("syncState").asString();
             return chats;
         } catch (IOException e) {
             throw ExceptionHandler.generateException("While loading chats", e);
         }
     }
 
-    protected JsonObject buildSubscriptionObject() {
+    private JsonObject buildSubscriptionObject() {
         JsonObject subscriptionObject = new JsonObject();
         subscriptionObject.add("channelType", "httpLongPoll");
         subscriptionObject.add("template", "raw");
@@ -213,24 +207,6 @@ protected JsonObject buildSubscriptionObject() {
         return subscriptionObject;
     }
 
-    protected JsonObject buildRegistrationObject() {
-        JsonObject registrationObject = new JsonObject();
-        registrationObject.add("id", "messagingService");
-        registrationObject.add("type", "EndpointPresenceDoc");
-        registrationObject.add("selfLink", "uri");
-        JsonObject publicInfo = new JsonObject();
-        publicInfo.add("capabilities", "video|audio");
-        publicInfo.add("type", 1);
-        publicInfo.add("skypeNameVersion", "skype.com");
-        publicInfo.add("nodeInfo", "");
-        publicInfo.add("version", Skype.VERSION);
-        JsonObject privateInfo = new JsonObject();
-        privateInfo.add("epname", "Skype4J");
-        registrationObject.add("publicInfo", publicInfo);
-        registrationObject.add("privateInfo", privateInfo);
-        return registrationObject;
-    }
-
     public void shutdown() {
         if (this.loggedIn.get()) {
             loggedIn.set(false);
@@ -239,13 +215,14 @@ public void shutdown() {
                 shutdownThread.shutdown();
                 reauthThread.kill();
                 scheduler.shutdownNow();
+                //TODO this looks fishy, find alternative
                 while (!scheduler.isTerminated()) ;
                 doShutdown();
             });
         }
     }
 
-    public void doShutdown() {
+    private void doShutdown() {
         if (this.pollThread != null) {
             this.pollThread.shutdown();
             this.pollThread = null;
@@ -254,10 +231,6 @@ public void doShutdown() {
             this.serverPingThread.kill();
             this.serverPingThread = null;
         }
-        if (this.activeThread != null) {
-            this.activeThread.kill();
-            this.activeThread = null;
-        }
         if (this.reauthThread != null) {
             this.reauthThread.kill();
             this.reauthThread = null;
@@ -267,9 +240,14 @@ public void doShutdown() {
             this.wss = null;
         }
 
+        if (scheduler != null && !scheduler.isTerminated()) {
+            scheduler.shutdownNow();
+            //TODO this looks fishy, find alternative
+            while (!scheduler.isTerminated()) ;
+        }
     }
 
-    protected void updateCloud(String anyLocation) {
+    public void updateCloud(String anyLocation) {
         Pattern grabber = Pattern.compile("https?://([^-]*-)client-s");
         Matcher m = grabber.matcher(anyLocation);
         if (m.find()) {
@@ -303,7 +281,7 @@ public ChatImpl getOrLoadChat(String name) throws ConnectionException, ChatNotFo
     }
 
     @Override
-    public GroupChat joinChat(String id) throws ConnectionException, ChatNotFoundException, NoPermissionException {
+    public GroupChat joinChat(String id) throws ConnectionException, ChatNotFoundException {
         Validate.isTrue(id.startsWith("19:") && id.endsWith("@thread.skype"), "Invalid chat id");
         JsonObject obj = new JsonObject();
         obj.add("role", "User");
@@ -352,26 +330,11 @@ public BotInfo getOrLoadBotInfo(String botId) throws ConnectionException {
         return botInfo;
     }
 
-    protected void registerEndpoint() throws ConnectionException {
-        Endpoints.ENDPOINTS_URL
-                .open(this)
-                .noRedirects()
-                .on(301, (connection) -> Endpoints
-                        .custom(Endpoints.ENDPOINTS_URL.url() + "/" + Encoder.encode(endpointId), SkypeImpl.this)
-                        .expect(200, "While registering endpoint")
-                        .header("Authentication", "skypetoken=" + skypeToken)
-                        .header("LockAndKey", Utils.generateChallengeHeader())
-                        .put(new JsonObject().add("endpointFeatures", "Agent")))
-                .expect(201, "While registering endpoint")
-                .header("Authentication", "skypetoken=" + skypeToken)
-                .post(new JsonObject().add("endpointFeatures", "Agent"));
-    }
-
-    public abstract void getContactRequests(boolean fromWebsocket) throws ConnectionException;
+    public abstract void getContactRequests() throws ConnectionException;
 
     public abstract void updateContactList() throws ConnectionException;
 
-    public void registerWebSocket() throws ConnectionException, InterruptedException, URISyntaxException, KeyManagementException, NoSuchAlgorithmException, UnsupportedEncodingException {
+    void registerWebSocket() throws ConnectionException, InterruptedException, URISyntaxException, KeyManagementException, NoSuchAlgorithmException, UnsupportedEncodingException {
         boolean needsToRegister = false;
         if (trouterData == null) {
             trouterData = Endpoints.TROUTER_URL
@@ -402,7 +365,7 @@ public void registerWebSocket() throws ConnectionException, InterruptedException
         data.put("ccid", Utils.coerceToString(trouterData.get("ccid")));
         data.put("v", "v2"); //TODO: MAGIC VALUE
         data.put("dom", "web.skype.com"); //TODO: MAGIC VALUE
-        data.put("auth", "true"); //TODO: MAGIC VALUE
+        data.put("refreshToken", "true"); //TODO: MAGIC VALUE
         data.put("tc", new JsonObject()
                 .add("cv", "2015.11.05")
                 .add("hr", "")
@@ -467,11 +430,11 @@ public void subscribe() throws ConnectionException {
                     .post(buildSubscriptionObject());
             if (connection.getResponseCode() == 404) {
                 if (connection.getHeaderField("Set-RegistrationToken") != null) {
-                    setRegistrationToken(connection.getHeaderField("Set-RegistrationToken"));
+                    getRegTokenProvider().setRegistrationToken(connection.getHeaderField("Set-RegistrationToken"));
                 }
                 Endpoints
                         .custom("https://" + this.getCloud() + "client-s.gateway.messenger.live.com/v1/users/ME/endpoints/" + Encoder
-                                .encode(endpointId), this)
+                                .encode(getRegTokenProvider().getEndpointId()), this)
                         .header("RegistrationToken", getRegistrationToken())
                         .expect(200, "Err")
                         .put(new JsonObject().add("endpointFeatures", "Agent"));
@@ -481,14 +444,14 @@ public void subscribe() throws ConnectionException {
                 throw ExceptionHandler.generateException("While subscribing", connection);
             }
             Endpoints.MESSAGINGSERVICE_URL
-                    .open(this, Encoder.encode(endpointId))
+                    .open(this, Encoder.encode(getRegTokenProvider().getEndpointId()))
                     .expect(200, "While submitting messagingservice")
-                    .put(buildRegistrationObject());
+                    .put(getRegTokenProvider().getRegistrationObject());
             if (this.pollThread != null) {
                 this.pollThread.shutdown();
                 this.pollThread = null;
             }
-            (pollThread = new PollThread(this, Encoder.encode(endpointId))).start();
+            (pollThread = new PollThread(this, Encoder.encode(getRegTokenProvider().getEndpointId()))).start();
             subscribed.set(true);
         } catch (IOException io) {
             throw ExceptionHandler.generateException("While subscribing", io);
@@ -499,46 +462,26 @@ public void subscribe() throws ConnectionException {
         }
     }
 
-    public void reauthenticate() throws ConnectionException, InvalidCredentialsException, NotParticipatingException {
+    public void reAuthenticate() throws ConnectionException,
+            SkypeAuthenticationException {
         //todo: keep subscribed until reauth is finished so events aren't lost
         doShutdown();
         login();
+        System.out.println(MessageFormat.format("{0}: Relogin successful", Instant.now().toString()));
         if (subscribed.get()) {
             subscribe();
         }
     }
 
     public String getRegistrationToken() {
-        return this.registrationToken;
-    }
-
-    public void setRegistrationToken(String registrationToken) {
-        String[] splits = registrationToken.split(";");
-        this.registrationToken = splits[0];
-        this.registrationTokenExpiryTime = Long.parseLong(splits[1].substring("expires=".length() + 1)) * 1000;
-        if (splits.length > 2) {
-            this.endpointId = splits[2].split("=")[1];
-            if (this.activeThread != null) {
-                this.activeThread.kill();
-                this.activeThread = null;
-            }
-            (activeThread = new ActiveThread(this, Encoder.encode(endpointId))).start();
-        }
+        return getRegTokenProvider().getRegistrationToken();
     }
 
     public String getSkypeToken() {
-        return this.skypeToken;
-    }
-
-    public void setSkypeToken(String skypeToken) {
-        this.skypeToken = skypeToken;
-        String[] data = skypeToken.split("\\.");
-        JsonObject object = JsonObject.readFrom(
-                new String(Base64.getDecoder().decode(data[1]), StandardCharsets.UTF_8));
-        this.skypeTokenExpiryTime = object.get("exp").asLong() * 1000;
+        return getAuthProvider().getSkypeToken();
     }
 
-    public String getCloud() {
+    String getCloud() {
         return this.cloud;
     }
 
@@ -567,7 +510,7 @@ public ExecutorService getScheduler() {
     }
 
     public String getUsername() {
-        return this.username;
+        return getAuthProvider().getUsername();
     }
 
     public UUID getGuid() {
@@ -603,22 +546,22 @@ protected HttpURLConnection getAsmToken() throws ConnectionException {
                 .cookies(cookies)
                 .header("Content-Type", "application/x-www-form-encoded")
                 .expect(204, "While fetching asmtoken")
-                .post("skypetoken=" + Encoder.encode(skypeToken));
+                .post("skypetoken=" + Encoder.encode(getSkypeToken()));
     }
 
     public boolean isAuthenticated() {
-        return System.currentTimeMillis() < skypeTokenExpiryTime;
+        return getExpirationTime().isAfter(Instant.now());
     }
 
     public boolean isRegistrationTokenValid() {
-        return System.currentTimeMillis() < registrationTokenExpiryTime;
+        return getRegTokenProvider().getRegistrationTokenExpiry().isAfter(Instant.now());
     }
 
-    public long getExpirationTime() {
-        return skypeTokenExpiryTime;
+    private Instant getExpirationTime() {
+        return getAuthProvider().getSkypeTokenExpiryTime();
     }
 
-    public SkypeWebSocket getWebSocket() {
+    SkypeWebSocket getWebSocket() {
         return wss;
     }
 
diff --git a/src/main/java/com/samczsun/skype4j/internal/SkypeWebSocket.java b/src/main/java/com/samczsun/skype4j/internal/SkypeWebSocket.java
index d92360e..fd0c200 100644
--- a/src/main/java/com/samczsun/skype4j/internal/SkypeWebSocket.java
+++ b/src/main/java/com/samczsun/skype4j/internal/SkypeWebSocket.java
@@ -116,7 +116,7 @@ public void onMessage(String s) {
             } else if (event == 14) {
                 try {
                     if (skype instanceof FullClient) {
-                        skype.getContactRequests(true);
+                        skype.getContactRequests();
                     }
                 } catch (ConnectionException e) {
                     skype.getLogger().log(Level.SEVERE, String.format("Unhandled exception while parsing websocket message '%s'", s), e);
diff --git a/src/main/java/com/samczsun/skype4j/internal/Utils.java b/src/main/java/com/samczsun/skype4j/internal/Utils.java
index 41f0a54..2cbfdff 100644
--- a/src/main/java/com/samczsun/skype4j/internal/Utils.java
+++ b/src/main/java/com/samczsun/skype4j/internal/Utils.java
@@ -31,13 +31,14 @@
 import java.nio.charset.StandardCharsets;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
-import java.util.Arrays;
 import java.util.Iterator;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
 public class Utils {
 
+    private static final String FORMAT = "appId=%s; time=%s; lockAndKeyResponse=%s";
+
     public static JsonObject parseJsonObject(InputStream inputStream) throws IOException {
         return parseJsonValue(inputStream).asObject();
     }
@@ -78,7 +79,7 @@ public static String upload(byte[] data, ImageType type, JsonObject extra, ChatI
                 .expect(201, "While uploading data")
                 .connect("PUT", data);
 
-        Endpoints.EndpointConnection<JsonObject> econn = Endpoints.IMG_STATUS
+        EndpointConnection<JsonObject> econn = Endpoints.IMG_STATUS
                 .open(chat.getClient(), id, type.id)
                 .as(JsonObject.class)
                 .expect(200, "While getting upload status");
@@ -99,22 +100,6 @@ public static String coerceToString(JsonValue value) {
         return value.isString() ? value.asString() : value.toString();
     }
 
-    public enum ImageType {
-        IMGT1("pish/image", "imgpsh", "imgt1"),
-        AVATAR("avatar/group", "avatar", "avatar_fullsize"), //Also has "avatar"
-        FILE("sharing/file", "original", "thumbnail");
-
-        private String mime;
-        private String endpoint;
-        private String id;
-
-        ImageType(String mime, String endpoint, String id) {
-            this.mime = mime;
-            this.endpoint = endpoint;
-            this.id = id;
-        }
-    }
-
     public static <T> Stream<T> asStream(Iterable<T> sourceIterable) {
         return asStream(sourceIterable.iterator());
     }
@@ -129,7 +114,7 @@ public static String coerceToString(JsonValue value) {
     }
 
     public static void sneakyThrow(Throwable ex) {
-        Utils.<RuntimeException>sneakyThrowInner(ex);
+        Utils.sneakyThrowInner(ex);
     }
 
     private static <T extends Throwable> T sneakyThrowInner(Throwable ex) throws T {
@@ -173,8 +158,6 @@ public static String makeValidBase64(String input) {
         return input;
     }
 
-    private static final String FORMAT = "appId=%s; time=%s; lockAndKeyResponse=%s";
-
     private static String generateTime() {
         long ms = System.currentTimeMillis();
         return String.valueOf(Math.round(ms / 1000.0));
@@ -229,26 +212,6 @@ public static String generateChallenge(String t, String n, String r) {
         E = Long.reverseBytes(E) >>> 32;
         return Long.toHexString(y) + Long.toHexString(b) + Long.toHexString(w) + Long.toHexString(E);
     }
-    /* function(t, n, r) {
-        var s = t + n,
-            f = s,
-            l = 8 - f.length % 8;
-        l !== 8 && (f = a(f, f.length + l, "0"));
-        var c = f.length / 4,
-            h = [],
-            p, d;
-        for (p = 0, d = 0; p < c; p++) h.splice(p, 0, 0), h[p] = h[p] + f.charCodeAt(d++) * 1, h[p] = h[p] + f.charCodeAt(d++) * 256, h[p] = h[p] + f.charCodeAt(d++) * 65536, h[p] = h[p] + f.charCodeAt(d++) * 16777216;
-        var v = new Array(4),
-            m = o(t + r);
-        for (p = 0, d = 0; p < v.length; p++) v[p] = 0, v[p] += i.parseHexInt(m.substr(d, 2)) * 1, d += 2, v[p] += i.parseHexInt(m.substr(d, 2)) * 256, d += 2, v[p] += i.parseHexInt(m.substr(d, 2)) * 65536, d += 2, v[p] += i.parseHexInt(m.substr(d, 2)) * 16777216, d += 2;
-        var g = new Array(2);
-        this._cS64_C(h, v, g);
-        var y = u(v[0], g[0]),
-            b = u(v[1], g[1]),
-            w = u(v[2], g[0]),
-            E = u(v[3], g[1]);
-        return this._int32ToHexString(y) + this._int32ToHexString(b) + this._int32ToHexString(w) + this._int32ToHexString(E)
-    }*/
 
     private static void _cS64_C(long[] t, long[] n, long[] i) {
         long s = 2147483647;
@@ -293,6 +256,50 @@ private static void _cS64_C(long[] t, long[] n, long[] i) {
         i[0] = Long.parseLong(b.toString(), 10);
         i[1] = Long.parseLong(w.toString(), 10);
     }
+    /* function(t, n, r) {
+        var s = t + n,
+            f = s,
+            l = 8 - f.length % 8;
+        l !== 8 && (f = a(f, f.length + l, "0"));
+        var c = f.length / 4,
+            h = [],
+            p, d;
+        for (p = 0, d = 0; p < c; p++) h.splice(p, 0, 0), h[p] = h[p] + f.charCodeAt(d++) * 1, h[p] = h[p] + f.charCodeAt(d++) * 256, h[p] = h[p] + f.charCodeAt(d++) * 65536, h[p] = h[p] + f.charCodeAt(d++) * 16777216;
+        var v = new Array(4),
+            m = o(t + r);
+        for (p = 0, d = 0; p < v.length; p++) v[p] = 0, v[p] += i.parseHexInt(m.substr(d, 2)) * 1, d += 2, v[p] += i.parseHexInt(m.substr(d, 2)) * 256, d += 2, v[p] += i.parseHexInt(m.substr(d, 2)) * 65536, d += 2, v[p] += i.parseHexInt(m.substr(d, 2)) * 16777216, d += 2;
+        var g = new Array(2);
+        this._cS64_C(h, v, g);
+        var y = u(v[0], g[0]),
+            b = u(v[1], g[1]),
+            w = u(v[2], g[0]),
+            E = u(v[3], g[1]);
+        return this._int32ToHexString(y) + this._int32ToHexString(b) + this._int32ToHexString(w) + this._int32ToHexString(E)
+    }*/
+
+    private static long u(long e, long t) {
+        String r = Long.toBinaryString(e);
+        String i = Long.toBinaryString(t);
+        StringBuilder s = new StringBuilder();
+        StringBuilder o = new StringBuilder();
+        int u = Math.abs(r.length() - i.length());
+        for (int a = 0; a < u; a++) {
+            o.append("0");
+        }
+        if (r.length() < i.length()) {
+            o.append(r);
+            r = o.toString();
+        } else {
+            if (i.length() < r.length()) {
+                o.append(i);
+                i = o.toString();
+            }
+        }
+        for (int a = 0; a < r.length(); a++) {
+            s.append(r.charAt(a) == i.charAt(a) ? "0" : "1");
+        }
+        return Long.parseLong(s.toString(), 2);
+    }
 
     /* function _cS64_C(t, n, i) {
         var s = 2147483647;
@@ -334,28 +341,20 @@ private static void _cS64_C(long[] t, long[] n, long[] i) {
         b.modulus(g), w.add(d), w.modulus(g), i[0] = parseInt(b.toString(), 10), i[1] = parseInt(w.toString(), 10), true;
     } */
 
-    private static long u(long e, long t) {
-        String r = Long.toBinaryString(e);
-        String i = Long.toBinaryString(t);
-        StringBuilder s = new StringBuilder();
-        StringBuilder o = new StringBuilder();
-        int u = Math.abs(r.length() - i.length());
-        for (int a = 0; a < u; a++) {
-            o.append("0");
-        }
-        if (r.length() < i.length()) {
-            o.append(r);
-            r = o.toString();
-        } else {
-            if (i.length() < r.length()) {
-                o.append(i);
-                i = o.toString();
-            }
-        }
-        for (int a = 0; a < r.length(); a++) {
-            s.append(r.charAt(a) == i.charAt(a) ? "0" : "1");
+    public enum ImageType {
+        IMGT1("pish/image", "imgpsh", "imgt1"),
+        AVATAR("avatar/group", "avatar", "avatar_fullsize"), //Also has "avatar"
+        FILE("sharing/file", "original", "thumbnail");
+
+        private String mime;
+        private String endpoint;
+        private String id;
+
+        ImageType(String mime, String endpoint, String id) {
+            this.mime = mime;
+            this.endpoint = endpoint;
+            this.id = id;
         }
-        return Long.parseLong(s.toString(), 2);
     }
 
     /* function u(e, t) {
diff --git a/src/main/java/com/samczsun/skype4j/internal/chat/ChatBot.java b/src/main/java/com/samczsun/skype4j/internal/chat/ChatBot.java
index 6bdbb5a..270936f 100644
--- a/src/main/java/com/samczsun/skype4j/internal/chat/ChatBot.java
+++ b/src/main/java/com/samczsun/skype4j/internal/chat/ChatBot.java
@@ -20,14 +20,11 @@
 import com.samczsun.skype4j.exceptions.ChatNotFoundException;
 import com.samczsun.skype4j.exceptions.ConnectionException;
 import com.samczsun.skype4j.internal.Factory;
-import com.samczsun.skype4j.internal.participants.BotImpl;
 import com.samczsun.skype4j.internal.SkypeImpl;
+import com.samczsun.skype4j.internal.participants.BotImpl;
 import com.samczsun.skype4j.internal.participants.UserImpl;
 import com.samczsun.skype4j.participants.Bot;
 
-import java.util.HashMap;
-import java.util.Map;
-
 public class ChatBot extends ChatImpl implements BotChat {
     private BotImpl bot;
 
@@ -36,7 +33,7 @@ public ChatBot(SkypeImpl skype, String identity) throws ConnectionException, Cha
     }
 
     @Override
-    public void addUser(String username) throws ConnectionException {
+    public void addUser(String username) {
         throw new IllegalArgumentException("Cannot remove user from bot chat");
     }
 
diff --git a/src/main/java/com/samczsun/skype4j/internal/chat/ChatGroup.java b/src/main/java/com/samczsun/skype4j/internal/chat/ChatGroup.java
index 2ce06fd..4f4b0c0 100644
--- a/src/main/java/com/samczsun/skype4j/internal/chat/ChatGroup.java
+++ b/src/main/java/com/samczsun/skype4j/internal/chat/ChatGroup.java
@@ -25,22 +25,23 @@
 import com.samczsun.skype4j.internal.Endpoints;
 import com.samczsun.skype4j.internal.Factory;
 import com.samczsun.skype4j.internal.SkypeImpl;
+import com.samczsun.skype4j.internal.Utils;
 import com.samczsun.skype4j.internal.participants.BotImpl;
 import com.samczsun.skype4j.internal.participants.ParticipantImpl;
 import com.samczsun.skype4j.internal.participants.UserImpl;
-import com.samczsun.skype4j.internal.Utils;
 import com.samczsun.skype4j.internal.participants.info.ContactImpl;
 import com.samczsun.skype4j.participants.Participant;
 import com.samczsun.skype4j.participants.info.Contact;
 
 import javax.imageio.ImageIO;
-import java.awt.Graphics2D;
+import java.awt.*;
 import java.awt.image.BufferedImage;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.nio.file.Files;
 import java.util.*;
+import java.util.List;
 import java.util.stream.Collectors;
 
 public class ChatGroup extends ChatImpl implements GroupChat {
@@ -59,7 +60,7 @@ public ChatGroup(SkypeImpl skype, String identity) throws ConnectionException, C
         super(skype, identity);
     }
 
-    public void load() throws ConnectionException, ChatNotFoundException {
+    public void load() throws ConnectionException {
         JsonObject object = Endpoints.CHAT_INFO_URL
                 .open(getClient(), getIdentity())
                 .as(JsonObject.class)
diff --git a/src/main/java/com/samczsun/skype4j/internal/chat/ChatImpl.java b/src/main/java/com/samczsun/skype4j/internal/chat/ChatImpl.java
index 754e310..32ab48a 100644
--- a/src/main/java/com/samczsun/skype4j/internal/chat/ChatImpl.java
+++ b/src/main/java/com/samczsun/skype4j/internal/chat/ChatImpl.java
@@ -33,7 +33,6 @@
 import com.samczsun.skype4j.internal.threads.TypingThread;
 import com.samczsun.skype4j.participants.Participant;
 import com.samczsun.skype4j.participants.info.Contact;
-import com.samczsun.skype4j.participants.User;
 
 import javax.imageio.ImageIO;
 import java.awt.image.BufferedImage;
@@ -45,7 +44,6 @@
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.*;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.regex.Matcher;
 
@@ -57,12 +55,11 @@
     private final String identity;
 
     private SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSX");
-    private String backwardLink;
     private String syncState;
 
     private TypingThread typingThread;
 
-    ChatImpl(SkypeImpl client, String identity) throws ConnectionException, ChatNotFoundException {
+    ChatImpl(SkypeImpl client, String identity) {
         this.client = client;
         this.identity = identity;
     }
@@ -116,7 +113,7 @@ public void sendImage(File image) throws ConnectionException, IOException {
         sendImage(data, name);
     }
 
-    private void sendImage(byte[] data, String imageName) throws ConnectionException, IOException {
+    private void sendImage(byte[] data, String imageName) throws ConnectionException {
         String id = Utils.uploadImage(data, Utils.ImageType.IMGT1, this);
         long ms = System.currentTimeMillis();
         String content = "<URIObject type=\"Picture.1\" uri=\"https://api.asm.skype.com/v1/objects/%s\" url_thumbnail=\"https://api.asm.skype.com/v1/objects/%s/views/imgt1\">MyLegacy pish <a href=\"https://api.asm.skype.com/s/i?%s\">https://api.asm.skype.com/s/i?%s</a><Title/><Description/><OriginalName v=\"%s\"/><meta type=\"photo\" originalName=\"%s\"/></URIObject>";
@@ -171,22 +168,16 @@ public void sendMoji(IMoji flik) throws ConnectionException {
     @Override
     public List<ChatMessage> loadMoreMessages(int amount) throws ConnectionException {
         JsonObject data;
-        if (backwardLink == null) {
-            if (syncState == null) {
-                data = Endpoints.LOAD_MESSAGES
-                        .open(getClient(), getIdentity(), amount)
-                        .as(JsonObject.class)
-                        .expect(200, "While loading messages")
-                        .get();
-            } else {
-                return Collections.emptyList();
-            }
+        if (syncState == null) {
+            data = Endpoints.LOAD_MESSAGES
+                    .open(getClient(), getIdentity(), amount)
+                    .as(JsonObject.class)
+                    .expect(200, "While loading messages")
+                    .get();
         } else {
-            Matcher matcher = SkypeImpl.PAGE_SIZE_PATTERN.matcher(this.backwardLink);
-            //Matcher find appears to be doing nothing.
-            matcher.find();
+            Matcher matcher = SkypeImpl.PAGE_SIZE_PATTERN.matcher(this.syncState);
             String url = matcher.replaceAll("pageSize=" + amount);
-            data =  Endpoints
+            data = Endpoints
                     .custom(url, getClient())
                     .header("RegistrationToken", getClient().getRegistrationToken())
                     .as(JsonObject.class)
@@ -205,7 +196,7 @@ public void sendMoji(IMoji flik) throws ConnectionException {
                         ChatMessage m = Factory.createMessage(this, u, msg.get("id").asString(),
                                 msg.get("clientmessageid").asString(),
                                 formatter.parse(msg.get("originalarrivaltime").asString()).getTime(), message
-                                ,getClient());
+                                , getClient());
                         this.messages.add(0, m);
                         u.insertMessage(m, 0);
                         messages.add(m);
@@ -222,12 +213,9 @@ public void sendMoji(IMoji flik) throws ConnectionException {
         }
 
         JsonObject metadata = data.get("_metadata").asObject();
-        if (metadata.get("backwardLink") != null) {
-            this.backwardLink = metadata.get("backwardLink").asString();
-        } else {
-            this.backwardLink = null;
+        if (metadata.get("syncState") != null) {
+            this.syncState = metadata.get("syncState").asString();
         }
-        this.syncState = metadata.get("syncState").asString();
         return messages;
     }
 
@@ -238,8 +226,17 @@ public void sendMoji(IMoji flik) throws ConnectionException {
 
     @Override
     public ParticipantImpl getParticipant(String username) {
-        username = username.startsWith("8:") ? username : "8:" + username;
-        return this.users.get(username.toLowerCase());
+        if (username.startsWith("8:")) {
+            return this.users.get(username.toLowerCase());
+        } else if (username.startsWith("28:")) {
+            // for bots
+            return this.users.get(username.toLowerCase());
+        } else if (username.startsWith("2:")) {
+            // for skype for business
+            return this.users.get(username.toLowerCase());
+        } else {
+            return this.users.get("8:" + username.toLowerCase());
+        }
     }
 
     @Override
@@ -308,7 +305,7 @@ public void alertsOn(String keyword) throws ConnectionException {
 
     public abstract void load() throws ConnectionException, ChatNotFoundException;
 
-    protected void putOption(String option, JsonValue value, boolean global) throws ConnectionException {
+    void putOption(String option, JsonValue value, boolean global) throws ConnectionException {
         JsonObject obj = new JsonObject();
         obj.add(option, value);
         (global ? Endpoints.CONVERSATION_PROPERTY_GLOBAL : Endpoints.CONVERSATION_PROPERTY_SELF)
diff --git a/src/main/java/com/samczsun/skype4j/internal/chat/ChatIndividual.java b/src/main/java/com/samczsun/skype4j/internal/chat/ChatIndividual.java
index 97c678d..91712db 100644
--- a/src/main/java/com/samczsun/skype4j/internal/chat/ChatIndividual.java
+++ b/src/main/java/com/samczsun/skype4j/internal/chat/ChatIndividual.java
@@ -21,13 +21,9 @@
 import com.samczsun.skype4j.exceptions.ConnectionException;
 import com.samczsun.skype4j.internal.Factory;
 import com.samczsun.skype4j.internal.SkypeImpl;
-import com.samczsun.skype4j.internal.participants.BotImpl;
 import com.samczsun.skype4j.internal.participants.UserImpl;
 import com.samczsun.skype4j.participants.User;
 
-import java.util.HashMap;
-import java.util.Map;
-
 public class ChatIndividual extends ChatImpl implements IndividualChat {
     private User partner;
 
diff --git a/src/main/java/com/samczsun/skype4j/internal/chat/messages/ChatMessageImpl.java b/src/main/java/com/samczsun/skype4j/internal/chat/messages/ChatMessageImpl.java
index c27c4c4..887034f 100644
--- a/src/main/java/com/samczsun/skype4j/internal/chat/messages/ChatMessageImpl.java
+++ b/src/main/java/com/samczsun/skype4j/internal/chat/messages/ChatMessageImpl.java
@@ -18,15 +18,9 @@
 
 import com.samczsun.skype4j.chat.Chat;
 import com.samczsun.skype4j.chat.messages.ChatMessage;
-import com.samczsun.skype4j.exceptions.ConnectionException;
 import com.samczsun.skype4j.formatting.Message;
 import com.samczsun.skype4j.internal.SkypeImpl;
-import com.samczsun.skype4j.internal.chat.ChatImpl;
 import com.samczsun.skype4j.internal.participants.ParticipantImpl;
-import com.samczsun.skype4j.internal.participants.UserImpl;
-import com.samczsun.skype4j.participants.Participant;
-import com.samczsun.skype4j.participants.User;
-import org.jsoup.helper.Validate;
 
 public abstract class ChatMessageImpl implements ChatMessage {
 
diff --git a/src/main/java/com/samczsun/skype4j/internal/chat/messages/ReceivedMessageImpl.java b/src/main/java/com/samczsun/skype4j/internal/chat/messages/ReceivedMessageImpl.java
index db380c0..eb0d745 100644
--- a/src/main/java/com/samczsun/skype4j/internal/chat/messages/ReceivedMessageImpl.java
+++ b/src/main/java/com/samczsun/skype4j/internal/chat/messages/ReceivedMessageImpl.java
@@ -21,8 +21,6 @@
 import com.samczsun.skype4j.formatting.Message;
 import com.samczsun.skype4j.internal.SkypeImpl;
 import com.samczsun.skype4j.internal.participants.ParticipantImpl;
-import com.samczsun.skype4j.participants.Participant;
-import com.samczsun.skype4j.participants.User;
 
 public class ReceivedMessageImpl extends ChatMessageImpl implements ReceivedMessage {
     public ReceivedMessageImpl(Chat chat, ParticipantImpl user, String id, String clientId, long time, Message message, SkypeImpl skype) {
diff --git a/src/main/java/com/samczsun/skype4j/internal/chat/messages/SentMessageImpl.java b/src/main/java/com/samczsun/skype4j/internal/chat/messages/SentMessageImpl.java
index 207530b..6bfc6cf 100644
--- a/src/main/java/com/samczsun/skype4j/internal/chat/messages/SentMessageImpl.java
+++ b/src/main/java/com/samczsun/skype4j/internal/chat/messages/SentMessageImpl.java
@@ -25,8 +25,6 @@
 import com.samczsun.skype4j.internal.Endpoints;
 import com.samczsun.skype4j.internal.SkypeImpl;
 import com.samczsun.skype4j.internal.participants.ParticipantImpl;
-import com.samczsun.skype4j.participants.Participant;
-import com.samczsun.skype4j.participants.User;
 
 public class SentMessageImpl extends ChatMessageImpl implements SentMessage {
     public SentMessageImpl(Chat chat, ParticipantImpl user, String id, String clientId, long time, Message message, SkypeImpl skype) {
diff --git a/src/main/java/com/samczsun/skype4j/internal/client/EntryPoint.java b/src/main/java/com/samczsun/skype4j/internal/client/EntryPoint.java
new file mode 100644
index 0000000..3cc6c99
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/client/EntryPoint.java
@@ -0,0 +1,72 @@
+package com.samczsun.skype4j.internal.client;
+
+import com.samczsun.skype4j.LiveLoginSkypeBuilder;
+import com.samczsun.skype4j.Skype;
+import com.samczsun.skype4j.events.EventHandler;
+import com.samczsun.skype4j.events.Listener;
+import com.samczsun.skype4j.events.chat.message.MessageReceivedEvent;
+import com.samczsun.skype4j.exceptions.ConnectionException;
+import com.samczsun.skype4j.exceptions.InvalidCredentialsException;
+import com.samczsun.skype4j.exceptions.NotParticipatingException;
+import com.samczsun.skype4j.exceptions.SkypeAuthenticationException;
+
+import java.time.Duration;
+import java.util.Scanner;
+import java.util.logging.Logger;
+
+/**
+ * @author a.semennikov
+ */
+public class EntryPoint implements Runnable {
+    static boolean quit = false;
+    private static Logger logger = Logger.getLogger(EntryPoint.class.getName());
+    Scanner sc = new Scanner(System.in);
+
+    /**
+     * @param args the command line arguments
+     */
+    public static void main(String[] args)
+            throws InterruptedException, ConnectionException, NotParticipatingException, InvalidCredentialsException,
+            SkypeAuthenticationException {
+        String username = args[0];
+        String password = args[1];
+        Skype skype = new LiveLoginSkypeBuilder(username, password).withAllResources()
+                .withLogger(logger).build();
+        skype.login();
+        skype.getEventDispatcher().registerListener(new Listener() {
+
+            @EventHandler
+            public void onMessageReceived(MessageReceivedEvent event) throws ConnectionException {
+                event.getChat().sendMessage("You typed: " + event.getMessage());
+            }
+
+        });
+        // TODO code application logic here
+        Thread mt = new Thread(new EntryPoint());
+        mt.start();
+
+        System.out.println("press Q THEN ENTER to terminate");
+
+        while (true) {
+            Thread.sleep(Duration.ofSeconds(10).toMillis());
+            if (quit) {
+                skype.logout();
+                break;
+            }
+//			System.out.println("hello buddy");
+        }
+        System.out.println("It is broken!");
+    }
+
+    @Override
+    public void run() {
+        String msg = "";
+        while (!(msg.equals("Q"))) {
+            try {
+                msg = sc.nextLine();
+            } catch (Exception e) {
+            }
+        }
+        quit = true;
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/client/FullClient.java b/src/main/java/com/samczsun/skype4j/internal/client/FullClient.java
index 51c0e26..0b5ca6a 100644
--- a/src/main/java/com/samczsun/skype4j/internal/client/FullClient.java
+++ b/src/main/java/com/samczsun/skype4j/internal/client/FullClient.java
@@ -23,26 +23,23 @@
 import com.samczsun.skype4j.events.contact.ContactRequestEvent;
 import com.samczsun.skype4j.exceptions.ChatNotFoundException;
 import com.samczsun.skype4j.exceptions.ConnectionException;
-import com.samczsun.skype4j.exceptions.InvalidCredentialsException;
+import com.samczsun.skype4j.exceptions.SkypeAuthenticationException;
 import com.samczsun.skype4j.exceptions.handler.ErrorHandler;
-import com.samczsun.skype4j.exceptions.handler.ErrorSource;
-import com.samczsun.skype4j.internal.*;
+import com.samczsun.skype4j.internal.Endpoints;
+import com.samczsun.skype4j.internal.ExceptionHandler;
+import com.samczsun.skype4j.internal.SkypeImpl;
+import com.samczsun.skype4j.internal.client.auth.SkypeApiAuthProvider;
+import com.samczsun.skype4j.internal.client.auth.SkypeAuthProvider;
+import com.samczsun.skype4j.internal.client.auth.SkypeRefreshAuthProvider;
 import com.samczsun.skype4j.internal.participants.info.ContactImpl;
 import com.samczsun.skype4j.internal.participants.info.ContactRequestImpl;
-import com.samczsun.skype4j.internal.utils.Encoder;
-import com.samczsun.skype4j.internal.utils.UncheckedRunnable;
 import com.samczsun.skype4j.participants.info.Contact;
 
-import javax.xml.bind.DatatypeConverter;
 import java.net.HttpURLConnection;
-import java.nio.charset.StandardCharsets;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.*;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
-import java.util.logging.Level;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
 import java.util.logging.Logger;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -50,52 +47,34 @@
 public class FullClient extends SkypeImpl {
     private static final Pattern URL_PATTERN = Pattern.compile("threads/(.*)", Pattern.CASE_INSENSITIVE);
 
-    private final String password;
+    private SkypeAuthProvider authProvider;
+    private SkypeRefreshAuthProvider refreshAuthProvider;
 
-    public FullClient(String username, String password, Set<String> resources, Logger customLogger, List<ErrorHandler> errorHandlers) {
-        super(username, resources, customLogger, errorHandlers);
-        this.password = password;
+    public FullClient(String username, String password, Set<String> resources, Logger customLogger,
+                      List<ErrorHandler> errorHandlers) {
+        super(resources, customLogger, errorHandlers);
+        this.authProvider = new SkypeApiAuthProvider(username, password);
+        this.refreshAuthProvider = new SkypeRefreshAuthProvider(username, password);
     }
 
     @Override
-    public void login() throws InvalidCredentialsException, ConnectionException {
-        Map<String, String> data = new HashMap<>();
-        data.put("scopes", "client");
-        data.put("clientVersion", "0/7.4.85.102/259/");
-        data.put("username", getUsername().toLowerCase());
-        data.put("passwordHash", hash());
-        JsonObject loginData = Endpoints.LOGIN_URL.open(this)
-                .as(JsonObject.class)
-                .expect(200, "While logging in")
-                .post(Encoder.encode(data));
-
-        this.setSkypeToken(loginData.get("skypetoken").asString());
-
-        List<UncheckedRunnable> tasks = new ArrayList<>();
-        tasks.add(() -> {
-            HttpURLConnection asmResponse = getAsmToken();
-            String[] setCookie = asmResponse.getHeaderField("Set-Cookie").split(";")[0].split("=");
-            this.cookies.put(setCookie[0], setCookie[1]);
-        });
-        tasks.add(this::loadAllContacts);
-        tasks.add(() -> this.getContactRequests(false));
-        tasks.add(() -> {
-            try {
-                this.registerWebSocket();
-            } catch (Exception e) {
-                handleError(ErrorSource.REGISTERING_WEBSOCKET, e, false);
-            }
-        });
-        tasks.add(this::registerEndpoint);
-
-        try {
-            ExecutorService executorService = Executors.newFixedThreadPool(5);
-            tasks.forEach(executorService::submit);
-            executorService.shutdown();
-            executorService.awaitTermination(1, TimeUnit.DAYS);
-        } catch (InterruptedException e) {
-            throw new RuntimeException(e);
-        }
+    protected SkypeAuthProvider getAuthProvider() {
+        return authProvider;
+    }
+
+    @Override
+    public void login() throws ConnectionException, SkypeAuthenticationException {
+
+        getAuthProvider().auth(this);
+        Endpoints.ELIGIBILITY_CHECK.open(this)
+                .expect(200, "You are not eligible to use Skype for Web!")
+                .get();
+        this.loggedIn.set(true);
+        getAsmToken();
+        getRegTokenProvider().registerEndpoint(this, getSkypeToken());
+
+        loadAllContacts();
+        getContactRequests();
 
         super.login();
     }
@@ -129,29 +108,32 @@ public void loadAllContacts() throws ConnectionException {
     }
 
     @Override
-    public void getContactRequests(boolean fromWebsocket) throws ConnectionException {
-        JsonArray array =  Endpoints.AUTH_REQUESTS_URL
-                .open(this)
-                .as(JsonArray.class)
-                .expect(200, "While loading authorization requests")
-                .get();
-        for (JsonValue contactRequest : array) {
-            JsonObject contactRequestObj = contactRequest.asObject();
-            try {
-                ContactRequestImpl request = new ContactRequestImpl(contactRequestObj.get("event_time").asString(),
-                        contactRequestObj.get("sender").asString(),
-                        contactRequestObj.get("greeting").asString(), this);
+    public void getContactRequests() throws ConnectionException {
+        JsonObject array = Endpoints.GET_CONTACT_REQUESTS
+                .open(this, getUsername()).as(JsonObject.class)
+                .expect(200, "While loading contact requests").get();
+
+        JsonArray inviteList = array.get("invite_list").asArray();
+        for (JsonValue jsonValue : inviteList) {
+            JsonObject inviteObject = jsonValue.asObject();
+
+            String sender = inviteObject.get("mri").asString();
+
+            Optional<JsonObject> lastInvite = inviteObject.get("invites").asArray().values().stream()
+                    .map(JsonValue::asObject).max(Comparator.comparing(o -> o.get("time").asString()));
+
+            if (lastInvite.isPresent()) {
+                String time = lastInvite.get().get("time").asString();
+                String message = lastInvite.get().get("message").asString();
+                Contact.ContactRequest request = new ContactRequestImpl(time, sender, message, this);
+
                 if (this.allContactRequests.add(request)) {
-                    if (fromWebsocket) {
-                        ContactRequestEvent event = new ContactRequestEvent(request);
-                        getEventDispatcher().callEvent(event);
-                    }
+                    ContactRequestEvent event = new ContactRequestEvent(request);
+                    getEventDispatcher().callEvent(event);
                 }
-            } catch (java.text.ParseException e) {
-                getLogger().log(Level.WARNING, "Could not parse date for contact request", e);
             }
         }
-        if (fromWebsocket) this.updateContactList();
+        updateContactList();
     }
 
     @Override
@@ -165,7 +147,8 @@ public void updateContactList() throws ConnectionException {
             if (value.asObject().get("suggested") == null || !value.asObject().get("suggested").asBoolean()) {
                 String id = value.asObject().get("id").asString();
                 ContactImpl impl = (ContactImpl) allContacts.get(id);
-                if (impl == null) impl = (ContactImpl) loadContact(id);
+                if (impl == null)
+                    impl = (ContactImpl) loadContact(id);
                 impl.update(value.asObject());
             }
         }
@@ -199,13 +182,4 @@ public GroupChat createGroupChat(Contact... contacts) throws ConnectionException
         }
     }
 
-    private String hash() {
-        try {
-            MessageDigest messageDigest = MessageDigest.getInstance("MD5");
-            byte[] encodedMD = messageDigest.digest(String.format("%s\nskyper\n%s", getUsername().toLowerCase(), password).getBytes(StandardCharsets.UTF_8));
-            return DatatypeConverter.printBase64Binary(encodedMD);
-        } catch (NoSuchAlgorithmException e) {
-            throw new RuntimeException(e);
-        }
-    }
 }
diff --git a/src/main/java/com/samczsun/skype4j/internal/client/GuestClient.java b/src/main/java/com/samczsun/skype4j/internal/client/GuestClient.java
index 1303e78..721cb75 100644
--- a/src/main/java/com/samczsun/skype4j/internal/client/GuestClient.java
+++ b/src/main/java/com/samczsun/skype4j/internal/client/GuestClient.java
@@ -16,20 +16,17 @@
 
 package com.samczsun.skype4j.internal.client;
 
-import com.eclipsesource.json.JsonObject;
 import com.samczsun.skype4j.chat.GroupChat;
 import com.samczsun.skype4j.exceptions.ConnectionException;
-import com.samczsun.skype4j.exceptions.InvalidCredentialsException;
-import com.samczsun.skype4j.exceptions.NotParticipatingException;
+import com.samczsun.skype4j.exceptions.SkypeAuthenticationException;
 import com.samczsun.skype4j.exceptions.handler.ErrorHandler;
 import com.samczsun.skype4j.internal.Endpoints;
 import com.samczsun.skype4j.internal.SkypeImpl;
-import com.samczsun.skype4j.internal.Utils;
+import com.samczsun.skype4j.internal.client.auth.SkypeAuthProvider;
+import com.samczsun.skype4j.internal.client.auth.SkypeGuestAuthProvider;
 import com.samczsun.skype4j.internal.utils.UncheckedRunnable;
 import com.samczsun.skype4j.participants.info.Contact;
 
-import javax.xml.bind.DatatypeConverter;
-import java.io.UnsupportedEncodingException;
 import java.net.HttpURLConnection;
 import java.util.ArrayList;
 import java.util.List;
@@ -41,42 +38,31 @@
 
 public class GuestClient extends SkypeImpl {
     private final String chatId;
-    private final String requestedUsername;
+	private final SkypeAuthProvider authProvider;
 
-    private volatile String actualUsername;
-
-    public GuestClient(String username, String chatId, Set<String> resources, Logger logger, List<ErrorHandler> errorHandlers) {
-        super(username, resources, logger, errorHandlers);
+	public GuestClient(String username, String chatId, Set<String> resources, Logger logger,
+					   List<ErrorHandler> errorHandlers) {
+		super(resources, logger, errorHandlers);
         this.chatId = chatId;
-        this.requestedUsername = username;
+		this.authProvider = new SkypeGuestAuthProvider(username, chatId);
+	}
+
+	@Override
+	protected SkypeAuthProvider getAuthProvider() {
+		return authProvider;
     }
 
     @Override
-    public void login() throws ConnectionException, InvalidCredentialsException {
-        JsonObject response = Endpoints.NEW_GUEST
-                .open(this)
-                .as(JsonObject.class)
-                .on(303, connection -> {
-                    throw new NotParticipatingException();
-                })
-                .expect(201, "While logging in")
-                .header("csrf_token", "skype4j")
-                .cookie("csrf_token", "skype4j")
-                .post(new JsonObject()
-                        .add("name", requestedUsername)
-                        .add("threadId", chatId)
-                        .add("shortId", "Skype4J")
-                        .add("flowId", "Skype4J"));
-        this.setSkypeToken(response.get("skypetoken").asString());
-
-        String[] splits = response.get("skypetoken").asString().split("\\.");
-        try {
-            String decoded = new String(DatatypeConverter.parseBase64Binary(Utils.makeValidBase64(splits[1])), "UTF-8");
-            JsonObject object = JsonObject.readFrom(decoded).asObject();
-            this.actualUsername = object.get("skypeid").asString();
-        } catch (UnsupportedEncodingException e) {
-            throw new RuntimeException(e);
-        }
+	public void login() throws ConnectionException, SkypeAuthenticationException {
+
+		getAuthProvider().auth(this);
+		Endpoints.ELIGIBILITY_CHECK.open(this)
+				.expect(200, "You are not eligible to use Skype for Web!")
+				.get();
+
+		this.loggedIn.set(true);
+
+		getRegTokenProvider().registerEndpoint(this, getSkypeToken());
 
         List<UncheckedRunnable> tasks = new ArrayList<>();
         tasks.add(() -> {
@@ -84,10 +70,8 @@ public void login() throws ConnectionException, InvalidCredentialsException {
             String[] setCookie = asmResponse.getHeaderField("Set-Cookie").split(";")[0].split("=");
             this.cookies.put(setCookie[0], setCookie[1]);
         });
-        tasks.add(this::registerEndpoint);
-
         try {
-            ExecutorService executorService = Executors.newFixedThreadPool(2);
+			ExecutorService executorService = Executors.newFixedThreadPool(1);
             tasks.forEach(executorService::submit);
             executorService.shutdown();
             executorService.awaitTermination(1, TimeUnit.DAYS);
@@ -121,7 +105,7 @@ public void loadAllContacts() {
     }
 
     @Override
-    public void getContactRequests(boolean fromWebsocket) {
+	public void getContactRequests() {
         throw new UnsupportedOperationException("Not supported with a guest account");
     }
 
@@ -132,9 +116,6 @@ public void updateContactList() {
 
     @Override
     public String getUsername() {
-        if (actualUsername == null) {
-            throw new IllegalStateException("Should not be called when login has not completed");
-        }
-        return actualUsername;
+		return this.authProvider.getUsername();
     }
 }
diff --git a/src/main/java/com/samczsun/skype4j/internal/client/MSFTSkypeClient.java b/src/main/java/com/samczsun/skype4j/internal/client/MSFTSkypeClient.java
new file mode 100644
index 0000000..fe45d7d
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/client/MSFTSkypeClient.java
@@ -0,0 +1,27 @@
+package com.samczsun.skype4j.internal.client;
+
+import com.samczsun.skype4j.exceptions.handler.ErrorHandler;
+import com.samczsun.skype4j.internal.client.auth.SkypeAuthProvider;
+import com.samczsun.skype4j.internal.client.auth.SkypeLiveAuthProvider;
+
+import java.util.List;
+import java.util.Set;
+import java.util.logging.Logger;
+
+public class MSFTSkypeClient extends FullClient {
+
+    private SkypeAuthProvider authProvider;
+
+    public MSFTSkypeClient(String userName, String password,
+                           Set<String> resources, Logger customLogger,
+                           List<ErrorHandler> errorHandlers) {
+        super(userName, password, resources, customLogger, errorHandlers);
+        this.authProvider = new SkypeLiveAuthProvider(userName, password);
+    }
+
+    @Override
+    protected SkypeAuthProvider getAuthProvider() {
+        return authProvider;
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/com/samczsun/skype4j/internal/client/auth/LiveLoginHelper.java b/src/main/java/com/samczsun/skype4j/internal/client/auth/LiveLoginHelper.java
new file mode 100644
index 0000000..f57351a
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/client/auth/LiveLoginHelper.java
@@ -0,0 +1,246 @@
+package com.samczsun.skype4j.internal.client.auth;
+
+import com.eclipsesource.json.JsonObject;
+import okhttp3.*;
+import org.apache.commons.lang3.StringEscapeUtils;
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.security.cert.X509Certificate;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+/**
+ * Класс для поддержки авторизации учетных записей microsoft, где в качестве имени пользователя - адрес email
+ */
+public class LiveLoginHelper {
+    public static final String SCOPE = "lw.skype.com";
+    public static final String RPS = "https://api.skype.com/rps/skypetoken";
+    public static final String SOAP_URL = "https://login.live.com:443/RST2.srf";
+    public static final String SOAP_PAYLOAD = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
+            "<s:Envelope xmlns:s=\"http://www.w3.org/2003/05/soap-envelope\" xmlns:wsse=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\" xmlns:saml=\"urn:oasis:names:tc:SAML:1.0:assertion\" xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\" xmlns:wsa=\"http://www.w3.org/2005/08/addressing\" xmlns:wssc=\"http://schemas.xmlsoap.org/ws/2005/02/sc\" xmlns:wst=\"http://schemas.xmlsoap.org/ws/2005/02/trust\">\n"
+            +
+            "    <s:Header>\n" +
+            "        <wsa:Action s:mustUnderstand=\"1\">http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue</wsa:Action>\n"
+            +
+            "        <wsa:To s:mustUnderstand=\"1\">HTTPS://login.live.com:443//RST2.srf</wsa:To>\n" +
+            "        <wsa:MessageID>0</wsa:MessageID>\n" +
+            "        <ps:AuthInfo xmlns:ps=\"http://schemas.microsoft.com/Passport/SoapServices/PPCRL\" Id=\"PPAuthInfo\">\n"
+            +
+            "            <ps:HostingApp>{7108E71A-9926-4FCB-BCC9-9A9D3F32E423}</ps:HostingApp>\n" +
+            "            <ps:BinaryVersion>5</ps:BinaryVersion>\n" +
+            "            <ps:UIVersion>1</ps:UIVersion>\n" +
+            "            <ps:Cookies />\n" +
+            "            <ps:RequestParams>AQAAAAIAAABsYwQAAAAxMDMz</ps:RequestParams>\n" +
+            "        </ps:AuthInfo>\n" +
+            "        <wsse:Security>\n" +
+            "            <wsse:UsernameToken Id=\"user\">\n" +
+            "                <wsse:Username>%s</wsse:Username>\n" +
+            "                <wsse:Password>%s</wsse:Password>\n" +
+            "            </wsse:UsernameToken>\n" +
+            "            <wsu:Timestamp Id=\"Timestamp\">\n" +
+            "                <wsu:Created>%s</wsu:Created>\n" +
+            "                <wsu:Expires>%s</wsu:Expires>\n" +
+            "            </wsu:Timestamp>\n" +
+            "        </wsse:Security>\n" +
+            "    </s:Header>\n" +
+            "    <s:Body>\n" +
+            "        <ps:RequestMultipleSecurityTokens xmlns:ps=\"http://schemas.microsoft.com/Passport/SoapServices/PPCRL\" Id=\"RSTS\">\n"
+            +
+            "            <wst:RequestSecurityToken Id=\"RST0\">\n" +
+            "                <wst:RequestType>http://schemas.xmlsoap.org/ws/2005/02/trust/Issue</wst:RequestType>\n" +
+            "                <wsp:AppliesTo>\n" +
+            "                    <wsa:EndpointReference>\n" +
+            "                        <wsa:Address>" + SCOPE + "</wsa:Address>\n" +
+            "                    </wsa:EndpointReference>\n" +
+            "                </wsp:AppliesTo>\n" +
+            "                <wsp:PolicyReference URI=\"MBI_SSL\" />\n" +
+            "            </wst:RequestSecurityToken>\n" +
+            "        </ps:RequestMultipleSecurityTokens>\n" +
+            "    </s:Body>\n" +
+            "</s:Envelope>";
+
+    private static Map<String, String> parsePayload(String payload) throws Exception {
+        JSONObject response = org.json.XML
+                .toJSONObject(payload)
+                .getJSONObject("S:Envelope")
+                .getJSONObject("S:Body");
+
+        if (!(response.isNull("S:Fault"))) {
+            String reason = response
+                    .getJSONObject("S:Fault")
+                    .getJSONObject("S:Reason")
+                    .getJSONObject("S:Text")
+                    .getString("content");
+
+            String code = response
+                    .getJSONObject("S:Fault")
+                    .getJSONObject("S:Detail")
+                    .getJSONObject("psf:error")
+                    .getString("psf:value");
+
+            throw new FailureReason(reason, code);
+        }
+
+        JSONObject a = response
+                .getJSONObject("wst:RequestSecurityTokenResponseCollection");
+        JSONArray array = a.get("wst:RequestSecurityTokenResponse") instanceof JSONArray
+                ? (JSONArray) a.get("wst:RequestSecurityTokenResponse")
+                : new JSONArray(Arrays.asList(a.get("wst:RequestSecurityTokenResponse")));
+
+        Map<String, String> tokens = new LinkedHashMap<>();
+
+        array.forEach((Object obj) -> {
+            JSONObject json = (JSONObject) obj;
+
+            String content = json.getJSONObject("wst:RequestedSecurityToken")
+                    .getJSONObject("wsse:BinarySecurityToken")
+                    .getString("content")
+                    .replaceAll("&p=", "")
+                    .replaceAll("t=", "");
+
+            String key = json.getJSONObject("wsp:AppliesTo")
+                    .getJSONObject("wsa:EndpointReference")
+                    .getString("wsa:Address")
+                    .replaceAll("&p=", "")
+                    .replaceAll("t=", "");
+
+            tokens.put(key, content);
+        });
+
+        return tokens;
+    }
+
+    private static JsonObject getXTokenObjectFromAccess(final String s, final OkHttpClient client) throws Exception {
+
+        MediaType MEDIA_TYPE_JSON = MediaType.parse("application/json; charset=utf-8");
+
+        JsonObject jsonObj = new JsonObject();
+        jsonObj.add("scopes", "client");
+        jsonObj.add("clientVersion", "0/7.18.0.112//");
+        jsonObj.add("access_token", s);
+        jsonObj.add("partner", "999");
+        jsonObj.add("site_name", "lw");
+        Request request = new Request.Builder().url(RPS)
+                .post(RequestBody.create(MEDIA_TYPE_JSON, jsonObj.toString()))
+                .build();
+
+        Response response = client.newCall(request).execute();
+        return JsonObject.readFrom(response.body().string());
+    }
+
+    public static JsonObject getXTokenObject(String email, String password) throws Exception {
+        Proxy proxy = Proxy.NO_PROXY;
+
+        String PROXY_HOST = System.getProperty("skype.conn.proxy.host", "");
+        String PROXY_PORT = System.getProperty("skype.conn.proxy.port", "");
+        boolean sslEnabled = !Boolean.parseBoolean(System.getProperty("skype.conn.proxy.ssl.disabled"));
+
+        if (!PROXY_HOST.isEmpty() && !PROXY_PORT.isEmpty()) {
+            proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(PROXY_HOST, Integer.parseInt(PROXY_PORT)));
+        }
+        OkHttpClient client = getOkHttpClient(proxy, sslEnabled);
+        MediaType MEDIA_TYPE_MARKDOWN
+                = MediaType.parse("application/json; charset=utf-8");
+
+        String created = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ")
+                .format(new Date(System.currentTimeMillis()));
+
+        String expires = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ")
+                .format(new Date(System.currentTimeMillis() + (1000L * 60L * 60L * 24L * 14L)));
+
+        String payload = String.format(SOAP_PAYLOAD,
+                StringEscapeUtils.escapeXml11(email),
+                StringEscapeUtils.escapeXml11(password),
+                StringEscapeUtils.escapeXml11(created),
+                StringEscapeUtils.escapeXml11(expires)
+        );
+
+        Request request = new Request.Builder()
+                .url(SOAP_URL)
+                .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, payload))
+                .build();
+
+        Response response = client.newCall(request).execute();
+
+        if (response.code() == 200) {
+            Map<String, String> parsedTokens = parsePayload(response.body().string());
+            if (parsedTokens.containsKey(SCOPE)) {
+                return getXTokenObjectFromAccess(parsedTokens.get(SCOPE), client);
+            } else {
+                throw new Exception("Deprecated key");
+            }
+        } else {
+            throw new Exception("Bad response");
+        }
+    }
+
+    private static OkHttpClient getOkHttpClient(Proxy proxy, boolean sslEnabled) {
+        try {
+            // Create a trust manager that does not validate certificate chains
+            final TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {
+                @Override
+                public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {
+                }
+
+                @Override
+                public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) {
+                }
+
+                @Override
+                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
+                    return new X509Certificate[]{};
+                }
+            }};
+
+            // Install the all-trusting trust manager
+            final SSLContext sslContext = SSLContext.getInstance("SSL");
+            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
+            // Create an ssl socket factory with our all-trusting manager
+            final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+
+            OkHttpClient.Builder builder = new OkHttpClient.Builder().proxy(proxy);
+            if (sslEnabled) {
+                builder.sslSocketFactory(sslSocketFactory, (X509TrustManager) trustAllCerts[0]);
+                builder.hostnameVerifier((hostname, session) -> true);
+            }
+            return builder.build();
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    protected static class FailureReason extends Exception {
+        private static final long serialVersionUID = -8430457751314168597L;
+        private final String reason;
+        private final String code;
+
+        protected FailureReason(String reason, String code) {
+            this.reason = reason;
+            this.code = code;
+        }
+
+        public String getCode() {
+            return code;
+        }
+
+        public String getReason() {
+            return reason;
+        }
+
+        @Override
+        public String getMessage() {
+            return String.format("%s: %s", this.code, this.reason);
+        }
+
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeApiAuthProvider.java b/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeApiAuthProvider.java
new file mode 100644
index 0000000..2e57da8
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeApiAuthProvider.java
@@ -0,0 +1,92 @@
+package com.samczsun.skype4j.internal.client.auth;
+
+import com.eclipsesource.json.JsonObject;
+import com.samczsun.skype4j.exceptions.ConnectionException;
+import com.samczsun.skype4j.exceptions.SkypeAuthenticationException;
+import com.samczsun.skype4j.internal.Endpoints;
+import com.samczsun.skype4j.internal.SkypeImpl;
+import com.samczsun.skype4j.internal.utils.Encoder;
+
+import javax.xml.bind.DatatypeConverter;
+import java.nio.charset.StandardCharsets;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.time.Duration;
+import java.time.Instant;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Standard authentication using Skype API endpoint
+ *
+ * @author a.semennikov
+ */
+public class SkypeApiAuthProvider implements SkypeAuthProvider {
+    private String skypeToken = null;
+    private Instant skypeTokenExpiry = null;
+    private String username;
+    private String password;
+
+    public SkypeApiAuthProvider(String username, String password) {
+        this.username = username;
+        this.password = password;
+    }
+
+    @Override
+    public String getPassword() {
+        return password;
+    }
+
+    @Override
+    public String getUsername() {
+        return username;
+    }
+
+    @Override
+    public void auth(SkypeImpl skype)
+            throws ConnectionException, SkypeAuthenticationException {
+        Map<String, String> data = new HashMap<>();
+        data.put("scopes", "client");
+        data.put("clientVersion", "0/7.4.85.102/259/");
+        data.put("username", username.toLowerCase());
+        data.put("passwordHash", hash(username, password));
+        JsonObject loginData = Endpoints.LOGIN_URL.open(skype).as(JsonObject.class)
+                .expect(200, "While logging in")
+                .post(Encoder.encode(data));
+
+        if (loginData.get("skypetoken") == null) {
+            throw new SkypeAuthenticationException(
+                    "Couldn't retrieve Skype token from response for user %s" + username);
+        }
+        this.skypeToken = loginData.get("skypetoken").asString();
+
+        if (loginData.get("expiresIn") != null) {
+            long expiresInMillis = loginData.get("expiresIn").asLong();
+            skypeTokenExpiry = Instant.now().plus(Duration.ofSeconds(expiresInMillis));
+        }
+
+    }
+
+    @Override
+    public String getSkypeToken() {
+        return skypeToken;
+    }
+
+    @Override
+    public Instant getSkypeTokenExpiryTime() {
+        return skypeTokenExpiry;
+    }
+
+    private String hash(String username, String password) {
+        try {
+            MessageDigest messageDigest = MessageDigest.getInstance("MD5");
+            byte[] encodedMD = messageDigest
+                    .digest(String.format("%s\nskyper\n%s", username.toLowerCase(), password)
+                            .getBytes(StandardCharsets.UTF_8));
+            return DatatypeConverter.printBase64Binary(encodedMD);
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeAuthProvider.java b/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeAuthProvider.java
new file mode 100644
index 0000000..5018047
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeAuthProvider.java
@@ -0,0 +1,37 @@
+package com.samczsun.skype4j.internal.client.auth;
+
+import com.samczsun.skype4j.exceptions.ConnectionException;
+import com.samczsun.skype4j.exceptions.SkypeAuthenticationException;
+import com.samczsun.skype4j.internal.SkypeImpl;
+
+import java.time.Instant;
+
+/**
+ * @author a.semennikov
+ */
+public interface SkypeAuthProvider {
+    /**
+     * current password
+     */
+    String getPassword();
+
+    /**
+     * current username
+     */
+    String getUsername();
+
+    void auth(SkypeImpl skype)
+            throws ConnectionException, SkypeAuthenticationException;
+
+    /**
+     * Skype token
+     */
+    String getSkypeToken();
+
+    /**
+     * The time when skype token becames expired and we need to get new one
+     *
+     * @return {@link Instant Instant} of datetime
+     */
+    Instant getSkypeTokenExpiryTime();
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeGuestAuthProvider.java b/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeGuestAuthProvider.java
new file mode 100644
index 0000000..2a5f305
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeGuestAuthProvider.java
@@ -0,0 +1,82 @@
+package com.samczsun.skype4j.internal.client.auth;
+
+import com.eclipsesource.json.JsonObject;
+import com.samczsun.skype4j.exceptions.ConnectionException;
+import com.samczsun.skype4j.exceptions.NotParticipatingException;
+import com.samczsun.skype4j.internal.Endpoints;
+import com.samczsun.skype4j.internal.SkypeImpl;
+import com.samczsun.skype4j.internal.Utils;
+
+import javax.xml.bind.DatatypeConverter;
+import java.io.UnsupportedEncodingException;
+import java.time.Instant;
+
+/**
+ * @author a.semennikov
+ */
+public class SkypeGuestAuthProvider implements SkypeAuthProvider {
+
+    private final String username;
+    private final String chatId;
+    private String actualUsername;
+    private String skypeToken;
+    private Instant skypeTokenExpiryTime;
+
+    public SkypeGuestAuthProvider(String username, String chatId) {
+        this.username = username;
+        this.chatId = chatId;
+    }
+
+    @Override
+    public String getPassword() {
+        return null;
+    }
+
+    @Override
+    public String getUsername() {
+        if (actualUsername == null) {
+            throw new IllegalStateException("Should not be called when login has not completed");
+        }
+        return actualUsername;
+    }
+
+    @Override
+    public void auth(SkypeImpl skype)
+            throws ConnectionException {
+        JsonObject response = Endpoints.NEW_GUEST
+                .open(skype)
+                .as(JsonObject.class)
+                .on(303, connection -> {
+                    throw new NotParticipatingException();
+                })
+                .expect(201, "While logging in")
+                .header("csrf_token", "skype4j")
+                .cookie("csrf_token", "skype4j")
+                .post(new JsonObject()
+                        .add("name", this.username)
+                        .add("threadId", chatId)
+                        .add("shortId", "Skype4J")
+                        .add("flowId", "Skype4J"));
+        skypeToken = response.get("skypeToken").asString();
+
+        String[] splits = skypeToken.split("\\.");
+        try {
+            String decoded = new String(DatatypeConverter.parseBase64Binary(Utils.makeValidBase64(splits[1])), "UTF-8");
+            JsonObject object = JsonObject.readFrom(decoded).asObject();
+            this.actualUsername = object.get("skypeid").asString();
+            this.skypeTokenExpiryTime = Instant.ofEpochSecond(object.get("exp").asLong());
+        } catch (UnsupportedEncodingException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public String getSkypeToken() {
+        return skypeToken;
+    }
+
+    @Override
+    public Instant getSkypeTokenExpiryTime() {
+        return skypeTokenExpiryTime;
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeLive2AuthProvider.java b/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeLive2AuthProvider.java
new file mode 100644
index 0000000..7260013
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeLive2AuthProvider.java
@@ -0,0 +1,183 @@
+package com.samczsun.skype4j.internal.client.auth;
+
+import com.eclipsesource.json.JsonObject;
+import com.samczsun.skype4j.exceptions.ConnectionException;
+import com.samczsun.skype4j.exceptions.SkypeAuthenticationException;
+import com.samczsun.skype4j.internal.Endpoints;
+import com.samczsun.skype4j.internal.SkypeImpl;
+import com.samczsun.skype4j.internal.utils.Encoder;
+import org.jsoup.nodes.Document;
+import org.jsoup.nodes.Element;
+import org.jsoup.parser.Parser;
+import org.jsoup.select.Elements;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.net.HttpCookie;
+import java.net.HttpURLConnection;
+import java.time.Duration;
+import java.time.Instant;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+/**
+ * @author a.semennikov
+ */
+@SuppressWarnings("Duplicates")
+public class SkypeLive2AuthProvider implements SkypeAuthProvider {
+    private String username;
+    private String password;
+    private String skypeToken;
+    private Instant skypeTokenExpiryTime;
+
+    public SkypeLive2AuthProvider(String username, String password) {
+        this.username = username;
+        this.password = password;
+    }
+
+    @Override
+    public String getPassword() {
+        return password;
+    }
+
+    @Override
+    public String getUsername() {
+        return username;
+    }
+
+    @Override
+    public void auth(SkypeImpl skype)
+            throws SkypeAuthenticationException {
+        try {
+            JsonObject params = getParams(skype);
+            String t = sendCredentials(skype, username, password, params);
+            getToken(skype, t);
+        } catch (Exception e) {
+            throw new SkypeAuthenticationException("Failed to get skype token", e);
+        }
+    }
+
+    private JsonObject getParams(SkypeImpl skype) throws ConnectionException, SkypeAuthenticationException,
+            IOException {
+
+        HttpURLConnection get = Endpoints
+                .custom("https://login.skype.com/login/oauth/microsoft?client_id=578134&redirect_uri=https%3A%2F%2Fweb.skype.com",
+                        skype)
+                .expect(200, "While getting handshake params")
+                .get();
+        String result = new BufferedReader(new InputStreamReader(get.getInputStream()))
+                .lines().collect(Collectors.joining("\n"));
+        Matcher m = Pattern.compile("<input.*type=\"hidden\".*name=\"PPFT\".*value=\"(.*)\">").matcher(result);
+        if (!m.find()) {
+            throw new SkypeAuthenticationException("Couldn't retrieve PPFT from login form");
+        }
+        String ppftReg = m.group(1);
+
+        Map<String, List<String>> headerFields = get.getHeaderFields();
+        List<String> cookieHeader = headerFields.get("Set-Cookie");
+        List<HttpCookie> cookie = new ArrayList<>();
+        for (String s : cookieHeader) {
+            cookie.addAll(HttpCookie.parse(s));
+        }
+
+        String MSPRequ = null;
+        String MSPOK = null;
+
+        for (HttpCookie httpCookie : cookie) {
+            if (httpCookie.getName().equals("MSPRequ")) {
+                MSPRequ = httpCookie.getValue();
+            }
+            if (httpCookie.getName().equals("MSPOK")) {
+                MSPOK = httpCookie.getValue();
+            }
+        }
+
+        if (MSPRequ == null || MSPOK == null) {
+            throw new SkypeAuthenticationException("Couldn't retrieve MSPRequ/MSPOK cookies");
+        }
+
+        return new JsonObject()
+                .add("MSPRequ", MSPRequ)
+                .add("MSPOK", MSPOK)
+                .add("PPFT", ppftReg);
+    }
+
+    private String sendCredentials(SkypeImpl skype, String username, String password, JsonObject params) {
+        try {
+            Map<String, String> cookies = new HashMap<>();
+            if (skypeToken != null) {
+                cookies.put("refresh-token", skypeToken);
+            }
+            cookies.put("MSRequ", params.get("MSPRequ").asString());
+            cookies.put("MSPOK", params.get("MSPOK").asString());
+            cookies.put("CkTst", String.valueOf(Instant.now().toEpochMilli()));
+
+            HttpURLConnection get = Endpoints.custom("https://login.live.com/ppsecure/post.srf?%s", skype,
+                    "wa=wsignin1.0"
+                            + "&wp=MBI_SSL"
+                            + "&wreply=https://lw.skype.com/login/oauth/proxy?client_id=578134&site_name=lw.skype.com&redirect_uri=https%3A%2F%2Fweb.skype.com%2F")
+                    .expect(code -> code == 200 || code == 201, "While logging in")
+                    .cookies(cookies)
+                    .post(new JsonObject()
+                            .add("login", username)
+                            .add("passwd", password)
+                            .add("PPFT", params.get("PPFT").asString()));
+            String result = new BufferedReader(new InputStreamReader(get.getInputStream()))
+                    .lines().collect(Collectors.joining("\n"));
+            Document doc = Parser.htmlParser().parseInput(result, "");
+
+            Element tField = doc.getElementById("t");
+            if (tField == null) {
+                throw new ConnectionException("Couldn't retrieve t field from login response",
+                        new IOException("no element with name \'t\'"));
+            }
+            return tField.val();
+        } catch (Throwable e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    private void getToken(SkypeImpl skype, String t) throws ConnectionException {
+        Map<String, String> data = new HashMap<>();
+//		data.put("t", t);
+        data.put("client_id", "578134");
+        data.put("oauthPartner", "999");
+        data.put("site_name", "lw.skype.com");
+        data.put("redirect_uri", "https://web.skype.com");
+        JsonObject jsonResp = Endpoints.REFRESH_EXCHANGE_LOGIN_URL.open(skype)
+                .expect(200, "While logging in")
+                .as(JsonObject.class)
+                .post(Encoder.encode(data));
+        String content = jsonResp.get("content").asString();
+        Document loginPage = Parser.xmlParser().parseInput(content, "");
+
+        Element inputField = loginPage.select("input").first();
+        Elements name = inputField.getElementsByTag("name");
+        String skypetoken = name.select("skypetoken").first().val();
+        String expiresIn = name.select("expires_in").first().val();
+
+        if (skypetoken == null) {
+            throw new ConnectionException("Couldn't retrieve t field from login response",
+                    new IOException("no element with name \'t\'"));
+        }
+        this.skypeToken = skypetoken;
+        this.skypeTokenExpiryTime = Instant.now().plus(Duration.ofSeconds(Long.parseLong(expiresIn)));
+    }
+
+    @Override
+    public String getSkypeToken() {
+        return skypeToken;
+    }
+
+    @Override
+    public Instant getSkypeTokenExpiryTime() {
+        return skypeTokenExpiryTime;
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeLiveAuthProvider.java b/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeLiveAuthProvider.java
new file mode 100644
index 0000000..4bf4fbd
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeLiveAuthProvider.java
@@ -0,0 +1,60 @@
+package com.samczsun.skype4j.internal.client.auth;
+
+import com.eclipsesource.json.JsonObject;
+import com.samczsun.skype4j.exceptions.SkypeAuthenticationException;
+import com.samczsun.skype4j.internal.SkypeImpl;
+
+import java.time.Duration;
+import java.time.Instant;
+
+/**
+ * @author a.semennikov
+ */
+public class SkypeLiveAuthProvider implements SkypeAuthProvider {
+
+    private final String originalUsername;
+    private String username;
+    private String password;
+    private String skypeToken;
+    private Instant skypeTokenExpiryTime;
+
+    public SkypeLiveAuthProvider(String username, String password) {
+        this.username = username;
+        this.originalUsername = username;
+        this.password = password;
+    }
+
+    @Override
+    public String getPassword() {
+        return password;
+    }
+
+    @Override
+    public String getUsername() {
+        return username;
+    }
+
+    @Override
+    public void auth(SkypeImpl skype)
+            throws SkypeAuthenticationException {
+        try {
+            JsonObject object = LiveLoginHelper.getXTokenObject(originalUsername, password);
+            this.username = object.get("skypeid").asString();
+            this.skypeToken = object.get("skypetoken").asString();
+//			this.skypeTokenExpiryTime = Instant.now().plus(Duration.ofMinutes(5));
+            this.skypeTokenExpiryTime = Instant.now().plus(Duration.ofSeconds(object.get("expiresIn").asLong()));
+        } catch (Exception e) {
+            throw new SkypeAuthenticationException("Failed to get skype token", e);
+        }
+    }
+
+    @Override
+    public String getSkypeToken() {
+        return skypeToken;
+    }
+
+    @Override
+    public Instant getSkypeTokenExpiryTime() {
+        return skypeTokenExpiryTime;
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeRefreshAuthProvider.java b/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeRefreshAuthProvider.java
new file mode 100644
index 0000000..282d303
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeRefreshAuthProvider.java
@@ -0,0 +1,123 @@
+package com.samczsun.skype4j.internal.client.auth;
+
+import com.eclipsesource.json.JsonObject;
+import com.samczsun.skype4j.exceptions.ConnectionException;
+import com.samczsun.skype4j.internal.Endpoints;
+import com.samczsun.skype4j.internal.SkypeImpl;
+import com.samczsun.skype4j.internal.utils.Encoder;
+import org.jsoup.nodes.Document;
+import org.jsoup.nodes.Element;
+import org.jsoup.parser.Parser;
+import org.jsoup.select.Elements;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.net.HttpURLConnection;
+import java.time.Duration;
+import java.time.Instant;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+/**
+ * Refreshing skype authentication token. Applicable only for Skype old-fashioned accounts
+ *
+ * @author a.semennikov
+ */
+public class SkypeRefreshAuthProvider implements SkypeAuthProvider {
+    private final String username;
+    private final String password;
+    private String skypeToken;
+    private Instant skypeTokenExpiryTime;
+
+    public SkypeRefreshAuthProvider(String username, String password) {
+        this.username = username;
+        this.password = password;
+    }
+
+    @Override
+    public void auth(SkypeImpl skype) {
+        throw new IllegalStateException("Not yet coreectly working");
+//		refreshToken(skype, skype.getSkypeToken());
+    }
+
+    private void refreshToken(SkypeImpl skype, String oldSkypeToken)
+            throws ConnectionException {
+        //Authentication dance
+        String t = this.sendToken(skype, oldSkypeToken);
+        this.getToken(skype, t);
+    }
+
+    private String sendToken(SkypeImpl skype, String skypeToken) {
+        try {
+            Map<String, String> cookies = new HashMap<>();
+            if (skypeToken != null) {
+                cookies.put("refresh-token", skypeToken);
+            }
+            HttpURLConnection get = Endpoints.REFRESH_LOGIN_URL.open(skype)
+                    .expect(code -> code == 200 || code == 201, "While logging in")
+                    .cookies(cookies)
+                    .get();
+            String result = new BufferedReader(new InputStreamReader(get.getInputStream()))
+                    .lines().collect(Collectors.joining("\n"));
+            Document doc = Parser.htmlParser().parseInput(result, "");//Utils.parseJsonObject(jsonResp).get("content").asString();
+
+            Element tField = doc.getElementById("t");
+            if (tField == null) {
+                throw new ConnectionException("Couldn't retrieve t field from login response",
+                        new IOException("no element with name \'t\'"));
+            }
+            return tField.val();
+        } catch (Throwable e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    private void getToken(SkypeImpl skype, String t) throws ConnectionException {
+        Map<String, String> data = new HashMap<>();
+        data.put("t", t);
+        data.put("client_id", "578134");
+        data.put("oauthPartner", "999");
+        data.put("site_name", "lw.skype.com");
+        data.put("redirect_uri", "https://web.skype.com");
+        JsonObject jsonResp = Endpoints.REFRESH_EXCHANGE_LOGIN_URL.open(skype)
+                .expect(200, "While logging in")
+                .as(JsonObject.class)
+                .post(Encoder.encode(data));
+        String content = jsonResp.get("content").asString();
+        Document loginPage = Parser.xmlParser().parseInput(content, "");
+
+        Element inputField = loginPage.select("input").first();
+        Elements name = inputField.getElementsByTag("name");
+        String skypetoken = name.select("skypetoken").first().val();
+        String expiresIn = name.select("expires_in").first().val();
+
+        if (skypetoken == null) {
+            throw new ConnectionException("Couldn't retrieve t field from login response",
+                    new IOException("no element with name \'t\'"));
+        }
+        this.skypeToken = skypetoken;
+        this.skypeTokenExpiryTime = Instant.now().plus(Duration.ofSeconds(Long.parseLong(expiresIn)));
+    }
+
+    @Override
+    public String getPassword() {
+        return password;
+    }
+
+    @Override
+    public String getUsername() {
+        return username;
+    }
+
+    public String getSkypeToken() {
+        return skypeToken;
+    }
+
+    @Override
+    public Instant getSkypeTokenExpiryTime() {
+        return skypeTokenExpiryTime;
+    }
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeRegistrationProvider.java b/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeRegistrationProvider.java
new file mode 100644
index 0000000..eb8b159
--- /dev/null
+++ b/src/main/java/com/samczsun/skype4j/internal/client/auth/SkypeRegistrationProvider.java
@@ -0,0 +1,137 @@
+package com.samczsun.skype4j.internal.client.auth;
+
+import com.eclipsesource.json.JsonObject;
+import com.samczsun.skype4j.Skype;
+import com.samczsun.skype4j.exceptions.ConnectionException;
+import com.samczsun.skype4j.internal.Endpoints;
+import com.samczsun.skype4j.internal.SkypeImpl;
+import com.samczsun.skype4j.internal.Utils;
+import com.samczsun.skype4j.internal.threads.ActiveThread;
+import com.samczsun.skype4j.internal.utils.Encoder;
+
+import java.net.HttpURLConnection;
+import java.time.Duration;
+import java.time.Instant;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * @author a.semennikov
+ */
+public class SkypeRegistrationProvider {
+
+    private String registrationToken;
+    private Instant registrationTokenExpiry;
+    private String endpointId;
+    private ActiveThread endpointCheckActiveThread;
+
+    public void registerEndpoint(SkypeImpl skype, String skypeToken) throws ConnectionException {
+        String newRegToken = null;
+        while (newRegToken == null) {
+            HttpURLConnection post = requestEndpoint(skype, skypeToken);
+            String regTokenHead = post.getHeaderField("Set-RegistrationToken");
+            String locationHead = post.getHeaderField("Location");
+
+            if (locationHead != null) {
+                Matcher m = Pattern.compile("(https://[^/]+/v1)/users/ME/endpoints(/%7B([a-z0-9\\-]+)%7D)?")
+                        .matcher(locationHead);
+                if (m.matches()) {
+                    if (m.groupCount() == 3 && m.group(3) != null) {
+                        this.endpointId = "{" + m.group(3) + "}";
+                    }
+
+                    if (!m.group(1).equals(Endpoints.ENDPOINTS_URL.url())) {
+                        // Skype is requiring the use of a different hostname.
+                        //update cloud prefix to use in queries
+                        skype.updateCloud(locationHead);
+                        //Don't accept the token if present, we need to re-register first.
+                    }
+                }
+            }
+
+            if (regTokenHead != null) {
+                newRegToken = setRegistrationToken(regTokenHead);
+            }
+        }
+//      Not sure whay we need this here
+//		Endpoints.MESSAGINGSERVICE_URL
+//				.open(skype, Encoder.encode(endpointId))
+//				.expect(200, "While submitting messagingservice")
+//				.put(getRegistrationObject());
+
+        if (endpointId != null) {
+            if (this.endpointCheckActiveThread != null) {
+                this.endpointCheckActiveThread.kill();
+                this.endpointCheckActiveThread = null;
+            }
+
+            (this.endpointCheckActiveThread = new ActiveThread(skype, Encoder.encode(endpointId))).start();
+        }
+    }
+
+    public String setRegistrationToken(String regTokenHead) {
+        String newRegToken;
+        String[] splits = regTokenHead.split(";");
+        this.registrationToken = splits[0];
+        newRegToken = this.registrationToken;
+        long expiresInMillis = Long.parseLong(splits[1].split("=")[1]);
+        this.registrationTokenExpiry = Instant.ofEpochMilli(Duration.ofSeconds(expiresInMillis).toMillis());
+        if (splits.length > 2) {
+            this.endpointId = splits[2].split("=")[1];
+        }
+        return newRegToken;
+    }
+
+    public JsonObject getRegistrationObject() {
+        JsonObject publicInfo = new JsonObject()
+                .add("capabilities", "video|audio")
+                .add("type", 1)
+                .add("skypeNameVersion", "skype.com")
+                .add("nodeInfo", "")
+                .add("version", Skype.VERSION);
+        JsonObject privateInfo = new JsonObject()
+                .add("epname", "Skype4J");
+        return new JsonObject()
+                .add("id", "messagingService")
+                .add("type", "EndpointPresenceDoc")
+                .add("selfLink", "uri")
+                .add("publicInfo", publicInfo)
+                .add("privateInfo", privateInfo);
+    }
+
+    private HttpURLConnection requestEndpoint(SkypeImpl skype, String skypeToken)
+            throws ConnectionException {
+        return Endpoints.ENDPOINTS_URL.open(skype)
+                .noRedirects()
+                .dontConnect()
+                .on(301, (connection) -> followRedirectToRegisteredEndpoint(skype, skypeToken))
+                .expect(code -> code == 201 || code == 404, "While registering endpoint")
+                .header("Authentication", "skypetoken=" + skypeToken)
+                .header("LockAndKey", Utils.generateChallengeHeader())
+                .header("BehaviorOverride", "redirectAs404")
+                .post(new JsonObject().add("endpointFeatures", "Agent"));
+    }
+
+    private HttpURLConnection followRedirectToRegisteredEndpoint(SkypeImpl skype, String skypeToken)
+            throws ConnectionException {
+        return Endpoints
+                .custom(Endpoints.ENDPOINTS_URL.url() + "/" + Encoder.encode(endpointId), skype)
+                .expect(200, "While registering endpoint")
+                .header("Authentication", "skypetoken=" + skypeToken)
+                .header("LockAndKey", Utils.generateChallengeHeader())
+                .put(new JsonObject().add("endpointFeatures", "Agent"));
+    }
+
+    public Instant getRegistrationTokenExpiry() {
+        return registrationTokenExpiry;
+    }
+
+    public String getEndpointId() {
+        return endpointId;
+    }
+
+    public String getRegistrationToken() {
+        return registrationToken;
+    }
+
+}
diff --git a/src/main/java/com/samczsun/skype4j/internal/participants/BotImpl.java b/src/main/java/com/samczsun/skype4j/internal/participants/BotImpl.java
index 0082a87..a872aee 100644
--- a/src/main/java/com/samczsun/skype4j/internal/participants/BotImpl.java
+++ b/src/main/java/com/samczsun/skype4j/internal/participants/BotImpl.java
@@ -16,22 +16,16 @@
 
 package com.samczsun.skype4j.internal.participants;
 
-import com.samczsun.skype4j.chat.messages.ChatMessage;
-import com.samczsun.skype4j.exceptions.ConnectionException;
 import com.samczsun.skype4j.internal.SkypeImpl;
-import com.samczsun.skype4j.internal.chat.ChatBot;
 import com.samczsun.skype4j.internal.chat.ChatImpl;
 import com.samczsun.skype4j.participants.Bot;
 import com.samczsun.skype4j.participants.info.BotInfo;
 
-import java.util.List;
-import java.util.UUID;
-
 public class BotImpl extends ParticipantImpl implements Bot {
 
     private BotInfo botInfo;
 
-    public BotImpl(SkypeImpl skype, ChatImpl chat, String id) throws ConnectionException {
+    public BotImpl(SkypeImpl skype, ChatImpl chat, String id) {
         super(skype, chat, id);
     }
 
diff --git a/src/main/java/com/samczsun/skype4j/internal/participants/ParticipantImpl.java b/src/main/java/com/samczsun/skype4j/internal/participants/ParticipantImpl.java
index b37125a..5d1224b 100644
--- a/src/main/java/com/samczsun/skype4j/internal/participants/ParticipantImpl.java
+++ b/src/main/java/com/samczsun/skype4j/internal/participants/ParticipantImpl.java
@@ -31,16 +31,13 @@
 
 public abstract class ParticipantImpl implements Participant {
 
+    private final List<ChatMessage> messages = Collections.synchronizedList(new ArrayList<>());
+    private final Map<String, ChatMessage> messageMap = Collections.synchronizedMap(new HashMap<>());
     private SkypeImpl skype;
     private String id;
-
     private ChatImpl chat;
-
     private Participant.Role role = Participant.Role.USER;
 
-    private final List<ChatMessage> messages = Collections.synchronizedList(new ArrayList<>());
-    private final Map<String, ChatMessage> messageMap = Collections.synchronizedMap(new HashMap<>());
-
     public ParticipantImpl(SkypeImpl skype, ChatImpl chat, String id) {
         this.skype = skype;
         this.id = id;
diff --git a/src/main/java/com/samczsun/skype4j/internal/participants/UserImpl.java b/src/main/java/com/samczsun/skype4j/internal/participants/UserImpl.java
index 3e8a8d5..cc5e2db 100644
--- a/src/main/java/com/samczsun/skype4j/internal/participants/UserImpl.java
+++ b/src/main/java/com/samczsun/skype4j/internal/participants/UserImpl.java
@@ -16,28 +16,15 @@
 
 package com.samczsun.skype4j.internal.participants;
 
-import com.eclipsesource.json.JsonObject;
-import com.samczsun.skype4j.chat.Chat;
-import com.samczsun.skype4j.chat.GroupChat;
-import com.samczsun.skype4j.chat.messages.ChatMessage;
-import com.samczsun.skype4j.exceptions.ConnectionException;
-import com.samczsun.skype4j.exceptions.NoPermissionException;
-import com.samczsun.skype4j.internal.Endpoints;
 import com.samczsun.skype4j.internal.SkypeImpl;
 import com.samczsun.skype4j.internal.chat.ChatImpl;
-import com.samczsun.skype4j.participants.info.Contact;
 import com.samczsun.skype4j.participants.User;
-
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CopyOnWriteArrayList;
+import com.samczsun.skype4j.participants.info.Contact;
 
 public class UserImpl extends ParticipantImpl implements User {
     private Contact contactRep;
 
-    public UserImpl(SkypeImpl skype, ChatImpl chat, String id) throws ConnectionException {
+    public UserImpl(SkypeImpl skype, ChatImpl chat, String id) {
         super(skype, chat, id);
     }
 
diff --git a/src/main/java/com/samczsun/skype4j/internal/participants/info/BotInfoImpl.java b/src/main/java/com/samczsun/skype4j/internal/participants/info/BotInfoImpl.java
index 2debc38..21f0e98 100644
--- a/src/main/java/com/samczsun/skype4j/internal/participants/info/BotInfoImpl.java
+++ b/src/main/java/com/samczsun/skype4j/internal/participants/info/BotInfoImpl.java
@@ -165,6 +165,12 @@ public void load() throws ConnectionException {
             throw Skype.UNEXPECTED;
         }
 
+        if (descriptions.isEmpty()) {
+            this.displayName = uuid;
+            this.description = this.getClass().getSimpleName();
+            return;
+        }
+
         JsonObject object = descriptions.get(0).asObject();
 
         this.displayName = Utils.getString(object, "displayName");
diff --git a/src/main/java/com/samczsun/skype4j/internal/participants/info/ContactImpl.java b/src/main/java/com/samczsun/skype4j/internal/participants/info/ContactImpl.java
index ce62c13..cffa11c 100644
--- a/src/main/java/com/samczsun/skype4j/internal/participants/info/ContactImpl.java
+++ b/src/main/java/com/samczsun/skype4j/internal/participants/info/ContactImpl.java
@@ -29,6 +29,7 @@
 import com.samczsun.skype4j.internal.client.FullClient;
 import com.samczsun.skype4j.internal.utils.Encoder;
 import com.samczsun.skype4j.participants.info.Contact;
+import org.apache.commons.lang3.StringUtils;
 import org.jsoup.helper.Validate;
 
 import java.awt.*;
@@ -38,30 +39,6 @@
 
 public class ContactImpl implements Contact {
     private static final Pattern PHONE_NUMBER = Pattern.compile("\\+[0-9]+");
-
-    public static Contact createContact(SkypeImpl skype, String username) throws ConnectionException {
-        Validate.notEmpty(username, "Username must not be empty");
-        return new ContactImpl(skype, username, getObject(skype, username));
-    }
-
-    public static Contact createContact(SkypeImpl skype, String username, JsonObject unaddedData) throws ConnectionException {
-        Validate.notEmpty(username, "Username must not be empty");
-        return new ContactImpl(skype, username, unaddedData);
-    }
-
-    private static JsonObject getObject(SkypeImpl skype, String username) throws ConnectionException {
-        JsonArray array = Endpoints.PROFILE_INFO
-                .open(skype)
-                .expect(200, "While getting contact info")
-                .as(JsonArray.class)
-                .post(new JsonObject()
-                        .add("usernames", new JsonArray()
-                                .add(username)
-                        )
-                );
-        return array.get(0).asObject();
-    }
-
     private SkypeImpl skype;
     private String username;
     private String displayName;
@@ -77,10 +54,8 @@ private static JsonObject getObject(SkypeImpl skype, String username) throws Con
     private String country;
     private String city;
     private boolean isPhone;
-
     private boolean isAuthorized;
     private boolean isBlocked;
-
     // What is this?
     private String authCertificate;
     private UUID personId;
@@ -96,13 +71,35 @@ public ContactImpl(SkypeImpl skype, String username, JsonObject unaddedData) thr
             this.isPhone = true;
         }
     }
-
     public ContactImpl(SkypeImpl skype, JsonObject contact) throws ConnectionException {
         this.skype = skype;
         update(contact);
         updateProfile(getObject(skype, getUsername()));
     }
 
+    public static Contact createContact(SkypeImpl skype, String username) throws ConnectionException {
+        Validate.notEmpty(username, "Username must not be empty");
+        return new ContactImpl(skype, username, getObject(skype, username));
+    }
+
+    public static Contact createContact(SkypeImpl skype, String username, JsonObject unaddedData) throws ConnectionException {
+        Validate.notEmpty(username, "Username must not be empty");
+        return new ContactImpl(skype, username, unaddedData);
+    }
+
+    private static JsonObject getObject(SkypeImpl skype, String username) throws ConnectionException {
+        JsonArray array = Endpoints.PROFILE_INFO
+                .open(skype)
+                .expect(200, "While getting contact info")
+                .as(JsonArray.class)
+                .post(new JsonObject()
+                        .add("usernames", new JsonArray()
+                                .add(username)
+                        )
+                );
+        return array.get(0).asObject();
+    }
+
     private void updateContactInfo() throws ConnectionException {
         if (this.skype instanceof FullClient) {
             JsonObject obj = Endpoints.GET_CONTACT_BY_ID
@@ -193,36 +190,40 @@ public boolean isAuthorized() {
 
     @Override
     public void authorize() throws ConnectionException {
-        Endpoints.AUTHORIZE_CONTACT.open(skype, this.username).expect(200, "While authorizing contact").put();
+        Endpoints.AUTHORIZE_CONTACT_SELF.open(skype, StringUtils.prependIfMissing(this.username, "8:"))
+                .header("BehaviorOverride", "redirectAs404")
+                .expect(c -> c == 200 || c == 404, "While adding to contact list").put();
         updateContactInfo();
     }
 
     @Override
     public void unauthorize() throws ConnectionException {
-        if (isAuthorized) {
-            Endpoints.UNAUTHORIZE_CONTACT_SELF
-                    .open(skype, this.username)
-                    .expect(200, "While unauthorizing contact")
-                    .put();
-        } else {
-            Endpoints.DECLINE_CONTACT_REQUEST
-                    .open(skype, this.username)
-                    .expect(201, "While unauthorizing contact")
-                    .put();
-        }
+
+        Endpoints.UNAUTHORIZE_CONTACT
+                .open(skype, skype.getUsername(), this.username)
+                .expect(200, "While anauthorizing contact")
+                .delete();
+        Endpoints.UNAUTHORIZE_CONTACT_SELF
+                .open(skype, this.username)
+                .expect(200, "While unauthorizing contact")
+                .delete();
         updateContactInfo();
     }
 
     @Override
-    public void sendRequest(String message) throws ConnectionException, NoSuchContactException {
-        Endpoints.AUTHORIZATION_REQUEST
-                .open(skype, this.username)
+    public void sendRequest(String message) throws ConnectionException {
+        JsonObject requestObject = new JsonObject();
+        requestObject
+                .add("mri", "8:" + this.username)
+                .add("greeting", Encoder.encode(message));
+        Endpoints.SEND_CONTACT_REQUEST
+                .open(skype, skype.getUsername())
                 .on(404, (connection) -> {
                     throw new NoSuchContactException();
                 })
                 .expect(201, "While sending request")
                 .expect(200, "While sending request")
-                .put("greeting=" + Encoder.encode(message));
+                .put(requestObject);
         updateContactInfo();
     }
 
diff --git a/src/main/java/com/samczsun/skype4j/internal/participants/info/ContactRequestImpl.java b/src/main/java/com/samczsun/skype4j/internal/participants/info/ContactRequestImpl.java
index d0763ec..01a57ad 100644
--- a/src/main/java/com/samczsun/skype4j/internal/participants/info/ContactRequestImpl.java
+++ b/src/main/java/com/samczsun/skype4j/internal/participants/info/ContactRequestImpl.java
@@ -20,9 +20,9 @@
 import com.samczsun.skype4j.internal.Endpoints;
 import com.samczsun.skype4j.internal.client.FullClient;
 import com.samczsun.skype4j.participants.info.Contact;
+import org.apache.commons.lang3.StringUtils;
 
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
+import java.time.Instant;
 import java.util.Date;
 
 public class ContactRequestImpl implements Contact.ContactRequest {
@@ -32,9 +32,8 @@
     private final String message;
     private final FullClient skype;
 
-    public ContactRequestImpl(String time, String sender, String message, FullClient skype) throws ParseException {
-        SimpleDateFormat FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSSSSS");
-        this.time = FORMAT.parse(time);
+    public ContactRequestImpl(String time, String sender, String message, FullClient skype) {
+        this.time = Date.from(Instant.parse(time));
         this.sender = sender;
         this.message = message;
         this.skype = skype;
@@ -58,17 +57,20 @@ public String getMessage() {
     @Override
     public void accept() throws ConnectionException {
         Endpoints.ACCEPT_CONTACT_REQUEST
-                .open(skype, sender)
-                .expect(201, "While accepting contact request")
+                .open(skype, skype.getUsername(), sender)
+                .expect(200, "While accepting contact request")
                 .put();
+        getSender().authorize();
     }
 
     @Override
     public void decline() throws ConnectionException {
         Endpoints.DECLINE_CONTACT_REQUEST
-                .open(skype, sender)
-                .expect(201, "While declining contact request")
+                .open(skype, skype.getUsername(), sender)
+                .expect(200, "While declining contact request")
                 .put();
+        Endpoints.UNAUTHORIZE_CONTACT_SELF.open(skype, StringUtils.prependIfMissing(sender, "8:"))
+                .expect(200, "While unauthorizing contact").delete();
     }
 
     @Override
diff --git a/src/main/java/com/samczsun/skype4j/internal/threads/ActiveThread.java b/src/main/java/com/samczsun/skype4j/internal/threads/ActiveThread.java
index 4b86cdf..7a7fc47 100644
--- a/src/main/java/com/samczsun/skype4j/internal/threads/ActiveThread.java
+++ b/src/main/java/com/samczsun/skype4j/internal/threads/ActiveThread.java
@@ -21,7 +21,9 @@
 import com.samczsun.skype4j.exceptions.handler.ErrorSource;
 import com.samczsun.skype4j.internal.Endpoints;
 import com.samczsun.skype4j.internal.SkypeImpl;
+import com.samczsun.skype4j.internal.Utils;
 
+import java.time.Duration;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -43,30 +45,36 @@ public ActiveThread(SkypeImpl skype, String endpoint) {
 
     public void run() {
         while (skype.isLoggedIn() && !stop.get()) {
-            if (skype.isAuthenticated() && !stop.get()) {
-                try {
-                    Endpoints.ACTIVE
-                            .open(skype, endpoint)
-                            .expect(201, "While submitting active in " + this.getName())
-                            .post(new JsonObject().add("timeout", 12));
-                } catch (ConnectionException e) {
-                    skype.handleError(ErrorSource.SESSION_ACTIVE, e, false);
-                }
-                if (stop.get()) {
-                    return;
-                }
-                try {
-                    Thread.sleep(12000);
-                } catch (InterruptedException ignored) {
-                }
-            } else {
+            if (!skype.isAuthenticated() || !skype.isRegistrationTokenValid()) {
                 return;
             }
+            try {
+                Endpoints.ACTIVE.open(skype, endpoint)
+                        .header("BehaviorOverride", "redirectAs404")
+                        .expect(201, "While submitting active in " + this.getName())
+                        .on(404, (connection) -> Endpoints
+                                .custom(Endpoints.ENDPOINTS_URL.url() + "/" + endpoint, skype)
+                                .expect(200, "While refreshing endpoint")
+                                .header("Authentication", "skypetoken=" + skype.getSkypeToken())
+                                .header("LockAndKey", Utils.generateChallengeHeader())
+                                .put(new JsonObject().add("endpointFeatures", "Agent")))
+                        .post(new JsonObject().add("timeout", 12));
+            } catch (ConnectionException e) {
+                skype.handleError(ErrorSource.SESSION_ACTIVE, e, false);
+            }
+            if (stop.get()) {
+                return;
+            }
+            try {
+                Thread.sleep(Duration.ofSeconds(12).toMillis());
+            } catch (InterruptedException ignored) {
+            }
         }
     }
 
     public void kill() {
         stop.set(true);
+        System.out.println("ActiveCheckThread is shutting down");
         this.interrupt();
     }
 }
diff --git a/src/main/java/com/samczsun/skype4j/internal/threads/AuthenticationChecker.java b/src/main/java/com/samczsun/skype4j/internal/threads/AuthenticationChecker.java
index e566766..4f8a9bb 100644
--- a/src/main/java/com/samczsun/skype4j/internal/threads/AuthenticationChecker.java
+++ b/src/main/java/com/samczsun/skype4j/internal/threads/AuthenticationChecker.java
@@ -19,6 +19,7 @@
 import com.samczsun.skype4j.exceptions.handler.ErrorSource;
 import com.samczsun.skype4j.internal.SkypeImpl;
 
+import java.time.Duration;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -37,13 +38,14 @@ public AuthenticationChecker(SkypeImpl skype) {
 
     public void run() {
         while (skype.isLoggedIn() && !stop.get()) {
-            long diff = (skype.getExpirationTime() - System.currentTimeMillis());
-            if (diff > 1800000) { //30 min
+
+            boolean tokensStillValid = skype.isAuthenticated() && skype.isRegistrationTokenValid();
+            if (tokensStillValid) {
                 if (stop.get()) {
                     return;
                 }
                 try {
-                    Thread.sleep(diff / 2);
+                    Thread.sleep(Duration.ofMinutes(10).toMillis());
                 } catch (InterruptedException ignored) {
                 }
             } else {
@@ -51,18 +53,17 @@ public void run() {
                     return;
                 }
                 try {
-                    skype.reauthenticate();
+                    skype.reAuthenticate();
                 } catch (Exception e) {
                     skype.handleError(ErrorSource.REAUTHENTICATING, e, true);
-                    //Don't see why you need to return in a finally block.
-                } finally {
-                    return;
                 }
+                return;
             }
         }
     }
 
     public void kill() {
         this.stop.set(true);
+        System.out.println("AuthenticationCheckerThread is shutting down");
     }
 }
diff --git a/src/main/java/com/samczsun/skype4j/internal/threads/PollThread.java b/src/main/java/com/samczsun/skype4j/internal/threads/PollThread.java
index 8222e53..a23a321 100644
--- a/src/main/java/com/samczsun/skype4j/internal/threads/PollThread.java
+++ b/src/main/java/com/samczsun/skype4j/internal/threads/PollThread.java
@@ -20,12 +20,8 @@
 import com.eclipsesource.json.JsonValue;
 import com.samczsun.skype4j.exceptions.ConnectionException;
 import com.samczsun.skype4j.exceptions.handler.ErrorSource;
-import com.samczsun.skype4j.internal.Endpoints;
-import com.samczsun.skype4j.internal.EventType;
-import com.samczsun.skype4j.internal.ExceptionHandler;
-import com.samczsun.skype4j.internal.SkypeImpl;
-import com.samczsun.skype4j.internal.SkypeThreadFactory;
-import com.samczsun.skype4j.internal.Utils;
+import com.samczsun.skype4j.internal.*;
+import com.samczsun.skype4j.internal.client.auth.SkypeRegistrationProvider;
 
 import java.io.IOException;
 import java.net.HttpURLConnection;
@@ -41,6 +37,7 @@
 
     private IOException pendingException;
     private HttpURLConnection connection;
+    private SkypeRegistrationProvider skypeRegistrationProvider;
 
     public PollThread(SkypeImpl skype, String endpointId) {
         super(String.format("Skype4J-Poller-%s", skype.getUsername()));
@@ -52,7 +49,7 @@ public PollThread(SkypeImpl skype, String endpointId) {
     public void run() {
         int pollId = 0;
         while (skype.isAuthenticated()) {
-            final Endpoints.EndpointConnection<HttpURLConnection> epconn = Endpoints.POLL
+            final EndpointConnection<HttpURLConnection> epconn = Endpoints.POLL
                     .open(skype, pollId)
                     .header("Content-Type", "application/json")
                     .dontConnect();
@@ -82,11 +79,13 @@ public void run() {
 
                     if (pendingException != null) {
                         skype.handleError(ErrorSource.POLLING_SKYPE, pendingException, false);
+                        pendingException = null;
                         continue;
                     }
 
                     if (connection.getHeaderField("Set-RegistrationToken") != null) {
-                        skype.setRegistrationToken(connection.getHeaderField("Set-RegistrationToken"));
+                        //needed as a Set-RegistrationToken comes really really often
+                        skype.getRegTokenProvider().setRegistrationToken(connection.getHeaderField("Set-RegistrationToken"));
                     }
 
                     if (connection.getResponseCode() == 403) {
@@ -104,7 +103,7 @@ public void run() {
                             }
                             String regtoken = conn.getHeaderField("Set-RegistrationToken");
                             if (regtoken != null) {
-                                skype.setRegistrationToken(regtoken);
+                                skype.getRegTokenProvider().setRegistrationToken(connection.getHeaderField("Set-RegistrationToken"));
                             }
                             JsonObject object = Utils.parseJsonObject(conn.getInputStream());
                             if (object.get("subscriptions") != null) {
diff --git a/src/main/java/com/samczsun/skype4j/internal/threads/ServerPingThread.java b/src/main/java/com/samczsun/skype4j/internal/threads/ServerPingThread.java
index ec2cddf..26b68cf 100644
--- a/src/main/java/com/samczsun/skype4j/internal/threads/ServerPingThread.java
+++ b/src/main/java/com/samczsun/skype4j/internal/threads/ServerPingThread.java
@@ -40,32 +40,31 @@ public ServerPingThread(SkypeImpl skype) {
 
     public void run() {
         while (skype.isLoggedIn() && !stop.get()) {
-            if (skype.isAuthenticated() && !stop.get()) {
-                try {
-                    Endpoints.PING_URL
-                            .open(skype)
-                            .expect(200, "While maintaining session")
-                            .header("Content-Type", "application/x-www-form-urlencoded")
-                            .cookies(skype.getCookies())
-                            .connect("POST", "sessionId=" + skype.getGuid().toString());
-                } catch (ConnectionException e) {
-                    skype.handleError(ErrorSource.SERVER_PING, e, false); // After reviewing source this appears correct
-                }
-                if (stop.get()) {
-                    return;
-                }
-                try {
-                    Thread.sleep(300000);
-                } catch (InterruptedException ignored) {
-                }
-            } else {
+            if (!skype.isAuthenticated() || stop.get()) {
                 return;
             }
+            try {
+                Endpoints.PING_URL.open(skype)
+                        .expect(200, "While maintaining session")
+                        .header("Content-Type", "application/x-www-form-urlencoded")
+                        .cookies(skype.getCookies())
+                        .connect("POST", "sessionId=" + skype.getGuid().toString());
+            } catch (ConnectionException e) {
+                skype.handleError(ErrorSource.SERVER_PING, e, false); // After reviewing source this appears correct
+            }
+            if (stop.get()) {
+                return;
+            }
+            try {
+                Thread.sleep(300000);
+            } catch (InterruptedException ignored) {
+            }
         }
     }
 
     public void kill() {
         this.stop.set(true);
+        System.out.println("ServerPingThread is shutting down");
         this.interrupt();
     }
 }
diff --git a/src/main/java/com/samczsun/skype4j/participants/User.java b/src/main/java/com/samczsun/skype4j/participants/User.java
index feb0787..2103bff 100644
--- a/src/main/java/com/samczsun/skype4j/participants/User.java
+++ b/src/main/java/com/samczsun/skype4j/participants/User.java
@@ -16,13 +16,11 @@
 
 package com.samczsun.skype4j.participants;
 
-import com.samczsun.skype4j.exceptions.ConnectionException;
-import com.samczsun.skype4j.exceptions.NoPermissionException;
 import com.samczsun.skype4j.participants.info.Contact;
 
 /**
  * Represents a user in a chat.
- *
+ * <p>
  * Multiple user instances may exist for a single contact
  */
 public interface User extends Participant {
diff --git a/src/main/java/com/samczsun/skype4j/participants/info/Contact.java b/src/main/java/com/samczsun/skype4j/participants/info/Contact.java
index eae199f..362a562 100644
--- a/src/main/java/com/samczsun/skype4j/participants/info/Contact.java
+++ b/src/main/java/com/samczsun/skype4j/participants/info/Contact.java
@@ -125,8 +125,9 @@
 
     /**
      * Send a authorization request to this user
+     *
      * @param message The message to attach
-     * @throws ConnectionException If an error occurs while sending the request
+     * @throws ConnectionException    If an error occurs while sending the request
      * @throws NoSuchContactException If the user does not exist
      */
     void sendRequest(String message) throws ConnectionException, NoSuchContactException;
@@ -162,8 +163,9 @@
 
     /**
      * Get the private conversation between you and this user
+     *
      * @return The private conversation
-     * @throws ConnectionException If an error occurs while connecting to the endpoint
+     * @throws ConnectionException   If an error occurs while connecting to the endpoint
      * @throws ChatNotFoundException If the contact does not exist or is a phone
      */
     Chat getPrivateConversation() throws ConnectionException, ChatNotFoundException;
diff --git a/src/test/java/com/samczsun/skype4j/FormattingTest.java b/src/test/java/com/samczsun/skype4j/FormattingTest.java
index 311f672..2f7d6dc 100644
--- a/src/test/java/com/samczsun/skype4j/FormattingTest.java
+++ b/src/test/java/com/samczsun/skype4j/FormattingTest.java
@@ -24,11 +24,11 @@ public void testParsing() {
                 .with(Text.rich("Underline").withUnderline())
                 .with(Text.rich("Black").withColor(Color.BLACK).withSize(10));
         String html = "Plain<b>Bold<i>Italic</i></b>" + Text.NEW_LINE +
-                      "<a href=\"http://google.com\">google</a>" +
-                      "<s>Strikethrough</s>" +
-                      "<blink>Blink</blink>" +
-                      "<u>Underline</u>" +
-                      "<font size=\"10\" color=\"#000000\">Black</font>";
+                "<a href=\"http://google.com\">google</a>" +
+                "<s>Strikethrough</s>" +
+                "<blink>Blink</blink>" +
+                "<u>Underline</u>" +
+                "<font size=\"10\" color=\"#000000\">Black</font>";
         Assert.assertEquals(message, Message.fromHtml(html));
     }
 
@@ -62,13 +62,13 @@ public void testBuilding() {
                 .with(Text.rich("Black").withColor(Color.BLACK).withSize(10));
 
         String html = "Plain" +
-                      "<b>Bold<i>Italic</i></b>" +
-                      Text.NEW_LINE +
-                      "<a href=\"http://google.com\">google</a>" +
-                      "<s>Strikethrough</s>" +
-                      "<blink>Blink</blink>" +
-                      "<u>Underline</u>" +
-                      "<font size=\"10\" color=\"#000000\">Black</font>";
+                "<b>Bold<i>Italic</i></b>" +
+                Text.NEW_LINE +
+                "<a href=\"http://google.com\">google</a>" +
+                "<s>Strikethrough</s>" +
+                "<blink>Blink</blink>" +
+                "<u>Underline</u>" +
+                "<font size=\"10\" color=\"#000000\">Black</font>";
         Assert.assertEquals(html, message.write());
     }
 }
diff --git a/src/test/java/com/samczsun/skype4j/StreamUtilsTest.java b/src/test/java/com/samczsun/skype4j/StreamUtilsTest.java
index 32d2fa1..13f5f73 100644
--- a/src/test/java/com/samczsun/skype4j/StreamUtilsTest.java
+++ b/src/test/java/com/samczsun/skype4j/StreamUtilsTest.java
@@ -2,7 +2,7 @@
 
 import com.samczsun.skype4j.internal.StreamUtils;
 import junit.framework.TestCase;
-import org.junit.*;
+import org.junit.Assert;
 
 import java.io.ByteArrayInputStream;
 
diff --git a/src/test/java/com/samczsun/skype4j/internal/chat/ChatImplTest.java b/src/test/java/com/samczsun/skype4j/internal/chat/ChatImplTest.java
new file mode 100644
index 0000000..7254e3c
--- /dev/null
+++ b/src/test/java/com/samczsun/skype4j/internal/chat/ChatImplTest.java
@@ -0,0 +1,44 @@
+package com.samczsun.skype4j.internal.chat;
+
+import com.samczsun.skype4j.LiveLoginSkypeBuilder;
+import com.samczsun.skype4j.Skype;
+import com.samczsun.skype4j.chat.Chat;
+import com.samczsun.skype4j.chat.messages.ChatMessage;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.List;
+import java.util.logging.Logger;
+
+import static org.junit.Assert.assertFalse;
+
+public class ChatImplTest {
+    private static final Logger logger = Logger.getLogger(Skype.class.getCanonicalName());
+    Skype skype = new LiveLoginSkypeBuilder("a.semennikov@argustelecom.ru", "HellSkype3Bot").withAllResources()
+            .withLogger(logger).build();
+
+    @Before
+    public void setUp() throws Exception {
+        skype.login();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        skype.logout();
+    }
+
+    @Test
+    public void loadMoreMessages() throws Exception {
+        Chat chat = skype.getOrLoadChat("8:alexey.semennikov");
+        List<ChatMessage> messages = chat.loadMoreMessages(10);
+        // in order to test this, send new message from this chat.
+        chat.sendMessage("testing messages 1");
+        List<ChatMessage> nextMessages = chat.loadMoreMessages(10);
+        assertFalse(messages.isEmpty());
+        assertFalse(nextMessages.isEmpty());
+        // assertThat(messages.size(), equalTo(2));
+        // assertThat(nextMessages.size(), equalTo(1));
+    }
+
+}
\ No newline at end of file
