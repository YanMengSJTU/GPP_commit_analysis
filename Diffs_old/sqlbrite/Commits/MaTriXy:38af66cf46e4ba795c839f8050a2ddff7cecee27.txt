diff --git a/.travis.yml b/.travis.yml
index 2a9f665..0f31d94 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -4,14 +4,30 @@ android:
   components:
     - tools
     - platform-tools
-    - build-tools-25.0.1
-    - extra-android-m2repository
-    - android-25
-    - sys-img-armeabi-v7a-android-23
 
 jdk:
   - oraclejdk8
 
+before_install:
+  # Install SDK license so Android Gradle plugin can install deps.
+  - mkdir "$ANDROID_HOME/licenses" || true
+  - echo "d56f5187479451eabf01fb78af6dfcb131a6481e" > "$ANDROID_HOME/licenses/android-sdk-license"
+  # Install the rest of tools (e.g., avdmanager)
+  - sdkmanager tools
+  # Install the system image
+  - sdkmanager "system-images;android-18;default;armeabi-v7a"
+  # Create and start emulator for the script. Meant to race the install task.
+  - echo no | avdmanager create avd --force -n test -k "system-images;android-18;default;armeabi-v7a"
+  - $ANDROID_HOME/emulator/emulator -avd test -no-audio -no-window &
+
+install: ./gradlew clean assemble assembleAndroidTest --stacktrace
+
+before_script:
+  - android-wait-for-emulator
+  - adb shell input keyevent 82
+
+script: ./gradlew check connectedCheck --stacktrace
+
 after_success:
   - .buildscript/deploy_snapshot.sh
 
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 69b2aa6..fa5449b 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,52 @@
 Change Log
 ==========
 
+Version 3.1.0 *(2017-12-18)*
+----------------------------
+
+ * New: `inTransaction` Kotlin extension function which handles starting, marking successful, and ending
+   a transaction.
+ * New: Embedded lint check which validates the number of arguments passed to `query` and `createQuery`
+   match the number of expected arguments of the SQL statement.
+ * Fix: Properly indent multi-line SQL statements in the logs for `query`.
+
+
+Version 3.0.0 *(2017-11-28)*
+----------------------------
+
+Group ID has changed to `com.squareup.sqlbrite3`.
+
+ * New: Build on top of the Android architecture components Sqlite support library. This allows swapping
+   out the underlying Sqlite implementation to that of your choosing.
+
+Because of the way the Sqlite support library works, there is no interop bridge between 1.x or 2.x to
+this new version. If you haven't fully migrated to 2.x, complete that migration first and then upgrade
+to 3.x all at once.
+
+
+Version 2.0.0 *(2017-07-07)*
+----------------------------
+
+Group ID has changed to `com.squareup.sqlbrite2`.
+
+ * New: RxJava 2.x support. Backpressure is no longer supported as evidenced by the use of
+   `Observable`. If you want to slow down query notifications based on backpressure or another metric
+   like time then you should apply those operators yourself.
+ * New: `mapToOptional` for queries that return 0 or 1 rows.
+ * New: `sqlbrite-kotlin` module provides `mapTo*` extension functions for `Observable<Query>`.
+ * New: `sqlbrite-interop` module allows bridging 1.x and 2.x libraries together so that notifications
+   from each trigger queries from the other.
+
+Note: This version only supports RxJava 2.
+
+
+Version 1.1.2 *(2017-06-30)*
+----------------------------
+
+ * Internal architecture changes to support the upcoming 2.0 release and a bridge allowing both 1.x
+   and 2.x to be used at the same time.
+
+
 Version 1.1.1 *(2016-12-20)*
 ----------------------------
 
diff --git a/README.md b/README.md
index d7c6b89..6194eeb 100755
--- a/README.md
+++ b/README.md
@@ -1,7 +1,7 @@
-SQLBrite
-========
+SQL Brite
+=========
 
-A lightweight wrapper around `SQLiteOpenHelper` and `ContentResolver` which introduces reactive
+A lightweight wrapper around `SupportSQLiteOpenHelper` and `ContentResolver` which introduces reactive
 stream semantics to queries.
 
 
@@ -15,7 +15,7 @@ Create a `SqlBrite` instance which is an adapter for the library functionality.
 SqlBrite sqlBrite = new SqlBrite.Builder().build();
 ```
 
-Pass a `SQLiteOpenHelper` instance and a `Scheduler` to create a `BriteDatabase`.
+Pass a `SupportSQLiteOpenHelper` instance and a `Scheduler` to create a `BriteDatabase`.
 
 ```java
 BriteDatabase db = sqlBrite.wrapDatabaseHelper(openHelper, Schedulers.io());
@@ -25,7 +25,7 @@ A `Scheduler` is required for a few reasons, but the most important is that quer
 trigger on the thread of your choice. The query can then be run without blocking the main thread or
 the thread which caused the trigger.
 
-The `BriteDatabase.createQuery` method is similar to `SQLiteDatabase.rawQuery` except it takes an
+The `BriteDatabase.createQuery` method is similar to `SupportSQLiteDatabase.query` except it takes an
 additional parameter of table(s) on which to listen for changes. Subscribe to the returned
 `Observable<Query>` which will immediately notify with a `Query` to run.
 
@@ -39,7 +39,7 @@ users.subscribe(new Action1<Query>() {
 });
 ```
 
-Unlike a traditional `rawQuery`, updates to the specified table(s) will trigger additional
+Unlike a traditional `query`, updates to the specified table(s) will trigger additional
 notifications for as long as you remain subscribed to the observable. This means that when you
 insert, update, or delete data, any subscribed queries will update with the new data instantly.
 
@@ -134,13 +134,13 @@ number of queries and data changes.
 Philosophy
 ----------
 
-SqlBrite's only responsibility is to be a mechanism for coordinating and composing the notification
+SQL Brite's only responsibility is to be a mechanism for coordinating and composing the notification
 of updates to tables such that you can update queries as soon as data changes.
 
 This library is not an ORM. It is not a type-safe query mechanism. It won't serialize the same POJOs
 you use for Gson. It's not going to perform database migrations for you.
 
-Some of these features are offered by [SQLDelight][sqldelight] which can be used with SQLBrite.
+Some of these features are offered by [SQL Delight][sqldelight] which can be used with SQL Brite.
 
 
 
@@ -148,9 +148,15 @@ Download
 --------
 
 ```groovy
-compile 'com.squareup.sqlbrite:sqlbrite:1.1.1'
+compile 'com.squareup.sqlbrite3:sqlbrite:3.1.0'
 ```
 
+For the 'kotlin' module that adds extension functions to `Observable<Query>`:
+```groovy
+compile 'com.squareup.sqlbrite3:sqlbrite-kotlin:3.1.0'
+```
+
+
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
 
diff --git a/RELEASING.md b/RELEASING.md
index 591e3a8..e037672 100644
--- a/RELEASING.md
+++ b/RELEASING.md
@@ -1,13 +1,13 @@
 Releasing
 ========
 
- 1. Change the version in `gradle.properties` to a non-SNAPSHOT verson.
+ 1. Change the version in `gradle.properties` to a non-SNAPSHOT version.
  2. Update the `CHANGELOG.md` for the impending release.
  3. Update the `README.md` with the new version.
  4. `git commit -am "Prepare for release X.Y.Z."` (where X.Y.Z is the new version)
  5. `./gradlew clean uploadArchives`.
  6. Visit [Sonatype Nexus](https://oss.sonatype.org/) and promote the artifact.
- 7. `git tag -a X.Y.X -m "Version X.Y.Z"` (where X.Y.Z is the new version)
+ 7. `git tag -a X.Y.Z -m "Version X.Y.Z"` (where X.Y.Z is the new version)
  8. Update the `gradle.properties` to the next SNAPSHOT version.
  9. `git commit -am "Prepare next development version."`
  10. `git push && git push --tags`
diff --git a/build.gradle b/build.gradle
index 483e1e9..a0bb673 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,42 +1,62 @@
-allprojects {
-  buildscript {
-    repositories {
-      mavenCentral()
-      jcenter()
-    }
+buildscript {
+  ext.versions = [
+      'minSdk': 14,
+      'compileSdk': 27,
+      'kotlin': '1.1.60',
+      'lint': '26.0.1'
+  ]
+
+  repositories {
+    mavenCentral()
+    google()
+    jcenter()
   }
 
+  dependencies {
+    classpath 'com.android.tools.build:gradle:3.0.1'
+    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:${versions.kotlin}"
+  }
+}
+
+allprojects {
   repositories {
     mavenCentral()
+    google()
+    jcenter()
   }
+
+  group = GROUP
+  version = VERSION_NAME
 }
 
 ext {
-  androidPlugin = 'com.android.tools.build:gradle:2.2.2'
-  compileSdkVersion = 25
-  buildToolsVersion = '25.0.1'
-
   // Android dependencies.
-  supportV4 = 'com.android.support:support-v4:25.0.1'
-  supportAnnotations = 'com.android.support:support-annotations:25.0.1'
+  supportV4 = 'com.android.support:support-v4:27.0.0'
+  supportAnnotations = 'com.android.support:support-annotations:27.0.0'
   supportTestRunner = 'com.android.support.test:runner:0.5'
 
-  // Dagger dependencies.
-  dagger = 'com.google.dagger:dagger:2.8'
-  daggerCompiler = 'com.google.dagger:dagger-compiler:2.8'
+  supportSqlite = 'android.arch.persistence:db:1.0.0'
+  supportSqliteFramework = 'android.arch.persistence:db-framework:1.0.0'
 
   // Third-party dependencies.
-  butterKnifeRuntime = 'com.jakewharton:butterknife:8.4.0'
-  butterKnifeCompiler = 'com.jakewharton:butterknife-compiler:8.4.0'
-  timber = 'com.jakewharton.timber:timber:4.3.1'
-  autoValue = 'com.google.auto.value:auto-value:1.3'
+  kotlinStdLib = "org.jetbrains.kotlin:kotlin-stdlib:${versions.kotlin}"
+  dagger = 'com.google.dagger:dagger:2.13'
+  daggerCompiler = 'com.google.dagger:dagger-compiler:2.13'
+  butterKnifeRuntime = 'com.jakewharton:butterknife:8.8.1'
+  butterKnifeCompiler = 'com.jakewharton:butterknife-compiler:8.8.1'
+  timber = 'com.jakewharton.timber:timber:4.6.0'
+  autoValue = 'com.google.auto.value:auto-value:1.5'
   autoValueParcel = 'com.ryanharter.auto.value:auto-value-parcel:0.2.5'
-  rxJava = 'io.reactivex:rxjava:1.2.3'
-  rxAndroid = 'io.reactivex:rxandroid:1.2.1'
-  rxBinding = 'com.jakewharton.rxbinding:rxbinding:0.4.0'
-  truth = 'com.google.truth:truth:0.30'
-  findbugsJsr305 = 'com.google.code.findbugs:jsr305:3.0.0'
-  findbugsAnnotations = 'com.google.code.findbugs:annotations:3.0.0'
+  rxJava = 'io.reactivex.rxjava2:rxjava:2.1.3'
+  rxAndroid = 'io.reactivex.rxjava2:rxandroid:2.0.1'
+  rxBinding = 'com.jakewharton.rxbinding2:rxbinding:2.0.0'
+  junit = 'junit:junit:4.12'
+  truth = 'com.google.truth:truth:0.36'
+
+  // Lint dependencies.
+  lintApi = "com.android.tools.lint:lint-api:${versions.lint}"
+  lint = "com.android.tools.lint:lint:${versions.lint}"
+  lintTests = "com.android.tools.lint:lint-tests:${versions.lint}"
 }
 
 configurations {
@@ -45,7 +65,7 @@ configurations {
 dependencies {
   osstrich 'com.squareup.osstrich:osstrich:1.2.0'
 }
-task publishJavadoc(type: JavaExec) {
+task publishV1Javadoc(type: JavaExec) {
   classpath = configurations.osstrich
   main = 'com.squareup.osstrich.JavadocPublisher'
   args = [
@@ -54,3 +74,22 @@ task publishJavadoc(type: JavaExec) {
       'com.squareup.sqlbrite'
   ]
 }
+task publishV2Javadoc(type: JavaExec) {
+  classpath = configurations.osstrich
+  main = 'com.squareup.osstrich.JavadocPublisher'
+  args = [
+      'build/javadoc',
+      'https://github.com/square/sqlbrite',
+      'com.squareup.sqlbrite2'
+  ]
+}
+task publishV3Javadoc(type: JavaExec) {
+  classpath = configurations.osstrich
+  main = 'com.squareup.osstrich.JavadocPublisher'
+  args = [
+      'build/javadoc',
+      'https://github.com/square/sqlbrite',
+      'com.squareup.sqlbrite3'
+  ]
+}
+task publishJavadoc(dependsOn: [publishV1Javadoc, publishV2Javadoc, publishV3Javadoc])
diff --git a/gradle.properties b/gradle.properties
index fbfb802..dd6e56b 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,5 +1,5 @@
-GROUP=com.squareup.sqlbrite
-VERSION_NAME=1.1.2-SNAPSHOT
+GROUP=com.squareup.sqlbrite3
+VERSION_NAME=3.1.1-SNAPSHOT
 
 POM_DESCRIPTION=A lightweight wrapper around SQLiteOpenHelper which introduces reactive stream semantics to SQL operations.
 
diff --git a/gradle/android-findbugs.gradle b/gradle/android-findbugs.gradle
deleted file mode 100644
index af3dc1f..0000000
--- a/gradle/android-findbugs.gradle
+++ /dev/null
@@ -1,34 +0,0 @@
-apply plugin: 'findbugs'
-
-afterEvaluate {
-  def variants = plugins.hasPlugin('com.android.application') ?
-      android.applicationVariants : android.libraryVariants
-
-  variants.each { variant ->
-    def task = tasks.create("findBugs${variant.name.capitalize()}", FindBugs)
-
-    task.group = 'verification'
-    task.description = "Run FindBugs for the ${variant.description}."
-
-    task.effort = 'max'
-
-    task.reportLevel = 'high'
-    task.reports {
-      xml {
-        enabled = false
-      }
-      html {
-        enabled = true
-      }
-    }
-
-    def variantCompile = variant.javaCompile
-
-    task.classes = fileTree(variantCompile.destinationDir)
-    task.source = variantCompile.source
-    task.classpath = variantCompile.classpath.plus(project.files(android.bootClasspath))
-
-    task.dependsOn(variantCompile)
-    tasks.getByName('check').dependsOn(task)
-  }
-}
diff --git a/gradle/gradle-mvn-push.gradle b/gradle/gradle-mvn-push.gradle
index 3376aba..a0c8b17 100644
--- a/gradle/gradle-mvn-push.gradle
+++ b/gradle/gradle-mvn-push.gradle
@@ -83,15 +83,13 @@ afterEvaluate { project ->
     }
 
     task androidJavadocs(type: Javadoc) {
-        source = android.sourceSets.main.java.srcDirs
+        if (!project.plugins.hasPlugin('kotlin-android')) {
+            source = android.sourceSets.main.java.srcDirs
+        }
         classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
 
         if (JavaVersion.current().isJava8Compatible()) {
-            allprojects {
-                tasks.withType(Javadoc) {
-                    options.addStringOption('Xdoclint:none', '-quiet')
-                }
-            }
+            options.addStringOption('Xdoclint:none', '-quiet')
         }
     }
 
diff --git a/gradle/start-emulator.sh b/gradle/start-emulator.sh
deleted file mode 100755
index ca0f828..0000000
--- a/gradle/start-emulator.sh
+++ /dev/null
@@ -1,8 +0,0 @@
-#!/bin/bash
-
-set -ex
-
-echo no | android create avd --force -n test -t android-18 --abi armeabi-v7a
-emulator -avd test -no-skin -no-audio -no-window &
-android-wait-for-emulator
-adb shell input keyevent 82
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 667288a..01b8bf6 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 224f727..b6517bb 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Wed Nov 26 14:54:50 EST 2014
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip
diff --git a/gradlew b/gradlew
index 91a7e26..cccdd3d 100755
--- a/gradlew
+++ b/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -6,20 +6,38 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,31 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -90,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
@@ -114,6 +113,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
@@ -154,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+exec "$JAVACMD" "$@"
diff --git a/sample/build.gradle b/sample/build.gradle
index 32ce65c..02bb0e7 100644
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -1,47 +1,29 @@
-buildscript {
-  dependencies {
-    classpath rootProject.ext.androidPlugin
-  }
-}
-
 apply plugin: 'com.android.application'
-apply from: rootProject.file('gradle/android-findbugs.gradle')
 
 dependencies {
-  // Android dependencies.
-  compile rootProject.ext.supportV4
-  compile rootProject.ext.supportAnnotations
+  implementation rootProject.ext.supportV4
+  implementation rootProject.ext.supportAnnotations
 
-  // Dagger dependencies.
-  compile rootProject.ext.dagger
+  implementation rootProject.ext.dagger
   annotationProcessor rootProject.ext.daggerCompiler
 
-  // Third-party dependencies.
-  compile rootProject.ext.butterKnifeRuntime
+  implementation rootProject.ext.butterKnifeRuntime
   annotationProcessor rootProject.ext.butterKnifeCompiler
-  compile rootProject.ext.timber
-  compile rootProject.ext.rxJava
-  compile rootProject.ext.rxAndroid
-  compile rootProject.ext.rxBinding
+  implementation rootProject.ext.timber
+  implementation rootProject.ext.rxJava
+  implementation rootProject.ext.rxAndroid
+  implementation rootProject.ext.rxBinding
 
-  provided rootProject.ext.autoValue
+  compileOnly rootProject.ext.autoValue
   annotationProcessor rootProject.ext.autoValue
   annotationProcessor rootProject.ext.autoValueParcel
 
-  provided rootProject.ext.findbugsJsr305
-  provided rootProject.ext.findbugsAnnotations
-
-  // In-repo dependencies.
-  compile project(':sqlbrite')
-}
-
-def isCi() {
-  return "true".equals(System.getenv('CI'))
+  implementation project(':sqlbrite')
+  implementation rootProject.ext.supportSqliteFramework
 }
 
 android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
+  compileSdkVersion versions.compileSdk
 
   compileOptions {
     sourceCompatibility JavaVersion.VERSION_1_7
@@ -54,13 +36,9 @@ android {
     ignore 'InvalidPackage' // Provided AutoValue pulls in Guava and friends. Doesn't end up in APK.
   }
 
-  dexOptions {
-    preDexLibraries = !isCi()
-  }
-
   defaultConfig {
-    minSdkVersion 14
-    targetSdkVersion 23
+    minSdkVersion versions.minSdk
+    targetSdkVersion versions.compileSdk
     applicationId 'com.example.sqlbrite.todo'
 
     versionCode 1
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/db/DbOpenHelper.java b/sample/src/main/java/com/example/sqlbrite/todo/db/DbCallback.java
similarity index 65%
rename from sample/src/main/java/com/example/sqlbrite/todo/db/DbOpenHelper.java
rename to sample/src/main/java/com/example/sqlbrite/todo/db/DbCallback.java
index 4ee73fd..a69d920 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/db/DbOpenHelper.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/db/DbCallback.java
@@ -15,11 +15,15 @@
  */
 package com.example.sqlbrite.todo.db;
 
+import android.arch.persistence.db.SupportSQLiteDatabase;
+import android.arch.persistence.db.SupportSQLiteOpenHelper;
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
 
-final class DbOpenHelper extends SQLiteOpenHelper {
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_FAIL;
+
+final class DbCallback extends SupportSQLiteOpenHelper.Callback {
   private static final int VERSION = 1;
 
   private static final String CREATE_LIST = ""
@@ -38,78 +42,78 @@
   private static final String CREATE_ITEM_LIST_ID_INDEX =
       "CREATE INDEX item_list_id ON " + TodoItem.TABLE + " (" + TodoItem.LIST_ID + ")";
 
-  public DbOpenHelper(Context context) {
-    super(context, "todo.db", null /* factory */, VERSION);
+  DbCallback() {
+    super(VERSION);
   }
 
-  @Override public void onCreate(SQLiteDatabase db) {
+  @Override public void onCreate(SupportSQLiteDatabase db) {
     db.execSQL(CREATE_LIST);
     db.execSQL(CREATE_ITEM);
     db.execSQL(CREATE_ITEM_LIST_ID_INDEX);
 
-    long groceryListId = db.insert(TodoList.TABLE, null, new TodoList.Builder()
+    long groceryListId = db.insert(TodoList.TABLE, CONFLICT_FAIL, new TodoList.Builder()
         .name("Grocery List")
         .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+    db.insert(TodoItem.TABLE, CONFLICT_FAIL, new TodoItem.Builder()
         .listId(groceryListId)
         .description("Beer")
         .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+    db.insert(TodoItem.TABLE, CONFLICT_FAIL, new TodoItem.Builder()
         .listId(groceryListId)
         .description("Point Break on DVD")
         .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+    db.insert(TodoItem.TABLE, CONFLICT_FAIL, new TodoItem.Builder()
         .listId(groceryListId)
         .description("Bad Boys 2 on DVD")
         .build());
 
-    long holidayPresentsListId = db.insert(TodoList.TABLE, null, new TodoList.Builder()
+    long holidayPresentsListId = db.insert(TodoList.TABLE, CONFLICT_FAIL, new TodoList.Builder()
         .name("Holiday Presents")
         .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+    db.insert(TodoItem.TABLE, CONFLICT_FAIL, new TodoItem.Builder()
         .listId(holidayPresentsListId)
         .description("Pogo Stick for Jake W.")
         .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+    db.insert(TodoItem.TABLE, CONFLICT_FAIL, new TodoItem.Builder()
         .listId(holidayPresentsListId)
         .description("Jack-in-the-box for Alec S.")
         .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+    db.insert(TodoItem.TABLE, CONFLICT_FAIL, new TodoItem.Builder()
         .listId(holidayPresentsListId)
         .description("Pogs for Matt P.")
         .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+    db.insert(TodoItem.TABLE, CONFLICT_FAIL, new TodoItem.Builder()
         .listId(holidayPresentsListId)
         .description("Cola for Jesse W.")
         .build());
 
-    long workListId = db.insert(TodoList.TABLE, null, new TodoList.Builder()
+    long workListId = db.insert(TodoList.TABLE, CONFLICT_FAIL, new TodoList.Builder()
         .name("Work Items")
         .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+    db.insert(TodoItem.TABLE, CONFLICT_FAIL, new TodoItem.Builder()
         .listId(workListId)
         .description("Finish SqlBrite library")
         .complete(true)
         .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+    db.insert(TodoItem.TABLE, CONFLICT_FAIL, new TodoItem.Builder()
         .listId(workListId)
         .description("Finish SqlBrite sample app")
         .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+    db.insert(TodoItem.TABLE, CONFLICT_FAIL, new TodoItem.Builder()
         .listId(workListId)
         .description("Publish SqlBrite to GitHub")
         .build());
 
-    long birthdayPresentsListId = db.insert(TodoList.TABLE, null, new TodoList.Builder()
+    long birthdayPresentsListId = db.insert(TodoList.TABLE, CONFLICT_FAIL, new TodoList.Builder()
         .name("Birthday Presents")
         .archived(true)
         .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder().listId(birthdayPresentsListId)
+    db.insert(TodoItem.TABLE, CONFLICT_FAIL, new TodoItem.Builder().listId(birthdayPresentsListId)
         .description("New car")
         .complete(true)
         .build());
   }
 
-  @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+  @Override public void onUpgrade(SupportSQLiteDatabase db, int oldVersion, int newVersion) {
   }
 }
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java b/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
index 2147fdd..c2701fe 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
@@ -16,30 +16,37 @@
 package com.example.sqlbrite.todo.db;
 
 import android.app.Application;
-import android.database.sqlite.SQLiteOpenHelper;
-import com.squareup.sqlbrite.BriteDatabase;
-import com.squareup.sqlbrite.SqlBrite;
+import android.arch.persistence.db.SupportSQLiteOpenHelper;
+import android.arch.persistence.db.SupportSQLiteOpenHelper.Configuration;
+import android.arch.persistence.db.SupportSQLiteOpenHelper.Factory;
+import android.arch.persistence.db.framework.FrameworkSQLiteOpenHelperFactory;
+import com.squareup.sqlbrite3.BriteDatabase;
+import com.squareup.sqlbrite3.SqlBrite;
 import dagger.Module;
 import dagger.Provides;
+import io.reactivex.schedulers.Schedulers;
 import javax.inject.Singleton;
-import rx.schedulers.Schedulers;
 import timber.log.Timber;
 
 @Module
 public final class DbModule {
-  @Provides @Singleton SQLiteOpenHelper provideOpenHelper(Application application) {
-    return new DbOpenHelper(application);
-  }
-
   @Provides @Singleton SqlBrite provideSqlBrite() {
-    return SqlBrite.create(new SqlBrite.Logger() {
-      @Override public void log(String message) {
-        Timber.tag("Database").v(message);
-      }
-    });
+    return new SqlBrite.Builder()
+        .logger(new SqlBrite.Logger() {
+          @Override public void log(String message) {
+            Timber.tag("Database").v(message);
+          }
+        })
+        .build();
   }
 
-  @Provides @Singleton BriteDatabase provideDatabase(SqlBrite sqlBrite, SQLiteOpenHelper helper) {
+  @Provides @Singleton BriteDatabase provideDatabase(SqlBrite sqlBrite, Application application) {
+    Configuration configuration = Configuration.builder(application)
+        .name("todo.db")
+        .callback(new DbCallback())
+        .build();
+    Factory factory = new FrameworkSQLiteOpenHelperFactory();
+    SupportSQLiteOpenHelper helper = factory.create(configuration);
     BriteDatabase db = sqlBrite.wrapDatabaseHelper(helper, Schedulers.io());
     db.setLoggingEnabled(true);
     return db;
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java b/sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
index 865328b..a40771f 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
@@ -19,7 +19,7 @@
 import android.database.Cursor;
 import android.os.Parcelable;
 import com.google.auto.value.AutoValue;
-import rx.functions.Func1;
+import io.reactivex.functions.Function;
 
 @AutoValue
 public abstract class TodoItem implements Parcelable {
@@ -35,8 +35,8 @@
   public abstract String description();
   public abstract boolean complete();
 
-  public static final Func1<Cursor, TodoItem> MAPPER = new Func1<Cursor, TodoItem>() {
-    @Override public TodoItem call(Cursor cursor) {
+  public static final Function<Cursor, TodoItem> MAPPER = new Function<Cursor, TodoItem>() {
+    @Override public TodoItem apply(Cursor cursor) {
       long id = Db.getLong(cursor, ID);
       long listId = Db.getLong(cursor, LIST_ID);
       String description = Db.getString(cursor, DESCRIPTION);
@@ -64,7 +64,7 @@ public Builder description(String description) {
     }
 
     public Builder complete(boolean complete) {
-      values.put(COMPLETE, complete);
+      values.put(COMPLETE, complete ? Db.BOOLEAN_TRUE : Db.BOOLEAN_FALSE);
       return this;
     }
 
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java b/sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java
index 12e3f91..8d60760 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java
@@ -16,12 +16,8 @@
 package com.example.sqlbrite.todo.db;
 
 import android.content.ContentValues;
-import android.database.Cursor;
 import android.os.Parcelable;
 import com.google.auto.value.AutoValue;
-import java.util.ArrayList;
-import java.util.List;
-import rx.functions.Func1;
 
 // Note: normally I wouldn't prefix table classes but I didn't want 'List' to be overloaded.
 @AutoValue
@@ -36,24 +32,6 @@
   public abstract String name();
   public abstract boolean archived();
 
-  public static Func1<Cursor, List<TodoList>> MAP = new Func1<Cursor, List<TodoList>>() {
-    @Override public List<TodoList> call(final Cursor cursor) {
-      try {
-        List<TodoList> values = new ArrayList<>(cursor.getCount());
-
-        while (cursor.moveToNext()) {
-          long id = Db.getLong(cursor, ID);
-          String name = Db.getString(cursor, NAME);
-          boolean archived = Db.getBoolean(cursor, ARCHIVED);
-          values.add(new AutoValue_TodoList(id, name, archived));
-        }
-        return values;
-      } finally {
-        cursor.close();
-      }
-    }
-  };
-
   public static final class Builder {
     private final ContentValues values = new ContentValues();
 
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsAdapter.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsAdapter.java
index 22ccff4..d22ecdd 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsAdapter.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsAdapter.java
@@ -24,11 +24,11 @@
 import android.widget.BaseAdapter;
 import android.widget.CheckedTextView;
 import com.example.sqlbrite.todo.db.TodoItem;
+import io.reactivex.functions.Consumer;
 import java.util.Collections;
 import java.util.List;
-import rx.functions.Action1;
 
-final class ItemsAdapter extends BaseAdapter implements Action1<List<TodoItem>> {
+final class ItemsAdapter extends BaseAdapter implements Consumer<List<TodoItem>> {
   private final LayoutInflater inflater;
 
   private List<TodoItem> items = Collections.emptyList();
@@ -37,7 +37,7 @@ public ItemsAdapter(Context context) {
     inflater = LayoutInflater.from(context);
   }
 
-  @Override public void call(List<TodoItem> items) {
+  @Override public void accept(List<TodoItem> items) {
     this.items = items;
     notifyDataSetChanged();
   }
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
index b64a2fe..6e39d27 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
@@ -35,21 +35,22 @@
 import com.example.sqlbrite.todo.db.Db;
 import com.example.sqlbrite.todo.db.TodoItem;
 import com.example.sqlbrite.todo.db.TodoList;
-import com.jakewharton.rxbinding.widget.AdapterViewItemClickEvent;
-import com.jakewharton.rxbinding.widget.RxAdapterView;
-import com.squareup.sqlbrite.BriteDatabase;
+import com.jakewharton.rxbinding2.widget.AdapterViewItemClickEvent;
+import com.jakewharton.rxbinding2.widget.RxAdapterView;
+import com.squareup.sqlbrite3.BriteDatabase;
+import io.reactivex.Observable;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.disposables.CompositeDisposable;
+import io.reactivex.functions.BiFunction;
+import io.reactivex.functions.Consumer;
+import io.reactivex.functions.Function;
+import io.reactivex.schedulers.Schedulers;
 import javax.inject.Inject;
-import rx.Observable;
-import rx.android.schedulers.AndroidSchedulers;
-import rx.functions.Action1;
-import rx.functions.Func1;
-import rx.functions.Func2;
-import rx.schedulers.Schedulers;
-import rx.subscriptions.CompositeSubscription;
 
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_NONE;
 import static android.support.v4.view.MenuItemCompat.SHOW_AS_ACTION_IF_ROOM;
 import static android.support.v4.view.MenuItemCompat.SHOW_AS_ACTION_WITH_TEXT;
-import static com.squareup.sqlbrite.SqlBrite.Query;
+import static com.squareup.sqlbrite3.SqlBrite.Query;
 
 public final class ItemsFragment extends Fragment {
   private static final String KEY_LIST_ID = "list_id";
@@ -92,7 +93,7 @@ public static ItemsFragment newInstance(long listId) {
 
   private Listener listener;
   private ItemsAdapter adapter;
-  private CompositeSubscription subscriptions;
+  private CompositeDisposable disposables;
 
   private long getListId() {
     return getArguments().getLong(KEY_LIST_ID);
@@ -138,11 +139,12 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
 
     RxAdapterView.itemClickEvents(listView) //
         .observeOn(Schedulers.io())
-        .subscribe(new Action1<AdapterViewItemClickEvent>() {
-          @Override public void call(AdapterViewItemClickEvent event) {
+        .subscribe(new Consumer<AdapterViewItemClickEvent>() {
+          @Override public void accept(AdapterViewItemClickEvent event) {
             boolean newValue = !adapter.getItem(event.position()).complete();
-            db.update(TodoItem.TABLE, new TodoItem.Builder().complete(newValue).build(),
-                TodoItem.ID + " = ?", String.valueOf(event.id()));
+            db.update(TodoItem.TABLE, CONFLICT_NONE,
+                new TodoItem.Builder().complete(newValue).build(), TodoItem.ID + " = ?",
+                String.valueOf(event.id()));
           }
         });
   }
@@ -151,11 +153,11 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
     super.onResume();
     String listId = String.valueOf(getListId());
 
-    subscriptions = new CompositeSubscription();
+    disposables = new CompositeDisposable();
 
     Observable<Integer> itemCount = db.createQuery(TodoItem.TABLE, COUNT_QUERY, listId) //
-        .map(new Func1<Query, Integer>() {
-          @Override public Integer call(Query query) {
+        .map(new Function<Query, Integer>() {
+          @Override public Integer apply(Query query) {
             Cursor cursor = query.run();
             try {
               if (!cursor.moveToNext()) {
@@ -168,8 +170,8 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
           }
         });
     Observable<String> listName =
-        db.createQuery(TodoList.TABLE, TITLE_QUERY, listId).map(new Func1<Query, String>() {
-          @Override public String call(Query query) {
+        db.createQuery(TodoList.TABLE, TITLE_QUERY, listId).map(new Function<Query, String>() {
+          @Override public String apply(Query query) {
             Cursor cursor = query.run();
             try {
               if (!cursor.moveToNext()) {
@@ -181,20 +183,20 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
             }
           }
         });
-    subscriptions.add(
-        Observable.combineLatest(listName, itemCount, new Func2<String, Integer, String>() {
-          @Override public String call(String listName, Integer itemCount) {
+    disposables.add(
+        Observable.combineLatest(listName, itemCount, new BiFunction<String, Integer, String>() {
+          @Override public String apply(String listName, Integer itemCount) {
             return listName + " (" + itemCount + ")";
           }
         })
             .observeOn(AndroidSchedulers.mainThread())
-            .subscribe(new Action1<String>() {
-              @Override public void call(String title) {
+            .subscribe(new Consumer<String>() {
+              @Override public void accept(String title) throws Exception {
                 getActivity().setTitle(title);
               }
             }));
 
-    subscriptions.add(db.createQuery(TodoItem.TABLE, LIST_QUERY, listId)
+    disposables.add(db.createQuery(TodoItem.TABLE, LIST_QUERY, listId)
         .mapToList(TodoItem.MAPPER)
         .observeOn(AndroidSchedulers.mainThread())
         .subscribe(adapter));
@@ -202,6 +204,6 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
 
   @Override public void onPause() {
     super.onPause();
-    subscriptions.unsubscribe();
+    disposables.dispose();
   }
 }
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsAdapter.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsAdapter.java
index b88362c..52c7608 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsAdapter.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsAdapter.java
@@ -21,11 +21,11 @@
 import android.view.ViewGroup;
 import android.widget.BaseAdapter;
 import android.widget.TextView;
+import io.reactivex.functions.Consumer;
 import java.util.Collections;
 import java.util.List;
-import rx.functions.Action1;
 
-final class ListsAdapter extends BaseAdapter implements Action1<List<ListsItem>> {
+final class ListsAdapter extends BaseAdapter implements Consumer<List<ListsItem>> {
   private final LayoutInflater inflater;
 
   private List<ListsItem> items = Collections.emptyList();
@@ -34,7 +34,7 @@ public ListsAdapter(Context context) {
     this.inflater = LayoutInflater.from(context);
   }
 
-  @Override public void call(List<ListsItem> items) {
+  @Override public void accept(List<ListsItem> items) {
     this.items = items;
     notifyDataSetChanged();
   }
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
index 09e1387..3869577 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
@@ -32,10 +32,10 @@
 import butterknife.OnItemClick;
 import com.example.sqlbrite.todo.R;
 import com.example.sqlbrite.todo.TodoApp;
-import com.squareup.sqlbrite.BriteDatabase;
+import com.squareup.sqlbrite3.BriteDatabase;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.disposables.Disposable;
 import javax.inject.Inject;
-import rx.Subscription;
-import rx.android.schedulers.AndroidSchedulers;
 
 import static android.support.v4.view.MenuItemCompat.SHOW_AS_ACTION_IF_ROOM;
 import static android.support.v4.view.MenuItemCompat.SHOW_AS_ACTION_WITH_TEXT;
@@ -57,7 +57,7 @@ static ListsFragment newInstance() {
 
   private Listener listener;
   private ListsAdapter adapter;
-  private Subscription subscription;
+  private Disposable disposable;
 
   @Override public void onAttach(Activity activity) {
     if (!(activity instanceof Listener)) {
@@ -107,7 +107,7 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
 
     getActivity().setTitle("To-Do");
 
-    subscription = db.createQuery(ListsItem.TABLES, ListsItem.QUERY)
+    disposable = db.createQuery(ListsItem.TABLES, ListsItem.QUERY)
         .mapToList(ListsItem.MAPPER)
         .observeOn(AndroidSchedulers.mainThread())
         .subscribe(adapter);
@@ -115,6 +115,6 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
 
   @Override public void onPause() {
     super.onPause();
-    subscription.unsubscribe();
+    disposable.dispose();
   }
 }
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
index a865ccb..4faee80 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
@@ -21,9 +21,9 @@
 import com.example.sqlbrite.todo.db.TodoItem;
 import com.example.sqlbrite.todo.db.TodoList;
 import com.google.auto.value.AutoValue;
+import io.reactivex.functions.Function;
 import java.util.Arrays;
 import java.util.Collection;
-import rx.functions.Func1;
 
 @AutoValue
 abstract class ListsItem implements Parcelable {
@@ -47,8 +47,8 @@
   abstract String name();
   abstract int itemCount();
 
-  static Func1<Cursor, ListsItem> MAPPER = new Func1<Cursor, ListsItem>() {
-    @Override public ListsItem call(Cursor cursor) {
+  static Function<Cursor, ListsItem> MAPPER = new Function<Cursor, ListsItem>() {
+    @Override public ListsItem apply(Cursor cursor) {
       long id = Db.getLong(cursor, TodoList.ID);
       String name = Db.getString(cursor, TodoList.NAME);
       int itemCount = Db.getInt(cursor, ITEM_COUNT);
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
index ea05e7b..d584d97 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
@@ -29,15 +29,16 @@
 import com.example.sqlbrite.todo.R;
 import com.example.sqlbrite.todo.TodoApp;
 import com.example.sqlbrite.todo.db.TodoItem;
-import com.jakewharton.rxbinding.widget.RxTextView;
-import com.squareup.sqlbrite.BriteDatabase;
+import com.jakewharton.rxbinding2.widget.RxTextView;
+import com.squareup.sqlbrite3.BriteDatabase;
+import io.reactivex.Observable;
+import io.reactivex.functions.BiFunction;
+import io.reactivex.functions.Consumer;
+import io.reactivex.schedulers.Schedulers;
+import io.reactivex.subjects.PublishSubject;
 import javax.inject.Inject;
-import rx.Observable;
-import rx.functions.Action1;
-import rx.functions.Func2;
-import rx.schedulers.Schedulers;
-import rx.subjects.PublishSubject;
 
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_NONE;
 import static butterknife.ButterKnife.findById;
 
 public final class NewItemFragment extends DialogFragment {
@@ -71,15 +72,15 @@ private long getListId() {
 
     EditText name = findById(view, android.R.id.input);
     Observable.combineLatest(createClicked, RxTextView.textChanges(name),
-        new Func2<String, CharSequence, String>() {
-          @Override public String call(String ignored, CharSequence text) {
+        new BiFunction<String, CharSequence, String>() {
+          @Override public String apply(String ignored, CharSequence text) {
             return text.toString();
           }
         }) //
         .observeOn(Schedulers.io())
-        .subscribe(new Action1<String>() {
-          @Override public void call(String description) {
-            db.insert(TodoItem.TABLE,
+        .subscribe(new Consumer<String>() {
+          @Override public void accept(String description) {
+            db.insert(TodoItem.TABLE, CONFLICT_NONE,
                 new TodoItem.Builder().listId(getListId()).description(description).build());
           }
         });
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
index b01e06b..5050419 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
@@ -29,15 +29,16 @@
 import com.example.sqlbrite.todo.R;
 import com.example.sqlbrite.todo.TodoApp;
 import com.example.sqlbrite.todo.db.TodoList;
-import com.jakewharton.rxbinding.widget.RxTextView;
-import com.squareup.sqlbrite.BriteDatabase;
+import com.jakewharton.rxbinding2.widget.RxTextView;
+import com.squareup.sqlbrite3.BriteDatabase;
+import io.reactivex.Observable;
+import io.reactivex.functions.BiFunction;
+import io.reactivex.functions.Consumer;
+import io.reactivex.schedulers.Schedulers;
+import io.reactivex.subjects.PublishSubject;
 import javax.inject.Inject;
-import rx.Observable;
-import rx.functions.Action1;
-import rx.functions.Func2;
-import rx.schedulers.Schedulers;
-import rx.subjects.PublishSubject;
 
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_NONE;
 import static butterknife.ButterKnife.findById;
 
 public final class NewListFragment extends DialogFragment {
@@ -60,15 +61,15 @@ public static NewListFragment newInstance() {
 
     EditText name = findById(view, android.R.id.input);
     Observable.combineLatest(createClicked, RxTextView.textChanges(name),
-        new Func2<String, CharSequence, String>() {
-          @Override public String call(String ignored, CharSequence text) {
+        new BiFunction<String, CharSequence, String>() {
+          @Override public String apply(String ignored, CharSequence text) {
             return text.toString();
           }
         }) //
         .observeOn(Schedulers.io())
-        .subscribe(new Action1<String>() {
-          @Override public void call(String name) {
-            db.insert(TodoList.TABLE, new TodoList.Builder().name(name).build());
+        .subscribe(new Consumer<String>() {
+          @Override public void accept(String name) {
+            db.insert(TodoList.TABLE, CONFLICT_NONE, new TodoList.Builder().name(name).build());
           }
         });
 
diff --git a/settings.gradle b/settings.gradle
index 4254ba9..c8e5799 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,4 +1,6 @@
 include ':sqlbrite'
+include ':sqlbrite-kotlin'
+include ':sqlbrite-lint'
 include ':sample'
 
 rootProject.name = 'sqlbrite-root'
diff --git a/sqlbrite-kotlin/build.gradle b/sqlbrite-kotlin/build.gradle
new file mode 100644
index 0000000..1e11354
--- /dev/null
+++ b/sqlbrite-kotlin/build.gradle
@@ -0,0 +1,27 @@
+apply plugin: 'com.android.library'
+apply plugin: 'org.jetbrains.kotlin.android'
+
+dependencies {
+  api project(':sqlbrite')
+  api rootProject.ext.kotlinStdLib
+}
+
+android {
+  compileSdkVersion versions.compileSdk
+
+  defaultConfig {
+    minSdkVersion versions.minSdk
+  }
+
+  compileOptions {
+    sourceCompatibility JavaVersion.VERSION_1_7
+    targetCompatibility JavaVersion.VERSION_1_7
+  }
+
+  lintOptions {
+    textOutput 'stdout'
+    textReport true
+  }
+}
+
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/sqlbrite-kotlin/gradle.properties b/sqlbrite-kotlin/gradle.properties
new file mode 100644
index 0000000..31389df
--- /dev/null
+++ b/sqlbrite-kotlin/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=sqlbrite-kotlin
+POM_NAME=SqlBrite (Kotlin Extensions)
+POM_PACKAGING=aar
diff --git a/sqlbrite-kotlin/src/main/AndroidManifest.xml b/sqlbrite-kotlin/src/main/AndroidManifest.xml
new file mode 100644
index 0000000..6fe168a
--- /dev/null
+++ b/sqlbrite-kotlin/src/main/AndroidManifest.xml
@@ -0,0 +1 @@
+<manifest package="com.squareup.sqlbrite2.kotlin"/>
diff --git a/sqlbrite-kotlin/src/main/java/com/squareup/sqlbrite3/extensions.kt b/sqlbrite-kotlin/src/main/java/com/squareup/sqlbrite3/extensions.kt
new file mode 100644
index 0000000..8de7e5e
--- /dev/null
+++ b/sqlbrite-kotlin/src/main/java/com/squareup/sqlbrite3/extensions.kt
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@file:Suppress("NOTHING_TO_INLINE") // Extensions provided for intentional convenience.
+
+package com.squareup.sqlbrite3
+
+import android.database.Cursor
+import android.support.annotation.RequiresApi
+import com.squareup.sqlbrite3.BriteDatabase.Transaction
+import com.squareup.sqlbrite3.SqlBrite.Query
+import io.reactivex.Observable
+import java.util.Optional
+
+typealias Mapper<T> = (Cursor) -> T
+
+/**
+ * Transforms an observable of single-row [Query] to an observable of `T` using `mapper`.
+ *
+ * It is an error for a query to pass through this operator with more than 1 row in its result set.
+ * Use `LIMIT 1` on the underlying SQL query to prevent this. Result sets with 0 rows do not emit
+ * an item.
+ *
+ * This operator ignores null cursors returned from [Query.run].
+ *
+ * @param mapper Maps the current [Cursor] row to `T`. May not return null.
+ */
+inline fun <T> Observable<Query>.mapToOne(noinline mapper: Mapper<T>): Observable<T>
+    = lift(Query.mapToOne(mapper))
+
+/**
+ * Transforms an observable of single-row [Query] to an observable of `T` using `mapper`
+ *
+ * It is an error for a query to pass through this operator with more than 1 row in its result set.
+ * Use `LIMIT 1` on the underlying SQL query to prevent this. Result sets with 0 rows emit
+ * `default`.
+ *
+ * This operator emits `defaultValue` if null is returned from [Query.run].
+ *
+ * @param mapper Maps the current [Cursor] row to `T`. May not return null.
+ * @param default Value returned if result set is empty
+ */
+inline fun <T> Observable<Query>.mapToOneOrDefault(default: T, noinline mapper: Mapper<T>): Observable<T>
+    = lift(Query.mapToOneOrDefault(mapper, default))
+
+/**
+ * Transforms an observable of single-row [Query] to an observable of `T` using `mapper.
+ *
+ * It is an error for a query to pass through this operator with more than 1 row in its result set.
+ * Use `LIMIT 1` on the underlying SQL query to prevent this. Result sets with 0 rows emit
+ * `default`.
+ *
+ * This operator ignores null cursors returned from [Query.run].
+ *
+ * @param mapper Maps the current [Cursor] row to `T`. May not return null.
+ */
+@RequiresApi(24)
+inline fun <T> Observable<Query>.mapToOptional(noinline mapper: Mapper<T>): Observable<Optional<T>>
+    = lift(Query.mapToOptional(mapper))
+
+/**
+ * Transforms an observable of [Query] to `List<T>` using `mapper` for each row.
+ *
+ * Be careful using this operator as it will always consume the entire cursor and create objects
+ * for each row, every time this observable emits a new query. On tables whose queries update
+ * frequently or very large result sets this can result in the creation of many objects.
+ *
+ * This operator ignores null cursors returned from [Query.run].
+ *
+ * @param mapper Maps the current [Cursor] row to `T`. May not return null.
+ */
+inline fun <T> Observable<Query>.mapToList(noinline mapper: Mapper<T>): Observable<List<T>>
+    = lift(Query.mapToList(mapper))
+
+/**
+ * Run the database interactions in `body` inside of a transaction.
+ *
+ * @param exclusive Uses [BriteDatabase.newTransaction] if true, otherwise
+ * [BriteDatabase.newNonExclusiveTransaction].
+ */
+inline fun <T> BriteDatabase.inTransaction(
+    exclusive: Boolean = true,
+    body: BriteDatabase.(Transaction) -> T
+): T {
+  val transaction = if (exclusive) newTransaction() else newNonExclusiveTransaction()
+  try {
+    val result = body(transaction)
+    transaction.markSuccessful()
+    return result
+  } finally {
+    transaction.end()
+  }
+}
diff --git a/sqlbrite-lint/build.gradle b/sqlbrite-lint/build.gradle
new file mode 100644
index 0000000..6760c20
--- /dev/null
+++ b/sqlbrite-lint/build.gradle
@@ -0,0 +1,16 @@
+apply plugin: 'kotlin'
+
+dependencies {
+  compileOnly rootProject.ext.kotlinStdLib
+  compileOnly rootProject.ext.lintApi
+
+  testImplementation rootProject.ext.junit
+  testImplementation rootProject.ext.lint
+  testImplementation rootProject.ext.lintTests
+}
+
+jar {
+  manifest {
+    attributes("Lint-Registry-v2": "com.squareup.sqlbrite3.BriteIssueRegistry")
+  }
+}
diff --git a/sqlbrite-lint/src/main/java/com/squareup/sqlbrite3/BriteIssueRegistry.kt b/sqlbrite-lint/src/main/java/com/squareup/sqlbrite3/BriteIssueRegistry.kt
new file mode 100644
index 0000000..ae91551
--- /dev/null
+++ b/sqlbrite-lint/src/main/java/com/squareup/sqlbrite3/BriteIssueRegistry.kt
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.sqlbrite3
+
+import com.android.tools.lint.client.api.IssueRegistry
+
+class BriteIssueRegistry : IssueRegistry() {
+
+  override fun getIssues() = listOf(SqlBriteArgCountDetector.ISSUE)
+}
diff --git a/sqlbrite-lint/src/main/java/com/squareup/sqlbrite3/SqlBriteArgCountDetector.kt b/sqlbrite-lint/src/main/java/com/squareup/sqlbrite3/SqlBriteArgCountDetector.kt
new file mode 100644
index 0000000..a353563
--- /dev/null
+++ b/sqlbrite-lint/src/main/java/com/squareup/sqlbrite3/SqlBriteArgCountDetector.kt
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.sqlbrite3
+
+import com.android.tools.lint.detector.api.Category
+import com.android.tools.lint.detector.api.ConstantEvaluator.evaluateString
+import com.android.tools.lint.detector.api.Detector
+import com.android.tools.lint.detector.api.Implementation
+import com.android.tools.lint.detector.api.Issue
+import com.android.tools.lint.detector.api.JavaContext
+import com.android.tools.lint.detector.api.Scope.JAVA_FILE
+import com.android.tools.lint.detector.api.Scope.TEST_SOURCES
+import com.android.tools.lint.detector.api.Severity
+import com.intellij.psi.PsiMethod
+import org.jetbrains.uast.UCallExpression
+import java.util.EnumSet
+
+private const val BRITE_DATABASE = "com.squareup.sqlbrite3.BriteDatabase"
+private const val QUERY_METHOD_NAME = "query"
+private const val CREATE_QUERY_METHOD_NAME = "createQuery"
+
+class SqlBriteArgCountDetector : Detector(), Detector.UastScanner {
+
+  companion object {
+
+    val ISSUE: Issue = Issue.create(
+        "SqlBriteArgCount",
+        "Number of provided arguments doesn't match number " +
+            "of arguments specified in query",
+        "When providing arguments to query you need to provide the same amount of " +
+            "arguments that is specified in query.",
+        Category.MESSAGES,
+        9,
+        Severity.ERROR,
+        Implementation(SqlBriteArgCountDetector::class.java, EnumSet.of(JAVA_FILE, TEST_SOURCES)))
+  }
+
+  override fun getApplicableMethodNames() = listOf(CREATE_QUERY_METHOD_NAME, QUERY_METHOD_NAME)
+
+  override fun visitMethod(context: JavaContext, call: UCallExpression, method: PsiMethod) {
+    val evaluator = context.evaluator
+
+    if (evaluator.isMemberInClass(method, BRITE_DATABASE)) {
+      // Skip non varargs overloads.
+      if (!method.isVarArgs) return
+
+      // Position of sql parameter depends on method.
+      val sql = evaluateString(context,
+          call.valueArguments[if (call.isQueryMethod()) 0 else 1], true) ?: return
+
+      // Count only vararg arguments.
+      val argumentsCount = call.valueArgumentCount - if (call.isQueryMethod()) 1 else 2
+      val questionMarksCount = sql.count { it == '?' }
+      if (argumentsCount != questionMarksCount) {
+        val requiredArguments = "$questionMarksCount ${"argument".pluralize(questionMarksCount)}"
+        val actualArguments = "$argumentsCount ${"argument".pluralize(argumentsCount)}"
+        context.report(ISSUE, call, context.getLocation(call), "Wrong argument count, " +
+            "query $sql requires $requiredArguments, but was provided $actualArguments")
+      }
+    }
+  }
+
+  private fun UCallExpression.isQueryMethod() = methodName == QUERY_METHOD_NAME
+
+  private fun String.pluralize(count: Int) = if (count == 1) this else this + "s"
+}
\ No newline at end of file
diff --git a/sqlbrite-lint/src/test/java/com/squareup/sqlbrite3/SqlBriteArgCountDetectorTest.kt b/sqlbrite-lint/src/test/java/com/squareup/sqlbrite3/SqlBriteArgCountDetectorTest.kt
new file mode 100644
index 0000000..c946983
--- /dev/null
+++ b/sqlbrite-lint/src/test/java/com/squareup/sqlbrite3/SqlBriteArgCountDetectorTest.kt
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.sqlbrite3
+
+import com.android.tools.lint.checks.infrastructure.TestFiles.java
+import com.android.tools.lint.checks.infrastructure.TestLintTask.lint
+import org.junit.Test
+
+class SqlBriteArgCountDetectorTest {
+
+  companion object {
+    private val BRITE_DATABASE_STUB = java(
+        """
+      package com.squareup.sqlbrite3;
+
+      public final class BriteDatabase {
+
+        public void query(String sql, Object... args) {
+        }
+
+        public void createQuery(String table, String sql, Object... args) {
+        }
+
+        // simulate createQuery with SupportSQLiteQuery query parameter
+        public void createQuery(String table, int something) {
+        }
+      }
+      """.trimIndent()
+    )
+  }
+
+  @Test
+  fun cleanCaseWithWithQueryAsLiteral() {
+    lint().files(
+        BRITE_DATABASE_STUB,
+        java(
+            """
+              package test.pkg;
+
+              import com.squareup.sqlbrite3.BriteDatabase;
+
+              public class Test {
+                  private static final String QUERY = "SELECT name FROM table WHERE id = ?";
+
+                  public void test() {
+                    BriteDatabase db = new BriteDatabase();
+                    db.query(QUERY, "id");
+                  }
+
+              }
+            """.trimIndent()))
+        .issues(SqlBriteArgCountDetector.ISSUE)
+        .run()
+        .expectClean()
+  }
+
+  @Test
+  fun cleanCaseWithQueryAsBinaryExpression() {
+    lint().files(
+        BRITE_DATABASE_STUB,
+        java(
+            """
+              package test.pkg;
+
+              import com.squareup.sqlbrite3.BriteDatabase;
+
+              public class Test {
+                  private static final String QUERY = "SELECT name FROM table WHERE ";
+
+                  public void test() {
+                    BriteDatabase db = new BriteDatabase();
+                    db.query(QUERY + "id = ?", "id");
+                  }
+
+              }
+            """.trimIndent()))
+        .issues(SqlBriteArgCountDetector.ISSUE)
+        .run()
+        .expectClean()
+  }
+
+  @Test
+  fun cleanCaseWithQueryThatCantBeEvaluated() {
+    lint().files(
+        BRITE_DATABASE_STUB,
+        java(
+            """
+              package test.pkg;
+
+              import com.squareup.sqlbrite3.BriteDatabase;
+
+              public class Test {
+                  private static final String QUERY = "SELECT name FROM table WHERE id = ?";
+
+                  public void test() {
+                    BriteDatabase db = new BriteDatabase();
+                    db.query(query(), "id");
+                  }
+
+                  private String query() {
+                    return QUERY + " age = ?";
+                  }
+
+              }
+            """.trimIndent()))
+        .issues(SqlBriteArgCountDetector.ISSUE)
+        .run()
+        .expectClean()
+  }
+
+  @Test
+  fun cleanCaseWithNonVarargMethodCall() {
+    lint().files(
+        BRITE_DATABASE_STUB,
+        java(
+            """
+              package test.pkg;
+
+              import com.squareup.sqlbrite3.BriteDatabase;
+
+              public class Test {
+
+                  public void test() {
+                    BriteDatabase db = new BriteDatabase();
+                    db.createQuery("table", 42);
+                  }
+
+              }
+            """.trimIndent()))
+        .issues(SqlBriteArgCountDetector.ISSUE)
+        .run()
+        .expectClean()
+  }
+
+  @Test
+  fun queryMethodWithWrongNumberOfArguments() {
+    lint().files(
+        BRITE_DATABASE_STUB,
+        java(
+            """
+              package test.pkg;
+
+              import com.squareup.sqlbrite3.BriteDatabase;
+
+              public class Test {
+                  private static final String QUERY = "SELECT name FROM table WHERE id = ?";
+
+                  public void test() {
+                    BriteDatabase db = new BriteDatabase();
+                    db.query(QUERY);
+                  }
+
+              }
+            """.trimIndent()))
+        .issues(SqlBriteArgCountDetector.ISSUE)
+        .run()
+        .expect("src/test/pkg/Test.java:10: " +
+            "Error: Wrong argument count, query SELECT name FROM table WHERE id = ?" +
+            " requires 1 argument, but was provided 0 arguments [SqlBriteArgCount]\n" +
+            "      db.query(QUERY);\n" +
+            "      ~~~~~~~~~~~~~~~\n" +
+            "1 errors, 0 warnings")
+  }
+
+  @Test
+  fun createQueryMethodWithWrongNumberOfArguments() {
+    lint().files(
+        BRITE_DATABASE_STUB,
+        java(
+            """
+              package test.pkg;
+
+              import com.squareup.sqlbrite3.BriteDatabase;
+
+              public class Test {
+                  private static final String QUERY = "SELECT name FROM table WHERE id = ?";
+
+                  public void test() {
+                    BriteDatabase db = new BriteDatabase();
+                    db.createQuery("table", QUERY);
+                  }
+
+              }
+            """.trimIndent()))
+        .issues(SqlBriteArgCountDetector.ISSUE)
+        .run()
+        .expect("src/test/pkg/Test.java:10: " +
+            "Error: Wrong argument count, query SELECT name FROM table WHERE id = ?" +
+            " requires 1 argument, but was provided 0 arguments [SqlBriteArgCount]\n" +
+            "      db.createQuery(\"table\", QUERY);\n" +
+            "      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n" +
+            "1 errors, 0 warnings")
+  }
+}
\ No newline at end of file
diff --git a/sqlbrite/build.gradle b/sqlbrite/build.gradle
index 90c8e7c..229e65d 100644
--- a/sqlbrite/build.gradle
+++ b/sqlbrite/build.gradle
@@ -1,31 +1,23 @@
-buildscript {
-  dependencies {
-    classpath rootProject.ext.androidPlugin
-  }
-}
-
 apply plugin: 'com.android.library'
-apply from: rootProject.file('gradle/android-findbugs.gradle')
 
 dependencies {
-  compile rootProject.ext.rxJava
-  compile rootProject.ext.supportAnnotations
+  api rootProject.ext.rxJava
+  api rootProject.ext.supportSqlite
+  implementation rootProject.ext.supportAnnotations
 
-  androidTestCompile rootProject.ext.supportTestRunner
-  androidTestCompile(rootProject.ext.truth) {
-    exclude group: 'junit' // Android has JUnit built in.
-  }
-}
+  androidTestImplementation rootProject.ext.supportTestRunner
+  androidTestImplementation rootProject.ext.truth
+  androidTestImplementation rootProject.ext.supportSqliteFramework
 
-def isCi() {
-  return "true".equals(System.getenv('CI'))
+  lintChecks project(':sqlbrite-lint')
 }
 
 android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
+  compileSdkVersion versions.compileSdk
 
   defaultConfig {
+    minSdkVersion versions.minSdk
+
     testInstrumentationRunner 'android.support.test.runner.AndroidJUnitRunner'
   }
 
@@ -34,37 +26,10 @@ android {
     targetCompatibility JavaVersion.VERSION_1_7
   }
 
-  dexOptions {
-    preDexLibraries = !isCi()
-  }
-
   lintOptions {
     textOutput 'stdout'
     textReport true
   }
-
-  buildTypes {
-    debug {
-      testCoverageEnabled true
-    }
-  }
-
-  packagingOptions {
-    exclude 'LICENSE.txt'
-  }
-}
-
-
-if (isCi()) {
-  println 'Running on CI. Adding task to start emulator.'
-
-  task startEmulator << {
-    "$rootDir/gradle/start-emulator.sh".execute().waitFor()
-  }
-
-  android.testVariants.all { variant ->
-    variant.connectedInstrumentTest.dependsOn startEmulator
-  }
 }
 
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryObservableTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryObservableTest.java
deleted file mode 100644
index b8094b8..0000000
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryObservableTest.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package com.squareup.sqlbrite;
-
-import android.database.Cursor;
-import android.database.MatrixCursor;
-import android.support.test.runner.AndroidJUnit4;
-
-import com.squareup.sqlbrite.SqlBrite.Query;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import rx.Observable.OnSubscribe;
-import rx.Subscriber;
-import rx.functions.Func1;
-import rx.observers.TestSubscriber;
-
-import static com.google.common.truth.Truth.assertThat;
-
-@RunWith(AndroidJUnit4.class)
-public final class QueryObservableTest {
-
-  @Test public void mapToListThrowsFromQueryRun() {
-    TestSubscriber<Object> testSubscriber = new TestSubscriber<>();
-
-    new QueryObservable(new OnSubscribe<Query>() {
-      @Override public void call(Subscriber<? super Query> subscriber) {
-        subscriber.onNext(new Query() {
-          @Override public Cursor run() {
-            throw new IllegalStateException("test exception");
-          }
-        });
-      }
-    }).mapToList(new Func1<Cursor, Object>() {
-      @Override public Object call(Cursor cursor) {
-        throw new AssertionError("Must not be called");
-      }
-    }).subscribe(testSubscriber);
-
-    testSubscriber.awaitTerminalEvent();
-    testSubscriber.assertNoValues();
-    assertThat(testSubscriber.getOnErrorEvents()).hasSize(1);
-
-    IllegalStateException expected = (IllegalStateException) testSubscriber.getOnErrorEvents().get(0);
-    assertThat(expected).hasMessage("test exception");
-  }
-
-  @Test public void mapToListThrowsFromMapFunction() {
-    TestSubscriber<Object> testSubscriber = new TestSubscriber<>();
-
-    new QueryObservable(new OnSubscribe<Query>() {
-      @Override public void call(Subscriber<? super Query> subscriber) {
-        subscriber.onNext(new Query() {
-          @Override public Cursor run() {
-            MatrixCursor cursor = new MatrixCursor(new String[]{"col1"});
-            cursor.addRow(new Object[]{"value1"});
-            return cursor;
-          }
-        });
-      }
-    }).mapToList(new Func1<Cursor, Object>() {
-      @Override public Object call(Cursor cursor) {
-        throw new IllegalStateException("test exception");
-      }
-    }).subscribe(testSubscriber);
-
-    testSubscriber.awaitTerminalEvent();
-    testSubscriber.assertNoValues();
-    assertThat(testSubscriber.getOnErrorEvents()).hasSize(1);
-
-    IllegalStateException expected = (IllegalStateException) testSubscriber.getOnErrorEvents().get(0);
-    assertThat(expected).hasMessage("test exception");
-  }
-}
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java
deleted file mode 100644
index 3bed90a..0000000
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.sqlbrite;
-
-import android.database.Cursor;
-import android.support.annotation.Nullable;
-import android.support.test.InstrumentationRegistry;
-import com.squareup.sqlbrite.SqlBrite.Query;
-import com.squareup.sqlbrite.TestDb.Employee;
-import java.util.ArrayList;
-import java.util.List;
-import org.junit.Before;
-import org.junit.Test;
-import rx.Observable;
-import rx.functions.Action1;
-import rx.functions.Func1;
-import rx.observables.BlockingObservable;
-import rx.observers.TestSubscriber;
-import rx.schedulers.Schedulers;
-
-import static com.google.common.truth.Truth.assertThat;
-import static com.squareup.sqlbrite.TestDb.SELECT_EMPLOYEES;
-import static com.squareup.sqlbrite.TestDb.TABLE_EMPLOYEE;
-import static org.junit.Assert.fail;
-
-public final class QueryTest {
-  private BriteDatabase db;
-
-  @Before public void setUp() {
-    SqlBrite sqlBrite = SqlBrite.create();
-    TestDb helper = new TestDb(InstrumentationRegistry.getContext(), null /* memory */);
-    db = sqlBrite.wrapDatabaseHelper(helper, Schedulers.immediate());
-  }
-
-  @Test public void mapToOne() {
-    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
-        .lift(Query.mapToOne(Employee.MAPPER))
-        .toBlocking()
-        .first();
-    assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
-  }
-
-  @Test public void mapToOneAllowsMapperNull() {
-    Func1<Cursor, Employee> mapToNull = new Func1<Cursor, Employee>() {
-      @Override public Employee call(Cursor cursor) {
-        return null;
-      }
-    };
-    Employee employee = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1") //
-        .lift(Query.mapToOne(mapToNull)) //
-        .toBlocking() //
-        .first();
-    assertThat(employee).isNull();
-  }
-
-  @Test public void mapToOneNoOpAndReRequestOnNoRows() {
-    final List<Long> requests = new ArrayList<>();
-    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE 1=2")
-        .take(1)
-        .doOnRequest(new Action1<Long>() {
-          @Override public void call(Long n) {
-            requests.add(n);
-          }
-        })
-        .lift(Query.mapToOne(Employee.MAPPER))
-        .toList()
-        .toBlocking()
-        .first();
-    assertThat(employees).isEmpty();
-    assertThat(requests).containsExactly(Long.MAX_VALUE, 1L);
-  }
-
-  @Test public void mapToOneThrowsOnMultipleRows() {
-    BlockingObservable<Employee> employees =
-        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 2") //
-            .lift(Query.mapToOne(Employee.MAPPER)) //
-            .toBlocking();
-    try {
-      employees.first();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Cursor returned more than 1 row");
-      assertThat(e.getCause()).hasMessage(
-          "OnError while emitting onNext value: SELECT username, name FROM employee LIMIT 2");
-    }
-  }
-
-  @Test public void mapToOneIgnoresNullCursor() {
-    Query nully = new Query() {
-      @Nullable @Override public Cursor run() {
-        return null;
-      }
-    };
-
-    TestSubscriber<Employee> subscriber = new TestSubscriber<>();
-    Observable.just(nully)
-        .lift(Query.mapToOne(Employee.MAPPER))
-        .subscribe(subscriber);
-
-    subscriber.assertNoValues();
-    subscriber.assertCompleted();
-  }
-
-  @Test public void mapToOneOrDefault() {
-    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
-        .lift(Query.mapToOneOrDefault(Employee.MAPPER, null))
-        .toBlocking()
-        .first();
-    assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
-  }
-
-  @Test public void mapToOneOrDefaultReturnsDefaultAndDoesNotReRequestWhenNoRows() {
-    final List<Long> requests = new ArrayList<>();
-    Employee defaultEmployee = new Employee("bob", "Bob Bobberson");
-    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE 1=2")
-        .take(1)
-        .doOnRequest(new Action1<Long>() {
-          @Override public void call(Long n) {
-            requests.add(n);
-          }
-        })
-        .lift(Query.mapToOneOrDefault(Employee.MAPPER, defaultEmployee))
-        .toList()
-        .toBlocking()
-        .first();
-    assertThat(employees).containsExactly(defaultEmployee);
-    assertThat(requests).containsExactly(Long.MAX_VALUE);
-  }
-
-  @Test public void mapToOneOrDefaultAllowsNullDefault() {
-    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE 1=2")
-        .lift(Query.mapToOneOrDefault(Employee.MAPPER, null))
-        .toBlocking()
-        .first();
-    assertThat(employees).isNull();
-  }
-
-  @Test public void mapToOneOrDefaultAllowsMapperNull() {
-    Func1<Cursor, Employee> mapToNull = new Func1<Cursor, Employee>() {
-      @Override public Employee call(Cursor cursor) {
-        return null;
-      }
-    };
-    Employee employee = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1") //
-        .lift(Query.mapToOneOrDefault(mapToNull, new Employee("bob", "Bob Bobberson"))) //
-        .toBlocking() //
-        .first();
-    assertThat(employee).isNull();
-  }
-
-  @Test public void mapToOneOrDefaultThrowsOnMultipleRows() {
-    BlockingObservable<Employee> employees =
-        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 2") //
-            .lift(Query.mapToOneOrDefault(Employee.MAPPER, null)) //
-            .toBlocking();
-    try {
-      employees.first();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Cursor returned more than 1 row");
-      assertThat(e.getCause()).hasMessage(
-          "OnError while emitting onNext value: SELECT username, name FROM employee LIMIT 2");
-    }
-  }
-
-  @Test public void mapToOneOrDefaultReturnsDefaultWhenNullCursor() {
-    Employee defaultEmployee = new Employee("bob", "Bob Bobberson");
-    Query nully = new Query() {
-      @Nullable @Override public Cursor run() {
-        return null;
-      }
-    };
-
-    TestSubscriber<Employee> subscriber = new TestSubscriber<>();
-    Observable.just(nully)
-        .lift(Query.mapToOneOrDefault(Employee.MAPPER, defaultEmployee))
-        .subscribe(subscriber);
-
-    subscriber.assertValues(defaultEmployee);
-    subscriber.assertCompleted();
-  }
-
-  @Test public void mapToList() {
-    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
-        .lift(Query.mapToList(Employee.MAPPER))
-        .toBlocking()
-        .first();
-    assertThat(employees).containsExactly( //
-        new Employee("alice", "Alice Allison"), //
-        new Employee("bob", "Bob Bobberson"), //
-        new Employee("eve", "Eve Evenson"));
-  }
-
-  @Test public void mapToListEmptyWhenNoRows() {
-    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE 1=2")
-        .lift(Query.mapToList(Employee.MAPPER))
-        .toBlocking()
-        .first();
-    assertThat(employees).isEmpty();
-  }
-
-  @Test public void mapToListReturnsNullOnMapperNull() {
-    Func1<Cursor, Employee> mapToNull = new Func1<Cursor, Employee>() {
-      private int count;
-
-      @Override public Employee call(Cursor cursor) {
-        return count++ == 2 ? null : Employee.MAPPER.call(cursor);
-      }
-    };
-    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES) //
-            .lift(Query.mapToList(mapToNull)) //
-            .toBlocking() //
-            .first();
-
-    assertThat(employees).containsExactly(
-        new Employee("alice", "Alice Allison"),
-        new Employee("bob", "Bob Bobberson"),
-        null);
-  }
-
-  @Test public void mapToListIgnoresNullCursor() {
-    Query nully = new Query() {
-      @Nullable @Override public Cursor run() {
-        return null;
-      }
-    };
-
-    TestSubscriber<List<Employee>> subscriber = new TestSubscriber<>();
-    Observable.just(nully)
-        .lift(Query.mapToList(Employee.MAPPER))
-        .subscribe(subscriber);
-
-    subscriber.assertNoValues();
-    subscriber.assertCompleted();
-  }
-}
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BlockingRecordingObserver.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/BlockingRecordingObserver.java
similarity index 97%
rename from sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BlockingRecordingObserver.java
rename to sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/BlockingRecordingObserver.java
index 5569489..305f622 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BlockingRecordingObserver.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/BlockingRecordingObserver.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.sqlbrite;
+package com.squareup.sqlbrite3;
 
 import static com.google.common.truth.Truth.assertThat;
 import static java.util.concurrent.TimeUnit.SECONDS;
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/BriteContentResolverTest.java
similarity index 61%
rename from sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java
rename to sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/BriteContentResolverTest.java
index b0f76ec..67619a8 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/BriteContentResolverTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.sqlbrite;
+package com.squareup.sqlbrite3;
 
 import android.content.ContentResolver;
 import android.content.ContentValues;
@@ -22,17 +22,15 @@
 import android.net.Uri;
 import android.test.ProviderTestCase2;
 import android.test.mock.MockContentProvider;
-import com.squareup.sqlbrite.SqlBrite.Query;
+import com.squareup.sqlbrite3.SqlBrite.Query;
+import io.reactivex.Observable;
+import io.reactivex.ObservableSource;
+import io.reactivex.ObservableTransformer;
+import io.reactivex.subjects.PublishSubject;
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import rx.Observable;
-import rx.Observable.Transformer;
-import rx.Subscription;
-import rx.internal.util.RxRingBuffer;
-import rx.subjects.PublishSubject;
-import rx.subscriptions.Subscriptions;
 
 import static com.google.common.truth.Truth.assertThat;
 
@@ -46,11 +44,10 @@
   private final List<String> logs = new ArrayList<>();
   private final RecordingObserver o = new BlockingRecordingObserver();
   private final TestScheduler scheduler = new TestScheduler();
-  private final PublishSubject<Void> killSwitch = PublishSubject.create();
+  private final PublishSubject<Object> killSwitch = PublishSubject.create();
 
   private ContentResolver contentResolver;
   private BriteContentResolver db;
-  private Subscription subscription;
 
   public BriteContentResolverTest() {
     super(TestContentProvider.class, AUTHORITY.getAuthority());
@@ -59,18 +56,18 @@ public BriteContentResolverTest() {
   @Override protected void setUp() throws Exception {
     super.setUp();
     contentResolver = getMockContentResolver();
-    subscription = Subscriptions.empty();
 
     SqlBrite.Logger logger = new SqlBrite.Logger() {
       @Override public void log(String message) {
         logs.add(message);
       }
     };
-    Transformer<Query, Query> queryTransformer = new Transformer<Query, Query>() {
-      @Override public Observable<Query> call(Observable<Query> queryObservable) {
-        return queryObservable.takeUntil(killSwitch);
-      }
-    };
+    ObservableTransformer<Query, Query> queryTransformer =
+        new ObservableTransformer<Query, Query>() {
+          @Override public ObservableSource<Query> apply(Observable<Query> upstream) {
+            return upstream.takeUntil(killSwitch);
+          }
+        };
     db = new BriteContentResolver(contentResolver, logger, scheduler, queryTransformer);
 
     getProvider().init(getContext().getContentResolver());
@@ -78,13 +75,13 @@ public BriteContentResolverTest() {
 
   @Override public void tearDown() {
     o.assertNoMoreEvents();
-    subscription.unsubscribe();
+    o.dispose();
   }
 
   public void testLoggerEnabled() {
     db.setLoggingEnabled(true);
 
-    subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
+    db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
     o.assertCursor().isExhausted();
 
     contentResolver.insert(TABLE, values("key1", "value1"));
@@ -100,7 +97,7 @@ public void testLoggerDisabled() {
   }
 
   public void testCreateQueryObservesInsert() {
-    subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
+    db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
     o.assertCursor().isExhausted();
 
     contentResolver.insert(TABLE, values("key1", "val1"));
@@ -109,7 +106,7 @@ public void testCreateQueryObservesInsert() {
 
   public void testCreateQueryObservesUpdate() {
     contentResolver.insert(TABLE, values("key1", "val1"));
-    subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
+    db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
     o.assertCursor().hasRow("key1", "val1").isExhausted();
 
     contentResolver.update(TABLE, values("key1", "val2"), null, null);
@@ -118,7 +115,7 @@ public void testCreateQueryObservesUpdate() {
 
   public void testCreateQueryObservesDelete() {
     contentResolver.insert(TABLE, values("key1", "val1"));
-    subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
+    db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
     o.assertCursor().hasRow("key1", "val1").isExhausted();
 
     contentResolver.delete(TABLE, null, null);
@@ -126,98 +123,30 @@ public void testCreateQueryObservesDelete() {
   }
 
   public void testUnsubscribeDoesNotTrigger() {
-    subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
+    db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
     o.assertCursor().isExhausted();
-    subscription.unsubscribe();
+    o.dispose();
 
     contentResolver.insert(TABLE, values("key1", "val1"));
     o.assertNoMoreEvents();
     assertThat(logs).isEmpty();
   }
 
-  public void testQueryNotNotifiedWhenQueryTransformerUnsubscribes() {
-    subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
+  public void testQueryNotNotifiedWhenQueryTransformerDisposed() {
+    db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
     o.assertCursor().isExhausted();
 
-    killSwitch.onNext(null);
+    killSwitch.onNext("kill");
     o.assertIsCompleted();
 
     contentResolver.insert(TABLE, values("key1", "val1"));
     o.assertNoMoreEvents();
   }
 
-  public void testBackpressureSupportedWhenConsumerSlow() {
-    contentResolver.insert(TABLE, values("key1", "val1"));
-    o.doRequest(2);
-
-    subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
-    o.assertCursor()
-        .hasRow("key1", "val1")
-        .isExhausted();
-
-    contentResolver.insert(TABLE, values("key2", "val2"));
-    o.assertCursor()
-        .hasRow("key1", "val1")
-        .hasRow("key2", "val2")
-        .isExhausted();
-
-    contentResolver.insert(TABLE, values("key3", "val3"));
-    o.assertNoMoreEvents();
-
-    contentResolver.insert(TABLE, values("key4", "val4"));
-    o.assertNoMoreEvents();
-
-    o.doRequest(1);
-    o.assertCursor()
-        .hasRow("key1", "val1")
-        .hasRow("key2", "val2")
-        .hasRow("key3", "val3")
-        .hasRow("key4", "val4")
-        .isExhausted();
-
-    contentResolver.insert(TABLE, values("key5", "val5"));
-    o.assertNoMoreEvents();
-    contentResolver.insert(TABLE, values("key6", "val6"));
-    o.assertNoMoreEvents();
-
-    o.doRequest(Long.MAX_VALUE);
-    o.assertCursor()
-        .hasRow("key1", "val1")
-        .hasRow("key2", "val2")
-        .hasRow("key3", "val3")
-        .hasRow("key4", "val4")
-        .hasRow("key5", "val5")
-        .hasRow("key6", "val6")
-        .isExhausted();
-    o.assertNoMoreEvents();
-  }
-
-  public void testBackpressureSupportedWhenSchedulerSlow() {
-    subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
-    o.assertCursor().isExhausted();
-
-    // Switch the scheduler to queue actions.
-    scheduler.runTasksImmediately(false);
-
-    // Shotgun twice as many insertions as the scheduler queue can handle.
-    for (int i = 0; i < RxRingBuffer.SIZE * 2; i++) {
-      contentResolver.insert(TABLE, values("key" + i, "val" + i));
-    }
-
-    scheduler.triggerActions();
-
-    // Assert we got all the events from the queue plus the one buffered from backpressure.
-    // Note: Because of the rebatching request behavior of observeOn, the initial emission is
-    // counted against this amount which is why there is no +1 on SIZE.
-    for (int i = 0; i < RxRingBuffer.SIZE; i++) {
-      o.assertCursor(); // Ignore contents, just assert we got notified.
-    }
-  }
-
   public void testInitialValueAndTriggerUsesScheduler() {
     scheduler.runTasksImmediately(false);
 
-    subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
+    db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
     o.assertNoMoreEvents();
     scheduler.triggerActions();
     o.assertCursor().isExhausted();
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/BriteDatabaseTest.java
similarity index 76%
rename from sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java
rename to sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/BriteDatabaseTest.java
index 98f7cab..07d528d 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/BriteDatabaseTest.java
@@ -13,21 +13,32 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.sqlbrite;
+package com.squareup.sqlbrite3;
 
 import android.annotation.TargetApi;
+import android.arch.persistence.db.SimpleSQLiteQuery;
+import android.arch.persistence.db.SupportSQLiteDatabase;
+import android.arch.persistence.db.SupportSQLiteOpenHelper;
+import android.arch.persistence.db.SupportSQLiteOpenHelper.Configuration;
+import android.arch.persistence.db.SupportSQLiteOpenHelper.Factory;
+import android.arch.persistence.db.SupportSQLiteStatement;
+import android.arch.persistence.db.framework.FrameworkSQLiteOpenHelperFactory;
 import android.content.ContentValues;
 import android.database.Cursor;
 import android.database.SQLException;
-import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteException;
-import android.database.sqlite.SQLiteStatement;
 import android.os.Build;
 import android.support.test.InstrumentationRegistry;
 import android.support.test.filters.SdkSuppress;
 import android.support.test.runner.AndroidJUnit4;
-import com.squareup.sqlbrite.BriteDatabase.Transaction;
-import com.squareup.sqlbrite.TestDb.Employee;
+import com.squareup.sqlbrite3.BriteDatabase.Transaction;
+import com.squareup.sqlbrite3.RecordingObserver.CursorAssert;
+import com.squareup.sqlbrite3.TestDb.Employee;
+import io.reactivex.Observable;
+import io.reactivex.ObservableSource;
+import io.reactivex.ObservableTransformer;
+import io.reactivex.functions.Consumer;
+import io.reactivex.subjects.PublishSubject;
 import java.io.Closeable;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -43,46 +54,45 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 import org.junit.runner.RunWith;
-import rx.Observable;
-import rx.Observable.Transformer;
-import rx.Subscription;
-import rx.functions.Action1;
-import rx.internal.util.RxRingBuffer;
-import rx.subjects.PublishSubject;
 
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE;
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_NONE;
 import static com.google.common.truth.Truth.assertThat;
-import static com.squareup.sqlbrite.RecordingObserver.CursorAssert;
-import static com.squareup.sqlbrite.SqlBrite.Query;
-import static com.squareup.sqlbrite.TestDb.BOTH_TABLES;
-import static com.squareup.sqlbrite.TestDb.EmployeeTable.NAME;
-import static com.squareup.sqlbrite.TestDb.EmployeeTable.USERNAME;
-import static com.squareup.sqlbrite.TestDb.SELECT_EMPLOYEES;
-import static com.squareup.sqlbrite.TestDb.SELECT_MANAGER_LIST;
-import static com.squareup.sqlbrite.TestDb.TABLE_EMPLOYEE;
-import static com.squareup.sqlbrite.TestDb.TABLE_MANAGER;
-import static com.squareup.sqlbrite.TestDb.employee;
-import static com.squareup.sqlbrite.TestDb.manager;
+import static com.squareup.sqlbrite3.SqlBrite.Query;
+import static com.squareup.sqlbrite3.TestDb.BOTH_TABLES;
+import static com.squareup.sqlbrite3.TestDb.EmployeeTable.NAME;
+import static com.squareup.sqlbrite3.TestDb.EmployeeTable.USERNAME;
+import static com.squareup.sqlbrite3.TestDb.SELECT_EMPLOYEES;
+import static com.squareup.sqlbrite3.TestDb.SELECT_MANAGER_LIST;
+import static com.squareup.sqlbrite3.TestDb.TABLE_EMPLOYEE;
+import static com.squareup.sqlbrite3.TestDb.TABLE_MANAGER;
+import static com.squareup.sqlbrite3.TestDb.employee;
+import static com.squareup.sqlbrite3.TestDb.manager;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.junit.Assert.fail;
 
-@RunWith(AndroidJUnit4.class)
+@RunWith(AndroidJUnit4.class) //
 public final class BriteDatabaseTest {
+  private final TestDb testDb = new TestDb();
   private final List<String> logs = new ArrayList<>();
   private final RecordingObserver o = new RecordingObserver();
   private final TestScheduler scheduler = new TestScheduler();
-  private final PublishSubject<Void> killSwitch = PublishSubject.create();
+  private final PublishSubject<Object> killSwitch = PublishSubject.create();
 
-  private TestDb helper;
-  private SQLiteDatabase real;
-  private BriteDatabase db;
+  @Rule public final TemporaryFolder dbFolder = new TemporaryFolder();
 
-  @Rule
-  public TemporaryFolder dbFolder = new TemporaryFolder();
+  private SupportSQLiteDatabase real;
+  private BriteDatabase db;
 
   @Before public void setUp() throws IOException {
-    helper = new TestDb(InstrumentationRegistry.getContext(), dbFolder.newFile().getPath());
+    Configuration configuration = Configuration.builder(InstrumentationRegistry.getContext())
+        .callback(testDb)
+        .name(dbFolder.newFile().getPath())
+        .build();
+
+    Factory factory = new FrameworkSQLiteOpenHelperFactory();
+    SupportSQLiteOpenHelper helper = factory.create(configuration);
     real = helper.getWritableDatabase();
 
     SqlBrite.Logger logger = new SqlBrite.Logger() {
@@ -90,11 +100,12 @@
         logs.add(message);
       }
     };
-    Transformer<Query, Query> queryTransformer = new Transformer<Query, Query>() {
-      @Override public Observable<Query> call(Observable<Query> queryObservable) {
-        return queryObservable.takeUntil(killSwitch);
-      }
-    };
+    ObservableTransformer<Query, Query> queryTransformer =
+        new ObservableTransformer<Query, Query>() {
+          @Override public ObservableSource<Query> apply(Observable<Query> upstream) {
+            return upstream.takeUntil(killSwitch);
+          }
+        };
     db = new BriteDatabase(helper, logger, scheduler, queryTransformer);
   }
 
@@ -104,16 +115,60 @@
 
   @Test public void loggerEnabled() {
     db.setLoggingEnabled(true);
-    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
     assertThat(logs).isNotEmpty();
   }
 
   @Test public void loggerDisabled() {
     db.setLoggingEnabled(false);
-    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
     assertThat(logs).isEmpty();
   }
 
+  @Test public void loggerIndentsSqlForCreateQuery() {
+    db.setLoggingEnabled(true);
+    QueryObservable query = db.createQuery(TABLE_EMPLOYEE, "SELECT\n1");
+    query.subscribe(new Consumer<Query>() {
+      @Override public void accept(Query query) throws Exception {
+        query.run().close();
+      }
+    });
+    assertThat(logs).containsExactly(""
+        + "QUERY\n"
+        + "  tables: [employee]\n"
+        + "  sql: SELECT\n"
+        + "       1");
+  }
+
+  @Test public void loggerIndentsSqlForQuery() {
+    db.setLoggingEnabled(true);
+    db.query("SELECT\n1").close();
+    assertThat(logs).containsExactly(""
+        + "QUERY\n"
+        + "  sql: SELECT\n"
+        + "       1\n"
+        + "  args: []");
+  }
+
+  @Test public void loggerIndentsSqlForExecute() {
+    db.setLoggingEnabled(true);
+    db.execute("PRAGMA\ncompile_options");
+    assertThat(logs).containsExactly(""
+        + "EXECUTE\n"
+        + "  sql: PRAGMA\n"
+        + "       compile_options");
+  }
+
+  @Test public void loggerIndentsSqlForExecuteWithArgs() {
+    db.setLoggingEnabled(true);
+    db.execute("PRAGMA\ncompile_options", new Object[0]);
+    assertThat(logs).containsExactly(""
+        + "EXECUTE\n"
+        + "  sql: PRAGMA\n"
+        + "       compile_options\n"
+        + "  args: []");
+  }
+
   @Test public void closePropagates() {
     db.close();
     assertThat(real.isOpen()).isFalse();
@@ -128,11 +183,19 @@
         .isExhausted();
   }
 
+  @Test public void queryWithQueryObject() {
+    db.createQuery(TABLE_EMPLOYEE, new SimpleSQLiteQuery(SELECT_EMPLOYEES)).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+  }
+
   @Test public void queryMapToList() {
     List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
         .mapToList(Employee.MAPPER)
-        .toBlocking()
-        .first();
+        .blockingFirst();
     assertThat(employees).containsExactly( //
         new Employee("alice", "Alice Allison"), //
         new Employee("bob", "Bob Bobberson"), //
@@ -142,26 +205,27 @@
   @Test public void queryMapToOne() {
     Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
         .mapToOne(Employee.MAPPER)
-        .toBlocking()
-        .first();
+        .blockingFirst();
     assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
   }
 
   @Test public void queryMapToOneOrDefault() {
     Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
-        .mapToOneOrDefault(Employee.MAPPER, null)
-        .toBlocking()
-        .first();
+        .mapToOneOrDefault(Employee.MAPPER, new Employee("wrong", "Wrong Person"))
+        .blockingFirst();
     assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
   }
 
   @Test public void badQueryCallsError() {
-    db.createQuery(TABLE_EMPLOYEE, "SELECT * FROM missing").subscribe(o);
+    // safeSubscribe is needed because the error occurs in onNext and will otherwise bubble up
+    // to the thread exception handler.
+    db.createQuery(TABLE_EMPLOYEE, "SELECT * FROM missing").safeSubscribe(o);
     o.assertErrorContains("no such table: missing");
   }
 
   @Test public void queryWithArgs() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE " + USERNAME + " = ?", "bob")
+    db.createQuery(
+        TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE " + USERNAME + " = ?", "bob")
         .subscribe(o);
     o.assertCursor()
         .hasRow("bob", "Bob Bobberson")
@@ -176,7 +240,7 @@
         .hasRow("eve", "Eve Evenson")
         .isExhausted();
 
-    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
     o.assertCursor()
         .hasRow("alice", "Alice Allison")
         .hasRow("bob", "Bob Bobberson")
@@ -197,7 +261,7 @@
         .hasRow("eve", "Eve Evenson")
         .isExhausted();
 
-    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
     o.assertNoMoreEvents();
     scheduler.triggerActions();
     o.assertCursor()
@@ -216,7 +280,7 @@
         .hasRow("eve", "Eve Evenson")
         .isExhausted();
 
-    db.insert(TABLE_EMPLOYEE, employee("bob", "Bob Bobberson"), CONFLICT_IGNORE);
+    db.insert(TABLE_EMPLOYEE, CONFLICT_IGNORE, employee("bob", "Bob Bobberson"));
     o.assertNoMoreEvents();
   }
 
@@ -228,10 +292,10 @@
         .hasRow("eve", "Eve Evenson")
         .isExhausted();
 
-    killSwitch.onNext(null);
+    killSwitch.onNext("kill");
     o.assertIsCompleted();
 
-    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
     o.assertNoMoreEvents();
   }
 
@@ -245,7 +309,7 @@
 
     ContentValues values = new ContentValues();
     values.put(NAME, "Robert Bobberson");
-    db.update(TABLE_EMPLOYEE, values, USERNAME + " = 'bob'");
+    db.update(TABLE_EMPLOYEE, CONFLICT_NONE, values, USERNAME + " = 'bob'");
     o.assertCursor()
         .hasRow("alice", "Alice Allison")
         .hasRow("bob", "Robert Bobberson")
@@ -263,7 +327,7 @@
 
     ContentValues values = new ContentValues();
     values.put(NAME, "John Johnson");
-    db.update(TABLE_EMPLOYEE, values, USERNAME + " = 'john'");
+    db.update(TABLE_EMPLOYEE, CONFLICT_NONE, values, USERNAME + " = 'john'");
     o.assertNoMoreEvents();
   }
 
@@ -301,6 +365,13 @@
         .isExhausted();
   }
 
+  @Test public void queryMultipleTablesWithQueryObject() {
+    db.createQuery(BOTH_TABLES, new SimpleSQLiteQuery(SELECT_MANAGER_LIST)).subscribe(o);
+    o.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+  }
+
   @Test public void queryMultipleTablesObservesChanges() {
     db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
     o.assertCursor()
@@ -308,13 +379,13 @@
         .isExhausted();
 
     // A new employee triggers, despite the fact that it's not in our result set.
-    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
     o.assertCursor()
         .hasRow("Eve Evenson", "Alice Allison")
         .isExhausted();
 
     // A new manager also triggers and it is in our result set.
-    db.insert(TABLE_MANAGER, manager(helper.bobId, helper.eveId));
+    db.insert(TABLE_MANAGER, CONFLICT_NONE, manager(testDb.bobId, testDb.eveId));
     o.assertCursor()
         .hasRow("Eve Evenson", "Alice Allison")
         .hasRow("Bob Bobberson", "Eve Evenson")
@@ -331,22 +402,22 @@
 
     ContentValues values = new ContentValues();
     values.put(NAME, "Even Evenson");
-    db.update(TABLE_EMPLOYEE, values, USERNAME + " = 'eve'");
+    db.update(TABLE_EMPLOYEE, CONFLICT_NONE, values, USERNAME + " = 'eve'");
     o.assertCursor()
         .hasRow("Even Evenson", "Alice Allison")
         .isExhausted();
   }
 
-  @Test public void queryNotNotifiedAfterUnsubscribe() {
-    Subscription subscription = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+  @Test public void queryNotNotifiedAfterDispose() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
     o.assertCursor()
         .hasRow("alice", "Alice Allison")
         .hasRow("bob", "Bob Bobberson")
         .hasRow("eve", "Eve Evenson")
         .isExhausted();
-    subscription.unsubscribe();
+    o.dispose();
 
-    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
     o.assertNoMoreEvents();
   }
 
@@ -354,7 +425,7 @@
     Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
     o.assertNoMoreEvents();
 
-    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
     o.assertNoMoreEvents();
 
     query.subscribe(o);
@@ -371,7 +442,7 @@
         .skip(1) // Skip initial
         .subscribe(o);
 
-    db.execute("UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+    db.execute("UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
     o.assertNoMoreEvents();
   }
 
@@ -380,7 +451,7 @@
         .skip(1) // Skip initial
         .subscribe(o);
 
-    db.execute("UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = ?", "Zach");
+    db.execute("UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = ?", "Zach");
     o.assertNoMoreEvents();
   }
 
@@ -393,7 +464,7 @@
         .isExhausted();
 
     db.executeAndTrigger(TABLE_EMPLOYEE,
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
     o.assertCursor()
         .hasRow("alice", "Zach")
         .hasRow("bob", "Zach")
@@ -416,7 +487,7 @@
 
     final Set<String> tablesToTrigger = Collections.unmodifiableSet(new HashSet<>(BOTH_TABLES));
     db.executeAndTrigger(tablesToTrigger,
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
 
     o.assertCursor()
         .hasRow("Zach", "Zach")
@@ -435,7 +506,7 @@
         .isExhausted();
 
     db.executeAndTrigger(Collections.<String>emptySet(),
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
 
     o.assertNoMoreEvents();
   }
@@ -447,7 +518,7 @@
 
     try {
       db.executeAndTrigger(TABLE_EMPLOYEE,
-          "UPDATE not_a_table SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+          "UPDATE not_a_table SET " + NAME + " = 'Zach'");
       fail();
     } catch (SQLException ignored) {
     }
@@ -463,7 +534,7 @@
         .isExhausted();
 
     db.executeAndTrigger(TABLE_EMPLOYEE,
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = ?", "Zach");
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = ?", "Zach");
     o.assertCursor()
         .hasRow("alice", "Zach")
         .hasRow("bob", "Zach")
@@ -478,7 +549,7 @@
 
     try {
       db.executeAndTrigger(TABLE_EMPLOYEE,
-          "UPDATE not_a_table SET " + TestDb.EmployeeTable.NAME + " = ?", "Zach");
+          "UPDATE not_a_table SET " + NAME + " = ?", "Zach");
       fail();
     } catch (SQLException ignored) {
     }
@@ -500,7 +571,7 @@
 
     final Set<String> tablesToTrigger = Collections.unmodifiableSet(new HashSet<>(BOTH_TABLES));
     db.executeAndTrigger(tablesToTrigger,
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = ?", "Zach");
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = ?", "Zach");
 
     o.assertCursor()
         .hasRow("Zach", "Zach")
@@ -519,14 +590,14 @@
         .isExhausted();
 
     db.executeAndTrigger(Collections.<String>emptySet(),
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = ?", "Zach");
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = ?", "Zach");
 
     o.assertNoMoreEvents();
   }
 
   @Test public void executeInsertAndTrigger() {
-    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
-        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") "
+    SupportSQLiteStatement statement = real.compileStatement("INSERT INTO "
+        + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") "
         + "VALUES ('Chad Chadson', 'chad')");
 
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
@@ -546,8 +617,8 @@
   }
 
   @Test public void executeInsertAndDontTrigger() {
-    SQLiteStatement statement = real.compileStatement("INSERT OR IGNORE INTO " + TABLE_EMPLOYEE + " ("
-        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") "
+    SupportSQLiteStatement statement = real.compileStatement("INSERT OR IGNORE INTO "
+        + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") "
         + "VALUES ('Alice Allison', 'alice')");
 
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
@@ -562,8 +633,8 @@
   }
 
   @Test public void executeInsertAndTriggerMultipleTables() {
-    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
-        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") "
+    SupportSQLiteStatement statement = real.compileStatement("INSERT INTO "
+        + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") "
         + "VALUES ('Chad Chadson', 'chad')");
 
     final RecordingObserver managerObserver = new RecordingObserver();
@@ -579,7 +650,8 @@
         .hasRow("eve", "Eve Evenson")
         .isExhausted();
 
-    final Set<String> employeeAndManagerTables = Collections.unmodifiableSet(new HashSet<>(BOTH_TABLES));
+    final Set<String> employeeAndManagerTables = Collections.unmodifiableSet(new HashSet<>(
+        BOTH_TABLES));
     db.executeInsert(employeeAndManagerTables, statement);
 
     o.assertCursor()
@@ -594,8 +666,8 @@
   }
 
   @Test public void executeInsertAndTriggerNoTables() {
-    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
-        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") "
+    SupportSQLiteStatement statement = real.compileStatement("INSERT INTO "
+        + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") "
         + "VALUES ('Chad Chadson', 'chad')");
 
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
@@ -611,8 +683,8 @@
   }
 
   @Test public void executeInsertThrowsAndDoesNotTrigger() {
-    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
-        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") "
+    SupportSQLiteStatement statement = real.compileStatement("INSERT INTO "
+        + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") "
         + "VALUES ('Alice Allison', 'alice')");
 
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
@@ -628,8 +700,8 @@
   }
 
   @Test public void executeInsertWithArgsAndTrigger() {
-    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
-        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") VALUES (?, ?)");
+    SupportSQLiteStatement statement = real.compileStatement("INSERT INTO "
+        + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") VALUES (?, ?)");
     statement.bindString(1, "Chad Chadson");
     statement.bindString(2, "chad");
 
@@ -650,8 +722,8 @@
   }
 
   @Test public void executeInsertWithArgsThrowsAndDoesNotTrigger() {
-    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
-        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") VALUES (?, ?)");
+    SupportSQLiteStatement statement = real.compileStatement("INSERT INTO "
+        + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") VALUES (?, ?)");
     statement.bindString(1, "Alice Aliison");
     statement.bindString(2, "alice");
 
@@ -670,8 +742,8 @@
   @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
   @Test public void executeUpdateDeleteAndTrigger() {
-    SQLiteStatement statement = real.compileStatement(
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+    SupportSQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
 
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
     o.assertCursor()
@@ -691,10 +763,10 @@
   @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
   @Test public void executeUpdateDeleteAndDontTrigger() {
-    SQLiteStatement statement = real.compileStatement(""
+    SupportSQLiteStatement statement = real.compileStatement(""
         + "UPDATE " + TABLE_EMPLOYEE
-        + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'"
-        + " WHERE " + TestDb.EmployeeTable.NAME + " = 'Rob'");
+        + " SET " + NAME + " = 'Zach'"
+        + " WHERE " + NAME + " = 'Rob'");
 
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
     o.assertCursor()
@@ -710,8 +782,8 @@
   @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
   @Test public void executeUpdateDeleteAndTriggerWithMultipleTables() {
-    SQLiteStatement statement = real.compileStatement(
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+    SupportSQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
 
 
     final RecordingObserver managerObserver = new RecordingObserver();
@@ -743,8 +815,8 @@
   @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
   @Test public void executeUpdateDeleteAndTriggerWithNoTables() {
-    SQLiteStatement statement = real.compileStatement(
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+    SupportSQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
 
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
     o.assertCursor()
@@ -761,8 +833,8 @@
   @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
   @Test public void executeUpdateDeleteThrowsAndDoesNotTrigger() {
-    SQLiteStatement statement = real.compileStatement(
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.USERNAME + " = 'alice'");
+    SupportSQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + USERNAME + " = 'alice'");
 
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
         .skip(1) // Skip initial
@@ -779,8 +851,8 @@
   @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
   @Test public void executeUpdateDeleteWithArgsAndTrigger() {
-    SQLiteStatement statement = real.compileStatement(
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = ?");
+    SupportSQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = ?");
     statement.bindString(1, "Zach");
 
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
@@ -801,8 +873,8 @@
   @TargetApi(Build.VERSION_CODES.HONEYCOMB)
   @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
   @Test public void executeUpdateDeleteWithArgsThrowsAndDoesNotTrigger() {
-    SQLiteStatement statement = real.compileStatement(
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.USERNAME + " = ?");
+    SupportSQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + USERNAME + " = ?");
     statement.bindString(1, "alice");
 
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
@@ -827,8 +899,8 @@
 
     Transaction transaction = db.newTransaction();
     try {
-      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-      db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
+      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
       o.assertNoMoreEvents();
 
       transaction.markSuccessful();
@@ -851,15 +923,15 @@
     // can result in creating a new transaction before the old is committed on the underlying DB.
 
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
-        .subscribe(new Action1<Query>() {
-          @Override public void call(Query query) {
+        .subscribe(new Consumer<Query>() {
+          @Override public void accept(Query query) {
             db.newTransaction().end();
           }
         });
 
     Transaction transaction = db.newTransaction();
     try {
-      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
       transaction.markSuccessful();
     } finally {
       transaction.end();
@@ -878,8 +950,8 @@
     //noinspection UnnecessaryLocalVariable
     Closeable closeableTransaction = transaction; // Verify type is implemented.
     try {
-      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-      db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
+      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
       transaction.markSuccessful();
     } finally {
       closeableTransaction.close();
@@ -904,8 +976,8 @@
 
     Transaction transaction = db.newTransaction();
     try {
-      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-      db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
+      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
       transaction.markSuccessful();
     } finally {
       transaction.close(); // Transactions should not throw on close().
@@ -935,18 +1007,6 @@
   @Test public void querySubscribedToDuringTransactionThrows() {
     Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
 
-    //noinspection CheckResult
-    db.newTransaction();
-    query.subscribe(o);
-    o.assertErrorContains("Cannot subscribe to observable query in a transaction.");
-  }
-
-  @Test public void querySubscribedToDuringTransactionThrowsWithBackpressure() {
-    o.doRequest(0);
-
-    Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
-
-    //noinspection CheckResult
     db.newTransaction();
     query.subscribe(o);
     o.assertErrorContains("Cannot subscribe to observable query in a transaction.");
@@ -993,8 +1053,8 @@
 
     Transaction transaction = db.newTransaction();
     try {
-      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-      db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
+      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
       transaction.markSuccessful();
     } finally {
       transaction.end();
@@ -1033,8 +1093,8 @@
           .hasRow("eve", "Eve Evenson")
           .isExhausted();
 
-      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-      db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
+      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
 
       assertCursor(db.query(SELECT_EMPLOYEES))
           .hasRow("alice", "Alice Allison")
@@ -1060,11 +1120,11 @@
 
     Transaction transactionOuter = db.newTransaction();
     try {
-      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
 
       Transaction transactionInner = db.newTransaction();
       try {
-        db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
+        db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
         transactionInner.markSuccessful();
       } finally {
         transactionInner.end();
@@ -1095,7 +1155,7 @@
 
       Transaction transactionInner = db.newTransaction();
       try {
-        db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+        db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
         transactionInner.markSuccessful();
       } finally {
         transactionInner.end();
@@ -1103,7 +1163,7 @@
 
       transactionInner = db.newTransaction();
       try {
-        db.insert(TABLE_MANAGER, manager(helper.aliceId, helper.bobId));
+        db.insert(TABLE_MANAGER, CONFLICT_NONE, manager(testDb.aliceId, testDb.bobId));
         transactionInner.markSuccessful();
       } finally {
         transactionInner.end();
@@ -1147,8 +1207,8 @@
 
     Transaction transaction = db.newTransaction();
     try {
-      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-      db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
+      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
       // No call to set successful.
     } finally {
       transaction.end();
@@ -1168,7 +1228,7 @@
         Transaction transaction = db.newNonExclusiveTransaction();
         transactionStarted.countDown();
         try {
-          db.insert(TABLE_EMPLOYEE, employee("hans", "Hans Hanson"));
+          db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("hans", "Hans Hanson"));
           transactionProceed.await(10, SECONDS);
         } catch (InterruptedException e) {
           throw new RuntimeException("Exception in transaction thread", e);
@@ -1184,85 +1244,13 @@
     //Simple query
     Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
             .lift(Query.mapToOne(Employee.MAPPER))
-            .toBlocking()
-            .first();
+            .blockingFirst();
     assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
 
     transactionProceed.countDown();
     assertThat(transactionCompleted.await(10, SECONDS)).isTrue();
   }
 
-  @Test public void backpressureSupportedWhenConsumerSlow() {
-    o.doRequest(2);
-
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("john", "John Johnson")
-        .isExhausted();
-
-    db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
-    o.assertNoMoreEvents();
-
-    db.delete(TABLE_EMPLOYEE, USERNAME + "=?", "bob");
-    o.assertNoMoreEvents();
-
-    o.doRequest(1);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("john", "John Johnson")
-        .hasRow("nick", "Nick Nickers")
-        .isExhausted();
-
-    db.delete(TABLE_EMPLOYEE, USERNAME + "=?", "eve");
-    o.assertNoMoreEvents();
-    db.delete(TABLE_EMPLOYEE, USERNAME + "=?", "alice");
-    o.assertNoMoreEvents();
-
-    o.doRequest(Long.MAX_VALUE);
-    o.assertCursor()
-        .hasRow("john", "John Johnson")
-        .hasRow("nick", "Nick Nickers")
-        .isExhausted();
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void backpressureSupportedWhenSchedulerSlow() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    // Switch the scheduler to queue actions.
-    scheduler.runTasksImmediately(false);
-
-    // Shotgun twice as many insertions as the scheduler queue can handle.
-    for (int i = 0; i < RxRingBuffer.SIZE * 2; i++) {
-      db.insert(TABLE_EMPLOYEE, employee("user" + i, "name" + i));
-    }
-
-    scheduler.triggerActions();
-
-    // Assert we got all the events from the queue plus the one buffered from backpressure.
-    // Note: Because of the rebatching request behavior of observeOn, the initial emission is
-    // counted against this amount which is why there is no +1 on SIZE.
-    for (int i = 0; i < RxRingBuffer.SIZE; i++) {
-      o.assertCursor(); // Ignore contents, just assert we got notified.
-    }
-  }
-
   @Test public void badQueryThrows() {
     try {
       //noinspection CheckResult
@@ -1275,7 +1263,7 @@
 
   @Test public void badInsertThrows() {
     try {
-      db.insert("missing", employee("john", "John Johnson"));
+      db.insert("missing", CONFLICT_NONE, employee("john", "John Johnson"));
       fail();
     } catch (SQLiteException e) {
       assertThat(e.getMessage()).contains("no such table: missing");
@@ -1284,7 +1272,7 @@
 
   @Test public void badUpdateThrows() {
     try {
-      db.update("missing", employee("john", "John Johnson"), "1");
+      db.update("missing", CONFLICT_NONE, employee("john", "John Johnson"), "1");
       fail();
     } catch (SQLiteException e) {
       assertThat(e.getMessage()).contains("no such table: missing");
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/QueryObservableTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/QueryObservableTest.java
new file mode 100644
index 0000000..5803205
--- /dev/null
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/QueryObservableTest.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.sqlbrite3;
+
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import com.squareup.sqlbrite3.QueryObservable;
+import com.squareup.sqlbrite3.SqlBrite.Query;
+import io.reactivex.Observable;
+import io.reactivex.functions.Function;
+import org.junit.Test;
+
+public final class QueryObservableTest {
+  @Test public void mapToListThrowsFromQueryRun() {
+    final IllegalStateException error = new IllegalStateException("test exception");
+    Query query = new Query() {
+      @Override public Cursor run() {
+        throw error;
+      }
+    };
+    new QueryObservable(Observable.just(query)) //
+        .mapToList(new Function<Cursor, Object>() {
+          @Override public Object apply(Cursor cursor) {
+            throw new AssertionError("Must not be called");
+          }
+        }) //
+        .test() //
+        .assertNoValues() //
+        .assertError(error);
+  }
+
+  @Test public void mapToListThrowsFromMapFunction() {
+    Query query = new Query() {
+      @Override public Cursor run() {
+        MatrixCursor cursor = new MatrixCursor(new String[] { "col1" });
+        cursor.addRow(new Object[] { "value1" });
+        return cursor;
+      }
+    };
+
+    final IllegalStateException error = new IllegalStateException("test exception");
+    new QueryObservable(Observable.just(query)) //
+        .mapToList(new Function<Cursor, Object>() {
+          @Override public Object apply(Cursor cursor) {
+            throw error;
+          }
+        }) //
+        .test() //
+        .assertNoValues() //
+        .assertError(error);
+  }
+}
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/QueryTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/QueryTest.java
new file mode 100644
index 0000000..dacecb8
--- /dev/null
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/QueryTest.java
@@ -0,0 +1,259 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.sqlbrite3;
+
+import android.arch.persistence.db.SupportSQLiteOpenHelper;
+import android.arch.persistence.db.SupportSQLiteOpenHelper.Configuration;
+import android.arch.persistence.db.SupportSQLiteOpenHelper.Factory;
+import android.arch.persistence.db.framework.FrameworkSQLiteOpenHelperFactory;
+import android.database.Cursor;
+import android.os.Build;
+import android.support.annotation.Nullable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.filters.SdkSuppress;
+import com.squareup.sqlbrite3.SqlBrite.Query;
+import com.squareup.sqlbrite3.TestDb.Employee;
+import io.reactivex.Observable;
+import io.reactivex.functions.Function;
+import io.reactivex.observers.TestObserver;
+import io.reactivex.schedulers.Schedulers;
+import java.util.List;
+import java.util.Optional;
+import org.junit.Before;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.squareup.sqlbrite3.TestDb.Employee.MAPPER;
+import static com.squareup.sqlbrite3.TestDb.SELECT_EMPLOYEES;
+import static com.squareup.sqlbrite3.TestDb.TABLE_EMPLOYEE;
+import static org.junit.Assert.fail;
+
+public final class QueryTest {
+  private BriteDatabase db;
+
+  @Before public void setUp() {
+    Configuration configuration = Configuration.builder(InstrumentationRegistry.getContext())
+        .callback(new TestDb())
+        .build();
+
+    Factory factory = new FrameworkSQLiteOpenHelperFactory();
+    SupportSQLiteOpenHelper helper = factory.create(configuration);
+
+    SqlBrite sqlBrite = new SqlBrite.Builder().build();
+    db = sqlBrite.wrapDatabaseHelper(helper, Schedulers.trampoline());
+  }
+
+  @Test public void mapToOne() {
+    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+        .lift(Query.mapToOne(MAPPER))
+        .blockingFirst();
+    assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
+  }
+
+  @Test public void mapToOneThrowsWhenMapperReturnsNull() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+        .lift(Query.mapToOne(new Function<Cursor, Employee>() {
+          @Override public Employee apply(Cursor cursor) throws Exception {
+            return null;
+          }
+        }))
+        .test()
+        .assertError(NullPointerException.class)
+        .assertErrorMessage("QueryToOne mapper returned null");
+  }
+
+  @Test public void mapToOneThrowsOnMultipleRows() {
+    Observable<Employee> employees =
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 2") //
+            .lift(Query.mapToOne(MAPPER));
+    try {
+      employees.blockingFirst();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Cursor returned more than 1 row");
+    }
+  }
+
+  @Test public void mapToOneIgnoresNullCursor() {
+    Query nully = new Query() {
+      @Nullable @Override public Cursor run() {
+        return null;
+      }
+    };
+
+    TestObserver<Employee> observer = new TestObserver<>();
+    Observable.just(nully)
+        .lift(Query.mapToOne(MAPPER))
+        .subscribe(observer);
+
+    observer.assertNoValues();
+    observer.assertComplete();
+  }
+
+  @Test public void mapToOneOrDefault() {
+    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+        .lift(Query.mapToOneOrDefault(
+            MAPPER, new Employee("fred", "Fred Frederson")))
+        .blockingFirst();
+    assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
+  }
+
+  @Test public void mapToOneOrDefaultDisallowsNullDefault() {
+    try {
+      Query.mapToOneOrDefault(MAPPER, null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("defaultValue == null");
+    }
+  }
+
+  @Test public void mapToOneOrDefaultThrowsWhenMapperReturnsNull() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+        .lift(Query.mapToOneOrDefault(new Function<Cursor, Employee>() {
+          @Override public Employee apply(Cursor cursor) throws Exception {
+            return null;
+          }
+        }, new Employee("fred", "Fred Frederson")))
+        .test()
+        .assertError(NullPointerException.class)
+        .assertErrorMessage("QueryToOne mapper returned null");
+  }
+
+  @Test public void mapToOneOrDefaultThrowsOnMultipleRows() {
+    Observable<Employee> employees =
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 2") //
+            .lift(Query.mapToOneOrDefault(
+                MAPPER, new Employee("fred", "Fred Frederson")));
+    try {
+      employees.blockingFirst();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Cursor returned more than 1 row");
+    }
+  }
+
+  @Test public void mapToOneOrDefaultReturnsDefaultWhenNullCursor() {
+    Employee defaultEmployee = new Employee("bob", "Bob Bobberson");
+    Query nully = new Query() {
+      @Nullable @Override public Cursor run() {
+        return null;
+      }
+    };
+
+    TestObserver<Employee> observer = new TestObserver<>();
+    Observable.just(nully)
+        .lift(Query.mapToOneOrDefault(MAPPER, defaultEmployee))
+        .subscribe(observer);
+
+    observer.assertValues(defaultEmployee);
+    observer.assertComplete();
+  }
+
+  @Test public void mapToList() {
+    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+        .lift(Query.mapToList(MAPPER))
+        .blockingFirst();
+    assertThat(employees).containsExactly( //
+        new Employee("alice", "Alice Allison"), //
+        new Employee("bob", "Bob Bobberson"), //
+        new Employee("eve", "Eve Evenson"));
+  }
+
+  @Test public void mapToListEmptyWhenNoRows() {
+    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE 1=2")
+        .lift(Query.mapToList(MAPPER))
+        .blockingFirst();
+    assertThat(employees).isEmpty();
+  }
+
+  @Test public void mapToListReturnsNullOnMapperNull() {
+    Function<Cursor, Employee> mapToNull = new Function<Cursor, Employee>() {
+      private int count;
+
+      @Override public Employee apply(Cursor cursor) throws Exception {
+        return count++ == 2 ? null : MAPPER.apply(cursor);
+      }
+    };
+    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES) //
+            .lift(Query.mapToList(mapToNull)) //
+            .blockingFirst();
+
+    assertThat(employees).containsExactly(
+        new Employee("alice", "Alice Allison"),
+        new Employee("bob", "Bob Bobberson"),
+        null);
+  }
+
+  @Test public void mapToListIgnoresNullCursor() {
+    Query nully = new Query() {
+      @Nullable @Override public Cursor run() {
+        return null;
+      }
+    };
+
+    TestObserver<List<Employee>> subscriber = new TestObserver<>();
+    Observable.just(nully)
+        .lift(Query.mapToList(MAPPER))
+        .subscribe(subscriber);
+
+    subscriber.assertNoValues();
+    subscriber.assertComplete();
+  }
+
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  @Test public void mapToOptional() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+        .lift(Query.mapToOptional(MAPPER))
+        .test()
+        .assertValue(Optional.of(new Employee("alice", "Alice Allison")));
+  }
+
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  @Test public void mapToOptionalThrowsWhenMapperReturnsNull() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+        .lift(Query.mapToOptional(new Function<Cursor, Employee>() {
+          @Override public Employee apply(Cursor cursor) throws Exception {
+            return null;
+          }
+        }))
+        .test()
+        .assertError(NullPointerException.class)
+        .assertErrorMessage("QueryToOne mapper returned null");
+  }
+
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  @Test public void mapToOptionalThrowsOnMultipleRows() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 2") //
+        .lift(Query.mapToOptional(MAPPER))
+        .test()
+        .assertError(IllegalStateException.class)
+        .assertErrorMessage("Cursor returned more than 1 row");
+  }
+
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+  @Test public void mapToOptionalIgnoresNullCursor() {
+    Query nully = new Query() {
+      @Nullable @Override public Cursor run() {
+        return null;
+      }
+    };
+
+    Observable.just(nully)
+        .lift(Query.mapToOptional(MAPPER))
+        .test()
+        .assertValue(Optional.<Employee>empty());
+  }
+}
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/RecordingObserver.java
similarity index 91%
rename from sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java
rename to sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/RecordingObserver.java
index c1deaf1..b6f7cdb 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/RecordingObserver.java
@@ -13,24 +13,24 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.sqlbrite;
+package com.squareup.sqlbrite3;
 
 import android.database.Cursor;
 import android.util.Log;
+import io.reactivex.observers.DisposableObserver;
 import java.util.concurrent.BlockingDeque;
 import java.util.concurrent.LinkedBlockingDeque;
-import rx.Subscriber;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.squareup.sqlbrite.SqlBrite.Query;
+import static com.squareup.sqlbrite3.SqlBrite.Query;
 
-class RecordingObserver extends Subscriber<Query> {
+class RecordingObserver extends DisposableObserver<Query> {
   private static final Object COMPLETED = "<completed>";
   private static final String TAG = RecordingObserver.class.getSimpleName();
 
   final BlockingDeque<Object> events = new LinkedBlockingDeque<>();
 
-  @Override public final void onCompleted() {
+  @Override public final void onComplete() {
     Log.d(TAG, "onCompleted");
     events.add(COMPLETED);
   }
@@ -45,10 +45,6 @@
     events.add(value.run());
   }
 
-  public final void doRequest(long amount) {
-    request(amount);
-  }
-
   protected Object takeEvent() {
     Object item = events.removeFirst();
     if (item == null) {
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/SqlBriteTest.java
similarity index 75%
rename from sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java
rename to sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/SqlBriteTest.java
index 6a5821a..4c96b14 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/SqlBriteTest.java
@@ -1,16 +1,15 @@
-package com.squareup.sqlbrite;
+package com.squareup.sqlbrite3;
 
 import android.database.Cursor;
 import android.database.MatrixCursor;
 import android.support.annotation.Nullable;
 import android.support.test.runner.AndroidJUnit4;
-import com.squareup.sqlbrite.SqlBrite.Query;
+import com.squareup.sqlbrite3.SqlBrite.Query;
+import io.reactivex.functions.Function;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import rx.functions.Func1;
-import rx.observers.TestSubscriber;
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
@@ -38,19 +37,10 @@
     }
   }
 
-  @Test public void createDisallowsNull() {
-    try {
-      SqlBrite.create(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("logger == null");
-    }
-  }
-
   @Test public void asRowsEmpty() {
     MatrixCursor cursor = new MatrixCursor(COLUMN_NAMES);
     Query query = new CursorQuery(cursor);
-    List<Name> names = query.asRows(Name.MAP).toList().toBlocking().first();
+    List<Name> names = query.asRows(Name.MAP).toList().blockingGet();
     assertThat(names).isEmpty();
   }
 
@@ -60,7 +50,7 @@
     cursor.addRow(new Object[] { "Bob", "Bobberson" });
 
     Query query = new CursorQuery(cursor);
-    List<Name> names = query.asRows(Name.MAP).toList().toBlocking().first();
+    List<Name> names = query.asRows(Name.MAP).toList().blockingGet();
     assertThat(names).containsExactly(new Name("Alice", "Allison"), new Name("Bob", "Bobberson"));
   }
 
@@ -71,12 +61,12 @@
 
     Query query = new CursorQuery(cursor);
     final AtomicInteger count = new AtomicInteger();
-    query.asRows(new Func1<Cursor, Name>() {
-      @Override public Name call(Cursor cursor) {
+    query.asRows(new Function<Cursor, Name>() {
+      @Override public Name apply(Cursor cursor) throws Exception {
         count.incrementAndGet();
-        return Name.MAP.call(cursor);
+        return Name.MAP.apply(cursor);
       }
-    }).take(1).toBlocking().first();
+    }).take(1).blockingFirst();
     assertThat(count.get()).isEqualTo(1);
   }
 
@@ -87,24 +77,20 @@
       }
     };
 
-    TestSubscriber<Name> subscriber = new TestSubscriber<>();
     final AtomicInteger count = new AtomicInteger();
-    nully.asRows(new Func1<Cursor, Name>() {
-      @Override public Name call(Cursor cursor) {
+    nully.asRows(new Function<Cursor, Name>() {
+      @Override public Name apply(Cursor cursor) throws Exception {
         count.incrementAndGet();
-        return Name.MAP.call(cursor);
+        return Name.MAP.apply(cursor);
       }
-    }).subscribe(subscriber);
-
-    subscriber.assertNoValues();
-    subscriber.assertCompleted();
+    }).test().assertNoValues().assertComplete();
 
     assertThat(count.get()).isEqualTo(0);
   }
 
   static final class Name {
-    static final Func1<Cursor, Name> MAP = new Func1<Cursor, Name>() {
-      @Override public Name call(Cursor cursor) {
+    static final Function<Cursor, Name> MAP = new Function<Cursor, Name>() {
+      @Override public Name apply(Cursor cursor) {
         return new Name( //
             cursor.getString(cursor.getColumnIndexOrThrow(FIRST_NAME)),
             cursor.getString(cursor.getColumnIndexOrThrow(LAST_NAME)));
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestDb.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/TestDb.java
similarity index 74%
rename from sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestDb.java
rename to sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/TestDb.java
index 04f9681..df91280 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestDb.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/TestDb.java
@@ -13,25 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.sqlbrite;
+package com.squareup.sqlbrite3;
 
+import android.arch.persistence.db.SupportSQLiteDatabase;
+import android.arch.persistence.db.SupportSQLiteOpenHelper;
 import android.content.ContentValues;
-import android.content.Context;
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
 import android.support.annotation.NonNull;
+import io.reactivex.functions.Function;
 import java.util.Arrays;
 import java.util.Collection;
-import rx.functions.Func1;
 
-import static com.squareup.sqlbrite.TestDb.EmployeeTable.ID;
-import static com.squareup.sqlbrite.TestDb.EmployeeTable.NAME;
-import static com.squareup.sqlbrite.TestDb.EmployeeTable.USERNAME;
-import static com.squareup.sqlbrite.TestDb.ManagerTable.EMPLOYEE_ID;
-import static com.squareup.sqlbrite.TestDb.ManagerTable.MANAGER_ID;
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_FAIL;
+import static com.squareup.sqlbrite3.TestDb.EmployeeTable.ID;
+import static com.squareup.sqlbrite3.TestDb.EmployeeTable.NAME;
+import static com.squareup.sqlbrite3.TestDb.EmployeeTable.USERNAME;
+import static com.squareup.sqlbrite3.TestDb.ManagerTable.EMPLOYEE_ID;
+import static com.squareup.sqlbrite3.TestDb.ManagerTable.MANAGER_ID;
 
-final class TestDb extends SQLiteOpenHelper {
+final class TestDb extends SupportSQLiteOpenHelper.Callback {
   static final String TABLE_EMPLOYEE = "employee";
   static final String TABLE_MANAGER = "manager";
 
@@ -54,8 +54,8 @@
   }
 
   static final class Employee {
-    static final Func1<Cursor, Employee> MAPPER = new Func1<Cursor, Employee>() {
-      @Override public Employee call(Cursor cursor) {
+    static final Function<Cursor, Employee> MAPPER = new Function<Cursor, Employee>() {
+      @Override public Employee apply(Cursor cursor) {
         return new Employee( //
             cursor.getString(cursor.getColumnIndexOrThrow(EmployeeTable.USERNAME)),
             cursor.getString(cursor.getColumnIndexOrThrow(EmployeeTable.NAME)));
@@ -105,20 +105,20 @@
   long bobId;
   long eveId;
 
-  TestDb(Context context, String path) {
-    super(context, path, null /* cursor factory */, 1 /* version */);
+  TestDb() {
+    super(1);
   }
 
-  @Override public void onCreate(@NonNull SQLiteDatabase db) {
+  @Override public void onCreate(@NonNull SupportSQLiteDatabase db) {
     db.execSQL("PRAGMA foreign_keys=ON");
 
     db.execSQL(CREATE_EMPLOYEE);
-    aliceId = db.insert(TABLE_EMPLOYEE, null, employee("alice", "Alice Allison"));
-    bobId = db.insert(TABLE_EMPLOYEE, null, employee("bob", "Bob Bobberson"));
-    eveId = db.insert(TABLE_EMPLOYEE, null, employee("eve", "Eve Evenson"));
+    aliceId = db.insert(TABLE_EMPLOYEE, CONFLICT_FAIL, employee("alice", "Alice Allison"));
+    bobId = db.insert(TABLE_EMPLOYEE, CONFLICT_FAIL, employee("bob", "Bob Bobberson"));
+    eveId = db.insert(TABLE_EMPLOYEE, CONFLICT_FAIL, employee("eve", "Eve Evenson"));
 
     db.execSQL(CREATE_MANAGER);
-    db.insert(TABLE_MANAGER, null, manager(eveId, aliceId));
+    db.insert(TABLE_MANAGER, CONFLICT_FAIL, manager(eveId, aliceId));
   }
 
   static ContentValues employee(String username, String name) {
@@ -135,7 +135,8 @@ static ContentValues manager(long employeeId, long managerId) {
     return values;
   }
 
-  @Override public void onUpgrade(@NonNull SQLiteDatabase db, int oldVersion, int newVersion) {
+  @Override
+  public void onUpgrade(@NonNull SupportSQLiteDatabase db, int oldVersion, int newVersion) {
     throw new AssertionError();
   }
 }
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestScheduler.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/TestScheduler.java
similarity index 60%
rename from sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestScheduler.java
rename to sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/TestScheduler.java
index 04aee49..92ba16e 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestScheduler.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/TestScheduler.java
@@ -13,15 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.sqlbrite;
+package com.squareup.sqlbrite3;
 
+import io.reactivex.Scheduler;
+import io.reactivex.annotations.NonNull;
+import io.reactivex.disposables.Disposable;
 import java.util.concurrent.TimeUnit;
-import rx.Scheduler;
-import rx.Subscription;
-import rx.functions.Action0;
 
 final class TestScheduler extends Scheduler {
-  private final rx.schedulers.TestScheduler delegate = new rx.schedulers.TestScheduler();
+  private final io.reactivex.schedulers.TestScheduler delegate =
+      new io.reactivex.schedulers.TestScheduler();
+
   private boolean runTasksImmediately = true;
 
   public void runTasksImmediately(boolean runTasksImmediately) {
@@ -39,28 +41,21 @@ public void triggerActions() {
   class TestWorker extends Worker {
     private final Worker delegateWorker = delegate.createWorker();
 
-    @Override public Subscription schedule(Action0 action) {
-      Subscription subscription = delegateWorker.schedule(action);
-      if (runTasksImmediately) {
-        triggerActions();
-      }
-      return subscription;
-    }
-
-    @Override public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
-      Subscription subscription = delegateWorker.schedule(action, delayTime, unit);
+    @Override
+    public Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {
+      Disposable disposable = delegateWorker.schedule(run, delay, unit);
       if (runTasksImmediately) {
         triggerActions();
       }
-      return subscription;
+      return disposable;
     }
 
-    @Override public void unsubscribe() {
-      delegateWorker.unsubscribe();
+    @Override public void dispose() {
+      delegateWorker.dispose();
     }
 
-    @Override public boolean isUnsubscribed() {
-      return delegateWorker.isUnsubscribed();
+    @Override public boolean isDisposed() {
+      return delegateWorker.isDisposed();
     }
   }
 }
diff --git a/sqlbrite/src/main/AndroidManifest.xml b/sqlbrite/src/main/AndroidManifest.xml
index eba4a1d..2fa9a3a 100644
--- a/sqlbrite/src/main/AndroidManifest.xml
+++ b/sqlbrite/src/main/AndroidManifest.xml
@@ -1,8 +1 @@
-<?xml version="1.0" encoding="utf-8"?>
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.squareup.sqlbrite">
-
-  <uses-sdk android:minSdkVersion="9"/>
-
-</manifest>
+<manifest package="com.squareup.sqlbrite2"/>
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
deleted file mode 100644
index dce4ab5..0000000
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package com.squareup.sqlbrite;
-
-import android.database.Cursor;
-import java.util.ArrayList;
-import java.util.List;
-import rx.Observable;
-import rx.Subscriber;
-import rx.exceptions.Exceptions;
-import rx.exceptions.OnErrorThrowable;
-import rx.functions.Func1;
-
-final class QueryToListOperator<T> implements Observable.Operator<List<T>, SqlBrite.Query> {
-  final Func1<Cursor, T> mapper;
-
-  QueryToListOperator(Func1<Cursor, T> mapper) {
-    this.mapper = mapper;
-  }
-
-  @Override
-  public Subscriber<? super SqlBrite.Query> call(final Subscriber<? super List<T>> subscriber) {
-    return new Subscriber<SqlBrite.Query>(subscriber) {
-      @Override public void onNext(SqlBrite.Query query) {
-        try {
-          Cursor cursor = query.run();
-          if (cursor == null || subscriber.isUnsubscribed()) {
-            return;
-          }
-          List<T> items = new ArrayList<>(cursor.getCount());
-          try {
-            while (cursor.moveToNext()) {
-              items.add(mapper.call(cursor));
-            }
-          } finally {
-            cursor.close();
-          }
-          if (!subscriber.isUnsubscribed()) {
-            subscriber.onNext(items);
-          }
-        } catch (Throwable e) {
-          Exceptions.throwIfFatal(e);
-          onError(OnErrorThrowable.addValueAsLastCause(e, query.toString()));
-        }
-      }
-
-      @Override public void onCompleted() {
-        subscriber.onCompleted();
-      }
-
-      @Override public void onError(Throwable e) {
-        subscriber.onError(e);
-      }
-    };
-  }
-}
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
deleted file mode 100644
index 55c86bc..0000000
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package com.squareup.sqlbrite;
-
-import android.database.Cursor;
-import rx.Observable;
-import rx.Subscriber;
-import rx.exceptions.Exceptions;
-import rx.exceptions.OnErrorThrowable;
-import rx.functions.Func1;
-
-final class QueryToOneOperator<T> implements Observable.Operator<T, SqlBrite.Query> {
-  final Func1<Cursor, T> mapper;
-  boolean emitDefault;
-  T defaultValue;
-
-  QueryToOneOperator(Func1<Cursor, T> mapper, boolean emitDefault, T defaultValue) {
-    this.mapper = mapper;
-    this.emitDefault = emitDefault;
-    this.defaultValue = defaultValue;
-  }
-
-  @Override public Subscriber<? super SqlBrite.Query> call(final Subscriber<? super T> subscriber) {
-    return new Subscriber<SqlBrite.Query>(subscriber) {
-      @Override public void onNext(SqlBrite.Query query) {
-        try {
-          boolean emit = false;
-          T item = null;
-          Cursor cursor = query.run();
-          if (cursor != null) {
-            try {
-              if (cursor.moveToNext()) {
-                item = mapper.call(cursor);
-                emit = true;
-                if (cursor.moveToNext()) {
-                  throw new IllegalStateException("Cursor returned more than 1 row");
-                }
-              }
-            } finally {
-              cursor.close();
-            }
-          }
-          if (!subscriber.isUnsubscribed()) {
-            if (emit) {
-              subscriber.onNext(item);
-            } else if (emitDefault) {
-              subscriber.onNext(defaultValue);
-            } else {
-              request(1L); // Account upstream for the lack of downstream emission.
-            }
-          }
-        } catch (Throwable e) {
-          Exceptions.throwIfFatal(e);
-          onError(OnErrorThrowable.addValueAsLastCause(e, query.toString()));
-        }
-      }
-
-      @Override public void onCompleted() {
-        subscriber.onCompleted();
-      }
-
-      @Override public void onError(Throwable e) {
-        subscriber.onError(e);
-      }
-    };
-  }
-}
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java b/sqlbrite/src/main/java/com/squareup/sqlbrite3/BriteContentResolver.java
similarity index 78%
rename from sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
rename to sqlbrite/src/main/java/com/squareup/sqlbrite3/BriteContentResolver.java
index 10d62b2..7b2ec06 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite3/BriteContentResolver.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.sqlbrite;
+package com.squareup.sqlbrite3;
 
 import android.content.ContentResolver;
 import android.database.ContentObserver;
@@ -24,17 +24,17 @@
 import android.support.annotation.CheckResult;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import com.squareup.sqlbrite3.SqlBrite.Logger;
+import com.squareup.sqlbrite3.SqlBrite.Query;
+import io.reactivex.Observable;
+import io.reactivex.ObservableEmitter;
+import io.reactivex.ObservableOnSubscribe;
+import io.reactivex.ObservableTransformer;
+import io.reactivex.Scheduler;
+import io.reactivex.functions.Cancellable;
 import java.util.Arrays;
-import rx.Observable;
-import rx.Observable.OnSubscribe;
-import rx.Observable.Transformer;
-import rx.Scheduler;
-import rx.Subscriber;
-import rx.functions.Action0;
-import rx.subscriptions.Subscriptions;
 
-import static com.squareup.sqlbrite.SqlBrite.Logger;
-import static com.squareup.sqlbrite.SqlBrite.Query;
+import static com.squareup.sqlbrite3.QueryObservable.QUERY_OBSERVABLE;
 import static java.lang.System.nanoTime;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
@@ -48,12 +48,12 @@
   final ContentResolver contentResolver;
   private final Logger logger;
   private final Scheduler scheduler;
-  private final Transformer<Query, Query> queryTransformer;
+  private final ObservableTransformer<Query, Query> queryTransformer;
 
   volatile boolean logging;
 
   BriteContentResolver(ContentResolver contentResolver, Logger logger, Scheduler scheduler,
-      Transformer<Query, Query> queryTransformer) {
+      ObservableTransformer<Query, Query> queryTransformer) {
     this.contentResolver = contentResolver;
     this.logger = logger;
     this.scheduler = scheduler;
@@ -108,34 +108,31 @@ public QueryObservable createQuery(@NonNull final Uri uri, @Nullable final Strin
         return cursor;
       }
     };
-    OnSubscribe<Query> subscribe = new OnSubscribe<Query>() {
-      @Override public void call(final Subscriber<? super Query> subscriber) {
+    Observable<Query> queries = Observable.create(new ObservableOnSubscribe<Query>() {
+      @Override public void subscribe(final ObservableEmitter<Query> e) throws Exception {
         final ContentObserver observer = new ContentObserver(contentObserverHandler) {
           @Override public void onChange(boolean selfChange) {
-            subscriber.onNext(query);
+            if (!e.isDisposed()) {
+              e.onNext(query);
+            }
           }
         };
         contentResolver.registerContentObserver(uri, notifyForDescendents, observer);
-        subscriber.add(Subscriptions.create(new Action0() {
-          @Override public void call() {
+        e.setCancellable(new Cancellable() {
+          @Override public void cancel() throws Exception {
             contentResolver.unregisterContentObserver(observer);
           }
-        }));
+        });
 
-        subscriber.onNext(query); // Trigger initial query.
+        if (!e.isDisposed()) {
+          e.onNext(query); // Trigger initial query.
+        }
       }
-    };
-    final Observable<Query> queryObservable = Observable.create(subscribe) //
-        .onBackpressureLatest() // Guard against uncontrollable frequency of upstream emissions.
+    });
+    return queries //
         .observeOn(scheduler) //
         .compose(queryTransformer) // Apply the user's query transformer.
-        .onBackpressureLatest(); // Guard against uncontrollable frequency of scheduler executions.
-    // TODO switch to .to() when non-@Experimental
-    return new QueryObservable(new OnSubscribe<Query>() {
-      @Override public void call(Subscriber<? super Query> subscriber) {
-        queryObservable.unsafeSubscribe(subscriber);
-      }
-    });
+        .to(QUERY_OBSERVABLE);
   }
 
   void log(String message, Object... args) {
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java b/sqlbrite/src/main/java/com/squareup/sqlbrite3/BriteDatabase.java
similarity index 72%
rename from sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
rename to sqlbrite/src/main/java/com/squareup/sqlbrite3/BriteDatabase.java
index a86d0db..6c5432b 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite3/BriteDatabase.java
@@ -13,22 +13,32 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.sqlbrite;
-
+package com.squareup.sqlbrite3;
+
+import android.arch.persistence.db.SimpleSQLiteQuery;
+import android.arch.persistence.db.SupportSQLiteDatabase;
+import android.arch.persistence.db.SupportSQLiteOpenHelper;
+import android.arch.persistence.db.SupportSQLiteOpenHelper.Callback;
+import android.arch.persistence.db.SupportSQLiteQuery;
+import android.arch.persistence.db.SupportSQLiteStatement;
 import android.content.ContentValues;
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.database.sqlite.SQLiteStatement;
 import android.database.sqlite.SQLiteTransactionListener;
-import android.os.Build;
 import android.support.annotation.CheckResult;
 import android.support.annotation.IntDef;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.support.annotation.RequiresApi;
 import android.support.annotation.WorkerThread;
-import com.squareup.sqlbrite.SqlBrite.Query;
+import com.squareup.sqlbrite3.SqlBrite.Logger;
+import com.squareup.sqlbrite3.SqlBrite.Query;
+import io.reactivex.Observable;
+import io.reactivex.ObservableTransformer;
+import io.reactivex.Scheduler;
+import io.reactivex.functions.Consumer;
+import io.reactivex.functions.Function;
+import io.reactivex.functions.Predicate;
+import io.reactivex.subjects.PublishSubject;
+import io.reactivex.subjects.Subject;
 import java.io.Closeable;
 import java.lang.annotation.Retention;
 import java.util.Arrays;
@@ -36,13 +46,6 @@
 import java.util.LinkedHashSet;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
-import rx.Observable;
-import rx.Observable.Transformer;
-import rx.Scheduler;
-import rx.Subscriber;
-import rx.functions.Action0;
-import rx.functions.Func1;
-import rx.subjects.PublishSubject;
 
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_ABORT;
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_FAIL;
@@ -50,24 +53,22 @@
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_NONE;
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_REPLACE;
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_ROLLBACK;
-import static android.os.Build.VERSION_CODES.HONEYCOMB;
-import static java.lang.System.nanoTime;
+import static com.squareup.sqlbrite3.QueryObservable.QUERY_OBSERVABLE;
 import static java.lang.annotation.RetentionPolicy.SOURCE;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
+import static java.util.Collections.singletonList;
 
 /**
- * A lightweight wrapper around {@link SQLiteOpenHelper} which allows for continuously observing
- * the result of a query. Create using a {@link SqlBrite} instance.
+ * A lightweight wrapper around {@link SupportSQLiteOpenHelper} which allows for continuously
+ * observing the result of a query. Create using a {@link SqlBrite} instance.
  */
 public final class BriteDatabase implements Closeable {
-  private final SQLiteOpenHelper helper;
-  private final SqlBrite.Logger logger;
-  private final Transformer<Query, Query> queryTransformer;
+  private final SupportSQLiteOpenHelper helper;
+  private final Logger logger;
+  private final ObservableTransformer<Query, Query> queryTransformer;
 
   // Package-private to avoid synthetic accessor method for 'transaction' instance.
   final ThreadLocal<SqliteTransaction> transactions = new ThreadLocal<>();
-  /** Publishes sets of tables which have changed. */
-  private final PublishSubject<Set<String>> triggers = PublishSubject.create();
+  private final Subject<Set<String>> triggers = PublishSubject.create();
 
   private final Transaction transaction = new Transaction() {
     @Override public void markSuccessful() {
@@ -102,8 +103,8 @@
       end();
     }
   };
-  private final Action0 ensureNotInTransaction = new Action0() {
-    @Override public void call() {
+  private final Consumer<Object> ensureNotInTransaction = new Consumer<Object>() {
+    @Override public void accept(Object ignored) throws Exception {
       if (transactions.get() != null) {
         throw new IllegalStateException("Cannot subscribe to observable query in a transaction.");
       }
@@ -115,8 +116,8 @@
   // Package-private to avoid synthetic accessor method for 'transaction' instance.
   volatile boolean logging;
 
-  BriteDatabase(SQLiteOpenHelper helper, SqlBrite.Logger logger, Scheduler scheduler,
-      Transformer<Query, Query> queryTransformer) {
+  BriteDatabase(SupportSQLiteOpenHelper helper, Logger logger, Scheduler scheduler,
+      ObservableTransformer<Query, Query> queryTransformer) {
     this.helper = helper;
     this.logger = logger;
     this.scheduler = scheduler;
@@ -132,40 +133,32 @@ public void setLoggingEnabled(boolean enabled) {
 
   /**
    * Create and/or open a database.  This will be the same object returned by
-   * {@link SQLiteOpenHelper#getWritableDatabase} unless some problem, such as a full disk,
+   * {@link SupportSQLiteOpenHelper#getWritableDatabase} unless some problem, such as a full disk,
    * requires the database to be opened read-only.  In that case, a read-only
    * database object will be returned.  If the problem is fixed, a future call
-   * to {@link SQLiteOpenHelper#getWritableDatabase} may succeed, in which case the read-only
+   * to {@link SupportSQLiteOpenHelper#getWritableDatabase} may succeed, in which case the read-only
    * database object will be closed and the read/write object will be returned
    * in the future.
    *
-   * <p class="caution">Like {@link SQLiteOpenHelper#getWritableDatabase}, this method may
+   * <p class="caution">Like {@link SupportSQLiteOpenHelper#getWritableDatabase}, this method may
    * take a long time to return, so you should not call it from the
    * application main thread, including from
    * {@link android.content.ContentProvider#onCreate ContentProvider.onCreate()}.
    *
    * @throws android.database.sqlite.SQLiteException if the database cannot be opened
-   * @return a database object valid until {@link SQLiteOpenHelper#getWritableDatabase}
+   * @return a database object valid until {@link SupportSQLiteOpenHelper#getWritableDatabase}
    *     or {@link #close} is called.
    */
   @NonNull @CheckResult @WorkerThread
-  public SQLiteDatabase getReadableDatabase() {
+  public SupportSQLiteDatabase getReadableDatabase() {
     return helper.getReadableDatabase();
   }
 
-
-  /** @deprecated Use {@link #getWritableDatabase()}. */
-  @Deprecated
-  @NonNull @CheckResult @WorkerThread
-  public SQLiteDatabase getWriteableDatabase() {
-    return helper.getWritableDatabase();
-  }
-
   /**
    * Create and/or open a database that will be used for reading and writing.
    * The first time this is called, the database will be opened and
-   * {@link SQLiteOpenHelper#onCreate}, {@link SQLiteOpenHelper#onUpgrade}
-   * and/or {@link SQLiteOpenHelper#onOpen} will be called.
+   * {@link Callback#onCreate}, {@link Callback#onUpgrade} and/or {@link Callback#onOpen} will be
+   * called.
    *
    * <p>Once opened successfully, the database is cached, so you can
    * call this method every time you need to write to the database.
@@ -181,7 +174,7 @@ public SQLiteDatabase getWriteableDatabase() {
    * @return a read/write database object valid until {@link #close} is called
    */
   @NonNull @CheckResult @WorkerThread
-  public SQLiteDatabase getWritableDatabase() {
+  public SupportSQLiteDatabase getWritableDatabase() {
     return helper.getWritableDatabase();
   }
 
@@ -230,7 +223,7 @@ void sendTableTrigger(Set<String> tables) {
    * }</pre>
    *
    *
-   * @see SQLiteDatabase#beginTransaction()
+   * @see SupportSQLiteDatabase#beginTransaction()
    */
   @CheckResult @NonNull
   public Transaction newTransaction() {
@@ -277,9 +270,8 @@ public Transaction newTransaction() {
    * }</pre>
    *
    *
-   * @see SQLiteDatabase#beginTransactionNonExclusive()
+   * @see SupportSQLiteDatabase#beginTransactionNonExclusive()
    */
-  @RequiresApi(HONEYCOMB)
   @CheckResult @NonNull
   public Transaction newNonExclusiveTransaction() {
     SqliteTransaction transaction = new SqliteTransaction(transactions.get());
@@ -291,7 +283,7 @@ public Transaction newNonExclusiveTransaction() {
   }
 
   /**
-   * Close the underlying {@link SQLiteOpenHelper} and remove cached readable and writeable
+   * Close the underlying {@link SupportSQLiteOpenHelper} and remove cached readable and writeable
    * databases. This does not prevent existing observables from retaining existing references as
    * well as attempting to create new ones for new subscriptions.
    */
@@ -320,88 +312,94 @@ public Transaction newNonExclusiveTransaction() {
    * <b>Warning:</b> this method does not perform the query! Only by subscribing to the returned
    * {@link Observable} will the operation occur.
    *
-   * @see SQLiteDatabase#rawQuery(String, String[])
+   * @see SupportSQLiteDatabase#query(String, Object[])
    */
   @CheckResult @NonNull
   public QueryObservable createQuery(@NonNull final String table, @NonNull String sql,
-      @NonNull String... args) {
-    Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
-      @Override public Boolean call(Set<String> triggers) {
-        return triggers.contains(table);
-      }
-
-      @Override public String toString() {
-        return table;
-      }
-    };
-    return createQuery(tableFilter, sql, args);
+      @NonNull Object... args) {
+    return createQuery(new DatabaseQuery(singletonList(table), new SimpleSQLiteQuery(sql, args)));
   }
 
   /**
-   * See {@link #createQuery(String, String, String...)} for usage. This overload allows for
+   * See {@link #createQuery(String, String, Object...)} for usage. This overload allows for
    * monitoring multiple tables for changes.
    *
-   * @see SQLiteDatabase#rawQuery(String, String[])
+   * @see SupportSQLiteDatabase#query(String, Object[])
    */
   @CheckResult @NonNull
   public QueryObservable createQuery(@NonNull final Iterable<String> tables, @NonNull String sql,
-      @NonNull String... args) {
-    Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
-      @Override public Boolean call(Set<String> triggers) {
-        for (String table : tables) {
-          if (triggers.contains(table)) {
-            return true;
-          }
-        }
-        return false;
-      }
+      @NonNull Object... args) {
+    return createQuery(new DatabaseQuery(tables, new SimpleSQLiteQuery(sql, args)));
+  }
 
-      @Override public String toString() {
-        return tables.toString();
-      }
-    };
-    return createQuery(tableFilter, sql, args);
+  /**
+   * Create an observable which will notify subscribers with a {@linkplain Query query} for
+   * execution. Subscribers are responsible for <b>always</b> closing {@link Cursor} instance
+   * returned from the {@link Query}.
+   * <p>
+   * Subscribers will receive an immediate notification for initial data as well as subsequent
+   * notifications for when the supplied {@code table}'s data changes through the {@code insert},
+   * {@code update}, and {@code delete} methods of this class. Unsubscribe when you no longer want
+   * updates to a query.
+   * <p>
+   * Since database triggers are inherently asynchronous, items emitted from the returned
+   * observable use the {@link Scheduler} supplied to {@link SqlBrite#wrapDatabaseHelper}. For
+   * consistency, the immediate notification sent on subscribe also uses this scheduler. As such,
+   * calling {@link Observable#subscribeOn subscribeOn} on the returned observable has no effect.
+   * <p>
+   * Note: To skip the immediate notification and only receive subsequent notifications when data
+   * has changed call {@code skip(1)} on the returned observable.
+   * <p>
+   * <b>Warning:</b> this method does not perform the query! Only by subscribing to the returned
+   * {@link Observable} will the operation occur.
+   *
+   * @see SupportSQLiteDatabase#query(SupportSQLiteQuery)
+   */
+  @CheckResult @NonNull
+  public QueryObservable createQuery(@NonNull final String table,
+      @NonNull SupportSQLiteQuery query) {
+    return createQuery(new DatabaseQuery(singletonList(table), query));
+  }
+
+  /**
+   * See {@link #createQuery(String, SupportSQLiteQuery)} for usage. This overload allows for
+   * monitoring multiple tables for changes.
+   *
+   * @see SupportSQLiteDatabase#query(SupportSQLiteQuery)
+   */
+  @CheckResult @NonNull
+  public QueryObservable createQuery(@NonNull final Iterable<String> tables,
+      @NonNull SupportSQLiteQuery query) {
+    return createQuery(new DatabaseQuery(tables, query));
   }
 
   @CheckResult @NonNull
-  private QueryObservable createQuery(Func1<Set<String>, Boolean> tableFilter, String sql,
-      String... args) {
+  private QueryObservable createQuery(DatabaseQuery query) {
     if (transactions.get() != null) {
       throw new IllegalStateException("Cannot create observable query in transaction. "
           + "Use query() for a query inside a transaction.");
     }
 
-    DatabaseQuery query = new DatabaseQuery(tableFilter, sql, args);
-    final Observable<Query> queryObservable = triggers //
-        .filter(tableFilter) // Only trigger on tables we care about.
+    return triggers //
+        .filter(query) // DatabaseQuery filters triggers to on tables we care about.
         .map(query) // DatabaseQuery maps to itself to save an allocation.
-        .onBackpressureLatest() // Guard against uncontrollable frequency of upstream emissions.
         .startWith(query) //
         .observeOn(scheduler) //
         .compose(queryTransformer) // Apply the user's query transformer.
-        .onBackpressureLatest() // Guard against uncontrollable frequency of scheduler executions.
-        .doOnSubscribe(ensureNotInTransaction);
-    // TODO switch to .to() when non-@Experimental
-    return new QueryObservable(new Observable.OnSubscribe<Query>() {
-      @Override public void call(Subscriber<? super Query> subscriber) {
-        queryObservable.unsafeSubscribe(subscriber);
-      }
-    });
+        .doOnSubscribe(ensureNotInTransaction)
+        .to(QUERY_OBSERVABLE);
   }
 
   /**
    * Runs the provided SQL and returns a {@link Cursor} over the result set.
    *
-   * @see SQLiteDatabase#rawQuery(String, String[])
+   * @see SupportSQLiteDatabase#query(String, Object[])
    */
   @CheckResult @WorkerThread
-  public Cursor query(@NonNull String sql, @NonNull String... args) {
-    long startNanos = nanoTime();
-    Cursor cursor = getReadableDatabase().rawQuery(sql, args);
-    long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
-
+  public Cursor query(@NonNull String sql, @NonNull Object... args) {
+    Cursor cursor = getReadableDatabase().query(sql, args);
     if (logging) {
-      log("QUERY (%sms)\n  sql: %s\n  args: %s", tookMillis, indentSql(sql), Arrays.toString(args));
+      log("QUERY\n  sql: %s\n  args: %s", indentSql(sql), Arrays.toString(args));
     }
 
     return cursor;
@@ -410,28 +408,18 @@ public Cursor query(@NonNull String sql, @NonNull String... args) {
   /**
    * Insert a row into the specified {@code table} and notify any subscribed queries.
    *
-   * @see SQLiteDatabase#insert(String, String, ContentValues)
-   */
-  @WorkerThread
-  public long insert(@NonNull String table, @NonNull ContentValues values) {
-    return insert(table, values, CONFLICT_NONE);
-  }
-
-  /**
-   * Insert a row into the specified {@code table} and notify any subscribed queries.
-   *
-   * @see SQLiteDatabase#insertWithOnConflict(String, String, ContentValues, int)
+   * @see SupportSQLiteDatabase#insert(String, int, ContentValues)
    */
   @WorkerThread
-  public long insert(@NonNull String table, @NonNull ContentValues values,
-      @ConflictAlgorithm int conflictAlgorithm) {
-    SQLiteDatabase db = getWritableDatabase();
+  public long insert(@NonNull String table, @ConflictAlgorithm int conflictAlgorithm,
+      @NonNull ContentValues values) {
+    SupportSQLiteDatabase db = getWritableDatabase();
 
     if (logging) {
       log("INSERT\n  table: %s\n  values: %s\n  conflictAlgorithm: %s", table, values,
           conflictString(conflictAlgorithm));
     }
-    long rowId = db.insertWithOnConflict(table, null, values, conflictAlgorithm);
+    long rowId = db.insert(table, conflictAlgorithm, values);
 
     if (logging) log("INSERT id: %s", rowId);
 
@@ -446,12 +434,12 @@ public long insert(@NonNull String table, @NonNull ContentValues values,
    * Delete rows from the specified {@code table} and notify any subscribed queries. This method
    * will not trigger a notification if no rows were deleted.
    *
-   * @see SQLiteDatabase#delete(String, String, String[])
+   * @see SupportSQLiteDatabase#delete(String, String, Object[])
    */
   @WorkerThread
   public int delete(@NonNull String table, @Nullable String whereClause,
       @Nullable String... whereArgs) {
-    SQLiteDatabase db = getWritableDatabase();
+    SupportSQLiteDatabase db = getWritableDatabase();
 
     if (logging) {
       log("DELETE\n  table: %s\n  whereClause: %s\n  whereArgs: %s", table, whereClause,
@@ -472,32 +460,19 @@ public int delete(@NonNull String table, @Nullable String whereClause,
    * Update rows in the specified {@code table} and notify any subscribed queries. This method
    * will not trigger a notification if no rows were updated.
    *
-   * @see SQLiteDatabase#update(String, ContentValues, String, String[])
-   */
-  @WorkerThread
-  public int update(@NonNull String table, @NonNull ContentValues values,
-      @Nullable String whereClause, @Nullable String... whereArgs) {
-    return update(table, values, CONFLICT_NONE, whereClause, whereArgs);
-  }
-
-  /**
-   * Update rows in the specified {@code table} and notify any subscribed queries. This method
-   * will not trigger a notification if no rows were updated.
-   *
-   * @see SQLiteDatabase#updateWithOnConflict(String, ContentValues, String, String[], int)
+   * @see SupportSQLiteDatabase#update(String, int, ContentValues, String, Object[])
    */
   @WorkerThread
-  public int update(@NonNull String table, @NonNull ContentValues values,
-      @ConflictAlgorithm int conflictAlgorithm, @Nullable String whereClause,
-      @Nullable String... whereArgs) {
-    SQLiteDatabase db = getWritableDatabase();
+  public int update(@NonNull String table, @ConflictAlgorithm int conflictAlgorithm,
+      @NonNull ContentValues values, @Nullable String whereClause, @Nullable String... whereArgs) {
+    SupportSQLiteDatabase db = getWritableDatabase();
 
     if (logging) {
       log("UPDATE\n  table: %s\n  values: %s\n  whereClause: %s\n  whereArgs: %s\n  conflictAlgorithm: %s",
           table, values, whereClause, Arrays.toString(whereArgs),
           conflictString(conflictAlgorithm));
     }
-    int rows = db.updateWithOnConflict(table, values, whereClause, whereArgs, conflictAlgorithm);
+    int rows = db.update(table, conflictAlgorithm, values, whereClause, whereArgs);
 
     if (logging) log("UPDATE affected %s %s", rows, rows != 1 ? "rows" : "row");
 
@@ -515,11 +490,11 @@ public int update(@NonNull String table, @NonNull ContentValues values,
    * <p>
    * No notifications will be sent to queries if {@code sql} affects the data of a table.
    *
-   * @see SQLiteDatabase#execSQL(String)
+   * @see SupportSQLiteDatabase#execSQL(String)
    */
   @WorkerThread
   public void execute(String sql) {
-    if (logging) log("EXECUTE\n  sql: %s", sql);
+    if (logging) log("EXECUTE\n  sql: %s", indentSql(sql));
 
     getWritableDatabase().execSQL(sql);
   }
@@ -531,11 +506,11 @@ public void execute(String sql) {
    * <p>
    * No notifications will be sent to queries if {@code sql} affects the data of a table.
    *
-   * @see SQLiteDatabase#execSQL(String, Object[])
+   * @see SupportSQLiteDatabase#execSQL(String, Object[])
    */
   @WorkerThread
   public void execute(String sql, Object... args) {
-    if (logging) log("EXECUTE\n  sql: %s\n  args: %s", sql, Arrays.toString(args));
+    if (logging) log("EXECUTE\n  sql: %s\n  args: %s", indentSql(sql), Arrays.toString(args));
 
     getWritableDatabase().execSQL(sql, args);
   }
@@ -547,7 +522,7 @@ public void execute(String sql, Object... args) {
    * <p>
    * A notification to queries for {@code table} will be sent after the statement is executed.
    *
-   * @see SQLiteDatabase#execSQL(String)
+   * @see SupportSQLiteDatabase#execSQL(String)
    */
   @WorkerThread
   public void executeAndTrigger(String table, String sql) {
@@ -573,7 +548,7 @@ public void executeAndTrigger(Set<String> tables, String sql) {
    * <p>
    * A notification to queries for {@code table} will be sent after the statement is executed.
    *
-   * @see SQLiteDatabase#execSQL(String, Object[])
+   * @see SupportSQLiteDatabase#execSQL(String, Object[])
    */
   @WorkerThread
   public void executeAndTrigger(String table, String sql, Object... args) {
@@ -599,22 +574,21 @@ public void executeAndTrigger(Set<String> tables, String sql, Object... args) {
    * @return the number of rows affected by this SQL statement execution.
    * @throws android.database.SQLException If the SQL string is invalid
    *
-   * @see SQLiteStatement#executeUpdateDelete()
+   * @see SupportSQLiteStatement#executeUpdateDelete()
    */
   @WorkerThread
-  @RequiresApi(Build.VERSION_CODES.HONEYCOMB)
-  public int executeUpdateDelete(String table, SQLiteStatement statement) {
+  public int executeUpdateDelete(String table, SupportSQLiteStatement statement) {
     return executeUpdateDelete(Collections.singleton(table), statement);
   }
 
   /**
-   * See {@link #executeUpdateDelete(String, SQLiteStatement)} for usage. This overload allows for triggering multiple tables.
+   * See {@link #executeUpdateDelete(String, SupportSQLiteStatement)} for usage. This overload
+   * allows for triggering multiple tables.
    *
-   * @see BriteDatabase#executeUpdateDelete(String, SQLiteStatement)
+   * @see BriteDatabase#executeUpdateDelete(String, SupportSQLiteStatement)
    */
   @WorkerThread
-  @RequiresApi(Build.VERSION_CODES.HONEYCOMB)
-  public int executeUpdateDelete(Set<String> tables, SQLiteStatement statement) {
+  public int executeUpdateDelete(Set<String> tables, SupportSQLiteStatement statement) {
     if (logging) log("EXECUTE\n %s", statement);
 
     int rows = statement.executeUpdateDelete();
@@ -633,20 +607,21 @@ public int executeUpdateDelete(Set<String> tables, SQLiteStatement statement) {
    *
    * @throws android.database.SQLException If the SQL string is invalid
    *
-   * @see SQLiteStatement#executeInsert()
+   * @see SupportSQLiteStatement#executeInsert()
    */
   @WorkerThread
-  public long executeInsert(String table, SQLiteStatement statement) {
+  public long executeInsert(String table, SupportSQLiteStatement statement) {
     return executeInsert(Collections.singleton(table), statement);
   }
 
   /**
-   * See {@link #executeInsert(String, SQLiteStatement)} for usage. This overload allows for triggering multiple tables.
+   * See {@link #executeInsert(String, SupportSQLiteStatement)} for usage. This overload allows for
+   * triggering multiple tables.
    *
-   * @see BriteDatabase#executeInsert(String, SQLiteStatement)
+   * @see BriteDatabase#executeInsert(String, SupportSQLiteStatement)
    */
   @WorkerThread
-  public long executeInsert(Set<String> tables, SQLiteStatement statement) {
+  public long executeInsert(Set<String> tables, SupportSQLiteStatement statement) {
     if (logging) log("EXECUTE\n %s", statement);
 
     long rowId = statement.executeInsert();
@@ -663,7 +638,7 @@ public long executeInsert(Set<String> tables, SQLiteStatement statement) {
      * End a transaction. See {@link #newTransaction()} for notes about how to use this and when
      * transactions are committed and rolled back.
      *
-     * @see SQLiteDatabase#endTransaction()
+     * @see SupportSQLiteDatabase#endTransaction()
      */
     @WorkerThread
     void end();
@@ -674,7 +649,7 @@ public long executeInsert(Set<String> tables, SQLiteStatement statement) {
      * situation too. If any errors are encountered between this and {@link #end()} the transaction
      * will still be committed.
      *
-     * @see SQLiteDatabase#setTransactionSuccessful()
+     * @see SupportSQLiteDatabase#setTransactionSuccessful()
      */
     @WorkerThread
     void markSuccessful();
@@ -688,7 +663,7 @@ public long executeInsert(Set<String> tables, SQLiteStatement statement) {
      *
      * @return true if the transaction was yielded
      *
-     * @see SQLiteDatabase#yieldIfContendedSafely()
+     * @see SupportSQLiteDatabase#yieldIfContendedSafely()
      */
     @WorkerThread
     boolean yieldIfContendedSafely();
@@ -705,7 +680,7 @@ public long executeInsert(Set<String> tables, SQLiteStatement statement) {
      *   more progress than they would if we started the transaction immediately.
      * @return true if the transaction was yielded
      *
-     * @see SQLiteDatabase#yieldIfContendedSafely(long)
+     * @see SupportSQLiteDatabase#yieldIfContendedSafely(long)
      */
     @WorkerThread
     boolean yieldIfContendedSafely(long sleepAmount, TimeUnit sleepUnit);
@@ -726,7 +701,7 @@ public long executeInsert(Set<String> tables, SQLiteStatement statement) {
       CONFLICT_ROLLBACK
   })
   @Retention(SOURCE)
-  public @interface ConflictAlgorithm {
+  private @interface ConflictAlgorithm {
   }
 
   static String indentSql(String sql) {
@@ -782,15 +757,14 @@ private static String conflictString(@ConflictAlgorithm int conflictAlgorithm) {
     }
   }
 
-  final class DatabaseQuery extends Query implements Func1<Set<String>, Query> {
-    private final Func1<Set<String>, Boolean> tableFilter;
-    private final String sql;
-    private final String[] args;
+  final class DatabaseQuery extends Query
+      implements Function<Set<String>, Query>, Predicate<Set<String>> {
+    private final Iterable<String> tables;
+    private final SupportSQLiteQuery query;
 
-    DatabaseQuery(Func1<Set<String>, Boolean> tableFilter, String sql, String... args) {
-      this.tableFilter = tableFilter;
-      this.sql = sql;
-      this.args = args;
+    DatabaseQuery(Iterable<String> tables, SupportSQLiteQuery query) {
+      this.tables = tables;
+      this.query = query;
     }
 
     @Override public Cursor run() {
@@ -798,24 +772,30 @@ private static String conflictString(@ConflictAlgorithm int conflictAlgorithm) {
         throw new IllegalStateException("Cannot execute observable query in a transaction.");
       }
 
-      long startNanos = nanoTime();
-      Cursor cursor = getReadableDatabase().rawQuery(sql, args);
+      Cursor cursor = getReadableDatabase().query(query);
 
       if (logging) {
-        long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
-        log("QUERY (%sms)\n  tables: %s\n  sql: %s\n  args: %s", tookMillis, tableFilter,
-            indentSql(sql), Arrays.toString(args));
+        log("QUERY\n  tables: %s\n  sql: %s", tables, indentSql(query.getSql()));
       }
 
       return cursor;
     }
 
     @Override public String toString() {
-      return sql;
+      return query.getSql();
     }
 
-    @Override public Query call(Set<String> ignored) {
+    @Override public Query apply(Set<String> ignored) {
       return this;
     }
+
+    @Override public boolean test(Set<String> strings) {
+      for (String table : tables) {
+        if (strings.contains(table)) {
+          return true;
+        }
+      }
+      return false;
+    }
   }
 }
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java b/sqlbrite/src/main/java/com/squareup/sqlbrite3/QueryObservable.java
similarity index 59%
rename from sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java
rename to sqlbrite/src/main/java/com/squareup/sqlbrite3/QueryObservable.java
index d5b197a..68dcc9d 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite3/QueryObservable.java
@@ -1,17 +1,34 @@
-package com.squareup.sqlbrite;
+package com.squareup.sqlbrite3;
 
 import android.database.Cursor;
+import android.os.Build;
 import android.support.annotation.CheckResult;
 import android.support.annotation.NonNull;
-import com.squareup.sqlbrite.SqlBrite.Query;
+import android.support.annotation.RequiresApi;
+import com.squareup.sqlbrite3.SqlBrite.Query;
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.functions.Function;
 import java.util.List;
-import rx.Observable;
-import rx.functions.Func1;
+import java.util.Optional;
 
 /** An {@link Observable} of {@link Query} which offers query-specific convenience operators. */
 public final class QueryObservable extends Observable<Query> {
-  public QueryObservable(OnSubscribe<Query> func) {
-    super(func);
+  static final Function<Observable<Query>, QueryObservable> QUERY_OBSERVABLE =
+      new Function<Observable<Query>, QueryObservable>() {
+        @Override public QueryObservable apply(Observable<Query> queryObservable) {
+          return new QueryObservable(queryObservable);
+        }
+      };
+
+  private final Observable<Query> upstream;
+
+  public QueryObservable(Observable<Query> upstream) {
+    this.upstream = upstream;
+  }
+
+  @Override protected void subscribeActual(Observer<? super Query> observer) {
+    upstream.subscribe(observer);
   }
 
   /**
@@ -34,7 +51,7 @@ public QueryObservable(OnSubscribe<Query> func) {
    * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
    */
   @CheckResult @NonNull
-  public final <T> Observable<T> mapToOne(@NonNull Func1<Cursor, T> mapper) {
+  public final <T> Observable<T> mapToOne(@NonNull Function<Cursor, T> mapper) {
     return lift(Query.mapToOne(mapper));
   }
 
@@ -59,11 +76,36 @@ public QueryObservable(OnSubscribe<Query> func) {
    * @param defaultValue Value returned if result set is empty
    */
   @CheckResult @NonNull
-  public final <T> Observable<T> mapToOneOrDefault(@NonNull Func1<Cursor, T> mapper,
-      T defaultValue) {
+  public final <T> Observable<T> mapToOneOrDefault(@NonNull Function<Cursor, T> mapper,
+      @NonNull T defaultValue) {
     return lift(Query.mapToOneOrDefault(mapper, defaultValue));
   }
 
+  /**
+   * Given a function mapping the current row of a {@link Cursor} to {@code T}, transform each
+   * emitted {@link Query} which returns a single row to {@code Optional<T>}.
+   * <p>
+   * It is an error for a query to pass through this operator with more than 1 row in its result
+   * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
+   * emit {@link Optional#empty() Optional.empty()}
+   * <p>
+   * This method is equivalent to:
+   * <pre>{@code
+   * flatMap(q -> q.asRows(mapper).take(1).map(Optional::of).defaultIfEmpty(Optional.empty())
+   * }</pre>
+   * and a convenience operator for:
+   * <pre>{@code
+   * lift(Query.mapToOptional(mapper))
+   * }</pre>
+   *
+   * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
+   */
+  @RequiresApi(Build.VERSION_CODES.N)
+  @CheckResult @NonNull
+  public final <T> Observable<Optional<T>> mapToOptional(@NonNull Function<Cursor, T> mapper) {
+    return lift(Query.mapToOptional(mapper));
+  }
+
   /**
    * Given a function mapping the current row of a {@link Cursor} to {@code T}, transform each
    * emitted {@link Query} to a {@code List<T>}.
@@ -86,7 +128,7 @@ public QueryObservable(OnSubscribe<Query> func) {
    * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
    */
   @CheckResult @NonNull
-  public final <T> Observable<List<T>> mapToList(@NonNull Func1<Cursor, T> mapper) {
+  public final <T> Observable<List<T>> mapToList(@NonNull Function<Cursor, T> mapper) {
     return lift(Query.mapToList(mapper));
   }
 }
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite3/QueryToListOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite3/QueryToListOperator.java
new file mode 100644
index 0000000..0ebeda2
--- /dev/null
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite3/QueryToListOperator.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.sqlbrite3;
+
+import android.database.Cursor;
+import io.reactivex.ObservableOperator;
+import io.reactivex.Observer;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Function;
+import io.reactivex.observers.DisposableObserver;
+import io.reactivex.plugins.RxJavaPlugins;
+import java.util.ArrayList;
+import java.util.List;
+
+final class QueryToListOperator<T> implements ObservableOperator<List<T>, SqlBrite.Query> {
+  private final Function<Cursor, T> mapper;
+
+  QueryToListOperator(Function<Cursor, T> mapper) {
+    this.mapper = mapper;
+  }
+
+  @Override public Observer<? super SqlBrite.Query> apply(Observer<? super List<T>> observer) {
+    return new MappingObserver<>(observer, mapper);
+  }
+
+  static final class MappingObserver<T> extends DisposableObserver<SqlBrite.Query> {
+    private final Observer<? super List<T>> downstream;
+    private final Function<Cursor, T> mapper;
+
+    MappingObserver(Observer<? super List<T>> downstream, Function<Cursor, T> mapper) {
+      this.downstream = downstream;
+      this.mapper = mapper;
+    }
+
+    @Override protected void onStart() {
+      downstream.onSubscribe(this);
+    }
+
+    @Override public void onNext(SqlBrite.Query query) {
+      try {
+        Cursor cursor = query.run();
+        if (cursor == null || isDisposed()) {
+          return;
+        }
+        List<T> items = new ArrayList<>(cursor.getCount());
+        try {
+          while (cursor.moveToNext()) {
+            items.add(mapper.apply(cursor));
+          }
+        } finally {
+          cursor.close();
+        }
+        if (!isDisposed()) {
+          downstream.onNext(items);
+        }
+      } catch (Throwable e) {
+        Exceptions.throwIfFatal(e);
+        onError(e);
+      }
+    }
+
+    @Override public void onComplete() {
+      if (!isDisposed()) {
+        downstream.onComplete();
+      }
+    }
+
+    @Override public void onError(Throwable e) {
+      if (isDisposed()) {
+        RxJavaPlugins.onError(e);
+      } else {
+        downstream.onError(e);
+      }
+    }
+  }
+}
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite3/QueryToOneOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite3/QueryToOneOperator.java
new file mode 100644
index 0000000..3c26713
--- /dev/null
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite3/QueryToOneOperator.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.sqlbrite3;
+
+import android.database.Cursor;
+import android.support.annotation.Nullable;
+import io.reactivex.ObservableOperator;
+import io.reactivex.Observer;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Function;
+import io.reactivex.observers.DisposableObserver;
+import io.reactivex.plugins.RxJavaPlugins;
+
+final class QueryToOneOperator<T> implements ObservableOperator<T, SqlBrite.Query> {
+  private final Function<Cursor, T> mapper;
+  private final T defaultValue;
+
+  /** A null {@code defaultValue} means nothing will be emitted when empty. */
+  QueryToOneOperator(Function<Cursor, T> mapper, @Nullable T defaultValue) {
+    this.mapper = mapper;
+    this.defaultValue = defaultValue;
+  }
+
+  @Override public Observer<? super SqlBrite.Query> apply(Observer<? super T> observer) {
+    return new MappingObserver<>(observer, mapper, defaultValue);
+  }
+
+  static final class MappingObserver<T> extends DisposableObserver<SqlBrite.Query> {
+    private final Observer<? super T> downstream;
+    private final Function<Cursor, T> mapper;
+    private final T defaultValue;
+
+    MappingObserver(Observer<? super T> downstream, Function<Cursor, T> mapper, T defaultValue) {
+      this.downstream = downstream;
+      this.mapper = mapper;
+      this.defaultValue = defaultValue;
+    }
+
+    @Override protected void onStart() {
+      downstream.onSubscribe(this);
+    }
+
+    @Override public void onNext(SqlBrite.Query query) {
+      try {
+        T item = null;
+        Cursor cursor = query.run();
+        if (cursor != null) {
+          try {
+            if (cursor.moveToNext()) {
+              item = mapper.apply(cursor);
+              if (item == null) {
+                downstream.onError(new NullPointerException("QueryToOne mapper returned null"));
+                return;
+              }
+              if (cursor.moveToNext()) {
+                throw new IllegalStateException("Cursor returned more than 1 row");
+              }
+            }
+          } finally {
+            cursor.close();
+          }
+        }
+        if (!isDisposed()) {
+          if (item != null) {
+            downstream.onNext(item);
+          } else if (defaultValue != null) {
+            downstream.onNext(defaultValue);
+          }
+        }
+      } catch (Throwable e) {
+        Exceptions.throwIfFatal(e);
+        onError(e);
+      }
+    }
+
+    @Override public void onComplete() {
+      if (!isDisposed()) {
+        downstream.onComplete();
+      }
+    }
+
+    @Override public void onError(Throwable e) {
+      if (isDisposed()) {
+        RxJavaPlugins.onError(e);
+      } else {
+        downstream.onError(e);
+      }
+    }
+  }
+}
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite3/QueryToOptionalOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite3/QueryToOptionalOperator.java
new file mode 100644
index 0000000..f5ec414
--- /dev/null
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite3/QueryToOptionalOperator.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.sqlbrite3;
+
+import android.database.Cursor;
+import android.os.Build;
+import android.support.annotation.RequiresApi;
+import io.reactivex.ObservableOperator;
+import io.reactivex.Observer;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.functions.Function;
+import io.reactivex.observers.DisposableObserver;
+import io.reactivex.plugins.RxJavaPlugins;
+import java.util.Optional;
+
+@RequiresApi(Build.VERSION_CODES.N)
+final class QueryToOptionalOperator<T> implements ObservableOperator<Optional<T>, SqlBrite.Query> {
+  private final Function<Cursor, T> mapper;
+
+  QueryToOptionalOperator(Function<Cursor, T> mapper) {
+    this.mapper = mapper;
+  }
+
+  @Override public Observer<? super SqlBrite.Query> apply(Observer<? super Optional<T>> observer) {
+    return new MappingObserver<>(observer, mapper);
+  }
+
+  static final class MappingObserver<T> extends DisposableObserver<SqlBrite.Query> {
+    private final Observer<? super Optional<T>> downstream;
+    private final Function<Cursor, T> mapper;
+
+    MappingObserver(Observer<? super Optional<T>> downstream, Function<Cursor, T> mapper) {
+      this.downstream = downstream;
+      this.mapper = mapper;
+    }
+
+    @Override protected void onStart() {
+      downstream.onSubscribe(this);
+    }
+
+    @Override public void onNext(SqlBrite.Query query) {
+      try {
+        T item = null;
+        Cursor cursor = query.run();
+        if (cursor != null) {
+          try {
+            if (cursor.moveToNext()) {
+              item = mapper.apply(cursor);
+              if (item == null) {
+                downstream.onError(new NullPointerException("QueryToOne mapper returned null"));
+                return;
+              }
+              if (cursor.moveToNext()) {
+                throw new IllegalStateException("Cursor returned more than 1 row");
+              }
+            }
+          } finally {
+            cursor.close();
+          }
+        }
+        if (!isDisposed()) {
+          downstream.onNext(Optional.ofNullable(item));
+        }
+      } catch (Throwable e) {
+        Exceptions.throwIfFatal(e);
+        onError(e);
+      }
+    }
+
+    @Override public void onComplete() {
+      if (!isDisposed()) {
+        downstream.onComplete();
+      }
+    }
+
+    @Override public void onError(Throwable e) {
+      if (isDisposed()) {
+        RxJavaPlugins.onError(e);
+      } else {
+        downstream.onError(e);
+      }
+    }
+  }
+}
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java b/sqlbrite/src/main/java/com/squareup/sqlbrite3/SqlBrite.java
similarity index 61%
rename from sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
rename to sqlbrite/src/main/java/com/squareup/sqlbrite3/SqlBrite.java
index c7d3b7e..ee4c7bc 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite3/SqlBrite.java
@@ -13,27 +13,31 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.sqlbrite;
+package com.squareup.sqlbrite3;
 
+import android.arch.persistence.db.SupportSQLiteOpenHelper;
 import android.content.ContentResolver;
 import android.database.Cursor;
-import android.database.sqlite.SQLiteOpenHelper;
+import android.os.Build;
 import android.support.annotation.CheckResult;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
 import android.support.annotation.WorkerThread;
 import android.util.Log;
+import io.reactivex.Observable;
+import io.reactivex.ObservableEmitter;
+import io.reactivex.ObservableOnSubscribe;
+import io.reactivex.ObservableOperator;
+import io.reactivex.ObservableTransformer;
+import io.reactivex.Scheduler;
+import io.reactivex.functions.Function;
 import java.util.List;
-import rx.Observable;
-import rx.Observable.Operator;
-import rx.Observable.Transformer;
-import rx.Scheduler;
-import rx.Subscriber;
-import rx.functions.Func1;
+import java.util.Optional;
 
 /**
- * A lightweight wrapper around {@link SQLiteOpenHelper} which allows for continuously observing
- * the result of a query.
+ * A lightweight wrapper around {@link SupportSQLiteOpenHelper} which allows for continuously
+ * observing the result of a query.
  */
 public final class SqlBrite {
   static final Logger DEFAULT_LOGGER = new Logger() {
@@ -41,15 +45,16 @@
       Log.d("SqlBrite", message);
     }
   };
-  static final Transformer<Query, Query> DEFAULT_TRANSFORMER = new Transformer<Query, Query>() {
-    @Override public Observable<Query> call(Observable<Query> queryObservable) {
-      return queryObservable;
-    }
-  };
+  static final ObservableTransformer<Query, Query> DEFAULT_TRANSFORMER =
+      new ObservableTransformer<Query, Query>() {
+        @Override public Observable<Query> apply(Observable<Query> queryObservable) {
+          return queryObservable;
+        }
+      };
 
   public static final class Builder {
     private Logger logger = DEFAULT_LOGGER;
-    private Transformer<Query, Query> queryTransformer = DEFAULT_TRANSFORMER;
+    private ObservableTransformer<Query, Query> queryTransformer = DEFAULT_TRANSFORMER;
 
     @CheckResult
     public Builder logger(@NonNull Logger logger) {
@@ -59,7 +64,7 @@ public Builder logger(@NonNull Logger logger) {
     }
 
     @CheckResult
-    public Builder queryTransformer(@NonNull Transformer<Query, Query> queryTransformer) {
+    public Builder queryTransformer(@NonNull ObservableTransformer<Query, Query> queryTransformer) {
       if (queryTransformer == null) throw new NullPointerException("queryTransformer == null");
       this.queryTransformer = queryTransformer;
       return this;
@@ -71,39 +76,27 @@ public SqlBrite build() {
     }
   }
 
-  /** @deprecated Use {@link Builder} to create instances. */
-  @Deprecated @CheckResult @NonNull
-  public static SqlBrite create() {
-    return new SqlBrite(DEFAULT_LOGGER, DEFAULT_TRANSFORMER);
-  }
-
-  /** @deprecated Use {@link Builder} to create instances. */
-  @Deprecated @CheckResult @NonNull
-  public static SqlBrite create(@NonNull Logger logger) {
-    if (logger == null) throw new NullPointerException("logger == null");
-    return new SqlBrite(logger, DEFAULT_TRANSFORMER);
-  }
-
-  private final Logger logger;
-  private final Transformer<Query, Query> queryTransformer;
+  final Logger logger;
+  final ObservableTransformer<Query, Query> queryTransformer;
 
-  SqlBrite(@NonNull Logger logger, @NonNull Transformer<Query, Query> queryTransformer) {
+  SqlBrite(@NonNull Logger logger, @NonNull ObservableTransformer<Query, Query> queryTransformer) {
     this.logger = logger;
     this.queryTransformer = queryTransformer;
   }
 
   /**
-   * Wrap a {@link SQLiteOpenHelper} for observable queries.
+   * Wrap a {@link SupportSQLiteOpenHelper} for observable queries.
    * <p>
    * While not strictly required, instances of this class assume that they will be the only ones
-   * interacting with the underlying {@link SQLiteOpenHelper} and it is required for automatic
-   * notifications of table changes to work. See {@linkplain BriteDatabase#createQuery the
+   * interacting with the underlying {@link SupportSQLiteOpenHelper} and it is required for
+   * automatic notifications of table changes to work. See {@linkplain BriteDatabase#createQuery the
    * <code>query</code> method} for more information on that behavior.
    *
    * @param scheduler The {@link Scheduler} on which items from {@link BriteDatabase#createQuery}
    * will be emitted.
    */
-  @CheckResult @NonNull public BriteDatabase wrapDatabaseHelper(@NonNull SQLiteOpenHelper helper,
+  @CheckResult @NonNull public BriteDatabase wrapDatabaseHelper(
+      @NonNull SupportSQLiteOpenHelper helper,
       @NonNull Scheduler scheduler) {
     return new BriteDatabase(helper, logger, scheduler, queryTransformer);
   }
@@ -122,8 +115,8 @@ public static SqlBrite create(@NonNull Logger logger) {
   /** An executable query. */
   public static abstract class Query {
     /**
-     * Creates an {@linkplain Operator observable operator} which transforms a query returning a
-     * single row to {@code T} using {@code mapper}.
+     * Creates an {@linkplain ObservableOperator operator} which transforms a query returning a
+     * single row to a {@code T} using {@code mapper}. Use with {@link Observable#lift}.
      * <p>
      * It is an error for a query to pass through this operator with more than 1 row in its result
      * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
@@ -133,14 +126,14 @@ public static SqlBrite create(@NonNull Logger logger) {
      *
      * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
      */
-    @CheckResult @NonNull
-    public static <T> Operator<T, Query> mapToOne(@NonNull Func1<Cursor, T> mapper) {
-      return new QueryToOneOperator<>(mapper, false, null);
+    @CheckResult @NonNull //
+    public static <T> ObservableOperator<T, Query> mapToOne(@NonNull Function<Cursor, T> mapper) {
+      return new QueryToOneOperator<>(mapper, null);
     }
 
     /**
-     * Creates an {@linkplain Operator observable operator} which transforms a query returning a
-     * single row to {@code T} using {@code mapper}.
+     * Creates an {@linkplain ObservableOperator operator} which transforms a query returning a
+     * single row to a {@code T} using {@code mapper}. Use with {@link Observable#lift}.
      * <p>
      * It is an error for a query to pass through this operator with more than 1 row in its result
      * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
@@ -151,15 +144,36 @@ public static SqlBrite create(@NonNull Logger logger) {
      * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
      * @param defaultValue Value returned if result set is empty
      */
+    @SuppressWarnings("ConstantConditions") // Public API contract.
     @CheckResult @NonNull
-    public static <T> Operator<T, Query> mapToOneOrDefault(@NonNull Func1<Cursor, T> mapper,
-        T defaultValue) {
-      return new QueryToOneOperator<>(mapper, true, defaultValue);
+    public static <T> ObservableOperator<T, Query> mapToOneOrDefault(
+        @NonNull Function<Cursor, T> mapper, @NonNull T defaultValue) {
+      if (defaultValue == null) throw new NullPointerException("defaultValue == null");
+      return new QueryToOneOperator<>(mapper, defaultValue);
+    }
+
+    /**
+     * Creates an {@linkplain ObservableOperator operator} which transforms a query returning a
+     * single row to a {@code Optional<T>} using {@code mapper}. Use with {@link Observable#lift}.
+     * <p>
+     * It is an error for a query to pass through this operator with more than 1 row in its result
+     * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
+     * emit {@link Optional#empty() Optional.empty()}.
+     * <p>
+     * This operator ignores {@code null} cursors returned from {@link #run()}.
+     *
+     * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
+     */
+    @RequiresApi(Build.VERSION_CODES.N) //
+    @CheckResult @NonNull //
+    public static <T> ObservableOperator<Optional<T>, Query> mapToOptional(
+        @NonNull Function<Cursor, T> mapper) {
+      return new QueryToOptionalOperator<>(mapper);
     }
 
     /**
-     * Creates an {@linkplain Operator observable operator} which transforms a query to a
-     * {@code List<T>} using {@code mapper}.
+     * Creates an {@linkplain ObservableOperator operator} which transforms a query to a
+     * {@code List<T>} using {@code mapper}. Use with {@link Observable#lift}.
      * <p>
      * Be careful using this operator as it will always consume the entire cursor and create objects
      * for each row, every time this observable emits a new query. On tables whose queries update
@@ -170,7 +184,8 @@ public static SqlBrite create(@NonNull Logger logger) {
      * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
      */
     @CheckResult @NonNull
-    public static <T> Operator<List<T>, Query> mapToList(@NonNull Func1<Cursor, T> mapper) {
+    public static <T> ObservableOperator<List<T>, Query> mapToList(
+        @NonNull Function<Cursor, T> mapper) {
       return new QueryToListOperator<>(mapper);
     }
 
@@ -210,21 +225,21 @@ public static SqlBrite create(@NonNull Logger logger) {
      * The resulting observable will be empty if {@code null} is returned from {@link #run()}.
      */
     @CheckResult @NonNull
-    public final <T> Observable<T> asRows(final Func1<Cursor, T> mapper) {
-      return Observable.create(new Observable.OnSubscribe<T>() {
-        @Override public void call(Subscriber<? super T> subscriber) {
+    public final <T> Observable<T> asRows(final Function<Cursor, T> mapper) {
+      return Observable.create(new ObservableOnSubscribe<T>() {
+        @Override public void subscribe(ObservableEmitter<T> e) throws Exception {
           Cursor cursor = run();
           if (cursor != null) {
             try {
-              while (cursor.moveToNext() && !subscriber.isUnsubscribed()) {
-                subscriber.onNext(mapper.call(cursor));
+              while (cursor.moveToNext() && !e.isDisposed()) {
+                e.onNext(mapper.apply(cursor));
               }
             } finally {
               cursor.close();
             }
           }
-          if (!subscriber.isUnsubscribed()) {
-            subscriber.onCompleted();
+          if (!e.isDisposed()) {
+            e.onComplete();
           }
         }
       });
