diff --git a/.travis.yml b/.travis.yml
index dd268b1..2a9f665 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -2,9 +2,11 @@ language: android
 
 android:
   components:
-    - build-tools-23.0.0
+    - tools
+    - platform-tools
+    - build-tools-25.0.1
     - extra-android-m2repository
-    - android-23
+    - android-25
     - sys-img-armeabi-v7a-android-23
 
 jdk:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 5373d2c..69b2aa6 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,85 @@
 Change Log
-=========
+==========
+
+Version 1.1.1 *(2016-12-20)*
+----------------------------
+
+ * Fix: Correct spelling of `getWritableDatabase()` to match `SQLiteOpenHelper`.
+
+
+Version 1.1.0 *(2016-12-16)*
+----------------------------
+
+ * New: Expose `getReadableDatabase()` and `getWriteableDatabase()` convenience methods.
+ * Fix: Do not cache instances of the readable and writable database internally as the framework
+   does this by default.
+
+
+Version 1.0.0 *(2016-12-02)*
+----------------------------
+
+ * RxJava dependency updated to 1.2.3.
+ * Restore `@WorkerThread` annotations to methods which do I/O. If you're using Java 8 with
+   Retrolambda or Jack you need to use version 2.3 or newer of the Android Gradle plugin to have
+   these annotations correctly handled by lint.
+
+
+Version 0.8.0 *(2016-10-21)*
+----------------------------
+
+ * New: A `Transformer<Query, Query>` can be supplied which is applied to each returned observable.
+ * New: `newNonExclusiveTransaction()` starts transactions in `IMMEDIATE` mode. See the platform
+   or SQLite documentation for more information.
+ * New: APIs for insert/update/delete which allow providing a compiled `SQLiteStatement`.
+
+
+Version 0.7.0 *(2016-07-06)*
+----------------------------
+
+ * New: Allow `mapTo*` mappers to return `null` values. This is useful when querying on a single,
+   nullable column for which `null` is a valid value.
+ * Fix: When `mapToOne` does not emit a value downstream, request another value from upstream to
+   ensure fixed-item requests (such as `take(1)`) as properly honored.
+ * Fix: Add logging to synchronous `execute` methods.
+
+
+Version 0.6.3 *(2016-04-13)*
+----------------------------
+
+ * `QueryObservable` constructor is now public allow instances to be created for tests.
+
+
+Version 0.6.2 *(2016-03-01)*
+----------------------------
+
+ * Fix: Document explicitly and correctly handle the fact that `Query.run()` can return `null` in
+   some situations. The `mapToOne`, `mapToOneOrDefault`, `mapToList`, and `asRows` helpers have all
+   been updated to handle this case and each is documented with their respective behavior.
+
+
+Version 0.6.1 *(2016-02-29)*
+----------------------------
+
+ * Fix: Apply backpressure strategy between database/content provider and the supplied `Scheduler`.
+   This guards against backpressure exceptions when the scheduler is unable to keep up with the rate
+   at which queries are being triggered.
+ * Fix: Indent the subsequent lines of a multi-line queries when logging.
+
+
+Version 0.6.0 *(2016-02-17)*
+----------------------------
+
+ * New: Require a `Scheduler` when wrapping a database or content provider which will be used when
+   sending query triggers. This allows the query to be run in subsequent operators without needing an
+   additional `observeOn`. It also eliminates the need to use `subscribeOn` since the supplied
+   `Scheduler` will be used for all emissions (similar to RxJava's `timer`, `interval`, etc.).
+
+   This also corrects a potential violation of the RxJava contract and potential source of bugs in that
+   all triggers will occur on the supplied `Scheduler`. Previously the initial value would trigger
+   synchronously (on the subscribing thread) while subsequent ones trigger on the thread which
+   performed the transaction. The new behavior puts the initial trigger on the same thread as all
+   subsequent triggers and also does not force transactions to block while sending triggers.
+
 
 Version 0.5.1 *(2016-02-03)*
 ----------------------------
diff --git a/README.md b/README.md
index dd1d9e0..d7c6b89 100755
--- a/README.md
+++ b/README.md
@@ -12,15 +12,19 @@ Usage
 Create a `SqlBrite` instance which is an adapter for the library functionality.
 
 ```java
-SqlBrite sqlBrite = SqlBrite.create();
+SqlBrite sqlBrite = new SqlBrite.Builder().build();
 ```
 
-Pass a `SQLiteOpenHelper` instance to create a `BriteDatabase`.
+Pass a `SQLiteOpenHelper` instance and a `Scheduler` to create a `BriteDatabase`.
 
 ```java
-BriteDatabase db = sqlBrite.wrapDatabaseHelper(openHelper);
+BriteDatabase db = sqlBrite.wrapDatabaseHelper(openHelper, Schedulers.io());
 ```
 
+A `Scheduler` is required for a few reasons, but the most important is that query notifications can
+trigger on the thread of your choice. The query can then be run without blocking the main thread or
+the thread which caused the trigger.
+
 The `BriteDatabase.createQuery` method is similar to `SQLiteDatabase.rawQuery` except it takes an
 additional parameter of table(s) on which to listen for changes. Subscribe to the returned
 `Observable<Query>` which will immediately notify with a `Query` to run.
@@ -118,7 +122,7 @@ The `SqlBrite` object can also wrap a `ContentResolver` for observing a query on
 content provider.
 
 ```java
-BriteContentResolver resolver = sqlBrite.wrapContentProvider(contentResolver);
+BriteContentResolver resolver = sqlBrite.wrapContentProvider(contentResolver, Schedulers.io());
 Observable<Query> query = resolver.createQuery(/*...*/);
 ```
 
@@ -136,7 +140,7 @@ of updates to tables such that you can update queries as soon as data changes.
 This library is not an ORM. It is not a type-safe query mechanism. It won't serialize the same POJOs
 you use for Gson. It's not going to perform database migrations for you.
 
-A day may come when some of those features are added, but it is not this day.
+Some of these features are offered by [SQLDelight][sqldelight] which can be used with SQLBrite.
 
 
 
@@ -144,7 +148,7 @@ Download
 --------
 
 ```groovy
-compile 'com.squareup.sqlbrite:sqlbrite:0.5.1'
+compile 'com.squareup.sqlbrite:sqlbrite:1.1.1'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -173,3 +177,4 @@ License
 
 
  [snap]: https://oss.sonatype.org/content/repositories/snapshots/
+ [sqldelight]: https://github.com/square/sqldelight/
diff --git a/build.gradle b/build.gradle
index 00152e6..483e1e9 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,7 +1,8 @@
-subprojects {
+allprojects {
   buildscript {
     repositories {
       mavenCentral()
+      jcenter()
     }
   }
 
@@ -11,28 +12,45 @@ subprojects {
 }
 
 ext {
-  androidPlugin = 'com.android.tools.build:gradle:1.3.0'
-  compileSdkVersion = 23
-  buildToolsVersion = '23.0.0'
+  androidPlugin = 'com.android.tools.build:gradle:2.2.2'
+  compileSdkVersion = 25
+  buildToolsVersion = '25.0.1'
 
   // Android dependencies.
-  supportV4 = 'com.android.support:support-v4:23.0.0'
-  supportAnnotations = 'com.android.support:support-annotations:23.0.0'
-  supportTestRunner = 'com.android.support.test:runner:0.3'
+  supportV4 = 'com.android.support:support-v4:25.0.1'
+  supportAnnotations = 'com.android.support:support-annotations:25.0.1'
+  supportTestRunner = 'com.android.support.test:runner:0.5'
 
-  // Square dependencies.
-  dagger = 'com.squareup.dagger:dagger:1.2.2'
-  daggerCompiler = 'com.squareup.dagger:dagger-compiler:1.2.2'
+  // Dagger dependencies.
+  dagger = 'com.google.dagger:dagger:2.8'
+  daggerCompiler = 'com.google.dagger:dagger-compiler:2.8'
 
   // Third-party dependencies.
-  butterKnife = 'com.jakewharton:butterknife:6.1.0'
-  timber = 'com.jakewharton.timber:timber:2.7.1'
-  autoParcel = 'com.github.frankiesardo:auto-parcel:0.3'
-  autoParcelProcessor = 'com.github.frankiesardo:auto-parcel-processor:0.3'
-  rxJava = 'io.reactivex:rxjava:1.1.0'
-  rxAndroid = 'io.reactivex:rxandroid:1.0.1'
-  rxBinding = 'com.jakewharton.rxbinding:rxbinding:0.2.0'
-  truth = 'com.google.truth:truth:0.27'
+  butterKnifeRuntime = 'com.jakewharton:butterknife:8.4.0'
+  butterKnifeCompiler = 'com.jakewharton:butterknife-compiler:8.4.0'
+  timber = 'com.jakewharton.timber:timber:4.3.1'
+  autoValue = 'com.google.auto.value:auto-value:1.3'
+  autoValueParcel = 'com.ryanharter.auto.value:auto-value-parcel:0.2.5'
+  rxJava = 'io.reactivex:rxjava:1.2.3'
+  rxAndroid = 'io.reactivex:rxandroid:1.2.1'
+  rxBinding = 'com.jakewharton.rxbinding:rxbinding:0.4.0'
+  truth = 'com.google.truth:truth:0.30'
   findbugsJsr305 = 'com.google.code.findbugs:jsr305:3.0.0'
   findbugsAnnotations = 'com.google.code.findbugs:annotations:3.0.0'
 }
+
+configurations {
+  osstrich
+}
+dependencies {
+  osstrich 'com.squareup.osstrich:osstrich:1.2.0'
+}
+task publishJavadoc(type: JavaExec) {
+  classpath = configurations.osstrich
+  main = 'com.squareup.osstrich.JavadocPublisher'
+  args = [
+      'build/javadoc',
+      'https://github.com/square/sqlbrite',
+      'com.squareup.sqlbrite'
+  ]
+}
diff --git a/gradle.properties b/gradle.properties
index a4f792f..fbfb802 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,5 +1,5 @@
 GROUP=com.squareup.sqlbrite
-VERSION_NAME=0.5.2-SNAPSHOT
+VERSION_NAME=1.1.2-SNAPSHOT
 
 POM_DESCRIPTION=A lightweight wrapper around SQLiteOpenHelper which introduces reactive stream semantics to SQL operations.
 
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index aee0967..224f727 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.6-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
diff --git a/sample/build.gradle b/sample/build.gradle
index fca8bfa..32ce65c 100644
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -1,12 +1,10 @@
 buildscript {
   dependencies {
     classpath rootProject.ext.androidPlugin
-    classpath 'com.neenbedankt.gradle.plugins:android-apt:1.7'
   }
 }
 
 apply plugin: 'com.android.application'
-apply plugin: 'com.neenbedankt.android-apt'
 apply from: rootProject.file('gradle/android-findbugs.gradle')
 
 dependencies {
@@ -14,18 +12,21 @@ dependencies {
   compile rootProject.ext.supportV4
   compile rootProject.ext.supportAnnotations
 
-  // Square dependencies.
+  // Dagger dependencies.
   compile rootProject.ext.dagger
-  apt rootProject.ext.daggerCompiler
+  annotationProcessor rootProject.ext.daggerCompiler
 
   // Third-party dependencies.
-  compile rootProject.ext.butterKnife
+  compile rootProject.ext.butterKnifeRuntime
+  annotationProcessor rootProject.ext.butterKnifeCompiler
   compile rootProject.ext.timber
   compile rootProject.ext.rxJava
   compile rootProject.ext.rxAndroid
   compile rootProject.ext.rxBinding
-  compile rootProject.ext.autoParcel
-  apt rootProject.ext.autoParcelProcessor
+
+  provided rootProject.ext.autoValue
+  annotationProcessor rootProject.ext.autoValue
+  annotationProcessor rootProject.ext.autoValueParcel
 
   provided rootProject.ext.findbugsJsr305
   provided rootProject.ext.findbugsAnnotations
@@ -49,6 +50,8 @@ android {
 
   lintOptions {
     textOutput 'stdout'
+    textReport true
+    ignore 'InvalidPackage' // Provided AutoValue pulls in Guava and friends. Doesn't end up in APK.
   }
 
   dexOptions {
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/TodoApp.java b/sample/src/main/java/com/example/sqlbrite/todo/TodoApp.java
index d99b5a4..70cff42 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/TodoApp.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/TodoApp.java
@@ -17,11 +17,10 @@
 
 import android.app.Application;
 import android.content.Context;
-import dagger.ObjectGraph;
 import timber.log.Timber;
 
 public final class TodoApp extends Application {
-  private ObjectGraph objectGraph;
+  private TodoComponent mainComponent;
 
   @Override public void onCreate() {
     super.onCreate();
@@ -30,10 +29,10 @@
       Timber.plant(new Timber.DebugTree());
     }
 
-    objectGraph = ObjectGraph.create(new TodoModule(this));
+    mainComponent = DaggerTodoComponent.builder().todoModule(new TodoModule(this)).build();
   }
 
-  public static ObjectGraph objectGraph(Context context) {
-    return ((TodoApp) context.getApplicationContext()).objectGraph;
+  public static TodoComponent getComponent(Context context) {
+    return ((TodoApp) context.getApplicationContext()).mainComponent;
   }
 }
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/UiModule.java b/sample/src/main/java/com/example/sqlbrite/todo/TodoComponent.java
similarity index 52%
rename from sample/src/main/java/com/example/sqlbrite/todo/ui/UiModule.java
rename to sample/src/main/java/com/example/sqlbrite/todo/TodoComponent.java
index 1e3c8a5..f53ca23 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/UiModule.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/TodoComponent.java
@@ -13,19 +13,24 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.example.sqlbrite.todo.ui;
+package com.example.sqlbrite.todo;
 
-import dagger.Module;
+import com.example.sqlbrite.todo.ui.ItemsFragment;
+import com.example.sqlbrite.todo.ui.ListsFragment;
+import com.example.sqlbrite.todo.ui.NewItemFragment;
+import com.example.sqlbrite.todo.ui.NewListFragment;
+import dagger.Component;
+import javax.inject.Singleton;
 
-@Module(
-    injects = {
-        ItemsFragment.class,
-        ListsFragment.class,
-        NewItemFragment.class,
-        NewListFragment.class
-    },
-    complete = false,
-    library = true
-)
-public final class UiModule {
+@Singleton
+@Component(modules = TodoModule.class)
+public interface TodoComponent {
+
+  void inject(ListsFragment fragment);
+
+  void inject(ItemsFragment fragment);
+
+  void inject(NewItemFragment fragment);
+
+  void inject(NewListFragment fragment);
 }
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/TodoModule.java b/sample/src/main/java/com/example/sqlbrite/todo/TodoModule.java
index eea28ab..ce901bb 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/TodoModule.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/TodoModule.java
@@ -17,7 +17,6 @@
 
 import android.app.Application;
 import com.example.sqlbrite.todo.db.DbModule;
-import com.example.sqlbrite.todo.ui.UiModule;
 import dagger.Module;
 import dagger.Provides;
 import javax.inject.Singleton;
@@ -25,7 +24,6 @@
 @Module(
     includes = {
         DbModule.class,
-        UiModule.class
     }
 )
 public final class TodoModule {
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java b/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
index 0143fe0..2147fdd 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
@@ -22,9 +22,10 @@
 import dagger.Module;
 import dagger.Provides;
 import javax.inject.Singleton;
+import rx.schedulers.Schedulers;
 import timber.log.Timber;
 
-@Module(complete = false, library = true)
+@Module
 public final class DbModule {
   @Provides @Singleton SQLiteOpenHelper provideOpenHelper(Application application) {
     return new DbOpenHelper(application);
@@ -39,7 +40,7 @@
   }
 
   @Provides @Singleton BriteDatabase provideDatabase(SqlBrite sqlBrite, SQLiteOpenHelper helper) {
-    BriteDatabase db = sqlBrite.wrapDatabaseHelper(helper);
+    BriteDatabase db = sqlBrite.wrapDatabaseHelper(helper, Schedulers.io());
     db.setLoggingEnabled(true);
     return db;
   }
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/db/DbOpenHelper.java b/sample/src/main/java/com/example/sqlbrite/todo/db/DbOpenHelper.java
index 00af8eb..4ee73fd 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/db/DbOpenHelper.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/db/DbOpenHelper.java
@@ -80,7 +80,7 @@ public DbOpenHelper(Context context) {
         .build());
     db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
         .listId(holidayPresentsListId)
-        .description("Coal for Jesse W.")
+        .description("Cola for Jesse W.")
         .build());
 
     long workListId = db.insert(TodoList.TABLE, null, new TodoList.Builder()
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java b/sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
index 77c6847..865328b 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
@@ -17,11 +17,12 @@
 
 import android.content.ContentValues;
 import android.database.Cursor;
-import auto.parcel.AutoParcel;
+import android.os.Parcelable;
+import com.google.auto.value.AutoValue;
 import rx.functions.Func1;
 
-@AutoParcel
-public abstract class TodoItem {
+@AutoValue
+public abstract class TodoItem implements Parcelable {
   public static final String TABLE = "todo_item";
 
   public static final String ID = "_id";
@@ -40,7 +41,7 @@
       long listId = Db.getLong(cursor, LIST_ID);
       String description = Db.getString(cursor, DESCRIPTION);
       boolean complete = Db.getBoolean(cursor, COMPLETE);
-      return new AutoParcel_TodoItem(id, listId, description, complete);
+      return new AutoValue_TodoItem(id, listId, description, complete);
     }
   };
 
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java b/sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java
index 0c890a6..12e3f91 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java
@@ -17,14 +17,15 @@
 
 import android.content.ContentValues;
 import android.database.Cursor;
-import auto.parcel.AutoParcel;
+import android.os.Parcelable;
+import com.google.auto.value.AutoValue;
 import java.util.ArrayList;
 import java.util.List;
 import rx.functions.Func1;
 
 // Note: normally I wouldn't prefix table classes but I didn't want 'List' to be overloaded.
-@AutoParcel
-public abstract class TodoList {
+@AutoValue
+public abstract class TodoList implements Parcelable {
   public static final String TABLE = "todo_list";
 
   public static final String ID = "_id";
@@ -44,7 +45,7 @@
           long id = Db.getLong(cursor, ID);
           String name = Db.getString(cursor, NAME);
           boolean archived = Db.getBoolean(cursor, ARCHIVED);
-          values.add(new AutoParcel_TodoList(id, name, archived));
+          values.add(new AutoValue_TodoList(id, name, archived));
         }
         return values;
       } finally {
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
index 113d3af..b64a2fe 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
@@ -28,8 +28,8 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ListView;
+import butterknife.BindView;
 import butterknife.ButterKnife;
-import butterknife.InjectView;
 import com.example.sqlbrite.todo.R;
 import com.example.sqlbrite.todo.TodoApp;
 import com.example.sqlbrite.todo.db.Db;
@@ -87,8 +87,8 @@ public static ItemsFragment newInstance(long listId) {
 
   @Inject BriteDatabase db;
 
-  @InjectView(android.R.id.list) ListView listView;
-  @InjectView(android.R.id.empty) View emptyView;
+  @BindView(android.R.id.list) ListView listView;
+  @BindView(android.R.id.empty) View emptyView;
 
   private Listener listener;
   private ItemsAdapter adapter;
@@ -104,7 +104,7 @@ private long getListId() {
     }
 
     super.onAttach(activity);
-    TodoApp.objectGraph(activity).inject(this);
+    TodoApp.getComponent(activity).inject(this);
     setHasOptionsMenu(true);
 
     listener = (Listener) activity;
@@ -132,7 +132,7 @@ private long getListId() {
   @Override
   public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
     super.onViewCreated(view, savedInstanceState);
-    ButterKnife.inject(this, view);
+    ButterKnife.bind(this, view);
     listView.setEmptyView(emptyView);
     listView.setAdapter(adapter);
 
@@ -187,7 +187,6 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
             return listName + " (" + itemCount + ")";
           }
         })
-            .subscribeOn(Schedulers.io())
             .observeOn(AndroidSchedulers.mainThread())
             .subscribe(new Action1<String>() {
               @Override public void call(String title) {
@@ -197,7 +196,6 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
 
     subscriptions.add(db.createQuery(TodoItem.TABLE, LIST_QUERY, listId)
         .mapToList(TodoItem.MAPPER)
-        .subscribeOn(Schedulers.io())
         .observeOn(AndroidSchedulers.mainThread())
         .subscribe(adapter));
   }
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
index feebb0d..09e1387 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
@@ -27,8 +27,8 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ListView;
+import butterknife.BindView;
 import butterknife.ButterKnife;
-import butterknife.InjectView;
 import butterknife.OnItemClick;
 import com.example.sqlbrite.todo.R;
 import com.example.sqlbrite.todo.TodoApp;
@@ -36,7 +36,6 @@
 import javax.inject.Inject;
 import rx.Subscription;
 import rx.android.schedulers.AndroidSchedulers;
-import rx.schedulers.Schedulers;
 
 import static android.support.v4.view.MenuItemCompat.SHOW_AS_ACTION_IF_ROOM;
 import static android.support.v4.view.MenuItemCompat.SHOW_AS_ACTION_WITH_TEXT;
@@ -53,8 +52,8 @@ static ListsFragment newInstance() {
 
   @Inject BriteDatabase db;
 
-  @InjectView(android.R.id.list) ListView listView;
-  @InjectView(android.R.id.empty) View emptyView;
+  @BindView(android.R.id.list) ListView listView;
+  @BindView(android.R.id.empty) View emptyView;
 
   private Listener listener;
   private ListsAdapter adapter;
@@ -66,7 +65,7 @@ static ListsFragment newInstance() {
     }
 
     super.onAttach(activity);
-    TodoApp.objectGraph(activity).inject(this);
+    TodoApp.getComponent(activity).inject(this);
     setHasOptionsMenu(true);
 
     listener = (Listener) activity;
@@ -94,7 +93,7 @@ static ListsFragment newInstance() {
   @Override
   public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
     super.onViewCreated(view, savedInstanceState);
-    ButterKnife.inject(this, view);
+    ButterKnife.bind(this, view);
     listView.setEmptyView(emptyView);
     listView.setAdapter(adapter);
   }
@@ -110,7 +109,6 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
 
     subscription = db.createQuery(ListsItem.TABLES, ListsItem.QUERY)
         .mapToList(ListsItem.MAPPER)
-        .subscribeOn(Schedulers.io())
         .observeOn(AndroidSchedulers.mainThread())
         .subscribe(adapter);
   }
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
index 51b2281..a865ccb 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
@@ -16,16 +16,17 @@
 package com.example.sqlbrite.todo.ui;
 
 import android.database.Cursor;
-import auto.parcel.AutoParcel;
+import android.os.Parcelable;
 import com.example.sqlbrite.todo.db.Db;
 import com.example.sqlbrite.todo.db.TodoItem;
 import com.example.sqlbrite.todo.db.TodoList;
+import com.google.auto.value.AutoValue;
 import java.util.Arrays;
 import java.util.Collection;
 import rx.functions.Func1;
 
-@AutoParcel
-abstract class ListsItem {
+@AutoValue
+abstract class ListsItem implements Parcelable {
   private static String ALIAS_LIST = "list";
   private static String ALIAS_ITEM = "item";
 
@@ -51,7 +52,7 @@
       long id = Db.getLong(cursor, TodoList.ID);
       String name = Db.getString(cursor, TodoList.NAME);
       int itemCount = Db.getInt(cursor, ITEM_COUNT);
-      return new AutoParcel_ListsItem(id, name, itemCount);
+      return new AutoValue_ListsItem(id, name, itemCount);
     }
   };
 }
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
index 6102a8f..ea05e7b 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
@@ -62,7 +62,7 @@ private long getListId() {
 
   @Override public void onAttach(Activity activity) {
     super.onAttach(activity);
-    TodoApp.objectGraph(activity).inject(this);
+    TodoApp.getComponent(activity).inject(this);
   }
 
   @NonNull @Override public Dialog onCreateDialog(Bundle savedInstanceState) {
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
index 2a14c60..b01e06b 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
@@ -51,7 +51,7 @@ public static NewListFragment newInstance() {
 
   @Override public void onAttach(Activity activity) {
     super.onAttach(activity);
-    TodoApp.objectGraph(activity).inject(this);
+    TodoApp.getComponent(activity).inject(this);
   }
 
   @NonNull @Override public Dialog onCreateDialog(Bundle savedInstanceState) {
diff --git a/sqlbrite/build.gradle b/sqlbrite/build.gradle
index fccb727..90c8e7c 100644
--- a/sqlbrite/build.gradle
+++ b/sqlbrite/build.gradle
@@ -40,6 +40,7 @@ android {
 
   lintOptions {
     textOutput 'stdout'
+    textReport true
   }
 
   buildTypes {
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java
index b8817c1..b0f76ec 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java
@@ -22,11 +22,16 @@
 import android.net.Uri;
 import android.test.ProviderTestCase2;
 import android.test.mock.MockContentProvider;
+import com.squareup.sqlbrite.SqlBrite.Query;
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import rx.Observable;
+import rx.Observable.Transformer;
 import rx.Subscription;
+import rx.internal.util.RxRingBuffer;
+import rx.subjects.PublishSubject;
 import rx.subscriptions.Subscriptions;
 
 import static com.google.common.truth.Truth.assertThat;
@@ -40,6 +45,8 @@
 
   private final List<String> logs = new ArrayList<>();
   private final RecordingObserver o = new BlockingRecordingObserver();
+  private final TestScheduler scheduler = new TestScheduler();
+  private final PublishSubject<Void> killSwitch = PublishSubject.create();
 
   private ContentResolver contentResolver;
   private BriteContentResolver db;
@@ -59,7 +66,12 @@ public BriteContentResolverTest() {
         logs.add(message);
       }
     };
-    db = new BriteContentResolver(contentResolver, logger);
+    Transformer<Query, Query> queryTransformer = new Transformer<Query, Query>() {
+      @Override public Observable<Query> call(Observable<Query> queryObservable) {
+        return queryObservable.takeUntil(killSwitch);
+      }
+    };
+    db = new BriteContentResolver(contentResolver, logger, scheduler, queryTransformer);
 
     getProvider().init(getContext().getContentResolver());
   }
@@ -123,7 +135,18 @@ public void testUnsubscribeDoesNotTrigger() {
     assertThat(logs).isEmpty();
   }
 
-  public void testBackpressureSupported() {
+  public void testQueryNotNotifiedWhenQueryTransformerUnsubscribes() {
+    subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
+    o.assertCursor().isExhausted();
+
+    killSwitch.onNext(null);
+    o.assertIsCompleted();
+
+    contentResolver.insert(TABLE, values("key1", "val1"));
+    o.assertNoMoreEvents();
+  }
+
+  public void testBackpressureSupportedWhenConsumerSlow() {
     contentResolver.insert(TABLE, values("key1", "val1"));
     o.doRequest(2);
 
@@ -169,6 +192,42 @@ public void testBackpressureSupported() {
     o.assertNoMoreEvents();
   }
 
+  public void testBackpressureSupportedWhenSchedulerSlow() {
+    subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
+    o.assertCursor().isExhausted();
+
+    // Switch the scheduler to queue actions.
+    scheduler.runTasksImmediately(false);
+
+    // Shotgun twice as many insertions as the scheduler queue can handle.
+    for (int i = 0; i < RxRingBuffer.SIZE * 2; i++) {
+      contentResolver.insert(TABLE, values("key" + i, "val" + i));
+    }
+
+    scheduler.triggerActions();
+
+    // Assert we got all the events from the queue plus the one buffered from backpressure.
+    // Note: Because of the rebatching request behavior of observeOn, the initial emission is
+    // counted against this amount which is why there is no +1 on SIZE.
+    for (int i = 0; i < RxRingBuffer.SIZE; i++) {
+      o.assertCursor(); // Ignore contents, just assert we got notified.
+    }
+  }
+
+  public void testInitialValueAndTriggerUsesScheduler() {
+    scheduler.runTasksImmediately(false);
+
+    subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
+    o.assertNoMoreEvents();
+    scheduler.triggerActions();
+    o.assertCursor().isExhausted();
+
+    contentResolver.insert(TABLE, values("key1", "val1"));
+    o.assertNoMoreEvents();
+    scheduler.triggerActions();
+    o.assertCursor().hasRow("key1", "val1").isExhausted();
+  }
+
   private ContentValues values(String key, String value) {
     ContentValues result = new ContentValues();
     result.put(KEY, key);
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java
index bd8f84f..98f7cab 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java
@@ -15,12 +15,16 @@
  */
 package com.squareup.sqlbrite;
 
+import android.annotation.TargetApi;
 import android.content.ContentValues;
 import android.database.Cursor;
 import android.database.SQLException;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteException;
+import android.database.sqlite.SQLiteStatement;
+import android.os.Build;
 import android.support.test.InstrumentationRegistry;
+import android.support.test.filters.SdkSuppress;
 import android.support.test.runner.AndroidJUnit4;
 import com.squareup.sqlbrite.BriteDatabase.Transaction;
 import com.squareup.sqlbrite.TestDb.Employee;
@@ -28,15 +32,23 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.CountDownLatch;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
 import org.junit.runner.RunWith;
 import rx.Observable;
+import rx.Observable.Transformer;
 import rx.Subscription;
 import rx.functions.Action1;
+import rx.internal.util.RxRingBuffer;
+import rx.subjects.PublishSubject;
 
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE;
 import static com.google.common.truth.Truth.assertThat;
@@ -52,19 +64,25 @@
 import static com.squareup.sqlbrite.TestDb.employee;
 import static com.squareup.sqlbrite.TestDb.manager;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
 public final class BriteDatabaseTest {
   private final List<String> logs = new ArrayList<>();
   private final RecordingObserver o = new RecordingObserver();
+  private final TestScheduler scheduler = new TestScheduler();
+  private final PublishSubject<Void> killSwitch = PublishSubject.create();
 
   private TestDb helper;
   private SQLiteDatabase real;
   private BriteDatabase db;
 
-  @Before public void setUp() {
-    helper = new TestDb(InstrumentationRegistry.getContext());
+  @Rule
+  public TemporaryFolder dbFolder = new TemporaryFolder();
+
+  @Before public void setUp() throws IOException {
+    helper = new TestDb(InstrumentationRegistry.getContext(), dbFolder.newFile().getPath());
     real = helper.getWritableDatabase();
 
     SqlBrite.Logger logger = new SqlBrite.Logger() {
@@ -72,7 +90,12 @@
         logs.add(message);
       }
     };
-    db = new BriteDatabase(helper, logger);
+    Transformer<Query, Query> queryTransformer = new Transformer<Query, Query>() {
+      @Override public Observable<Query> call(Observable<Query> queryObservable) {
+        return queryObservable.takeUntil(killSwitch);
+      }
+    };
+    db = new BriteDatabase(helper, logger, scheduler, queryTransformer);
   }
 
   @After public void tearDown() {
@@ -162,6 +185,29 @@
         .isExhausted();
   }
 
+  @Test public void queryInitialValueAndTriggerUsesScheduler() {
+    scheduler.runTasksImmediately(false);
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertNoMoreEvents();
+    scheduler.triggerActions();
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    o.assertNoMoreEvents();
+    scheduler.triggerActions();
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .hasRow("john", "John Johnson")
+        .isExhausted();
+  }
+
   @Test public void queryNotNotifiedWhenInsertFails() {
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
     o.assertCursor()
@@ -174,6 +220,21 @@
     o.assertNoMoreEvents();
   }
 
+  @Test public void queryNotNotifiedWhenQueryTransformerUnsubscribes() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    killSwitch.onNext(null);
+    o.assertIsCompleted();
+
+    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    o.assertNoMoreEvents();
+  }
+
   @Test public void queryObservesUpdate() {
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
     o.assertCursor()
@@ -340,6 +401,45 @@
         .isExhausted();
   }
 
+  @Test public void executeSqlAndTriggerMultipleTables() {
+    db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(o);
+    o.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+    final RecordingObserver employeeObserver = new RecordingObserver();
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(employeeObserver);
+    employeeObserver.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    final Set<String> tablesToTrigger = Collections.unmodifiableSet(new HashSet<>(BOTH_TABLES));
+    db.executeAndTrigger(tablesToTrigger,
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+
+    o.assertCursor()
+        .hasRow("Zach", "Zach")
+        .isExhausted();
+    employeeObserver.assertCursor()
+        .hasRow("alice", "Zach")
+        .hasRow("bob", "Zach")
+        .hasRow("eve", "Zach")
+        .isExhausted();
+  }
+
+  @Test public void executeSqlAndTriggerWithNoTables() {
+    db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(o);
+    o.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+
+    db.executeAndTrigger(Collections.<String>emptySet(),
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+
+    o.assertNoMoreEvents();
+  }
+
   @Test public void executeSqlThrowsAndDoesNotTrigger() {
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
         .skip(1) // Skip initial
@@ -385,6 +485,338 @@
     o.assertNoMoreEvents();
   }
 
+  @Test public void executeSqlWithArgsAndTriggerWithMultipleTables() {
+    db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(o);
+    o.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+    final RecordingObserver employeeObserver = new RecordingObserver();
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(employeeObserver);
+    employeeObserver.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    final Set<String> tablesToTrigger = Collections.unmodifiableSet(new HashSet<>(BOTH_TABLES));
+    db.executeAndTrigger(tablesToTrigger,
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = ?", "Zach");
+
+    o.assertCursor()
+        .hasRow("Zach", "Zach")
+        .isExhausted();
+    employeeObserver.assertCursor()
+        .hasRow("alice", "Zach")
+        .hasRow("bob", "Zach")
+        .hasRow("eve", "Zach")
+        .isExhausted();
+  }
+
+  @Test public void executeSqlWithArgsAndTriggerWithNoTables() {
+    db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
+    o.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+
+    db.executeAndTrigger(Collections.<String>emptySet(),
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = ?", "Zach");
+
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void executeInsertAndTrigger() {
+    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
+        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") "
+        + "VALUES ('Chad Chadson', 'chad')");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeInsert(TABLE_EMPLOYEE, statement);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .hasRow("chad", "Chad Chadson")
+        .isExhausted();
+  }
+
+  @Test public void executeInsertAndDontTrigger() {
+    SQLiteStatement statement = real.compileStatement("INSERT OR IGNORE INTO " + TABLE_EMPLOYEE + " ("
+        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") "
+        + "VALUES ('Alice Allison', 'alice')");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeInsert(TABLE_EMPLOYEE, statement);
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void executeInsertAndTriggerMultipleTables() {
+    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
+        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") "
+        + "VALUES ('Chad Chadson', 'chad')");
+
+    final RecordingObserver managerObserver = new RecordingObserver();
+    db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(managerObserver);
+    managerObserver.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    final Set<String> employeeAndManagerTables = Collections.unmodifiableSet(new HashSet<>(BOTH_TABLES));
+    db.executeInsert(employeeAndManagerTables, statement);
+
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .hasRow("chad", "Chad Chadson")
+        .isExhausted();
+    managerObserver.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+  }
+
+  @Test public void executeInsertAndTriggerNoTables() {
+    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
+        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") "
+        + "VALUES ('Chad Chadson', 'chad')");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeInsert(Collections.<String>emptySet(), statement);
+
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void executeInsertThrowsAndDoesNotTrigger() {
+    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
+        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") "
+        + "VALUES ('Alice Allison', 'alice')");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+        .skip(1) // Skip initial
+        .subscribe(o);
+
+    try {
+      db.executeInsert(TABLE_EMPLOYEE, statement);
+      fail();
+    } catch (SQLException ignored) {
+    }
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void executeInsertWithArgsAndTrigger() {
+    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
+        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") VALUES (?, ?)");
+    statement.bindString(1, "Chad Chadson");
+    statement.bindString(2, "chad");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeInsert(TABLE_EMPLOYEE, statement);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .hasRow("chad", "Chad Chadson")
+        .isExhausted();
+  }
+
+  @Test public void executeInsertWithArgsThrowsAndDoesNotTrigger() {
+    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
+        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") VALUES (?, ?)");
+    statement.bindString(1, "Alice Aliison");
+    statement.bindString(2, "alice");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+        .skip(1) // Skip initial
+        .subscribe(o);
+
+    try {
+      db.executeInsert(TABLE_EMPLOYEE, statement);
+      fail();
+    } catch (SQLException ignored) {
+    }
+    o.assertNoMoreEvents();
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+  @Test public void executeUpdateDeleteAndTrigger() {
+    SQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
+    o.assertCursor()
+        .hasRow("alice", "Zach")
+        .hasRow("bob", "Zach")
+        .hasRow("eve", "Zach")
+        .isExhausted();
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+  @Test public void executeUpdateDeleteAndDontTrigger() {
+    SQLiteStatement statement = real.compileStatement(""
+        + "UPDATE " + TABLE_EMPLOYEE
+        + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'"
+        + " WHERE " + TestDb.EmployeeTable.NAME + " = 'Rob'");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
+    o.assertNoMoreEvents();
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+  @Test public void executeUpdateDeleteAndTriggerWithMultipleTables() {
+    SQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+
+
+    final RecordingObserver managerObserver = new RecordingObserver();
+    db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(managerObserver);
+    managerObserver.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    final Set<String> employeeAndManagerTables = Collections.unmodifiableSet(new HashSet<>(BOTH_TABLES));
+    db.executeUpdateDelete(employeeAndManagerTables, statement);
+
+    o.assertCursor()
+        .hasRow("alice", "Zach")
+        .hasRow("bob", "Zach")
+        .hasRow("eve", "Zach")
+        .isExhausted();
+    managerObserver.assertCursor()
+        .hasRow("Zach", "Zach")
+        .isExhausted();
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+  @Test public void executeUpdateDeleteAndTriggerWithNoTables() {
+    SQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeUpdateDelete(Collections.<String>emptySet(), statement);
+
+    o.assertNoMoreEvents();
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+  @Test public void executeUpdateDeleteThrowsAndDoesNotTrigger() {
+    SQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.USERNAME + " = 'alice'");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+        .skip(1) // Skip initial
+        .subscribe(o);
+
+    try {
+      db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
+      fail();
+    } catch (SQLException ignored) {
+    }
+    o.assertNoMoreEvents();
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+  @Test public void executeUpdateDeleteWithArgsAndTrigger() {
+    SQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = ?");
+    statement.bindString(1, "Zach");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
+    o.assertCursor()
+        .hasRow("alice", "Zach")
+        .hasRow("bob", "Zach")
+        .hasRow("eve", "Zach")
+        .isExhausted();
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+  @Test public void executeUpdateDeleteWithArgsThrowsAndDoesNotTrigger() {
+    SQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.USERNAME + " = ?");
+    statement.bindString(1, "alice");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+        .skip(1) // Skip initial
+        .subscribe(o);
+
+    try {
+      db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
+      fail();
+    } catch (SQLException ignored) {
+    }
+    o.assertNoMoreEvents();
+  }
+
   @Test public void transactionOnlyNotifiesOnce() {
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
     o.assertCursor()
@@ -489,8 +921,10 @@
   }
 
   @Test public void queryCreatedDuringTransactionThrows() {
+    //noinspection CheckResult
     db.newTransaction();
     try {
+      //noinspection CheckResult
       db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
       fail();
     } catch (IllegalStateException e) {
@@ -501,6 +935,7 @@
   @Test public void querySubscribedToDuringTransactionThrows() {
     Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
 
+    //noinspection CheckResult
     db.newTransaction();
     query.subscribe(o);
     o.assertErrorContains("Cannot subscribe to observable query in a transaction.");
@@ -511,6 +946,7 @@
 
     Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
 
+    //noinspection CheckResult
     db.newTransaction();
     query.subscribe(o);
     o.assertErrorContains("Cannot subscribe to observable query in a transaction.");
@@ -720,7 +1156,43 @@
     o.assertNoMoreEvents();
   }
 
-  @Test public void backpressureSupported() {
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+  @Test public void nonExclusiveTransactionWorks() throws InterruptedException {
+    final CountDownLatch transactionStarted = new CountDownLatch(1);
+    final CountDownLatch transactionProceed = new CountDownLatch(1);
+    final CountDownLatch transactionCompleted = new CountDownLatch(1);
+
+    new Thread() {
+      @Override public void run() {
+        Transaction transaction = db.newNonExclusiveTransaction();
+        transactionStarted.countDown();
+        try {
+          db.insert(TABLE_EMPLOYEE, employee("hans", "Hans Hanson"));
+          transactionProceed.await(10, SECONDS);
+        } catch (InterruptedException e) {
+          throw new RuntimeException("Exception in transaction thread", e);
+        }
+        transaction.markSuccessful();
+        transaction.close();
+        transactionCompleted.countDown();
+      }
+    }.start();
+
+    assertThat(transactionStarted.await(10, SECONDS)).isTrue();
+
+    //Simple query
+    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+            .lift(Query.mapToOne(Employee.MAPPER))
+            .toBlocking()
+            .first();
+    assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
+
+    transactionProceed.countDown();
+    assertThat(transactionCompleted.await(10, SECONDS)).isTrue();
+  }
+
+  @Test public void backpressureSupportedWhenConsumerSlow() {
     o.doRequest(2);
 
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
@@ -765,8 +1237,35 @@
     o.assertNoMoreEvents();
   }
 
+  @Test public void backpressureSupportedWhenSchedulerSlow() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    // Switch the scheduler to queue actions.
+    scheduler.runTasksImmediately(false);
+
+    // Shotgun twice as many insertions as the scheduler queue can handle.
+    for (int i = 0; i < RxRingBuffer.SIZE * 2; i++) {
+      db.insert(TABLE_EMPLOYEE, employee("user" + i, "name" + i));
+    }
+
+    scheduler.triggerActions();
+
+    // Assert we got all the events from the queue plus the one buffered from backpressure.
+    // Note: Because of the rebatching request behavior of observeOn, the initial emission is
+    // counted against this amount which is why there is no +1 on SIZE.
+    for (int i = 0; i < RxRingBuffer.SIZE; i++) {
+      o.assertCursor(); // Ignore contents, just assert we got notified.
+    }
+  }
+
   @Test public void badQueryThrows() {
     try {
+      //noinspection CheckResult
       db.query("SELECT * FROM missing");
       fail();
     } catch (SQLiteException e) {
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryObservableTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryObservableTest.java
index 5d5ac6c..b8094b8 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryObservableTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryObservableTest.java
@@ -9,7 +9,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import rx.Observable;
+import rx.Observable.OnSubscribe;
+import rx.Subscriber;
 import rx.functions.Func1;
 import rx.observers.TestSubscriber;
 
@@ -21,11 +22,15 @@
   @Test public void mapToListThrowsFromQueryRun() {
     TestSubscriber<Object> testSubscriber = new TestSubscriber<>();
 
-    new QueryObservable(Observable.<Query>just(new Query() {
-      @Override public Cursor run() {
-        throw new IllegalStateException("test exception");
+    new QueryObservable(new OnSubscribe<Query>() {
+      @Override public void call(Subscriber<? super Query> subscriber) {
+        subscriber.onNext(new Query() {
+          @Override public Cursor run() {
+            throw new IllegalStateException("test exception");
+          }
+        });
       }
-    })).mapToList(new Func1<Cursor, Object>() {
+    }).mapToList(new Func1<Cursor, Object>() {
       @Override public Object call(Cursor cursor) {
         throw new AssertionError("Must not be called");
       }
@@ -42,13 +47,17 @@
   @Test public void mapToListThrowsFromMapFunction() {
     TestSubscriber<Object> testSubscriber = new TestSubscriber<>();
 
-    new QueryObservable(Observable.<Query>just(new Query() {
-      @Override public Cursor run() {
-        MatrixCursor cursor = new MatrixCursor(new String[]{"col1"});
-        cursor.addRow(new Object[]{"value1"});
-        return cursor;
+    new QueryObservable(new OnSubscribe<Query>() {
+      @Override public void call(Subscriber<? super Query> subscriber) {
+        subscriber.onNext(new Query() {
+          @Override public Cursor run() {
+            MatrixCursor cursor = new MatrixCursor(new String[]{"col1"});
+            cursor.addRow(new Object[]{"value1"});
+            return cursor;
+          }
+        });
       }
-    })).mapToList(new Func1<Cursor, Object>() {
+    }).mapToList(new Func1<Cursor, Object>() {
       @Override public Object call(Cursor cursor) {
         throw new IllegalStateException("test exception");
       }
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java
index 159b8f7..3bed90a 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java
@@ -16,26 +16,33 @@
 package com.squareup.sqlbrite;
 
 import android.database.Cursor;
+import android.support.annotation.Nullable;
 import android.support.test.InstrumentationRegistry;
 import com.squareup.sqlbrite.SqlBrite.Query;
 import com.squareup.sqlbrite.TestDb.Employee;
+import java.util.ArrayList;
 import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
+import rx.Observable;
+import rx.functions.Action1;
 import rx.functions.Func1;
 import rx.observables.BlockingObservable;
+import rx.observers.TestSubscriber;
+import rx.schedulers.Schedulers;
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.squareup.sqlbrite.TestDb.SELECT_EMPLOYEES;
 import static com.squareup.sqlbrite.TestDb.TABLE_EMPLOYEE;
+import static org.junit.Assert.fail;
 
 public final class QueryTest {
   private BriteDatabase db;
 
   @Before public void setUp() {
     SqlBrite sqlBrite = SqlBrite.create();
-    TestDb helper = new TestDb(InstrumentationRegistry.getContext());
-    db = sqlBrite.wrapDatabaseHelper(helper);
+    TestDb helper = new TestDb(InstrumentationRegistry.getContext(), null /* memory */);
+    db = sqlBrite.wrapDatabaseHelper(helper, Schedulers.immediate());
   }
 
   @Test public void mapToOne() {
@@ -46,32 +53,34 @@
     assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
   }
 
-  @Test public void mapToOneThrowsOnMapperNull() {
-    BlockingObservable<Employee> employees =
-        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES) //
-            .lift(Query.mapToOne(new Func1<Cursor, Employee>() {
-              @Override public Employee call(Cursor cursor) {
-                return null;
-              }
-            })) //
-            .toBlocking();
-    try {
-      employees.first();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("Mapper returned null for row 1");
-      assertThat(e.getCause()).hasMessage(
-          "OnError while emitting onNext value: SELECT username, name FROM employee");
-    }
+  @Test public void mapToOneAllowsMapperNull() {
+    Func1<Cursor, Employee> mapToNull = new Func1<Cursor, Employee>() {
+      @Override public Employee call(Cursor cursor) {
+        return null;
+      }
+    };
+    Employee employee = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1") //
+        .lift(Query.mapToOne(mapToNull)) //
+        .toBlocking() //
+        .first();
+    assertThat(employee).isNull();
   }
 
-  @Test public void mapToOneNoOpOnNoRows() {
+  @Test public void mapToOneNoOpAndReRequestOnNoRows() {
+    final List<Long> requests = new ArrayList<>();
     List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE 1=2")
         .take(1)
+        .doOnRequest(new Action1<Long>() {
+          @Override public void call(Long n) {
+            requests.add(n);
+          }
+        })
         .lift(Query.mapToOne(Employee.MAPPER))
         .toList()
         .toBlocking()
         .first();
     assertThat(employees).isEmpty();
+    assertThat(requests).containsExactly(Long.MAX_VALUE, 1L);
   }
 
   @Test public void mapToOneThrowsOnMultipleRows() {
@@ -81,6 +90,7 @@
             .toBlocking();
     try {
       employees.first();
+      fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Cursor returned more than 1 row");
       assertThat(e.getCause()).hasMessage(
@@ -88,6 +98,22 @@
     }
   }
 
+  @Test public void mapToOneIgnoresNullCursor() {
+    Query nully = new Query() {
+      @Nullable @Override public Cursor run() {
+        return null;
+      }
+    };
+
+    TestSubscriber<Employee> subscriber = new TestSubscriber<>();
+    Observable.just(nully)
+        .lift(Query.mapToOne(Employee.MAPPER))
+        .subscribe(subscriber);
+
+    subscriber.assertNoValues();
+    subscriber.assertCompleted();
+  }
+
   @Test public void mapToOneOrDefault() {
     Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
         .lift(Query.mapToOneOrDefault(Employee.MAPPER, null))
@@ -96,13 +122,22 @@
     assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
   }
 
-  @Test public void mapToOneOrDefaultReturnsDefaultWhenNoRows() {
+  @Test public void mapToOneOrDefaultReturnsDefaultAndDoesNotReRequestWhenNoRows() {
+    final List<Long> requests = new ArrayList<>();
     Employee defaultEmployee = new Employee("bob", "Bob Bobberson");
-    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE 1=2")
+    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE 1=2")
+        .take(1)
+        .doOnRequest(new Action1<Long>() {
+          @Override public void call(Long n) {
+            requests.add(n);
+          }
+        })
         .lift(Query.mapToOneOrDefault(Employee.MAPPER, defaultEmployee))
+        .toList()
         .toBlocking()
         .first();
-    assertThat(employees).isSameAs(defaultEmployee);
+    assertThat(employees).containsExactly(defaultEmployee);
+    assertThat(requests).containsExactly(Long.MAX_VALUE);
   }
 
   @Test public void mapToOneOrDefaultAllowsNullDefault() {
@@ -113,22 +148,17 @@
     assertThat(employees).isNull();
   }
 
-  @Test public void mapToOneOrDefaultThrowsOnMapperNull() {
-    BlockingObservable<Employee> employees =
-        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES) //
-            .lift(Query.mapToOneOrDefault(new Func1<Cursor, Employee>() {
-              @Override public Employee call(Cursor cursor) {
-                return null;
-              }
-            }, null)) //
-            .toBlocking();
-    try {
-      employees.first();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("Mapper returned null for row 1");
-      assertThat(e.getCause()).hasMessage(
-          "OnError while emitting onNext value: SELECT username, name FROM employee");
-    }
+  @Test public void mapToOneOrDefaultAllowsMapperNull() {
+    Func1<Cursor, Employee> mapToNull = new Func1<Cursor, Employee>() {
+      @Override public Employee call(Cursor cursor) {
+        return null;
+      }
+    };
+    Employee employee = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1") //
+        .lift(Query.mapToOneOrDefault(mapToNull, new Employee("bob", "Bob Bobberson"))) //
+        .toBlocking() //
+        .first();
+    assertThat(employee).isNull();
   }
 
   @Test public void mapToOneOrDefaultThrowsOnMultipleRows() {
@@ -138,6 +168,7 @@
             .toBlocking();
     try {
       employees.first();
+      fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Cursor returned more than 1 row");
       assertThat(e.getCause()).hasMessage(
@@ -145,6 +176,23 @@
     }
   }
 
+  @Test public void mapToOneOrDefaultReturnsDefaultWhenNullCursor() {
+    Employee defaultEmployee = new Employee("bob", "Bob Bobberson");
+    Query nully = new Query() {
+      @Nullable @Override public Cursor run() {
+        return null;
+      }
+    };
+
+    TestSubscriber<Employee> subscriber = new TestSubscriber<>();
+    Observable.just(nully)
+        .lift(Query.mapToOneOrDefault(Employee.MAPPER, defaultEmployee))
+        .subscribe(subscriber);
+
+    subscriber.assertValues(defaultEmployee);
+    subscriber.assertCompleted();
+  }
+
   @Test public void mapToList() {
     List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
         .lift(Query.mapToList(Employee.MAPPER))
@@ -164,23 +212,38 @@
     assertThat(employees).isEmpty();
   }
 
-  @Test public void mapToListThrowsOnMapperNull() {
-    BlockingObservable<List<Employee>> employees =
-        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES) //
-            .lift(Query.mapToList(new Func1<Cursor, Employee>() {
-              private int count;
+  @Test public void mapToListReturnsNullOnMapperNull() {
+    Func1<Cursor, Employee> mapToNull = new Func1<Cursor, Employee>() {
+      private int count;
+
+      @Override public Employee call(Cursor cursor) {
+        return count++ == 2 ? null : Employee.MAPPER.call(cursor);
+      }
+    };
+    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES) //
+            .lift(Query.mapToList(mapToNull)) //
+            .toBlocking() //
+            .first();
+
+    assertThat(employees).containsExactly(
+        new Employee("alice", "Alice Allison"),
+        new Employee("bob", "Bob Bobberson"),
+        null);
+  }
 
-              @Override public Employee call(Cursor cursor) {
-                return count++ == 2 ? null : Employee.MAPPER.call(cursor);
-              }
-            })) //
-            .toBlocking();
-    try {
-      employees.first();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("Mapper returned null for row 3");
-      assertThat(e.getCause()).hasMessage(
-          "OnError while emitting onNext value: SELECT username, name FROM employee");
-    }
+  @Test public void mapToListIgnoresNullCursor() {
+    Query nully = new Query() {
+      @Nullable @Override public Cursor run() {
+        return null;
+      }
+    };
+
+    TestSubscriber<List<Employee>> subscriber = new TestSubscriber<>();
+    Observable.just(nully)
+        .lift(Query.mapToList(Employee.MAPPER))
+        .subscribe(subscriber);
+
+    subscriber.assertNoValues();
+    subscriber.assertCompleted();
   }
 }
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java
index 94b3648..c1deaf1 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java
@@ -69,6 +69,11 @@ public final void assertErrorContains(String expected) {
     assertThat(((Throwable) event).getMessage()).contains(expected);
   }
 
+  public final void assertIsCompleted() {
+    Object event = takeEvent();
+    assertThat(event).isEqualTo(COMPLETED);
+  }
+
   public void assertNoMoreEvents() {
     assertThat(events).isEmpty();
   }
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java
index f320d2b..6a5821a 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java
@@ -2,6 +2,7 @@
 
 import android.database.Cursor;
 import android.database.MatrixCursor;
+import android.support.annotation.Nullable;
 import android.support.test.runner.AndroidJUnit4;
 import com.squareup.sqlbrite.SqlBrite.Query;
 import java.util.List;
@@ -9,15 +10,43 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import rx.functions.Func1;
+import rx.observers.TestSubscriber;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
+@SuppressWarnings("CheckResult")
 public final class SqlBriteTest {
   private static final String FIRST_NAME = "first_name";
   private static final String LAST_NAME = "last_name";
   private static final String[] COLUMN_NAMES = { FIRST_NAME, LAST_NAME };
 
+  @Test public void builderDisallowsNull() {
+    SqlBrite.Builder builder = new SqlBrite.Builder();
+    try {
+      builder.logger(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("logger == null");
+    }
+    try {
+      builder.queryTransformer(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("queryTransformer == null");
+    }
+  }
+
+  @Test public void createDisallowsNull() {
+    try {
+      SqlBrite.create(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("logger == null");
+    }
+  }
+
   @Test public void asRowsEmpty() {
     MatrixCursor cursor = new MatrixCursor(COLUMN_NAMES);
     Query query = new CursorQuery(cursor);
@@ -51,6 +80,28 @@
     assertThat(count.get()).isEqualTo(1);
   }
 
+  @Test public void asRowsEmptyWhenNullCursor() {
+    Query nully = new Query() {
+      @Nullable @Override public Cursor run() {
+        return null;
+      }
+    };
+
+    TestSubscriber<Name> subscriber = new TestSubscriber<>();
+    final AtomicInteger count = new AtomicInteger();
+    nully.asRows(new Func1<Cursor, Name>() {
+      @Override public Name call(Cursor cursor) {
+        count.incrementAndGet();
+        return Name.MAP.call(cursor);
+      }
+    }).subscribe(subscriber);
+
+    subscriber.assertNoValues();
+    subscriber.assertCompleted();
+
+    assertThat(count.get()).isEqualTo(0);
+  }
+
   static final class Name {
     static final Func1<Cursor, Name> MAP = new Func1<Cursor, Name>() {
       @Override public Name call(Cursor cursor) {
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestDb.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestDb.java
index 6fa8d20..04f9681 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestDb.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestDb.java
@@ -105,8 +105,8 @@
   long bobId;
   long eveId;
 
-  TestDb(Context context) {
-    super(context, null /* memory */, null /* cursor factory */, 1 /* version */);
+  TestDb(Context context, String path) {
+    super(context, path, null /* cursor factory */, 1 /* version */);
   }
 
   @Override public void onCreate(@NonNull SQLiteDatabase db) {
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestScheduler.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestScheduler.java
new file mode 100644
index 0000000..04aee49
--- /dev/null
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestScheduler.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.sqlbrite;
+
+import java.util.concurrent.TimeUnit;
+import rx.Scheduler;
+import rx.Subscription;
+import rx.functions.Action0;
+
+final class TestScheduler extends Scheduler {
+  private final rx.schedulers.TestScheduler delegate = new rx.schedulers.TestScheduler();
+  private boolean runTasksImmediately = true;
+
+  public void runTasksImmediately(boolean runTasksImmediately) {
+    this.runTasksImmediately = runTasksImmediately;
+  }
+
+  public void triggerActions() {
+    delegate.triggerActions();
+  }
+
+  @Override public Worker createWorker() {
+    return new TestWorker();
+  }
+
+  class TestWorker extends Worker {
+    private final Worker delegateWorker = delegate.createWorker();
+
+    @Override public Subscription schedule(Action0 action) {
+      Subscription subscription = delegateWorker.schedule(action);
+      if (runTasksImmediately) {
+        triggerActions();
+      }
+      return subscription;
+    }
+
+    @Override public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
+      Subscription subscription = delegateWorker.schedule(action, delayTime, unit);
+      if (runTasksImmediately) {
+        triggerActions();
+      }
+      return subscription;
+    }
+
+    @Override public void unsubscribe() {
+      delegateWorker.unsubscribe();
+    }
+
+    @Override public boolean isUnsubscribed() {
+      return delegateWorker.isUnsubscribed();
+    }
+  }
+}
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
index 157297d..10d62b2 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
@@ -27,6 +27,8 @@
 import java.util.Arrays;
 import rx.Observable;
 import rx.Observable.OnSubscribe;
+import rx.Observable.Transformer;
+import rx.Scheduler;
 import rx.Subscriber;
 import rx.functions.Action0;
 import rx.subscriptions.Subscriptions;
@@ -45,12 +47,17 @@
 
   final ContentResolver contentResolver;
   private final Logger logger;
+  private final Scheduler scheduler;
+  private final Transformer<Query, Query> queryTransformer;
 
   volatile boolean logging;
 
-  BriteContentResolver(@NonNull ContentResolver contentResolver, @NonNull Logger logger) {
+  BriteContentResolver(ContentResolver contentResolver, Logger logger, Scheduler scheduler,
+      Transformer<Query, Query> queryTransformer) {
     this.contentResolver = contentResolver;
     this.logger = logger;
+    this.scheduler = scheduler;
+    this.queryTransformer = queryTransformer;
   }
 
   /** Control whether debug logging is enabled. */
@@ -67,6 +74,11 @@ public void setLoggingEnabled(boolean enabled) {
    * notifications for when the supplied {@code uri}'s data changes. Unsubscribe when you no longer
    * want updates to a query.
    * <p>
+   * Since content resolver triggers are inherently asynchronous, items emitted from the returned
+   * observable use the {@link Scheduler} supplied to {@link SqlBrite#wrapContentProvider}. For
+   * consistency, the immediate notification sent on subscribe also uses this scheduler. As such,
+   * calling {@link Observable#subscribeOn subscribeOn} on the returned observable has no effect.
+   * <p>
    * Note: To skip the immediate notification and only receive subsequent notifications when data
    * has changed call {@code skip(1)} on the returned observable.
    * <p>
@@ -84,9 +96,9 @@ public QueryObservable createQuery(@NonNull final Uri uri, @Nullable final Strin
       @Override public Cursor run() {
         long startNanos = nanoTime();
         Cursor cursor = contentResolver.query(uri, projection, selection, selectionArgs, sortOrder);
-        long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
 
         if (logging) {
+          long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
           log("QUERY (%sms)\n  uri: %s\n  projection: %s\n  selection: %s\n  selectionArgs: %s\n  "
                   + "sortOrder: %s\n  notifyForDescendents: %s", tookMillis, uri,
               Arrays.toString(projection), selection, Arrays.toString(selectionArgs), sortOrder,
@@ -109,12 +121,21 @@ public QueryObservable createQuery(@NonNull final Uri uri, @Nullable final Strin
             contentResolver.unregisterContentObserver(observer);
           }
         }));
+
+        subscriber.onNext(query); // Trigger initial query.
       }
     };
-    Observable<Query> queryObservable = Observable.create(subscribe) //
-        .startWith(query) //
-        .onBackpressureLatest();
-    return new QueryObservable(queryObservable);
+    final Observable<Query> queryObservable = Observable.create(subscribe) //
+        .onBackpressureLatest() // Guard against uncontrollable frequency of upstream emissions.
+        .observeOn(scheduler) //
+        .compose(queryTransformer) // Apply the user's query transformer.
+        .onBackpressureLatest(); // Guard against uncontrollable frequency of scheduler executions.
+    // TODO switch to .to() when non-@Experimental
+    return new QueryObservable(new OnSubscribe<Query>() {
+      @Override public void call(Subscriber<? super Query> subscriber) {
+        queryObservable.unsafeSubscribe(subscriber);
+      }
+    });
   }
 
   void log(String message, Object... args) {
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
index 30edc38..a86d0db 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
@@ -19,11 +19,15 @@
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
+import android.database.sqlite.SQLiteStatement;
 import android.database.sqlite.SQLiteTransactionListener;
+import android.os.Build;
 import android.support.annotation.CheckResult;
 import android.support.annotation.IntDef;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
+import android.support.annotation.WorkerThread;
 import com.squareup.sqlbrite.SqlBrite.Query;
 import java.io.Closeable;
 import java.lang.annotation.Retention;
@@ -33,6 +37,9 @@
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import rx.Observable;
+import rx.Observable.Transformer;
+import rx.Scheduler;
+import rx.Subscriber;
 import rx.functions.Action0;
 import rx.functions.Func1;
 import rx.subjects.PublishSubject;
@@ -43,6 +50,7 @@
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_NONE;
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_REPLACE;
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_ROLLBACK;
+import static android.os.Build.VERSION_CODES.HONEYCOMB;
 import static java.lang.System.nanoTime;
 import static java.lang.annotation.RetentionPolicy.SOURCE;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
@@ -54,6 +62,7 @@
 public final class BriteDatabase implements Closeable {
   private final SQLiteOpenHelper helper;
   private final SqlBrite.Logger logger;
+  private final Transformer<Query, Query> queryTransformer;
 
   // Package-private to avoid synthetic accessor method for 'transaction' instance.
   final ThreadLocal<SqliteTransaction> transactions = new ThreadLocal<>();
@@ -63,15 +72,15 @@
   private final Transaction transaction = new Transaction() {
     @Override public void markSuccessful() {
       if (logging) log("TXN SUCCESS %s", transactions.get());
-      getWriteableDatabase().setTransactionSuccessful();
+      getWritableDatabase().setTransactionSuccessful();
     }
 
     @Override public boolean yieldIfContendedSafely() {
-      return getWriteableDatabase().yieldIfContendedSafely();
+      return getWritableDatabase().yieldIfContendedSafely();
     }
 
     @Override public boolean yieldIfContendedSafely(long sleepAmount, TimeUnit sleepUnit) {
-      return getWriteableDatabase().yieldIfContendedSafely(sleepUnit.toMillis(sleepAmount));
+      return getWritableDatabase().yieldIfContendedSafely(sleepUnit.toMillis(sleepAmount));
     }
 
     @Override public void end() {
@@ -82,7 +91,7 @@
       SqliteTransaction newTransaction = transaction.parent;
       transactions.set(newTransaction);
       if (logging) log("TXN END %s", transaction);
-      getWriteableDatabase().endTransaction();
+      getWritableDatabase().endTransaction();
       // Send the triggers after ending the transaction in the DB.
       if (transaction.commit) {
         sendTableTrigger(transaction);
@@ -93,18 +102,25 @@
       end();
     }
   };
+  private final Action0 ensureNotInTransaction = new Action0() {
+    @Override public void call() {
+      if (transactions.get() != null) {
+        throw new IllegalStateException("Cannot subscribe to observable query in a transaction.");
+      }
+    }
+  };
 
-  // Read and write guarded by 'databaseLock'. Lazily initialized. Use methods to access.
-  private volatile SQLiteDatabase readableDatabase;
-  private volatile SQLiteDatabase writeableDatabase;
-  private final Object databaseLock = new Object();
+  private final Scheduler scheduler;
 
   // Package-private to avoid synthetic accessor method for 'transaction' instance.
   volatile boolean logging;
 
-  BriteDatabase(@NonNull SQLiteOpenHelper helper, @NonNull SqlBrite.Logger logger) {
+  BriteDatabase(SQLiteOpenHelper helper, SqlBrite.Logger logger, Scheduler scheduler,
+      Transformer<Query, Query> queryTransformer) {
     this.helper = helper;
     this.logger = logger;
+    this.scheduler = scheduler;
+    this.queryTransformer = queryTransformer;
   }
 
   /**
@@ -114,33 +130,59 @@ public void setLoggingEnabled(boolean enabled) {
     logging = enabled;
   }
 
-  SQLiteDatabase getReadableDatabase() {
-    SQLiteDatabase db = readableDatabase;
-    if (db == null) {
-      synchronized (databaseLock) {
-        db = readableDatabase;
-        if (db == null) {
-          if (logging) log("Creating readable database");
-          db = readableDatabase = helper.getReadableDatabase();
-        }
-      }
-    }
-    return db;
+  /**
+   * Create and/or open a database.  This will be the same object returned by
+   * {@link SQLiteOpenHelper#getWritableDatabase} unless some problem, such as a full disk,
+   * requires the database to be opened read-only.  In that case, a read-only
+   * database object will be returned.  If the problem is fixed, a future call
+   * to {@link SQLiteOpenHelper#getWritableDatabase} may succeed, in which case the read-only
+   * database object will be closed and the read/write object will be returned
+   * in the future.
+   *
+   * <p class="caution">Like {@link SQLiteOpenHelper#getWritableDatabase}, this method may
+   * take a long time to return, so you should not call it from the
+   * application main thread, including from
+   * {@link android.content.ContentProvider#onCreate ContentProvider.onCreate()}.
+   *
+   * @throws android.database.sqlite.SQLiteException if the database cannot be opened
+   * @return a database object valid until {@link SQLiteOpenHelper#getWritableDatabase}
+   *     or {@link #close} is called.
+   */
+  @NonNull @CheckResult @WorkerThread
+  public SQLiteDatabase getReadableDatabase() {
+    return helper.getReadableDatabase();
   }
 
-  // Package-private to avoid synthetic accessor method for 'transaction' instance.
-  SQLiteDatabase getWriteableDatabase() {
-    SQLiteDatabase db = writeableDatabase;
-    if (db == null) {
-      synchronized (databaseLock) {
-        db = writeableDatabase;
-        if (db == null) {
-          if (logging) log("Creating writeable database");
-          db = writeableDatabase = helper.getWritableDatabase();
-        }
-      }
-    }
-    return db;
+
+  /** @deprecated Use {@link #getWritableDatabase()}. */
+  @Deprecated
+  @NonNull @CheckResult @WorkerThread
+  public SQLiteDatabase getWriteableDatabase() {
+    return helper.getWritableDatabase();
+  }
+
+  /**
+   * Create and/or open a database that will be used for reading and writing.
+   * The first time this is called, the database will be opened and
+   * {@link SQLiteOpenHelper#onCreate}, {@link SQLiteOpenHelper#onUpgrade}
+   * and/or {@link SQLiteOpenHelper#onOpen} will be called.
+   *
+   * <p>Once opened successfully, the database is cached, so you can
+   * call this method every time you need to write to the database.
+   * (Make sure to call {@link #close} when you no longer need the database.)
+   * Errors such as bad permissions or a full disk may cause this method
+   * to fail, but future attempts may succeed if the problem is fixed.</p>
+   *
+   * <p class="caution">Database upgrade may take a long time, you
+   * should not call this method from the application main thread, including
+   * from {@link android.content.ContentProvider#onCreate ContentProvider.onCreate()}.
+   *
+   * @throws android.database.sqlite.SQLiteException if the database cannot be opened for writing
+   * @return a read/write database object valid until {@link #close} is called
+   */
+  @NonNull @CheckResult @WorkerThread
+  public SQLiteDatabase getWritableDatabase() {
+    return helper.getWritableDatabase();
   }
 
   void sendTableTrigger(Set<String> tables) {
@@ -195,7 +237,55 @@ public Transaction newTransaction() {
     SqliteTransaction transaction = new SqliteTransaction(transactions.get());
     transactions.set(transaction);
     if (logging) log("TXN BEGIN %s", transaction);
-    getWriteableDatabase().beginTransactionWithListener(transaction);
+    getWritableDatabase().beginTransactionWithListener(transaction);
+
+    return this.transaction;
+  }
+
+  /**
+   * Begins a transaction in IMMEDIATE mode for this thread.
+   * <p>
+   * Transactions may nest. If the transaction is not in progress, then a database connection is
+   * obtained and a new transaction is started. Otherwise, a nested transaction is started.
+   * <p>
+   * Each call to {@code newNonExclusiveTransaction} must be matched exactly by a call to
+   * {@link Transaction#end()}. To mark a transaction as successful, call
+   * {@link Transaction#markSuccessful()} before calling {@link Transaction#end()}. If the
+   * transaction is not successful, or if any of its nested transactions were not successful, then
+   * the entire transaction will be rolled back when the outermost transaction is ended.
+   * <p>
+   * Transactions queue up all query notifications until they have been applied.
+   * <p>
+   * Here is the standard idiom for transactions:
+   *
+   * <pre>{@code
+   * try (Transaction transaction = db.newNonExclusiveTransaction()) {
+   *   ...
+   *   transaction.markSuccessful();
+   * }
+   * }</pre>
+   *
+   * Manually call {@link Transaction#end()} when try-with-resources is not available:
+   * <pre>{@code
+   * Transaction transaction = db.newNonExclusiveTransaction();
+   * try {
+   *   ...
+   *   transaction.markSuccessful();
+   * } finally {
+   *   transaction.end();
+   * }
+   * }</pre>
+   *
+   *
+   * @see SQLiteDatabase#beginTransactionNonExclusive()
+   */
+  @RequiresApi(HONEYCOMB)
+  @CheckResult @NonNull
+  public Transaction newNonExclusiveTransaction() {
+    SqliteTransaction transaction = new SqliteTransaction(transactions.get());
+    transactions.set(transaction);
+    if (logging) log("TXN BEGIN %s", transaction);
+    getWritableDatabase().beginTransactionWithListenerNonExclusive(transaction);
 
     return this.transaction;
   }
@@ -206,11 +296,7 @@ public Transaction newTransaction() {
    * well as attempting to create new ones for new subscriptions.
    */
   @Override public void close() {
-    synchronized (databaseLock) {
-      readableDatabase = null;
-      writeableDatabase = null;
-      helper.close();
-    }
+    helper.close();
   }
 
   /**
@@ -223,6 +309,11 @@ public Transaction newTransaction() {
    * {@code update}, and {@code delete} methods of this class. Unsubscribe when you no longer want
    * updates to a query.
    * <p>
+   * Since database triggers are inherently asynchronous, items emitted from the returned
+   * observable use the {@link Scheduler} supplied to {@link SqlBrite#wrapDatabaseHelper}. For
+   * consistency, the immediate notification sent on subscribe also uses this scheduler. As such,
+   * calling {@link Observable#subscribeOn subscribeOn} on the returned observable has no effect.
+   * <p>
    * Note: To skip the immediate notification and only receive subsequent notifications when data
    * has changed call {@code skip(1)} on the returned observable.
    * <p>
@@ -273,54 +364,29 @@ public QueryObservable createQuery(@NonNull final Iterable<String> tables, @NonN
   }
 
   @CheckResult @NonNull
-  private QueryObservable createQuery(final Func1<Set<String>, Boolean> tableFilter,
-      final String sql, final String... args) {
+  private QueryObservable createQuery(Func1<Set<String>, Boolean> tableFilter, String sql,
+      String... args) {
     if (transactions.get() != null) {
       throw new IllegalStateException("Cannot create observable query in transaction. "
           + "Use query() for a query inside a transaction.");
     }
 
-    final Query query = new Query() {
-      @Override public Cursor run() {
-        if (transactions.get() != null) {
-          throw new IllegalStateException("Cannot execute observable query in a transaction.");
-        }
-
-        long startNanos = nanoTime();
-        Cursor cursor = getReadableDatabase().rawQuery(sql, args);
-        long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
-
-        if (logging) {
-          log("QUERY (%sms)\n  tables: %s\n  sql: %s\n  args: %s", tookMillis, tableFilter, sql,
-              Arrays.toString(args));
-        }
-
-        return cursor;
-      }
-
-      @Override public String toString() {
-        return sql;
-      }
-    };
-
-    Observable<Query> queryObservable = triggers //
+    DatabaseQuery query = new DatabaseQuery(tableFilter, sql, args);
+    final Observable<Query> queryObservable = triggers //
         .filter(tableFilter) // Only trigger on tables we care about.
-        .map(new Func1<Set<String>, Query>() {
-          @Override public Query call(Set<String> trigger) {
-            return query;
-          }
-        }) //
-        .startWith(query) // Immediately trigger the query for initial value.
-        .onBackpressureLatest() //
-        .doOnSubscribe(new Action0() {
-          @Override public void call() {
-            if (transactions.get() != null) {
-              throw new IllegalStateException(
-                  "Cannot subscribe to observable query in a transaction.");
-            }
-          }
-        });
-    return new QueryObservable(queryObservable);
+        .map(query) // DatabaseQuery maps to itself to save an allocation.
+        .onBackpressureLatest() // Guard against uncontrollable frequency of upstream emissions.
+        .startWith(query) //
+        .observeOn(scheduler) //
+        .compose(queryTransformer) // Apply the user's query transformer.
+        .onBackpressureLatest() // Guard against uncontrollable frequency of scheduler executions.
+        .doOnSubscribe(ensureNotInTransaction);
+    // TODO switch to .to() when non-@Experimental
+    return new QueryObservable(new Observable.OnSubscribe<Query>() {
+      @Override public void call(Subscriber<? super Query> subscriber) {
+        queryObservable.unsafeSubscribe(subscriber);
+      }
+    });
   }
 
   /**
@@ -328,14 +394,14 @@ private QueryObservable createQuery(final Func1<Set<String>, Boolean> tableFilte
    *
    * @see SQLiteDatabase#rawQuery(String, String[])
    */
-  @CheckResult // TODO @WorkerThread
+  @CheckResult @WorkerThread
   public Cursor query(@NonNull String sql, @NonNull String... args) {
     long startNanos = nanoTime();
     Cursor cursor = getReadableDatabase().rawQuery(sql, args);
     long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
 
     if (logging) {
-      log("QUERY (%sms)\n  sql: %s\n  args: %s", tookMillis, sql, Arrays.toString(args));
+      log("QUERY (%sms)\n  sql: %s\n  args: %s", tookMillis, indentSql(sql), Arrays.toString(args));
     }
 
     return cursor;
@@ -346,7 +412,7 @@ public Cursor query(@NonNull String sql, @NonNull String... args) {
    *
    * @see SQLiteDatabase#insert(String, String, ContentValues)
    */
-  // TODO @WorkerThread
+  @WorkerThread
   public long insert(@NonNull String table, @NonNull ContentValues values) {
     return insert(table, values, CONFLICT_NONE);
   }
@@ -356,10 +422,10 @@ public long insert(@NonNull String table, @NonNull ContentValues values) {
    *
    * @see SQLiteDatabase#insertWithOnConflict(String, String, ContentValues, int)
    */
-  // TODO @WorkerThread
+  @WorkerThread
   public long insert(@NonNull String table, @NonNull ContentValues values,
       @ConflictAlgorithm int conflictAlgorithm) {
-    SQLiteDatabase db = getWriteableDatabase();
+    SQLiteDatabase db = getWritableDatabase();
 
     if (logging) {
       log("INSERT\n  table: %s\n  values: %s\n  conflictAlgorithm: %s", table, values,
@@ -382,10 +448,10 @@ public long insert(@NonNull String table, @NonNull ContentValues values,
    *
    * @see SQLiteDatabase#delete(String, String, String[])
    */
-  // TODO @WorkerThread
+  @WorkerThread
   public int delete(@NonNull String table, @Nullable String whereClause,
       @Nullable String... whereArgs) {
-    SQLiteDatabase db = getWriteableDatabase();
+    SQLiteDatabase db = getWritableDatabase();
 
     if (logging) {
       log("DELETE\n  table: %s\n  whereClause: %s\n  whereArgs: %s", table, whereClause,
@@ -408,7 +474,7 @@ public int delete(@NonNull String table, @Nullable String whereClause,
    *
    * @see SQLiteDatabase#update(String, ContentValues, String, String[])
    */
-  // TODO @WorkerThread
+  @WorkerThread
   public int update(@NonNull String table, @NonNull ContentValues values,
       @Nullable String whereClause, @Nullable String... whereArgs) {
     return update(table, values, CONFLICT_NONE, whereClause, whereArgs);
@@ -420,11 +486,11 @@ public int update(@NonNull String table, @NonNull ContentValues values,
    *
    * @see SQLiteDatabase#updateWithOnConflict(String, ContentValues, String, String[], int)
    */
-  // TODO @WorkerThread
+  @WorkerThread
   public int update(@NonNull String table, @NonNull ContentValues values,
       @ConflictAlgorithm int conflictAlgorithm, @Nullable String whereClause,
       @Nullable String... whereArgs) {
-    SQLiteDatabase db = getWriteableDatabase();
+    SQLiteDatabase db = getWritableDatabase();
 
     if (logging) {
       log("UPDATE\n  table: %s\n  values: %s\n  whereClause: %s\n  whereArgs: %s\n  conflictAlgorithm: %s",
@@ -451,9 +517,11 @@ public int update(@NonNull String table, @NonNull ContentValues values,
    *
    * @see SQLiteDatabase#execSQL(String)
    */
+  @WorkerThread
   public void execute(String sql) {
-    SQLiteDatabase db = getWriteableDatabase();
-    db.execSQL(sql);
+    if (logging) log("EXECUTE\n  sql: %s", sql);
+
+    getWritableDatabase().execSQL(sql);
   }
 
   /**
@@ -465,9 +533,11 @@ public void execute(String sql) {
    *
    * @see SQLiteDatabase#execSQL(String, Object[])
    */
+  @WorkerThread
   public void execute(String sql, Object... args) {
-    SQLiteDatabase db = getWriteableDatabase();
-    db.execSQL(sql, args);
+    if (logging) log("EXECUTE\n  sql: %s\n  args: %s", sql, Arrays.toString(args));
+
+    getWritableDatabase().execSQL(sql, args);
   }
 
   /**
@@ -479,11 +549,21 @@ public void execute(String sql, Object... args) {
    *
    * @see SQLiteDatabase#execSQL(String)
    */
+  @WorkerThread
   public void executeAndTrigger(String table, String sql) {
-    SQLiteDatabase db = getWriteableDatabase();
-    db.execSQL(sql);
+    executeAndTrigger(Collections.singleton(table), sql);
+  }
+
+  /**
+   * See {@link #executeAndTrigger(String, String)} for usage. This overload allows for triggering multiple tables.
+   *
+   * @see BriteDatabase#executeAndTrigger(String, String)
+   */
+  @WorkerThread
+  public void executeAndTrigger(Set<String> tables, String sql) {
+    execute(sql);
 
-    sendTableTrigger(Collections.singleton(table));
+    sendTableTrigger(tables);
   }
 
   /**
@@ -495,11 +575,86 @@ public void executeAndTrigger(String table, String sql) {
    *
    * @see SQLiteDatabase#execSQL(String, Object[])
    */
+  @WorkerThread
   public void executeAndTrigger(String table, String sql, Object... args) {
-    SQLiteDatabase db = getWriteableDatabase();
-    db.execSQL(sql, args);
+    executeAndTrigger(Collections.singleton(table), sql, args);
+  }
+
+  /**
+   * See {@link #executeAndTrigger(String, String, Object...)} for usage. This overload allows for triggering multiple tables.
+   *
+   * @see BriteDatabase#executeAndTrigger(String, String, Object...)
+   */
+  @WorkerThread
+  public void executeAndTrigger(Set<String> tables, String sql, Object... args) {
+    execute(sql, args);
+
+    sendTableTrigger(tables);
+  }
+
+  /**
+   * Execute {@code statement}, if the the number of rows affected by execution of this SQL
+   * statement is of any importance to the caller - for example, UPDATE / DELETE SQL statements.
+   *
+   * @return the number of rows affected by this SQL statement execution.
+   * @throws android.database.SQLException If the SQL string is invalid
+   *
+   * @see SQLiteStatement#executeUpdateDelete()
+   */
+  @WorkerThread
+  @RequiresApi(Build.VERSION_CODES.HONEYCOMB)
+  public int executeUpdateDelete(String table, SQLiteStatement statement) {
+    return executeUpdateDelete(Collections.singleton(table), statement);
+  }
 
-    sendTableTrigger(Collections.singleton(table));
+  /**
+   * See {@link #executeUpdateDelete(String, SQLiteStatement)} for usage. This overload allows for triggering multiple tables.
+   *
+   * @see BriteDatabase#executeUpdateDelete(String, SQLiteStatement)
+   */
+  @WorkerThread
+  @RequiresApi(Build.VERSION_CODES.HONEYCOMB)
+  public int executeUpdateDelete(Set<String> tables, SQLiteStatement statement) {
+    if (logging) log("EXECUTE\n %s", statement);
+
+    int rows = statement.executeUpdateDelete();
+    if (rows > 0) {
+      // Only send a table trigger if rows were affected.
+      sendTableTrigger(tables);
+    }
+    return rows;
+  }
+
+  /**
+   * Execute {@code statement} and return the ID of the row inserted due to this call.
+   * The SQL statement should be an INSERT for this to be a useful call.
+   *
+   * @return the row ID of the last row inserted, if this insert is successful. -1 otherwise.
+   *
+   * @throws android.database.SQLException If the SQL string is invalid
+   *
+   * @see SQLiteStatement#executeInsert()
+   */
+  @WorkerThread
+  public long executeInsert(String table, SQLiteStatement statement) {
+    return executeInsert(Collections.singleton(table), statement);
+  }
+
+  /**
+   * See {@link #executeInsert(String, SQLiteStatement)} for usage. This overload allows for triggering multiple tables.
+   *
+   * @see BriteDatabase#executeInsert(String, SQLiteStatement)
+   */
+  @WorkerThread
+  public long executeInsert(Set<String> tables, SQLiteStatement statement) {
+    if (logging) log("EXECUTE\n %s", statement);
+
+    long rowId = statement.executeInsert();
+    if (rowId != -1) {
+      // Only send a table trigger if the insert was successful.
+      sendTableTrigger(tables);
+    }
+    return rowId;
   }
 
   /** An in-progress database transaction. */
@@ -510,7 +665,7 @@ public void executeAndTrigger(String table, String sql, Object... args) {
      *
      * @see SQLiteDatabase#endTransaction()
      */
-    // TODO @WorkerThread
+    @WorkerThread
     void end();
 
     /**
@@ -521,7 +676,7 @@ public void executeAndTrigger(String table, String sql, Object... args) {
      *
      * @see SQLiteDatabase#setTransactionSuccessful()
      */
-    // TODO @WorkerThread
+    @WorkerThread
     void markSuccessful();
 
     /**
@@ -535,7 +690,7 @@ public void executeAndTrigger(String table, String sql, Object... args) {
      *
      * @see SQLiteDatabase#yieldIfContendedSafely()
      */
-    // TODO @WorkerThread
+    @WorkerThread
     boolean yieldIfContendedSafely();
 
     /**
@@ -552,13 +707,13 @@ public void executeAndTrigger(String table, String sql, Object... args) {
      *
      * @see SQLiteDatabase#yieldIfContendedSafely(long)
      */
-    // TODO @WorkerThread
+    @WorkerThread
     boolean yieldIfContendedSafely(long sleepAmount, TimeUnit sleepUnit);
 
     /**
      * Equivalent to calling {@link #end()}
      */
-    // TODO @WorkerThread
+    @WorkerThread
     @Override void close();
   }
 
@@ -574,6 +729,10 @@ public void executeAndTrigger(String table, String sql, Object... args) {
   public @interface ConflictAlgorithm {
   }
 
+  static String indentSql(String sql) {
+    return sql.replace("\n", "\n       ");
+  }
+
   void log(String message, Object... args) {
     if (args.length > 0) message = String.format(message, args);
     logger.log(message);
@@ -622,4 +781,41 @@ private static String conflictString(@ConflictAlgorithm int conflictAlgorithm) {
       return parent == null ? name : name + " [" + parent.toString() + ']';
     }
   }
+
+  final class DatabaseQuery extends Query implements Func1<Set<String>, Query> {
+    private final Func1<Set<String>, Boolean> tableFilter;
+    private final String sql;
+    private final String[] args;
+
+    DatabaseQuery(Func1<Set<String>, Boolean> tableFilter, String sql, String... args) {
+      this.tableFilter = tableFilter;
+      this.sql = sql;
+      this.args = args;
+    }
+
+    @Override public Cursor run() {
+      if (transactions.get() != null) {
+        throw new IllegalStateException("Cannot execute observable query in a transaction.");
+      }
+
+      long startNanos = nanoTime();
+      Cursor cursor = getReadableDatabase().rawQuery(sql, args);
+
+      if (logging) {
+        long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
+        log("QUERY (%sms)\n  tables: %s\n  sql: %s\n  args: %s", tookMillis, tableFilter,
+            indentSql(sql), Arrays.toString(args));
+      }
+
+      return cursor;
+    }
+
+    @Override public String toString() {
+      return sql;
+    }
+
+    @Override public Query call(Set<String> ignored) {
+      return this;
+    }
+  }
 }
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java
index cca3b21..d5b197a 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java
@@ -6,17 +6,12 @@
 import com.squareup.sqlbrite.SqlBrite.Query;
 import java.util.List;
 import rx.Observable;
-import rx.Subscriber;
 import rx.functions.Func1;
 
 /** An {@link Observable} of {@link Query} which offers query-specific convenience operators. */
 public final class QueryObservable extends Observable<Query> {
-  QueryObservable(final Observable<Query> o) {
-    super(new OnSubscribe<Query>() {
-      @Override public void call(Subscriber<? super Query> subscriber) {
-        o.unsafeSubscribe(subscriber);
-      }
-    });
+  public QueryObservable(OnSubscribe<Query> func) {
+    super(func);
   }
 
   /**
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
index 802ac69..dce4ab5 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
@@ -22,14 +22,13 @@
       @Override public void onNext(SqlBrite.Query query) {
         try {
           Cursor cursor = query.run();
+          if (cursor == null || subscriber.isUnsubscribed()) {
+            return;
+          }
           List<T> items = new ArrayList<>(cursor.getCount());
           try {
-            for (int i = 1; cursor.moveToNext() && !subscriber.isUnsubscribed(); i++) {
-              T item = mapper.call(cursor);
-              if (item == null) {
-                throw new NullPointerException("Mapper returned null for row " + i);
-              }
-              items.add(item);
+            while (cursor.moveToNext()) {
+              items.add(mapper.call(cursor));
             }
           } finally {
             cursor.close();
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
index fcc90e1..55c86bc 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
@@ -22,26 +22,29 @@
     return new Subscriber<SqlBrite.Query>(subscriber) {
       @Override public void onNext(SqlBrite.Query query) {
         try {
+          boolean emit = false;
           T item = null;
           Cursor cursor = query.run();
-          try {
-            if (cursor.moveToNext()) {
-              item = mapper.call(cursor);
-              if (item == null) {
-                throw new NullPointerException("Mapper returned null for row 1");
-              }
+          if (cursor != null) {
+            try {
               if (cursor.moveToNext()) {
-                throw new IllegalStateException("Cursor returned more than 1 row");
+                item = mapper.call(cursor);
+                emit = true;
+                if (cursor.moveToNext()) {
+                  throw new IllegalStateException("Cursor returned more than 1 row");
+                }
               }
+            } finally {
+              cursor.close();
             }
-          } finally {
-            cursor.close();
           }
           if (!subscriber.isUnsubscribed()) {
-            if (item != null) {
+            if (emit) {
               subscriber.onNext(item);
             } else if (emitDefault) {
               subscriber.onNext(defaultValue);
+            } else {
+              request(1L); // Account upstream for the lack of downstream emission.
             }
           }
         } catch (Throwable e) {
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
index c616327..c7d3b7e 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
@@ -20,10 +20,14 @@
 import android.database.sqlite.SQLiteOpenHelper;
 import android.support.annotation.CheckResult;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.WorkerThread;
 import android.util.Log;
 import java.util.List;
 import rx.Observable;
 import rx.Observable.Operator;
+import rx.Observable.Transformer;
+import rx.Scheduler;
 import rx.Subscriber;
 import rx.functions.Func1;
 
@@ -32,24 +36,60 @@
  * the result of a query.
  */
 public final class SqlBrite {
-  @CheckResult @NonNull
+  static final Logger DEFAULT_LOGGER = new Logger() {
+    @Override public void log(String message) {
+      Log.d("SqlBrite", message);
+    }
+  };
+  static final Transformer<Query, Query> DEFAULT_TRANSFORMER = new Transformer<Query, Query>() {
+    @Override public Observable<Query> call(Observable<Query> queryObservable) {
+      return queryObservable;
+    }
+  };
+
+  public static final class Builder {
+    private Logger logger = DEFAULT_LOGGER;
+    private Transformer<Query, Query> queryTransformer = DEFAULT_TRANSFORMER;
+
+    @CheckResult
+    public Builder logger(@NonNull Logger logger) {
+      if (logger == null) throw new NullPointerException("logger == null");
+      this.logger = logger;
+      return this;
+    }
+
+    @CheckResult
+    public Builder queryTransformer(@NonNull Transformer<Query, Query> queryTransformer) {
+      if (queryTransformer == null) throw new NullPointerException("queryTransformer == null");
+      this.queryTransformer = queryTransformer;
+      return this;
+    }
+
+    @CheckResult
+    public SqlBrite build() {
+      return new SqlBrite(logger, queryTransformer);
+    }
+  }
+
+  /** @deprecated Use {@link Builder} to create instances. */
+  @Deprecated @CheckResult @NonNull
   public static SqlBrite create() {
-    return create(new Logger() {
-      @Override public void log(String message) {
-        Log.d("SqlBrite", message);
-      }
-    });
+    return new SqlBrite(DEFAULT_LOGGER, DEFAULT_TRANSFORMER);
   }
 
-  @CheckResult @NonNull
+  /** @deprecated Use {@link Builder} to create instances. */
+  @Deprecated @CheckResult @NonNull
   public static SqlBrite create(@NonNull Logger logger) {
-    return new SqlBrite(logger);
+    if (logger == null) throw new NullPointerException("logger == null");
+    return new SqlBrite(logger, DEFAULT_TRANSFORMER);
   }
 
   private final Logger logger;
+  private final Transformer<Query, Query> queryTransformer;
 
-  private SqlBrite(@NonNull Logger logger) {
+  SqlBrite(@NonNull Logger logger, @NonNull Transformer<Query, Query> queryTransformer) {
     this.logger = logger;
+    this.queryTransformer = queryTransformer;
   }
 
   /**
@@ -59,16 +99,24 @@ private SqlBrite(@NonNull Logger logger) {
    * interacting with the underlying {@link SQLiteOpenHelper} and it is required for automatic
    * notifications of table changes to work. See {@linkplain BriteDatabase#createQuery the
    * <code>query</code> method} for more information on that behavior.
+   *
+   * @param scheduler The {@link Scheduler} on which items from {@link BriteDatabase#createQuery}
+   * will be emitted.
    */
-  @CheckResult @NonNull
-  public BriteDatabase wrapDatabaseHelper(@NonNull SQLiteOpenHelper helper) {
-    return new BriteDatabase(helper, logger);
+  @CheckResult @NonNull public BriteDatabase wrapDatabaseHelper(@NonNull SQLiteOpenHelper helper,
+      @NonNull Scheduler scheduler) {
+    return new BriteDatabase(helper, logger, scheduler, queryTransformer);
   }
 
-  /** Wrap a {@link ContentResolver} for observable queries. */
-  @CheckResult @NonNull
-  public BriteContentResolver wrapContentProvider(@NonNull ContentResolver contentResolver) {
-    return new BriteContentResolver(contentResolver, logger);
+  /**
+   * Wrap a {@link ContentResolver} for observable queries.
+   *
+   * @param scheduler The {@link Scheduler} on which items from
+   * {@link BriteContentResolver#createQuery} will be emitted.
+   */
+  @CheckResult @NonNull public BriteContentResolver wrapContentProvider(
+      @NonNull ContentResolver contentResolver, @NonNull Scheduler scheduler) {
+    return new BriteContentResolver(contentResolver, logger, scheduler, queryTransformer);
   }
 
   /** An executable query. */
@@ -80,6 +128,8 @@ public BriteContentResolver wrapContentProvider(@NonNull ContentResolver content
      * It is an error for a query to pass through this operator with more than 1 row in its result
      * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
      * do not emit an item.
+     * <p>
+     * This operator ignores {@code null} cursors returned from {@link #run()}.
      *
      * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
      */
@@ -95,6 +145,8 @@ public BriteContentResolver wrapContentProvider(@NonNull ContentResolver content
      * It is an error for a query to pass through this operator with more than 1 row in its result
      * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
      * emit {@code defaultValue}.
+     * <p>
+     * This operator emits {@code defaultValue} if {@code null} is returned from {@link #run()}.
      *
      * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
      * @param defaultValue Value returned if result set is empty
@@ -112,6 +164,8 @@ public BriteContentResolver wrapContentProvider(@NonNull ContentResolver content
      * Be careful using this operator as it will always consume the entire cursor and create objects
      * for each row, every time this observable emits a new query. On tables whose queries update
      * frequently or very large result sets this can result in the creation of many objects.
+     * <p>
+     * This operator ignores {@code null} cursors returned from {@link #run()}.
      *
      * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
      */
@@ -120,9 +174,17 @@ public BriteContentResolver wrapContentProvider(@NonNull ContentResolver content
       return new QueryToListOperator<>(mapper);
     }
 
-    /** Execute the query on the underlying database and return the resulting cursor. */
-    @CheckResult // TODO @WorkerThread
-    // TODO Implementations might return null, which is gross. Throw?
+    /**
+     * Execute the query on the underlying database and return the resulting cursor.
+     *
+     * @return A {@link Cursor} with query results, or {@code null} when the query could not be
+     * executed due to a problem with the underlying store. Unfortunately it is not well documented
+     * when {@code null} is returned. It usually involves a problem in communicating with the
+     * underlying store and should either be treated as failure or ignored for retry at a later
+     * time.
+     */
+    @CheckResult @WorkerThread
+    @Nullable
     public abstract Cursor run();
 
     /**
@@ -144,18 +206,22 @@ public BriteContentResolver wrapContentProvider(@NonNull ContentResolver content
      * <p>
      * Note: Limiting results or filtering will almost always be faster in the database as part of
      * a query and should be preferred, where possible.
+     * <p>
+     * The resulting observable will be empty if {@code null} is returned from {@link #run()}.
      */
     @CheckResult @NonNull
     public final <T> Observable<T> asRows(final Func1<Cursor, T> mapper) {
       return Observable.create(new Observable.OnSubscribe<T>() {
         @Override public void call(Subscriber<? super T> subscriber) {
           Cursor cursor = run();
-          try {
-            while (cursor.moveToNext() && !subscriber.isUnsubscribed()) {
-              subscriber.onNext(mapper.call(cursor));
+          if (cursor != null) {
+            try {
+              while (cursor.moveToNext() && !subscriber.isUnsubscribed()) {
+                subscriber.onNext(mapper.call(cursor));
+              }
+            } finally {
+              cursor.close();
             }
-          } finally {
-            cursor.close();
           }
           if (!subscriber.isUnsubscribed()) {
             subscriber.onCompleted();
