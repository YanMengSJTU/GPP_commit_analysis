diff --git a/.travis.yml b/.travis.yml
index dd268b1..6110668 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -2,9 +2,11 @@ language: android
 
 android:
   components:
-    - build-tools-23.0.0
+    - tools
+    - platform-tools
+    - build-tools-24.0.0
     - extra-android-m2repository
-    - android-23
+    - android-24
     - sys-img-armeabi-v7a-android-23
 
 jdk:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 465866d..8fe2366 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,16 @@
 Change Log
 =========
 
+Version 0.7.0 *(2016-07-06)*
+----------------------------
+
+ * New: Allow `mapTo*` mappers to return `null` values. This is useful when querying on a single,
+   nullable column for which `null` is a valid value.
+ * Fix: When `mapToOne` does not emit a value downstream, request another value from upstream to
+   ensure fixed-item requests (such as `take(1)`) as properly honored.
+ * Fix: Add logging to synchronous `execute` methods.
+
+
 Version 0.6.3 *(2016-04-13)*
 ----------------------------
 
diff --git a/README.md b/README.md
index b317c0c..eeddef3 100755
--- a/README.md
+++ b/README.md
@@ -154,7 +154,7 @@ Download
 --------
 
 ```groovy
-compile 'com.squareup.sqlbrite:sqlbrite:0.6.3'
+compile 'com.squareup.sqlbrite:sqlbrite:0.7.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/build.gradle b/build.gradle
index 68a9f50..a64e0a1 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,8 +1,5 @@
 allprojects {
   buildscript {
-    dependencies {
-      classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3' // Add this line
-    }
     repositories {
       mavenCentral()
     }
@@ -14,18 +11,18 @@ allprojects {
 }
 
 ext {
-  androidPlugin = 'com.android.tools.build:gradle:1.3.0'
-  compileSdkVersion = 23
-  buildToolsVersion = '23.0.2'
+  androidPlugin = 'com.android.tools.build:gradle:2.1.0'
+  compileSdkVersion = 24
+  buildToolsVersion = '24.0.0'
 
   // Android dependencies.
-  supportV4 = 'com.android.support:support-v4:23.0.0'
-  supportAnnotations = 'com.android.support:support-annotations:23.0.0'
-  supportTestRunner = 'com.android.support.test:runner:0.3'
+  supportV4 = 'com.android.support:support-v4:24.0.0'
+  supportAnnotations = 'com.android.support:support-annotations:24.0.0'
+  supportTestRunner = 'com.android.support.test:runner:0.5'
 
-  // Square dependencies.
-  dagger = 'com.squareup.dagger:dagger:1.2.2'
-  daggerCompiler = 'com.squareup.dagger:dagger-compiler:1.2.2'
+  // Dagger dependencies.
+  dagger = 'com.google.dagger:dagger:2.4'
+  daggerCompiler = 'com.google.dagger:dagger-compiler:2.4'
 
   // Third-party dependencies.
   butterKnife = 'com.jakewharton:butterknife:6.1.0'
diff --git a/gradle.properties b/gradle.properties
index 2c0e7a7..f278d17 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,5 +1,5 @@
 GROUP=com.squareup.sqlbrite
-VERSION_NAME=0.6.4-SNAPSHOT
+VERSION_NAME=0.7.1-SNAPSHOT
 
 POM_DESCRIPTION=A lightweight wrapper around SQLiteOpenHelper which introduces reactive stream semantics to SQL operations.
 
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index aee0967..24c9a80 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.6-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.14-all.zip
diff --git a/sample/build.gradle b/sample/build.gradle
index 9b319b6..b4ebcc5 100644
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -14,7 +14,7 @@ dependencies {
   compile rootProject.ext.supportV4
   compile rootProject.ext.supportAnnotations
 
-  // Square dependencies.
+  // Dagger dependencies.
   compile rootProject.ext.dagger
   apt rootProject.ext.daggerCompiler
 
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/TodoApp.java b/sample/src/main/java/com/example/sqlbrite/todo/TodoApp.java
index d99b5a4..70cff42 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/TodoApp.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/TodoApp.java
@@ -17,11 +17,10 @@
 
 import android.app.Application;
 import android.content.Context;
-import dagger.ObjectGraph;
 import timber.log.Timber;
 
 public final class TodoApp extends Application {
-  private ObjectGraph objectGraph;
+  private TodoComponent mainComponent;
 
   @Override public void onCreate() {
     super.onCreate();
@@ -30,10 +29,10 @@
       Timber.plant(new Timber.DebugTree());
     }
 
-    objectGraph = ObjectGraph.create(new TodoModule(this));
+    mainComponent = DaggerTodoComponent.builder().todoModule(new TodoModule(this)).build();
   }
 
-  public static ObjectGraph objectGraph(Context context) {
-    return ((TodoApp) context.getApplicationContext()).objectGraph;
+  public static TodoComponent getComponent(Context context) {
+    return ((TodoApp) context.getApplicationContext()).mainComponent;
   }
 }
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/UiModule.java b/sample/src/main/java/com/example/sqlbrite/todo/TodoComponent.java
similarity index 52%
rename from sample/src/main/java/com/example/sqlbrite/todo/ui/UiModule.java
rename to sample/src/main/java/com/example/sqlbrite/todo/TodoComponent.java
index 1e3c8a5..f53ca23 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/UiModule.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/TodoComponent.java
@@ -13,19 +13,24 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.example.sqlbrite.todo.ui;
+package com.example.sqlbrite.todo;
 
-import dagger.Module;
+import com.example.sqlbrite.todo.ui.ItemsFragment;
+import com.example.sqlbrite.todo.ui.ListsFragment;
+import com.example.sqlbrite.todo.ui.NewItemFragment;
+import com.example.sqlbrite.todo.ui.NewListFragment;
+import dagger.Component;
+import javax.inject.Singleton;
 
-@Module(
-    injects = {
-        ItemsFragment.class,
-        ListsFragment.class,
-        NewItemFragment.class,
-        NewListFragment.class
-    },
-    complete = false,
-    library = true
-)
-public final class UiModule {
+@Singleton
+@Component(modules = TodoModule.class)
+public interface TodoComponent {
+
+  void inject(ListsFragment fragment);
+
+  void inject(ItemsFragment fragment);
+
+  void inject(NewItemFragment fragment);
+
+  void inject(NewListFragment fragment);
 }
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/TodoModule.java b/sample/src/main/java/com/example/sqlbrite/todo/TodoModule.java
index eea28ab..ce901bb 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/TodoModule.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/TodoModule.java
@@ -17,7 +17,6 @@
 
 import android.app.Application;
 import com.example.sqlbrite.todo.db.DbModule;
-import com.example.sqlbrite.todo.ui.UiModule;
 import dagger.Module;
 import dagger.Provides;
 import javax.inject.Singleton;
@@ -25,7 +24,6 @@
 @Module(
     includes = {
         DbModule.class,
-        UiModule.class
     }
 )
 public final class TodoModule {
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java b/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
index b5ea4fa..2147fdd 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
@@ -25,7 +25,7 @@
 import rx.schedulers.Schedulers;
 import timber.log.Timber;
 
-@Module(complete = false, library = true)
+@Module
 public final class DbModule {
   @Provides @Singleton SQLiteOpenHelper provideOpenHelper(Application application) {
     return new DbOpenHelper(application);
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
index c6c350a..1526347 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
@@ -104,7 +104,7 @@ private long getListId() {
     }
 
     super.onAttach(activity);
-    TodoApp.objectGraph(activity).inject(this);
+    TodoApp.getComponent(activity).inject(this);
     setHasOptionsMenu(true);
 
     listener = (Listener) activity;
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
index ef1bb2d..750495d 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
@@ -65,7 +65,7 @@ static ListsFragment newInstance() {
     }
 
     super.onAttach(activity);
-    TodoApp.objectGraph(activity).inject(this);
+    TodoApp.getComponent(activity).inject(this);
     setHasOptionsMenu(true);
 
     listener = (Listener) activity;
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
index 6102a8f..ea05e7b 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
@@ -62,7 +62,7 @@ private long getListId() {
 
   @Override public void onAttach(Activity activity) {
     super.onAttach(activity);
-    TodoApp.objectGraph(activity).inject(this);
+    TodoApp.getComponent(activity).inject(this);
   }
 
   @NonNull @Override public Dialog onCreateDialog(Bundle savedInstanceState) {
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
index 2a14c60..b01e06b 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
@@ -51,7 +51,7 @@ public static NewListFragment newInstance() {
 
   @Override public void onAttach(Activity activity) {
     super.onAttach(activity);
-    TodoApp.objectGraph(activity).inject(this);
+    TodoApp.getComponent(activity).inject(this);
   }
 
   @NonNull @Override public Dialog onCreateDialog(Bundle savedInstanceState) {
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java
index 6553170..9aaa91d 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java
@@ -20,10 +20,12 @@
 import android.support.test.InstrumentationRegistry;
 import com.squareup.sqlbrite.SqlBrite.Query;
 import com.squareup.sqlbrite.TestDb.Employee;
+import java.util.ArrayList;
 import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import rx.Observable;
+import rx.functions.Action1;
 import rx.functions.Func1;
 import rx.observables.BlockingObservable;
 import rx.observers.TestSubscriber;
@@ -32,6 +34,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static com.squareup.sqlbrite.TestDb.SELECT_EMPLOYEES;
 import static com.squareup.sqlbrite.TestDb.TABLE_EMPLOYEE;
+import static org.junit.Assert.fail;
 
 public final class QueryTest {
   private BriteDatabase db;
@@ -50,32 +53,34 @@
     assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
   }
 
-  @Test public void mapToOneThrowsOnMapperNull() {
-    BlockingObservable<Employee> employees =
-        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES) //
-            .lift(Query.mapToOne(new Func1<Cursor, Employee>() {
-              @Override public Employee call(Cursor cursor) {
-                return null;
-              }
-            })) //
-            .toBlocking();
-    try {
-      employees.first();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("Mapper returned null for row 1");
-      assertThat(e.getCause()).hasMessage(
-          "OnError while emitting onNext value: SELECT username, name FROM employee");
-    }
+  @Test public void mapToOneAllowsMapperNull() {
+    Func1<Cursor, Employee> mapToNull = new Func1<Cursor, Employee>() {
+      @Override public Employee call(Cursor cursor) {
+        return null;
+      }
+    };
+    Employee employee = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1") //
+        .lift(Query.mapToOne(mapToNull)) //
+        .toBlocking() //
+        .first();
+    assertThat(employee).isNull();
   }
 
-  @Test public void mapToOneNoOpOnNoRows() {
+  @Test public void mapToOneNoOpAndReRequestOnNoRows() {
+    final List<Long> requests = new ArrayList<>();
     List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE 1=2")
         .take(1)
+        .doOnRequest(new Action1<Long>() {
+          @Override public void call(Long n) {
+            requests.add(n);
+          }
+        })
         .lift(Query.mapToOne(Employee.MAPPER))
         .toList()
         .toBlocking()
         .first();
     assertThat(employees).isEmpty();
+    assertThat(requests).containsExactly(Long.MAX_VALUE, 1L);
   }
 
   @Test public void mapToOneThrowsOnMultipleRows() {
@@ -85,6 +90,7 @@
             .toBlocking();
     try {
       employees.first();
+      fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Cursor returned more than 1 row");
       assertThat(e.getCause()).hasMessage(
@@ -116,13 +122,22 @@
     assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
   }
 
-  @Test public void mapToOneOrDefaultReturnsDefaultWhenNoRows() {
+  @Test public void mapToOneOrDefaultReturnsDefaultAndDoesNotReRequestWhenNoRows() {
+    final List<Long> requests = new ArrayList<>();
     Employee defaultEmployee = new Employee("bob", "Bob Bobberson");
-    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE 1=2")
+    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE 1=2")
+        .take(1)
+        .doOnRequest(new Action1<Long>() {
+          @Override public void call(Long n) {
+            requests.add(n);
+          }
+        })
         .lift(Query.mapToOneOrDefault(Employee.MAPPER, defaultEmployee))
+        .toList()
         .toBlocking()
         .first();
-    assertThat(employees).isSameAs(defaultEmployee);
+    assertThat(employees).containsExactly(defaultEmployee);
+    assertThat(requests).containsExactly(Long.MAX_VALUE);
   }
 
   @Test public void mapToOneOrDefaultAllowsNullDefault() {
@@ -133,22 +148,17 @@
     assertThat(employees).isNull();
   }
 
-  @Test public void mapToOneOrDefaultThrowsOnMapperNull() {
-    BlockingObservable<Employee> employees =
-        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES) //
-            .lift(Query.mapToOneOrDefault(new Func1<Cursor, Employee>() {
-              @Override public Employee call(Cursor cursor) {
-                return null;
-              }
-            }, null)) //
-            .toBlocking();
-    try {
-      employees.first();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("Mapper returned null for row 1");
-      assertThat(e.getCause()).hasMessage(
-          "OnError while emitting onNext value: SELECT username, name FROM employee");
-    }
+  @Test public void mapToOneOrDefaultAllowsMapperNull() {
+    Func1<Cursor, Employee> mapToNull = new Func1<Cursor, Employee>() {
+      @Override public Employee call(Cursor cursor) {
+        return null;
+      }
+    };
+    Employee employee = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1") //
+        .lift(Query.mapToOneOrDefault(mapToNull, new Employee("bob", "Bob Bobberson"))) //
+        .toBlocking() //
+        .first();
+    assertThat(employee).isNull();
   }
 
   @Test public void mapToOneOrDefaultThrowsOnMultipleRows() {
@@ -158,6 +168,7 @@
             .toBlocking();
     try {
       employees.first();
+      fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Cursor returned more than 1 row");
       assertThat(e.getCause()).hasMessage(
@@ -201,24 +212,23 @@
     assertThat(employees).isEmpty();
   }
 
-  @Test public void mapToListThrowsOnMapperNull() {
-    BlockingObservable<List<Employee>> employees =
-        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES) //
-            .lift(Query.mapToList(new Func1<Cursor, Employee>() {
-              private int count;
+  @Test public void mapToListReturnsNullOnMapperNull() {
+    Func1<Cursor, Employee> mapToNull = new Func1<Cursor, Employee>() {
+      private int count;
 
-              @Override public Employee call(Cursor cursor) {
-                return count++ == 2 ? null : Employee.MAPPER.call(cursor);
-              }
-            })) //
-            .toBlocking();
-    try {
-      employees.first();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("Mapper returned null for row 3");
-      assertThat(e.getCause()).hasMessage(
-          "OnError while emitting onNext value: SELECT username, name FROM employee");
-    }
+      @Override public Employee call(Cursor cursor) {
+        return count++ == 2 ? null : Employee.MAPPER.call(cursor);
+      }
+    };
+    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES) //
+            .lift(Query.mapToList(mapToNull)) //
+            .toBlocking() //
+            .first();
+
+    assertThat(employees).containsExactly(
+        new Employee("alice", "Alice Allison"),
+        new Employee("bob", "Bob Bobberson"),
+        null);
   }
 
   @Test public void mapToListIgnoresNullCursor() {
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
index 304dc8b..e265cab 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
@@ -95,6 +95,13 @@
       end();
     }
   };
+  private final Action0 ensureNotInTransaction = new Action0() {
+    @Override public void call() {
+      if (transactions.get() != null) {
+        throw new IllegalStateException("Cannot subscribe to observable query in a transaction.");
+      }
+    }
+  };
 
   // Read and write guarded by 'databaseLock'. Lazily initialized. Use methods to access.
   private volatile SQLiteDatabase readableDatabase;
@@ -287,55 +294,22 @@ public QueryObservable createQuery(@NonNull final Iterable<String> tables, @NonN
   }
 
   @CheckResult @NonNull
-  private QueryObservable createQuery(final Func1<Set<String>, Boolean> tableFilter,
-      final String sql, final String... args) {
+  private QueryObservable createQuery(Func1<Set<String>, Boolean> tableFilter, String sql,
+      String... args) {
     if (transactions.get() != null) {
       throw new IllegalStateException("Cannot create observable query in transaction. "
           + "Use query() for a query inside a transaction.");
     }
 
-    final Query query = new Query() {
-      @Override public Cursor run() {
-        if (transactions.get() != null) {
-          throw new IllegalStateException("Cannot execute observable query in a transaction.");
-        }
-
-        long startNanos = nanoTime();
-        Cursor cursor = getReadableDatabase().rawQuery(sql, args);
-
-        if (logging) {
-          long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
-          log("QUERY (%sms)\n  tables: %s\n  sql: %s\n  args: %s", tookMillis, tableFilter,
-              indentSql(sql), Arrays.toString(args));
-        }
-
-        return cursor;
-      }
-
-      @Override public String toString() {
-        return sql;
-      }
-    };
-
+    DatabaseQuery query = new DatabaseQuery(tableFilter, sql, args);
     final Observable<Query> queryObservable = triggers //
         .filter(tableFilter) // Only trigger on tables we care about.
-        .map(new Func1<Set<String>, Query>() {
-          @Override public Query call(Set<String> trigger) {
-            return query;
-          }
-        }) //
+        .map(query) // DatabaseQuery maps to itself to save an allocation.
         .onBackpressureLatest() // Guard against uncontrollable frequency of upstream emissions.
         .startWith(query) //
         .observeOn(scheduler) //
         .onBackpressureLatest() // Guard against uncontrollable frequency of scheduler executions.
-        .doOnSubscribe(new Action0() {
-          @Override public void call() {
-            if (transactions.get() != null) {
-              throw new IllegalStateException(
-                  "Cannot subscribe to observable query in a transaction.");
-            }
-          }
-        });
+        .doOnSubscribe(ensureNotInTransaction);
     // TODO switch to .extend when non-@Experimental
     return new QueryObservable(new Observable.OnSubscribe<Query>() {
       @Override public void call(Subscriber<? super Query> subscriber) {
@@ -473,6 +447,8 @@ public int update(@NonNull String table, @NonNull ContentValues values,
    * @see SQLiteDatabase#execSQL(String)
    */
   public void execute(String sql) {
+    if (logging) log("EXECUTE\n  sql: %s", sql);
+
     SQLiteDatabase db = getWriteableDatabase();
     db.execSQL(sql);
   }
@@ -487,6 +463,8 @@ public void execute(String sql) {
    * @see SQLiteDatabase#execSQL(String, Object[])
    */
   public void execute(String sql, Object... args) {
+    if (logging) log("EXECUTE\n  sql: %s\n  args: %s", sql, Arrays.toString(args));
+
     SQLiteDatabase db = getWriteableDatabase();
     db.execSQL(sql, args);
   }
@@ -501,8 +479,7 @@ public void execute(String sql, Object... args) {
    * @see SQLiteDatabase#execSQL(String)
    */
   public void executeAndTrigger(String table, String sql) {
-    SQLiteDatabase db = getWriteableDatabase();
-    db.execSQL(sql);
+    execute(sql);
 
     sendTableTrigger(Collections.singleton(table));
   }
@@ -517,8 +494,7 @@ public void executeAndTrigger(String table, String sql) {
    * @see SQLiteDatabase#execSQL(String, Object[])
    */
   public void executeAndTrigger(String table, String sql, Object... args) {
-    SQLiteDatabase db = getWriteableDatabase();
-    db.execSQL(sql, args);
+    execute(sql, args);
 
     sendTableTrigger(Collections.singleton(table));
   }
@@ -647,4 +623,41 @@ private static String conflictString(@ConflictAlgorithm int conflictAlgorithm) {
       return parent == null ? name : name + " [" + parent.toString() + ']';
     }
   }
+
+  final class DatabaseQuery extends Query implements Func1<Set<String>, Query> {
+    private final Func1<Set<String>, Boolean> tableFilter;
+    private final String sql;
+    private final String[] args;
+
+    DatabaseQuery(Func1<Set<String>, Boolean> tableFilter, String sql, String... args) {
+      this.tableFilter = tableFilter;
+      this.sql = sql;
+      this.args = args;
+    }
+
+    @Override public Cursor run() {
+      if (transactions.get() != null) {
+        throw new IllegalStateException("Cannot execute observable query in a transaction.");
+      }
+
+      long startNanos = nanoTime();
+      Cursor cursor = getReadableDatabase().rawQuery(sql, args);
+
+      if (logging) {
+        long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
+        log("QUERY (%sms)\n  tables: %s\n  sql: %s\n  args: %s", tookMillis, tableFilter,
+            indentSql(sql), Arrays.toString(args));
+      }
+
+      return cursor;
+    }
+
+    @Override public String toString() {
+      return sql;
+    }
+
+    @Override public Query call(Set<String> ignored) {
+      return this;
+    }
+  }
 }
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
index 2c0accf..dce4ab5 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
@@ -22,17 +22,13 @@
       @Override public void onNext(SqlBrite.Query query) {
         try {
           Cursor cursor = query.run();
-          if (cursor == null) {
+          if (cursor == null || subscriber.isUnsubscribed()) {
             return;
           }
           List<T> items = new ArrayList<>(cursor.getCount());
           try {
-            for (int i = 1; cursor.moveToNext() && !subscriber.isUnsubscribed(); i++) {
-              T item = mapper.call(cursor);
-              if (item == null) {
-                throw new NullPointerException("Mapper returned null for row " + i);
-              }
-              items.add(item);
+            while (cursor.moveToNext()) {
+              items.add(mapper.call(cursor));
             }
           } finally {
             cursor.close();
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
index cde2e7e..55c86bc 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
@@ -22,15 +22,14 @@
     return new Subscriber<SqlBrite.Query>(subscriber) {
       @Override public void onNext(SqlBrite.Query query) {
         try {
+          boolean emit = false;
           T item = null;
           Cursor cursor = query.run();
           if (cursor != null) {
             try {
               if (cursor.moveToNext()) {
                 item = mapper.call(cursor);
-                if (item == null) {
-                  throw new NullPointerException("Mapper returned null for row 1");
-                }
+                emit = true;
                 if (cursor.moveToNext()) {
                   throw new IllegalStateException("Cursor returned more than 1 row");
                 }
@@ -40,10 +39,12 @@
             }
           }
           if (!subscriber.isUnsubscribed()) {
-            if (item != null) {
+            if (emit) {
               subscriber.onNext(item);
             } else if (emitDefault) {
               subscriber.onNext(defaultValue);
+            } else {
+              request(1L); // Account upstream for the lack of downstream emission.
             }
           }
         } catch (Throwable e) {
