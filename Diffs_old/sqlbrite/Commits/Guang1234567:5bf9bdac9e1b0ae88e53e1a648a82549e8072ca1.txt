diff --git a/build.gradle b/build.gradle
index 163b37a..e104e6e 100644
--- a/build.gradle
+++ b/build.gradle
@@ -41,6 +41,9 @@ ext {
   // https://www.zetetic.net/sqlcipher/sqlcipher-for-android/
   supportSqlcipher = 'net.zetetic:android-database-sqlcipher:3.5.8@aar'
 
+  // https://github.com/Tencent/wcdb
+  supportWcdb = 'com.tencent.wcdb:wcdb-android:1.0.5'
+
   // Third-party dependencies.
   kotlinStdLib = "org.jetbrains.kotlin:kotlin-stdlib:${versions.kotlin}"
   dagger = 'com.google.dagger:dagger:2.13'
diff --git a/sample/build.gradle b/sample/build.gradle
index 018b313..18e70c2 100644
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -22,6 +22,7 @@ dependencies {
   implementation rootProject.ext.supportSqliteFramework
 
   implementation project(':sqlbrite-sqlcipher-integration')
+  implementation project(':sqlbrite-wcdb-integration')
 }
 
 android {
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java b/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
index 622610d..0fdc0b3 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
@@ -21,55 +21,89 @@
 import android.arch.persistence.db.SupportSQLiteOpenHelper.Factory;
 import android.arch.persistence.db.framework.FrameworkSQLiteOpenHelperFactory;
 import android.arch.persistence.db.sqlcipher.SqlcipherSQLiteOpenHelperFactory;
+import android.arch.persistence.db.wcdb.WcdbSQLiteOpenHelperFactory;
 
 import com.squareup.sqlbrite3.BriteDatabase;
 import com.squareup.sqlbrite3.SqlBrite;
+
 import dagger.Module;
 import dagger.Provides;
 import io.reactivex.schedulers.Schedulers;
+
 import javax.inject.Singleton;
+
 import timber.log.Timber;
 
 @Module
 public final class DbModule {
-  @Provides @Singleton SqlBrite provideSqlBrite() {
-    return new SqlBrite.Builder()
-        .logger(new SqlBrite.Logger() {
-          @Override public void log(String message) {
-            Timber.tag("Database").v(message);
-          }
-        })
-        .build();
-  }
+    @Provides
+    @Singleton
+    SqlBrite provideSqlBrite() {
+        return new SqlBrite.Builder()
+                .logger(new SqlBrite.Logger() {
+                    @Override
+                    public void log(String message) {
+                        Timber.tag("Database").v(message);
+                    }
+                })
+                .build();
+    }
 
-  @Provides @Singleton BriteDatabase provideDatabase(SqlBrite sqlBrite, Application application) {
+    @Provides
+    @Singleton
+    BriteDatabase provideDatabase(SqlBrite sqlBrite, Application application) {
 
-    // 原生
-    /*Configuration configuration = Configuration.builder(application)
-        .name("todo.db")
-        .callback(new DbCallback())
-        .build();
+        // 原生
+        /*Configuration configuration = Configuration.builder(application)
+            .name("todo.db")
+            .callback(new DbCallback())
+            .build();
 
-    Factory factory = new FrameworkSQLiteOpenHelperFactory();
-    SupportSQLiteOpenHelper helper = factory.create(configuration);
+        Factory factory = new FrameworkSQLiteOpenHelperFactory();
+        SupportSQLiteOpenHelper helper = factory.create(configuration);
 
-    BriteDatabase db = sqlBrite.wrapDatabaseHelper(helper, Schedulers.io());
-    db.setLoggingEnabled(true);*/
+        BriteDatabase db = sqlBrite.wrapDatabaseHelper(helper, Schedulers.io());
+        db.setLoggingEnabled(true);*/
 
 
+        // 加密
+        /*Configuration configuration_sqlcipher = Configuration.builder(application)
+                .name("todo_sqlcipher.db")
+                .callback(new DbCallback())
+                .build();
 
-    // 加密
-    Configuration configuration_sqlcipher = Configuration.builder(application)
-            .name("todo_sqlcipher.db")
-            .callback(new DbCallback())
-            .build();
+        SqlcipherSQLiteOpenHelperFactory factory_sqlcipher = new SqlcipherSQLiteOpenHelperFactory();
+        SupportSQLiteOpenHelper helper_sqlcipher = factory_sqlcipher.create(configuration_sqlcipher, "Passsword_1234567");
+
+        BriteDatabase db_sqlcipher = sqlBrite.wrapDatabaseHelper(helper_sqlcipher, Schedulers.io());
+        db_sqlcipher.setLoggingEnabled(true);*/
+
+
+        // wcdb
+        /*Configuration configuration_wcdb = Configuration.builder(application)
+                .name("todo_wcdb.db")
+                .callback(new DbCallback())
+                .build();
+
+        WcdbSQLiteOpenHelperFactory factory_wcdb = new WcdbSQLiteOpenHelperFactory();
+        SupportSQLiteOpenHelper helper_wcdb = factory_wcdb.create(configuration_wcdb);
+
+        BriteDatabase db_wcdb = sqlBrite.wrapDatabaseHelper(helper_wcdb, Schedulers.io());
+        db_wcdb.setLoggingEnabled(true);*/
+
+
+        // wcdb cipher
+        Configuration configuration_wcdb_cipher = Configuration.builder(application)
+                .name("todo_wcdb_cipher.db")
+                .callback(new DbCallback())
+                .build();
 
-    SqlcipherSQLiteOpenHelperFactory factory_sqlcipher = new SqlcipherSQLiteOpenHelperFactory();
-    SupportSQLiteOpenHelper helper_sqlcipher = factory_sqlcipher.create(configuration_sqlcipher, "Passsword_1234567");
+        WcdbSQLiteOpenHelperFactory factory_wcdb_cipher = new WcdbSQLiteOpenHelperFactory();
+        SupportSQLiteOpenHelper helper_wcdb_cipher = factory_wcdb_cipher.create(configuration_wcdb_cipher, "Passsword_7788");
 
-    BriteDatabase db_sqlcipher = sqlBrite.wrapDatabaseHelper(helper_sqlcipher, Schedulers.io());
-    db_sqlcipher.setLoggingEnabled(true);
+        BriteDatabase db_wcdb_cipher = sqlBrite.wrapDatabaseHelper(helper_wcdb_cipher, Schedulers.io());
+        db_wcdb_cipher.setLoggingEnabled(true);
 
-    return db_sqlcipher;
-  }
+        return db_wcdb_cipher;
+    }
 }
diff --git a/settings.gradle b/settings.gradle
index 31a91c7..36edaca 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -4,5 +4,6 @@ include ':sqlbrite-lint'
 include ':sample'
 
 include ':sqlbrite-sqlcipher-integration'
+include ':sqlbrite-wcdb-integration'
 
 rootProject.name = 'sqlbrite-root'
diff --git a/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteDatabase.java b/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteDatabase.java
index fb0970e..430a851 100644
--- a/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteDatabase.java
+++ b/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteDatabase.java
@@ -21,13 +21,13 @@
 import android.arch.persistence.db.SupportSQLiteQuery;
 import android.arch.persistence.db.SupportSQLiteStatement;
 import android.content.ContentValues;
+import android.database.Cursor;
 import android.database.sqlite.SQLiteTransactionListener;
 import android.os.Build;
 import android.os.CancellationSignal;
 import android.support.annotation.RequiresApi;
 import android.util.Pair;
 
-import net.sqlcipher.Cursor;
 import net.sqlcipher.SQLException;
 import net.sqlcipher.database.SQLiteCursor;
 import net.sqlcipher.database.SQLiteCursorDriver;
@@ -197,8 +197,8 @@ public Cursor query(final SupportSQLiteQuery supportQuery) {
 
         return mDelegate.rawQueryWithFactory(new SQLiteDatabase.CursorFactory() {
             @Override
-            public Cursor newCursor(SQLiteDatabase db, SQLiteCursorDriver masterQuery,
-                                    String editTable, SQLiteQuery query) {
+            public net.sqlcipher.Cursor newCursor(SQLiteDatabase db, SQLiteCursorDriver masterQuery,
+                                                  String editTable, SQLiteQuery query) {
                 supportQuery.bindTo(new SqlcipherSQLiteProgram(query));
                 return new SQLiteCursor(db, masterQuery, editTable, query);
             }
diff --git a/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteOpenHelper.java b/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteOpenHelper.java
index 33a87e1..84175d2 100644
--- a/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteOpenHelper.java
+++ b/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteOpenHelper.java
@@ -92,7 +92,7 @@ public void onCorruption(SQLiteDatabase dbObj) {
                     });
 
             if (loadLibs) {
-                net.sqlcipher.database.SQLiteDatabase.loadLibs(context);
+                SQLiteDatabase.loadLibs(context);
                 loadLibs = false; // only load once
             }
 
diff --git a/sqlbrite-wcdb-integration/.gitignore b/sqlbrite-wcdb-integration/.gitignore
new file mode 100644
index 0000000..3543521
--- /dev/null
+++ b/sqlbrite-wcdb-integration/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/sqlbrite-wcdb-integration/build.gradle b/sqlbrite-wcdb-integration/build.gradle
new file mode 100644
index 0000000..5c259f9
--- /dev/null
+++ b/sqlbrite-wcdb-integration/build.gradle
@@ -0,0 +1,36 @@
+apply plugin: 'com.android.library'
+
+dependencies {
+    api rootProject.ext.rxJava
+    api rootProject.ext.supportSqlite
+    api rootProject.ext.supportWcdb
+    implementation rootProject.ext.supportAnnotations
+
+    androidTestImplementation rootProject.ext.supportTestRunner
+    androidTestImplementation rootProject.ext.truth
+    androidTestImplementation rootProject.ext.supportSqliteFramework
+
+    lintChecks project(':sqlbrite-lint')
+}
+
+android {
+    compileSdkVersion versions.compileSdk
+
+    defaultConfig {
+        minSdkVersion versions.minSdk
+
+        testInstrumentationRunner 'android.support.test.runner.AndroidJUnitRunner'
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+
+    lintOptions {
+        textOutput 'stdout'
+        textReport true
+    }
+}
+
+//apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/sqlbrite-wcdb-integration/proguard-rules.pro b/sqlbrite-wcdb-integration/proguard-rules.pro
new file mode 100644
index 0000000..6e7ffa9
--- /dev/null
+++ b/sqlbrite-wcdb-integration/proguard-rules.pro
@@ -0,0 +1,21 @@
+# Add project specific ProGuard rules here.
+# You can control the set of applied configuration files using the
+# proguardFiles setting in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
diff --git a/sqlbrite-wcdb-integration/src/androidTest/java/android/arch/persistence/db/wcdb/ExampleInstrumentedTest.java b/sqlbrite-wcdb-integration/src/androidTest/java/android/arch/persistence/db/wcdb/ExampleInstrumentedTest.java
new file mode 100644
index 0000000..ab614c1
--- /dev/null
+++ b/sqlbrite-wcdb-integration/src/androidTest/java/android/arch/persistence/db/wcdb/ExampleInstrumentedTest.java
@@ -0,0 +1,26 @@
+package android.arch.persistence.db.wcdb;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.junit.Assert.*;
+
+/**
+ * Instrumented test, which will execute on an Android device.
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+@RunWith(AndroidJUnit4.class)
+public class ExampleInstrumentedTest {
+    @Test
+    public void useAppContext() throws Exception {
+        // Context of the app under test.
+        Context appContext = InstrumentationRegistry.getTargetContext();
+
+        assertEquals("android.arch.persistence.db.wcdb.test", appContext.getPackageName());
+    }
+}
diff --git a/sqlbrite-wcdb-integration/src/main/AndroidManifest.xml b/sqlbrite-wcdb-integration/src/main/AndroidManifest.xml
new file mode 100644
index 0000000..a638d54
--- /dev/null
+++ b/sqlbrite-wcdb-integration/src/main/AndroidManifest.xml
@@ -0,0 +1,2 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="android.arch.persistence.db.wcdb"/>
diff --git a/sqlbrite-wcdb-integration/src/main/java/android/arch/persistence/db/wcdb/WcdbSQLiteDatabase.java b/sqlbrite-wcdb-integration/src/main/java/android/arch/persistence/db/wcdb/WcdbSQLiteDatabase.java
new file mode 100644
index 0000000..963c5a7
--- /dev/null
+++ b/sqlbrite-wcdb-integration/src/main/java/android/arch/persistence/db/wcdb/WcdbSQLiteDatabase.java
@@ -0,0 +1,377 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.arch.persistence.db.wcdb;
+
+import android.arch.persistence.db.SimpleSQLiteQuery;
+import android.arch.persistence.db.SupportSQLiteDatabase;
+import android.arch.persistence.db.SupportSQLiteQuery;
+import android.arch.persistence.db.SupportSQLiteStatement;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteTransactionListener;
+import android.os.Build;
+import android.support.annotation.RequiresApi;
+import android.util.Pair;
+
+import com.tencent.wcdb.SQLException;
+import com.tencent.wcdb.database.SQLiteCursor;
+import com.tencent.wcdb.database.SQLiteDatabase;
+
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * Delegates all calls to an implementation of {@link SQLiteDatabase}.
+ */
+@SuppressWarnings("unused")
+class WcdbSQLiteDatabase implements SupportSQLiteDatabase {
+    private static final String[] CONFLICT_VALUES = new String[]
+            {"", " OR ROLLBACK ", " OR ABORT ", " OR FAIL ", " OR IGNORE ", " OR REPLACE "};
+    private static final String[] EMPTY_STRING_ARRAY = new String[0];
+
+    private final SQLiteDatabase mDelegate;
+
+    /**
+     * Creates a wrapper around {@link SQLiteDatabase}.
+     *
+     * @param delegate The delegate to receive all calls.
+     */
+    WcdbSQLiteDatabase(SQLiteDatabase delegate) {
+        mDelegate = delegate;
+    }
+
+    @Override
+    public SupportSQLiteStatement compileStatement(String sql) {
+        return new WcdbSQLiteStatement(mDelegate.compileStatement(sql));
+    }
+
+    @Override
+    public void beginTransaction() {
+        mDelegate.beginTransaction();
+    }
+
+    @Override
+    public void beginTransactionNonExclusive() {
+        mDelegate.beginTransactionNonExclusive();
+    }
+
+    @Override
+    public void beginTransactionWithListener(final SQLiteTransactionListener transactionListener) {
+        mDelegate.beginTransactionWithListener(new com.tencent.wcdb.database.SQLiteTransactionListener() {
+            @Override
+            public void onBegin() {
+                if (null != transactionListener) {
+                    transactionListener.onBegin();
+                }
+            }
+
+            @Override
+            public void onCommit() {
+                if (null != transactionListener) {
+                    transactionListener.onCommit();
+                }
+            }
+
+            @Override
+            public void onRollback() {
+                if (null != transactionListener) {
+                    transactionListener.onRollback();
+                }
+            }
+        });
+    }
+
+    @Override
+    public void beginTransactionWithListenerNonExclusive(
+            final SQLiteTransactionListener transactionListener) {
+        mDelegate.beginTransactionWithListenerNonExclusive(new com.tencent.wcdb.database.SQLiteTransactionListener() {
+            @Override
+            public void onBegin() {
+                if (null != transactionListener) {
+                    transactionListener.onBegin();
+                }
+            }
+
+            @Override
+            public void onCommit() {
+                if (null != transactionListener) {
+                    transactionListener.onCommit();
+                }
+            }
+
+            @Override
+            public void onRollback() {
+                if (null != transactionListener) {
+                    transactionListener.onRollback();
+                }
+            }
+        });
+    }
+
+    @Override
+    public void endTransaction() {
+        mDelegate.endTransaction();
+    }
+
+    @Override
+    public void setTransactionSuccessful() {
+        mDelegate.setTransactionSuccessful();
+    }
+
+    @Override
+    public boolean inTransaction() {
+        return mDelegate.inTransaction();
+    }
+
+    @Override
+    public boolean isDbLockedByCurrentThread() {
+        return mDelegate.isDbLockedByCurrentThread();
+    }
+
+    @Override
+    public boolean yieldIfContendedSafely() {
+        return mDelegate.yieldIfContendedSafely();
+    }
+
+    @Override
+    public boolean yieldIfContendedSafely(long sleepAfterYieldDelay) {
+        return mDelegate.yieldIfContendedSafely(sleepAfterYieldDelay);
+    }
+
+    @Override
+    public int getVersion() {
+        return mDelegate.getVersion();
+    }
+
+    @Override
+    public void setVersion(int version) {
+        mDelegate.setVersion(version);
+    }
+
+    @Override
+    public long getMaximumSize() {
+        return mDelegate.getMaximumSize();
+    }
+
+    @Override
+    public long setMaximumSize(long numBytes) {
+        return mDelegate.setMaximumSize(numBytes);
+    }
+
+    @Override
+    public long getPageSize() {
+        return mDelegate.getPageSize();
+    }
+
+    @Override
+    public void setPageSize(long numBytes) {
+        mDelegate.setPageSize(numBytes);
+    }
+
+    @Override
+    public Cursor query(String query) {
+        return query(new SimpleSQLiteQuery(query));
+    }
+
+    @Override
+    public Cursor query(String query, Object[] bindArgs) {
+        return query(new SimpleSQLiteQuery(query, bindArgs));
+    }
+
+
+    @Override
+    public Cursor query(final SupportSQLiteQuery supportQuery) {
+        String[] selectionArgs = EMPTY_STRING_ARRAY;
+        try {
+            Field f = supportQuery.getClass().getDeclaredField("mBindArgs");
+            f.setAccessible(true);
+            Object[] tmp = (Object[]) f.get(supportQuery);
+            int length = tmp.length;
+            if (tmp != null && length > 0) {
+                selectionArgs = new String[length];
+                System.arraycopy(tmp, 0, selectionArgs, 0, length);
+            }
+        } catch (Throwable e) {
+            e.printStackTrace();
+        }
+
+        return mDelegate.rawQueryWithFactory(SQLiteCursor.FACTORY, supportQuery.getSql(), selectionArgs, null);
+    }
+
+    @Override
+    public Cursor query(final android.arch.persistence.db.SupportSQLiteQuery supportQuery, android.os.CancellationSignal cancellationSignal) {
+        /*return mDelegate.rawQueryWithFactory(new SQLiteDatabase.CursorFactory() {
+            @Override
+            public com.tencent.wcdb.Cursor newCursor(SQLiteDatabase db, SQLiteCursorDriver masterQuery, String editTable, SQLiteProgram program) {
+                supportQuery.bindTo(new WcdbSQLiteProgram(program));
+
+                SQLiteQuery query = null;
+                if (program instanceof SQLiteQuery) {
+                    query = (SQLiteQuery) program;
+                }
+
+                return new SQLiteCursor(masterQuery, editTable, query);
+            }
+
+            @Override
+            public SQLiteProgram newQuery(SQLiteDatabase db, String query, Object[] bindArgs, CancellationSignal cancellationSignalForPrepare) {
+                return new SQLiteProgram(db, query, bindArgs, cancellationSignalForPrepare) {};
+            }
+        }, supportQuery.getSql(), EMPTY_STRING_ARRAY, null, cancellationSignal);*/
+
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public long insert(String table, int conflictAlgorithm, ContentValues values)
+            throws SQLException {
+        return mDelegate.insertWithOnConflict(table, null, values,
+                conflictAlgorithm);
+    }
+
+    @Override
+    public int delete(String table, String whereClause, Object[] whereArgs) {
+        String query = "DELETE FROM " + table
+                + (isEmpty(whereClause) ? "" : " WHERE " + whereClause);
+        SupportSQLiteStatement statement = compileStatement(query);
+        SimpleSQLiteQuery.bind(statement, whereArgs);
+        return statement.executeUpdateDelete();
+    }
+
+
+    @Override
+    public int update(String table, int conflictAlgorithm, ContentValues values, String whereClause,
+                      Object[] whereArgs) {
+        // taken from SQLiteDatabase class.
+        if (values == null || values.size() == 0) {
+            throw new IllegalArgumentException("Empty values");
+        }
+        StringBuilder sql = new StringBuilder(120);
+        sql.append("UPDATE ");
+        sql.append(CONFLICT_VALUES[conflictAlgorithm]);
+        sql.append(table);
+        sql.append(" SET ");
+
+        // move all bind args to one array
+        int setValuesSize = values.size();
+        int bindArgsSize = (whereArgs == null) ? setValuesSize : (setValuesSize + whereArgs.length);
+        Object[] bindArgs = new Object[bindArgsSize];
+        int i = 0;
+        for (String colName : values.keySet()) {
+            sql.append((i > 0) ? "," : "");
+            sql.append(colName);
+            bindArgs[i++] = values.get(colName);
+            sql.append("=?");
+        }
+        if (whereArgs != null) {
+            for (i = setValuesSize; i < bindArgsSize; i++) {
+                bindArgs[i] = whereArgs[i - setValuesSize];
+            }
+        }
+        if (!isEmpty(whereClause)) {
+            sql.append(" WHERE ");
+            sql.append(whereClause);
+        }
+        SupportSQLiteStatement stmt = compileStatement(sql.toString());
+        SimpleSQLiteQuery.bind(stmt, bindArgs);
+        return stmt.executeUpdateDelete();
+    }
+
+    @Override
+    public void execSQL(String sql) throws SQLException {
+        mDelegate.execSQL(sql);
+    }
+
+    @Override
+    public void execSQL(String sql, Object[] bindArgs) throws SQLException {
+        mDelegate.execSQL(sql, bindArgs);
+    }
+
+    @Override
+    public boolean isReadOnly() {
+        return mDelegate.isReadOnly();
+    }
+
+    @Override
+    public boolean isOpen() {
+        return mDelegate.isOpen();
+    }
+
+    @Override
+    public boolean needUpgrade(int newVersion) {
+        return mDelegate.needUpgrade(newVersion);
+    }
+
+    @Override
+    public String getPath() {
+        return mDelegate.getPath();
+    }
+
+    @Override
+    public void setLocale(Locale locale) {
+        mDelegate.setLocale(locale);
+    }
+
+    @Override
+    public void setMaxSqlCacheSize(int cacheSize) {
+        mDelegate.setMaxSqlCacheSize(cacheSize);
+    }
+
+    @Override
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN)
+    public void setForeignKeyConstraintsEnabled(boolean enable) {
+        mDelegate.setForeignKeyConstraintsEnabled(enable);
+    }
+
+    @Override
+    public boolean enableWriteAheadLogging() {
+        return mDelegate.enableWriteAheadLogging();
+    }
+
+    @Override
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN)
+    public void disableWriteAheadLogging() {
+        mDelegate.disableWriteAheadLogging();
+    }
+
+    @Override
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN)
+    public boolean isWriteAheadLoggingEnabled() {
+        return mDelegate.isWriteAheadLoggingEnabled();
+    }
+
+    @Override
+    public List<Pair<String, String>> getAttachedDbs() {
+        return mDelegate.getAttachedDbs();
+    }
+
+    @Override
+    public boolean isDatabaseIntegrityOk() {
+        return mDelegate.isDatabaseIntegrityOk();
+    }
+
+    @Override
+    public void close() throws IOException {
+        mDelegate.close();
+    }
+
+    private static boolean isEmpty(String input) {
+        return input == null || input.length() == 0;
+    }
+}
diff --git a/sqlbrite-wcdb-integration/src/main/java/android/arch/persistence/db/wcdb/WcdbSQLiteOpenHelper.java b/sqlbrite-wcdb-integration/src/main/java/android/arch/persistence/db/wcdb/WcdbSQLiteOpenHelper.java
new file mode 100644
index 0000000..53a7e01
--- /dev/null
+++ b/sqlbrite-wcdb-integration/src/main/java/android/arch/persistence/db/wcdb/WcdbSQLiteOpenHelper.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.arch.persistence.db.wcdb;
+
+import android.arch.persistence.db.SupportSQLiteDatabase;
+import android.arch.persistence.db.SupportSQLiteOpenHelper;
+import android.content.Context;
+import com.tencent.wcdb.DatabaseErrorHandler;
+import com.tencent.wcdb.database.SQLiteCipherSpec;
+import com.tencent.wcdb.database.SQLiteDatabase;
+import com.tencent.wcdb.database.SQLiteOpenHelper;
+import android.os.Build;
+import android.support.annotation.RequiresApi;
+
+class WcdbSQLiteOpenHelper implements SupportSQLiteOpenHelper {
+    private final OpenHelper mDelegate;
+
+    WcdbSQLiteOpenHelper(Context context, String name,
+            Callback callback) {
+        mDelegate = createDelegate(context, name, callback);
+    }
+
+    WcdbSQLiteOpenHelper(Context context, String name,
+                         Callback callback, String password, SQLiteCipherSpec cipher) {
+        mDelegate = createDelegate(context, name, callback, password, cipher);
+    }
+
+    private OpenHelper createDelegate(Context context, String name, Callback callback) {
+        final WcdbSQLiteDatabase[] dbRef = new WcdbSQLiteDatabase[1];
+        return new OpenHelper(context, name, dbRef, callback);
+    }
+
+    private OpenHelper createDelegate(Context context, String name, Callback callback, String password, SQLiteCipherSpec cipher) {
+        final WcdbSQLiteDatabase[] dbRef = new WcdbSQLiteDatabase[1];
+        return new OpenHelper(context, name, dbRef, callback, password, cipher);
+    }
+
+    @Override
+    public String getDatabaseName() {
+        return mDelegate.getDatabaseName();
+    }
+
+    @Override
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN)
+    public void setWriteAheadLoggingEnabled(boolean enabled) {
+        mDelegate.setWriteAheadLoggingEnabled(enabled);
+    }
+
+    @Override
+    public SupportSQLiteDatabase getWritableDatabase() {
+        return mDelegate.getWritableSupportDatabase();
+    }
+
+    @Override
+    public SupportSQLiteDatabase getReadableDatabase() {
+        return mDelegate.getReadableSupportDatabase();
+    }
+
+    @Override
+    public void close() {
+        mDelegate.close();
+    }
+
+    static class OpenHelper extends SQLiteOpenHelper {
+        /**
+         * This is used as an Object reference so that we can access the wrapped database inside
+         * the constructor. SQLiteOpenHelper requires the error handler to be passed in the
+         * constructor.
+         */
+        final WcdbSQLiteDatabase[] mDbRef;
+        final Callback mCallback;
+
+        OpenHelper(Context context, String name, final WcdbSQLiteDatabase[] dbRef,
+                   final Callback callback) {
+            super(context, name, null, callback.version,
+                    new DatabaseErrorHandler() {
+                        @Override
+                        public void onCorruption(SQLiteDatabase dbObj) {
+                            WcdbSQLiteDatabase db = dbRef[0];
+                            if (db != null) {
+                                callback.onCorruption(db);
+                            }
+                        }
+                    });
+            mCallback = callback;
+            mDbRef = dbRef;
+        }
+
+        OpenHelper(Context context, String name, final WcdbSQLiteDatabase[] dbRef,
+                final Callback callback, String password, SQLiteCipherSpec cipher) {
+            super(context, name, password.getBytes(), cipher, null, callback.version,
+                    new DatabaseErrorHandler() {
+                        @Override
+                        public void onCorruption(SQLiteDatabase dbObj) {
+                            WcdbSQLiteDatabase db = dbRef[0];
+                            if (db != null) {
+                                callback.onCorruption(db);
+                            }
+                        }
+                    });
+            mCallback = callback;
+            mDbRef = dbRef;
+        }
+
+        SupportSQLiteDatabase getWritableSupportDatabase() {
+            SQLiteDatabase db = super.getWritableDatabase();
+            return getWrappedDb(db);
+        }
+
+        SupportSQLiteDatabase getReadableSupportDatabase() {
+            SQLiteDatabase db = super.getReadableDatabase();
+            return getWrappedDb(db);
+        }
+
+        WcdbSQLiteDatabase getWrappedDb(SQLiteDatabase sqLiteDatabase) {
+            WcdbSQLiteDatabase dbRef = mDbRef[0];
+            if (dbRef == null) {
+                dbRef = new WcdbSQLiteDatabase(sqLiteDatabase);
+                mDbRef[0] = dbRef;
+            }
+            return mDbRef[0];
+        }
+
+        @Override
+        public void onCreate(SQLiteDatabase sqLiteDatabase) {
+            mCallback.onCreate(getWrappedDb(sqLiteDatabase));
+        }
+
+        @Override
+        public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
+            mCallback.onUpgrade(getWrappedDb(sqLiteDatabase), oldVersion, newVersion);
+        }
+
+        @Override
+        public void onConfigure(SQLiteDatabase db) {
+            mCallback.onConfigure(getWrappedDb(db));
+        }
+
+        @Override
+        public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            mCallback.onDowngrade(getWrappedDb(db), oldVersion, newVersion);
+        }
+
+        @Override
+        public void onOpen(SQLiteDatabase db) {
+            mCallback.onOpen(getWrappedDb(db));
+        }
+
+        @Override
+        public synchronized void close() {
+            super.close();
+            mDbRef[0] = null;
+        }
+    }
+}
diff --git a/sqlbrite-wcdb-integration/src/main/java/android/arch/persistence/db/wcdb/WcdbSQLiteOpenHelperFactory.java b/sqlbrite-wcdb-integration/src/main/java/android/arch/persistence/db/wcdb/WcdbSQLiteOpenHelperFactory.java
new file mode 100644
index 0000000..385a31a
--- /dev/null
+++ b/sqlbrite-wcdb-integration/src/main/java/android/arch/persistence/db/wcdb/WcdbSQLiteOpenHelperFactory.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.arch.persistence.db.wcdb;
+
+import android.arch.persistence.db.SupportSQLiteOpenHelper;
+
+import com.tencent.wcdb.database.SQLiteCipherSpec;
+
+/**
+ * Implements {@link SupportSQLiteOpenHelper.Factory} using the SQLite implementation in the
+ * framework.
+ */
+@SuppressWarnings("unused")
+public final class WcdbSQLiteOpenHelperFactory implements SupportSQLiteOpenHelper.Factory {
+    @Override
+    public SupportSQLiteOpenHelper create(SupportSQLiteOpenHelper.Configuration configuration) {
+        return new WcdbSQLiteOpenHelper(
+                configuration.context, configuration.name, configuration.callback);
+    }
+
+    public SupportSQLiteOpenHelper create(SupportSQLiteOpenHelper.Configuration configuration, String password) {
+        SQLiteCipherSpec cipher = new SQLiteCipherSpec()  // 加密描述对象
+                .setPageSize(1024)        // SQLCipher 默认 Page size 为 1024
+                .setSQLCipherVersion(3);  // 1,2,3 分别对应 1.x, 2.x, 3.x 创建的 SQLCipher 数据库
+        return new WcdbSQLiteOpenHelper(
+                configuration.context, configuration.name, configuration.callback, password, cipher);
+    }
+}
diff --git a/sqlbrite-wcdb-integration/src/main/java/android/arch/persistence/db/wcdb/WcdbSQLiteProgram.java b/sqlbrite-wcdb-integration/src/main/java/android/arch/persistence/db/wcdb/WcdbSQLiteProgram.java
new file mode 100644
index 0000000..64c1a6a
--- /dev/null
+++ b/sqlbrite-wcdb-integration/src/main/java/android/arch/persistence/db/wcdb/WcdbSQLiteProgram.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.arch.persistence.db.wcdb;
+
+import android.arch.persistence.db.SupportSQLiteProgram;
+import com.tencent.wcdb.database.SQLiteProgram;
+
+/**
+ * An wrapper around {@link SQLiteProgram} to implement {@link SupportSQLiteProgram} API.
+ */
+class WcdbSQLiteProgram implements SupportSQLiteProgram {
+    private final SQLiteProgram mDelegate;
+
+    WcdbSQLiteProgram(SQLiteProgram delegate) {
+        mDelegate = delegate;
+    }
+
+    @Override
+    public void bindNull(int index) {
+        mDelegate.bindNull(index);
+    }
+
+    @Override
+    public void bindLong(int index, long value) {
+        mDelegate.bindLong(index, value);
+    }
+
+    @Override
+    public void bindDouble(int index, double value) {
+        mDelegate.bindDouble(index, value);
+    }
+
+    @Override
+    public void bindString(int index, String value) {
+        mDelegate.bindString(index, value);
+    }
+
+    @Override
+    public void bindBlob(int index, byte[] value) {
+        mDelegate.bindBlob(index, value);
+    }
+
+    @Override
+    public void clearBindings() {
+        mDelegate.clearBindings();
+    }
+
+    @Override
+    public void close() throws Exception {
+        mDelegate.close();
+    }
+}
diff --git a/sqlbrite-wcdb-integration/src/main/java/android/arch/persistence/db/wcdb/WcdbSQLiteStatement.java b/sqlbrite-wcdb-integration/src/main/java/android/arch/persistence/db/wcdb/WcdbSQLiteStatement.java
new file mode 100644
index 0000000..226495b
--- /dev/null
+++ b/sqlbrite-wcdb-integration/src/main/java/android/arch/persistence/db/wcdb/WcdbSQLiteStatement.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.arch.persistence.db.wcdb;
+
+import android.arch.persistence.db.SupportSQLiteStatement;
+import com.tencent.wcdb.database.SQLiteStatement;
+
+/**
+ * Delegates all calls to a {@link SQLiteStatement}.
+ */
+class WcdbSQLiteStatement implements SupportSQLiteStatement {
+    private final SQLiteStatement mDelegate;
+
+    /**
+     * Creates a wrapper around a framework {@link SQLiteStatement}.
+     *
+     * @param delegate The SQLiteStatement to delegate calls to.
+     */
+    WcdbSQLiteStatement(SQLiteStatement delegate) {
+        mDelegate = delegate;
+    }
+
+    @Override
+    public void bindNull(int index) {
+        mDelegate.bindNull(index);
+    }
+
+    @Override
+    public void bindLong(int index, long value) {
+        mDelegate.bindLong(index, value);
+    }
+
+    @Override
+    public void bindDouble(int index, double value) {
+        mDelegate.bindDouble(index, value);
+    }
+
+    @Override
+    public void bindString(int index, String value) {
+        mDelegate.bindString(index, value);
+    }
+
+    @Override
+    public void bindBlob(int index, byte[] value) {
+        mDelegate.bindBlob(index, value);
+    }
+
+    @Override
+    public void clearBindings() {
+        mDelegate.clearBindings();
+    }
+
+    @Override
+    public void execute() {
+        mDelegate.execute();
+    }
+
+    @Override
+    public int executeUpdateDelete() {
+        return mDelegate.executeUpdateDelete();
+    }
+
+    @Override
+    public long executeInsert() {
+        return mDelegate.executeInsert();
+    }
+
+    @Override
+    public long simpleQueryForLong() {
+        return mDelegate.simpleQueryForLong();
+    }
+
+    @Override
+    public String simpleQueryForString() {
+        return mDelegate.simpleQueryForString();
+    }
+
+    @Override
+    public void close() throws Exception {
+        mDelegate.close();
+    }
+}
diff --git a/sqlbrite-wcdb-integration/src/main/res/values/strings.xml b/sqlbrite-wcdb-integration/src/main/res/values/strings.xml
new file mode 100644
index 0000000..1fb9515
--- /dev/null
+++ b/sqlbrite-wcdb-integration/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">sqlbrite-wcdb-integration</string>
+</resources>
diff --git a/sqlbrite-wcdb-integration/src/test/java/android/arch/persistence/db/wcdb/ExampleUnitTest.java b/sqlbrite-wcdb-integration/src/test/java/android/arch/persistence/db/wcdb/ExampleUnitTest.java
new file mode 100644
index 0000000..7dde473
--- /dev/null
+++ b/sqlbrite-wcdb-integration/src/test/java/android/arch/persistence/db/wcdb/ExampleUnitTest.java
@@ -0,0 +1,17 @@
+package android.arch.persistence.db.wcdb;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * Example local unit test, which will execute on the development machine (host).
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
