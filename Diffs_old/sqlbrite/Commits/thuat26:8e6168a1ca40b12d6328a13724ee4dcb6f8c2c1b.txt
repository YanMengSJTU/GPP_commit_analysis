diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/TodoApp.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/TodoApp.java
index d99b5a4..1e7dcdf 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/TodoApp.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/TodoApp.java
@@ -17,23 +17,25 @@
 
 import android.app.Application;
 import android.content.Context;
+
 import dagger.ObjectGraph;
 import timber.log.Timber;
 
 public final class TodoApp extends Application {
-  private ObjectGraph objectGraph;
-
-  @Override public void onCreate() {
-    super.onCreate();
+    private ObjectGraph objectGraph;
 
-    if (BuildConfig.DEBUG) {
-      Timber.plant(new Timber.DebugTree());
+    public static ObjectGraph objectGraph(Context context) {
+        return ((TodoApp) context.getApplicationContext()).objectGraph;
     }
 
-    objectGraph = ObjectGraph.create(new TodoModule(this));
-  }
+    @Override
+    public void onCreate() {
+        super.onCreate();
 
-  public static ObjectGraph objectGraph(Context context) {
-    return ((TodoApp) context.getApplicationContext()).objectGraph;
-  }
+        if (BuildConfig.DEBUG) {
+            Timber.plant(new Timber.DebugTree());
+        }
+
+        objectGraph = ObjectGraph.create(new TodoModule(this));
+    }
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/TodoModule.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/TodoModule.java
index eea28ab..653a63f 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/TodoModule.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/TodoModule.java
@@ -16,26 +16,31 @@
 package com.example.sqlbrite.todo;
 
 import android.app.Application;
+
 import com.example.sqlbrite.todo.db.DbModule;
 import com.example.sqlbrite.todo.ui.UiModule;
+
+import javax.inject.Singleton;
+
 import dagger.Module;
 import dagger.Provides;
-import javax.inject.Singleton;
 
 @Module(
-    includes = {
-        DbModule.class,
-        UiModule.class
-    }
+        includes = {
+                DbModule.class,
+                UiModule.class
+        }
 )
 public final class TodoModule {
-  private final Application application;
+    private final Application application;
 
-  TodoModule(Application application) {
-    this.application = application;
-  }
+    TodoModule(Application application) {
+        this.application = application;
+    }
 
-  @Provides @Singleton Application provideApplication() {
-    return application;
-  }
+    @Provides
+    @Singleton
+    Application provideApplication() {
+        return application;
+    }
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/Db.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/Db.java
index 60a928b..ab96de2 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/Db.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/Db.java
@@ -18,26 +18,26 @@
 import android.database.Cursor;
 
 public final class Db {
-  public static final int BOOLEAN_FALSE = 0;
-  public static final int BOOLEAN_TRUE = 1;
+    public static final int BOOLEAN_FALSE = 0;
+    public static final int BOOLEAN_TRUE = 1;
 
-  public static String getString(Cursor cursor, String columnName) {
-    return cursor.getString(cursor.getColumnIndexOrThrow(columnName));
-  }
+    private Db() {
+        throw new AssertionError("No instances.");
+    }
 
-  public static boolean getBoolean(Cursor cursor, String columnName) {
-    return getInt(cursor, columnName) == BOOLEAN_TRUE;
-  }
+    public static String getString(Cursor cursor, String columnName) {
+        return cursor.getString(cursor.getColumnIndexOrThrow(columnName));
+    }
 
-  public static long getLong(Cursor cursor, String columnName) {
-    return cursor.getLong(cursor.getColumnIndexOrThrow(columnName));
-  }
+    public static boolean getBoolean(Cursor cursor, String columnName) {
+        return getInt(cursor, columnName) == BOOLEAN_TRUE;
+    }
 
-  public static int getInt(Cursor cursor, String columnName) {
-    return cursor.getInt(cursor.getColumnIndexOrThrow(columnName));
-  }
+    public static long getLong(Cursor cursor, String columnName) {
+        return cursor.getLong(cursor.getColumnIndexOrThrow(columnName));
+    }
 
-  private Db() {
-    throw new AssertionError("No instances.");
-  }
+    public static int getInt(Cursor cursor, String columnName) {
+        return cursor.getInt(cursor.getColumnIndexOrThrow(columnName));
+    }
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
index c8a346f..abf6c32 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
@@ -17,28 +17,38 @@
 
 import android.app.Application;
 import android.database.sqlite.SQLiteOpenHelper;
+
 import com.squareup.sqlbrite.BriteDatabase;
 import com.squareup.sqlbrite.SqlBrite;
+
+import javax.inject.Singleton;
+
 import dagger.Module;
 import dagger.Provides;
-import javax.inject.Singleton;
 import timber.log.Timber;
 
 @Module(complete = false, library = true)
 public final class DbModule {
-  @Provides @Singleton SQLiteOpenHelper provideOpenHelper(Application application) {
-    return new DbOpenHelper(application);
-  }
+    @Provides
+    @Singleton
+    SQLiteOpenHelper provideOpenHelper(Application application) {
+        return new DbOpenHelper(application);
+    }
 
-  @Provides @Singleton SqlBrite provideSqlBrite() {
-    return SqlBrite.create(new SqlBrite.Logger() {
-      @Override public void log(String message) {
-        Timber.tag("Database").v(message);
-      }
-    });
-  }
+    @Provides
+    @Singleton
+    SqlBrite provideSqlBrite() {
+        return SqlBrite.create(new SqlBrite.Logger() {
+            @Override
+            public void log(String message) {
+                Timber.tag("Database").v(message);
+            }
+        });
+    }
 
-  @Provides @Singleton BriteDatabase provideDatabase(SqlBrite sqlBrite, SQLiteOpenHelper helper) {
-    return sqlBrite.wrapDatabaseHelper(helper);
-  }
+    @Provides
+    @Singleton
+    BriteDatabase provideDatabase(SqlBrite sqlBrite, SQLiteOpenHelper helper) {
+        return sqlBrite.wrapDatabaseHelper(helper);
+    }
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/DbOpenHelper.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/DbOpenHelper.java
index 00af8eb..b43221a 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/DbOpenHelper.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/DbOpenHelper.java
@@ -20,96 +20,98 @@
 import android.database.sqlite.SQLiteOpenHelper;
 
 final class DbOpenHelper extends SQLiteOpenHelper {
-  private static final int VERSION = 1;
+    private static final int VERSION = 1;
 
-  private static final String CREATE_LIST = ""
-      + "CREATE TABLE " + TodoList.TABLE + "("
-      + TodoList.ID + " INTEGER NOT NULL PRIMARY KEY,"
-      + TodoList.NAME + " TEXT NOT NULL,"
-      + TodoList.ARCHIVED + " INTEGER NOT NULL DEFAULT 0"
-      + ")";
-  private static final String CREATE_ITEM = ""
-      + "CREATE TABLE " + TodoItem.TABLE + "("
-      + TodoItem.ID + " INTEGER NOT NULL PRIMARY KEY,"
-      + TodoItem.LIST_ID + " INTEGER NOT NULL REFERENCES " + TodoList.TABLE + "(" + TodoList.ID + "),"
-      + TodoItem.DESCRIPTION + " TEXT NOT NULL,"
-      + TodoItem.COMPLETE + " INTEGER NOT NULL DEFAULT 0"
-      + ")";
-  private static final String CREATE_ITEM_LIST_ID_INDEX =
-      "CREATE INDEX item_list_id ON " + TodoItem.TABLE + " (" + TodoItem.LIST_ID + ")";
+    private static final String CREATE_LIST = ""
+            + "CREATE TABLE " + TodoList.TABLE + "("
+            + TodoList.ID + " INTEGER NOT NULL PRIMARY KEY,"
+            + TodoList.NAME + " TEXT NOT NULL,"
+            + TodoList.ARCHIVED + " INTEGER NOT NULL DEFAULT 0"
+            + ")";
+    private static final String CREATE_ITEM = ""
+            + "CREATE TABLE " + TodoItem.TABLE + "("
+            + TodoItem.ID + " INTEGER NOT NULL PRIMARY KEY,"
+            + TodoItem.LIST_ID + " INTEGER NOT NULL REFERENCES " + TodoList.TABLE + "(" + TodoList.ID + "),"
+            + TodoItem.DESCRIPTION + " TEXT NOT NULL,"
+            + TodoItem.COMPLETE + " INTEGER NOT NULL DEFAULT 0"
+            + ")";
+    private static final String CREATE_ITEM_LIST_ID_INDEX =
+            "CREATE INDEX item_list_id ON " + TodoItem.TABLE + " (" + TodoItem.LIST_ID + ")";
 
-  public DbOpenHelper(Context context) {
-    super(context, "todo.db", null /* factory */, VERSION);
-  }
+    public DbOpenHelper(Context context) {
+        super(context, "todo.db", null /* factory */, VERSION);
+    }
 
-  @Override public void onCreate(SQLiteDatabase db) {
-    db.execSQL(CREATE_LIST);
-    db.execSQL(CREATE_ITEM);
-    db.execSQL(CREATE_ITEM_LIST_ID_INDEX);
+    @Override
+    public void onCreate(SQLiteDatabase db) {
+        db.execSQL(CREATE_LIST);
+        db.execSQL(CREATE_ITEM);
+        db.execSQL(CREATE_ITEM_LIST_ID_INDEX);
 
-    long groceryListId = db.insert(TodoList.TABLE, null, new TodoList.Builder()
-        .name("Grocery List")
-        .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
-        .listId(groceryListId)
-        .description("Beer")
-        .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
-        .listId(groceryListId)
-        .description("Point Break on DVD")
-        .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
-        .listId(groceryListId)
-        .description("Bad Boys 2 on DVD")
-        .build());
+        long groceryListId = db.insert(TodoList.TABLE, null, new TodoList.Builder()
+                .name("Grocery List")
+                .build());
+        db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+                .listId(groceryListId)
+                .description("Beer")
+                .build());
+        db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+                .listId(groceryListId)
+                .description("Point Break on DVD")
+                .build());
+        db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+                .listId(groceryListId)
+                .description("Bad Boys 2 on DVD")
+                .build());
 
-    long holidayPresentsListId = db.insert(TodoList.TABLE, null, new TodoList.Builder()
-        .name("Holiday Presents")
-        .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
-        .listId(holidayPresentsListId)
-        .description("Pogo Stick for Jake W.")
-        .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
-        .listId(holidayPresentsListId)
-        .description("Jack-in-the-box for Alec S.")
-        .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
-        .listId(holidayPresentsListId)
-        .description("Pogs for Matt P.")
-        .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
-        .listId(holidayPresentsListId)
-        .description("Coal for Jesse W.")
-        .build());
+        long holidayPresentsListId = db.insert(TodoList.TABLE, null, new TodoList.Builder()
+                .name("Holiday Presents")
+                .build());
+        db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+                .listId(holidayPresentsListId)
+                .description("Pogo Stick for Jake W.")
+                .build());
+        db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+                .listId(holidayPresentsListId)
+                .description("Jack-in-the-box for Alec S.")
+                .build());
+        db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+                .listId(holidayPresentsListId)
+                .description("Pogs for Matt P.")
+                .build());
+        db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+                .listId(holidayPresentsListId)
+                .description("Coal for Jesse W.")
+                .build());
 
-    long workListId = db.insert(TodoList.TABLE, null, new TodoList.Builder()
-        .name("Work Items")
-        .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
-        .listId(workListId)
-        .description("Finish SqlBrite library")
-        .complete(true)
-        .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
-        .listId(workListId)
-        .description("Finish SqlBrite sample app")
-        .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
-        .listId(workListId)
-        .description("Publish SqlBrite to GitHub")
-        .build());
+        long workListId = db.insert(TodoList.TABLE, null, new TodoList.Builder()
+                .name("Work Items")
+                .build());
+        db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+                .listId(workListId)
+                .description("Finish SqlBrite library")
+                .complete(true)
+                .build());
+        db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+                .listId(workListId)
+                .description("Finish SqlBrite sample app")
+                .build());
+        db.insert(TodoItem.TABLE, null, new TodoItem.Builder()
+                .listId(workListId)
+                .description("Publish SqlBrite to GitHub")
+                .build());
 
-    long birthdayPresentsListId = db.insert(TodoList.TABLE, null, new TodoList.Builder()
-        .name("Birthday Presents")
-        .archived(true)
-        .build());
-    db.insert(TodoItem.TABLE, null, new TodoItem.Builder().listId(birthdayPresentsListId)
-        .description("New car")
-        .complete(true)
-        .build());
-  }
+        long birthdayPresentsListId = db.insert(TodoList.TABLE, null, new TodoList.Builder()
+                .name("Birthday Presents")
+                .archived(true)
+                .build());
+        db.insert(TodoItem.TABLE, null, new TodoItem.Builder().listId(birthdayPresentsListId)
+                .description("New car")
+                .complete(true)
+                .build());
+    }
 
-  @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-  }
+    @Override
+    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+    }
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
index 77c6847..6dfd2db 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
@@ -17,58 +17,62 @@
 
 import android.content.ContentValues;
 import android.database.Cursor;
+
 import auto.parcel.AutoParcel;
 import rx.functions.Func1;
 
 @AutoParcel
 public abstract class TodoItem {
-  public static final String TABLE = "todo_item";
+    public static final String TABLE = "todo_item";
 
-  public static final String ID = "_id";
-  public static final String LIST_ID = "todo_list_id";
-  public static final String DESCRIPTION = "description";
-  public static final String COMPLETE = "complete";
+    public static final String ID = "_id";
+    public static final String LIST_ID = "todo_list_id";
+    public static final String DESCRIPTION = "description";
+    public static final String COMPLETE = "complete";
+    public static final Func1<Cursor, TodoItem> MAPPER = new Func1<Cursor, TodoItem>() {
+        @Override
+        public TodoItem call(Cursor cursor) {
+            long id = Db.getLong(cursor, ID);
+            long listId = Db.getLong(cursor, LIST_ID);
+            String description = Db.getString(cursor, DESCRIPTION);
+            boolean complete = Db.getBoolean(cursor, COMPLETE);
+            return new AutoParcel_TodoItem(id, listId, description, complete);
+        }
+    };
 
-  public abstract long id();
-  public abstract long listId();
-  public abstract String description();
-  public abstract boolean complete();
+    public abstract long id();
 
-  public static final Func1<Cursor, TodoItem> MAPPER = new Func1<Cursor, TodoItem>() {
-    @Override public TodoItem call(Cursor cursor) {
-      long id = Db.getLong(cursor, ID);
-      long listId = Db.getLong(cursor, LIST_ID);
-      String description = Db.getString(cursor, DESCRIPTION);
-      boolean complete = Db.getBoolean(cursor, COMPLETE);
-      return new AutoParcel_TodoItem(id, listId, description, complete);
-    }
-  };
+    public abstract long listId();
 
-  public static final class Builder {
-    private final ContentValues values = new ContentValues();
+    public abstract String description();
 
-    public Builder id(long id) {
-      values.put(ID, id);
-      return this;
-    }
+    public abstract boolean complete();
 
-    public Builder listId(long listId) {
-      values.put(LIST_ID, listId);
-      return this;
-    }
+    public static final class Builder {
+        private final ContentValues values = new ContentValues();
 
-    public Builder description(String description) {
-      values.put(DESCRIPTION, description);
-      return this;
-    }
+        public Builder id(long id) {
+            values.put(ID, id);
+            return this;
+        }
 
-    public Builder complete(boolean complete) {
-      values.put(COMPLETE, complete);
-      return this;
-    }
+        public Builder listId(long listId) {
+            values.put(LIST_ID, listId);
+            return this;
+        }
+
+        public Builder description(String description) {
+            values.put(DESCRIPTION, description);
+            return this;
+        }
+
+        public Builder complete(boolean complete) {
+            values.put(COMPLETE, complete);
+            return this;
+        }
 
-    public ContentValues build() {
-      return values; // TODO defensive copy?
+        public ContentValues build() {
+            return values; // TODO defensive copy?
+        }
     }
-  }
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java
index 0c890a6..d94d294 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java
@@ -17,62 +17,66 @@
 
 import android.content.ContentValues;
 import android.database.Cursor;
-import auto.parcel.AutoParcel;
+
 import java.util.ArrayList;
 import java.util.List;
+
+import auto.parcel.AutoParcel;
 import rx.functions.Func1;
 
 // Note: normally I wouldn't prefix table classes but I didn't want 'List' to be overloaded.
 @AutoParcel
 public abstract class TodoList {
-  public static final String TABLE = "todo_list";
+    public static final String TABLE = "todo_list";
 
-  public static final String ID = "_id";
-  public static final String NAME = "name";
-  public static final String ARCHIVED = "archived";
+    public static final String ID = "_id";
+    public static final String NAME = "name";
+    public static final String ARCHIVED = "archived";
+    public static Func1<Cursor, List<TodoList>> MAP = new Func1<Cursor, List<TodoList>>() {
+        @Override
+        public List<TodoList> call(final Cursor cursor) {
+            try {
+                List<TodoList> values = new ArrayList<>(cursor.getCount());
 
-  public abstract long id();
-  public abstract String name();
-  public abstract boolean archived();
+                while (cursor.moveToNext()) {
+                    long id = Db.getLong(cursor, ID);
+                    String name = Db.getString(cursor, NAME);
+                    boolean archived = Db.getBoolean(cursor, ARCHIVED);
+                    values.add(new AutoParcel_TodoList(id, name, archived));
+                }
+                return values;
+            } finally {
+                cursor.close();
+            }
+        }
+    };
 
-  public static Func1<Cursor, List<TodoList>> MAP = new Func1<Cursor, List<TodoList>>() {
-    @Override public List<TodoList> call(final Cursor cursor) {
-      try {
-        List<TodoList> values = new ArrayList<>(cursor.getCount());
+    public abstract long id();
 
-        while (cursor.moveToNext()) {
-          long id = Db.getLong(cursor, ID);
-          String name = Db.getString(cursor, NAME);
-          boolean archived = Db.getBoolean(cursor, ARCHIVED);
-          values.add(new AutoParcel_TodoList(id, name, archived));
-        }
-        return values;
-      } finally {
-        cursor.close();
-      }
-    }
-  };
+    public abstract String name();
 
-  public static final class Builder {
-    private final ContentValues values = new ContentValues();
+    public abstract boolean archived();
 
-    public Builder id(long id) {
-      values.put(ID, id);
-      return this;
-    }
+    public static final class Builder {
+        private final ContentValues values = new ContentValues();
 
-    public Builder name(String name) {
-      values.put(NAME, name);
-      return this;
-    }
+        public Builder id(long id) {
+            values.put(ID, id);
+            return this;
+        }
 
-    public Builder archived(boolean archived) {
-      values.put(ARCHIVED, archived);
-      return this;
-    }
+        public Builder name(String name) {
+            values.put(NAME, name);
+            return this;
+        }
 
-    public ContentValues build() {
-      return values; // TODO defensive copy?
+        public Builder archived(boolean archived) {
+            values.put(ARCHIVED, archived);
+            return this;
+        }
+
+        public ContentValues build() {
+            return values; // TODO defensive copy?
+        }
     }
-  }
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsAdapter.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsAdapter.java
index 22ccff4..1ce856d 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsAdapter.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsAdapter.java
@@ -23,59 +23,68 @@
 import android.view.ViewGroup;
 import android.widget.BaseAdapter;
 import android.widget.CheckedTextView;
+
 import com.example.sqlbrite.todo.db.TodoItem;
+
 import java.util.Collections;
 import java.util.List;
+
 import rx.functions.Action1;
 
 final class ItemsAdapter extends BaseAdapter implements Action1<List<TodoItem>> {
-  private final LayoutInflater inflater;
+    private final LayoutInflater inflater;
 
-  private List<TodoItem> items = Collections.emptyList();
+    private List<TodoItem> items = Collections.emptyList();
 
-  public ItemsAdapter(Context context) {
-    inflater = LayoutInflater.from(context);
-  }
-
-  @Override public void call(List<TodoItem> items) {
-    this.items = items;
-    notifyDataSetChanged();
-  }
+    public ItemsAdapter(Context context) {
+        inflater = LayoutInflater.from(context);
+    }
 
-  @Override public int getCount() {
-    return items.size();
-  }
+    @Override
+    public void call(List<TodoItem> items) {
+        this.items = items;
+        notifyDataSetChanged();
+    }
 
-  @Override public TodoItem getItem(int position) {
-    return items.get(position);
-  }
+    @Override
+    public int getCount() {
+        return items.size();
+    }
 
-  @Override public long getItemId(int position) {
-    return getItem(position).id();
-  }
+    @Override
+    public TodoItem getItem(int position) {
+        return items.get(position);
+    }
 
-  @Override public boolean hasStableIds() {
-    return true;
-  }
+    @Override
+    public long getItemId(int position) {
+        return getItem(position).id();
+    }
 
-  @Override public View getView(int position, View convertView, ViewGroup parent) {
-    if (convertView == null) {
-      convertView = inflater.inflate(android.R.layout.simple_list_item_multiple_choice, parent, false);
+    @Override
+    public boolean hasStableIds() {
+        return true;
     }
 
-    TodoItem item = getItem(position);
-    CheckedTextView textView = (CheckedTextView) convertView;
-    textView.setChecked(item.complete());
+    @Override
+    public View getView(int position, View convertView, ViewGroup parent) {
+        if (convertView == null) {
+            convertView = inflater.inflate(android.R.layout.simple_list_item_multiple_choice, parent, false);
+        }
 
-    CharSequence description = item.description();
-    if (item.complete()) {
-      SpannableString spannable = new SpannableString(description);
-      spannable.setSpan(new StrikethroughSpan(), 0, description.length(), 0);
-      description = spannable;
-    }
+        TodoItem item = getItem(position);
+        CheckedTextView textView = (CheckedTextView) convertView;
+        textView.setChecked(item.complete());
+
+        CharSequence description = item.description();
+        if (item.complete()) {
+            SpannableString spannable = new SpannableString(description);
+            spannable.setSpan(new StrikethroughSpan(), 0, description.length(), 0);
+            description = spannable;
+        }
 
-    textView.setText(description);
+        textView.setText(description);
 
-    return convertView;
-  }
+        return convertView;
+    }
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
index 113d3af..2e3ba14 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
@@ -28,8 +28,7 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ListView;
-import butterknife.ButterKnife;
-import butterknife.InjectView;
+
 import com.example.sqlbrite.todo.R;
 import com.example.sqlbrite.todo.TodoApp;
 import com.example.sqlbrite.todo.db.Db;
@@ -38,7 +37,11 @@
 import com.jakewharton.rxbinding.widget.AdapterViewItemClickEvent;
 import com.jakewharton.rxbinding.widget.RxAdapterView;
 import com.squareup.sqlbrite.BriteDatabase;
+
 import javax.inject.Inject;
+
+import butterknife.ButterKnife;
+import butterknife.InjectView;
 import rx.Observable;
 import rx.android.schedulers.AndroidSchedulers;
 import rx.functions.Action1;
@@ -52,158 +55,166 @@
 import static com.squareup.sqlbrite.SqlBrite.Query;
 
 public final class ItemsFragment extends Fragment {
-  private static final String KEY_LIST_ID = "list_id";
-  private static final String LIST_QUERY = "SELECT * FROM "
-      + TodoItem.TABLE
-      + " WHERE "
-      + TodoItem.LIST_ID
-      + " = ? ORDER BY "
-      + TodoItem.COMPLETE
-      + " ASC";
-  private static final String COUNT_QUERY = "SELECT COUNT(*) FROM "
-      + TodoItem.TABLE
-      + " WHERE "
-      + TodoItem.COMPLETE
-      + " = "
-      + Db.BOOLEAN_FALSE
-      + " AND "
-      + TodoItem.LIST_ID
-      + " = ?";
-  private static final String TITLE_QUERY =
-      "SELECT " + TodoList.NAME + " FROM " + TodoList.TABLE + " WHERE " + TodoList.ID + " = ?";
-
-  public interface Listener {
-    void onNewItemClicked(long listId);
-  }
-
-  public static ItemsFragment newInstance(long listId) {
-    Bundle arguments = new Bundle();
-    arguments.putLong(KEY_LIST_ID, listId);
-
-    ItemsFragment fragment = new ItemsFragment();
-    fragment.setArguments(arguments);
-    return fragment;
-  }
-
-  @Inject BriteDatabase db;
-
-  @InjectView(android.R.id.list) ListView listView;
-  @InjectView(android.R.id.empty) View emptyView;
-
-  private Listener listener;
-  private ItemsAdapter adapter;
-  private CompositeSubscription subscriptions;
-
-  private long getListId() {
-    return getArguments().getLong(KEY_LIST_ID);
-  }
-
-  @Override public void onAttach(Activity activity) {
-    if (!(activity instanceof Listener)) {
-      throw new IllegalStateException("Activity must implement fragment Listener.");
+    private static final String KEY_LIST_ID = "list_id";
+    private static final String LIST_QUERY = "SELECT * FROM "
+            + TodoItem.TABLE
+            + " WHERE "
+            + TodoItem.LIST_ID
+            + " = ? ORDER BY "
+            + TodoItem.COMPLETE
+            + " ASC";
+    private static final String COUNT_QUERY = "SELECT COUNT(*) FROM "
+            + TodoItem.TABLE
+            + " WHERE "
+            + TodoItem.COMPLETE
+            + " = "
+            + Db.BOOLEAN_FALSE
+            + " AND "
+            + TodoItem.LIST_ID
+            + " = ?";
+    private static final String TITLE_QUERY =
+            "SELECT " + TodoList.NAME + " FROM " + TodoList.TABLE + " WHERE " + TodoList.ID + " = ?";
+    @Inject BriteDatabase db;
+    @InjectView(android.R.id.list) ListView listView;
+    @InjectView(android.R.id.empty) View emptyView;
+    private Listener listener;
+    private ItemsAdapter adapter;
+    private CompositeSubscription subscriptions;
+
+    public static ItemsFragment newInstance(long listId) {
+        Bundle arguments = new Bundle();
+        arguments.putLong(KEY_LIST_ID, listId);
+
+        ItemsFragment fragment = new ItemsFragment();
+        fragment.setArguments(arguments);
+        return fragment;
+    }
+
+    private long getListId() {
+        return getArguments().getLong(KEY_LIST_ID);
+    }
+
+    @Override
+    public void onAttach(Activity activity) {
+        if (!(activity instanceof Listener)) {
+            throw new IllegalStateException("Activity must implement fragment Listener.");
+        }
+
+        super.onAttach(activity);
+        TodoApp.objectGraph(activity).inject(this);
+        setHasOptionsMenu(true);
+
+        listener = (Listener) activity;
+        adapter = new ItemsAdapter(activity);
+    }
+
+    @Override
+    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+        super.onCreateOptionsMenu(menu, inflater);
+
+        MenuItem item = menu.add(R.string.new_item)
+                .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
+                    @Override
+                    public boolean onMenuItemClick(MenuItem item) {
+                        listener.onNewItemClicked(getListId());
+                        return true;
+                    }
+                });
+        MenuItemCompat.setShowAsAction(item, SHOW_AS_ACTION_IF_ROOM | SHOW_AS_ACTION_WITH_TEXT);
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
+                             @Nullable Bundle savedInstanceState) {
+        return inflater.inflate(R.layout.items, container, false);
+    }
+
+    @Override
+    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+        ButterKnife.inject(this, view);
+        listView.setEmptyView(emptyView);
+        listView.setAdapter(adapter);
+
+        RxAdapterView.itemClickEvents(listView) //
+                .observeOn(Schedulers.io())
+                .subscribe(new Action1<AdapterViewItemClickEvent>() {
+                    @Override
+                    public void call(AdapterViewItemClickEvent event) {
+                        boolean newValue = !adapter.getItem(event.position()).complete();
+                        db.update(TodoItem.TABLE, new TodoItem.Builder().complete(newValue).build(),
+                                TodoItem.ID + " = ?", String.valueOf(event.id()));
+                    }
+                });
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        String listId = String.valueOf(getListId());
+
+        subscriptions = new CompositeSubscription();
+
+        Observable<Integer> itemCount = db.createQuery(TodoItem.TABLE, COUNT_QUERY, listId) //
+                .map(new Func1<Query, Integer>() {
+                    @Override
+                    public Integer call(Query query) {
+                        Cursor cursor = query.run();
+                        try {
+                            if (!cursor.moveToNext()) {
+                                throw new AssertionError("No rows");
+                            }
+                            return cursor.getInt(0);
+                        } finally {
+                            cursor.close();
+                        }
+                    }
+                });
+        Observable<String> listName =
+                db.createQuery(TodoList.TABLE, TITLE_QUERY, listId).map(new Func1<Query, String>() {
+                    @Override
+                    public String call(Query query) {
+                        Cursor cursor = query.run();
+                        try {
+                            if (!cursor.moveToNext()) {
+                                throw new AssertionError("No rows");
+                            }
+                            return cursor.getString(0);
+                        } finally {
+                            cursor.close();
+                        }
+                    }
+                });
+        subscriptions.add(
+                Observable.combineLatest(listName, itemCount, new Func2<String, Integer, String>() {
+                    @Override
+                    public String call(String listName, Integer itemCount) {
+                        return listName + " (" + itemCount + ")";
+                    }
+                })
+                        .subscribeOn(Schedulers.io())
+                        .observeOn(AndroidSchedulers.mainThread())
+                        .subscribe(new Action1<String>() {
+                            @Override
+                            public void call(String title) {
+                                getActivity().setTitle(title);
+                            }
+                        }));
+
+        subscriptions.add(db.createQuery(TodoItem.TABLE, LIST_QUERY, listId)
+                .mapToList(TodoItem.MAPPER)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(adapter));
     }
 
-    super.onAttach(activity);
-    TodoApp.objectGraph(activity).inject(this);
-    setHasOptionsMenu(true);
-
-    listener = (Listener) activity;
-    adapter = new ItemsAdapter(activity);
-  }
-
-  @Override public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
-    super.onCreateOptionsMenu(menu, inflater);
-
-    MenuItem item = menu.add(R.string.new_item)
-        .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
-          @Override public boolean onMenuItemClick(MenuItem item) {
-            listener.onNewItemClicked(getListId());
-            return true;
-          }
-        });
-    MenuItemCompat.setShowAsAction(item, SHOW_AS_ACTION_IF_ROOM | SHOW_AS_ACTION_WITH_TEXT);
-  }
-
-  @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
-      @Nullable Bundle savedInstanceState) {
-    return inflater.inflate(R.layout.items, container, false);
-  }
-
-  @Override
-  public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
-    super.onViewCreated(view, savedInstanceState);
-    ButterKnife.inject(this, view);
-    listView.setEmptyView(emptyView);
-    listView.setAdapter(adapter);
-
-    RxAdapterView.itemClickEvents(listView) //
-        .observeOn(Schedulers.io())
-        .subscribe(new Action1<AdapterViewItemClickEvent>() {
-          @Override public void call(AdapterViewItemClickEvent event) {
-            boolean newValue = !adapter.getItem(event.position()).complete();
-            db.update(TodoItem.TABLE, new TodoItem.Builder().complete(newValue).build(),
-                TodoItem.ID + " = ?", String.valueOf(event.id()));
-          }
-        });
-  }
-
-  @Override public void onResume() {
-    super.onResume();
-    String listId = String.valueOf(getListId());
-
-    subscriptions = new CompositeSubscription();
-
-    Observable<Integer> itemCount = db.createQuery(TodoItem.TABLE, COUNT_QUERY, listId) //
-        .map(new Func1<Query, Integer>() {
-          @Override public Integer call(Query query) {
-            Cursor cursor = query.run();
-            try {
-              if (!cursor.moveToNext()) {
-                throw new AssertionError("No rows");
-              }
-              return cursor.getInt(0);
-            } finally {
-              cursor.close();
-            }
-          }
-        });
-    Observable<String> listName =
-        db.createQuery(TodoList.TABLE, TITLE_QUERY, listId).map(new Func1<Query, String>() {
-          @Override public String call(Query query) {
-            Cursor cursor = query.run();
-            try {
-              if (!cursor.moveToNext()) {
-                throw new AssertionError("No rows");
-              }
-              return cursor.getString(0);
-            } finally {
-              cursor.close();
-            }
-          }
-        });
-    subscriptions.add(
-        Observable.combineLatest(listName, itemCount, new Func2<String, Integer, String>() {
-          @Override public String call(String listName, Integer itemCount) {
-            return listName + " (" + itemCount + ")";
-          }
-        })
-            .subscribeOn(Schedulers.io())
-            .observeOn(AndroidSchedulers.mainThread())
-            .subscribe(new Action1<String>() {
-              @Override public void call(String title) {
-                getActivity().setTitle(title);
-              }
-            }));
-
-    subscriptions.add(db.createQuery(TodoItem.TABLE, LIST_QUERY, listId)
-        .mapToList(TodoItem.MAPPER)
-        .subscribeOn(Schedulers.io())
-        .observeOn(AndroidSchedulers.mainThread())
-        .subscribe(adapter));
-  }
-
-  @Override public void onPause() {
-    super.onPause();
-    subscriptions.unsubscribe();
-  }
+    @Override
+    public void onPause() {
+        super.onPause();
+        subscriptions.unsubscribe();
+    }
+
+    public interface Listener {
+        void onNewItemClicked(long listId);
+    }
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsAdapter.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsAdapter.java
index b88362c..ff2ff3b 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsAdapter.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsAdapter.java
@@ -21,48 +21,56 @@
 import android.view.ViewGroup;
 import android.widget.BaseAdapter;
 import android.widget.TextView;
+
 import java.util.Collections;
 import java.util.List;
+
 import rx.functions.Action1;
 
 final class ListsAdapter extends BaseAdapter implements Action1<List<ListsItem>> {
-  private final LayoutInflater inflater;
-
-  private List<ListsItem> items = Collections.emptyList();
+    private final LayoutInflater inflater;
 
-  public ListsAdapter(Context context) {
-    this.inflater = LayoutInflater.from(context);
-  }
+    private List<ListsItem> items = Collections.emptyList();
 
-  @Override public void call(List<ListsItem> items) {
-    this.items = items;
-    notifyDataSetChanged();
-  }
+    public ListsAdapter(Context context) {
+        this.inflater = LayoutInflater.from(context);
+    }
 
-  @Override public int getCount() {
-    return items.size();
-  }
+    @Override
+    public void call(List<ListsItem> items) {
+        this.items = items;
+        notifyDataSetChanged();
+    }
 
-  @Override public ListsItem getItem(int position) {
-    return items.get(position);
-  }
+    @Override
+    public int getCount() {
+        return items.size();
+    }
 
-  @Override public long getItemId(int position) {
-    return getItem(position).id();
-  }
+    @Override
+    public ListsItem getItem(int position) {
+        return items.get(position);
+    }
 
-  @Override public boolean hasStableIds() {
-    return true;
-  }
+    @Override
+    public long getItemId(int position) {
+        return getItem(position).id();
+    }
 
-  @Override public View getView(int position, View convertView, ViewGroup parent) {
-    if (convertView == null) {
-      convertView = inflater.inflate(android.R.layout.simple_list_item_1, parent, false);
+    @Override
+    public boolean hasStableIds() {
+        return true;
     }
 
-    ListsItem item = getItem(position);
-    ((TextView) convertView).setText(item.name() + " (" + item.itemCount() + ")");
+    @Override
+    public View getView(int position, View convertView, ViewGroup parent) {
+        if (convertView == null) {
+            convertView = inflater.inflate(android.R.layout.simple_list_item_1, parent, false);
+        }
 
-    return convertView;
-  }
+        ListsItem item = getItem(position);
+        ((TextView) convertView).setText(item.name() + " (" + item.itemCount() + ")");
+
+        return convertView;
+    }
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
index feebb0d..73a15b3 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
@@ -27,13 +27,16 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ListView;
-import butterknife.ButterKnife;
-import butterknife.InjectView;
-import butterknife.OnItemClick;
+
 import com.example.sqlbrite.todo.R;
 import com.example.sqlbrite.todo.TodoApp;
 import com.squareup.sqlbrite.BriteDatabase;
+
 import javax.inject.Inject;
+
+import butterknife.ButterKnife;
+import butterknife.InjectView;
+import butterknife.OnItemClick;
 import rx.Subscription;
 import rx.android.schedulers.AndroidSchedulers;
 import rx.schedulers.Schedulers;
@@ -42,81 +45,87 @@
 import static android.support.v4.view.MenuItemCompat.SHOW_AS_ACTION_WITH_TEXT;
 
 public final class ListsFragment extends Fragment {
-  interface Listener {
-    void onListClicked(long id);
-    void onNewListClicked();
-  }
+    @Inject BriteDatabase db;
+    @InjectView(android.R.id.list) ListView listView;
+    @InjectView(android.R.id.empty) View emptyView;
+    private Listener listener;
+    private ListsAdapter adapter;
+    private Subscription subscription;
+
+    static ListsFragment newInstance() {
+        return new ListsFragment();
+    }
+
+    @Override
+    public void onAttach(Activity activity) {
+        if (!(activity instanceof Listener)) {
+            throw new IllegalStateException("Activity must implement fragment Listener.");
+        }
+
+        super.onAttach(activity);
+        TodoApp.objectGraph(activity).inject(this);
+        setHasOptionsMenu(true);
 
-  static ListsFragment newInstance() {
-    return new ListsFragment();
-  }
+        listener = (Listener) activity;
+        adapter = new ListsAdapter(activity);
+    }
+
+    @Override
+    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+        super.onCreateOptionsMenu(menu, inflater);
+
+        MenuItem item = menu.add(R.string.new_list)
+                .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
+                    @Override
+                    public boolean onMenuItemClick(MenuItem item) {
+                        listener.onNewListClicked();
+                        return true;
+                    }
+                });
+        MenuItemCompat.setShowAsAction(item, SHOW_AS_ACTION_IF_ROOM | SHOW_AS_ACTION_WITH_TEXT);
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
+                             @Nullable Bundle savedInstanceState) {
+        return inflater.inflate(R.layout.lists, container, false);
+    }
+
+    @Override
+    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+        ButterKnife.inject(this, view);
+        listView.setEmptyView(emptyView);
+        listView.setAdapter(adapter);
+    }
+
+    @OnItemClick(android.R.id.list)
+    void listClicked(long listId) {
+        listener.onListClicked(listId);
+    }
 
-  @Inject BriteDatabase db;
+    @Override
+    public void onResume() {
+        super.onResume();
 
-  @InjectView(android.R.id.list) ListView listView;
-  @InjectView(android.R.id.empty) View emptyView;
+        getActivity().setTitle("To-Do");
 
-  private Listener listener;
-  private ListsAdapter adapter;
-  private Subscription subscription;
+        subscription = db.createQuery(ListsItem.TABLES, ListsItem.QUERY)
+                .mapToList(ListsItem.MAPPER)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(adapter);
+    }
 
-  @Override public void onAttach(Activity activity) {
-    if (!(activity instanceof Listener)) {
-      throw new IllegalStateException("Activity must implement fragment Listener.");
+    @Override
+    public void onPause() {
+        super.onPause();
+        subscription.unsubscribe();
     }
 
-    super.onAttach(activity);
-    TodoApp.objectGraph(activity).inject(this);
-    setHasOptionsMenu(true);
-
-    listener = (Listener) activity;
-    adapter = new ListsAdapter(activity);
-  }
-
-  @Override public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
-    super.onCreateOptionsMenu(menu, inflater);
-
-    MenuItem item = menu.add(R.string.new_list)
-        .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
-          @Override public boolean onMenuItemClick(MenuItem item) {
-            listener.onNewListClicked();
-            return true;
-          }
-        });
-    MenuItemCompat.setShowAsAction(item, SHOW_AS_ACTION_IF_ROOM | SHOW_AS_ACTION_WITH_TEXT);
-  }
-
-  @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
-      @Nullable Bundle savedInstanceState) {
-    return inflater.inflate(R.layout.lists, container, false);
-  }
-
-  @Override
-  public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
-    super.onViewCreated(view, savedInstanceState);
-    ButterKnife.inject(this, view);
-    listView.setEmptyView(emptyView);
-    listView.setAdapter(adapter);
-  }
-
-  @OnItemClick(android.R.id.list) void listClicked(long listId) {
-    listener.onListClicked(listId);
-  }
-
-  @Override public void onResume() {
-    super.onResume();
-
-    getActivity().setTitle("To-Do");
-
-    subscription = db.createQuery(ListsItem.TABLES, ListsItem.QUERY)
-        .mapToList(ListsItem.MAPPER)
-        .subscribeOn(Schedulers.io())
-        .observeOn(AndroidSchedulers.mainThread())
-        .subscribe(adapter);
-  }
-
-  @Override public void onPause() {
-    super.onPause();
-    subscription.unsubscribe();
-  }
+    interface Listener {
+        void onListClicked(long id);
+
+        void onNewListClicked();
+    }
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
index 51b2281..452ec8f 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
@@ -16,42 +16,45 @@
 package com.example.sqlbrite.todo.ui;
 
 import android.database.Cursor;
-import auto.parcel.AutoParcel;
+
 import com.example.sqlbrite.todo.db.Db;
 import com.example.sqlbrite.todo.db.TodoItem;
 import com.example.sqlbrite.todo.db.TodoList;
+
 import java.util.Arrays;
 import java.util.Collection;
+
+import auto.parcel.AutoParcel;
 import rx.functions.Func1;
 
 @AutoParcel
 abstract class ListsItem {
-  private static String ALIAS_LIST = "list";
-  private static String ALIAS_ITEM = "item";
-
-  private static String LIST_ID = ALIAS_LIST + "." + TodoList.ID;
-  private static String LIST_NAME = ALIAS_LIST + "." + TodoList.NAME;
-  private static String ITEM_COUNT = "item_count";
-  private static String ITEM_ID = ALIAS_ITEM + "." + TodoItem.ID;
-  private static String ITEM_LIST_ID = ALIAS_ITEM + "." + TodoItem.LIST_ID;
-
-  public static Collection<String> TABLES = Arrays.asList(TodoList.TABLE, TodoItem.TABLE);
-  public static String QUERY = ""
-      + "SELECT " + LIST_ID + ", " + LIST_NAME + ", COUNT(" + ITEM_ID + ") as " + ITEM_COUNT
-      + " FROM " + TodoList.TABLE + " AS " + ALIAS_LIST
-      + " LEFT OUTER JOIN " + TodoItem.TABLE + " AS " + ALIAS_ITEM + " ON " + LIST_ID + " = " + ITEM_LIST_ID
-      + " GROUP BY " + LIST_ID;
-
-  abstract long id();
-  abstract String name();
-  abstract int itemCount();
-
-  static Func1<Cursor, ListsItem> MAPPER = new Func1<Cursor, ListsItem>() {
-    @Override public ListsItem call(Cursor cursor) {
-      long id = Db.getLong(cursor, TodoList.ID);
-      String name = Db.getString(cursor, TodoList.NAME);
-      int itemCount = Db.getInt(cursor, ITEM_COUNT);
-      return new AutoParcel_ListsItem(id, name, itemCount);
-    }
-  };
+    public static Collection<String> TABLES = Arrays.asList(TodoList.TABLE, TodoItem.TABLE);
+    private static String ALIAS_LIST = "list";
+    private static String ALIAS_ITEM = "item";
+    private static String LIST_ID = ALIAS_LIST + "." + TodoList.ID;
+    private static String LIST_NAME = ALIAS_LIST + "." + TodoList.NAME;
+    private static String ITEM_COUNT = "item_count";
+    static Func1<Cursor, ListsItem> MAPPER = new Func1<Cursor, ListsItem>() {
+        @Override
+        public ListsItem call(Cursor cursor) {
+            long id = Db.getLong(cursor, TodoList.ID);
+            String name = Db.getString(cursor, TodoList.NAME);
+            int itemCount = Db.getInt(cursor, ITEM_COUNT);
+            return new AutoParcel_ListsItem(id, name, itemCount);
+        }
+    };
+    private static String ITEM_ID = ALIAS_ITEM + "." + TodoItem.ID;
+    private static String ITEM_LIST_ID = ALIAS_ITEM + "." + TodoItem.LIST_ID;
+    public static String QUERY = ""
+            + "SELECT " + LIST_ID + ", " + LIST_NAME + ", COUNT(" + ITEM_ID + ") as " + ITEM_COUNT
+            + " FROM " + TodoList.TABLE + " AS " + ALIAS_LIST
+            + " LEFT OUTER JOIN " + TodoItem.TABLE + " AS " + ALIAS_ITEM + " ON " + LIST_ID + " = " + ITEM_LIST_ID
+            + " GROUP BY " + LIST_ID;
+
+    abstract long id();
+
+    abstract String name();
+
+    abstract int itemCount();
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/MainActivity.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/MainActivity.java
index f5b8cb3..87c41b5 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/MainActivity.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/MainActivity.java
@@ -17,34 +17,39 @@
 
 import android.os.Bundle;
 import android.support.v4.app.FragmentActivity;
+
 import com.example.sqlbrite.todo.R;
 
 public final class MainActivity extends FragmentActivity
-    implements ListsFragment.Listener, ItemsFragment.Listener {
+        implements ListsFragment.Listener, ItemsFragment.Listener {
 
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-    if (savedInstanceState == null) {
-      getSupportFragmentManager().beginTransaction()
-          .add(android.R.id.content, ListsFragment.newInstance())
-          .commit();
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        if (savedInstanceState == null) {
+            getSupportFragmentManager().beginTransaction()
+                    .add(android.R.id.content, ListsFragment.newInstance())
+                    .commit();
+        }
     }
-  }
 
-  @Override public void onListClicked(long id) {
-    getSupportFragmentManager().beginTransaction()
-        .setCustomAnimations(R.anim.slide_in_right, R.anim.slide_out_left, R.anim.slide_in_left,
-            R.anim.slide_out_right)
-        .replace(android.R.id.content, ItemsFragment.newInstance(id))
-        .addToBackStack(null)
-        .commit();
-  }
+    @Override
+    public void onListClicked(long id) {
+        getSupportFragmentManager().beginTransaction()
+                .setCustomAnimations(R.anim.slide_in_right, R.anim.slide_out_left, R.anim.slide_in_left,
+                        R.anim.slide_out_right)
+                .replace(android.R.id.content, ItemsFragment.newInstance(id))
+                .addToBackStack(null)
+                .commit();
+    }
 
-  @Override public void onNewListClicked() {
-    NewListFragment.newInstance().show(getSupportFragmentManager(), "new-list");
-  }
+    @Override
+    public void onNewListClicked() {
+        NewListFragment.newInstance().show(getSupportFragmentManager(), "new-list");
+    }
 
-  @Override public void onNewItemClicked(long listId) {
-    NewItemFragment.newInstance(listId).show(getSupportFragmentManager(), "new-item");
-  }
+    @Override
+    public void onNewItemClicked(long listId) {
+        NewItemFragment.newInstance(listId).show(getSupportFragmentManager(), "new-item");
+    }
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
index 6102a8f..9b04e77 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
@@ -26,12 +26,15 @@
 import android.view.LayoutInflater;
 import android.view.View;
 import android.widget.EditText;
+
 import com.example.sqlbrite.todo.R;
 import com.example.sqlbrite.todo.TodoApp;
 import com.example.sqlbrite.todo.db.TodoItem;
 import com.jakewharton.rxbinding.widget.RxTextView;
 import com.squareup.sqlbrite.BriteDatabase;
+
 import javax.inject.Inject;
+
 import rx.Observable;
 import rx.functions.Action1;
 import rx.functions.Func2;
@@ -41,61 +44,66 @@
 import static butterknife.ButterKnife.findById;
 
 public final class NewItemFragment extends DialogFragment {
-  private static final String KEY_LIST_ID = "list_id";
-
-  public static NewItemFragment newInstance(long listId) {
-    Bundle arguments = new Bundle();
-    arguments.putLong(KEY_LIST_ID, listId);
-
-    NewItemFragment fragment = new NewItemFragment();
-    fragment.setArguments(arguments);
-    return fragment;
-  }
+    private static final String KEY_LIST_ID = "list_id";
+    private final PublishSubject<String> createClicked = PublishSubject.create();
+    @Inject BriteDatabase db;
 
-  private final PublishSubject<String> createClicked = PublishSubject.create();
+    public static NewItemFragment newInstance(long listId) {
+        Bundle arguments = new Bundle();
+        arguments.putLong(KEY_LIST_ID, listId);
 
-  @Inject BriteDatabase db;
+        NewItemFragment fragment = new NewItemFragment();
+        fragment.setArguments(arguments);
+        return fragment;
+    }
 
-  private long getListId() {
-    return getArguments().getLong(KEY_LIST_ID);
-  }
+    private long getListId() {
+        return getArguments().getLong(KEY_LIST_ID);
+    }
 
-  @Override public void onAttach(Activity activity) {
-    super.onAttach(activity);
-    TodoApp.objectGraph(activity).inject(this);
-  }
+    @Override
+    public void onAttach(Activity activity) {
+        super.onAttach(activity);
+        TodoApp.objectGraph(activity).inject(this);
+    }
 
-  @NonNull @Override public Dialog onCreateDialog(Bundle savedInstanceState) {
-    final Context context = getActivity();
-    View view = LayoutInflater.from(context).inflate(R.layout.new_item, null);
+    @NonNull
+    @Override
+    public Dialog onCreateDialog(Bundle savedInstanceState) {
+        final Context context = getActivity();
+        View view = LayoutInflater.from(context).inflate(R.layout.new_item, null);
 
-    EditText name = findById(view, android.R.id.input);
-    Observable.combineLatest(createClicked, RxTextView.textChanges(name),
-        new Func2<String, CharSequence, String>() {
-          @Override public String call(String ignored, CharSequence text) {
-            return text.toString();
-          }
-        }) //
-        .observeOn(Schedulers.io())
-        .subscribe(new Action1<String>() {
-          @Override public void call(String description) {
-            db.insert(TodoItem.TABLE,
-                new TodoItem.Builder().listId(getListId()).description(description).build());
-          }
-        });
+        EditText name = findById(view, android.R.id.input);
+        Observable.combineLatest(createClicked, RxTextView.textChanges(name),
+                new Func2<String, CharSequence, String>() {
+                    @Override
+                    public String call(String ignored, CharSequence text) {
+                        return text.toString();
+                    }
+                }) //
+                .observeOn(Schedulers.io())
+                .subscribe(new Action1<String>() {
+                    @Override
+                    public void call(String description) {
+                        db.insert(TodoItem.TABLE,
+                                new TodoItem.Builder().listId(getListId()).description(description).build());
+                    }
+                });
 
-    return new AlertDialog.Builder(context) //
-        .setTitle(R.string.new_item)
-        .setView(view)
-        .setPositiveButton(R.string.create, new DialogInterface.OnClickListener() {
-          @Override public void onClick(DialogInterface dialog, int which) {
-            createClicked.onNext("clicked");
-          }
-        })
-        .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
-          @Override public void onClick(@NonNull DialogInterface dialog, int which) {
-          }
-        })
-        .create();
-  }
+        return new AlertDialog.Builder(context) //
+                .setTitle(R.string.new_item)
+                .setView(view)
+                .setPositiveButton(R.string.create, new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        createClicked.onNext("clicked");
+                    }
+                })
+                .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(@NonNull DialogInterface dialog, int which) {
+                    }
+                })
+                .create();
+    }
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
index 2a14c60..7d0c807 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
@@ -26,12 +26,15 @@
 import android.view.LayoutInflater;
 import android.view.View;
 import android.widget.EditText;
+
 import com.example.sqlbrite.todo.R;
 import com.example.sqlbrite.todo.TodoApp;
 import com.example.sqlbrite.todo.db.TodoList;
 import com.jakewharton.rxbinding.widget.RxTextView;
 import com.squareup.sqlbrite.BriteDatabase;
+
 import javax.inject.Inject;
+
 import rx.Observable;
 import rx.functions.Action1;
 import rx.functions.Func2;
@@ -41,49 +44,55 @@
 import static butterknife.ButterKnife.findById;
 
 public final class NewListFragment extends DialogFragment {
-  public static NewListFragment newInstance() {
-    return new NewListFragment();
-  }
-
-  private final PublishSubject<String> createClicked = PublishSubject.create();
+    private final PublishSubject<String> createClicked = PublishSubject.create();
+    @Inject BriteDatabase db;
 
-  @Inject BriteDatabase db;
+    public static NewListFragment newInstance() {
+        return new NewListFragment();
+    }
 
-  @Override public void onAttach(Activity activity) {
-    super.onAttach(activity);
-    TodoApp.objectGraph(activity).inject(this);
-  }
+    @Override
+    public void onAttach(Activity activity) {
+        super.onAttach(activity);
+        TodoApp.objectGraph(activity).inject(this);
+    }
 
-  @NonNull @Override public Dialog onCreateDialog(Bundle savedInstanceState) {
-    final Context context = getActivity();
-    View view = LayoutInflater.from(context).inflate(R.layout.new_list, null);
+    @NonNull
+    @Override
+    public Dialog onCreateDialog(Bundle savedInstanceState) {
+        final Context context = getActivity();
+        View view = LayoutInflater.from(context).inflate(R.layout.new_list, null);
 
-    EditText name = findById(view, android.R.id.input);
-    Observable.combineLatest(createClicked, RxTextView.textChanges(name),
-        new Func2<String, CharSequence, String>() {
-          @Override public String call(String ignored, CharSequence text) {
-            return text.toString();
-          }
-        }) //
-        .observeOn(Schedulers.io())
-        .subscribe(new Action1<String>() {
-          @Override public void call(String name) {
-            db.insert(TodoList.TABLE, new TodoList.Builder().name(name).build());
-          }
-        });
+        EditText name = findById(view, android.R.id.input);
+        Observable.combineLatest(createClicked, RxTextView.textChanges(name),
+                new Func2<String, CharSequence, String>() {
+                    @Override
+                    public String call(String ignored, CharSequence text) {
+                        return text.toString();
+                    }
+                }) //
+                .observeOn(Schedulers.io())
+                .subscribe(new Action1<String>() {
+                    @Override
+                    public void call(String name) {
+                        db.insert(TodoList.TABLE, new TodoList.Builder().name(name).build());
+                    }
+                });
 
-    return new AlertDialog.Builder(context) //
-        .setTitle(R.string.new_list)
-        .setView(view)
-        .setPositiveButton(R.string.create, new DialogInterface.OnClickListener() {
-          @Override public void onClick(DialogInterface dialog, int which) {
-            createClicked.onNext("clicked");
-          }
-        })
-        .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
-          @Override public void onClick(@NonNull DialogInterface dialog, int which) {
-          }
-        })
-        .create();
-  }
+        return new AlertDialog.Builder(context) //
+                .setTitle(R.string.new_list)
+                .setView(view)
+                .setPositiveButton(R.string.create, new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        createClicked.onNext("clicked");
+                    }
+                })
+                .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(@NonNull DialogInterface dialog, int which) {
+                    }
+                })
+                .create();
+    }
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/UiModule.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/UiModule.java
index 1e3c8a5..0453023 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/UiModule.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/UiModule.java
@@ -18,14 +18,14 @@
 import dagger.Module;
 
 @Module(
-    injects = {
-        ItemsFragment.class,
-        ListsFragment.class,
-        NewItemFragment.class,
-        NewListFragment.class
-    },
-    complete = false,
-    library = true
+        injects = {
+                ItemsFragment.class,
+                ListsFragment.class,
+                NewItemFragment.class,
+                NewListFragment.class
+        },
+        complete = false,
+        library = true
 )
 public final class UiModule {
 }
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/BackpressureBufferLastOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/BackpressureBufferLastOperator.java
index 16ab987..7fdbfe8 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/BackpressureBufferLastOperator.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/BackpressureBufferLastOperator.java
@@ -19,99 +19,107 @@
 import rx.Producer;
 import rx.Subscriber;
 
-/** An operator which keeps the last emitted instance when backpressure has been applied. */
+/**
+ * An operator which keeps the last emitted instance when backpressure has been applied.
+ */
 final class BackpressureBufferLastOperator<T> implements Operator<T, T> {
-  static final Operator<Object, Object> instance = new BackpressureBufferLastOperator<>();
-
-  static <T> Operator<T, T> instance() {
-    //noinspection unchecked
-    return (Operator<T, T>) instance;
-  }
-
-  private BackpressureBufferLastOperator() {
-  }
+    static final Operator<Object, Object> instance = new BackpressureBufferLastOperator<>();
 
-  @Override public Subscriber<? super T> call(final Subscriber<? super T> child) {
-    BufferLastSubscriber<T> parent = new BufferLastSubscriber<>(child);
-    child.add(parent);
-    child.setProducer(parent.producer);
-    return parent;
-  }
+    private BackpressureBufferLastOperator() {
+    }
 
-  static final class BufferLastSubscriber<T> extends Subscriber<T> {
-    private static final Object NONE = new Object();
+    static <T> Operator<T, T> instance() {
+        //noinspection unchecked
+        return (Operator<T, T>) instance;
+    }
 
-    private final Subscriber<? super T> child;
+    @Override
+    public Subscriber<? super T> call(final Subscriber<? super T> child) {
+        BufferLastSubscriber<T> parent = new BufferLastSubscriber<>(child);
+        child.add(parent);
+        child.setProducer(parent.producer);
+        return parent;
+    }
 
-    private Object last = NONE; // Guarded by 'this'.
-    private long requested; // Guarded by 'this'. Starts at zero.
+    static final class BufferLastSubscriber<T> extends Subscriber<T> {
+        private static final Object NONE = new Object();
+
+        private final Subscriber<? super T> child;
+
+        private Object last = NONE; // Guarded by 'this'.
+        private long requested; // Guarded by 'this'. Starts at zero.
+
+        final Producer producer = new Producer() {
+            @Override
+            public void request(long n) {
+                if (n < 0) {
+                    throw new IllegalArgumentException("requested " + n + " < 0");
+                }
+                if (n == 0) {
+                    return;
+                }
+
+                Object candidate;
+                synchronized (BufferLastSubscriber.this) {
+                    candidate = last;
+
+                    long currentRequested = requested;
+                    if (Long.MAX_VALUE - n <= currentRequested) {
+                        requested = Long.MAX_VALUE;
+                    } else {
+                        if (candidate != NONE) {
+                            n--; // Decrement since we will be emitting a value.
+                        }
+                        requested = currentRequested + n;
+                    }
+                }
+
+                // Only emit if the value is not the explicit NONE marker.
+                if (candidate != NONE) {
+                    //noinspection unchecked
+                    child.onNext((T) candidate);
+                }
+            }
+        };
 
-    final Producer producer = new Producer() {
-      @Override public void request(long n) {
-        if (n < 0) {
-          throw new IllegalArgumentException("requested " + n + " < 0");
-        }
-        if (n == 0) {
-          return;
+        public BufferLastSubscriber(Subscriber<? super T> child) {
+            this.child = child;
         }
 
-        Object candidate;
-        synchronized (BufferLastSubscriber.this) {
-          candidate = last;
+        @Override
+        public void onNext(T t) {
+            boolean emit = false;
+            synchronized (this) {
+                long currentRequested = requested;
+                if (currentRequested == Long.MAX_VALUE) {
+                    // No need to decrement when the firehose is open.
+                    emit = true;
+                } else if (currentRequested > 0) {
+                    requested = currentRequested - 1;
+                    emit = true;
+                } else {
+                    last = t; // Not emitting, store for later.
+                }
+            }
 
-          long currentRequested = requested;
-          if (Long.MAX_VALUE - n <= currentRequested) {
-            requested = Long.MAX_VALUE;
-          } else {
-            if (candidate != NONE) {
-              n--; // Decrement since we will be emitting a value.
+            if (emit) {
+                child.onNext(t);
             }
-            requested = currentRequested + n;
-          }
         }
 
-        // Only emit if the value is not the explicit NONE marker.
-        if (candidate != NONE) {
-          //noinspection unchecked
-          child.onNext((T) candidate);
+        @Override
+        public void onStart() {
+            request(Long.MAX_VALUE);
         }
-      }
-    };
 
-    public BufferLastSubscriber(Subscriber<? super T> child) {
-      this.child = child;
-    }
-
-    @Override public void onNext(T t) {
-      boolean emit = false;
-      synchronized (this) {
-        long currentRequested = requested;
-        if (currentRequested == Long.MAX_VALUE) {
-          // No need to decrement when the firehose is open.
-          emit = true;
-        } else if (currentRequested > 0) {
-          requested = currentRequested - 1;
-          emit = true;
-        } else {
-          last = t; // Not emitting, store for later.
+        @Override
+        public void onCompleted() {
+            child.onCompleted();
         }
-      }
 
-      if (emit) {
-        child.onNext(t);
-      }
-    }
-
-    @Override public void onStart() {
-      request(Long.MAX_VALUE);
-    }
-
-    @Override public void onCompleted() {
-      child.onCompleted();
-    }
-
-    @Override public void onError(Throwable e) {
-      child.onError(e);
+        @Override
+        public void onError(Throwable e) {
+            child.onError(e);
+        }
     }
-  }
 }
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
index 4a22cc3..1289b06 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
@@ -24,7 +24,9 @@
 import android.support.annotation.CheckResult;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+
 import java.util.Arrays;
+
 import rx.Observable;
 import rx.Observable.OnSubscribe;
 import rx.Subscriber;
@@ -39,79 +41,86 @@
  * the result of a query. Create using a {@link SqlBrite} instance.
  */
 public final class BriteContentResolver {
-  private final Handler contentObserverHandler = new Handler(Looper.getMainLooper());
+    private final Handler contentObserverHandler = new Handler(Looper.getMainLooper());
 
-  private final ContentResolver contentResolver;
-  private final Logger logger;
+    private final ContentResolver contentResolver;
+    private final Logger logger;
 
-  private volatile boolean logging;
+    private volatile boolean logging;
 
-  BriteContentResolver(@NonNull ContentResolver contentResolver, @NonNull Logger logger) {
-    this.contentResolver = contentResolver;
-    this.logger = logger;
-  }
+    BriteContentResolver(@NonNull ContentResolver contentResolver, @NonNull Logger logger) {
+        this.contentResolver = contentResolver;
+        this.logger = logger;
+    }
 
-  /** Control whether debug logging is enabled. */
-  public void setLoggingEnabled(boolean enabled) {
-    logging = enabled;
-  }
+    /**
+     * Control whether debug logging is enabled.
+     */
+    public void setLoggingEnabled(boolean enabled) {
+        logging = enabled;
+    }
 
-  /**
-   * Create an observable which will notify subscribers with a {@linkplain Query query} for
-   * execution. Subscribers are responsible for <b>always</b> closing {@link Cursor} instance
-   * returned from the {@link Query}.
-   * <p>
-   * Subscribers will receive an immediate notification for initial data as well as subsequent
-   * notifications for when the supplied {@code uri}'s data changes. Unsubscribe when you no longer
-   * want updates to a query.
-   * <p>
-   * Note: To skip the immediate notification and only receive subsequent notifications when data
-   * has changed call {@code skip(1)} on the returned observable.
-   * <p>
-   * <b>Warning:</b> this method does not perform the query! Only by subscribing to the returned
-   * {@link Observable} will the operation occur.
-   *
-   * @see ContentResolver#query(Uri, String[], String, String[], String)
-   * @see ContentResolver#registerContentObserver(Uri, boolean, ContentObserver)
-   */
-  @CheckResult @NonNull
-  public QueryObservable createQuery(@NonNull final Uri uri, @Nullable final String[] projection,
-      @Nullable final String selection, @Nullable final String[] selectionArgs, @Nullable
-      final String sortOrder, final boolean notifyForDescendents) {
-    final Query query = new Query() {
-      @Override public Cursor run() {
-        return contentResolver.query(uri, projection, selection, selectionArgs, sortOrder);
-      }
-    };
-    OnSubscribe<Query> subscribe = new OnSubscribe<Query>() {
-      @Override public void call(final Subscriber<? super Query> subscriber) {
-        final ContentObserver observer = new ContentObserver(contentObserverHandler) {
-          @Override public void onChange(boolean selfChange) {
-            if (logging) {
-              log("QUERY\n  uri: %s\n  projection: %s\n  selection: %s\n  selectionArgs: %s\n  "
-                      + "sortOrder: %s\n  notifyForDescendents: %s", uri,
-                  Arrays.toString(projection), selection, Arrays.toString(selectionArgs), sortOrder,
-                  notifyForDescendents);
+    /**
+     * Create an observable which will notify subscribers with a {@linkplain Query query} for
+     * execution. Subscribers are responsible for <b>always</b> closing {@link Cursor} instance
+     * returned from the {@link Query}.
+     * <p/>
+     * Subscribers will receive an immediate notification for initial data as well as subsequent
+     * notifications for when the supplied {@code uri}'s data changes. Unsubscribe when you no longer
+     * want updates to a query.
+     * <p/>
+     * Note: To skip the immediate notification and only receive subsequent notifications when data
+     * has changed call {@code skip(1)} on the returned observable.
+     * <p/>
+     * <b>Warning:</b> this method does not perform the query! Only by subscribing to the returned
+     * {@link Observable} will the operation occur.
+     *
+     * @see ContentResolver#query(Uri, String[], String, String[], String)
+     * @see ContentResolver#registerContentObserver(Uri, boolean, ContentObserver)
+     */
+    @CheckResult
+    @NonNull
+    public QueryObservable createQuery(@NonNull final Uri uri, @Nullable final String[] projection,
+                                       @Nullable final String selection, @Nullable final String[] selectionArgs, @Nullable
+                                       final String sortOrder, final boolean notifyForDescendents) {
+        final Query query = new Query() {
+            @Override
+            public Cursor run() {
+                return contentResolver.query(uri, projection, selection, selectionArgs, sortOrder);
+            }
+        };
+        OnSubscribe<Query> subscribe = new OnSubscribe<Query>() {
+            @Override
+            public void call(final Subscriber<? super Query> subscriber) {
+                final ContentObserver observer = new ContentObserver(contentObserverHandler) {
+                    @Override
+                    public void onChange(boolean selfChange) {
+                        if (logging) {
+                            log("QUERY\n  uri: %s\n  projection: %s\n  selection: %s\n  selectionArgs: %s\n  "
+                                            + "sortOrder: %s\n  notifyForDescendents: %s", uri,
+                                    Arrays.toString(projection), selection, Arrays.toString(selectionArgs), sortOrder,
+                                    notifyForDescendents);
+                        }
+                        subscriber.onNext(query);
+                    }
+                };
+                contentResolver.registerContentObserver(uri, notifyForDescendents, observer);
+                subscriber.add(Subscriptions.create(new Action0() {
+                    @Override
+                    public void call() {
+                        contentResolver.unregisterContentObserver(observer);
+                    }
+                }));
             }
-            subscriber.onNext(query);
-          }
         };
-        contentResolver.registerContentObserver(uri, notifyForDescendents, observer);
-        subscriber.add(Subscriptions.create(new Action0() {
-          @Override public void call() {
-            contentResolver.unregisterContentObserver(observer);
-          }
-        }));
-      }
-    };
-    Observable<Query> queryObservable = Observable.create(subscribe) //
-        .startWith(query) //
-        .lift(BackpressureBufferLastOperator.<Query>instance());
-    return new QueryObservable(queryObservable);
-  }
+        Observable<Query> queryObservable = Observable.create(subscribe) //
+                .startWith(query) //
+                .lift(BackpressureBufferLastOperator.<Query>instance());
+        return new QueryObservable(queryObservable);
+    }
 
-  private void log(String message, Object... args) {
-    if (args.length > 0) message = String.format(message, args);
-    logger.log(message);
-  }
+    private void log(String message, Object... args) {
+        if (args.length > 0) message = String.format(message, args);
+        logger.log(message);
+    }
 }
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
index 1c36857..69ff01f 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
@@ -24,7 +24,9 @@
 import android.support.annotation.IntDef;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+
 import com.squareup.sqlbrite.SqlBrite.Query;
+
 import java.io.Closeable;
 import java.io.IOException;
 import java.lang.annotation.Retention;
@@ -33,6 +35,7 @@
 import java.util.LinkedHashSet;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
+
 import rx.Observable;
 import rx.functions.Func1;
 import rx.subjects.PublishSubject;
@@ -50,559 +53,577 @@
  * the result of a query. Create using a {@link SqlBrite} instance.
  */
 public final class BriteDatabase implements Closeable {
-  private static final Set<String> INITIAL_TRIGGER = Collections.singleton("<initial>");
+    private static final Set<String> INITIAL_TRIGGER = Collections.singleton("<initial>");
+    // Package-private to avoid synthetic accessor method for 'transaction' instance.
+    final ThreadLocal<SqliteTransaction> transactions = new ThreadLocal<>();
+    private final SQLiteOpenHelper helper;
+    private final SqlBrite.Logger logger;
+    /**
+     * Publishes sets of tables which have changed.
+     */
+    private final PublishSubject<Set<String>> triggers = PublishSubject.create();
+    private final Object databaseLock = new Object();
+    // Package-private to avoid synthetic accessor method for 'transaction' instance.
+    volatile boolean logging;
+    // Read and write guarded by 'databaseLock'. Lazily initialized. Use methods to access.
+    private volatile SQLiteDatabase readableDatabase;
+    private volatile SQLiteDatabase writeableDatabase;
+    private final Transaction transaction = new Transaction() {
+        @Override
+        public void markSuccessful() {
+            if (logging) log("TXN SUCCESS %s", transactions.get());
+            getWriteableDatabase().setTransactionSuccessful();
+        }
 
-  private final SQLiteOpenHelper helper;
-  private final SqlBrite.Logger logger;
+        @Override
+        public boolean yieldIfContendedSafely() {
+            return getWriteableDatabase().yieldIfContendedSafely();
+        }
 
-  // Package-private to avoid synthetic accessor method for 'transaction' instance.
-  final ThreadLocal<SqliteTransaction> transactions = new ThreadLocal<>();
-  /** Publishes sets of tables which have changed. */
-  private final PublishSubject<Set<String>> triggers = PublishSubject.create();
+        @Override
+        public boolean yieldIfContendedSafely(long sleepAmount, TimeUnit sleepUnit) {
+            return getWriteableDatabase().yieldIfContendedSafely(sleepUnit.toMillis(sleepAmount));
+        }
 
-  private final Transaction transaction = new Transaction() {
-    @Override public void markSuccessful() {
-      if (logging) log("TXN SUCCESS %s", transactions.get());
-      getWriteableDatabase().setTransactionSuccessful();
-    }
+        @Override
+        public void end() {
+            SqliteTransaction transaction = transactions.get();
+            if (transaction == null) {
+                throw new IllegalStateException("Not in transaction.");
+            }
+            SqliteTransaction newTransaction = transaction.parent;
+            transactions.set(newTransaction);
+            if (logging) log("TXN END %s", transaction);
+            getWriteableDatabase().endTransaction();
+            // Send the triggers after ending the transaction in the DB.
+            if (transaction.commit) {
+                sendTableTrigger(transaction);
+            }
+        }
 
-    @Override public boolean yieldIfContendedSafely() {
-      return getWriteableDatabase().yieldIfContendedSafely();
-    }
+        @Override
+        public void close() {
+            end();
+        }
+    };
 
-    @Override public boolean yieldIfContendedSafely(long sleepAmount, TimeUnit sleepUnit) {
-      return getWriteableDatabase().yieldIfContendedSafely(sleepUnit.toMillis(sleepAmount));
+    BriteDatabase(@NonNull SQLiteOpenHelper helper, @NonNull SqlBrite.Logger logger) {
+        this.helper = helper;
+        this.logger = logger;
     }
 
-    @Override public void end() {
-      SqliteTransaction transaction = transactions.get();
-      if (transaction == null) {
-        throw new IllegalStateException("Not in transaction.");
-      }
-      SqliteTransaction newTransaction = transaction.parent;
-      transactions.set(newTransaction);
-      if (logging) log("TXN END %s", transaction);
-      getWriteableDatabase().endTransaction();
-      // Send the triggers after ending the transaction in the DB.
-      if (transaction.commit) {
-        sendTableTrigger(transaction);
-      }
+    private static String conflictString(@ConflictAlgorithm int conflictAlgorithm) {
+        switch (conflictAlgorithm) {
+            case CONFLICT_ABORT:
+                return "abort";
+            case CONFLICT_FAIL:
+                return "fail";
+            case CONFLICT_IGNORE:
+                return "ignore";
+            case CONFLICT_NONE:
+                return "none";
+            case CONFLICT_REPLACE:
+                return "replace";
+            case CONFLICT_ROLLBACK:
+                return "rollback";
+            default:
+                return "unknown (" + conflictAlgorithm + ')';
+        }
     }
 
-    @Override public void close() {
-      end();
+    /**
+     * Control whether debug logging is enabled.
+     */
+    public void setLoggingEnabled(boolean enabled) {
+        logging = enabled;
     }
-  };
-
-  // Read and write guarded by 'databaseLock'. Lazily initialized. Use methods to access.
-  private volatile SQLiteDatabase readableDatabase;
-  private volatile SQLiteDatabase writeableDatabase;
-  private final Object databaseLock = new Object();
-
-  // Package-private to avoid synthetic accessor method for 'transaction' instance.
-  volatile boolean logging;
-
-  BriteDatabase(@NonNull SQLiteOpenHelper helper, @NonNull SqlBrite.Logger logger) {
-    this.helper = helper;
-    this.logger = logger;
-  }
-
-  /**
-   * Control whether debug logging is enabled.
-   */
-  public void setLoggingEnabled(boolean enabled) {
-    logging = enabled;
-  }
-
-  private SQLiteDatabase getReadableDatabase() {
-    SQLiteDatabase db = readableDatabase;
-    if (db == null) {
-      synchronized (databaseLock) {
-        db = readableDatabase;
+
+    private SQLiteDatabase getReadableDatabase() {
+        SQLiteDatabase db = readableDatabase;
         if (db == null) {
-          if (logging) log("Creating readable database");
-          db = readableDatabase = helper.getReadableDatabase();
+            synchronized (databaseLock) {
+                db = readableDatabase;
+                if (db == null) {
+                    if (logging) log("Creating readable database");
+                    db = readableDatabase = helper.getReadableDatabase();
+                }
+            }
         }
-      }
+        return db;
     }
-    return db;
-  }
-
-  // Package-private to avoid synthetic accessor method for 'transaction' instance.
-  SQLiteDatabase getWriteableDatabase() {
-    SQLiteDatabase db = writeableDatabase;
-    if (db == null) {
-      synchronized (databaseLock) {
-        db = writeableDatabase;
+
+    // Package-private to avoid synthetic accessor method for 'transaction' instance.
+    SQLiteDatabase getWriteableDatabase() {
+        SQLiteDatabase db = writeableDatabase;
         if (db == null) {
-          if (logging) log("Creating writeable database");
-          db = writeableDatabase = helper.getWritableDatabase();
+            synchronized (databaseLock) {
+                db = writeableDatabase;
+                if (db == null) {
+                    if (logging) log("Creating writeable database");
+                    db = writeableDatabase = helper.getWritableDatabase();
+                }
+            }
         }
-      }
+        return db;
     }
-    return db;
-  }
-
-  private void sendTableTrigger(Set<String> tables) {
-    SqliteTransaction transaction = transactions.get();
-    if (transaction != null) {
-      transaction.addAll(tables);
-    } else {
-      if (logging) log("TRIGGER %s", tables);
-      triggers.onNext(tables);
+
+    private void sendTableTrigger(Set<String> tables) {
+        SqliteTransaction transaction = transactions.get();
+        if (transaction != null) {
+            transaction.addAll(tables);
+        } else {
+            if (logging) log("TRIGGER %s", tables);
+            triggers.onNext(tables);
+        }
     }
-  }
-
-  /**
-   * Begin a transaction for this thread.
-   * <p>
-   * Transactions may nest. If the transaction is not in progress, then a database connection is
-   * obtained and a new transaction is started. Otherwise, a nested transaction is started.
-   * <p>
-   * Each call to {@code newTransaction} must be matched exactly by a call to
-   * {@link Transaction#end()}. To mark a transaction as successful, call
-   * {@link Transaction#markSuccessful()} before calling {@link Transaction#end()}. If the
-   * transaction is not successful, or if any of its nested transactions were not successful, then
-   * the entire transaction will be rolled back when the outermost transaction is ended.
-   * <p>
-   * Transactions queue up all query notifications until they have been applied.
-   * <p>
-   * Here is the standard idiom for transactions:
-   *
-   * <pre>{@code
-   * try (Transaction transaction = db.newTransaction()) {
-   *   ...
-   *   transaction.markSuccessful();
-   * }
-   * }</pre>
-   *
-   * Manually call {@link Transaction#end()} when try-with-resources is not available:
-   * <pre>{@code
-   * Transaction transaction = db.newTransaction();
-   * try {
-   *   ...
-   *   transaction.markSuccessful();
-   * } finally {
-   *   transaction.end();
-   * }
-   * }</pre>
-   *
-   *
-   * @see SQLiteDatabase#beginTransaction()
-   */
-  @CheckResult @NonNull
-  public Transaction newTransaction() {
-    SqliteTransaction transaction = new SqliteTransaction(transactions.get());
-    transactions.set(transaction);
-    if (logging) log("TXN BEGIN %s", transaction);
-    getWriteableDatabase().beginTransactionWithListener(transaction);
-
-    return this.transaction;
-  }
-
-  /**
-   * Close the underlying {@link SQLiteOpenHelper} and remove cached readable and writeable
-   * databases. This does not prevent existing observables from retaining existing references as
-   * well as attempting to create new ones for new subscriptions.
-   */
-  @Override public void close() throws IOException {
-    synchronized (databaseLock) {
-      readableDatabase = null;
-      writeableDatabase = null;
-      helper.close();
+
+    /**
+     * Begin a transaction for this thread.
+     * <p/>
+     * Transactions may nest. If the transaction is not in progress, then a database connection is
+     * obtained and a new transaction is started. Otherwise, a nested transaction is started.
+     * <p/>
+     * Each call to {@code newTransaction} must be matched exactly by a call to
+     * {@link Transaction#end()}. To mark a transaction as successful, call
+     * {@link Transaction#markSuccessful()} before calling {@link Transaction#end()}. If the
+     * transaction is not successful, or if any of its nested transactions were not successful, then
+     * the entire transaction will be rolled back when the outermost transaction is ended.
+     * <p/>
+     * Transactions queue up all query notifications until they have been applied.
+     * <p/>
+     * Here is the standard idiom for transactions:
+     * <p/>
+     * <pre>{@code
+     * try (Transaction transaction = db.newTransaction()) {
+     *   ...
+     *   transaction.markSuccessful();
+     * }
+     * }</pre>
+     * <p/>
+     * Manually call {@link Transaction#end()} when try-with-resources is not available:
+     * <pre>{@code
+     * Transaction transaction = db.newTransaction();
+     * try {
+     *   ...
+     *   transaction.markSuccessful();
+     * } finally {
+     *   transaction.end();
+     * }
+     * }</pre>
+     *
+     * @see SQLiteDatabase#beginTransaction()
+     */
+    @CheckResult
+    @NonNull
+    public Transaction newTransaction() {
+        SqliteTransaction transaction = new SqliteTransaction(transactions.get());
+        transactions.set(transaction);
+        if (logging) log("TXN BEGIN %s", transaction);
+        getWriteableDatabase().beginTransactionWithListener(transaction);
+
+        return this.transaction;
     }
-  }
-
-  /**
-   * Create an observable which will notify subscribers with a {@linkplain Query query} for
-   * execution. Subscribers are responsible for <b>always</b> closing {@link Cursor} instance
-   * returned from the {@link Query}.
-   * <p>
-   * Subscribers will receive an immediate notification for initial data as well as subsequent
-   * notifications for when the supplied {@code table}'s data changes through the {@code insert},
-   * {@code update}, and {@code delete} methods of this class. Unsubscribe when you no longer want
-   * updates to a query.
-   * <p>
-   * Note: To skip the immediate notification and only receive subsequent notifications when data
-   * has changed call {@code skip(1)} on the returned observable.
-   * <p>
-   * <b>Warning:</b> this method does not perform the query! Only by subscribing to the returned
-   * {@link Observable} will the operation occur.
-   *
-   * @see SQLiteDatabase#rawQuery(String, String[])
-   */
-  @CheckResult @NonNull
-  public QueryObservable createQuery(@NonNull final String table, @NonNull String sql,
-      @NonNull String... args) {
-    Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
-      @Override public Boolean call(Set<String> triggers) {
-        return triggers.contains(table);
-      }
-
-      @Override public String toString() {
-        return table;
-      }
-    };
-    return createQuery(tableFilter, sql, args);
-  }
-
-  /**
-   * See {@link #createQuery(String, String, String...)} for usage. This overload allows for
-   * monitoring multiple tables for changes.
-   *
-   * @see SQLiteDatabase#rawQuery(String, String[])
-   */
-  @CheckResult @NonNull
-  public QueryObservable createQuery(@NonNull final Iterable<String> tables, @NonNull String sql,
-      @NonNull String... args) {
-    Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
-      @Override public Boolean call(Set<String> triggers) {
-        for (String table : tables) {
-          if (triggers.contains(table)) {
-            return true;
-          }
+
+    /**
+     * Close the underlying {@link SQLiteOpenHelper} and remove cached readable and writeable
+     * databases. This does not prevent existing observables from retaining existing references as
+     * well as attempting to create new ones for new subscriptions.
+     */
+    @Override
+    public void close() throws IOException {
+        synchronized (databaseLock) {
+            readableDatabase = null;
+            writeableDatabase = null;
+            helper.close();
         }
-        return false;
-      }
+    }
 
-      @Override public String toString() {
-        return tables.toString();
-      }
-    };
-    return createQuery(tableFilter, sql, args);
-  }
-
-  @CheckResult @NonNull
-  private QueryObservable createQuery(final Func1<Set<String>, Boolean> tableFilter,
-      final String sql, final String... args) {
-    if (transactions.get() != null) {
-      throw new IllegalStateException("Cannot create observable query in transaction. "
-          + "Use query() for a query inside a transaction.");
+    /**
+     * Create an observable which will notify subscribers with a {@linkplain Query query} for
+     * execution. Subscribers are responsible for <b>always</b> closing {@link Cursor} instance
+     * returned from the {@link Query}.
+     * <p/>
+     * Subscribers will receive an immediate notification for initial data as well as subsequent
+     * notifications for when the supplied {@code table}'s data changes through the {@code insert},
+     * {@code update}, and {@code delete} methods of this class. Unsubscribe when you no longer want
+     * updates to a query.
+     * <p/>
+     * Note: To skip the immediate notification and only receive subsequent notifications when data
+     * has changed call {@code skip(1)} on the returned observable.
+     * <p/>
+     * <b>Warning:</b> this method does not perform the query! Only by subscribing to the returned
+     * {@link Observable} will the operation occur.
+     *
+     * @see SQLiteDatabase#rawQuery(String, String[])
+     */
+    @CheckResult
+    @NonNull
+    public QueryObservable createQuery(@NonNull final String table, @NonNull String sql,
+                                       @NonNull String... args) {
+        Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
+            @Override
+            public Boolean call(Set<String> triggers) {
+                return triggers.contains(table);
+            }
+
+            @Override
+            public String toString() {
+                return table;
+            }
+        };
+        return createQuery(tableFilter, sql, args);
     }
 
-    final Query query = new Query() {
-      @Override public Cursor run() {
+    /**
+     * See {@link #createQuery(String, String, String...)} for usage. This overload allows for
+     * monitoring multiple tables for changes.
+     *
+     * @see SQLiteDatabase#rawQuery(String, String[])
+     */
+    @CheckResult
+    @NonNull
+    public QueryObservable createQuery(@NonNull final Iterable<String> tables, @NonNull String sql,
+                                       @NonNull String... args) {
+        Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
+            @Override
+            public Boolean call(Set<String> triggers) {
+                for (String table : tables) {
+                    if (triggers.contains(table)) {
+                        return true;
+                    }
+                }
+                return false;
+            }
+
+            @Override
+            public String toString() {
+                return tables.toString();
+            }
+        };
+        return createQuery(tableFilter, sql, args);
+    }
+
+    @CheckResult
+    @NonNull
+    private QueryObservable createQuery(final Func1<Set<String>, Boolean> tableFilter,
+                                        final String sql, final String... args) {
         if (transactions.get() != null) {
-          throw new IllegalStateException("Cannot execute observable query in a transaction.");
+            throw new IllegalStateException("Cannot create observable query in transaction. "
+                    + "Use query() for a query inside a transaction.");
         }
-        return getReadableDatabase().rawQuery(sql, args);
-      }
-
-      @Override public String toString() {
-        return sql;
-      }
-    };
 
-    Observable<Query> queryObservable = triggers //
-        .filter(tableFilter) // Only trigger on tables we care about.
-        .startWith(INITIAL_TRIGGER) // Immediately execute the query for initial value.
-        .map(new Func1<Set<String>, Query>() {
-          @Override public Query call(Set<String> trigger) {
-            if (transactions.get() != null) {
-              throw new IllegalStateException(
-                  "Cannot subscribe to observable query in a transaction.");
+        final Query query = new Query() {
+            @Override
+            public Cursor run() {
+                if (transactions.get() != null) {
+                    throw new IllegalStateException("Cannot execute observable query in a transaction.");
+                }
+                return getReadableDatabase().rawQuery(sql, args);
             }
-            if (logging) {
-              log("QUERY\n  trigger: %s\n  tables: %s\n  sql: %s\n  args: %s", trigger, tableFilter,
-                  sql, Arrays.toString(args));
+
+            @Override
+            public String toString() {
+                return sql;
             }
-            return query;
-          }
-        }) //
-        .lift(BackpressureBufferLastOperator.<Query>instance());
-    return new QueryObservable(queryObservable);
-  }
-
-  /**
-   * Runs the provided SQL and returns a {@link Cursor} over the result set.
-   *
-   * @see SQLiteDatabase#rawQuery(String, String[])
-   */
-  @CheckResult // TODO @WorkerThread
-  public Cursor query(@NonNull String sql, @NonNull String... args) {
-    if (logging) log("QUERY\n  sql: %s\n  args: %s", sql, Arrays.toString(args));
-    return getReadableDatabase().rawQuery(sql, args);
-  }
-
-  /**
-   * Insert a row into the specified {@code table} and notify any subscribed queries.
-   *
-   * @see SQLiteDatabase#insert(String, String, ContentValues)
-   */
-  // TODO @WorkerThread
-  public long insert(@NonNull String table, @NonNull ContentValues values) {
-    return insert(table, values, CONFLICT_NONE);
-  }
-
-  /**
-   * Insert a row into the specified {@code table} and notify any subscribed queries.
-   *
-   * @see SQLiteDatabase#insertWithOnConflict(String, String, ContentValues, int)
-   */
-  // TODO @WorkerThread
-  public long insert(@NonNull String table, @NonNull ContentValues values,
-      @ConflictAlgorithm int conflictAlgorithm) {
-    SQLiteDatabase db = getWriteableDatabase();
-
-    if (logging) {
-      log("INSERT\n  table: %s\n  values: %s\n  conflictAlgorithm: %s", table, values,
-          conflictString(conflictAlgorithm));
+        };
+
+        Observable<Query> queryObservable = triggers //
+                .filter(tableFilter) // Only trigger on tables we care about.
+                .startWith(INITIAL_TRIGGER) // Immediately execute the query for initial value.
+                .map(new Func1<Set<String>, Query>() {
+                    @Override
+                    public Query call(Set<String> trigger) {
+                        if (transactions.get() != null) {
+                            throw new IllegalStateException(
+                                    "Cannot subscribe to observable query in a transaction.");
+                        }
+                        if (logging) {
+                            log("QUERY\n  trigger: %s\n  tables: %s\n  sql: %s\n  args: %s", trigger, tableFilter,
+                                    sql, Arrays.toString(args));
+                        }
+                        return query;
+                    }
+                }) //
+                .lift(BackpressureBufferLastOperator.<Query>instance());
+        return new QueryObservable(queryObservable);
     }
-    long rowId = db.insertWithOnConflict(table, null, values, conflictAlgorithm);
-
-    if (logging) log("INSERT id: %s", rowId);
 
-    if (rowId != -1) {
-      // Only send a table trigger if the insert was successful.
-      sendTableTrigger(Collections.singleton(table));
+    /**
+     * Runs the provided SQL and returns a {@link Cursor} over the result set.
+     *
+     * @see SQLiteDatabase#rawQuery(String, String[])
+     */
+    @CheckResult // TODO @WorkerThread
+    public Cursor query(@NonNull String sql, @NonNull String... args) {
+        if (logging) log("QUERY\n  sql: %s\n  args: %s", sql, Arrays.toString(args));
+        return getReadableDatabase().rawQuery(sql, args);
     }
-    return rowId;
-  }
-
-  /**
-   * Delete rows from the specified {@code table} and notify any subscribed queries. This method
-   * will not trigger a notification if no rows were deleted.
-   *
-   * @see SQLiteDatabase#delete(String, String, String[])
-   */
-  // TODO @WorkerThread
-  public int delete(@NonNull String table, @Nullable String whereClause,
-      @Nullable String... whereArgs) {
-    SQLiteDatabase db = getWriteableDatabase();
-
-    if (logging) {
-      log("DELETE\n  table: %s\n  whereClause: %s\n  whereArgs: %s", table, whereClause,
-          Arrays.toString(whereArgs));
+
+    /**
+     * Insert a row into the specified {@code table} and notify any subscribed queries.
+     *
+     * @see SQLiteDatabase#insert(String, String, ContentValues)
+     */
+    // TODO @WorkerThread
+    public long insert(@NonNull String table, @NonNull ContentValues values) {
+        return insert(table, values, CONFLICT_NONE);
     }
-    int rows = db.delete(table, whereClause, whereArgs);
 
-    if (logging) log("DELETE affected %s %s", rows, rows != 1 ? "rows" : "row");
+    /**
+     * Insert a row into the specified {@code table} and notify any subscribed queries.
+     *
+     * @see SQLiteDatabase#insertWithOnConflict(String, String, ContentValues, int)
+     */
+    // TODO @WorkerThread
+    public long insert(@NonNull String table, @NonNull ContentValues values,
+                       @ConflictAlgorithm int conflictAlgorithm) {
+        SQLiteDatabase db = getWriteableDatabase();
 
-    if (rows > 0) {
-      // Only send a table trigger if rows were affected.
-      sendTableTrigger(Collections.singleton(table));
-    }
-    return rows;
-  }
-
-  /**
-   * Update rows in the specified {@code table} and notify any subscribed queries. This method
-   * will not trigger a notification if no rows were updated.
-   *
-   * @see SQLiteDatabase#update(String, ContentValues, String, String[])
-   */
-  // TODO @WorkerThread
-  public int update(@NonNull String table, @NonNull ContentValues values,
-      @Nullable String whereClause, @Nullable String... whereArgs) {
-    return update(table, values, CONFLICT_NONE, whereClause, whereArgs);
-  }
-
-  /**
-   * Update rows in the specified {@code table} and notify any subscribed queries. This method
-   * will not trigger a notification if no rows were updated.
-   *
-   * @see SQLiteDatabase#updateWithOnConflict(String, ContentValues, String, String[], int)
-   */
-  // TODO @WorkerThread
-  public int update(@NonNull String table, @NonNull ContentValues values,
-      @ConflictAlgorithm int conflictAlgorithm, @Nullable String whereClause,
-      @Nullable String... whereArgs) {
-    SQLiteDatabase db = getWriteableDatabase();
-
-    if (logging) {
-      log("UPDATE\n  table: %s\n  values: %s\n  whereClause: %s\n  whereArgs: %s\n  conflictAlgorithm: %s",
-          table, values, whereClause, Arrays.toString(whereArgs),
-          conflictString(conflictAlgorithm));
-    }
-    int rows = db.updateWithOnConflict(table, values, whereClause, whereArgs, conflictAlgorithm);
+        if (logging) {
+            log("INSERT\n  table: %s\n  values: %s\n  conflictAlgorithm: %s", table, values,
+                    conflictString(conflictAlgorithm));
+        }
+        long rowId = db.insertWithOnConflict(table, null, values, conflictAlgorithm);
 
-    if (logging) log("UPDATE affected %s %s", rows, rows != 1 ? "rows" : "row");
+        if (logging) log("INSERT id: %s", rowId);
 
-    if (rows > 0) {
-      // Only send a table trigger if rows were affected.
-      sendTableTrigger(Collections.singleton(table));
+        if (rowId != -1) {
+            // Only send a table trigger if the insert was successful.
+            sendTableTrigger(Collections.singleton(table));
+        }
+        return rowId;
     }
-    return rows;
-  }
-
-  /**
-   * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
-   * returns data. No data can be returned (such as the number of affected rows). Instead, use
-   * {@link #insert}, {@link #update}, et al, when possible.
-   * <p>
-   * No notifications will be sent to queries if {@code sql} affects the data of a table.
-   *
-   * @see SQLiteDatabase#execSQL(String)
-   */
-  public void execute(String sql) {
-    SQLiteDatabase db = getWriteableDatabase();
-    db.execSQL(sql);
-  }
-
-  /**
-   * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
-   * returns data. No data can be returned (such as the number of affected rows). Instead, use
-   * {@link #insert}, {@link #update}, et al, when possible.
-   * <p>
-   * No notifications will be sent to queries if {@code sql} affects the data of a table.
-   *
-   * @see SQLiteDatabase#execSQL(String, Object[])
-   */
-  public void execute(String sql, Object... args) {
-    SQLiteDatabase db = getWriteableDatabase();
-    db.execSQL(sql, args);
-  }
-
-  /**
-   * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
-   * returns data. No data can be returned (such as the number of affected rows). Instead, use
-   * {@link #insert}, {@link #update}, et al, when possible.
-   * <p>
-   * A notification to queries for {@code table} will be sent after the statement is executed.
-   *
-   * @see SQLiteDatabase#execSQL(String)
-   */
-  public void executeAndTrigger(String table, String sql) {
-    SQLiteDatabase db = getWriteableDatabase();
-    db.execSQL(sql);
-
-    sendTableTrigger(Collections.singleton(table));
-  }
-
-  /**
-   * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
-   * returns data. No data can be returned (such as the number of affected rows). Instead, use
-   * {@link #insert}, {@link #update}, et al, when possible.
-   * <p>
-   * A notification to queries for {@code table} will be sent after the statement is executed.
-   *
-   * @see SQLiteDatabase#execSQL(String, Object[])
-   */
-  public void executeAndTrigger(String table, String sql, Object... args) {
-    SQLiteDatabase db = getWriteableDatabase();
-    db.execSQL(sql, args);
-
-    sendTableTrigger(Collections.singleton(table));
-  }
-
-  /** An in-progress database transaction. */
-  public interface Transaction extends Closeable {
+
     /**
-     * End a transaction. See {@link #newTransaction()} for notes about how to use this and when
-     * transactions are committed and rolled back.
+     * Delete rows from the specified {@code table} and notify any subscribed queries. This method
+     * will not trigger a notification if no rows were deleted.
      *
-     * @see SQLiteDatabase#endTransaction()
+     * @see SQLiteDatabase#delete(String, String, String[])
      */
     // TODO @WorkerThread
-    void end();
+    public int delete(@NonNull String table, @Nullable String whereClause,
+                      @Nullable String... whereArgs) {
+        SQLiteDatabase db = getWriteableDatabase();
+
+        if (logging) {
+            log("DELETE\n  table: %s\n  whereClause: %s\n  whereArgs: %s", table, whereClause,
+                    Arrays.toString(whereArgs));
+        }
+        int rows = db.delete(table, whereClause, whereArgs);
+
+        if (logging) log("DELETE affected %s %s", rows, rows != 1 ? "rows" : "row");
+
+        if (rows > 0) {
+            // Only send a table trigger if rows were affected.
+            sendTableTrigger(Collections.singleton(table));
+        }
+        return rows;
+    }
 
     /**
-     * Marks the current transaction as successful. Do not do any more database work between
-     * calling this and calling {@link #end()}. Do as little non-database work as possible in that
-     * situation too. If any errors are encountered between this and {@link #end()} the transaction
-     * will still be committed.
+     * Update rows in the specified {@code table} and notify any subscribed queries. This method
+     * will not trigger a notification if no rows were updated.
      *
-     * @see SQLiteDatabase#setTransactionSuccessful()
+     * @see SQLiteDatabase#update(String, ContentValues, String, String[])
      */
     // TODO @WorkerThread
-    void markSuccessful();
+    public int update(@NonNull String table, @NonNull ContentValues values,
+                      @Nullable String whereClause, @Nullable String... whereArgs) {
+        return update(table, values, CONFLICT_NONE, whereClause, whereArgs);
+    }
 
     /**
-     * Temporarily end the transaction to let other threads run. The transaction is assumed to be
-     * successful so far. Do not call {@link #markSuccessful()} before calling this. When this
-     * returns a new transaction will have been created but not marked as successful. This assumes
-     * that there are no nested transactions (newTransaction has only been called once) and will
-     * throw an exception if that is not the case.
+     * Update rows in the specified {@code table} and notify any subscribed queries. This method
+     * will not trigger a notification if no rows were updated.
      *
-     * @return true if the transaction was yielded
-     *
-     * @see SQLiteDatabase#yieldIfContendedSafely()
+     * @see SQLiteDatabase#updateWithOnConflict(String, ContentValues, String, String[], int)
      */
     // TODO @WorkerThread
-    boolean yieldIfContendedSafely();
+    public int update(@NonNull String table, @NonNull ContentValues values,
+                      @ConflictAlgorithm int conflictAlgorithm, @Nullable String whereClause,
+                      @Nullable String... whereArgs) {
+        SQLiteDatabase db = getWriteableDatabase();
+
+        if (logging) {
+            log("UPDATE\n  table: %s\n  values: %s\n  whereClause: %s\n  whereArgs: %s\n  conflictAlgorithm: %s",
+                    table, values, whereClause, Arrays.toString(whereArgs),
+                    conflictString(conflictAlgorithm));
+        }
+        int rows = db.updateWithOnConflict(table, values, whereClause, whereArgs, conflictAlgorithm);
+
+        if (logging) log("UPDATE affected %s %s", rows, rows != 1 ? "rows" : "row");
+
+        if (rows > 0) {
+            // Only send a table trigger if rows were affected.
+            sendTableTrigger(Collections.singleton(table));
+        }
+        return rows;
+    }
 
     /**
-     * Temporarily end the transaction to let other threads run. The transaction is assumed to be
-     * successful so far. Do not call {@link #markSuccessful()} before calling this. When this
-     * returns a new transaction will have been created but not marked as successful. This assumes
-     * that there are no nested transactions (newTransaction has only been called once) and will
-     * throw an exception if that is not the case.
+     * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
+     * returns data. No data can be returned (such as the number of affected rows). Instead, use
+     * {@link #insert}, {@link #update}, et al, when possible.
+     * <p/>
+     * No notifications will be sent to queries if {@code sql} affects the data of a table.
      *
-     * @param sleepAmount if > 0, sleep this long before starting a new transaction if
-     *   the lock was actually yielded. This will allow other background threads to make some
-     *   more progress than they would if we started the transaction immediately.
-     * @return true if the transaction was yielded
+     * @see SQLiteDatabase#execSQL(String)
+     */
+    public void execute(String sql) {
+        SQLiteDatabase db = getWriteableDatabase();
+        db.execSQL(sql);
+    }
+
+    /**
+     * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
+     * returns data. No data can be returned (such as the number of affected rows). Instead, use
+     * {@link #insert}, {@link #update}, et al, when possible.
+     * <p/>
+     * No notifications will be sent to queries if {@code sql} affects the data of a table.
      *
-     * @see SQLiteDatabase#yieldIfContendedSafely(long)
+     * @see SQLiteDatabase#execSQL(String, Object[])
      */
-    // TODO @WorkerThread
-    boolean yieldIfContendedSafely(long sleepAmount, TimeUnit sleepUnit);
+    public void execute(String sql, Object... args) {
+        SQLiteDatabase db = getWriteableDatabase();
+        db.execSQL(sql, args);
+    }
 
     /**
-     * Equivalent to calling {@link #end()}
+     * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
+     * returns data. No data can be returned (such as the number of affected rows). Instead, use
+     * {@link #insert}, {@link #update}, et al, when possible.
+     * <p/>
+     * A notification to queries for {@code table} will be sent after the statement is executed.
+     *
+     * @see SQLiteDatabase#execSQL(String)
      */
-    // TODO @WorkerThread
-    @Override void close();
-  }
-
-  @IntDef({
-      CONFLICT_ABORT,
-      CONFLICT_FAIL,
-      CONFLICT_IGNORE,
-      CONFLICT_NONE,
-      CONFLICT_REPLACE,
-      CONFLICT_ROLLBACK
-  })
-  @Retention(SOURCE)
-  public @interface ConflictAlgorithm {
-  }
-
-  private void log(String message, Object... args) {
-    if (args.length > 0) message = String.format(message, args);
-    logger.log(message);
-  }
-
-  private static String conflictString(@ConflictAlgorithm int conflictAlgorithm) {
-    switch (conflictAlgorithm) {
-      case CONFLICT_ABORT:
-        return "abort";
-      case CONFLICT_FAIL:
-        return "fail";
-      case CONFLICT_IGNORE:
-        return "ignore";
-      case CONFLICT_NONE:
-        return "none";
-      case CONFLICT_REPLACE:
-        return "replace";
-      case CONFLICT_ROLLBACK:
-        return "rollback";
-      default:
-        return "unknown (" + conflictAlgorithm + ')';
+    public void executeAndTrigger(String table, String sql) {
+        SQLiteDatabase db = getWriteableDatabase();
+        db.execSQL(sql);
+
+        sendTableTrigger(Collections.singleton(table));
     }
-  }
 
-  static final class SqliteTransaction extends LinkedHashSet<String>
-      implements SQLiteTransactionListener {
-    final SqliteTransaction parent;
-    boolean commit;
+    /**
+     * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
+     * returns data. No data can be returned (such as the number of affected rows). Instead, use
+     * {@link #insert}, {@link #update}, et al, when possible.
+     * <p/>
+     * A notification to queries for {@code table} will be sent after the statement is executed.
+     *
+     * @see SQLiteDatabase#execSQL(String, Object[])
+     */
+    public void executeAndTrigger(String table, String sql, Object... args) {
+        SQLiteDatabase db = getWriteableDatabase();
+        db.execSQL(sql, args);
 
-    SqliteTransaction(SqliteTransaction parent) {
-      this.parent = parent;
+        sendTableTrigger(Collections.singleton(table));
     }
 
-    @Override public void onBegin() {
+    private void log(String message, Object... args) {
+        if (args.length > 0) message = String.format(message, args);
+        logger.log(message);
     }
 
-    @Override public void onCommit() {
-      commit = true;
+    /**
+     * An in-progress database transaction.
+     */
+    public interface Transaction extends Closeable {
+        /**
+         * End a transaction. See {@link #newTransaction()} for notes about how to use this and when
+         * transactions are committed and rolled back.
+         *
+         * @see SQLiteDatabase#endTransaction()
+         */
+        // TODO @WorkerThread
+        void end();
+
+        /**
+         * Marks the current transaction as successful. Do not do any more database work between
+         * calling this and calling {@link #end()}. Do as little non-database work as possible in that
+         * situation too. If any errors are encountered between this and {@link #end()} the transaction
+         * will still be committed.
+         *
+         * @see SQLiteDatabase#setTransactionSuccessful()
+         */
+        // TODO @WorkerThread
+        void markSuccessful();
+
+        /**
+         * Temporarily end the transaction to let other threads run. The transaction is assumed to be
+         * successful so far. Do not call {@link #markSuccessful()} before calling this. When this
+         * returns a new transaction will have been created but not marked as successful. This assumes
+         * that there are no nested transactions (newTransaction has only been called once) and will
+         * throw an exception if that is not the case.
+         *
+         * @return true if the transaction was yielded
+         * @see SQLiteDatabase#yieldIfContendedSafely()
+         */
+        // TODO @WorkerThread
+        boolean yieldIfContendedSafely();
+
+        /**
+         * Temporarily end the transaction to let other threads run. The transaction is assumed to be
+         * successful so far. Do not call {@link #markSuccessful()} before calling this. When this
+         * returns a new transaction will have been created but not marked as successful. This assumes
+         * that there are no nested transactions (newTransaction has only been called once) and will
+         * throw an exception if that is not the case.
+         *
+         * @param sleepAmount if > 0, sleep this long before starting a new transaction if
+         *                    the lock was actually yielded. This will allow other background threads to make some
+         *                    more progress than they would if we started the transaction immediately.
+         * @return true if the transaction was yielded
+         * @see SQLiteDatabase#yieldIfContendedSafely(long)
+         */
+        // TODO @WorkerThread
+        boolean yieldIfContendedSafely(long sleepAmount, TimeUnit sleepUnit);
+
+        /**
+         * Equivalent to calling {@link #end()}
+         */
+        // TODO @WorkerThread
+        @Override
+        void close();
     }
 
-    @Override public void onRollback() {
+    @IntDef({
+            CONFLICT_ABORT,
+            CONFLICT_FAIL,
+            CONFLICT_IGNORE,
+            CONFLICT_NONE,
+            CONFLICT_REPLACE,
+            CONFLICT_ROLLBACK
+    })
+    @Retention(SOURCE)
+    public @interface ConflictAlgorithm {
     }
 
-    @Override public String toString() {
-      String name = String.format("%08x", System.identityHashCode(this));
-      return parent == null ? name : name + " [" + parent.toString() + ']';
+    static final class SqliteTransaction extends LinkedHashSet<String>
+            implements SQLiteTransactionListener {
+        final SqliteTransaction parent;
+        boolean commit;
+
+        SqliteTransaction(SqliteTransaction parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public void onBegin() {
+        }
+
+        @Override
+        public void onCommit() {
+            commit = true;
+        }
+
+        @Override
+        public void onRollback() {
+        }
+
+        @Override
+        public String toString() {
+            String name = String.format("%08x", System.identityHashCode(this));
+            return parent == null ? name : name + " [" + parent.toString() + ']';
+        }
     }
-  }
 }
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java
index a7fe06f..832c387 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java
@@ -3,82 +3,91 @@
 import android.database.Cursor;
 import android.support.annotation.CheckResult;
 import android.support.annotation.NonNull;
+
 import com.squareup.sqlbrite.SqlBrite.Query;
+
 import java.util.List;
+
 import rx.Observable;
 import rx.Subscriber;
 import rx.functions.Func1;
 
-/** An {@link Observable} of {@link Query} which offers query-specific convenience operators. */
+/**
+ * An {@link Observable} of {@link Query} which offers query-specific convenience operators.
+ */
 public final class QueryObservable extends Observable<Query> {
-  QueryObservable(final Observable<Query> o) {
-    super(new OnSubscribe<Query>() {
-      @Override public void call(Subscriber<? super Query> subscriber) {
-        o.unsafeSubscribe(subscriber);
-      }
-    });
-  }
+    QueryObservable(final Observable<Query> o) {
+        super(new OnSubscribe<Query>() {
+            @Override
+            public void call(Subscriber<? super Query> subscriber) {
+                o.unsafeSubscribe(subscriber);
+            }
+        });
+    }
 
-  /**
-   * Given a function mapping the current row of a {@link Cursor} to {@code T}, transform each
-   * emitted {@link Query} which returns a single row to {@code T}.
-   * <p>
-   * It is an error for a query to pass through this operator with more than 1 row in its result
-   * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
-   * do not emit an item.
-   * <p>
-   * This method is equivalent to:
-   * <pre>{@code
-   * flatMap(q -> q.asRows(mapper).take(1))
-   * }</pre>
-   *
-   * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
-   */
-  @CheckResult @NonNull
-  public final <T> Observable<T> mapToOne(@NonNull final Func1<Cursor, T> mapper) {
-    return lift(new QueryToOneOperator<>(mapper, false, null));
-  }
+    /**
+     * Given a function mapping the current row of a {@link Cursor} to {@code T}, transform each
+     * emitted {@link Query} which returns a single row to {@code T}.
+     * <p/>
+     * It is an error for a query to pass through this operator with more than 1 row in its result
+     * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
+     * do not emit an item.
+     * <p/>
+     * This method is equivalent to:
+     * <pre>{@code
+     * flatMap(q -> q.asRows(mapper).take(1))
+     * }</pre>
+     *
+     * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
+     */
+    @CheckResult
+    @NonNull
+    public final <T> Observable<T> mapToOne(@NonNull final Func1<Cursor, T> mapper) {
+        return lift(new QueryToOneOperator<>(mapper, false, null));
+    }
 
-  /**
-   * Given a function mapping the current row of a {@link Cursor} to {@code T}, transform each
-   * emitted {@link Query} which returns a single row to {@code T}.
-   * <p>
-   * It is an error for a query to pass through this operator with more than 1 row in its result
-   * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
-   * emit {@code defaultValue}.
-   * <p>
-   * This method is equivalent to:
-   * <pre>{@code
-   * flatMap(q -> q.asRows(mapper).take(1).defaultIfEmpty(defaultValue))
-   * }</pre>
-   *
-   * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
-   * @param defaultValue Value returned if result set is empty
-   */
-  @CheckResult @NonNull
-  public final <T> Observable<T> mapToOneOrDefault(@NonNull final Func1<Cursor, T> mapper,
-      T defaultValue) {
-    return lift(new QueryToOneOperator<>(mapper, true, defaultValue));
-  }
+    /**
+     * Given a function mapping the current row of a {@link Cursor} to {@code T}, transform each
+     * emitted {@link Query} which returns a single row to {@code T}.
+     * <p/>
+     * It is an error for a query to pass through this operator with more than 1 row in its result
+     * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
+     * emit {@code defaultValue}.
+     * <p/>
+     * This method is equivalent to:
+     * <pre>{@code
+     * flatMap(q -> q.asRows(mapper).take(1).defaultIfEmpty(defaultValue))
+     * }</pre>
+     *
+     * @param mapper       Maps the current {@link Cursor} row to {@code T}. May not return null.
+     * @param defaultValue Value returned if result set is empty
+     */
+    @CheckResult
+    @NonNull
+    public final <T> Observable<T> mapToOneOrDefault(@NonNull final Func1<Cursor, T> mapper,
+                                                     T defaultValue) {
+        return lift(new QueryToOneOperator<>(mapper, true, defaultValue));
+    }
 
-  /**
-   * Given a function mapping the current row of a {@link Cursor} to {@code T}, transform each
-   * emitted {@link Query} to a {@code List<T>}.
-   * <p>
-   * Be careful using this operator as it will always consume the entire cursor and create objects
-   * for each row, every time this observable emits a new query. On tables whose queries update
-   * frequently or very large result sets this can result in the creation of many objects.
-   * <p>
-   * This method is equivalent to:
-   * <pre>{@code
-   * flatMap(q -> q.asRows(mapper).toList())
-   * }</pre>
-   * Consider using {@link Query#asRows} if you need to limit or filter in memory.
-   *
-   * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
-   */
-  @CheckResult @NonNull
-  public final <T> Observable<List<T>> mapToList(@NonNull final Func1<Cursor, T> mapper) {
-    return lift(new QueryToListOperator<>(mapper));
-  }
+    /**
+     * Given a function mapping the current row of a {@link Cursor} to {@code T}, transform each
+     * emitted {@link Query} to a {@code List<T>}.
+     * <p/>
+     * Be careful using this operator as it will always consume the entire cursor and create objects
+     * for each row, every time this observable emits a new query. On tables whose queries update
+     * frequently or very large result sets this can result in the creation of many objects.
+     * <p/>
+     * This method is equivalent to:
+     * <pre>{@code
+     * flatMap(q -> q.asRows(mapper).toList())
+     * }</pre>
+     * Consider using {@link Query#asRows} if you need to limit or filter in memory.
+     *
+     * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
+     */
+    @CheckResult
+    @NonNull
+    public final <T> Observable<List<T>> mapToList(@NonNull final Func1<Cursor, T> mapper) {
+        return lift(new QueryToListOperator<>(mapper));
+    }
 }
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
index ecf2710..070fa1c 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
@@ -1,8 +1,10 @@
 package com.squareup.sqlbrite;
 
 import android.database.Cursor;
+
 import java.util.ArrayList;
 import java.util.List;
+
 import rx.Observable;
 import rx.Subscriber;
 import rx.exceptions.Exceptions;
@@ -10,46 +12,49 @@
 import rx.functions.Func1;
 
 final class QueryToListOperator<T> implements Observable.Operator<List<T>, SqlBrite.Query> {
-  private final Func1<Cursor, T> mapper;
-
-  QueryToListOperator(Func1<Cursor, T> mapper) {
-    this.mapper = mapper;
-  }
-
-  @Override
-  public Subscriber<? super SqlBrite.Query> call(final Subscriber<? super List<T>> subscriber) {
-    return new Subscriber<SqlBrite.Query>(subscriber) {
-      @Override public void onNext(SqlBrite.Query query) {
-        try {
-          Cursor cursor = query.run();
-          List<T> items = new ArrayList<>(cursor.getCount());
-          try {
-            for (int i = 1; cursor.moveToNext() && !subscriber.isUnsubscribed(); i++) {
-              T item = mapper.call(cursor);
-              if (item == null) {
-                throw new NullPointerException("Mapper returned null for row " + i);
-              }
-              items.add(item);
+    private final Func1<Cursor, T> mapper;
+
+    QueryToListOperator(Func1<Cursor, T> mapper) {
+        this.mapper = mapper;
+    }
+
+    @Override
+    public Subscriber<? super SqlBrite.Query> call(final Subscriber<? super List<T>> subscriber) {
+        return new Subscriber<SqlBrite.Query>(subscriber) {
+            @Override
+            public void onNext(SqlBrite.Query query) {
+                try {
+                    Cursor cursor = query.run();
+                    List<T> items = new ArrayList<>(cursor.getCount());
+                    try {
+                        for (int i = 1; cursor.moveToNext() && !subscriber.isUnsubscribed(); i++) {
+                            T item = mapper.call(cursor);
+                            if (item == null) {
+                                throw new NullPointerException("Mapper returned null for row " + i);
+                            }
+                            items.add(item);
+                        }
+                    } finally {
+                        cursor.close();
+                    }
+                    if (!subscriber.isUnsubscribed()) {
+                        subscriber.onNext(items);
+                    }
+                } catch (Throwable e) {
+                    Exceptions.throwIfFatal(e);
+                    onError(OnErrorThrowable.addValueAsLastCause(e, query.toString()));
+                }
+            }
+
+            @Override
+            public void onCompleted() {
+                subscriber.onCompleted();
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                subscriber.onError(e);
             }
-          } finally {
-            cursor.close();
-          }
-          if (!subscriber.isUnsubscribed()) {
-            subscriber.onNext(items);
-          }
-        } catch (Throwable e) {
-          Exceptions.throwIfFatal(e);
-          onError(OnErrorThrowable.addValueAsLastCause(e, query.toString()));
-        }
-      }
-
-      @Override public void onCompleted() {
-        subscriber.onCompleted();
-      }
-
-      @Override public void onError(Throwable e) {
-        subscriber.onError(e);
-      }
-    };
-  }
+        };
+    }
 }
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
index 09f834f..5f01772 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
@@ -1,6 +1,7 @@
 package com.squareup.sqlbrite;
 
 import android.database.Cursor;
+
 import rx.Observable;
 import rx.Subscriber;
 import rx.exceptions.Exceptions;
@@ -8,55 +9,59 @@
 import rx.functions.Func1;
 
 final class QueryToOneOperator<T> implements Observable.Operator<T, SqlBrite.Query> {
-  private final Func1<Cursor, T> mapper;
-  private boolean emitDefault;
-  private T defaultValue;
+    private final Func1<Cursor, T> mapper;
+    private boolean emitDefault;
+    private T defaultValue;
 
-  QueryToOneOperator(Func1<Cursor, T> mapper, boolean emitDefault, T defaultValue) {
-    this.mapper = mapper;
-    this.emitDefault = emitDefault;
-    this.defaultValue = defaultValue;
-  }
+    QueryToOneOperator(Func1<Cursor, T> mapper, boolean emitDefault, T defaultValue) {
+        this.mapper = mapper;
+        this.emitDefault = emitDefault;
+        this.defaultValue = defaultValue;
+    }
 
-  @Override public Subscriber<? super SqlBrite.Query> call(final Subscriber<? super T> subscriber) {
-    return new Subscriber<SqlBrite.Query>(subscriber) {
-      @Override public void onNext(SqlBrite.Query query) {
-        try {
-          T item = null;
-          Cursor cursor = query.run();
-          try {
-            if (cursor.moveToNext()) {
-              item = mapper.call(cursor);
-              if (item == null) {
-                throw new NullPointerException("Mapper returned null for row 1");
-              }
-              if (cursor.moveToNext()) {
-                throw new IllegalStateException("Cursor returned more than 1 row");
-              }
-            }
-          } finally {
-            cursor.close();
-          }
-          if (!subscriber.isUnsubscribed()) {
-            if (item != null) {
-              subscriber.onNext(item);
-            } else if (emitDefault) {
-              subscriber.onNext(defaultValue);
+    @Override
+    public Subscriber<? super SqlBrite.Query> call(final Subscriber<? super T> subscriber) {
+        return new Subscriber<SqlBrite.Query>(subscriber) {
+            @Override
+            public void onNext(SqlBrite.Query query) {
+                try {
+                    T item = null;
+                    Cursor cursor = query.run();
+                    try {
+                        if (cursor.moveToNext()) {
+                            item = mapper.call(cursor);
+                            if (item == null) {
+                                throw new NullPointerException("Mapper returned null for row 1");
+                            }
+                            if (cursor.moveToNext()) {
+                                throw new IllegalStateException("Cursor returned more than 1 row");
+                            }
+                        }
+                    } finally {
+                        cursor.close();
+                    }
+                    if (!subscriber.isUnsubscribed()) {
+                        if (item != null) {
+                            subscriber.onNext(item);
+                        } else if (emitDefault) {
+                            subscriber.onNext(defaultValue);
+                        }
+                    }
+                } catch (Throwable e) {
+                    Exceptions.throwIfFatal(e);
+                    onError(OnErrorThrowable.addValueAsLastCause(e, query.toString()));
+                }
             }
-          }
-        } catch (Throwable e) {
-          Exceptions.throwIfFatal(e);
-          onError(OnErrorThrowable.addValueAsLastCause(e, query.toString()));
-        }
-      }
 
-      @Override public void onCompleted() {
-        subscriber.onCompleted();
-      }
+            @Override
+            public void onCompleted() {
+                subscriber.onCompleted();
+            }
 
-      @Override public void onError(Throwable e) {
-        subscriber.onError(e);
-      }
-    };
-  }
+            @Override
+            public void onError(Throwable e) {
+                subscriber.onError(e);
+            }
+        };
+    }
 }
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
index e930a12..ce0054a 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
@@ -21,6 +21,7 @@
 import android.support.annotation.CheckResult;
 import android.support.annotation.NonNull;
 import android.util.Log;
+
 import rx.Observable;
 import rx.Subscriber;
 import rx.functions.Func1;
@@ -30,94 +31,109 @@
  * the result of a query.
  */
 public final class SqlBrite {
-  @CheckResult @NonNull
-  public static SqlBrite create() {
-    return create(new Logger() {
-      @Override public void log(String message) {
-        Log.d("SqlBrite", message);
-      }
-    });
-  }
+    private final Logger logger;
 
-  @CheckResult @NonNull
-  public static SqlBrite create(@NonNull Logger logger) {
-    return new SqlBrite(logger);
-  }
+    private SqlBrite(@NonNull Logger logger) {
+        this.logger = logger;
+    }
 
-  private final Logger logger;
+    @CheckResult
+    @NonNull
+    public static SqlBrite create() {
+        return create(new Logger() {
+            @Override
+            public void log(String message) {
+                Log.d("SqlBrite", message);
+            }
+        });
+    }
 
-  private SqlBrite(@NonNull Logger logger) {
-    this.logger = logger;
-  }
+    @CheckResult
+    @NonNull
+    public static SqlBrite create(@NonNull Logger logger) {
+        return new SqlBrite(logger);
+    }
 
-  /**
-   * Wrap a {@link SQLiteOpenHelper} for observable queries.
-   * <p>
-   * While not strictly required, instances of this class assume that they will be the only ones
-   * interacting with the underlying {@link SQLiteOpenHelper} and it is required for automatic
-   * notifications of table changes to work. See {@linkplain BriteDatabase#createQuery the
-   * <code>query</code> method} for more information on that behavior.
-   */
-  @CheckResult @NonNull
-  public BriteDatabase wrapDatabaseHelper(@NonNull SQLiteOpenHelper helper) {
-    return new BriteDatabase(helper, logger);
-  }
+    /**
+     * Wrap a {@link SQLiteOpenHelper} for observable queries.
+     * <p/>
+     * While not strictly required, instances of this class assume that they will be the only ones
+     * interacting with the underlying {@link SQLiteOpenHelper} and it is required for automatic
+     * notifications of table changes to work. See {@linkplain BriteDatabase#createQuery the
+     * <code>query</code> method} for more information on that behavior.
+     */
+    @CheckResult
+    @NonNull
+    public BriteDatabase wrapDatabaseHelper(@NonNull SQLiteOpenHelper helper) {
+        return new BriteDatabase(helper, logger);
+    }
 
-  /** Wrap a {@link ContentResolver} for observable queries. */
-  @CheckResult @NonNull
-  public BriteContentResolver wrapContentProvider(@NonNull ContentResolver contentResolver) {
-    return new BriteContentResolver(contentResolver, logger);
-  }
+    /**
+     * Wrap a {@link ContentResolver} for observable queries.
+     */
+    @CheckResult
+    @NonNull
+    public BriteContentResolver wrapContentProvider(@NonNull ContentResolver contentResolver) {
+        return new BriteContentResolver(contentResolver, logger);
+    }
 
-  /** An executable query. */
-  public static abstract class Query {
-    /** Execute the query on the underlying database and return the resulting cursor. */
-    @CheckResult // TODO @WorkerThread
-    // TODO Implementations might return null, which is gross. Throw?
-    public abstract Cursor run();
+    /**
+     * A simple indirection for logging debug messages.
+     */
+    public interface Logger {
+        void log(String message);
+    }
 
     /**
-     * Execute the query on the underlying database and return an Observable of each row mapped to
-     * {@code T} by {@code mapper}.
-     * <p>
-     * Standard usage of this operation is in {@code flatMap}:
-     * <pre>{@code
-     * flatMap(q -> q.asRows(Item.MAPPER).toList())
-     * }</pre>
-     * However, the above is a more-verbose but identical operation as
-     * {@link QueryObservable#mapToList}. This {@code asRows} method should be used when you need
-     * to limit or filter the items separate from the actual query.
-     * <pre>{@code
-     * flatMap(q -> q.asRows(Item.MAPPER).take(5).toList())
-     * // or...
-     * flatMap(q -> q.asRows(Item.MAPPER).filter(i -> i.isActive).toList())
-     * }</pre>
-     * <p>
-     * Note: Limiting results or filtering will almost always be faster in the database as part of
-     * a query and should be preferred, where possible.
+     * An executable query.
      */
-    @CheckResult @NonNull
-    public final <T> Observable<T> asRows(final Func1<Cursor, T> mapper) {
-      return Observable.create(new Observable.OnSubscribe<T>() {
-        @Override public void call(Subscriber<? super T> subscriber) {
-          Cursor cursor = run();
-          try {
-            while (cursor.moveToNext() && !subscriber.isUnsubscribed()) {
-              subscriber.onNext(mapper.call(cursor));
-            }
-          } finally {
-            cursor.close();
-          }
-          if (!subscriber.isUnsubscribed()) {
-            subscriber.onCompleted();
-          }
+    public static abstract class Query {
+        /**
+         * Execute the query on the underlying database and return the resulting cursor.
+         */
+        @CheckResult // TODO @WorkerThread
+        // TODO Implementations might return null, which is gross. Throw?
+        public abstract Cursor run();
+
+        /**
+         * Execute the query on the underlying database and return an Observable of each row mapped to
+         * {@code T} by {@code mapper}.
+         * <p/>
+         * Standard usage of this operation is in {@code flatMap}:
+         * <pre>{@code
+         * flatMap(q -> q.asRows(Item.MAPPER).toList())
+         * }</pre>
+         * However, the above is a more-verbose but identical operation as
+         * {@link QueryObservable#mapToList}. This {@code asRows} method should be used when you need
+         * to limit or filter the items separate from the actual query.
+         * <pre>{@code
+         * flatMap(q -> q.asRows(Item.MAPPER).take(5).toList())
+         * // or...
+         * flatMap(q -> q.asRows(Item.MAPPER).filter(i -> i.isActive).toList())
+         * }</pre>
+         * <p/>
+         * Note: Limiting results or filtering will almost always be faster in the database as part of
+         * a query and should be preferred, where possible.
+         */
+        @CheckResult
+        @NonNull
+        public final <T> Observable<T> asRows(final Func1<Cursor, T> mapper) {
+            return Observable.create(new Observable.OnSubscribe<T>() {
+                @Override
+                public void call(Subscriber<? super T> subscriber) {
+                    Cursor cursor = run();
+                    try {
+                        while (cursor.moveToNext() && !subscriber.isUnsubscribed()) {
+                            subscriber.onNext(mapper.call(cursor));
+                        }
+                    } finally {
+                        cursor.close();
+                    }
+                    if (!subscriber.isUnsubscribed()) {
+                        subscriber.onCompleted();
+                    }
+                }
+            });
         }
-      });
     }
-  }
-
-  /** A simple indirection for logging debug messages. */
-  public interface Logger {
-    void log(String message);
-  }
 }
