diff --git a/build.gradle b/build.gradle
index ca5148a..6bb3c0e 100644
--- a/build.gradle
+++ b/build.gradle
@@ -3,7 +3,7 @@ buildscript {
       'minSdk': 14,
       'compileSdk': 26,
       'buildTools': '26.0.1',
-      'kotlin': '1.1.4-3',
+      'kotlin': '1.1.50',
   ]
 
   repositories {
@@ -13,7 +13,7 @@ buildscript {
   }
 
   dependencies {
-    classpath 'com.android.tools.build:gradle:3.0.0-beta5'
+    classpath 'com.android.tools.build:gradle:3.0.0-beta6'
     classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:${versions.kotlin}"
   }
 }
@@ -51,6 +51,7 @@ ext {
   rxBinding = 'com.jakewharton.rxbinding2:rxbinding:2.0.0'
   junit = 'junit:junit:4.12'
   truth = 'com.google.truth:truth:0.35'
+  sqlcipher = 'net.zetetic:android-database-sqlcipher:3.5.7@aar'
 }
 
 configurations {
diff --git a/sqlbrite/build.gradle b/sqlbrite/build.gradle
index f5972f1..5635e31 100644
--- a/sqlbrite/build.gradle
+++ b/sqlbrite/build.gradle
@@ -3,6 +3,7 @@ apply plugin: 'com.android.library'
 dependencies {
   api rootProject.ext.rxJava
   api rootProject.ext.supportSqlite
+  api rootProject.ext.sqlcipher
   implementation rootProject.ext.supportAnnotations
 
   androidTestImplementation rootProject.ext.supportTestRunner
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/BriteDatabaseTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/BriteDatabaseTest.java
index 7502423..f0f9ff3 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/BriteDatabaseTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/BriteDatabaseTest.java
@@ -16,13 +16,13 @@
 package com.squareup.sqlbrite3;
 
 import android.annotation.TargetApi;
-import android.arch.persistence.db.SimpleSQLiteQuery;
-import android.arch.persistence.db.SupportSQLiteDatabase;
-import android.arch.persistence.db.SupportSQLiteOpenHelper;
-import android.arch.persistence.db.SupportSQLiteOpenHelper.Configuration;
-import android.arch.persistence.db.SupportSQLiteOpenHelper.Factory;
-import android.arch.persistence.db.SupportSQLiteStatement;
-import android.arch.persistence.db.framework.FrameworkSQLiteOpenHelperFactory;
+//import android.arch.persistence.db.SimpleSQLiteQuery;
+//import android.arch.persistence.db.SupportSQLiteDatabase;
+//import android.arch.persistence.db.SupportSQLiteOpenHelper;
+//import android.arch.persistence.db.SupportSQLiteOpenHelper.Configuration;
+//import android.arch.persistence.db.SupportSQLiteOpenHelper.Factory;
+//import android.arch.persistence.db.SupportSQLiteStatement;
+//import android.arch.persistence.db.framework.FrameworkSQLiteOpenHelperFactory;
 import android.content.ContentValues;
 import android.database.Cursor;
 import android.database.SQLException;
@@ -31,14 +31,21 @@
 import android.support.test.InstrumentationRegistry;
 import android.support.test.filters.SdkSuppress;
 import android.support.test.runner.AndroidJUnit4;
+
 import com.squareup.sqlbrite3.BriteDatabase.Transaction;
 import com.squareup.sqlbrite3.RecordingObserver.CursorAssert;
 import com.squareup.sqlbrite3.TestDb.Employee;
+
+import net.sqlcipher.database.SQLiteDatabase;
+import net.sqlcipher.database.SQLiteOpenHelper;
+import net.sqlcipher.database.SQLiteStatement;
+
 import io.reactivex.Observable;
 import io.reactivex.ObservableSource;
 import io.reactivex.ObservableTransformer;
 import io.reactivex.functions.Consumer;
 import io.reactivex.subjects.PublishSubject;
+
 import java.io.Closeable;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -48,6 +55,7 @@
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.CountDownLatch;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -74,1178 +82,1250 @@
 
 @RunWith(AndroidJUnit4.class) //
 public final class BriteDatabaseTest {
-  private final TestDb testDb = new TestDb();
-  private final List<String> logs = new ArrayList<>();
-  private final RecordingObserver o = new RecordingObserver();
-  private final TestScheduler scheduler = new TestScheduler();
-  private final PublishSubject<Object> killSwitch = PublishSubject.create();
-
-  @Rule public final TemporaryFolder dbFolder = new TemporaryFolder();
-
-  private SupportSQLiteDatabase real;
-  private BriteDatabase db;
-
-  @Before public void setUp() throws IOException {
-    Configuration configuration = Configuration.builder(InstrumentationRegistry.getContext())
-        .callback(testDb)
-        .version(1)
-        .name(dbFolder.newFile().getPath())
-        .build();
-
-    Factory factory = new FrameworkSQLiteOpenHelperFactory();
-    SupportSQLiteOpenHelper helper = factory.create(configuration);
-    real = helper.getWritableDatabase();
-
-    SqlBrite.Logger logger = new SqlBrite.Logger() {
-      @Override public void log(String message) {
-        logs.add(message);
-      }
-    };
-    ObservableTransformer<Query, Query> queryTransformer =
-        new ObservableTransformer<Query, Query>() {
-          @Override public ObservableSource<Query> apply(Observable<Query> upstream) {
-            return upstream.takeUntil(killSwitch);
-          }
+    private TestDb testDb;
+    private final List<String> logs = new ArrayList<>();
+    private final RecordingObserver o = new RecordingObserver();
+    private final TestScheduler scheduler = new TestScheduler();
+    private final PublishSubject<Object> killSwitch = PublishSubject.create();
+
+    public static final String PASSWORD = "testkey";
+
+    @Rule public final TemporaryFolder dbFolder = new TemporaryFolder();
+
+    private SQLiteDatabase real;
+    private BriteDatabase db;
+
+    @Before
+    public void setUp() throws IOException {
+        SQLiteDatabase.loadLibs(InstrumentationRegistry.getContext());
+        testDb = new TestDb(InstrumentationRegistry.getContext(), dbFolder.newFile().getPath(), null, 1);
+        SQLiteOpenHelper helper = testDb;
+        real = helper.getWritableDatabase(PASSWORD.toCharArray());
+
+        SqlBrite.Logger logger = new SqlBrite.Logger() {
+            @Override
+            public void log(String message) {
+                logs.add(message);
+            }
         };
-    db = new BriteDatabase(helper, logger, scheduler, queryTransformer);
-  }
-
-  @After public void tearDown() {
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void loggerEnabled() {
-    db.setLoggingEnabled(true);
-    db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
-    assertThat(logs).isNotEmpty();
-  }
-
-  @Test public void loggerDisabled() {
-    db.setLoggingEnabled(false);
-    db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
-    assertThat(logs).isEmpty();
-  }
-
-  @Test public void closePropagates() {
-    db.close();
-    assertThat(real.isOpen()).isFalse();
-  }
-
-  @Test public void query() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-  }
-
-  @Test public void queryWithQueryObject() {
-    db.createQuery(TABLE_EMPLOYEE, new SimpleSQLiteQuery(SELECT_EMPLOYEES)).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-  }
-
-  @Test public void queryMapToList() {
-    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
-        .mapToList(Employee.MAPPER)
-        .blockingFirst();
-    assertThat(employees).containsExactly( //
-        new Employee("alice", "Alice Allison"), //
-        new Employee("bob", "Bob Bobberson"), //
-        new Employee("eve", "Eve Evenson"));
-  }
-
-  @Test public void queryMapToOne() {
-    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
-        .mapToOne(Employee.MAPPER)
-        .blockingFirst();
-    assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
-  }
-
-  @Test public void queryMapToOneOrDefault() {
-    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
-        .mapToOneOrDefault(Employee.MAPPER, new Employee("wrong", "Wrong Person"))
-        .blockingFirst();
-    assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
-  }
-
-  @Test public void badQueryCallsError() {
-    // safeSubscribe is needed because the error occurs in onNext and will otherwise bubble up
-    // to the thread exception handler.
-    db.createQuery(TABLE_EMPLOYEE, "SELECT * FROM missing").safeSubscribe(o);
-    o.assertErrorContains("no such table: missing");
-  }
-
-  @Test public void queryWithArgs() {
-    db.createQuery(
-        TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE " + USERNAME + " = ?", "bob")
-        .subscribe(o);
-    o.assertCursor()
-        .hasRow("bob", "Bob Bobberson")
-        .isExhausted();
-  }
-
-  @Test public void queryObservesInsert() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("john", "John Johnson")
-        .isExhausted();
-  }
-
-  @Test public void queryInitialValueAndTriggerUsesScheduler() {
-    scheduler.runTasksImmediately(false);
-
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertNoMoreEvents();
-    scheduler.triggerActions();
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
-    o.assertNoMoreEvents();
-    scheduler.triggerActions();
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("john", "John Johnson")
-        .isExhausted();
-  }
-
-  @Test public void queryNotNotifiedWhenInsertFails() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.insert(TABLE_EMPLOYEE, CONFLICT_IGNORE, employee("bob", "Bob Bobberson"));
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void queryNotNotifiedWhenQueryTransformerUnsubscribes() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    killSwitch.onNext("kill");
-    o.assertIsCompleted();
-
-    db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void queryObservesUpdate() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    ContentValues values = new ContentValues();
-    values.put(NAME, "Robert Bobberson");
-    db.update(TABLE_EMPLOYEE, CONFLICT_NONE, values, USERNAME + " = 'bob'");
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Robert Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-  }
-
-  @Test public void queryNotNotifiedWhenUpdateAffectsZeroRows() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    ContentValues values = new ContentValues();
-    values.put(NAME, "John Johnson");
-    db.update(TABLE_EMPLOYEE, CONFLICT_NONE, values, USERNAME + " = 'john'");
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void queryObservesDelete() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.delete(TABLE_EMPLOYEE, USERNAME + " = 'bob'");
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-  }
-
-  @Test public void queryNotNotifiedWhenDeleteAffectsZeroRows() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.delete(TABLE_EMPLOYEE, USERNAME + " = 'john'");
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void queryMultipleTables() {
-    db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-  }
-
-  @Test public void queryMultipleTablesWithQueryObject() {
-    db.createQuery(BOTH_TABLES, new SimpleSQLiteQuery(SELECT_MANAGER_LIST)).subscribe(o);
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-  }
-
-  @Test public void queryMultipleTablesObservesChanges() {
-    db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-
-    // A new employee triggers, despite the fact that it's not in our result set.
-    db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-
-    // A new manager also triggers and it is in our result set.
-    db.insert(TABLE_MANAGER, CONFLICT_NONE, manager(testDb.bobId, testDb.eveId));
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .hasRow("Bob Bobberson", "Eve Evenson")
-        .isExhausted();
-  }
-
-  @Test public void queryMultipleTablesObservesChangesOnlyOnce() {
-    // Employee table is in this list twice. We should still only be notified once for a change.
-    List<String> tables = Arrays.asList(TABLE_EMPLOYEE, TABLE_MANAGER, TABLE_EMPLOYEE);
-    db.createQuery(tables, SELECT_MANAGER_LIST).subscribe(o);
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-
-    ContentValues values = new ContentValues();
-    values.put(NAME, "Even Evenson");
-    db.update(TABLE_EMPLOYEE, CONFLICT_NONE, values, USERNAME + " = 'eve'");
-    o.assertCursor()
-        .hasRow("Even Evenson", "Alice Allison")
-        .isExhausted();
-  }
-
-  @Test public void queryNotNotifiedAfterDispose() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-    o.dispose();
-
-    db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void queryOnlyNotifiedAfterSubscribe() {
-    Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
-    o.assertNoMoreEvents();
-
-    db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
-    o.assertNoMoreEvents();
-
-    query.subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("john", "John Johnson")
-        .isExhausted();
-  }
-
-  @Test public void executeSqlNoTrigger() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
-        .skip(1) // Skip initial
-        .subscribe(o);
-
-    db.execute("UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void executeSqlWithArgsNoTrigger() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
-        .skip(1) // Skip initial
-        .subscribe(o);
-
-    db.execute("UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = ?", "Zach");
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void executeSqlAndTrigger() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.executeAndTrigger(TABLE_EMPLOYEE,
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
-    o.assertCursor()
-        .hasRow("alice", "Zach")
-        .hasRow("bob", "Zach")
-        .hasRow("eve", "Zach")
-        .isExhausted();
-  }
-
-  @Test public void executeSqlAndTriggerMultipleTables() {
-    db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(o);
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-    final RecordingObserver employeeObserver = new RecordingObserver();
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(employeeObserver);
-    employeeObserver.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    final Set<String> tablesToTrigger = Collections.unmodifiableSet(new HashSet<>(BOTH_TABLES));
-    db.executeAndTrigger(tablesToTrigger,
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
-
-    o.assertCursor()
-        .hasRow("Zach", "Zach")
-        .isExhausted();
-    employeeObserver.assertCursor()
-        .hasRow("alice", "Zach")
-        .hasRow("bob", "Zach")
-        .hasRow("eve", "Zach")
-        .isExhausted();
-  }
-
-  @Test public void executeSqlAndTriggerWithNoTables() {
-    db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(o);
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-
-    db.executeAndTrigger(Collections.<String>emptySet(),
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
-
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void executeSqlThrowsAndDoesNotTrigger() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
-        .skip(1) // Skip initial
-        .subscribe(o);
-
-    try {
-      db.executeAndTrigger(TABLE_EMPLOYEE,
-          "UPDATE not_a_table SET " + NAME + " = 'Zach'");
-      fail();
-    } catch (SQLException ignored) {
-    }
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void executeSqlWithArgsAndTrigger() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.executeAndTrigger(TABLE_EMPLOYEE,
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = ?", "Zach");
-    o.assertCursor()
-        .hasRow("alice", "Zach")
-        .hasRow("bob", "Zach")
-        .hasRow("eve", "Zach")
-        .isExhausted();
-  }
-
-  @Test public void executeSqlWithArgsThrowsAndDoesNotTrigger() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
-        .skip(1) // Skip initial
-        .subscribe(o);
-
-    try {
-      db.executeAndTrigger(TABLE_EMPLOYEE,
-          "UPDATE not_a_table SET " + NAME + " = ?", "Zach");
-      fail();
-    } catch (SQLException ignored) {
-    }
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void executeSqlWithArgsAndTriggerWithMultipleTables() {
-    db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(o);
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-    final RecordingObserver employeeObserver = new RecordingObserver();
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(employeeObserver);
-    employeeObserver.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    final Set<String> tablesToTrigger = Collections.unmodifiableSet(new HashSet<>(BOTH_TABLES));
-    db.executeAndTrigger(tablesToTrigger,
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = ?", "Zach");
-
-    o.assertCursor()
-        .hasRow("Zach", "Zach")
-        .isExhausted();
-    employeeObserver.assertCursor()
-        .hasRow("alice", "Zach")
-        .hasRow("bob", "Zach")
-        .hasRow("eve", "Zach")
-        .isExhausted();
-  }
-
-  @Test public void executeSqlWithArgsAndTriggerWithNoTables() {
-    db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-
-    db.executeAndTrigger(Collections.<String>emptySet(),
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = ?", "Zach");
-
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void executeInsertAndTrigger() {
-    SupportSQLiteStatement statement = real.compileStatement("INSERT INTO "
-        + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") "
-        + "VALUES ('Chad Chadson', 'chad')");
-
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.executeInsert(TABLE_EMPLOYEE, statement);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("chad", "Chad Chadson")
-        .isExhausted();
-  }
-
-  @Test public void executeInsertAndDontTrigger() {
-    SupportSQLiteStatement statement = real.compileStatement("INSERT OR IGNORE INTO "
-        + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") "
-        + "VALUES ('Alice Allison', 'alice')");
-
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.executeInsert(TABLE_EMPLOYEE, statement);
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void executeInsertAndTriggerMultipleTables() {
-    SupportSQLiteStatement statement = real.compileStatement("INSERT INTO "
-        + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") "
-        + "VALUES ('Chad Chadson', 'chad')");
-
-    final RecordingObserver managerObserver = new RecordingObserver();
-    db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(managerObserver);
-    managerObserver.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    final Set<String> employeeAndManagerTables = Collections.unmodifiableSet(new HashSet<>(
-        BOTH_TABLES));
-    db.executeInsert(employeeAndManagerTables, statement);
-
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("chad", "Chad Chadson")
-        .isExhausted();
-    managerObserver.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-  }
-
-  @Test public void executeInsertAndTriggerNoTables() {
-    SupportSQLiteStatement statement = real.compileStatement("INSERT INTO "
-        + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") "
-        + "VALUES ('Chad Chadson', 'chad')");
-
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.executeInsert(Collections.<String>emptySet(), statement);
-
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void executeInsertThrowsAndDoesNotTrigger() {
-    SupportSQLiteStatement statement = real.compileStatement("INSERT INTO "
-        + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") "
-        + "VALUES ('Alice Allison', 'alice')");
-
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
-        .skip(1) // Skip initial
-        .subscribe(o);
-
-    try {
-      db.executeInsert(TABLE_EMPLOYEE, statement);
-      fail();
-    } catch (SQLException ignored) {
-    }
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void executeInsertWithArgsAndTrigger() {
-    SupportSQLiteStatement statement = real.compileStatement("INSERT INTO "
-        + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") VALUES (?, ?)");
-    statement.bindString(1, "Chad Chadson");
-    statement.bindString(2, "chad");
-
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.executeInsert(TABLE_EMPLOYEE, statement);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("chad", "Chad Chadson")
-        .isExhausted();
-  }
-
-  @Test public void executeInsertWithArgsThrowsAndDoesNotTrigger() {
-    SupportSQLiteStatement statement = real.compileStatement("INSERT INTO "
-        + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") VALUES (?, ?)");
-    statement.bindString(1, "Alice Aliison");
-    statement.bindString(2, "alice");
-
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
-        .skip(1) // Skip initial
-        .subscribe(o);
-
-    try {
-      db.executeInsert(TABLE_EMPLOYEE, statement);
-      fail();
-    } catch (SQLException ignored) {
-    }
-    o.assertNoMoreEvents();
-  }
-
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
-  @Test public void executeUpdateDeleteAndTrigger() {
-    SupportSQLiteStatement statement = real.compileStatement(
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
-
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
-    o.assertCursor()
-        .hasRow("alice", "Zach")
-        .hasRow("bob", "Zach")
-        .hasRow("eve", "Zach")
-        .isExhausted();
-  }
-
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
-  @Test public void executeUpdateDeleteAndDontTrigger() {
-    SupportSQLiteStatement statement = real.compileStatement(""
-        + "UPDATE " + TABLE_EMPLOYEE
-        + " SET " + NAME + " = 'Zach'"
-        + " WHERE " + NAME + " = 'Rob'");
-
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
-    o.assertNoMoreEvents();
-  }
-
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
-  @Test public void executeUpdateDeleteAndTriggerWithMultipleTables() {
-    SupportSQLiteStatement statement = real.compileStatement(
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
-
-
-    final RecordingObserver managerObserver = new RecordingObserver();
-    db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(managerObserver);
-    managerObserver.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    final Set<String> employeeAndManagerTables = Collections.unmodifiableSet(new HashSet<>(BOTH_TABLES));
-    db.executeUpdateDelete(employeeAndManagerTables, statement);
-
-    o.assertCursor()
-        .hasRow("alice", "Zach")
-        .hasRow("bob", "Zach")
-        .hasRow("eve", "Zach")
-        .isExhausted();
-    managerObserver.assertCursor()
-        .hasRow("Zach", "Zach")
-        .isExhausted();
-  }
-
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
-  @Test public void executeUpdateDeleteAndTriggerWithNoTables() {
-    SupportSQLiteStatement statement = real.compileStatement(
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
-
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.executeUpdateDelete(Collections.<String>emptySet(), statement);
-
-    o.assertNoMoreEvents();
-  }
-
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
-  @Test public void executeUpdateDeleteThrowsAndDoesNotTrigger() {
-    SupportSQLiteStatement statement = real.compileStatement(
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + USERNAME + " = 'alice'");
-
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
-        .skip(1) // Skip initial
-        .subscribe(o);
-
-    try {
-      db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
-      fail();
-    } catch (SQLException ignored) {
-    }
-    o.assertNoMoreEvents();
-  }
-
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
-  @Test public void executeUpdateDeleteWithArgsAndTrigger() {
-    SupportSQLiteStatement statement = real.compileStatement(
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = ?");
-    statement.bindString(1, "Zach");
-
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
-    o.assertCursor()
-        .hasRow("alice", "Zach")
-        .hasRow("bob", "Zach")
-        .hasRow("eve", "Zach")
-        .isExhausted();
-  }
-
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
-  @Test public void executeUpdateDeleteWithArgsThrowsAndDoesNotTrigger() {
-    SupportSQLiteStatement statement = real.compileStatement(
-        "UPDATE " + TABLE_EMPLOYEE + " SET " + USERNAME + " = ?");
-    statement.bindString(1, "alice");
-
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
-        .skip(1) // Skip initial
-        .subscribe(o);
-
-    try {
-      db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
-      fail();
-    } catch (SQLException ignored) {
-    }
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void transactionOnlyNotifiesOnce() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    Transaction transaction = db.newTransaction();
-    try {
-      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
-      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
-      o.assertNoMoreEvents();
-
-      transaction.markSuccessful();
-    } finally {
-      transaction.end();
-    }
-
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("john", "John Johnson")
-        .hasRow("nick", "Nick Nickers")
-        .isExhausted();
-  }
-
-  @Test public void transactionCreatedFromTransactionNotificationWorks() {
-    // Tests the case where a transaction is created in the subscriber to a query which gets
-    // notified as the result of another transaction being committed. With improper ordering, this
-    // can result in creating a new transaction before the old is committed on the underlying DB.
-
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
-        .subscribe(new Consumer<Query>() {
-          @Override public void accept(Query query) {
-            db.newTransaction().end();
-          }
-        });
-
-    Transaction transaction = db.newTransaction();
-    try {
-      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
-      transaction.markSuccessful();
-    } finally {
-      transaction.end();
-    }
-  }
-
-  @Test public void transactionIsCloseable() throws IOException {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    Transaction transaction = db.newTransaction();
-    //noinspection UnnecessaryLocalVariable
-    Closeable closeableTransaction = transaction; // Verify type is implemented.
-    try {
-      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
-      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
-      transaction.markSuccessful();
-    } finally {
-      closeableTransaction.close();
-    }
-
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("john", "John Johnson")
-        .hasRow("nick", "Nick Nickers")
-        .isExhausted();
-  }
-
-  @Test public void transactionDoesNotThrow() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    Transaction transaction = db.newTransaction();
-    try {
-      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
-      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
-      transaction.markSuccessful();
-    } finally {
-      transaction.close(); // Transactions should not throw on close().
-    }
-
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("john", "John Johnson")
-        .hasRow("nick", "Nick Nickers")
-        .isExhausted();
-  }
-
-  @Test public void queryCreatedDuringTransactionThrows() {
-    //noinspection CheckResult
-    db.newTransaction();
-    try {
-      //noinspection CheckResult
-      db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).startsWith("Cannot create observable query in transaction.");
-    }
-  }
-
-  @Test public void querySubscribedToDuringTransactionThrows() {
-    Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
-
-    db.newTransaction();
-    query.subscribe(o);
-    o.assertErrorContains("Cannot subscribe to observable query in a transaction.");
-  }
-
-  @Test public void callingEndMultipleTimesThrows() {
-    Transaction transaction = db.newTransaction();
-    transaction.end();
-    try {
-      transaction.end();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Not in transaction.");
-    }
-  }
-
-  @Test public void querySubscribedToDuringTransactionOnDifferentThread()
-      throws InterruptedException {
-    Transaction transaction = db.newTransaction();
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    new Thread() {
-      @Override public void run() {
+        ObservableTransformer<Query, Query> queryTransformer =
+                new ObservableTransformer<Query, Query>() {
+                    @Override
+                    public ObservableSource<Query> apply(Observable<Query> upstream) {
+                        return upstream.takeUntil(killSwitch);
+                    }
+                };
+        db = new BriteDatabase(helper, PASSWORD.toCharArray(), logger, scheduler, queryTransformer);
+    }
+
+    @After
+    public void tearDown() {
+        o.assertNoMoreEvents();
+    }
+
+    @Test
+    public void loggerEnabled() {
+        db.setLoggingEnabled(true);
+        db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+        assertThat(logs).isNotEmpty();
+    }
+
+    @Test
+    public void loggerDisabled() {
+        db.setLoggingEnabled(false);
+        db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+        assertThat(logs).isEmpty();
+    }
+
+    @Test
+    public void closePropagates() {
+        db.close();
+        assertThat(real.isOpen()).isFalse();
+    }
+
+    @Test
+    public void query() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+    }
+
+    @Test
+    public void queryWithQueryObject() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+    }
+
+    @Test
+    public void queryMapToList() {
+        List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+                .mapToList(Employee.MAPPER)
+                .blockingFirst();
+        assertThat(employees).containsExactly( //
+                new Employee("alice", "Alice Allison"), //
+                new Employee("bob", "Bob Bobberson"), //
+                new Employee("eve", "Eve Evenson"));
+    }
+
+    @Test
+    public void queryMapToOne() {
+        Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+                .mapToOne(Employee.MAPPER)
+                .blockingFirst();
+        assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
+    }
+
+    @Test
+    public void queryMapToOneOrDefault() {
+        Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+                .mapToOneOrDefault(Employee.MAPPER, new Employee("wrong", "Wrong Person"))
+                .blockingFirst();
+        assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
+    }
+
+    @Test
+    public void badQueryCallsError() {
+        // safeSubscribe is needed because the error occurs in onNext and will otherwise bubble up
+        // to the thread exception handler.
+        db.createQuery(TABLE_EMPLOYEE, "SELECT * FROM missing").safeSubscribe(o);
+        o.assertErrorContains("no such table: missing");
+    }
+
+    @Test
+    public void queryWithArgs() {
+        db.createQuery(
+                TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE " + USERNAME + " = ?", "bob")
+                .subscribe(o);
+        o.assertCursor()
+                .hasRow("bob", "Bob Bobberson")
+                .isExhausted();
+    }
+
+    @Test
+    public void queryObservesInsert() {
         db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-        latch.countDown();
-      }
-    }.start();
-
-    Thread.sleep(500); // Wait for the thread to block on initial query.
-    o.assertNoMoreEvents();
-
-    transaction.end(); // Allow other queries to continue.
-    latch.await(500, MILLISECONDS); // Wait for thread to observe initial query.
-
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-  }
-
-  @Test public void queryCreatedBeforeTransactionButSubscribedAfter() {
-    Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
-
-    Transaction transaction = db.newTransaction();
-    try {
-      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
-      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
-      transaction.markSuccessful();
-    } finally {
-      transaction.end();
-    }
-
-    query.subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("john", "John Johnson")
-        .hasRow("nick", "Nick Nickers")
-        .isExhausted();
-  }
-
-  @Test public void synchronousQueryDuringTransaction() {
-    Transaction transaction = db.newTransaction();
-    try {
-      transaction.markSuccessful();
-      assertCursor(db.query(SELECT_EMPLOYEES))
-          .hasRow("alice", "Alice Allison")
-          .hasRow("bob", "Bob Bobberson")
-          .hasRow("eve", "Eve Evenson")
-          .isExhausted();
-    } finally {
-      transaction.end();
-    }
-  }
-
-  @Test public void synchronousQueryDuringTransactionSeesChanges() {
-    Transaction transaction = db.newTransaction();
-    try {
-      assertCursor(db.query(SELECT_EMPLOYEES))
-          .hasRow("alice", "Alice Allison")
-          .hasRow("bob", "Bob Bobberson")
-          .hasRow("eve", "Eve Evenson")
-          .isExhausted();
-
-      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
-      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
-
-      assertCursor(db.query(SELECT_EMPLOYEES))
-          .hasRow("alice", "Alice Allison")
-          .hasRow("bob", "Bob Bobberson")
-          .hasRow("eve", "Eve Evenson")
-          .hasRow("john", "John Johnson")
-          .hasRow("nick", "Nick Nickers")
-          .isExhausted();
-
-      transaction.markSuccessful();
-    } finally {
-      transaction.end();
-    }
-  }
-
-  @Test public void nestedTransactionsOnlyNotifyOnce() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    Transaction transactionOuter = db.newTransaction();
-    try {
-      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
-
-      Transaction transactionInner = db.newTransaction();
-      try {
-        db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
-        transactionInner.markSuccessful();
-      } finally {
-        transactionInner.end();
-      }
-
-      transactionOuter.markSuccessful();
-    } finally {
-      transactionOuter.end();
-    }
-
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("john", "John Johnson")
-        .hasRow("nick", "Nick Nickers")
-        .isExhausted();
-  }
-
-  @Test public void nestedTransactionsOnMultipleTables() {
-    db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-
-    Transaction transactionOuter = db.newTransaction();
-    try {
-
-      Transaction transactionInner = db.newTransaction();
-      try {
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
         db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
-        transactionInner.markSuccessful();
-      } finally {
-        transactionInner.end();
-      }
-
-      transactionInner = db.newTransaction();
-      try {
-        db.insert(TABLE_MANAGER, CONFLICT_NONE, manager(testDb.aliceId, testDb.bobId));
-        transactionInner.markSuccessful();
-      } finally {
-        transactionInner.end();
-      }
-
-      transactionOuter.markSuccessful();
-    } finally {
-      transactionOuter.end();
-    }
-
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .hasRow("Alice Allison", "Bob Bobberson")
-        .isExhausted();
-  }
-
-  @Test public void emptyTransactionDoesNotNotify() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    Transaction transaction = db.newTransaction();
-    try {
-      transaction.markSuccessful();
-    } finally {
-      transaction.end();
-    }
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void transactionRollbackDoesNotNotify() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    Transaction transaction = db.newTransaction();
-    try {
-      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
-      db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
-      // No call to set successful.
-    } finally {
-      transaction.end();
-    }
-    o.assertNoMoreEvents();
-  }
-
-  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
-  @Test public void nonExclusiveTransactionWorks() throws InterruptedException {
-    final CountDownLatch transactionStarted = new CountDownLatch(1);
-    final CountDownLatch transactionProceed = new CountDownLatch(1);
-    final CountDownLatch transactionCompleted = new CountDownLatch(1);
-
-    new Thread() {
-      @Override public void run() {
-        Transaction transaction = db.newNonExclusiveTransaction();
-        transactionStarted.countDown();
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .hasRow("john", "John Johnson")
+                .isExhausted();
+    }
+
+    @Test
+    public void queryInitialValueAndTriggerUsesScheduler() {
+        scheduler.runTasksImmediately(false);
+
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertNoMoreEvents();
+        scheduler.triggerActions();
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+        o.assertNoMoreEvents();
+        scheduler.triggerActions();
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .hasRow("john", "John Johnson")
+                .isExhausted();
+    }
+
+    @Test
+    public void queryNotNotifiedWhenInsertFails() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        db.insert(TABLE_EMPLOYEE, CONFLICT_IGNORE, employee("bob", "Bob Bobberson"));
+        o.assertNoMoreEvents();
+    }
+
+    @Test
+    public void queryNotNotifiedWhenQueryTransformerUnsubscribes() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        killSwitch.onNext("kill");
+        o.assertIsCompleted();
+
+        db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+        o.assertNoMoreEvents();
+    }
+
+    @Test
+    public void queryObservesUpdate() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        ContentValues values = new ContentValues();
+        values.put(NAME, "Robert Bobberson");
+        db.update(TABLE_EMPLOYEE, CONFLICT_NONE, values, USERNAME + " = 'bob'");
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Robert Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+    }
+
+    @Test
+    public void queryNotNotifiedWhenUpdateAffectsZeroRows() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        ContentValues values = new ContentValues();
+        values.put(NAME, "John Johnson");
+        db.update(TABLE_EMPLOYEE, CONFLICT_NONE, values, USERNAME + " = 'john'");
+        o.assertNoMoreEvents();
+    }
+
+    @Test
+    public void queryObservesDelete() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        db.delete(TABLE_EMPLOYEE, USERNAME + " = 'bob'");
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+    }
+
+    @Test
+    public void queryNotNotifiedWhenDeleteAffectsZeroRows() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        db.delete(TABLE_EMPLOYEE, USERNAME + " = 'john'");
+        o.assertNoMoreEvents();
+    }
+
+    @Test
+    public void queryMultipleTables() {
+        db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
+        o.assertCursor()
+                .hasRow("Eve Evenson", "Alice Allison")
+                .isExhausted();
+    }
+
+    @Test
+    public void queryMultipleTablesWithQueryObject() {
+        db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
+        o.assertCursor()
+                .hasRow("Eve Evenson", "Alice Allison")
+                .isExhausted();
+    }
+
+    @Test
+    public void queryMultipleTablesObservesChanges() {
+        db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
+        o.assertCursor()
+                .hasRow("Eve Evenson", "Alice Allison")
+                .isExhausted();
+
+        // A new employee triggers, despite the fact that it's not in our result set.
+        db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+        o.assertCursor()
+                .hasRow("Eve Evenson", "Alice Allison")
+                .isExhausted();
+
+        // A new manager also triggers and it is in our result set.
+        db.insert(TABLE_MANAGER, CONFLICT_NONE, manager(testDb.bobId, testDb.eveId));
+        o.assertCursor()
+                .hasRow("Eve Evenson", "Alice Allison")
+                .hasRow("Bob Bobberson", "Eve Evenson")
+                .isExhausted();
+    }
+
+    @Test
+    public void queryMultipleTablesObservesChangesOnlyOnce() {
+        // Employee table is in this list twice. We should still only be notified once for a change.
+        List<String> tables = Arrays.asList(TABLE_EMPLOYEE, TABLE_MANAGER, TABLE_EMPLOYEE);
+        db.createQuery(tables, SELECT_MANAGER_LIST).subscribe(o);
+        o.assertCursor()
+                .hasRow("Eve Evenson", "Alice Allison")
+                .isExhausted();
+
+        ContentValues values = new ContentValues();
+        values.put(NAME, "Even Evenson");
+        db.update(TABLE_EMPLOYEE, CONFLICT_NONE, values, USERNAME + " = 'eve'");
+        o.assertCursor()
+                .hasRow("Even Evenson", "Alice Allison")
+                .isExhausted();
+    }
+
+    @Test
+    public void queryNotNotifiedAfterDispose() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+        o.dispose();
+
+        db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+        o.assertNoMoreEvents();
+    }
+
+    @Test
+    public void queryOnlyNotifiedAfterSubscribe() {
+        Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
+        o.assertNoMoreEvents();
+
+        db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+        o.assertNoMoreEvents();
+
+        query.subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .hasRow("john", "John Johnson")
+                .isExhausted();
+    }
+
+    @Test
+    public void executeSqlNoTrigger() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+                .skip(1) // Skip initial
+                .subscribe(o);
+
+        db.execute("UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
+        o.assertNoMoreEvents();
+    }
+
+    @Test
+    public void executeSqlWithArgsNoTrigger() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+                .skip(1) // Skip initial
+                .subscribe(o);
+
+        db.execute("UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = ?", "Zach");
+        o.assertNoMoreEvents();
+    }
+
+    @Test
+    public void executeSqlAndTrigger() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        db.executeAndTrigger(TABLE_EMPLOYEE,
+                "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
+        o.assertCursor()
+                .hasRow("alice", "Zach")
+                .hasRow("bob", "Zach")
+                .hasRow("eve", "Zach")
+                .isExhausted();
+    }
+
+    @Test
+    public void executeSqlAndTriggerMultipleTables() {
+        db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(o);
+        o.assertCursor()
+                .hasRow("Eve Evenson", "Alice Allison")
+                .isExhausted();
+        final RecordingObserver employeeObserver = new RecordingObserver();
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(employeeObserver);
+        employeeObserver.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        final Set<String> tablesToTrigger = Collections.unmodifiableSet(new HashSet<>(BOTH_TABLES));
+        db.executeAndTrigger(tablesToTrigger,
+                "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
+
+        o.assertCursor()
+                .hasRow("Zach", "Zach")
+                .isExhausted();
+        employeeObserver.assertCursor()
+                .hasRow("alice", "Zach")
+                .hasRow("bob", "Zach")
+                .hasRow("eve", "Zach")
+                .isExhausted();
+    }
+
+    @Test
+    public void executeSqlAndTriggerWithNoTables() {
+        db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(o);
+        o.assertCursor()
+                .hasRow("Eve Evenson", "Alice Allison")
+                .isExhausted();
+
+        db.executeAndTrigger(Collections.<String>emptySet(),
+                "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
+
+        o.assertNoMoreEvents();
+    }
+
+    @Test
+    public void executeSqlThrowsAndDoesNotTrigger() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+                .skip(1) // Skip initial
+                .subscribe(o);
+
+        try {
+            db.executeAndTrigger(TABLE_EMPLOYEE,
+                    "UPDATE not_a_table SET " + NAME + " = 'Zach'");
+            fail();
+        } catch (SQLException ignored) {
+        }
+        o.assertNoMoreEvents();
+    }
+
+    @Test
+    public void executeSqlWithArgsAndTrigger() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        db.executeAndTrigger(TABLE_EMPLOYEE,
+                "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = ?", "Zach");
+        o.assertCursor()
+                .hasRow("alice", "Zach")
+                .hasRow("bob", "Zach")
+                .hasRow("eve", "Zach")
+                .isExhausted();
+    }
+
+    @Test
+    public void executeSqlWithArgsThrowsAndDoesNotTrigger() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+                .skip(1) // Skip initial
+                .subscribe(o);
+
+        try {
+            db.executeAndTrigger(TABLE_EMPLOYEE,
+                    "UPDATE not_a_table SET " + NAME + " = ?", "Zach");
+            fail();
+        } catch (SQLException ignored) {
+        }
+        o.assertNoMoreEvents();
+    }
+
+    @Test
+    public void executeSqlWithArgsAndTriggerWithMultipleTables() {
+        db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(o);
+        o.assertCursor()
+                .hasRow("Eve Evenson", "Alice Allison")
+                .isExhausted();
+        final RecordingObserver employeeObserver = new RecordingObserver();
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(employeeObserver);
+        employeeObserver.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        final Set<String> tablesToTrigger = Collections.unmodifiableSet(new HashSet<>(BOTH_TABLES));
+        db.executeAndTrigger(tablesToTrigger,
+                "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = ?", "Zach");
+
+        o.assertCursor()
+                .hasRow("Zach", "Zach")
+                .isExhausted();
+        employeeObserver.assertCursor()
+                .hasRow("alice", "Zach")
+                .hasRow("bob", "Zach")
+                .hasRow("eve", "Zach")
+                .isExhausted();
+    }
+
+    @Test
+    public void executeSqlWithArgsAndTriggerWithNoTables() {
+        db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
+        o.assertCursor()
+                .hasRow("Eve Evenson", "Alice Allison")
+                .isExhausted();
+
+        db.executeAndTrigger(Collections.<String>emptySet(),
+                "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = ?", "Zach");
+
+        o.assertNoMoreEvents();
+    }
+
+    @Test
+    public void executeInsertAndTrigger() {
+        SQLiteStatement statement = real.compileStatement("INSERT INTO "
+                + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") "
+                + "VALUES ('Chad Chadson', 'chad')");
+
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        db.executeInsert(TABLE_EMPLOYEE, statement);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .hasRow("chad", "Chad Chadson")
+                .isExhausted();
+    }
+
+    @Test
+    public void executeInsertAndDontTrigger() {
+        SQLiteStatement statement = real.compileStatement("INSERT OR IGNORE INTO "
+                + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") "
+                + "VALUES ('Alice Allison', 'alice')");
+
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        db.executeInsert(TABLE_EMPLOYEE, statement);
+        o.assertNoMoreEvents();
+    }
+
+    @Test
+    public void executeInsertAndTriggerMultipleTables() {
+        SQLiteStatement statement = real.compileStatement("INSERT INTO "
+                + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") "
+                + "VALUES ('Chad Chadson', 'chad')");
+
+        final RecordingObserver managerObserver = new RecordingObserver();
+        db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(managerObserver);
+        managerObserver.assertCursor()
+                .hasRow("Eve Evenson", "Alice Allison")
+                .isExhausted();
+
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        final Set<String> employeeAndManagerTables = Collections.unmodifiableSet(new HashSet<>(
+                BOTH_TABLES));
+        db.executeInsert(employeeAndManagerTables, statement);
+
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .hasRow("chad", "Chad Chadson")
+                .isExhausted();
+        managerObserver.assertCursor()
+                .hasRow("Eve Evenson", "Alice Allison")
+                .isExhausted();
+    }
+
+    @Test
+    public void executeInsertAndTriggerNoTables() {
+        SQLiteStatement statement = real.compileStatement("INSERT INTO "
+                + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") "
+                + "VALUES ('Chad Chadson', 'chad')");
+
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        db.executeInsert(Collections.<String>emptySet(), statement);
+
+        o.assertNoMoreEvents();
+    }
+
+    @Test
+    public void executeInsertThrowsAndDoesNotTrigger() {
+        SQLiteStatement statement = real.compileStatement("INSERT INTO "
+                + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") "
+                + "VALUES ('Alice Allison', 'alice')");
+
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+                .skip(1) // Skip initial
+                .subscribe(o);
+
+        try {
+            db.executeInsert(TABLE_EMPLOYEE, statement);
+            fail();
+        } catch (SQLException ignored) {
+        }
+        o.assertNoMoreEvents();
+    }
+
+    @Test
+    public void executeInsertWithArgsAndTrigger() {
+        SQLiteStatement statement = real.compileStatement("INSERT INTO "
+                + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") VALUES (?, ?)");
+        statement.bindString(1, "Chad Chadson");
+        statement.bindString(2, "chad");
+
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        db.executeInsert(TABLE_EMPLOYEE, statement);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .hasRow("chad", "Chad Chadson")
+                .isExhausted();
+    }
+
+    @Test
+    public void executeInsertWithArgsThrowsAndDoesNotTrigger() {
+        SQLiteStatement statement = real.compileStatement("INSERT INTO "
+                + TABLE_EMPLOYEE + " (" + NAME + ", " + USERNAME + ") VALUES (?, ?)");
+        statement.bindString(1, "Alice Aliison");
+        statement.bindString(2, "alice");
+
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+                .skip(1) // Skip initial
+                .subscribe(o);
+
+        try {
+            db.executeInsert(TABLE_EMPLOYEE, statement);
+            fail();
+        } catch (SQLException ignored) {
+        }
+        o.assertNoMoreEvents();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+    @Test
+    public void executeUpdateDeleteAndTrigger() {
+        SQLiteStatement statement = real.compileStatement(
+                "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
+
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
+        o.assertCursor()
+                .hasRow("alice", "Zach")
+                .hasRow("bob", "Zach")
+                .hasRow("eve", "Zach")
+                .isExhausted();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+    @Test
+    public void executeUpdateDeleteAndDontTrigger() {
+        SQLiteStatement statement = real.compileStatement(""
+                + "UPDATE " + TABLE_EMPLOYEE
+                + " SET " + NAME + " = 'Zach'"
+                + " WHERE " + NAME + " = 'Rob'");
+
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
+        o.assertNoMoreEvents();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+    @Test
+    public void executeUpdateDeleteAndTriggerWithMultipleTables() {
+        SQLiteStatement statement = real.compileStatement(
+                "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
+
+
+        final RecordingObserver managerObserver = new RecordingObserver();
+        db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(managerObserver);
+        managerObserver.assertCursor()
+                .hasRow("Eve Evenson", "Alice Allison")
+                .isExhausted();
+
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        final Set<String> employeeAndManagerTables = Collections.unmodifiableSet(new HashSet<>(BOTH_TABLES));
+        db.executeUpdateDelete(employeeAndManagerTables, statement);
+
+        o.assertCursor()
+                .hasRow("alice", "Zach")
+                .hasRow("bob", "Zach")
+                .hasRow("eve", "Zach")
+                .isExhausted();
+        managerObserver.assertCursor()
+                .hasRow("Zach", "Zach")
+                .isExhausted();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+    @Test
+    public void executeUpdateDeleteAndTriggerWithNoTables() {
+        SQLiteStatement statement = real.compileStatement(
+                "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = 'Zach'");
+
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        db.executeUpdateDelete(Collections.<String>emptySet(), statement);
+
+        o.assertNoMoreEvents();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+    @Test
+    public void executeUpdateDeleteThrowsAndDoesNotTrigger() {
+        SQLiteStatement statement = real.compileStatement(
+                "UPDATE " + TABLE_EMPLOYEE + " SET " + USERNAME + " = 'alice'");
+
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+                .skip(1) // Skip initial
+                .subscribe(o);
+
+        try {
+            db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
+            fail();
+        } catch (SQLException ignored) {
+        }
+        o.assertNoMoreEvents();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+    @Test
+    public void executeUpdateDeleteWithArgsAndTrigger() {
+        SQLiteStatement statement = real.compileStatement(
+                "UPDATE " + TABLE_EMPLOYEE + " SET " + NAME + " = ?");
+        statement.bindString(1, "Zach");
+
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
+        o.assertCursor()
+                .hasRow("alice", "Zach")
+                .hasRow("bob", "Zach")
+                .hasRow("eve", "Zach")
+                .isExhausted();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+    @Test
+    public void executeUpdateDeleteWithArgsThrowsAndDoesNotTrigger() {
+        SQLiteStatement statement = real.compileStatement(
+                "UPDATE " + TABLE_EMPLOYEE + " SET " + USERNAME + " = ?");
+        statement.bindString(1, "alice");
+
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+                .skip(1) // Skip initial
+                .subscribe(o);
+
+        try {
+            db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
+            fail();
+        } catch (SQLException ignored) {
+        }
+        o.assertNoMoreEvents();
+    }
+
+    @Test
+    public void transactionOnlyNotifiesOnce() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        Transaction transaction = db.newTransaction();
+        try {
+            db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+            db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
+            o.assertNoMoreEvents();
+
+            transaction.markSuccessful();
+        } finally {
+            transaction.end();
+        }
+
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .hasRow("john", "John Johnson")
+                .hasRow("nick", "Nick Nickers")
+                .isExhausted();
+    }
+
+    @Test
+    public void transactionCreatedFromTransactionNotificationWorks() {
+        // Tests the case where a transaction is created in the subscriber to a query which gets
+        // notified as the result of another transaction being committed. With improper ordering, this
+        // can result in creating a new transaction before the old is committed on the underlying DB.
+
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+                .subscribe(new Consumer<Query>() {
+                    @Override
+                    public void accept(Query query) {
+                        db.newTransaction().end();
+                    }
+                });
+
+        Transaction transaction = db.newTransaction();
+        try {
+            db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+            transaction.markSuccessful();
+        } finally {
+            transaction.end();
+        }
+    }
+
+    @Test
+    public void transactionIsCloseable() throws IOException {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        Transaction transaction = db.newTransaction();
+        //noinspection UnnecessaryLocalVariable
+        Closeable closeableTransaction = transaction; // Verify type is implemented.
+        try {
+            db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+            db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
+            transaction.markSuccessful();
+        } finally {
+            closeableTransaction.close();
+        }
+
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .hasRow("john", "John Johnson")
+                .hasRow("nick", "Nick Nickers")
+                .isExhausted();
+    }
+
+    @Test
+    public void transactionDoesNotThrow() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        Transaction transaction = db.newTransaction();
+        try {
+            db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+            db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
+            transaction.markSuccessful();
+        } finally {
+            transaction.close(); // Transactions should not throw on close().
+        }
+
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .hasRow("john", "John Johnson")
+                .hasRow("nick", "Nick Nickers")
+                .isExhausted();
+    }
+
+    @Test
+    public void queryCreatedDuringTransactionThrows() {
+        //noinspection CheckResult
+        db.newTransaction();
         try {
-          db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("hans", "Hans Hanson"));
-          transactionProceed.await(10, SECONDS);
-        } catch (InterruptedException e) {
-          throw new RuntimeException("Exception in transaction thread", e);
+            //noinspection CheckResult
+            db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e.getMessage()).startsWith("Cannot create observable query in transaction.");
         }
-        transaction.markSuccessful();
-        transaction.close();
-        transactionCompleted.countDown();
-      }
-    }.start();
-
-    assertThat(transactionStarted.await(10, SECONDS)).isTrue();
-
-    //Simple query
-    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
-            .lift(Query.mapToOne(Employee.MAPPER))
-            .blockingFirst();
-    assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
-
-    transactionProceed.countDown();
-    assertThat(transactionCompleted.await(10, SECONDS)).isTrue();
-  }
-
-  @Test public void badQueryThrows() {
-    try {
-      //noinspection CheckResult
-      db.query("SELECT * FROM missing");
-      fail();
-    } catch (SQLiteException e) {
-      assertThat(e.getMessage()).contains("no such table: missing");
-    }
-  }
-
-  @Test public void badInsertThrows() {
-    try {
-      db.insert("missing", CONFLICT_NONE, employee("john", "John Johnson"));
-      fail();
-    } catch (SQLiteException e) {
-      assertThat(e.getMessage()).contains("no such table: missing");
-    }
-  }
-
-  @Test public void badUpdateThrows() {
-    try {
-      db.update("missing", CONFLICT_NONE, employee("john", "John Johnson"), "1");
-      fail();
-    } catch (SQLiteException e) {
-      assertThat(e.getMessage()).contains("no such table: missing");
-    }
-  }
-
-  @Test public void badDeleteThrows() {
-    try {
-      db.delete("missing", "1");
-      fail();
-    } catch (SQLiteException e) {
-      assertThat(e.getMessage()).contains("no such table: missing");
-    }
-  }
-
-  private static CursorAssert assertCursor(Cursor cursor) {
-    return new CursorAssert(cursor);
-  }
+    }
+
+    @Test
+    public void querySubscribedToDuringTransactionThrows() {
+        Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
+
+        db.newTransaction();
+        query.subscribe(o);
+        o.assertErrorContains("Cannot subscribe to observable query in a transaction.");
+    }
+
+    @Test
+    public void callingEndMultipleTimesThrows() {
+        Transaction transaction = db.newTransaction();
+        transaction.end();
+        try {
+            transaction.end();
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage("Not in transaction.");
+        }
+    }
+
+    @Test
+    public void querySubscribedToDuringTransactionOnDifferentThread()
+            throws InterruptedException {
+        Transaction transaction = db.newTransaction();
+
+        final CountDownLatch latch = new CountDownLatch(1);
+        new Thread() {
+            @Override
+            public void run() {
+                db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+                latch.countDown();
+            }
+        }.start();
+
+        Thread.sleep(500); // Wait for the thread to block on initial query.
+        o.assertNoMoreEvents();
+
+        transaction.end(); // Allow other queries to continue.
+        latch.await(500, MILLISECONDS); // Wait for thread to observe initial query.
+
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+    }
+
+    @Test
+    public void queryCreatedBeforeTransactionButSubscribedAfter() {
+        Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
+
+        Transaction transaction = db.newTransaction();
+        try {
+            db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+            db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
+            transaction.markSuccessful();
+        } finally {
+            transaction.end();
+        }
+
+        query.subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .hasRow("john", "John Johnson")
+                .hasRow("nick", "Nick Nickers")
+                .isExhausted();
+    }
+
+    @Test
+    public void synchronousQueryDuringTransaction() {
+        Transaction transaction = db.newTransaction();
+        try {
+            transaction.markSuccessful();
+            assertCursor(db.query(SELECT_EMPLOYEES))
+                    .hasRow("alice", "Alice Allison")
+                    .hasRow("bob", "Bob Bobberson")
+                    .hasRow("eve", "Eve Evenson")
+                    .isExhausted();
+        } finally {
+            transaction.end();
+        }
+    }
+
+    @Test
+    public void synchronousQueryDuringTransactionSeesChanges() {
+        Transaction transaction = db.newTransaction();
+        try {
+            assertCursor(db.query(SELECT_EMPLOYEES))
+                    .hasRow("alice", "Alice Allison")
+                    .hasRow("bob", "Bob Bobberson")
+                    .hasRow("eve", "Eve Evenson")
+                    .isExhausted();
+
+            db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+            db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
+
+            assertCursor(db.query(SELECT_EMPLOYEES))
+                    .hasRow("alice", "Alice Allison")
+                    .hasRow("bob", "Bob Bobberson")
+                    .hasRow("eve", "Eve Evenson")
+                    .hasRow("john", "John Johnson")
+                    .hasRow("nick", "Nick Nickers")
+                    .isExhausted();
+
+            transaction.markSuccessful();
+        } finally {
+            transaction.end();
+        }
+    }
+
+    @Test
+    public void nestedTransactionsOnlyNotifyOnce() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        Transaction transactionOuter = db.newTransaction();
+        try {
+            db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+
+            Transaction transactionInner = db.newTransaction();
+            try {
+                db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
+                transactionInner.markSuccessful();
+            } finally {
+                transactionInner.end();
+            }
+
+            transactionOuter.markSuccessful();
+        } finally {
+            transactionOuter.end();
+        }
+
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .hasRow("john", "John Johnson")
+                .hasRow("nick", "Nick Nickers")
+                .isExhausted();
+    }
+
+    @Test
+    public void nestedTransactionsOnMultipleTables() {
+        db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
+        o.assertCursor()
+                .hasRow("Eve Evenson", "Alice Allison")
+                .isExhausted();
+
+        Transaction transactionOuter = db.newTransaction();
+        try {
+
+            Transaction transactionInner = db.newTransaction();
+            try {
+                db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+                transactionInner.markSuccessful();
+            } finally {
+                transactionInner.end();
+            }
+
+            transactionInner = db.newTransaction();
+            try {
+                db.insert(TABLE_MANAGER, CONFLICT_NONE, manager(testDb.aliceId, testDb.bobId));
+                transactionInner.markSuccessful();
+            } finally {
+                transactionInner.end();
+            }
+
+            transactionOuter.markSuccessful();
+        } finally {
+            transactionOuter.end();
+        }
+
+        o.assertCursor()
+                .hasRow("Eve Evenson", "Alice Allison")
+                .hasRow("Alice Allison", "Bob Bobberson")
+                .isExhausted();
+    }
+
+    @Test
+    public void emptyTransactionDoesNotNotify() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        Transaction transaction = db.newTransaction();
+        try {
+            transaction.markSuccessful();
+        } finally {
+            transaction.end();
+        }
+        o.assertNoMoreEvents();
+    }
+
+    @Test
+    public void transactionRollbackDoesNotNotify() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        o.assertCursor()
+                .hasRow("alice", "Alice Allison")
+                .hasRow("bob", "Bob Bobberson")
+                .hasRow("eve", "Eve Evenson")
+                .isExhausted();
+
+        Transaction transaction = db.newTransaction();
+        try {
+            db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("john", "John Johnson"));
+            db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("nick", "Nick Nickers"));
+            // No call to set successful.
+        } finally {
+            transaction.end();
+        }
+        o.assertNoMoreEvents();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+    @Test
+    public void nonExclusiveTransactionWorks() throws InterruptedException {
+        final CountDownLatch transactionStarted = new CountDownLatch(1);
+        final CountDownLatch transactionProceed = new CountDownLatch(1);
+        final CountDownLatch transactionCompleted = new CountDownLatch(1);
+
+        new Thread() {
+            @Override
+            public void run() {
+                Transaction transaction = db.newNonExclusiveTransaction();
+                transactionStarted.countDown();
+                try {
+                    db.insert(TABLE_EMPLOYEE, CONFLICT_NONE, employee("hans", "Hans Hanson"));
+                    transactionProceed.await(10, SECONDS);
+                } catch (InterruptedException e) {
+                    throw new RuntimeException("Exception in transaction thread", e);
+                }
+                transaction.markSuccessful();
+                transaction.close();
+                transactionCompleted.countDown();
+            }
+        }.start();
+
+        assertThat(transactionStarted.await(10, SECONDS)).isTrue();
+
+        //Simple query
+        Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+                .lift(Query.mapToOne(Employee.MAPPER))
+                .blockingFirst();
+        assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
+
+        transactionProceed.countDown();
+        assertThat(transactionCompleted.await(10, SECONDS)).isTrue();
+    }
+
+    @Test
+    public void badQueryThrows() {
+        try {
+            //noinspection CheckResult
+            db.query("SELECT * FROM missing");
+            fail();
+        } catch (SQLiteException e) {
+            assertThat(e.getMessage()).contains("no such table: missing");
+        }
+    }
+
+    @Test
+    public void badInsertThrows() {
+        try {
+            db.insert("missing", CONFLICT_NONE, employee("john", "John Johnson"));
+            fail();
+        } catch (SQLiteException e) {
+            assertThat(e.getMessage()).contains("no such table: missing");
+        }
+    }
+
+    @Test
+    public void badUpdateThrows() {
+        try {
+            db.update("missing", CONFLICT_NONE, employee("john", "John Johnson"), "1");
+            fail();
+        } catch (SQLiteException e) {
+            assertThat(e.getMessage()).contains("no such table: missing");
+        }
+    }
+
+    @Test
+    public void badDeleteThrows() {
+        try {
+            db.delete("missing", "1");
+            fail();
+        } catch (SQLiteException e) {
+            assertThat(e.getMessage()).contains("no such table: missing");
+        }
+    }
+
+    private static CursorAssert assertCursor(Cursor cursor) {
+        return new CursorAssert(cursor);
+    }
 }
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/QueryTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/QueryTest.java
index 5181ee0..be171a3 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/QueryTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/QueryTest.java
@@ -16,23 +16,27 @@
 package com.squareup.sqlbrite3;
 
 import android.annotation.TargetApi;
-import android.arch.persistence.db.SupportSQLiteOpenHelper;
-import android.arch.persistence.db.SupportSQLiteOpenHelper.Configuration;
-import android.arch.persistence.db.SupportSQLiteOpenHelper.Factory;
+//import android.arch.persistence.db.SupportSQLiteOpenHelper;
+//import android.arch.persistence.db.SupportSQLiteOpenHelper.Configuration;
+//import android.arch.persistence.db.SupportSQLiteOpenHelper.Factory;
 import android.arch.persistence.db.framework.FrameworkSQLiteOpenHelperFactory;
 import android.database.Cursor;
 import android.os.Build;
 import android.support.annotation.Nullable;
 import android.support.test.InstrumentationRegistry;
 import android.support.test.filters.SdkSuppress;
+
 import com.squareup.sqlbrite3.SqlBrite.Query;
 import com.squareup.sqlbrite3.TestDb.Employee;
+
 import io.reactivex.Observable;
 import io.reactivex.functions.Function;
 import io.reactivex.observers.TestObserver;
 import io.reactivex.schedulers.Schedulers;
+
 import java.util.List;
 import java.util.Optional;
+
 import org.junit.Before;
 import org.junit.Test;
 
@@ -43,219 +47,255 @@
 import static org.junit.Assert.fail;
 
 public final class QueryTest {
-  private BriteDatabase db;
-
-  @Before public void setUp() {
-    Configuration configuration = Configuration.builder(InstrumentationRegistry.getContext())
-        .callback(new TestDb())
-        .version(1)
-        .build();
-
-    Factory factory = new FrameworkSQLiteOpenHelperFactory();
-    SupportSQLiteOpenHelper helper = factory.create(configuration);
-
-    SqlBrite sqlBrite = new SqlBrite.Builder().build();
-    db = sqlBrite.wrapDatabaseHelper(helper, Schedulers.trampoline());
-  }
-
-  @Test public void mapToOne() {
-    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
-        .lift(Query.mapToOne(MAPPER))
-        .blockingFirst();
-    assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
-  }
-
-  @Test public void mapToOneThrowsWhenMapperReturnsNull() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
-        .lift(Query.mapToOne(new Function<Cursor, Employee>() {
-          @Override public Employee apply(Cursor cursor) throws Exception {
-            return null;
-          }
-        }))
-        .test()
-        .assertError(NullPointerException.class)
-        .assertErrorMessage("QueryToOne mapper returned null");
-  }
-
-  @Test public void mapToOneThrowsOnMultipleRows() {
-    Observable<Employee> employees =
-        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 2") //
-            .lift(Query.mapToOne(MAPPER));
-    try {
-      employees.blockingFirst();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Cursor returned more than 1 row");
+    private BriteDatabase db;
+
+    @Before
+    public void setUp() {
+//    Configuration configuration = Configuration.builder(InstrumentationRegistry.getContext())
+//        .callback(new TestDb())
+//        .version(1)
+//        .build();
+//
+//    Factory factory = new FrameworkSQLiteOpenHelperFactory();
+//    SupportSQLiteOpenHelper helper = factory.create(configuration);
+
+        TestDb helper = new TestDb(InstrumentationRegistry.getContext(),
+                "test.db",
+                null,
+                1
+        );
+
+        SqlBrite sqlBrite = new SqlBrite.Builder().build();
+        db = sqlBrite.wrapDatabaseHelper(helper, "testkey".toCharArray(), Schedulers.trampoline());
     }
-  }
-
-  @Test public void mapToOneIgnoresNullCursor() {
-    Query nully = new Query() {
-      @Nullable @Override public Cursor run() {
-        return null;
-      }
-    };
-
-    TestObserver<Employee> observer = new TestObserver<>();
-    Observable.just(nully)
-        .lift(Query.mapToOne(MAPPER))
-        .subscribe(observer);
-
-    observer.assertNoValues();
-    observer.assertComplete();
-  }
-
-  @Test public void mapToOneOrDefault() {
-    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
-        .lift(Query.mapToOneOrDefault(
-            MAPPER, new Employee("fred", "Fred Frederson")))
-        .blockingFirst();
-    assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
-  }
-
-  @Test public void mapToOneOrDefaultDisallowsNullDefault() {
-    try {
-      Query.mapToOneOrDefault(MAPPER, null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("defaultValue == null");
+
+    @Test
+    public void mapToOne() {
+        Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+                .lift(Query.mapToOne(MAPPER))
+                .blockingFirst();
+        assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
+    }
+
+    @Test
+    public void mapToOneThrowsWhenMapperReturnsNull() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+                .lift(Query.mapToOne(new Function<Cursor, Employee>() {
+                    @Override
+                    public Employee apply(Cursor cursor) throws Exception {
+                        return null;
+                    }
+                }))
+                .test()
+                .assertError(NullPointerException.class)
+                .assertErrorMessage("QueryToOne mapper returned null");
+    }
+
+    @Test
+    public void mapToOneThrowsOnMultipleRows() {
+        Observable<Employee> employees =
+                db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 2") //
+                        .lift(Query.mapToOne(MAPPER));
+        try {
+            employees.blockingFirst();
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage("Cursor returned more than 1 row");
+        }
     }
-  }
-
-  @Test public void mapToOneOrDefaultThrowsWhenMapperReturnsNull() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
-        .lift(Query.mapToOneOrDefault(new Function<Cursor, Employee>() {
-          @Override public Employee apply(Cursor cursor) throws Exception {
-            return null;
-          }
-        }, new Employee("fred", "Fred Frederson")))
-        .test()
-        .assertError(NullPointerException.class)
-        .assertErrorMessage("QueryToOne mapper returned null");
-  }
-
-  @Test public void mapToOneOrDefaultThrowsOnMultipleRows() {
-    Observable<Employee> employees =
+
+    @Test
+    public void mapToOneIgnoresNullCursor() {
+        Query nully = new Query() {
+            @Nullable
+            @Override
+            public Cursor run() {
+                return null;
+            }
+        };
+
+        TestObserver<Employee> observer = new TestObserver<>();
+        Observable.just(nully)
+                .lift(Query.mapToOne(MAPPER))
+                .subscribe(observer);
+
+        observer.assertNoValues();
+        observer.assertComplete();
+    }
+
+    @Test
+    public void mapToOneOrDefault() {
+        Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+                .lift(Query.mapToOneOrDefault(
+                        MAPPER, new Employee("fred", "Fred Frederson")))
+                .blockingFirst();
+        assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
+    }
+
+    @Test
+    public void mapToOneOrDefaultDisallowsNullDefault() {
+        try {
+            Query.mapToOneOrDefault(MAPPER, null);
+            fail();
+        } catch (NullPointerException e) {
+            assertThat(e).hasMessage("defaultValue == null");
+        }
+    }
+
+    @Test
+    public void mapToOneOrDefaultThrowsWhenMapperReturnsNull() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+                .lift(Query.mapToOneOrDefault(new Function<Cursor, Employee>() {
+                    @Override
+                    public Employee apply(Cursor cursor) throws Exception {
+                        return null;
+                    }
+                }, new Employee("fred", "Fred Frederson")))
+                .test()
+                .assertError(NullPointerException.class)
+                .assertErrorMessage("QueryToOne mapper returned null");
+    }
+
+    @Test
+    public void mapToOneOrDefaultThrowsOnMultipleRows() {
+        Observable<Employee> employees =
+                db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 2") //
+                        .lift(Query.mapToOneOrDefault(
+                                MAPPER, new Employee("fred", "Fred Frederson")));
+        try {
+            employees.blockingFirst();
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e).hasMessage("Cursor returned more than 1 row");
+        }
+    }
+
+    @Test
+    public void mapToOneOrDefaultReturnsDefaultWhenNullCursor() {
+        Employee defaultEmployee = new Employee("bob", "Bob Bobberson");
+        Query nully = new Query() {
+            @Nullable
+            @Override
+            public Cursor run() {
+                return null;
+            }
+        };
+
+        TestObserver<Employee> observer = new TestObserver<>();
+        Observable.just(nully)
+                .lift(Query.mapToOneOrDefault(MAPPER, defaultEmployee))
+                .subscribe(observer);
+
+        observer.assertValues(defaultEmployee);
+        observer.assertComplete();
+    }
+
+    @Test
+    public void mapToList() {
+        List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+                .lift(Query.mapToList(MAPPER))
+                .blockingFirst();
+        assertThat(employees).containsExactly( //
+                new Employee("alice", "Alice Allison"), //
+                new Employee("bob", "Bob Bobberson"), //
+                new Employee("eve", "Eve Evenson"));
+    }
+
+    @Test
+    public void mapToListEmptyWhenNoRows() {
+        List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE 1=2")
+                .lift(Query.mapToList(MAPPER))
+                .blockingFirst();
+        assertThat(employees).isEmpty();
+    }
+
+    @Test
+    public void mapToListReturnsNullOnMapperNull() {
+        Function<Cursor, Employee> mapToNull = new Function<Cursor, Employee>() {
+            private int count;
+
+            @Override
+            public Employee apply(Cursor cursor) throws Exception {
+                return count++ == 2 ? null : MAPPER.apply(cursor);
+            }
+        };
+        List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES) //
+                .lift(Query.mapToList(mapToNull)) //
+                .blockingFirst();
+
+        assertThat(employees).containsExactly(
+                new Employee("alice", "Alice Allison"),
+                new Employee("bob", "Bob Bobberson"),
+                null);
+    }
+
+    @Test
+    public void mapToListIgnoresNullCursor() {
+        Query nully = new Query() {
+            @Nullable
+            @Override
+            public Cursor run() {
+                return null;
+            }
+        };
+
+        TestObserver<List<Employee>> subscriber = new TestObserver<>();
+        Observable.just(nully)
+                .lift(Query.mapToList(MAPPER))
+                .subscribe(subscriber);
+
+        subscriber.assertNoValues();
+        subscriber.assertComplete();
+    }
+
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+    @Test
+    public void mapToOptional() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+                .lift(Query.mapToOptional(MAPPER))
+                .test()
+                .assertValue(Optional.of(new Employee("alice", "Alice Allison")));
+    }
+
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+    @Test
+    public void mapToOptionalThrowsWhenMapperReturnsNull() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+                .lift(Query.mapToOptional(new Function<Cursor, Employee>() {
+                    @Override
+                    public Employee apply(Cursor cursor) throws Exception {
+                        return null;
+                    }
+                }))
+                .test()
+                .assertError(NullPointerException.class)
+                .assertErrorMessage("QueryToOne mapper returned null");
+    }
+
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+    @Test
+    public void mapToOptionalThrowsOnMultipleRows() {
         db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 2") //
-            .lift(Query.mapToOneOrDefault(
-                MAPPER, new Employee("fred", "Fred Frederson")));
-    try {
-      employees.blockingFirst();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Cursor returned more than 1 row");
+                .lift(Query.mapToOptional(MAPPER))
+                .test()
+                .assertError(IllegalStateException.class)
+                .assertErrorMessage("Cursor returned more than 1 row");
+    }
+
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
+    @Test
+    public void mapToOptionalIgnoresNullCursor() {
+        Query nully = new Query() {
+            @Nullable
+            @Override
+            public Cursor run() {
+                return null;
+            }
+        };
+
+        Observable.just(nully)
+                .lift(Query.mapToOptional(MAPPER))
+                .test()
+                .assertValue(Optional.<Employee>empty());
     }
-  }
-
-  @Test public void mapToOneOrDefaultReturnsDefaultWhenNullCursor() {
-    Employee defaultEmployee = new Employee("bob", "Bob Bobberson");
-    Query nully = new Query() {
-      @Nullable @Override public Cursor run() {
-        return null;
-      }
-    };
-
-    TestObserver<Employee> observer = new TestObserver<>();
-    Observable.just(nully)
-        .lift(Query.mapToOneOrDefault(MAPPER, defaultEmployee))
-        .subscribe(observer);
-
-    observer.assertValues(defaultEmployee);
-    observer.assertComplete();
-  }
-
-  @Test public void mapToList() {
-    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
-        .lift(Query.mapToList(MAPPER))
-        .blockingFirst();
-    assertThat(employees).containsExactly( //
-        new Employee("alice", "Alice Allison"), //
-        new Employee("bob", "Bob Bobberson"), //
-        new Employee("eve", "Eve Evenson"));
-  }
-
-  @Test public void mapToListEmptyWhenNoRows() {
-    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE 1=2")
-        .lift(Query.mapToList(MAPPER))
-        .blockingFirst();
-    assertThat(employees).isEmpty();
-  }
-
-  @Test public void mapToListReturnsNullOnMapperNull() {
-    Function<Cursor, Employee> mapToNull = new Function<Cursor, Employee>() {
-      private int count;
-
-      @Override public Employee apply(Cursor cursor) throws Exception {
-        return count++ == 2 ? null : MAPPER.apply(cursor);
-      }
-    };
-    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES) //
-            .lift(Query.mapToList(mapToNull)) //
-            .blockingFirst();
-
-    assertThat(employees).containsExactly(
-        new Employee("alice", "Alice Allison"),
-        new Employee("bob", "Bob Bobberson"),
-        null);
-  }
-
-  @Test public void mapToListIgnoresNullCursor() {
-    Query nully = new Query() {
-      @Nullable @Override public Cursor run() {
-        return null;
-      }
-    };
-
-    TestObserver<List<Employee>> subscriber = new TestObserver<>();
-    Observable.just(nully)
-        .lift(Query.mapToList(MAPPER))
-        .subscribe(subscriber);
-
-    subscriber.assertNoValues();
-    subscriber.assertComplete();
-  }
-
-  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
-  @Test public void mapToOptional() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
-        .lift(Query.mapToOptional(MAPPER))
-        .test()
-        .assertValue(Optional.of(new Employee("alice", "Alice Allison")));
-  }
-
-  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
-  @Test public void mapToOptionalThrowsWhenMapperReturnsNull() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
-        .lift(Query.mapToOptional(new Function<Cursor, Employee>() {
-          @Override public Employee apply(Cursor cursor) throws Exception {
-            return null;
-          }
-        }))
-        .test()
-        .assertError(NullPointerException.class)
-        .assertErrorMessage("QueryToOne mapper returned null");
-  }
-
-  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
-  @Test public void mapToOptionalThrowsOnMultipleRows() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 2") //
-        .lift(Query.mapToOptional(MAPPER))
-        .test()
-        .assertError(IllegalStateException.class)
-        .assertErrorMessage("Cursor returned more than 1 row");
-  }
-
-  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.N)
-  @Test public void mapToOptionalIgnoresNullCursor() {
-    Query nully = new Query() {
-      @Nullable @Override public Cursor run() {
-        return null;
-      }
-    };
-
-    Observable.just(nully)
-        .lift(Query.mapToOptional(MAPPER))
-        .test()
-        .assertValue(Optional.<Employee>empty());
-  }
 }
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/TestDb.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/TestDb.java
index 71926e6..318c644 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/TestDb.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite3/TestDb.java
@@ -15,23 +15,27 @@
  */
 package com.squareup.sqlbrite3;
 
-import android.arch.persistence.db.SupportSQLiteDatabase;
-import android.arch.persistence.db.SupportSQLiteOpenHelper;
 import android.content.ContentValues;
+import android.content.Context;
 import android.database.Cursor;
 import android.support.annotation.NonNull;
-import io.reactivex.functions.Function;
+
+import net.sqlcipher.database.SQLiteDatabase;
+import net.sqlcipher.database.SQLiteOpenHelper;
+
 import java.util.Arrays;
 import java.util.Collection;
 
-import static android.database.sqlite.SQLiteDatabase.CONFLICT_FAIL;
+import io.reactivex.functions.Function;
+
 import static com.squareup.sqlbrite3.TestDb.EmployeeTable.ID;
 import static com.squareup.sqlbrite3.TestDb.EmployeeTable.NAME;
 import static com.squareup.sqlbrite3.TestDb.EmployeeTable.USERNAME;
 import static com.squareup.sqlbrite3.TestDb.ManagerTable.EMPLOYEE_ID;
 import static com.squareup.sqlbrite3.TestDb.ManagerTable.MANAGER_ID;
+import static net.sqlcipher.database.SQLiteDatabase.CONFLICT_FAIL;
 
-final class TestDb extends SupportSQLiteOpenHelper.Callback {
+final class TestDb extends SQLiteOpenHelper {
   static final String TABLE_EMPLOYEE = "employee";
   static final String TABLE_MANAGER = "manager";
 
@@ -47,6 +51,10 @@
   static final Collection<String> BOTH_TABLES =
       Arrays.asList(TABLE_EMPLOYEE, TABLE_MANAGER);
 
+  public TestDb(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
+    super(context, name, factory, version);
+  }
+
   interface EmployeeTable {
     String ID = "_id";
     String USERNAME = "username";
@@ -105,16 +113,16 @@
   long bobId;
   long eveId;
 
-  @Override public void onCreate(@NonNull SupportSQLiteDatabase db) {
+  @Override public void onCreate(@NonNull SQLiteDatabase db) {
     db.execSQL("PRAGMA foreign_keys=ON");
 
     db.execSQL(CREATE_EMPLOYEE);
-    aliceId = db.insert(TABLE_EMPLOYEE, CONFLICT_FAIL, employee("alice", "Alice Allison"));
-    bobId = db.insert(TABLE_EMPLOYEE, CONFLICT_FAIL, employee("bob", "Bob Bobberson"));
-    eveId = db.insert(TABLE_EMPLOYEE, CONFLICT_FAIL, employee("eve", "Eve Evenson"));
+    db.insertWithOnConflict(TABLE_EMPLOYEE, null, employee("alice", "Alice Allison"), CONFLICT_FAIL);
+    db.insertWithOnConflict(TABLE_EMPLOYEE, null, employee("bob", "Bob Bobberson"), CONFLICT_FAIL);
+    db.insertWithOnConflict(TABLE_EMPLOYEE, null, employee("eve", "Eve Evenson"), CONFLICT_FAIL);
 
     db.execSQL(CREATE_MANAGER);
-    db.insert(TABLE_MANAGER, CONFLICT_FAIL, manager(eveId, aliceId));
+    db.insertWithOnConflict(TABLE_MANAGER, null, manager(eveId, aliceId), CONFLICT_FAIL);
   }
 
   static ContentValues employee(String username, String name) {
@@ -132,7 +140,7 @@ static ContentValues manager(long employeeId, long managerId) {
   }
 
   @Override
-  public void onUpgrade(@NonNull SupportSQLiteDatabase db, int oldVersion, int newVersion) {
+  public void onUpgrade(@NonNull SQLiteDatabase db, int oldVersion, int newVersion) {
     throw new AssertionError();
   }
 }
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite3/BriteDatabase.java b/sqlbrite/src/main/java/com/squareup/sqlbrite3/BriteDatabase.java
index ef2766a..0875399 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite3/BriteDatabase.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite3/BriteDatabase.java
@@ -17,20 +17,34 @@
 
 import android.arch.persistence.db.SimpleSQLiteQuery;
 import android.arch.persistence.db.SupportSQLiteDatabase;
-import android.arch.persistence.db.SupportSQLiteOpenHelper;
-import android.arch.persistence.db.SupportSQLiteOpenHelper.Callback;
 import android.arch.persistence.db.SupportSQLiteQuery;
-import android.arch.persistence.db.SupportSQLiteStatement;
 import android.content.ContentValues;
 import android.database.Cursor;
-import android.database.sqlite.SQLiteTransactionListener;
 import android.support.annotation.CheckResult;
 import android.support.annotation.IntDef;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.annotation.WorkerThread;
+
 import com.squareup.sqlbrite3.SqlBrite.Logger;
 import com.squareup.sqlbrite3.SqlBrite.Query;
+
+import net.sqlcipher.database.SQLiteCursor;
+import net.sqlcipher.database.SQLiteCursorDriver;
+import net.sqlcipher.database.SQLiteDatabase;
+import net.sqlcipher.database.SQLiteOpenHelper;
+import net.sqlcipher.database.SQLiteQuery;
+import net.sqlcipher.database.SQLiteQueryBuilder;
+import net.sqlcipher.database.SQLiteStatement;
+
+import java.io.Closeable;
+import java.lang.annotation.Retention;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+
 import io.reactivex.Observable;
 import io.reactivex.ObservableTransformer;
 import io.reactivex.Scheduler;
@@ -39,13 +53,6 @@
 import io.reactivex.functions.Predicate;
 import io.reactivex.subjects.PublishSubject;
 import io.reactivex.subjects.Subject;
-import java.io.Closeable;
-import java.lang.annotation.Retention;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
 
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_ABORT;
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_FAIL;
@@ -60,750 +67,790 @@
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
 /**
- * A lightweight wrapper around {@link SupportSQLiteOpenHelper} which allows for continuously
+ * A lightweight wrapper around {@link SQLiteOpenHelper} which allows for continuously
  * observing the result of a query. Create using a {@link SqlBrite} instance.
  */
 public final class BriteDatabase implements Closeable {
-  private final SupportSQLiteOpenHelper helper;
-  private final Logger logger;
-  private final ObservableTransformer<Query, Query> queryTransformer;
-
-  // Package-private to avoid synthetic accessor method for 'transaction' instance.
-  final ThreadLocal<SqliteTransaction> transactions = new ThreadLocal<>();
-  private final Subject<Set<String>> triggers = PublishSubject.create();
-
-  private final Transaction transaction = new Transaction() {
-    @Override public void markSuccessful() {
-      if (logging) log("TXN SUCCESS %s", transactions.get());
-      getWritableDatabase().setTransactionSuccessful();
-    }
-
-    @Override public boolean yieldIfContendedSafely() {
-      return getWritableDatabase().yieldIfContendedSafely();
-    }
-
-    @Override public boolean yieldIfContendedSafely(long sleepAmount, TimeUnit sleepUnit) {
-      return getWritableDatabase().yieldIfContendedSafely(sleepUnit.toMillis(sleepAmount));
-    }
-
-    @Override public void end() {
-      SqliteTransaction transaction = transactions.get();
-      if (transaction == null) {
-        throw new IllegalStateException("Not in transaction.");
-      }
-      SqliteTransaction newTransaction = transaction.parent;
-      transactions.set(newTransaction);
-      if (logging) log("TXN END %s", transaction);
-      getWritableDatabase().endTransaction();
-      // Send the triggers after ending the transaction in the DB.
-      if (transaction.commit) {
-        sendTableTrigger(transaction);
-      }
-    }
-
-    @Override public void close() {
-      end();
-    }
-  };
-  private final Consumer<Object> ensureNotInTransaction = new Consumer<Object>() {
-    @Override public void accept(Object ignored) throws Exception {
-      if (transactions.get() != null) {
-        throw new IllegalStateException("Cannot subscribe to observable query in a transaction.");
-      }
-    }
-  };
-
-  private final Scheduler scheduler;
-
-  // Package-private to avoid synthetic accessor method for 'transaction' instance.
-  volatile boolean logging;
-
-  BriteDatabase(SupportSQLiteOpenHelper helper, Logger logger, Scheduler scheduler,
-      ObservableTransformer<Query, Query> queryTransformer) {
-    this.helper = helper;
-    this.logger = logger;
-    this.scheduler = scheduler;
-    this.queryTransformer = queryTransformer;
-  }
-
-  /**
-   * Control whether debug logging is enabled.
-   */
-  public void setLoggingEnabled(boolean enabled) {
-    logging = enabled;
-  }
-
-  /**
-   * Create and/or open a database.  This will be the same object returned by
-   * {@link SupportSQLiteOpenHelper#getWritableDatabase} unless some problem, such as a full disk,
-   * requires the database to be opened read-only.  In that case, a read-only
-   * database object will be returned.  If the problem is fixed, a future call
-   * to {@link SupportSQLiteOpenHelper#getWritableDatabase} may succeed, in which case the read-only
-   * database object will be closed and the read/write object will be returned
-   * in the future.
-   *
-   * <p class="caution">Like {@link SupportSQLiteOpenHelper#getWritableDatabase}, this method may
-   * take a long time to return, so you should not call it from the
-   * application main thread, including from
-   * {@link android.content.ContentProvider#onCreate ContentProvider.onCreate()}.
-   *
-   * @throws android.database.sqlite.SQLiteException if the database cannot be opened
-   * @return a database object valid until {@link SupportSQLiteOpenHelper#getWritableDatabase}
-   *     or {@link #close} is called.
-   */
-  @NonNull @CheckResult @WorkerThread
-  public SupportSQLiteDatabase getReadableDatabase() {
-    return helper.getReadableDatabase();
-  }
-
-  /**
-   * Create and/or open a database that will be used for reading and writing.
-   * The first time this is called, the database will be opened and
-   * {@link Callback#onCreate}, {@link Callback#onUpgrade} and/or {@link Callback#onOpen} will be
-   * called.
-   *
-   * <p>Once opened successfully, the database is cached, so you can
-   * call this method every time you need to write to the database.
-   * (Make sure to call {@link #close} when you no longer need the database.)
-   * Errors such as bad permissions or a full disk may cause this method
-   * to fail, but future attempts may succeed if the problem is fixed.</p>
-   *
-   * <p class="caution">Database upgrade may take a long time, you
-   * should not call this method from the application main thread, including
-   * from {@link android.content.ContentProvider#onCreate ContentProvider.onCreate()}.
-   *
-   * @throws android.database.sqlite.SQLiteException if the database cannot be opened for writing
-   * @return a read/write database object valid until {@link #close} is called
-   */
-  @NonNull @CheckResult @WorkerThread
-  public SupportSQLiteDatabase getWritableDatabase() {
-    return helper.getWritableDatabase();
-  }
-
-  void sendTableTrigger(Set<String> tables) {
-    SqliteTransaction transaction = transactions.get();
-    if (transaction != null) {
-      transaction.addAll(tables);
-    } else {
-      if (logging) log("TRIGGER %s", tables);
-      triggers.onNext(tables);
-    }
-  }
-
-  /**
-   * Begin a transaction for this thread.
-   * <p>
-   * Transactions may nest. If the transaction is not in progress, then a database connection is
-   * obtained and a new transaction is started. Otherwise, a nested transaction is started.
-   * <p>
-   * Each call to {@code newTransaction} must be matched exactly by a call to
-   * {@link Transaction#end()}. To mark a transaction as successful, call
-   * {@link Transaction#markSuccessful()} before calling {@link Transaction#end()}. If the
-   * transaction is not successful, or if any of its nested transactions were not successful, then
-   * the entire transaction will be rolled back when the outermost transaction is ended.
-   * <p>
-   * Transactions queue up all query notifications until they have been applied.
-   * <p>
-   * Here is the standard idiom for transactions:
-   *
-   * <pre>{@code
-   * try (Transaction transaction = db.newTransaction()) {
-   *   ...
-   *   transaction.markSuccessful();
-   * }
-   * }</pre>
-   *
-   * Manually call {@link Transaction#end()} when try-with-resources is not available:
-   * <pre>{@code
-   * Transaction transaction = db.newTransaction();
-   * try {
-   *   ...
-   *   transaction.markSuccessful();
-   * } finally {
-   *   transaction.end();
-   * }
-   * }</pre>
-   *
-   *
-   * @see SupportSQLiteDatabase#beginTransaction()
-   */
-  @CheckResult @NonNull
-  public Transaction newTransaction() {
-    SqliteTransaction transaction = new SqliteTransaction(transactions.get());
-    transactions.set(transaction);
-    if (logging) log("TXN BEGIN %s", transaction);
-    getWritableDatabase().beginTransactionWithListener(transaction);
-
-    return this.transaction;
-  }
-
-  /**
-   * Begins a transaction in IMMEDIATE mode for this thread.
-   * <p>
-   * Transactions may nest. If the transaction is not in progress, then a database connection is
-   * obtained and a new transaction is started. Otherwise, a nested transaction is started.
-   * <p>
-   * Each call to {@code newNonExclusiveTransaction} must be matched exactly by a call to
-   * {@link Transaction#end()}. To mark a transaction as successful, call
-   * {@link Transaction#markSuccessful()} before calling {@link Transaction#end()}. If the
-   * transaction is not successful, or if any of its nested transactions were not successful, then
-   * the entire transaction will be rolled back when the outermost transaction is ended.
-   * <p>
-   * Transactions queue up all query notifications until they have been applied.
-   * <p>
-   * Here is the standard idiom for transactions:
-   *
-   * <pre>{@code
-   * try (Transaction transaction = db.newNonExclusiveTransaction()) {
-   *   ...
-   *   transaction.markSuccessful();
-   * }
-   * }</pre>
-   *
-   * Manually call {@link Transaction#end()} when try-with-resources is not available:
-   * <pre>{@code
-   * Transaction transaction = db.newNonExclusiveTransaction();
-   * try {
-   *   ...
-   *   transaction.markSuccessful();
-   * } finally {
-   *   transaction.end();
-   * }
-   * }</pre>
-   *
-   *
-   * @see SupportSQLiteDatabase#beginTransactionNonExclusive()
-   */
-  @CheckResult @NonNull
-  public Transaction newNonExclusiveTransaction() {
-    SqliteTransaction transaction = new SqliteTransaction(transactions.get());
-    transactions.set(transaction);
-    if (logging) log("TXN BEGIN %s", transaction);
-    getWritableDatabase().beginTransactionWithListenerNonExclusive(transaction);
-
-    return this.transaction;
-  }
-
-  /**
-   * Close the underlying {@link SupportSQLiteOpenHelper} and remove cached readable and writeable
-   * databases. This does not prevent existing observables from retaining existing references as
-   * well as attempting to create new ones for new subscriptions.
-   */
-  @Override public void close() {
-    helper.close();
-  }
-
-  /**
-   * Create an observable which will notify subscribers with a {@linkplain Query query} for
-   * execution. Subscribers are responsible for <b>always</b> closing {@link Cursor} instance
-   * returned from the {@link Query}.
-   * <p>
-   * Subscribers will receive an immediate notification for initial data as well as subsequent
-   * notifications for when the supplied {@code table}'s data changes through the {@code insert},
-   * {@code update}, and {@code delete} methods of this class. Unsubscribe when you no longer want
-   * updates to a query.
-   * <p>
-   * Since database triggers are inherently asynchronous, items emitted from the returned
-   * observable use the {@link Scheduler} supplied to {@link SqlBrite#wrapDatabaseHelper}. For
-   * consistency, the immediate notification sent on subscribe also uses this scheduler. As such,
-   * calling {@link Observable#subscribeOn subscribeOn} on the returned observable has no effect.
-   * <p>
-   * Note: To skip the immediate notification and only receive subsequent notifications when data
-   * has changed call {@code skip(1)} on the returned observable.
-   * <p>
-   * <b>Warning:</b> this method does not perform the query! Only by subscribing to the returned
-   * {@link Observable} will the operation occur.
-   *
-   * @see SupportSQLiteDatabase#query(String, Object[])
-   */
-  @CheckResult @NonNull
-  public QueryObservable createQuery(@NonNull final String table, @NonNull String sql,
-      @NonNull Object... args) {
-    return createQuery(new DatabaseQuery(singletonList(table), new SimpleSQLiteQuery(sql, args)));
-  }
-
-  /**
-   * See {@link #createQuery(String, String, Object...)} for usage. This overload allows for
-   * monitoring multiple tables for changes.
-   *
-   * @see SupportSQLiteDatabase#query(String, Object[])
-   */
-  @CheckResult @NonNull
-  public QueryObservable createQuery(@NonNull final Iterable<String> tables, @NonNull String sql,
-      @NonNull Object... args) {
-    return createQuery(new DatabaseQuery(tables, new SimpleSQLiteQuery(sql, args)));
-  }
-
-  /**
-   * Create an observable which will notify subscribers with a {@linkplain Query query} for
-   * execution. Subscribers are responsible for <b>always</b> closing {@link Cursor} instance
-   * returned from the {@link Query}.
-   * <p>
-   * Subscribers will receive an immediate notification for initial data as well as subsequent
-   * notifications for when the supplied {@code table}'s data changes through the {@code insert},
-   * {@code update}, and {@code delete} methods of this class. Unsubscribe when you no longer want
-   * updates to a query.
-   * <p>
-   * Since database triggers are inherently asynchronous, items emitted from the returned
-   * observable use the {@link Scheduler} supplied to {@link SqlBrite#wrapDatabaseHelper}. For
-   * consistency, the immediate notification sent on subscribe also uses this scheduler. As such,
-   * calling {@link Observable#subscribeOn subscribeOn} on the returned observable has no effect.
-   * <p>
-   * Note: To skip the immediate notification and only receive subsequent notifications when data
-   * has changed call {@code skip(1)} on the returned observable.
-   * <p>
-   * <b>Warning:</b> this method does not perform the query! Only by subscribing to the returned
-   * {@link Observable} will the operation occur.
-   *
-   * @see SupportSQLiteDatabase#query(SupportSQLiteQuery)
-   */
-  @CheckResult @NonNull
-  public QueryObservable createQuery(@NonNull final String table,
-      @NonNull SupportSQLiteQuery query) {
-    return createQuery(new DatabaseQuery(singletonList(table), query));
-  }
-
-  /**
-   * See {@link #createQuery(String, SupportSQLiteQuery)} for usage. This overload allows for
-   * monitoring multiple tables for changes.
-   *
-   * @see SupportSQLiteDatabase#query(SupportSQLiteQuery)
-   */
-  @CheckResult @NonNull
-  public QueryObservable createQuery(@NonNull final Iterable<String> tables,
-      @NonNull SupportSQLiteQuery query) {
-    return createQuery(new DatabaseQuery(tables, query));
-  }
-
-  @CheckResult @NonNull
-  private QueryObservable createQuery(DatabaseQuery query) {
-    if (transactions.get() != null) {
-      throw new IllegalStateException("Cannot create observable query in transaction. "
-          + "Use query() for a query inside a transaction.");
-    }
-
-    return triggers //
-        .filter(query) // DatabaseQuery filters triggers to on tables we care about.
-        .map(query) // DatabaseQuery maps to itself to save an allocation.
-        .startWith(query) //
-        .observeOn(scheduler) //
-        .compose(queryTransformer) // Apply the user's query transformer.
-        .doOnSubscribe(ensureNotInTransaction)
-        .to(QUERY_OBSERVABLE);
-  }
-
-  /**
-   * Runs the provided SQL and returns a {@link Cursor} over the result set.
-   *
-   * @see SupportSQLiteDatabase#query(String, Object[])
-   */
-  @CheckResult @WorkerThread
-  public Cursor query(@NonNull String sql, @NonNull Object... args) {
-    long startNanos = nanoTime();
-    Cursor cursor = getReadableDatabase().query(sql, args);
-    long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
-
-    if (logging) {
-      log("QUERY (%sms)\n  sql: %s\n  args: %s", tookMillis, indentSql(sql), Arrays.toString(args));
-    }
-
-    return cursor;
-  }
-
-  /**
-   * Insert a row into the specified {@code table} and notify any subscribed queries.
-   *
-   * @see SupportSQLiteDatabase#insert(String, int, ContentValues)
-   */
-  @WorkerThread
-  public long insert(@NonNull String table, @ConflictAlgorithm int conflictAlgorithm,
-      @NonNull ContentValues values) {
-    SupportSQLiteDatabase db = getWritableDatabase();
-
-    if (logging) {
-      log("INSERT\n  table: %s\n  values: %s\n  conflictAlgorithm: %s", table, values,
-          conflictString(conflictAlgorithm));
-    }
-    long rowId = db.insert(table, conflictAlgorithm, values);
-
-    if (logging) log("INSERT id: %s", rowId);
-
-    if (rowId != -1) {
-      // Only send a table trigger if the insert was successful.
-      sendTableTrigger(Collections.singleton(table));
-    }
-    return rowId;
-  }
-
-  /**
-   * Delete rows from the specified {@code table} and notify any subscribed queries. This method
-   * will not trigger a notification if no rows were deleted.
-   *
-   * @see SupportSQLiteDatabase#delete(String, String, Object[])
-   */
-  @WorkerThread
-  public int delete(@NonNull String table, @Nullable String whereClause,
-      @Nullable String... whereArgs) {
-    SupportSQLiteDatabase db = getWritableDatabase();
-
-    if (logging) {
-      log("DELETE\n  table: %s\n  whereClause: %s\n  whereArgs: %s", table, whereClause,
-          Arrays.toString(whereArgs));
-    }
-    int rows = db.delete(table, whereClause, whereArgs);
-
-    if (logging) log("DELETE affected %s %s", rows, rows != 1 ? "rows" : "row");
-
-    if (rows > 0) {
-      // Only send a table trigger if rows were affected.
-      sendTableTrigger(Collections.singleton(table));
-    }
-    return rows;
-  }
-
-  /**
-   * Update rows in the specified {@code table} and notify any subscribed queries. This method
-   * will not trigger a notification if no rows were updated.
-   *
-   * @see SupportSQLiteDatabase#update(String, int, ContentValues, String, Object[])
-   */
-  @WorkerThread
-  public int update(@NonNull String table, @ConflictAlgorithm int conflictAlgorithm,
-      @NonNull ContentValues values, @Nullable String whereClause, @Nullable String... whereArgs) {
-    SupportSQLiteDatabase db = getWritableDatabase();
-
-    if (logging) {
-      log("UPDATE\n  table: %s\n  values: %s\n  whereClause: %s\n  whereArgs: %s\n  conflictAlgorithm: %s",
-          table, values, whereClause, Arrays.toString(whereArgs),
-          conflictString(conflictAlgorithm));
-    }
-    int rows = db.update(table, conflictAlgorithm, values, whereClause, whereArgs);
-
-    if (logging) log("UPDATE affected %s %s", rows, rows != 1 ? "rows" : "row");
-
-    if (rows > 0) {
-      // Only send a table trigger if rows were affected.
-      sendTableTrigger(Collections.singleton(table));
-    }
-    return rows;
-  }
-
-  /**
-   * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
-   * returns data. No data can be returned (such as the number of affected rows). Instead, use
-   * {@link #insert}, {@link #update}, et al, when possible.
-   * <p>
-   * No notifications will be sent to queries if {@code sql} affects the data of a table.
-   *
-   * @see SupportSQLiteDatabase#execSQL(String)
-   */
-  @WorkerThread
-  public void execute(String sql) {
-    if (logging) log("EXECUTE\n  sql: %s", sql);
-
-    getWritableDatabase().execSQL(sql);
-  }
-
-  /**
-   * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
-   * returns data. No data can be returned (such as the number of affected rows). Instead, use
-   * {@link #insert}, {@link #update}, et al, when possible.
-   * <p>
-   * No notifications will be sent to queries if {@code sql} affects the data of a table.
-   *
-   * @see SupportSQLiteDatabase#execSQL(String, Object[])
-   */
-  @WorkerThread
-  public void execute(String sql, Object... args) {
-    if (logging) log("EXECUTE\n  sql: %s\n  args: %s", sql, Arrays.toString(args));
-
-    getWritableDatabase().execSQL(sql, args);
-  }
-
-  /**
-   * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
-   * returns data. No data can be returned (such as the number of affected rows). Instead, use
-   * {@link #insert}, {@link #update}, et al, when possible.
-   * <p>
-   * A notification to queries for {@code table} will be sent after the statement is executed.
-   *
-   * @see SupportSQLiteDatabase#execSQL(String)
-   */
-  @WorkerThread
-  public void executeAndTrigger(String table, String sql) {
-    executeAndTrigger(Collections.singleton(table), sql);
-  }
-
-  /**
-   * See {@link #executeAndTrigger(String, String)} for usage. This overload allows for triggering multiple tables.
-   *
-   * @see BriteDatabase#executeAndTrigger(String, String)
-   */
-  @WorkerThread
-  public void executeAndTrigger(Set<String> tables, String sql) {
-    execute(sql);
-
-    sendTableTrigger(tables);
-  }
-
-  /**
-   * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
-   * returns data. No data can be returned (such as the number of affected rows). Instead, use
-   * {@link #insert}, {@link #update}, et al, when possible.
-   * <p>
-   * A notification to queries for {@code table} will be sent after the statement is executed.
-   *
-   * @see SupportSQLiteDatabase#execSQL(String, Object[])
-   */
-  @WorkerThread
-  public void executeAndTrigger(String table, String sql, Object... args) {
-    executeAndTrigger(Collections.singleton(table), sql, args);
-  }
-
-  /**
-   * See {@link #executeAndTrigger(String, String, Object...)} for usage. This overload allows for triggering multiple tables.
-   *
-   * @see BriteDatabase#executeAndTrigger(String, String, Object...)
-   */
-  @WorkerThread
-  public void executeAndTrigger(Set<String> tables, String sql, Object... args) {
-    execute(sql, args);
-
-    sendTableTrigger(tables);
-  }
-
-  /**
-   * Execute {@code statement}, if the the number of rows affected by execution of this SQL
-   * statement is of any importance to the caller - for example, UPDATE / DELETE SQL statements.
-   *
-   * @return the number of rows affected by this SQL statement execution.
-   * @throws android.database.SQLException If the SQL string is invalid
-   *
-   * @see SupportSQLiteStatement#executeUpdateDelete()
-   */
-  @WorkerThread
-  public int executeUpdateDelete(String table, SupportSQLiteStatement statement) {
-    return executeUpdateDelete(Collections.singleton(table), statement);
-  }
-
-  /**
-   * See {@link #executeUpdateDelete(String, SupportSQLiteStatement)} for usage. This overload
-   * allows for triggering multiple tables.
-   *
-   * @see BriteDatabase#executeUpdateDelete(String, SupportSQLiteStatement)
-   */
-  @WorkerThread
-  public int executeUpdateDelete(Set<String> tables, SupportSQLiteStatement statement) {
-    if (logging) log("EXECUTE\n %s", statement);
-
-    int rows = statement.executeUpdateDelete();
-    if (rows > 0) {
-      // Only send a table trigger if rows were affected.
-      sendTableTrigger(tables);
-    }
-    return rows;
-  }
-
-  /**
-   * Execute {@code statement} and return the ID of the row inserted due to this call.
-   * The SQL statement should be an INSERT for this to be a useful call.
-   *
-   * @return the row ID of the last row inserted, if this insert is successful. -1 otherwise.
-   *
-   * @throws android.database.SQLException If the SQL string is invalid
-   *
-   * @see SupportSQLiteStatement#executeInsert()
-   */
-  @WorkerThread
-  public long executeInsert(String table, SupportSQLiteStatement statement) {
-    return executeInsert(Collections.singleton(table), statement);
-  }
-
-  /**
-   * See {@link #executeInsert(String, SupportSQLiteStatement)} for usage. This overload allows for
-   * triggering multiple tables.
-   *
-   * @see BriteDatabase#executeInsert(String, SupportSQLiteStatement)
-   */
-  @WorkerThread
-  public long executeInsert(Set<String> tables, SupportSQLiteStatement statement) {
-    if (logging) log("EXECUTE\n %s", statement);
-
-    long rowId = statement.executeInsert();
-    if (rowId != -1) {
-      // Only send a table trigger if the insert was successful.
-      sendTableTrigger(tables);
-    }
-    return rowId;
-  }
-
-  /** An in-progress database transaction. */
-  public interface Transaction extends Closeable {
+    private final SQLiteOpenHelper helper;
+    private final char[] password;
+    private final Logger logger;
+    private final ObservableTransformer<Query, Query> queryTransformer;
+
+    // Package-private to avoid synthetic accessor method for 'transaction' instance.
+    final ThreadLocal<SqliteTransaction> transactions = new ThreadLocal<>();
+    private final Subject<Set<String>> triggers = PublishSubject.create();
+
+    private final Transaction transaction = new Transaction() {
+        @Override
+        public void markSuccessful() {
+            if (logging) log("TXN SUCCESS %s", transactions.get());
+            getWritableDatabase(password).setTransactionSuccessful();
+        }
+
+        @Override
+        public boolean yieldIfContendedSafely() {
+            return getWritableDatabase(password).yieldIfContendedSafely();
+        }
+
+        @Override
+        public boolean yieldIfContendedSafely(long sleepAmount, TimeUnit sleepUnit) {
+            return getWritableDatabase(password).yieldIfContendedSafely(sleepUnit.toMillis(sleepAmount));
+        }
+
+        @Override
+        public void end() {
+            SqliteTransaction transaction = transactions.get();
+            if (transaction == null) {
+                throw new IllegalStateException("Not in transaction.");
+            }
+            SqliteTransaction newTransaction = transaction.parent;
+            transactions.set(newTransaction);
+            if (logging) log("TXN END %s", transaction);
+            getWritableDatabase(password).endTransaction();
+            // Send the triggers after ending the transaction in the DB.
+            if (transaction.commit) {
+                sendTableTrigger(transaction);
+            }
+        }
+
+        @Override
+        public void close() {
+            end();
+        }
+    };
+    private final Consumer<Object> ensureNotInTransaction = new Consumer<Object>() {
+        @Override
+        public void accept(Object ignored) throws Exception {
+            if (transactions.get() != null) {
+                throw new IllegalStateException("Cannot subscribe to observable query in a transaction.");
+            }
+        }
+    };
+
+    private final Scheduler scheduler;
+
+    // Package-private to avoid synthetic accessor method for 'transaction' instance.
+    volatile boolean logging;
+
+    BriteDatabase(SQLiteOpenHelper helper, char[] password, Logger logger, Scheduler scheduler,
+                  ObservableTransformer<Query, Query> queryTransformer) {
+        this.helper = helper;
+        this.password = password;
+        this.logger = logger;
+        this.scheduler = scheduler;
+        this.queryTransformer = queryTransformer;
+    }
+
     /**
-     * End a transaction. See {@link #newTransaction()} for notes about how to use this and when
-     * transactions are committed and rolled back.
+     * Control whether debug logging is enabled.
+     */
+    public void setLoggingEnabled(boolean enabled) {
+        logging = enabled;
+    }
+
+    /**
+     * Create and/or open a database.  This will be the same object returned by
+     * {@link SQLiteOpenHelper#getWritableDatabase} unless some problem, such as a full disk,
+     * requires the database to be opened read-only.  In that case, a read-only
+     * database object will be returned.  If the problem is fixed, a future call
+     * to {@link SQLiteOpenHelper#getWritableDatabase} may succeed, in which case the read-only
+     * database object will be closed and the read/write object will be returned
+     * in the future.
+     * <p>
+     * <p class="caution">Like {@link SQLiteOpenHelper#getWritableDatabase}, this method may
+     * take a long time to return, so you should not call it from the
+     * application main thread, including from
+     * {@link android.content.ContentProvider#onCreate ContentProvider.onCreate()}.
      *
-     * @see SupportSQLiteDatabase#endTransaction()
+     * @return a database object valid until {@link SQLiteOpenHelper#getWritableDatabase}
+     * or {@link #close} is called.
+     * @throws android.database.sqlite.SQLiteException if the database cannot be opened
      */
+    @NonNull
+    @CheckResult
     @WorkerThread
-    void end();
+    public SQLiteDatabase getReadableDatabase(char[] password) {
+        return helper.getReadableDatabase(password);
+    }
 
     /**
-     * Marks the current transaction as successful. Do not do any more database work between
-     * calling this and calling {@link #end()}. Do as little non-database work as possible in that
-     * situation too. If any errors are encountered between this and {@link #end()} the transaction
-     * will still be committed.
+     * Create and/or open a database that will be used for reading and writing.
+     * The first time this is called, the database will be opened and
+     * {@link SQLiteOpenHelper#onCreate}, {@link SQLiteOpenHelper#onUpgrade} and/or {@link SQLiteOpenHelper#onOpen} will be
+     * called.
+     * <p>
+     * <p>Once opened successfully, the database is cached, so you can
+     * call this method every time you need to write to the database.
+     * (Make sure to call {@link #close} when you no longer need the database.)
+     * Errors such as bad permissions or a full disk may cause this method
+     * to fail, but future attempts may succeed if the problem is fixed.</p>
+     * <p>
+     * <p class="caution">Database upgrade may take a long time, you
+     * should not call this method from the application main thread, including
+     * from {@link android.content.ContentProvider#onCreate ContentProvider.onCreate()}.
      *
-     * @see SupportSQLiteDatabase#setTransactionSuccessful()
+     * @return a read/write database object valid until {@link #close} is called
+     * @throws android.database.sqlite.SQLiteException if the database cannot be opened for writing
      */
+    @NonNull
+    @CheckResult
     @WorkerThread
-    void markSuccessful();
+    public SQLiteDatabase getWritableDatabase(char[] password) {
+        return helper.getWritableDatabase(password);
+    }
+
+    void sendTableTrigger(Set<String> tables) {
+        SqliteTransaction transaction = transactions.get();
+        if (transaction != null) {
+            transaction.addAll(tables);
+        } else {
+            if (logging) log("TRIGGER %s", tables);
+            triggers.onNext(tables);
+        }
+    }
 
     /**
-     * Temporarily end the transaction to let other threads run. The transaction is assumed to be
-     * successful so far. Do not call {@link #markSuccessful()} before calling this. When this
-     * returns a new transaction will have been created but not marked as successful. This assumes
-     * that there are no nested transactions (newTransaction has only been called once) and will
-     * throw an exception if that is not the case.
+     * Begin a transaction for this thread.
+     * <p>
+     * Transactions may nest. If the transaction is not in progress, then a database connection is
+     * obtained and a new transaction is started. Otherwise, a nested transaction is started.
+     * <p>
+     * Each call to {@code newTransaction} must be matched exactly by a call to
+     * {@link Transaction#end()}. To mark a transaction as successful, call
+     * {@link Transaction#markSuccessful()} before calling {@link Transaction#end()}. If the
+     * transaction is not successful, or if any of its nested transactions were not successful, then
+     * the entire transaction will be rolled back when the outermost transaction is ended.
+     * <p>
+     * Transactions queue up all query notifications until they have been applied.
+     * <p>
+     * Here is the standard idiom for transactions:
+     * <p>
+     * <pre>{@code
+     * try (Transaction transaction = db.newTransaction()) {
+     *   ...
+     *   transaction.markSuccessful();
+     * }
+     * }</pre>
+     * <p>
+     * Manually call {@link Transaction#end()} when try-with-resources is not available:
+     * <pre>{@code
+     * Transaction transaction = db.newTransaction();
+     * try {
+     *   ...
+     *   transaction.markSuccessful();
+     * } finally {
+     *   transaction.end();
+     * }
+     * }</pre>
      *
-     * @return true if the transaction was yielded
+     * @see SQLiteDatabase#beginTransaction()
+     */
+    @CheckResult
+    @NonNull
+    public Transaction newTransaction() {
+        SqliteTransaction transaction = new SqliteTransaction(transactions.get());
+        transactions.set(transaction);
+        if (logging) log("TXN BEGIN %s", transaction);
+        getWritableDatabase(password).beginTransactionWithListener(transaction);
+
+        return this.transaction;
+    }
+
+    /**
+     * Begins a transaction in IMMEDIATE mode for this thread.
+     * <p>
+     * Transactions may nest. If the transaction is not in progress, then a database connection is
+     * obtained and a new transaction is started. Otherwise, a nested transaction is started.
+     * <p>
+     * Each call to {@code newNonExclusiveTransaction} must be matched exactly by a call to
+     * {@link Transaction#end()}. To mark a transaction as successful, call
+     * {@link Transaction#markSuccessful()} before calling {@link Transaction#end()}. If the
+     * transaction is not successful, or if any of its nested transactions were not successful, then
+     * the entire transaction will be rolled back when the outermost transaction is ended.
+     * <p>
+     * Transactions queue up all query notifications until they have been applied.
+     * <p>
+     * Here is the standard idiom for transactions:
+     * <p>
+     * <pre>{@code
+     * try (Transaction transaction = db.newNonExclusiveTransaction()) {
+     *   ...
+     *   transaction.markSuccessful();
+     * }
+     * }</pre>
+     * <p>
+     * Manually call {@link Transaction#end()} when try-with-resources is not available:
+     * <pre>{@code
+     * Transaction transaction = db.newNonExclusiveTransaction();
+     * try {
+     *   ...
+     *   transaction.markSuccessful();
+     * } finally {
+     *   transaction.end();
+     * }
+     * }</pre>
+     *
+     * @see SQLiteDatabase#beginTransaction()
+     */
+    @CheckResult
+    @NonNull
+    public Transaction newNonExclusiveTransaction() {
+        SqliteTransaction transaction = new SqliteTransaction(transactions.get());
+        transactions.set(transaction);
+        if (logging) log("TXN BEGIN %s", transaction);
+        getWritableDatabase(password).beginTransactionWithListener(transaction);
+
+        return this.transaction;
+    }
+
+    /**
+     * Close the underlying {@link SQLiteOpenHelper} and remove cached readable and writeable
+     * databases. This does not prevent existing observables from retaining existing references as
+     * well as attempting to create new ones for new subscriptions.
+     */
+    @Override
+    public void close() {
+        helper.close();
+    }
+
+    /**
+     * Create an observable which will notify subscribers with a {@linkplain Query query} for
+     * execution. Subscribers are responsible for <b>always</b> closing {@link Cursor} instance
+     * returned from the {@link Query}.
+     * <p>
+     * Subscribers will receive an immediate notification for initial data as well as subsequent
+     * notifications for when the supplied {@code table}'s data changes through the {@code insert},
+     * {@code update}, and {@code delete} methods of this class. Unsubscribe when you no longer want
+     * updates to a query.
+     * <p>
+     * Since database triggers are inherently asynchronous, items emitted from the returned
+     * observable use the {@link Scheduler} supplied to {@link SqlBrite#wrapDatabaseHelper}. For
+     * consistency, the immediate notification sent on subscribe also uses this scheduler. As such,
+     * calling {@link Observable#subscribeOn subscribeOn} on the returned observable has no effect.
+     * <p>
+     * Note: To skip the immediate notification and only receive subsequent notifications when data
+     * has changed call {@code skip(1)} on the returned observable.
+     * <p>
+     * <b>Warning:</b> this method does not perform the query! Only by subscribing to the returned
+     * {@link Observable} will the operation occur.
      *
-     * @see SupportSQLiteDatabase#yieldIfContendedSafely()
+     * @see SQLiteDatabase#rawQuery(String, Object[])
      */
+    @CheckResult
+    @NonNull
+    public QueryObservable createQuery(@NonNull final String table, @NonNull String sql,
+                                       @NonNull Object... args) {
+//        return createQuery(new DatabaseQuery(singletonList(table), new SimpleSQLiteQuery(sql, args)));
+        return createQuery(new DatabaseQuery(singletonList(table), sql, args));
+    }
+
+    /**
+     * See {@link #createQuery(String, String, Object...)} for usage. This overload allows for
+     * monitoring multiple tables for changes.
+     *
+     * @see SQLiteDatabase#rawQuery(String, Object[])
+     */
+    @CheckResult
+    @NonNull
+    public QueryObservable createQuery(@NonNull final Iterable<String> tables, @NonNull String sql,
+                                       @NonNull Object... args) {
+//        return createQuery(new DatabaseQuery(tables, new SimpleSQLiteQuery(sql, args)));
+        return createQuery(new DatabaseQuery(tables, sql, args));
+    }
+
+//    /**
+//     * Create an observable which will notify subscribers with a {@linkplain Query query} for
+//     * execution. Subscribers are responsible for <b>always</b> closing {@link Cursor} instance
+//     * returned from the {@link Query}.
+//     * <p>
+//     * Subscribers will receive an immediate notification for initial data as well as subsequent
+//     * notifications for when the supplied {@code table}'s data changes through the {@code insert},
+//     * {@code update}, and {@code delete} methods of this class. Unsubscribe when you no longer want
+//     * updates to a query.
+//     * <p>
+//     * Since database triggers are inherently asynchronous, items emitted from the returned
+//     * observable use the {@link Scheduler} supplied to {@link SqlBrite#wrapDatabaseHelper}. For
+//     * consistency, the immediate notification sent on subscribe also uses this scheduler. As such,
+//     * calling {@link Observable#subscribeOn subscribeOn} on the returned observable has no effect.
+//     * <p>
+//     * Note: To skip the immediate notification and only receive subsequent notifications when data
+//     * has changed call {@code skip(1)} on the returned observable.
+//     * <p>
+//     * <b>Warning:</b> this method does not perform the query! Only by subscribing to the returned
+//     * {@link Observable} will the operation occur.
+//     *
+//     * @see SQLiteDatabase#query(SQLiteQuery)
+//     */
+//    @CheckResult
+//    @NonNull
+//    public QueryObservable createQuery(@NonNull final String table,
+//                                       @NonNull SupportSQLiteQuery query) {
+//        return createQuery(new DatabaseQuery(singletonList(table), query));
+//    }
+
+//    /**
+//     * See {@link #createQuery(String, SQLiteQuery)} for usage. This overload allows for
+//     * monitoring multiple tables for changes.
+//     *
+//     * @see SQLiteDatabase#query(SQLiteQuery)
+//     */
+//    @CheckResult
+//    @NonNull
+//    public QueryObservable createQuery(@NonNull final Iterable<String> tables,
+//                                       @NonNull SupportSQLiteQuery query) {
+//        return createQuery(new DatabaseQuery(tables, query));
+//    }
+
+    @CheckResult
+    @NonNull
+    private QueryObservable createQuery(DatabaseQuery query) {
+        if (transactions.get() != null) {
+            throw new IllegalStateException("Cannot create observable query in transaction. "
+                    + "Use query() for a query inside a transaction.");
+        }
+
+        return triggers //
+                .filter(query) // DatabaseQuery filters triggers to on tables we care about.
+                .map(query) // DatabaseQuery maps to itself to save an allocation.
+                .startWith(query) //
+                .observeOn(scheduler) //
+                .compose(queryTransformer) // Apply the user's query transformer.
+                .doOnSubscribe(ensureNotInTransaction)
+                .to(QUERY_OBSERVABLE);
+    }
+
+    /**
+     * Runs the provided SQL and returns a {@link Cursor} over the result set.
+     *
+     * @see SQLiteDatabase#rawQuery(String, Object[])
+     */
+    @CheckResult
     @WorkerThread
-    boolean yieldIfContendedSafely();
+    public Cursor query(@NonNull String sql, @NonNull Object... args) {
+        long startNanos = nanoTime();
+        Cursor cursor = getReadableDatabase(password).rawQuery(sql, args);
+        long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
+
+        if (logging) {
+            log("QUERY (%sms)\n  sql: %s\n  args: %s", tookMillis, indentSql(sql), Arrays.toString(args));
+        }
+
+        return cursor;
+    }
 
     /**
-     * Temporarily end the transaction to let other threads run. The transaction is assumed to be
-     * successful so far. Do not call {@link #markSuccessful()} before calling this. When this
-     * returns a new transaction will have been created but not marked as successful. This assumes
-     * that there are no nested transactions (newTransaction has only been called once) and will
-     * throw an exception if that is not the case.
+     * Insert a row into the specified {@code table} and notify any subscribed queries.
      *
-     * @param sleepAmount if > 0, sleep this long before starting a new transaction if
-     *   the lock was actually yielded. This will allow other background threads to make some
-     *   more progress than they would if we started the transaction immediately.
-     * @return true if the transaction was yielded
+     * @see SQLiteDatabase#insertWithOnConflict(String, String, ContentValues, int)
+     */
+    @WorkerThread
+    public long insert(@NonNull String table, @ConflictAlgorithm int conflictAlgorithm,
+                       @NonNull ContentValues values) {
+        SQLiteDatabase db = getWritableDatabase(password);
+
+        if (logging) {
+            log("INSERT\n  table: %s\n  values: %s\n  conflictAlgorithm: %s", table, values,
+                    conflictString(conflictAlgorithm));
+        }
+        long rowId = db.insertWithOnConflict(table, null, values, conflictAlgorithm);
+
+        if (logging) log("INSERT id: %s", rowId);
+
+        if (rowId != -1) {
+            // Only send a table trigger if the insert was successful.
+            sendTableTrigger(Collections.singleton(table));
+        }
+        return rowId;
+    }
+
+    /**
+     * Delete rows from the specified {@code table} and notify any subscribed queries. This method
+     * will not trigger a notification if no rows were deleted.
+     *
+     * @see SQLiteDatabase#delete(String, String, String[])
+     */
+    @WorkerThread
+    public int delete(@NonNull String table, @Nullable String whereClause,
+                      @Nullable String... whereArgs) {
+        SQLiteDatabase db = getWritableDatabase(password);
+
+        if (logging) {
+            log("DELETE\n  table: %s\n  whereClause: %s\n  whereArgs: %s", table, whereClause,
+                    Arrays.toString(whereArgs));
+        }
+        int rows = db.delete(table, whereClause, whereArgs);
+
+        if (logging) log("DELETE affected %s %s", rows, rows != 1 ? "rows" : "row");
+
+        if (rows > 0) {
+            // Only send a table trigger if rows were affected.
+            sendTableTrigger(Collections.singleton(table));
+        }
+        return rows;
+    }
+
+    /**
+     * Update rows in the specified {@code table} and notify any subscribed queries. This method
+     * will not trigger a notification if no rows were updated.
      *
-     * @see SupportSQLiteDatabase#yieldIfContendedSafely(long)
+     * @see SQLiteDatabase#updateWithOnConflict(String, ContentValues, String, String[], int)
      */
     @WorkerThread
-    boolean yieldIfContendedSafely(long sleepAmount, TimeUnit sleepUnit);
+    public int update(@NonNull String table, @ConflictAlgorithm int conflictAlgorithm,
+                      @NonNull ContentValues values, @Nullable String whereClause, @Nullable String... whereArgs) {
+        SQLiteDatabase db = getWritableDatabase(password);
+
+        if (logging) {
+            log("UPDATE\n  table: %s\n  values: %s\n  whereClause: %s\n  whereArgs: %s\n  conflictAlgorithm: %s",
+                    table, values, whereClause, Arrays.toString(whereArgs),
+                    conflictString(conflictAlgorithm));
+        }
+        int rows = db.updateWithOnConflict(table, values, whereClause, whereArgs, conflictAlgorithm);
+
+        if (logging) log("UPDATE affected %s %s", rows, rows != 1 ? "rows" : "row");
+
+        if (rows > 0) {
+            // Only send a table trigger if rows were affected.
+            sendTableTrigger(Collections.singleton(table));
+        }
+        return rows;
+    }
 
     /**
-     * Equivalent to calling {@link #end()}
+     * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
+     * returns data. No data can be returned (such as the number of affected rows). Instead, use
+     * {@link #insert}, {@link #update}, et al, when possible.
+     * <p>
+     * No notifications will be sent to queries if {@code sql} affects the data of a table.
+     *
+     * @see SQLiteDatabase#execSQL(String)
      */
     @WorkerThread
-    @Override void close();
-  }
+    public void execute(String sql) {
+        if (logging) log("EXECUTE\n  sql: %s", sql);
 
-  @IntDef({
-      CONFLICT_ABORT,
-      CONFLICT_FAIL,
-      CONFLICT_IGNORE,
-      CONFLICT_NONE,
-      CONFLICT_REPLACE,
-      CONFLICT_ROLLBACK
-  })
-  @Retention(SOURCE)
-  private @interface ConflictAlgorithm {
-  }
+        getWritableDatabase(password).execSQL(sql);
+    }
 
-  static String indentSql(String sql) {
-    return sql.replace("\n", "\n       ");
-  }
+    /**
+     * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
+     * returns data. No data can be returned (such as the number of affected rows). Instead, use
+     * {@link #insert}, {@link #update}, et al, when possible.
+     * <p>
+     * No notifications will be sent to queries if {@code sql} affects the data of a table.
+     *
+     * @see SQLiteDatabase#execSQL(String, Object[])
+     */
+    @WorkerThread
+    public void execute(String sql, Object... args) {
+        if (logging) log("EXECUTE\n  sql: %s\n  args: %s", sql, Arrays.toString(args));
 
-  void log(String message, Object... args) {
-    if (args.length > 0) message = String.format(message, args);
-    logger.log(message);
-  }
+        getWritableDatabase(password).execSQL(sql, args);
+    }
 
-  private static String conflictString(@ConflictAlgorithm int conflictAlgorithm) {
-    switch (conflictAlgorithm) {
-      case CONFLICT_ABORT:
-        return "abort";
-      case CONFLICT_FAIL:
-        return "fail";
-      case CONFLICT_IGNORE:
-        return "ignore";
-      case CONFLICT_NONE:
-        return "none";
-      case CONFLICT_REPLACE:
-        return "replace";
-      case CONFLICT_ROLLBACK:
-        return "rollback";
-      default:
-        return "unknown (" + conflictAlgorithm + ')';
+    /**
+     * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
+     * returns data. No data can be returned (such as the number of affected rows). Instead, use
+     * {@link #insert}, {@link #update}, et al, when possible.
+     * <p>
+     * A notification to queries for {@code table} will be sent after the statement is executed.
+     *
+     * @see SQLiteDatabase#execSQL(String)
+     */
+    @WorkerThread
+    public void executeAndTrigger(String table, String sql) {
+        executeAndTrigger(Collections.singleton(table), sql);
     }
-  }
 
-  static final class SqliteTransaction extends LinkedHashSet<String>
-      implements SQLiteTransactionListener {
-    final SqliteTransaction parent;
-    boolean commit;
+    /**
+     * See {@link #executeAndTrigger(String, String)} for usage. This overload allows for triggering multiple tables.
+     *
+     * @see BriteDatabase#executeAndTrigger(String, String)
+     */
+    @WorkerThread
+    public void executeAndTrigger(Set<String> tables, String sql) {
+        execute(sql);
 
-    SqliteTransaction(SqliteTransaction parent) {
-      this.parent = parent;
+        sendTableTrigger(tables);
     }
 
-    @Override public void onBegin() {
+    /**
+     * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
+     * returns data. No data can be returned (such as the number of affected rows). Instead, use
+     * {@link #insert}, {@link #update}, et al, when possible.
+     * <p>
+     * A notification to queries for {@code table} will be sent after the statement is executed.
+     *
+     * @see SupportSQLiteDatabase#execSQL(String, Object[])
+     */
+    @WorkerThread
+    public void executeAndTrigger(String table, String sql, Object... args) {
+        executeAndTrigger(Collections.singleton(table), sql, args);
     }
 
-    @Override public void onCommit() {
-      commit = true;
+    /**
+     * See {@link #executeAndTrigger(String, String, Object...)} for usage. This overload allows for triggering multiple tables.
+     *
+     * @see BriteDatabase#executeAndTrigger(String, String, Object...)
+     */
+    @WorkerThread
+    public void executeAndTrigger(Set<String> tables, String sql, Object... args) {
+        execute(sql, args);
+
+        sendTableTrigger(tables);
     }
 
-    @Override public void onRollback() {
+    /**
+     * Execute {@code statement}, if the the number of rows affected by execution of this SQL
+     * statement is of any importance to the caller - for example, UPDATE / DELETE SQL statements.
+     *
+     * @return the number of rows affected by this SQL statement execution.
+     * @throws android.database.SQLException If the SQL string is invalid
+     * @see SQLiteStatement#executeUpdateDelete()
+     */
+    @WorkerThread
+    public int executeUpdateDelete(String table, SQLiteStatement statement) {
+        return executeUpdateDelete(Collections.singleton(table), statement);
     }
 
-    @Override public String toString() {
-      String name = String.format("%08x", System.identityHashCode(this));
-      return parent == null ? name : name + " [" + parent.toString() + ']';
+    /**
+     * See {@link #executeUpdateDelete(String, SQLiteStatement)} for usage. This overload
+     * allows for triggering multiple tables.
+     *
+     * @see BriteDatabase#executeUpdateDelete(String, SQLiteStatement)
+     */
+    @WorkerThread
+    public int executeUpdateDelete(Set<String> tables, SQLiteStatement statement) {
+        if (logging) log("EXECUTE\n %s", statement);
+
+        int rows = statement.executeUpdateDelete();
+        if (rows > 0) {
+            // Only send a table trigger if rows were affected.
+            sendTableTrigger(tables);
+        }
+        return rows;
     }
-  }
 
-  final class DatabaseQuery extends Query
-      implements Function<Set<String>, Query>, Predicate<Set<String>> {
-    private final Iterable<String> tables;
-    private final SupportSQLiteQuery query;
+    /**
+     * Execute {@code statement} and return the ID of the row inserted due to this call.
+     * The SQL statement should be an INSERT for this to be a useful call.
+     *
+     * @return the row ID of the last row inserted, if this insert is successful. -1 otherwise.
+     * @throws android.database.SQLException If the SQL string is invalid
+     * @see SQLiteStatement#executeInsert()
+     */
+    @WorkerThread
+    public long executeInsert(String table, SQLiteStatement statement) {
+        return executeInsert(Collections.singleton(table), statement);
+    }
+
+    /**
+     * See {@link #executeInsert(String, SQLiteStatement)} for usage. This overload allows for
+     * triggering multiple tables.
+     *
+     * @see BriteDatabase#executeInsert(String, SQLiteStatement)
+     */
+    @WorkerThread
+    public long executeInsert(Set<String> tables, SQLiteStatement statement) {
+        if (logging) log("EXECUTE\n %s", statement);
 
-    DatabaseQuery(Iterable<String> tables, SupportSQLiteQuery query) {
-      this.tables = tables;
-      this.query = query;
+        long rowId = statement.executeInsert();
+        if (rowId != -1) {
+            // Only send a table trigger if the insert was successful.
+            sendTableTrigger(tables);
+        }
+        return rowId;
     }
 
-    @Override public Cursor run() {
-      if (transactions.get() != null) {
-        throw new IllegalStateException("Cannot execute observable query in a transaction.");
-      }
+    /**
+     * An in-progress database transaction.
+     */
+    public interface Transaction extends Closeable {
+        /**
+         * End a transaction. See {@link #newTransaction()} for notes about how to use this and when
+         * transactions are committed and rolled back.
+         *
+         * @see SQLiteDatabase#endTransaction()
+         */
+        @WorkerThread
+        void end();
+
+        /**
+         * Marks the current transaction as successful. Do not do any more database work between
+         * calling this and calling {@link #end()}. Do as little non-database work as possible in that
+         * situation too. If any errors are encountered between this and {@link #end()} the transaction
+         * will still be committed.
+         *
+         * @see SupportSQLiteDatabase#setTransactionSuccessful()
+         */
+        @WorkerThread
+        void markSuccessful();
+
+        /**
+         * Temporarily end the transaction to let other threads run. The transaction is assumed to be
+         * successful so far. Do not call {@link #markSuccessful()} before calling this. When this
+         * returns a new transaction will have been created but not marked as successful. This assumes
+         * that there are no nested transactions (newTransaction has only been called once) and will
+         * throw an exception if that is not the case.
+         *
+         * @return true if the transaction was yielded
+         * @see SQLiteDatabase#yieldIfContendedSafely()
+         */
+        @WorkerThread
+        boolean yieldIfContendedSafely();
+
+        /**
+         * Temporarily end the transaction to let other threads run. The transaction is assumed to be
+         * successful so far. Do not call {@link #markSuccessful()} before calling this. When this
+         * returns a new transaction will have been created but not marked as successful. This assumes
+         * that there are no nested transactions (newTransaction has only been called once) and will
+         * throw an exception if that is not the case.
+         *
+         * @param sleepAmount if > 0, sleep this long before starting a new transaction if
+         *                    the lock was actually yielded. This will allow other background threads to make some
+         *                    more progress than they would if we started the transaction immediately.
+         * @return true if the transaction was yielded
+         * @see SQLiteDatabase#yieldIfContendedSafely(long)
+         */
+        @WorkerThread
+        boolean yieldIfContendedSafely(long sleepAmount, TimeUnit sleepUnit);
+
+        /**
+         * Equivalent to calling {@link #end()}
+         */
+        @WorkerThread
+        @Override
+        void close();
+    }
 
-      long startNanos = nanoTime();
-      Cursor cursor = getReadableDatabase().query(query);
+    @IntDef({
+            CONFLICT_ABORT,
+            CONFLICT_FAIL,
+            CONFLICT_IGNORE,
+            CONFLICT_NONE,
+            CONFLICT_REPLACE,
+            CONFLICT_ROLLBACK
+    })
+    @Retention(SOURCE)
+    private @interface ConflictAlgorithm {
+    }
 
-      if (logging) {
-        long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
-        log("QUERY (%sms)\n  tables: %s\n  sql: %s", tookMillis, tables,
-            indentSql(query.getSql()));
-      }
+    static String indentSql(String sql) {
+        return sql.replace("\n", "\n       ");
+    }
 
-      return cursor;
+    void log(String message, Object... args) {
+        if (args.length > 0) message = String.format(message, args);
+        logger.log(message);
     }
 
-    @Override public String toString() {
-      return query.getSql();
+    private static String conflictString(@ConflictAlgorithm int conflictAlgorithm) {
+        switch (conflictAlgorithm) {
+            case CONFLICT_ABORT:
+                return "abort";
+            case CONFLICT_FAIL:
+                return "fail";
+            case CONFLICT_IGNORE:
+                return "ignore";
+            case CONFLICT_NONE:
+                return "none";
+            case CONFLICT_REPLACE:
+                return "replace";
+            case CONFLICT_ROLLBACK:
+                return "rollback";
+            default:
+                return "unknown (" + conflictAlgorithm + ')';
+        }
     }
 
-    @Override public Query apply(Set<String> ignored) {
-      return this;
+    static final class SqliteTransaction extends LinkedHashSet<String>
+            implements net.sqlcipher.database.SQLiteTransactionListener {
+        final SqliteTransaction parent;
+        boolean commit;
+
+        SqliteTransaction(SqliteTransaction parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public void onBegin() {
+        }
+
+        @Override
+        public void onCommit() {
+            commit = true;
+        }
+
+        @Override
+        public void onRollback() {
+        }
+
+        @Override
+        public String toString() {
+            String name = String.format("%08x", System.identityHashCode(this));
+            return parent == null ? name : name + " [" + parent.toString() + ']';
+        }
     }
 
-    @Override public boolean test(Set<String> strings) {
-      for (String table : tables) {
-        if (strings.contains(table)) {
-          return true;
+    final class DatabaseQuery extends Query
+            implements Function<Set<String>, Query>, Predicate<Set<String>> {
+        private final Iterable<String> tables;
+        private final SupportSQLiteQuery query;
+        private final String sql;
+        private final Object[] args;
+
+//        DatabaseQuery(Iterable<String> tables, SQLiteQuery query) {
+//            this.tables = tables;
+//            this.query = query;
+//        }
+
+        DatabaseQuery(Iterable<String> tables,
+                      @NonNull String sql,
+                      @NonNull Object... args) {
+            this.tables = tables;
+            this.sql = sql;
+            this.args = args;
+            this.query = new SimpleSQLiteQuery(sql, args);
+        }
+
+        @Override
+        public Cursor run() {
+            if (transactions.get() != null) {
+                throw new IllegalStateException("Cannot execute observable query in a transaction.");
+            }
+
+            long startNanos = nanoTime();
+
+//            Cursor cursor = getReadableDatabase(password).query(query);
+            Cursor cursor = getWritableDatabase(password).rawQuery(sql, args);
+
+            if (logging) {
+                long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
+                log("QUERY (%sms)\n  tables: %s\n  sql: %s", tookMillis, tables,
+                        indentSql(query.toString()));
+            }
+
+            return cursor;
+        }
+
+        @Override
+        public String toString() {
+            return query.toString();
+        }
+
+        @Override
+        public Query apply(Set<String> ignored) {
+            return this;
+        }
+
+        @Override
+        public boolean test(Set<String> strings) {
+            for (String table : tables) {
+                if (strings.contains(table)) {
+                    return true;
+                }
+            }
+            return false;
         }
-      }
-      return false;
     }
-  }
 }
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite3/SqlBrite.java b/sqlbrite/src/main/java/com/squareup/sqlbrite3/SqlBrite.java
index ee4c7bc..e9d7400 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite3/SqlBrite.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite3/SqlBrite.java
@@ -15,7 +15,7 @@
  */
 package com.squareup.sqlbrite3;
 
-import android.arch.persistence.db.SupportSQLiteOpenHelper;
+//import android.arch.persistence.db.SupportSQLiteOpenHelper;
 import android.content.ContentResolver;
 import android.database.Cursor;
 import android.os.Build;
@@ -25,6 +25,9 @@
 import android.support.annotation.RequiresApi;
 import android.support.annotation.WorkerThread;
 import android.util.Log;
+
+import net.sqlcipher.database.SQLiteOpenHelper;
+
 import io.reactivex.Observable;
 import io.reactivex.ObservableEmitter;
 import io.reactivex.ObservableOnSubscribe;
@@ -36,7 +39,7 @@
 import java.util.Optional;
 
 /**
- * A lightweight wrapper around {@link SupportSQLiteOpenHelper} which allows for continuously
+ * A lightweight wrapper around {@link SQLiteOpenHelper} which allows for continuously
  * observing the result of a query.
  */
 public final class SqlBrite {
@@ -85,10 +88,10 @@ public SqlBrite build() {
   }
 
   /**
-   * Wrap a {@link SupportSQLiteOpenHelper} for observable queries.
+   * Wrap a {@link SQLiteOpenHelper} for observable queries.
    * <p>
    * While not strictly required, instances of this class assume that they will be the only ones
-   * interacting with the underlying {@link SupportSQLiteOpenHelper} and it is required for
+   * interacting with the underlying {@link SQLiteOpenHelper} and it is required for
    * automatic notifications of table changes to work. See {@linkplain BriteDatabase#createQuery the
    * <code>query</code> method} for more information on that behavior.
    *
@@ -96,9 +99,10 @@ public SqlBrite build() {
    * will be emitted.
    */
   @CheckResult @NonNull public BriteDatabase wrapDatabaseHelper(
-      @NonNull SupportSQLiteOpenHelper helper,
+      @NonNull SQLiteOpenHelper helper,
+      char[] password,
       @NonNull Scheduler scheduler) {
-    return new BriteDatabase(helper, logger, scheduler, queryTransformer);
+    return new BriteDatabase(helper, password, logger, scheduler, queryTransformer);
   }
 
   /**
