diff --git a/.travis.yml b/.travis.yml
index 93b8fe8..dd268b1 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -2,11 +2,10 @@ language: android
 
 android:
   components:
-    - build-tools-21.1.2
+    - build-tools-23.0.0
     - extra-android-m2repository
-    - android-21
-    - android-18
-    - sys-img-armeabi-v7a-android-18
+    - android-23
+    - sys-img-armeabi-v7a-android-23
 
 jdk:
   - oraclejdk8
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 33a455c..fd58ead 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,78 @@
 Change Log
 =========
 
+Version 0.5.0 *(In Development)*
+--------------------------------
+
+ * New: Expose `mapToOne`, `mapToOneOrDefault`, and `mapToList` as static methods on `Query`. These
+   mirror the behavior of the methods of the same name on `QueryObservable` but can be used later in
+   a stream by passing the returned `Operator` instances to `lift()` (e.g.,
+   `take(1).lift(Query.mapToOne(..))`).
+ * Requires RxJava 1.1.0 or newer.
+
+
+Version 0.4.1 *(2015-10-19)*
+----------------------------
+
+ * New: `execute` method provides the ability to execute arbitrary SQL statements.
+ * New: `executeAndTrigger` method provides the ability to execute arbitrary SQL statements and
+   notifying any queries to update on the specified table.
+ * Fix: `Query.asRows` no longer calls `onCompleted` when the downstream subscriber has unsubscribed.
+
+
+Version 0.4.0 *(2015-09-22)*
+----------------------------
+
+ * New: `mapToOneOrDefault` replaces `mapToOneOrNull` for more flexibility.
+ * Fix: Notifications of table updates as the result of a transaction now occur after the transaction
+   has been applied. Previous the notification would happen during the commit at which time it was
+   invalid to create a new transaction in a subscriber.
+
+
+Version 0.3.1 *(2015-09-02)*
+----------------------------
+
+ * New: `mapToOne` and `mapToOneOrNull` operators on `QueryObservable`. These work on queries which
+   return 0 or 1 rows and are a convenience for turning them into a type `T` given a mapper of type
+   `Func1<Cursor, T>` (the same which can be used for `mapToList`).
+ * Fix: Remove `@WorkerThread` annotations for now. Various combinations of lint, RxJava, and
+   retrolambda can cause false-positives.
+
+
+Version 0.3.0 *(2015-08-31)*
+----------------------------
+
+ * Transactions are now exposed as objects instead of methods. Call `newTransaction()` to start a
+   transaction. On the `Transaction` instance, call `markSuccessful()` to indicate success and
+   `end()` to commit or rollback the transaction. The `Transaction` instance implements `Closeable`
+   to allow its use in a try-with-resources construct. See the `newTransaction()` Javadoc for more
+   information.
+ * `Query` instances can now be turned directly into an `Observable<T>` by calling `asRows` with a
+   `Func1<Cursor, T>` that maps rows to a type `T`. This allows easy filtering and limiting in
+   memory rather than in the query. See the `asRows` Javadoc for more information.
+ * `createQuery` now returns a `QueryObservable` which offers a `mapToList` operator. This operator
+   also takes a `Func1<Cursor, T>` for mapping rows to a type `T`, but instead of individual rows it
+   collects all the rows into a list. For large query results or frequently updated tables this can
+   create a lot of objects. See the `mapToList` Javadoc for more information.
+ * New: Nullability, `@CheckResult`, and `@WorkerThread` annotations on all APIs allow a more useful
+   interaction with lint in consuming projects.
+
+
+Version 0.2.1 *(2015-07-14)*
+----------------------------
+
+ * Fix: Add support for backpressure.
+
+
+Version 0.2.0 *(2015-06-30)*
+----------------------------
+
+ * An `Observable<Query>` can now be created from wrapping a `ContentResolver` in order to observe
+   queries from another app's content provider.
+ * `SqlBrite` class is now a factory for both a `BriteDatabase` (the `SQLiteOpenHelper` wrapper)
+   and `BriteContentResolver` (the `ContentResolver` wrapper).
+
+
 Version 0.1.0 *(2015-02-21)*
 ----------------------------
 
diff --git a/README.md b/README.md
old mode 100644
new mode 100755
index e005511..493e685
--- a/README.md
+++ b/README.md
@@ -1,21 +1,27 @@
 SQLBrite
 ========
 
-A lightweight wrapper around `SQLiteOpenHelper` which introduces reactive stream semantics to SQL
-operations.
+A lightweight wrapper around `SQLiteOpenHelper` and `ContentResolver` which introduces reactive
+stream semantics to queries.
 
 
 
 Usage
 -----
 
-Wrap a `SQLiteOpenHelper` instance with `SqlBrite`:
+Create a `SqlBrite` instance which is an adapter for the library functionality.
 
 ```java
-SqlBrite db = SqlBrite.create(helper);
+SqlBrite sqlBrite = SqlBrite.create();
 ```
 
-The `SqlBrite.createQuery` method is similar to `SQLiteOpenHelper.rawQuery` except it takes an
+Pass a `SQLiteOpenHelper` instance to create a `BriteDatabase`.
+
+```java
+BriteDatabase db = sqlBrite.wrapDatabaseHelper(openHelper);
+```
+
+The `BriteDatabase.createQuery` method is similar to `SQLiteDatabase.rawQuery` except it takes an
 additional parameter of table(s) on which to listen for changes. Subscribe to the returned
 `Observable<Query>` which will immediately notify with a `Query` to run.
 
@@ -49,8 +55,8 @@ db.insert("users", createUser("strong", "Alec Strong"));
 System.out.println("Queries: " + queries.get()); // Prints 4
 ```
 
-In the previous example we re-used the `SqlBrite` object "db" for inserts. All insert, update, or
-delete operations must go through this object in order to correctly notify subscribers.
+In the previous example we re-used the `BriteDatabase` object "db" for inserts. All insert, update,
+or delete operations must go through this object in order to correctly notify subscribers.
 
 Unsubscribe from the returned `Subscription` to stop getting updates.
 
@@ -83,18 +89,19 @@ users.subscribe(new Action1<Query>() {
 });
 System.out.println("Queries: " + queries.get()); // Prints 1
 
-db.beginTransaction();
+Transaction transaction = db.newTransaction();
 try {
   db.insert("users", createUser("jw", "Jake Wharton"));
   db.insert("users", createUser("mattp", "Matt Precious"));
   db.insert("users", createUser("strong", "Alec Strong"));
-  db.setTransactionSuccessful();
+  transaction.markSuccessful();
 } finally {
-  db.endTransaction();
+  transaction.end();
 }
 
 System.out.println("Queries: " + queries.get()); // Prints 2
 ```
+*Note: You can also use try-with-resources with a `Transaction` instance.*
 
 Since queries are just regular RxJava `Observable` objects, operators can also be used to
 control the frequency of notifications to subscribers.
@@ -107,6 +114,14 @@ users.debounce(500, MILLISECONDS).subscribe(new Action1<Query>() {
 });
 ```
 
+The `SqlBrite` object can also wrap a `ContentResolver` for observing a query on another app's
+content provider.
+
+```java
+BriteContentResolver resolver = sqlBrite.wrapContentProvider(contentResolver);
+Observable<Query> query = resolver.createQuery(/*...*/);
+```
+
 The full power of RxJava's operators are available for combining, filtering, and triggering any
 number of queries and data changes.
 
@@ -129,7 +144,7 @@ Download
 --------
 
 ```groovy
-compile 'com.squareup.sqlbrite:sqlbrite:0.1.0'
+compile 'com.squareup.sqlbrite:sqlbrite:0.5.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/build.gradle b/build.gradle
index 43fc5cb..00152e6 100644
--- a/build.gradle
+++ b/build.gradle
@@ -11,14 +11,14 @@ subprojects {
 }
 
 ext {
-  androidPlugin = 'com.android.tools.build:gradle:1.1.0'
-  compileSdkVersion = 21
-  buildToolsVersion = '21.1.2'
+  androidPlugin = 'com.android.tools.build:gradle:1.3.0'
+  compileSdkVersion = 23
+  buildToolsVersion = '23.0.0'
 
   // Android dependencies.
-  supportV4 = 'com.android.support:support-v4:21.0.3'
-  supportAnnotations = 'com.android.support:support-annotations:21.0.3'
-  testingSupportLib = 'com.android.support.test:testing-support-lib:0.1'
+  supportV4 = 'com.android.support:support-v4:23.0.0'
+  supportAnnotations = 'com.android.support:support-annotations:23.0.0'
+  supportTestRunner = 'com.android.support.test:runner:0.3'
 
   // Square dependencies.
   dagger = 'com.squareup.dagger:dagger:1.2.2'
@@ -29,9 +29,10 @@ ext {
   timber = 'com.jakewharton.timber:timber:2.7.1'
   autoParcel = 'com.github.frankiesardo:auto-parcel:0.3'
   autoParcelProcessor = 'com.github.frankiesardo:auto-parcel-processor:0.3'
-  rxJava = 'io.reactivex:rxjava:1.0.6'
-  rxAndroid = 'io.reactivex:rxandroid:0.24.0'
-  truth = 'com.google.truth:truth:0.25'
+  rxJava = 'io.reactivex:rxjava:1.1.0'
+  rxAndroid = 'io.reactivex:rxandroid:1.0.1'
+  rxBinding = 'com.jakewharton.rxbinding:rxbinding:0.2.0'
+  truth = 'com.google.truth:truth:0.27'
   findbugsJsr305 = 'com.google.code.findbugs:jsr305:3.0.0'
   findbugsAnnotations = 'com.google.code.findbugs:annotations:3.0.0'
 }
diff --git a/deploy_javadoc.sh b/deploy_javadoc.sh
deleted file mode 100755
index 2b6d5b6..0000000
--- a/deploy_javadoc.sh
+++ /dev/null
@@ -1,41 +0,0 @@
-#!/bin/bash
-
-set -ex
-
-REPO="git@github.com:square/sqlbrite.git"
-GROUP_ID="com.squareup.sqlbrite"
-ARTIFACT_ID="sqlbrite"
-
-DIR=temp-clone
-
-# Delete any existing temporary website clone
-rm -rf $DIR
-
-# Clone the current repo into temp folder
-git clone $REPO $DIR
-
-# Move working directory into temp folder
-cd $DIR
-
-# Checkout and track the gh-pages branch
-git checkout -t origin/gh-pages
-
-# Delete everything
-rm -rf *
-
-# Download the latest javadoc
-curl -L "https://search.maven.org/remote_content?g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
-unzip javadoc.zip
-rm javadoc.zip
-
-# Stage all files in git and create a commit
-git add .
-git add -u
-git commit -m "Website at $(date)"
-
-# Push the new files up to GitHub
-git push origin gh-pages
-
-# Delete our temp folder
-cd ..
-rm -rf $DIR
diff --git a/gradle.properties b/gradle.properties
index 6708009..b34fa99 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,5 +1,5 @@
 GROUP=com.squareup.sqlbrite
-VERSION_NAME=0.1.1-SNAPSHOT
+VERSION_NAME=0.5.1-SNAPSHOT
 
 POM_DESCRIPTION=A lightweight wrapper around SQLiteOpenHelper which introduces reactive stream semantics to SQL operations.
 
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 0f4cdce..aee0967 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.3-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.6-all.zip
diff --git a/sqlbrite-sample/build.gradle b/sqlbrite-sample/build.gradle
index 43301fa..fca8bfa 100644
--- a/sqlbrite-sample/build.gradle
+++ b/sqlbrite-sample/build.gradle
@@ -1,7 +1,7 @@
 buildscript {
   dependencies {
     classpath rootProject.ext.androidPlugin
-    classpath 'com.neenbedankt.gradle.plugins:android-apt:1.4'
+    classpath 'com.neenbedankt.gradle.plugins:android-apt:1.7'
   }
 }
 
@@ -21,7 +21,9 @@ dependencies {
   // Third-party dependencies.
   compile rootProject.ext.butterKnife
   compile rootProject.ext.timber
+  compile rootProject.ext.rxJava
   compile rootProject.ext.rxAndroid
+  compile rootProject.ext.rxBinding
   compile rootProject.ext.autoParcel
   apt rootProject.ext.autoParcelProcessor
 
@@ -54,8 +56,8 @@ android {
   }
 
   defaultConfig {
-    minSdkVersion 9
-    targetSdkVersion 21
+    minSdkVersion 14
+    targetSdkVersion 23
     applicationId 'com.example.sqlbrite.todo'
 
     versionCode 1
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
index 884ba18..c8a346f 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
@@ -17,7 +17,7 @@
 
 import android.app.Application;
 import android.database.sqlite.SQLiteOpenHelper;
-import com.example.sqlbrite.todo.BuildConfig;
+import com.squareup.sqlbrite.BriteDatabase;
 import com.squareup.sqlbrite.SqlBrite;
 import dagger.Module;
 import dagger.Provides;
@@ -30,18 +30,15 @@
     return new DbOpenHelper(application);
   }
 
-  @Provides @Singleton SqlBrite provideSqlBrite(SQLiteOpenHelper openHelper) {
-    SqlBrite db = SqlBrite.create(openHelper);
-
-    if (BuildConfig.DEBUG) {
-      db.setLogger(new SqlBrite.Logger() {
-        @Override public void log(String message) {
-          Timber.tag("Database").v(message);
-        }
-      });
-      db.setLoggingEnabled(true);
-    }
+  @Provides @Singleton SqlBrite provideSqlBrite() {
+    return SqlBrite.create(new SqlBrite.Logger() {
+      @Override public void log(String message) {
+        Timber.tag("Database").v(message);
+      }
+    });
+  }
 
-    return db;
+  @Provides @Singleton BriteDatabase provideDatabase(SqlBrite sqlBrite, SQLiteOpenHelper helper) {
+    return sqlBrite.wrapDatabaseHelper(helper);
   }
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
index 2a67f2d..77c6847 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
@@ -18,12 +18,8 @@
 import android.content.ContentValues;
 import android.database.Cursor;
 import auto.parcel.AutoParcel;
-import java.util.ArrayList;
-import java.util.List;
 import rx.functions.Func1;
 
-import static com.squareup.sqlbrite.SqlBrite.Query;
-
 @AutoParcel
 public abstract class TodoItem {
   public static final String TABLE = "todo_item";
@@ -38,22 +34,13 @@
   public abstract String description();
   public abstract boolean complete();
 
-  public static final Func1<Query, List<TodoItem>> MAP = new Func1<Query, List<TodoItem>>() {
-    @Override public List<TodoItem> call(Query query) {
-      Cursor cursor = query.run();
-      try {
-        List<TodoItem> values = new ArrayList<>(cursor.getCount());
-        while (cursor.moveToNext()) {
-          long id = Db.getLong(cursor, ID);
-          long listId = Db.getLong(cursor, LIST_ID);
-          String description = Db.getString(cursor, DESCRIPTION);
-          boolean complete = Db.getBoolean(cursor, COMPLETE);
-          values.add(new AutoParcel_TodoItem(id, listId, description, complete));
-        }
-        return values;
-      } finally {
-        cursor.close();
-      }
+  public static final Func1<Cursor, TodoItem> MAPPER = new Func1<Cursor, TodoItem>() {
+    @Override public TodoItem call(Cursor cursor) {
+      long id = Db.getLong(cursor, ID);
+      long listId = Db.getLong(cursor, LIST_ID);
+      String description = Db.getString(cursor, DESCRIPTION);
+      boolean complete = Db.getBoolean(cursor, COMPLETE);
+      return new AutoParcel_TodoItem(id, listId, description, complete);
     }
   };
 
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
index 6c736cd..113d3af 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
@@ -35,12 +35,12 @@
 import com.example.sqlbrite.todo.db.Db;
 import com.example.sqlbrite.todo.db.TodoItem;
 import com.example.sqlbrite.todo.db.TodoList;
-import com.squareup.sqlbrite.SqlBrite;
+import com.jakewharton.rxbinding.widget.AdapterViewItemClickEvent;
+import com.jakewharton.rxbinding.widget.RxAdapterView;
+import com.squareup.sqlbrite.BriteDatabase;
 import javax.inject.Inject;
 import rx.Observable;
 import rx.android.schedulers.AndroidSchedulers;
-import rx.android.widget.OnItemClickEvent;
-import rx.android.widget.WidgetObservable;
 import rx.functions.Action1;
 import rx.functions.Func1;
 import rx.functions.Func2;
@@ -85,7 +85,7 @@ public static ItemsFragment newInstance(long listId) {
     return fragment;
   }
 
-  @Inject SqlBrite db;
+  @Inject BriteDatabase db;
 
   @InjectView(android.R.id.list) ListView listView;
   @InjectView(android.R.id.empty) View emptyView;
@@ -136,11 +136,10 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
     listView.setEmptyView(emptyView);
     listView.setAdapter(adapter);
 
-    WidgetObservable.itemClicks(listView) //
-        .subscribeOn(AndroidSchedulers.mainThread())
+    RxAdapterView.itemClickEvents(listView) //
         .observeOn(Schedulers.io())
-        .subscribe(new Action1<OnItemClickEvent>() {
-          @Override public void call(OnItemClickEvent event) {
+        .subscribe(new Action1<AdapterViewItemClickEvent>() {
+          @Override public void call(AdapterViewItemClickEvent event) {
             boolean newValue = !adapter.getItem(event.position()).complete();
             db.update(TodoItem.TABLE, new TodoItem.Builder().complete(newValue).build(),
                 TodoItem.ID + " = ?", String.valueOf(event.id()));
@@ -197,7 +196,7 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
             }));
 
     subscriptions.add(db.createQuery(TodoItem.TABLE, LIST_QUERY, listId)
-        .map(TodoItem.MAP)
+        .mapToList(TodoItem.MAPPER)
         .subscribeOn(Schedulers.io())
         .observeOn(AndroidSchedulers.mainThread())
         .subscribe(adapter));
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
index b5db0ea..feebb0d 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
@@ -32,7 +32,7 @@
 import butterknife.OnItemClick;
 import com.example.sqlbrite.todo.R;
 import com.example.sqlbrite.todo.TodoApp;
-import com.squareup.sqlbrite.SqlBrite;
+import com.squareup.sqlbrite.BriteDatabase;
 import javax.inject.Inject;
 import rx.Subscription;
 import rx.android.schedulers.AndroidSchedulers;
@@ -51,7 +51,7 @@ static ListsFragment newInstance() {
     return new ListsFragment();
   }
 
-  @Inject SqlBrite db;
+  @Inject BriteDatabase db;
 
   @InjectView(android.R.id.list) ListView listView;
   @InjectView(android.R.id.empty) View emptyView;
@@ -109,7 +109,7 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
     getActivity().setTitle("To-Do");
 
     subscription = db.createQuery(ListsItem.TABLES, ListsItem.QUERY)
-        .map(ListsItem.MAP)
+        .mapToList(ListsItem.MAPPER)
         .subscribeOn(Schedulers.io())
         .observeOn(AndroidSchedulers.mainThread())
         .subscribe(adapter);
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
index dfe7781..51b2281 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
@@ -20,14 +20,10 @@
 import com.example.sqlbrite.todo.db.Db;
 import com.example.sqlbrite.todo.db.TodoItem;
 import com.example.sqlbrite.todo.db.TodoList;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.List;
 import rx.functions.Func1;
 
-import static com.squareup.sqlbrite.SqlBrite.Query;
-
 @AutoParcel
 abstract class ListsItem {
   private static String ALIAS_LIST = "list";
@@ -50,21 +46,12 @@
   abstract String name();
   abstract int itemCount();
 
-  static Func1<Query, List<ListsItem>> MAP = new Func1<Query, List<ListsItem>>() {
-    @Override public List<ListsItem> call(Query query) {
-      Cursor cursor = query.run();
-      try {
-        List<ListsItem> values = new ArrayList<>(cursor.getCount());
-        while (cursor.moveToNext()) {
-          long id = Db.getLong(cursor, TodoList.ID);
-          String name = Db.getString(cursor, TodoList.NAME);
-          int itemCount = Db.getInt(cursor, ITEM_COUNT);
-          values.add(new AutoParcel_ListsItem(id, name, itemCount));
-        }
-        return values;
-      } finally {
-        cursor.close();
-      }
+  static Func1<Cursor, ListsItem> MAPPER = new Func1<Cursor, ListsItem>() {
+    @Override public ListsItem call(Cursor cursor) {
+      long id = Db.getLong(cursor, TodoList.ID);
+      String name = Db.getString(cursor, TodoList.NAME);
+      int itemCount = Db.getInt(cursor, ITEM_COUNT);
+      return new AutoParcel_ListsItem(id, name, itemCount);
     }
   };
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
index 9b6de72..6102a8f 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
@@ -29,12 +29,10 @@
 import com.example.sqlbrite.todo.R;
 import com.example.sqlbrite.todo.TodoApp;
 import com.example.sqlbrite.todo.db.TodoItem;
-import com.squareup.sqlbrite.SqlBrite;
+import com.jakewharton.rxbinding.widget.RxTextView;
+import com.squareup.sqlbrite.BriteDatabase;
 import javax.inject.Inject;
 import rx.Observable;
-import rx.android.schedulers.AndroidSchedulers;
-import rx.android.widget.OnTextChangeEvent;
-import rx.android.widget.WidgetObservable;
 import rx.functions.Action1;
 import rx.functions.Func2;
 import rx.schedulers.Schedulers;
@@ -56,7 +54,7 @@ public static NewItemFragment newInstance(long listId) {
 
   private final PublishSubject<String> createClicked = PublishSubject.create();
 
-  @Inject SqlBrite db;
+  @Inject BriteDatabase db;
 
   private long getListId() {
     return getArguments().getLong(KEY_LIST_ID);
@@ -72,15 +70,12 @@ private long getListId() {
     View view = LayoutInflater.from(context).inflate(R.layout.new_item, null);
 
     EditText name = findById(view, android.R.id.input);
-    Observable<OnTextChangeEvent> nameText = WidgetObservable.text(name);
-
-    Observable.combineLatest(createClicked, nameText,
-        new Func2<String, OnTextChangeEvent, String>() {
-          @Override public String call(String ignored, OnTextChangeEvent event) {
-            return event.text().toString();
+    Observable.combineLatest(createClicked, RxTextView.textChanges(name),
+        new Func2<String, CharSequence, String>() {
+          @Override public String call(String ignored, CharSequence text) {
+            return text.toString();
           }
         }) //
-        .subscribeOn(AndroidSchedulers.mainThread())
         .observeOn(Schedulers.io())
         .subscribe(new Action1<String>() {
           @Override public void call(String description) {
@@ -98,7 +93,7 @@ private long getListId() {
           }
         })
         .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
-          @Override public void onClick(DialogInterface dialog, int which) {
+          @Override public void onClick(@NonNull DialogInterface dialog, int which) {
           }
         })
         .create();
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
index 0f669c2..2a14c60 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
@@ -29,12 +29,10 @@
 import com.example.sqlbrite.todo.R;
 import com.example.sqlbrite.todo.TodoApp;
 import com.example.sqlbrite.todo.db.TodoList;
-import com.squareup.sqlbrite.SqlBrite;
+import com.jakewharton.rxbinding.widget.RxTextView;
+import com.squareup.sqlbrite.BriteDatabase;
 import javax.inject.Inject;
 import rx.Observable;
-import rx.android.schedulers.AndroidSchedulers;
-import rx.android.widget.OnTextChangeEvent;
-import rx.android.widget.WidgetObservable;
 import rx.functions.Action1;
 import rx.functions.Func2;
 import rx.schedulers.Schedulers;
@@ -49,7 +47,7 @@ public static NewListFragment newInstance() {
 
   private final PublishSubject<String> createClicked = PublishSubject.create();
 
-  @Inject SqlBrite db;
+  @Inject BriteDatabase db;
 
   @Override public void onAttach(Activity activity) {
     super.onAttach(activity);
@@ -61,15 +59,12 @@ public static NewListFragment newInstance() {
     View view = LayoutInflater.from(context).inflate(R.layout.new_list, null);
 
     EditText name = findById(view, android.R.id.input);
-    Observable<OnTextChangeEvent> nameText = WidgetObservable.text(name);
-
-    Observable.combineLatest(createClicked, nameText,
-        new Func2<String, OnTextChangeEvent, String>() {
-          @Override public String call(String ignored, OnTextChangeEvent event) {
-            return event.text().toString();
+    Observable.combineLatest(createClicked, RxTextView.textChanges(name),
+        new Func2<String, CharSequence, String>() {
+          @Override public String call(String ignored, CharSequence text) {
+            return text.toString();
           }
         }) //
-        .subscribeOn(AndroidSchedulers.mainThread())
         .observeOn(Schedulers.io())
         .subscribe(new Action1<String>() {
           @Override public void call(String name) {
@@ -86,7 +81,7 @@ public static NewListFragment newInstance() {
           }
         })
         .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
-          @Override public void onClick(DialogInterface dialog, int which) {
+          @Override public void onClick(@NonNull DialogInterface dialog, int which) {
           }
         })
         .create();
diff --git a/sqlbrite/build.gradle b/sqlbrite/build.gradle
index 8c312a0..fccb727 100644
--- a/sqlbrite/build.gradle
+++ b/sqlbrite/build.gradle
@@ -11,7 +11,7 @@ dependencies {
   compile rootProject.ext.rxJava
   compile rootProject.ext.supportAnnotations
 
-  androidTestCompile rootProject.ext.testingSupportLib
+  androidTestCompile rootProject.ext.supportTestRunner
   androidTestCompile(rootProject.ext.truth) {
     exclude group: 'junit' // Android has JUnit built in.
   }
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteContentProviderTests.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java
similarity index 76%
rename from sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteContentProviderTests.java
rename to sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java
index b92f2f5..f7826a9 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteContentProviderTests.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java
@@ -31,30 +31,37 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-public final class SqlBriteContentProviderTests
-    extends ProviderTestCase2<SqlBriteContentProviderTests.TestContentProvider> {
+public final class BriteContentResolverTest
+    extends ProviderTestCase2<BriteContentResolverTest.TestContentProvider> {
   private static final Uri AUTHORITY = Uri.parse("content://test_authority");
   private static final Uri TABLE = AUTHORITY.buildUpon().appendPath("test_table").build();
   private static final String KEY = "test_key";
   private static final String VALUE = "test_value";
 
+  private final List<String> logs = new ArrayList<>();
   private final RecordingObserver o = new RecordingObserver();
 
   private ContentResolver contentResolver;
-  private SqlBriteContentProvider db;
+  private BriteContentResolver db;
   private Subscription subscription;
 
-  public SqlBriteContentProviderTests() {
+  public BriteContentResolverTest() {
     super(TestContentProvider.class, AUTHORITY.getAuthority());
   }
 
   @Override protected void setUp() throws Exception {
     super.setUp();
     contentResolver = getMockContentResolver();
-    db = SqlBriteContentProvider.create(contentResolver);
-    getProvider().init(getContext().getContentResolver());
-    db.setLoggingEnabled(true);
     subscription = Subscriptions.empty();
+
+    SqlBrite.Logger logger = new SqlBrite.Logger() {
+      @Override public void log(String message) {
+        logs.add(message);
+      }
+    };
+    db = new BriteContentResolver(contentResolver, logger);
+
+    getProvider().init(getContext().getContentResolver());
   }
 
   @Override public void tearDown() {
@@ -62,22 +69,8 @@ public SqlBriteContentProviderTests() {
     subscription.unsubscribe();
   }
 
-  public void testLoggerInvalidValues() {
-    try {
-      db.setLogger(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("logger == null");
-    }
-  }
-
   public void testLoggerEnabled() {
-    final List<String> logs = new ArrayList<>();
-    db.setLogger(new SqlBrite.Logger() {
-      @Override public void log(String message) {
-        logs.add(message);
-      }
-    });
+    db.setLoggingEnabled(true);
 
     subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
     o.assertCursor().isExhausted();
@@ -88,13 +81,7 @@ public void testLoggerEnabled() {
   }
 
   public void testLoggerDisabled() {
-    final List<String> logs = new ArrayList<>();
     db.setLoggingEnabled(false);
-    db.setLogger(new SqlBrite.Logger() {
-      @Override public void log(String message) {
-        logs.add(message);
-      }
-    });
 
     contentResolver.insert(TABLE, values("key1", "value1"));
     assertThat(logs).isEmpty();
@@ -127,13 +114,6 @@ public void testCreateQueryObservesDelete() {
   }
 
   public void testUnsubscribeDoesNotTrigger() {
-    final List<String> logs = new ArrayList<>();
-    db.setLogger(new SqlBrite.Logger() {
-      @Override public void log(String message) {
-        logs.add(message);
-      }
-    });
-
     subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
     o.assertCursor().isExhausted();
     subscription.unsubscribe();
@@ -143,6 +123,52 @@ public void testUnsubscribeDoesNotTrigger() {
     assertThat(logs).isEmpty();
   }
 
+  public void testBackpressureSupported() {
+    contentResolver.insert(TABLE, values("key1", "val1"));
+    o.doRequest(2);
+
+    subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
+    o.assertCursor()
+        .hasRow("key1", "val1")
+        .isExhausted();
+
+    contentResolver.insert(TABLE, values("key2", "val2"));
+    o.assertCursor()
+        .hasRow("key1", "val1")
+        .hasRow("key2", "val2")
+        .isExhausted();
+
+    contentResolver.insert(TABLE, values("key3", "val3"));
+    o.assertNoMoreEvents();
+
+    contentResolver.insert(TABLE, values("key4", "val4"));
+    o.assertNoMoreEvents();
+
+    o.doRequest(1);
+    o.assertCursor()
+        .hasRow("key1", "val1")
+        .hasRow("key2", "val2")
+        .hasRow("key3", "val3")
+        .hasRow("key4", "val4")
+        .isExhausted();
+
+    contentResolver.insert(TABLE, values("key5", "val5"));
+    o.assertNoMoreEvents();
+    contentResolver.insert(TABLE, values("key6", "val6"));
+    o.assertNoMoreEvents();
+
+    o.doRequest(Long.MAX_VALUE);
+    o.assertCursor()
+        .hasRow("key1", "val1")
+        .hasRow("key2", "val2")
+        .hasRow("key3", "val3")
+        .hasRow("key4", "val4")
+        .hasRow("key5", "val5")
+        .hasRow("key6", "val6")
+        .isExhausted();
+    o.assertNoMoreEvents();
+  }
+
   private ContentValues values(String key, String value) {
     ContentValues result = new ContentValues();
     result.put(KEY, key);
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java
new file mode 100644
index 0000000..cf09800
--- /dev/null
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java
@@ -0,0 +1,837 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.sqlbrite;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.google.common.collect.Range;
+import com.squareup.sqlbrite.BriteDatabase.Transaction;
+import com.squareup.sqlbrite.TestDb.Employee;
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import rx.Observable;
+import rx.Subscription;
+import rx.functions.Action1;
+
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE;
+import static com.google.common.truth.Truth.assertThat;
+import static com.squareup.sqlbrite.RecordingObserver.CursorAssert;
+import static com.squareup.sqlbrite.SqlBrite.Query;
+import static com.squareup.sqlbrite.TestDb.BOTH_TABLES;
+import static com.squareup.sqlbrite.TestDb.EmployeeTable.NAME;
+import static com.squareup.sqlbrite.TestDb.EmployeeTable.USERNAME;
+import static com.squareup.sqlbrite.TestDb.SELECT_EMPLOYEES;
+import static com.squareup.sqlbrite.TestDb.SELECT_MANAGER_LIST;
+import static com.squareup.sqlbrite.TestDb.TABLE_EMPLOYEE;
+import static com.squareup.sqlbrite.TestDb.TABLE_MANAGER;
+import static com.squareup.sqlbrite.TestDb.employee;
+import static com.squareup.sqlbrite.TestDb.manager;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public final class BriteDatabaseTest {
+  private final List<String> logs = new ArrayList<>();
+  private final RecordingObserver o = new RecordingObserver();
+
+  private TestDb helper;
+  private SQLiteDatabase real;
+  private BriteDatabase db;
+
+  @Before public void setUp() {
+    helper = new TestDb(InstrumentationRegistry.getContext());
+    real = helper.getWritableDatabase();
+
+    SqlBrite.Logger logger = new SqlBrite.Logger() {
+      @Override public void log(String message) {
+        logs.add(message);
+      }
+    };
+    db = new BriteDatabase(helper, logger);
+  }
+
+  @After public void tearDown() {
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void loggerEnabled() {
+    db.setLoggingEnabled(true);
+    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    assertThat(logs).isNotEmpty();
+  }
+
+  @Test public void loggerDisabled() {
+    db.setLoggingEnabled(false);
+    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    assertThat(logs).isEmpty();
+  }
+
+  @Test public void closePropagates() {
+    db.close();
+    assertThat(real.isOpen()).isFalse();
+  }
+
+  @Test public void query() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+  }
+
+  @Test public void queryMapToList() {
+    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+        .mapToList(Employee.MAPPER)
+        .toBlocking()
+        .first();
+    assertThat(employees).containsExactly( //
+        new Employee("alice", "Alice Allison"), //
+        new Employee("bob", "Bob Bobberson"), //
+        new Employee("eve", "Eve Evenson"));
+  }
+
+  @Test public void queryMapToOne() {
+    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+        .mapToOne(Employee.MAPPER)
+        .toBlocking()
+        .first();
+    assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
+  }
+
+  @Test public void queryMapToOneOrDefault() {
+    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+        .mapToOneOrDefault(Employee.MAPPER, null)
+        .toBlocking()
+        .first();
+    assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
+  }
+
+  @Test public void badQueryCallsError() {
+    db.createQuery(TABLE_EMPLOYEE, "SELECT * FROM missing").subscribe(o);
+    o.assertErrorContains("no such table: missing");
+  }
+
+  @Test public void queryWithArgs() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE " + USERNAME + " = ?", "bob")
+        .subscribe(o);
+    o.assertCursor()
+        .hasRow("bob", "Bob Bobberson")
+        .isExhausted();
+  }
+
+  @Test public void queryObservesInsert() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .hasRow("john", "John Johnson")
+        .isExhausted();
+  }
+
+  @Test public void queryObservesInsertDebounced() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+        .debounce(500, MILLISECONDS)
+        .subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    long startNs = System.nanoTime();
+
+    // Shotgun 10 inserts which will cause 10 triggers. DO NOT DO THIS IRL! Use a transaction!
+    for (int i = 0; i < 10; i++) {
+      db.insert(TABLE_EMPLOYEE, employee("john" + i, "John Johnson " + i));
+    }
+
+    // Only one trigger should have been observed.
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .hasRow("john0", "John Johnson 0")
+        .hasRow("john1", "John Johnson 1")
+        .hasRow("john2", "John Johnson 2")
+        .hasRow("john3", "John Johnson 3")
+        .hasRow("john4", "John Johnson 4")
+        .hasRow("john5", "John Johnson 5")
+        .hasRow("john6", "John Johnson 6")
+        .hasRow("john7", "John Johnson 7")
+        .hasRow("john8", "John Johnson 8")
+        .hasRow("john9", "John Johnson 9")
+        .isExhausted();
+
+    long tookNs = System.nanoTime() - startNs;
+    assertThat(TimeUnit.NANOSECONDS.toMillis(tookNs)).isIn(Range.atLeast(500L));
+  }
+
+  @Test public void queryNotNotifiedWhenInsertFails() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.insert(TABLE_EMPLOYEE, employee("bob", "Bob Bobberson"), CONFLICT_IGNORE);
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void queryObservesUpdate() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    ContentValues values = new ContentValues();
+    values.put(NAME, "Robert Bobberson");
+    db.update(TABLE_EMPLOYEE, values, USERNAME + " = 'bob'");
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Robert Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+  }
+
+  @Test public void queryNotNotifiedWhenUpdateAffectsZeroRows() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    ContentValues values = new ContentValues();
+    values.put(NAME, "John Johnson");
+    db.update(TABLE_EMPLOYEE, values, USERNAME + " = 'john'");
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void queryObservesDelete() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.delete(TABLE_EMPLOYEE, USERNAME + " = 'bob'");
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+  }
+
+  @Test public void queryNotNotifiedWhenDeleteAffectsZeroRows() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.delete(TABLE_EMPLOYEE, USERNAME + " = 'john'");
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void queryMultipleTables() {
+    db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
+    o.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+  }
+
+  @Test public void queryMultipleTablesObservesChanges() {
+    db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
+    o.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+
+    // A new employee triggers, despite the fact that it's not in our result set.
+    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    o.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+
+    // A new manager also triggers and it is in our result set.
+    db.insert(TABLE_MANAGER, manager(helper.bobId, helper.eveId));
+    o.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .hasRow("Bob Bobberson", "Eve Evenson")
+        .isExhausted();
+  }
+
+  @Test public void queryMultipleTablesObservesChangesOnlyOnce() {
+    // Employee table is in this list twice. We should still only be notified once for a change.
+    List<String> tables = Arrays.asList(TABLE_EMPLOYEE, TABLE_MANAGER, TABLE_EMPLOYEE);
+    db.createQuery(tables, SELECT_MANAGER_LIST).subscribe(o);
+    o.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+
+    ContentValues values = new ContentValues();
+    values.put(NAME, "Even Evenson");
+    db.update(TABLE_EMPLOYEE, values, USERNAME + " = 'eve'");
+    o.assertCursor()
+        .hasRow("Even Evenson", "Alice Allison")
+        .isExhausted();
+  }
+
+  @Test public void queryNotNotifiedAfterUnsubscribe() {
+    Subscription subscription = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+    subscription.unsubscribe();
+
+    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void queryOnlyNotifiedAfterSubscribe() {
+    Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
+    o.assertNoMoreEvents();
+
+    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    o.assertNoMoreEvents();
+
+    query.subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .hasRow("john", "John Johnson")
+        .isExhausted();
+  }
+
+  @Test public void executeSqlNoTrigger() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+        .skip(1) // Skip initial
+        .subscribe(o);
+
+    db.execute("UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void executeSqlWithArgsNoTrigger() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+        .skip(1) // Skip initial
+        .subscribe(o);
+
+    db.execute("UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = ?", "Zach");
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void executeSqlAndTrigger() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeAndTrigger(TABLE_EMPLOYEE,
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+    o.assertCursor()
+        .hasRow("alice", "Zach")
+        .hasRow("bob", "Zach")
+        .hasRow("eve", "Zach")
+        .isExhausted();
+  }
+
+  @Test public void executeSqlThrowsAndDoesNotTrigger() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+        .skip(1) // Skip initial
+        .subscribe(o);
+
+    try {
+      db.executeAndTrigger(TABLE_EMPLOYEE,
+          "UPDATE not_a_table SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+      fail();
+    } catch (SQLException ignored) {
+    }
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void executeSqlWithArgsAndTrigger() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeAndTrigger(TABLE_EMPLOYEE,
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = ?", "Zach");
+    o.assertCursor()
+        .hasRow("alice", "Zach")
+        .hasRow("bob", "Zach")
+        .hasRow("eve", "Zach")
+        .isExhausted();
+  }
+
+  @Test public void executeSqlWithArgsThrowsAndDoesNotTrigger() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+        .skip(1) // Skip initial
+        .subscribe(o);
+
+    try {
+      db.executeAndTrigger(TABLE_EMPLOYEE,
+          "UPDATE not_a_table SET " + TestDb.EmployeeTable.NAME + " = ?", "Zach");
+      fail();
+    } catch (SQLException ignored) {
+    }
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void transactionOnlyNotifiesOnce() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    Transaction transaction = db.newTransaction();
+    try {
+      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+      db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
+      o.assertNoMoreEvents();
+
+      transaction.markSuccessful();
+    } finally {
+      transaction.end();
+    }
+
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .hasRow("john", "John Johnson")
+        .hasRow("nick", "Nick Nickers")
+        .isExhausted();
+  }
+
+  @Test public void transactionCreatedFromTransactionNotificationWorks() {
+    // Tests the case where a transaction is created in the subscriber to a query which gets
+    // notified as the result of another transaction being committed. With improper ordering, this
+    // can result in creating a new transaction before the old is committed on the underlying DB.
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+        .subscribe(new Action1<Query>() {
+          @Override public void call(Query query) {
+            db.newTransaction().end();
+          }
+        });
+
+    Transaction transaction = db.newTransaction();
+    try {
+      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+      transaction.markSuccessful();
+    } finally {
+      transaction.end();
+    }
+  }
+
+  @Test public void transactionIsCloseable() throws IOException {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    Transaction transaction = db.newTransaction();
+    //noinspection UnnecessaryLocalVariable
+    Closeable closeableTransaction = transaction; // Verify type is implemented.
+    try {
+      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+      db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
+      transaction.markSuccessful();
+    } finally {
+      closeableTransaction.close();
+    }
+
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .hasRow("john", "John Johnson")
+        .hasRow("nick", "Nick Nickers")
+        .isExhausted();
+  }
+
+  @Test public void transactionDoesNotThrow() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    Transaction transaction = db.newTransaction();
+    try {
+      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+      db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
+      transaction.markSuccessful();
+    } finally {
+      transaction.close(); // Transactions should not throw on close().
+    }
+
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .hasRow("john", "John Johnson")
+        .hasRow("nick", "Nick Nickers")
+        .isExhausted();
+  }
+
+  @Test public void queryCreatedDuringTransactionThrows() {
+    db.newTransaction();
+    try {
+      db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).startsWith("Cannot create observable query in transaction.");
+    }
+  }
+
+  @Test public void querySubscribedToDuringTransactionThrows() {
+    Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
+
+    db.newTransaction();
+    query.subscribe(o);
+    o.assertErrorContains("Cannot subscribe to observable query in a transaction.");
+  }
+
+  @Test public void callingEndMultipleTimesThrows() {
+    Transaction transaction = db.newTransaction();
+    transaction.end();
+    try {
+      transaction.end();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Not in transaction.");
+    }
+  }
+
+  @Test public void querySubscribedToDuringTransactionOnDifferentThread()
+      throws InterruptedException {
+    Transaction transaction = db.newTransaction();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    new Thread() {
+      @Override public void run() {
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+        latch.countDown();
+      }
+    }.start();
+
+    Thread.sleep(500); // Wait for the thread to block on initial query.
+    o.assertNoMoreEvents();
+
+    transaction.end(); // Allow other queries to continue.
+    latch.await(500, MILLISECONDS); // Wait for thread to observe initial query.
+
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+  }
+
+  @Test public void queryCreatedBeforeTransactionButSubscribedAfter() {
+    Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
+
+    Transaction transaction = db.newTransaction();
+    try {
+      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+      db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
+      transaction.markSuccessful();
+    } finally {
+      transaction.end();
+    }
+
+    query.subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .hasRow("john", "John Johnson")
+        .hasRow("nick", "Nick Nickers")
+        .isExhausted();
+  }
+
+  @Test public void synchronousQueryDuringTransaction() {
+    Transaction transaction = db.newTransaction();
+    try {
+      transaction.markSuccessful();
+      assertCursor(db.query(SELECT_EMPLOYEES))
+          .hasRow("alice", "Alice Allison")
+          .hasRow("bob", "Bob Bobberson")
+          .hasRow("eve", "Eve Evenson")
+          .isExhausted();
+    } finally {
+      transaction.end();
+    }
+  }
+
+  @Test public void synchronousQueryDuringTransactionSeesChanges() {
+    Transaction transaction = db.newTransaction();
+    try {
+      assertCursor(db.query(SELECT_EMPLOYEES))
+          .hasRow("alice", "Alice Allison")
+          .hasRow("bob", "Bob Bobberson")
+          .hasRow("eve", "Eve Evenson")
+          .isExhausted();
+
+      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+      db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
+
+      assertCursor(db.query(SELECT_EMPLOYEES))
+          .hasRow("alice", "Alice Allison")
+          .hasRow("bob", "Bob Bobberson")
+          .hasRow("eve", "Eve Evenson")
+          .hasRow("john", "John Johnson")
+          .hasRow("nick", "Nick Nickers")
+          .isExhausted();
+
+      transaction.markSuccessful();
+    } finally {
+      transaction.end();
+    }
+  }
+
+  @Test public void nestedTransactionsOnlyNotifyOnce() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    Transaction transactionOuter = db.newTransaction();
+    try {
+      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+
+      Transaction transactionInner = db.newTransaction();
+      try {
+        db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
+        transactionInner.markSuccessful();
+      } finally {
+        transactionInner.end();
+      }
+
+      transactionOuter.markSuccessful();
+    } finally {
+      transactionOuter.end();
+    }
+
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .hasRow("john", "John Johnson")
+        .hasRow("nick", "Nick Nickers")
+        .isExhausted();
+  }
+
+  @Test public void nestedTransactionsOnMultipleTables() {
+    db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
+    o.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+
+    Transaction transactionOuter = db.newTransaction();
+    try {
+
+      Transaction transactionInner = db.newTransaction();
+      try {
+        db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+        transactionInner.markSuccessful();
+      } finally {
+        transactionInner.end();
+      }
+
+      transactionInner = db.newTransaction();
+      try {
+        db.insert(TABLE_MANAGER, manager(helper.aliceId, helper.bobId));
+        transactionInner.markSuccessful();
+      } finally {
+        transactionInner.end();
+      }
+
+      transactionOuter.markSuccessful();
+    } finally {
+      transactionOuter.end();
+    }
+
+    o.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .hasRow("Alice Allison", "Bob Bobberson")
+        .isExhausted();
+  }
+
+  @Test public void emptyTransactionDoesNotNotify() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    Transaction transaction = db.newTransaction();
+    try {
+      transaction.markSuccessful();
+    } finally {
+      transaction.end();
+    }
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void transactionRollbackDoesNotNotify() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    Transaction transaction = db.newTransaction();
+    try {
+      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+      db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
+      // No call to set successful.
+    } finally {
+      transaction.end();
+    }
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void backpressureSupported() {
+    o.doRequest(2);
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .hasRow("john", "John Johnson")
+        .isExhausted();
+
+    db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
+    o.assertNoMoreEvents();
+
+    db.delete(TABLE_EMPLOYEE, USERNAME + "=?", "bob");
+    o.assertNoMoreEvents();
+
+    o.doRequest(1);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("eve", "Eve Evenson")
+        .hasRow("john", "John Johnson")
+        .hasRow("nick", "Nick Nickers")
+        .isExhausted();
+
+    db.delete(TABLE_EMPLOYEE, USERNAME + "=?", "eve");
+    o.assertNoMoreEvents();
+    db.delete(TABLE_EMPLOYEE, USERNAME + "=?", "alice");
+    o.assertNoMoreEvents();
+
+    o.doRequest(Long.MAX_VALUE);
+    o.assertCursor()
+        .hasRow("john", "John Johnson")
+        .hasRow("nick", "Nick Nickers")
+        .isExhausted();
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void badQueryThrows() {
+    try {
+      db.query("SELECT * FROM missing");
+      fail();
+    } catch (SQLiteException e) {
+      assertThat(e.getMessage()).contains("no such table: missing");
+    }
+  }
+
+  @Test public void badInsertThrows() {
+    try {
+      db.insert("missing", employee("john", "John Johnson"));
+      fail();
+    } catch (SQLiteException e) {
+      assertThat(e.getMessage()).contains("no such table: missing");
+    }
+  }
+
+  @Test public void badUpdateThrows() {
+    try {
+      db.update("missing", employee("john", "John Johnson"), "1");
+      fail();
+    } catch (SQLiteException e) {
+      assertThat(e.getMessage()).contains("no such table: missing");
+    }
+  }
+
+  @Test public void badDeleteThrows() {
+    try {
+      db.delete("missing", "1");
+      fail();
+    } catch (SQLiteException e) {
+      assertThat(e.getMessage()).contains("no such table: missing");
+    }
+  }
+
+  private static CursorAssert assertCursor(Cursor cursor) {
+    return new CursorAssert(cursor);
+  }
+}
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryObservableTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryObservableTest.java
new file mode 100644
index 0000000..5d5ac6c
--- /dev/null
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryObservableTest.java
@@ -0,0 +1,64 @@
+package com.squareup.sqlbrite;
+
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.support.test.runner.AndroidJUnit4;
+
+import com.squareup.sqlbrite.SqlBrite.Query;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import rx.Observable;
+import rx.functions.Func1;
+import rx.observers.TestSubscriber;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(AndroidJUnit4.class)
+public final class QueryObservableTest {
+
+  @Test public void mapToListThrowsFromQueryRun() {
+    TestSubscriber<Object> testSubscriber = new TestSubscriber<>();
+
+    new QueryObservable(Observable.<Query>just(new Query() {
+      @Override public Cursor run() {
+        throw new IllegalStateException("test exception");
+      }
+    })).mapToList(new Func1<Cursor, Object>() {
+      @Override public Object call(Cursor cursor) {
+        throw new AssertionError("Must not be called");
+      }
+    }).subscribe(testSubscriber);
+
+    testSubscriber.awaitTerminalEvent();
+    testSubscriber.assertNoValues();
+    assertThat(testSubscriber.getOnErrorEvents()).hasSize(1);
+
+    IllegalStateException expected = (IllegalStateException) testSubscriber.getOnErrorEvents().get(0);
+    assertThat(expected).hasMessage("test exception");
+  }
+
+  @Test public void mapToListThrowsFromMapFunction() {
+    TestSubscriber<Object> testSubscriber = new TestSubscriber<>();
+
+    new QueryObservable(Observable.<Query>just(new Query() {
+      @Override public Cursor run() {
+        MatrixCursor cursor = new MatrixCursor(new String[]{"col1"});
+        cursor.addRow(new Object[]{"value1"});
+        return cursor;
+      }
+    })).mapToList(new Func1<Cursor, Object>() {
+      @Override public Object call(Cursor cursor) {
+        throw new IllegalStateException("test exception");
+      }
+    }).subscribe(testSubscriber);
+
+    testSubscriber.awaitTerminalEvent();
+    testSubscriber.assertNoValues();
+    assertThat(testSubscriber.getOnErrorEvents()).hasSize(1);
+
+    IllegalStateException expected = (IllegalStateException) testSubscriber.getOnErrorEvents().get(0);
+    assertThat(expected).hasMessage("test exception");
+  }
+}
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java
new file mode 100644
index 0000000..159b8f7
--- /dev/null
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java
@@ -0,0 +1,186 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.sqlbrite;
+
+import android.database.Cursor;
+import android.support.test.InstrumentationRegistry;
+import com.squareup.sqlbrite.SqlBrite.Query;
+import com.squareup.sqlbrite.TestDb.Employee;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import rx.functions.Func1;
+import rx.observables.BlockingObservable;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.squareup.sqlbrite.TestDb.SELECT_EMPLOYEES;
+import static com.squareup.sqlbrite.TestDb.TABLE_EMPLOYEE;
+
+public final class QueryTest {
+  private BriteDatabase db;
+
+  @Before public void setUp() {
+    SqlBrite sqlBrite = SqlBrite.create();
+    TestDb helper = new TestDb(InstrumentationRegistry.getContext());
+    db = sqlBrite.wrapDatabaseHelper(helper);
+  }
+
+  @Test public void mapToOne() {
+    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+        .lift(Query.mapToOne(Employee.MAPPER))
+        .toBlocking()
+        .first();
+    assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
+  }
+
+  @Test public void mapToOneThrowsOnMapperNull() {
+    BlockingObservable<Employee> employees =
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES) //
+            .lift(Query.mapToOne(new Func1<Cursor, Employee>() {
+              @Override public Employee call(Cursor cursor) {
+                return null;
+              }
+            })) //
+            .toBlocking();
+    try {
+      employees.first();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("Mapper returned null for row 1");
+      assertThat(e.getCause()).hasMessage(
+          "OnError while emitting onNext value: SELECT username, name FROM employee");
+    }
+  }
+
+  @Test public void mapToOneNoOpOnNoRows() {
+    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE 1=2")
+        .take(1)
+        .lift(Query.mapToOne(Employee.MAPPER))
+        .toList()
+        .toBlocking()
+        .first();
+    assertThat(employees).isEmpty();
+  }
+
+  @Test public void mapToOneThrowsOnMultipleRows() {
+    BlockingObservable<Employee> employees =
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 2") //
+            .lift(Query.mapToOne(Employee.MAPPER)) //
+            .toBlocking();
+    try {
+      employees.first();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Cursor returned more than 1 row");
+      assertThat(e.getCause()).hasMessage(
+          "OnError while emitting onNext value: SELECT username, name FROM employee LIMIT 2");
+    }
+  }
+
+  @Test public void mapToOneOrDefault() {
+    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
+        .lift(Query.mapToOneOrDefault(Employee.MAPPER, null))
+        .toBlocking()
+        .first();
+    assertThat(employees).isEqualTo(new Employee("alice", "Alice Allison"));
+  }
+
+  @Test public void mapToOneOrDefaultReturnsDefaultWhenNoRows() {
+    Employee defaultEmployee = new Employee("bob", "Bob Bobberson");
+    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE 1=2")
+        .lift(Query.mapToOneOrDefault(Employee.MAPPER, defaultEmployee))
+        .toBlocking()
+        .first();
+    assertThat(employees).isSameAs(defaultEmployee);
+  }
+
+  @Test public void mapToOneOrDefaultAllowsNullDefault() {
+    Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE 1=2")
+        .lift(Query.mapToOneOrDefault(Employee.MAPPER, null))
+        .toBlocking()
+        .first();
+    assertThat(employees).isNull();
+  }
+
+  @Test public void mapToOneOrDefaultThrowsOnMapperNull() {
+    BlockingObservable<Employee> employees =
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES) //
+            .lift(Query.mapToOneOrDefault(new Func1<Cursor, Employee>() {
+              @Override public Employee call(Cursor cursor) {
+                return null;
+              }
+            }, null)) //
+            .toBlocking();
+    try {
+      employees.first();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("Mapper returned null for row 1");
+      assertThat(e.getCause()).hasMessage(
+          "OnError while emitting onNext value: SELECT username, name FROM employee");
+    }
+  }
+
+  @Test public void mapToOneOrDefaultThrowsOnMultipleRows() {
+    BlockingObservable<Employee> employees =
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 2") //
+            .lift(Query.mapToOneOrDefault(Employee.MAPPER, null)) //
+            .toBlocking();
+    try {
+      employees.first();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Cursor returned more than 1 row");
+      assertThat(e.getCause()).hasMessage(
+          "OnError while emitting onNext value: SELECT username, name FROM employee LIMIT 2");
+    }
+  }
+
+  @Test public void mapToList() {
+    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+        .lift(Query.mapToList(Employee.MAPPER))
+        .toBlocking()
+        .first();
+    assertThat(employees).containsExactly( //
+        new Employee("alice", "Alice Allison"), //
+        new Employee("bob", "Bob Bobberson"), //
+        new Employee("eve", "Eve Evenson"));
+  }
+
+  @Test public void mapToListEmptyWhenNoRows() {
+    List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE 1=2")
+        .lift(Query.mapToList(Employee.MAPPER))
+        .toBlocking()
+        .first();
+    assertThat(employees).isEmpty();
+  }
+
+  @Test public void mapToListThrowsOnMapperNull() {
+    BlockingObservable<List<Employee>> employees =
+        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES) //
+            .lift(Query.mapToList(new Func1<Cursor, Employee>() {
+              private int count;
+
+              @Override public Employee call(Cursor cursor) {
+                return count++ == 2 ? null : Employee.MAPPER.call(cursor);
+              }
+            })) //
+            .toBlocking();
+    try {
+      employees.first();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("Mapper returned null for row 3");
+      assertThat(e.getCause()).hasMessage(
+          "OnError while emitting onNext value: SELECT username, name FROM employee");
+    }
+  }
+}
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java
index 96e1d20..e670477 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java
@@ -19,13 +19,13 @@
 import android.util.Log;
 import java.util.concurrent.BlockingDeque;
 import java.util.concurrent.LinkedBlockingDeque;
-import rx.Observer;
+import rx.Subscriber;
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.squareup.sqlbrite.SqlBrite.Query;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
-final class RecordingObserver implements Observer<Query> {
+final class RecordingObserver extends Subscriber<Query> {
   private static final Object COMPLETED = "<completed>";
   private static final String TAG = RecordingObserver.class.getSimpleName();
 
@@ -46,6 +46,10 @@
     events.add(value.run());
   }
 
+  public void doRequest(long amount) {
+    request(amount);
+  }
+
   private Object takeEvent() {
     try {
       Object item = events.pollFirst(1, SECONDS);
@@ -71,7 +75,11 @@ public void assertErrorContains(String expected) {
   }
 
   public void assertNoMoreEvents() {
-    assertThat(events).isEmpty();
+    try {
+      assertThat(events.pollFirst(1, SECONDS)).isNull();
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
   }
 
   static final class CursorAssert {
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java
index 6432b1a..f320d2b 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java
@@ -1,632 +1,98 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 package com.squareup.sqlbrite;
 
-import android.content.ContentValues;
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteException;
-import android.support.test.InstrumentationRegistry;
+import android.database.MatrixCursor;
 import android.support.test.runner.AndroidJUnit4;
-import com.google.common.collect.Range;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
+import com.squareup.sqlbrite.SqlBrite.Query;
 import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import org.junit.After;
-import org.junit.Before;
+import java.util.concurrent.atomic.AtomicInteger;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import rx.Observable;
-import rx.Subscription;
+import rx.functions.Func1;
 
-import static android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE;
 import static com.google.common.truth.Truth.assertThat;
-import static com.squareup.sqlbrite.RecordingObserver.CursorAssert;
-import static com.squareup.sqlbrite.SqlBrite.Query;
-import static com.squareup.sqlbrite.TestDb.EmployeeTable.ID;
-import static com.squareup.sqlbrite.TestDb.EmployeeTable.NAME;
-import static com.squareup.sqlbrite.TestDb.EmployeeTable.USERNAME;
-import static com.squareup.sqlbrite.TestDb.ManagerTable.EMPLOYEE_ID;
-import static com.squareup.sqlbrite.TestDb.ManagerTable.MANAGER_ID;
-import static com.squareup.sqlbrite.TestDb.TABLE_EMPLOYEE;
-import static com.squareup.sqlbrite.TestDb.TABLE_MANAGER;
-import static com.squareup.sqlbrite.TestDb.employee;
-import static com.squareup.sqlbrite.TestDb.manager;
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
 public final class SqlBriteTest {
-  private static final Collection<String> BOTH_TABLES =
-      Arrays.asList(TABLE_EMPLOYEE, TABLE_MANAGER);
-  private static final String SELECT_EMPLOYEES =
-      "SELECT " + USERNAME + ", " + NAME + " FROM " + TABLE_EMPLOYEE;
-  private static final String SELECT_MANAGER_LIST = ""
-      + "SELECT e." + NAME + ", m." + NAME + " "
-      + "FROM " + TABLE_MANAGER + " AS manager "
-      + "JOIN " + TABLE_EMPLOYEE + " AS e "
-      + "ON manager." + EMPLOYEE_ID + " = e." + ID + " "
-      + "JOIN " + TABLE_EMPLOYEE + " as m "
-      + "ON manager." + MANAGER_ID + " = m." + ID;
-
-  private final RecordingObserver o = new RecordingObserver();
-
-  private TestDb helper;
-  private SQLiteDatabase real;
-  private SqlBrite db;
-
-  @Before public void setUp() {
-    helper = new TestDb(InstrumentationRegistry.getContext());
-    real = helper.getWritableDatabase();
-    db = SqlBrite.create(helper);
-    db.setLoggingEnabled(true);
-  }
-
-  @After public void tearDown() {
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void loggerInvalidValues() {
-    try {
-      db.setLogger(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("logger == null");
-    }
-  }
-
-  @Test public void loggerEnabled() {
-    final List<String> logs = new ArrayList<>();
-    db.setLogger(new SqlBrite.Logger() {
-      @Override public void log(String message) {
-        logs.add(message);
-      }
-    });
-
-    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-    assertThat(logs).isNotEmpty();
-  }
-
-  @Test public void loggerDisabled() {
-    final List<String> logs = new ArrayList<>();
-    db.setLoggingEnabled(false);
-    db.setLogger(new SqlBrite.Logger() {
-      @Override public void log(String message) {
-        logs.add(message);
-      }
-    });
-
-    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-    assertThat(logs).isEmpty();
-  }
-
-  @Test public void closePropagates() throws IOException {
-    db.close();
-    assertThat(real.isOpen()).isFalse();
-  }
-
-  @Test public void query() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-  }
-
-  @Test public void badQueryCallsError() {
-    db.createQuery(TABLE_EMPLOYEE, "SELECT * FROM missing").subscribe(o);
-    o.assertErrorContains("no such table: missing");
-  }
-
-  @Test public void queryWithArgs() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " WHERE " + USERNAME + " = ?", "bob")
-        .subscribe(o);
-    o.assertCursor()
-        .hasRow("bob", "Bob Bobberson")
-        .isExhausted();
-  }
-
-  @Test public void queryObservesInsert() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("john", "John Johnson")
-        .isExhausted();
-  }
-
-  @Test public void queryObservesInsertDebounced() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
-        .debounce(500, MILLISECONDS)
-        .subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    long startNs = System.nanoTime();
-
-    // Shotgun 10 inserts which will cause 10 triggers. DO NOT DO THIS IRL! Use a transaction!
-    for (int i = 0; i < 10; i++) {
-      db.insert(TABLE_EMPLOYEE, employee("john" + i, "John Johnson " + i));
-    }
-
-    // Only one trigger should have been observed.
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("john0", "John Johnson 0")
-        .hasRow("john1", "John Johnson 1")
-        .hasRow("john2", "John Johnson 2")
-        .hasRow("john3", "John Johnson 3")
-        .hasRow("john4", "John Johnson 4")
-        .hasRow("john5", "John Johnson 5")
-        .hasRow("john6", "John Johnson 6")
-        .hasRow("john7", "John Johnson 7")
-        .hasRow("john8", "John Johnson 8")
-        .hasRow("john9", "John Johnson 9")
-        .isExhausted();
-
-    long tookNs = System.nanoTime() - startNs;
-    assertThat(TimeUnit.NANOSECONDS.toMillis(tookNs)).isIn(Range.atLeast(500L));
-  }
-
-  @Test public void queryNotNotifiedWhenInsertFails() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.insert(TABLE_EMPLOYEE, employee("bob", "Bob Bobberson"), CONFLICT_IGNORE);
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void queryObservesUpdate() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    ContentValues values = new ContentValues();
-    values.put(NAME, "Robert Bobberson");
-    db.update(TABLE_EMPLOYEE, values, USERNAME + " = 'bob'");
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Robert Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-  }
-
-  @Test public void queryNotNotifiedWhenUpdateAffectsZeroRows() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    ContentValues values = new ContentValues();
-    values.put(NAME, "John Johnson");
-    db.update(TABLE_EMPLOYEE, values, USERNAME + " = 'john'");
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void queryObservesDelete() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.delete(TABLE_EMPLOYEE, USERNAME + " = 'bob'");
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-  }
-
-  @Test public void queryNotNotifiedWhenDeleteAffectsZeroRows() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.delete(TABLE_EMPLOYEE, USERNAME + " = 'john'");
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void queryMultipleTables() {
-    db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-  }
-
-  @Test public void queryMultipleTablesObservesChanges() {
-    db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-
-    // A new employee triggers, despite the fact that it's not in our result set.
-    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-
-    // A new manager also triggers and it is in our result set.
-    db.insert(TABLE_MANAGER, manager(helper.bobId, helper.eveId));
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .hasRow("Bob Bobberson", "Eve Evenson")
-        .isExhausted();
-  }
-
-  @Test public void queryMultipleTablesObservesChangesOnlyOnce() {
-    // Employee table is in this list twice. We should still only be notified once for a change.
-    List<String> tables = Arrays.asList(TABLE_EMPLOYEE, TABLE_MANAGER, TABLE_EMPLOYEE);
-    db.createQuery(tables, SELECT_MANAGER_LIST).subscribe(o);
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-
-    ContentValues values = new ContentValues();
-    values.put(NAME, "Even Evenson");
-    db.update(TABLE_EMPLOYEE, values, USERNAME + " = 'eve'");
-    o.assertCursor()
-        .hasRow("Even Evenson", "Alice Allison")
-        .isExhausted();
-  }
-
-  @Test public void queryNotNotifiedAfterUnsubscribe() {
-    Subscription subscription = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-    subscription.unsubscribe();
-
-    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-    o.assertNoMoreEvents();
-  }
-
-  @Test public void queryOnlyNotifiedAfterSubscribe() {
-    Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
-    o.assertNoMoreEvents();
-
-    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-    o.assertNoMoreEvents();
-
-    query.subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("john", "John Johnson")
-        .isExhausted();
-  }
-
-  @Test public void transactionOnlyNotifiesOnce() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.beginTransaction();
-    try {
-      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-      db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
-      o.assertNoMoreEvents();
-
-      db.setTransactionSuccessful();
-    } finally {
-      db.endTransaction();
-    }
-
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("john", "John Johnson")
-        .hasRow("nick", "Nick Nickers")
-        .isExhausted();
-  }
-
-  @Test public void queryCreatedDuringTransactionThrows() {
-    db.beginTransaction();
-    try {
-      db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).startsWith("Cannot create observable query in transaction.");
-    }
-  }
-
-  @Test public void querySubscribedToDuringTransactionThrows() {
-    Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
-
-    db.beginTransaction();
-    query.subscribe(o);
-    o.assertErrorContains("Cannot subscribe to observable query in a transaction.");
-  }
-
-  @Test public void endTransactionWithNoBeginFails() {
-    try {
-      db.endTransaction();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Not in transaction.");
-    }
-  }
-
-  @Test public void querySubscribedToDuringTransactionOnDifferentThread()
-      throws InterruptedException {
-    db.beginTransaction();
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    new Thread() {
-      @Override public void run() {
-        db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-        latch.countDown();
+  private static final String FIRST_NAME = "first_name";
+  private static final String LAST_NAME = "last_name";
+  private static final String[] COLUMN_NAMES = { FIRST_NAME, LAST_NAME };
+
+  @Test public void asRowsEmpty() {
+    MatrixCursor cursor = new MatrixCursor(COLUMN_NAMES);
+    Query query = new CursorQuery(cursor);
+    List<Name> names = query.asRows(Name.MAP).toList().toBlocking().first();
+    assertThat(names).isEmpty();
+  }
+
+  @Test public void asRows() {
+    MatrixCursor cursor = new MatrixCursor(COLUMN_NAMES);
+    cursor.addRow(new Object[] { "Alice", "Allison" });
+    cursor.addRow(new Object[] { "Bob", "Bobberson" });
+
+    Query query = new CursorQuery(cursor);
+    List<Name> names = query.asRows(Name.MAP).toList().toBlocking().first();
+    assertThat(names).containsExactly(new Name("Alice", "Allison"), new Name("Bob", "Bobberson"));
+  }
+
+  @Test public void asRowsStopsWhenUnsubscribed() {
+    MatrixCursor cursor = new MatrixCursor(COLUMN_NAMES);
+    cursor.addRow(new Object[] { "Alice", "Allison" });
+    cursor.addRow(new Object[] { "Bob", "Bobberson" });
+
+    Query query = new CursorQuery(cursor);
+    final AtomicInteger count = new AtomicInteger();
+    query.asRows(new Func1<Cursor, Name>() {
+      @Override public Name call(Cursor cursor) {
+        count.incrementAndGet();
+        return Name.MAP.call(cursor);
       }
-    }.start();
-
-    Thread.sleep(500); // Wait for the thread to block on initial query.
-    o.assertNoMoreEvents();
-
-    db.endTransaction(); // Allow other queries to continue.
-    latch.await(500, MILLISECONDS); // Wait for thread to observe initial query.
-
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
+    }).take(1).toBlocking().first();
+    assertThat(count.get()).isEqualTo(1);
   }
 
-  @Test public void queryCreatedBeforeTransactionButSubscribedAfter() {
-    Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
-
-    db.beginTransaction();
-    try {
-      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-      db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
-      db.setTransactionSuccessful();
-    } finally {
-      db.endTransaction();
-    }
-
-    query.subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("john", "John Johnson")
-        .hasRow("nick", "Nick Nickers")
-        .isExhausted();
-  }
-
-  @Test public void synchronousQueryDuringTransaction() {
-    db.beginTransaction();
-    try {
-      db.setTransactionSuccessful();
-      assertCursor(db.query(SELECT_EMPLOYEES))
-          .hasRow("alice", "Alice Allison")
-          .hasRow("bob", "Bob Bobberson")
-          .hasRow("eve", "Eve Evenson")
-          .isExhausted();
-    } finally {
-      db.endTransaction();
-    }
-  }
-
-  @Test public void synchronousQueryDuringTransactionSeesChanges() {
-    db.beginTransaction();
-    try {
-      assertCursor(db.query(SELECT_EMPLOYEES))
-          .hasRow("alice", "Alice Allison")
-          .hasRow("bob", "Bob Bobberson")
-          .hasRow("eve", "Eve Evenson")
-          .isExhausted();
-
-      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-      db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
-
-      assertCursor(db.query(SELECT_EMPLOYEES))
-          .hasRow("alice", "Alice Allison")
-          .hasRow("bob", "Bob Bobberson")
-          .hasRow("eve", "Eve Evenson")
-          .hasRow("john", "John Johnson")
-          .hasRow("nick", "Nick Nickers")
-          .isExhausted();
-
-      db.setTransactionSuccessful();
-    } finally {
-      db.endTransaction();
-    }
-  }
-
-  @Test public void nestedTransactionsOnlyNotifyOnce() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.beginTransaction();
-    try {
-      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-
-      db.beginTransaction();
-      try {
-        db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
-        db.setTransactionSuccessful();
-      } finally {
-        db.endTransaction();
-      }
-
-      db.setTransactionSuccessful();
-    } finally {
-      db.endTransaction();
-    }
-
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .hasRow("john", "John Johnson")
-        .hasRow("nick", "Nick Nickers")
-        .isExhausted();
-  }
-
-  @Test public void nestedTransactionsOnMultipleTables() {
-    db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .isExhausted();
-
-    db.beginTransaction();
-    try {
-
-      db.beginTransaction();
-      try {
-        db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-        db.setTransactionSuccessful();
-      } finally {
-        db.endTransaction();
+  static final class Name {
+    static final Func1<Cursor, Name> MAP = new Func1<Cursor, Name>() {
+      @Override public Name call(Cursor cursor) {
+        return new Name( //
+            cursor.getString(cursor.getColumnIndexOrThrow(FIRST_NAME)),
+            cursor.getString(cursor.getColumnIndexOrThrow(LAST_NAME)));
       }
+    };
 
-      db.beginTransaction();
-      try {
-        db.insert(TABLE_MANAGER, manager(helper.aliceId, helper.bobId));
-        db.setTransactionSuccessful();
-      } finally {
-        db.endTransaction();
-      }
+    final String first;
+    final String last;
 
-      db.setTransactionSuccessful();
-    } finally {
-      db.endTransaction();
+    Name(String first, String last) {
+      this.first = first;
+      this.last = last;
     }
 
-    o.assertCursor()
-        .hasRow("Eve Evenson", "Alice Allison")
-        .hasRow("Alice Allison", "Bob Bobberson")
-        .isExhausted();
-  }
-
-  @Test public void emptyTransactionDoesNotNotify() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.beginTransaction();
-    try {
-      db.setTransactionSuccessful();
-    } finally {
-      db.endTransaction();
+    @Override public boolean equals(Object o) {
+      if (o == this) return true;
+      if (!(o instanceof Name)) return false;
+      Name other = (Name) o;
+      return first.equals(other.first) && last.equals(other.last);
     }
-    o.assertNoMoreEvents();
-  }
 
-  @Test public void transactionRollbackDoesNotNotify() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
-    o.assertCursor()
-        .hasRow("alice", "Alice Allison")
-        .hasRow("bob", "Bob Bobberson")
-        .hasRow("eve", "Eve Evenson")
-        .isExhausted();
-
-    db.beginTransaction();
-    try {
-      db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
-      db.insert(TABLE_EMPLOYEE, employee("nick", "Nick Nickers"));
-      // No call to set successful.
-    } finally {
-      db.endTransaction();
+    @Override public int hashCode() {
+      return first.hashCode() * 17 + last.hashCode();
     }
-    o.assertNoMoreEvents();
-  }
 
-  @Test public void badQueryThrows() {
-    try {
-      db.query("SELECT * FROM missing");
-      fail();
-    } catch (SQLiteException e) {
-      assertThat(e.getMessage()).contains("no such table: missing");
+    @Override public String toString() {
+      return "Name[" + first + ' ' + last + ']';
     }
   }
 
-  @Test public void badInsertThrows() {
-    try {
-      db.insert("missing", employee("john", "John Johnson"));
-      fail();
-    } catch (SQLiteException e) {
-      assertThat(e.getMessage()).contains("no such table: missing");
-    }
-  }
+  static final class CursorQuery extends Query {
+    private final Cursor cursor;
 
-  @Test public void badUpdateThrows() {
-    try {
-      db.update("missing", employee("john", "John Johnson"), "1");
-      fail();
-    } catch (SQLiteException e) {
-      assertThat(e.getMessage()).contains("no such table: missing");
+    CursorQuery(Cursor cursor) {
+      this.cursor = cursor;
     }
-  }
 
-  @Test public void badDeleteThrows() {
-    try {
-      db.delete("missing", "1");
-      fail();
-    } catch (SQLiteException e) {
-      assertThat(e.getMessage()).contains("no such table: missing");
+    @Override public Cursor run() {
+      return cursor;
     }
   }
-
-  private static CursorAssert assertCursor(Cursor cursor) {
-    return new CursorAssert(cursor);
-  }
 }
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestDb.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestDb.java
index bf524b6..6fa8d20 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestDb.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestDb.java
@@ -17,19 +17,75 @@
 
 import android.content.ContentValues;
 import android.content.Context;
+import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
+import android.support.annotation.NonNull;
+import java.util.Arrays;
+import java.util.Collection;
+import rx.functions.Func1;
+
+import static com.squareup.sqlbrite.TestDb.EmployeeTable.ID;
+import static com.squareup.sqlbrite.TestDb.EmployeeTable.NAME;
+import static com.squareup.sqlbrite.TestDb.EmployeeTable.USERNAME;
+import static com.squareup.sqlbrite.TestDb.ManagerTable.EMPLOYEE_ID;
+import static com.squareup.sqlbrite.TestDb.ManagerTable.MANAGER_ID;
 
 final class TestDb extends SQLiteOpenHelper {
   static final String TABLE_EMPLOYEE = "employee";
   static final String TABLE_MANAGER = "manager";
 
+  static final String SELECT_EMPLOYEES =
+      "SELECT " + USERNAME + ", " + NAME + " FROM " + TABLE_EMPLOYEE;
+  static final String SELECT_MANAGER_LIST = ""
+      + "SELECT e." + NAME + ", m." + NAME + " "
+      + "FROM " + TABLE_MANAGER + " AS manager "
+      + "JOIN " + TABLE_EMPLOYEE + " AS e "
+      + "ON manager." + EMPLOYEE_ID + " = e." + ID + " "
+      + "JOIN " + TABLE_EMPLOYEE + " as m "
+      + "ON manager." + MANAGER_ID + " = m." + ID;
+  static final Collection<String> BOTH_TABLES =
+      Arrays.asList(TABLE_EMPLOYEE, TABLE_MANAGER);
+
   interface EmployeeTable {
     String ID = "_id";
     String USERNAME = "username";
     String NAME = "name";
   }
 
+  static final class Employee {
+    static final Func1<Cursor, Employee> MAPPER = new Func1<Cursor, Employee>() {
+      @Override public Employee call(Cursor cursor) {
+        return new Employee( //
+            cursor.getString(cursor.getColumnIndexOrThrow(EmployeeTable.USERNAME)),
+            cursor.getString(cursor.getColumnIndexOrThrow(EmployeeTable.NAME)));
+      }
+    };
+
+    final String username;
+    final String name;
+
+    Employee(String username, String name) {
+      this.username = username;
+      this.name = name;
+    }
+
+    @Override public boolean equals(Object o) {
+      if (o == this) return true;
+      if (!(o instanceof Employee)) return false;
+      Employee other = (Employee) o;
+      return username.equals(other.username) && name.equals(other.name);
+    }
+
+    @Override public int hashCode() {
+      return username.hashCode() * 17 + name.hashCode();
+    }
+
+    @Override public String toString() {
+      return "Employee[" + username + ' ' + name + ']';
+    }
+  }
+
   interface ManagerTable {
     String ID = "_id";
     String EMPLOYEE_ID = "employee_id";
@@ -53,7 +109,7 @@
     super(context, null /* memory */, null /* cursor factory */, 1 /* version */);
   }
 
-  @Override public void onCreate(SQLiteDatabase db) {
+  @Override public void onCreate(@NonNull SQLiteDatabase db) {
     db.execSQL("PRAGMA foreign_keys=ON");
 
     db.execSQL(CREATE_EMPLOYEE);
@@ -79,6 +135,7 @@ static ContentValues manager(long employeeId, long managerId) {
     return values;
   }
 
-  @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+  @Override public void onUpgrade(@NonNull SQLiteDatabase db, int oldVersion, int newVersion) {
+    throw new AssertionError();
   }
 }
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBriteContentProvider.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
similarity index 70%
rename from sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBriteContentProvider.java
rename to sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
index fa446d6..d407d03 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBriteContentProvider.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
@@ -21,11 +21,12 @@
 import android.net.Uri;
 import android.os.Handler;
 import android.os.Looper;
+import android.support.annotation.CheckResult;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.util.Log;
 import java.util.Arrays;
 import rx.Observable;
+import rx.Observable.OnSubscribe;
 import rx.Subscriber;
 import rx.functions.Action0;
 import rx.subscriptions.Subscriptions;
@@ -35,50 +36,26 @@
 
 /**
  * A lightweight wrapper around {@link ContentResolver} which allows for continuously observing
- * the result of a query.
+ * the result of a query. Create using a {@link SqlBrite} instance.
  */
-public final class SqlBriteContentProvider {
-  public static SqlBriteContentProvider create(@NonNull ContentResolver contentResolver) {
-    return new SqlBriteContentProvider(contentResolver);
-  }
+public final class BriteContentResolver {
+  final Handler contentObserverHandler = new Handler(Looper.getMainLooper());
 
-  private final Handler contentObserverHandler = new Handler(Looper.getMainLooper());
-  private final ContentResolver contentResolver;
+  final ContentResolver contentResolver;
+  private final Logger logger;
 
-  // Not volatile because we don't care if threads don't immediately see changes to this value.
-  private boolean logging;
-  private volatile Logger logger;
+  volatile boolean logging;
 
-  private SqlBriteContentProvider(ContentResolver contentResolver) {
+  BriteContentResolver(@NonNull ContentResolver contentResolver, @NonNull Logger logger) {
     this.contentResolver = contentResolver;
+    this.logger = logger;
   }
 
-  /**
-   * Control whether debug logging is enabled.
-   * <p>
-   * By default this method will log verbose message to {@linkplain Log Android's log}. Use a
-   * custom logger by calling {@link #setLogger}.
-   */
+  /** Control whether debug logging is enabled. */
   public void setLoggingEnabled(boolean enabled) {
-    if (enabled && logger == null) {
-      logger = new Logger() {
-        @Override public void log(String message) {
-          Log.v("SqlBrite", message);
-        }
-      };
-    }
     logging = enabled;
   }
 
-  /**
-   * Specify a custom logger for debug messages when {@linkplain #setLoggingEnabled(boolean)
-   * logging is enabled}.
-   */
-  public void setLogger(Logger logger) {
-    if (logger == null) throw new NullPointerException("logger == null");
-    this.logger = logger;
-  }
-
   /**
    * Create an observable which will notify subscribers with a {@linkplain Query query} for
    * execution. Subscribers are responsible for <b>always</b> closing {@link Cursor} instance
@@ -88,13 +65,17 @@ public void setLogger(Logger logger) {
    * notifications for when the supplied {@code uri}'s data changes. Unsubscribe when you no longer
    * want updates to a query.
    * <p>
+   * Note: To skip the immediate notification and only receive subsequent notifications when data
+   * has changed call {@code skip(1)} on the returned observable.
+   * <p>
    * <b>Warning:</b> this method does not perform the query! Only by subscribing to the returned
    * {@link Observable} will the operation occur.
    *
    * @see ContentResolver#query(Uri, String[], String, String[], String)
    * @see ContentResolver#registerContentObserver(Uri, boolean, ContentObserver)
    */
-  public Observable<Query> createQuery(@NonNull final Uri uri, @Nullable final String[] projection,
+  @CheckResult @NonNull
+  public QueryObservable createQuery(@NonNull final Uri uri, @Nullable final String[] projection,
       @Nullable final String selection, @Nullable final String[] selectionArgs, @Nullable
       final String sortOrder, final boolean notifyForDescendents) {
     final Query query = new Query() {
@@ -102,7 +83,7 @@ public void setLogger(Logger logger) {
         return contentResolver.query(uri, projection, selection, selectionArgs, sortOrder);
       }
     };
-    return Observable.create(new Observable.OnSubscribe<Query>() {
+    OnSubscribe<Query> subscribe = new OnSubscribe<Query>() {
       @Override public void call(final Subscriber<? super Query> subscriber) {
         final ContentObserver observer = new ContentObserver(contentObserverHandler) {
           @Override public void onChange(boolean selfChange) {
@@ -122,10 +103,14 @@ public void setLogger(Logger logger) {
           }
         }));
       }
-    }).startWith(query);
+    };
+    Observable<Query> queryObservable = Observable.create(subscribe) //
+        .startWith(query) //
+        .onBackpressureLatest();
+    return new QueryObservable(queryObservable);
   }
 
-  private void log(String message, Object... args) {
+  void log(String message, Object... args) {
     if (args.length > 0) message = String.format(message, args);
     logger.log(message);
   }
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
new file mode 100644
index 0000000..afd4c10
--- /dev/null
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
@@ -0,0 +1,607 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.sqlbrite;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.database.sqlite.SQLiteTransactionListener;
+import android.support.annotation.CheckResult;
+import android.support.annotation.IntDef;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.squareup.sqlbrite.SqlBrite.Query;
+import java.io.Closeable;
+import java.lang.annotation.Retention;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import rx.Observable;
+import rx.functions.Func1;
+import rx.subjects.PublishSubject;
+
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_ABORT;
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_FAIL;
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE;
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_NONE;
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_REPLACE;
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_ROLLBACK;
+import static java.lang.annotation.RetentionPolicy.SOURCE;
+
+/**
+ * A lightweight wrapper around {@link SQLiteOpenHelper} which allows for continuously observing
+ * the result of a query. Create using a {@link SqlBrite} instance.
+ */
+public final class BriteDatabase implements Closeable {
+  private static final Set<String> INITIAL_TRIGGER = Collections.singleton("<initial>");
+
+  private final SQLiteOpenHelper helper;
+  private final SqlBrite.Logger logger;
+
+  // Package-private to avoid synthetic accessor method for 'transaction' instance.
+  final ThreadLocal<SqliteTransaction> transactions = new ThreadLocal<>();
+  /** Publishes sets of tables which have changed. */
+  private final PublishSubject<Set<String>> triggers = PublishSubject.create();
+
+  private final Transaction transaction = new Transaction() {
+    @Override public void markSuccessful() {
+      if (logging) log("TXN SUCCESS %s", transactions.get());
+      getWriteableDatabase().setTransactionSuccessful();
+    }
+
+    @Override public boolean yieldIfContendedSafely() {
+      return getWriteableDatabase().yieldIfContendedSafely();
+    }
+
+    @Override public boolean yieldIfContendedSafely(long sleepAmount, TimeUnit sleepUnit) {
+      return getWriteableDatabase().yieldIfContendedSafely(sleepUnit.toMillis(sleepAmount));
+    }
+
+    @Override public void end() {
+      SqliteTransaction transaction = transactions.get();
+      if (transaction == null) {
+        throw new IllegalStateException("Not in transaction.");
+      }
+      SqliteTransaction newTransaction = transaction.parent;
+      transactions.set(newTransaction);
+      if (logging) log("TXN END %s", transaction);
+      getWriteableDatabase().endTransaction();
+      // Send the triggers after ending the transaction in the DB.
+      if (transaction.commit) {
+        sendTableTrigger(transaction);
+      }
+    }
+
+    @Override public void close() {
+      end();
+    }
+  };
+
+  // Read and write guarded by 'databaseLock'. Lazily initialized. Use methods to access.
+  private volatile SQLiteDatabase readableDatabase;
+  private volatile SQLiteDatabase writeableDatabase;
+  private final Object databaseLock = new Object();
+
+  // Package-private to avoid synthetic accessor method for 'transaction' instance.
+  volatile boolean logging;
+
+  BriteDatabase(@NonNull SQLiteOpenHelper helper, @NonNull SqlBrite.Logger logger) {
+    this.helper = helper;
+    this.logger = logger;
+  }
+
+  /**
+   * Control whether debug logging is enabled.
+   */
+  public void setLoggingEnabled(boolean enabled) {
+    logging = enabled;
+  }
+
+  SQLiteDatabase getReadableDatabase() {
+    SQLiteDatabase db = readableDatabase;
+    if (db == null) {
+      synchronized (databaseLock) {
+        db = readableDatabase;
+        if (db == null) {
+          if (logging) log("Creating readable database");
+          db = readableDatabase = helper.getReadableDatabase();
+        }
+      }
+    }
+    return db;
+  }
+
+  // Package-private to avoid synthetic accessor method for 'transaction' instance.
+  SQLiteDatabase getWriteableDatabase() {
+    SQLiteDatabase db = writeableDatabase;
+    if (db == null) {
+      synchronized (databaseLock) {
+        db = writeableDatabase;
+        if (db == null) {
+          if (logging) log("Creating writeable database");
+          db = writeableDatabase = helper.getWritableDatabase();
+        }
+      }
+    }
+    return db;
+  }
+
+  void sendTableTrigger(Set<String> tables) {
+    SqliteTransaction transaction = transactions.get();
+    if (transaction != null) {
+      transaction.addAll(tables);
+    } else {
+      if (logging) log("TRIGGER %s", tables);
+      triggers.onNext(tables);
+    }
+  }
+
+  /**
+   * Begin a transaction for this thread.
+   * <p>
+   * Transactions may nest. If the transaction is not in progress, then a database connection is
+   * obtained and a new transaction is started. Otherwise, a nested transaction is started.
+   * <p>
+   * Each call to {@code newTransaction} must be matched exactly by a call to
+   * {@link Transaction#end()}. To mark a transaction as successful, call
+   * {@link Transaction#markSuccessful()} before calling {@link Transaction#end()}. If the
+   * transaction is not successful, or if any of its nested transactions were not successful, then
+   * the entire transaction will be rolled back when the outermost transaction is ended.
+   * <p>
+   * Transactions queue up all query notifications until they have been applied.
+   * <p>
+   * Here is the standard idiom for transactions:
+   *
+   * <pre>{@code
+   * try (Transaction transaction = db.newTransaction()) {
+   *   ...
+   *   transaction.markSuccessful();
+   * }
+   * }</pre>
+   *
+   * Manually call {@link Transaction#end()} when try-with-resources is not available:
+   * <pre>{@code
+   * Transaction transaction = db.newTransaction();
+   * try {
+   *   ...
+   *   transaction.markSuccessful();
+   * } finally {
+   *   transaction.end();
+   * }
+   * }</pre>
+   *
+   *
+   * @see SQLiteDatabase#beginTransaction()
+   */
+  @CheckResult @NonNull
+  public Transaction newTransaction() {
+    SqliteTransaction transaction = new SqliteTransaction(transactions.get());
+    transactions.set(transaction);
+    if (logging) log("TXN BEGIN %s", transaction);
+    getWriteableDatabase().beginTransactionWithListener(transaction);
+
+    return this.transaction;
+  }
+
+  /**
+   * Close the underlying {@link SQLiteOpenHelper} and remove cached readable and writeable
+   * databases. This does not prevent existing observables from retaining existing references as
+   * well as attempting to create new ones for new subscriptions.
+   */
+  @Override public void close() {
+    synchronized (databaseLock) {
+      readableDatabase = null;
+      writeableDatabase = null;
+      helper.close();
+    }
+  }
+
+  /**
+   * Create an observable which will notify subscribers with a {@linkplain Query query} for
+   * execution. Subscribers are responsible for <b>always</b> closing {@link Cursor} instance
+   * returned from the {@link Query}.
+   * <p>
+   * Subscribers will receive an immediate notification for initial data as well as subsequent
+   * notifications for when the supplied {@code table}'s data changes through the {@code insert},
+   * {@code update}, and {@code delete} methods of this class. Unsubscribe when you no longer want
+   * updates to a query.
+   * <p>
+   * Note: To skip the immediate notification and only receive subsequent notifications when data
+   * has changed call {@code skip(1)} on the returned observable.
+   * <p>
+   * <b>Warning:</b> this method does not perform the query! Only by subscribing to the returned
+   * {@link Observable} will the operation occur.
+   *
+   * @see SQLiteDatabase#rawQuery(String, String[])
+   */
+  @CheckResult @NonNull
+  public QueryObservable createQuery(@NonNull final String table, @NonNull String sql,
+      @NonNull String... args) {
+    Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
+      @Override public Boolean call(Set<String> triggers) {
+        return triggers.contains(table);
+      }
+
+      @Override public String toString() {
+        return table;
+      }
+    };
+    return createQuery(tableFilter, sql, args);
+  }
+
+  /**
+   * See {@link #createQuery(String, String, String...)} for usage. This overload allows for
+   * monitoring multiple tables for changes.
+   *
+   * @see SQLiteDatabase#rawQuery(String, String[])
+   */
+  @CheckResult @NonNull
+  public QueryObservable createQuery(@NonNull final Iterable<String> tables, @NonNull String sql,
+      @NonNull String... args) {
+    Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
+      @Override public Boolean call(Set<String> triggers) {
+        for (String table : tables) {
+          if (triggers.contains(table)) {
+            return true;
+          }
+        }
+        return false;
+      }
+
+      @Override public String toString() {
+        return tables.toString();
+      }
+    };
+    return createQuery(tableFilter, sql, args);
+  }
+
+  @CheckResult @NonNull
+  private QueryObservable createQuery(final Func1<Set<String>, Boolean> tableFilter,
+      final String sql, final String... args) {
+    if (transactions.get() != null) {
+      throw new IllegalStateException("Cannot create observable query in transaction. "
+          + "Use query() for a query inside a transaction.");
+    }
+
+    final Query query = new Query() {
+      @Override public Cursor run() {
+        if (transactions.get() != null) {
+          throw new IllegalStateException("Cannot execute observable query in a transaction.");
+        }
+        return getReadableDatabase().rawQuery(sql, args);
+      }
+
+      @Override public String toString() {
+        return sql;
+      }
+    };
+
+    Observable<Query> queryObservable = triggers //
+        .filter(tableFilter) // Only trigger on tables we care about.
+        .startWith(INITIAL_TRIGGER) // Immediately execute the query for initial value.
+        .map(new Func1<Set<String>, Query>() {
+          @Override public Query call(Set<String> trigger) {
+            if (transactions.get() != null) {
+              throw new IllegalStateException(
+                  "Cannot subscribe to observable query in a transaction.");
+            }
+            if (logging) {
+              log("QUERY\n  trigger: %s\n  tables: %s\n  sql: %s\n  args: %s", trigger, tableFilter,
+                  sql, Arrays.toString(args));
+            }
+            return query;
+          }
+        }) //
+        .onBackpressureLatest();
+    return new QueryObservable(queryObservable);
+  }
+
+  /**
+   * Runs the provided SQL and returns a {@link Cursor} over the result set.
+   *
+   * @see SQLiteDatabase#rawQuery(String, String[])
+   */
+  @CheckResult // TODO @WorkerThread
+  public Cursor query(@NonNull String sql, @NonNull String... args) {
+    if (logging) log("QUERY\n  sql: %s\n  args: %s", sql, Arrays.toString(args));
+    return getReadableDatabase().rawQuery(sql, args);
+  }
+
+  /**
+   * Insert a row into the specified {@code table} and notify any subscribed queries.
+   *
+   * @see SQLiteDatabase#insert(String, String, ContentValues)
+   */
+  // TODO @WorkerThread
+  public long insert(@NonNull String table, @NonNull ContentValues values) {
+    return insert(table, values, CONFLICT_NONE);
+  }
+
+  /**
+   * Insert a row into the specified {@code table} and notify any subscribed queries.
+   *
+   * @see SQLiteDatabase#insertWithOnConflict(String, String, ContentValues, int)
+   */
+  // TODO @WorkerThread
+  public long insert(@NonNull String table, @NonNull ContentValues values,
+      @ConflictAlgorithm int conflictAlgorithm) {
+    SQLiteDatabase db = getWriteableDatabase();
+
+    if (logging) {
+      log("INSERT\n  table: %s\n  values: %s\n  conflictAlgorithm: %s", table, values,
+          conflictString(conflictAlgorithm));
+    }
+    long rowId = db.insertWithOnConflict(table, null, values, conflictAlgorithm);
+
+    if (logging) log("INSERT id: %s", rowId);
+
+    if (rowId != -1) {
+      // Only send a table trigger if the insert was successful.
+      sendTableTrigger(Collections.singleton(table));
+    }
+    return rowId;
+  }
+
+  /**
+   * Delete rows from the specified {@code table} and notify any subscribed queries. This method
+   * will not trigger a notification if no rows were deleted.
+   *
+   * @see SQLiteDatabase#delete(String, String, String[])
+   */
+  // TODO @WorkerThread
+  public int delete(@NonNull String table, @Nullable String whereClause,
+      @Nullable String... whereArgs) {
+    SQLiteDatabase db = getWriteableDatabase();
+
+    if (logging) {
+      log("DELETE\n  table: %s\n  whereClause: %s\n  whereArgs: %s", table, whereClause,
+          Arrays.toString(whereArgs));
+    }
+    int rows = db.delete(table, whereClause, whereArgs);
+
+    if (logging) log("DELETE affected %s %s", rows, rows != 1 ? "rows" : "row");
+
+    if (rows > 0) {
+      // Only send a table trigger if rows were affected.
+      sendTableTrigger(Collections.singleton(table));
+    }
+    return rows;
+  }
+
+  /**
+   * Update rows in the specified {@code table} and notify any subscribed queries. This method
+   * will not trigger a notification if no rows were updated.
+   *
+   * @see SQLiteDatabase#update(String, ContentValues, String, String[])
+   */
+  // TODO @WorkerThread
+  public int update(@NonNull String table, @NonNull ContentValues values,
+      @Nullable String whereClause, @Nullable String... whereArgs) {
+    return update(table, values, CONFLICT_NONE, whereClause, whereArgs);
+  }
+
+  /**
+   * Update rows in the specified {@code table} and notify any subscribed queries. This method
+   * will not trigger a notification if no rows were updated.
+   *
+   * @see SQLiteDatabase#updateWithOnConflict(String, ContentValues, String, String[], int)
+   */
+  // TODO @WorkerThread
+  public int update(@NonNull String table, @NonNull ContentValues values,
+      @ConflictAlgorithm int conflictAlgorithm, @Nullable String whereClause,
+      @Nullable String... whereArgs) {
+    SQLiteDatabase db = getWriteableDatabase();
+
+    if (logging) {
+      log("UPDATE\n  table: %s\n  values: %s\n  whereClause: %s\n  whereArgs: %s\n  conflictAlgorithm: %s",
+          table, values, whereClause, Arrays.toString(whereArgs),
+          conflictString(conflictAlgorithm));
+    }
+    int rows = db.updateWithOnConflict(table, values, whereClause, whereArgs, conflictAlgorithm);
+
+    if (logging) log("UPDATE affected %s %s", rows, rows != 1 ? "rows" : "row");
+
+    if (rows > 0) {
+      // Only send a table trigger if rows were affected.
+      sendTableTrigger(Collections.singleton(table));
+    }
+    return rows;
+  }
+
+  /**
+   * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
+   * returns data. No data can be returned (such as the number of affected rows). Instead, use
+   * {@link #insert}, {@link #update}, et al, when possible.
+   * <p>
+   * No notifications will be sent to queries if {@code sql} affects the data of a table.
+   *
+   * @see SQLiteDatabase#execSQL(String)
+   */
+  public void execute(String sql) {
+    SQLiteDatabase db = getWriteableDatabase();
+    db.execSQL(sql);
+  }
+
+  /**
+   * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
+   * returns data. No data can be returned (such as the number of affected rows). Instead, use
+   * {@link #insert}, {@link #update}, et al, when possible.
+   * <p>
+   * No notifications will be sent to queries if {@code sql} affects the data of a table.
+   *
+   * @see SQLiteDatabase#execSQL(String, Object[])
+   */
+  public void execute(String sql, Object... args) {
+    SQLiteDatabase db = getWriteableDatabase();
+    db.execSQL(sql, args);
+  }
+
+  /**
+   * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
+   * returns data. No data can be returned (such as the number of affected rows). Instead, use
+   * {@link #insert}, {@link #update}, et al, when possible.
+   * <p>
+   * A notification to queries for {@code table} will be sent after the statement is executed.
+   *
+   * @see SQLiteDatabase#execSQL(String)
+   */
+  public void executeAndTrigger(String table, String sql) {
+    SQLiteDatabase db = getWriteableDatabase();
+    db.execSQL(sql);
+
+    sendTableTrigger(Collections.singleton(table));
+  }
+
+  /**
+   * Execute {@code sql} provided it is NOT a {@code SELECT} or any other SQL statement that
+   * returns data. No data can be returned (such as the number of affected rows). Instead, use
+   * {@link #insert}, {@link #update}, et al, when possible.
+   * <p>
+   * A notification to queries for {@code table} will be sent after the statement is executed.
+   *
+   * @see SQLiteDatabase#execSQL(String, Object[])
+   */
+  public void executeAndTrigger(String table, String sql, Object... args) {
+    SQLiteDatabase db = getWriteableDatabase();
+    db.execSQL(sql, args);
+
+    sendTableTrigger(Collections.singleton(table));
+  }
+
+  /** An in-progress database transaction. */
+  public interface Transaction extends Closeable {
+    /**
+     * End a transaction. See {@link #newTransaction()} for notes about how to use this and when
+     * transactions are committed and rolled back.
+     *
+     * @see SQLiteDatabase#endTransaction()
+     */
+    // TODO @WorkerThread
+    void end();
+
+    /**
+     * Marks the current transaction as successful. Do not do any more database work between
+     * calling this and calling {@link #end()}. Do as little non-database work as possible in that
+     * situation too. If any errors are encountered between this and {@link #end()} the transaction
+     * will still be committed.
+     *
+     * @see SQLiteDatabase#setTransactionSuccessful()
+     */
+    // TODO @WorkerThread
+    void markSuccessful();
+
+    /**
+     * Temporarily end the transaction to let other threads run. The transaction is assumed to be
+     * successful so far. Do not call {@link #markSuccessful()} before calling this. When this
+     * returns a new transaction will have been created but not marked as successful. This assumes
+     * that there are no nested transactions (newTransaction has only been called once) and will
+     * throw an exception if that is not the case.
+     *
+     * @return true if the transaction was yielded
+     *
+     * @see SQLiteDatabase#yieldIfContendedSafely()
+     */
+    // TODO @WorkerThread
+    boolean yieldIfContendedSafely();
+
+    /**
+     * Temporarily end the transaction to let other threads run. The transaction is assumed to be
+     * successful so far. Do not call {@link #markSuccessful()} before calling this. When this
+     * returns a new transaction will have been created but not marked as successful. This assumes
+     * that there are no nested transactions (newTransaction has only been called once) and will
+     * throw an exception if that is not the case.
+     *
+     * @param sleepAmount if > 0, sleep this long before starting a new transaction if
+     *   the lock was actually yielded. This will allow other background threads to make some
+     *   more progress than they would if we started the transaction immediately.
+     * @return true if the transaction was yielded
+     *
+     * @see SQLiteDatabase#yieldIfContendedSafely(long)
+     */
+    // TODO @WorkerThread
+    boolean yieldIfContendedSafely(long sleepAmount, TimeUnit sleepUnit);
+
+    /**
+     * Equivalent to calling {@link #end()}
+     */
+    // TODO @WorkerThread
+    @Override void close();
+  }
+
+  @IntDef({
+      CONFLICT_ABORT,
+      CONFLICT_FAIL,
+      CONFLICT_IGNORE,
+      CONFLICT_NONE,
+      CONFLICT_REPLACE,
+      CONFLICT_ROLLBACK
+  })
+  @Retention(SOURCE)
+  public @interface ConflictAlgorithm {
+  }
+
+  void log(String message, Object... args) {
+    if (args.length > 0) message = String.format(message, args);
+    logger.log(message);
+  }
+
+  private static String conflictString(@ConflictAlgorithm int conflictAlgorithm) {
+    switch (conflictAlgorithm) {
+      case CONFLICT_ABORT:
+        return "abort";
+      case CONFLICT_FAIL:
+        return "fail";
+      case CONFLICT_IGNORE:
+        return "ignore";
+      case CONFLICT_NONE:
+        return "none";
+      case CONFLICT_REPLACE:
+        return "replace";
+      case CONFLICT_ROLLBACK:
+        return "rollback";
+      default:
+        return "unknown (" + conflictAlgorithm + ')';
+    }
+  }
+
+  static final class SqliteTransaction extends LinkedHashSet<String>
+      implements SQLiteTransactionListener {
+    final SqliteTransaction parent;
+    boolean commit;
+
+    SqliteTransaction(SqliteTransaction parent) {
+      this.parent = parent;
+    }
+
+    @Override public void onBegin() {
+    }
+
+    @Override public void onCommit() {
+      commit = true;
+    }
+
+    @Override public void onRollback() {
+    }
+
+    @Override public String toString() {
+      String name = String.format("%08x", System.identityHashCode(this));
+      return parent == null ? name : name + " [" + parent.toString() + ']';
+    }
+  }
+}
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java
new file mode 100644
index 0000000..cca3b21
--- /dev/null
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java
@@ -0,0 +1,97 @@
+package com.squareup.sqlbrite;
+
+import android.database.Cursor;
+import android.support.annotation.CheckResult;
+import android.support.annotation.NonNull;
+import com.squareup.sqlbrite.SqlBrite.Query;
+import java.util.List;
+import rx.Observable;
+import rx.Subscriber;
+import rx.functions.Func1;
+
+/** An {@link Observable} of {@link Query} which offers query-specific convenience operators. */
+public final class QueryObservable extends Observable<Query> {
+  QueryObservable(final Observable<Query> o) {
+    super(new OnSubscribe<Query>() {
+      @Override public void call(Subscriber<? super Query> subscriber) {
+        o.unsafeSubscribe(subscriber);
+      }
+    });
+  }
+
+  /**
+   * Given a function mapping the current row of a {@link Cursor} to {@code T}, transform each
+   * emitted {@link Query} which returns a single row to {@code T}.
+   * <p>
+   * It is an error for a query to pass through this operator with more than 1 row in its result
+   * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
+   * do not emit an item.
+   * <p>
+   * This method is equivalent to:
+   * <pre>{@code
+   * flatMap(q -> q.asRows(mapper).take(1))
+   * }</pre>
+   * and a convenience operator for:
+   * <pre>{@code
+   * lift(Query.mapToOne(mapper))
+   * }</pre>
+   *
+   * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
+   */
+  @CheckResult @NonNull
+  public final <T> Observable<T> mapToOne(@NonNull Func1<Cursor, T> mapper) {
+    return lift(Query.mapToOne(mapper));
+  }
+
+  /**
+   * Given a function mapping the current row of a {@link Cursor} to {@code T}, transform each
+   * emitted {@link Query} which returns a single row to {@code T}.
+   * <p>
+   * It is an error for a query to pass through this operator with more than 1 row in its result
+   * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
+   * emit {@code defaultValue}.
+   * <p>
+   * This method is equivalent to:
+   * <pre>{@code
+   * flatMap(q -> q.asRows(mapper).take(1).defaultIfEmpty(defaultValue))
+   * }</pre>
+   * and a convenience operator for:
+   * <pre>{@code
+   * lift(Query.mapToOneOrDefault(mapper, defaultValue))
+   * }</pre>
+   *
+   * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
+   * @param defaultValue Value returned if result set is empty
+   */
+  @CheckResult @NonNull
+  public final <T> Observable<T> mapToOneOrDefault(@NonNull Func1<Cursor, T> mapper,
+      T defaultValue) {
+    return lift(Query.mapToOneOrDefault(mapper, defaultValue));
+  }
+
+  /**
+   * Given a function mapping the current row of a {@link Cursor} to {@code T}, transform each
+   * emitted {@link Query} to a {@code List<T>}.
+   * <p>
+   * Be careful using this operator as it will always consume the entire cursor and create objects
+   * for each row, every time this observable emits a new query. On tables whose queries update
+   * frequently or very large result sets this can result in the creation of many objects.
+   * <p>
+   * This method is equivalent to:
+   * <pre>{@code
+   * flatMap(q -> q.asRows(mapper).toList())
+   * }</pre>
+   * and a convenience operator for:
+   * <pre>{@code
+   * lift(Query.mapToList(mapper))
+   * }</pre>
+   * <p>
+   * Consider using {@link Query#asRows} if you need to limit or filter in memory.
+   *
+   * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
+   */
+  @CheckResult @NonNull
+  public final <T> Observable<List<T>> mapToList(@NonNull Func1<Cursor, T> mapper) {
+    return lift(Query.mapToList(mapper));
+  }
+}
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
new file mode 100644
index 0000000..802ac69
--- /dev/null
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
@@ -0,0 +1,55 @@
+package com.squareup.sqlbrite;
+
+import android.database.Cursor;
+import java.util.ArrayList;
+import java.util.List;
+import rx.Observable;
+import rx.Subscriber;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnErrorThrowable;
+import rx.functions.Func1;
+
+final class QueryToListOperator<T> implements Observable.Operator<List<T>, SqlBrite.Query> {
+  final Func1<Cursor, T> mapper;
+
+  QueryToListOperator(Func1<Cursor, T> mapper) {
+    this.mapper = mapper;
+  }
+
+  @Override
+  public Subscriber<? super SqlBrite.Query> call(final Subscriber<? super List<T>> subscriber) {
+    return new Subscriber<SqlBrite.Query>(subscriber) {
+      @Override public void onNext(SqlBrite.Query query) {
+        try {
+          Cursor cursor = query.run();
+          List<T> items = new ArrayList<>(cursor.getCount());
+          try {
+            for (int i = 1; cursor.moveToNext() && !subscriber.isUnsubscribed(); i++) {
+              T item = mapper.call(cursor);
+              if (item == null) {
+                throw new NullPointerException("Mapper returned null for row " + i);
+              }
+              items.add(item);
+            }
+          } finally {
+            cursor.close();
+          }
+          if (!subscriber.isUnsubscribed()) {
+            subscriber.onNext(items);
+          }
+        } catch (Throwable e) {
+          Exceptions.throwIfFatal(e);
+          onError(OnErrorThrowable.addValueAsLastCause(e, query.toString()));
+        }
+      }
+
+      @Override public void onCompleted() {
+        subscriber.onCompleted();
+      }
+
+      @Override public void onError(Throwable e) {
+        subscriber.onError(e);
+      }
+    };
+  }
+}
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
new file mode 100644
index 0000000..fcc90e1
--- /dev/null
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
@@ -0,0 +1,62 @@
+package com.squareup.sqlbrite;
+
+import android.database.Cursor;
+import rx.Observable;
+import rx.Subscriber;
+import rx.exceptions.Exceptions;
+import rx.exceptions.OnErrorThrowable;
+import rx.functions.Func1;
+
+final class QueryToOneOperator<T> implements Observable.Operator<T, SqlBrite.Query> {
+  final Func1<Cursor, T> mapper;
+  boolean emitDefault;
+  T defaultValue;
+
+  QueryToOneOperator(Func1<Cursor, T> mapper, boolean emitDefault, T defaultValue) {
+    this.mapper = mapper;
+    this.emitDefault = emitDefault;
+    this.defaultValue = defaultValue;
+  }
+
+  @Override public Subscriber<? super SqlBrite.Query> call(final Subscriber<? super T> subscriber) {
+    return new Subscriber<SqlBrite.Query>(subscriber) {
+      @Override public void onNext(SqlBrite.Query query) {
+        try {
+          T item = null;
+          Cursor cursor = query.run();
+          try {
+            if (cursor.moveToNext()) {
+              item = mapper.call(cursor);
+              if (item == null) {
+                throw new NullPointerException("Mapper returned null for row 1");
+              }
+              if (cursor.moveToNext()) {
+                throw new IllegalStateException("Cursor returned more than 1 row");
+              }
+            }
+          } finally {
+            cursor.close();
+          }
+          if (!subscriber.isUnsubscribed()) {
+            if (item != null) {
+              subscriber.onNext(item);
+            } else if (emitDefault) {
+              subscriber.onNext(defaultValue);
+            }
+          }
+        } catch (Throwable e) {
+          Exceptions.throwIfFatal(e);
+          onError(OnErrorThrowable.addValueAsLastCause(e, query.toString()));
+        }
+      }
+
+      @Override public void onCompleted() {
+        subscriber.onCompleted();
+      }
+
+      @Override public void onError(Throwable e) {
+        subscriber.onError(e);
+      }
+    };
+  }
+}
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
index 3ec76bc..c616327 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
@@ -15,509 +15,158 @@
  */
 package com.squareup.sqlbrite;
 
-import android.content.ContentValues;
+import android.content.ContentResolver;
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
-import android.database.sqlite.SQLiteTransactionListener;
-import android.support.annotation.IntDef;
+import android.support.annotation.CheckResult;
 import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.util.Log;
-import java.io.Closeable;
-import java.io.IOException;
-import java.lang.annotation.Retention;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
+import java.util.List;
 import rx.Observable;
+import rx.Observable.Operator;
+import rx.Subscriber;
 import rx.functions.Func1;
-import rx.subjects.PublishSubject;
-
-import static android.database.sqlite.SQLiteDatabase.CONFLICT_ABORT;
-import static android.database.sqlite.SQLiteDatabase.CONFLICT_FAIL;
-import static android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE;
-import static android.database.sqlite.SQLiteDatabase.CONFLICT_NONE;
-import static android.database.sqlite.SQLiteDatabase.CONFLICT_REPLACE;
-import static android.database.sqlite.SQLiteDatabase.CONFLICT_ROLLBACK;
-import static java.lang.annotation.RetentionPolicy.SOURCE;
 
 /**
  * A lightweight wrapper around {@link SQLiteOpenHelper} which allows for continuously observing
  * the result of a query.
- * <p>
- * While not strictly required, instances of this class assume that they will be the only ones
- * interacting with the underlying {@link SQLiteOpenHelper} and it is required for automatic
- * notifications of table changes to work. See {@linkplain #createQuery the <code>query</code>
- * method} for more information on that behavior.
  */
-public final class SqlBrite implements Closeable {
-  private static final Set<String> INITIAL_TRIGGER = Collections.singleton("<initial>");
-
-  /** Create an instance around the specified {@code helper} using appropriate defaults. */
-  public static SqlBrite create(@NonNull SQLiteOpenHelper helper) {
-    return new SqlBrite(helper);
-  }
-
-  /** An executable query. */
-  public interface Query {
-    /** Execute the query on the underlying database and return the resulting cursor. */
-    Cursor run();
-  }
-
-  /** A simple indirection for logging debug messages. */
-  public interface Logger {
-    void log(String message);
-  }
-
-  private final SQLiteOpenHelper helper;
-  private final ThreadLocal<Transaction> transactions = new ThreadLocal<>();
-  /** Publishes sets of tables which have changed. */
-  private final PublishSubject<Set<String>> triggers = PublishSubject.create();
-
-  // Read and write guarded by 'databaseLock'. Lazily initialized. Use methods to access.
-  private volatile SQLiteDatabase readableDatabase;
-  private volatile SQLiteDatabase writeableDatabase;
-  private final Object databaseLock = new Object();
-
-  // Not volatile because we don't care if threads don't immediately see changes to this value.
-  private boolean logging;
-  private volatile Logger logger;
-
-  private SqlBrite(SQLiteOpenHelper helper) {
-    this.helper = helper;
-  }
-
-  /**
-   * Control whether debug logging is enabled.
-   * <p>
-   * By default this method will log verbose message to {@linkplain Log Android's log}. Use a
-   * custom logger by calling {@link #setLogger}.
-   */
-  public void setLoggingEnabled(boolean enabled) {
-    if (enabled && logger == null) {
-      logger = new Logger() {
-        @Override public void log(String message) {
-          Log.v("SqlBrite", message);
-        }
-      };
-    }
-    logging = enabled;
-  }
-
-  /**
-   * Specify a custom logger for debug messages when {@linkplain #setLoggingEnabled(boolean)
-   * logging is enabled}.
-   */
-  public void setLogger(Logger logger) {
-    if (logger == null) throw new NullPointerException("logger == null");
-    this.logger = logger;
-  }
-
-  private SQLiteDatabase getReadableDatabase() {
-    SQLiteDatabase db = readableDatabase;
-    if (db == null) {
-      synchronized (databaseLock) {
-        db = readableDatabase;
-        if (db == null) {
-          if (logging) log("Creating readable database");
-          db = readableDatabase = helper.getReadableDatabase();
-        }
+public final class SqlBrite {
+  @CheckResult @NonNull
+  public static SqlBrite create() {
+    return create(new Logger() {
+      @Override public void log(String message) {
+        Log.d("SqlBrite", message);
       }
-    }
-    return db;
+    });
   }
 
-  private SQLiteDatabase getWriteableDatabase() {
-    SQLiteDatabase db = writeableDatabase;
-    if (db == null) {
-      synchronized (databaseLock) {
-        db = writeableDatabase;
-        if (db == null) {
-          if (logging) log("Creating writeable database");
-          db = writeableDatabase = helper.getWritableDatabase();
-        }
-      }
-    }
-    return db;
+  @CheckResult @NonNull
+  public static SqlBrite create(@NonNull Logger logger) {
+    return new SqlBrite(logger);
   }
 
-  private void sendTableTrigger(Set<String> tables) {
-    Transaction transaction = transactions.get();
-    if (transaction != null) {
-      transaction.triggers.addAll(tables);
-    } else {
-      if (logging) log("TRIGGER %s", tables);
-      triggers.onNext(tables);
-    }
-  }
+  private final Logger logger;
 
-  /**
-   * Begin a transaction for this thread.
-   * <p>
-   * Transactions may nest. If the transaction is not in progress, then a database connection is
-   * obtained and a new transaction is started. Otherwise, a nested transaction is started.
-   * <p>
-   * Each call to {@code beginTransaction} must be matched exactly by a call to
-   * {@link #endTransaction}. To mark a transaction as successful, call
-   * {@link #setTransactionSuccessful} before calling {@link #endTransaction}. If the transaction
-   * is not successful, or if any of its nested transactions were not successful, then the entire
-   * transaction will be rolled back when the outermost transaction is ended.
-   * <p>
-   * Transactions queue up all query notifications until they have been applied.
-   * <p>
-   * Here is the standard idiom for transactions:
-   *
-   * <pre>{@code
-   * db.beginTransaction();
-   * try {
-   *   ...
-   *   db.setTransactionSuccessful();
-   * } finally {
-   *   db.endTransaction();
-   * }
-   * }</pre>
-   *
-   * @see SQLiteDatabase#beginTransaction()
-   */
-  public void beginTransaction() {
-    Transaction transaction = new Transaction(transactions.get());
-    transactions.set(transaction);
-    if (logging) log("TXN BEGIN %s", transaction);
-    getWriteableDatabase().beginTransactionWithListener(transaction);
-  }
-
-  /**
-   * Marks the current transaction as successful. Do not do any more database work between
-   * calling this and calling {@link #endTransaction()}. Do as little non-database work as possible
-   * in that situation too. If any errors are encountered between this and
-   * {@link #endTransaction()} the transaction will still be committed.
-   *
-   * @see SQLiteDatabase#setTransactionSuccessful()
-   */
-  public void setTransactionSuccessful() {
-    if (logging) log("TXN SUCCESS %s", transactions.get());
-    getWriteableDatabase().setTransactionSuccessful();
-  }
-
-  /**
-   * End a transaction. See {@link #beginTransaction()} for notes about how to use this and when
-   * transactions are committed and rolled back.
-   *
-   * @see SQLiteDatabase#endTransaction()
-   */
-  public void endTransaction() {
-    Transaction transaction = transactions.get();
-    if (transaction == null) {
-      throw new IllegalStateException("Not in transaction.");
-    }
-    Transaction newTransaction = transaction.parent;
-    transactions.set(newTransaction);
-    if (logging) log("TXN END %s", transaction);
-    getWriteableDatabase().endTransaction();
-  }
-
-  /**
-   * Close the underlying {@link SQLiteOpenHelper} and remove cached readable and writeable
-   * databases. This does not prevent existing observables from retaining existing references as
-   * well as attempting to create new ones for new subscriptions.
-   */
-  @Override public void close() throws IOException {
-    synchronized (databaseLock) {
-      readableDatabase = null;
-      writeableDatabase = null;
-      helper.close();
-    }
+  private SqlBrite(@NonNull Logger logger) {
+    this.logger = logger;
   }
 
   /**
-   * Create an observable which will notify subscribers with a {@linkplain Query query} for
-   * execution. Subscribers are responsible for <b>always</b> closing {@link Cursor} instance
-   * returned from the {@link Query}.
+   * Wrap a {@link SQLiteOpenHelper} for observable queries.
    * <p>
-   * Subscribers will receive an immediate notification for initial data as well as subsequent
-   * notifications for when the supplied {@code table}'s data changes through the {@code insert},
-   * {@code update}, and {@code delete} methods of this class. Unsubscribe when you no longer want
-   * updates to a query.
-   * <p>
-   * <b>Warning:</b> this method does not perform the query! Only by subscribing to the returned
-   * {@link Observable} will the operation occur.
-   *
-   * @see SQLiteDatabase#rawQuery(String, String[])
+   * While not strictly required, instances of this class assume that they will be the only ones
+   * interacting with the underlying {@link SQLiteOpenHelper} and it is required for automatic
+   * notifications of table changes to work. See {@linkplain BriteDatabase#createQuery the
+   * <code>query</code> method} for more information on that behavior.
    */
-  public Observable<Query> createQuery(@NonNull final String table, @NonNull String sql,
-      @NonNull String... args) {
-    Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
-      @Override public Boolean call(Set<String> triggers) {
-        return triggers.contains(table);
-      }
-
-      @Override public String toString() {
-        return table;
-      }
-    };
-    return createQuery(tableFilter, sql, args);
+  @CheckResult @NonNull
+  public BriteDatabase wrapDatabaseHelper(@NonNull SQLiteOpenHelper helper) {
+    return new BriteDatabase(helper, logger);
   }
 
-  /**
-   * See {@link #createQuery(String, String, String...)} for usage. This overload allows for
-   * monitoring multiple tables for changes.
-   *
-   * @see SQLiteDatabase#rawQuery(String, String[])
-   */
-  public Observable<Query> createQuery(@NonNull final Iterable<String> tables, @NonNull String sql,
-      @NonNull String... args) {
-    Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
-      @Override public Boolean call(Set<String> triggers) {
-        for (String table : tables) {
-          if (triggers.contains(table)) {
-            return true;
-          }
-        }
-        return false;
-      }
-
-      @Override public String toString() {
-        return tables.toString();
-      }
-    };
-    return createQuery(tableFilter, sql, args);
+  /** Wrap a {@link ContentResolver} for observable queries. */
+  @CheckResult @NonNull
+  public BriteContentResolver wrapContentProvider(@NonNull ContentResolver contentResolver) {
+    return new BriteContentResolver(contentResolver, logger);
   }
 
-  private Observable<Query> createQuery(final Func1<Set<String>, Boolean> tableFilter,
-      final String sql, final String... args) {
-    if (transactions.get() != null) {
-      throw new IllegalStateException("Cannot create observable query in transaction. "
-          + "Use query() for a query inside a transaction.");
+  /** An executable query. */
+  public static abstract class Query {
+    /**
+     * Creates an {@linkplain Operator observable operator} which transforms a query returning a
+     * single row to {@code T} using {@code mapper}.
+     * <p>
+     * It is an error for a query to pass through this operator with more than 1 row in its result
+     * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
+     * do not emit an item.
+     *
+     * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
+     */
+    @CheckResult @NonNull
+    public static <T> Operator<T, Query> mapToOne(@NonNull Func1<Cursor, T> mapper) {
+      return new QueryToOneOperator<>(mapper, false, null);
+    }
+
+    /**
+     * Creates an {@linkplain Operator observable operator} which transforms a query returning a
+     * single row to {@code T} using {@code mapper}.
+     * <p>
+     * It is an error for a query to pass through this operator with more than 1 row in its result
+     * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
+     * emit {@code defaultValue}.
+     *
+     * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
+     * @param defaultValue Value returned if result set is empty
+     */
+    @CheckResult @NonNull
+    public static <T> Operator<T, Query> mapToOneOrDefault(@NonNull Func1<Cursor, T> mapper,
+        T defaultValue) {
+      return new QueryToOneOperator<>(mapper, true, defaultValue);
+    }
+
+    /**
+     * Creates an {@linkplain Operator observable operator} which transforms a query to a
+     * {@code List<T>} using {@code mapper}.
+     * <p>
+     * Be careful using this operator as it will always consume the entire cursor and create objects
+     * for each row, every time this observable emits a new query. On tables whose queries update
+     * frequently or very large result sets this can result in the creation of many objects.
+     *
+     * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
+     */
+    @CheckResult @NonNull
+    public static <T> Operator<List<T>, Query> mapToList(@NonNull Func1<Cursor, T> mapper) {
+      return new QueryToListOperator<>(mapper);
     }
 
-    final Query query = new Query() {
-      @Override public Cursor run() {
-        if (transactions.get() != null) {
-          throw new IllegalStateException("Cannot execute observable query in a transaction.");
-        }
-        return getReadableDatabase().rawQuery(sql, args);
-      }
-
-      @Override public String toString() {
-        return sql;
-      }
-    };
-
-    return triggers //
-        .filter(tableFilter) // Only trigger on tables we care about.
-        .startWith(INITIAL_TRIGGER) // Immediately execute the query for initial value.
-        .map(new Func1<Set<String>, Query>() {
-          @Override public Query call(Set<String> trigger) {
-            if (transactions.get() != null) {
-              throw new IllegalStateException(
-                  "Cannot subscribe to observable query in a transaction.");
-            }
-            if (logging) {
-              log("QUERY\n  trigger: %s\n  tables: %s\n  sql: %s\n  args: %s", trigger, tableFilter,
-                  sql, Arrays.toString(args));
+    /** Execute the query on the underlying database and return the resulting cursor. */
+    @CheckResult // TODO @WorkerThread
+    // TODO Implementations might return null, which is gross. Throw?
+    public abstract Cursor run();
+
+    /**
+     * Execute the query on the underlying database and return an Observable of each row mapped to
+     * {@code T} by {@code mapper}.
+     * <p>
+     * Standard usage of this operation is in {@code flatMap}:
+     * <pre>{@code
+     * flatMap(q -> q.asRows(Item.MAPPER).toList())
+     * }</pre>
+     * However, the above is a more-verbose but identical operation as
+     * {@link QueryObservable#mapToList}. This {@code asRows} method should be used when you need
+     * to limit or filter the items separate from the actual query.
+     * <pre>{@code
+     * flatMap(q -> q.asRows(Item.MAPPER).take(5).toList())
+     * // or...
+     * flatMap(q -> q.asRows(Item.MAPPER).filter(i -> i.isActive).toList())
+     * }</pre>
+     * <p>
+     * Note: Limiting results or filtering will almost always be faster in the database as part of
+     * a query and should be preferred, where possible.
+     */
+    @CheckResult @NonNull
+    public final <T> Observable<T> asRows(final Func1<Cursor, T> mapper) {
+      return Observable.create(new Observable.OnSubscribe<T>() {
+        @Override public void call(Subscriber<? super T> subscriber) {
+          Cursor cursor = run();
+          try {
+            while (cursor.moveToNext() && !subscriber.isUnsubscribed()) {
+              subscriber.onNext(mapper.call(cursor));
             }
-            return query;
+          } finally {
+            cursor.close();
           }
-        });
-  }
-
-  /**
-   * Runs the provided SQL and returns a {@link Cursor} over the result set.
-   *
-   * @see SQLiteDatabase#rawQuery(String, String[])
-   */
-  public Cursor query(@NonNull String sql, @NonNull String... args) {
-    if (logging) log("QUERY\n  sql: %s\n  args: %s", sql, Arrays.toString(args));
-    return getReadableDatabase().rawQuery(sql, args);
-  }
-
-  /**
-   * Insert a row into the specified {@code table} and notify any subscribed queries.
-   *
-   * @see SQLiteDatabase#insert(String, String, ContentValues)
-   */
-  public long insert(@NonNull String table, @NonNull ContentValues values) {
-    return insert(table, values, CONFLICT_NONE);
-  }
-
-  /**
-   * Insert a row into the specified {@code table} and notify any subscribed queries.
-   *
-   * @see SQLiteDatabase#insertWithOnConflict(String, String, ContentValues, int)
-   */
-  public long insert(@NonNull String table, @NonNull ContentValues values,
-      @ConflictAlgorithm int conflictAlgorithm) {
-    SQLiteDatabase db = getWriteableDatabase();
-
-    if (logging) {
-      log("INSERT\n  table: %s\n  values: %s\n  conflictAlgorithm: %s", table, values,
-          conflictString(conflictAlgorithm));
-    }
-    long rowId = db.insertWithOnConflict(table, null, values, conflictAlgorithm);
-
-    if (logging) log("INSERT id: %s", rowId);
-
-    if (rowId != -1) {
-      // Only send a table trigger if the insert was successful.
-      sendTableTrigger(Collections.singleton(table));
-    }
-    return rowId;
-  }
-
-  /**
-   * Delete rows from the specified {@code table} and notify any subscribed queries. This method
-   * will not trigger a notification if no rows were deleted.
-   *
-   * @see SQLiteDatabase#delete(String, String, String[])
-   */
-  public int delete(@NonNull String table, @Nullable String whereClause,
-      @Nullable String... whereArgs) {
-    SQLiteDatabase db = getWriteableDatabase();
-
-    if (logging) {
-      log("DELETE\n  table: %s\n  whereClause: %s\n  whereArgs: %s", table, whereClause,
-          Arrays.toString(whereArgs));
-    }
-    int rows = db.delete(table, whereClause, whereArgs);
-
-    if (logging) log("DELETE affected %s %s", rows, rows != 1 ? "rows" : "row");
-
-    if (rows > 0) {
-      // Only send a table trigger if rows were affected.
-      sendTableTrigger(Collections.singleton(table));
-    }
-    return rows;
-  }
-
-  /**
-   * Update rows in the specified {@code table} and notify any subscribed queries. This method
-   * will not trigger a notification if no rows were updated.
-   *
-   * @see SQLiteDatabase#update(String, ContentValues, String, String[])
-   */
-  public int update(@NonNull String table, @NonNull ContentValues values,
-      @Nullable String whereClause, @Nullable String... whereArgs) {
-    return update(table, values, CONFLICT_NONE, whereClause, whereArgs);
-  }
-
-  /**
-   * Update rows in the specified {@code table} and notify any subscribed queries. This method
-   * will not trigger a notification if no rows were updated.
-   *
-   * @see SQLiteDatabase#updateWithOnConflict(String, ContentValues, String, String[], int)
-   */
-  public int update(@NonNull String table, @NonNull ContentValues values,
-      @ConflictAlgorithm int conflictAlgorithm, @Nullable String whereClause,
-      @Nullable String... whereArgs) {
-    SQLiteDatabase db = getWriteableDatabase();
-
-    if (logging) {
-      log("UPDATE\n  table: %s\n  values: %s\n  whereClause: %s\n  whereArgs: %s\n  conflictAlgorithm: %s",
-          table, values, whereClause, Arrays.toString(whereArgs),
-          conflictString(conflictAlgorithm));
-    }
-    int rows = db.updateWithOnConflict(table, values, whereClause, whereArgs, conflictAlgorithm);
-
-    if (logging) log("UPDATE affected %s %s", rows, rows != 1 ? "rows" : "row");
-
-    if (rows > 0) {
-      // Only send a table trigger if rows were affected.
-      sendTableTrigger(Collections.singleton(table));
-    }
-    return rows;
-  }
-
-  /**
-   * Temporarily end the transaction to let other threads run. The transaction is assumed to be
-   * successful so far. Do not call setTransactionSuccessful before calling this. When this
-   * returns a new transaction will have been created but not marked as successful. This assumes
-   * that there are no nested transactions (beginTransaction has only been called once) and will
-   * throw an exception if that is not the case.
-   * @return true if the transaction was yielded
-   *
-   * @see SQLiteDatabase#yieldIfContendedSafely()
-   */
-  public boolean yieldIfContendedSafely() {
-    return getWriteableDatabase().yieldIfContendedSafely();
-  }
-
-  /**
-   * Temporarily end the transaction to let other threads run. The transaction is assumed to be
-   * successful so far. Do not call setTransactionSuccessful before calling this. When this
-   * returns a new transaction will have been created but not marked as successful. This assumes
-   * that there are no nested transactions (beginTransaction has only been called once) and will
-   * throw an exception if that is not the case.
-   * @param sleepAmount if > 0, sleep this long before starting a new transaction if
-   *   the lock was actually yielded. This will allow other background threads to make some
-   *   more progress than they would if we started the transaction immediately.
-   * @return true if the transaction was yielded
-   *
-   * @see SQLiteDatabase#yieldIfContendedSafely(long)
-   */
-  public boolean yieldIfContendedSafely(long sleepAmount, TimeUnit sleepUnit) {
-    return getWriteableDatabase().yieldIfContendedSafely(sleepUnit.toMillis(sleepAmount));
-  }
-
-  @IntDef({
-      CONFLICT_ABORT,
-      CONFLICT_FAIL,
-      CONFLICT_IGNORE,
-      CONFLICT_NONE,
-      CONFLICT_REPLACE,
-      CONFLICT_ROLLBACK
-  })
-  @Retention(SOURCE)
-  public @interface ConflictAlgorithm {
-  }
-
-  private void log(String message, Object... args) {
-    if (args.length > 0) message = String.format(message, args);
-    logger.log(message);
-  }
-
-  private static String conflictString(@ConflictAlgorithm int conflictAlgorithm) {
-    switch (conflictAlgorithm) {
-      case CONFLICT_ABORT:
-        return "abort";
-      case CONFLICT_FAIL:
-        return "fail";
-      case CONFLICT_IGNORE:
-        return "ignore";
-      case CONFLICT_NONE:
-        return "none";
-      case CONFLICT_REPLACE:
-        return "replace";
-      case CONFLICT_ROLLBACK:
-        return "rollback";
-      default:
-        return "unknown (" + conflictAlgorithm + ')';
+          if (!subscriber.isUnsubscribed()) {
+            subscriber.onCompleted();
+          }
+        }
+      });
     }
   }
 
-  private final class Transaction implements SQLiteTransactionListener {
-    final Transaction parent;
-    final Set<String> triggers = new LinkedHashSet<>();
-
-    Transaction(Transaction parent) {
-      this.parent = parent;
-    }
-
-    @Override public void onBegin() {
-    }
-
-    @Override public void onCommit() {
-      sendTableTrigger(triggers);
-    }
-
-    @Override public void onRollback() {
-    }
-
-    @Override public String toString() {
-      String name = String.format("%08x", System.identityHashCode(this));
-      return parent == null ? name : name + " [" + parent.toString() + ']';
-    }
+  /** A simple indirection for logging debug messages. */
+  public interface Logger {
+    void log(String message);
   }
 }
