diff --git a/CHANGELOG.md b/CHANGELOG.md
index 878d8e0..465866d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,29 @@
 Change Log
 =========
 
+Version 0.6.3 *(2016-04-13)*
+----------------------------
+
+ * `QueryObservable` constructor is now public allow instances to be created for tests.
+
+
+Version 0.6.2 *(2016-03-01)*
+----------------------------
+
+ * Fix: Document explicitly and correctly handle the fact that `Query.run()` can return `null` in
+   some situations. The `mapToOne`, `mapToOneOrDefault`, `mapToList`, and `asRows` helpers have all
+   been updated to handle this case and each is documented with their respective behavior.
+
+
+Version 0.6.1 *(2016-02-29)*
+----------------------------
+
+ * Fix: Apply backpressure strategy between database/content provider and the supplied `Scheduler`.
+   This guards against backpressure exceptions when the scheduler is unable to keep up with the rate
+   at which queries are being triggered.
+ * Fix: Indent the subsequent lines of a multi-line queries when logging.
+
+
 Version 0.6.0 *(2016-02-17)*
 ----------------------------
 
diff --git a/README.md b/README.md
index 17eb4a5..b317c0c 100755
--- a/README.md
+++ b/README.md
@@ -128,7 +128,7 @@ The `SqlBrite` object can also wrap a `ContentResolver` for observing a query on
 content provider.
 
 ```java
-BriteContentResolver resolver = sqlBrite.wrapContentProvider(contentResolver);
+BriteContentResolver resolver = sqlBrite.wrapContentProvider(contentResolver, Schedulers.io());
 Observable<Query> query = resolver.createQuery(/*...*/);
 ```
 
@@ -154,7 +154,7 @@ Download
 --------
 
 ```groovy
-compile 'com.squareup.sqlbrite:sqlbrite:0.6.0'
+compile 'com.squareup.sqlbrite:sqlbrite:0.6.3'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/build.gradle b/build.gradle
index 5087650..68a9f50 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,4 +1,4 @@
-subprojects {
+allprojects {
   buildscript {
     dependencies {
       classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3' // Add this line
@@ -30,8 +30,8 @@ ext {
   // Third-party dependencies.
   butterKnife = 'com.jakewharton:butterknife:6.1.0'
   timber = 'com.jakewharton.timber:timber:2.7.1'
-  autoParcel = 'com.github.frankiesardo:auto-parcel:0.3'
-  autoParcelProcessor = 'com.github.frankiesardo:auto-parcel-processor:0.3'
+  autoValue = 'com.google.auto.value:auto-value:1.2-rc1'
+  autoValueParcel = 'com.ryanharter.auto.value:auto-value-parcel:0.2.0'
   rxJava = 'io.reactivex:rxjava:1.1.0'
   rxAndroid = 'io.reactivex:rxandroid:1.0.1'
   rxBinding = 'com.jakewharton.rxbinding:rxbinding:0.2.0'
@@ -39,3 +39,19 @@ ext {
   findbugsJsr305 = 'com.google.code.findbugs:jsr305:3.0.0'
   findbugsAnnotations = 'com.google.code.findbugs:annotations:3.0.0'
 }
+
+configurations {
+  osstrich
+}
+dependencies {
+  osstrich 'com.squareup.osstrich:osstrich:1.2.0'
+}
+task publishJavadoc(type: JavaExec) {
+  classpath = configurations.osstrich
+  main = 'com.squareup.osstrich.JavadocPublisher'
+  args = [
+      'build/javadoc',
+      'https://github.com/square/sqlbrite',
+      'com.squareup.sqlbrite'
+  ]
+}
diff --git a/gradle.properties b/gradle.properties
index 69bc461..2c0e7a7 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,5 +1,5 @@
 GROUP=com.squareup.sqlbrite
-VERSION_NAME=0.6.1-SNAPSHOT
+VERSION_NAME=0.6.4-SNAPSHOT
 
 POM_DESCRIPTION=A lightweight wrapper around SQLiteOpenHelper which introduces reactive stream semantics to SQL operations.
 
diff --git a/sample/build.gradle b/sample/build.gradle
index fca8bfa..9b319b6 100644
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -24,8 +24,10 @@ dependencies {
   compile rootProject.ext.rxJava
   compile rootProject.ext.rxAndroid
   compile rootProject.ext.rxBinding
-  compile rootProject.ext.autoParcel
-  apt rootProject.ext.autoParcelProcessor
+
+  provided rootProject.ext.autoValue
+  apt rootProject.ext.autoValue
+  apt rootProject.ext.autoValueParcel
 
   provided rootProject.ext.findbugsJsr305
   provided rootProject.ext.findbugsAnnotations
@@ -49,6 +51,8 @@ android {
 
   lintOptions {
     textOutput 'stdout'
+    textReport true
+    ignore 'InvalidPackage' // Provided AutoValue pulls in Guava and friends. Doesn't end up in APK.
   }
 
   dexOptions {
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java b/sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
index 77c6847..865328b 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
@@ -17,11 +17,12 @@
 
 import android.content.ContentValues;
 import android.database.Cursor;
-import auto.parcel.AutoParcel;
+import android.os.Parcelable;
+import com.google.auto.value.AutoValue;
 import rx.functions.Func1;
 
-@AutoParcel
-public abstract class TodoItem {
+@AutoValue
+public abstract class TodoItem implements Parcelable {
   public static final String TABLE = "todo_item";
 
   public static final String ID = "_id";
@@ -40,7 +41,7 @@
       long listId = Db.getLong(cursor, LIST_ID);
       String description = Db.getString(cursor, DESCRIPTION);
       boolean complete = Db.getBoolean(cursor, COMPLETE);
-      return new AutoParcel_TodoItem(id, listId, description, complete);
+      return new AutoValue_TodoItem(id, listId, description, complete);
     }
   };
 
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java b/sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java
index 0c890a6..12e3f91 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java
@@ -17,14 +17,15 @@
 
 import android.content.ContentValues;
 import android.database.Cursor;
-import auto.parcel.AutoParcel;
+import android.os.Parcelable;
+import com.google.auto.value.AutoValue;
 import java.util.ArrayList;
 import java.util.List;
 import rx.functions.Func1;
 
 // Note: normally I wouldn't prefix table classes but I didn't want 'List' to be overloaded.
-@AutoParcel
-public abstract class TodoList {
+@AutoValue
+public abstract class TodoList implements Parcelable {
   public static final String TABLE = "todo_list";
 
   public static final String ID = "_id";
@@ -44,7 +45,7 @@
           long id = Db.getLong(cursor, ID);
           String name = Db.getString(cursor, NAME);
           boolean archived = Db.getBoolean(cursor, ARCHIVED);
-          values.add(new AutoParcel_TodoList(id, name, archived));
+          values.add(new AutoValue_TodoList(id, name, archived));
         }
         return values;
       } finally {
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
index 51b2281..a865ccb 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
@@ -16,16 +16,17 @@
 package com.example.sqlbrite.todo.ui;
 
 import android.database.Cursor;
-import auto.parcel.AutoParcel;
+import android.os.Parcelable;
 import com.example.sqlbrite.todo.db.Db;
 import com.example.sqlbrite.todo.db.TodoItem;
 import com.example.sqlbrite.todo.db.TodoList;
+import com.google.auto.value.AutoValue;
 import java.util.Arrays;
 import java.util.Collection;
 import rx.functions.Func1;
 
-@AutoParcel
-abstract class ListsItem {
+@AutoValue
+abstract class ListsItem implements Parcelable {
   private static String ALIAS_LIST = "list";
   private static String ALIAS_ITEM = "item";
 
@@ -51,7 +52,7 @@
       long id = Db.getLong(cursor, TodoList.ID);
       String name = Db.getString(cursor, TodoList.NAME);
       int itemCount = Db.getInt(cursor, ITEM_COUNT);
-      return new AutoParcel_ListsItem(id, name, itemCount);
+      return new AutoValue_ListsItem(id, name, itemCount);
     }
   };
 }
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java
index 2c3ea2e..80d24ce 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java
@@ -27,6 +27,7 @@
 import java.util.List;
 import java.util.Map;
 import rx.Subscription;
+import rx.internal.util.RxRingBuffer;
 import rx.subscriptions.Subscriptions;
 
 import static com.google.common.truth.Truth.assertThat;
@@ -124,7 +125,7 @@ public void testUnsubscribeDoesNotTrigger() {
     assertThat(logs).isEmpty();
   }
 
-  public void testBackpressureSupported() {
+  public void testBackpressureSupportedWhenConsumerSlow() {
     contentResolver.insert(TABLE, values("key1", "val1"));
     o.doRequest(2);
 
@@ -170,6 +171,26 @@ public void testBackpressureSupported() {
     o.assertNoMoreEvents();
   }
 
+  public void testBackpressureSupportedWhenSchedulerSlow() {
+    subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
+    o.assertCursor().isExhausted();
+
+    // Switch the scheduler to queue actions.
+    scheduler.runTasksImmediately(false);
+
+    // Shotgun twice as many insertions as the scheduler queue can handle.
+    for (int i = 0; i < RxRingBuffer.SIZE * 2; i++) {
+      contentResolver.insert(TABLE, values("key" + i, "val" + i));
+    }
+
+    scheduler.triggerActions();
+
+    // Assert we got all the events from the queue plus the one buffered from backpressure.
+    for (int i = 0; i < RxRingBuffer.SIZE + 1; i++) {
+      o.assertCursor(); // Ignore contents, just assert we got notified.
+    }
+  }
+
   public void testInitialValueAndTriggerUsesScheduler() {
     scheduler.runTasksImmediately(false);
 
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java
index 5997775..bda04d0 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java
@@ -37,6 +37,7 @@
 import rx.Observable;
 import rx.Subscription;
 import rx.functions.Action1;
+import rx.internal.util.RxRingBuffer;
 
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE;
 import static com.google.common.truth.Truth.assertThat;
@@ -744,7 +745,7 @@
     o.assertNoMoreEvents();
   }
 
-  @Test public void backpressureSupported() {
+  @Test public void backpressureSupportedWhenConsumerSlow() {
     o.doRequest(2);
 
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
@@ -789,6 +790,30 @@
     o.assertNoMoreEvents();
   }
 
+  @Test public void backpressureSupportedWhenSchedulerSlow() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    // Switch the scheduler to queue actions.
+    scheduler.runTasksImmediately(false);
+
+    // Shotgun twice as many insertions as the scheduler queue can handle.
+    for (int i = 0; i < RxRingBuffer.SIZE * 2; i++) {
+      db.insert(TABLE_EMPLOYEE, employee("user" + i, "name" + i));
+    }
+
+    scheduler.triggerActions();
+
+    // Assert we got all the events from the queue plus the one buffered from backpressure.
+    for (int i = 0; i < RxRingBuffer.SIZE + 1; i++) {
+      o.assertCursor(); // Ignore contents, just assert we got notified.
+    }
+  }
+
   @Test public void badQueryThrows() {
     try {
       db.query("SELECT * FROM missing");
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryObservableTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryObservableTest.java
index 5d5ac6c..03812aa 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryObservableTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryObservableTest.java
@@ -10,6 +10,7 @@
 import org.junit.runner.RunWith;
 
 import rx.Observable;
+import rx.Observable.OnSubscribe;
 import rx.functions.Func1;
 import rx.observers.TestSubscriber;
 
@@ -21,11 +22,15 @@
   @Test public void mapToListThrowsFromQueryRun() {
     TestSubscriber<Object> testSubscriber = new TestSubscriber<>();
 
-    new QueryObservable(Observable.<Query>just(new Query() {
+    Observable.<Query>just(new Query() {
       @Override public Cursor run() {
         throw new IllegalStateException("test exception");
       }
-    })).mapToList(new Func1<Cursor, Object>() {
+    }).extend(new Func1<OnSubscribe<Query>, QueryObservable>() {
+      @Override public QueryObservable call(OnSubscribe<Query> func) {
+        return new QueryObservable(func);
+      }
+    }).mapToList(new Func1<Cursor, Object>() {
       @Override public Object call(Cursor cursor) {
         throw new AssertionError("Must not be called");
       }
@@ -42,13 +47,17 @@
   @Test public void mapToListThrowsFromMapFunction() {
     TestSubscriber<Object> testSubscriber = new TestSubscriber<>();
 
-    new QueryObservable(Observable.<Query>just(new Query() {
+    Observable.<Query>just(new Query() {
       @Override public Cursor run() {
         MatrixCursor cursor = new MatrixCursor(new String[]{"col1"});
         cursor.addRow(new Object[]{"value1"});
         return cursor;
       }
-    })).mapToList(new Func1<Cursor, Object>() {
+    }).extend(new Func1<OnSubscribe<Query>, QueryObservable>() {
+      @Override public QueryObservable call(OnSubscribe<Query> func) {
+        return new QueryObservable(func);
+      }
+    }).mapToList(new Func1<Cursor, Object>() {
       @Override public Object call(Cursor cursor) {
         throw new IllegalStateException("test exception");
       }
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java
index 70226a6..6553170 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java
@@ -16,14 +16,17 @@
 package com.squareup.sqlbrite;
 
 import android.database.Cursor;
+import android.support.annotation.Nullable;
 import android.support.test.InstrumentationRegistry;
 import com.squareup.sqlbrite.SqlBrite.Query;
 import com.squareup.sqlbrite.TestDb.Employee;
 import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
+import rx.Observable;
 import rx.functions.Func1;
 import rx.observables.BlockingObservable;
+import rx.observers.TestSubscriber;
 import rx.schedulers.Schedulers;
 
 import static com.google.common.truth.Truth.assertThat;
@@ -89,6 +92,22 @@
     }
   }
 
+  @Test public void mapToOneIgnoresNullCursor() {
+    Query nully = new Query() {
+      @Nullable @Override public Cursor run() {
+        return null;
+      }
+    };
+
+    TestSubscriber<Employee> subscriber = new TestSubscriber<>();
+    Observable.just(nully)
+        .lift(Query.mapToOne(Employee.MAPPER))
+        .subscribe(subscriber);
+
+    subscriber.assertNoValues();
+    subscriber.assertCompleted();
+  }
+
   @Test public void mapToOneOrDefault() {
     Employee employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES + " LIMIT 1")
         .lift(Query.mapToOneOrDefault(Employee.MAPPER, null))
@@ -146,6 +165,23 @@
     }
   }
 
+  @Test public void mapToOneOrDefaultReturnsDefaultWhenNullCursor() {
+    Employee defaultEmployee = new Employee("bob", "Bob Bobberson");
+    Query nully = new Query() {
+      @Nullable @Override public Cursor run() {
+        return null;
+      }
+    };
+
+    TestSubscriber<Employee> subscriber = new TestSubscriber<>();
+    Observable.just(nully)
+        .lift(Query.mapToOneOrDefault(Employee.MAPPER, defaultEmployee))
+        .subscribe(subscriber);
+
+    subscriber.assertValues(defaultEmployee);
+    subscriber.assertCompleted();
+  }
+
   @Test public void mapToList() {
     List<Employee> employees = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
         .lift(Query.mapToList(Employee.MAPPER))
@@ -184,4 +220,20 @@
           "OnError while emitting onNext value: SELECT username, name FROM employee");
     }
   }
+
+  @Test public void mapToListIgnoresNullCursor() {
+    Query nully = new Query() {
+      @Nullable @Override public Cursor run() {
+        return null;
+      }
+    };
+
+    TestSubscriber<List<Employee>> subscriber = new TestSubscriber<>();
+    Observable.just(nully)
+        .lift(Query.mapToList(Employee.MAPPER))
+        .subscribe(subscriber);
+
+    subscriber.assertNoValues();
+    subscriber.assertCompleted();
+  }
 }
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java
index f320d2b..a1e5b1a 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java
@@ -2,6 +2,7 @@
 
 import android.database.Cursor;
 import android.database.MatrixCursor;
+import android.support.annotation.Nullable;
 import android.support.test.runner.AndroidJUnit4;
 import com.squareup.sqlbrite.SqlBrite.Query;
 import java.util.List;
@@ -9,6 +10,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import rx.functions.Func1;
+import rx.observers.TestSubscriber;
 
 import static com.google.common.truth.Truth.assertThat;
 
@@ -51,6 +53,28 @@
     assertThat(count.get()).isEqualTo(1);
   }
 
+  @Test public void asRowsEmptyWhenNullCursor() {
+    Query nully = new Query() {
+      @Nullable @Override public Cursor run() {
+        return null;
+      }
+    };
+
+    TestSubscriber<Name> subscriber = new TestSubscriber<>();
+    final AtomicInteger count = new AtomicInteger();
+    nully.asRows(new Func1<Cursor, Name>() {
+      @Override public Name call(Cursor cursor) {
+        count.incrementAndGet();
+        return Name.MAP.call(cursor);
+      }
+    }).subscribe(subscriber);
+
+    subscriber.assertNoValues();
+    subscriber.assertCompleted();
+
+    assertThat(count.get()).isEqualTo(0);
+  }
+
   static final class Name {
     static final Func1<Cursor, Name> MAP = new Func1<Cursor, Name>() {
       @Override public Name call(Cursor cursor) {
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
index 931999e..193fc1b 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
@@ -117,13 +117,20 @@ public QueryObservable createQuery(@NonNull final Uri uri, @Nullable final Strin
             contentResolver.unregisterContentObserver(observer);
           }
         }));
+
+        subscriber.onNext(query); // Trigger initial query.
       }
     };
-    Observable<Query> queryObservable = Observable.create(subscribe) //
-        .startWith(query) //
+    final Observable<Query> queryObservable = Observable.create(subscribe) //
+        .onBackpressureLatest() // Guard against uncontrollable frequency of upstream emissions.
         .observeOn(scheduler) //
-        .onBackpressureLatest();
-    return new QueryObservable(queryObservable);
+        .onBackpressureLatest(); // Guard against uncontrollable frequency of scheduler executions.
+    // TODO switch to .extend when non-@Experimental
+    return new QueryObservable(new OnSubscribe<Query>() {
+      @Override public void call(Subscriber<? super Query> subscriber) {
+        queryObservable.unsafeSubscribe(subscriber);
+      }
+    });
   }
 
   void log(String message, Object... args) {
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
index 1087016..304dc8b 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
@@ -34,6 +34,7 @@
 import java.util.concurrent.TimeUnit;
 import rx.Observable;
 import rx.Scheduler;
+import rx.Subscriber;
 import rx.functions.Action0;
 import rx.functions.Func1;
 import rx.subjects.PublishSubject;
@@ -53,8 +54,6 @@
  * the result of a query. Create using a {@link SqlBrite} instance.
  */
 public final class BriteDatabase implements Closeable {
-  private static final Set<String> INITIAL = Collections.emptySet();
-
   private final SQLiteOpenHelper helper;
   private final SqlBrite.Logger logger;
 
@@ -251,7 +250,7 @@ public QueryObservable createQuery(@NonNull final String table, @NonNull String
       @NonNull String... args) {
     Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
       @Override public Boolean call(Set<String> triggers) {
-        return triggers == INITIAL || triggers.contains(table);
+        return triggers.contains(table);
       }
 
       @Override public String toString() {
@@ -272,9 +271,6 @@ public QueryObservable createQuery(@NonNull final Iterable<String> tables, @NonN
       @NonNull String... args) {
     Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
       @Override public Boolean call(Set<String> triggers) {
-        if (triggers == INITIAL) {
-          return true;
-        }
         for (String table : tables) {
           if (triggers.contains(table)) {
             return true;
@@ -309,8 +305,8 @@ private QueryObservable createQuery(final Func1<Set<String>, Boolean> tableFilte
 
         if (logging) {
           long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
-          log("QUERY (%sms)\n  tables: %s\n  sql: %s\n  args: %s", tookMillis, tableFilter, sql,
-              Arrays.toString(args));
+          log("QUERY (%sms)\n  tables: %s\n  sql: %s\n  args: %s", tookMillis, tableFilter,
+              indentSql(sql), Arrays.toString(args));
         }
 
         return cursor;
@@ -321,16 +317,17 @@ private QueryObservable createQuery(final Func1<Set<String>, Boolean> tableFilte
       }
     };
 
-    Observable<Query> queryObservable = triggers //
-        .startWith(INITIAL) // Immediately trigger the query for initial value.
-        .observeOn(scheduler) //
+    final Observable<Query> queryObservable = triggers //
         .filter(tableFilter) // Only trigger on tables we care about.
         .map(new Func1<Set<String>, Query>() {
           @Override public Query call(Set<String> trigger) {
             return query;
           }
         }) //
-        .onBackpressureLatest() //
+        .onBackpressureLatest() // Guard against uncontrollable frequency of upstream emissions.
+        .startWith(query) //
+        .observeOn(scheduler) //
+        .onBackpressureLatest() // Guard against uncontrollable frequency of scheduler executions.
         .doOnSubscribe(new Action0() {
           @Override public void call() {
             if (transactions.get() != null) {
@@ -339,7 +336,12 @@ private QueryObservable createQuery(final Func1<Set<String>, Boolean> tableFilte
             }
           }
         });
-    return new QueryObservable(queryObservable);
+    // TODO switch to .extend when non-@Experimental
+    return new QueryObservable(new Observable.OnSubscribe<Query>() {
+      @Override public void call(Subscriber<? super Query> subscriber) {
+        queryObservable.unsafeSubscribe(subscriber);
+      }
+    });
   }
 
   /**
@@ -354,7 +356,7 @@ public Cursor query(@NonNull String sql, @NonNull String... args) {
     long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
 
     if (logging) {
-      log("QUERY (%sms)\n  sql: %s\n  args: %s", tookMillis, sql, Arrays.toString(args));
+      log("QUERY (%sms)\n  sql: %s\n  args: %s", tookMillis, indentSql(sql), Arrays.toString(args));
     }
 
     return cursor;
@@ -593,6 +595,10 @@ public void executeAndTrigger(String table, String sql, Object... args) {
   public @interface ConflictAlgorithm {
   }
 
+  private static String indentSql(String sql) {
+    return sql.replace("\n", "\n       ");
+  }
+
   void log(String message, Object... args) {
     if (args.length > 0) message = String.format(message, args);
     logger.log(message);
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java
index cca3b21..d5b197a 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryObservable.java
@@ -6,17 +6,12 @@
 import com.squareup.sqlbrite.SqlBrite.Query;
 import java.util.List;
 import rx.Observable;
-import rx.Subscriber;
 import rx.functions.Func1;
 
 /** An {@link Observable} of {@link Query} which offers query-specific convenience operators. */
 public final class QueryObservable extends Observable<Query> {
-  QueryObservable(final Observable<Query> o) {
-    super(new OnSubscribe<Query>() {
-      @Override public void call(Subscriber<? super Query> subscriber) {
-        o.unsafeSubscribe(subscriber);
-      }
-    });
+  public QueryObservable(OnSubscribe<Query> func) {
+    super(func);
   }
 
   /**
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
index 802ac69..2c0accf 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
@@ -22,6 +22,9 @@
       @Override public void onNext(SqlBrite.Query query) {
         try {
           Cursor cursor = query.run();
+          if (cursor == null) {
+            return;
+          }
           List<T> items = new ArrayList<>(cursor.getCount());
           try {
             for (int i = 1; cursor.moveToNext() && !subscriber.isUnsubscribed(); i++) {
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
index fcc90e1..cde2e7e 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
@@ -24,18 +24,20 @@
         try {
           T item = null;
           Cursor cursor = query.run();
-          try {
-            if (cursor.moveToNext()) {
-              item = mapper.call(cursor);
-              if (item == null) {
-                throw new NullPointerException("Mapper returned null for row 1");
-              }
+          if (cursor != null) {
+            try {
               if (cursor.moveToNext()) {
-                throw new IllegalStateException("Cursor returned more than 1 row");
+                item = mapper.call(cursor);
+                if (item == null) {
+                  throw new NullPointerException("Mapper returned null for row 1");
+                }
+                if (cursor.moveToNext()) {
+                  throw new IllegalStateException("Cursor returned more than 1 row");
+                }
               }
+            } finally {
+              cursor.close();
             }
-          } finally {
-            cursor.close();
           }
           if (!subscriber.isUnsubscribed()) {
             if (item != null) {
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
index 34af3bb..1728b67 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
@@ -20,6 +20,7 @@
 import android.database.sqlite.SQLiteOpenHelper;
 import android.support.annotation.CheckResult;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import java.util.List;
 import rx.Observable;
@@ -89,6 +90,8 @@ private SqlBrite(@NonNull Logger logger) {
      * It is an error for a query to pass through this operator with more than 1 row in its result
      * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
      * do not emit an item.
+     * <p>
+     * This operator ignores {@code null} cursors returned from {@link #run()}.
      *
      * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
      */
@@ -104,6 +107,8 @@ private SqlBrite(@NonNull Logger logger) {
      * It is an error for a query to pass through this operator with more than 1 row in its result
      * set. Use {@code LIMIT 1} on the underlying SQL query to prevent this. Result sets with 0 rows
      * emit {@code defaultValue}.
+     * <p>
+     * This operator emits {@code defaultValue} if {@code null} is returned from {@link #run()}.
      *
      * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
      * @param defaultValue Value returned if result set is empty
@@ -121,6 +126,8 @@ private SqlBrite(@NonNull Logger logger) {
      * Be careful using this operator as it will always consume the entire cursor and create objects
      * for each row, every time this observable emits a new query. On tables whose queries update
      * frequently or very large result sets this can result in the creation of many objects.
+     * <p>
+     * This operator ignores {@code null} cursors returned from {@link #run()}.
      *
      * @param mapper Maps the current {@link Cursor} row to {@code T}. May not return null.
      */
@@ -129,9 +136,17 @@ private SqlBrite(@NonNull Logger logger) {
       return new QueryToListOperator<>(mapper);
     }
 
-    /** Execute the query on the underlying database and return the resulting cursor. */
+    /**
+     * Execute the query on the underlying database and return the resulting cursor.
+     *
+     * @return A {@link Cursor} with query results, or {@code null} when the query could not be
+     * executed due to a problem with the underlying store. Unfortunately it is not well documented
+     * when {@code null} is returned. It usually involves a problem in communicating with the
+     * underlying store and should either be treated as failure or ignored for retry at a later
+     * time.
+     */
     @CheckResult // TODO @WorkerThread
-    // TODO Implementations might return null, which is gross. Throw?
+    @Nullable
     public abstract Cursor run();
 
     /**
@@ -153,18 +168,22 @@ private SqlBrite(@NonNull Logger logger) {
      * <p>
      * Note: Limiting results or filtering will almost always be faster in the database as part of
      * a query and should be preferred, where possible.
+     * <p>
+     * The resulting observable will be empty if {@code null} is returned from {@link #run()}.
      */
     @CheckResult @NonNull
     public final <T> Observable<T> asRows(final Func1<Cursor, T> mapper) {
       return Observable.create(new Observable.OnSubscribe<T>() {
         @Override public void call(Subscriber<? super T> subscriber) {
           Cursor cursor = run();
-          try {
-            while (cursor.moveToNext() && !subscriber.isUnsubscribed()) {
-              subscriber.onNext(mapper.call(cursor));
+          if (cursor != null) {
+            try {
+              while (cursor.moveToNext() && !subscriber.isUnsubscribed()) {
+                subscriber.onNext(mapper.call(cursor));
+              }
+            } finally {
+              cursor.close();
             }
-          } finally {
-            cursor.close();
           }
           if (!subscriber.isUnsubscribed()) {
             subscriber.onCompleted();
