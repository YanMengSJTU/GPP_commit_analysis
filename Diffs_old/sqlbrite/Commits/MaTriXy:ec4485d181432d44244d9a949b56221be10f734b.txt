diff --git a/CHANGELOG.md b/CHANGELOG.md
index d47dd43..33a455c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,7 +1,7 @@
 Change Log
 =========
 
-Version 0.1.0 *(In Development)*
---------------------------------
+Version 0.1.0 *(2015-02-21)*
+----------------------------
 
 Initial release.
diff --git a/README.md b/README.md
index a7e88c1..e005511 100644
--- a/README.md
+++ b/README.md
@@ -29,9 +29,9 @@ users.subscribe(new Action1<Query>() {
 });
 ```
 
-Unlike a traditional `rawQuery`, as long as you remain subscribed to the observable updates to the
-specified table(s) will trigger another query. This means that when you insert, update, or delete
-data any subscribed queries will update instantly.
+Unlike a traditional `rawQuery`, updates to the specified table(s) will trigger additional
+notifications for as long as you remain subscribed to the observable. This means that when you
+insert, update, or delete data, any subscribed queries will update with the new data instantly.
 
 ```java
 final AtomicInteger queries = new AtomicInteger();
@@ -129,7 +129,7 @@ Download
 --------
 
 ```groovy
-compile 'com.squareup.sqlbrite:sqlbrite:0.1.0-SNAPSHOT'
+compile 'com.squareup.sqlbrite:sqlbrite:0.1.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/RELEASING.md b/RELEASING.md
new file mode 100644
index 0000000..c86a089
--- /dev/null
+++ b/RELEASING.md
@@ -0,0 +1,13 @@
+Releasing
+========
+
+ 1. Change the version in `gradle.properties` to a non-SNAPSHOT verson.
+ 2. Update the `CHANGELOG.md` for the impending release.
+ 3. Update the `README.md` with the new version.
+ 4. `git commit -am "Prepare for release X.Y.Z."` (where X.Y.Z is the new version)
+ 5. `git tag -a X.Y.X -m "Version X.Y.Z"` (where X.Y.Z is the new version)
+ 6. `./gradlew clean uploadArchives`
+ 7. Update the `gradle.properties` to the next SNAPSHOT version.
+ 8. `git commit -am "Prepare next development version."`
+ 9. `git push && git push --tags`
+ 10. Visit [Sonatype Nexus](https://oss.sonatype.org/) and promote the artifact.
diff --git a/gradle.properties b/gradle.properties
index bda0aa8..6708009 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,5 +1,5 @@
 GROUP=com.squareup.sqlbrite
-VERSION_NAME=0.1.0-SNAPSHOT
+VERSION_NAME=0.1.1-SNAPSHOT
 
 POM_DESCRIPTION=A lightweight wrapper around SQLiteOpenHelper which introduces reactive stream semantics to SQL operations.
 
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
index db463e3..46bfbb2 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
@@ -125,7 +125,12 @@ private long getListId() {
 
   @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
       @Nullable Bundle savedInstanceState) {
-    View view = inflater.inflate(R.layout.items, container, false);
+    return inflater.inflate(R.layout.items, container, false);
+  }
+
+  @Override
+  public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
+    super.onViewCreated(view, savedInstanceState);
     ButterKnife.inject(this, view);
     listView.setEmptyView(emptyView);
     listView.setAdapter(adapter);
@@ -140,8 +145,6 @@ private long getListId() {
                 TodoItem.ID + " = ?", String.valueOf(event.id()));
           }
         });
-
-    return view;
   }
 
   @Override public void onResume() {
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
index e204682..7109a4f 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
+++ b/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
@@ -87,11 +87,15 @@ static ListsFragment newInstance() {
 
   @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
       @Nullable Bundle savedInstanceState) {
-    View view = inflater.inflate(R.layout.lists, container, false);
+    return inflater.inflate(R.layout.lists, container, false);
+  }
+
+  @Override
+  public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
+    super.onViewCreated(view, savedInstanceState);
     ButterKnife.inject(this, view);
     listView.setEmptyView(emptyView);
     listView.setAdapter(adapter);
-    return view;
   }
 
   @OnItemClick(android.R.id.list) void listClicked(long listId) {
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
index 3400ab1..3ec76bc 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
@@ -31,6 +31,7 @@
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.Set;
+import java.util.concurrent.TimeUnit;
 import rx.Observable;
 import rx.functions.Func1;
 import rx.subjects.PublishSubject;
@@ -74,7 +75,7 @@ public static SqlBrite create(@NonNull SQLiteOpenHelper helper) {
   private final SQLiteOpenHelper helper;
   private final ThreadLocal<Transaction> transactions = new ThreadLocal<>();
   /** Publishes sets of tables which have changed. */
-  private final PublishSubject<Set<String>> trigger = PublishSubject.create();
+  private final PublishSubject<Set<String>> triggers = PublishSubject.create();
 
   // Read and write guarded by 'databaseLock'. Lazily initialized. Use methods to access.
   private volatile SQLiteDatabase readableDatabase;
@@ -149,7 +150,7 @@ private void sendTableTrigger(Set<String> tables) {
       transaction.triggers.addAll(tables);
     } else {
       if (logging) log("TRIGGER %s", tables);
-      trigger.onNext(tables);
+      triggers.onNext(tables);
     }
   }
 
@@ -305,7 +306,7 @@ public void endTransaction() {
       }
     };
 
-    return trigger //
+    return triggers //
         .filter(tableFilter) // Only trigger on tables we care about.
         .startWith(INITIAL_TRIGGER) // Immediately execute the query for initial value.
         .map(new Func1<Set<String>, Query>() {
@@ -429,6 +430,37 @@ public int update(@NonNull String table, @NonNull ContentValues values,
     return rows;
   }
 
+  /**
+   * Temporarily end the transaction to let other threads run. The transaction is assumed to be
+   * successful so far. Do not call setTransactionSuccessful before calling this. When this
+   * returns a new transaction will have been created but not marked as successful. This assumes
+   * that there are no nested transactions (beginTransaction has only been called once) and will
+   * throw an exception if that is not the case.
+   * @return true if the transaction was yielded
+   *
+   * @see SQLiteDatabase#yieldIfContendedSafely()
+   */
+  public boolean yieldIfContendedSafely() {
+    return getWriteableDatabase().yieldIfContendedSafely();
+  }
+
+  /**
+   * Temporarily end the transaction to let other threads run. The transaction is assumed to be
+   * successful so far. Do not call setTransactionSuccessful before calling this. When this
+   * returns a new transaction will have been created but not marked as successful. This assumes
+   * that there are no nested transactions (beginTransaction has only been called once) and will
+   * throw an exception if that is not the case.
+   * @param sleepAmount if > 0, sleep this long before starting a new transaction if
+   *   the lock was actually yielded. This will allow other background threads to make some
+   *   more progress than they would if we started the transaction immediately.
+   * @return true if the transaction was yielded
+   *
+   * @see SQLiteDatabase#yieldIfContendedSafely(long)
+   */
+  public boolean yieldIfContendedSafely(long sleepAmount, TimeUnit sleepUnit) {
+    return getWriteableDatabase().yieldIfContendedSafely(sleepUnit.toMillis(sleepAmount));
+  }
+
   @IntDef({
       CONFLICT_ABORT,
       CONFLICT_FAIL,
@@ -484,7 +516,7 @@ private static String conflictString(@ConflictAlgorithm int conflictAlgorithm) {
     }
 
     @Override public String toString() {
-      String name = String.format("%08x", System.identityHashCode(this)).replace(' ', '0');
+      String name = String.format("%08x", System.identityHashCode(this));
       return parent == null ? name : name + " [" + parent.toString() + ']';
     }
   }
