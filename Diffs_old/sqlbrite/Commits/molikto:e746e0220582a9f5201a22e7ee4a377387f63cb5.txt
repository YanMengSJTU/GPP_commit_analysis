diff --git a/build.gradle b/build.gradle
index ef1206f..d2c9401 100644
--- a/build.gradle
+++ b/build.gradle
@@ -13,7 +13,7 @@ subprojects {
 ext {
   androidPlugin = 'com.android.tools.build:gradle:1.3.0'
   compileSdkVersion = 23
-  buildToolsVersion = '23.0.0'
+  buildToolsVersion = '23.0.1'
 
   // Android dependencies.
   supportV4 = 'com.android.support:support-v4:23.0.0'
diff --git a/sqlbrite/build.gradle b/sqlbrite/build.gradle
index fccb727..bda53dd 100644
--- a/sqlbrite/build.gradle
+++ b/sqlbrite/build.gradle
@@ -1,20 +1,8 @@
-buildscript {
-  dependencies {
-    classpath rootProject.ext.androidPlugin
-  }
-}
-
 apply plugin: 'com.android.library'
-apply from: rootProject.file('gradle/android-findbugs.gradle')
 
 dependencies {
-  compile rootProject.ext.rxJava
-  compile rootProject.ext.supportAnnotations
-
-  androidTestCompile rootProject.ext.supportTestRunner
-  androidTestCompile(rootProject.ext.truth) {
-    exclude group: 'junit' // Android has JUnit built in.
-  }
+  compile 'io.reactivex:rxjava:1.0.3'
+  compile  'com.android.support:support-annotations:23.0.1'
 }
 
 def isCi() {
@@ -22,11 +10,10 @@ def isCi() {
 }
 
 android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
+  compileSdkVersion 23
+  buildToolsVersion "23.0.1"
 
   defaultConfig {
-    testInstrumentationRunner 'android.support.test.runner.AndroidJUnitRunner'
   }
 
   compileOptions {
@@ -66,4 +53,4 @@ if (isCi()) {
   }
 }
 
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
+//apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
index 9040e94..7c8b7db 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
@@ -30,6 +30,7 @@
 import java.lang.annotation.Retention;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
@@ -143,13 +144,29 @@ SQLiteDatabase getWriteableDatabase() {
     return db;
   }
 
-  private void sendTableTrigger(Set<String> tables) {
+  // the change is like this:
+  // you can only notify a change on a **leave**, but all nodes above will be triggered
+  public static Set<String> pathsToIntervals(Set<String> paths) {
+    Set<String> a = new HashSet<>(paths.size());
+    for (String p : paths) {
+      for (int i = 0; i < p.length(); i++) {
+        if (p.charAt(i) == '/') {
+          a.add(p.substring(0, i));
+        }
+        a.add(p);
+      }
+    }
+    return a;
+  }
+
+  private void sendTableTrigger(Set<String> paths) {
     SqliteTransaction transaction = transactions.get();
     if (transaction != null) {
-      transaction.addAll(tables);
+
+      transaction.addAll(pathsToIntervals(paths));
     } else {
-      if (logging) log("TRIGGER %s", tables);
-      triggers.onNext(tables);
+      if (logging) log("TRIGGER %s", paths);
+      triggers.onNext(pathsToIntervals(paths));
     }
   }
 
@@ -232,45 +249,45 @@ public Transaction newTransaction() {
    * @see SQLiteDatabase#rawQuery(String, String[])
    */
   @CheckResult @NonNull
-  public QueryObservable createQuery(@NonNull final String table, @NonNull String sql,
+  public QueryObservable createQuery(@NonNull final String triggerPath, @NonNull String sql,
       @NonNull String... args) {
     Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
       @Override public Boolean call(Set<String> triggers) {
-        return triggers.contains(table);
+        return triggers.contains(triggerPath);
       }
 
       @Override public String toString() {
-        return table;
+        return triggerPath;
       }
     };
     return createQuery(tableFilter, sql, args);
   }
 
-  /**
-   * See {@link #createQuery(String, String, String...)} for usage. This overload allows for
-   * monitoring multiple tables for changes.
-   *
-   * @see SQLiteDatabase#rawQuery(String, String[])
-   */
-  @CheckResult @NonNull
-  public QueryObservable createQuery(@NonNull final Iterable<String> tables, @NonNull String sql,
-      @NonNull String... args) {
-    Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
-      @Override public Boolean call(Set<String> triggers) {
-        for (String table : tables) {
-          if (triggers.contains(table)) {
-            return true;
-          }
-        }
-        return false;
-      }
-
-      @Override public String toString() {
-        return tables.toString();
-      }
-    };
-    return createQuery(tableFilter, sql, args);
-  }
+//  /**
+//   * See {@link #createQuery(String, String, String...)} for usage. This overload allows for
+//   * monitoring multiple tables for changes.
+//   *
+//   * @see SQLiteDatabase#rawQuery(String, String[])
+//   */
+//  @CheckResult @NonNull
+//  public QueryObservable createQuery(@NonNull final Iterable<String> tables, @NonNull String sql,
+//      @NonNull String... args) {
+//    Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
+//      @Override public Boolean call(Set<String> triggers) {
+//        for (String table : tables) {
+//          if (triggers.contains(table)) {
+//            return true;
+//          }
+//        }
+//        return false;
+//      }
+//
+//      @Override public String toString() {
+//        return tables.toString();
+//      }
+//    };
+//    return createQuery(tableFilter, sql, args);
+//  }
 
   @CheckResult @NonNull
   private QueryObservable createQuery(final Func1<Set<String>, Boolean> tableFilter,
@@ -330,8 +347,8 @@ public Cursor query(@NonNull String sql, @NonNull String... args) {
    * @see SQLiteDatabase#insert(String, String, ContentValues)
    */
   // TODO @WorkerThread
-  public long insert(@NonNull String table, @NonNull ContentValues values) {
-    return insert(table, values, CONFLICT_NONE);
+  public long insert(@NonNull String triggerPath, @NonNull String table, @NonNull ContentValues values) {
+    return insert(triggerPath, table, values, CONFLICT_NONE);
   }
 
   /**
@@ -340,8 +357,8 @@ public long insert(@NonNull String table, @NonNull ContentValues values) {
    * @see SQLiteDatabase#insertWithOnConflict(String, String, ContentValues, int)
    */
   // TODO @WorkerThread
-  public long insert(@NonNull String table, @NonNull ContentValues values,
-      @ConflictAlgorithm int conflictAlgorithm) {
+  public long insert(String triggerPath, @NonNull String table, @NonNull ContentValues values,
+                     @ConflictAlgorithm int conflictAlgorithm) {
     SQLiteDatabase db = getWriteableDatabase();
 
     if (logging) {
@@ -354,7 +371,7 @@ public long insert(@NonNull String table, @NonNull ContentValues values,
 
     if (rowId != -1) {
       // Only send a table trigger if the insert was successful.
-      sendTableTrigger(Collections.singleton(table));
+      sendTableTrigger(Collections.singleton(triggerPath));
     }
     return rowId;
   }
@@ -366,7 +383,7 @@ public long insert(@NonNull String table, @NonNull ContentValues values,
    * @see SQLiteDatabase#delete(String, String, String[])
    */
   // TODO @WorkerThread
-  public int delete(@NonNull String table, @Nullable String whereClause,
+  public int delete(@NonNull String triggerPath, @NonNull String table, @Nullable String whereClause,
       @Nullable String... whereArgs) {
     SQLiteDatabase db = getWriteableDatabase();
 
@@ -380,7 +397,7 @@ public int delete(@NonNull String table, @Nullable String whereClause,
 
     if (rows > 0) {
       // Only send a table trigger if rows were affected.
-      sendTableTrigger(Collections.singleton(table));
+      sendTableTrigger(Collections.singleton(triggerPath));
     }
     return rows;
   }
@@ -392,9 +409,9 @@ public int delete(@NonNull String table, @Nullable String whereClause,
    * @see SQLiteDatabase#update(String, ContentValues, String, String[])
    */
   // TODO @WorkerThread
-  public int update(@NonNull String table, @NonNull ContentValues values,
+  public int update(@NonNull String triggerPath, @NonNull String table, @NonNull ContentValues values,
       @Nullable String whereClause, @Nullable String... whereArgs) {
-    return update(table, values, CONFLICT_NONE, whereClause, whereArgs);
+    return update(triggerPath, table, values, CONFLICT_NONE, whereClause, whereArgs);
   }
 
   /**
@@ -404,9 +421,9 @@ public int update(@NonNull String table, @NonNull ContentValues values,
    * @see SQLiteDatabase#updateWithOnConflict(String, ContentValues, String, String[], int)
    */
   // TODO @WorkerThread
-  public int update(@NonNull String table, @NonNull ContentValues values,
-      @ConflictAlgorithm int conflictAlgorithm, @Nullable String whereClause,
-      @Nullable String... whereArgs) {
+  public int update(@NonNull String triggerPath, @NonNull String table,
+                    ContentValues values, @ConflictAlgorithm int conflictAlgorithm, @Nullable String whereClause,
+                    @Nullable String... whereArgs) {
     SQLiteDatabase db = getWriteableDatabase();
 
     if (logging) {
@@ -420,7 +437,7 @@ public int update(@NonNull String table, @NonNull ContentValues values,
 
     if (rows > 0) {
       // Only send a table trigger if rows were affected.
-      sendTableTrigger(Collections.singleton(table));
+      sendTableTrigger(Collections.singleton(triggerPath));
     }
     return rows;
   }
