diff --git a/build.gradle b/build.gradle
index a0bb673..163b37a 100644
--- a/build.gradle
+++ b/build.gradle
@@ -38,6 +38,9 @@ ext {
   supportSqlite = 'android.arch.persistence:db:1.0.0'
   supportSqliteFramework = 'android.arch.persistence:db-framework:1.0.0'
 
+  // https://www.zetetic.net/sqlcipher/sqlcipher-for-android/
+  supportSqlcipher = 'net.zetetic:android-database-sqlcipher:3.5.8@aar'
+
   // Third-party dependencies.
   kotlinStdLib = "org.jetbrains.kotlin:kotlin-stdlib:${versions.kotlin}"
   dagger = 'com.google.dagger:dagger:2.13'
diff --git a/sample/build.gradle b/sample/build.gradle
index 02bb0e7..018b313 100644
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -20,6 +20,8 @@ dependencies {
 
   implementation project(':sqlbrite')
   implementation rootProject.ext.supportSqliteFramework
+
+  implementation project(':sqlbrite-sqlcipher-integration')
 }
 
 android {
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java b/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
index c2701fe..622610d 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
@@ -20,6 +20,8 @@
 import android.arch.persistence.db.SupportSQLiteOpenHelper.Configuration;
 import android.arch.persistence.db.SupportSQLiteOpenHelper.Factory;
 import android.arch.persistence.db.framework.FrameworkSQLiteOpenHelperFactory;
+import android.arch.persistence.db.sqlcipher.SqlcipherSQLiteOpenHelperFactory;
+
 import com.squareup.sqlbrite3.BriteDatabase;
 import com.squareup.sqlbrite3.SqlBrite;
 import dagger.Module;
@@ -41,14 +43,33 @@
   }
 
   @Provides @Singleton BriteDatabase provideDatabase(SqlBrite sqlBrite, Application application) {
-    Configuration configuration = Configuration.builder(application)
+
+    // 原生
+    /*Configuration configuration = Configuration.builder(application)
         .name("todo.db")
         .callback(new DbCallback())
         .build();
+
     Factory factory = new FrameworkSQLiteOpenHelperFactory();
     SupportSQLiteOpenHelper helper = factory.create(configuration);
+
     BriteDatabase db = sqlBrite.wrapDatabaseHelper(helper, Schedulers.io());
-    db.setLoggingEnabled(true);
-    return db;
+    db.setLoggingEnabled(true);*/
+
+
+
+    // 加密
+    Configuration configuration_sqlcipher = Configuration.builder(application)
+            .name("todo_sqlcipher.db")
+            .callback(new DbCallback())
+            .build();
+
+    SqlcipherSQLiteOpenHelperFactory factory_sqlcipher = new SqlcipherSQLiteOpenHelperFactory();
+    SupportSQLiteOpenHelper helper_sqlcipher = factory_sqlcipher.create(configuration_sqlcipher, "Passsword_1234567");
+
+    BriteDatabase db_sqlcipher = sqlBrite.wrapDatabaseHelper(helper_sqlcipher, Schedulers.io());
+    db_sqlcipher.setLoggingEnabled(true);
+
+    return db_sqlcipher;
   }
 }
diff --git a/settings.gradle b/settings.gradle
index c8e5799..31a91c7 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -3,4 +3,6 @@ include ':sqlbrite-kotlin'
 include ':sqlbrite-lint'
 include ':sample'
 
+include ':sqlbrite-sqlcipher-integration'
+
 rootProject.name = 'sqlbrite-root'
diff --git a/sqlbrite-sqlcipher-integration/.gitignore b/sqlbrite-sqlcipher-integration/.gitignore
new file mode 100644
index 0000000..3543521
--- /dev/null
+++ b/sqlbrite-sqlcipher-integration/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/sqlbrite-sqlcipher-integration/build.gradle b/sqlbrite-sqlcipher-integration/build.gradle
new file mode 100644
index 0000000..4a68295
--- /dev/null
+++ b/sqlbrite-sqlcipher-integration/build.gradle
@@ -0,0 +1,36 @@
+apply plugin: 'com.android.library'
+
+dependencies {
+    api rootProject.ext.rxJava
+    api rootProject.ext.supportSqlite
+    api rootProject.ext.supportSqlcipher
+    implementation rootProject.ext.supportAnnotations
+
+    androidTestImplementation rootProject.ext.supportTestRunner
+    androidTestImplementation rootProject.ext.truth
+    androidTestImplementation rootProject.ext.supportSqliteFramework
+
+    lintChecks project(':sqlbrite-lint')
+}
+
+android {
+    compileSdkVersion versions.compileSdk
+
+    defaultConfig {
+        minSdkVersion versions.minSdk
+
+        testInstrumentationRunner 'android.support.test.runner.AndroidJUnitRunner'
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+
+    lintOptions {
+        textOutput 'stdout'
+        textReport true
+    }
+}
+
+//apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/sqlbrite-sqlcipher-integration/proguard-rules.pro b/sqlbrite-sqlcipher-integration/proguard-rules.pro
new file mode 100644
index 0000000..6e7ffa9
--- /dev/null
+++ b/sqlbrite-sqlcipher-integration/proguard-rules.pro
@@ -0,0 +1,21 @@
+# Add project specific ProGuard rules here.
+# You can control the set of applied configuration files using the
+# proguardFiles setting in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
diff --git a/sqlbrite-sqlcipher-integration/src/androidTest/java/com/example/sqlbrite_sqlcipher_integration/ExampleInstrumentedTest.java b/sqlbrite-sqlcipher-integration/src/androidTest/java/com/example/sqlbrite_sqlcipher_integration/ExampleInstrumentedTest.java
new file mode 100644
index 0000000..27639a5
--- /dev/null
+++ b/sqlbrite-sqlcipher-integration/src/androidTest/java/com/example/sqlbrite_sqlcipher_integration/ExampleInstrumentedTest.java
@@ -0,0 +1,26 @@
+package com.example.sqlbrite_sqlcipher_integration;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.junit.Assert.*;
+
+/**
+ * Instrumented test, which will execute on an Android device.
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+@RunWith(AndroidJUnit4.class)
+public class ExampleInstrumentedTest {
+    @Test
+    public void useAppContext() throws Exception {
+        // Context of the app under test.
+        Context appContext = InstrumentationRegistry.getTargetContext();
+
+        assertEquals("com.example.sqlbrite_sqlcipher_integration.test", appContext.getPackageName());
+    }
+}
diff --git a/sqlbrite-sqlcipher-integration/src/main/AndroidManifest.xml b/sqlbrite-sqlcipher-integration/src/main/AndroidManifest.xml
new file mode 100644
index 0000000..5dead02
--- /dev/null
+++ b/sqlbrite-sqlcipher-integration/src/main/AndroidManifest.xml
@@ -0,0 +1,2 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="android.arch.persistence.db.sqlcipher"/>
diff --git a/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteDatabase.java b/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteDatabase.java
new file mode 100644
index 0000000..fb0970e
--- /dev/null
+++ b/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteDatabase.java
@@ -0,0 +1,357 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.arch.persistence.db.sqlcipher;
+
+import android.arch.persistence.db.SimpleSQLiteQuery;
+import android.arch.persistence.db.SupportSQLiteDatabase;
+import android.arch.persistence.db.SupportSQLiteQuery;
+import android.arch.persistence.db.SupportSQLiteStatement;
+import android.content.ContentValues;
+import android.database.sqlite.SQLiteTransactionListener;
+import android.os.Build;
+import android.os.CancellationSignal;
+import android.support.annotation.RequiresApi;
+import android.util.Pair;
+
+import net.sqlcipher.Cursor;
+import net.sqlcipher.SQLException;
+import net.sqlcipher.database.SQLiteCursor;
+import net.sqlcipher.database.SQLiteCursorDriver;
+import net.sqlcipher.database.SQLiteDatabase;
+import net.sqlcipher.database.SQLiteQuery;
+
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * Delegates all calls to an implementation of {@link SQLiteDatabase}.
+ */
+@SuppressWarnings("unused")
+class SqlcipherSQLiteDatabase implements SupportSQLiteDatabase {
+    private static final String[] CONFLICT_VALUES = new String[]
+            {"", " OR ROLLBACK ", " OR ABORT ", " OR FAIL ", " OR IGNORE ", " OR REPLACE "};
+    private static final String[] EMPTY_STRING_ARRAY = new String[0];
+
+    private final SQLiteDatabase mDelegate;
+
+    /**
+     * Creates a wrapper around {@link SQLiteDatabase}.
+     *
+     * @param delegate The delegate to receive all calls.
+     */
+    SqlcipherSQLiteDatabase(SQLiteDatabase delegate) {
+        mDelegate = delegate;
+    }
+
+    @Override
+    public SupportSQLiteStatement compileStatement(String sql) {
+        return new SqlcipherSQLiteStatement(mDelegate.compileStatement(sql));
+    }
+
+    @Override
+    public void beginTransaction() {
+        mDelegate.beginTransaction();
+    }
+
+    @Override
+    public void beginTransactionNonExclusive() {
+        beginTransaction();
+    }
+
+    @Override
+    public void beginTransactionWithListener(final SQLiteTransactionListener transactionListener) {
+        mDelegate.beginTransactionWithListener(new net.sqlcipher.database.SQLiteTransactionListener() {
+            @Override
+            public void onBegin() {
+                if (null != transactionListener) {
+                    transactionListener.onBegin();
+                }
+            }
+
+            @Override
+            public void onCommit() {
+                if (null != transactionListener) {
+                    transactionListener.onCommit();
+                }
+            }
+
+            @Override
+            public void onRollback() {
+                if (null != transactionListener) {
+                    transactionListener.onRollback();
+                }
+            }
+        });
+    }
+
+    @Override
+    public void beginTransactionWithListenerNonExclusive(
+            SQLiteTransactionListener transactionListener) {
+        beginTransactionWithListener(transactionListener);
+    }
+
+    @Override
+    public void endTransaction() {
+        mDelegate.endTransaction();
+    }
+
+    @Override
+    public void setTransactionSuccessful() {
+        mDelegate.setTransactionSuccessful();
+    }
+
+    @Override
+    public boolean inTransaction() {
+        return mDelegate.inTransaction();
+    }
+
+    @Override
+    public boolean isDbLockedByCurrentThread() {
+        return mDelegate.isDbLockedByCurrentThread();
+    }
+
+    @Override
+    public boolean yieldIfContendedSafely() {
+        return mDelegate.yieldIfContendedSafely();
+    }
+
+    @Override
+    public boolean yieldIfContendedSafely(long sleepAfterYieldDelay) {
+        return mDelegate.yieldIfContendedSafely(sleepAfterYieldDelay);
+    }
+
+    @Override
+    public int getVersion() {
+        return mDelegate.getVersion();
+    }
+
+    @Override
+    public void setVersion(int version) {
+        mDelegate.setVersion(version);
+    }
+
+    @Override
+    public long getMaximumSize() {
+        return mDelegate.getMaximumSize();
+    }
+
+    @Override
+    public long setMaximumSize(long numBytes) {
+        return mDelegate.setMaximumSize(numBytes);
+    }
+
+    @Override
+    public long getPageSize() {
+        return mDelegate.getPageSize();
+    }
+
+    @Override
+    public void setPageSize(long numBytes) {
+        mDelegate.setPageSize(numBytes);
+    }
+
+    @Override
+    public Cursor query(String query) {
+        return query(new SimpleSQLiteQuery(query));
+    }
+
+    @Override
+    public Cursor query(String query, Object[] bindArgs) {
+        return query(new SimpleSQLiteQuery(query, bindArgs));
+    }
+
+
+    @Override
+    public Cursor query(final SupportSQLiteQuery supportQuery) {
+
+        // fix compatibility between 'SupportSQLiteQuery' and 'net.sqlcipher.database.SQLiteDatabase.rawQueryWithFactory'
+        String[] selectionArgs = EMPTY_STRING_ARRAY;
+        try {
+            Field f = supportQuery.getClass().getDeclaredField("mBindArgs");
+            f.setAccessible(true);
+            Object[] tmp = (Object[]) f.get(supportQuery);
+            int length = tmp.length;
+            if (tmp != null && length > 0) {
+                selectionArgs = new String[length];
+                System.arraycopy(tmp, 0, selectionArgs, 0, length);
+            }
+        } catch (Throwable e) {
+            e.printStackTrace();
+        }
+
+        return mDelegate.rawQueryWithFactory(new SQLiteDatabase.CursorFactory() {
+            @Override
+            public Cursor newCursor(SQLiteDatabase db, SQLiteCursorDriver masterQuery,
+                                    String editTable, SQLiteQuery query) {
+                supportQuery.bindTo(new SqlcipherSQLiteProgram(query));
+                return new SQLiteCursor(db, masterQuery, editTable, query);
+            }
+        }, supportQuery.getSql(), selectionArgs/*EMPTY_STRING_ARRAY*/, null);
+    }
+
+    @Override
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN)
+    public Cursor query(final SupportSQLiteQuery supportQuery,
+                        CancellationSignal cancellationSignal) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public long insert(String table, int conflictAlgorithm, ContentValues values)
+            throws SQLException {
+        return mDelegate.insertWithOnConflict(table, null, values,
+                conflictAlgorithm);
+    }
+
+    @Override
+    public int delete(String table, String whereClause, Object[] whereArgs) {
+        String query = "DELETE FROM " + table
+                + (isEmpty(whereClause) ? "" : " WHERE " + whereClause);
+        SupportSQLiteStatement statement = compileStatement(query);
+        SimpleSQLiteQuery.bind(statement, whereArgs);
+        return statement.executeUpdateDelete();
+    }
+
+
+    @Override
+    public int update(String table, int conflictAlgorithm, ContentValues values, String whereClause,
+                      Object[] whereArgs) {
+        // taken from SQLiteDatabase class.
+        if (values == null || values.size() == 0) {
+            throw new IllegalArgumentException("Empty values");
+        }
+        StringBuilder sql = new StringBuilder(120);
+        sql.append("UPDATE ");
+        sql.append(CONFLICT_VALUES[conflictAlgorithm]);
+        sql.append(table);
+        sql.append(" SET ");
+
+        // move all bind args to one array
+        int setValuesSize = values.size();
+        int bindArgsSize = (whereArgs == null) ? setValuesSize : (setValuesSize + whereArgs.length);
+        Object[] bindArgs = new Object[bindArgsSize];
+        int i = 0;
+        for (String colName : values.keySet()) {
+            sql.append((i > 0) ? "," : "");
+            sql.append(colName);
+            bindArgs[i++] = values.get(colName);
+            sql.append("=?");
+        }
+        if (whereArgs != null) {
+            for (i = setValuesSize; i < bindArgsSize; i++) {
+                bindArgs[i] = whereArgs[i - setValuesSize];
+            }
+        }
+        if (!isEmpty(whereClause)) {
+            sql.append(" WHERE ");
+            sql.append(whereClause);
+        }
+        SupportSQLiteStatement stmt = compileStatement(sql.toString());
+        SimpleSQLiteQuery.bind(stmt, bindArgs);
+        return stmt.executeUpdateDelete();
+    }
+
+    @Override
+    public void execSQL(String sql) throws SQLException {
+        mDelegate.execSQL(sql);
+    }
+
+    @Override
+    public void execSQL(String sql, Object[] bindArgs) throws SQLException {
+        mDelegate.execSQL(sql, bindArgs);
+    }
+
+    @Override
+    public boolean isReadOnly() {
+        return mDelegate.isReadOnly();
+    }
+
+    @Override
+    public boolean isOpen() {
+        return mDelegate.isOpen();
+    }
+
+    @Override
+    public boolean needUpgrade(int newVersion) {
+        return mDelegate.needUpgrade(newVersion);
+    }
+
+    @Override
+    public String getPath() {
+        return mDelegate.getPath();
+    }
+
+    @Override
+    public void setLocale(Locale locale) {
+        mDelegate.setLocale(locale);
+    }
+
+    @Override
+    public void setMaxSqlCacheSize(int cacheSize) {
+        mDelegate.setMaxSqlCacheSize(cacheSize);
+    }
+
+    @Override
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN)
+    public void setForeignKeyConstraintsEnabled(boolean enable) {
+        //mDelegate.setForeignKeyConstraintsEnabled(enable);
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean enableWriteAheadLogging() {
+        //return mDelegate.enableWriteAheadLogging();
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN)
+    public void disableWriteAheadLogging() {
+        //mDelegate.disableWriteAheadLogging();
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN)
+    public boolean isWriteAheadLoggingEnabled() {
+        //return mDelegate.isWriteAheadLoggingEnabled();
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public List<Pair<String, String>> getAttachedDbs() {
+        //return mDelegate.getAttachedDbs();
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isDatabaseIntegrityOk() {
+        //return mDelegate.isDatabaseIntegrityOk();
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void close() throws IOException {
+        mDelegate.close();
+    }
+
+    private static boolean isEmpty(String input) {
+        return input == null || input.length() == 0;
+    }
+}
diff --git a/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteOpenHelper.java b/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteOpenHelper.java
new file mode 100644
index 0000000..33a87e1
--- /dev/null
+++ b/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteOpenHelper.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.arch.persistence.db.sqlcipher;
+
+import android.arch.persistence.db.SupportSQLiteDatabase;
+import android.arch.persistence.db.SupportSQLiteOpenHelper;
+import android.content.Context;
+import android.os.Build;
+import android.support.annotation.RequiresApi;
+
+import net.sqlcipher.DatabaseErrorHandler;
+import net.sqlcipher.database.SQLiteDatabase;
+import net.sqlcipher.database.SQLiteOpenHelper;
+
+class SqlcipherSQLiteOpenHelper implements SupportSQLiteOpenHelper {
+    private final OpenHelper mDelegate;
+
+    SqlcipherSQLiteOpenHelper(Context context, String name,
+                              Callback callback, String password) {
+        mDelegate = createDelegate(context, name, callback, password);
+    }
+
+    private OpenHelper createDelegate(Context context, String name, Callback callback, String password) {
+        final SqlcipherSQLiteDatabase[] dbRef = new SqlcipherSQLiteDatabase[1];
+        return new OpenHelper(context, name, dbRef, callback, password);
+    }
+
+    @Override
+    public String getDatabaseName() {
+        throw new RuntimeException("Stub!");
+    }
+
+    @Override
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN)
+    public void setWriteAheadLoggingEnabled(boolean enabled) {
+        throw new RuntimeException("Stub!");
+    }
+
+    @Override
+    public SupportSQLiteDatabase getWritableDatabase() {
+        return mDelegate.getWritableSupportDatabase();
+    }
+
+    @Override
+    public SupportSQLiteDatabase getReadableDatabase() {
+        return mDelegate.getReadableSupportDatabase();
+    }
+
+    @Override
+    public void close() {
+        mDelegate.close();
+    }
+
+    static class OpenHelper extends SQLiteOpenHelper {
+        private static boolean loadLibs = true;
+
+        /**
+         * This is used as an Object reference so that we can access the wrapped database inside
+         * the constructor. SQLiteOpenHelper requires the error handler to be passed in the
+         * constructor.
+         */
+        final SqlcipherSQLiteDatabase[] mDbRef;
+        final Callback mCallback;
+
+        final String mPassword;
+
+        OpenHelper(Context context, String name, final SqlcipherSQLiteDatabase[] dbRef,
+                   final Callback callback, final String password) {
+            super(context, name, null, callback.version, null,
+                    new DatabaseErrorHandler() {
+                        @Override
+                        public void onCorruption(SQLiteDatabase dbObj) {
+                            SqlcipherSQLiteDatabase db = dbRef[0];
+                            if (db != null) {
+                                callback.onCorruption(db);
+                            }
+                        }
+                    });
+
+            if (loadLibs) {
+                net.sqlcipher.database.SQLiteDatabase.loadLibs(context);
+                loadLibs = false; // only load once
+            }
+
+            mCallback = callback;
+            mDbRef = dbRef;
+
+            mPassword = password;
+        }
+
+        SupportSQLiteDatabase getWritableSupportDatabase() {
+            SQLiteDatabase db = super.getWritableDatabase(mPassword);
+            return getWrappedDb(db);
+        }
+
+        SupportSQLiteDatabase getReadableSupportDatabase() {
+            SQLiteDatabase db = super.getReadableDatabase(mPassword);
+            return getWrappedDb(db);
+        }
+
+        SqlcipherSQLiteDatabase getWrappedDb(SQLiteDatabase sqLiteDatabase) {
+            SqlcipherSQLiteDatabase dbRef = mDbRef[0];
+            if (dbRef == null) {
+                dbRef = new SqlcipherSQLiteDatabase(sqLiteDatabase);
+                mDbRef[0] = dbRef;
+            }
+            return mDbRef[0];
+        }
+
+        @Override
+        public void onCreate(SQLiteDatabase sqLiteDatabase) {
+            mCallback.onCreate(getWrappedDb(sqLiteDatabase));
+        }
+
+        @Override
+        public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
+            mCallback.onUpgrade(getWrappedDb(sqLiteDatabase), oldVersion, newVersion);
+        }
+
+
+        public void onConfigure(SQLiteDatabase db) {
+            mCallback.onConfigure(getWrappedDb(db));
+        }
+
+        public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            mCallback.onDowngrade(getWrappedDb(db), oldVersion, newVersion);
+        }
+
+        @Override
+        public void onOpen(SQLiteDatabase db) {
+            mCallback.onOpen(getWrappedDb(db));
+        }
+
+        @Override
+        public synchronized void close() {
+            super.close();
+            mDbRef[0] = null;
+        }
+    }
+}
diff --git a/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteOpenHelperFactory.java b/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteOpenHelperFactory.java
new file mode 100644
index 0000000..8c6c2ca
--- /dev/null
+++ b/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteOpenHelperFactory.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.arch.persistence.db.sqlcipher;
+
+import android.arch.persistence.db.SupportSQLiteOpenHelper;
+
+/**
+ * Implements {@link SupportSQLiteOpenHelper.Factory} using the SQLite implementation in the
+ * framework.
+ */
+@SuppressWarnings("unused")
+public final class SqlcipherSQLiteOpenHelperFactory implements SupportSQLiteOpenHelper.Factory {
+    private static final String DEFAULT_PWD = "Password_1234567";
+
+    @Override
+    public SupportSQLiteOpenHelper create(SupportSQLiteOpenHelper.Configuration configuration) {
+        return new SqlcipherSQLiteOpenHelper(
+                configuration.context, configuration.name, configuration.callback, DEFAULT_PWD);
+    }
+
+    public SupportSQLiteOpenHelper create(SupportSQLiteOpenHelper.Configuration configuration, String password) {
+        return new SqlcipherSQLiteOpenHelper(
+                configuration.context, configuration.name, configuration.callback, password);
+    }
+}
diff --git a/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteProgram.java b/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteProgram.java
new file mode 100644
index 0000000..ee68871
--- /dev/null
+++ b/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteProgram.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.arch.persistence.db.sqlcipher;
+
+import android.arch.persistence.db.SupportSQLiteProgram;
+
+import net.sqlcipher.database.SQLiteProgram;
+
+/**
+ * An wrapper around {@link SQLiteProgram} to implement {@link SupportSQLiteProgram} API.
+ */
+class SqlcipherSQLiteProgram implements SupportSQLiteProgram {
+    private final SQLiteProgram mDelegate;
+
+    SqlcipherSQLiteProgram(SQLiteProgram delegate) {
+        mDelegate = delegate;
+    }
+
+    @Override
+    public void bindNull(int index) {
+        mDelegate.bindNull(index);
+    }
+
+    @Override
+    public void bindLong(int index, long value) {
+        mDelegate.bindLong(index, value);
+    }
+
+    @Override
+    public void bindDouble(int index, double value) {
+        mDelegate.bindDouble(index, value);
+    }
+
+    @Override
+    public void bindString(int index, String value) {
+        mDelegate.bindString(index, value);
+    }
+
+    @Override
+    public void bindBlob(int index, byte[] value) {
+        mDelegate.bindBlob(index, value);
+    }
+
+    @Override
+    public void clearBindings() {
+        mDelegate.clearBindings();
+    }
+
+    @Override
+    public void close() throws Exception {
+        mDelegate.close();
+    }
+}
diff --git a/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteStatement.java b/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteStatement.java
new file mode 100644
index 0000000..ba96998
--- /dev/null
+++ b/sqlbrite-sqlcipher-integration/src/main/java/android/arch/persistence/db/sqlcipher/SqlcipherSQLiteStatement.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.arch.persistence.db.sqlcipher;
+
+import android.arch.persistence.db.SupportSQLiteStatement;
+
+import net.sqlcipher.database.SQLiteStatement;
+
+/**
+ * Delegates all calls to a {@link SQLiteStatement}.
+ */
+class SqlcipherSQLiteStatement implements SupportSQLiteStatement {
+    private final SQLiteStatement mDelegate;
+
+    /**
+     * Creates a wrapper around a framework {@link SQLiteStatement}.
+     *
+     * @param delegate The SQLiteStatement to delegate calls to.
+     */
+    SqlcipherSQLiteStatement(SQLiteStatement delegate) {
+        mDelegate = delegate;
+    }
+
+    @Override
+    public void bindNull(int index) {
+        mDelegate.bindNull(index);
+    }
+
+    @Override
+    public void bindLong(int index, long value) {
+        mDelegate.bindLong(index, value);
+    }
+
+    @Override
+    public void bindDouble(int index, double value) {
+        mDelegate.bindDouble(index, value);
+    }
+
+    @Override
+    public void bindString(int index, String value) {
+        mDelegate.bindString(index, value);
+    }
+
+    @Override
+    public void bindBlob(int index, byte[] value) {
+        mDelegate.bindBlob(index, value);
+    }
+
+    @Override
+    public void clearBindings() {
+        mDelegate.clearBindings();
+    }
+
+    @Override
+    public void execute() {
+        mDelegate.execute();
+    }
+
+    @Override
+    public int executeUpdateDelete() {
+        return mDelegate.executeUpdateDelete();
+    }
+
+    @Override
+    public long executeInsert() {
+        return mDelegate.executeInsert();
+    }
+
+    @Override
+    public long simpleQueryForLong() {
+        return mDelegate.simpleQueryForLong();
+    }
+
+    @Override
+    public String simpleQueryForString() {
+        return mDelegate.simpleQueryForString();
+    }
+
+    @Override
+    public void close() throws Exception {
+        mDelegate.close();
+    }
+}
diff --git a/sqlbrite-sqlcipher-integration/src/main/res/values/strings.xml b/sqlbrite-sqlcipher-integration/src/main/res/values/strings.xml
new file mode 100644
index 0000000..b22ea34
--- /dev/null
+++ b/sqlbrite-sqlcipher-integration/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">sqlbrite-sqlcipher-integration</string>
+</resources>
diff --git a/sqlbrite-sqlcipher-integration/src/test/java/com/example/sqlbrite_sqlcipher_integration/ExampleUnitTest.java b/sqlbrite-sqlcipher-integration/src/test/java/com/example/sqlbrite_sqlcipher_integration/ExampleUnitTest.java
new file mode 100644
index 0000000..980f99d
--- /dev/null
+++ b/sqlbrite-sqlcipher-integration/src/test/java/com/example/sqlbrite_sqlcipher_integration/ExampleUnitTest.java
@@ -0,0 +1,17 @@
+package com.example.sqlbrite_sqlcipher_integration;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * Example local unit test, which will execute on the development machine (host).
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
