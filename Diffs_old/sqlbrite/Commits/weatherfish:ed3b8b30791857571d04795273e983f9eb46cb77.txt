diff --git a/.travis.yml b/.travis.yml
index 6110668..1d89f29 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -4,9 +4,9 @@ android:
   components:
     - tools
     - platform-tools
-    - build-tools-24.0.0
+    - build-tools-25.0.0
     - extra-android-m2repository
-    - android-24
+    - android-25
     - sys-img-armeabi-v7a-android-23
 
 jdk:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 8fe2366..fa8125c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,15 @@
 Change Log
 =========
 
+Version 0.8.0 *(2016-10-21)*
+----------------------------
+
+ * New: A `Transformer<Query, Query>` can be supplied which is applied to each returned observable.
+ * New: `newNonExclusiveTransaction()` starts transactions in `IMMEDIATE` mode. See the platform
+   or SQLite documentation for more information.
+ * New: APIs for insert/update/delete which allow providing a compiled `SQLiteStatement`.
+
+
 Version 0.7.0 *(2016-07-06)*
 ----------------------------
 
diff --git a/README.md b/README.md
index c7a883e..650508e 100755
--- a/README.md
+++ b/README.md
@@ -148,7 +148,7 @@ Download
 --------
 
 ```groovy
-compile 'com.squareup.sqlbrite:sqlbrite:0.7.0'
+compile 'com.squareup.sqlbrite:sqlbrite:0.8.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/build.gradle b/build.gradle
index a64e0a1..acb457a 100644
--- a/build.gradle
+++ b/build.gradle
@@ -2,6 +2,7 @@ allprojects {
   buildscript {
     repositories {
       mavenCentral()
+      jcenter()
     }
   }
 
@@ -11,28 +12,29 @@ allprojects {
 }
 
 ext {
-  androidPlugin = 'com.android.tools.build:gradle:2.1.0'
-  compileSdkVersion = 24
-  buildToolsVersion = '24.0.0'
+  androidPlugin = 'com.android.tools.build:gradle:2.2.2'
+  compileSdkVersion = 25
+  buildToolsVersion = '25.0.0'
 
   // Android dependencies.
-  supportV4 = 'com.android.support:support-v4:24.0.0'
-  supportAnnotations = 'com.android.support:support-annotations:24.0.0'
+  supportV4 = 'com.android.support:support-v4:25.0.0'
+  supportAnnotations = 'com.android.support:support-annotations:25.0.0'
   supportTestRunner = 'com.android.support.test:runner:0.5'
 
   // Dagger dependencies.
-  dagger = 'com.google.dagger:dagger:2.4'
-  daggerCompiler = 'com.google.dagger:dagger-compiler:2.4'
+  dagger = 'com.google.dagger:dagger:2.7'
+  daggerCompiler = 'com.google.dagger:dagger-compiler:2.7'
 
   // Third-party dependencies.
-  butterKnife = 'com.jakewharton:butterknife:6.1.0'
-  timber = 'com.jakewharton.timber:timber:2.7.1'
-  autoValue = 'com.google.auto.value:auto-value:1.2-rc1'
-  autoValueParcel = 'com.ryanharter.auto.value:auto-value-parcel:0.2.0'
-  rxJava = 'io.reactivex:rxjava:1.1.0'
-  rxAndroid = 'io.reactivex:rxandroid:1.0.1'
-  rxBinding = 'com.jakewharton.rxbinding:rxbinding:0.2.0'
-  truth = 'com.google.truth:truth:0.27'
+  butterKnifeRuntime = 'com.jakewharton:butterknife:8.4.0'
+  butterKnifeCompiler = 'com.jakewharton:butterknife-compiler:8.4.0'
+  timber = 'com.jakewharton.timber:timber:4.3.1'
+  autoValue = 'com.google.auto.value:auto-value:1.3'
+  autoValueParcel = 'com.ryanharter.auto.value:auto-value-parcel:0.2.5'
+  rxJava = 'io.reactivex:rxjava:1.2.1'
+  rxAndroid = 'io.reactivex:rxandroid:1.2.1'
+  rxBinding = 'com.jakewharton.rxbinding:rxbinding:0.4.0'
+  truth = 'com.google.truth:truth:0.30'
   findbugsJsr305 = 'com.google.code.findbugs:jsr305:3.0.0'
   findbugsAnnotations = 'com.google.code.findbugs:annotations:3.0.0'
 }
diff --git a/gradle.properties b/gradle.properties
index f278d17..5d02ee4 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,5 +1,5 @@
 GROUP=com.squareup.sqlbrite
-VERSION_NAME=0.7.1-SNAPSHOT
+VERSION_NAME=0.8.1-SNAPSHOT
 
 POM_DESCRIPTION=A lightweight wrapper around SQLiteOpenHelper which introduces reactive stream semantics to SQL operations.
 
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 24c9a80..224f727 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.14-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
diff --git a/sample/build.gradle b/sample/build.gradle
index b4ebcc5..c68fad1 100644
--- a/sample/build.gradle
+++ b/sample/build.gradle
@@ -19,7 +19,8 @@ dependencies {
   apt rootProject.ext.daggerCompiler
 
   // Third-party dependencies.
-  compile rootProject.ext.butterKnife
+  compile rootProject.ext.butterKnifeRuntime
+  annotationProcessor rootProject.ext.butterKnifeCompiler
   compile rootProject.ext.timber
   compile rootProject.ext.rxJava
   compile rootProject.ext.rxAndroid
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
index 1526347..b64a2fe 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
@@ -28,8 +28,8 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ListView;
+import butterknife.BindView;
 import butterknife.ButterKnife;
-import butterknife.InjectView;
 import com.example.sqlbrite.todo.R;
 import com.example.sqlbrite.todo.TodoApp;
 import com.example.sqlbrite.todo.db.Db;
@@ -87,8 +87,8 @@ public static ItemsFragment newInstance(long listId) {
 
   @Inject BriteDatabase db;
 
-  @InjectView(android.R.id.list) ListView listView;
-  @InjectView(android.R.id.empty) View emptyView;
+  @BindView(android.R.id.list) ListView listView;
+  @BindView(android.R.id.empty) View emptyView;
 
   private Listener listener;
   private ItemsAdapter adapter;
@@ -132,7 +132,7 @@ private long getListId() {
   @Override
   public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
     super.onViewCreated(view, savedInstanceState);
-    ButterKnife.inject(this, view);
+    ButterKnife.bind(this, view);
     listView.setEmptyView(emptyView);
     listView.setAdapter(adapter);
 
diff --git a/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
index 750495d..09e1387 100644
--- a/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
@@ -27,8 +27,8 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ListView;
+import butterknife.BindView;
 import butterknife.ButterKnife;
-import butterknife.InjectView;
 import butterknife.OnItemClick;
 import com.example.sqlbrite.todo.R;
 import com.example.sqlbrite.todo.TodoApp;
@@ -52,8 +52,8 @@ static ListsFragment newInstance() {
 
   @Inject BriteDatabase db;
 
-  @InjectView(android.R.id.list) ListView listView;
-  @InjectView(android.R.id.empty) View emptyView;
+  @BindView(android.R.id.list) ListView listView;
+  @BindView(android.R.id.empty) View emptyView;
 
   private Listener listener;
   private ListsAdapter adapter;
@@ -93,7 +93,7 @@ static ListsFragment newInstance() {
   @Override
   public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
     super.onViewCreated(view, savedInstanceState);
-    ButterKnife.inject(this, view);
+    ButterKnife.bind(this, view);
     listView.setEmptyView(emptyView);
     listView.setAdapter(adapter);
   }
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java
index 80d24ce..39fddac 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java
@@ -22,12 +22,16 @@
 import android.net.Uri;
 import android.test.ProviderTestCase2;
 import android.test.mock.MockContentProvider;
+import com.squareup.sqlbrite.SqlBrite.Query;
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import rx.Observable;
+import rx.Observable.Transformer;
 import rx.Subscription;
 import rx.internal.util.RxRingBuffer;
+import rx.subjects.PublishSubject;
 import rx.subscriptions.Subscriptions;
 
 import static com.google.common.truth.Truth.assertThat;
@@ -42,6 +46,7 @@
   private final List<String> logs = new ArrayList<>();
   private final RecordingObserver o = new BlockingRecordingObserver();
   private final TestScheduler scheduler = new TestScheduler();
+  private final PublishSubject<Void> killSwitch = PublishSubject.create();
 
   private ContentResolver contentResolver;
   private BriteContentResolver db;
@@ -61,7 +66,12 @@ public BriteContentResolverTest() {
         logs.add(message);
       }
     };
-    db = new BriteContentResolver(contentResolver, logger, scheduler);
+    Transformer<Query, Query> queryTransformer = new Transformer<Query, Query>() {
+      @Override public Observable<Query> call(Observable<Query> queryObservable) {
+        return queryObservable.takeUntil(killSwitch);
+      }
+    };
+    db = new BriteContentResolver(contentResolver, logger, scheduler, queryTransformer);
 
     getProvider().init(getContext().getContentResolver());
   }
@@ -125,6 +135,17 @@ public void testUnsubscribeDoesNotTrigger() {
     assertThat(logs).isEmpty();
   }
 
+  public void testQueryNotNotifiedWhenQueryTransformerUnsubscribes() {
+    subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
+    o.assertCursor().isExhausted();
+
+    killSwitch.onNext(null);
+    o.assertIsCompleted();
+
+    contentResolver.insert(TABLE, values("key1", "val1"));
+    o.assertNoMoreEvents();
+  }
+
   public void testBackpressureSupportedWhenConsumerSlow() {
     contentResolver.insert(TABLE, values("key1", "val1"));
     o.doRequest(2);
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java
index d2e2b0d..d530d44 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java
@@ -15,12 +15,16 @@
  */
 package com.squareup.sqlbrite;
 
+import android.annotation.TargetApi;
 import android.content.ContentValues;
 import android.database.Cursor;
 import android.database.SQLException;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteException;
+import android.database.sqlite.SQLiteStatement;
+import android.os.Build;
 import android.support.test.InstrumentationRegistry;
+import android.support.test.filters.SdkSuppress;
 import android.support.test.runner.AndroidJUnit4;
 import com.squareup.sqlbrite.BriteDatabase.Transaction;
 import com.squareup.sqlbrite.TestDb.Employee;
@@ -28,7 +32,10 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.CountDownLatch;
 import org.junit.After;
 import org.junit.Before;
@@ -37,9 +44,11 @@
 import org.junit.rules.TemporaryFolder;
 import org.junit.runner.RunWith;
 import rx.Observable;
+import rx.Observable.Transformer;
 import rx.Subscription;
 import rx.functions.Action1;
 import rx.internal.util.RxRingBuffer;
+import rx.subjects.PublishSubject;
 
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE;
 import static com.google.common.truth.Truth.assertThat;
@@ -63,6 +72,7 @@
   private final List<String> logs = new ArrayList<>();
   private final RecordingObserver o = new RecordingObserver();
   private final TestScheduler scheduler = new TestScheduler();
+  private final PublishSubject<Void> killSwitch = PublishSubject.create();
 
   private TestDb helper;
   private SQLiteDatabase real;
@@ -80,7 +90,12 @@
         logs.add(message);
       }
     };
-    db = new BriteDatabase(helper, logger, scheduler);
+    Transformer<Query, Query> queryTransformer = new Transformer<Query, Query>() {
+      @Override public Observable<Query> call(Observable<Query> queryObservable) {
+        return queryObservable.takeUntil(killSwitch);
+      }
+    };
+    db = new BriteDatabase(helper, logger, scheduler, queryTransformer);
   }
 
   @After public void tearDown() {
@@ -205,6 +220,21 @@
     o.assertNoMoreEvents();
   }
 
+  @Test public void queryNotNotifiedWhenQueryTransformerUnsubscribes() {
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    killSwitch.onNext(null);
+    o.assertIsCompleted();
+
+    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    o.assertNoMoreEvents();
+  }
+
   @Test public void queryObservesUpdate() {
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
     o.assertCursor()
@@ -371,6 +401,45 @@
         .isExhausted();
   }
 
+  @Test public void executeSqlAndTriggerMultipleTables() {
+    db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(o);
+    o.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+    final RecordingObserver employeeObserver = new RecordingObserver();
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(employeeObserver);
+    employeeObserver.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    final Set<String> tablesToTrigger = Collections.unmodifiableSet(new HashSet<>(BOTH_TABLES));
+    db.executeAndTrigger(tablesToTrigger,
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+
+    o.assertCursor()
+        .hasRow("Zach", "Zach")
+        .isExhausted();
+    employeeObserver.assertCursor()
+        .hasRow("alice", "Zach")
+        .hasRow("bob", "Zach")
+        .hasRow("eve", "Zach")
+        .isExhausted();
+  }
+
+  @Test public void executeSqlAndTriggerWithNoTables() {
+    db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(o);
+    o.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+
+    db.executeAndTrigger(Collections.<String>emptySet(),
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+
+    o.assertNoMoreEvents();
+  }
+
   @Test public void executeSqlThrowsAndDoesNotTrigger() {
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
         .skip(1) // Skip initial
@@ -416,6 +485,338 @@
     o.assertNoMoreEvents();
   }
 
+  @Test public void executeSqlWithArgsAndTriggerWithMultipleTables() {
+    db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(o);
+    o.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+    final RecordingObserver employeeObserver = new RecordingObserver();
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(employeeObserver);
+    employeeObserver.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    final Set<String> tablesToTrigger = Collections.unmodifiableSet(new HashSet<>(BOTH_TABLES));
+    db.executeAndTrigger(tablesToTrigger,
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = ?", "Zach");
+
+    o.assertCursor()
+        .hasRow("Zach", "Zach")
+        .isExhausted();
+    employeeObserver.assertCursor()
+        .hasRow("alice", "Zach")
+        .hasRow("bob", "Zach")
+        .hasRow("eve", "Zach")
+        .isExhausted();
+  }
+
+  @Test public void executeSqlWithArgsAndTriggerWithNoTables() {
+    db.createQuery(BOTH_TABLES, SELECT_MANAGER_LIST).subscribe(o);
+    o.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+
+    db.executeAndTrigger(Collections.<String>emptySet(),
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = ?", "Zach");
+
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void executeInsertAndTrigger() {
+    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
+        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") "
+        + "VALUES ('Chad Chadson', 'chad')");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeInsert(TABLE_EMPLOYEE, statement);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .hasRow("chad", "Chad Chadson")
+        .isExhausted();
+  }
+
+  @Test public void executeInsertAndDontTrigger() {
+    SQLiteStatement statement = real.compileStatement("INSERT OR IGNORE INTO " + TABLE_EMPLOYEE + " ("
+        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") "
+        + "VALUES ('Alice Allison', 'alice')");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeInsert(TABLE_EMPLOYEE, statement);
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void executeInsertAndTriggerMultipleTables() {
+    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
+        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") "
+        + "VALUES ('Chad Chadson', 'chad')");
+
+    final RecordingObserver managerObserver = new RecordingObserver();
+    db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(managerObserver);
+    managerObserver.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    final Set<String> employeeAndManagerTables = Collections.unmodifiableSet(new HashSet<>(BOTH_TABLES));
+    db.executeInsert(employeeAndManagerTables, statement);
+
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .hasRow("chad", "Chad Chadson")
+        .isExhausted();
+    managerObserver.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+  }
+
+  @Test public void executeInsertAndTriggerNoTables() {
+    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
+        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") "
+        + "VALUES ('Chad Chadson', 'chad')");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeInsert(Collections.<String>emptySet(), statement);
+
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void executeInsertThrowsAndDoesNotTrigger() {
+    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
+        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") "
+        + "VALUES ('Alice Allison', 'alice')");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+        .skip(1) // Skip initial
+        .subscribe(o);
+
+    try {
+      db.executeInsert(TABLE_EMPLOYEE, statement);
+      fail();
+    } catch (SQLException ignored) {
+    }
+    o.assertNoMoreEvents();
+  }
+
+  @Test public void executeInsertWithArgsAndTrigger() {
+    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
+        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") VALUES (?, ?)");
+    statement.bindString(1, "Chad Chadson");
+    statement.bindString(2, "chad");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeInsert(TABLE_EMPLOYEE, statement);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .hasRow("chad", "Chad Chadson")
+        .isExhausted();
+  }
+
+  @Test public void executeInsertWithArgsThrowsAndDoesNotTrigger() {
+    SQLiteStatement statement = real.compileStatement("INSERT INTO " + TABLE_EMPLOYEE + " ("
+        + TestDb.EmployeeTable.NAME + ", " + TestDb.EmployeeTable.USERNAME + ") VALUES (?, ?)");
+    statement.bindString(1, "Alice Aliison");
+    statement.bindString(2, "alice");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+        .skip(1) // Skip initial
+        .subscribe(o);
+
+    try {
+      db.executeInsert(TABLE_EMPLOYEE, statement);
+      fail();
+    } catch (SQLException ignored) {
+    }
+    o.assertNoMoreEvents();
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+  @Test public void executeUpdateDeleteAndTrigger() {
+    SQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
+    o.assertCursor()
+        .hasRow("alice", "Zach")
+        .hasRow("bob", "Zach")
+        .hasRow("eve", "Zach")
+        .isExhausted();
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+  @Test public void executeUpdateDeleteAndDontTrigger() {
+    SQLiteStatement statement = real.compileStatement(""
+        + "UPDATE " + TABLE_EMPLOYEE
+        + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'"
+        + " WHERE " + TestDb.EmployeeTable.NAME + " = 'Rob'");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
+    o.assertNoMoreEvents();
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+  @Test public void executeUpdateDeleteAndTriggerWithMultipleTables() {
+    SQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+
+
+    final RecordingObserver managerObserver = new RecordingObserver();
+    db.createQuery(TABLE_MANAGER, SELECT_MANAGER_LIST).subscribe(managerObserver);
+    managerObserver.assertCursor()
+        .hasRow("Eve Evenson", "Alice Allison")
+        .isExhausted();
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    final Set<String> employeeAndManagerTables = Collections.unmodifiableSet(new HashSet<>(BOTH_TABLES));
+    db.executeUpdateDelete(employeeAndManagerTables, statement);
+
+    o.assertCursor()
+        .hasRow("alice", "Zach")
+        .hasRow("bob", "Zach")
+        .hasRow("eve", "Zach")
+        .isExhausted();
+    managerObserver.assertCursor()
+        .hasRow("Zach", "Zach")
+        .isExhausted();
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+  @Test public void executeUpdateDeleteAndTriggerWithNoTables() {
+    SQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = 'Zach'");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeUpdateDelete(Collections.<String>emptySet(), statement);
+
+    o.assertNoMoreEvents();
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+  @Test public void executeUpdateDeleteThrowsAndDoesNotTrigger() {
+    SQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.USERNAME + " = 'alice'");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+        .skip(1) // Skip initial
+        .subscribe(o);
+
+    try {
+      db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
+      fail();
+    } catch (SQLException ignored) {
+    }
+    o.assertNoMoreEvents();
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+  @Test public void executeUpdateDeleteWithArgsAndTrigger() {
+    SQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.NAME + " = ?");
+    statement.bindString(1, "Zach");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertCursor()
+        .hasRow("alice", "Alice Allison")
+        .hasRow("bob", "Bob Bobberson")
+        .hasRow("eve", "Eve Evenson")
+        .isExhausted();
+
+    db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
+    o.assertCursor()
+        .hasRow("alice", "Zach")
+        .hasRow("bob", "Zach")
+        .hasRow("eve", "Zach")
+        .isExhausted();
+  }
+
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
+  @Test public void executeUpdateDeleteWithArgsThrowsAndDoesNotTrigger() {
+    SQLiteStatement statement = real.compileStatement(
+        "UPDATE " + TABLE_EMPLOYEE + " SET " + TestDb.EmployeeTable.USERNAME + " = ?");
+    statement.bindString(1, "alice");
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
+        .skip(1) // Skip initial
+        .subscribe(o);
+
+    try {
+      db.executeUpdateDelete(TABLE_EMPLOYEE, statement);
+      fail();
+    } catch (SQLException ignored) {
+    }
+    o.assertNoMoreEvents();
+  }
+
   @Test public void transactionOnlyNotifiesOnce() {
     db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
     o.assertCursor()
@@ -520,8 +921,10 @@
   }
 
   @Test public void queryCreatedDuringTransactionThrows() {
+    //noinspection CheckResult
     db.newTransaction();
     try {
+      //noinspection CheckResult
       db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
       fail();
     } catch (IllegalStateException e) {
@@ -532,6 +935,7 @@
   @Test public void querySubscribedToDuringTransactionThrows() {
     Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
 
+    //noinspection CheckResult
     db.newTransaction();
     query.subscribe(o);
     o.assertErrorContains("Cannot subscribe to observable query in a transaction.");
@@ -542,6 +946,7 @@
 
     Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
 
+    //noinspection CheckResult
     db.newTransaction();
     query.subscribe(o);
     o.assertErrorContains("Cannot subscribe to observable query in a transaction.");
@@ -751,6 +1156,8 @@
     o.assertNoMoreEvents();
   }
 
+  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.HONEYCOMB)
   @Test public void nonExclusiveTransactionWorks() throws InterruptedException {
     final CountDownLatch transactionStarted = new CountDownLatch(1);
     final CountDownLatch transactionProceed = new CountDownLatch(1);
@@ -856,6 +1263,7 @@
 
   @Test public void badQueryThrows() {
     try {
+      //noinspection CheckResult
       db.query("SELECT * FROM missing");
       fail();
     } catch (SQLiteException e) {
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java
index 94b3648..c1deaf1 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java
@@ -69,6 +69,11 @@ public final void assertErrorContains(String expected) {
     assertThat(((Throwable) event).getMessage()).contains(expected);
   }
 
+  public final void assertIsCompleted() {
+    Object event = takeEvent();
+    assertThat(event).isEqualTo(COMPLETED);
+  }
+
   public void assertNoMoreEvents() {
     assertThat(events).isEmpty();
   }
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java
index a1e5b1a..6a5821a 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/SqlBriteTest.java
@@ -13,13 +13,40 @@
 import rx.observers.TestSubscriber;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
+@SuppressWarnings("CheckResult")
 public final class SqlBriteTest {
   private static final String FIRST_NAME = "first_name";
   private static final String LAST_NAME = "last_name";
   private static final String[] COLUMN_NAMES = { FIRST_NAME, LAST_NAME };
 
+  @Test public void builderDisallowsNull() {
+    SqlBrite.Builder builder = new SqlBrite.Builder();
+    try {
+      builder.logger(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("logger == null");
+    }
+    try {
+      builder.queryTransformer(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("queryTransformer == null");
+    }
+  }
+
+  @Test public void createDisallowsNull() {
+    try {
+      SqlBrite.create(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("logger == null");
+    }
+  }
+
   @Test public void asRowsEmpty() {
     MatrixCursor cursor = new MatrixCursor(COLUMN_NAMES);
     Query query = new CursorQuery(cursor);
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
index 193fc1b..10d62b2 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
@@ -27,6 +27,7 @@
 import java.util.Arrays;
 import rx.Observable;
 import rx.Observable.OnSubscribe;
+import rx.Observable.Transformer;
 import rx.Scheduler;
 import rx.Subscriber;
 import rx.functions.Action0;
@@ -47,13 +48,16 @@
   final ContentResolver contentResolver;
   private final Logger logger;
   private final Scheduler scheduler;
+  private final Transformer<Query, Query> queryTransformer;
 
   volatile boolean logging;
 
-  BriteContentResolver(ContentResolver contentResolver, Logger logger, Scheduler scheduler) {
+  BriteContentResolver(ContentResolver contentResolver, Logger logger, Scheduler scheduler,
+      Transformer<Query, Query> queryTransformer) {
     this.contentResolver = contentResolver;
     this.logger = logger;
     this.scheduler = scheduler;
+    this.queryTransformer = queryTransformer;
   }
 
   /** Control whether debug logging is enabled. */
@@ -124,8 +128,9 @@ public QueryObservable createQuery(@NonNull final Uri uri, @Nullable final Strin
     final Observable<Query> queryObservable = Observable.create(subscribe) //
         .onBackpressureLatest() // Guard against uncontrollable frequency of upstream emissions.
         .observeOn(scheduler) //
+        .compose(queryTransformer) // Apply the user's query transformer.
         .onBackpressureLatest(); // Guard against uncontrollable frequency of scheduler executions.
-    // TODO switch to .extend when non-@Experimental
+    // TODO switch to .to() when non-@Experimental
     return new QueryObservable(new OnSubscribe<Query>() {
       @Override public void call(Subscriber<? super Query> subscriber) {
         queryObservable.unsafeSubscribe(subscriber);
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
index dece5ff..58561b2 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
@@ -15,12 +15,13 @@
  */
 package com.squareup.sqlbrite;
 
-import android.annotation.TargetApi;
 import android.content.ContentValues;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
+import android.database.sqlite.SQLiteStatement;
 import android.database.sqlite.SQLiteTransactionListener;
+import android.os.Build;
 import android.support.annotation.CheckResult;
 import android.support.annotation.IntDef;
 import android.support.annotation.NonNull;
@@ -35,6 +36,7 @@
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import rx.Observable;
+import rx.Observable.Transformer;
 import rx.Scheduler;
 import rx.Subscriber;
 import rx.functions.Action0;
@@ -59,6 +61,7 @@
 public final class BriteDatabase implements Closeable {
   private final SQLiteOpenHelper helper;
   private final SqlBrite.Logger logger;
+  private final Transformer<Query, Query> queryTransformer;
 
   // Package-private to avoid synthetic accessor method for 'transaction' instance.
   final ThreadLocal<SqliteTransaction> transactions = new ThreadLocal<>();
@@ -116,10 +119,12 @@
   // Package-private to avoid synthetic accessor method for 'transaction' instance.
   volatile boolean logging;
 
-  BriteDatabase(SQLiteOpenHelper helper, SqlBrite.Logger logger, Scheduler scheduler) {
+  BriteDatabase(SQLiteOpenHelper helper, SqlBrite.Logger logger, Scheduler scheduler,
+      Transformer<Query, Query> queryTransformer) {
     this.helper = helper;
     this.logger = logger;
     this.scheduler = scheduler;
+    this.queryTransformer = queryTransformer;
   }
 
   /**
@@ -252,7 +257,6 @@ public Transaction newTransaction() {
    *
    * @see SQLiteDatabase#beginTransactionNonExclusive()
    */
-  @TargetApi(HONEYCOMB)
   @RequiresApi(HONEYCOMB)
   @CheckResult @NonNull
   public Transaction newNonExclusiveTransaction() {
@@ -356,9 +360,10 @@ private QueryObservable createQuery(Func1<Set<String>, Boolean> tableFilter, Str
         .onBackpressureLatest() // Guard against uncontrollable frequency of upstream emissions.
         .startWith(query) //
         .observeOn(scheduler) //
+        .compose(queryTransformer) // Apply the user's query transformer.
         .onBackpressureLatest() // Guard against uncontrollable frequency of scheduler executions.
         .doOnSubscribe(ensureNotInTransaction);
-    // TODO switch to .extend when non-@Experimental
+    // TODO switch to .to() when non-@Experimental
     return new QueryObservable(new Observable.OnSubscribe<Query>() {
       @Override public void call(Subscriber<? super Query> subscriber) {
         queryObservable.unsafeSubscribe(subscriber);
@@ -494,6 +499,7 @@ public int update(@NonNull String table, @NonNull ContentValues values,
    *
    * @see SQLiteDatabase#execSQL(String)
    */
+  // TODO @WorkerThread
   public void execute(String sql) {
     if (logging) log("EXECUTE\n  sql: %s", sql);
 
@@ -510,6 +516,7 @@ public void execute(String sql) {
    *
    * @see SQLiteDatabase#execSQL(String, Object[])
    */
+  // TODO @WorkerThread
   public void execute(String sql, Object... args) {
     if (logging) log("EXECUTE\n  sql: %s\n  args: %s", sql, Arrays.toString(args));
 
@@ -526,10 +533,21 @@ public void execute(String sql, Object... args) {
    *
    * @see SQLiteDatabase#execSQL(String)
    */
+  // TODO @WorkerThread
   public void executeAndTrigger(String table, String sql) {
+    executeAndTrigger(Collections.singleton(table), sql);
+  }
+
+  /**
+   * See {@link #executeAndTrigger(String, String)} for usage. This overload allows for triggering multiple tables.
+   *
+   * @see BriteDatabase#executeAndTrigger(String, String)
+   */
+  // TODO @WorkerThread
+  public void executeAndTrigger(Set<String> tables, String sql) {
     execute(sql);
 
-    sendTableTrigger(Collections.singleton(table));
+    sendTableTrigger(tables);
   }
 
   /**
@@ -541,10 +559,86 @@ public void executeAndTrigger(String table, String sql) {
    *
    * @see SQLiteDatabase#execSQL(String, Object[])
    */
+  // TODO @WorkerThread
   public void executeAndTrigger(String table, String sql, Object... args) {
+    executeAndTrigger(Collections.singleton(table), sql, args);
+  }
+
+  /**
+   * See {@link #executeAndTrigger(String, String, Object...)} for usage. This overload allows for triggering multiple tables.
+   *
+   * @see BriteDatabase#executeAndTrigger(String, String, Object...)
+   */
+  // TODO @WorkerThread
+  public void executeAndTrigger(Set<String> tables, String sql, Object... args) {
     execute(sql, args);
 
-    sendTableTrigger(Collections.singleton(table));
+    sendTableTrigger(tables);
+  }
+
+  /**
+   * Execute {@code statement}, if the the number of rows affected by execution of this SQL
+   * statement is of any importance to the caller - for example, UPDATE / DELETE SQL statements.
+   *
+   * @return the number of rows affected by this SQL statement execution.
+   * @throws android.database.SQLException If the SQL string is invalid
+   *
+   * @see SQLiteStatement#executeUpdateDelete()
+   */
+  // TODO @WorkerThread
+  @RequiresApi(Build.VERSION_CODES.HONEYCOMB)
+  public int executeUpdateDelete(String table, SQLiteStatement statement) {
+    return executeUpdateDelete(Collections.singleton(table), statement);
+  }
+
+  /**
+   * See {@link #executeUpdateDelete(String, SQLiteStatement)} for usage. This overload allows for triggering multiple tables.
+   *
+   * @see BriteDatabase#executeUpdateDelete(String, SQLiteStatement)
+   */
+  // TODO @WorkerThread
+  @RequiresApi(Build.VERSION_CODES.HONEYCOMB)
+  public int executeUpdateDelete(Set<String> tables, SQLiteStatement statement) {
+    if (logging) log("EXECUTE\n %s", statement);
+
+    int rows = statement.executeUpdateDelete();
+    if (rows > 0) {
+      // Only send a table trigger if rows were affected.
+      sendTableTrigger(tables);
+    }
+    return rows;
+  }
+
+  /**
+   * Execute {@code statement} and return the ID of the row inserted due to this call.
+   * The SQL statement should be an INSERT for this to be a useful call.
+   *
+   * @return the row ID of the last row inserted, if this insert is successful. -1 otherwise.
+   *
+   * @throws android.database.SQLException If the SQL string is invalid
+   *
+   * @see SQLiteStatement#executeInsert()
+   */
+  // TODO @WorkerThread
+  public long executeInsert(String table, SQLiteStatement statement) {
+    return executeInsert(Collections.singleton(table), statement);
+  }
+
+  /**
+   * See {@link #executeInsert(String, SQLiteStatement)} for usage. This overload allows for triggering multiple tables.
+   *
+   * @see BriteDatabase#executeInsert(String, SQLiteStatement)
+   */
+  // TODO @WorkerThread
+  public long executeInsert(Set<String> tables, SQLiteStatement statement) {
+    if (logging) log("EXECUTE\n %s", statement);
+
+    long rowId = statement.executeInsert();
+    if (rowId != -1) {
+      // Only send a table trigger if the insert was successful.
+      sendTableTrigger(tables);
+    }
+    return rowId;
   }
 
   /** An in-progress database transaction. */
@@ -619,7 +713,7 @@ public void executeAndTrigger(String table, String sql, Object... args) {
   public @interface ConflictAlgorithm {
   }
 
-  private static String indentSql(String sql) {
+  static String indentSql(String sql) {
     return sql.replace("\n", "\n       ");
   }
 
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
index 1728b67..16513f9 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
@@ -25,6 +25,7 @@
 import java.util.List;
 import rx.Observable;
 import rx.Observable.Operator;
+import rx.Observable.Transformer;
 import rx.Scheduler;
 import rx.Subscriber;
 import rx.functions.Func1;
@@ -34,24 +35,60 @@
  * the result of a query.
  */
 public final class SqlBrite {
-  @CheckResult @NonNull
+  static final Logger DEFAULT_LOGGER = new Logger() {
+    @Override public void log(String message) {
+      Log.d("SqlBrite", message);
+    }
+  };
+  static final Transformer<Query, Query> DEFAULT_TRANSFORMER = new Transformer<Query, Query>() {
+    @Override public Observable<Query> call(Observable<Query> queryObservable) {
+      return queryObservable;
+    }
+  };
+
+  public static final class Builder {
+    private Logger logger = DEFAULT_LOGGER;
+    private Transformer<Query, Query> queryTransformer = DEFAULT_TRANSFORMER;
+
+    @CheckResult
+    public Builder logger(@NonNull Logger logger) {
+      if (logger == null) throw new NullPointerException("logger == null");
+      this.logger = logger;
+      return this;
+    }
+
+    @CheckResult
+    public Builder queryTransformer(@NonNull Transformer<Query, Query> queryTransformer) {
+      if (queryTransformer == null) throw new NullPointerException("queryTransformer == null");
+      this.queryTransformer = queryTransformer;
+      return this;
+    }
+
+    @CheckResult
+    public SqlBrite build() {
+      return new SqlBrite(logger, queryTransformer);
+    }
+  }
+
+  /** @deprecated Use {@link Builder} to create instances. */
+  @Deprecated @CheckResult @NonNull
   public static SqlBrite create() {
-    return create(new Logger() {
-      @Override public void log(String message) {
-        Log.d("SqlBrite", message);
-      }
-    });
+    return new SqlBrite(DEFAULT_LOGGER, DEFAULT_TRANSFORMER);
   }
 
-  @CheckResult @NonNull
+  /** @deprecated Use {@link Builder} to create instances. */
+  @Deprecated @CheckResult @NonNull
   public static SqlBrite create(@NonNull Logger logger) {
-    return new SqlBrite(logger);
+    if (logger == null) throw new NullPointerException("logger == null");
+    return new SqlBrite(logger, DEFAULT_TRANSFORMER);
   }
 
   private final Logger logger;
+  private final Transformer<Query, Query> queryTransformer;
 
-  private SqlBrite(@NonNull Logger logger) {
+  private SqlBrite(@NonNull Logger logger, @NonNull Transformer<Query, Query> queryTransformer) {
     this.logger = logger;
+    this.queryTransformer = queryTransformer;
   }
 
   /**
@@ -67,7 +104,7 @@ private SqlBrite(@NonNull Logger logger) {
    */
   @CheckResult @NonNull public BriteDatabase wrapDatabaseHelper(@NonNull SQLiteOpenHelper helper,
       @NonNull Scheduler scheduler) {
-    return new BriteDatabase(helper, logger, scheduler);
+    return new BriteDatabase(helper, logger, scheduler, queryTransformer);
   }
 
   /**
@@ -78,7 +115,7 @@ private SqlBrite(@NonNull Logger logger) {
    */
   @CheckResult @NonNull public BriteContentResolver wrapContentProvider(
       @NonNull ContentResolver contentResolver, @NonNull Scheduler scheduler) {
-    return new BriteContentResolver(contentResolver, logger, scheduler);
+    return new BriteContentResolver(contentResolver, logger, scheduler, queryTransformer);
   }
 
   /** An executable query. */
