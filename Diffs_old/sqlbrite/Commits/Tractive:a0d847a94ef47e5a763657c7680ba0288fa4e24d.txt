diff --git a/CHANGELOG.md b/CHANGELOG.md
index fd58ead..878d8e0 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,8 +1,32 @@
 Change Log
 =========
 
-Version 0.5.0 *(In Development)*
---------------------------------
+Version 0.6.0 *(2016-02-17)*
+----------------------------
+
+ * New: Require a `Scheduler` when wrapping a database or content provider which will be used when
+   sending query triggers. This allows the query to be run in subsequent operators without needing an
+   additional `observeOn`. It also eliminates the need to use `subscribeOn` since the supplied
+   `Scheduler` will be used for all emissions (similar to RxJava's `timer`, `interval`, etc.).
+
+   This also corrects a potential violation of the RxJava contract and potential source of bugs in that
+   all triggers will occur on the supplied `Scheduler`. Previously the initial value would trigger
+   synchronously (on the subscribing thread) while subsequent ones trigger on the thread which
+   performed the transaction. The new behavior puts the initial trigger on the same thread as all
+   subsequent triggers and also does not force transactions to block while sending triggers.
+
+
+Version 0.5.1 *(2016-02-03)*
+----------------------------
+
+ * New: Query logs now contain timing information on how long they took to execute. This only covers
+   the time until a `Cursor` was made available, not object mapping or delivering to subscribers.
+ * Fix: Switch query logging to happen when `Query.run` is called, not when a query is triggered.
+ * Fix: Check for subscribing inside a transaction using a more accurate primitive.
+
+
+Version 0.5.0 *(2015-12-09)*
+----------------------------
 
  * New: Expose `mapToOne`, `mapToOneOrDefault`, and `mapToList` as static methods on `Query`. These
    mirror the behavior of the methods of the same name on `QueryObservable` but can be used later in
diff --git a/README.md b/README.md
index 4571e72..17eb4a5 100755
--- a/README.md
+++ b/README.md
@@ -21,12 +21,16 @@ Create a `SqlBrite` instance which is an adapter for the library functionality.
 SqlBrite sqlBrite = SqlBrite.create();
 ```
 
-Pass a `SQLiteOpenHelper` instance to create a `BriteDatabase`.
+Pass a `SQLiteOpenHelper` instance and a `Scheduler` to create a `BriteDatabase`.
 
 ```java
-BriteDatabase db = sqlBrite.wrapDatabaseHelper(openHelper);
+BriteDatabase db = sqlBrite.wrapDatabaseHelper(openHelper, Schedulers.io());
 ```
 
+A `Scheduler` is required for a few reasons, but the most important is that query notifications can
+trigger on the thread of your choice. The query can then be run without blocking the main thread or
+the thread which caused the trigger.
+
 The `BriteDatabase.createQuery` method is similar to `SQLiteDatabase.rawQuery` except it takes an
 additional parameter of table(s) on which to listen for changes. Subscribe to the returned
 `Observable<Query>` which will immediately notify with a `Query` to run.
@@ -142,7 +146,7 @@ of updates to tables such that you can update queries as soon as data changes.
 This library is not an ORM. It is not a type-safe query mechanism. It won't serialize the same POJOs
 you use for Gson. It's not going to perform database migrations for you.
 
-A day may come when some of those features are added, but it is not this day.
+Some of these features are offered by [SQLDelight][sqldelight] which can be used with SQLBrite.
 
 
 
@@ -150,7 +154,7 @@ Download
 --------
 
 ```groovy
-compile 'com.squareup.sqlbrite:sqlbrite:0.5.0'
+compile 'com.squareup.sqlbrite:sqlbrite:0.6.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -179,3 +183,4 @@ License
 
 
  [snap]: https://oss.sonatype.org/content/repositories/snapshots/
+ [sqldelight]: https://github.com/square/sqldelight/
diff --git a/RELEASING.md b/RELEASING.md
index c86a089..591e3a8 100644
--- a/RELEASING.md
+++ b/RELEASING.md
@@ -5,9 +5,11 @@ Releasing
  2. Update the `CHANGELOG.md` for the impending release.
  3. Update the `README.md` with the new version.
  4. `git commit -am "Prepare for release X.Y.Z."` (where X.Y.Z is the new version)
- 5. `git tag -a X.Y.X -m "Version X.Y.Z"` (where X.Y.Z is the new version)
- 6. `./gradlew clean uploadArchives`
- 7. Update the `gradle.properties` to the next SNAPSHOT version.
- 8. `git commit -am "Prepare next development version."`
- 9. `git push && git push --tags`
- 10. Visit [Sonatype Nexus](https://oss.sonatype.org/) and promote the artifact.
+ 5. `./gradlew clean uploadArchives`.
+ 6. Visit [Sonatype Nexus](https://oss.sonatype.org/) and promote the artifact.
+ 7. `git tag -a X.Y.X -m "Version X.Y.Z"` (where X.Y.Z is the new version)
+ 8. Update the `gradle.properties` to the next SNAPSHOT version.
+ 9. `git commit -am "Prepare next development version."`
+ 10. `git push && git push --tags`
+
+If step 5 or 6 fails, drop the Sonatype repo, fix the problem, commit, and start again at step 5.
diff --git a/gradle.properties b/gradle.properties
index b34fa99..69bc461 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,5 +1,5 @@
 GROUP=com.squareup.sqlbrite
-VERSION_NAME=0.5.1-SNAPSHOT
+VERSION_NAME=0.6.1-SNAPSHOT
 
 POM_DESCRIPTION=A lightweight wrapper around SQLiteOpenHelper which introduces reactive stream semantics to SQL operations.
 
diff --git a/sqlbrite-sample/build.gradle b/sample/build.gradle
similarity index 100%
rename from sqlbrite-sample/build.gradle
rename to sample/build.gradle
diff --git a/sqlbrite-sample/debug.keystore b/sample/debug.keystore
similarity index 100%
rename from sqlbrite-sample/debug.keystore
rename to sample/debug.keystore
diff --git a/sqlbrite-sample/src/main/AndroidManifest.xml b/sample/src/main/AndroidManifest.xml
similarity index 100%
rename from sqlbrite-sample/src/main/AndroidManifest.xml
rename to sample/src/main/AndroidManifest.xml
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/TodoApp.java b/sample/src/main/java/com/example/sqlbrite/todo/TodoApp.java
similarity index 100%
rename from sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/TodoApp.java
rename to sample/src/main/java/com/example/sqlbrite/todo/TodoApp.java
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/TodoModule.java b/sample/src/main/java/com/example/sqlbrite/todo/TodoModule.java
similarity index 100%
rename from sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/TodoModule.java
rename to sample/src/main/java/com/example/sqlbrite/todo/TodoModule.java
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/Db.java b/sample/src/main/java/com/example/sqlbrite/todo/db/Db.java
similarity index 100%
rename from sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/Db.java
rename to sample/src/main/java/com/example/sqlbrite/todo/db/Db.java
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java b/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
similarity index 90%
rename from sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
rename to sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
index c8a346f..b5ea4fa 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/db/DbModule.java
@@ -22,6 +22,7 @@
 import dagger.Module;
 import dagger.Provides;
 import javax.inject.Singleton;
+import rx.schedulers.Schedulers;
 import timber.log.Timber;
 
 @Module(complete = false, library = true)
@@ -39,6 +40,8 @@
   }
 
   @Provides @Singleton BriteDatabase provideDatabase(SqlBrite sqlBrite, SQLiteOpenHelper helper) {
-    return sqlBrite.wrapDatabaseHelper(helper);
+    BriteDatabase db = sqlBrite.wrapDatabaseHelper(helper, Schedulers.io());
+    db.setLoggingEnabled(true);
+    return db;
   }
 }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/DbOpenHelper.java b/sample/src/main/java/com/example/sqlbrite/todo/db/DbOpenHelper.java
similarity index 100%
rename from sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/DbOpenHelper.java
rename to sample/src/main/java/com/example/sqlbrite/todo/db/DbOpenHelper.java
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java b/sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
similarity index 100%
rename from sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
rename to sample/src/main/java/com/example/sqlbrite/todo/db/TodoItem.java
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java b/sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java
similarity index 100%
rename from sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java
rename to sample/src/main/java/com/example/sqlbrite/todo/db/TodoList.java
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsAdapter.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsAdapter.java
similarity index 100%
rename from sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsAdapter.java
rename to sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsAdapter.java
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
similarity index 98%
rename from sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
rename to sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
index 113d3af..c6c350a 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/ItemsFragment.java
@@ -187,7 +187,6 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
             return listName + " (" + itemCount + ")";
           }
         })
-            .subscribeOn(Schedulers.io())
             .observeOn(AndroidSchedulers.mainThread())
             .subscribe(new Action1<String>() {
               @Override public void call(String title) {
@@ -197,7 +196,6 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
 
     subscriptions.add(db.createQuery(TodoItem.TABLE, LIST_QUERY, listId)
         .mapToList(TodoItem.MAPPER)
-        .subscribeOn(Schedulers.io())
         .observeOn(AndroidSchedulers.mainThread())
         .subscribe(adapter));
   }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsAdapter.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsAdapter.java
similarity index 100%
rename from sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsAdapter.java
rename to sample/src/main/java/com/example/sqlbrite/todo/ui/ListsAdapter.java
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
similarity index 98%
rename from sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
rename to sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
index feebb0d..ef1bb2d 100644
--- a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
+++ b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsFragment.java
@@ -36,7 +36,6 @@
 import javax.inject.Inject;
 import rx.Subscription;
 import rx.android.schedulers.AndroidSchedulers;
-import rx.schedulers.Schedulers;
 
 import static android.support.v4.view.MenuItemCompat.SHOW_AS_ACTION_IF_ROOM;
 import static android.support.v4.view.MenuItemCompat.SHOW_AS_ACTION_WITH_TEXT;
@@ -110,7 +109,6 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
 
     subscription = db.createQuery(ListsItem.TABLES, ListsItem.QUERY)
         .mapToList(ListsItem.MAPPER)
-        .subscribeOn(Schedulers.io())
         .observeOn(AndroidSchedulers.mainThread())
         .subscribe(adapter);
   }
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
similarity index 100%
rename from sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
rename to sample/src/main/java/com/example/sqlbrite/todo/ui/ListsItem.java
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/MainActivity.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/MainActivity.java
similarity index 100%
rename from sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/MainActivity.java
rename to sample/src/main/java/com/example/sqlbrite/todo/ui/MainActivity.java
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
similarity index 100%
rename from sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
rename to sample/src/main/java/com/example/sqlbrite/todo/ui/NewItemFragment.java
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
similarity index 100%
rename from sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
rename to sample/src/main/java/com/example/sqlbrite/todo/ui/NewListFragment.java
diff --git a/sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/UiModule.java b/sample/src/main/java/com/example/sqlbrite/todo/ui/UiModule.java
similarity index 100%
rename from sqlbrite-sample/src/main/java/com/example/sqlbrite/todo/ui/UiModule.java
rename to sample/src/main/java/com/example/sqlbrite/todo/ui/UiModule.java
diff --git a/sqlbrite-sample/src/main/res/anim/slide_in_left.xml b/sample/src/main/res/anim/slide_in_left.xml
similarity index 100%
rename from sqlbrite-sample/src/main/res/anim/slide_in_left.xml
rename to sample/src/main/res/anim/slide_in_left.xml
diff --git a/sqlbrite-sample/src/main/res/anim/slide_in_right.xml b/sample/src/main/res/anim/slide_in_right.xml
similarity index 100%
rename from sqlbrite-sample/src/main/res/anim/slide_in_right.xml
rename to sample/src/main/res/anim/slide_in_right.xml
diff --git a/sqlbrite-sample/src/main/res/anim/slide_out_left.xml b/sample/src/main/res/anim/slide_out_left.xml
similarity index 100%
rename from sqlbrite-sample/src/main/res/anim/slide_out_left.xml
rename to sample/src/main/res/anim/slide_out_left.xml
diff --git a/sqlbrite-sample/src/main/res/anim/slide_out_right.xml b/sample/src/main/res/anim/slide_out_right.xml
similarity index 100%
rename from sqlbrite-sample/src/main/res/anim/slide_out_right.xml
rename to sample/src/main/res/anim/slide_out_right.xml
diff --git a/sqlbrite-sample/src/main/res/drawable-hdpi/ic_launcher.png b/sample/src/main/res/drawable-hdpi/ic_launcher.png
similarity index 100%
rename from sqlbrite-sample/src/main/res/drawable-hdpi/ic_launcher.png
rename to sample/src/main/res/drawable-hdpi/ic_launcher.png
diff --git a/sqlbrite-sample/src/main/res/drawable-xhdpi/ic_launcher.png b/sample/src/main/res/drawable-xhdpi/ic_launcher.png
similarity index 100%
rename from sqlbrite-sample/src/main/res/drawable-xhdpi/ic_launcher.png
rename to sample/src/main/res/drawable-xhdpi/ic_launcher.png
diff --git a/sqlbrite-sample/src/main/res/drawable-xxhdpi/ic_launcher.png b/sample/src/main/res/drawable-xxhdpi/ic_launcher.png
similarity index 100%
rename from sqlbrite-sample/src/main/res/drawable-xxhdpi/ic_launcher.png
rename to sample/src/main/res/drawable-xxhdpi/ic_launcher.png
diff --git a/sqlbrite-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png b/sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
similarity index 100%
rename from sqlbrite-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
rename to sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
diff --git a/sqlbrite-sample/src/main/res/layout/items.xml b/sample/src/main/res/layout/items.xml
similarity index 100%
rename from sqlbrite-sample/src/main/res/layout/items.xml
rename to sample/src/main/res/layout/items.xml
diff --git a/sqlbrite-sample/src/main/res/layout/lists.xml b/sample/src/main/res/layout/lists.xml
similarity index 100%
rename from sqlbrite-sample/src/main/res/layout/lists.xml
rename to sample/src/main/res/layout/lists.xml
diff --git a/sqlbrite-sample/src/main/res/layout/new_item.xml b/sample/src/main/res/layout/new_item.xml
similarity index 100%
rename from sqlbrite-sample/src/main/res/layout/new_item.xml
rename to sample/src/main/res/layout/new_item.xml
diff --git a/sqlbrite-sample/src/main/res/layout/new_list.xml b/sample/src/main/res/layout/new_list.xml
similarity index 100%
rename from sqlbrite-sample/src/main/res/layout/new_list.xml
rename to sample/src/main/res/layout/new_list.xml
diff --git a/sqlbrite-sample/src/main/res/values/strings.xml b/sample/src/main/res/values/strings.xml
similarity index 100%
rename from sqlbrite-sample/src/main/res/values/strings.xml
rename to sample/src/main/res/values/strings.xml
diff --git a/settings.gradle b/settings.gradle
index 1ba2cf3..4254ba9 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,4 +1,4 @@
 include ':sqlbrite'
-include ':sqlbrite-sample'
+include ':sample'
 
 rootProject.name = 'sqlbrite-root'
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BlockingRecordingObserver.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BlockingRecordingObserver.java
new file mode 100644
index 0000000..5569489
--- /dev/null
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BlockingRecordingObserver.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.sqlbrite;
+
+import static com.google.common.truth.Truth.assertThat;
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+final class BlockingRecordingObserver extends RecordingObserver {
+  protected Object takeEvent() {
+    try {
+      Object item = events.pollFirst(1, SECONDS);
+      if (item == null) {
+        throw new AssertionError("No items.");
+      }
+      return item;
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override public void assertNoMoreEvents() {
+    try {
+      assertThat(events.pollFirst(1, SECONDS)).isNull();
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java
index f7826a9..2c3ea2e 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteContentResolverTest.java
@@ -39,7 +39,8 @@
   private static final String VALUE = "test_value";
 
   private final List<String> logs = new ArrayList<>();
-  private final RecordingObserver o = new RecordingObserver();
+  private final RecordingObserver o = new BlockingRecordingObserver();
+  private final TestScheduler scheduler = new TestScheduler();
 
   private ContentResolver contentResolver;
   private BriteContentResolver db;
@@ -59,7 +60,7 @@ public BriteContentResolverTest() {
         logs.add(message);
       }
     };
-    db = new BriteContentResolver(contentResolver, logger);
+    db = new BriteContentResolver(contentResolver, logger, scheduler);
 
     getProvider().init(getContext().getContentResolver());
   }
@@ -169,6 +170,20 @@ public void testBackpressureSupported() {
     o.assertNoMoreEvents();
   }
 
+  public void testInitialValueAndTriggerUsesScheduler() {
+    scheduler.runTasksImmediately(false);
+
+    subscription = db.createQuery(TABLE, null, null, null, null, false).subscribe(o);
+    o.assertNoMoreEvents();
+    scheduler.triggerActions();
+    o.assertCursor().isExhausted();
+
+    contentResolver.insert(TABLE, values("key1", "val1"));
+    o.assertNoMoreEvents();
+    scheduler.triggerActions();
+    o.assertCursor().hasRow("key1", "val1").isExhausted();
+  }
+
   private ContentValues values(String key, String value) {
     ContentValues result = new ContentValues();
     result.put(KEY, key);
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java
index b41b52c..5997775 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/BriteDatabaseTest.java
@@ -22,7 +22,6 @@
 import android.database.sqlite.SQLiteException;
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
-import com.google.common.collect.Range;
 import com.squareup.sqlbrite.BriteDatabase.Transaction;
 import com.squareup.sqlbrite.TestDb.Employee;
 import java.io.Closeable;
@@ -31,7 +30,6 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -60,6 +58,7 @@
 public final class BriteDatabaseTest {
   private final List<String> logs = new ArrayList<>();
   private final RecordingObserver o = new RecordingObserver();
+  private final TestScheduler scheduler = new TestScheduler();
 
   private TestDb helper;
   private SQLiteDatabase real;
@@ -74,7 +73,7 @@
         logs.add(message);
       }
     };
-    db = new BriteDatabase(helper, logger);
+    db = new BriteDatabase(helper, logger, scheduler);
   }
 
   @After public void tearDown() {
@@ -93,7 +92,7 @@
     assertThat(logs).isEmpty();
   }
 
-  @Test public void closePropagates() throws IOException {
+  @Test public void closePropagates() {
     db.close();
     assertThat(real.isOpen()).isFalse();
   }
@@ -164,42 +163,27 @@
         .isExhausted();
   }
 
-  @Test public void queryObservesInsertDebounced() {
-    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES)
-        .debounce(500, MILLISECONDS)
-        .subscribe(o);
+  @Test public void queryInitialValueAndTriggerUsesScheduler() {
+    scheduler.runTasksImmediately(false);
+
+    db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES).subscribe(o);
+    o.assertNoMoreEvents();
+    scheduler.triggerActions();
     o.assertCursor()
         .hasRow("alice", "Alice Allison")
         .hasRow("bob", "Bob Bobberson")
         .hasRow("eve", "Eve Evenson")
         .isExhausted();
 
-    long startNs = System.nanoTime();
-
-    // Shotgun 10 inserts which will cause 10 triggers. DO NOT DO THIS IRL! Use a transaction!
-    for (int i = 0; i < 10; i++) {
-      db.insert(TABLE_EMPLOYEE, employee("john" + i, "John Johnson " + i));
-    }
-
-    // Only one trigger should have been observed.
+    db.insert(TABLE_EMPLOYEE, employee("john", "John Johnson"));
+    o.assertNoMoreEvents();
+    scheduler.triggerActions();
     o.assertCursor()
         .hasRow("alice", "Alice Allison")
         .hasRow("bob", "Bob Bobberson")
         .hasRow("eve", "Eve Evenson")
-        .hasRow("john0", "John Johnson 0")
-        .hasRow("john1", "John Johnson 1")
-        .hasRow("john2", "John Johnson 2")
-        .hasRow("john3", "John Johnson 3")
-        .hasRow("john4", "John Johnson 4")
-        .hasRow("john5", "John Johnson 5")
-        .hasRow("john6", "John Johnson 6")
-        .hasRow("john7", "John Johnson 7")
-        .hasRow("john8", "John Johnson 8")
-        .hasRow("john9", "John Johnson 9")
+        .hasRow("john", "John Johnson")
         .isExhausted();
-
-    long tookNs = System.nanoTime() - startNs;
-    assertThat(TimeUnit.NANOSECONDS.toMillis(tookNs)).isIn(Range.atLeast(500L));
   }
 
   @Test public void queryNotNotifiedWhenInsertFails() {
@@ -546,6 +530,16 @@
     o.assertErrorContains("Cannot subscribe to observable query in a transaction.");
   }
 
+  @Test public void querySubscribedToDuringTransactionThrowsWithBackpressure() {
+    o.doRequest(0);
+
+    Observable<Query> query = db.createQuery(TABLE_EMPLOYEE, SELECT_EMPLOYEES);
+
+    db.newTransaction();
+    query.subscribe(o);
+    o.assertErrorContains("Cannot subscribe to observable query in a transaction.");
+  }
+
   @Test public void callingEndMultipleTimesThrows() {
     Transaction transaction = db.newTransaction();
     transaction.end();
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java
index 159b8f7..70226a6 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/QueryTest.java
@@ -24,6 +24,7 @@
 import org.junit.Test;
 import rx.functions.Func1;
 import rx.observables.BlockingObservable;
+import rx.schedulers.Schedulers;
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.squareup.sqlbrite.TestDb.SELECT_EMPLOYEES;
@@ -35,7 +36,7 @@
   @Before public void setUp() {
     SqlBrite sqlBrite = SqlBrite.create();
     TestDb helper = new TestDb(InstrumentationRegistry.getContext());
-    db = sqlBrite.wrapDatabaseHelper(helper);
+    db = sqlBrite.wrapDatabaseHelper(helper, Schedulers.immediate());
   }
 
   @Test public void mapToOne() {
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java
index e670477..94b3648 100644
--- a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/RecordingObserver.java
@@ -23,63 +23,54 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.squareup.sqlbrite.SqlBrite.Query;
-import static java.util.concurrent.TimeUnit.SECONDS;
 
-final class RecordingObserver extends Subscriber<Query> {
+class RecordingObserver extends Subscriber<Query> {
   private static final Object COMPLETED = "<completed>";
   private static final String TAG = RecordingObserver.class.getSimpleName();
 
-  private final BlockingDeque<Object> events = new LinkedBlockingDeque<>();
+  final BlockingDeque<Object> events = new LinkedBlockingDeque<>();
 
-  @Override public void onCompleted() {
+  @Override public final void onCompleted() {
     Log.d(TAG, "onCompleted");
     events.add(COMPLETED);
   }
 
-  @Override public void onError(Throwable e) {
+  @Override public final void onError(Throwable e) {
     Log.d(TAG, "onError " + e.getClass().getSimpleName() + " " + e.getMessage());
     events.add(e);
   }
 
-  @Override public void onNext(Query value) {
+  @Override public final void onNext(Query value) {
     Log.d(TAG, "onNext " + value);
     events.add(value.run());
   }
 
-  public void doRequest(long amount) {
+  public final void doRequest(long amount) {
     request(amount);
   }
 
-  private Object takeEvent() {
-    try {
-      Object item = events.pollFirst(1, SECONDS);
-      if (item == null) {
-        throw new AssertionError("Timeout expired waiting for item.");
-      }
-      return item;
-    } catch (InterruptedException e) {
-      throw new RuntimeException(e);
+  protected Object takeEvent() {
+    Object item = events.removeFirst();
+    if (item == null) {
+      throw new AssertionError("No items.");
     }
+    return item;
   }
 
-  public CursorAssert assertCursor() {
+  public final CursorAssert assertCursor() {
     Object event = takeEvent();
     assertThat(event).isInstanceOf(Cursor.class);
     return new CursorAssert((Cursor) event);
   }
 
-  public void assertErrorContains(String expected) {
+  public final void assertErrorContains(String expected) {
     Object event = takeEvent();
     assertThat(event).isInstanceOf(Throwable.class);
     assertThat(((Throwable) event).getMessage()).contains(expected);
   }
 
   public void assertNoMoreEvents() {
-    try {
-      assertThat(events.pollFirst(1, SECONDS)).isNull();
-    } catch (InterruptedException e) {
-      throw new RuntimeException(e);
-    }
+    assertThat(events).isEmpty();
   }
 
   static final class CursorAssert {
diff --git a/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestScheduler.java b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestScheduler.java
new file mode 100644
index 0000000..04aee49
--- /dev/null
+++ b/sqlbrite/src/androidTest/java/com/squareup/sqlbrite/TestScheduler.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.sqlbrite;
+
+import java.util.concurrent.TimeUnit;
+import rx.Scheduler;
+import rx.Subscription;
+import rx.functions.Action0;
+
+final class TestScheduler extends Scheduler {
+  private final rx.schedulers.TestScheduler delegate = new rx.schedulers.TestScheduler();
+  private boolean runTasksImmediately = true;
+
+  public void runTasksImmediately(boolean runTasksImmediately) {
+    this.runTasksImmediately = runTasksImmediately;
+  }
+
+  public void triggerActions() {
+    delegate.triggerActions();
+  }
+
+  @Override public Worker createWorker() {
+    return new TestWorker();
+  }
+
+  class TestWorker extends Worker {
+    private final Worker delegateWorker = delegate.createWorker();
+
+    @Override public Subscription schedule(Action0 action) {
+      Subscription subscription = delegateWorker.schedule(action);
+      if (runTasksImmediately) {
+        triggerActions();
+      }
+      return subscription;
+    }
+
+    @Override public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
+      Subscription subscription = delegateWorker.schedule(action, delayTime, unit);
+      if (runTasksImmediately) {
+        triggerActions();
+      }
+      return subscription;
+    }
+
+    @Override public void unsubscribe() {
+      delegateWorker.unsubscribe();
+    }
+
+    @Override public boolean isUnsubscribed() {
+      return delegateWorker.isUnsubscribed();
+    }
+  }
+}
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
index 9e314e8..931999e 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteContentResolver.java
@@ -27,28 +27,33 @@
 import java.util.Arrays;
 import rx.Observable;
 import rx.Observable.OnSubscribe;
+import rx.Scheduler;
 import rx.Subscriber;
 import rx.functions.Action0;
 import rx.subscriptions.Subscriptions;
 
 import static com.squareup.sqlbrite.SqlBrite.Logger;
 import static com.squareup.sqlbrite.SqlBrite.Query;
+import static java.lang.System.nanoTime;
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
 /**
  * A lightweight wrapper around {@link ContentResolver} which allows for continuously observing
  * the result of a query. Create using a {@link SqlBrite} instance.
  */
 public final class BriteContentResolver {
-  private final Handler contentObserverHandler = new Handler(Looper.getMainLooper());
+  final Handler contentObserverHandler = new Handler(Looper.getMainLooper());
 
-  private final ContentResolver contentResolver;
+  final ContentResolver contentResolver;
   private final Logger logger;
+  private final Scheduler scheduler;
 
-  private volatile boolean logging;
+  volatile boolean logging;
 
-  BriteContentResolver(@NonNull ContentResolver contentResolver, @NonNull Logger logger) {
+  BriteContentResolver(ContentResolver contentResolver, Logger logger, Scheduler scheduler) {
     this.contentResolver = contentResolver;
     this.logger = logger;
+    this.scheduler = scheduler;
   }
 
   /** Control whether debug logging is enabled. */
@@ -65,6 +70,11 @@ public void setLoggingEnabled(boolean enabled) {
    * notifications for when the supplied {@code uri}'s data changes. Unsubscribe when you no longer
    * want updates to a query.
    * <p>
+   * Since content resolver triggers are inherently asynchronous, items emitted from the returned
+   * observable use the {@link Scheduler} supplied to {@link SqlBrite#wrapContentProvider}. For
+   * consistency, the immediate notification sent on subscribe also uses this scheduler. As such,
+   * calling {@link Observable#subscribeOn subscribeOn} on the returned observable has no effect.
+   * <p>
    * Note: To skip the immediate notification and only receive subsequent notifications when data
    * has changed call {@code skip(1)} on the returned observable.
    * <p>
@@ -80,19 +90,24 @@ public QueryObservable createQuery(@NonNull final Uri uri, @Nullable final Strin
       final String sortOrder, final boolean notifyForDescendents) {
     final Query query = new Query() {
       @Override public Cursor run() {
-        return contentResolver.query(uri, projection, selection, selectionArgs, sortOrder);
+        long startNanos = nanoTime();
+        Cursor cursor = contentResolver.query(uri, projection, selection, selectionArgs, sortOrder);
+
+        if (logging) {
+          long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
+          log("QUERY (%sms)\n  uri: %s\n  projection: %s\n  selection: %s\n  selectionArgs: %s\n  "
+                  + "sortOrder: %s\n  notifyForDescendents: %s", tookMillis, uri,
+              Arrays.toString(projection), selection, Arrays.toString(selectionArgs), sortOrder,
+              notifyForDescendents);
+        }
+
+        return cursor;
       }
     };
     OnSubscribe<Query> subscribe = new OnSubscribe<Query>() {
       @Override public void call(final Subscriber<? super Query> subscriber) {
         final ContentObserver observer = new ContentObserver(contentObserverHandler) {
           @Override public void onChange(boolean selfChange) {
-            if (logging) {
-              log("QUERY\n  uri: %s\n  projection: %s\n  selection: %s\n  selectionArgs: %s\n  "
-                      + "sortOrder: %s\n  notifyForDescendents: %s", uri,
-                  Arrays.toString(projection), selection, Arrays.toString(selectionArgs), sortOrder,
-                  notifyForDescendents);
-            }
             subscriber.onNext(query);
           }
         };
@@ -106,11 +121,12 @@ public QueryObservable createQuery(@NonNull final Uri uri, @Nullable final Strin
     };
     Observable<Query> queryObservable = Observable.create(subscribe) //
         .startWith(query) //
+        .observeOn(scheduler) //
         .onBackpressureLatest();
     return new QueryObservable(queryObservable);
   }
 
-  private void log(String message, Object... args) {
+  void log(String message, Object... args) {
     if (args.length > 0) message = String.format(message, args);
     logger.log(message);
   }
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
index ac8458e..1087016 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/BriteDatabase.java
@@ -26,7 +26,6 @@
 import android.support.annotation.Nullable;
 import com.squareup.sqlbrite.SqlBrite.Query;
 import java.io.Closeable;
-import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.util.Arrays;
 import java.util.Collections;
@@ -34,6 +33,8 @@
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import rx.Observable;
+import rx.Scheduler;
+import rx.functions.Action0;
 import rx.functions.Func1;
 import rx.subjects.PublishSubject;
 
@@ -43,14 +44,16 @@
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_NONE;
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_REPLACE;
 import static android.database.sqlite.SQLiteDatabase.CONFLICT_ROLLBACK;
+import static java.lang.System.nanoTime;
 import static java.lang.annotation.RetentionPolicy.SOURCE;
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
 /**
  * A lightweight wrapper around {@link SQLiteOpenHelper} which allows for continuously observing
  * the result of a query. Create using a {@link SqlBrite} instance.
  */
 public final class BriteDatabase implements Closeable {
-  private static final Set<String> INITIAL_TRIGGER = Collections.singleton("<initial>");
+  private static final Set<String> INITIAL = Collections.emptySet();
 
   private final SQLiteOpenHelper helper;
   private final SqlBrite.Logger logger;
@@ -99,12 +102,15 @@
   private volatile SQLiteDatabase writeableDatabase;
   private final Object databaseLock = new Object();
 
+  private final Scheduler scheduler;
+
   // Package-private to avoid synthetic accessor method for 'transaction' instance.
   volatile boolean logging;
 
-  BriteDatabase(@NonNull SQLiteOpenHelper helper, @NonNull SqlBrite.Logger logger) {
+  BriteDatabase(SQLiteOpenHelper helper, SqlBrite.Logger logger, Scheduler scheduler) {
     this.helper = helper;
     this.logger = logger;
+    this.scheduler = scheduler;
   }
 
   /**
@@ -147,7 +153,7 @@ SQLiteDatabase getWriteableDatabase() {
     return db;
   }
 
-  private void sendTableTrigger(Set<String> tables) {
+  void sendTableTrigger(Set<String> tables) {
     SqliteTransaction transaction = transactions.get();
     if (transaction != null) {
       transaction.addAll(tables);
@@ -209,7 +215,7 @@ public Transaction newTransaction() {
    * databases. This does not prevent existing observables from retaining existing references as
    * well as attempting to create new ones for new subscriptions.
    */
-  @Override public void close() throws IOException {
+  @Override public void close() {
     synchronized (databaseLock) {
       readableDatabase = null;
       writeableDatabase = null;
@@ -227,6 +233,11 @@ public Transaction newTransaction() {
    * {@code update}, and {@code delete} methods of this class. Unsubscribe when you no longer want
    * updates to a query.
    * <p>
+   * Since database triggers are inherently asynchronous, items emitted from the returned
+   * observable use the {@link Scheduler} supplied to {@link SqlBrite#wrapDatabaseHelper}. For
+   * consistency, the immediate notification sent on subscribe also uses this scheduler. As such,
+   * calling {@link Observable#subscribeOn subscribeOn} on the returned observable has no effect.
+   * <p>
    * Note: To skip the immediate notification and only receive subsequent notifications when data
    * has changed call {@code skip(1)} on the returned observable.
    * <p>
@@ -240,7 +251,7 @@ public QueryObservable createQuery(@NonNull final String table, @NonNull String
       @NonNull String... args) {
     Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
       @Override public Boolean call(Set<String> triggers) {
-        return triggers.contains(table);
+        return triggers == INITIAL || triggers.contains(table);
       }
 
       @Override public String toString() {
@@ -261,6 +272,9 @@ public QueryObservable createQuery(@NonNull final Iterable<String> tables, @NonN
       @NonNull String... args) {
     Func1<Set<String>, Boolean> tableFilter = new Func1<Set<String>, Boolean>() {
       @Override public Boolean call(Set<String> triggers) {
+        if (triggers == INITIAL) {
+          return true;
+        }
         for (String table : tables) {
           if (triggers.contains(table)) {
             return true;
@@ -289,7 +303,17 @@ private QueryObservable createQuery(final Func1<Set<String>, Boolean> tableFilte
         if (transactions.get() != null) {
           throw new IllegalStateException("Cannot execute observable query in a transaction.");
         }
-        return getReadableDatabase().rawQuery(sql, args);
+
+        long startNanos = nanoTime();
+        Cursor cursor = getReadableDatabase().rawQuery(sql, args);
+
+        if (logging) {
+          long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
+          log("QUERY (%sms)\n  tables: %s\n  sql: %s\n  args: %s", tookMillis, tableFilter, sql,
+              Arrays.toString(args));
+        }
+
+        return cursor;
       }
 
       @Override public String toString() {
@@ -298,22 +322,23 @@ private QueryObservable createQuery(final Func1<Set<String>, Boolean> tableFilte
     };
 
     Observable<Query> queryObservable = triggers //
+        .startWith(INITIAL) // Immediately trigger the query for initial value.
+        .observeOn(scheduler) //
         .filter(tableFilter) // Only trigger on tables we care about.
-        .startWith(INITIAL_TRIGGER) // Immediately execute the query for initial value.
         .map(new Func1<Set<String>, Query>() {
           @Override public Query call(Set<String> trigger) {
+            return query;
+          }
+        }) //
+        .onBackpressureLatest() //
+        .doOnSubscribe(new Action0() {
+          @Override public void call() {
             if (transactions.get() != null) {
               throw new IllegalStateException(
                   "Cannot subscribe to observable query in a transaction.");
             }
-            if (logging) {
-              log("QUERY\n  trigger: %s\n  tables: %s\n  sql: %s\n  args: %s", trigger, tableFilter,
-                  sql, Arrays.toString(args));
-            }
-            return query;
           }
-        }) //
-        .onBackpressureLatest();
+        });
     return new QueryObservable(queryObservable);
   }
 
@@ -324,8 +349,15 @@ private QueryObservable createQuery(final Func1<Set<String>, Boolean> tableFilte
    */
   @CheckResult // TODO @WorkerThread
   public Cursor query(@NonNull String sql, @NonNull String... args) {
-    if (logging) log("QUERY\n  sql: %s\n  args: %s", sql, Arrays.toString(args));
-    return getReadableDatabase().rawQuery(sql, args);
+    long startNanos = nanoTime();
+    Cursor cursor = getReadableDatabase().rawQuery(sql, args);
+    long tookMillis = NANOSECONDS.toMillis(nanoTime() - startNanos);
+
+    if (logging) {
+      log("QUERY (%sms)\n  sql: %s\n  args: %s", tookMillis, sql, Arrays.toString(args));
+    }
+
+    return cursor;
   }
 
   /**
@@ -561,7 +593,7 @@ public void executeAndTrigger(String table, String sql, Object... args) {
   public @interface ConflictAlgorithm {
   }
 
-  private void log(String message, Object... args) {
+  void log(String message, Object... args) {
     if (args.length > 0) message = String.format(message, args);
     logger.log(message);
   }
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
index ecf2710..802ac69 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToListOperator.java
@@ -10,7 +10,7 @@
 import rx.functions.Func1;
 
 final class QueryToListOperator<T> implements Observable.Operator<List<T>, SqlBrite.Query> {
-  private final Func1<Cursor, T> mapper;
+  final Func1<Cursor, T> mapper;
 
   QueryToListOperator(Func1<Cursor, T> mapper) {
     this.mapper = mapper;
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
index 09f834f..fcc90e1 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/QueryToOneOperator.java
@@ -8,9 +8,9 @@
 import rx.functions.Func1;
 
 final class QueryToOneOperator<T> implements Observable.Operator<T, SqlBrite.Query> {
-  private final Func1<Cursor, T> mapper;
-  private boolean emitDefault;
-  private T defaultValue;
+  final Func1<Cursor, T> mapper;
+  boolean emitDefault;
+  T defaultValue;
 
   QueryToOneOperator(Func1<Cursor, T> mapper, boolean emitDefault, T defaultValue) {
     this.mapper = mapper;
diff --git a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java b/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
index c616327..34af3bb 100644
--- a/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
+++ b/sqlbrite/src/main/java/com/squareup/sqlbrite/SqlBrite.java
@@ -24,6 +24,7 @@
 import java.util.List;
 import rx.Observable;
 import rx.Observable.Operator;
+import rx.Scheduler;
 import rx.Subscriber;
 import rx.functions.Func1;
 
@@ -59,16 +60,24 @@ private SqlBrite(@NonNull Logger logger) {
    * interacting with the underlying {@link SQLiteOpenHelper} and it is required for automatic
    * notifications of table changes to work. See {@linkplain BriteDatabase#createQuery the
    * <code>query</code> method} for more information on that behavior.
+   *
+   * @param scheduler The {@link Scheduler} on which items from {@link BriteDatabase#createQuery}
+   * will be emitted.
    */
-  @CheckResult @NonNull
-  public BriteDatabase wrapDatabaseHelper(@NonNull SQLiteOpenHelper helper) {
-    return new BriteDatabase(helper, logger);
+  @CheckResult @NonNull public BriteDatabase wrapDatabaseHelper(@NonNull SQLiteOpenHelper helper,
+      @NonNull Scheduler scheduler) {
+    return new BriteDatabase(helper, logger, scheduler);
   }
 
-  /** Wrap a {@link ContentResolver} for observable queries. */
-  @CheckResult @NonNull
-  public BriteContentResolver wrapContentProvider(@NonNull ContentResolver contentResolver) {
-    return new BriteContentResolver(contentResolver, logger);
+  /**
+   * Wrap a {@link ContentResolver} for observable queries.
+   *
+   * @param scheduler The {@link Scheduler} on which items from
+   * {@link BriteContentResolver#createQuery} will be emitted.
+   */
+  @CheckResult @NonNull public BriteContentResolver wrapContentProvider(
+      @NonNull ContentResolver contentResolver, @NonNull Scheduler scheduler) {
+    return new BriteContentResolver(contentResolver, logger, scheduler);
   }
 
   /** An executable query. */
