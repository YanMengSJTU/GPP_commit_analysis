diff --git a/library/src/com/nineoldandroids/view/ViewPropertyAnimator.java b/library/src/com/nineoldandroids/view/ViewPropertyAnimator.java
index b967897..6e22364 100644
--- a/library/src/com/nineoldandroids/view/ViewPropertyAnimator.java
+++ b/library/src/com/nineoldandroids/view/ViewPropertyAnimator.java
@@ -352,4 +352,18 @@ else if (version >= Build.VERSION_CODES.HONEYCOMB)
      * @see View#setAlpha(float)
      */
     public abstract ViewPropertyAnimator alphaBy(float value);
+
+    /**
+     * Clean way to execute work when the animation starts without using a listener.
+     * @param startRunnable
+     * @return This object, allowing calls to methods in this class to be chained.
+     */
+    public abstract ViewPropertyAnimator withStartAction(Runnable startRunnable);
+
+    /**
+     * Clean way to execute work when the animation ends without using a listener.
+     * @param endRunnable
+     * @return This object, allowing calls to methods in this class to be chained.
+     */
+    public abstract ViewPropertyAnimator withEndAction(Runnable endRunnable);
 }
diff --git a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorHC.java b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorHC.java
index f5fa533..3a3a910 100644
--- a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorHC.java
+++ b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorHC.java
@@ -133,6 +133,8 @@ public void run()
     private HashMap<Animator, PropertyBundle> mAnimatorMap =
             new HashMap<Animator, PropertyBundle>();
 
+    private Runnable mStartAction, mEndAction;
+
     /**
      * Constructor, called by View. This is private by design, as the user should only
      * get a ViewPropertyAnimator by calling View.animate().
@@ -397,6 +399,20 @@ public ViewPropertyAnimator alphaBy(float value)
         return this;
     }
 
+    @Override
+    public ViewPropertyAnimator withStartAction(Runnable startRunnable)
+    {
+        mStartAction = startRunnable;
+        return this;
+    }
+
+    @Override
+    public ViewPropertyAnimator withEndAction(Runnable endRunnable)
+    {
+        mEndAction = endRunnable;
+        return this;
+    }
+
     /**
      * Starts the underlying Animator for a set of properties. We use a single animator that
      * simply runs from 0 to 1, and then use that fractional value to set each property
@@ -685,6 +701,11 @@ public void onAnimationStart(Animator animation)
             {
                 mListener.onAnimationStart(animation);
             }
+
+            if (mStartAction != null)
+            {
+                mStartAction.run();
+            }
         }
 
         @Override
@@ -701,6 +722,12 @@ public void onAnimationEnd(Animator animation)
             if (mAnimatorMap.isEmpty())
             {
                 mListener = null;
+
+                //pc Wait until all animations are done to start the endAction
+                if (mEndAction != null)
+                {
+                    mEndAction.run();
+                }
             }
         }
 
diff --git a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorICS.java b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorICS.java
index 971315f..8da63be 100644
--- a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorICS.java
+++ b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorICS.java
@@ -14,6 +14,8 @@
      */
     private final static long RETURN_WHEN_NULL = -1L;
 
+    private Runnable mStartAction, mEndAction;
+
     /**
      * A WeakReference holding the native implementation of ViewPropertyAnimator
      */
@@ -97,6 +99,7 @@ public ViewPropertyAnimator setListener(final AnimatorListener listener)
                     public void onAnimationStart(android.animation.Animator animation)
                     {
                         listener.onAnimationStart(null);
+                        mStartAction.run();
                     }
 
                     @Override
@@ -109,6 +112,7 @@ public void onAnimationRepeat(android.animation.Animator animation)
                     public void onAnimationEnd(android.animation.Animator animation)
                     {
                         listener.onAnimationEnd(null);
+                        mEndAction.run();
                     }
 
                     @Override
@@ -361,4 +365,18 @@ public ViewPropertyAnimator alphaBy(float value)
         }
         return this;
     }
+
+    @Override
+    public ViewPropertyAnimator withStartAction(Runnable startRunnable)
+    {
+        mStartAction = startRunnable;
+        return this;
+    }
+
+    @Override
+    public ViewPropertyAnimator withEndAction(Runnable endRunnable)
+    {
+        mEndAction = endRunnable;
+        return this;
+    }
 }
diff --git a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorPreHC.java b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorPreHC.java
index 2ff56a8..6992fc3 100644
--- a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorPreHC.java
+++ b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorPreHC.java
@@ -137,6 +137,8 @@ public void run()
     private HashMap<Animator, PropertyBundle> mAnimatorMap =
             new HashMap<Animator, PropertyBundle>();
 
+    private Runnable mStartAction, mEndAction;
+
     /**
      * Constructor, called by View. This is private by design, as the user should only
      * get a ViewPropertyAnimator by calling View.animate().
@@ -402,6 +404,20 @@ public ViewPropertyAnimator alphaBy(float value)
         return this;
     }
 
+    @Override
+    public ViewPropertyAnimator withStartAction(Runnable startRunnable)
+    {
+        mStartAction = startRunnable;
+        return this;
+    }
+
+    @Override
+    public ViewPropertyAnimator withEndAction(Runnable endRunnable)
+    {
+        mEndAction = endRunnable;
+        return this;
+    }
+
     /**
      * Starts the underlying Animator for a set of properties. We use a single animator that
      * simply runs from 0 to 1, and then use that fractional value to set each property
@@ -682,6 +698,11 @@ public void onAnimationStart(Animator animation)
             {
                 mListener.onAnimationStart(animation);
             }
+
+            if (mStartAction != null)
+            {
+                mStartAction.run();
+            }
         }
 
         @Override
@@ -692,12 +713,18 @@ public void onAnimationEnd(Animator animation)
                 mListener.onAnimationEnd(animation);
             }
             mAnimatorMap.remove(animation);
+
             // If the map is empty, it means all animation are done or canceled, so the listener
             // isn't needed anymore. Not nulling it would cause it to leak any objects used in
             // its implementation
             if (mAnimatorMap.isEmpty())
             {
                 mListener = null;
+
+                if (mEndAction != null)
+                {
+                    mEndAction.run();
+                }
             }
         }
 
