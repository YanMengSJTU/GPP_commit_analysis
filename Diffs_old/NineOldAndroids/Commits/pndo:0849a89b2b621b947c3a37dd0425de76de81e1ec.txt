diff --git a/library/AndroidManifest.xml b/library/AndroidManifest.xml
index 0e057cf..6076613 100644
--- a/library/AndroidManifest.xml
+++ b/library/AndroidManifest.xml
@@ -1,11 +1,11 @@
 <?xml version="1.0" encoding="utf-8"?>
 
 <manifest
-	xmlns:android="http://schemas.android.com/apk/res/android"
-	package="com.nineoldandroids"
-	android:versionCode="60"
-	android:versionName="2.4.0">
-	
-    <uses-sdk android:minSdkVersion="1" />
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.nineoldandroids"
+    android:versionCode="60"
+    android:versionName="2.4.0">
+
+    <uses-sdk android:minSdkVersion="1"/>
 
 </manifest>
diff --git a/library/pom.xml b/library/pom.xml
index 6d8cac5..9c9103f 100644
--- a/library/pom.xml
+++ b/library/pom.xml
@@ -1,53 +1,54 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-	<modelVersion>4.0.0</modelVersion>
+<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
 
-	<groupId>com.nineoldandroids</groupId>
-	<artifactId>library</artifactId>
-	<name>Nine Old Androids</name>
-	<packaging>jar</packaging>
+    <groupId>com.nineoldandroids</groupId>
+    <artifactId>library</artifactId>
+    <name>Nine Old Androids</name>
+    <packaging>jar</packaging>
 
-	<parent>
-		<groupId>com.nineoldandroids</groupId>
-		<artifactId>parent</artifactId>
-		<version>2.4.0</version>
-		<relativePath>../pom.xml</relativePath>
-	</parent>
-	
-	<dependencies>
-		<dependency>
-			<groupId>com.google.android</groupId>
-			<artifactId>android</artifactId>
-			<scope>provided</scope>
-		</dependency>
-	</dependencies>
+    <parent>
+        <groupId>com.nineoldandroids</groupId>
+        <artifactId>parent</artifactId>
+        <version>2.4.0</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
 
-	<build>
-		<sourceDirectory>src</sourceDirectory>
+    <dependencies>
+        <dependency>
+            <groupId>com.google.android</groupId>
+            <artifactId>android</artifactId>
+            <scope>provided</scope>
+        </dependency>
+    </dependencies>
 
-		<plugins>
-			<plugin>
-				<groupId>com.jayway.maven.plugins.android.generation2</groupId>
-				<artifactId>android-maven-plugin</artifactId>
-				<extensions>true</extensions>
-			</plugin>
+    <build>
+        <sourceDirectory>src</sourceDirectory>
 
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-checkstyle-plugin</artifactId>
-				<configuration>
-					<configLocation>${project.basedir}/../checkstyle.xml</configLocation>
-				</configuration>
-				<executions>
-					<execution>
-						<phase>verify</phase>
-						<goals>
-							<goal>checkstyle</goal>
-						</goals>
-					</execution>
-				</executions>
-			</plugin>
-		</plugins>
-	</build>
+        <plugins>
+            <plugin>
+                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+                <artifactId>android-maven-plugin</artifactId>
+                <extensions>true</extensions>
+            </plugin>
+
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-checkstyle-plugin</artifactId>
+                <configuration>
+                    <configLocation>${project.basedir}/../checkstyle.xml</configLocation>
+                </configuration>
+                <executions>
+                    <execution>
+                        <phase>verify</phase>
+                        <goals>
+                            <goal>checkstyle</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+        </plugins>
+    </build>
 </project>
diff --git a/library/src/com/nineoldandroids/animation/AnimatorListenerAdapter.java b/library/src/com/nineoldandroids/animation/AnimatorListenerAdapter.java
index 6cfa597..e322494 100644
--- a/library/src/com/nineoldandroids/animation/AnimatorListenerAdapter.java
+++ b/library/src/com/nineoldandroids/animation/AnimatorListenerAdapter.java
@@ -28,7 +28,7 @@
      * {@inheritDoc}
      */
     @Override
-    public void onAnimationCancel(Animator animation)
+    public void onAnimationStart(Animator animation)
     {
     }
 
@@ -44,7 +44,7 @@ public void onAnimationEnd(Animator animation)
      * {@inheritDoc}
      */
     @Override
-    public void onAnimationRepeat(Animator animation)
+    public void onAnimationCancel(Animator animation)
     {
     }
 
@@ -52,7 +52,7 @@ public void onAnimationRepeat(Animator animation)
      * {@inheritDoc}
      */
     @Override
-    public void onAnimationStart(Animator animation)
+    public void onAnimationRepeat(Animator animation)
     {
     }
 
diff --git a/library/src/com/nineoldandroids/animation/AnimatorSet.java b/library/src/com/nineoldandroids/animation/AnimatorSet.java
index 3120f99..4338b44 100644
--- a/library/src/com/nineoldandroids/animation/AnimatorSet.java
+++ b/library/src/com/nineoldandroids/animation/AnimatorSet.java
@@ -221,45 +221,6 @@ public void playSequentially(List<Animator> items)
         return childList;
     }
 
-    /**
-     * Sets the target object for all current {@link #getChildAnimations() child animations}
-     * of this AnimatorSet that take targets ({@link ObjectAnimator} and
-     * AnimatorSet).
-     *
-     * @param target The object being animated
-     */
-    @Override
-    public void setTarget(Object target)
-    {
-        for (Node node : mNodes)
-        {
-            Animator animation = node.animation;
-            if (animation instanceof AnimatorSet)
-            {
-                ((AnimatorSet) animation).setTarget(target);
-            }
-            else if (animation instanceof ObjectAnimator)
-            {
-                ((ObjectAnimator) animation).setTarget(target);
-            }
-        }
-    }
-
-    /**
-     * Sets the TimeInterpolator for all current {@link #getChildAnimations() child animations}
-     * of this AnimatorSet.
-     *
-     * @param interpolator the interpolator to be used by each child animation of this AnimatorSet
-     */
-    @Override
-    public void setInterpolator(/*Time*/Interpolator interpolator)
-    {
-        for (Node node : mNodes)
-        {
-            node.animation.setInterpolator(interpolator);
-        }
-    }
-
     /**
      * This method creates a <code>Builder</code> object, which is used to
      * set up playing constraints. This initial <code>play()</code> method
@@ -298,6 +259,141 @@ public Builder play(Animator anim)
         return null;
     }
 
+    /**
+     * {@inheritDoc}
+     * <p/>
+     * <p>Starting this <code>AnimatorSet</code> will, in turn, start the animations for which
+     * it is responsible. The details of when exactly those animations are started depends on
+     * the dependency relationships that have been set up between the animations.
+     */
+    @SuppressWarnings("unchecked")
+    @Override
+    public void start()
+    {
+        mTerminated = false;
+        mStarted = true;
+
+        // First, sort the nodes (if necessary). This will ensure that sortedNodes
+        // contains the animation nodes in the correct order.
+        sortNodes();
+
+        int numSortedNodes = mSortedNodes.size();
+        for (int i = 0; i < numSortedNodes; ++i)
+        {
+            Node node = mSortedNodes.get(i);
+            // First, clear out the old listeners
+            ArrayList<AnimatorListener> oldListeners = node.animation.getListeners();
+            if (oldListeners != null && oldListeners.size() > 0)
+            {
+                final ArrayList<AnimatorListener> clonedListeners = new
+                        ArrayList<AnimatorListener>(oldListeners);
+
+                for (AnimatorListener listener : clonedListeners)
+                {
+                    if (listener instanceof DependencyListener ||
+                            listener instanceof AnimatorSetListener)
+                    {
+                        node.animation.removeListener(listener);
+                    }
+                }
+            }
+        }
+
+        // nodesToStart holds the list of nodes to be started immediately. We don't want to
+        // start the animations in the loop directly because we first need to set up
+        // dependencies on all of the nodes. For example, we don't want to start an animation
+        // when some other animation also wants to start when the first animation begins.
+        final ArrayList<Node> nodesToStart = new ArrayList<Node>();
+        for (int i = 0; i < numSortedNodes; ++i)
+        {
+            Node node = mSortedNodes.get(i);
+            if (mSetListener == null)
+            {
+                mSetListener = new AnimatorSetListener(this);
+            }
+            if (node.dependencies == null || node.dependencies.size() == 0)
+            {
+                nodesToStart.add(node);
+            }
+            else
+            {
+                int numDependencies = node.dependencies.size();
+                for (int j = 0; j < numDependencies; ++j)
+                {
+                    Dependency dependency = node.dependencies.get(j);
+                    dependency.node.animation.addListener(
+                            new DependencyListener(this, node, dependency.rule));
+                }
+                node.tmpDependencies = (ArrayList<Dependency>) node.dependencies.clone();
+            }
+            node.animation.addListener(mSetListener);
+        }
+        // Now that all dependencies are set up, start the animations that should be started.
+        if (mStartDelay <= 0)
+        {
+            for (Node node : nodesToStart)
+            {
+                node.animation.start();
+                mPlayingSet.add(node.animation);
+            }
+        }
+        else
+        {
+            mDelayAnim = ValueAnimator.ofFloat(0f, 1f);
+            mDelayAnim.setDuration(mStartDelay);
+            mDelayAnim.addListener(new AnimatorListenerAdapter()
+            {
+                boolean canceled = false;
+
+                public void onAnimationCancel(Animator anim)
+                {
+                    canceled = true;
+                }
+
+                public void onAnimationEnd(Animator anim)
+                {
+                    if (!canceled)
+                    {
+                        int numNodes = nodesToStart.size();
+                        for (int i = 0; i < numNodes; ++i)
+                        {
+                            Node node = nodesToStart.get(i);
+                            node.animation.start();
+                            mPlayingSet.add(node.animation);
+                        }
+                    }
+                }
+            });
+            mDelayAnim.start();
+        }
+        if (mListeners != null)
+        {
+            ArrayList<AnimatorListener> tmpListeners =
+                    (ArrayList<AnimatorListener>) mListeners.clone();
+            int numListeners = tmpListeners.size();
+            for (int i = 0; i < numListeners; ++i)
+            {
+                tmpListeners.get(i).onAnimationStart(this);
+            }
+        }
+        if (mNodes.size() == 0 && mStartDelay == 0)
+        {
+            // Handle unusual case where empty AnimatorSet is started - should send out
+            // end event immediately since the event will not be sent out at all otherwise
+            mStarted = false;
+            if (mListeners != null)
+            {
+                ArrayList<AnimatorListener> tmpListeners =
+                        (ArrayList<AnimatorListener>) mListeners.clone();
+                int numListeners = tmpListeners.size();
+                for (int i = 0; i < numListeners; ++i)
+                {
+                    tmpListeners.get(i).onAnimationEnd(this);
+                }
+            }
+        }
+    }
+
     /**
      * {@inheritDoc}
      * <p/>
@@ -393,31 +489,6 @@ public void end()
         }
     }
 
-    /**
-     * Returns true if any of the child animations of this AnimatorSet have been started and have
-     * not yet ended.
-     *
-     * @return Whether this AnimatorSet has been started and has not yet ended.
-     */
-    @Override
-    public boolean isRunning()
-    {
-        for (Node node : mNodes)
-        {
-            if (node.animation.isRunning())
-            {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    @Override
-    public boolean isStarted()
-    {
-        return mStarted;
-    }
-
     /**
      * The amount of time, in milliseconds, to delay starting the animation after
      * {@link #start()} is called.
@@ -481,157 +552,44 @@ public AnimatorSet setDuration(long duration)
         return this;
     }
 
+    /**
+     * Sets the TimeInterpolator for all current {@link #getChildAnimations() child animations}
+     * of this AnimatorSet.
+     *
+     * @param interpolator the interpolator to be used by each child animation of this AnimatorSet
+     */
     @Override
-    public void setupStartValues()
-    {
-        for (Node node : mNodes)
-        {
-            node.animation.setupStartValues();
-        }
-    }
-
-    @Override
-    public void setupEndValues()
+    public void setInterpolator(/*Time*/Interpolator interpolator)
     {
         for (Node node : mNodes)
         {
-            node.animation.setupEndValues();
+            node.animation.setInterpolator(interpolator);
         }
     }
 
     /**
-     * {@inheritDoc}
-     * <p/>
-     * <p>Starting this <code>AnimatorSet</code> will, in turn, start the animations for which
-     * it is responsible. The details of when exactly those animations are started depends on
-     * the dependency relationships that have been set up between the animations.
+     * Returns true if any of the child animations of this AnimatorSet have been started and have
+     * not yet ended.
+     *
+     * @return Whether this AnimatorSet has been started and has not yet ended.
      */
-    @SuppressWarnings("unchecked")
     @Override
-    public void start()
+    public boolean isRunning()
     {
-        mTerminated = false;
-        mStarted = true;
-
-        // First, sort the nodes (if necessary). This will ensure that sortedNodes
-        // contains the animation nodes in the correct order.
-        sortNodes();
-
-        int numSortedNodes = mSortedNodes.size();
-        for (int i = 0; i < numSortedNodes; ++i)
-        {
-            Node node = mSortedNodes.get(i);
-            // First, clear out the old listeners
-            ArrayList<AnimatorListener> oldListeners = node.animation.getListeners();
-            if (oldListeners != null && oldListeners.size() > 0)
-            {
-                final ArrayList<AnimatorListener> clonedListeners = new
-                        ArrayList<AnimatorListener>(oldListeners);
-
-                for (AnimatorListener listener : clonedListeners)
-                {
-                    if (listener instanceof DependencyListener ||
-                            listener instanceof AnimatorSetListener)
-                    {
-                        node.animation.removeListener(listener);
-                    }
-                }
-            }
-        }
-
-        // nodesToStart holds the list of nodes to be started immediately. We don't want to
-        // start the animations in the loop directly because we first need to set up
-        // dependencies on all of the nodes. For example, we don't want to start an animation
-        // when some other animation also wants to start when the first animation begins.
-        final ArrayList<Node> nodesToStart = new ArrayList<Node>();
-        for (int i = 0; i < numSortedNodes; ++i)
-        {
-            Node node = mSortedNodes.get(i);
-            if (mSetListener == null)
-            {
-                mSetListener = new AnimatorSetListener(this);
-            }
-            if (node.dependencies == null || node.dependencies.size() == 0)
-            {
-                nodesToStart.add(node);
-            }
-            else
-            {
-                int numDependencies = node.dependencies.size();
-                for (int j = 0; j < numDependencies; ++j)
-                {
-                    Dependency dependency = node.dependencies.get(j);
-                    dependency.node.animation.addListener(
-                            new DependencyListener(this, node, dependency.rule));
-                }
-                node.tmpDependencies = (ArrayList<Dependency>) node.dependencies.clone();
-            }
-            node.animation.addListener(mSetListener);
-        }
-        // Now that all dependencies are set up, start the animations that should be started.
-        if (mStartDelay <= 0)
+        for (Node node : mNodes)
         {
-            for (Node node : nodesToStart)
+            if (node.animation.isRunning())
             {
-                node.animation.start();
-                mPlayingSet.add(node.animation);
+                return true;
             }
         }
-        else
-        {
-            mDelayAnim = ValueAnimator.ofFloat(0f, 1f);
-            mDelayAnim.setDuration(mStartDelay);
-            mDelayAnim.addListener(new AnimatorListenerAdapter()
-            {
-                boolean canceled = false;
-
-                public void onAnimationCancel(Animator anim)
-                {
-                    canceled = true;
-                }
+        return false;
+    }
 
-                public void onAnimationEnd(Animator anim)
-                {
-                    if (!canceled)
-                    {
-                        int numNodes = nodesToStart.size();
-                        for (int i = 0; i < numNodes; ++i)
-                        {
-                            Node node = nodesToStart.get(i);
-                            node.animation.start();
-                            mPlayingSet.add(node.animation);
-                        }
-                    }
-                }
-            });
-            mDelayAnim.start();
-        }
-        if (mListeners != null)
-        {
-            ArrayList<AnimatorListener> tmpListeners =
-                    (ArrayList<AnimatorListener>) mListeners.clone();
-            int numListeners = tmpListeners.size();
-            for (int i = 0; i < numListeners; ++i)
-            {
-                tmpListeners.get(i).onAnimationStart(this);
-            }
-        }
-        if (mNodes.size() == 0 && mStartDelay == 0)
-        {
-            // Handle unusual case where empty AnimatorSet is started - should send out
-            // end event immediately since the event will not be sent out at all otherwise
-            mStarted = false;
-            if (mListeners != null)
-            {
-                ArrayList<AnimatorListener> tmpListeners =
-                        (ArrayList<AnimatorListener>) mListeners.clone();
-                int numListeners = tmpListeners.size();
-                for (int i = 0; i < numListeners; ++i)
-                {
-                    tmpListeners.get(i).onAnimationEnd(this);
-                }
-            }
-        }
+    @Override
+    public boolean isStarted()
+    {
+        return mStarted;
     }
 
     @Override
@@ -715,6 +673,48 @@ public AnimatorSet clone()
         return anim;
     }
 
+    @Override
+    public void setupStartValues()
+    {
+        for (Node node : mNodes)
+        {
+            node.animation.setupStartValues();
+        }
+    }
+
+    @Override
+    public void setupEndValues()
+    {
+        for (Node node : mNodes)
+        {
+            node.animation.setupEndValues();
+        }
+    }
+
+    /**
+     * Sets the target object for all current {@link #getChildAnimations() child animations}
+     * of this AnimatorSet that take targets ({@link ObjectAnimator} and
+     * AnimatorSet).
+     *
+     * @param target The object being animated
+     */
+    @Override
+    public void setTarget(Object target)
+    {
+        for (Node node : mNodes)
+        {
+            Animator animation = node.animation;
+            if (animation instanceof AnimatorSet)
+            {
+                ((AnimatorSet) animation).setTarget(target);
+            }
+            else if (animation instanceof ObjectAnimator)
+            {
+                ((ObjectAnimator) animation).setTarget(target);
+            }
+        }
+    }
+
     /**
      * This method sorts the current set of nodes, if needed. The sort is a simple
      * DependencyGraph sort, which goes like this:
@@ -829,33 +829,6 @@ public DependencyListener(AnimatorSet animatorSet, Node node, int rule)
             this.mRule = rule;
         }
 
-        /**
-         * Ignore cancel events for now. We may want to handle this eventually,
-         * to prevent follow-on animations from running when some dependency
-         * animation is canceled.
-         */
-        public void onAnimationCancel(Animator animation)
-        {
-        }
-
-        /**
-         * An end event is received - see if this is an event we are listening for
-         */
-        public void onAnimationEnd(Animator animation)
-        {
-            if (mRule == Dependency.AFTER)
-            {
-                startIfReady(animation);
-            }
-        }
-
-        /**
-         * Ignore repeat events for now
-         */
-        public void onAnimationRepeat(Animator animation)
-        {
-        }
-
         /**
          * A start event is received - see if this is an event we are listening for
          */
@@ -865,6 +838,13 @@ public void onAnimationStart(Animator animation)
             {
                 startIfReady(animation);
             }
+        }        /**
+         * Ignore cancel events for now. We may want to handle this eventually,
+         * to prevent follow-on animations from running when some dependency
+         * animation is canceled.
+         */
+        public void onAnimationCancel(Animator animation)
+        {
         }
 
         /**
@@ -903,8 +883,28 @@ private void startIfReady(Animator dependencyAnimation)
                 mNode.animation.start();
                 mAnimatorSet.mPlayingSet.add(mNode.animation);
             }
+        }        /**
+         * An end event is received - see if this is an event we are listening for
+         */
+        public void onAnimationEnd(Animator animation)
+        {
+            if (mRule == Dependency.AFTER)
+            {
+                startIfReady(animation);
+            }
+        }
+
+        /**
+         * Ignore repeat events for now
+         */
+        public void onAnimationRepeat(Animator animation)
+        {
         }
 
+
+
+
+
     }
 
     /**
diff --git a/library/src/com/nineoldandroids/animation/FloatKeyframeSet.java b/library/src/com/nineoldandroids/animation/FloatKeyframeSet.java
index b313c82..6efc8e2 100644
--- a/library/src/com/nineoldandroids/animation/FloatKeyframeSet.java
+++ b/library/src/com/nineoldandroids/animation/FloatKeyframeSet.java
@@ -43,12 +43,6 @@ public FloatKeyframeSet(FloatKeyframe... keyframes)
         super(keyframes);
     }
 
-    @Override
-    public Object getValue(float fraction)
-    {
-        return getFloatValue(fraction);
-    }
-
     @Override
     public FloatKeyframeSet clone()
     {
@@ -63,6 +57,12 @@ public FloatKeyframeSet clone()
         return newSet;
     }
 
+    @Override
+    public Object getValue(float fraction)
+    {
+        return getFloatValue(fraction);
+    }
+
     public float getFloatValue(float fraction)
     {
         if (mNumKeyframes == 2)
diff --git a/library/src/com/nineoldandroids/animation/IntKeyframeSet.java b/library/src/com/nineoldandroids/animation/IntKeyframeSet.java
index 8841e8d..e5a2e34 100644
--- a/library/src/com/nineoldandroids/animation/IntKeyframeSet.java
+++ b/library/src/com/nineoldandroids/animation/IntKeyframeSet.java
@@ -43,12 +43,6 @@ public IntKeyframeSet(IntKeyframe... keyframes)
         super(keyframes);
     }
 
-    @Override
-    public Object getValue(float fraction)
-    {
-        return getIntValue(fraction);
-    }
-
     @Override
     public IntKeyframeSet clone()
     {
@@ -63,6 +57,12 @@ public IntKeyframeSet clone()
         return newSet;
     }
 
+    @Override
+    public Object getValue(float fraction)
+    {
+        return getIntValue(fraction);
+    }
+
     public int getIntValue(float fraction)
     {
         if (mNumKeyframes == 2)
diff --git a/library/src/com/nineoldandroids/animation/ObjectAnimator.java b/library/src/com/nineoldandroids/animation/ObjectAnimator.java
index b999d02..c121e57 100644
--- a/library/src/com/nineoldandroids/animation/ObjectAnimator.java
+++ b/library/src/com/nineoldandroids/animation/ObjectAnimator.java
@@ -407,24 +407,6 @@ public void setObjectValues(Object... values)
         }
     }
 
-    @Override
-    public void start()
-    {
-        if (DBG)
-        {
-            Log.d("ObjectAnimator", "Anim target, duration: " + mTarget + ", " + getDuration());
-            for (int i = 0; i < mValues.length; ++i)
-            {
-                PropertyValuesHolder pvh = mValues[i];
-                ArrayList<Keyframe> keyframes = pvh.mKeyframeSet.mKeyframes;
-                Log.d("ObjectAnimator", "   Values[" + i + "]: " +
-                        pvh.getPropertyName() + ", " + keyframes.get(0).getValue() + ", " +
-                        keyframes.get(pvh.mKeyframeSet.mNumKeyframes - 1).getValue());
-            }
-        }
-        super.start();
-    }
-
     /**
      * This function is called immediately before processing the first animation
      * frame of an animation. If there is a nonzero <code>startDelay</code>, the
@@ -474,6 +456,68 @@ public ObjectAnimator setDuration(long duration)
         return this;
     }
 
+    @Override
+    public void start()
+    {
+        if (DBG)
+        {
+            Log.d("ObjectAnimator", "Anim target, duration: " + mTarget + ", " + getDuration());
+            for (int i = 0; i < mValues.length; ++i)
+            {
+                PropertyValuesHolder pvh = mValues[i];
+                ArrayList<Keyframe> keyframes = pvh.mKeyframeSet.mKeyframes;
+                Log.d("ObjectAnimator", "   Values[" + i + "]: " +
+                        pvh.getPropertyName() + ", " + keyframes.get(0).getValue() + ", " +
+                        keyframes.get(pvh.mKeyframeSet.mNumKeyframes - 1).getValue());
+            }
+        }
+        super.start();
+    }
+
+    /**
+     * This method is called with the elapsed fraction of the animation during every
+     * animation frame. This function turns the elapsed fraction into an interpolated fraction
+     * and then into an animated value (from the evaluator. The function is called mostly during
+     * animation updates, but it is also called when the <code>end()</code>
+     * function is called, to set the final value on the property.
+     * <p/>
+     * <p>Overrides of this method must call the superclass to perform the calculation
+     * of the animated value.</p>
+     *
+     * @param fraction The elapsed fraction of the animation.
+     */
+    @Override
+    void animateValue(float fraction)
+    {
+        super.animateValue(fraction);
+        int numValues = mValues.length;
+        for (int i = 0; i < numValues; ++i)
+        {
+            mValues[i].setAnimatedValue(mTarget);
+        }
+    }
+
+    @Override
+    public ObjectAnimator clone()
+    {
+        final ObjectAnimator anim = (ObjectAnimator) super.clone();
+        return anim;
+    }
+
+    @Override
+    public String toString()
+    {
+        String returnVal = "ObjectAnimator@" + Integer.toHexString(hashCode()) + ", target " +
+                mTarget;
+        if (mValues != null)
+        {
+            for (int i = 0; i < mValues.length; ++i)
+            {
+                returnVal += "\n    " + mValues[i].toString();
+            }
+        }
+        return returnVal;
+    }
 
     /**
      * The target object whose property will be animated by this animation
@@ -527,49 +571,4 @@ public void setupEndValues()
             mValues[i].setupEndValue(mTarget);
         }
     }
-
-    /**
-     * This method is called with the elapsed fraction of the animation during every
-     * animation frame. This function turns the elapsed fraction into an interpolated fraction
-     * and then into an animated value (from the evaluator. The function is called mostly during
-     * animation updates, but it is also called when the <code>end()</code>
-     * function is called, to set the final value on the property.
-     * <p/>
-     * <p>Overrides of this method must call the superclass to perform the calculation
-     * of the animated value.</p>
-     *
-     * @param fraction The elapsed fraction of the animation.
-     */
-    @Override
-    void animateValue(float fraction)
-    {
-        super.animateValue(fraction);
-        int numValues = mValues.length;
-        for (int i = 0; i < numValues; ++i)
-        {
-            mValues[i].setAnimatedValue(mTarget);
-        }
-    }
-
-    @Override
-    public ObjectAnimator clone()
-    {
-        final ObjectAnimator anim = (ObjectAnimator) super.clone();
-        return anim;
-    }
-
-    @Override
-    public String toString()
-    {
-        String returnVal = "ObjectAnimator@" + Integer.toHexString(hashCode()) + ", target " +
-                mTarget;
-        if (mValues != null)
-        {
-            for (int i = 0; i < mValues.length; ++i)
-            {
-                returnVal += "\n    " + mValues[i].toString();
-            }
-        }
-        return returnVal;
-    }
 }
diff --git a/library/src/com/nineoldandroids/animation/TimeAnimator.java b/library/src/com/nineoldandroids/animation/TimeAnimator.java
index 9158632..1d413e6 100644
--- a/library/src/com/nineoldandroids/animation/TimeAnimator.java
+++ b/library/src/com/nineoldandroids/animation/TimeAnimator.java
@@ -15,6 +15,23 @@
     private TimeListener mListener;
     private long mPreviousTime = -1;
 
+    /**
+     * Sets a listener that is sent update events throughout the life of
+     * an animation.
+     *
+     * @param listener the listener to be set.
+     */
+    public void setTimeListener(TimeListener listener)
+    {
+        mListener = listener;
+    }
+
+    @Override
+    void initAnimation()
+    {
+        // noop
+    }
+
     @Override
     boolean animationFrame(long currentTime)
     {
@@ -42,29 +59,12 @@ boolean animationFrame(long currentTime)
         return false;
     }
 
-    /**
-     * Sets a listener that is sent update events throughout the life of
-     * an animation.
-     *
-     * @param listener the listener to be set.
-     */
-    public void setTimeListener(TimeListener listener)
-    {
-        mListener = listener;
-    }
-
     @Override
     void animateValue(float fraction)
     {
         // Noop
     }
 
-    @Override
-    void initAnimation()
-    {
-        // noop
-    }
-
     /**
      * Implementors of this interface can set themselves as update listeners
      * to a <code>TimeAnimator</code> instance to receive callbacks on every animation
diff --git a/library/src/com/nineoldandroids/animation/ValueAnimator.java b/library/src/com/nineoldandroids/animation/ValueAnimator.java
index fda8297..4872cfd 100644
--- a/library/src/com/nineoldandroids/animation/ValueAnimator.java
+++ b/library/src/com/nineoldandroids/animation/ValueAnimator.java
@@ -557,36 +557,6 @@ void initAnimation()
         }
     }
 
-    /**
-     * Gets the length of the animation. The default duration is 300 milliseconds.
-     *
-     * @return The length of the animation, in milliseconds.
-     */
-    public long getDuration()
-    {
-        return mDuration;
-    }
-
-    /**
-     * Sets the length of the animation. The default duration is 300 milliseconds.
-     *
-     * @param duration The length of the animation, in milliseconds. This value cannot
-     *                 be negative.
-     * @return ValueAnimator The object called with setDuration(). This return
-     * value makes it easier to compose statements together that construct and then set the
-     * duration, as in <code>ValueAnimator.ofInt(0, 10).setDuration(500).start()</code>.
-     */
-    public ValueAnimator setDuration(long duration)
-    {
-        if (duration < 0)
-        {
-            throw new IllegalArgumentException("Animators cannot have negative duration: " +
-                                                       duration);
-        }
-        mDuration = duration;
-        return this;
-    }
-
     /**
      * Gets the current position of the animation in time, which is equal to the current
      * time minus the time that the animation started. An animation that is not yet started will
@@ -626,28 +596,6 @@ public void setCurrentPlayTime(long playTime)
         animationFrame(currentTime);
     }
 
-    /**
-     * The amount of time, in milliseconds, to delay starting the animation after
-     * {@link #start()} is called.
-     *
-     * @return the number of milliseconds to delay running the animation
-     */
-    public long getStartDelay()
-    {
-        return mStartDelay;
-    }
-
-    /**
-     * The amount of time, in milliseconds, to delay starting the animation after
-     * {@link #start()} is called.
-     *
-     * @param startDelay The amount of the delay, in milliseconds
-     */
-    public void setStartDelay(long startDelay)
-    {
-        this.mStartDelay = startDelay;
-    }
-
     /**
      * The most recent value calculated by this <code>ValueAnimator</code> when there is just one
      * property being animated. This value is only sensible while the animation is running. The main
@@ -820,6 +768,54 @@ public void setInterpolator(/*Time*/Interpolator value)
         }
     }
 
+    @Override
+    public boolean isRunning()
+    {
+        return (mPlayingState == RUNNING || mRunning);
+    }
+
+    @Override
+    public boolean isStarted()
+    {
+        return mStarted;
+    }
+
+    @Override
+    public ValueAnimator clone()
+    {
+        final ValueAnimator anim = (ValueAnimator) super.clone();
+        if (mUpdateListeners != null)
+        {
+            ArrayList<AnimatorUpdateListener> oldListeners = mUpdateListeners;
+            anim.mUpdateListeners = new ArrayList<AnimatorUpdateListener>();
+            int numListeners = oldListeners.size();
+            for (int i = 0; i < numListeners; ++i)
+            {
+                anim.mUpdateListeners.add(oldListeners.get(i));
+            }
+        }
+        anim.mSeekTime = -1;
+        anim.mPlayingBackwards = false;
+        anim.mCurrentIteration = 0;
+        anim.mInitialized = false;
+        anim.mPlayingState = STOPPED;
+        anim.mStartedDelay = false;
+        PropertyValuesHolder[] oldValues = mValues;
+        if (oldValues != null)
+        {
+            int numValues = oldValues.length;
+            anim.mValues = new PropertyValuesHolder[numValues];
+            anim.mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
+            for (int i = 0; i < numValues; ++i)
+            {
+                PropertyValuesHolder newValuesHolder = oldValues[i].clone();
+                anim.mValues[i] = newValuesHolder;
+                anim.mValuesMap.put(newValuesHolder.getPropertyName(), newValuesHolder);
+            }
+        }
+        return anim;
+    }
+
     /**
      * The type evaluator to be used when calculating the animated values of this animation.
      * The system will automatically assign a float or int evaluator based on the type
@@ -950,16 +946,56 @@ else if (!mInitialized)
         endAnimation();
     }
 
-    @Override
-    public boolean isRunning()
+    /**
+     * The amount of time, in milliseconds, to delay starting the animation after
+     * {@link #start()} is called.
+     *
+     * @return the number of milliseconds to delay running the animation
+     */
+    public long getStartDelay()
     {
-        return (mPlayingState == RUNNING || mRunning);
+        return mStartDelay;
     }
 
-    @Override
-    public boolean isStarted()
+    /**
+     * The amount of time, in milliseconds, to delay starting the animation after
+     * {@link #start()} is called.
+     *
+     * @param startDelay The amount of the delay, in milliseconds
+     */
+    public void setStartDelay(long startDelay)
     {
-        return mStarted;
+        this.mStartDelay = startDelay;
+    }
+
+    /**
+     * Gets the length of the animation. The default duration is 300 milliseconds.
+     *
+     * @return The length of the animation, in milliseconds.
+     */
+    public long getDuration()
+    {
+        return mDuration;
+    }
+
+    /**
+     * Sets the length of the animation. The default duration is 300 milliseconds.
+     *
+     * @param duration The length of the animation, in milliseconds. This value cannot
+     *                 be negative.
+     * @return ValueAnimator The object called with setDuration(). This return
+     * value makes it easier to compose statements together that construct and then set the
+     * duration, as in <code>ValueAnimator.ofInt(0, 10).setDuration(500).start()</code>.
+     */
+    public ValueAnimator setDuration(long duration)
+    {
+        if (duration < 0)
+        {
+            throw new IllegalArgumentException("Animators cannot have negative duration: " +
+                                                       duration);
+        }
+        mDuration = duration;
+        return this;
     }
 
     /**
@@ -1178,42 +1214,6 @@ void animateValue(float fraction)
         }
     }
 
-    @Override
-    public ValueAnimator clone()
-    {
-        final ValueAnimator anim = (ValueAnimator) super.clone();
-        if (mUpdateListeners != null)
-        {
-            ArrayList<AnimatorUpdateListener> oldListeners = mUpdateListeners;
-            anim.mUpdateListeners = new ArrayList<AnimatorUpdateListener>();
-            int numListeners = oldListeners.size();
-            for (int i = 0; i < numListeners; ++i)
-            {
-                anim.mUpdateListeners.add(oldListeners.get(i));
-            }
-        }
-        anim.mSeekTime = -1;
-        anim.mPlayingBackwards = false;
-        anim.mCurrentIteration = 0;
-        anim.mInitialized = false;
-        anim.mPlayingState = STOPPED;
-        anim.mStartedDelay = false;
-        PropertyValuesHolder[] oldValues = mValues;
-        if (oldValues != null)
-        {
-            int numValues = oldValues.length;
-            anim.mValues = new PropertyValuesHolder[numValues];
-            anim.mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
-            for (int i = 0; i < numValues; ++i)
-            {
-                PropertyValuesHolder newValuesHolder = oldValues[i].clone();
-                anim.mValues[i] = newValuesHolder;
-                anim.mValuesMap.put(newValuesHolder.getPropertyName(), newValuesHolder);
-            }
-        }
-        return anim;
-    }
-
     @Override
     public String toString()
     {
diff --git a/library/src/com/nineoldandroids/util/ReflectiveProperty.java b/library/src/com/nineoldandroids/util/ReflectiveProperty.java
index c9a7809..9e54d83 100644
--- a/library/src/com/nineoldandroids/util/ReflectiveProperty.java
+++ b/library/src/com/nineoldandroids/util/ReflectiveProperty.java
@@ -156,6 +156,15 @@ private boolean typesMatch(Class<V> valueType, Class getterType)
         return true;
     }
 
+    /**
+     * Returns false if there is no setter or public field underlying this Property.
+     */
+    @Override
+    public boolean isReadOnly()
+    {
+        return (mSetter == null && mField == null);
+    }
+
     @Override
     public void set(T object, V value)
     {
@@ -223,13 +232,4 @@ else if (mField != null)
         // Should not get here: there should always be a non-null getter or field
         throw new AssertionError();
     }
-
-    /**
-     * Returns false if there is no setter or public field underlying this Property.
-     */
-    @Override
-    public boolean isReadOnly()
-    {
-        return (mSetter == null && mField == null);
-    }
 }
diff --git a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorHC.java b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorHC.java
index 160bfc4..f5fa533 100644
--- a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorHC.java
+++ b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorHC.java
@@ -144,27 +144,6 @@ public void run()
         mView = new WeakReference<View>(view);
     }
 
-    /**
-     * Sets the duration for the underlying animator that animates the requested properties.
-     * By default, the animator uses the default value for ValueAnimator. Calling this method
-     * will cause the declared value to be used instead.
-     *
-     * @param duration The length of ensuing property animations, in milliseconds. The value
-     *                 cannot be negative.
-     * @return This object, allowing calls to methods in this class to be chained.
-     */
-    public ViewPropertyAnimator setDuration(long duration)
-    {
-        if (duration < 0)
-        {
-            throw new IllegalArgumentException("Animators cannot have negative duration: " +
-                                                       duration);
-        }
-        mDurationSet = true;
-        mDuration = duration;
-        return this;
-    }
-
     /**
      * Returns the current duration of property animations. If the duration was set on this
      * object, that value is returned. Otherwise, the default value of the underlying Animator
@@ -187,6 +166,27 @@ public long getDuration()
         }
     }
 
+    /**
+     * Sets the duration for the underlying animator that animates the requested properties.
+     * By default, the animator uses the default value for ValueAnimator. Calling this method
+     * will cause the declared value to be used instead.
+     *
+     * @param duration The length of ensuing property animations, in milliseconds. The value
+     *                 cannot be negative.
+     * @return This object, allowing calls to methods in this class to be chained.
+     */
+    public ViewPropertyAnimator setDuration(long duration)
+    {
+        if (duration < 0)
+        {
+            throw new IllegalArgumentException("Animators cannot have negative duration: " +
+                                                       duration);
+        }
+        mDurationSet = true;
+        mDuration = duration;
+        return this;
+    }
+
     @Override
     public long getStartDelay()
     {
@@ -688,37 +688,37 @@ public void onAnimationStart(Animator animation)
         }
 
         @Override
-        public void onAnimationCancel(Animator animation)
+        public void onAnimationEnd(Animator animation)
         {
             if (mListener != null)
             {
-                mListener.onAnimationCancel(animation);
+                mListener.onAnimationEnd(animation);
+            }
+            mAnimatorMap.remove(animation);
+            // If the map is empty, it means all animation are done or canceled, so the listener
+            // isn't needed anymore. Not nulling it would cause it to leak any objects used in
+            // its implementation
+            if (mAnimatorMap.isEmpty())
+            {
+                mListener = null;
             }
         }
 
         @Override
-        public void onAnimationRepeat(Animator animation)
+        public void onAnimationCancel(Animator animation)
         {
             if (mListener != null)
             {
-                mListener.onAnimationRepeat(animation);
+                mListener.onAnimationCancel(animation);
             }
         }
 
         @Override
-        public void onAnimationEnd(Animator animation)
+        public void onAnimationRepeat(Animator animation)
         {
             if (mListener != null)
             {
-                mListener.onAnimationEnd(animation);
-            }
-            mAnimatorMap.remove(animation);
-            // If the map is empty, it means all animation are done or canceled, so the listener
-            // isn't needed anymore. Not nulling it would cause it to leak any objects used in
-            // its implementation
-            if (mAnimatorMap.isEmpty())
-            {
-                mListener = null;
+                mListener.onAnimationRepeat(animation);
             }
         }
 
diff --git a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorICS.java b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorICS.java
index a60b4cd..971315f 100644
--- a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorICS.java
+++ b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorICS.java
@@ -1,7 +1,5 @@
 package com.nineoldandroids.view;
 
-import android.annotation.TargetApi;
-import android.os.Build;
 import android.view.View;
 import android.view.animation.Interpolator;
 import com.nineoldandroids.animation.Animator.AnimatorListener;
@@ -27,47 +25,47 @@
     }
 
     @Override
-    public ViewPropertyAnimator setDuration(long duration)
+    public long getDuration()
     {
         android.view.ViewPropertyAnimator n = mNative.get();
         if (n != null)
         {
-            n.setDuration(duration);
+            return n.getDuration();
         }
-        return this;
+        return RETURN_WHEN_NULL;
     }
 
     @Override
-    public long getDuration()
+    public ViewPropertyAnimator setDuration(long duration)
     {
         android.view.ViewPropertyAnimator n = mNative.get();
         if (n != null)
         {
-            return n.getDuration();
+            n.setDuration(duration);
         }
-        return RETURN_WHEN_NULL;
+        return this;
     }
 
     @Override
-    public ViewPropertyAnimator setStartDelay(long startDelay)
+    public long getStartDelay()
     {
         android.view.ViewPropertyAnimator n = mNative.get();
         if (n != null)
         {
-            n.setStartDelay(startDelay);
+            return n.getStartDelay();
         }
-        return this;
+        return RETURN_WHEN_NULL;
     }
 
     @Override
-    public long getStartDelay()
+    public ViewPropertyAnimator setStartDelay(long startDelay)
     {
         android.view.ViewPropertyAnimator n = mNative.get();
         if (n != null)
         {
-            return n.getStartDelay();
+            n.setStartDelay(startDelay);
         }
-        return RETURN_WHEN_NULL;
+        return this;
     }
 
     @Override
diff --git a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorPreHC.java b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorPreHC.java
index 5926b43..2ff56a8 100644
--- a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorPreHC.java
+++ b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorPreHC.java
@@ -149,27 +149,6 @@ public void run()
         mProxy = AnimatorProxy.wrap(view);
     }
 
-    /**
-     * Sets the duration for the underlying animator that animates the requested properties.
-     * By default, the animator uses the default value for ValueAnimator. Calling this method
-     * will cause the declared value to be used instead.
-     *
-     * @param duration The length of ensuing property animations, in milliseconds. The value
-     *                 cannot be negative.
-     * @return This object, allowing calls to methods in this class to be chained.
-     */
-    public ViewPropertyAnimator setDuration(long duration)
-    {
-        if (duration < 0)
-        {
-            throw new IllegalArgumentException("Animators cannot have negative duration: " +
-                                                       duration);
-        }
-        mDurationSet = true;
-        mDuration = duration;
-        return this;
-    }
-
     /**
      * Returns the current duration of property animations. If the duration was set on this
      * object, that value is returned. Otherwise, the default value of the underlying Animator
@@ -192,6 +171,27 @@ public long getDuration()
         }
     }
 
+    /**
+     * Sets the duration for the underlying animator that animates the requested properties.
+     * By default, the animator uses the default value for ValueAnimator. Calling this method
+     * will cause the declared value to be used instead.
+     *
+     * @param duration The length of ensuing property animations, in milliseconds. The value
+     *                 cannot be negative.
+     * @return This object, allowing calls to methods in this class to be chained.
+     */
+    public ViewPropertyAnimator setDuration(long duration)
+    {
+        if (duration < 0)
+        {
+            throw new IllegalArgumentException("Animators cannot have negative duration: " +
+                                                       duration);
+        }
+        mDurationSet = true;
+        mDuration = duration;
+        return this;
+    }
+
     @Override
     public long getStartDelay()
     {
@@ -685,37 +685,37 @@ public void onAnimationStart(Animator animation)
         }
 
         @Override
-        public void onAnimationCancel(Animator animation)
+        public void onAnimationEnd(Animator animation)
         {
             if (mListener != null)
             {
-                mListener.onAnimationCancel(animation);
+                mListener.onAnimationEnd(animation);
+            }
+            mAnimatorMap.remove(animation);
+            // If the map is empty, it means all animation are done or canceled, so the listener
+            // isn't needed anymore. Not nulling it would cause it to leak any objects used in
+            // its implementation
+            if (mAnimatorMap.isEmpty())
+            {
+                mListener = null;
             }
         }
 
         @Override
-        public void onAnimationRepeat(Animator animation)
+        public void onAnimationCancel(Animator animation)
         {
             if (mListener != null)
             {
-                mListener.onAnimationRepeat(animation);
+                mListener.onAnimationCancel(animation);
             }
         }
 
         @Override
-        public void onAnimationEnd(Animator animation)
+        public void onAnimationRepeat(Animator animation)
         {
             if (mListener != null)
             {
-                mListener.onAnimationEnd(animation);
-            }
-            mAnimatorMap.remove(animation);
-            // If the map is empty, it means all animation are done or canceled, so the listener
-            // isn't needed anymore. Not nulling it would cause it to leak any objects used in
-            // its implementation
-            if (mAnimatorMap.isEmpty())
-            {
-                mListener = null;
+                mListener.onAnimationRepeat(animation);
             }
         }
 
diff --git a/library/src/com/nineoldandroids/view/animation/AnimatorProxy.java b/library/src/com/nineoldandroids/view/animation/AnimatorProxy.java
index 2a46117..88de954 100644
--- a/library/src/com/nineoldandroids/view/animation/AnimatorProxy.java
+++ b/library/src/com/nineoldandroids/view/animation/AnimatorProxy.java
@@ -42,6 +42,7 @@
     private float mScaleY = 1;
     private float mTranslationX;
     private float mTranslationY;
+
     private AnimatorProxy(View view)
     {
         setDuration(0); //perform transformation immediately
