diff --git a/library/local.properties b/library/local.properties
new file mode 100644
index 0000000..7843cb0
--- /dev/null
+++ b/library/local.properties
@@ -0,0 +1,11 @@
+## This file is automatically generated by Android Studio.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must *NOT* be checked into Version Control Systems,
+# as it contains information specific to your local configuration.
+#
+# Location of the SDK. This is only used by Gradle.
+# For customization when using a Version Control System, please read the
+# header note.
+#Tue Jul 15 02:43:54 PDT 2014
+sdk.dir=/Applications/Android Studio.app/sdk
diff --git a/library/src/com/nineoldandroids/animation/Animator.java b/library/src/com/nineoldandroids/animation/Animator.java
index 399049f..a13f413 100644
--- a/library/src/com/nineoldandroids/animation/Animator.java
+++ b/library/src/com/nineoldandroids/animation/Animator.java
@@ -16,15 +16,16 @@
 
 package com.nineoldandroids.animation;
 
-import java.util.ArrayList;
-
 import android.view.animation.Interpolator;
 
+import java.util.ArrayList;
+
 /**
  * This is the superclass for classes which provide basic support for animations which can be
  * started, ended, and have <code>AnimatorListeners</code> added to them.
  */
-public abstract class Animator implements Cloneable {
+public abstract class Animator implements Cloneable
+{
 
 
     /**
@@ -37,15 +38,15 @@
      * running after that delay elapses. A non-delayed animation will have its initial
      * value(s) set immediately, followed by calls to
      * {@link AnimatorListener#onAnimationStart(Animator)} for any listeners of this animator.
-     *
+     * <p/>
      * <p>The animation started by calling this method will be run on the thread that called
      * this method. This thread should have a Looper on it (a runtime exception will be thrown if
      * this is not the case). Also, if the animation will animate
      * properties of objects in the view hierarchy, then the calling thread should be the UI
      * thread for that view hierarchy.</p>
-     *
      */
-    public void start() {
+    public void start()
+    {
     }
 
     /**
@@ -54,10 +55,11 @@ public void start() {
      * {@link android.animation.Animator.AnimatorListener#onAnimationCancel(Animator)} to
      * its listeners, followed by an
      * {@link android.animation.Animator.AnimatorListener#onAnimationEnd(Animator)} message.
-     *
+     * <p/>
      * <p>This method must be called on the thread that is running the animation.</p>
      */
-    public void cancel() {
+    public void cancel()
+    {
     }
 
     /**
@@ -65,10 +67,11 @@ public void cancel() {
      * animated, then calling the
      * {@link android.animation.Animator.AnimatorListener#onAnimationEnd(Animator)} method on
      * its listeners.
-     *
+     * <p/>
      * <p>This method must be called on the thread that is running the animation.</p>
      */
-    public void end() {
+    public void end()
+    {
     }
 
     /**
@@ -82,25 +85,24 @@ public void end() {
     /**
      * The amount of time, in milliseconds, to delay starting the animation after
      * {@link #start()} is called.
-
+     *
      * @param startDelay The amount of the delay, in milliseconds
      */
     public abstract void setStartDelay(long startDelay);
 
-
     /**
-     * Sets the length of the animation.
+     * Gets the length of the animation.
      *
-     * @param duration The length of the animation, in milliseconds.
+     * @return The length of the animation, in milliseconds.
      */
-    public abstract Animator setDuration(long duration);
+    public abstract long getDuration();
 
     /**
-     * Gets the length of the animation.
+     * Sets the length of the animation.
      *
-     * @return The length of the animation, in milliseconds.
+     * @param duration The length of the animation, in milliseconds.
      */
-    public abstract long getDuration();
+    public abstract Animator setDuration(long duration);
 
     /**
      * The time interpolator used in calculating the elapsed fraction of this animation. The
@@ -129,7 +131,8 @@ public void end() {
      *
      * @return Whether the Animator has been started and not yet ended.
      */
-    public boolean isStarted() {
+    public boolean isStarted()
+    {
         // Default method returns value for isRunning(). Subclasses should override to return a
         // real value.
         return isRunning();
@@ -141,8 +144,10 @@ public boolean isStarted() {
      *
      * @param listener the listener to be added to the current set of listeners for this animation.
      */
-    public void addListener(AnimatorListener listener) {
-        if (mListeners == null) {
+    public void addListener(AnimatorListener listener)
+    {
+        if (mListeners == null)
+        {
             mListeners = new ArrayList<AnimatorListener>();
         }
         mListeners.add(listener);
@@ -154,12 +159,15 @@ public void addListener(AnimatorListener listener) {
      * @param listener the listener to be removed from the current set of listeners for this
      *                 animation.
      */
-    public void removeListener(AnimatorListener listener) {
-        if (mListeners == null) {
+    public void removeListener(AnimatorListener listener)
+    {
+        if (mListeners == null)
+        {
             return;
         }
         mListeners.remove(listener);
-        if (mListeners.size() == 0) {
+        if (mListeners.size() == 0)
+        {
             mListeners = null;
         }
     }
@@ -170,7 +178,8 @@ public void removeListener(AnimatorListener listener) {
      *
      * @return ArrayList<AnimatorListener> The set of listeners.
      */
-    public ArrayList<AnimatorListener> getListeners() {
+    public ArrayList<AnimatorListener> getListeners()
+    {
         return mListeners;
     }
 
@@ -179,28 +188,36 @@ public void removeListener(AnimatorListener listener) {
      * <code>getListeners()</code> followed by calling <code>clear()</code> on the
      * returned list of listeners.
      */
-    public void removeAllListeners() {
-        if (mListeners != null) {
+    public void removeAllListeners()
+    {
+        if (mListeners != null)
+        {
             mListeners.clear();
             mListeners = null;
         }
     }
 
     @Override
-    public Animator clone() {
-        try {
+    public Animator clone()
+    {
+        try
+        {
             final Animator anim = (Animator) super.clone();
-            if (mListeners != null) {
+            if (mListeners != null)
+            {
                 ArrayList<AnimatorListener> oldListeners = mListeners;
                 anim.mListeners = new ArrayList<AnimatorListener>();
                 int numListeners = oldListeners.size();
-                for (int i = 0; i < numListeners; ++i) {
+                for (int i = 0; i < numListeners; ++i)
+                {
                     anim.mListeners.add(oldListeners.get(i));
                 }
             }
             return anim;
-        } catch (CloneNotSupportedException e) {
-           throw new AssertionError();
+        }
+        catch (CloneNotSupportedException e)
+        {
+            throw new AssertionError();
         }
     }
 
@@ -213,7 +230,8 @@ public Animator clone() {
      * An ValueAnimator object will ignore the request since it does not have enough
      * information (such as a target object) to gather these values.
      */
-    public void setupStartValues() {
+    public void setupStartValues()
+    {
     }
 
     /**
@@ -225,7 +243,8 @@ public void setupStartValues() {
      * An ValueAnimator object will ignore the request since it does not have enough
      * information (such as a target object) to gather these values.
      */
-    public void setupEndValues() {
+    public void setupEndValues()
+    {
     }
 
     /**
@@ -236,7 +255,8 @@ public void setupEndValues() {
      *
      * @param target The object being animated
      */
-    public void setTarget(Object target) {
+    public void setTarget(Object target)
+    {
     }
 
     /**
@@ -244,7 +264,8 @@ public void setTarget(Object target) {
      * Notifications indicate animation related events, such as the end or the
      * repetition of the animation.</p>
      */
-    public static interface AnimatorListener {
+    public static interface AnimatorListener
+    {
         /**
          * <p>Notifies the start of the animation.</p>
          *
diff --git a/library/src/com/nineoldandroids/animation/AnimatorInflater.java b/library/src/com/nineoldandroids/animation/AnimatorInflater.java
index f3ab192..79eb83d 100644
--- a/library/src/com/nineoldandroids/animation/AnimatorInflater.java
+++ b/library/src/com/nineoldandroids/animation/AnimatorInflater.java
@@ -17,9 +17,9 @@
 
 import android.content.Context;
 import android.content.res.Resources;
+import android.content.res.Resources.NotFoundException;
 import android.content.res.TypedArray;
 import android.content.res.XmlResourceParser;
-import android.content.res.Resources.NotFoundException;
 import android.util.AttributeSet;
 import android.util.TypedValue;
 import android.util.Xml;
@@ -32,25 +32,26 @@
 
 /**
  * This class is used to instantiate animator XML files into Animator objects.
- * <p>
+ * <p/>
  * For performance reasons, inflation relies heavily on pre-processing of
  * XML files that is done at build time. Therefore, it is not currently possible
  * to use this inflater with an XmlPullParser over a plain XML file at runtime;
  * it only works with an XmlPullParser returned from a compiled resource (R.
  * <em>something</em> file.)
  */
-public class AnimatorInflater {
-    private static final int[] AnimatorSet = new int[] {
+public class AnimatorInflater
+{
+    private static final int[] AnimatorSet = new int[]{
         /* 0 */ android.R.attr.ordering,
     };
     private static final int AnimatorSet_ordering = 0;
 
-    private static final int[] PropertyAnimator = new int[] {
+    private static final int[] PropertyAnimator = new int[]{
         /* 0 */ android.R.attr.propertyName,
     };
     private static final int PropertyAnimator_propertyName = 0;
 
-    private static final int[] Animator = new int[] {
+    private static final int[] Animator = new int[]{
         /* 0 */ android.R.attr.interpolator,
         /* 1 */ android.R.attr.duration,
         /* 2 */ android.R.attr.startOffset,
@@ -78,7 +79,7 @@
     /**
      * Enum values used in XML attributes to indicate the value for mValueType
      */
-    private static final int VALUE_TYPE_FLOAT       = 0;
+    private static final int VALUE_TYPE_FLOAT = 0;
     //private static final int VALUE_TYPE_INT         = 1;
     //private static final int VALUE_TYPE_COLOR       = 4;
     //private static final int VALUE_TYPE_CUSTOM      = 5;
@@ -87,43 +88,56 @@
      * Loads an {@link Animator} object from a resource
      *
      * @param context Application context used to access resources
-     * @param id The resource id of the animation to load
+     * @param id      The resource id of the animation to load
      * @return The animator object reference by the specified id
      * @throws android.content.res.Resources.NotFoundException when the animation cannot be loaded
      */
     public static Animator loadAnimator(Context context, int id)
-            throws NotFoundException {
+            throws NotFoundException
+    {
 
         XmlResourceParser parser = null;
-        try {
+        try
+        {
             parser = context.getResources().getAnimation(id);
             return createAnimatorFromXml(context, parser);
-        } catch (XmlPullParserException ex) {
+        }
+        catch (XmlPullParserException ex)
+        {
             Resources.NotFoundException rnf =
                     new Resources.NotFoundException("Can't load animation resource ID #0x" +
-                    Integer.toHexString(id));
+                                                            Integer.toHexString(id));
             rnf.initCause(ex);
             throw rnf;
-        } catch (IOException ex) {
+        }
+        catch (IOException ex)
+        {
             Resources.NotFoundException rnf =
                     new Resources.NotFoundException("Can't load animation resource ID #0x" +
-                    Integer.toHexString(id));
+                                                            Integer.toHexString(id));
             rnf.initCause(ex);
             throw rnf;
-        } finally {
-            if (parser != null) parser.close();
+        }
+        finally
+        {
+            if (parser != null)
+            {
+                parser.close();
+            }
         }
     }
 
     private static Animator createAnimatorFromXml(Context c, XmlPullParser parser)
-            throws XmlPullParserException, IOException {
+            throws XmlPullParserException, IOException
+    {
 
         return createAnimatorFromXml(c, parser, Xml.asAttributeSet(parser), null, 0);
     }
 
     private static Animator createAnimatorFromXml(Context c, XmlPullParser parser,
-            AttributeSet attrs, AnimatorSet parent, int sequenceOrdering)
-            throws XmlPullParserException, IOException {
+                                                  AttributeSet attrs, AnimatorSet parent, int sequenceOrdering)
+            throws XmlPullParserException, IOException
+    {
 
         Animator anim = null;
         ArrayList<Animator> childAnims = null;
@@ -132,20 +146,27 @@ private static Animator createAnimatorFromXml(Context c, XmlPullParser parser,
         int type;
         int depth = parser.getDepth();
 
-        while (((type=parser.next()) != XmlPullParser.END_TAG || parser.getDepth() > depth)
-               && type != XmlPullParser.END_DOCUMENT) {
+        while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() > depth)
+                && type != XmlPullParser.END_DOCUMENT)
+        {
 
-            if (type != XmlPullParser.START_TAG) {
+            if (type != XmlPullParser.START_TAG)
+            {
                 continue;
             }
 
-            String  name = parser.getName();
+            String name = parser.getName();
 
-            if (name.equals("objectAnimator")) {
+            if (name.equals("objectAnimator"))
+            {
                 anim = loadObjectAnimator(c, attrs);
-            } else if (name.equals("animator")) {
+            }
+            else if (name.equals("animator"))
+            {
                 anim = loadAnimator(c, attrs, null);
-            } else if (name.equals("set")) {
+            }
+            else if (name.equals("set"))
+            {
                 anim = new AnimatorSet();
                 TypedArray a = c.obtainStyledAttributes(attrs,
                         /*com.android.internal.R.styleable.*/AnimatorSet);
@@ -154,28 +175,37 @@ private static Animator createAnimatorFromXml(Context c, XmlPullParser parser,
                 a.getValue(/*com.android.internal.R.styleable.*/AnimatorSet_ordering, orderingValue);
                 int ordering = orderingValue.type == TypedValue.TYPE_INT_DEC ? orderingValue.data : TOGETHER;
 
-                createAnimatorFromXml(c, parser, attrs, (AnimatorSet) anim,  ordering);
+                createAnimatorFromXml(c, parser, attrs, (AnimatorSet) anim, ordering);
                 a.recycle();
-            } else {
+            }
+            else
+            {
                 throw new RuntimeException("Unknown animator name: " + parser.getName());
             }
 
-            if (parent != null) {
-                if (childAnims == null) {
+            if (parent != null)
+            {
+                if (childAnims == null)
+                {
                     childAnims = new ArrayList<Animator>();
                 }
                 childAnims.add(anim);
             }
         }
-        if (parent != null && childAnims != null) {
+        if (parent != null && childAnims != null)
+        {
             Animator[] animsArray = new Animator[childAnims.size()];
             int index = 0;
-            for (Animator a : childAnims) {
+            for (Animator a : childAnims)
+            {
                 animsArray[index++] = a;
             }
-            if (sequenceOrdering == TOGETHER) {
+            if (sequenceOrdering == TOGETHER)
+            {
                 parent.playTogether(animsArray);
-            } else {
+            }
+            else
+            {
                 parent.playSequentially(animsArray);
             }
         }
@@ -185,7 +215,8 @@ private static Animator createAnimatorFromXml(Context c, XmlPullParser parser,
     }
 
     private static ObjectAnimator loadObjectAnimator(Context context, AttributeSet attrs)
-            throws NotFoundException {
+            throws NotFoundException
+    {
 
         ObjectAnimator anim = new ObjectAnimator();
 
@@ -208,10 +239,11 @@ private static ObjectAnimator loadObjectAnimator(Context context, AttributeSet a
      * attributes set.
      *
      * @param context the application environment
-     * @param attrs the set of attributes holding the animation parameters
+     * @param attrs   the set of attributes holding the animation parameters
      */
     private static ValueAnimator loadAnimator(Context context, AttributeSet attrs, ValueAnimator anim)
-            throws NotFoundException {
+            throws NotFoundException
+    {
 
         TypedArray a =
                 context.obtainStyledAttributes(attrs, /*com.android.internal.R.styleable.*/Animator);
@@ -221,9 +253,10 @@ private static ValueAnimator loadAnimator(Context context, AttributeSet attrs, V
         long startDelay = a.getInt(/*com.android.internal.R.styleable.*/Animator_startOffset, 0);
 
         int valueType = a.getInt(/*com.android.internal.R.styleable.*/Animator_valueType,
-                VALUE_TYPE_FLOAT);
+                                 VALUE_TYPE_FLOAT);
 
-        if (anim == null) {
+        if (anim == null)
+        {
             anim = new ValueAnimator();
         }
         //TypeEvaluator evaluator = null;
@@ -242,73 +275,114 @@ private static ValueAnimator loadAnimator(Context context, AttributeSet attrs, V
 
         if ((hasFrom && (fromType >= TypedValue.TYPE_FIRST_COLOR_INT) &&
                 (fromType <= TypedValue.TYPE_LAST_COLOR_INT)) ||
-            (hasTo && (toType >= TypedValue.TYPE_FIRST_COLOR_INT) &&
-                (toType <= TypedValue.TYPE_LAST_COLOR_INT))) {
+                (hasTo && (toType >= TypedValue.TYPE_FIRST_COLOR_INT) &&
+                        (toType <= TypedValue.TYPE_LAST_COLOR_INT)))
+        {
             // special case for colors: ignore valueType and get ints
             getFloats = false;
             anim.setEvaluator(new ArgbEvaluator());
         }
 
-        if (getFloats) {
+        if (getFloats)
+        {
             float valueFrom;
             float valueTo;
-            if (hasFrom) {
-                if (fromType == TypedValue.TYPE_DIMENSION) {
+            if (hasFrom)
+            {
+                if (fromType == TypedValue.TYPE_DIMENSION)
+                {
                     valueFrom = a.getDimension(valueFromIndex, 0f);
-                } else {
+                }
+                else
+                {
                     valueFrom = a.getFloat(valueFromIndex, 0f);
                 }
-                if (hasTo) {
-                    if (toType == TypedValue.TYPE_DIMENSION) {
+                if (hasTo)
+                {
+                    if (toType == TypedValue.TYPE_DIMENSION)
+                    {
                         valueTo = a.getDimension(valueToIndex, 0f);
-                    } else {
+                    }
+                    else
+                    {
                         valueTo = a.getFloat(valueToIndex, 0f);
                     }
                     anim.setFloatValues(valueFrom, valueTo);
-                } else {
+                }
+                else
+                {
                     anim.setFloatValues(valueFrom);
                 }
-            } else {
-                if (toType == TypedValue.TYPE_DIMENSION) {
+            }
+            else
+            {
+                if (toType == TypedValue.TYPE_DIMENSION)
+                {
                     valueTo = a.getDimension(valueToIndex, 0f);
-                } else {
+                }
+                else
+                {
                     valueTo = a.getFloat(valueToIndex, 0f);
                 }
                 anim.setFloatValues(valueTo);
             }
-        } else {
+        }
+        else
+        {
             int valueFrom;
             int valueTo;
-            if (hasFrom) {
-                if (fromType == TypedValue.TYPE_DIMENSION) {
+            if (hasFrom)
+            {
+                if (fromType == TypedValue.TYPE_DIMENSION)
+                {
                     valueFrom = (int) a.getDimension(valueFromIndex, 0f);
-                } else if ((fromType >= TypedValue.TYPE_FIRST_COLOR_INT) &&
-                        (fromType <= TypedValue.TYPE_LAST_COLOR_INT)) {
+                }
+                else if ((fromType >= TypedValue.TYPE_FIRST_COLOR_INT) &&
+                        (fromType <= TypedValue.TYPE_LAST_COLOR_INT))
+                {
                     valueFrom = a.getColor(valueFromIndex, 0);
-                } else {
+                }
+                else
+                {
                     valueFrom = a.getInt(valueFromIndex, 0);
                 }
-                if (hasTo) {
-                    if (toType == TypedValue.TYPE_DIMENSION) {
+                if (hasTo)
+                {
+                    if (toType == TypedValue.TYPE_DIMENSION)
+                    {
                         valueTo = (int) a.getDimension(valueToIndex, 0f);
-                    } else if ((toType >= TypedValue.TYPE_FIRST_COLOR_INT) &&
-                            (toType <= TypedValue.TYPE_LAST_COLOR_INT)) {
+                    }
+                    else if ((toType >= TypedValue.TYPE_FIRST_COLOR_INT) &&
+                            (toType <= TypedValue.TYPE_LAST_COLOR_INT))
+                    {
                         valueTo = a.getColor(valueToIndex, 0);
-                    } else {
+                    }
+                    else
+                    {
                         valueTo = a.getInt(valueToIndex, 0);
                     }
                     anim.setIntValues(valueFrom, valueTo);
-                } else {
+                }
+                else
+                {
                     anim.setIntValues(valueFrom);
                 }
-            } else {
-                if (hasTo) {
-                    if (toType == TypedValue.TYPE_DIMENSION) {
+            }
+            else
+            {
+                if (hasTo)
+                {
+                    if (toType == TypedValue.TYPE_DIMENSION)
+                    {
                         valueTo = (int) a.getDimension(valueToIndex, 0f);
-                    } else if ((toType >= TypedValue.TYPE_FIRST_COLOR_INT) &&
-                        (toType <= TypedValue.TYPE_LAST_COLOR_INT)) {
+                    }
+                    else if ((toType >= TypedValue.TYPE_FIRST_COLOR_INT) &&
+                            (toType <= TypedValue.TYPE_LAST_COLOR_INT))
+                    {
                         valueTo = a.getColor(valueToIndex, 0);
-                    } else {
+                    }
+                    else
+                    {
                         valueTo = a.getInt(valueToIndex, 0);
                     }
                     anim.setIntValues(valueTo);
@@ -319,14 +393,17 @@ private static ValueAnimator loadAnimator(Context context, AttributeSet attrs, V
         anim.setDuration(duration);
         anim.setStartDelay(startDelay);
 
-        if (a.hasValue(/*com.android.internal.R.styleable.*/Animator_repeatCount)) {
+        if (a.hasValue(/*com.android.internal.R.styleable.*/Animator_repeatCount))
+        {
             anim.setRepeatCount(
                     a.getInt(/*com.android.internal.R.styleable.*/Animator_repeatCount, 0));
         }
-        if (a.hasValue(/*com.android.internal.R.styleable.*/Animator_repeatMode)) {
+        if (a.hasValue(/*com.android.internal.R.styleable.*/Animator_repeatMode))
+        {
             anim.setRepeatMode(
                     a.getInt(/*com.android.internal.R.styleable.*/Animator_repeatMode,
-                            ValueAnimator.RESTART));
+                             ValueAnimator.RESTART)
+            );
         }
         //if (evaluator != null) {
         //    anim.setEvaluator(evaluator);
@@ -334,7 +411,8 @@ private static ValueAnimator loadAnimator(Context context, AttributeSet attrs, V
 
         final int resID =
                 a.getResourceId(/*com.android.internal.R.styleable.*/Animator_interpolator, 0);
-        if (resID > 0) {
+        if (resID > 0)
+        {
             anim.setInterpolator(AnimationUtils.loadInterpolator(context, resID));
         }
         a.recycle();
diff --git a/library/src/com/nineoldandroids/animation/AnimatorListenerAdapter.java b/library/src/com/nineoldandroids/animation/AnimatorListenerAdapter.java
index fa5cef3..6cfa597 100644
--- a/library/src/com/nineoldandroids/animation/AnimatorListenerAdapter.java
+++ b/library/src/com/nineoldandroids/animation/AnimatorListenerAdapter.java
@@ -21,34 +21,39 @@
  * Any custom listener that cares only about a subset of the methods of this listener can
  * simply subclass this adapter class instead of implementing the interface directly.
  */
-public abstract class AnimatorListenerAdapter implements Animator.AnimatorListener {
+public abstract class AnimatorListenerAdapter implements Animator.AnimatorListener
+{
 
     /**
      * {@inheritDoc}
      */
     @Override
-    public void onAnimationCancel(Animator animation) {
+    public void onAnimationCancel(Animator animation)
+    {
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
-    public void onAnimationEnd(Animator animation) {
+    public void onAnimationEnd(Animator animation)
+    {
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
-    public void onAnimationRepeat(Animator animation) {
+    public void onAnimationRepeat(Animator animation)
+    {
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
-    public void onAnimationStart(Animator animation) {
+    public void onAnimationStart(Animator animation)
+    {
     }
 
 }
diff --git a/library/src/com/nineoldandroids/animation/AnimatorSet.java b/library/src/com/nineoldandroids/animation/AnimatorSet.java
index 0027ae1..3120f99 100644
--- a/library/src/com/nineoldandroids/animation/AnimatorSet.java
+++ b/library/src/com/nineoldandroids/animation/AnimatorSet.java
@@ -16,17 +16,17 @@
 
 package com.nineoldandroids.animation;
 
+import android.view.animation.Interpolator;
+
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 
-import android.view.animation.Interpolator;
-
 /**
  * This class plays a set of {@link Animator} objects in the specified order. Animations
  * can be set up to play together, in sequence, or after a specified delay.
- *
+ * <p/>
  * <p>There are two different approaches to adding animations to a <code>AnimatorSet</code>:
  * either the {@link AnimatorSet#playTogether(Animator[]) playTogether()} or
  * {@link AnimatorSet#playSequentially(Animator[]) playSequentially()} methods can be called to add
@@ -34,7 +34,7 @@
  * used in conjunction with methods in the {@link AnimatorSet.Builder Builder}
  * class to add animations
  * one by one.</p>
- *
+ * <p/>
  * <p>It is possible to set up a <code>AnimatorSet</code> with circular dependencies between
  * its animations. For example, an animation a1 could be set up to start before animation a2, a2
  * before a3, and a3 before a1. The results of this configuration are undefined, but will typically
@@ -42,7 +42,8 @@
  * circular dependencies do not make logical sense anyway), circular dependencies
  * should be avoided, and the dependency flow of animations should only be in one direction.
  */
-public final class AnimatorSet extends Animator {
+public final class AnimatorSet extends Animator
+{
 
     /**
      * Internal variables
@@ -51,12 +52,19 @@
      * to clone() to make deep copies of them.
      */
 
+    /**
+     * Flag indicating that the AnimatorSet has been manually
+     * terminated (by calling cancel() or end()).
+     * This flag is used to avoid starting other animations when currently-playing
+     * child animations of this AnimatorSet end. It also determines whether cancel/end
+     * notifications are sent out via the normal AnimatorSetListener mechanism.
+     */
+    boolean mTerminated = false;
     /**
      * Tracks animations currently being played, so that we know what to
      * cancel or end when cancel() or end() is called on this AnimatorSet
      */
     private ArrayList<Animator> mPlayingSet = new ArrayList<Animator>();
-
     /**
      * Contains all nodes, mapped to their respective Animators. When new
      * dependency information is added for an Animator, we want to add it
@@ -64,39 +72,25 @@
      * if one already exists.
      */
     private HashMap<Animator, Node> mNodeMap = new HashMap<Animator, Node>();
-
     /**
      * Set of all nodes created for this AnimatorSet. This list is used upon
      * starting the set, and the nodes are placed in sorted order into the
      * sortedNodes collection.
      */
     private ArrayList<Node> mNodes = new ArrayList<Node>();
-
     /**
      * The sorted list of nodes. This is the order in which the animations will
      * be played. The details about when exactly they will be played depend
      * on the dependency relationships of the nodes.
      */
     private ArrayList<Node> mSortedNodes = new ArrayList<Node>();
-
     /**
      * Flag indicating whether the nodes should be sorted prior to playing. This
      * flag allows us to cache the previous sorted nodes so that if the sequence
      * is replayed with no changes, it does not have to re-sort the nodes again.
      */
     private boolean mNeedsSort = true;
-
     private AnimatorSetListener mSetListener = null;
-
-    /**
-     * Flag indicating that the AnimatorSet has been manually
-     * terminated (by calling cancel() or end()).
-     * This flag is used to avoid starting other animations when currently-playing
-     * child animations of this AnimatorSet end. It also determines whether cancel/end
-     * notifications are sent out via the normal AnimatorSetListener mechanism.
-     */
-    boolean mTerminated = false;
-
     /**
      * Indicates whether an AnimatorSet has been start()'d, whether or
      * not there is a nonzero startDelay.
@@ -121,11 +115,14 @@
      *
      * @param items The animations that will be started simultaneously.
      */
-    public void playTogether(Animator... items) {
-        if (items != null) {
+    public void playTogether(Animator... items)
+    {
+        if (items != null)
+        {
             mNeedsSort = true;
             Builder builder = play(items[0]);
-            for (int i = 1; i < items.length; ++i) {
+            for (int i = 1; i < items.length; ++i)
+            {
                 builder.with(items[i]);
             }
         }
@@ -136,14 +133,20 @@ public void playTogether(Animator... items) {
      *
      * @param items The animations that will be started simultaneously.
      */
-    public void playTogether(Collection<Animator> items) {
-        if (items != null && items.size() > 0) {
+    public void playTogether(Collection<Animator> items)
+    {
+        if (items != null && items.size() > 0)
+        {
             mNeedsSort = true;
             Builder builder = null;
-            for (Animator anim : items) {
-                if (builder == null) {
+            for (Animator anim : items)
+            {
+                if (builder == null)
+                {
                     builder = play(anim);
-                } else {
+                }
+                else
+                {
                     builder.with(anim);
                 }
             }
@@ -156,14 +159,20 @@ public void playTogether(Collection<Animator> items) {
      *
      * @param items The animations that will be started one after another.
      */
-    public void playSequentially(Animator... items) {
-        if (items != null) {
+    public void playSequentially(Animator... items)
+    {
+        if (items != null)
+        {
             mNeedsSort = true;
-            if (items.length == 1) {
+            if (items.length == 1)
+            {
                 play(items[0]);
-            } else {
-                for (int i = 0; i < items.length - 1; ++i) {
-                    play(items[i]).before(items[i+1]);
+            }
+            else
+            {
+                for (int i = 0; i < items.length - 1; ++i)
+                {
+                    play(items[i]).before(items[i + 1]);
                 }
             }
         }
@@ -175,14 +184,20 @@ public void playSequentially(Animator... items) {
      *
      * @param items The animations that will be started one after another.
      */
-    public void playSequentially(List<Animator> items) {
-        if (items != null && items.size() > 0) {
+    public void playSequentially(List<Animator> items)
+    {
+        if (items != null && items.size() > 0)
+        {
             mNeedsSort = true;
-            if (items.size() == 1) {
+            if (items.size() == 1)
+            {
                 play(items.get(0));
-            } else {
-                for (int i = 0; i < items.size() - 1; ++i) {
-                    play(items.get(i)).before(items.get(i+1));
+            }
+            else
+            {
+                for (int i = 0; i < items.size() - 1; ++i)
+                {
+                    play(items.get(i)).before(items.get(i + 1));
                 }
             }
         }
@@ -196,9 +211,11 @@ public void playSequentially(List<Animator> items) {
      *
      * @return ArrayList<Animator> The list of child animations of this AnimatorSet.
      */
-    public ArrayList<Animator> getChildAnimations() {
+    public ArrayList<Animator> getChildAnimations()
+    {
         ArrayList<Animator> childList = new ArrayList<Animator>();
-        for (Node node : mNodes) {
+        for (Node node : mNodes)
+        {
             childList.add(node.animation);
         }
         return childList;
@@ -212,13 +229,18 @@ public void playSequentially(List<Animator> items) {
      * @param target The object being animated
      */
     @Override
-    public void setTarget(Object target) {
-        for (Node node : mNodes) {
+    public void setTarget(Object target)
+    {
+        for (Node node : mNodes)
+        {
             Animator animation = node.animation;
-            if (animation instanceof AnimatorSet) {
-                ((AnimatorSet)animation).setTarget(target);
-            } else if (animation instanceof ObjectAnimator) {
-                ((ObjectAnimator)animation).setTarget(target);
+            if (animation instanceof AnimatorSet)
+            {
+                ((AnimatorSet) animation).setTarget(target);
+            }
+            else if (animation instanceof ObjectAnimator)
+            {
+                ((ObjectAnimator) animation).setTarget(target);
             }
         }
     }
@@ -230,8 +252,10 @@ public void setTarget(Object target) {
      * @param interpolator the interpolator to be used by each child animation of this AnimatorSet
      */
     @Override
-    public void setInterpolator(/*Time*/Interpolator interpolator) {
-        for (Node node : mNodes) {
+    public void setInterpolator(/*Time*/Interpolator interpolator)
+    {
+        for (Node node : mNodes)
+        {
             node.animation.setInterpolator(interpolator);
         }
     }
@@ -247,7 +271,7 @@ public void setInterpolator(/*Time*/Interpolator interpolator) {
      * <code>a1</code> first, followed by <code>a2</code>, and
      * <code>play(a1).after(a2)</code> sets up the AnimatorSet to play
      * <code>a2</code> first, followed by <code>a1</code>.
-     *
+     * <p/>
      * <p>Note that <code>play()</code> is the only way to tell the
      * <code>Builder</code> the animation upon which the dependency is created,
      * so successive calls to the various functions in <code>Builder</code>
@@ -258,14 +282,16 @@ public void setInterpolator(/*Time*/Interpolator interpolator) {
      * <code>a2</code> and <code>a3</code>.</p>
      *
      * @param anim The animation that is the dependency used in later calls to the
-     * methods in the returned <code>Builder</code> object. A null parameter will result
-     * in a null <code>Builder</code> return value.
+     *             methods in the returned <code>Builder</code> object. A null parameter will result
+     *             in a null <code>Builder</code> return value.
      * @return Builder The object that constructs the AnimatorSet based on the dependencies
      * outlined in the calls to <code>play</code> and the other methods in the
      * <code>Builder</code object.
      */
-    public Builder play(Animator anim) {
-        if (anim != null) {
+    public Builder play(Animator anim)
+    {
+        if (anim != null)
+        {
             mNeedsSort = true;
             return new Builder(anim);
         }
@@ -274,33 +300,43 @@ public Builder play(Animator anim) {
 
     /**
      * {@inheritDoc}
-     *
+     * <p/>
      * <p>Note that canceling a <code>AnimatorSet</code> also cancels all of the animations that it
      * is responsible for.</p>
      */
     @SuppressWarnings("unchecked")
     @Override
-    public void cancel() {
+    public void cancel()
+    {
         mTerminated = true;
-        if (isStarted()) {
+        if (isStarted())
+        {
             ArrayList<AnimatorListener> tmpListeners = null;
-            if (mListeners != null) {
+            if (mListeners != null)
+            {
                 tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
-                for (AnimatorListener listener : tmpListeners) {
+                for (AnimatorListener listener : tmpListeners)
+                {
                     listener.onAnimationCancel(this);
                 }
             }
-            if (mDelayAnim != null && mDelayAnim.isRunning()) {
+            if (mDelayAnim != null && mDelayAnim.isRunning())
+            {
                 // If we're currently in the startDelay period, just cancel that animator and
                 // send out the end event to all listeners
                 mDelayAnim.cancel();
-            } else  if (mSortedNodes.size() > 0) {
-                for (Node node : mSortedNodes) {
+            }
+            else if (mSortedNodes.size() > 0)
+            {
+                for (Node node : mSortedNodes)
+                {
                     node.animation.cancel();
                 }
             }
-            if (tmpListeners != null) {
-                for (AnimatorListener listener : tmpListeners) {
+            if (tmpListeners != null)
+            {
+                for (AnimatorListener listener : tmpListeners)
+                {
                     listener.onAnimationEnd(this);
                 }
             }
@@ -310,36 +346,46 @@ public void cancel() {
 
     /**
      * {@inheritDoc}
-     *
+     * <p/>
      * <p>Note that ending a <code>AnimatorSet</code> also ends all of the animations that it is
      * responsible for.</p>
      */
     @Override
-    public void end() {
+    public void end()
+    {
         mTerminated = true;
-        if (isStarted()) {
-            if (mSortedNodes.size() != mNodes.size()) {
+        if (isStarted())
+        {
+            if (mSortedNodes.size() != mNodes.size())
+            {
                 // hasn't been started yet - sort the nodes now, then end them
                 sortNodes();
-                for (Node node : mSortedNodes) {
-                    if (mSetListener == null) {
+                for (Node node : mSortedNodes)
+                {
+                    if (mSetListener == null)
+                    {
                         mSetListener = new AnimatorSetListener(this);
                     }
                     node.animation.addListener(mSetListener);
                 }
             }
-            if (mDelayAnim != null) {
+            if (mDelayAnim != null)
+            {
                 mDelayAnim.cancel();
             }
-            if (mSortedNodes.size() > 0) {
-                for (Node node : mSortedNodes) {
+            if (mSortedNodes.size() > 0)
+            {
+                for (Node node : mSortedNodes)
+                {
                     node.animation.end();
                 }
             }
-            if (mListeners != null) {
+            if (mListeners != null)
+            {
                 ArrayList<AnimatorListener> tmpListeners =
                         (ArrayList<AnimatorListener>) mListeners.clone();
-                for (AnimatorListener listener : tmpListeners) {
+                for (AnimatorListener listener : tmpListeners)
+                {
                     listener.onAnimationEnd(this);
                 }
             }
@@ -350,12 +396,16 @@ public void end() {
     /**
      * Returns true if any of the child animations of this AnimatorSet have been started and have
      * not yet ended.
+     *
      * @return Whether this AnimatorSet has been started and has not yet ended.
      */
     @Override
-    public boolean isRunning() {
-        for (Node node : mNodes) {
-            if (node.animation.isRunning()) {
+    public boolean isRunning()
+    {
+        for (Node node : mNodes)
+        {
+            if (node.animation.isRunning())
+            {
                 return true;
             }
         }
@@ -363,7 +413,8 @@ public boolean isRunning() {
     }
 
     @Override
-    public boolean isStarted() {
+    public boolean isStarted()
+    {
         return mStarted;
     }
 
@@ -374,18 +425,20 @@ public boolean isStarted() {
      * @return the number of milliseconds to delay running the animation
      */
     @Override
-    public long getStartDelay() {
+    public long getStartDelay()
+    {
         return mStartDelay;
     }
 
     /**
      * The amount of time, in milliseconds, to delay starting the animation after
      * {@link #start()} is called.
-
+     *
      * @param startDelay The amount of the delay, in milliseconds
      */
     @Override
-    public void setStartDelay(long startDelay) {
+    public void setStartDelay(long startDelay)
+    {
         mStartDelay = startDelay;
     }
 
@@ -398,7 +451,8 @@ public void setStartDelay(long startDelay) {
      * animations of this AnimatorSet.
      */
     @Override
-    public long getDuration() {
+    public long getDuration()
+    {
         return mDuration;
     }
 
@@ -408,14 +462,17 @@ public long getDuration() {
      * then each child animation inherits this duration.
      *
      * @param duration The length of the animation, in milliseconds, of each of the child
-     * animations of this AnimatorSet.
+     *                 animations of this AnimatorSet.
      */
     @Override
-    public AnimatorSet setDuration(long duration) {
-        if (duration < 0) {
+    public AnimatorSet setDuration(long duration)
+    {
+        if (duration < 0)
+        {
             throw new IllegalArgumentException("duration must be a value of zero or greater");
         }
-        for (Node node : mNodes) {
+        for (Node node : mNodes)
+        {
             // TODO: don't set the duration of the timing-only nodes created by AnimatorSet to
             // insert "play-after" delays
             node.animation.setDuration(duration);
@@ -425,29 +482,34 @@ public AnimatorSet setDuration(long duration) {
     }
 
     @Override
-    public void setupStartValues() {
-        for (Node node : mNodes) {
+    public void setupStartValues()
+    {
+        for (Node node : mNodes)
+        {
             node.animation.setupStartValues();
         }
     }
 
     @Override
-    public void setupEndValues() {
-        for (Node node : mNodes) {
+    public void setupEndValues()
+    {
+        for (Node node : mNodes)
+        {
             node.animation.setupEndValues();
         }
     }
 
     /**
      * {@inheritDoc}
-     *
+     * <p/>
      * <p>Starting this <code>AnimatorSet</code> will, in turn, start the animations for which
      * it is responsible. The details of when exactly those animations are started depends on
      * the dependency relationships that have been set up between the animations.
      */
     @SuppressWarnings("unchecked")
     @Override
-    public void start() {
+    public void start()
+    {
         mTerminated = false;
         mStarted = true;
 
@@ -456,17 +518,21 @@ public void start() {
         sortNodes();
 
         int numSortedNodes = mSortedNodes.size();
-        for (int i = 0; i < numSortedNodes; ++i) {
+        for (int i = 0; i < numSortedNodes; ++i)
+        {
             Node node = mSortedNodes.get(i);
             // First, clear out the old listeners
             ArrayList<AnimatorListener> oldListeners = node.animation.getListeners();
-            if (oldListeners != null && oldListeners.size() > 0) {
+            if (oldListeners != null && oldListeners.size() > 0)
+            {
                 final ArrayList<AnimatorListener> clonedListeners = new
                         ArrayList<AnimatorListener>(oldListeners);
 
-                for (AnimatorListener listener : clonedListeners) {
+                for (AnimatorListener listener : clonedListeners)
+                {
                     if (listener instanceof DependencyListener ||
-                            listener instanceof AnimatorSetListener) {
+                            listener instanceof AnimatorSetListener)
+                    {
                         node.animation.removeListener(listener);
                     }
                 }
@@ -478,16 +544,22 @@ public void start() {
         // dependencies on all of the nodes. For example, we don't want to start an animation
         // when some other animation also wants to start when the first animation begins.
         final ArrayList<Node> nodesToStart = new ArrayList<Node>();
-        for (int i = 0; i < numSortedNodes; ++i) {
+        for (int i = 0; i < numSortedNodes; ++i)
+        {
             Node node = mSortedNodes.get(i);
-            if (mSetListener == null) {
+            if (mSetListener == null)
+            {
                 mSetListener = new AnimatorSetListener(this);
             }
-            if (node.dependencies == null || node.dependencies.size() == 0) {
+            if (node.dependencies == null || node.dependencies.size() == 0)
+            {
                 nodesToStart.add(node);
-            } else {
+            }
+            else
+            {
                 int numDependencies = node.dependencies.size();
-                for (int j = 0; j < numDependencies; ++j) {
+                for (int j = 0; j < numDependencies; ++j)
+                {
                     Dependency dependency = node.dependencies.get(j);
                     dependency.node.animation.addListener(
                             new DependencyListener(this, node, dependency.rule));
@@ -497,23 +569,34 @@ public void start() {
             node.animation.addListener(mSetListener);
         }
         // Now that all dependencies are set up, start the animations that should be started.
-        if (mStartDelay <= 0) {
-            for (Node node : nodesToStart) {
+        if (mStartDelay <= 0)
+        {
+            for (Node node : nodesToStart)
+            {
                 node.animation.start();
                 mPlayingSet.add(node.animation);
             }
-        } else {
+        }
+        else
+        {
             mDelayAnim = ValueAnimator.ofFloat(0f, 1f);
             mDelayAnim.setDuration(mStartDelay);
-            mDelayAnim.addListener(new AnimatorListenerAdapter() {
+            mDelayAnim.addListener(new AnimatorListenerAdapter()
+            {
                 boolean canceled = false;
-                public void onAnimationCancel(Animator anim) {
+
+                public void onAnimationCancel(Animator anim)
+                {
                     canceled = true;
                 }
-                public void onAnimationEnd(Animator anim) {
-                    if (!canceled) {
+
+                public void onAnimationEnd(Animator anim)
+                {
+                    if (!canceled)
+                    {
                         int numNodes = nodesToStart.size();
-                        for (int i = 0; i < numNodes; ++i) {
+                        for (int i = 0; i < numNodes; ++i)
+                        {
                             Node node = nodesToStart.get(i);
                             node.animation.start();
                             mPlayingSet.add(node.animation);
@@ -523,23 +606,28 @@ public void onAnimationEnd(Animator anim) {
             });
             mDelayAnim.start();
         }
-        if (mListeners != null) {
+        if (mListeners != null)
+        {
             ArrayList<AnimatorListener> tmpListeners =
                     (ArrayList<AnimatorListener>) mListeners.clone();
             int numListeners = tmpListeners.size();
-            for (int i = 0; i < numListeners; ++i) {
+            for (int i = 0; i < numListeners; ++i)
+            {
                 tmpListeners.get(i).onAnimationStart(this);
             }
         }
-        if (mNodes.size() == 0 && mStartDelay == 0) {
+        if (mNodes.size() == 0 && mStartDelay == 0)
+        {
             // Handle unusual case where empty AnimatorSet is started - should send out
             // end event immediately since the event will not be sent out at all otherwise
             mStarted = false;
-            if (mListeners != null) {
+            if (mListeners != null)
+            {
                 ArrayList<AnimatorListener> tmpListeners =
                         (ArrayList<AnimatorListener>) mListeners.clone();
                 int numListeners = tmpListeners.size();
-                for (int i = 0; i < numListeners; ++i) {
+                for (int i = 0; i < numListeners; ++i)
+                {
                     tmpListeners.get(i).onAnimationEnd(this);
                 }
             }
@@ -547,7 +635,8 @@ public void onAnimationEnd(Animator anim) {
     }
 
     @Override
-    public AnimatorSet clone() {
+    public AnimatorSet clone()
+    {
         final AnimatorSet anim = (AnimatorSet) super.clone();
         /*
          * The basic clone() operation copies all items. This doesn't work very well for
@@ -569,7 +658,8 @@ public AnimatorSet clone() {
         // One problem is that the old node dependencies point to nodes in the old AnimatorSet.
         // We need to track the old/new nodes in order to reconstruct the dependencies in the clone.
         HashMap<Node, Node> nodeCloneMap = new HashMap<Node, Node>(); // <old, new>
-        for (Node node : mNodes) {
+        for (Node node : mNodes)
+        {
             Node nodeClone = node.clone();
             nodeCloneMap.put(node, nodeClone);
             anim.mNodes.add(nodeClone);
@@ -582,18 +672,24 @@ public AnimatorSet clone() {
             // clear out any listeners that were set up by the AnimatorSet; these will
             // be set up when the clone's nodes are sorted
             ArrayList<AnimatorListener> cloneListeners = nodeClone.animation.getListeners();
-            if (cloneListeners != null) {
+            if (cloneListeners != null)
+            {
                 ArrayList<AnimatorListener> listenersToRemove = null;
-                for (AnimatorListener listener : cloneListeners) {
-                    if (listener instanceof AnimatorSetListener) {
-                        if (listenersToRemove == null) {
+                for (AnimatorListener listener : cloneListeners)
+                {
+                    if (listener instanceof AnimatorSetListener)
+                    {
+                        if (listenersToRemove == null)
+                        {
                             listenersToRemove = new ArrayList<AnimatorListener>();
                         }
                         listenersToRemove.add(listener);
                     }
                 }
-                if (listenersToRemove != null) {
-                    for (AnimatorListener listener : listenersToRemove) {
+                if (listenersToRemove != null)
+                {
+                    for (AnimatorListener listener : listenersToRemove)
+                    {
                         cloneListeners.remove(listener);
                     }
                 }
@@ -601,13 +697,16 @@ public AnimatorSet clone() {
         }
         // Now that we've cloned all of the nodes, we're ready to walk through their
         // dependencies, mapping the old dependencies to the new nodes
-        for (Node node : mNodes) {
+        for (Node node : mNodes)
+        {
             Node nodeClone = nodeCloneMap.get(node);
-            if (node.dependencies != null) {
-                for (Dependency dependency : node.dependencies) {
+            if (node.dependencies != null)
+            {
+                for (Dependency dependency : node.dependencies)
+                {
                     Node clonedDependencyNode = nodeCloneMap.get(dependency.node);
                     Dependency cloneDependency = new Dependency(clonedDependencyNode,
-                            dependency.rule);
+                                                                dependency.rule);
                     nodeClone.addDependency(cloneDependency);
                 }
             }
@@ -616,12 +715,103 @@ public AnimatorSet clone() {
         return anim;
     }
 
+    /**
+     * This method sorts the current set of nodes, if needed. The sort is a simple
+     * DependencyGraph sort, which goes like this:
+     * - All nodes without dependencies become 'roots'
+     * - while roots list is not null
+     * -   for each root r
+     * -     add r to sorted list
+     * -     remove r as a dependency from any other node
+     * -   any nodes with no dependencies are added to the roots list
+     */
+    private void sortNodes()
+    {
+        if (mNeedsSort)
+        {
+            mSortedNodes.clear();
+            ArrayList<Node> roots = new ArrayList<Node>();
+            int numNodes = mNodes.size();
+            for (int i = 0; i < numNodes; ++i)
+            {
+                Node node = mNodes.get(i);
+                if (node.dependencies == null || node.dependencies.size() == 0)
+                {
+                    roots.add(node);
+                }
+            }
+            ArrayList<Node> tmpRoots = new ArrayList<Node>();
+            while (roots.size() > 0)
+            {
+                int numRoots = roots.size();
+                for (int i = 0; i < numRoots; ++i)
+                {
+                    Node root = roots.get(i);
+                    mSortedNodes.add(root);
+                    if (root.nodeDependents != null)
+                    {
+                        int numDependents = root.nodeDependents.size();
+                        for (int j = 0; j < numDependents; ++j)
+                        {
+                            Node node = root.nodeDependents.get(j);
+                            node.nodeDependencies.remove(root);
+                            if (node.nodeDependencies.size() == 0)
+                            {
+                                tmpRoots.add(node);
+                            }
+                        }
+                    }
+                }
+                roots.clear();
+                roots.addAll(tmpRoots);
+                tmpRoots.clear();
+            }
+            mNeedsSort = false;
+            if (mSortedNodes.size() != mNodes.size())
+            {
+                throw new IllegalStateException("Circular dependencies cannot exist"
+                                                        + " in AnimatorSet");
+            }
+        }
+        else
+        {
+            // Doesn't need sorting, but still need to add in the nodeDependencies list
+            // because these get removed as the event listeners fire and the dependencies
+            // are satisfied
+            int numNodes = mNodes.size();
+            for (int i = 0; i < numNodes; ++i)
+            {
+                Node node = mNodes.get(i);
+                if (node.dependencies != null && node.dependencies.size() > 0)
+                {
+                    int numDependencies = node.dependencies.size();
+                    for (int j = 0; j < numDependencies; ++j)
+                    {
+                        Dependency dependency = node.dependencies.get(j);
+                        if (node.nodeDependencies == null)
+                        {
+                            node.nodeDependencies = new ArrayList<Node>();
+                        }
+                        if (!node.nodeDependencies.contains(dependency.node))
+                        {
+                            node.nodeDependencies.add(dependency.node);
+                        }
+                    }
+                }
+                // nodes are 'done' by default; they become un-done when started, and done
+                // again when ended
+                node.done = false;
+            }
+        }
+    }
+
     /**
      * This class is the mechanism by which animations are started based on events in other
      * animations. If an animation has multiple dependencies on other animations, then
      * all dependencies must be satisfied before the animation is started.
      */
-    private static class DependencyListener implements AnimatorListener {
+    private static class DependencyListener implements AnimatorListener
+    {
 
         private AnimatorSet mAnimatorSet;
 
@@ -632,7 +822,8 @@ public AnimatorSet clone() {
         // the node
         private int mRule;
 
-        public DependencyListener(AnimatorSet animatorSet, Node node, int rule) {
+        public DependencyListener(AnimatorSet animatorSet, Node node, int rule)
+        {
             this.mAnimatorSet = animatorSet;
             this.mNode = node;
             this.mRule = rule;
@@ -643,14 +834,17 @@ public DependencyListener(AnimatorSet animatorSet, Node node, int rule) {
          * to prevent follow-on animations from running when some dependency
          * animation is canceled.
          */
-        public void onAnimationCancel(Animator animation) {
+        public void onAnimationCancel(Animator animation)
+        {
         }
 
         /**
          * An end event is received - see if this is an event we are listening for
          */
-        public void onAnimationEnd(Animator animation) {
-            if (mRule == Dependency.AFTER) {
+        public void onAnimationEnd(Animator animation)
+        {
+            if (mRule == Dependency.AFTER)
+            {
                 startIfReady(animation);
             }
         }
@@ -658,14 +852,17 @@ public void onAnimationEnd(Animator animation) {
         /**
          * Ignore repeat events for now
          */
-        public void onAnimationRepeat(Animator animation) {
+        public void onAnimationRepeat(Animator animation)
+        {
         }
 
         /**
          * A start event is received - see if this is an event we are listening for
          */
-        public void onAnimationStart(Animator animation) {
-            if (mRule == Dependency.WITH) {
+        public void onAnimationStart(Animator animation)
+        {
+            if (mRule == Dependency.WITH)
+            {
                 startIfReady(animation);
             }
         }
@@ -674,19 +871,24 @@ public void onAnimationStart(Animator animation) {
          * Check whether the event received is one that the node was waiting for.
          * If so, mark it as complete and see whether it's time to start
          * the animation.
+         *
          * @param dependencyAnimation the animation that sent the event.
          */
-        private void startIfReady(Animator dependencyAnimation) {
-            if (mAnimatorSet.mTerminated) {
+        private void startIfReady(Animator dependencyAnimation)
+        {
+            if (mAnimatorSet.mTerminated)
+            {
                 // if the parent AnimatorSet was canceled, then don't start any dependent anims
                 return;
             }
             Dependency dependencyToRemove = null;
             int numDependencies = mNode.tmpDependencies.size();
-            for (int i = 0; i < numDependencies; ++i) {
+            for (int i = 0; i < numDependencies; ++i)
+            {
                 Dependency dependency = mNode.tmpDependencies.get(i);
                 if (dependency.rule == mRule &&
-                        dependency.node.animation == dependencyAnimation) {
+                        dependency.node.animation == dependencyAnimation)
+                {
                     // rule fired - remove the dependency and listener and check to
                     // see whether it's time to start the animation
                     dependencyToRemove = dependency;
@@ -695,7 +897,8 @@ private void startIfReady(Animator dependencyAnimation) {
                 }
             }
             mNode.tmpDependencies.remove(dependencyToRemove);
-            if (mNode.tmpDependencies.size() == 0) {
+            if (mNode.tmpDependencies.size() == 0)
+            {
                 // all dependencies satisfied: start the animation
                 mNode.animation.start();
                 mAnimatorSet.mPlayingSet.add(mNode.animation);
@@ -704,152 +907,12 @@ private void startIfReady(Animator dependencyAnimation) {
 
     }
 
-    private class AnimatorSetListener implements AnimatorListener {
-
-        private AnimatorSet mAnimatorSet;
-
-        AnimatorSetListener(AnimatorSet animatorSet) {
-            mAnimatorSet = animatorSet;
-        }
-
-        public void onAnimationCancel(Animator animation) {
-            if (!mTerminated) {
-                // Listeners are already notified of the AnimatorSet canceling in cancel().
-                // The logic below only kicks in when animations end normally
-                if (mPlayingSet.size() == 0) {
-                    if (mListeners != null) {
-                        int numListeners = mListeners.size();
-                        for (int i = 0; i < numListeners; ++i) {
-                            mListeners.get(i).onAnimationCancel(mAnimatorSet);
-                        }
-                    }
-                }
-            }
-        }
-
-        @SuppressWarnings("unchecked")
-        public void onAnimationEnd(Animator animation) {
-            animation.removeListener(this);
-            mPlayingSet.remove(animation);
-            Node animNode = mAnimatorSet.mNodeMap.get(animation);
-            animNode.done = true;
-            if (!mTerminated) {
-                // Listeners are already notified of the AnimatorSet ending in cancel() or
-                // end(); the logic below only kicks in when animations end normally
-                ArrayList<Node> sortedNodes = mAnimatorSet.mSortedNodes;
-                boolean allDone = true;
-                int numSortedNodes = sortedNodes.size();
-                for (int i = 0; i < numSortedNodes; ++i) {
-                    if (!sortedNodes.get(i).done) {
-                        allDone = false;
-                        break;
-                    }
-                }
-                if (allDone) {
-                    // If this was the last child animation to end, then notify listeners that this
-                    // AnimatorSet has ended
-                    if (mListeners != null) {
-                        ArrayList<AnimatorListener> tmpListeners =
-                                (ArrayList<AnimatorListener>) mListeners.clone();
-                        int numListeners = tmpListeners.size();
-                        for (int i = 0; i < numListeners; ++i) {
-                            tmpListeners.get(i).onAnimationEnd(mAnimatorSet);
-                        }
-                    }
-                    mAnimatorSet.mStarted = false;
-                }
-            }
-        }
-
-        // Nothing to do
-        public void onAnimationRepeat(Animator animation) {
-        }
-
-        // Nothing to do
-        public void onAnimationStart(Animator animation) {
-        }
-
-    }
-
-    /**
-     * This method sorts the current set of nodes, if needed. The sort is a simple
-     * DependencyGraph sort, which goes like this:
-     * - All nodes without dependencies become 'roots'
-     * - while roots list is not null
-     * -   for each root r
-     * -     add r to sorted list
-     * -     remove r as a dependency from any other node
-     * -   any nodes with no dependencies are added to the roots list
-     */
-    private void sortNodes() {
-        if (mNeedsSort) {
-            mSortedNodes.clear();
-            ArrayList<Node> roots = new ArrayList<Node>();
-            int numNodes = mNodes.size();
-            for (int i = 0; i < numNodes; ++i) {
-                Node node = mNodes.get(i);
-                if (node.dependencies == null || node.dependencies.size() == 0) {
-                    roots.add(node);
-                }
-            }
-            ArrayList<Node> tmpRoots = new ArrayList<Node>();
-            while (roots.size() > 0) {
-                int numRoots = roots.size();
-                for (int i = 0; i < numRoots; ++i) {
-                    Node root = roots.get(i);
-                    mSortedNodes.add(root);
-                    if (root.nodeDependents != null) {
-                        int numDependents = root.nodeDependents.size();
-                        for (int j = 0; j < numDependents; ++j) {
-                            Node node = root.nodeDependents.get(j);
-                            node.nodeDependencies.remove(root);
-                            if (node.nodeDependencies.size() == 0) {
-                                tmpRoots.add(node);
-                            }
-                        }
-                    }
-                }
-                roots.clear();
-                roots.addAll(tmpRoots);
-                tmpRoots.clear();
-            }
-            mNeedsSort = false;
-            if (mSortedNodes.size() != mNodes.size()) {
-                throw new IllegalStateException("Circular dependencies cannot exist"
-                        + " in AnimatorSet");
-            }
-        } else {
-            // Doesn't need sorting, but still need to add in the nodeDependencies list
-            // because these get removed as the event listeners fire and the dependencies
-            // are satisfied
-            int numNodes = mNodes.size();
-            for (int i = 0; i < numNodes; ++i) {
-                Node node = mNodes.get(i);
-                if (node.dependencies != null && node.dependencies.size() > 0) {
-                    int numDependencies = node.dependencies.size();
-                    for (int j = 0; j < numDependencies; ++j) {
-                        Dependency dependency = node.dependencies.get(j);
-                        if (node.nodeDependencies == null) {
-                            node.nodeDependencies = new ArrayList<Node>();
-                        }
-                        if (!node.nodeDependencies.contains(dependency.node)) {
-                            node.nodeDependencies.add(dependency.node);
-                        }
-                    }
-                }
-                // nodes are 'done' by default; they become un-done when started, and done
-                // again when ended
-                node.done = false;
-            }
-        }
-    }
-
     /**
      * Dependency holds information about the node that some other node is
      * dependent upon and the nature of that dependency.
-     *
      */
-    private static class Dependency {
+    private static class Dependency
+    {
         static final int WITH = 0; // dependent node must start with this dependency node
         static final int AFTER = 1; // dependent node must start when this dependency node finishes
 
@@ -859,7 +922,8 @@ private void sortNodes() {
         // The nature of the dependency (WITH or AFTER)
         public int rule;
 
-        public Dependency(Node node, int rule) {
+        public Dependency(Node node, int rule)
+        {
             this.node = node;
             this.rule = rule;
         }
@@ -871,14 +935,15 @@ public Dependency(Node node, int rule) {
      * both dependencies upon other nodes (in the dependencies list) as
      * well as dependencies of other nodes upon this (in the nodeDependents list).
      */
-    private static class Node implements Cloneable {
+    private static class Node implements Cloneable
+    {
         public Animator animation;
 
         /**
-         *  These are the dependencies that this node's animation has on other
-         *  nodes. For example, if this node's animation should begin with some
-         *  other animation ends, then there will be an item in this node's
-         *  dependencies list for that other animation's node.
+         * These are the dependencies that this node's animation has on other
+         * nodes. For example, if this node's animation should begin with some
+         * other animation ends, then there will be an item in this node's
+         * dependencies list for that other animation's node.
          */
         public ArrayList<Dependency> dependencies = null;
 
@@ -920,41 +985,134 @@ public Dependency(Node node, int rule) {
          *
          * @param animation The animation that the Node encapsulates.
          */
-        public Node(Animator animation) {
+        public Node(Animator animation)
+        {
             this.animation = animation;
         }
 
         /**
          * Add a dependency to this Node. The dependency includes information about the
          * node that this node is dependency upon and the nature of the dependency.
+         *
          * @param dependency
          */
-        public void addDependency(Dependency dependency) {
-            if (dependencies == null) {
+        public void addDependency(Dependency dependency)
+        {
+            if (dependencies == null)
+            {
                 dependencies = new ArrayList<Dependency>();
                 nodeDependencies = new ArrayList<Node>();
             }
             dependencies.add(dependency);
-            if (!nodeDependencies.contains(dependency.node)) {
+            if (!nodeDependencies.contains(dependency.node))
+            {
                 nodeDependencies.add(dependency.node);
             }
             Node dependencyNode = dependency.node;
-            if (dependencyNode.nodeDependents == null) {
+            if (dependencyNode.nodeDependents == null)
+            {
                 dependencyNode.nodeDependents = new ArrayList<Node>();
             }
             dependencyNode.nodeDependents.add(this);
         }
 
         @Override
-        public Node clone() {
-            try {
+        public Node clone()
+        {
+            try
+            {
                 Node node = (Node) super.clone();
                 node.animation = (Animator) animation.clone();
                 return node;
-            } catch (CloneNotSupportedException e) {
-               throw new AssertionError();
+            }
+            catch (CloneNotSupportedException e)
+            {
+                throw new AssertionError();
+            }
+        }
+    }
+
+    private class AnimatorSetListener implements AnimatorListener
+    {
+
+        private AnimatorSet mAnimatorSet;
+
+        AnimatorSetListener(AnimatorSet animatorSet)
+        {
+            mAnimatorSet = animatorSet;
+        }
+
+        public void onAnimationCancel(Animator animation)
+        {
+            if (!mTerminated)
+            {
+                // Listeners are already notified of the AnimatorSet canceling in cancel().
+                // The logic below only kicks in when animations end normally
+                if (mPlayingSet.size() == 0)
+                {
+                    if (mListeners != null)
+                    {
+                        int numListeners = mListeners.size();
+                        for (int i = 0; i < numListeners; ++i)
+                        {
+                            mListeners.get(i).onAnimationCancel(mAnimatorSet);
+                        }
+                    }
+                }
             }
         }
+
+        @SuppressWarnings("unchecked")
+        public void onAnimationEnd(Animator animation)
+        {
+            animation.removeListener(this);
+            mPlayingSet.remove(animation);
+            Node animNode = mAnimatorSet.mNodeMap.get(animation);
+            animNode.done = true;
+            if (!mTerminated)
+            {
+                // Listeners are already notified of the AnimatorSet ending in cancel() or
+                // end(); the logic below only kicks in when animations end normally
+                ArrayList<Node> sortedNodes = mAnimatorSet.mSortedNodes;
+                boolean allDone = true;
+                int numSortedNodes = sortedNodes.size();
+                for (int i = 0; i < numSortedNodes; ++i)
+                {
+                    if (!sortedNodes.get(i).done)
+                    {
+                        allDone = false;
+                        break;
+                    }
+                }
+                if (allDone)
+                {
+                    // If this was the last child animation to end, then notify listeners that this
+                    // AnimatorSet has ended
+                    if (mListeners != null)
+                    {
+                        ArrayList<AnimatorListener> tmpListeners =
+                                (ArrayList<AnimatorListener>) mListeners.clone();
+                        int numListeners = tmpListeners.size();
+                        for (int i = 0; i < numListeners; ++i)
+                        {
+                            tmpListeners.get(i).onAnimationEnd(mAnimatorSet);
+                        }
+                    }
+                    mAnimatorSet.mStarted = false;
+                }
+            }
+        }
+
+        // Nothing to do
+        public void onAnimationRepeat(Animator animation)
+        {
+        }
+
+        // Nothing to do
+        public void onAnimationStart(Animator animation)
+        {
+        }
+
     }
 
     /**
@@ -1009,7 +1167,8 @@ public Node clone() {
      * that can boil down to a simple, one-way relationship of animations starting with, before, and
      * after other, different, animations.</p>
      */
-    public class Builder {
+    public class Builder
+    {
 
         /**
          * This tracks the current node being processed. It is supplied to the play() method
@@ -1022,11 +1181,13 @@ public Node clone() {
          * play() method is called.
          *
          * @param anim The animation that is the dependency for the other animations passed into
-         * the other methods of this Builder object.
+         *             the other methods of this Builder object.
          */
-        Builder(Animator anim) {
+        Builder(Animator anim)
+        {
             mCurrentNode = mNodeMap.get(anim);
-            if (mCurrentNode == null) {
+            if (mCurrentNode == null)
+            {
                 mCurrentNode = new Node(anim);
                 mNodeMap.put(anim, mCurrentNode);
                 mNodes.add(mCurrentNode);
@@ -1038,11 +1199,13 @@ public Node clone() {
          * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object.
          *
          * @param anim The animation that will play when the animation supplied to the
-         * {@link AnimatorSet#play(Animator)} method starts.
+         *             {@link AnimatorSet#play(Animator)} method starts.
          */
-        public Builder with(Animator anim) {
+        public Builder with(Animator anim)
+        {
             Node node = mNodeMap.get(anim);
-            if (node == null) {
+            if (node == null)
+            {
                 node = new Node(anim);
                 mNodeMap.put(anim, node);
                 mNodes.add(node);
@@ -1058,11 +1221,13 @@ public Builder with(Animator anim) {
          * ends.
          *
          * @param anim The animation that will play when the animation supplied to the
-         * {@link AnimatorSet#play(Animator)} method ends.
+         *             {@link AnimatorSet#play(Animator)} method ends.
          */
-        public Builder before(Animator anim) {
+        public Builder before(Animator anim)
+        {
             Node node = mNodeMap.get(anim);
-            if (node == null) {
+            if (node == null)
+            {
                 node = new Node(anim);
                 mNodeMap.put(anim, node);
                 mNodes.add(node);
@@ -1078,11 +1243,13 @@ public Builder before(Animator anim) {
          * to start when the animation supplied in this method call ends.
          *
          * @param anim The animation whose end will cause the animation supplied to the
-         * {@link AnimatorSet#play(Animator)} method to play.
+         *             {@link AnimatorSet#play(Animator)} method to play.
          */
-        public Builder after(Animator anim) {
+        public Builder after(Animator anim)
+        {
             Node node = mNodeMap.get(anim);
-            if (node == null) {
+            if (node == null)
+            {
                 node = new Node(anim);
                 mNodeMap.put(anim, node);
                 mNodes.add(node);
@@ -1098,9 +1265,10 @@ public Builder after(Animator anim) {
          * to play when the given amount of time elapses.
          *
          * @param delay The number of milliseconds that should elapse before the
-         * animation starts.
+         *              animation starts.
          */
-        public Builder after(long delay) {
+        public Builder after(long delay)
+        {
             // setup dummy ValueAnimator just to run the clock
             ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);
             anim.setDuration(delay);
diff --git a/library/src/com/nineoldandroids/animation/ArgbEvaluator.java b/library/src/com/nineoldandroids/animation/ArgbEvaluator.java
index 8c19f01..e7186b8 100644
--- a/library/src/com/nineoldandroids/animation/ArgbEvaluator.java
+++ b/library/src/com/nineoldandroids/animation/ArgbEvaluator.java
@@ -20,7 +20,8 @@
  * This evaluator can be used to perform type interpolation between integer
  * values that represent ARGB colors.
  */
-public class ArgbEvaluator implements TypeEvaluator {
+public class ArgbEvaluator implements TypeEvaluator
+{
 
     /**
      * This function returns the calculated in-between value for a color
@@ -28,17 +29,18 @@
      * bytes of the 32-bit int. Each channel is separately linearly interpolated
      * and the resulting calculated values are recombined into the return value.
      *
-     * @param fraction The fraction from the starting to the ending values
+     * @param fraction   The fraction from the starting to the ending values
      * @param startValue A 32-bit int value representing colors in the
-     * separate bytes of the parameter
-     * @param endValue A 32-bit int value representing colors in the
-     * separate bytes of the parameter
+     *                   separate bytes of the parameter
+     * @param endValue   A 32-bit int value representing colors in the
+     *                   separate bytes of the parameter
      * @return A value that is calculated to be the linearly interpolated
      * result, derived by separating the start and end values into separate
      * color channels and interpolating each one separately, recombining the
      * resulting values in the same way.
      */
-    public Object evaluate(float fraction, Object startValue, Object endValue) {
+    public Object evaluate(float fraction, Object startValue, Object endValue)
+    {
         int startInt = (Integer) startValue;
         int startA = (startInt >> 24);
         int startR = (startInt >> 16) & 0xff;
@@ -51,9 +53,9 @@ public Object evaluate(float fraction, Object startValue, Object endValue) {
         int endG = (endInt >> 8) & 0xff;
         int endB = endInt & 0xff;
 
-        return (int)((startA + (int)(fraction * (endA - startA))) << 24) |
-                (int)((startR + (int)(fraction * (endR - startR))) << 16) |
-                (int)((startG + (int)(fraction * (endG - startG))) << 8) |
-                (int)((startB + (int)(fraction * (endB - startB))));
+        return (int) ((startA + (int) (fraction * (endA - startA))) << 24) |
+                (int) ((startR + (int) (fraction * (endR - startR))) << 16) |
+                (int) ((startG + (int) (fraction * (endG - startG))) << 8) |
+                (int) ((startB + (int) (fraction * (endB - startB))));
     }
 }
\ No newline at end of file
diff --git a/library/src/com/nineoldandroids/animation/FloatEvaluator.java b/library/src/com/nineoldandroids/animation/FloatEvaluator.java
index c53cdfd..05c9f28 100644
--- a/library/src/com/nineoldandroids/animation/FloatEvaluator.java
+++ b/library/src/com/nineoldandroids/animation/FloatEvaluator.java
@@ -19,7 +19,8 @@
 /**
  * This evaluator can be used to perform type interpolation between <code>float</code> values.
  */
-public class FloatEvaluator implements TypeEvaluator<Number> {
+public class FloatEvaluator implements TypeEvaluator<Number>
+{
 
     /**
      * This function returns the result of linearly interpolating the start and end values, with
@@ -33,9 +34,10 @@
      *                   <code>Float</code>
      * @param endValue   The end value; should be of type <code>float</code> or <code>Float</code>
      * @return A linear interpolation between the start and end values, given the
-     *         <code>fraction</code> parameter.
+     * <code>fraction</code> parameter.
      */
-    public Float evaluate(float fraction, Number startValue, Number endValue) {
+    public Float evaluate(float fraction, Number startValue, Number endValue)
+    {
         float startFloat = startValue.floatValue();
         return startFloat + fraction * (endValue.floatValue() - startFloat);
     }
diff --git a/library/src/com/nineoldandroids/animation/FloatKeyframeSet.java b/library/src/com/nineoldandroids/animation/FloatKeyframeSet.java
index 1c32f9c..b313c82 100644
--- a/library/src/com/nineoldandroids/animation/FloatKeyframeSet.java
+++ b/library/src/com/nineoldandroids/animation/FloatKeyframeSet.java
@@ -17,7 +17,6 @@
 package com.nineoldandroids.animation;
 
 import android.view.animation.Interpolator;
-
 import com.nineoldandroids.animation.Keyframe.FloatKeyframe;
 
 import java.util.ArrayList;
@@ -26,110 +25,130 @@
  * This class holds a collection of FloatKeyframe objects and is called by ValueAnimator to calculate
  * values between those keyframes for a given animation. The class internal to the animation
  * package because it is an implementation detail of how Keyframes are stored and used.
- *
+ * <p/>
  * <p>This type-specific subclass of KeyframeSet, along with the other type-specific subclass for
  * int, exists to speed up the getValue() method when there is no custom
  * TypeEvaluator set for the animation, so that values can be calculated without autoboxing to the
  * Object equivalents of these primitive types.</p>
  */
-class FloatKeyframeSet extends KeyframeSet {
+class FloatKeyframeSet extends KeyframeSet
+{
     private float firstValue;
     private float lastValue;
     private float deltaValue;
     private boolean firstTime = true;
 
-    public FloatKeyframeSet(FloatKeyframe... keyframes) {
+    public FloatKeyframeSet(FloatKeyframe... keyframes)
+    {
         super(keyframes);
     }
 
     @Override
-    public Object getValue(float fraction) {
+    public Object getValue(float fraction)
+    {
         return getFloatValue(fraction);
     }
 
     @Override
-    public FloatKeyframeSet clone() {
+    public FloatKeyframeSet clone()
+    {
         ArrayList<Keyframe> keyframes = mKeyframes;
         int numKeyframes = mKeyframes.size();
         FloatKeyframe[] newKeyframes = new FloatKeyframe[numKeyframes];
-        for (int i = 0; i < numKeyframes; ++i) {
+        for (int i = 0; i < numKeyframes; ++i)
+        {
             newKeyframes[i] = (FloatKeyframe) keyframes.get(i).clone();
         }
         FloatKeyframeSet newSet = new FloatKeyframeSet(newKeyframes);
         return newSet;
     }
 
-    public float getFloatValue(float fraction) {
-        if (mNumKeyframes == 2) {
-            if (firstTime) {
+    public float getFloatValue(float fraction)
+    {
+        if (mNumKeyframes == 2)
+        {
+            if (firstTime)
+            {
                 firstTime = false;
                 firstValue = ((FloatKeyframe) mKeyframes.get(0)).getFloatValue();
                 lastValue = ((FloatKeyframe) mKeyframes.get(1)).getFloatValue();
                 deltaValue = lastValue - firstValue;
             }
-            if (mInterpolator != null) {
+            if (mInterpolator != null)
+            {
                 fraction = mInterpolator.getInterpolation(fraction);
             }
-            if (mEvaluator == null) {
+            if (mEvaluator == null)
+            {
                 return firstValue + fraction * deltaValue;
-            } else {
-                return ((Number)mEvaluator.evaluate(fraction, firstValue, lastValue)).floatValue();
+            }
+            else
+            {
+                return ((Number) mEvaluator.evaluate(fraction, firstValue, lastValue)).floatValue();
             }
         }
-        if (fraction <= 0f) {
+        if (fraction <= 0f)
+        {
             final FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(0);
             final FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(1);
             float prevValue = prevKeyframe.getFloatValue();
             float nextValue = nextKeyframe.getFloatValue();
             float prevFraction = prevKeyframe.getFraction();
             float nextFraction = nextKeyframe.getFraction();
-            final /*Time*/Interpolator interpolator = nextKeyframe.getInterpolator();
-            if (interpolator != null) {
+            final /*Time*/ Interpolator interpolator = nextKeyframe.getInterpolator();
+            if (interpolator != null)
+            {
                 fraction = interpolator.getInterpolation(fraction);
             }
             float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
             return mEvaluator == null ?
                     prevValue + intervalFraction * (nextValue - prevValue) :
-                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
-                            floatValue();
-        } else if (fraction >= 1f) {
+                    ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
+                                                                                                  floatValue();
+        }
+        else if (fraction >= 1f)
+        {
             final FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - 2);
             final FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - 1);
             float prevValue = prevKeyframe.getFloatValue();
             float nextValue = nextKeyframe.getFloatValue();
             float prevFraction = prevKeyframe.getFraction();
             float nextFraction = nextKeyframe.getFraction();
-            final /*Time*/Interpolator interpolator = nextKeyframe.getInterpolator();
-            if (interpolator != null) {
+            final /*Time*/ Interpolator interpolator = nextKeyframe.getInterpolator();
+            if (interpolator != null)
+            {
                 fraction = interpolator.getInterpolation(fraction);
             }
             float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
             return mEvaluator == null ?
                     prevValue + intervalFraction * (nextValue - prevValue) :
-                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
-                            floatValue();
+                    ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
+                                                                                                  floatValue();
         }
         FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(0);
-        for (int i = 1; i < mNumKeyframes; ++i) {
+        for (int i = 1; i < mNumKeyframes; ++i)
+        {
             FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(i);
-            if (fraction < nextKeyframe.getFraction()) {
-                final /*Time*/Interpolator interpolator = nextKeyframe.getInterpolator();
-                if (interpolator != null) {
+            if (fraction < nextKeyframe.getFraction())
+            {
+                final /*Time*/ Interpolator interpolator = nextKeyframe.getInterpolator();
+                if (interpolator != null)
+                {
                     fraction = interpolator.getInterpolation(fraction);
                 }
                 float intervalFraction = (fraction - prevKeyframe.getFraction()) /
-                    (nextKeyframe.getFraction() - prevKeyframe.getFraction());
+                        (nextKeyframe.getFraction() - prevKeyframe.getFraction());
                 float prevValue = prevKeyframe.getFloatValue();
                 float nextValue = nextKeyframe.getFloatValue();
                 return mEvaluator == null ?
                         prevValue + intervalFraction * (nextValue - prevValue) :
-                        ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
-                            floatValue();
+                        ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
+                                                                                                      floatValue();
             }
             prevKeyframe = nextKeyframe;
         }
         // shouldn't get here
-        return ((Number)mKeyframes.get(mNumKeyframes - 1).getValue()).floatValue();
+        return ((Number) mKeyframes.get(mNumKeyframes - 1).getValue()).floatValue();
     }
 
 }
diff --git a/library/src/com/nineoldandroids/animation/IntEvaluator.java b/library/src/com/nineoldandroids/animation/IntEvaluator.java
index d60542b..7bf8a7b 100644
--- a/library/src/com/nineoldandroids/animation/IntEvaluator.java
+++ b/library/src/com/nineoldandroids/animation/IntEvaluator.java
@@ -19,7 +19,8 @@
 /**
  * This evaluator can be used to perform type interpolation between <code>int</code> values.
  */
-public class IntEvaluator implements TypeEvaluator<Integer> {
+public class IntEvaluator implements TypeEvaluator<Integer>
+{
 
     /**
      * This function returns the result of linearly interpolating the start and end values, with
@@ -33,10 +34,11 @@
      *                   <code>Integer</code>
      * @param endValue   The end value; should be of type <code>int</code> or <code>Integer</code>
      * @return A linear interpolation between the start and end values, given the
-     *         <code>fraction</code> parameter.
+     * <code>fraction</code> parameter.
      */
-    public Integer evaluate(float fraction, Integer startValue, Integer endValue) {
+    public Integer evaluate(float fraction, Integer startValue, Integer endValue)
+    {
         int startInt = startValue;
-        return (int)(startInt + fraction * (endValue - startInt));
+        return (int) (startInt + fraction * (endValue - startInt));
     }
 }
\ No newline at end of file
diff --git a/library/src/com/nineoldandroids/animation/IntKeyframeSet.java b/library/src/com/nineoldandroids/animation/IntKeyframeSet.java
index 9c26c1e..8841e8d 100644
--- a/library/src/com/nineoldandroids/animation/IntKeyframeSet.java
+++ b/library/src/com/nineoldandroids/animation/IntKeyframeSet.java
@@ -17,7 +17,6 @@
 package com.nineoldandroids.animation;
 
 import android.view.animation.Interpolator;
-
 import com.nineoldandroids.animation.Keyframe.IntKeyframe;
 
 import java.util.ArrayList;
@@ -26,109 +25,129 @@
  * This class holds a collection of IntKeyframe objects and is called by ValueAnimator to calculate
  * values between those keyframes for a given animation. The class internal to the animation
  * package because it is an implementation detail of how Keyframes are stored and used.
- *
+ * <p/>
  * <p>This type-specific subclass of KeyframeSet, along with the other type-specific subclass for
  * float, exists to speed up the getValue() method when there is no custom
  * TypeEvaluator set for the animation, so that values can be calculated without autoboxing to the
  * Object equivalents of these primitive types.</p>
  */
-class IntKeyframeSet extends KeyframeSet {
+class IntKeyframeSet extends KeyframeSet
+{
     private int firstValue;
     private int lastValue;
     private int deltaValue;
     private boolean firstTime = true;
 
-    public IntKeyframeSet(IntKeyframe... keyframes) {
+    public IntKeyframeSet(IntKeyframe... keyframes)
+    {
         super(keyframes);
     }
 
     @Override
-    public Object getValue(float fraction) {
+    public Object getValue(float fraction)
+    {
         return getIntValue(fraction);
     }
 
     @Override
-    public IntKeyframeSet clone() {
+    public IntKeyframeSet clone()
+    {
         ArrayList<Keyframe> keyframes = mKeyframes;
         int numKeyframes = mKeyframes.size();
         IntKeyframe[] newKeyframes = new IntKeyframe[numKeyframes];
-        for (int i = 0; i < numKeyframes; ++i) {
+        for (int i = 0; i < numKeyframes; ++i)
+        {
             newKeyframes[i] = (IntKeyframe) keyframes.get(i).clone();
         }
         IntKeyframeSet newSet = new IntKeyframeSet(newKeyframes);
         return newSet;
     }
 
-    public int getIntValue(float fraction) {
-        if (mNumKeyframes == 2) {
-            if (firstTime) {
+    public int getIntValue(float fraction)
+    {
+        if (mNumKeyframes == 2)
+        {
+            if (firstTime)
+            {
                 firstTime = false;
                 firstValue = ((IntKeyframe) mKeyframes.get(0)).getIntValue();
                 lastValue = ((IntKeyframe) mKeyframes.get(1)).getIntValue();
                 deltaValue = lastValue - firstValue;
             }
-            if (mInterpolator != null) {
+            if (mInterpolator != null)
+            {
                 fraction = mInterpolator.getInterpolation(fraction);
             }
-            if (mEvaluator == null) {
-                return firstValue + (int)(fraction * deltaValue);
-            } else {
-                return ((Number)mEvaluator.evaluate(fraction, firstValue, lastValue)).intValue();
+            if (mEvaluator == null)
+            {
+                return firstValue + (int) (fraction * deltaValue);
+            }
+            else
+            {
+                return ((Number) mEvaluator.evaluate(fraction, firstValue, lastValue)).intValue();
             }
         }
-        if (fraction <= 0f) {
+        if (fraction <= 0f)
+        {
             final IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(0);
             final IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(1);
             int prevValue = prevKeyframe.getIntValue();
             int nextValue = nextKeyframe.getIntValue();
             float prevFraction = prevKeyframe.getFraction();
             float nextFraction = nextKeyframe.getFraction();
-            final /*Time*/Interpolator interpolator = nextKeyframe.getInterpolator();
-            if (interpolator != null) {
+            final /*Time*/ Interpolator interpolator = nextKeyframe.getInterpolator();
+            if (interpolator != null)
+            {
                 fraction = interpolator.getInterpolation(fraction);
             }
             float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
             return mEvaluator == null ?
-                    prevValue + (int)(intervalFraction * (nextValue - prevValue)) :
-                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
-                            intValue();
-        } else if (fraction >= 1f) {
+                    prevValue + (int) (intervalFraction * (nextValue - prevValue)) :
+                    ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
+                                                                                                  intValue();
+        }
+        else if (fraction >= 1f)
+        {
             final IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - 2);
             final IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - 1);
             int prevValue = prevKeyframe.getIntValue();
             int nextValue = nextKeyframe.getIntValue();
             float prevFraction = prevKeyframe.getFraction();
             float nextFraction = nextKeyframe.getFraction();
-            final /*Time*/Interpolator interpolator = nextKeyframe.getInterpolator();
-            if (interpolator != null) {
+            final /*Time*/ Interpolator interpolator = nextKeyframe.getInterpolator();
+            if (interpolator != null)
+            {
                 fraction = interpolator.getInterpolation(fraction);
             }
             float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
             return mEvaluator == null ?
-                    prevValue + (int)(intervalFraction * (nextValue - prevValue)) :
-                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
+                    prevValue + (int) (intervalFraction * (nextValue - prevValue)) :
+                    ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
         }
         IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(0);
-        for (int i = 1; i < mNumKeyframes; ++i) {
+        for (int i = 1; i < mNumKeyframes; ++i)
+        {
             IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(i);
-            if (fraction < nextKeyframe.getFraction()) {
-                final /*Time*/Interpolator interpolator = nextKeyframe.getInterpolator();
-                if (interpolator != null) {
+            if (fraction < nextKeyframe.getFraction())
+            {
+                final /*Time*/ Interpolator interpolator = nextKeyframe.getInterpolator();
+                if (interpolator != null)
+                {
                     fraction = interpolator.getInterpolation(fraction);
                 }
                 float intervalFraction = (fraction - prevKeyframe.getFraction()) /
-                    (nextKeyframe.getFraction() - prevKeyframe.getFraction());
+                        (nextKeyframe.getFraction() - prevKeyframe.getFraction());
                 int prevValue = prevKeyframe.getIntValue();
                 int nextValue = nextKeyframe.getIntValue();
                 return mEvaluator == null ?
-                        prevValue + (int)(intervalFraction * (nextValue - prevValue)) :
-                        ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
-                                intValue();
+                        prevValue + (int) (intervalFraction * (nextValue - prevValue)) :
+                        ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
+                                                                                                      intValue();
             }
             prevKeyframe = nextKeyframe;
         }
         // shouldn't get here
-        return ((Number)mKeyframes.get(mNumKeyframes - 1).getValue()).intValue();
+        return ((Number) mKeyframes.get(mNumKeyframes - 1).getValue()).intValue();
     }
 
 }
diff --git a/library/src/com/nineoldandroids/animation/Keyframe.java b/library/src/com/nineoldandroids/animation/Keyframe.java
index e7062a6..de06a8e 100644
--- a/library/src/com/nineoldandroids/animation/Keyframe.java
+++ b/library/src/com/nineoldandroids/animation/Keyframe.java
@@ -25,7 +25,7 @@
  * target object will animate between the value at the previous keyframe and the value at the
  * next keyframe. Each keyframe also holds an optional {@link TimeInterpolator}
  * object, which defines the time interpolation over the intervalue preceding the keyframe.
- *
+ * <p/>
  * <p>The Keyframe class itself is abstract. The type-specific factory methods will return
  * a subclass of Keyframe specific to the type of value being stored. This is done to improve
  * performance when dealing with the most common cases (e.g., <code>float</code> and
@@ -35,7 +35,8 @@
  * of {@link TypeEvaluator}), you should stick to using float and int as animations using those
  * types have lower runtime overhead than other types.</p>
  */
-public abstract class Keyframe implements Cloneable {
+public abstract class Keyframe implements Cloneable
+{
     /**
      * The time at which mValue will hold true.
      */
@@ -46,19 +47,17 @@
      * based on the type of the <code>value</code> object passed into the constructor.
      */
     Class mValueType;
-
-    /**
-     * The optional time interpolator for the interval preceding this keyframe. A null interpolator
-     * (the default) results in linear interpolation over the interval.
-     */
-    private /*Time*/Interpolator mInterpolator = null;
-
     /**
      * Flag to indicate whether this keyframe has a valid value. This flag is used when an
      * animation first starts, to populate placeholder keyframes with real values derived
      * from the target object.
      */
     boolean mHasValue = false;
+    /**
+     * The optional time interpolator for the interval preceding this keyframe. A null interpolator
+     * (the default) results in linear interpolation over the interval.
+     */
+    private /*Time*/ Interpolator mInterpolator = null;
 
     /**
      * Constructs a Keyframe object with the given time and value. The time defines the
@@ -67,12 +66,13 @@
      * an interpolation between the values at those keyframes.
      *
      * @param fraction The time, expressed as a value between 0 and 1, representing the fraction
-     * of time elapsed of the overall animation duration.
-     * @param value The value that the object will animate to as the animation time approaches
-     * the time in this keyframe, and the the value animated from as the time passes the time in
-     * this keyframe.
+     *                 of time elapsed of the overall animation duration.
+     * @param value    The value that the object will animate to as the animation time approaches
+     *                 the time in this keyframe, and the the value animated from as the time passes the time in
+     *                 this keyframe.
      */
-    public static Keyframe ofInt(float fraction, int value) {
+    public static Keyframe ofInt(float fraction, int value)
+    {
         return new IntKeyframe(fraction, value);
     }
 
@@ -86,9 +86,10 @@ public static Keyframe ofInt(float fraction, int value) {
      * an interpolation between the values at those keyframes.
      *
      * @param fraction The time, expressed as a value between 0 and 1, representing the fraction
-     * of time elapsed of the overall animation duration.
+     *                 of time elapsed of the overall animation duration.
      */
-    public static Keyframe ofInt(float fraction) {
+    public static Keyframe ofInt(float fraction)
+    {
         return new IntKeyframe(fraction);
     }
 
@@ -99,12 +100,13 @@ public static Keyframe ofInt(float fraction) {
      * an interpolation between the values at those keyframes.
      *
      * @param fraction The time, expressed as a value between 0 and 1, representing the fraction
-     * of time elapsed of the overall animation duration.
-     * @param value The value that the object will animate to as the animation time approaches
-     * the time in this keyframe, and the the value animated from as the time passes the time in
-     * this keyframe.
+     *                 of time elapsed of the overall animation duration.
+     * @param value    The value that the object will animate to as the animation time approaches
+     *                 the time in this keyframe, and the the value animated from as the time passes the time in
+     *                 this keyframe.
      */
-    public static Keyframe ofFloat(float fraction, float value) {
+    public static Keyframe ofFloat(float fraction, float value)
+    {
         return new FloatKeyframe(fraction, value);
     }
 
@@ -118,9 +120,10 @@ public static Keyframe ofFloat(float fraction, float value) {
      * an interpolation between the values at those keyframes.
      *
      * @param fraction The time, expressed as a value between 0 and 1, representing the fraction
-     * of time elapsed of the overall animation duration.
+     *                 of time elapsed of the overall animation duration.
      */
-    public static Keyframe ofFloat(float fraction) {
+    public static Keyframe ofFloat(float fraction)
+    {
         return new FloatKeyframe(fraction);
     }
 
@@ -131,12 +134,13 @@ public static Keyframe ofFloat(float fraction) {
      * an interpolation between the values at those keyframes.
      *
      * @param fraction The time, expressed as a value between 0 and 1, representing the fraction
-     * of time elapsed of the overall animation duration.
-     * @param value The value that the object will animate to as the animation time approaches
-     * the time in this keyframe, and the the value animated from as the time passes the time in
-     * this keyframe.
+     *                 of time elapsed of the overall animation duration.
+     * @param value    The value that the object will animate to as the animation time approaches
+     *                 the time in this keyframe, and the the value animated from as the time passes the time in
+     *                 this keyframe.
      */
-    public static Keyframe ofObject(float fraction, Object value) {
+    public static Keyframe ofObject(float fraction, Object value)
+    {
         return new ObjectKeyframe(fraction, value);
     }
 
@@ -150,9 +154,10 @@ public static Keyframe ofObject(float fraction, Object value) {
      * an interpolation between the values at those keyframes.
      *
      * @param fraction The time, expressed as a value between 0 and 1, representing the fraction
-     * of time elapsed of the overall animation duration.
+     *                 of time elapsed of the overall animation duration.
      */
-    public static Keyframe ofObject(float fraction) {
+    public static Keyframe ofObject(float fraction)
+    {
         return new ObjectKeyframe(fraction, null);
     }
 
@@ -163,7 +168,8 @@ public static Keyframe ofObject(float fraction) {
      *
      * @return boolean Whether this object has a value assigned.
      */
-    public boolean hasValue() {
+    public boolean hasValue()
+    {
         return mHasValue;
     }
 
@@ -187,7 +193,8 @@ public boolean hasValue() {
      * @return The time associated with this keyframe, as a fraction of the overall animation
      * duration. This should be a value between 0 and 1.
      */
-    public float getFraction() {
+    public float getFraction()
+    {
         return mFraction;
     }
 
@@ -195,9 +202,10 @@ public float getFraction() {
      * Sets the time for this keyframe, as a fraction of the overall animation duration.
      *
      * @param fraction time associated with this keyframe, as a fraction of the overall animation
-     * duration. This should be a value between 0 and 1.
+     *                 duration. This should be a value between 0 and 1.
      */
-    public void setFraction(float fraction) {
+    public void setFraction(float fraction)
+    {
         mFraction = fraction;
     }
 
@@ -207,7 +215,8 @@ public void setFraction(float fraction) {
      *
      * @return The optional interpolator for this Keyframe.
      */
-    public /*Time*/Interpolator getInterpolator() {
+    public /*Time*/Interpolator getInterpolator()
+    {
         return mInterpolator;
     }
 
@@ -217,7 +226,8 @@ public void setFraction(float fraction) {
      *
      * @return The optional interpolator for this Keyframe.
      */
-    public void setInterpolator(/*Time*/Interpolator interpolator) {
+    public void setInterpolator(/*Time*/Interpolator interpolator)
+    {
         mInterpolator = interpolator;
     }
 
@@ -228,7 +238,8 @@ public void setInterpolator(/*Time*/Interpolator interpolator) {
      *
      * @return The type of the value stored in the Keyframe.
      */
-    public Class getType() {
+    public Class getType()
+    {
         return mValueType;
     }
 
@@ -238,31 +249,36 @@ public Class getType() {
     /**
      * This internal subclass is used for all types which are not int or float.
      */
-    static class ObjectKeyframe extends Keyframe {
+    static class ObjectKeyframe extends Keyframe
+    {
 
         /**
          * The value of the animation at the time mFraction.
          */
         Object mValue;
 
-        ObjectKeyframe(float fraction, Object value) {
+        ObjectKeyframe(float fraction, Object value)
+        {
             mFraction = fraction;
             mValue = value;
             mHasValue = (value != null);
             mValueType = mHasValue ? value.getClass() : Object.class;
         }
 
-        public Object getValue() {
+        public Object getValue()
+        {
             return mValue;
         }
 
-        public void setValue(Object value) {
+        public void setValue(Object value)
+        {
             mValue = value;
             mHasValue = (value != null);
         }
 
         @Override
-        public ObjectKeyframe clone() {
+        public ObjectKeyframe clone()
+        {
             ObjectKeyframe kfClone = new ObjectKeyframe(getFraction(), mValue);
             kfClone.setInterpolator(getInterpolator());
             return kfClone;
@@ -272,42 +288,50 @@ public ObjectKeyframe clone() {
     /**
      * Internal subclass used when the keyframe value is of type int.
      */
-    static class IntKeyframe extends Keyframe {
+    static class IntKeyframe extends Keyframe
+    {
 
         /**
          * The value of the animation at the time mFraction.
          */
         int mValue;
 
-        IntKeyframe(float fraction, int value) {
+        IntKeyframe(float fraction, int value)
+        {
             mFraction = fraction;
             mValue = value;
             mValueType = int.class;
             mHasValue = true;
         }
 
-        IntKeyframe(float fraction) {
+        IntKeyframe(float fraction)
+        {
             mFraction = fraction;
             mValueType = int.class;
         }
 
-        public int getIntValue() {
+        public int getIntValue()
+        {
             return mValue;
         }
 
-        public Object getValue() {
+        public Object getValue()
+        {
             return mValue;
         }
 
-        public void setValue(Object value) {
-            if (value != null && value.getClass() == Integer.class) {
-                mValue = ((Integer)value).intValue();
+        public void setValue(Object value)
+        {
+            if (value != null && value.getClass() == Integer.class)
+            {
+                mValue = ((Integer) value).intValue();
                 mHasValue = true;
             }
         }
 
         @Override
-        public IntKeyframe clone() {
+        public IntKeyframe clone()
+        {
             IntKeyframe kfClone = new IntKeyframe(getFraction(), mValue);
             kfClone.setInterpolator(getInterpolator());
             return kfClone;
@@ -317,41 +341,49 @@ public IntKeyframe clone() {
     /**
      * Internal subclass used when the keyframe value is of type float.
      */
-    static class FloatKeyframe extends Keyframe {
+    static class FloatKeyframe extends Keyframe
+    {
         /**
          * The value of the animation at the time mFraction.
          */
         float mValue;
 
-        FloatKeyframe(float fraction, float value) {
+        FloatKeyframe(float fraction, float value)
+        {
             mFraction = fraction;
             mValue = value;
             mValueType = float.class;
             mHasValue = true;
         }
 
-        FloatKeyframe(float fraction) {
+        FloatKeyframe(float fraction)
+        {
             mFraction = fraction;
             mValueType = float.class;
         }
 
-        public float getFloatValue() {
+        public float getFloatValue()
+        {
             return mValue;
         }
 
-        public Object getValue() {
+        public Object getValue()
+        {
             return mValue;
         }
 
-        public void setValue(Object value) {
-            if (value != null && value.getClass() == Float.class) {
-                mValue = ((Float)value).floatValue();
+        public void setValue(Object value)
+        {
+            if (value != null && value.getClass() == Float.class)
+            {
+                mValue = ((Float) value).floatValue();
                 mHasValue = true;
             }
         }
 
         @Override
-        public FloatKeyframe clone() {
+        public FloatKeyframe clone()
+        {
             FloatKeyframe kfClone = new FloatKeyframe(getFraction(), mValue);
             kfClone.setInterpolator(getInterpolator());
             return kfClone;
diff --git a/library/src/com/nineoldandroids/animation/KeyframeSet.java b/library/src/com/nineoldandroids/animation/KeyframeSet.java
index 5694d4c..c915258 100644
--- a/library/src/com/nineoldandroids/animation/KeyframeSet.java
+++ b/library/src/com/nineoldandroids/animation/KeyframeSet.java
@@ -16,32 +16,33 @@
 
 package com.nineoldandroids.animation;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-
 import android.view.animation.Interpolator;
-
 import com.nineoldandroids.animation.Keyframe.FloatKeyframe;
 import com.nineoldandroids.animation.Keyframe.IntKeyframe;
 import com.nineoldandroids.animation.Keyframe.ObjectKeyframe;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+
 /**
  * This class holds a collection of Keyframe objects and is called by ValueAnimator to calculate
  * values between those keyframes for a given animation. The class internal to the animation
  * package because it is an implementation detail of how Keyframes are stored and used.
  */
-class KeyframeSet {
+class KeyframeSet
+{
 
     int mNumKeyframes;
 
     Keyframe mFirstKeyframe;
     Keyframe mLastKeyframe;
-    /*Time*/Interpolator mInterpolator; // only used in the 2-keyframe case
+    /*Time*/ Interpolator mInterpolator; // only used in the 2-keyframe case
     ArrayList<Keyframe> mKeyframes; // only used when there are not 2 keyframes
     TypeEvaluator mEvaluator;
 
 
-    public KeyframeSet(Keyframe... keyframes) {
+    public KeyframeSet(Keyframe... keyframes)
+    {
         mNumKeyframes = keyframes.length;
         mKeyframes = new ArrayList<Keyframe>();
         mKeyframes.addAll(Arrays.asList(keyframes));
@@ -50,77 +51,106 @@ public KeyframeSet(Keyframe... keyframes) {
         mInterpolator = mLastKeyframe.getInterpolator();
     }
 
-    public static KeyframeSet ofInt(int... values) {
+    public static KeyframeSet ofInt(int... values)
+    {
         int numKeyframes = values.length;
-        IntKeyframe keyframes[] = new IntKeyframe[Math.max(numKeyframes,2)];
-        if (numKeyframes == 1) {
+        IntKeyframe keyframes[] = new IntKeyframe[Math.max(numKeyframes, 2)];
+        if (numKeyframes == 1)
+        {
             keyframes[0] = (IntKeyframe) Keyframe.ofInt(0f);
             keyframes[1] = (IntKeyframe) Keyframe.ofInt(1f, values[0]);
-        } else {
+        }
+        else
+        {
             keyframes[0] = (IntKeyframe) Keyframe.ofInt(0f, values[0]);
-            for (int i = 1; i < numKeyframes; ++i) {
+            for (int i = 1; i < numKeyframes; ++i)
+            {
                 keyframes[i] = (IntKeyframe) Keyframe.ofInt((float) i / (numKeyframes - 1), values[i]);
             }
         }
         return new IntKeyframeSet(keyframes);
     }
 
-    public static KeyframeSet ofFloat(float... values) {
+    public static KeyframeSet ofFloat(float... values)
+    {
         int numKeyframes = values.length;
-        FloatKeyframe keyframes[] = new FloatKeyframe[Math.max(numKeyframes,2)];
-        if (numKeyframes == 1) {
+        FloatKeyframe keyframes[] = new FloatKeyframe[Math.max(numKeyframes, 2)];
+        if (numKeyframes == 1)
+        {
             keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f);
             keyframes[1] = (FloatKeyframe) Keyframe.ofFloat(1f, values[0]);
-        } else {
+        }
+        else
+        {
             keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f, values[0]);
-            for (int i = 1; i < numKeyframes; ++i) {
+            for (int i = 1; i < numKeyframes; ++i)
+            {
                 keyframes[i] = (FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]);
             }
         }
         return new FloatKeyframeSet(keyframes);
     }
 
-    public static KeyframeSet ofKeyframe(Keyframe... keyframes) {
+    public static KeyframeSet ofKeyframe(Keyframe... keyframes)
+    {
         // if all keyframes of same primitive type, create the appropriate KeyframeSet
         int numKeyframes = keyframes.length;
         boolean hasFloat = false;
         boolean hasInt = false;
         boolean hasOther = false;
-        for (int i = 0; i < numKeyframes; ++i) {
-            if (keyframes[i] instanceof FloatKeyframe) {
+        for (int i = 0; i < numKeyframes; ++i)
+        {
+            if (keyframes[i] instanceof FloatKeyframe)
+            {
                 hasFloat = true;
-            } else if (keyframes[i] instanceof IntKeyframe) {
+            }
+            else if (keyframes[i] instanceof IntKeyframe)
+            {
                 hasInt = true;
-            } else {
+            }
+            else
+            {
                 hasOther = true;
             }
         }
-        if (hasFloat && !hasInt && !hasOther) {
+        if (hasFloat && !hasInt && !hasOther)
+        {
             FloatKeyframe floatKeyframes[] = new FloatKeyframe[numKeyframes];
-            for (int i = 0; i < numKeyframes; ++i) {
+            for (int i = 0; i < numKeyframes; ++i)
+            {
                 floatKeyframes[i] = (FloatKeyframe) keyframes[i];
             }
             return new FloatKeyframeSet(floatKeyframes);
-        } else if (hasInt && !hasFloat && !hasOther) {
+        }
+        else if (hasInt && !hasFloat && !hasOther)
+        {
             IntKeyframe intKeyframes[] = new IntKeyframe[numKeyframes];
-            for (int i = 0; i < numKeyframes; ++i) {
+            for (int i = 0; i < numKeyframes; ++i)
+            {
                 intKeyframes[i] = (IntKeyframe) keyframes[i];
             }
             return new IntKeyframeSet(intKeyframes);
-        } else {
+        }
+        else
+        {
             return new KeyframeSet(keyframes);
         }
     }
 
-    public static KeyframeSet ofObject(Object... values) {
+    public static KeyframeSet ofObject(Object... values)
+    {
         int numKeyframes = values.length;
-        ObjectKeyframe keyframes[] = new ObjectKeyframe[Math.max(numKeyframes,2)];
-        if (numKeyframes == 1) {
+        ObjectKeyframe keyframes[] = new ObjectKeyframe[Math.max(numKeyframes, 2)];
+        if (numKeyframes == 1)
+        {
             keyframes[0] = (ObjectKeyframe) Keyframe.ofObject(0f);
             keyframes[1] = (ObjectKeyframe) Keyframe.ofObject(1f, values[0]);
-        } else {
+        }
+        else
+        {
             keyframes[0] = (ObjectKeyframe) Keyframe.ofObject(0f, values[0]);
-            for (int i = 1; i < numKeyframes; ++i) {
+            for (int i = 1; i < numKeyframes; ++i)
+            {
                 keyframes[i] = (ObjectKeyframe) Keyframe.ofObject((float) i / (numKeyframes - 1), values[i]);
             }
         }
@@ -135,22 +165,36 @@ public static KeyframeSet ofObject(Object... values) {
      *
      * @param evaluator The TypeEvaluator to be used to calculate animated values.
      */
-    public void setEvaluator(TypeEvaluator evaluator) {
+    public void setEvaluator(TypeEvaluator evaluator)
+    {
         mEvaluator = evaluator;
     }
 
     @Override
-    public KeyframeSet clone() {
+    public KeyframeSet clone()
+    {
         ArrayList<Keyframe> keyframes = mKeyframes;
         int numKeyframes = mKeyframes.size();
         Keyframe[] newKeyframes = new Keyframe[numKeyframes];
-        for (int i = 0; i < numKeyframes; ++i) {
+        for (int i = 0; i < numKeyframes; ++i)
+        {
             newKeyframes[i] = keyframes.get(i).clone();
         }
         KeyframeSet newSet = new KeyframeSet(newKeyframes);
         return newSet;
     }
 
+    @Override
+    public String toString()
+    {
+        String returnVal = " ";
+        for (int i = 0; i < mNumKeyframes; ++i)
+        {
+            returnVal += mKeyframes.get(i).getValue() + "  ";
+        }
+        return returnVal;
+    }
+
     /**
      * Gets the animated value, given the elapsed fraction of the animation (interpolated by the
      * animation's interpolator) and the evaluator used to calculate in-between values. This
@@ -163,65 +207,67 @@ public KeyframeSet clone() {
      * @param fraction The elapsed fraction of the animation
      * @return The animated value.
      */
-    public Object getValue(float fraction) {
+    public Object getValue(float fraction)
+    {
 
         // Special-case optimization for the common case of only two keyframes
-        if (mNumKeyframes == 2) {
-            if (mInterpolator != null) {
+        if (mNumKeyframes == 2)
+        {
+            if (mInterpolator != null)
+            {
                 fraction = mInterpolator.getInterpolation(fraction);
             }
             return mEvaluator.evaluate(fraction, mFirstKeyframe.getValue(),
-                    mLastKeyframe.getValue());
+                                       mLastKeyframe.getValue());
         }
-        if (fraction <= 0f) {
+        if (fraction <= 0f)
+        {
             final Keyframe nextKeyframe = mKeyframes.get(1);
-            final /*Time*/Interpolator interpolator = nextKeyframe.getInterpolator();
-            if (interpolator != null) {
+            final /*Time*/ Interpolator interpolator = nextKeyframe.getInterpolator();
+            if (interpolator != null)
+            {
                 fraction = interpolator.getInterpolation(fraction);
             }
             final float prevFraction = mFirstKeyframe.getFraction();
             float intervalFraction = (fraction - prevFraction) /
-                (nextKeyframe.getFraction() - prevFraction);
+                    (nextKeyframe.getFraction() - prevFraction);
             return mEvaluator.evaluate(intervalFraction, mFirstKeyframe.getValue(),
-                    nextKeyframe.getValue());
-        } else if (fraction >= 1f) {
+                                       nextKeyframe.getValue());
+        }
+        else if (fraction >= 1f)
+        {
             final Keyframe prevKeyframe = mKeyframes.get(mNumKeyframes - 2);
-            final /*Time*/Interpolator interpolator = mLastKeyframe.getInterpolator();
-            if (interpolator != null) {
+            final /*Time*/ Interpolator interpolator = mLastKeyframe.getInterpolator();
+            if (interpolator != null)
+            {
                 fraction = interpolator.getInterpolation(fraction);
             }
             final float prevFraction = prevKeyframe.getFraction();
             float intervalFraction = (fraction - prevFraction) /
-                (mLastKeyframe.getFraction() - prevFraction);
+                    (mLastKeyframe.getFraction() - prevFraction);
             return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(),
-                    mLastKeyframe.getValue());
+                                       mLastKeyframe.getValue());
         }
         Keyframe prevKeyframe = mFirstKeyframe;
-        for (int i = 1; i < mNumKeyframes; ++i) {
+        for (int i = 1; i < mNumKeyframes; ++i)
+        {
             Keyframe nextKeyframe = mKeyframes.get(i);
-            if (fraction < nextKeyframe.getFraction()) {
-                final /*Time*/Interpolator interpolator = nextKeyframe.getInterpolator();
-                if (interpolator != null) {
+            if (fraction < nextKeyframe.getFraction())
+            {
+                final /*Time*/ Interpolator interpolator = nextKeyframe.getInterpolator();
+                if (interpolator != null)
+                {
                     fraction = interpolator.getInterpolation(fraction);
                 }
                 final float prevFraction = prevKeyframe.getFraction();
                 float intervalFraction = (fraction - prevFraction) /
-                    (nextKeyframe.getFraction() - prevFraction);
+                        (nextKeyframe.getFraction() - prevFraction);
                 return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(),
-                        nextKeyframe.getValue());
+                                           nextKeyframe.getValue());
             }
             prevKeyframe = nextKeyframe;
         }
         // shouldn't reach here
         return mLastKeyframe.getValue();
     }
-
-    @Override
-    public String toString() {
-        String returnVal = " ";
-        for (int i = 0; i < mNumKeyframes; ++i) {
-            returnVal += mKeyframes.get(i).getValue() + "  ";
-        }
-        return returnVal;
-    }
 }
diff --git a/library/src/com/nineoldandroids/animation/ObjectAnimator.java b/library/src/com/nineoldandroids/animation/ObjectAnimator.java
index 7b779ee..b999d02 100644
--- a/library/src/com/nineoldandroids/animation/ObjectAnimator.java
+++ b/library/src/com/nineoldandroids/animation/ObjectAnimator.java
@@ -16,16 +16,15 @@
 
 package com.nineoldandroids.animation;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Map;
-
 import android.util.Log;
 import android.view.View;
-
 import com.nineoldandroids.util.Property;
 import com.nineoldandroids.view.animation.AnimatorProxy;
 
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+
 /**
  * This subclass of {@link ValueAnimator} provides support for animating properties on target objects.
  * The constructors of this class take parameters to define the target object that will be animated
@@ -34,13 +33,14 @@
  * animate the property.
  *
  * @see #setPropertyName(String)
- *
  */
-public final class ObjectAnimator extends ValueAnimator {
+public final class ObjectAnimator extends ValueAnimator
+{
     private static final boolean DBG = false;
     private static final Map<String, Property> PROXY_PROPERTIES = new HashMap<String, Property>();
 
-    static {
+    static
+    {
         PROXY_PROPERTIES.put("alpha", PreHoneycombCompat.ALPHA);
         PROXY_PROPERTIES.put("pivotX", PreHoneycombCompat.PIVOT_X);
         PROXY_PROPERTIES.put("pivotY", PreHoneycombCompat.PIVOT_Y);
@@ -64,102 +64,26 @@
 
     private Property mProperty;
 
-    /**
-     * Sets the name of the property that will be animated. This name is used to derive
-     * a setter function that will be called to set animated values.
-     * For example, a property name of <code>foo</code> will result
-     * in a call to the function <code>setFoo()</code> on the target object. If either
-     * <code>valueFrom</code> or <code>valueTo</code> is null, then a getter function will
-     * also be derived and called.
-     *
-     * <p>For best performance of the mechanism that calls the setter function determined by the
-     * name of the property being animated, use <code>float</code> or <code>int</code> typed values,
-     * and make the setter function for those properties have a <code>void</code> return value. This
-     * will cause the code to take an optimized path for these constrained circumstances. Other
-     * property types and return types will work, but will have more overhead in processing
-     * the requests due to normal reflection mechanisms.</p>
-     *
-     * <p>Note that the setter function derived from this property name
-     * must take the same parameter type as the
-     * <code>valueFrom</code> and <code>valueTo</code> properties, otherwise the call to
-     * the setter function will fail.</p>
-     *
-     * <p>If this ObjectAnimator has been set up to animate several properties together,
-     * using more than one PropertyValuesHolder objects, then setting the propertyName simply
-     * sets the propertyName in the first of those PropertyValuesHolder objects.</p>
-     *
-     * @param propertyName The name of the property being animated. Should not be null.
-     */
-    public void setPropertyName(String propertyName) {
-        // mValues could be null if this is being constructed piecemeal. Just record the
-        // propertyName to be used later when setValues() is called if so.
-        if (mValues != null) {
-            PropertyValuesHolder valuesHolder = mValues[0];
-            String oldName = valuesHolder.getPropertyName();
-            valuesHolder.setPropertyName(propertyName);
-            mValuesMap.remove(oldName);
-            mValuesMap.put(propertyName, valuesHolder);
-        }
-        mPropertyName = propertyName;
-        // New property/values/target should cause re-initialization prior to starting
-        mInitialized = false;
-    }
-
-    /**
-     * Sets the property that will be animated. Property objects will take precedence over
-     * properties specified by the {@link #setPropertyName(String)} method. Animations should
-     * be set up to use one or the other, not both.
-     *
-     * @param property The property being animated. Should not be null.
-     */
-    public void setProperty(Property property) {
-        // mValues could be null if this is being constructed piecemeal. Just record the
-        // propertyName to be used later when setValues() is called if so.
-        if (mValues != null) {
-            PropertyValuesHolder valuesHolder = mValues[0];
-            String oldName = valuesHolder.getPropertyName();
-            valuesHolder.setProperty(property);
-            mValuesMap.remove(oldName);
-            mValuesMap.put(mPropertyName, valuesHolder);
-        }
-        if (mProperty != null) {
-            mPropertyName = property.getName();
-        }
-        mProperty = property;
-        // New property/values/target should cause re-initialization prior to starting
-        mInitialized = false;
-    }
-
-    /**
-     * Gets the name of the property that will be animated. This name will be used to derive
-     * a setter function that will be called to set animated values.
-     * For example, a property name of <code>foo</code> will result
-     * in a call to the function <code>setFoo()</code> on the target object. If either
-     * <code>valueFrom</code> or <code>valueTo</code> is null, then a getter function will
-     * also be derived and called.
-     */
-    public String getPropertyName() {
-        return mPropertyName;
-    }
-
     /**
      * Creates a new ObjectAnimator object. This default constructor is primarily for
      * use internally; the other constructors which take parameters are more generally
      * useful.
      */
-    public ObjectAnimator() {
+    public ObjectAnimator()
+    {
     }
 
     /**
      * Private utility constructor that initializes the target object and name of the
      * property being animated.
      *
-     * @param target The object whose property is to be animated. This object should
-     * have a public method on it called <code>setName()</code>, where <code>name</code> is
-     * the value of the <code>propertyName</code> parameter.
+     * @param target       The object whose property is to be animated. This object should
+     *                     have a public method on it called <code>setName()</code>, where <code>name</code> is
+     *                     the value of the <code>propertyName</code> parameter.
      * @param propertyName The name of the property being animated.
      */
-    private ObjectAnimator(Object target, String propertyName) {
+    private ObjectAnimator(Object target, String propertyName)
+    {
         mTarget = target;
         setPropertyName(propertyName);
     }
@@ -167,10 +91,11 @@ private ObjectAnimator(Object target, String propertyName) {
     /**
      * Private utility constructor that initializes the target object and property being animated.
      *
-     * @param target The object whose property is to be animated.
+     * @param target   The object whose property is to be animated.
      * @param property The property being animated.
      */
-    private <T> ObjectAnimator(T target, Property<T, ?> property) {
+    private <T> ObjectAnimator(T target, Property<T, ?> property)
+    {
         mTarget = target;
         setProperty(property);
     }
@@ -182,14 +107,15 @@ private ObjectAnimator(Object target, String propertyName) {
      * along the way, and an ending value (these values will be distributed evenly across
      * the duration of the animation).
      *
-     * @param target The object whose property is to be animated. This object should
-     * have a public method on it called <code>setName()</code>, where <code>name</code> is
-     * the value of the <code>propertyName</code> parameter.
+     * @param target       The object whose property is to be animated. This object should
+     *                     have a public method on it called <code>setName()</code>, where <code>name</code> is
+     *                     the value of the <code>propertyName</code> parameter.
      * @param propertyName The name of the property being animated.
-     * @param values A set of values that the animation will animate between over time.
+     * @param values       A set of values that the animation will animate between over time.
      * @return An ObjectAnimator object that is set up to animate between the given values.
      */
-    public static ObjectAnimator ofInt(Object target, String propertyName, int... values) {
+    public static ObjectAnimator ofInt(Object target, String propertyName, int... values)
+    {
         ObjectAnimator anim = new ObjectAnimator(target, propertyName);
         anim.setIntValues(values);
         return anim;
@@ -202,12 +128,13 @@ public static ObjectAnimator ofInt(Object target, String propertyName, int... va
      * along the way, and an ending value (these values will be distributed evenly across
      * the duration of the animation).
      *
-     * @param target The object whose property is to be animated.
+     * @param target   The object whose property is to be animated.
      * @param property The property being animated.
-     * @param values A set of values that the animation will animate between over time.
+     * @param values   A set of values that the animation will animate between over time.
      * @return An ObjectAnimator object that is set up to animate between the given values.
      */
-    public static <T> ObjectAnimator ofInt(T target, Property<T, Integer> property, int... values) {
+    public static <T> ObjectAnimator ofInt(T target, Property<T, Integer> property, int... values)
+    {
         ObjectAnimator anim = new ObjectAnimator(target, property);
         anim.setIntValues(values);
         return anim;
@@ -220,14 +147,15 @@ public static ObjectAnimator ofInt(Object target, String propertyName, int... va
      * along the way, and an ending value (these values will be distributed evenly across
      * the duration of the animation).
      *
-     * @param target The object whose property is to be animated. This object should
-     * have a public method on it called <code>setName()</code>, where <code>name</code> is
-     * the value of the <code>propertyName</code> parameter.
+     * @param target       The object whose property is to be animated. This object should
+     *                     have a public method on it called <code>setName()</code>, where <code>name</code> is
+     *                     the value of the <code>propertyName</code> parameter.
      * @param propertyName The name of the property being animated.
-     * @param values A set of values that the animation will animate between over time.
+     * @param values       A set of values that the animation will animate between over time.
      * @return An ObjectAnimator object that is set up to animate between the given values.
      */
-    public static ObjectAnimator ofFloat(Object target, String propertyName, float... values) {
+    public static ObjectAnimator ofFloat(Object target, String propertyName, float... values)
+    {
         ObjectAnimator anim = new ObjectAnimator(target, propertyName);
         anim.setFloatValues(values);
         return anim;
@@ -240,13 +168,14 @@ public static ObjectAnimator ofFloat(Object target, String propertyName, float..
      * along the way, and an ending value (these values will be distributed evenly across
      * the duration of the animation).
      *
-     * @param target The object whose property is to be animated.
+     * @param target   The object whose property is to be animated.
      * @param property The property being animated.
-     * @param values A set of values that the animation will animate between over time.
+     * @param values   A set of values that the animation will animate between over time.
      * @return An ObjectAnimator object that is set up to animate between the given values.
      */
     public static <T> ObjectAnimator ofFloat(T target, Property<T, Float> property,
-            float... values) {
+                                             float... values)
+    {
         ObjectAnimator anim = new ObjectAnimator(target, property);
         anim.setFloatValues(values);
         return anim;
@@ -259,18 +188,19 @@ public static ObjectAnimator ofFloat(Object target, String propertyName, float..
      * along the way, and an ending value (these values will be distributed evenly across
      * the duration of the animation).
      *
-     * @param target The object whose property is to be animated. This object should
-     * have a public method on it called <code>setName()</code>, where <code>name</code> is
-     * the value of the <code>propertyName</code> parameter.
+     * @param target       The object whose property is to be animated. This object should
+     *                     have a public method on it called <code>setName()</code>, where <code>name</code> is
+     *                     the value of the <code>propertyName</code> parameter.
      * @param propertyName The name of the property being animated.
-     * @param evaluator A TypeEvaluator that will be called on each animation frame to
-     * provide the necessary interpolation between the Object values to derive the animated
-     * value.
-     * @param values A set of values that the animation will animate between over time.
+     * @param evaluator    A TypeEvaluator that will be called on each animation frame to
+     *                     provide the necessary interpolation between the Object values to derive the animated
+     *                     value.
+     * @param values       A set of values that the animation will animate between over time.
      * @return An ObjectAnimator object that is set up to animate between the given values.
      */
     public static ObjectAnimator ofObject(Object target, String propertyName,
-            TypeEvaluator evaluator, Object... values) {
+                                          TypeEvaluator evaluator, Object... values)
+    {
         ObjectAnimator anim = new ObjectAnimator(target, propertyName);
         anim.setObjectValues(values);
         anim.setEvaluator(evaluator);
@@ -284,16 +214,17 @@ public static ObjectAnimator ofObject(Object target, String propertyName,
      * along the way, and an ending value (these values will be distributed evenly across
      * the duration of the animation).
      *
-     * @param target The object whose property is to be animated.
-     * @param property The property being animated.
+     * @param target    The object whose property is to be animated.
+     * @param property  The property being animated.
      * @param evaluator A TypeEvaluator that will be called on each animation frame to
-     * provide the necessary interpolation between the Object values to derive the animated
-     * value.
-     * @param values A set of values that the animation will animate between over time.
+     *                  provide the necessary interpolation between the Object values to derive the animated
+     *                  value.
+     * @param values    A set of values that the animation will animate between over time.
      * @return An ObjectAnimator object that is set up to animate between the given values.
      */
     public static <T, V> ObjectAnimator ofObject(T target, Property<T, V> property,
-            TypeEvaluator<V> evaluator, V... values) {
+                                                 TypeEvaluator<V> evaluator, V... values)
+    {
         ObjectAnimator anim = new ObjectAnimator(target, property);
         anim.setObjectValues(values);
         anim.setEvaluator(evaluator);
@@ -307,79 +238,188 @@ public static ObjectAnimator ofObject(Object target, String propertyName,
      * you to associate a set of animation values with a property name.
      *
      * @param target The object whose property is to be animated. Depending on how the
-     * PropertyValuesObjects were constructed, the target object should either have the {@link
-     * android.util.Property} objects used to construct the PropertyValuesHolder objects or (if the
-     * PropertyValuesHOlder objects were created with property names) the target object should have
-     * public methods on it called <code>setName()</code>, where <code>name</code> is the name of
-     * the property passed in as the <code>propertyName</code> parameter for each of the
-     * PropertyValuesHolder objects.
+     *               PropertyValuesObjects were constructed, the target object should either have the {@link
+     *               android.util.Property} objects used to construct the PropertyValuesHolder objects or (if the
+     *               PropertyValuesHOlder objects were created with property names) the target object should have
+     *               public methods on it called <code>setName()</code>, where <code>name</code> is the name of
+     *               the property passed in as the <code>propertyName</code> parameter for each of the
+     *               PropertyValuesHolder objects.
      * @param values A set of PropertyValuesHolder objects whose values will be animated between
-     * over time.
+     *               over time.
      * @return An ObjectAnimator object that is set up to animate between the given values.
      */
     public static ObjectAnimator ofPropertyValuesHolder(Object target,
-            PropertyValuesHolder... values) {
+                                                        PropertyValuesHolder... values)
+    {
         ObjectAnimator anim = new ObjectAnimator();
         anim.mTarget = target;
         anim.setValues(values);
         return anim;
     }
 
+    /**
+     * Sets the property that will be animated. Property objects will take precedence over
+     * properties specified by the {@link #setPropertyName(String)} method. Animations should
+     * be set up to use one or the other, not both.
+     *
+     * @param property The property being animated. Should not be null.
+     */
+    public void setProperty(Property property)
+    {
+        // mValues could be null if this is being constructed piecemeal. Just record the
+        // propertyName to be used later when setValues() is called if so.
+        if (mValues != null)
+        {
+            PropertyValuesHolder valuesHolder = mValues[0];
+            String oldName = valuesHolder.getPropertyName();
+            valuesHolder.setProperty(property);
+            mValuesMap.remove(oldName);
+            mValuesMap.put(mPropertyName, valuesHolder);
+        }
+        if (mProperty != null)
+        {
+            mPropertyName = property.getName();
+        }
+        mProperty = property;
+        // New property/values/target should cause re-initialization prior to starting
+        mInitialized = false;
+    }
+
+    /**
+     * Gets the name of the property that will be animated. This name will be used to derive
+     * a setter function that will be called to set animated values.
+     * For example, a property name of <code>foo</code> will result
+     * in a call to the function <code>setFoo()</code> on the target object. If either
+     * <code>valueFrom</code> or <code>valueTo</code> is null, then a getter function will
+     * also be derived and called.
+     */
+    public String getPropertyName()
+    {
+        return mPropertyName;
+    }
+
+    /**
+     * Sets the name of the property that will be animated. This name is used to derive
+     * a setter function that will be called to set animated values.
+     * For example, a property name of <code>foo</code> will result
+     * in a call to the function <code>setFoo()</code> on the target object. If either
+     * <code>valueFrom</code> or <code>valueTo</code> is null, then a getter function will
+     * also be derived and called.
+     * <p/>
+     * <p>For best performance of the mechanism that calls the setter function determined by the
+     * name of the property being animated, use <code>float</code> or <code>int</code> typed values,
+     * and make the setter function for those properties have a <code>void</code> return value. This
+     * will cause the code to take an optimized path for these constrained circumstances. Other
+     * property types and return types will work, but will have more overhead in processing
+     * the requests due to normal reflection mechanisms.</p>
+     * <p/>
+     * <p>Note that the setter function derived from this property name
+     * must take the same parameter type as the
+     * <code>valueFrom</code> and <code>valueTo</code> properties, otherwise the call to
+     * the setter function will fail.</p>
+     * <p/>
+     * <p>If this ObjectAnimator has been set up to animate several properties together,
+     * using more than one PropertyValuesHolder objects, then setting the propertyName simply
+     * sets the propertyName in the first of those PropertyValuesHolder objects.</p>
+     *
+     * @param propertyName The name of the property being animated. Should not be null.
+     */
+    public void setPropertyName(String propertyName)
+    {
+        // mValues could be null if this is being constructed piecemeal. Just record the
+        // propertyName to be used later when setValues() is called if so.
+        if (mValues != null)
+        {
+            PropertyValuesHolder valuesHolder = mValues[0];
+            String oldName = valuesHolder.getPropertyName();
+            valuesHolder.setPropertyName(propertyName);
+            mValuesMap.remove(oldName);
+            mValuesMap.put(propertyName, valuesHolder);
+        }
+        mPropertyName = propertyName;
+        // New property/values/target should cause re-initialization prior to starting
+        mInitialized = false;
+    }
+
     @Override
-    public void setIntValues(int... values) {
-        if (mValues == null || mValues.length == 0) {
+    public void setIntValues(int... values)
+    {
+        if (mValues == null || mValues.length == 0)
+        {
             // No values yet - this animator is being constructed piecemeal. Init the values with
             // whatever the current propertyName is
-            if (mProperty != null) {
+            if (mProperty != null)
+            {
                 setValues(PropertyValuesHolder.ofInt(mProperty, values));
-            } else {
+            }
+            else
+            {
                 setValues(PropertyValuesHolder.ofInt(mPropertyName, values));
             }
-        } else {
+        }
+        else
+        {
             super.setIntValues(values);
         }
     }
 
     @Override
-    public void setFloatValues(float... values) {
-        if (mValues == null || mValues.length == 0) {
+    public void setFloatValues(float... values)
+    {
+        if (mValues == null || mValues.length == 0)
+        {
             // No values yet - this animator is being constructed piecemeal. Init the values with
             // whatever the current propertyName is
-            if (mProperty != null) {
+            if (mProperty != null)
+            {
                 setValues(PropertyValuesHolder.ofFloat(mProperty, values));
-            } else {
+            }
+            else
+            {
                 setValues(PropertyValuesHolder.ofFloat(mPropertyName, values));
             }
-        } else {
+        }
+        else
+        {
             super.setFloatValues(values);
         }
     }
 
     @Override
-    public void setObjectValues(Object... values) {
-        if (mValues == null || mValues.length == 0) {
+    public void setObjectValues(Object... values)
+    {
+        if (mValues == null || mValues.length == 0)
+        {
             // No values yet - this animator is being constructed piecemeal. Init the values with
             // whatever the current propertyName is
-            if (mProperty != null) {
-                setValues(PropertyValuesHolder.ofObject(mProperty, (TypeEvaluator)null, values));
-            } else {
-                setValues(PropertyValuesHolder.ofObject(mPropertyName, (TypeEvaluator)null, values));
+            if (mProperty != null)
+            {
+                setValues(PropertyValuesHolder.ofObject(mProperty, (TypeEvaluator) null, values));
+            }
+            else
+            {
+                setValues(PropertyValuesHolder.ofObject(mPropertyName, (TypeEvaluator) null, values));
             }
-        } else {
+        }
+        else
+        {
             super.setObjectValues(values);
         }
     }
 
     @Override
-    public void start() {
-        if (DBG) {
+    public void start()
+    {
+        if (DBG)
+        {
             Log.d("ObjectAnimator", "Anim target, duration: " + mTarget + ", " + getDuration());
-            for (int i = 0; i < mValues.length; ++i) {
+            for (int i = 0; i < mValues.length; ++i)
+            {
                 PropertyValuesHolder pvh = mValues[i];
                 ArrayList<Keyframe> keyframes = pvh.mKeyframeSet.mKeyframes;
                 Log.d("ObjectAnimator", "   Values[" + i + "]: " +
-                    pvh.getPropertyName() + ", " + keyframes.get(0).getValue() + ", " +
-                    keyframes.get(pvh.mKeyframeSet.mNumKeyframes - 1).getValue());
+                        pvh.getPropertyName() + ", " + keyframes.get(0).getValue() + ", " +
+                        keyframes.get(pvh.mKeyframeSet.mNumKeyframes - 1).getValue());
             }
         }
         super.start();
@@ -393,20 +433,25 @@ public void start() {
      * animation. This includes setting mEvaluator, if the user has not yet
      * set it up, and the setter/getter methods, if the user did not supply
      * them.
-     *
-     *  <p>Overriders of this method should call the superclass method to cause
-     *  internal mechanisms to be set up correctly.</p>
+     * <p/>
+     * <p>Overriders of this method should call the superclass method to cause
+     * internal mechanisms to be set up correctly.</p>
      */
     @Override
-    void initAnimation() {
-        if (!mInitialized) {
+    void initAnimation()
+    {
+        if (!mInitialized)
+        {
             // mValueType may change due to setter/getter setup; do this before calling super.init(),
             // which uses mValueType to set up the default type evaluator.
-            if ((mProperty == null) && AnimatorProxy.NEEDS_PROXY && (mTarget instanceof View) && PROXY_PROPERTIES.containsKey(mPropertyName)) {
+            if ((mProperty == null) && AnimatorProxy.NEEDS_PROXY && (mTarget instanceof View) &&
+                    PROXY_PROPERTIES.containsKey(mPropertyName))
+            {
                 setProperty(PROXY_PROPERTIES.get(mPropertyName));
             }
             int numValues = mValues.length;
-            for (int i = 0; i < numValues; ++i) {
+            for (int i = 0; i < numValues; ++i)
+            {
                 mValues[i].setupSetterAndGetter(mTarget);
             }
             super.initAnimation();
@@ -423,7 +468,8 @@ void initAnimation() {
      * <code>ObjectAnimator.ofInt(target, propertyName, 0, 10).setDuration(500).start()</code>.
      */
     @Override
-    public ObjectAnimator setDuration(long duration) {
+    public ObjectAnimator setDuration(long duration)
+    {
         super.setDuration(duration);
         return this;
     }
@@ -434,7 +480,8 @@ public ObjectAnimator setDuration(long duration) {
      *
      * @return The object being animated
      */
-    public Object getTarget() {
+    public Object getTarget()
+    {
         return mTarget;
     }
 
@@ -444,11 +491,14 @@ public Object getTarget() {
      * @param target The object being animated
      */
     @Override
-    public void setTarget(Object target) {
-        if (mTarget != target) {
+    public void setTarget(Object target)
+    {
+        if (mTarget != target)
+        {
             final Object oldTarget = mTarget;
             mTarget = target;
-            if (oldTarget != null && target != null && oldTarget.getClass() == target.getClass()) {
+            if (oldTarget != null && target != null && oldTarget.getClass() == target.getClass())
+            {
                 return;
             }
             // New target type should cause re-initialization prior to starting
@@ -457,19 +507,23 @@ public void setTarget(Object target) {
     }
 
     @Override
-    public void setupStartValues() {
+    public void setupStartValues()
+    {
         initAnimation();
         int numValues = mValues.length;
-        for (int i = 0; i < numValues; ++i) {
+        for (int i = 0; i < numValues; ++i)
+        {
             mValues[i].setupStartValue(mTarget);
         }
     }
 
     @Override
-    public void setupEndValues() {
+    public void setupEndValues()
+    {
         initAnimation();
         int numValues = mValues.length;
-        for (int i = 0; i < numValues; ++i) {
+        for (int i = 0; i < numValues; ++i)
+        {
             mValues[i].setupEndValue(mTarget);
         }
     }
@@ -480,33 +534,39 @@ public void setupEndValues() {
      * and then into an animated value (from the evaluator. The function is called mostly during
      * animation updates, but it is also called when the <code>end()</code>
      * function is called, to set the final value on the property.
-     *
+     * <p/>
      * <p>Overrides of this method must call the superclass to perform the calculation
      * of the animated value.</p>
      *
      * @param fraction The elapsed fraction of the animation.
      */
     @Override
-    void animateValue(float fraction) {
+    void animateValue(float fraction)
+    {
         super.animateValue(fraction);
         int numValues = mValues.length;
-        for (int i = 0; i < numValues; ++i) {
+        for (int i = 0; i < numValues; ++i)
+        {
             mValues[i].setAnimatedValue(mTarget);
         }
     }
 
     @Override
-    public ObjectAnimator clone() {
+    public ObjectAnimator clone()
+    {
         final ObjectAnimator anim = (ObjectAnimator) super.clone();
         return anim;
     }
 
     @Override
-    public String toString() {
+    public String toString()
+    {
         String returnVal = "ObjectAnimator@" + Integer.toHexString(hashCode()) + ", target " +
-            mTarget;
-        if (mValues != null) {
-            for (int i = 0; i < mValues.length; ++i) {
+                mTarget;
+        if (mValues != null)
+        {
+            for (int i = 0; i < mValues.length; ++i)
+            {
                 returnVal += "\n    " + mValues[i].toString();
             }
         }
diff --git a/library/src/com/nineoldandroids/animation/PreHoneycombCompat.java b/library/src/com/nineoldandroids/animation/PreHoneycombCompat.java
index 8a68d82..05aa796 100644
--- a/library/src/com/nineoldandroids/animation/PreHoneycombCompat.java
+++ b/library/src/com/nineoldandroids/animation/PreHoneycombCompat.java
@@ -6,163 +6,208 @@
 import com.nineoldandroids.util.Property;
 import com.nineoldandroids.view.animation.AnimatorProxy;
 
-final class PreHoneycombCompat {
-    static Property<View, Float> ALPHA = new FloatProperty<View>("alpha") {
+final class PreHoneycombCompat
+{
+    static Property<View, Float> ALPHA = new FloatProperty<View>("alpha")
+    {
         @Override
-        public void setValue(View object, float value) {
+        public void setValue(View object, float value)
+        {
             AnimatorProxy.wrap(object).setAlpha(value);
         }
 
         @Override
-        public Float get(View object) {
+        public Float get(View object)
+        {
             return AnimatorProxy.wrap(object).getAlpha();
         }
     };
-    static Property<View, Float> PIVOT_X = new FloatProperty<View>("pivotX") {
+    static Property<View, Float> PIVOT_X = new FloatProperty<View>("pivotX")
+    {
         @Override
-        public void setValue(View object, float value) {
+        public void setValue(View object, float value)
+        {
             AnimatorProxy.wrap(object).setPivotX(value);
         }
 
         @Override
-        public Float get(View object) {
+        public Float get(View object)
+        {
             return AnimatorProxy.wrap(object).getPivotX();
         }
     };
-    static Property<View, Float> PIVOT_Y = new FloatProperty<View>("pivotY") {
+    static Property<View, Float> PIVOT_Y = new FloatProperty<View>("pivotY")
+    {
         @Override
-        public void setValue(View object, float value) {
+        public void setValue(View object, float value)
+        {
             AnimatorProxy.wrap(object).setPivotY(value);
         }
 
         @Override
-        public Float get(View object) {
+        public Float get(View object)
+        {
             return AnimatorProxy.wrap(object).getPivotY();
         }
     };
-    static Property<View, Float> TRANSLATION_X = new FloatProperty<View>("translationX") {
+    static Property<View, Float> TRANSLATION_X = new FloatProperty<View>("translationX")
+    {
         @Override
-        public void setValue(View object, float value) {
+        public void setValue(View object, float value)
+        {
             AnimatorProxy.wrap(object).setTranslationX(value);
         }
 
         @Override
-        public Float get(View object) {
+        public Float get(View object)
+        {
             return AnimatorProxy.wrap(object).getTranslationX();
         }
     };
-    static Property<View, Float> TRANSLATION_Y = new FloatProperty<View>("translationY") {
+    static Property<View, Float> TRANSLATION_Y = new FloatProperty<View>("translationY")
+    {
         @Override
-        public void setValue(View object, float value) {
+        public void setValue(View object, float value)
+        {
             AnimatorProxy.wrap(object).setTranslationY(value);
         }
 
         @Override
-        public Float get(View object) {
+        public Float get(View object)
+        {
             return AnimatorProxy.wrap(object).getTranslationY();
         }
     };
-    static Property<View, Float> ROTATION = new FloatProperty<View>("rotation") {
+    static Property<View, Float> ROTATION = new FloatProperty<View>("rotation")
+    {
         @Override
-        public void setValue(View object, float value) {
+        public void setValue(View object, float value)
+        {
             AnimatorProxy.wrap(object).setRotation(value);
         }
 
         @Override
-        public Float get(View object) {
+        public Float get(View object)
+        {
             return AnimatorProxy.wrap(object).getRotation();
         }
     };
-    static Property<View, Float> ROTATION_X = new FloatProperty<View>("rotationX") {
+    static Property<View, Float> ROTATION_X = new FloatProperty<View>("rotationX")
+    {
         @Override
-        public void setValue(View object, float value) {
+        public void setValue(View object, float value)
+        {
             AnimatorProxy.wrap(object).setRotationX(value);
         }
 
         @Override
-        public Float get(View object) {
+        public Float get(View object)
+        {
             return AnimatorProxy.wrap(object).getRotationX();
         }
     };
-    static Property<View, Float> ROTATION_Y = new FloatProperty<View>("rotationY") {
+    static Property<View, Float> ROTATION_Y = new FloatProperty<View>("rotationY")
+    {
         @Override
-        public void setValue(View object, float value) {
+        public void setValue(View object, float value)
+        {
             AnimatorProxy.wrap(object).setRotationY(value);
         }
 
         @Override
-        public Float get(View object) {
+        public Float get(View object)
+        {
             return AnimatorProxy.wrap(object).getRotationY();
         }
     };
-    static Property<View, Float> SCALE_X = new FloatProperty<View>("scaleX") {
+    static Property<View, Float> SCALE_X = new FloatProperty<View>("scaleX")
+    {
         @Override
-        public void setValue(View object, float value) {
+        public void setValue(View object, float value)
+        {
             AnimatorProxy.wrap(object).setScaleX(value);
         }
 
         @Override
-        public Float get(View object) {
+        public Float get(View object)
+        {
             return AnimatorProxy.wrap(object).getScaleX();
         }
     };
-    static Property<View, Float> SCALE_Y = new FloatProperty<View>("scaleY") {
+    static Property<View, Float> SCALE_Y = new FloatProperty<View>("scaleY")
+    {
         @Override
-        public void setValue(View object, float value) {
+        public void setValue(View object, float value)
+        {
             AnimatorProxy.wrap(object).setScaleY(value);
         }
 
         @Override
-        public Float get(View object) {
+        public Float get(View object)
+        {
             return AnimatorProxy.wrap(object).getScaleY();
         }
     };
-    static Property<View, Integer> SCROLL_X = new IntProperty<View>("scrollX") {
+    static Property<View, Integer> SCROLL_X = new IntProperty<View>("scrollX")
+    {
         @Override
-        public void setValue(View object, int value) {
+        public void setValue(View object, int value)
+        {
             AnimatorProxy.wrap(object).setScrollX(value);
         }
 
         @Override
-        public Integer get(View object) {
+        public Integer get(View object)
+        {
             return AnimatorProxy.wrap(object).getScrollX();
         }
     };
-    static Property<View, Integer> SCROLL_Y = new IntProperty<View>("scrollY") {
+    static Property<View, Integer> SCROLL_Y = new IntProperty<View>("scrollY")
+    {
         @Override
-        public void setValue(View object, int value) {
+        public void setValue(View object, int value)
+        {
             AnimatorProxy.wrap(object).setScrollY(value);
         }
 
         @Override
-        public Integer get(View object) {
+        public Integer get(View object)
+        {
             return AnimatorProxy.wrap(object).getScrollY();
         }
     };
-    static Property<View, Float> X = new FloatProperty<View>("x") {
+    static Property<View, Float> X = new FloatProperty<View>("x")
+    {
         @Override
-        public void setValue(View object, float value) {
+        public void setValue(View object, float value)
+        {
             AnimatorProxy.wrap(object).setX(value);
         }
 
         @Override
-        public Float get(View object) {
+        public Float get(View object)
+        {
             return AnimatorProxy.wrap(object).getX();
         }
     };
-    static Property<View, Float> Y = new FloatProperty<View>("y") {
+    static Property<View, Float> Y = new FloatProperty<View>("y")
+    {
         @Override
-        public void setValue(View object, float value) {
+        public void setValue(View object, float value)
+        {
             AnimatorProxy.wrap(object).setY(value);
         }
 
         @Override
-        public Float get(View object) {
+        public Float get(View object)
+        {
             return AnimatorProxy.wrap(object).getY();
         }
     };
 
 
     //No instances
-    private PreHoneycombCompat() {}
+    private PreHoneycombCompat()
+    {
+    }
 }
diff --git a/library/src/com/nineoldandroids/animation/PropertyValuesHolder.java b/library/src/com/nineoldandroids/animation/PropertyValuesHolder.java
index 8e2fb30..c779d52 100644
--- a/library/src/com/nineoldandroids/animation/PropertyValuesHolder.java
+++ b/library/src/com/nineoldandroids/animation/PropertyValuesHolder.java
@@ -17,36 +17,62 @@
 package com.nineoldandroids.animation;
 
 import android.util.Log;
+import com.nineoldandroids.util.FloatProperty;
+import com.nineoldandroids.util.IntProperty;
+import com.nineoldandroids.util.Property;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.HashMap;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
-import com.nineoldandroids.util.FloatProperty;
-import com.nineoldandroids.util.IntProperty;
-import com.nineoldandroids.util.Property;
-
 /**
  * This class holds information about a property and the values that that property
  * should take on during an animation. PropertyValuesHolder objects can be used to create
  * animations with ValueAnimator or ObjectAnimator that operate on several different properties
  * in parallel.
  */
-public class PropertyValuesHolder implements Cloneable {
+public class PropertyValuesHolder implements Cloneable
+{
 
+    // type evaluators for the primitive types handled by this implementation
+    private static final TypeEvaluator sIntEvaluator = new IntEvaluator();
+    private static final TypeEvaluator sFloatEvaluator = new FloatEvaluator();
+    // These maps hold all property entries for a particular class. This map
+    // is used to speed up property/setter/getter lookups for a given class/property
+    // combination. No need to use reflection on the combination more than once.
+    private static final HashMap<Class, HashMap<String, Method>> sSetterPropertyMap =
+            new HashMap<Class, HashMap<String, Method>>();
+    private static final HashMap<Class, HashMap<String, Method>> sGetterPropertyMap =
+            new HashMap<Class, HashMap<String, Method>>();
+    // We try several different types when searching for appropriate setter/getter functions.
+    // The caller may have supplied values in a type that does not match the setter/getter
+    // functions (such as the integers 0 and 1 to represent floating point values for alpha).
+    // Also, the use of generics in constructors means that we end up with the Object versions
+    // of primitive types (Float vs. float). But most likely, the setter/getter functions
+    // will take primitive types instead.
+    // So we supply an ordered array of other types to try before giving up.
+    private static Class[] FLOAT_VARIANTS = {float.class, Float.class, double.class, int.class,
+            Double.class, Integer.class};
+    private static Class[] INTEGER_VARIANTS = {int.class, Integer.class, float.class, double.class,
+            Float.class, Double.class};
+    private static Class[] DOUBLE_VARIANTS = {double.class, Double.class, float.class, int.class,
+            Float.class, Integer.class};
+    // This lock is used to ensure that only one thread is accessing the property maps
+    // at a time.
+    final ReentrantReadWriteLock mPropertyMapLock = new ReentrantReadWriteLock();
+    // Used to pass single value to varargs parameter in setter invocation
+    final Object[] mTmpValueArray = new Object[1];
+    /**
+     * @hide
+     */
+    protected Property mProperty;
     /**
      * The name of the property associated with the values. This need not be a real property,
      * unless this object is being used with ObjectAnimator. But this is the name by which
      * aniamted values are looked up with getAnimatedValue(String) in ValueAnimator.
      */
     String mPropertyName;
-
-    /**
-     * @hide
-     */
-    protected Property mProperty;
-
     /**
      * The setter function, if needed. ObjectAnimator hands off this functionality to
      * PropertyValuesHolder, since it holds all of the per-property information. This
@@ -54,61 +80,23 @@
      * derived when the animation starts in setupSetterAndGetter() if using ObjectAnimator.
      */
     Method mSetter = null;
-
-    /**
-     * The getter function, if needed. ObjectAnimator hands off this functionality to
-     * PropertyValuesHolder, since it holds all of the per-property information. This
-     * property is automatically
-     * derived when the animation starts in setupSetterAndGetter() if using ObjectAnimator.
-     * The getter is only derived and used if one of the values is null.
-     */
-    private Method mGetter = null;
-
     /**
      * The type of values supplied. This information is used both in deriving the setter/getter
      * functions and in deriving the type of TypeEvaluator.
      */
     Class mValueType;
-
     /**
      * The set of keyframes (time/value pairs) that define this animation.
      */
     KeyframeSet mKeyframeSet = null;
-
-
-    // type evaluators for the primitive types handled by this implementation
-    private static final TypeEvaluator sIntEvaluator = new IntEvaluator();
-    private static final TypeEvaluator sFloatEvaluator = new FloatEvaluator();
-
-    // We try several different types when searching for appropriate setter/getter functions.
-    // The caller may have supplied values in a type that does not match the setter/getter
-    // functions (such as the integers 0 and 1 to represent floating point values for alpha).
-    // Also, the use of generics in constructors means that we end up with the Object versions
-    // of primitive types (Float vs. float). But most likely, the setter/getter functions
-    // will take primitive types instead.
-    // So we supply an ordered array of other types to try before giving up.
-    private static Class[] FLOAT_VARIANTS = {float.class, Float.class, double.class, int.class,
-            Double.class, Integer.class};
-    private static Class[] INTEGER_VARIANTS = {int.class, Integer.class, float.class, double.class,
-            Float.class, Double.class};
-    private static Class[] DOUBLE_VARIANTS = {double.class, Double.class, float.class, int.class,
-            Float.class, Integer.class};
-
-    // These maps hold all property entries for a particular class. This map
-    // is used to speed up property/setter/getter lookups for a given class/property
-    // combination. No need to use reflection on the combination more than once.
-    private static final HashMap<Class, HashMap<String, Method>> sSetterPropertyMap =
-            new HashMap<Class, HashMap<String, Method>>();
-    private static final HashMap<Class, HashMap<String, Method>> sGetterPropertyMap =
-            new HashMap<Class, HashMap<String, Method>>();
-
-    // This lock is used to ensure that only one thread is accessing the property maps
-    // at a time.
-    final ReentrantReadWriteLock mPropertyMapLock = new ReentrantReadWriteLock();
-
-    // Used to pass single value to varargs parameter in setter invocation
-    final Object[] mTmpValueArray = new Object[1];
-
+    /**
+     * The getter function, if needed. ObjectAnimator hands off this functionality to
+     * PropertyValuesHolder, since it holds all of the per-property information. This
+     * property is automatically
+     * derived when the animation starts in setupSetterAndGetter() if using ObjectAnimator.
+     * The getter is only derived and used if one of the values is null.
+     */
+    private Method mGetter = null;
     /**
      * The type evaluator used to calculate the animated values. This evaluator is determined
      * automatically based on the type of the start/end objects passed into the constructor,
@@ -126,19 +114,24 @@
 
     /**
      * Internal utility constructor, used by the factory methods to set the property name.
+     *
      * @param propertyName The name of the property for this holder.
      */
-    private PropertyValuesHolder(String propertyName) {
+    private PropertyValuesHolder(String propertyName)
+    {
         mPropertyName = propertyName;
     }
 
     /**
      * Internal utility constructor, used by the factory methods to set the property.
+     *
      * @param property The property for this holder.
      */
-    private PropertyValuesHolder(Property property) {
+    private PropertyValuesHolder(Property property)
+    {
         mProperty = property;
-        if (property != null) {
+        if (property != null)
+        {
             mPropertyName = property.getName();
         }
     }
@@ -146,44 +139,52 @@ private PropertyValuesHolder(Property property) {
     /**
      * Constructs and returns a PropertyValuesHolder with a given property name and
      * set of int values.
+     *
      * @param propertyName The name of the property being animated.
-     * @param values The values that the named property will animate between.
+     * @param values       The values that the named property will animate between.
      * @return PropertyValuesHolder The constructed PropertyValuesHolder object.
      */
-    public static PropertyValuesHolder ofInt(String propertyName, int... values) {
+    public static PropertyValuesHolder ofInt(String propertyName, int... values)
+    {
         return new IntPropertyValuesHolder(propertyName, values);
     }
 
     /**
      * Constructs and returns a PropertyValuesHolder with a given property and
      * set of int values.
+     *
      * @param property The property being animated. Should not be null.
-     * @param values The values that the property will animate between.
+     * @param values   The values that the property will animate between.
      * @return PropertyValuesHolder The constructed PropertyValuesHolder object.
      */
-    public static PropertyValuesHolder ofInt(Property<?, Integer> property, int... values) {
+    public static PropertyValuesHolder ofInt(Property<?, Integer> property, int... values)
+    {
         return new IntPropertyValuesHolder(property, values);
     }
 
     /**
      * Constructs and returns a PropertyValuesHolder with a given property name and
      * set of float values.
+     *
      * @param propertyName The name of the property being animated.
-     * @param values The values that the named property will animate between.
+     * @param values       The values that the named property will animate between.
      * @return PropertyValuesHolder The constructed PropertyValuesHolder object.
      */
-    public static PropertyValuesHolder ofFloat(String propertyName, float... values) {
+    public static PropertyValuesHolder ofFloat(String propertyName, float... values)
+    {
         return new FloatPropertyValuesHolder(propertyName, values);
     }
 
     /**
      * Constructs and returns a PropertyValuesHolder with a given property and
      * set of float values.
+     *
      * @param property The property being animated. Should not be null.
-     * @param values The values that the property will animate between.
+     * @param values   The values that the property will animate between.
      * @return PropertyValuesHolder The constructed PropertyValuesHolder object.
      */
-    public static PropertyValuesHolder ofFloat(Property<?, Float> property, float... values) {
+    public static PropertyValuesHolder ofFloat(Property<?, Float> property, float... values)
+    {
         return new FloatPropertyValuesHolder(property, values);
     }
 
@@ -193,14 +194,15 @@ public static PropertyValuesHolder ofFloat(Property<?, Float> property, float...
      * cannot automatically interpolate between objects of unknown type.
      *
      * @param propertyName The name of the property being animated.
-     * @param evaluator A TypeEvaluator that will be called on each animation frame to
-     * provide the necessary interpolation between the Object values to derive the animated
-     * value.
-     * @param values The values that the named property will animate between.
+     * @param evaluator    A TypeEvaluator that will be called on each animation frame to
+     *                     provide the necessary interpolation between the Object values to derive the animated
+     *                     value.
+     * @param values       The values that the named property will animate between.
      * @return PropertyValuesHolder The constructed PropertyValuesHolder object.
      */
     public static PropertyValuesHolder ofObject(String propertyName, TypeEvaluator evaluator,
-            Object... values) {
+                                                Object... values)
+    {
         PropertyValuesHolder pvh = new PropertyValuesHolder(propertyName);
         pvh.setObjectValues(values);
         pvh.setEvaluator(evaluator);
@@ -212,15 +214,16 @@ public static PropertyValuesHolder ofObject(String propertyName, TypeEvaluator e
      * set of Object values. This variant also takes a TypeEvaluator because the system
      * cannot automatically interpolate between objects of unknown type.
      *
-     * @param property The property being animated. Should not be null.
+     * @param property  The property being animated. Should not be null.
      * @param evaluator A TypeEvaluator that will be called on each animation frame to
-     * provide the necessary interpolation between the Object values to derive the animated
-     * value.
-     * @param values The values that the property will animate between.
+     *                  provide the necessary interpolation between the Object values to derive the animated
+     *                  value.
+     * @param values    The values that the property will animate between.
      * @return PropertyValuesHolder The constructed PropertyValuesHolder object.
      */
     public static <V> PropertyValuesHolder ofObject(Property property,
-            TypeEvaluator<V> evaluator, V... values) {
+                                                    TypeEvaluator<V> evaluator, V... values)
+    {
         PropertyValuesHolder pvh = new PropertyValuesHolder(property);
         pvh.setObjectValues(values);
         pvh.setEvaluator(evaluator);
@@ -240,23 +243,29 @@ public static PropertyValuesHolder ofObject(String propertyName, TypeEvaluator e
      * {@link ObjectAnimator}, and with a getter function
      * derived automatically from <code>propertyName</code>, since otherwise PropertyValuesHolder has
      * no way of determining what the value should be.
+     *
      * @param propertyName The name of the property associated with this set of values. This
-     * can be the actual property name to be used when using a ObjectAnimator object, or
-     * just a name used to get animated values, such as if this object is used with an
-     * ValueAnimator object.
-     * @param values The set of values to animate between.
+     *                     can be the actual property name to be used when using a ObjectAnimator object, or
+     *                     just a name used to get animated values, such as if this object is used with an
+     *                     ValueAnimator object.
+     * @param values       The set of values to animate between.
      */
-    public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values) {
+    public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values)
+    {
         KeyframeSet keyframeSet = KeyframeSet.ofKeyframe(values);
-        if (keyframeSet instanceof IntKeyframeSet) {
+        if (keyframeSet instanceof IntKeyframeSet)
+        {
             return new IntPropertyValuesHolder(propertyName, (IntKeyframeSet) keyframeSet);
-        } else if (keyframeSet instanceof FloatKeyframeSet) {
+        }
+        else if (keyframeSet instanceof FloatKeyframeSet)
+        {
             return new FloatPropertyValuesHolder(propertyName, (FloatKeyframeSet) keyframeSet);
         }
-        else {
+        else
+        {
             PropertyValuesHolder pvh = new PropertyValuesHolder(propertyName);
             pvh.mKeyframeSet = keyframeSet;
-            pvh.mValueType = ((Keyframe)values[0]).getType();
+            pvh.mValueType = ((Keyframe) values[0]).getType();
             return pvh;
         }
     }
@@ -274,24 +283,55 @@ public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... v
      * if the PropertyValuesHolder object is used in conjunction with
      * {@link ObjectAnimator}, since otherwise PropertyValuesHolder has
      * no way of determining what the value should be.
+     *
      * @param property The property associated with this set of values. Should not be null.
-     * @param values The set of values to animate between.
+     * @param values   The set of values to animate between.
      */
-    public static PropertyValuesHolder ofKeyframe(Property property, Keyframe... values) {
+    public static PropertyValuesHolder ofKeyframe(Property property, Keyframe... values)
+    {
         KeyframeSet keyframeSet = KeyframeSet.ofKeyframe(values);
-        if (keyframeSet instanceof IntKeyframeSet) {
+        if (keyframeSet instanceof IntKeyframeSet)
+        {
             return new IntPropertyValuesHolder(property, (IntKeyframeSet) keyframeSet);
-        } else if (keyframeSet instanceof FloatKeyframeSet) {
+        }
+        else if (keyframeSet instanceof FloatKeyframeSet)
+        {
             return new FloatPropertyValuesHolder(property, (FloatKeyframeSet) keyframeSet);
         }
-        else {
+        else
+        {
             PropertyValuesHolder pvh = new PropertyValuesHolder(property);
             pvh.mKeyframeSet = keyframeSet;
-            pvh.mValueType = ((Keyframe)values[0]).getType();
+            pvh.mValueType = ((Keyframe) values[0]).getType();
             return pvh;
         }
     }
 
+    /**
+     * Utility method to derive a setter/getter method name from a property name, where the
+     * prefix is typically "set" or "get" and the first letter of the property name is
+     * capitalized.
+     *
+     * @param prefix       The precursor to the method name, before the property name begins, typically
+     *                     "set" or "get".
+     * @param propertyName The name of the property that represents the bulk of the method name
+     *                     after the prefix. The first letter of this word will be capitalized in the resulting
+     *                     method name.
+     * @return String the property name converted to a method name according to the conventions
+     * specified above.
+     */
+    static String getMethodName(String prefix, String propertyName)
+    {
+        if (propertyName == null || propertyName.length() == 0)
+        {
+            // shouldn't get here
+            return prefix;
+        }
+        char firstLetter = Character.toUpperCase(propertyName.charAt(0));
+        String theRest = propertyName.substring(1);
+        return prefix + firstLetter + theRest;
+    }
+
     /**
      * Set the animated values for this object to this set of ints.
      * If there is only one value, it is assumed to be the end value of an animation,
@@ -305,7 +345,8 @@ public static PropertyValuesHolder ofKeyframe(Property property, Keyframe... val
      *
      * @param values One or more values that the animation will animate between.
      */
-    public void setIntValues(int... values) {
+    public void setIntValues(int... values)
+    {
         mValueType = int.class;
         mKeyframeSet = KeyframeSet.ofInt(values);
     }
@@ -323,7 +364,8 @@ public void setIntValues(int... values) {
      *
      * @param values One or more values that the animation will animate between.
      */
-    public void setFloatValues(float... values) {
+    public void setFloatValues(float... values)
+    {
         mValueType = float.class;
         mKeyframeSet = KeyframeSet.ofFloat(values);
     }
@@ -333,12 +375,14 @@ public void setFloatValues(float... values) {
      *
      * @param values One or more values that the animation will animate between.
      */
-    public void setKeyframes(Keyframe... values) {
+    public void setKeyframes(Keyframe... values)
+    {
         int numKeyframes = values.length;
-        Keyframe keyframes[] = new Keyframe[Math.max(numKeyframes,2)];
-        mValueType = ((Keyframe)values[0]).getType();
-        for (int i = 0; i < numKeyframes; ++i) {
-            keyframes[i] = (Keyframe)values[i];
+        Keyframe keyframes[] = new Keyframe[Math.max(numKeyframes, 2)];
+        mValueType = ((Keyframe) values[0]).getType();
+        for (int i = 0; i < numKeyframes; ++i)
+        {
+            keyframes[i] = (Keyframe) values[i];
         }
         mKeyframeSet = new KeyframeSet(keyframes);
     }
@@ -356,7 +400,8 @@ public void setKeyframes(Keyframe... values) {
      *
      * @param values One or more values that the animation will animate between.
      */
-    public void setObjectValues(Object... values) {
+    public void setObjectValues(Object... values)
+    {
         mValueType = values[0].getClass();
         mKeyframeSet = KeyframeSet.ofObject(values);
     }
@@ -368,111 +413,143 @@ public void setObjectValues(Object... values) {
      * target object.
      *
      * @param targetClass The class to search for the method
-     * @param prefix "set" or "get", depending on whether we need a setter or getter.
-     * @param valueType The type of the parameter (in the case of a setter). This type
-     * is derived from the values set on this PropertyValuesHolder. This type is used as
-     * a first guess at the parameter type, but we check for methods with several different
-     * types to avoid problems with slight mis-matches between supplied values and actual
-     * value types used on the setter.
+     * @param prefix      "set" or "get", depending on whether we need a setter or getter.
+     * @param valueType   The type of the parameter (in the case of a setter). This type
+     *                    is derived from the values set on this PropertyValuesHolder. This type is used as
+     *                    a first guess at the parameter type, but we check for methods with several different
+     *                    types to avoid problems with slight mis-matches between supplied values and actual
+     *                    value types used on the setter.
      * @return Method the method associated with mPropertyName.
      */
-    private Method getPropertyFunction(Class targetClass, String prefix, Class valueType) {
+    private Method getPropertyFunction(Class targetClass, String prefix, Class valueType)
+    {
         // TODO: faster implementation...
         Method returnVal = null;
         String methodName = getMethodName(prefix, mPropertyName);
         Class args[] = null;
-        if (valueType == null) {
-            try {
+        if (valueType == null)
+        {
+            try
+            {
                 returnVal = targetClass.getMethod(methodName, args);
-            } catch (NoSuchMethodException e) {
+            }
+            catch (NoSuchMethodException e)
+            {
                 /* The native implementation uses JNI to do reflection, which allows access to private methods.
                  * getDeclaredMethod(..) does not find superclass methods, so it's implemented as a fallback.
                  */
-                try {
+                try
+                {
                     returnVal = targetClass.getDeclaredMethod(methodName, args);
                     returnVal.setAccessible(true);
-                } catch (NoSuchMethodException e2) {
+                }
+                catch (NoSuchMethodException e2)
+                {
                     Log.e("PropertyValuesHolder",
-                            "Couldn't find no-arg method for property " + mPropertyName + ": " + e);
+                          "Couldn't find no-arg method for property " + mPropertyName + ": " + e);
                 }
             }
-        } else {
+        }
+        else
+        {
             args = new Class[1];
             Class typeVariants[];
-            if (mValueType.equals(Float.class)) {
+            if (mValueType.equals(Float.class))
+            {
                 typeVariants = FLOAT_VARIANTS;
-            } else if (mValueType.equals(Integer.class)) {
+            }
+            else if (mValueType.equals(Integer.class))
+            {
                 typeVariants = INTEGER_VARIANTS;
-            } else if (mValueType.equals(Double.class)) {
+            }
+            else if (mValueType.equals(Double.class))
+            {
                 typeVariants = DOUBLE_VARIANTS;
-            } else {
+            }
+            else
+            {
                 typeVariants = new Class[1];
                 typeVariants[0] = mValueType;
             }
-            for (Class typeVariant : typeVariants) {
+            for (Class typeVariant : typeVariants)
+            {
                 args[0] = typeVariant;
-                try {
+                try
+                {
                     returnVal = targetClass.getMethod(methodName, args);
                     // change the value type to suit
                     mValueType = typeVariant;
                     return returnVal;
-                } catch (NoSuchMethodException e) {
+                }
+                catch (NoSuchMethodException e)
+                {
                     /* The native implementation uses JNI to do reflection, which allows access to private methods.
                      * getDeclaredMethod(..) does not find superclass methods, so it's implemented as a fallback.
                      */
-                    try {
+                    try
+                    {
                         returnVal = targetClass.getDeclaredMethod(methodName, args);
                         returnVal.setAccessible(true);
                         // change the value type to suit
                         mValueType = typeVariant;
                         return returnVal;
-                    } catch (NoSuchMethodException e2) {
+                    }
+                    catch (NoSuchMethodException e2)
+                    {
                         // Swallow the error and keep trying other variants
                     }
                 }
             }
             // If we got here, then no appropriate function was found
             Log.e("PropertyValuesHolder",
-                    "Couldn't find setter/getter for property " + mPropertyName +
-                            " with value type "+ mValueType);
+                  "Couldn't find setter/getter for property " + mPropertyName +
+                          " with value type " + mValueType
+            );
         }
 
         return returnVal;
     }
 
-
     /**
      * Returns the setter or getter requested. This utility function checks whether the
      * requested method exists in the propertyMapMap cache. If not, it calls another
      * utility function to request the Method from the targetClass directly.
-     * @param targetClass The Class on which the requested method should exist.
+     *
+     * @param targetClass    The Class on which the requested method should exist.
      * @param propertyMapMap The cache of setters/getters derived so far.
-     * @param prefix "set" or "get", for the setter or getter.
-     * @param valueType The type of parameter passed into the method (null for getter).
+     * @param prefix         "set" or "get", for the setter or getter.
+     * @param valueType      The type of parameter passed into the method (null for getter).
      * @return Method the method associated with mPropertyName.
      */
     private Method setupSetterOrGetter(Class targetClass,
-            HashMap<Class, HashMap<String, Method>> propertyMapMap,
-            String prefix, Class valueType) {
+                                       HashMap<Class, HashMap<String, Method>> propertyMapMap,
+                                       String prefix, Class valueType)
+    {
         Method setterOrGetter = null;
-        try {
+        try
+        {
             // Have to lock property map prior to reading it, to guard against
             // another thread putting something in there after we've checked it
             // but before we've added an entry to it
             mPropertyMapLock.writeLock().lock();
             HashMap<String, Method> propertyMap = propertyMapMap.get(targetClass);
-            if (propertyMap != null) {
+            if (propertyMap != null)
+            {
                 setterOrGetter = propertyMap.get(mPropertyName);
             }
-            if (setterOrGetter == null) {
+            if (setterOrGetter == null)
+            {
                 setterOrGetter = getPropertyFunction(targetClass, prefix, valueType);
-                if (propertyMap == null) {
+                if (propertyMap == null)
+                {
                     propertyMap = new HashMap<String, Method>();
                     propertyMapMap.put(targetClass, propertyMap);
                 }
                 propertyMap.put(mPropertyName, setterOrGetter);
             }
-        } finally {
+        }
+        finally
+        {
             mPropertyMapLock.writeLock().unlock();
         }
         return setterOrGetter;
@@ -480,16 +557,19 @@ private Method setupSetterOrGetter(Class targetClass,
 
     /**
      * Utility function to get the setter from targetClass
+     *
      * @param targetClass The Class on which the requested method should exist.
      */
-    void setupSetter(Class targetClass) {
+    void setupSetter(Class targetClass)
+    {
         mSetter = setupSetterOrGetter(targetClass, sSetterPropertyMap, "set", mValueType);
     }
 
     /**
      * Utility function to get the getter from targetClass
      */
-    private void setupGetter(Class targetClass) {
+    private void setupGetter(Class targetClass)
+    {
         mGetter = setupSetterOrGetter(targetClass, sGetterPropertyMap, "get", null);
     }
 
@@ -501,39 +581,56 @@ private void setupGetter(Class targetClass) {
      * supplied values was null. If there is a null value, then the getter (supplied or derived)
      * will be called to set those null values to the current value of the property
      * on the target object.
+     *
      * @param target The object on which the setter (and possibly getter) exist.
      */
-    void setupSetterAndGetter(Object target) {
-        if (mProperty != null) {
+    void setupSetterAndGetter(Object target)
+    {
+        if (mProperty != null)
+        {
             // check to make sure that mProperty is on the class of target
-            try {
+            try
+            {
                 Object testValue = mProperty.get(target);
-                for (Keyframe kf : mKeyframeSet.mKeyframes) {
-                    if (!kf.hasValue()) {
+                for (Keyframe kf : mKeyframeSet.mKeyframes)
+                {
+                    if (!kf.hasValue())
+                    {
                         kf.setValue(mProperty.get(target));
                     }
                 }
                 return;
-            } catch (ClassCastException e) {
-                Log.e("PropertyValuesHolder","No such property (" + mProperty.getName() +
+            }
+            catch (ClassCastException e)
+            {
+                Log.e("PropertyValuesHolder", "No such property (" + mProperty.getName() +
                         ") on target object " + target + ". Trying reflection instead");
                 mProperty = null;
             }
         }
         Class targetClass = target.getClass();
-        if (mSetter == null) {
+        if (mSetter == null)
+        {
             setupSetter(targetClass);
         }
-        for (Keyframe kf : mKeyframeSet.mKeyframes) {
-            if (!kf.hasValue()) {
-                if (mGetter == null) {
+        for (Keyframe kf : mKeyframeSet.mKeyframes)
+        {
+            if (!kf.hasValue())
+            {
+                if (mGetter == null)
+                {
                     setupGetter(targetClass);
                 }
-                try {
+                try
+                {
                     kf.setValue(mGetter.invoke(target));
-                } catch (InvocationTargetException e) {
+                }
+                catch (InvocationTargetException e)
+                {
                     Log.e("PropertyValuesHolder", e.toString());
-                } catch (IllegalAccessException e) {
+                }
+                catch (IllegalAccessException e)
+                {
                     Log.e("PropertyValuesHolder", e.toString());
                 }
             }
@@ -545,21 +642,29 @@ void setupSetterAndGetter(Object target) {
      * whatever the value is for the property name specified in the keyframe on the target object.
      *
      * @param target The target object from which the current value should be extracted.
-     * @param kf The keyframe which holds the property name and value.
+     * @param kf     The keyframe which holds the property name and value.
      */
-    private void setupValue(Object target, Keyframe kf) {
-        if (mProperty != null) {
+    private void setupValue(Object target, Keyframe kf)
+    {
+        if (mProperty != null)
+        {
             kf.setValue(mProperty.get(target));
         }
-        try {
-            if (mGetter == null) {
+        try
+        {
+            if (mGetter == null)
+            {
                 Class targetClass = target.getClass();
                 setupGetter(targetClass);
             }
             kf.setValue(mGetter.invoke(target));
-        } catch (InvocationTargetException e) {
+        }
+        catch (InvocationTargetException e)
+        {
             Log.e("PropertyValuesHolder", e.toString());
-        } catch (IllegalAccessException e) {
+        }
+        catch (IllegalAccessException e)
+        {
             Log.e("PropertyValuesHolder", e.toString());
         }
     }
@@ -572,7 +677,8 @@ private void setupValue(Object target, Keyframe kf) {
      *
      * @param target The object which holds the start values that should be set.
      */
-    void setupStartValue(Object target) {
+    void setupStartValue(Object target)
+    {
         setupValue(target, mKeyframeSet.mKeyframes.get(0));
     }
 
@@ -584,61 +690,52 @@ void setupStartValue(Object target) {
      *
      * @param target The object which holds the start values that should be set.
      */
-    void setupEndValue(Object target) {
+    void setupEndValue(Object target)
+    {
         setupValue(target, mKeyframeSet.mKeyframes.get(mKeyframeSet.mKeyframes.size() - 1));
     }
 
     @Override
-    public PropertyValuesHolder clone() {
-        try {
+    public PropertyValuesHolder clone()
+    {
+        try
+        {
             PropertyValuesHolder newPVH = (PropertyValuesHolder) super.clone();
             newPVH.mPropertyName = mPropertyName;
             newPVH.mProperty = mProperty;
             newPVH.mKeyframeSet = mKeyframeSet.clone();
             newPVH.mEvaluator = mEvaluator;
             return newPVH;
-        } catch (CloneNotSupportedException e) {
+        }
+        catch (CloneNotSupportedException e)
+        {
             // won't reach here
             return null;
         }
     }
 
-    /**
-     * Internal function to set the value on the target object, using the setter set up
-     * earlier on this PropertyValuesHolder object. This function is called by ObjectAnimator
-     * to handle turning the value calculated by ValueAnimator into a value set on the object
-     * according to the name of the property.
-     * @param target The target object on which the value is set
-     */
-    void setAnimatedValue(Object target) {
-        if (mProperty != null) {
-            mProperty.set(target, getAnimatedValue());
-        }
-        if (mSetter != null) {
-            try {
-                mTmpValueArray[0] = getAnimatedValue();
-                mSetter.invoke(target, mTmpValueArray);
-            } catch (InvocationTargetException e) {
-                Log.e("PropertyValuesHolder", e.toString());
-            } catch (IllegalAccessException e) {
-                Log.e("PropertyValuesHolder", e.toString());
-            }
-        }
+    @Override
+    public String toString()
+    {
+        return mPropertyName + ": " + mKeyframeSet.toString();
     }
 
     /**
      * Internal function, called by ValueAnimator, to set up the TypeEvaluator that will be used
      * to calculate animated values.
      */
-    void init() {
-        if (mEvaluator == null) {
+    void init()
+    {
+        if (mEvaluator == null)
+        {
             // We already handle int and float automatically, but not their Object
             // equivalents
             mEvaluator = (mValueType == Integer.class) ? sIntEvaluator :
                     (mValueType == Float.class) ? sFloatEvaluator :
-                    null;
+                            null;
         }
-        if (mEvaluator != null) {
+        if (mEvaluator != null)
+        {
             // KeyframeSet knows how to evaluate the common types - only give it a custom
             // evaluator if one has been set on this class
             mKeyframeSet.setEvaluator(mEvaluator);
@@ -653,9 +750,11 @@ void init() {
      * are of a custom type or one not currently understood by the animation system. Currently,
      * only values of type float and int (and their Object equivalents: Float
      * and Integer) are  correctly interpolated; all other types require setting a TypeEvaluator.
+     *
      * @param evaluator
      */
-    public void setEvaluator(TypeEvaluator evaluator) {
+    public void setEvaluator(TypeEvaluator evaluator)
+    {
         mEvaluator = evaluator;
         mKeyframeSet.setEvaluator(evaluator);
     }
@@ -666,38 +765,21 @@ public void setEvaluator(TypeEvaluator evaluator) {
      *
      * @param fraction The elapsed, interpolated fraction of the animation.
      */
-    void calculateValue(float fraction) {
+    void calculateValue(float fraction)
+    {
         mAnimatedValue = mKeyframeSet.getValue(fraction);
     }
 
-    /**
-     * Sets the name of the property that will be animated. This name is used to derive
-     * a setter function that will be called to set animated values.
-     * For example, a property name of <code>foo</code> will result
-     * in a call to the function <code>setFoo()</code> on the target object. If either
-     * <code>valueFrom</code> or <code>valueTo</code> is null, then a getter function will
-     * also be derived and called.
-     *
-     * <p>Note that the setter function derived from this property name
-     * must take the same parameter type as the
-     * <code>valueFrom</code> and <code>valueTo</code> properties, otherwise the call to
-     * the setter function will fail.</p>
-     *
-     * @param propertyName The name of the property being animated.
-     */
-    public void setPropertyName(String propertyName) {
-        mPropertyName = propertyName;
-    }
-
     /**
      * Sets the property that will be animated.
-     *
+     * <p/>
      * <p>Note that if this PropertyValuesHolder object is used with ObjectAnimator, the property
      * must exist on the target object specified in that ObjectAnimator.</p>
      *
      * @param property The property being animated.
      */
-    public void setProperty(Property property) {
+    public void setProperty(Property property)
+    {
         mProperty = property;
     }
 
@@ -709,106 +791,143 @@ public void setProperty(Property property) {
      * <code>valueFrom</code> or <code>valueTo</code> is null, then a getter function will
      * also be derived and called.
      */
-    public String getPropertyName() {
+    public String getPropertyName()
+    {
         return mPropertyName;
     }
 
+    /**
+     * Sets the name of the property that will be animated. This name is used to derive
+     * a setter function that will be called to set animated values.
+     * For example, a property name of <code>foo</code> will result
+     * in a call to the function <code>setFoo()</code> on the target object. If either
+     * <code>valueFrom</code> or <code>valueTo</code> is null, then a getter function will
+     * also be derived and called.
+     * <p/>
+     * <p>Note that the setter function derived from this property name
+     * must take the same parameter type as the
+     * <code>valueFrom</code> and <code>valueTo</code> properties, otherwise the call to
+     * the setter function will fail.</p>
+     *
+     * @param propertyName The name of the property being animated.
+     */
+    public void setPropertyName(String propertyName)
+    {
+        mPropertyName = propertyName;
+    }
+
     /**
      * Internal function, called by ValueAnimator and ObjectAnimator, to retrieve the value
      * most recently calculated in calculateValue().
+     *
      * @return
      */
-    Object getAnimatedValue() {
+    Object getAnimatedValue()
+    {
         return mAnimatedValue;
     }
 
-    @Override
-    public String toString() {
-        return mPropertyName + ": " + mKeyframeSet.toString();
-    }
-
     /**
-     * Utility method to derive a setter/getter method name from a property name, where the
-     * prefix is typically "set" or "get" and the first letter of the property name is
-     * capitalized.
+     * Internal function to set the value on the target object, using the setter set up
+     * earlier on this PropertyValuesHolder object. This function is called by ObjectAnimator
+     * to handle turning the value calculated by ValueAnimator into a value set on the object
+     * according to the name of the property.
      *
-     * @param prefix The precursor to the method name, before the property name begins, typically
-     * "set" or "get".
-     * @param propertyName The name of the property that represents the bulk of the method name
-     * after the prefix. The first letter of this word will be capitalized in the resulting
-     * method name.
-     * @return String the property name converted to a method name according to the conventions
-     * specified above.
+     * @param target The target object on which the value is set
      */
-    static String getMethodName(String prefix, String propertyName) {
-        if (propertyName == null || propertyName.length() == 0) {
-            // shouldn't get here
-            return prefix;
+    void setAnimatedValue(Object target)
+    {
+        if (mProperty != null)
+        {
+            mProperty.set(target, getAnimatedValue());
+        }
+        if (mSetter != null)
+        {
+            try
+            {
+                mTmpValueArray[0] = getAnimatedValue();
+                mSetter.invoke(target, mTmpValueArray);
+            }
+            catch (InvocationTargetException e)
+            {
+                Log.e("PropertyValuesHolder", e.toString());
+            }
+            catch (IllegalAccessException e)
+            {
+                Log.e("PropertyValuesHolder", e.toString());
+            }
         }
-        char firstLetter = Character.toUpperCase(propertyName.charAt(0));
-        String theRest = propertyName.substring(1);
-        return prefix + firstLetter + theRest;
     }
 
-    static class IntPropertyValuesHolder extends PropertyValuesHolder {
+    static class IntPropertyValuesHolder extends PropertyValuesHolder
+    {
 
+        IntKeyframeSet mIntKeyframeSet;
+        int mIntAnimatedValue;
         // Cache JNI functions to avoid looking them up twice
         //private static final HashMap<Class, HashMap<String, Integer>> sJNISetterPropertyMap =
         //        new HashMap<Class, HashMap<String, Integer>>();
         //int mJniSetter;
         private IntProperty mIntProperty;
 
-        IntKeyframeSet mIntKeyframeSet;
-        int mIntAnimatedValue;
-
-        public IntPropertyValuesHolder(String propertyName, IntKeyframeSet keyframeSet) {
+        public IntPropertyValuesHolder(String propertyName, IntKeyframeSet keyframeSet)
+        {
             super(propertyName);
             mValueType = int.class;
             mKeyframeSet = keyframeSet;
             mIntKeyframeSet = (IntKeyframeSet) mKeyframeSet;
         }
 
-        public IntPropertyValuesHolder(Property property, IntKeyframeSet keyframeSet) {
+        public IntPropertyValuesHolder(Property property, IntKeyframeSet keyframeSet)
+        {
             super(property);
             mValueType = int.class;
             mKeyframeSet = keyframeSet;
             mIntKeyframeSet = (IntKeyframeSet) mKeyframeSet;
-            if (property instanceof  IntProperty) {
+            if (property instanceof IntProperty)
+            {
                 mIntProperty = (IntProperty) mProperty;
             }
         }
 
-        public IntPropertyValuesHolder(String propertyName, int... values) {
+        public IntPropertyValuesHolder(String propertyName, int... values)
+        {
             super(propertyName);
             setIntValues(values);
         }
 
-        public IntPropertyValuesHolder(Property property, int... values) {
+        public IntPropertyValuesHolder(Property property, int... values)
+        {
             super(property);
             setIntValues(values);
-            if (property instanceof  IntProperty) {
+            if (property instanceof IntProperty)
+            {
                 mIntProperty = (IntProperty) mProperty;
             }
         }
 
         @Override
-        public void setIntValues(int... values) {
+        public void setIntValues(int... values)
+        {
             super.setIntValues(values);
             mIntKeyframeSet = (IntKeyframeSet) mKeyframeSet;
         }
 
         @Override
-        void calculateValue(float fraction) {
+        void calculateValue(float fraction)
+        {
             mIntAnimatedValue = mIntKeyframeSet.getIntValue(fraction);
         }
 
         @Override
-        Object getAnimatedValue() {
+        Object getAnimatedValue()
+        {
             return mIntAnimatedValue;
         }
 
         @Override
-        public IntPropertyValuesHolder clone() {
+        public IntPropertyValuesHolder clone()
+        {
             IntPropertyValuesHolder newPVH = (IntPropertyValuesHolder) super.clone();
             newPVH.mIntKeyframeSet = (IntKeyframeSet) newPVH.mKeyframeSet;
             return newPVH;
@@ -819,15 +938,19 @@ public IntPropertyValuesHolder clone() {
          * earlier on this PropertyValuesHolder object. This function is called by ObjectAnimator
          * to handle turning the value calculated by ValueAnimator into a value set on the object
          * according to the name of the property.
+         *
          * @param target The target object on which the value is set
          */
         @Override
-        void setAnimatedValue(Object target) {
-            if (mIntProperty != null) {
+        void setAnimatedValue(Object target)
+        {
+            if (mIntProperty != null)
+            {
                 mIntProperty.setValue(target, mIntAnimatedValue);
                 return;
             }
-            if (mProperty != null) {
+            if (mProperty != null)
+            {
                 mProperty.set(target, mIntAnimatedValue);
                 return;
             }
@@ -835,21 +958,29 @@ void setAnimatedValue(Object target) {
             //    nCallIntMethod(target, mJniSetter, mIntAnimatedValue);
             //    return;
             //}
-            if (mSetter != null) {
-                try {
+            if (mSetter != null)
+            {
+                try
+                {
                     mTmpValueArray[0] = mIntAnimatedValue;
                     mSetter.invoke(target, mTmpValueArray);
-                } catch (InvocationTargetException e) {
+                }
+                catch (InvocationTargetException e)
+                {
                     Log.e("PropertyValuesHolder", e.toString());
-                } catch (IllegalAccessException e) {
+                }
+                catch (IllegalAccessException e)
+                {
                     Log.e("PropertyValuesHolder", e.toString());
                 }
             }
         }
 
         @Override
-        void setupSetter(Class targetClass) {
-            if (mProperty != null) {
+        void setupSetter(Class targetClass)
+        {
+            if (mProperty != null)
+            {
                 return;
             }
             // Check new static hashmap<propName, int> for setter method
@@ -880,71 +1011,81 @@ void setupSetter(Class targetClass) {
             //    mPropertyMapLock.writeLock().unlock();
             //}
             //if (mJniSetter == 0) {
-                // Couldn't find method through fast JNI approach - just use reflection
-                super.setupSetter(targetClass);
+            // Couldn't find method through fast JNI approach - just use reflection
+            super.setupSetter(targetClass);
             //}
         }
     }
 
-    static class FloatPropertyValuesHolder extends PropertyValuesHolder {
+    static class FloatPropertyValuesHolder extends PropertyValuesHolder
+    {
 
+        FloatKeyframeSet mFloatKeyframeSet;
+        float mFloatAnimatedValue;
         // Cache JNI functions to avoid looking them up twice
         //private static final HashMap<Class, HashMap<String, Integer>> sJNISetterPropertyMap =
         //        new HashMap<Class, HashMap<String, Integer>>();
         //int mJniSetter;
         private FloatProperty mFloatProperty;
 
-        FloatKeyframeSet mFloatKeyframeSet;
-        float mFloatAnimatedValue;
-
-        public FloatPropertyValuesHolder(String propertyName, FloatKeyframeSet keyframeSet) {
+        public FloatPropertyValuesHolder(String propertyName, FloatKeyframeSet keyframeSet)
+        {
             super(propertyName);
             mValueType = float.class;
             mKeyframeSet = keyframeSet;
             mFloatKeyframeSet = (FloatKeyframeSet) mKeyframeSet;
         }
 
-        public FloatPropertyValuesHolder(Property property, FloatKeyframeSet keyframeSet) {
+        public FloatPropertyValuesHolder(Property property, FloatKeyframeSet keyframeSet)
+        {
             super(property);
             mValueType = float.class;
             mKeyframeSet = keyframeSet;
             mFloatKeyframeSet = (FloatKeyframeSet) mKeyframeSet;
-            if (property instanceof FloatProperty) {
+            if (property instanceof FloatProperty)
+            {
                 mFloatProperty = (FloatProperty) mProperty;
             }
         }
 
-        public FloatPropertyValuesHolder(String propertyName, float... values) {
+        public FloatPropertyValuesHolder(String propertyName, float... values)
+        {
             super(propertyName);
             setFloatValues(values);
         }
 
-        public FloatPropertyValuesHolder(Property property, float... values) {
+        public FloatPropertyValuesHolder(Property property, float... values)
+        {
             super(property);
             setFloatValues(values);
-            if (property instanceof  FloatProperty) {
+            if (property instanceof FloatProperty)
+            {
                 mFloatProperty = (FloatProperty) mProperty;
             }
         }
 
         @Override
-        public void setFloatValues(float... values) {
+        public void setFloatValues(float... values)
+        {
             super.setFloatValues(values);
             mFloatKeyframeSet = (FloatKeyframeSet) mKeyframeSet;
         }
 
         @Override
-        void calculateValue(float fraction) {
+        void calculateValue(float fraction)
+        {
             mFloatAnimatedValue = mFloatKeyframeSet.getFloatValue(fraction);
         }
 
         @Override
-        Object getAnimatedValue() {
+        Object getAnimatedValue()
+        {
             return mFloatAnimatedValue;
         }
 
         @Override
-        public FloatPropertyValuesHolder clone() {
+        public FloatPropertyValuesHolder clone()
+        {
             FloatPropertyValuesHolder newPVH = (FloatPropertyValuesHolder) super.clone();
             newPVH.mFloatKeyframeSet = (FloatKeyframeSet) newPVH.mKeyframeSet;
             return newPVH;
@@ -955,15 +1096,19 @@ public FloatPropertyValuesHolder clone() {
          * earlier on this PropertyValuesHolder object. This function is called by ObjectAnimator
          * to handle turning the value calculated by ValueAnimator into a value set on the object
          * according to the name of the property.
+         *
          * @param target The target object on which the value is set
          */
         @Override
-        void setAnimatedValue(Object target) {
-            if (mFloatProperty != null) {
+        void setAnimatedValue(Object target)
+        {
+            if (mFloatProperty != null)
+            {
                 mFloatProperty.setValue(target, mFloatAnimatedValue);
                 return;
             }
-            if (mProperty != null) {
+            if (mProperty != null)
+            {
                 mProperty.set(target, mFloatAnimatedValue);
                 return;
             }
@@ -971,21 +1116,29 @@ void setAnimatedValue(Object target) {
             //    nCallFloatMethod(target, mJniSetter, mFloatAnimatedValue);
             //    return;
             //}
-            if (mSetter != null) {
-                try {
+            if (mSetter != null)
+            {
+                try
+                {
                     mTmpValueArray[0] = mFloatAnimatedValue;
                     mSetter.invoke(target, mTmpValueArray);
-                } catch (InvocationTargetException e) {
+                }
+                catch (InvocationTargetException e)
+                {
                     Log.e("PropertyValuesHolder", e.toString());
-                } catch (IllegalAccessException e) {
+                }
+                catch (IllegalAccessException e)
+                {
                     Log.e("PropertyValuesHolder", e.toString());
                 }
             }
         }
 
         @Override
-        void setupSetter(Class targetClass) {
-            if (mProperty != null) {
+        void setupSetter(Class targetClass)
+        {
+            if (mProperty != null)
+            {
                 return;
             }
             // Check new static hashmap<propName, int> for setter method
@@ -1016,8 +1169,8 @@ void setupSetter(Class targetClass) {
             //    mPropertyMapLock.writeLock().unlock();
             //}
             //if (mJniSetter == 0) {
-                // Couldn't find method through fast JNI approach - just use reflection
-                super.setupSetter(targetClass);
+            // Couldn't find method through fast JNI approach - just use reflection
+            super.setupSetter(targetClass);
             //}
         }
 
diff --git a/library/src/com/nineoldandroids/animation/TimeAnimator.java b/library/src/com/nineoldandroids/animation/TimeAnimator.java
index 7c50063..9158632 100644
--- a/library/src/com/nineoldandroids/animation/TimeAnimator.java
+++ b/library/src/com/nineoldandroids/animation/TimeAnimator.java
@@ -9,24 +9,31 @@
  *
  * @hide
  */
-public class TimeAnimator extends ValueAnimator {
+public class TimeAnimator extends ValueAnimator
+{
 
     private TimeListener mListener;
     private long mPreviousTime = -1;
 
     @Override
-    boolean animationFrame(long currentTime) {
-        if (mPlayingState == STOPPED) {
+    boolean animationFrame(long currentTime)
+    {
+        if (mPlayingState == STOPPED)
+        {
             mPlayingState = RUNNING;
-            if (mSeekTime < 0) {
+            if (mSeekTime < 0)
+            {
                 mStartTime = currentTime;
-            } else {
+            }
+            else
+            {
                 mStartTime = currentTime - mSeekTime;
                 // Now that we're playing, reset the seek time
                 mSeekTime = -1;
             }
         }
-        if (mListener != null) {
+        if (mListener != null)
+        {
             long totalTime = currentTime - mStartTime;
             long deltaTime = (mPreviousTime < 0) ? 0 : (currentTime - mPreviousTime);
             mPreviousTime = currentTime;
@@ -41,17 +48,20 @@ boolean animationFrame(long currentTime) {
      *
      * @param listener the listener to be set.
      */
-    public void setTimeListener(TimeListener listener) {
+    public void setTimeListener(TimeListener listener)
+    {
         mListener = listener;
     }
 
     @Override
-    void animateValue(float fraction) {
+    void animateValue(float fraction)
+    {
         // Noop
     }
 
     @Override
-    void initAnimation() {
+    void initAnimation()
+    {
         // noop
     }
 
@@ -64,7 +74,8 @@ void initAnimation() {
      *
      * @hide
      */
-    public static interface TimeListener {
+    public static interface TimeListener
+    {
         /**
          * <p>Notifies listeners of the occurrence of another frame of the animation,
          * along with information about the elapsed time.</p>
diff --git a/library/src/com/nineoldandroids/animation/TypeEvaluator.java b/library/src/com/nineoldandroids/animation/TypeEvaluator.java
index 5d2f05e..743985c 100644
--- a/library/src/com/nineoldandroids/animation/TypeEvaluator.java
+++ b/library/src/com/nineoldandroids/animation/TypeEvaluator.java
@@ -24,7 +24,8 @@
  *
  * @see ValueAnimator#setEvaluator(TypeEvaluator)
  */
-public interface TypeEvaluator<T> {
+public interface TypeEvaluator<T>
+{
 
     /**
      * This function returns the result of linearly interpolating the start and end values, with
@@ -37,7 +38,7 @@
      * @param startValue The start value.
      * @param endValue   The end value.
      * @return A linear interpolation between the start and end values, given the
-     *         <code>fraction</code> parameter.
+     * <code>fraction</code> parameter.
      */
     public T evaluate(float fraction, T startValue, T endValue);
 
diff --git a/library/src/com/nineoldandroids/animation/ValueAnimator.java b/library/src/com/nineoldandroids/animation/ValueAnimator.java
index 45866f5..fda8297 100644
--- a/library/src/com/nineoldandroids/animation/ValueAnimator.java
+++ b/library/src/com/nineoldandroids/animation/ValueAnimator.java
@@ -31,145 +31,193 @@
 /**
  * This class provides a simple timing engine for running animations
  * which calculate animated values and set them on target objects.
- *
+ * <p/>
  * <p>There is a single timing pulse that all animations use. It runs in a
  * custom handler to ensure that property changes happen on the UI thread.</p>
- *
+ * <p/>
  * <p>By default, ValueAnimator uses non-linear time interpolation, via the
  * {@link AccelerateDecelerateInterpolator} class, which accelerates into and decelerates
  * out of an animation. This behavior can be changed by calling
  * {@link ValueAnimator#setInterpolator(TimeInterpolator)}.</p>
  */
-public class ValueAnimator extends Animator {
+public class ValueAnimator extends Animator
+{
 
     /**
-     * Internal constants
+     * When the animation reaches the end and <code>repeatCount</code> is INFINITE
+     * or a positive value, the animation restarts from the beginning.
      */
-
-    /*
-     * The default amount of time in ms between animation frames
+    public static final int RESTART = 1;
+    /**
+     * The type of repetition that will occur when repeatMode is nonzero. RESTART means the
+     * animation will start from the beginning on every new cycle. REVERSE means the animation
+     * will reverse directions on each iteration.
      */
-    private static final long DEFAULT_FRAME_DELAY = 10;
-
+    private int mRepeatMode = RESTART;
+    /**
+     * When the animation reaches the end and <code>repeatCount</code> is INFINITE
+     * or a positive value, the animation reverses direction on every iteration.
+     */
+    public static final int REVERSE = 2;
+    /**
+     * This value used used with the {@link #setRepeatCount(int)} property to repeat
+     * the animation indefinitely.
+     */
+    public static final int INFINITE = -1;
     /**
      * Messages sent to timing handler: START is sent when an animation first begins, FRAME is sent
      * by the handler to itself to process the next animation frame
      */
     static final int ANIMATION_START = 0;
     static final int ANIMATION_FRAME = 1;
-
     /**
      * Values used with internal variable mPlayingState to indicate the current state of an
      * animation.
      */
-    static final int STOPPED    = 0; // Not yet playing
-    static final int RUNNING    = 1; // Playing normally
-    static final int SEEKED     = 2; // Seeked to some time value
-
-    /**
-     * Internal variables
-     * NOTE: This object implements the clone() method, making a deep copy of any referenced
-     * objects. As other non-trivial fields are added to this class, make sure to add logic
-     * to clone() to make deep copies of them.
-     */
-
-    // The first time that the animation's animateFrame() method is called. This time is used to
-    // determine elapsed time (and therefore the elapsed fraction) in subsequent calls
-    // to animateFrame()
-    long mStartTime;
-
+    static final int STOPPED = 0; // Not yet playing
     /**
-     * Set when setCurrentPlayTime() is called. If negative, animation is not currently seeked
-     * to a value.
+     * Flag that represents the current state of the animation. Used to figure out when to start
+     * an animation (if state == STOPPED). Also used to end an animation that
+     * has been cancel()'d or end()'d since the last animation frame. Possible values are
+     * STOPPED, RUNNING, SEEKED.
      */
-    long mSeekTime = -1;
+    int mPlayingState = STOPPED;
 
     // TODO: We access the following ThreadLocal variables often, some of them on every update.
     // If ThreadLocal access is significantly expensive, we may want to put all of these
     // fields into a structure sot hat we just access ThreadLocal once to get the reference
     // to that structure, then access the structure directly for each field.
+    static final int RUNNING = 1; // Playing normally
+    static final int SEEKED = 2; // Seeked to some time value
+    /**
+     * Internal constants
+     */
 
-    // The static sAnimationHandler processes the internal timing loop on which all animations
-    // are based
-    private static ThreadLocal<AnimationHandler> sAnimationHandler =
-            new ThreadLocal<AnimationHandler>();
-
+    /*
+     * The default amount of time in ms between animation frames
+     */
+    private static final long DEFAULT_FRAME_DELAY = 10;
+    // The number of milliseconds between animation frames
+    private static long sFrameDelay = DEFAULT_FRAME_DELAY;
     // The per-thread list of all active animations
     private static final ThreadLocal<ArrayList<ValueAnimator>> sAnimations =
-            new ThreadLocal<ArrayList<ValueAnimator>>() {
+            new ThreadLocal<ArrayList<ValueAnimator>>()
+            {
                 @Override
-                protected ArrayList<ValueAnimator> initialValue() {
+                protected ArrayList<ValueAnimator> initialValue()
+                {
                     return new ArrayList<ValueAnimator>();
                 }
             };
-
     // The per-thread set of animations to be started on the next animation frame
     private static final ThreadLocal<ArrayList<ValueAnimator>> sPendingAnimations =
-            new ThreadLocal<ArrayList<ValueAnimator>>() {
+            new ThreadLocal<ArrayList<ValueAnimator>>()
+            {
                 @Override
-                protected ArrayList<ValueAnimator> initialValue() {
+                protected ArrayList<ValueAnimator> initialValue()
+                {
                     return new ArrayList<ValueAnimator>();
                 }
             };
-
     /**
      * Internal per-thread collections used to avoid set collisions as animations start and end
      * while being processed.
      */
     private static final ThreadLocal<ArrayList<ValueAnimator>> sDelayedAnims =
-            new ThreadLocal<ArrayList<ValueAnimator>>() {
+            new ThreadLocal<ArrayList<ValueAnimator>>()
+            {
                 @Override
-                protected ArrayList<ValueAnimator> initialValue() {
+                protected ArrayList<ValueAnimator> initialValue()
+                {
                     return new ArrayList<ValueAnimator>();
                 }
             };
-
     private static final ThreadLocal<ArrayList<ValueAnimator>> sEndingAnims =
-            new ThreadLocal<ArrayList<ValueAnimator>>() {
+            new ThreadLocal<ArrayList<ValueAnimator>>()
+            {
                 @Override
-                protected ArrayList<ValueAnimator> initialValue() {
+                protected ArrayList<ValueAnimator> initialValue()
+                {
                     return new ArrayList<ValueAnimator>();
                 }
             };
-
     private static final ThreadLocal<ArrayList<ValueAnimator>> sReadyAnims =
-            new ThreadLocal<ArrayList<ValueAnimator>>() {
+            new ThreadLocal<ArrayList<ValueAnimator>>()
+            {
                 @Override
-                protected ArrayList<ValueAnimator> initialValue() {
+                protected ArrayList<ValueAnimator> initialValue()
+                {
                     return new ArrayList<ValueAnimator>();
                 }
             };
-
     // The time interpolator to be used if none is set on the animation
-    private static final /*Time*/Interpolator sDefaultInterpolator =
+    private static final /*Time*/ Interpolator sDefaultInterpolator =
             new AccelerateDecelerateInterpolator();
-
+    /**
+     * The time interpolator to be used. The elapsed fraction of the animation will be passed
+     * through this interpolator to calculate the interpolated fraction, which is then used to
+     * calculate the animated values.
+     */
+    private /*Time*/ Interpolator mInterpolator = sDefaultInterpolator;
     // type evaluators for the primitive types handled by this implementation
     private static final TypeEvaluator sIntEvaluator = new IntEvaluator();
     private static final TypeEvaluator sFloatEvaluator = new FloatEvaluator();
+    // The static sAnimationHandler processes the internal timing loop on which all animations
+    // are based
+    private static ThreadLocal<AnimationHandler> sAnimationHandler =
+            new ThreadLocal<AnimationHandler>();
+    /**
+     * Internal variables
+     * NOTE: This object implements the clone() method, making a deep copy of any referenced
+     * objects. As other non-trivial fields are added to this class, make sure to add logic
+     * to clone() to make deep copies of them.
+     */
+
+    // The first time that the animation's animateFrame() method is called. This time is used to
+    // determine elapsed time (and therefore the elapsed fraction) in subsequent calls
+    // to animateFrame()
+    long mStartTime;
+    /**
+     * Set when setCurrentPlayTime() is called. If negative, animation is not currently seeked
+     * to a value.
+     */
+    long mSeekTime = -1;
+    /**
+     * Flag that denotes whether the animation is set up and ready to go. Used to
+     * set up animation that has not yet been started.
+     */
+    boolean mInitialized = false;
+    /**
+     * The property/value sets being animated.
+     */
+    PropertyValuesHolder[] mValues;
 
+    //
+    // Backing variables
+    //
+    /**
+     * A hashmap of the PropertyValuesHolder objects. This map is used to lookup animated values
+     * by property name during calls to getAnimatedValue(String).
+     */
+    HashMap<String, PropertyValuesHolder> mValuesMap;
     /**
      * Used to indicate whether the animation is currently playing in reverse. This causes the
      * elapsed fraction to be inverted to calculate the appropriate values.
      */
     private boolean mPlayingBackwards = false;
-
     /**
      * This variable tracks the current iteration that is playing. When mCurrentIteration exceeds the
      * repeatCount (if repeatCount!=INFINITE), the animation ends
      */
     private int mCurrentIteration = 0;
-
     /**
      * Tracks current elapsed/eased fraction, for querying in getAnimatedFraction().
      */
     private float mCurrentFraction = 0f;
-
     /**
      * Tracks whether a startDelay'd animation has begun playing through the startDelay.
      */
     private boolean mStartedDelay = false;
-
     /**
      * Tracks the time at which the animation began playing through its startDelay. This is
      * different from the mStartTime variable, which is used to track when the animation became
@@ -177,15 +225,6 @@
      * animations list).
      */
     private long mDelayStartTime;
-
-    /**
-     * Flag that represents the current state of the animation. Used to figure out when to start
-     * an animation (if state == STOPPED). Also used to end an animation that
-     * has been cancel()'d or end()'d since the last animation frame. Possible values are
-     * STOPPED, RUNNING, SEEKED.
-     */
-    int mPlayingState = STOPPED;
-
     /**
      * Additional playing state to indicate whether an animator has been start()'d. There is
      * some lag between a call to start() and the first animation frame. We should still note
@@ -195,92 +234,34 @@
      * animation frame, which occurs after their delay elapses.
      */
     private boolean mRunning = false;
-
     /**
      * Additional playing state to indicate whether an animator has been start()'d, whether or
      * not there is a nonzero startDelay.
      */
     private boolean mStarted = false;
-
-    /**
-     * Flag that denotes whether the animation is set up and ready to go. Used to
-     * set up animation that has not yet been started.
-     */
-    boolean mInitialized = false;
-
-    //
-    // Backing variables
-    //
-
     // How long the animation should last in ms
     private long mDuration = 300;
 
+    /**
+     * Public constants
+     */
     // The amount of time in ms to delay starting the animation after start() is called
     private long mStartDelay = 0;
-
-    // The number of milliseconds between animation frames
-    private static long sFrameDelay = DEFAULT_FRAME_DELAY;
-
     // The number of times the animation will repeat. The default is 0, which means the animation
     // will play only once
     private int mRepeatCount = 0;
-
-    /**
-     * The type of repetition that will occur when repeatMode is nonzero. RESTART means the
-     * animation will start from the beginning on every new cycle. REVERSE means the animation
-     * will reverse directions on each iteration.
-     */
-    private int mRepeatMode = RESTART;
-
-    /**
-     * The time interpolator to be used. The elapsed fraction of the animation will be passed
-     * through this interpolator to calculate the interpolated fraction, which is then used to
-     * calculate the animated values.
-     */
-    private /*Time*/Interpolator mInterpolator = sDefaultInterpolator;
-
     /**
      * The set of listeners to be sent events through the life of an animation.
      */
     private ArrayList<AnimatorUpdateListener> mUpdateListeners = null;
 
-    /**
-     * The property/value sets being animated.
-     */
-    PropertyValuesHolder[] mValues;
-
-    /**
-     * A hashmap of the PropertyValuesHolder objects. This map is used to lookup animated values
-     * by property name during calls to getAnimatedValue(String).
-     */
-    HashMap<String, PropertyValuesHolder> mValuesMap;
-
-    /**
-     * Public constants
-     */
-
-    /**
-     * When the animation reaches the end and <code>repeatCount</code> is INFINITE
-     * or a positive value, the animation restarts from the beginning.
-     */
-    public static final int RESTART = 1;
-    /**
-     * When the animation reaches the end and <code>repeatCount</code> is INFINITE
-     * or a positive value, the animation reverses direction on every iteration.
-     */
-    public static final int REVERSE = 2;
-    /**
-     * This value used used with the {@link #setRepeatCount(int)} property to repeat
-     * the animation indefinitely.
-     */
-    public static final int INFINITE = -1;
-
     /**
      * Creates a new ValueAnimator object. This default constructor is primarily for
      * use internally; the factory methods which take parameters are more generally
      * useful.
      */
-    public ValueAnimator() {
+    public ValueAnimator()
+    {
     }
 
     /**
@@ -294,7 +275,8 @@ public ValueAnimator() {
      * @param values A set of values that the animation will animate between over time.
      * @return A ValueAnimator object that is set up to animate between the given values.
      */
-    public static ValueAnimator ofInt(int... values) {
+    public static ValueAnimator ofInt(int... values)
+    {
         ValueAnimator anim = new ValueAnimator();
         anim.setIntValues(values);
         return anim;
@@ -311,7 +293,8 @@ public static ValueAnimator ofInt(int... values) {
      * @param values A set of values that the animation will animate between over time.
      * @return A ValueAnimator object that is set up to animate between the given values.
      */
-    public static ValueAnimator ofFloat(float... values) {
+    public static ValueAnimator ofFloat(float... values)
+    {
         ValueAnimator anim = new ValueAnimator();
         anim.setFloatValues(values);
         return anim;
@@ -322,14 +305,16 @@ public static ValueAnimator ofFloat(float... values) {
      * specified in the PropertyValuesHolder objects.
      *
      * @param values A set of PropertyValuesHolder objects whose values will be animated
-     * between over time.
+     *               between over time.
      * @return A ValueAnimator object that is set up to animate between the given values.
      */
-    public static ValueAnimator ofPropertyValuesHolder(PropertyValuesHolder... values) {
+    public static ValueAnimator ofPropertyValuesHolder(PropertyValuesHolder... values)
+    {
         ValueAnimator anim = new ValueAnimator();
         anim.setValues(values);
         return anim;
     }
+
     /**
      * Constructs and returns a ValueAnimator that animates between Object values. A single
      * value implies that that value is the one being animated to. However, this is not typically
@@ -337,24 +322,79 @@ public static ValueAnimator ofPropertyValuesHolder(PropertyValuesHolder... value
      * starting value for the animation (unlike ObjectAnimator, which can derive that value
      * from the target object and property being animated). Therefore, there should typically
      * be two or more values.
-     *
+     * <p/>
      * <p>Since ValueAnimator does not know how to animate between arbitrary Objects, this
      * factory method also takes a TypeEvaluator object that the ValueAnimator will use
      * to perform that interpolation.
      *
      * @param evaluator A TypeEvaluator that will be called on each animation frame to
-     * provide the ncessry interpolation between the Object values to derive the animated
-     * value.
-     * @param values A set of values that the animation will animate between over time.
+     *                  provide the ncessry interpolation between the Object values to derive the animated
+     *                  value.
+     * @param values    A set of values that the animation will animate between over time.
      * @return A ValueAnimator object that is set up to animate between the given values.
      */
-    public static ValueAnimator ofObject(TypeEvaluator evaluator, Object... values) {
+    public static ValueAnimator ofObject(TypeEvaluator evaluator, Object... values)
+    {
         ValueAnimator anim = new ValueAnimator();
         anim.setObjectValues(values);
         anim.setEvaluator(evaluator);
         return anim;
     }
 
+    /**
+     * The amount of time, in milliseconds, between each frame of the animation. This is a
+     * requested time that the animation will attempt to honor, but the actual delay between
+     * frames may be different, depending on system load and capabilities. This is a static
+     * function because the same delay will be applied to all animations, since they are all
+     * run off of a single timing loop.
+     *
+     * @return the requested time between frames, in milliseconds
+     */
+    public static long getFrameDelay()
+    {
+        return sFrameDelay;
+    }
+
+    /**
+     * The amount of time, in milliseconds, between each frame of the animation. This is a
+     * requested time that the animation will attempt to honor, but the actual delay between
+     * frames may be different, depending on system load and capabilities. This is a static
+     * function because the same delay will be applied to all animations, since they are all
+     * run off of a single timing loop.
+     *
+     * @param frameDelay the requested time between frames, in milliseconds
+     */
+    public static void setFrameDelay(long frameDelay)
+    {
+        sFrameDelay = frameDelay;
+    }
+
+    /**
+     * Return the number of animations currently running.
+     * <p/>
+     * Used by StrictMode internally to annotate violations.  Only
+     * called on the main thread.
+     *
+     * @hide
+     */
+    public static int getCurrentAnimationsCount()
+    {
+        return sAnimations.get().size();
+    }
+
+    /**
+     * Clear all animations on this thread, without canceling or ending them.
+     * This should be used with caution.
+     *
+     * @hide
+     */
+    public static void clearAllAnimations()
+    {
+        sAnimations.get().clear();
+        sPendingAnimations.get().clear();
+        sDelayedAnims.get().clear();
+    }
+
     /**
      * Sets int values that will be animated between. A single
      * value implies that that value is the one being animated to. However, this is not typically
@@ -362,20 +402,25 @@ public static ValueAnimator ofObject(TypeEvaluator evaluator, Object... values)
      * starting value for the animation (unlike ObjectAnimator, which can derive that value
      * from the target object and property being animated). Therefore, there should typically
      * be two or more values.
-     *
+     * <p/>
      * <p>If there are already multiple sets of values defined for this ValueAnimator via more
      * than one PropertyValuesHolder object, this method will set the values for the first
      * of those objects.</p>
      *
      * @param values A set of values that the animation will animate between over time.
      */
-    public void setIntValues(int... values) {
-        if (values == null || values.length == 0) {
+    public void setIntValues(int... values)
+    {
+        if (values == null || values.length == 0)
+        {
             return;
         }
-        if (mValues == null || mValues.length == 0) {
+        if (mValues == null || mValues.length == 0)
+        {
             setValues(new PropertyValuesHolder[]{PropertyValuesHolder.ofInt("", values)});
-        } else {
+        }
+        else
+        {
             PropertyValuesHolder valuesHolder = mValues[0];
             valuesHolder.setIntValues(values);
         }
@@ -390,20 +435,25 @@ public void setIntValues(int... values) {
      * starting value for the animation (unlike ObjectAnimator, which can derive that value
      * from the target object and property being animated). Therefore, there should typically
      * be two or more values.
-     *
+     * <p/>
      * <p>If there are already multiple sets of values defined for this ValueAnimator via more
      * than one PropertyValuesHolder object, this method will set the values for the first
      * of those objects.</p>
      *
      * @param values A set of values that the animation will animate between over time.
      */
-    public void setFloatValues(float... values) {
-        if (values == null || values.length == 0) {
+    public void setFloatValues(float... values)
+    {
+        if (values == null || values.length == 0)
+        {
             return;
         }
-        if (mValues == null || mValues.length == 0) {
+        if (mValues == null || mValues.length == 0)
+        {
             setValues(new PropertyValuesHolder[]{PropertyValuesHolder.ofFloat("", values)});
-        } else {
+        }
+        else
+        {
             PropertyValuesHolder valuesHolder = mValues[0];
             valuesHolder.setFloatValues(values);
         }
@@ -418,25 +468,30 @@ public void setFloatValues(float... values) {
      * starting value for the animation (unlike ObjectAnimator, which can derive that value
      * from the target object and property being animated). Therefore, there should typically
      * be two or more values.
-     *
+     * <p/>
      * <p>If there are already multiple sets of values defined for this ValueAnimator via more
      * than one PropertyValuesHolder object, this method will set the values for the first
      * of those objects.</p>
-     *
+     * <p/>
      * <p>There should be a TypeEvaluator set on the ValueAnimator that knows how to interpolate
      * between these value objects. ValueAnimator only knows how to interpolate between the
      * primitive types specified in the other setValues() methods.</p>
      *
      * @param values The set of values to animate between.
      */
-    public void setObjectValues(Object... values) {
-        if (values == null || values.length == 0) {
+    public void setObjectValues(Object... values)
+    {
+        if (values == null || values.length == 0)
+        {
             return;
         }
-        if (mValues == null || mValues.length == 0) {
+        if (mValues == null || mValues.length == 0)
+        {
             setValues(new PropertyValuesHolder[]{PropertyValuesHolder.ofObject("",
-                    (TypeEvaluator)null, values)});
-        } else {
+                                                                               (TypeEvaluator) null, values)});
+        }
+        else
+        {
             PropertyValuesHolder valuesHolder = mValues[0];
             valuesHolder.setObjectValues(values);
         }
@@ -444,6 +499,19 @@ public void setObjectValues(Object... values) {
         mInitialized = false;
     }
 
+    /**
+     * Returns the values that this ValueAnimator animates between. These values are stored in
+     * PropertyValuesHolder objects, even if the ValueAnimator was created with a simple list
+     * of value objects instead.
+     *
+     * @return PropertyValuesHolder[] An array of PropertyValuesHolder objects which hold the
+     * values, per property, that define the animation.
+     */
+    public PropertyValuesHolder[] getValues()
+    {
+        return mValues;
+    }
+
     /**
      * Sets the values, per property, being animated between. This function is called internally
      * by the constructors of ValueAnimator that take a list of values. But an ValueAnimator can
@@ -452,11 +520,13 @@ public void setObjectValues(Object... values) {
      *
      * @param values The set of values, per property, being animated between.
      */
-    public void setValues(PropertyValuesHolder... values) {
+    public void setValues(PropertyValuesHolder... values)
+    {
         int numValues = values.length;
         mValues = values;
         mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
-        for (int i = 0; i < numValues; ++i) {
+        for (int i = 0; i < numValues; ++i)
+        {
             PropertyValuesHolder valuesHolder = (PropertyValuesHolder) values[i];
             mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);
         }
@@ -464,268 +534,118 @@ public void setValues(PropertyValuesHolder... values) {
         mInitialized = false;
     }
 
-    /**
-     * Returns the values that this ValueAnimator animates between. These values are stored in
-     * PropertyValuesHolder objects, even if the ValueAnimator was created with a simple list
-     * of value objects instead.
-     *
-     * @return PropertyValuesHolder[] An array of PropertyValuesHolder objects which hold the
-     * values, per property, that define the animation.
-     */
-    public PropertyValuesHolder[] getValues() {
-        return mValues;
-    }
-
     /**
      * This function is called immediately before processing the first animation
      * frame of an animation. If there is a nonzero <code>startDelay</code>, the
      * function is called after that delay ends.
      * It takes care of the final initialization steps for the
      * animation.
-     *
-     *  <p>Overrides of this method should call the superclass method to ensure
-     *  that internal mechanisms for the animation are set up correctly.</p>
-     */
-    void initAnimation() {
-        if (!mInitialized) {
+     * <p/>
+     * <p>Overrides of this method should call the superclass method to ensure
+     * that internal mechanisms for the animation are set up correctly.</p>
+     */
+    void initAnimation()
+    {
+        if (!mInitialized)
+        {
             int numValues = mValues.length;
-            for (int i = 0; i < numValues; ++i) {
-                mValues[i].init();
-            }
-            mInitialized = true;
-        }
-    }
-
-
-    /**
-     * Sets the length of the animation. The default duration is 300 milliseconds.
-     *
-     * @param duration The length of the animation, in milliseconds. This value cannot
-     * be negative.
-     * @return ValueAnimator The object called with setDuration(). This return
-     * value makes it easier to compose statements together that construct and then set the
-     * duration, as in <code>ValueAnimator.ofInt(0, 10).setDuration(500).start()</code>.
-     */
-    public ValueAnimator setDuration(long duration) {
-        if (duration < 0) {
-            throw new IllegalArgumentException("Animators cannot have negative duration: " +
-                    duration);
-        }
-        mDuration = duration;
-        return this;
-    }
-
-    /**
-     * Gets the length of the animation. The default duration is 300 milliseconds.
-     *
-     * @return The length of the animation, in milliseconds.
-     */
-    public long getDuration() {
-        return mDuration;
-    }
-
-    /**
-     * Sets the position of the animation to the specified point in time. This time should
-     * be between 0 and the total duration of the animation, including any repetition. If
-     * the animation has not yet been started, then it will not advance forward after it is
-     * set to this time; it will simply set the time to this value and perform any appropriate
-     * actions based on that time. If the animation is already running, then setCurrentPlayTime()
-     * will set the current playing time to this value and continue playing from that point.
-     *
-     * @param playTime The time, in milliseconds, to which the animation is advanced or rewound.
-     */
-    public void setCurrentPlayTime(long playTime) {
-        initAnimation();
-        long currentTime = AnimationUtils.currentAnimationTimeMillis();
-        if (mPlayingState != RUNNING) {
-            mSeekTime = playTime;
-            mPlayingState = SEEKED;
-        }
-        mStartTime = currentTime - playTime;
-        animationFrame(currentTime);
-    }
-
-    /**
-     * Gets the current position of the animation in time, which is equal to the current
-     * time minus the time that the animation started. An animation that is not yet started will
-     * return a value of zero.
-     *
-     * @return The current position in time of the animation.
-     */
-    public long getCurrentPlayTime() {
-        if (!mInitialized || mPlayingState == STOPPED) {
-            return 0;
-        }
-        return AnimationUtils.currentAnimationTimeMillis() - mStartTime;
-    }
-
-    /**
-     * This custom, static handler handles the timing pulse that is shared by
-     * all active animations. This approach ensures that the setting of animation
-     * values will happen on the UI thread and that all animations will share
-     * the same times for calculating their values, which makes synchronizing
-     * animations possible.
-     *
-     */
-    private static class AnimationHandler extends Handler {
-        /**
-         * There are only two messages that we care about: ANIMATION_START and
-         * ANIMATION_FRAME. The START message is sent when an animation's start()
-         * method is called. It cannot start synchronously when start() is called
-         * because the call may be on the wrong thread, and it would also not be
-         * synchronized with other animations because it would not start on a common
-         * timing pulse. So each animation sends a START message to the handler, which
-         * causes the handler to place the animation on the active animations queue and
-         * start processing frames for that animation.
-         * The FRAME message is the one that is sent over and over while there are any
-         * active animations to process.
-         */
-        @Override
-        public void handleMessage(Message msg) {
-            boolean callAgain = true;
-            ArrayList<ValueAnimator> animations = sAnimations.get();
-            ArrayList<ValueAnimator> delayedAnims = sDelayedAnims.get();
-            switch (msg.what) {
-                // TODO: should we avoid sending frame message when starting if we
-                // were already running?
-                case ANIMATION_START:
-                    ArrayList<ValueAnimator> pendingAnimations = sPendingAnimations.get();
-                    if (animations.size() > 0 || delayedAnims.size() > 0) {
-                        callAgain = false;
-                    }
-                    // pendingAnims holds any animations that have requested to be started
-                    // We're going to clear sPendingAnimations, but starting animation may
-                    // cause more to be added to the pending list (for example, if one animation
-                    // starting triggers another starting). So we loop until sPendingAnimations
-                    // is empty.
-                    while (pendingAnimations.size() > 0) {
-                        ArrayList<ValueAnimator> pendingCopy =
-                                (ArrayList<ValueAnimator>) pendingAnimations.clone();
-                        pendingAnimations.clear();
-                        int count = pendingCopy.size();
-                        for (int i = 0; i < count; ++i) {
-                            ValueAnimator anim = pendingCopy.get(i);
-                            // If the animation has a startDelay, place it on the delayed list
-                            if (anim.mStartDelay == 0) {
-                                anim.startAnimation();
-                            } else {
-                                delayedAnims.add(anim);
-                            }
-                        }
-                    }
-                    // fall through to process first frame of new animations
-                case ANIMATION_FRAME:
-                    // currentTime holds the common time for all animations processed
-                    // during this frame
-                    long currentTime = AnimationUtils.currentAnimationTimeMillis();
-                    ArrayList<ValueAnimator> readyAnims = sReadyAnims.get();
-                    ArrayList<ValueAnimator> endingAnims = sEndingAnims.get();
-
-                    // First, process animations currently sitting on the delayed queue, adding
-                    // them to the active animations if they are ready
-                    int numDelayedAnims = delayedAnims.size();
-                    for (int i = 0; i < numDelayedAnims; ++i) {
-                        ValueAnimator anim = delayedAnims.get(i);
-                        if (anim.delayedAnimationFrame(currentTime)) {
-                            readyAnims.add(anim);
-                        }
-                    }
-                    int numReadyAnims = readyAnims.size();
-                    if (numReadyAnims > 0) {
-                        for (int i = 0; i < numReadyAnims; ++i) {
-                            ValueAnimator anim = readyAnims.get(i);
-                            anim.startAnimation();
-                            anim.mRunning = true;
-                            delayedAnims.remove(anim);
-                        }
-                        readyAnims.clear();
-                    }
-
-                    // Now process all active animations. The return value from animationFrame()
-                    // tells the handler whether it should now be ended
-                    int numAnims = animations.size();
-                    int i = 0;
-                    while (i < numAnims) {
-                        ValueAnimator anim = animations.get(i);
-                        if (anim.animationFrame(currentTime)) {
-                            endingAnims.add(anim);
-                        }
-                        if (animations.size() == numAnims) {
-                            ++i;
-                        } else {
-                            // An animation might be canceled or ended by client code
-                            // during the animation frame. Check to see if this happened by
-                            // seeing whether the current index is the same as it was before
-                            // calling animationFrame(). Another approach would be to copy
-                            // animations to a temporary list and process that list instead,
-                            // but that entails garbage and processing overhead that would
-                            // be nice to avoid.
-                            --numAnims;
-                            endingAnims.remove(anim);
-                        }
-                    }
-                    if (endingAnims.size() > 0) {
-                        for (i = 0; i < endingAnims.size(); ++i) {
-                            endingAnims.get(i).endAnimation();
-                        }
-                        endingAnims.clear();
-                    }
-
-                    // If there are still active or delayed animations, call the handler again
-                    // after the frameDelay
-                    if (callAgain && (!animations.isEmpty() || !delayedAnims.isEmpty())) {
-                        sendEmptyMessageDelayed(ANIMATION_FRAME, Math.max(0, sFrameDelay -
-                            (AnimationUtils.currentAnimationTimeMillis() - currentTime)));
-                    }
-                    break;
+            for (int i = 0; i < numValues; ++i)
+            {
+                mValues[i].init();
             }
+            mInitialized = true;
         }
     }
 
     /**
-     * The amount of time, in milliseconds, to delay starting the animation after
-     * {@link #start()} is called.
+     * Gets the length of the animation. The default duration is 300 milliseconds.
      *
-     * @return the number of milliseconds to delay running the animation
+     * @return The length of the animation, in milliseconds.
      */
-    public long getStartDelay() {
-        return mStartDelay;
+    public long getDuration()
+    {
+        return mDuration;
     }
 
     /**
-     * The amount of time, in milliseconds, to delay starting the animation after
-     * {@link #start()} is called.
+     * Sets the length of the animation. The default duration is 300 milliseconds.
+     *
+     * @param duration The length of the animation, in milliseconds. This value cannot
+     *                 be negative.
+     * @return ValueAnimator The object called with setDuration(). This return
+     * value makes it easier to compose statements together that construct and then set the
+     * duration, as in <code>ValueAnimator.ofInt(0, 10).setDuration(500).start()</code>.
+     */
+    public ValueAnimator setDuration(long duration)
+    {
+        if (duration < 0)
+        {
+            throw new IllegalArgumentException("Animators cannot have negative duration: " +
+                                                       duration);
+        }
+        mDuration = duration;
+        return this;
+    }
 
-     * @param startDelay The amount of the delay, in milliseconds
+    /**
+     * Gets the current position of the animation in time, which is equal to the current
+     * time minus the time that the animation started. An animation that is not yet started will
+     * return a value of zero.
+     *
+     * @return The current position in time of the animation.
      */
-    public void setStartDelay(long startDelay) {
-        this.mStartDelay = startDelay;
+    public long getCurrentPlayTime()
+    {
+        if (!mInitialized || mPlayingState == STOPPED)
+        {
+            return 0;
+        }
+        return AnimationUtils.currentAnimationTimeMillis() - mStartTime;
     }
 
     /**
-     * The amount of time, in milliseconds, between each frame of the animation. This is a
-     * requested time that the animation will attempt to honor, but the actual delay between
-     * frames may be different, depending on system load and capabilities. This is a static
-     * function because the same delay will be applied to all animations, since they are all
-     * run off of a single timing loop.
+     * Sets the position of the animation to the specified point in time. This time should
+     * be between 0 and the total duration of the animation, including any repetition. If
+     * the animation has not yet been started, then it will not advance forward after it is
+     * set to this time; it will simply set the time to this value and perform any appropriate
+     * actions based on that time. If the animation is already running, then setCurrentPlayTime()
+     * will set the current playing time to this value and continue playing from that point.
      *
-     * @return the requested time between frames, in milliseconds
+     * @param playTime The time, in milliseconds, to which the animation is advanced or rewound.
      */
-    public static long getFrameDelay() {
-        return sFrameDelay;
+    public void setCurrentPlayTime(long playTime)
+    {
+        initAnimation();
+        long currentTime = AnimationUtils.currentAnimationTimeMillis();
+        if (mPlayingState != RUNNING)
+        {
+            mSeekTime = playTime;
+            mPlayingState = SEEKED;
+        }
+        mStartTime = currentTime - playTime;
+        animationFrame(currentTime);
     }
 
     /**
-     * The amount of time, in milliseconds, between each frame of the animation. This is a
-     * requested time that the animation will attempt to honor, but the actual delay between
-     * frames may be different, depending on system load and capabilities. This is a static
-     * function because the same delay will be applied to all animations, since they are all
-     * run off of a single timing loop.
+     * The amount of time, in milliseconds, to delay starting the animation after
+     * {@link #start()} is called.
      *
-     * @param frameDelay the requested time between frames, in milliseconds
+     * @return the number of milliseconds to delay running the animation
      */
-    public static void setFrameDelay(long frameDelay) {
-        sFrameDelay = frameDelay;
+    public long getStartDelay()
+    {
+        return mStartDelay;
+    }
+
+    /**
+     * The amount of time, in milliseconds, to delay starting the animation after
+     * {@link #start()} is called.
+     *
+     * @param startDelay The amount of the delay, in milliseconds
+     */
+    public void setStartDelay(long startDelay)
+    {
+        this.mStartDelay = startDelay;
     }
 
     /**
@@ -740,8 +660,10 @@ public static void setFrameDelay(long frameDelay) {
      * (specified by several PropertyValuesHolder objects in the constructor), this function
      * returns the animated value for the first of those objects.
      */
-    public Object getAnimatedValue() {
-        if (mValues != null && mValues.length > 0) {
+    public Object getAnimatedValue()
+    {
+        if (mValues != null && mValues.length > 0)
+        {
             return mValues[0].getAnimatedValue();
         }
         // Shouldn't get here; should always have values unless ValueAnimator was set up wrong
@@ -758,16 +680,31 @@ public Object getAnimatedValue() {
      * @return animatedValue The value most recently calculated for the named property
      * by this <code>ValueAnimator</code>.
      */
-    public Object getAnimatedValue(String propertyName) {
+    public Object getAnimatedValue(String propertyName)
+    {
         PropertyValuesHolder valuesHolder = mValuesMap.get(propertyName);
-        if (valuesHolder != null) {
+        if (valuesHolder != null)
+        {
             return valuesHolder.getAnimatedValue();
-        } else {
+        }
+        else
+        {
             // At least avoid crashing if called with bogus propertyName
             return null;
         }
     }
 
+    /**
+     * Defines how many times the animation should repeat. The default value
+     * is 0.
+     *
+     * @return the number of times the animation should repeat, or {@link #INFINITE}
+     */
+    public int getRepeatCount()
+    {
+        return mRepeatCount;
+    }
+
     /**
      * Sets how many times the animation should be repeated. If the repeat
      * count is 0, the animation is never repeated. If the repeat count is
@@ -776,17 +713,19 @@ public Object getAnimatedValue(String propertyName) {
      *
      * @param value the number of times the animation should be repeated
      */
-    public void setRepeatCount(int value) {
+    public void setRepeatCount(int value)
+    {
         mRepeatCount = value;
     }
+
     /**
-     * Defines how many times the animation should repeat. The default value
-     * is 0.
+     * Defines what this animation should do when it reaches the end.
      *
-     * @return the number of times the animation should repeat, or {@link #INFINITE}
+     * @return either one of {@link #REVERSE} or {@link #RESTART}
      */
-    public int getRepeatCount() {
-        return mRepeatCount;
+    public int getRepeatMode()
+    {
+        return mRepeatMode;
     }
 
     /**
@@ -796,19 +735,11 @@ public int getRepeatCount() {
      *
      * @param value {@link #RESTART} or {@link #REVERSE}
      */
-    public void setRepeatMode(int value) {
+    public void setRepeatMode(int value)
+    {
         mRepeatMode = value;
     }
 
-    /**
-     * Defines what this animation should do when it reaches the end.
-     *
-     * @return either one of {@link #REVERSE} or {@link #RESTART}
-     */
-    public int getRepeatMode() {
-        return mRepeatMode;
-    }
-
     /**
      * Adds a listener to the set of listeners that are sent update events through the life of
      * an animation. This method is called on all listeners for every frame of the animation,
@@ -816,8 +747,10 @@ public int getRepeatMode() {
      *
      * @param listener the listener to be added to the current set of listeners for this animation.
      */
-    public void addUpdateListener(AnimatorUpdateListener listener) {
-        if (mUpdateListeners == null) {
+    public void addUpdateListener(AnimatorUpdateListener listener)
+    {
+        if (mUpdateListeners == null)
+        {
             mUpdateListeners = new ArrayList<AnimatorUpdateListener>();
         }
         mUpdateListeners.add(listener);
@@ -826,8 +759,10 @@ public void addUpdateListener(AnimatorUpdateListener listener) {
     /**
      * Removes all listeners from the set listening to frame updates for this animation.
      */
-    public void removeAllUpdateListeners() {
-        if (mUpdateListeners == null) {
+    public void removeAllUpdateListeners()
+    {
+        if (mUpdateListeners == null)
+        {
             return;
         }
         mUpdateListeners.clear();
@@ -838,18 +773,30 @@ public void removeAllUpdateListeners() {
      * Removes a listener from the set listening to frame updates for this animation.
      *
      * @param listener the listener to be removed from the current set of update listeners
-     * for this animation.
+     *                 for this animation.
      */
-    public void removeUpdateListener(AnimatorUpdateListener listener) {
-        if (mUpdateListeners == null) {
+    public void removeUpdateListener(AnimatorUpdateListener listener)
+    {
+        if (mUpdateListeners == null)
+        {
             return;
         }
         mUpdateListeners.remove(listener);
-        if (mUpdateListeners.size() == 0) {
+        if (mUpdateListeners.size() == 0)
+        {
             mUpdateListeners = null;
         }
     }
 
+    /**
+     * Returns the timing interpolator that this ValueAnimator uses.
+     *
+     * @return The timing interpolator for this ValueAnimator.
+     */
+    public /*Time*/Interpolator getInterpolator()
+    {
+        return mInterpolator;
+    }
 
     /**
      * The time interpolator used in calculating the elapsed fraction of this animation. The
@@ -858,26 +805,21 @@ public void removeUpdateListener(AnimatorUpdateListener listener) {
      * {@link android.view.animation.AccelerateDecelerateInterpolator}
      *
      * @param value the interpolator to be used by this animation. A value of <code>null</code>
-     * will result in linear interpolation.
+     *              will result in linear interpolation.
      */
     @Override
-    public void setInterpolator(/*Time*/Interpolator value) {
-        if (value != null) {
+    public void setInterpolator(/*Time*/Interpolator value)
+    {
+        if (value != null)
+        {
             mInterpolator = value;
-        } else {
+        }
+        else
+        {
             mInterpolator = new LinearInterpolator();
         }
     }
 
-    /**
-     * Returns the timing interpolator that this ValueAnimator uses.
-     *
-     * @return The timing interpolator for this ValueAnimator.
-     */
-    public /*Time*/Interpolator getInterpolator() {
-        return mInterpolator;
-    }
-
     /**
      * The type evaluator to be used when calculating the animated values of this animation.
      * The system will automatically assign a float or int evaluator based on the type
@@ -886,7 +828,7 @@ public void setInterpolator(/*Time*/Interpolator value) {
      * necessary with int values that represent colors), a custom evaluator needs to be assigned.
      * For example, when running an animation on color values, the {@link ArgbEvaluator}
      * should be used to get correct RGB color interpolation.
-     *
+     * <p/>
      * <p>If this ValueAnimator has only one set of values being animated between, this evaluator
      * will be used for that set. If there are several sets of values being animated, which is
      * the case if PropertyValuesHOlder objects were set on the ValueAnimator, then the evaluator
@@ -894,8 +836,10 @@ public void setInterpolator(/*Time*/Interpolator value) {
      *
      * @param value the evaluator to be used this animation
      */
-    public void setEvaluator(TypeEvaluator value) {
-        if (value != null && mValues != null && mValues.length > 0) {
+    public void setEvaluator(TypeEvaluator value)
+    {
+        if (value != null && mValues != null && mValues.length > 0)
+        {
             mValues[0].setEvaluator(value);
         }
     }
@@ -904,7 +848,7 @@ public void setEvaluator(TypeEvaluator value) {
      * Start the animation playing. This version of start() takes a boolean flag that indicates
      * whether the animation should play in reverse. The flag is usually false, but may be set
      * to true if called from the reverse() method.
-     *
+     * <p/>
      * <p>The animation started by calling this method will be run on the thread that called
      * this method. This thread should have a Looper on it (a runtime exception will be thrown if
      * this is not the case). Also, if the animation will animate
@@ -913,8 +857,10 @@ public void setEvaluator(TypeEvaluator value) {
      *
      * @param playBackwards Whether the ValueAnimator should start playing in reverse.
      */
-    private void start(boolean playBackwards) {
-        if (Looper.myLooper() == null) {
+    private void start(boolean playBackwards)
+    {
+        if (Looper.myLooper() == null)
+        {
             throw new AndroidRuntimeException("Animators may only be run on Looper threads");
         }
         mPlayingBackwards = playBackwards;
@@ -923,23 +869,27 @@ private void start(boolean playBackwards) {
         mStarted = true;
         mStartedDelay = false;
         sPendingAnimations.get().add(this);
-        if (mStartDelay == 0) {
+        if (mStartDelay == 0)
+        {
             // This sets the initial value of the animation, prior to actually starting it running
             setCurrentPlayTime(getCurrentPlayTime());
             mPlayingState = STOPPED;
             mRunning = true;
 
-            if (mListeners != null) {
+            if (mListeners != null)
+            {
                 ArrayList<AnimatorListener> tmpListeners =
                         (ArrayList<AnimatorListener>) mListeners.clone();
                 int numListeners = tmpListeners.size();
-                for (int i = 0; i < numListeners; ++i) {
+                for (int i = 0; i < numListeners; ++i)
+                {
                     tmpListeners.get(i).onAnimationStart(this);
                 }
             }
         }
         AnimationHandler animationHandler = sAnimationHandler.get();
-        if (animationHandler == null) {
+        if (animationHandler == null)
+        {
             animationHandler = new AnimationHandler();
             sAnimationHandler.set(animationHandler);
         }
@@ -947,21 +897,26 @@ private void start(boolean playBackwards) {
     }
 
     @Override
-    public void start() {
+    public void start()
+    {
         start(false);
     }
 
     @Override
-    public void cancel() {
+    public void cancel()
+    {
         // Only cancel if the animation is actually running or has been started and is about
         // to run
         if (mPlayingState != STOPPED || sPendingAnimations.get().contains(this) ||
-                sDelayedAnims.get().contains(this)) {
+                sDelayedAnims.get().contains(this))
+        {
             // Only notify listeners if the animator has actually started
-            if (mRunning && mListeners != null) {
+            if (mRunning && mListeners != null)
+            {
                 ArrayList<AnimatorListener> tmpListeners =
                         (ArrayList<AnimatorListener>) mListeners.clone();
-                for (AnimatorListener listener : tmpListeners) {
+                for (AnimatorListener listener : tmpListeners)
+                {
                     listener.onAnimationCancel(this);
                 }
             }
@@ -970,31 +925,40 @@ public void cancel() {
     }
 
     @Override
-    public void end() {
-        if (!sAnimations.get().contains(this) && !sPendingAnimations.get().contains(this)) {
+    public void end()
+    {
+        if (!sAnimations.get().contains(this) && !sPendingAnimations.get().contains(this))
+        {
             // Special case if the animation has not yet started; get it ready for ending
             mStartedDelay = false;
             startAnimation();
-        } else if (!mInitialized) {
+        }
+        else if (!mInitialized)
+        {
             initAnimation();
         }
         // The final value set on the target varies, depending on whether the animation
         // was supposed to repeat an odd number of times
-        if (mRepeatCount > 0 && (mRepeatCount & 0x01) == 1) {
+        if (mRepeatCount > 0 && (mRepeatCount & 0x01) == 1)
+        {
             animateValue(0f);
-        } else {
+        }
+        else
+        {
             animateValue(1f);
         }
         endAnimation();
     }
 
     @Override
-    public boolean isRunning() {
+    public boolean isRunning()
+    {
         return (mPlayingState == RUNNING || mRunning);
     }
 
     @Override
-    public boolean isStarted() {
+    public boolean isStarted()
+    {
         return mStarted;
     }
 
@@ -1005,14 +969,18 @@ public boolean isStarted() {
      * play backwards. This behavior is only set for the current animation; future playing
      * of the animation will use the default behavior of playing forward.
      */
-    public void reverse() {
+    public void reverse()
+    {
         mPlayingBackwards = !mPlayingBackwards;
-        if (mPlayingState == RUNNING) {
+        if (mPlayingState == RUNNING)
+        {
             long currentTime = AnimationUtils.currentAnimationTimeMillis();
             long currentPlayTime = currentTime - mStartTime;
             long timeLeft = mDuration - currentPlayTime;
             mStartTime = currentTime - timeLeft;
-        } else {
+        }
+        else
+        {
             start(true);
         }
     }
@@ -1021,16 +989,19 @@ public void reverse() {
      * Called internally to end an animation by removing it from the animations list. Must be
      * called on the UI thread.
      */
-    private void endAnimation() {
+    private void endAnimation()
+    {
         sAnimations.get().remove(this);
         sPendingAnimations.get().remove(this);
         sDelayedAnims.get().remove(this);
         mPlayingState = STOPPED;
-        if (mRunning && mListeners != null) {
+        if (mRunning && mListeners != null)
+        {
             ArrayList<AnimatorListener> tmpListeners =
                     (ArrayList<AnimatorListener>) mListeners.clone();
             int numListeners = tmpListeners.size();
-            for (int i = 0; i < numListeners; ++i) {
+            for (int i = 0; i < numListeners; ++i)
+            {
                 tmpListeners.get(i).onAnimationEnd(this);
             }
         }
@@ -1042,16 +1013,19 @@ private void endAnimation() {
      * Called internally to start an animation by adding it to the active animations list. Must be
      * called on the UI thread.
      */
-    private void startAnimation() {
+    private void startAnimation()
+    {
         initAnimation();
         sAnimations.get().add(this);
-        if (mStartDelay > 0 && mListeners != null) {
+        if (mStartDelay > 0 && mListeners != null)
+        {
             // Listeners were already notified in start() if startDelay is 0; this is
             // just for delayed animations
             ArrayList<AnimatorListener> tmpListeners =
                     (ArrayList<AnimatorListener>) mListeners.clone();
             int numListeners = tmpListeners.size();
-            for (int i = 0; i < numListeners; ++i) {
+            for (int i = 0; i < numListeners; ++i)
+            {
                 tmpListeners.get(i).onAnimationStart(this);
             }
         }
@@ -1063,17 +1037,22 @@ private void startAnimation() {
      * should be woken up and put on the active animations queue.
      *
      * @param currentTime The current animation time, used to calculate whether the animation
-     * has exceeded its <code>startDelay</code> and should be started.
+     *                    has exceeded its <code>startDelay</code> and should be started.
      * @return True if the animation's <code>startDelay</code> has been exceeded and the animation
      * should be added to the set of active animations.
      */
-    private boolean delayedAnimationFrame(long currentTime) {
-        if (!mStartedDelay) {
+    private boolean delayedAnimationFrame(long currentTime)
+    {
+        if (!mStartedDelay)
+        {
             mStartedDelay = true;
             mDelayStartTime = currentTime;
-        } else {
+        }
+        else
+        {
             long deltaTime = currentTime - mDelayStartTime;
-            if (deltaTime > mStartDelay) {
+            if (deltaTime > mStartDelay)
+            {
                 // startDelay ended - start the anim and record the
                 // mStartTime appropriately
                 mStartTime = currentTime - (deltaTime - mStartDelay);
@@ -1096,48 +1075,62 @@ private boolean delayedAnimationFrame(long currentTime) {
      * @return true if the animation's duration, including any repetitions due to
      * <code>repeatCount</code> has been exceeded and the animation should be ended.
      */
-    boolean animationFrame(long currentTime) {
+    boolean animationFrame(long currentTime)
+    {
         boolean done = false;
 
-        if (mPlayingState == STOPPED) {
+        if (mPlayingState == STOPPED)
+        {
             mPlayingState = RUNNING;
-            if (mSeekTime < 0) {
+            if (mSeekTime < 0)
+            {
                 mStartTime = currentTime;
-            } else {
+            }
+            else
+            {
                 mStartTime = currentTime - mSeekTime;
                 // Now that we're playing, reset the seek time
                 mSeekTime = -1;
             }
         }
-        switch (mPlayingState) {
-        case RUNNING:
-        case SEEKED:
-            float fraction = mDuration > 0 ? (float)(currentTime - mStartTime) / mDuration : 1f;
-            if (fraction >= 1f) {
-                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {
-                    // Time to repeat
-                    if (mListeners != null) {
-                        int numListeners = mListeners.size();
-                        for (int i = 0; i < numListeners; ++i) {
-                            mListeners.get(i).onAnimationRepeat(this);
+        switch (mPlayingState)
+        {
+            case RUNNING:
+            case SEEKED:
+                float fraction = mDuration > 0 ? (float) (currentTime - mStartTime) / mDuration : 1f;
+                if (fraction >= 1f)
+                {
+                    if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE)
+                    {
+                        // Time to repeat
+                        if (mListeners != null)
+                        {
+                            int numListeners = mListeners.size();
+                            for (int i = 0; i < numListeners; ++i)
+                            {
+                                mListeners.get(i).onAnimationRepeat(this);
+                            }
+                        }
+                        if (mRepeatMode == REVERSE)
+                        {
+                            mPlayingBackwards = mPlayingBackwards ? false : true;
                         }
+                        mCurrentIteration += (int) fraction;
+                        fraction = fraction % 1f;
+                        mStartTime += mDuration;
                     }
-                    if (mRepeatMode == REVERSE) {
-                        mPlayingBackwards = mPlayingBackwards ? false : true;
+                    else
+                    {
+                        done = true;
+                        fraction = Math.min(fraction, 1.0f);
                     }
-                    mCurrentIteration += (int)fraction;
-                    fraction = fraction % 1f;
-                    mStartTime += mDuration;
-                } else {
-                    done = true;
-                    fraction = Math.min(fraction, 1.0f);
                 }
-            }
-            if (mPlayingBackwards) {
-                fraction = 1f - fraction;
-            }
-            animateValue(fraction);
-            break;
+                if (mPlayingBackwards)
+                {
+                    fraction = 1f - fraction;
+                }
+                animateValue(fraction);
+                break;
         }
 
         return done;
@@ -1149,7 +1142,8 @@ boolean animationFrame(long currentTime) {
      *
      * @return Elapsed/interpolated fraction of the animation.
      */
-    public float getAnimatedFraction() {
+    public float getAnimatedFraction()
+    {
         return mCurrentFraction;
     }
 
@@ -1159,35 +1153,42 @@ public float getAnimatedFraction() {
      * and then into an animated value (from the evaluator. The function is called mostly during
      * animation updates, but it is also called when the <code>end()</code>
      * function is called, to set the final value on the property.
-     *
+     * <p/>
      * <p>Overrides of this method must call the superclass to perform the calculation
      * of the animated value.</p>
      *
      * @param fraction The elapsed fraction of the animation.
      */
-    void animateValue(float fraction) {
+    void animateValue(float fraction)
+    {
         fraction = mInterpolator.getInterpolation(fraction);
         mCurrentFraction = fraction;
         int numValues = mValues.length;
-        for (int i = 0; i < numValues; ++i) {
+        for (int i = 0; i < numValues; ++i)
+        {
             mValues[i].calculateValue(fraction);
         }
-        if (mUpdateListeners != null) {
+        if (mUpdateListeners != null)
+        {
             int numListeners = mUpdateListeners.size();
-            for (int i = 0; i < numListeners; ++i) {
+            for (int i = 0; i < numListeners; ++i)
+            {
                 mUpdateListeners.get(i).onAnimationUpdate(this);
             }
         }
     }
 
     @Override
-    public ValueAnimator clone() {
+    public ValueAnimator clone()
+    {
         final ValueAnimator anim = (ValueAnimator) super.clone();
-        if (mUpdateListeners != null) {
+        if (mUpdateListeners != null)
+        {
             ArrayList<AnimatorUpdateListener> oldListeners = mUpdateListeners;
             anim.mUpdateListeners = new ArrayList<AnimatorUpdateListener>();
             int numListeners = oldListeners.size();
-            for (int i = 0; i < numListeners; ++i) {
+            for (int i = 0; i < numListeners; ++i)
+            {
                 anim.mUpdateListeners.add(oldListeners.get(i));
             }
         }
@@ -1198,11 +1199,13 @@ public ValueAnimator clone() {
         anim.mPlayingState = STOPPED;
         anim.mStartedDelay = false;
         PropertyValuesHolder[] oldValues = mValues;
-        if (oldValues != null) {
+        if (oldValues != null)
+        {
             int numValues = oldValues.length;
             anim.mValues = new PropertyValuesHolder[numValues];
             anim.mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
-            for (int i = 0; i < numValues; ++i) {
+            for (int i = 0; i < numValues; ++i)
+            {
                 PropertyValuesHolder newValuesHolder = oldValues[i].clone();
                 anim.mValues[i] = newValuesHolder;
                 anim.mValuesMap.put(newValuesHolder.getPropertyName(), newValuesHolder);
@@ -1211,13 +1214,28 @@ public ValueAnimator clone() {
         return anim;
     }
 
+    @Override
+    public String toString()
+    {
+        String returnVal = "ValueAnimator@" + Integer.toHexString(hashCode());
+        if (mValues != null)
+        {
+            for (int i = 0; i < mValues.length; ++i)
+            {
+                returnVal += "\n    " + mValues[i].toString();
+            }
+        }
+        return returnVal;
+    }
+
     /**
      * Implementors of this interface can add themselves as update listeners
      * to an <code>ValueAnimator</code> instance to receive callbacks on every animation
      * frame, after the current frame's values have been calculated for that
      * <code>ValueAnimator</code>.
      */
-    public static interface AnimatorUpdateListener {
+    public static interface AnimatorUpdateListener
+    {
         /**
          * <p>Notifies the occurrence of another frame of the animation.</p>
          *
@@ -1228,37 +1246,145 @@ public ValueAnimator clone() {
     }
 
     /**
-     * Return the number of animations currently running.
-     *
-     * Used by StrictMode internally to annotate violations.  Only
-     * called on the main thread.
-     *
-     * @hide
+     * This custom, static handler handles the timing pulse that is shared by
+     * all active animations. This approach ensures that the setting of animation
+     * values will happen on the UI thread and that all animations will share
+     * the same times for calculating their values, which makes synchronizing
+     * animations possible.
      */
-    public static int getCurrentAnimationsCount() {
-        return sAnimations.get().size();
-    }
+    private static class AnimationHandler extends Handler
+    {
+        /**
+         * There are only two messages that we care about: ANIMATION_START and
+         * ANIMATION_FRAME. The START message is sent when an animation's start()
+         * method is called. It cannot start synchronously when start() is called
+         * because the call may be on the wrong thread, and it would also not be
+         * synchronized with other animations because it would not start on a common
+         * timing pulse. So each animation sends a START message to the handler, which
+         * causes the handler to place the animation on the active animations queue and
+         * start processing frames for that animation.
+         * The FRAME message is the one that is sent over and over while there are any
+         * active animations to process.
+         */
+        @Override
+        public void handleMessage(Message msg)
+        {
+            boolean callAgain = true;
+            ArrayList<ValueAnimator> animations = sAnimations.get();
+            ArrayList<ValueAnimator> delayedAnims = sDelayedAnims.get();
+            switch (msg.what)
+            {
+                // TODO: should we avoid sending frame message when starting if we
+                // were already running?
+                case ANIMATION_START:
+                    ArrayList<ValueAnimator> pendingAnimations = sPendingAnimations.get();
+                    if (animations.size() > 0 || delayedAnims.size() > 0)
+                    {
+                        callAgain = false;
+                    }
+                    // pendingAnims holds any animations that have requested to be started
+                    // We're going to clear sPendingAnimations, but starting animation may
+                    // cause more to be added to the pending list (for example, if one animation
+                    // starting triggers another starting). So we loop until sPendingAnimations
+                    // is empty.
+                    while (pendingAnimations.size() > 0)
+                    {
+                        ArrayList<ValueAnimator> pendingCopy =
+                                (ArrayList<ValueAnimator>) pendingAnimations.clone();
+                        pendingAnimations.clear();
+                        int count = pendingCopy.size();
+                        for (int i = 0; i < count; ++i)
+                        {
+                            ValueAnimator anim = pendingCopy.get(i);
+                            // If the animation has a startDelay, place it on the delayed list
+                            if (anim.mStartDelay == 0)
+                            {
+                                anim.startAnimation();
+                            }
+                            else
+                            {
+                                delayedAnims.add(anim);
+                            }
+                        }
+                    }
+                    // fall through to process first frame of new animations
+                case ANIMATION_FRAME:
+                    // currentTime holds the common time for all animations processed
+                    // during this frame
+                    long currentTime = AnimationUtils.currentAnimationTimeMillis();
+                    ArrayList<ValueAnimator> readyAnims = sReadyAnims.get();
+                    ArrayList<ValueAnimator> endingAnims = sEndingAnims.get();
 
-    /**
-     * Clear all animations on this thread, without canceling or ending them.
-     * This should be used with caution.
-     *
-     * @hide
-     */
-    public static void clearAllAnimations() {
-        sAnimations.get().clear();
-        sPendingAnimations.get().clear();
-        sDelayedAnims.get().clear();
-    }
+                    // First, process animations currently sitting on the delayed queue, adding
+                    // them to the active animations if they are ready
+                    int numDelayedAnims = delayedAnims.size();
+                    for (int i = 0; i < numDelayedAnims; ++i)
+                    {
+                        ValueAnimator anim = delayedAnims.get(i);
+                        if (anim.delayedAnimationFrame(currentTime))
+                        {
+                            readyAnims.add(anim);
+                        }
+                    }
+                    int numReadyAnims = readyAnims.size();
+                    if (numReadyAnims > 0)
+                    {
+                        for (int i = 0; i < numReadyAnims; ++i)
+                        {
+                            ValueAnimator anim = readyAnims.get(i);
+                            anim.startAnimation();
+                            anim.mRunning = true;
+                            delayedAnims.remove(anim);
+                        }
+                        readyAnims.clear();
+                    }
 
-    @Override
-    public String toString() {
-        String returnVal = "ValueAnimator@" + Integer.toHexString(hashCode());
-        if (mValues != null) {
-            for (int i = 0; i < mValues.length; ++i) {
-                returnVal += "\n    " + mValues[i].toString();
+                    // Now process all active animations. The return value from animationFrame()
+                    // tells the handler whether it should now be ended
+                    int numAnims = animations.size();
+                    int i = 0;
+                    while (i < numAnims)
+                    {
+                        ValueAnimator anim = animations.get(i);
+                        if (anim.animationFrame(currentTime))
+                        {
+                            endingAnims.add(anim);
+                        }
+                        if (animations.size() == numAnims)
+                        {
+                            ++i;
+                        }
+                        else
+                        {
+                            // An animation might be canceled or ended by client code
+                            // during the animation frame. Check to see if this happened by
+                            // seeing whether the current index is the same as it was before
+                            // calling animationFrame(). Another approach would be to copy
+                            // animations to a temporary list and process that list instead,
+                            // but that entails garbage and processing overhead that would
+                            // be nice to avoid.
+                            --numAnims;
+                            endingAnims.remove(anim);
+                        }
+                    }
+                    if (endingAnims.size() > 0)
+                    {
+                        for (i = 0; i < endingAnims.size(); ++i)
+                        {
+                            endingAnims.get(i).endAnimation();
+                        }
+                        endingAnims.clear();
+                    }
+
+                    // If there are still active or delayed animations, call the handler again
+                    // after the frameDelay
+                    if (callAgain && (!animations.isEmpty() || !delayedAnims.isEmpty()))
+                    {
+                        sendEmptyMessageDelayed(ANIMATION_FRAME, Math.max(0, sFrameDelay -
+                                (AnimationUtils.currentAnimationTimeMillis() - currentTime)));
+                    }
+                    break;
             }
         }
-        return returnVal;
     }
 }
diff --git a/library/src/com/nineoldandroids/util/FloatProperty.java b/library/src/com/nineoldandroids/util/FloatProperty.java
index ba3f48f..af63871 100644
--- a/library/src/com/nineoldandroids/util/FloatProperty.java
+++ b/library/src/com/nineoldandroids/util/FloatProperty.java
@@ -23,12 +23,13 @@
  * <code>Float</code> class.
  *
  * @param <T> The class on which the Property is declared.
- *
  * @hide
  */
-public abstract class FloatProperty<T> extends Property<T, Float> {
+public abstract class FloatProperty<T> extends Property<T, Float>
+{
 
-    public FloatProperty(String name) {
+    public FloatProperty(String name)
+    {
         super(Float.class, name);
     }
 
@@ -39,7 +40,8 @@ public FloatProperty(String name) {
     public abstract void setValue(T object, float value);
 
     @Override
-    final public void set(T object, Float value) {
+    final public void set(T object, Float value)
+    {
         setValue(object, value);
     }
 
diff --git a/library/src/com/nineoldandroids/util/IntProperty.java b/library/src/com/nineoldandroids/util/IntProperty.java
index 73d155d..7fab2ed 100644
--- a/library/src/com/nineoldandroids/util/IntProperty.java
+++ b/library/src/com/nineoldandroids/util/IntProperty.java
@@ -23,12 +23,13 @@
  * <code>Integer</code> class.
  *
  * @param <T> The class on which the Property is declared.
- *
  * @hide
  */
-public abstract class IntProperty<T> extends Property<T, Integer> {
+public abstract class IntProperty<T> extends Property<T, Integer>
+{
 
-    public IntProperty(String name) {
+    public IntProperty(String name)
+    {
         super(Integer.class, name);
     }
 
@@ -39,7 +40,8 @@ public IntProperty(String name) {
     public abstract void setValue(T object, int value);
 
     @Override
-    final public void set(T object, Integer value) {
+    final public void set(T object, Integer value)
+    {
         set(object, value.intValue());
     }
 
diff --git a/library/src/com/nineoldandroids/util/NoSuchPropertyException.java b/library/src/com/nineoldandroids/util/NoSuchPropertyException.java
index f8b583d..ee3e294 100644
--- a/library/src/com/nineoldandroids/util/NoSuchPropertyException.java
+++ b/library/src/com/nineoldandroids/util/NoSuchPropertyException.java
@@ -21,9 +21,11 @@
  *
  * @see Property#of(java.lang.Class, java.lang.Class, java.lang.String)
  */
-public class NoSuchPropertyException extends RuntimeException {
+public class NoSuchPropertyException extends RuntimeException
+{
 
-    public NoSuchPropertyException(String s) {
+    public NoSuchPropertyException(String s)
+    {
         super(s);
     }
 
diff --git a/library/src/com/nineoldandroids/util/Property.java b/library/src/com/nineoldandroids/util/Property.java
index 1e10872..b99f79e 100644
--- a/library/src/com/nineoldandroids/util/Property.java
+++ b/library/src/com/nineoldandroids/util/Property.java
@@ -25,44 +25,47 @@
  * @param <T> The class on which the property is declared.
  * @param <V> The type that this property represents.
  */
-public abstract class Property<T, V> {
+public abstract class Property<T, V>
+{
 
     private final String mName;
     private final Class<V> mType;
 
+    /**
+     * A constructor that takes an identifying name and {@link #getType() type} for the property.
+     */
+    public Property(Class<V> type, String name)
+    {
+        mName = name;
+        mType = type;
+    }
+
     /**
      * This factory method creates and returns a Property given the <code>class</code> and
      * <code>name</code> parameters, where the <code>"name"</code> parameter represents either:
      * <ul>
-     *     <li>a public <code>getName()</code> method on the class which takes no arguments, plus an
-     *     optional public <code>setName()</code> method which takes a value of the same type
-     *     returned by <code>getName()</code>
-     *     <li>a public <code>isName()</code> method on the class which takes no arguments, plus an
-     *     optional public <code>setName()</code> method which takes a value of the same type
-     *     returned by <code>isName()</code>
-     *     <li>a public <code>name</code> field on the class
+     * <li>a public <code>getName()</code> method on the class which takes no arguments, plus an
+     * optional public <code>setName()</code> method which takes a value of the same type
+     * returned by <code>getName()</code>
+     * <li>a public <code>isName()</code> method on the class which takes no arguments, plus an
+     * optional public <code>setName()</code> method which takes a value of the same type
+     * returned by <code>isName()</code>
+     * <li>a public <code>name</code> field on the class
      * </ul>
-     *
+     * <p/>
      * <p>If either of the get/is method alternatives is found on the class, but an appropriate
      * <code>setName()</code> method is not found, the <code>Property</code> will be
      * {@link #isReadOnly() readOnly}. Calling the {@link #set(Object, Object)} method on such
      * a property is allowed, but will have no effect.</p>
-     *
+     * <p/>
      * <p>If neither the methods nor the field are found on the class a
      * {@link NoSuchPropertyException} exception will be thrown.</p>
      */
-    public static <T, V> Property<T, V> of(Class<T> hostType, Class<V> valueType, String name) {
+    public static <T, V> Property<T, V> of(Class<T> hostType, Class<V> valueType, String name)
+    {
         return new ReflectiveProperty<T, V>(hostType, valueType, name);
     }
 
-    /**
-     * A constructor that takes an identifying name and {@link #getType() type} for the property.
-     */
-    public Property(Class<V> type, String name) {
-        mName = name;
-        mType = type;
-    }
-
     /**
      * Returns true if the {@link #set(Object, Object)} method does not set the value on the target
      * object (in which case the {@link #set(Object, Object) set()} method should throw a {@link
@@ -72,7 +75,8 @@ public Property(Class<V> type, String name) {
      * only a <code>getFoo()</code> or <code>isFoo()</code> method, but no matching
      * <code>setFoo()</code> method.
      */
-    public boolean isReadOnly() {
+    public boolean isReadOnly()
+    {
         return false;
     }
 
@@ -81,8 +85,9 @@ public boolean isReadOnly() {
      * to set the value on the target object it will throw an {@link UnsupportedOperationException}
      * exception.
      */
-    public void set(T object, V value) {
-        throw new UnsupportedOperationException("Property " + getName() +" is read-only");
+    public void set(T object, V value)
+    {
+        throw new UnsupportedOperationException("Property " + getName() + " is read-only");
     }
 
     /**
@@ -93,14 +98,16 @@ public void set(T object, V value) {
     /**
      * Returns the name for this property.
      */
-    public String getName() {
+    public String getName()
+    {
         return mName;
     }
 
     /**
      * Returns the type for this property.
      */
-    public Class<V> getType() {
+    public Class<V> getType()
+    {
         return mType;
     }
 }
diff --git a/library/src/com/nineoldandroids/util/ReflectiveProperty.java b/library/src/com/nineoldandroids/util/ReflectiveProperty.java
index 10b14c0..c9a7809 100644
--- a/library/src/com/nineoldandroids/util/ReflectiveProperty.java
+++ b/library/src/com/nineoldandroids/util/ReflectiveProperty.java
@@ -23,7 +23,8 @@
  * Internal class to automatically generate a Property for a given class/name pair, given the
  * specification of {@link Property#of(java.lang.Class, java.lang.Class, java.lang.String)}
  */
-class ReflectiveProperty<T, V> extends Property<T, V> {
+class ReflectiveProperty<T, V> extends Property<T, V>
+{
 
     private static final String PREFIX_GET = "get";
     private static final String PREFIX_IS = "is";
@@ -38,52 +39,70 @@
      * field results in throwing NoSuchPropertyException.
      *
      * @param propertyHolder The class on which the methods or field are found
-     * @param name The name of the property, where this name is capitalized and appended to
-     * "get" and "is to search for the appropriate methods. If the get/is methods are not found,
-     * the constructor will search for a field with that exact name.
+     * @param name           The name of the property, where this name is capitalized and appended to
+     *                       "get" and "is to search for the appropriate methods. If the get/is methods are not found,
+     *                       the constructor will search for a field with that exact name.
      */
-    public ReflectiveProperty(Class<T> propertyHolder, Class<V> valueType, String name) {
-         // TODO: cache reflection info for each new class/name pair
+    public ReflectiveProperty(Class<T> propertyHolder, Class<V> valueType, String name)
+    {
+        // TODO: cache reflection info for each new class/name pair
         super(valueType, name);
         char firstLetter = Character.toUpperCase(name.charAt(0));
         String theRest = name.substring(1);
         String capitalizedName = firstLetter + theRest;
         String getterName = PREFIX_GET + capitalizedName;
-        try {
+        try
+        {
             mGetter = propertyHolder.getMethod(getterName, (Class<?>[]) null);
-        } catch (NoSuchMethodException e) {
-            try {
+        }
+        catch (NoSuchMethodException e)
+        {
+            try
+            {
                 /* The native implementation uses JNI to do reflection, which allows access to private methods.
                  * getDeclaredMethod(..) does not find superclass methods, so it's implemented as a fallback.
                  */
                 mGetter = propertyHolder.getDeclaredMethod(getterName, (Class<?>[]) null);
                 mGetter.setAccessible(true);
-            } catch (NoSuchMethodException e2) {
+            }
+            catch (NoSuchMethodException e2)
+            {
                 // getName() not available - try isName() instead
                 getterName = PREFIX_IS + capitalizedName;
-                try {
+                try
+                {
                     mGetter = propertyHolder.getMethod(getterName, (Class<?>[]) null);
-                } catch (NoSuchMethodException e3) {
-                    try {
+                }
+                catch (NoSuchMethodException e3)
+                {
+                    try
+                    {
                         /* The native implementation uses JNI to do reflection, which allows access to private methods.
                          * getDeclaredMethod(..) does not find superclass methods, so it's implemented as a fallback.
                          */
                         mGetter = propertyHolder.getDeclaredMethod(getterName, (Class<?>[]) null);
                         mGetter.setAccessible(true);
-                    } catch (NoSuchMethodException e4) {
+                    }
+                    catch (NoSuchMethodException e4)
+                    {
                         // Try public field instead
-                        try {
+                        try
+                        {
                             mField = propertyHolder.getField(name);
                             Class fieldType = mField.getType();
-                            if (!typesMatch(valueType, fieldType)) {
+                            if (!typesMatch(valueType, fieldType))
+                            {
                                 throw new NoSuchPropertyException("Underlying type (" + fieldType + ") " +
-                                        "does not match Property type (" + valueType + ")");
+                                                                          "does not match Property type (" + valueType +
+                                                                          ")");
                             }
                             return;
-                        } catch (NoSuchFieldException e5) {
+                        }
+                        catch (NoSuchFieldException e5)
+                        {
                             // no way to access property - throw appropriate exception
                             throw new NoSuchPropertyException("No accessor method or field found for"
-                                    + " property with name " + name);
+                                                                      + " property with name " + name);
                         }
                     }
                 }
@@ -91,17 +110,21 @@ public ReflectiveProperty(Class<T> propertyHolder, Class<V> valueType, String na
         }
         Class getterType = mGetter.getReturnType();
         // Check to make sure our getter type matches our valueType
-        if (!typesMatch(valueType, getterType)) {
+        if (!typesMatch(valueType, getterType))
+        {
             throw new NoSuchPropertyException("Underlying type (" + getterType + ") " +
-                    "does not match Property type (" + valueType + ")");
+                                                      "does not match Property type (" + valueType + ")");
         }
         String setterName = PREFIX_SET + capitalizedName;
-        try {
+        try
+        {
             // mSetter = propertyHolder.getMethod(setterName, getterType);
             // The native implementation uses JNI to do reflection, which allows access to private methods.
             mSetter = propertyHolder.getDeclaredMethod(setterName, getterType);
             mSetter.setAccessible(true);
-        } catch (NoSuchMethodException ignored) {
+        }
+        catch (NoSuchMethodException ignored)
+        {
             // Okay to not have a setter - just a readonly property
         }
     }
@@ -113,9 +136,12 @@ public ReflectiveProperty(Class<T> propertyHolder, Class<V> valueType, String na
      * method/field will probably be a primitive type instead. Accept float as matching Float,
      * etc.
      */
-    private boolean typesMatch(Class<V> valueType, Class getterType) {
-        if (getterType != valueType) {
-            if (getterType.isPrimitive()) {
+    private boolean typesMatch(Class<V> valueType, Class getterType)
+    {
+        if (getterType != valueType)
+        {
+            if (getterType.isPrimitive())
+            {
                 return (getterType == float.class && valueType == Float.class) ||
                         (getterType == int.class && valueType == Integer.class) ||
                         (getterType == boolean.class && valueType == Boolean.class) ||
@@ -131,40 +157,66 @@ private boolean typesMatch(Class<V> valueType, Class getterType) {
     }
 
     @Override
-    public void set(T object, V value) {
-        if (mSetter != null) {
-            try {
+    public void set(T object, V value)
+    {
+        if (mSetter != null)
+        {
+            try
+            {
                 mSetter.invoke(object, value);
-            } catch (IllegalAccessException e) {
+            }
+            catch (IllegalAccessException e)
+            {
                 throw new AssertionError();
-            } catch (InvocationTargetException e) {
+            }
+            catch (InvocationTargetException e)
+            {
                 throw new RuntimeException(e.getCause());
             }
-        } else if (mField != null) {
-            try {
+        }
+        else if (mField != null)
+        {
+            try
+            {
                 mField.set(object, value);
-            } catch (IllegalAccessException e) {
+            }
+            catch (IllegalAccessException e)
+            {
                 throw new AssertionError();
             }
-        } else {
-            throw new UnsupportedOperationException("Property " + getName() +" is read-only");
+        }
+        else
+        {
+            throw new UnsupportedOperationException("Property " + getName() + " is read-only");
         }
     }
 
     @Override
-    public V get(T object) {
-        if (mGetter != null) {
-            try {
-                return (V) mGetter.invoke(object, (Object[])null);
-            } catch (IllegalAccessException e) {
+    public V get(T object)
+    {
+        if (mGetter != null)
+        {
+            try
+            {
+                return (V) mGetter.invoke(object, (Object[]) null);
+            }
+            catch (IllegalAccessException e)
+            {
                 throw new AssertionError();
-            } catch (InvocationTargetException e) {
+            }
+            catch (InvocationTargetException e)
+            {
                 throw new RuntimeException(e.getCause());
             }
-        } else if (mField != null) {
-            try {
+        }
+        else if (mField != null)
+        {
+            try
+            {
                 return (V) mField.get(object);
-            } catch (IllegalAccessException e) {
+            }
+            catch (IllegalAccessException e)
+            {
                 throw new AssertionError();
             }
         }
@@ -176,7 +228,8 @@ public V get(T object) {
      * Returns false if there is no setter or public field underlying this Property.
      */
     @Override
-    public boolean isReadOnly() {
+    public boolean isReadOnly()
+    {
         return (mSetter == null && mField == null);
     }
 }
diff --git a/library/src/com/nineoldandroids/view/ViewHelper.java b/library/src/com/nineoldandroids/view/ViewHelper.java
index d79dc0f..77dddec 100644
--- a/library/src/com/nineoldandroids/view/ViewHelper.java
+++ b/library/src/com/nineoldandroids/view/ViewHelper.java
@@ -5,287 +5,389 @@
 import static com.nineoldandroids.view.animation.AnimatorProxy.NEEDS_PROXY;
 import static com.nineoldandroids.view.animation.AnimatorProxy.wrap;
 
-public final class ViewHelper {
-    private ViewHelper() {}
+public final class ViewHelper
+{
+    private ViewHelper()
+    {
+    }
 
-    public static float getAlpha(View view) {
+    public static float getAlpha(View view)
+    {
         return NEEDS_PROXY ? wrap(view).getAlpha() : Honeycomb.getAlpha(view);
     }
 
-    public static void setAlpha(View view, float alpha) {
-        if (NEEDS_PROXY) {
+    public static void setAlpha(View view, float alpha)
+    {
+        if (NEEDS_PROXY)
+        {
             wrap(view).setAlpha(alpha);
-        } else {
+        }
+        else
+        {
             Honeycomb.setAlpha(view, alpha);
         }
     }
 
-    public static float getPivotX(View view) {
+    public static float getPivotX(View view)
+    {
         return NEEDS_PROXY ? wrap(view).getPivotX() : Honeycomb.getPivotX(view);
     }
 
-    public static void setPivotX(View view, float pivotX) {
-        if (NEEDS_PROXY) {
+    public static void setPivotX(View view, float pivotX)
+    {
+        if (NEEDS_PROXY)
+        {
             wrap(view).setPivotX(pivotX);
-        } else {
+        }
+        else
+        {
             Honeycomb.setPivotX(view, pivotX);
         }
     }
 
-    public static float getPivotY(View view) {
+    public static float getPivotY(View view)
+    {
         return NEEDS_PROXY ? wrap(view).getPivotY() : Honeycomb.getPivotY(view);
     }
 
-    public static void setPivotY(View view, float pivotY) {
-        if (NEEDS_PROXY) {
+    public static void setPivotY(View view, float pivotY)
+    {
+        if (NEEDS_PROXY)
+        {
             wrap(view).setPivotY(pivotY);
-        } else {
+        }
+        else
+        {
             Honeycomb.setPivotY(view, pivotY);
         }
     }
 
-    public static float getRotation(View view) {
+    public static float getRotation(View view)
+    {
         return NEEDS_PROXY ? wrap(view).getRotation() : Honeycomb.getRotation(view);
     }
 
-    public static void setRotation(View view, float rotation) {
-        if (NEEDS_PROXY) {
+    public static void setRotation(View view, float rotation)
+    {
+        if (NEEDS_PROXY)
+        {
             wrap(view).setRotation(rotation);
-        } else {
+        }
+        else
+        {
             Honeycomb.setRotation(view, rotation);
         }
     }
 
-    public static float getRotationX(View view) {
+    public static float getRotationX(View view)
+    {
         return NEEDS_PROXY ? wrap(view).getRotationX() : Honeycomb.getRotationX(view);
     }
 
-    public static void setRotationX(View view, float rotationX) {
-        if (NEEDS_PROXY) {
+    public static void setRotationX(View view, float rotationX)
+    {
+        if (NEEDS_PROXY)
+        {
             wrap(view).setRotationX(rotationX);
-        } else {
+        }
+        else
+        {
             Honeycomb.setRotationX(view, rotationX);
         }
     }
 
-    public static float getRotationY(View view) {
+    public static float getRotationY(View view)
+    {
         return NEEDS_PROXY ? wrap(view).getRotationY() : Honeycomb.getRotationY(view);
     }
 
-    public static void setRotationY(View view, float rotationY) {
-        if (NEEDS_PROXY) {
+    public static void setRotationY(View view, float rotationY)
+    {
+        if (NEEDS_PROXY)
+        {
             wrap(view).setRotationY(rotationY);
-        } else {
+        }
+        else
+        {
             Honeycomb.setRotationY(view, rotationY);
         }
     }
 
-    public static float getScaleX(View view) {
+    public static float getScaleX(View view)
+    {
         return NEEDS_PROXY ? wrap(view).getScaleX() : Honeycomb.getScaleX(view);
     }
 
-    public static void setScaleX(View view, float scaleX) {
-        if (NEEDS_PROXY) {
+    public static void setScaleX(View view, float scaleX)
+    {
+        if (NEEDS_PROXY)
+        {
             wrap(view).setScaleX(scaleX);
-        } else {
+        }
+        else
+        {
             Honeycomb.setScaleX(view, scaleX);
         }
     }
 
-    public static float getScaleY(View view) {
+    public static float getScaleY(View view)
+    {
         return NEEDS_PROXY ? wrap(view).getScaleY() : Honeycomb.getScaleY(view);
     }
 
-    public static void setScaleY(View view, float scaleY) {
-        if (NEEDS_PROXY) {
+    public static void setScaleY(View view, float scaleY)
+    {
+        if (NEEDS_PROXY)
+        {
             wrap(view).setScaleY(scaleY);
-        } else {
+        }
+        else
+        {
             Honeycomb.setScaleY(view, scaleY);
         }
     }
 
-    public static float getScrollX(View view) {
+    public static float getScrollX(View view)
+    {
         return NEEDS_PROXY ? wrap(view).getScrollX() : Honeycomb.getScrollX(view);
     }
 
-    public static void setScrollX(View view, int scrollX) {
-        if (NEEDS_PROXY) {
+    public static void setScrollX(View view, int scrollX)
+    {
+        if (NEEDS_PROXY)
+        {
             wrap(view).setScrollX(scrollX);
-        } else {
+        }
+        else
+        {
             Honeycomb.setScrollX(view, scrollX);
         }
     }
 
-    public static float getScrollY(View view) {
+    public static float getScrollY(View view)
+    {
         return NEEDS_PROXY ? wrap(view).getScrollY() : Honeycomb.getScrollY(view);
     }
 
-    public static void setScrollY(View view, int scrollY) {
-        if (NEEDS_PROXY) {
+    public static void setScrollY(View view, int scrollY)
+    {
+        if (NEEDS_PROXY)
+        {
             wrap(view).setScrollY(scrollY);
-        } else {
+        }
+        else
+        {
             Honeycomb.setScrollY(view, scrollY);
         }
     }
 
-    public static float getTranslationX(View view) {
+    public static float getTranslationX(View view)
+    {
         return NEEDS_PROXY ? wrap(view).getTranslationX() : Honeycomb.getTranslationX(view);
     }
 
-    public static void setTranslationX(View view, float translationX) {
-        if (NEEDS_PROXY) {
+    public static void setTranslationX(View view, float translationX)
+    {
+        if (NEEDS_PROXY)
+        {
             wrap(view).setTranslationX(translationX);
-        } else {
+        }
+        else
+        {
             Honeycomb.setTranslationX(view, translationX);
         }
     }
 
-    public static float getTranslationY(View view) {
+    public static float getTranslationY(View view)
+    {
         return NEEDS_PROXY ? wrap(view).getTranslationY() : Honeycomb.getTranslationY(view);
     }
 
-    public static void setTranslationY(View view, float translationY) {
-        if (NEEDS_PROXY) {
+    public static void setTranslationY(View view, float translationY)
+    {
+        if (NEEDS_PROXY)
+        {
             wrap(view).setTranslationY(translationY);
-        } else {
+        }
+        else
+        {
             Honeycomb.setTranslationY(view, translationY);
         }
     }
 
-    public static float getX(View view) {
+    public static float getX(View view)
+    {
         return NEEDS_PROXY ? wrap(view).getX() : Honeycomb.getX(view);
     }
 
-    public static void setX(View view, float x) {
-        if (NEEDS_PROXY) {
+    public static void setX(View view, float x)
+    {
+        if (NEEDS_PROXY)
+        {
             wrap(view).setX(x);
-        } else {
+        }
+        else
+        {
             Honeycomb.setX(view, x);
         }
     }
 
-    public static float getY(View view) {
+    public static float getY(View view)
+    {
         return NEEDS_PROXY ? wrap(view).getY() : Honeycomb.getY(view);
     }
 
-    public static void setY(View view, float y) {
-        if (NEEDS_PROXY) {
+    public static void setY(View view, float y)
+    {
+        if (NEEDS_PROXY)
+        {
             wrap(view).setY(y);
-        } else {
+        }
+        else
+        {
             Honeycomb.setY(view, y);
         }
     }
 
-    private static final class Honeycomb {
-        static float getAlpha(View view) {
+    private static final class Honeycomb
+    {
+        static float getAlpha(View view)
+        {
             return view.getAlpha();
         }
 
-        static void setAlpha(View view, float alpha) {
+        static void setAlpha(View view, float alpha)
+        {
             view.setAlpha(alpha);
         }
 
-        static float getPivotX(View view) {
+        static float getPivotX(View view)
+        {
             return view.getPivotX();
         }
 
-        static void setPivotX(View view, float pivotX) {
+        static void setPivotX(View view, float pivotX)
+        {
             view.setPivotX(pivotX);
         }
 
-        static float getPivotY(View view) {
+        static float getPivotY(View view)
+        {
             return view.getPivotY();
         }
 
-        static void setPivotY(View view, float pivotY) {
+        static void setPivotY(View view, float pivotY)
+        {
             view.setPivotY(pivotY);
         }
 
-        static float getRotation(View view) {
+        static float getRotation(View view)
+        {
             return view.getRotation();
         }
 
-        static void setRotation(View view, float rotation) {
+        static void setRotation(View view, float rotation)
+        {
             view.setRotation(rotation);
         }
 
-        static float getRotationX(View view) {
+        static float getRotationX(View view)
+        {
             return view.getRotationX();
         }
 
-        static void setRotationX(View view, float rotationX) {
+        static void setRotationX(View view, float rotationX)
+        {
             view.setRotationX(rotationX);
         }
 
-        static float getRotationY(View view) {
+        static float getRotationY(View view)
+        {
             return view.getRotationY();
         }
 
-        static void setRotationY(View view, float rotationY) {
+        static void setRotationY(View view, float rotationY)
+        {
             view.setRotationY(rotationY);
         }
 
-        static float getScaleX(View view) {
+        static float getScaleX(View view)
+        {
             return view.getScaleX();
         }
 
-        static void setScaleX(View view, float scaleX) {
+        static void setScaleX(View view, float scaleX)
+        {
             view.setScaleX(scaleX);
         }
 
-        static float getScaleY(View view) {
+        static float getScaleY(View view)
+        {
             return view.getScaleY();
         }
 
-        static void setScaleY(View view, float scaleY) {
+        static void setScaleY(View view, float scaleY)
+        {
             view.setScaleY(scaleY);
         }
 
-        static float getScrollX(View view) {
+        static float getScrollX(View view)
+        {
             return view.getScrollX();
         }
 
-        static void setScrollX(View view, int scrollX) {
+        static void setScrollX(View view, int scrollX)
+        {
             view.setScrollX(scrollX);
         }
 
-        static float getScrollY(View view) {
+        static float getScrollY(View view)
+        {
             return view.getScrollY();
         }
 
-        static void setScrollY(View view, int scrollY) {
+        static void setScrollY(View view, int scrollY)
+        {
             view.setScrollY(scrollY);
         }
 
-        static float getTranslationX(View view) {
+        static float getTranslationX(View view)
+        {
             return view.getTranslationX();
         }
 
-        static void setTranslationX(View view, float translationX) {
+        static void setTranslationX(View view, float translationX)
+        {
             view.setTranslationX(translationX);
         }
 
-        static float getTranslationY(View view) {
+        static float getTranslationY(View view)
+        {
             return view.getTranslationY();
         }
 
-        static void setTranslationY(View view, float translationY) {
+        static void setTranslationY(View view, float translationY)
+        {
             view.setTranslationY(translationY);
         }
 
-        static float getX(View view) {
+        static float getX(View view)
+        {
             return view.getX();
         }
 
-        static void setX(View view, float x) {
+        static void setX(View view, float x)
+        {
             view.setX(x);
         }
 
-        static float getY(View view) {
+        static float getY(View view)
+        {
             return view.getY();
         }
 
-        static void setY(View view, float y) {
+        static void setY(View view, float y)
+        {
             view.setY(y);
         }
     }
diff --git a/library/src/com/nineoldandroids/view/ViewPropertyAnimator.java b/library/src/com/nineoldandroids/view/ViewPropertyAnimator.java
index c3bc4e6..b967897 100644
--- a/library/src/com/nineoldandroids/view/ViewPropertyAnimator.java
+++ b/library/src/com/nineoldandroids/view/ViewPropertyAnimator.java
@@ -16,12 +16,13 @@
 
 package com.nineoldandroids.view;
 
-import java.util.WeakHashMap;
 import android.os.Build;
 import android.view.View;
 import android.view.animation.Interpolator;
 import com.nineoldandroids.animation.Animator;
 
+import java.util.WeakHashMap;
+
 /**
  * This class enables automatic and optimized animation of select properties on View objects.
  * If only one or two properties on a View object are being animated, then using an
@@ -30,20 +31,20 @@
  * appropriately. But if several properties are animated simultaneously, or if you just want a
  * more convenient syntax to animate a specific property, then ViewPropertyAnimator might be
  * more well-suited to the task.
- *
+ * <p/>
  * <p>This class may provide better performance for several simultaneous animations, because
  * it will optimize invalidate calls to take place only once for several properties instead of each
  * animated property independently causing its own invalidation. Also, the syntax of using this
  * class could be easier to use because the caller need only tell the View object which
  * property to animate, and the value to animate either to or by, and this class handles the
  * details of configuring the underlying Animator class and starting it.</p>
- *
+ * <p/>
  * <p>This class is not constructed by the caller, but rather by the View whose properties
  * it will animate. Calls to {@link android.view.View#animate()} will return a reference
  * to the appropriate ViewPropertyAnimator object for that View.</p>
- *
  */
-public abstract class ViewPropertyAnimator {
+public abstract class ViewPropertyAnimator
+{
     private static final WeakHashMap<View, ViewPropertyAnimator> ANIMATORS =
             new WeakHashMap<View, ViewPropertyAnimator>(0);
 
@@ -54,15 +55,22 @@
      * @param view View to animate.
      * @return The ViewPropertyAnimator associated with this View.
      */
-    public static ViewPropertyAnimator animate(View view) {
+    public static ViewPropertyAnimator animate(View view)
+    {
         ViewPropertyAnimator animator = ANIMATORS.get(view);
-        if (animator == null) {
+        if (animator == null)
+        {
             final int version = Integer.valueOf(Build.VERSION.SDK);
-            if (version >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
+            if (version >= Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+            {
                 animator = new ViewPropertyAnimatorICS(view);
-            } else if (version >= Build.VERSION_CODES.HONEYCOMB) {
+            }
+            else if (version >= Build.VERSION_CODES.HONEYCOMB)
+            {
                 animator = new ViewPropertyAnimatorHC(view);
-            } else {
+            }
+            else
+            {
                 animator = new ViewPropertyAnimatorPreHC(view);
             }
             ANIMATORS.put(view, animator);
@@ -70,34 +78,34 @@ public static ViewPropertyAnimator animate(View view) {
         return animator;
     }
 
+    /**
+     * Returns the current duration of property animations. If the duration was set on this
+     * object, that value is returned. Otherwise, the default value of the underlying Animator
+     * is returned.
+     *
+     * @return The duration of animations, in milliseconds.
+     * @see #setDuration(long)
+     */
+    public abstract long getDuration();
 
     /**
      * Sets the duration for the underlying animator that animates the requested properties.
      * By default, the animator uses the default value for ValueAnimator. Calling this method
      * will cause the declared value to be used instead.
+     *
      * @param duration The length of ensuing property animations, in milliseconds. The value
-     * cannot be negative.
+     *                 cannot be negative.
      * @return This object, allowing calls to methods in this class to be chained.
      */
     public abstract ViewPropertyAnimator setDuration(long duration);
 
-    /**
-     * Returns the current duration of property animations. If the duration was set on this
-     * object, that value is returned. Otherwise, the default value of the underlying Animator
-     * is returned.
-     *
-     * @see #setDuration(long)
-     * @return The duration of animations, in milliseconds.
-     */
-    public abstract long getDuration();
-
     /**
      * Returns the current startDelay of property animations. If the startDelay was set on this
      * object, that value is returned. Otherwise, the default value of the underlying Animator
      * is returned.
      *
-     * @see #setStartDelay(long)
      * @return The startDelay of animations, in milliseconds.
+     * @see #setStartDelay(long)
      */
     public abstract long getStartDelay();
 
@@ -105,8 +113,9 @@ public static ViewPropertyAnimator animate(View view) {
      * Sets the startDelay for the underlying animator that animates the requested properties.
      * By default, the animator uses the default value for ValueAnimator. Calling this method
      * will cause the declared value to be used instead.
+     *
      * @param startDelay The delay of ensuing property animations, in milliseconds. The value
-     * cannot be negative.
+     *                   cannot be negative.
      * @return This object, allowing calls to methods in this class to be chained.
      */
     public abstract ViewPropertyAnimator setStartDelay(long startDelay);
@@ -149,8 +158,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The value to be animated to.
-     * @see View#setX(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setX(float)
      */
     public abstract ViewPropertyAnimator x(float value);
 
@@ -159,8 +168,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The amount to be animated by, as an offset from the current value.
-     * @see View#setX(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setX(float)
      */
     public abstract ViewPropertyAnimator xBy(float value);
 
@@ -169,8 +178,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The value to be animated to.
-     * @see View#setY(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setY(float)
      */
     public abstract ViewPropertyAnimator y(float value);
 
@@ -179,8 +188,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The amount to be animated by, as an offset from the current value.
-     * @see View#setY(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setY(float)
      */
     public abstract ViewPropertyAnimator yBy(float value);
 
@@ -189,8 +198,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The value to be animated to.
-     * @see View#setRotation(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setRotation(float)
      */
     public abstract ViewPropertyAnimator rotation(float value);
 
@@ -199,8 +208,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The amount to be animated by, as an offset from the current value.
-     * @see View#setRotation(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setRotation(float)
      */
     public abstract ViewPropertyAnimator rotationBy(float value);
 
@@ -209,8 +218,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The value to be animated to.
-     * @see View#setRotationX(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setRotationX(float)
      */
     public abstract ViewPropertyAnimator rotationX(float value);
 
@@ -219,8 +228,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The amount to be animated by, as an offset from the current value.
-     * @see View#setRotationX(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setRotationX(float)
      */
     public abstract ViewPropertyAnimator rotationXBy(float value);
 
@@ -229,8 +238,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The value to be animated to.
-     * @see View#setRotationY(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setRotationY(float)
      */
     public abstract ViewPropertyAnimator rotationY(float value);
 
@@ -239,8 +248,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The amount to be animated by, as an offset from the current value.
-     * @see View#setRotationY(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setRotationY(float)
      */
     public abstract ViewPropertyAnimator rotationYBy(float value);
 
@@ -249,8 +258,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The value to be animated to.
-     * @see View#setTranslationX(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setTranslationX(float)
      */
     public abstract ViewPropertyAnimator translationX(float value);
 
@@ -259,8 +268,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The amount to be animated by, as an offset from the current value.
-     * @see View#setTranslationX(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setTranslationX(float)
      */
     public abstract ViewPropertyAnimator translationXBy(float value);
 
@@ -269,8 +278,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The value to be animated to.
-     * @see View#setTranslationY(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setTranslationY(float)
      */
     public abstract ViewPropertyAnimator translationY(float value);
 
@@ -279,8 +288,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The amount to be animated by, as an offset from the current value.
-     * @see View#setTranslationY(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setTranslationY(float)
      */
     public abstract ViewPropertyAnimator translationYBy(float value);
 
@@ -289,8 +298,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The value to be animated to.
-     * @see View#setScaleX(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setScaleX(float)
      */
     public abstract ViewPropertyAnimator scaleX(float value);
 
@@ -299,8 +308,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The amount to be animated by, as an offset from the current value.
-     * @see View#setScaleX(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setScaleX(float)
      */
     public abstract ViewPropertyAnimator scaleXBy(float value);
 
@@ -309,8 +318,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The value to be animated to.
-     * @see View#setScaleY(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setScaleY(float)
      */
     public abstract ViewPropertyAnimator scaleY(float value);
 
@@ -319,8 +328,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The amount to be animated by, as an offset from the current value.
-     * @see View#setScaleY(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setScaleY(float)
      */
     public abstract ViewPropertyAnimator scaleYBy(float value);
 
@@ -329,8 +338,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The value to be animated to.
-     * @see View#setAlpha(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setAlpha(float)
      */
     public abstract ViewPropertyAnimator alpha(float value);
 
@@ -339,8 +348,8 @@ public static ViewPropertyAnimator animate(View view) {
      * specified value. Animations already running on the property will be canceled.
      *
      * @param value The amount to be animated by, as an offset from the current value.
-     * @see View#setAlpha(float)
      * @return This object, allowing calls to methods in this class to be chained.
+     * @see View#setAlpha(float)
      */
     public abstract ViewPropertyAnimator alphaBy(float value);
 }
diff --git a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorHC.java b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorHC.java
index 7ad2ada..1f0543e 100644
--- a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorHC.java
+++ b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorHC.java
@@ -16,103 +16,95 @@
 
 package com.nineoldandroids.view;
 
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Set;
 import android.view.View;
 import android.view.animation.Interpolator;
 import com.nineoldandroids.animation.Animator;
 import com.nineoldandroids.animation.ValueAnimator;
 
-class ViewPropertyAnimatorHC extends ViewPropertyAnimator {
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Set;
+
+class ViewPropertyAnimatorHC extends ViewPropertyAnimator
+{
 
+    /**
+     * Constants used to associate a property being requested and the mechanism used to set
+     * the property (this class calls directly into View to set the properties in question).
+     */
+    private static final int NONE = 0x0000;
+    private static final int TRANSLATION_X = 0x0001;
+    private static final int TRANSLATION_Y = 0x0002;
+    private static final int SCALE_X = 0x0004;
+    private static final int SCALE_Y = 0x0008;
+    private static final int ROTATION = 0x0010;
+    private static final int ROTATION_X = 0x0020;
+    private static final int ROTATION_Y = 0x0040;
+    private static final int X = 0x0080;
+    private static final int Y = 0x0100;
+
+    HashMap
+    private static final int TRANSFORM_MASK = TRANSLATION_X | TRANSLATION_Y | SCALE_X | SCALE_Y |
+            ROTATION | ROTATION_X | ROTATION_Y | X | Y;
+    private static final int ALPHA = 0x0200;
     /**
      * A WeakReference holding the View whose properties are being animated by this class.
      * This is set at construction time.
      */
     private final WeakReference<View> mView;
-
+    /**
+     * This list holds the properties that have been asked to animate. We allow the caller to
+     * request several animations prior to actually starting the underlying animator. This
+     * enables us to run one single animator to handle several properties in parallel. Each
+     * property is tossed onto the pending list until the animation actually starts (which is
+     * done by posting it onto mView), at which time the pending list is cleared and the properties
+     * on that list are added to the list of properties associated with that animator.
+     */
+    ArrayList<NameValuesHolder> mPendingAnimations = new ArrayList<NameValuesHolder>();
     /**
      * The duration of the underlying Animator object. By default, we don't set the duration
      * on the Animator and just use its default duration. If the duration is ever set on this
      * Animator, then we use the duration that it was set to.
      */
     private long mDuration;
-
     /**
      * A flag indicating whether the duration has been set on this object. If not, we don't set
      * the duration on the underlying Animator, but instead just use its default duration.
      */
     private boolean mDurationSet = false;
-
     /**
      * The startDelay of the underlying Animator object. By default, we don't set the startDelay
      * on the Animator and just use its default startDelay. If the startDelay is ever set on this
      * Animator, then we use the startDelay that it was set to.
      */
     private long mStartDelay = 0;
-
     /**
      * A flag indicating whether the startDelay has been set on this object. If not, we don't set
      * the startDelay on the underlying Animator, but instead just use its default startDelay.
      */
     private boolean mStartDelaySet = false;
-
     /**
      * The interpolator of the underlying Animator object. By default, we don't set the interpolator
      * on the Animator and just use its default interpolator. If the interpolator is ever set on
      * this Animator, then we use the interpolator that it was set to.
      */
-    private /*Time*/Interpolator mInterpolator;
-
+    private /*Time*/ Interpolator mInterpolator;
     /**
      * A flag indicating whether the interpolator has been set on this object. If not, we don't set
      * the interpolator on the underlying Animator, but instead just use its default interpolator.
      */
     private boolean mInterpolatorSet = false;
-
     /**
      * Listener for the lifecycle events of the underlying
      */
     private Animator.AnimatorListener mListener = null;
-
     /**
      * This listener is the mechanism by which the underlying Animator causes changes to the
      * properties currently being animated, as well as the cleanup after an animation is
      * complete.
      */
     private AnimatorEventListener mAnimatorEventListener = new AnimatorEventListener();
-
-    /**
-     * This list holds the properties that have been asked to animate. We allow the caller to
-     * request several animations prior to actually starting the underlying animator. This
-     * enables us to run one single animator to handle several properties in parallel. Each
-     * property is tossed onto the pending list until the animation actually starts (which is
-     * done by posting it onto mView), at which time the pending list is cleared and the properties
-     * on that list are added to the list of properties associated with that animator.
-     */
-    ArrayList<NameValuesHolder> mPendingAnimations = new ArrayList<NameValuesHolder>();
-
-    /**
-     * Constants used to associate a property being requested and the mechanism used to set
-     * the property (this class calls directly into View to set the properties in question).
-     */
-    private static final int NONE           = 0x0000;
-    private static final int TRANSLATION_X  = 0x0001;
-    private static final int TRANSLATION_Y  = 0x0002;
-    private static final int SCALE_X        = 0x0004;
-    private static final int SCALE_Y        = 0x0008;
-    private static final int ROTATION       = 0x0010;
-    private static final int ROTATION_X     = 0x0020;
-    private static final int ROTATION_Y     = 0x0040;
-    private static final int X              = 0x0080;
-    private static final int Y              = 0x0100;
-    private static final int ALPHA          = 0x0200;
-
-    private static final int TRANSFORM_MASK = TRANSLATION_X | TRANSLATION_Y | SCALE_X | SCALE_Y |
-            ROTATION | ROTATION_X | ROTATION_Y | X | Y;
-
     /**
      * The mechanism by which the user can request several properties that are then animated
      * together works by posting this Runnable to start the underlying Animator. Every time
@@ -121,53 +113,14 @@
      * underlying animator) after the caller is done setting the properties that should be
      * animated together.
      */
-    private Runnable mAnimationStarter = new Runnable() {
+    private Runnable mAnimationStarter = new Runnable()
+    {
         @Override
-        public void run() {
+        public void run()
+        {
             startAnimation();
         }
     };
-
-    /**
-     * This class holds information about the overall animation being run on the set of
-     * properties. The mask describes which properties are being animated and the
-     * values holder is the list of all property/value objects.
-     */
-    private static class PropertyBundle {
-        int mPropertyMask;
-        ArrayList<NameValuesHolder> mNameValuesHolder;
-
-        PropertyBundle(int propertyMask, ArrayList<NameValuesHolder> nameValuesHolder) {
-            mPropertyMask = propertyMask;
-            mNameValuesHolder = nameValuesHolder;
-        }
-
-        /**
-         * Removes the given property from being animated as a part of this
-         * PropertyBundle. If the property was a part of this bundle, it returns
-         * true to indicate that it was, in fact, canceled. This is an indication
-         * to the caller that a cancellation actually occurred.
-         *
-         * @param propertyConstant The property whose cancellation is requested.
-         * @return true if the given property is a part of this bundle and if it
-         * has therefore been canceled.
-         */
-        boolean cancel(int propertyConstant) {
-            if ((mPropertyMask & propertyConstant) != 0 && mNameValuesHolder != null) {
-                int count = mNameValuesHolder.size();
-                for (int i = 0; i < count; ++i) {
-                    NameValuesHolder nameValuesHolder = mNameValuesHolder.get(i);
-                    if (nameValuesHolder.mNameConstant == propertyConstant) {
-                        mNameValuesHolder.remove(i);
-                        mPropertyMask &= ~propertyConstant;
-                        return true;
-                    }
-                }
-            }
-            return false;
-        }
-    }
-
     /**
      * This list tracks the list of properties being animated by any particular animator.
      * In most situations, there would only ever be one animator running at a time. But it is
@@ -180,30 +133,14 @@ boolean cancel(int propertyConstant) {
     private HashMap<Animator, PropertyBundle> mAnimatorMap =
             new HashMap<Animator, PropertyBundle>();
 
-    /**
-     * This is the information we need to set each property during the animation.
-     * mNameConstant is used to set the appropriate field in View, and the from/delta
-     * values are used to calculate the animated value for a given animation fraction
-     * during the animation.
-     */
-    private static class NameValuesHolder {
-        int mNameConstant;
-        float mFromValue;
-        float mDeltaValue;
-        NameValuesHolder(int nameConstant, float fromValue, float deltaValue) {
-            mNameConstant = nameConstant;
-            mFromValue = fromValue;
-            mDeltaValue = deltaValue;
-        }
-    }
-
     /**
      * Constructor, called by View. This is private by design, as the user should only
      * get a ViewPropertyAnimator by calling View.animate().
      *
      * @param view The View associated with this ViewPropertyAnimator
      */
-    ViewPropertyAnimatorHC(View view) {
+    ViewPropertyAnimatorHC(View view)
+    {
         mView = new WeakReference<View>(view);
     }
 
@@ -211,14 +148,17 @@ boolean cancel(int propertyConstant) {
      * Sets the duration for the underlying animator that animates the requested properties.
      * By default, the animator uses the default value for ValueAnimator. Calling this method
      * will cause the declared value to be used instead.
+     *
      * @param duration The length of ensuing property animations, in milliseconds. The value
-     * cannot be negative.
+     *                 cannot be negative.
      * @return This object, allowing calls to methods in this class to be chained.
      */
-    public ViewPropertyAnimator setDuration(long duration) {
-        if (duration < 0) {
+    public ViewPropertyAnimator setDuration(long duration)
+    {
+        if (duration < 0)
+        {
             throw new IllegalArgumentException("Animators cannot have negative duration: " +
-                    duration);
+                                                       duration);
         }
         mDurationSet = true;
         mDuration = duration;
@@ -230,13 +170,17 @@ public ViewPropertyAnimator setDuration(long duration) {
      * object, that value is returned. Otherwise, the default value of the underlying Animator
      * is returned.
      *
-     * @see #setDuration(long)
      * @return The duration of animations, in milliseconds.
+     * @see #setDuration(long)
      */
-    public long getDuration() {
-        if (mDurationSet) {
+    public long getDuration()
+    {
+        if (mDurationSet)
+        {
             return mDuration;
-        } else {
+        }
+        else
+        {
             // Just return the default from ValueAnimator, since that's what we'd get if
             // the value has not been set otherwise
             return new ValueAnimator().getDuration();
@@ -244,10 +188,14 @@ public long getDuration() {
     }
 
     @Override
-    public long getStartDelay() {
-        if (mStartDelaySet) {
+    public long getStartDelay()
+    {
+        if (mStartDelaySet)
+        {
             return mStartDelay;
-        } else {
+        }
+        else
+        {
             // Just return the default from ValueAnimator (0), since that's what we'd get if
             // the value has not been set otherwise
             return 0;
@@ -255,10 +203,12 @@ public long getStartDelay() {
     }
 
     @Override
-    public ViewPropertyAnimator setStartDelay(long startDelay) {
-        if (startDelay < 0) {
+    public ViewPropertyAnimator setStartDelay(long startDelay)
+    {
+        if (startDelay < 0)
+        {
             throw new IllegalArgumentException("Animators cannot have negative duration: " +
-                    startDelay);
+                                                       startDelay);
         }
         mStartDelaySet = true;
         mStartDelay = startDelay;
@@ -266,156 +216,183 @@ public ViewPropertyAnimator setStartDelay(long startDelay) {
     }
 
     @Override
-    public ViewPropertyAnimator setInterpolator(/*Time*/Interpolator interpolator) {
+    public ViewPropertyAnimator setInterpolator(/*Time*/Interpolator interpolator)
+    {
         mInterpolatorSet = true;
         mInterpolator = interpolator;
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator setListener(Animator.AnimatorListener listener) {
+    public ViewPropertyAnimator setListener(Animator.AnimatorListener listener)
+    {
         mListener = listener;
         return this;
     }
 
     @Override
-    public void start() {
+    public void start()
+    {
         startAnimation();
     }
 
     @Override
-    public void cancel() {
-        if (mAnimatorMap.size() > 0) {
+    public void cancel()
+    {
+        if (mAnimatorMap.size() > 0)
+        {
             HashMap<Animator, PropertyBundle> mAnimatorMapCopy =
-                    (HashMap<Animator, PropertyBundle>)mAnimatorMap.clone();
+                    (HashMap<Animator, PropertyBundle>) mAnimatorMap.clone();
             Set<Animator> animatorSet = mAnimatorMapCopy.keySet();
-            for (Animator runningAnim : animatorSet) {
+            for (Animator runningAnim : animatorSet)
+            {
                 runningAnim.cancel();
             }
         }
         mPendingAnimations.clear();
         View v = mView.get();
-        if (v != null) {
+        if (v != null)
+        {
             v.removeCallbacks(mAnimationStarter);
         }
     }
 
     @Override
-    public ViewPropertyAnimator x(float value) {
+    public ViewPropertyAnimator x(float value)
+    {
         animateProperty(X, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator xBy(float value) {
+    public ViewPropertyAnimator xBy(float value)
+    {
         animatePropertyBy(X, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator y(float value) {
+    public ViewPropertyAnimator y(float value)
+    {
         animateProperty(Y, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator yBy(float value) {
+    public ViewPropertyAnimator yBy(float value)
+    {
         animatePropertyBy(Y, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotation(float value) {
+    public ViewPropertyAnimator rotation(float value)
+    {
         animateProperty(ROTATION, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotationBy(float value) {
+    public ViewPropertyAnimator rotationBy(float value)
+    {
         animatePropertyBy(ROTATION, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotationX(float value) {
+    public ViewPropertyAnimator rotationX(float value)
+    {
         animateProperty(ROTATION_X, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotationXBy(float value) {
+    public ViewPropertyAnimator rotationXBy(float value)
+    {
         animatePropertyBy(ROTATION_X, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotationY(float value) {
+    public ViewPropertyAnimator rotationY(float value)
+    {
         animateProperty(ROTATION_Y, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotationYBy(float value) {
+    public ViewPropertyAnimator rotationYBy(float value)
+    {
         animatePropertyBy(ROTATION_Y, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator translationX(float value) {
+    public ViewPropertyAnimator translationX(float value)
+    {
         animateProperty(TRANSLATION_X, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator translationXBy(float value) {
+    public ViewPropertyAnimator translationXBy(float value)
+    {
         animatePropertyBy(TRANSLATION_X, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator translationY(float value) {
+    public ViewPropertyAnimator translationY(float value)
+    {
         animateProperty(TRANSLATION_Y, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator translationYBy(float value) {
+    public ViewPropertyAnimator translationYBy(float value)
+    {
         animatePropertyBy(TRANSLATION_Y, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator scaleX(float value) {
+    public ViewPropertyAnimator scaleX(float value)
+    {
         animateProperty(SCALE_X, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator scaleXBy(float value) {
+    public ViewPropertyAnimator scaleXBy(float value)
+    {
         animatePropertyBy(SCALE_X, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator scaleY(float value) {
+    public ViewPropertyAnimator scaleY(float value)
+    {
         animateProperty(SCALE_Y, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator scaleYBy(float value) {
+    public ViewPropertyAnimator scaleYBy(float value)
+    {
         animatePropertyBy(SCALE_Y, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator alpha(float value) {
+    public ViewPropertyAnimator alpha(float value)
+    {
         animateProperty(ALPHA, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator alphaBy(float value) {
+    public ViewPropertyAnimator alphaBy(float value)
+    {
         animatePropertyBy(ALPHA, value);
         return this;
     }
@@ -425,27 +402,32 @@ public ViewPropertyAnimator alphaBy(float value) {
      * simply runs from 0 to 1, and then use that fractional value to set each property
      * value accordingly.
      */
-    private void startAnimation() {
+    private void startAnimation()
+    {
         ValueAnimator animator = ValueAnimator.ofFloat(1.0f);
         ArrayList<NameValuesHolder> nameValueList =
                 (ArrayList<NameValuesHolder>) mPendingAnimations.clone();
         mPendingAnimations.clear();
         int propertyMask = 0;
         int propertyCount = nameValueList.size();
-        for (int i = 0; i < propertyCount; ++i) {
+        for (int i = 0; i < propertyCount; ++i)
+        {
             NameValuesHolder nameValuesHolder = nameValueList.get(i);
             propertyMask |= nameValuesHolder.mNameConstant;
         }
         mAnimatorMap.put(animator, new PropertyBundle(propertyMask, nameValueList));
         animator.addUpdateListener(mAnimatorEventListener);
         animator.addListener(mAnimatorEventListener);
-        if (mStartDelaySet) {
+        if (mStartDelaySet)
+        {
             animator.setStartDelay(mStartDelay);
         }
-        if (mDurationSet) {
+        if (mDurationSet)
+        {
             animator.setDuration(mDuration);
         }
-        if (mInterpolatorSet) {
+        if (mInterpolatorSet)
+        {
             animator.setInterpolator(mInterpolator);
         }
         animator.start();
@@ -461,9 +443,10 @@ private void startAnimation() {
      * specified at one time).
      *
      * @param constantName The specifier for the property being animated
-     * @param toValue The value to which the property will animate
+     * @param toValue      The value to which the property will animate
      */
-    private void animateProperty(int constantName, float toValue) {
+    private void animateProperty(int constantName, float toValue)
+    {
         float fromValue = getValue(constantName);
         float deltaValue = toValue - fromValue;
         animatePropertyBy(constantName, fromValue, deltaValue);
@@ -475,9 +458,10 @@ private void animateProperty(int constantName, float toValue) {
      * current value, instead of an absolute "to" value.
      *
      * @param constantName The specifier for the property being animated
-     * @param byValue The amount by which the property will change
+     * @param byValue      The amount by which the property will change
      */
-    private void animatePropertyBy(int constantName, float byValue) {
+    private void animatePropertyBy(int constantName, float byValue)
+    {
         float fromValue = getValue(constantName);
         animatePropertyBy(constantName, fromValue, byValue);
     }
@@ -487,29 +471,35 @@ private void animatePropertyBy(int constantName, float byValue) {
      * details of adding a pending animation and posting the request to start the animation.
      *
      * @param constantName The specifier for the property being animated
-     * @param startValue The starting value of the property
-     * @param byValue The amount by which the property will change
+     * @param startValue   The starting value of the property
+     * @param byValue      The amount by which the property will change
      */
-    private void animatePropertyBy(int constantName, float startValue, float byValue) {
+    private void animatePropertyBy(int constantName, float startValue, float byValue)
+    {
         // First, cancel any existing animations on this property
-        if (mAnimatorMap.size() > 0) {
+        if (mAnimatorMap.size() > 0)
+        {
             Animator animatorToCancel = null;
             Set<Animator> animatorSet = mAnimatorMap.keySet();
-            for (Animator runningAnim : animatorSet) {
+            for (Animator runningAnim : animatorSet)
+            {
                 PropertyBundle bundle = mAnimatorMap.get(runningAnim);
-                if (bundle.cancel(constantName)) {
+                if (bundle.cancel(constantName))
+                {
                     // property was canceled - cancel the animation if it's now empty
                     // Note that it's safe to break out here because every new animation
                     // on a property will cancel a previous animation on that property, so
                     // there can only ever be one such animation running.
-                    if (bundle.mPropertyMask == NONE) {
+                    if (bundle.mPropertyMask == NONE)
+                    {
                         // the animation is no longer changing anything - cancel it
                         animatorToCancel = runningAnim;
                         break;
                     }
                 }
             }
-            if (animatorToCancel != null) {
+            if (animatorToCancel != null)
+            {
                 animatorToCancel.cancel();
             }
         }
@@ -517,7 +507,8 @@ private void animatePropertyBy(int constantName, float startValue, float byValue
         NameValuesHolder nameValuePair = new NameValuesHolder(constantName, startValue, byValue);
         mPendingAnimations.add(nameValuePair);
         View v = mView.get();
-        if (v != null) {
+        if (v != null)
+        {
             v.removeCallbacks(mAnimationStarter);
             v.post(mAnimationStarter);
         }
@@ -529,13 +520,16 @@ private void animatePropertyBy(int constantName, float startValue, float byValue
      * the property to.
      *
      * @param propertyConstant The property to be set
-     * @param value The value to set the property to
+     * @param value            The value to set the property to
      */
-    private void setValue(int propertyConstant, float value) {
+    private void setValue(int propertyConstant, float value)
+    {
         //final View.TransformationInfo info = mView.mTransformationInfo;
         View v = mView.get();
-        if (v != null) {
-            switch (propertyConstant) {
+        if (v != null)
+        {
+            switch (propertyConstant)
+            {
                 case TRANSLATION_X:
                     //info.mTranslationX = value;
                     v.setTranslationX(value);
@@ -586,11 +580,14 @@ private void setValue(int propertyConstant, float value) {
      * @param propertyConstant The property whose value should be returned
      * @return float The value of the named property
      */
-    private float getValue(int propertyConstant) {
+    private float getValue(int propertyConstant)
+    {
         //final View.TransformationInfo info = mView.mTransformationInfo;
         View v = mView.get();
-        if (v != null) {
-            switch (propertyConstant) {
+        if (v != null)
+        {
+            switch (propertyConstant)
+            {
                 case TRANSLATION_X:
                     //return info.mTranslationX;
                     return v.getTranslationX();
@@ -626,6 +623,72 @@ private float getValue(int propertyConstant) {
         return 0;
     }
 
+    /**
+     * This class holds information about the overall animation being run on the set of
+     * properties. The mask describes which properties are being animated and the
+     * values holder is the list of all property/value objects.
+     */
+    private static class PropertyBundle
+    {
+        int mPropertyMask;
+        ArrayList<NameValuesHolder> mNameValuesHolder;
+
+        PropertyBundle(int propertyMask, ArrayList<NameValuesHolder> nameValuesHolder)
+        {
+            mPropertyMask = propertyMask;
+            mNameValuesHolder = nameValuesHolder;
+        }
+
+        /**
+         * Removes the given property from being animated as a part of this
+         * PropertyBundle. If the property was a part of this bundle, it returns
+         * true to indicate that it was, in fact, canceled. This is an indication
+         * to the caller that a cancellation actually occurred.
+         *
+         * @param propertyConstant The property whose cancellation is requested.
+         * @return true if the given property is a part of this bundle and if it
+         * has therefore been canceled.
+         */
+        boolean cancel(int propertyConstant)
+        {
+            if ((mPropertyMask & propertyConstant) != 0 && mNameValuesHolder != null)
+            {
+                int count = mNameValuesHolder.size();
+                for (int i = 0; i < count; ++i)
+                {
+                    NameValuesHolder nameValuesHolder = mNameValuesHolder.get(i);
+                    if (nameValuesHolder.mNameConstant == propertyConstant)
+                    {
+                        mNameValuesHolder.remove(i);
+                        mPropertyMask &= ~propertyConstant;
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+    }
+
+    /**
+     * This is the information we need to set each property during the animation.
+     * mNameConstant is used to set the appropriate field in View, and the from/delta
+     * values are used to calculate the animated value for a given animation fraction
+     * during the animation.
+     */
+    private static class NameValuesHolder
+    {
+        int mNameConstant;
+        float mFromValue;
+        float mDeltaValue;
+
+        NameValuesHolder(int nameConstant, float fromValue, float deltaValue)
+        {
+            mNameConstant = nameConstant;
+            mFromValue = fromValue;
+            mDeltaValue = deltaValue;
+        }
+    }
+
     /**
      * Utility class that handles the various Animator events. The only ones we care
      * about are the end event (which we use to clean up the animator map when an animator
@@ -633,38 +696,48 @@ private float getValue(int propertyConstant) {
      * property and then set it on the view object).
      */
     private class AnimatorEventListener
-            implements Animator.AnimatorListener, ValueAnimator.AnimatorUpdateListener {
+            implements Animator.AnimatorListener, ValueAnimator.AnimatorUpdateListener
+    {
         @Override
-        public void onAnimationStart(Animator animation) {
-            if (mListener != null) {
+        public void onAnimationStart(Animator animation)
+        {
+            if (mListener != null)
+            {
                 mListener.onAnimationStart(animation);
             }
         }
 
         @Override
-        public void onAnimationCancel(Animator animation) {
-            if (mListener != null) {
+        public void onAnimationCancel(Animator animation)
+        {
+            if (mListener != null)
+            {
                 mListener.onAnimationCancel(animation);
             }
         }
 
         @Override
-        public void onAnimationRepeat(Animator animation) {
-            if (mListener != null) {
+        public void onAnimationRepeat(Animator animation)
+        {
+            if (mListener != null)
+            {
                 mListener.onAnimationRepeat(animation);
             }
         }
 
         @Override
-        public void onAnimationEnd(Animator animation) {
-            if (mListener != null) {
+        public void onAnimationEnd(Animator animation)
+        {
+            if (mListener != null)
+            {
                 mListener.onAnimationEnd(animation);
             }
             mAnimatorMap.remove(animation);
             // If the map is empty, it means all animation are done or canceled, so the listener
             // isn't needed anymore. Not nulling it would cause it to leak any objects used in
             // its implementation
-            if (mAnimatorMap.isEmpty()) {
+            if (mAnimatorMap.isEmpty())
+            {
                 mListener = null;
             }
         }
@@ -674,11 +747,12 @@ public void onAnimationEnd(Animator animation) {
          * the view object appropriately, depending on which properties are being animated.
          *
          * @param animation The animator associated with the properties that need to be
-         * set. This animator holds the animation fraction which we will use to calculate
-         * the current value of each property.
+         *                  set. This animator holds the animation fraction which we will use to calculate
+         *                  the current value of each property.
          */
         @Override
-        public void onAnimationUpdate(ValueAnimator animation) {
+        public void onAnimationUpdate(ValueAnimator animation)
+        {
             // alpha requires slightly different treatment than the other (transform) properties.
             // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
             // logic is dependent on how the view handles an internal call to onSetAlpha().
@@ -689,22 +763,26 @@ public void onAnimationUpdate(ValueAnimator animation) {
             float fraction = animation.getAnimatedFraction();
             PropertyBundle propertyBundle = mAnimatorMap.get(animation);
             int propertyMask = propertyBundle.mPropertyMask;
-            if ((propertyMask & TRANSFORM_MASK) != 0) {
+            if ((propertyMask & TRANSFORM_MASK) != 0)
+            {
                 View v = mView.get();
-                if (v != null) {
+                if (v != null)
+                {
                     v.invalidate(/*false*/);
                 }
             }
             ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
-            if (valueList != null) {
+            if (valueList != null)
+            {
                 int count = valueList.size();
-                for (int i = 0; i < count; ++i) {
+                for (int i = 0; i < count; ++i)
+                {
                     NameValuesHolder values = valueList.get(i);
                     float value = values.mFromValue + fraction * values.mDeltaValue;
                     //if (values.mNameConstant == ALPHA) {
                     //    alphaHandled = mView.setAlphaNoInvalidation(value);
                     //} else {
-                        setValue(values.mNameConstant, value);
+                    setValue(values.mNameConstant, value);
                     //}
                 }
             }
@@ -715,7 +793,8 @@ public void onAnimationUpdate(ValueAnimator animation) {
             // invalidate(false) in all cases except if alphaHandled gets set to true
             // via the call to setAlphaNoInvalidation(), above
             View v = mView.get();
-            if (v != null) {
+            if (v != null)
+            {
                 v.invalidate(/*alphaHandled*/);
             }
         }
diff --git a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorICS.java b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorICS.java
index b60a820..19b8afe 100644
--- a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorICS.java
+++ b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorICS.java
@@ -1,12 +1,13 @@
 package com.nineoldandroids.view;
 
-import java.lang.ref.WeakReference;
-
 import android.view.View;
 import android.view.animation.Interpolator;
 import com.nineoldandroids.animation.Animator.AnimatorListener;
 
-class ViewPropertyAnimatorICS extends ViewPropertyAnimator {
+import java.lang.ref.WeakReference;
+
+class ViewPropertyAnimatorICS extends ViewPropertyAnimator
+{
     /**
      * A value to be returned when the WeakReference holding the native implementation
      * returns <code>null</code>
@@ -18,80 +19,101 @@
      */
     private final WeakReference<android.view.ViewPropertyAnimator> mNative;
 
-    ViewPropertyAnimatorICS(View view) {
+    ViewPropertyAnimatorICS(View view)
+    {
         mNative = new WeakReference<android.view.ViewPropertyAnimator>(view.animate());
     }
 
     @Override
-    public ViewPropertyAnimator setDuration(long duration) {
+    public ViewPropertyAnimator setDuration(long duration)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.setDuration(duration);
         }
         return this;
     }
 
     @Override
-    public long getDuration() {
+    public long getDuration()
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             return n.getDuration();
         }
         return RETURN_WHEN_NULL;
     }
 
     @Override
-    public ViewPropertyAnimator setStartDelay(long startDelay) {
+    public ViewPropertyAnimator setStartDelay(long startDelay)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.setStartDelay(startDelay);
         }
         return this;
     }
 
     @Override
-    public long getStartDelay() {
+    public long getStartDelay()
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             return n.getStartDelay();
         }
         return RETURN_WHEN_NULL;
     }
 
     @Override
-    public ViewPropertyAnimator setInterpolator(Interpolator interpolator) {
+    public ViewPropertyAnimator setInterpolator(Interpolator interpolator)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.setInterpolator(interpolator);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator setListener(final AnimatorListener listener) {
+    public ViewPropertyAnimator setListener(final AnimatorListener listener)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
-            if (listener == null) {
+        if (n != null)
+        {
+            if (listener == null)
+            {
                 n.setListener(null);
-            } else {
-                n.setListener(new android.animation.Animator.AnimatorListener() {
+            }
+            else
+            {
+                n.setListener(new android.animation.Animator.AnimatorListener()
+                {
                     @Override
-                    public void onAnimationStart(android.animation.Animator animation) {
+                    public void onAnimationStart(android.animation.Animator animation)
+                    {
                         listener.onAnimationStart(null);
                     }
 
                     @Override
-                    public void onAnimationRepeat(android.animation.Animator animation) {
+                    public void onAnimationRepeat(android.animation.Animator animation)
+                    {
                         listener.onAnimationRepeat(null);
                     }
 
                     @Override
-                    public void onAnimationEnd(android.animation.Animator animation) {
+                    public void onAnimationEnd(android.animation.Animator animation)
+                    {
                         listener.onAnimationEnd(null);
                     }
 
                     @Override
-                    public void onAnimationCancel(android.animation.Animator animation) {
+                    public void onAnimationCancel(android.animation.Animator animation)
+                    {
                         listener.onAnimationCancel(null);
                     }
                 });
@@ -101,196 +123,240 @@ public void onAnimationCancel(android.animation.Animator animation) {
     }
 
     @Override
-    public void start() {
+    public void start()
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.start();
         }
     }
 
     @Override
-    public void cancel() {
+    public void cancel()
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.cancel();
         }
     }
 
     @Override
-    public ViewPropertyAnimator x(float value) {
+    public ViewPropertyAnimator x(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.x(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator xBy(float value) {
+    public ViewPropertyAnimator xBy(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.xBy(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator y(float value) {
+    public ViewPropertyAnimator y(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.y(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator yBy(float value) {
+    public ViewPropertyAnimator yBy(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.yBy(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotation(float value) {
+    public ViewPropertyAnimator rotation(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.rotation(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotationBy(float value) {
+    public ViewPropertyAnimator rotationBy(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.rotationBy(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotationX(float value) {
+    public ViewPropertyAnimator rotationX(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.rotationX(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotationXBy(float value) {
+    public ViewPropertyAnimator rotationXBy(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.rotationXBy(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotationY(float value) {
+    public ViewPropertyAnimator rotationY(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.rotationY(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotationYBy(float value) {
+    public ViewPropertyAnimator rotationYBy(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.rotationYBy(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator translationX(float value) {
+    public ViewPropertyAnimator translationX(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.translationX(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator translationXBy(float value) {
+    public ViewPropertyAnimator translationXBy(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.translationXBy(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator translationY(float value) {
+    public ViewPropertyAnimator translationY(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.translationY(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator translationYBy(float value) {
+    public ViewPropertyAnimator translationYBy(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.translationYBy(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator scaleX(float value) {
+    public ViewPropertyAnimator scaleX(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.scaleX(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator scaleXBy(float value) {
+    public ViewPropertyAnimator scaleXBy(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.scaleXBy(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator scaleY(float value) {
+    public ViewPropertyAnimator scaleY(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.scaleY(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator scaleYBy(float value) {
+    public ViewPropertyAnimator scaleYBy(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.scaleYBy(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator alpha(float value) {
+    public ViewPropertyAnimator alpha(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.alpha(value);
         }
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator alphaBy(float value) {
+    public ViewPropertyAnimator alphaBy(float value)
+    {
         android.view.ViewPropertyAnimator n = mNative.get();
-        if (n != null) {
+        if (n != null)
+        {
             n.alphaBy(value);
         }
         return this;
diff --git a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorPreHC.java b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorPreHC.java
index c170f6d..ecd4d23 100644
--- a/library/src/com/nineoldandroids/view/ViewPropertyAnimatorPreHC.java
+++ b/library/src/com/nineoldandroids/view/ViewPropertyAnimatorPreHC.java
@@ -16,109 +16,98 @@
 
 package com.nineoldandroids.view;
 
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Set;
 import android.view.View;
 import android.view.animation.Interpolator;
 import com.nineoldandroids.animation.Animator;
 import com.nineoldandroids.animation.ValueAnimator;
 import com.nineoldandroids.view.animation.AnimatorProxy;
 
-class ViewPropertyAnimatorPreHC extends ViewPropertyAnimator {
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Set;
+
+class ViewPropertyAnimatorPreHC extends ViewPropertyAnimator
+{
+    /**
+     * Constants used to associate a property being requested and the mechanism used to set
+     * the property (this class calls directly into View to set the properties in question).
+     */
+    private static final int NONE = 0x0000;
+    private static final int TRANSLATION_X = 0x0001;
+    private static final int TRANSLATION_Y = 0x0002;
+    private static final int SCALE_X = 0x0004;
+    private static final int SCALE_Y = 0x0008;
+    private static final int ROTATION = 0x0010;
+    private static final int ROTATION_X = 0x0020;
+    private static final int ROTATION_Y = 0x0040;
+    private static final int X = 0x0080;
+    private static final int Y = 0x0100;
+    private static final int TRANSFORM_MASK = TRANSLATION_X | TRANSLATION_Y | SCALE_X | SCALE_Y |
+            ROTATION | ROTATION_X | ROTATION_Y | X | Y;
+    private static final int ALPHA = 0x0200;
     /**
      * Proxy animation class which will allow us access to post-Honeycomb properties that were not
      * otherwise available.
      */
     private final AnimatorProxy mProxy;
-
     /**
      * A WeakReference holding the View whose properties are being animated by this class. This is
      * set at construction time.
      */
     private final WeakReference<View> mView;
-
+    /**
+     * This list holds the properties that have been asked to animate. We allow the caller to
+     * request several animations prior to actually starting the underlying animator. This
+     * enables us to run one single animator to handle several properties in parallel. Each
+     * property is tossed onto the pending list until the animation actually starts (which is
+     * done by posting it onto mView), at which time the pending list is cleared and the properties
+     * on that list are added to the list of properties associated with that animator.
+     */
+    ArrayList<NameValuesHolder> mPendingAnimations = new ArrayList<NameValuesHolder>();
     /**
      * The duration of the underlying Animator object. By default, we don't set the duration
      * on the Animator and just use its default duration. If the duration is ever set on this
      * Animator, then we use the duration that it was set to.
      */
     private long mDuration;
-
     /**
      * A flag indicating whether the duration has been set on this object. If not, we don't set
      * the duration on the underlying Animator, but instead just use its default duration.
      */
     private boolean mDurationSet = false;
-
     /**
      * The startDelay of the underlying Animator object. By default, we don't set the startDelay
      * on the Animator and just use its default startDelay. If the startDelay is ever set on this
      * Animator, then we use the startDelay that it was set to.
      */
     private long mStartDelay = 0;
-
     /**
      * A flag indicating whether the startDelay has been set on this object. If not, we don't set
      * the startDelay on the underlying Animator, but instead just use its default startDelay.
      */
     private boolean mStartDelaySet = false;
-
     /**
      * The interpolator of the underlying Animator object. By default, we don't set the interpolator
      * on the Animator and just use its default interpolator. If the interpolator is ever set on
      * this Animator, then we use the interpolator that it was set to.
      */
-    private /*Time*/Interpolator mInterpolator;
-
+    private /*Time*/ Interpolator mInterpolator;
     /**
      * A flag indicating whether the interpolator has been set on this object. If not, we don't set
      * the interpolator on the underlying Animator, but instead just use its default interpolator.
      */
     private boolean mInterpolatorSet = false;
-
     /**
      * Listener for the lifecycle events of the underlying
      */
     private Animator.AnimatorListener mListener = null;
-
     /**
      * This listener is the mechanism by which the underlying Animator causes changes to the
      * properties currently being animated, as well as the cleanup after an animation is
      * complete.
      */
     private AnimatorEventListener mAnimatorEventListener = new AnimatorEventListener();
-
-    /**
-     * This list holds the properties that have been asked to animate. We allow the caller to
-     * request several animations prior to actually starting the underlying animator. This
-     * enables us to run one single animator to handle several properties in parallel. Each
-     * property is tossed onto the pending list until the animation actually starts (which is
-     * done by posting it onto mView), at which time the pending list is cleared and the properties
-     * on that list are added to the list of properties associated with that animator.
-     */
-    ArrayList<NameValuesHolder> mPendingAnimations = new ArrayList<NameValuesHolder>();
-
-    /**
-     * Constants used to associate a property being requested and the mechanism used to set
-     * the property (this class calls directly into View to set the properties in question).
-     */
-    private static final int NONE           = 0x0000;
-    private static final int TRANSLATION_X  = 0x0001;
-    private static final int TRANSLATION_Y  = 0x0002;
-    private static final int SCALE_X        = 0x0004;
-    private static final int SCALE_Y        = 0x0008;
-    private static final int ROTATION       = 0x0010;
-    private static final int ROTATION_X     = 0x0020;
-    private static final int ROTATION_Y     = 0x0040;
-    private static final int X              = 0x0080;
-    private static final int Y              = 0x0100;
-    private static final int ALPHA          = 0x0200;
-
-    private static final int TRANSFORM_MASK = TRANSLATION_X | TRANSLATION_Y | SCALE_X | SCALE_Y |
-            ROTATION | ROTATION_X | ROTATION_Y | X | Y;
-
     /**
      * The mechanism by which the user can request several properties that are then animated
      * together works by posting this Runnable to start the underlying Animator. Every time
@@ -127,53 +116,14 @@
      * underlying animator) after the caller is done setting the properties that should be
      * animated together.
      */
-    private Runnable mAnimationStarter = new Runnable() {
+    private Runnable mAnimationStarter = new Runnable()
+    {
         @Override
-        public void run() {
+        public void run()
+        {
             startAnimation();
         }
     };
-
-    /**
-     * This class holds information about the overall animation being run on the set of
-     * properties. The mask describes which properties are being animated and the
-     * values holder is the list of all property/value objects.
-     */
-    private static class PropertyBundle {
-        int mPropertyMask;
-        ArrayList<NameValuesHolder> mNameValuesHolder;
-
-        PropertyBundle(int propertyMask, ArrayList<NameValuesHolder> nameValuesHolder) {
-            mPropertyMask = propertyMask;
-            mNameValuesHolder = nameValuesHolder;
-        }
-
-        /**
-         * Removes the given property from being animated as a part of this
-         * PropertyBundle. If the property was a part of this bundle, it returns
-         * true to indicate that it was, in fact, canceled. This is an indication
-         * to the caller that a cancellation actually occurred.
-         *
-         * @param propertyConstant The property whose cancellation is requested.
-         * @return true if the given property is a part of this bundle and if it
-         * has therefore been canceled.
-         */
-        boolean cancel(int propertyConstant) {
-            if ((mPropertyMask & propertyConstant) != 0 && mNameValuesHolder != null) {
-                int count = mNameValuesHolder.size();
-                for (int i = 0; i < count; ++i) {
-                    NameValuesHolder nameValuesHolder = mNameValuesHolder.get(i);
-                    if (nameValuesHolder.mNameConstant == propertyConstant) {
-                        mNameValuesHolder.remove(i);
-                        mPropertyMask &= ~propertyConstant;
-                        return true;
-                    }
-                }
-            }
-            return false;
-        }
-    }
-
     /**
      * This list tracks the list of properties being animated by any particular animator.
      * In most situations, there would only ever be one animator running at a time. But it is
@@ -186,30 +136,14 @@ boolean cancel(int propertyConstant) {
     private HashMap<Animator, PropertyBundle> mAnimatorMap =
             new HashMap<Animator, PropertyBundle>();
 
-    /**
-     * This is the information we need to set each property during the animation.
-     * mNameConstant is used to set the appropriate field in View, and the from/delta
-     * values are used to calculate the animated value for a given animation fraction
-     * during the animation.
-     */
-    private static class NameValuesHolder {
-        int mNameConstant;
-        float mFromValue;
-        float mDeltaValue;
-        NameValuesHolder(int nameConstant, float fromValue, float deltaValue) {
-            mNameConstant = nameConstant;
-            mFromValue = fromValue;
-            mDeltaValue = deltaValue;
-        }
-    }
-
     /**
      * Constructor, called by View. This is private by design, as the user should only
      * get a ViewPropertyAnimator by calling View.animate().
      *
      * @param view The View associated with this ViewPropertyAnimator
      */
-    ViewPropertyAnimatorPreHC(View view) {
+    ViewPropertyAnimatorPreHC(View view)
+    {
         mView = new WeakReference<View>(view);
         mProxy = AnimatorProxy.wrap(view);
     }
@@ -218,14 +152,17 @@ boolean cancel(int propertyConstant) {
      * Sets the duration for the underlying animator that animates the requested properties.
      * By default, the animator uses the default value for ValueAnimator. Calling this method
      * will cause the declared value to be used instead.
+     *
      * @param duration The length of ensuing property animations, in milliseconds. The value
-     * cannot be negative.
+     *                 cannot be negative.
      * @return This object, allowing calls to methods in this class to be chained.
      */
-    public ViewPropertyAnimator setDuration(long duration) {
-        if (duration < 0) {
+    public ViewPropertyAnimator setDuration(long duration)
+    {
+        if (duration < 0)
+        {
             throw new IllegalArgumentException("Animators cannot have negative duration: " +
-                    duration);
+                                                       duration);
         }
         mDurationSet = true;
         mDuration = duration;
@@ -237,13 +174,17 @@ public ViewPropertyAnimator setDuration(long duration) {
      * object, that value is returned. Otherwise, the default value of the underlying Animator
      * is returned.
      *
-     * @see #setDuration(long)
      * @return The duration of animations, in milliseconds.
+     * @see #setDuration(long)
      */
-    public long getDuration() {
-        if (mDurationSet) {
+    public long getDuration()
+    {
+        if (mDurationSet)
+        {
             return mDuration;
-        } else {
+        }
+        else
+        {
             // Just return the default from ValueAnimator, since that's what we'd get if
             // the value has not been set otherwise
             return new ValueAnimator().getDuration();
@@ -251,10 +192,14 @@ public long getDuration() {
     }
 
     @Override
-    public long getStartDelay() {
-        if (mStartDelaySet) {
+    public long getStartDelay()
+    {
+        if (mStartDelaySet)
+        {
             return mStartDelay;
-        } else {
+        }
+        else
+        {
             // Just return the default from ValueAnimator (0), since that's what we'd get if
             // the value has not been set otherwise
             return 0;
@@ -262,10 +207,12 @@ public long getStartDelay() {
     }
 
     @Override
-    public ViewPropertyAnimator setStartDelay(long startDelay) {
-        if (startDelay < 0) {
+    public ViewPropertyAnimator setStartDelay(long startDelay)
+    {
+        if (startDelay < 0)
+        {
             throw new IllegalArgumentException("Animators cannot have negative duration: " +
-                    startDelay);
+                                                       startDelay);
         }
         mStartDelaySet = true;
         mStartDelay = startDelay;
@@ -273,156 +220,183 @@ public ViewPropertyAnimator setStartDelay(long startDelay) {
     }
 
     @Override
-    public ViewPropertyAnimator setInterpolator(/*Time*/Interpolator interpolator) {
+    public ViewPropertyAnimator setInterpolator(/*Time*/Interpolator interpolator)
+    {
         mInterpolatorSet = true;
         mInterpolator = interpolator;
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator setListener(Animator.AnimatorListener listener) {
+    public ViewPropertyAnimator setListener(Animator.AnimatorListener listener)
+    {
         mListener = listener;
         return this;
     }
 
     @Override
-    public void start() {
+    public void start()
+    {
         startAnimation();
     }
 
     @Override
-    public void cancel() {
-        if (mAnimatorMap.size() > 0) {
+    public void cancel()
+    {
+        if (mAnimatorMap.size() > 0)
+        {
             HashMap<Animator, PropertyBundle> mAnimatorMapCopy =
-                    (HashMap<Animator, PropertyBundle>)mAnimatorMap.clone();
+                    (HashMap<Animator, PropertyBundle>) mAnimatorMap.clone();
             Set<Animator> animatorSet = mAnimatorMapCopy.keySet();
-            for (Animator runningAnim : animatorSet) {
+            for (Animator runningAnim : animatorSet)
+            {
                 runningAnim.cancel();
             }
         }
         mPendingAnimations.clear();
         View v = mView.get();
-        if (v != null) {
+        if (v != null)
+        {
             v.removeCallbacks(mAnimationStarter);
         }
     }
 
     @Override
-    public ViewPropertyAnimator x(float value) {
+    public ViewPropertyAnimator x(float value)
+    {
         animateProperty(X, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator xBy(float value) {
+    public ViewPropertyAnimator xBy(float value)
+    {
         animatePropertyBy(X, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator y(float value) {
+    public ViewPropertyAnimator y(float value)
+    {
         animateProperty(Y, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator yBy(float value) {
+    public ViewPropertyAnimator yBy(float value)
+    {
         animatePropertyBy(Y, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotation(float value) {
+    public ViewPropertyAnimator rotation(float value)
+    {
         animateProperty(ROTATION, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotationBy(float value) {
+    public ViewPropertyAnimator rotationBy(float value)
+    {
         animatePropertyBy(ROTATION, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotationX(float value) {
+    public ViewPropertyAnimator rotationX(float value)
+    {
         animateProperty(ROTATION_X, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotationXBy(float value) {
+    public ViewPropertyAnimator rotationXBy(float value)
+    {
         animatePropertyBy(ROTATION_X, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotationY(float value) {
+    public ViewPropertyAnimator rotationY(float value)
+    {
         animateProperty(ROTATION_Y, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator rotationYBy(float value) {
+    public ViewPropertyAnimator rotationYBy(float value)
+    {
         animatePropertyBy(ROTATION_Y, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator translationX(float value) {
+    public ViewPropertyAnimator translationX(float value)
+    {
         animateProperty(TRANSLATION_X, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator translationXBy(float value) {
+    public ViewPropertyAnimator translationXBy(float value)
+    {
         animatePropertyBy(TRANSLATION_X, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator translationY(float value) {
+    public ViewPropertyAnimator translationY(float value)
+    {
         animateProperty(TRANSLATION_Y, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator translationYBy(float value) {
+    public ViewPropertyAnimator translationYBy(float value)
+    {
         animatePropertyBy(TRANSLATION_Y, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator scaleX(float value) {
+    public ViewPropertyAnimator scaleX(float value)
+    {
         animateProperty(SCALE_X, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator scaleXBy(float value) {
+    public ViewPropertyAnimator scaleXBy(float value)
+    {
         animatePropertyBy(SCALE_X, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator scaleY(float value) {
+    public ViewPropertyAnimator scaleY(float value)
+    {
         animateProperty(SCALE_Y, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator scaleYBy(float value) {
+    public ViewPropertyAnimator scaleYBy(float value)
+    {
         animatePropertyBy(SCALE_Y, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator alpha(float value) {
+    public ViewPropertyAnimator alpha(float value)
+    {
         animateProperty(ALPHA, value);
         return this;
     }
 
     @Override
-    public ViewPropertyAnimator alphaBy(float value) {
+    public ViewPropertyAnimator alphaBy(float value)
+    {
         animatePropertyBy(ALPHA, value);
         return this;
     }
@@ -432,27 +406,32 @@ public ViewPropertyAnimator alphaBy(float value) {
      * simply runs from 0 to 1, and then use that fractional value to set each property
      * value accordingly.
      */
-    private void startAnimation() {
+    private void startAnimation()
+    {
         ValueAnimator animator = ValueAnimator.ofFloat(1.0f);
         ArrayList<NameValuesHolder> nameValueList =
                 (ArrayList<NameValuesHolder>) mPendingAnimations.clone();
         mPendingAnimations.clear();
         int propertyMask = 0;
         int propertyCount = nameValueList.size();
-        for (int i = 0; i < propertyCount; ++i) {
+        for (int i = 0; i < propertyCount; ++i)
+        {
             NameValuesHolder nameValuesHolder = nameValueList.get(i);
             propertyMask |= nameValuesHolder.mNameConstant;
         }
         mAnimatorMap.put(animator, new PropertyBundle(propertyMask, nameValueList));
         animator.addUpdateListener(mAnimatorEventListener);
         animator.addListener(mAnimatorEventListener);
-        if (mStartDelaySet) {
+        if (mStartDelaySet)
+        {
             animator.setStartDelay(mStartDelay);
         }
-        if (mDurationSet) {
+        if (mDurationSet)
+        {
             animator.setDuration(mDuration);
         }
-        if (mInterpolatorSet) {
+        if (mInterpolatorSet)
+        {
             animator.setInterpolator(mInterpolator);
         }
         animator.start();
@@ -468,9 +447,10 @@ private void startAnimation() {
      * specified at one time).
      *
      * @param constantName The specifier for the property being animated
-     * @param toValue The value to which the property will animate
+     * @param toValue      The value to which the property will animate
      */
-    private void animateProperty(int constantName, float toValue) {
+    private void animateProperty(int constantName, float toValue)
+    {
         float fromValue = getValue(constantName);
         float deltaValue = toValue - fromValue;
         animatePropertyBy(constantName, fromValue, deltaValue);
@@ -482,9 +462,10 @@ private void animateProperty(int constantName, float toValue) {
      * current value, instead of an absolute "to" value.
      *
      * @param constantName The specifier for the property being animated
-     * @param byValue The amount by which the property will change
+     * @param byValue      The amount by which the property will change
      */
-    private void animatePropertyBy(int constantName, float byValue) {
+    private void animatePropertyBy(int constantName, float byValue)
+    {
         float fromValue = getValue(constantName);
         animatePropertyBy(constantName, fromValue, byValue);
     }
@@ -494,29 +475,35 @@ private void animatePropertyBy(int constantName, float byValue) {
      * details of adding a pending animation and posting the request to start the animation.
      *
      * @param constantName The specifier for the property being animated
-     * @param startValue The starting value of the property
-     * @param byValue The amount by which the property will change
+     * @param startValue   The starting value of the property
+     * @param byValue      The amount by which the property will change
      */
-    private void animatePropertyBy(int constantName, float startValue, float byValue) {
+    private void animatePropertyBy(int constantName, float startValue, float byValue)
+    {
         // First, cancel any existing animations on this property
-        if (mAnimatorMap.size() > 0) {
+        if (mAnimatorMap.size() > 0)
+        {
             Animator animatorToCancel = null;
             Set<Animator> animatorSet = mAnimatorMap.keySet();
-            for (Animator runningAnim : animatorSet) {
+            for (Animator runningAnim : animatorSet)
+            {
                 PropertyBundle bundle = mAnimatorMap.get(runningAnim);
-                if (bundle.cancel(constantName)) {
+                if (bundle.cancel(constantName))
+                {
                     // property was canceled - cancel the animation if it's now empty
                     // Note that it's safe to break out here because every new animation
                     // on a property will cancel a previous animation on that property, so
                     // there can only ever be one such animation running.
-                    if (bundle.mPropertyMask == NONE) {
+                    if (bundle.mPropertyMask == NONE)
+                    {
                         // the animation is no longer changing anything - cancel it
                         animatorToCancel = runningAnim;
                         break;
                     }
                 }
             }
-            if (animatorToCancel != null) {
+            if (animatorToCancel != null)
+            {
                 animatorToCancel.cancel();
             }
         }
@@ -524,7 +511,8 @@ private void animatePropertyBy(int constantName, float startValue, float byValue
         NameValuesHolder nameValuePair = new NameValuesHolder(constantName, startValue, byValue);
         mPendingAnimations.add(nameValuePair);
         View v = mView.get();
-        if (v != null) {
+        if (v != null)
+        {
             v.removeCallbacks(mAnimationStarter);
             v.post(mAnimationStarter);
         }
@@ -536,11 +524,13 @@ private void animatePropertyBy(int constantName, float startValue, float byValue
      * the property to.
      *
      * @param propertyConstant The property to be set
-     * @param value The value to set the property to
+     * @param value            The value to set the property to
      */
-    private void setValue(int propertyConstant, float value) {
+    private void setValue(int propertyConstant, float value)
+    {
         //final View.TransformationInfo info = mView.mTransformationInfo;
-        switch (propertyConstant) {
+        switch (propertyConstant)
+        {
             case TRANSLATION_X:
                 //info.mTranslationX = value;
                 mProxy.setTranslationX(value);
@@ -590,9 +580,11 @@ private void setValue(int propertyConstant, float value) {
      * @param propertyConstant The property whose value should be returned
      * @return float The value of the named property
      */
-    private float getValue(int propertyConstant) {
+    private float getValue(int propertyConstant)
+    {
         //final View.TransformationInfo info = mView.mTransformationInfo;
-        switch (propertyConstant) {
+        switch (propertyConstant)
+        {
             case TRANSLATION_X:
                 //return info.mTranslationX;
                 return mProxy.getTranslationX();
@@ -627,6 +619,72 @@ private float getValue(int propertyConstant) {
         return 0;
     }
 
+    /**
+     * This class holds information about the overall animation being run on the set of
+     * properties. The mask describes which properties are being animated and the
+     * values holder is the list of all property/value objects.
+     */
+    private static class PropertyBundle
+    {
+        int mPropertyMask;
+        ArrayList<NameValuesHolder> mNameValuesHolder;
+
+        PropertyBundle(int propertyMask, ArrayList<NameValuesHolder> nameValuesHolder)
+        {
+            mPropertyMask = propertyMask;
+            mNameValuesHolder = nameValuesHolder;
+        }
+
+        /**
+         * Removes the given property from being animated as a part of this
+         * PropertyBundle. If the property was a part of this bundle, it returns
+         * true to indicate that it was, in fact, canceled. This is an indication
+         * to the caller that a cancellation actually occurred.
+         *
+         * @param propertyConstant The property whose cancellation is requested.
+         * @return true if the given property is a part of this bundle and if it
+         * has therefore been canceled.
+         */
+        boolean cancel(int propertyConstant)
+        {
+            if ((mPropertyMask & propertyConstant) != 0 && mNameValuesHolder != null)
+            {
+                int count = mNameValuesHolder.size();
+                for (int i = 0; i < count; ++i)
+                {
+                    NameValuesHolder nameValuesHolder = mNameValuesHolder.get(i);
+                    if (nameValuesHolder.mNameConstant == propertyConstant)
+                    {
+                        mNameValuesHolder.remove(i);
+                        mPropertyMask &= ~propertyConstant;
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+    }
+
+    /**
+     * This is the information we need to set each property during the animation.
+     * mNameConstant is used to set the appropriate field in View, and the from/delta
+     * values are used to calculate the animated value for a given animation fraction
+     * during the animation.
+     */
+    private static class NameValuesHolder
+    {
+        int mNameConstant;
+        float mFromValue;
+        float mDeltaValue;
+
+        NameValuesHolder(int nameConstant, float fromValue, float deltaValue)
+        {
+            mNameConstant = nameConstant;
+            mFromValue = fromValue;
+            mDeltaValue = deltaValue;
+        }
+    }
+
     /**
      * Utility class that handles the various Animator events. The only ones we care
      * about are the end event (which we use to clean up the animator map when an animator
@@ -634,38 +692,48 @@ private float getValue(int propertyConstant) {
      * property and then set it on the view object).
      */
     private class AnimatorEventListener
-            implements Animator.AnimatorListener, ValueAnimator.AnimatorUpdateListener {
+            implements Animator.AnimatorListener, ValueAnimator.AnimatorUpdateListener
+    {
         @Override
-        public void onAnimationStart(Animator animation) {
-            if (mListener != null) {
+        public void onAnimationStart(Animator animation)
+        {
+            if (mListener != null)
+            {
                 mListener.onAnimationStart(animation);
             }
         }
 
         @Override
-        public void onAnimationCancel(Animator animation) {
-            if (mListener != null) {
+        public void onAnimationCancel(Animator animation)
+        {
+            if (mListener != null)
+            {
                 mListener.onAnimationCancel(animation);
             }
         }
 
         @Override
-        public void onAnimationRepeat(Animator animation) {
-            if (mListener != null) {
+        public void onAnimationRepeat(Animator animation)
+        {
+            if (mListener != null)
+            {
                 mListener.onAnimationRepeat(animation);
             }
         }
 
         @Override
-        public void onAnimationEnd(Animator animation) {
-            if (mListener != null) {
+        public void onAnimationEnd(Animator animation)
+        {
+            if (mListener != null)
+            {
                 mListener.onAnimationEnd(animation);
             }
             mAnimatorMap.remove(animation);
             // If the map is empty, it means all animation are done or canceled, so the listener
             // isn't needed anymore. Not nulling it would cause it to leak any objects used in
             // its implementation
-            if (mAnimatorMap.isEmpty()) {
+            if (mAnimatorMap.isEmpty())
+            {
                 mListener = null;
             }
         }
@@ -675,11 +743,12 @@ public void onAnimationEnd(Animator animation) {
          * the view object appropriately, depending on which properties are being animated.
          *
          * @param animation The animator associated with the properties that need to be
-         * set. This animator holds the animation fraction which we will use to calculate
-         * the current value of each property.
+         *                  set. This animator holds the animation fraction which we will use to calculate
+         *                  the current value of each property.
          */
         @Override
-        public void onAnimationUpdate(ValueAnimator animation) {
+        public void onAnimationUpdate(ValueAnimator animation)
+        {
             // alpha requires slightly different treatment than the other (transform) properties.
             // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
             // logic is dependent on how the view handles an internal call to onSetAlpha().
@@ -690,22 +759,26 @@ public void onAnimationUpdate(ValueAnimator animation) {
             float fraction = animation.getAnimatedFraction();
             PropertyBundle propertyBundle = mAnimatorMap.get(animation);
             int propertyMask = propertyBundle.mPropertyMask;
-            if ((propertyMask & TRANSFORM_MASK) != 0) {
+            if ((propertyMask & TRANSFORM_MASK) != 0)
+            {
                 View v = mView.get();
-                if (v != null) {
+                if (v != null)
+                {
                     v.invalidate(/*false*/);
                 }
             }
             ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
-            if (valueList != null) {
+            if (valueList != null)
+            {
                 int count = valueList.size();
-                for (int i = 0; i < count; ++i) {
+                for (int i = 0; i < count; ++i)
+                {
                     NameValuesHolder values = valueList.get(i);
                     float value = values.mFromValue + fraction * values.mDeltaValue;
                     //if (values.mNameConstant == ALPHA) {
                     //    alphaHandled = mView.setAlphaNoInvalidation(value);
                     //} else {
-                        setValue(values.mNameConstant, value);
+                    setValue(values.mNameConstant, value);
                     //}
                 }
             }
@@ -716,7 +789,8 @@ public void onAnimationUpdate(ValueAnimator animation) {
             // invalidate(false) in all cases except if alphaHandled gets set to true
             // via the call to setAlphaNoInvalidation(), above
             View v = mView.get();
-            if (v != null) {
+            if (v != null)
+            {
                 v.invalidate(/*alphaHandled*/);
             }
         }
diff --git a/library/src/com/nineoldandroids/view/animation/AnimatorProxy.java b/library/src/com/nineoldandroids/view/animation/AnimatorProxy.java
index ef3dda2..2a46117 100644
--- a/library/src/com/nineoldandroids/view/animation/AnimatorProxy.java
+++ b/library/src/com/nineoldandroids/view/animation/AnimatorProxy.java
@@ -16,35 +16,22 @@
  * platforms. <strong>DO NOT</strong> wrap your views with this class if you
  * are using {@code ObjectAnimator} as it will handle that itself.
  */
-public final class AnimatorProxy extends Animation {
-    /** Whether or not the current running platform needs to be proxied. */
-    public static final boolean NEEDS_PROXY = Integer.valueOf(Build.VERSION.SDK).intValue() < Build.VERSION_CODES.HONEYCOMB;
-
-    private static final WeakHashMap<View, AnimatorProxy> PROXIES =
-            new WeakHashMap<View, AnimatorProxy>();
-
+public final class AnimatorProxy extends Animation
+{
     /**
-     * Create a proxy to allow for modifying post-3.0 view properties on all
-     * pre-3.0 platforms. <strong>DO NOT</strong> wrap your views if you are
-     * using {@code ObjectAnimator} as it will handle that itself.
-     *
-     * @param view View to wrap.
-     * @return Proxy to post-3.0 properties.
+     * Whether or not the current running platform needs to be proxied.
      */
-    public static AnimatorProxy wrap(View view) {
-        AnimatorProxy proxy = PROXIES.get(view);
-        // This checks if the proxy already exists and whether it still is the animation of the given view
-        if (proxy == null || proxy != view.getAnimation()) {
-            proxy = new AnimatorProxy(view);
-            PROXIES.put(view, proxy);
-        }
-        return proxy;
-    }
+    public static final boolean NEEDS_PROXY =
+            Integer.valueOf(Build.VERSION.SDK).intValue() < Build.VERSION_CODES.HONEYCOMB;
 
+    private static final WeakHashMap<View, AnimatorProxy> PROXIES =
+            new WeakHashMap<View, AnimatorProxy>();
     private final WeakReference<View> mView;
     private final Camera mCamera = new Camera();
+    private final RectF mBefore = new RectF();
+    private final RectF mAfter = new RectF();
+    private final Matrix mTempMatrix = new Matrix();
     private boolean mHasPivot;
-
     private float mAlpha = 1;
     private float mPivotX;
     private float mPivotY;
@@ -55,186 +42,279 @@ public static AnimatorProxy wrap(View view) {
     private float mScaleY = 1;
     private float mTranslationX;
     private float mTranslationY;
-
-    private final RectF mBefore = new RectF();
-    private final RectF mAfter = new RectF();
-    private final Matrix mTempMatrix = new Matrix();
-
-    private AnimatorProxy(View view) {
+    private AnimatorProxy(View view)
+    {
         setDuration(0); //perform transformation immediately
         setFillAfter(true); //persist transformation beyond duration
         view.setAnimation(this);
         mView = new WeakReference<View>(view);
     }
 
-    public float getAlpha() {
+    /**
+     * Create a proxy to allow for modifying post-3.0 view properties on all
+     * pre-3.0 platforms. <strong>DO NOT</strong> wrap your views if you are
+     * using {@code ObjectAnimator} as it will handle that itself.
+     *
+     * @param view View to wrap.
+     * @return Proxy to post-3.0 properties.
+     */
+    public static AnimatorProxy wrap(View view)
+    {
+        AnimatorProxy proxy = PROXIES.get(view);
+        // This checks if the proxy already exists and whether it still is the animation of the given view
+        if (proxy == null || proxy != view.getAnimation())
+        {
+            proxy = new AnimatorProxy(view);
+            PROXIES.put(view, proxy);
+        }
+        return proxy;
+    }
+
+    public float getAlpha()
+    {
         return mAlpha;
     }
-    public void setAlpha(float alpha) {
-        if (mAlpha != alpha) {
+
+    public void setAlpha(float alpha)
+    {
+        if (mAlpha != alpha)
+        {
             mAlpha = alpha;
             View view = mView.get();
-            if (view != null) {
+            if (view != null)
+            {
                 view.invalidate();
             }
         }
     }
-    public float getPivotX() {
+
+    public float getPivotX()
+    {
         return mPivotX;
     }
-    public void setPivotX(float pivotX) {
-        if (!mHasPivot || mPivotX != pivotX) {
+
+    public void setPivotX(float pivotX)
+    {
+        if (!mHasPivot || mPivotX != pivotX)
+        {
             prepareForUpdate();
             mHasPivot = true;
             mPivotX = pivotX;
             invalidateAfterUpdate();
         }
     }
-    public float getPivotY() {
+
+    public float getPivotY()
+    {
         return mPivotY;
     }
-    public void setPivotY(float pivotY) {
-        if (!mHasPivot || mPivotY != pivotY) {
+
+    public void setPivotY(float pivotY)
+    {
+        if (!mHasPivot || mPivotY != pivotY)
+        {
             prepareForUpdate();
             mHasPivot = true;
             mPivotY = pivotY;
             invalidateAfterUpdate();
         }
     }
-    public float getRotation() {
+
+    public float getRotation()
+    {
         return mRotationZ;
     }
-    public void setRotation(float rotation) {
-        if (mRotationZ != rotation) {
+
+    public void setRotation(float rotation)
+    {
+        if (mRotationZ != rotation)
+        {
             prepareForUpdate();
             mRotationZ = rotation;
             invalidateAfterUpdate();
         }
     }
-    public float getRotationX() {
+
+    public float getRotationX()
+    {
         return mRotationX;
     }
-    public void setRotationX(float rotationX) {
-        if (mRotationX != rotationX) {
+
+    public void setRotationX(float rotationX)
+    {
+        if (mRotationX != rotationX)
+        {
             prepareForUpdate();
             mRotationX = rotationX;
             invalidateAfterUpdate();
         }
     }
-    public float getRotationY() {
+
+    public float getRotationY()
+    {
         return mRotationY;
     }
 
-    public void setRotationY(float rotationY) {
-        if (mRotationY != rotationY) {
+    public void setRotationY(float rotationY)
+    {
+        if (mRotationY != rotationY)
+        {
             prepareForUpdate();
             mRotationY = rotationY;
             invalidateAfterUpdate();
         }
     }
-    public float getScaleX() {
+
+    public float getScaleX()
+    {
         return mScaleX;
     }
-    public void setScaleX(float scaleX) {
-        if (mScaleX != scaleX) {
+
+    public void setScaleX(float scaleX)
+    {
+        if (mScaleX != scaleX)
+        {
             prepareForUpdate();
             mScaleX = scaleX;
             invalidateAfterUpdate();
         }
     }
-    public float getScaleY() {
+
+    public float getScaleY()
+    {
         return mScaleY;
     }
-    public void setScaleY(float scaleY) {
-        if (mScaleY != scaleY) {
+
+    public void setScaleY(float scaleY)
+    {
+        if (mScaleY != scaleY)
+        {
             prepareForUpdate();
             mScaleY = scaleY;
             invalidateAfterUpdate();
         }
     }
-    public int getScrollX() {
+
+    public int getScrollX()
+    {
         View view = mView.get();
-        if (view == null) {
+        if (view == null)
+        {
             return 0;
         }
         return view.getScrollX();
     }
-    public void setScrollX(int value) {
+
+    public void setScrollX(int value)
+    {
         View view = mView.get();
-        if (view != null) {
+        if (view != null)
+        {
             view.scrollTo(value, view.getScrollY());
         }
     }
-    public int getScrollY() {
+
+    public int getScrollY()
+    {
         View view = mView.get();
-        if (view == null) {
+        if (view == null)
+        {
             return 0;
         }
         return view.getScrollY();
     }
-    public void setScrollY(int value) {
+
+    public void setScrollY(int value)
+    {
         View view = mView.get();
-        if (view != null) {
+        if (view != null)
+        {
             view.scrollTo(view.getScrollX(), value);
         }
     }
 
-    public float getTranslationX() {
+    public float getTranslationX()
+    {
         return mTranslationX;
     }
-    public void setTranslationX(float translationX) {
-        if (mTranslationX != translationX) {
+
+    public void setTranslationX(float translationX)
+    {
+        if (mTranslationX != translationX)
+        {
             prepareForUpdate();
             mTranslationX = translationX;
             invalidateAfterUpdate();
         }
     }
-    public float getTranslationY() {
+
+    public float getTranslationY()
+    {
         return mTranslationY;
     }
-    public void setTranslationY(float translationY) {
-        if (mTranslationY != translationY) {
+
+    public void setTranslationY(float translationY)
+    {
+        if (mTranslationY != translationY)
+        {
             prepareForUpdate();
             mTranslationY = translationY;
             invalidateAfterUpdate();
         }
     }
-    public float getX() {
+
+    public float getX()
+    {
         View view = mView.get();
-        if (view == null) {
+        if (view == null)
+        {
             return 0;
         }
         return view.getLeft() + mTranslationX;
     }
-    public void setX(float x) {
+
+    public void setX(float x)
+    {
         View view = mView.get();
-        if (view != null) {
+        if (view != null)
+        {
             setTranslationX(x - view.getLeft());
         }
     }
-    public float getY() {
+
+    public float getY()
+    {
         View view = mView.get();
-        if (view == null) {
+        if (view == null)
+        {
             return 0;
         }
         return view.getTop() + mTranslationY;
     }
-    public void setY(float y) {
+
+    public void setY(float y)
+    {
         View view = mView.get();
-        if (view != null) {
+        if (view != null)
+        {
             setTranslationY(y - view.getTop());
         }
     }
 
-    private void prepareForUpdate() {
+    private void prepareForUpdate()
+    {
         View view = mView.get();
-        if (view != null) {
+        if (view != null)
+        {
             computeRect(mBefore, view);
         }
     }
-    private void invalidateAfterUpdate() {
+
+    private void invalidateAfterUpdate()
+    {
         View view = mView.get();
-        if (view == null || view.getParent() == null) {
+        if (view == null || view.getParent() == null)
+        {
             return;
         }
 
@@ -242,14 +322,15 @@ private void invalidateAfterUpdate() {
         computeRect(after, view);
         after.union(mBefore);
 
-        ((View)view.getParent()).invalidate(
+        ((View) view.getParent()).invalidate(
                 (int) Math.floor(after.left),
                 (int) Math.floor(after.top),
                 (int) Math.ceil(after.right),
                 (int) Math.ceil(after.bottom));
     }
 
-    private void computeRect(final RectF r, View view) {
+    private void computeRect(final RectF r, View view)
+    {
         // compute current rectangle according to matrix transformation
         final float w = view.getWidth();
         final float h = view.getHeight();
@@ -265,19 +346,22 @@ private void computeRect(final RectF r, View view) {
         r.offset(view.getLeft(), view.getTop());
 
         // Straighten coords if rotations flipped them
-        if (r.right < r.left) {
+        if (r.right < r.left)
+        {
             final float f = r.right;
             r.right = r.left;
             r.left = f;
         }
-        if (r.bottom < r.top) {
+        if (r.bottom < r.top)
+        {
             final float f = r.top;
             r.top = r.bottom;
             r.bottom = f;
         }
     }
 
-    private void transformMatrix(Matrix m, View view) {
+    private void transformMatrix(Matrix m, View view)
+    {
         final float w = view.getWidth();
         final float h = view.getHeight();
         final boolean hasPivot = mHasPivot;
@@ -287,7 +371,8 @@ private void transformMatrix(Matrix m, View view) {
         final float rX = mRotationX;
         final float rY = mRotationY;
         final float rZ = mRotationZ;
-        if ((rX != 0) || (rY != 0) || (rZ != 0)) {
+        if ((rX != 0) || (rY != 0) || (rZ != 0))
+        {
             final Camera camera = mCamera;
             camera.save();
             camera.rotateX(rX);
@@ -301,7 +386,8 @@ private void transformMatrix(Matrix m, View view) {
 
         final float sX = mScaleX;
         final float sY = mScaleY;
-        if ((sX != 1.0f) || (sY != 1.0f)) {
+        if ((sX != 1.0f) || (sY != 1.0f))
+        {
             m.postScale(sX, sY);
             final float sPX = -(pX / w) * ((sX * w) - w);
             final float sPY = -(pY / h) * ((sY * h) - h);
@@ -312,9 +398,11 @@ private void transformMatrix(Matrix m, View view) {
     }
 
     @Override
-    protected void applyTransformation(float interpolatedTime, Transformation t) {
+    protected void applyTransformation(float interpolatedTime, Transformation t)
+    {
         View view = mView.get();
-        if (view != null) {
+        if (view != null)
+        {
             t.setAlpha(mAlpha);
             transformMatrix(t.getMatrix(), view);
         }
