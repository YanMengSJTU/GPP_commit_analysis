diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
index b5c44875e..5f514d73e 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
@@ -18,12 +18,6 @@
 
 package com.graphhopper.jsprit.core.algorithm.box;
 
-import java.util.Collection;
-import java.util.Properties;
-import java.util.Random;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
 import com.graphhopper.jsprit.core.algorithm.PrettyAlgorithmBuilder;
 import com.graphhopper.jsprit.core.algorithm.SearchStrategy;
 import com.graphhopper.jsprit.core.algorithm.VehicleRoutingAlgorithm;
@@ -32,25 +26,9 @@
 import com.graphhopper.jsprit.core.algorithm.listener.AlgorithmEndsListener;
 import com.graphhopper.jsprit.core.algorithm.listener.IterationStartsListener;
 import com.graphhopper.jsprit.core.algorithm.module.RuinAndRecreateModule;
-import com.graphhopper.jsprit.core.algorithm.recreate.AbstractInsertionStrategy;
-import com.graphhopper.jsprit.core.algorithm.recreate.ActivityInsertionCostsCalculator;
-import com.graphhopper.jsprit.core.algorithm.recreate.BestInsertion;
-import com.graphhopper.jsprit.core.algorithm.recreate.BestInsertionConcurrent;
-import com.graphhopper.jsprit.core.algorithm.recreate.BreakScheduling;
-import com.graphhopper.jsprit.core.algorithm.recreate.DefaultScorer;
-import com.graphhopper.jsprit.core.algorithm.recreate.InsertionBuilder;
-import com.graphhopper.jsprit.core.algorithm.recreate.RegretInsertion;
-import com.graphhopper.jsprit.core.algorithm.recreate.RegretInsertionConcurrent;
-import com.graphhopper.jsprit.core.algorithm.recreate.RegretInsertionConcurrentFast;
-import com.graphhopper.jsprit.core.algorithm.recreate.RegretInsertionFast;
-import com.graphhopper.jsprit.core.algorithm.ruin.JobNeighborhoods;
-import com.graphhopper.jsprit.core.algorithm.ruin.JobNeighborhoodsFactory;
-import com.graphhopper.jsprit.core.algorithm.ruin.RuinClusters;
-import com.graphhopper.jsprit.core.algorithm.ruin.RuinRadial;
-import com.graphhopper.jsprit.core.algorithm.ruin.RuinRandom;
-import com.graphhopper.jsprit.core.algorithm.ruin.RuinShareFactory;
-import com.graphhopper.jsprit.core.algorithm.ruin.RuinWorst;
-import com.graphhopper.jsprit.core.algorithm.ruin.distance.DefaultJobDistance;
+import com.graphhopper.jsprit.core.algorithm.recreate.*;
+import com.graphhopper.jsprit.core.algorithm.ruin.*;
+import com.graphhopper.jsprit.core.algorithm.ruin.distance.AvgServiceAndShipmentDistance;
 import com.graphhopper.jsprit.core.algorithm.selector.SelectBest;
 import com.graphhopper.jsprit.core.algorithm.state.StateManager;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
@@ -68,6 +46,12 @@
 import com.graphhopper.jsprit.core.util.RandomNumberGeneration;
 import com.graphhopper.jsprit.core.util.Solutions;
 
+import java.util.Collection;
+import java.util.Properties;
+import java.util.Random;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
 
 public class Jsprit {
 
@@ -83,7 +67,6 @@
             this.name = name;
         }
 
-        @Override
         public String toString() {
             return name;
         }
@@ -107,7 +90,6 @@ public String toString() {
             this.strategyName = strategyName;
         }
 
-        @Override
         public String toString() {
             return strategyName;
         }
@@ -142,10 +124,9 @@ public String toString() {
         String paraName;
 
         Parameter(String name) {
-            paraName = name;
+            this.paraName = name;
         }
 
-        @Override
         public String toString() {
             return paraName;
         }
@@ -180,6 +161,8 @@ public static VehicleRoutingAlgorithm createAlgorithm(VehicleRoutingProblem vehi
 
         private SolutionAcceptor solutionAcceptor;
 
+        private ScoringFunction regretScorer = null;
+
         public static Builder newInstance(VehicleRoutingProblem vrp) {
             return new Builder(vrp);
         }
@@ -239,8 +222,8 @@ public Builder setExecutorService(ExecutorService es, int noThreads) {
             return this;
         }
 
-        public Builder setCustomAcceptor(SolutionAcceptor acceptor) {
-            solutionAcceptor = acceptor;
+        public Builder setCustomAcceptor(SolutionAcceptor acceptor){
+            this.solutionAcceptor = acceptor;
             return this;
         }
 
@@ -285,6 +268,11 @@ public Builder setActivityInsertionCalculator(ActivityInsertionCostsCalculator a
             return this;
         }
 
+        public Builder setRegretScorer(ScoringFunction scoringFunction) {
+            this.regretScorer = scoringFunction;
+            return this;
+        }
+
         public VehicleRoutingAlgorithm buildAlgorithm() {
             return new Jsprit(this).create(vrp);
         }
@@ -306,17 +294,15 @@ public void setRandom(Random random) {
         }
 
         public RuinShareFactoryImpl(int minShare, int maxShare) {
-            if (maxShare < minShare) {
+            if (maxShare < minShare)
                 throw new IllegalArgumentException("maxShare must be equal or greater than minShare");
-            }
             this.minShare = minShare;
             this.maxShare = maxShare;
         }
 
         public RuinShareFactoryImpl(int minShare, int maxShare, Random random) {
-            if (maxShare < minShare) {
+            if (maxShare < minShare)
                 throw new IllegalArgumentException("maxShare must be equal or greater than minShare");
-            }
             this.minShare = minShare;
             this.maxShare = maxShare;
             this.random = random;
@@ -349,20 +335,28 @@ public int createNumberToBeRemoved() {
 
     private SolutionAcceptor acceptor;
 
+    private ScoringFunction regretScorer;
+
     private Jsprit(Builder builder) {
-        stateManager = builder.stateManager;
-        constraintManager = builder.constraintManager;
-        es = builder.es;
-        noThreads = builder.noThreads;
-        addCoreConstraints = builder.addConstraints;
-        properties = builder.properties;
-        objectiveFunction = builder.objectiveFunction;
-        random = builder.random;
-        activityInsertion = builder.activityInsertionCalculator;
-        acceptor = builder.solutionAcceptor;
+        this.stateManager = builder.stateManager;
+        this.constraintManager = builder.constraintManager;
+        this.es = builder.es;
+        this.noThreads = builder.noThreads;
+        this.addCoreConstraints = builder.addConstraints;
+        this.properties = builder.properties;
+        this.objectiveFunction = builder.objectiveFunction;
+        this.random = builder.random;
+        this.activityInsertion = builder.activityInsertionCalculator;
+        this.acceptor = builder.solutionAcceptor;
+        regretScorer = builder.regretScorer;
+    }
+
+    private void ini(VehicleRoutingProblem vrp) {
+        if (regretScorer == null) regretScorer = getRegretScorer(vrp);
     }
 
     private VehicleRoutingAlgorithm create(final VehicleRoutingProblem vrp) {
+        ini(vrp);
         VehicleFleetManager fm;
         if (vrp.getFleetSize().equals(VehicleRoutingProblem.FleetSize.INFINITE)) {
             fm = new InfiniteFleetManagerFactory(vrp.getVehicles()).createFleetManager();
@@ -392,13 +386,14 @@ private VehicleRoutingAlgorithm create(final VehicleRoutingProblem vrp) {
         double noiseLevel = toDouble(getProperty(Parameter.INSERTION_NOISE_LEVEL.toString()));
         double noiseProbability = toDouble(getProperty(Parameter.INSERTION_NOISE_PROB.toString()));
 
-        JobNeighborhoods jobNeighborhoods = new JobNeighborhoodsFactory().createNeighborhoods(vrp, new DefaultJobDistance(vrp.getTransportCosts()), (int) (vrp.getJobs().values().size() * 0.5));
+        JobNeighborhoods jobNeighborhoods = new JobNeighborhoodsFactory().createNeighborhoods(vrp, new AvgServiceAndShipmentDistance(vrp.getTransportCosts()), (int) (vrp.getJobs().values().size() * 0.5));
         jobNeighborhoods.initialise();
 
         final double maxCosts;
-        if (properties.containsKey(Parameter.MAX_TRANSPORT_COSTS.toString())) {
+        if(properties.containsKey(Parameter.MAX_TRANSPORT_COSTS.toString())){
             maxCosts = Double.parseDouble(getProperty(Parameter.MAX_TRANSPORT_COSTS.toString()));
-        } else {
+        }
+        else{
             maxCosts = jobNeighborhoods.getMaxDistance();
         }
 
@@ -418,47 +413,44 @@ private VehicleRoutingAlgorithm create(final VehicleRoutingProblem vrp) {
         RuinRadial radial = new RuinRadial(vrp, vrp.getJobs().size(), jobNeighborhoods);
         radial.setRandom(random);
         radial.setRuinShareFactory(new RuinShareFactoryImpl(
-                        toInteger(properties.getProperty(Parameter.RADIAL_MIN_SHARE.toString())),
-                        toInteger(properties.getProperty(Parameter.RADIAL_MAX_SHARE.toString())),
-                        random)
-                        );
+                toInteger(properties.getProperty(Parameter.RADIAL_MIN_SHARE.toString())),
+                toInteger(properties.getProperty(Parameter.RADIAL_MAX_SHARE.toString())),
+                random)
+        );
 
         final RuinRandom random_for_regret = new RuinRandom(vrp, 0.5);
         random_for_regret.setRandom(random);
         random_for_regret.setRuinShareFactory(new RuinShareFactoryImpl(
-                        toInteger(properties.getProperty(Parameter.RANDOM_REGRET_MIN_SHARE.toString())),
-                        toInteger(properties.getProperty(Parameter.RANDOM_REGRET_MAX_SHARE.toString())),
-                        random)
-                        );
+                toInteger(properties.getProperty(Parameter.RANDOM_REGRET_MIN_SHARE.toString())),
+                toInteger(properties.getProperty(Parameter.RANDOM_REGRET_MAX_SHARE.toString())),
+                random)
+        );
 
         final RuinRandom random_for_best = new RuinRandom(vrp, 0.5);
         random_for_best.setRandom(random);
         random_for_best.setRuinShareFactory(new RuinShareFactoryImpl(
-                        toInteger(properties.getProperty(Parameter.RANDOM_BEST_MIN_SHARE.toString())),
-                        toInteger(properties.getProperty(Parameter.RANDOM_BEST_MAX_SHARE.toString())),
-                        random)
-                        );
+                toInteger(properties.getProperty(Parameter.RANDOM_BEST_MIN_SHARE.toString())),
+                toInteger(properties.getProperty(Parameter.RANDOM_BEST_MAX_SHARE.toString())),
+                random)
+        );
 
         final RuinWorst worst = new RuinWorst(vrp, (int) (vrp.getJobs().values().size() * 0.5));
         worst.setRandom(random);
         worst.setRuinShareFactory(new RuinShareFactoryImpl(
-                        toInteger(properties.getProperty(Parameter.WORST_MIN_SHARE.toString())),
-                        toInteger(properties.getProperty(Parameter.WORST_MAX_SHARE.toString())),
-                        random)
-                        );
+                toInteger(properties.getProperty(Parameter.WORST_MIN_SHARE.toString())),
+                toInteger(properties.getProperty(Parameter.WORST_MAX_SHARE.toString())),
+                random)
+        );
         IterationStartsListener noise = new IterationStartsListener() {
             @Override
             public void informIterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
                 worst.setNoiseMaker(new NoiseMaker() {
 
-                    @Override
                     public double makeNoise() {
                         if (random.nextDouble() < toDouble(getProperty(Parameter.RUIN_WORST_NOISE_PROB.toString()))) {
                             return toDouble(getProperty(Parameter.RUIN_WORST_NOISE_LEVEL.toString()))
-                                            * maxCosts * random.nextDouble();
-                        } else {
-                            return 0.;
-                        }
+                                * maxCosts * random.nextDouble();
+                        } else return 0.;
                     }
                 });
             }
@@ -467,62 +459,64 @@ public double makeNoise() {
         final RuinClusters clusters = new RuinClusters(vrp, (int) (vrp.getJobs().values().size() * 0.5), jobNeighborhoods);
         clusters.setRandom(random);
         clusters.setRuinShareFactory(new RuinShareFactoryImpl(
-                        toInteger(properties.getProperty(Parameter.WORST_MIN_SHARE.toString())),
-                        toInteger(properties.getProperty(Parameter.WORST_MAX_SHARE.toString())),
-                        random)
-                        );
+                toInteger(properties.getProperty(Parameter.WORST_MIN_SHARE.toString())),
+                toInteger(properties.getProperty(Parameter.WORST_MAX_SHARE.toString())),
+                random)
+        );
 
         AbstractInsertionStrategy regret;
-        final DefaultScorer scorer;
+        final ScoringFunction scorer;
 
         boolean fastRegret = Boolean.parseBoolean(getProperty(Parameter.FAST_REGRET.toString()));
         if (es != null) {
-            if (fastRegret) {
+            if(fastRegret){
                 RegretInsertionConcurrentFast regretInsertion = (RegretInsertionConcurrentFast) new InsertionBuilder(vrp, fm, stateManager, constraintManager)
-                                .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
-                                .setConcurrentMode(es, noThreads)
-                                .setFastRegret(true)
-                                .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                                .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                                .setActivityInsertionCostCalculator(activityInsertion)
-                                .build();
-                scorer = getRegretScorer(vrp);
+                    .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
+                    .setConcurrentMode(es, noThreads)
+                    .setFastRegret(true)
+                    .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                    .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                    .setActivityInsertionCostCalculator(activityInsertion)
+                    .build();
+                scorer = regretScorer;
                 regretInsertion.setScoringFunction(scorer);
                 regretInsertion.setDependencyTypes(constraintManager.getDependencyTypes());
                 regret = regretInsertion;
-            } else {
+            }
+            else {
                 RegretInsertionConcurrent regretInsertion = (RegretInsertionConcurrent) new InsertionBuilder(vrp, fm, stateManager, constraintManager)
-                                .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
-                                .setConcurrentMode(es, noThreads)
-                                .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                                .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                                .setActivityInsertionCostCalculator(activityInsertion)
-                                .build();
-                scorer = getRegretScorer(vrp);
+                    .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
+                    .setConcurrentMode(es, noThreads)
+                    .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                    .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                    .setActivityInsertionCostCalculator(activityInsertion)
+                    .build();
+                scorer = regretScorer;
                 regretInsertion.setScoringFunction(scorer);
                 regret = regretInsertion;
             }
         } else {
-            if (fastRegret) {
+            if(fastRegret) {
                 RegretInsertionFast regretInsertion = (RegretInsertionFast) new InsertionBuilder(vrp, fm, stateManager, constraintManager)
-                                .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
-                                .setFastRegret(true)
-                                .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                                .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                                .setActivityInsertionCostCalculator(activityInsertion)
-                                .build();
-                scorer = getRegretScorer(vrp);
+                    .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
+                    .setFastRegret(true)
+                    .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                    .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                    .setActivityInsertionCostCalculator(activityInsertion)
+                    .build();
+                scorer = regretScorer;
                 regretInsertion.setScoringFunction(scorer);
                 regretInsertion.setDependencyTypes(constraintManager.getDependencyTypes());
                 regret = regretInsertion;
-            } else {
+            }
+            else{
                 RegretInsertion regretInsertion = (RegretInsertion) new InsertionBuilder(vrp, fm, stateManager, constraintManager)
-                                .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
-                                .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                                .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                                .setActivityInsertionCostCalculator(activityInsertion)
-                                .build();
-                scorer = getRegretScorer(vrp);
+                    .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
+                    .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                    .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                    .setActivityInsertionCostCalculator(activityInsertion)
+                    .build();
+                scorer = regretScorer;
                 regretInsertion.setScoringFunction(scorer);
                 regret = regretInsertion;
             }
@@ -532,26 +526,26 @@ public double makeNoise() {
         AbstractInsertionStrategy best;
         if (vrp.getJobs().size() < 250 || es == null) {
             BestInsertion bestInsertion = (BestInsertion) new InsertionBuilder(vrp, fm, stateManager, constraintManager)
-                            .setInsertionStrategy(InsertionBuilder.Strategy.BEST)
-                            .considerFixedCosts(Double.valueOf(properties.getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                            .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                            .setActivityInsertionCostCalculator(activityInsertion)
-                            .build();
+                .setInsertionStrategy(InsertionBuilder.Strategy.BEST)
+                .considerFixedCosts(Double.valueOf(properties.getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                .setActivityInsertionCostCalculator(activityInsertion)
+                .build();
             best = bestInsertion;
         } else {
             BestInsertionConcurrent bestInsertion = (BestInsertionConcurrent) new InsertionBuilder(vrp, fm, stateManager, constraintManager)
-                            .setInsertionStrategy(InsertionBuilder.Strategy.BEST)
-                            .considerFixedCosts(Double.valueOf(properties.getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                            .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                            .setConcurrentMode(es, noThreads)
-                            .setActivityInsertionCostCalculator(activityInsertion)
-                            .build();
+                .setInsertionStrategy(InsertionBuilder.Strategy.BEST)
+                .considerFixedCosts(Double.valueOf(properties.getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                .setConcurrentMode(es, noThreads)
+                .setActivityInsertionCostCalculator(activityInsertion)
+                .build();
             best = bestInsertion;
         }
         best.setRandom(random);
 
         IterationStartsListener schrimpfThreshold = null;
-        if (acceptor == null) {
+        if(acceptor == null) {
             final SchrimpfAcceptance schrimpfAcceptance = new SchrimpfAcceptance(1, toDouble(getProperty(Parameter.THRESHOLD_ALPHA.toString())));
             schrimpfThreshold = new IterationStartsListener() {
                 @Override
@@ -597,13 +591,13 @@ public void informIterationStarts(int i, VehicleRoutingProblem problem, Collecti
             prettyBuilder.addCoreStateAndConstraintStuff();
         }
         prettyBuilder.withStrategy(radial_regret, toDouble(getProperty(Strategy.RADIAL_REGRET.toString())))
-        .withStrategy(radial_best, toDouble(getProperty(Strategy.RADIAL_BEST.toString())))
-        .withStrategy(random_best, toDouble(getProperty(Strategy.RANDOM_BEST.toString())))
-        .withStrategy(random_regret, toDouble(getProperty(Strategy.RANDOM_REGRET.toString())))
-        .withStrategy(worst_best, toDouble(getProperty(Strategy.WORST_BEST.toString())))
-        .withStrategy(worst_regret, toDouble(getProperty(Strategy.WORST_REGRET.toString())))
-        .withStrategy(clusters_regret, toDouble(getProperty(Strategy.CLUSTER_REGRET.toString())))
-        .withStrategy(clusters_best, toDouble(getProperty(Strategy.CLUSTER_BEST.toString())));
+            .withStrategy(radial_best, toDouble(getProperty(Strategy.RADIAL_BEST.toString())))
+            .withStrategy(random_best, toDouble(getProperty(Strategy.RANDOM_BEST.toString())))
+            .withStrategy(random_regret, toDouble(getProperty(Strategy.RANDOM_REGRET.toString())))
+            .withStrategy(worst_best, toDouble(getProperty(Strategy.WORST_BEST.toString())))
+            .withStrategy(worst_regret, toDouble(getProperty(Strategy.WORST_REGRET.toString())))
+            .withStrategy(clusters_regret, toDouble(getProperty(Strategy.CLUSTER_REGRET.toString())))
+            .withStrategy(clusters_best, toDouble(getProperty(Strategy.CLUSTER_BEST.toString())));
         if (getProperty(Parameter.CONSTRUCTION.toString()).equals(Construction.BEST_INSERTION.toString())) {
             prettyBuilder.constructInitialSolutionWith(best, objectiveFunction);
         } else {
@@ -613,14 +607,14 @@ public void informIterationStarts(int i, VehicleRoutingProblem problem, Collecti
 
 
         VehicleRoutingAlgorithm vra = prettyBuilder.build();
-        if (schrimpfThreshold != null) {
+        if(schrimpfThreshold != null) {
             vra.addListener(schrimpfThreshold);
         }
         vra.addListener(noiseConfigurator);
         vra.addListener(noise);
         vra.addListener(clusters);
 
-        if (toBoolean(getProperty(Parameter.BREAK_SCHEDULING.toString()))) {
+        if(toBoolean(getProperty(Parameter.BREAK_SCHEDULING.toString()))) {
             vra.addListener(new BreakScheduling(vrp, stateManager, constraintManager));
         }
         handleExecutorShutdown(vra);
@@ -641,7 +635,6 @@ private DefaultScorer getRegretScorer(VehicleRoutingProblem vrp) {
     private void handleExecutorShutdown(VehicleRoutingAlgorithm vra) {
         if (setupExecutorInternally) {
             final Thread hook = new Thread() {
-                @Override
                 public void run() {
                     if (!es.isShutdown()) {
                         System.err.println("shutdownHook shuts down executorService");
@@ -660,17 +653,17 @@ public void informAlgorithmEnds(VehicleRoutingProblem problem, Collection<Vehicl
 
             });
         }
-        //        if (es != null) {
-        //
-        //            Runtime.getRuntime().addShutdownHook(hook);
-        //            vra.addListener(new AlgorithmEndsListener() {
-        //                @Override
-        //                public void informAlgorithmEnds(VehicleRoutingProblem aProblem,
-        //                                                Collection<VehicleRoutingProblemSolution> aSolutions) {
-        //                    Runtime.getRuntime().removeShutdownHook(hook);
-        //                }
-        //            });
-        //        }
+//        if (es != null) {
+//
+//            Runtime.getRuntime().addShutdownHook(hook);
+//            vra.addListener(new AlgorithmEndsListener() {
+//                @Override
+//                public void informAlgorithmEnds(VehicleRoutingProblem aProblem,
+//                                                Collection<VehicleRoutingProblemSolution> aSolutions) {
+//                    Runtime.getRuntime().removeShutdownHook(hook);
+//                }
+//            });
+//        }
     }
 
     String getProperty(String key) {
@@ -690,9 +683,7 @@ private double toDouble(String string) {
     }
 
     private SolutionCostCalculator getObjectiveFunction(final VehicleRoutingProblem vrp, final double maxCosts) {
-        if (objectiveFunction != null) {
-            return objectiveFunction;
-        }
+        if (objectiveFunction != null) return objectiveFunction;
 
         SolutionCostCalculator solutionCostCalculator = new SolutionCostCalculator() {
             @Override
@@ -704,9 +695,7 @@ public double getCosts(VehicleRoutingProblemSolution solution) {
                     boolean hasBreak = false;
                     TourActivity prevAct = route.getStart();
                     for (TourActivity act : route.getActivities()) {
-                        if (act instanceof BreakActivity) {
-                            hasBreak = true;
-                        }
+                        if (act instanceof BreakActivity) hasBreak = true;
                         costs += vrp.getTransportCosts().getTransportCost(prevAct.getLocation(), act.getLocation(), prevAct.getEndTime(), route.getDriver(), route.getVehicle());
                         costs += vrp.getActivityCosts().getActivityCost(act, act.getArrTime(), route.getDriver(), route.getVehicle());
                         prevAct = act;
@@ -715,18 +704,13 @@ public double getCosts(VehicleRoutingProblemSolution solution) {
                     if (route.getVehicle().getBreak() != null) {
                         if (!hasBreak) {
                             //break defined and required but not assigned penalty
-                            if (route.getEnd().getArrTime() > route.getVehicle().getBreak()
-                                            .getActivity().getSingleTimeWindow()
-                                            .getEnd()) {
-                                costs += 4 * (maxCosts * 2 + route.getVehicle().getBreak()
-                                                .getActivity().getOperationTime()
-                                                * route.getVehicle().getType()
-                                                                .getVehicleCostParams().perServiceTimeUnit);
+                            if (route.getEnd().getArrTime() > route.getVehicle().getBreak().getTimeWindow().getEnd()) {
+                                costs += 4 * (maxCosts * 2 + route.getVehicle().getBreak().getServiceDuration() * route.getVehicle().getType().getVehicleCostParams().perServiceTimeUnit);
                             }
                         }
                     }
                 }
-                for (Job j : solution.getUnassignedJobs()) {
+                for(Job j : solution.getUnassignedJobs()){
                     costs += maxCosts * 2 * (4 - j.getPriority());
                 }
                 return costs;
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
index fb7f09eae..fac022db8 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
@@ -18,20 +18,19 @@
 
 package com.graphhopper.jsprit.core.problem.constraint;
 
-import java.util.Collection;
-import java.util.Map;
-
 import com.graphhopper.jsprit.core.algorithm.state.StateId;
 import com.graphhopper.jsprit.core.algorithm.state.StateManager;
 import com.graphhopper.jsprit.core.problem.cost.TransportDistance;
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.AbstractActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliverShipment;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.Start;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 
+import java.util.Collection;
+import java.util.Map;
+
 /**
  * Created by schroeder on 11/10/16.
  */
@@ -63,59 +62,55 @@ private void makeArray(Map<Vehicle, Double> maxDistances) {
     private int getMaxIndex(Collection<Vehicle> vehicles) {
         int index = 0;
         for(Vehicle v : vehicles){
-            if(v.getIndex() > index) {
-                index = v.getIndex();
-            }
+            if(v.getIndex() > index) index = v.getIndex();
         }
         return index;
     }
 
     @Override
     public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime) {
-        if(!hasMaxDistance(iFacts.getNewVehicle())) {
-            return ConstraintsStatus.FULFILLED;
-        }
+        if(!hasMaxDistance(iFacts.getNewVehicle())) return ConstraintsStatus.FULFILLED;
         Double currentDistance = 0d;
         boolean routeIsEmpty = iFacts.getRoute().isEmpty();
         if(!routeIsEmpty){
             currentDistance = stateManager.getRouteState(iFacts.getRoute(),iFacts.getNewVehicle(), distanceId,Double.class);
         }
         double maxDistance = getMaxDistance(iFacts.getNewVehicle());
-        if(currentDistance > maxDistance) {
-            return ConstraintsStatus.NOT_FULFILLED_BREAK;
-        }
+        if(currentDistance > maxDistance) return ConstraintsStatus.NOT_FULFILLED_BREAK;
 
         double distancePrevAct2NewAct = distanceCalculator.getDistance(prevAct.getLocation(), newAct.getLocation(), iFacts.getNewDepTime(), iFacts.getNewVehicle());
         double distanceNewAct2nextAct = distanceCalculator.getDistance(newAct.getLocation(), nextAct.getLocation(), iFacts.getNewDepTime(), iFacts.getNewVehicle());
         double distancePrevAct2NextAct = distanceCalculator.getDistance(prevAct.getLocation(), nextAct.getLocation(), prevActDepTime, iFacts.getNewVehicle());
-        if(routeIsEmpty) {
-            distancePrevAct2NextAct = 0;
-        }
+        if(prevAct instanceof Start && nextAct instanceof End) distancePrevAct2NextAct = 0;
         if(nextAct instanceof End && !iFacts.getNewVehicle().isReturnToDepot()){
             distanceNewAct2nextAct = 0;
             distancePrevAct2NextAct = 0;
         }
         double additionalDistance = distancePrevAct2NewAct + distanceNewAct2nextAct - distancePrevAct2NextAct;
-        if(currentDistance + additionalDistance > maxDistance) {
-            return ConstraintsStatus.NOT_FULFILLED;
-        }
+        if(currentDistance + additionalDistance > maxDistance) return ConstraintsStatus.NOT_FULFILLED;
+
 
         double additionalDistanceOfPickup = 0;
-        if (newAct instanceof DeliveryActivity && AbstractActivity.isShipment(newAct)) {
+        if(newAct instanceof DeliverShipment){
             int iIndexOfPickup = iFacts.getRelatedActivityContext().getInsertionIndex();
             TourActivity pickup = iFacts.getAssociatedActivities().get(0);
             TourActivity actBeforePickup;
-            if(iIndexOfPickup > 0) {
-                actBeforePickup = iFacts.getRoute().getActivities().get(iIndexOfPickup-1);
-            } else {
-                actBeforePickup = new Start(iFacts.getNewVehicle().getStartLocation(),0,Double.MAX_VALUE);
-            }
-            TourActivity actAfterPickup = iFacts.getRoute().getActivities().get(iIndexOfPickup);
-            //ToDo account here fore End and returnToDepot
+            if(iIndexOfPickup > 0) actBeforePickup = iFacts.getRoute().getActivities().get(iIndexOfPickup-1);
+            else actBeforePickup = new Start(iFacts.getNewVehicle().getStartLocation(),0,Double.MAX_VALUE);
+            TourActivity actAfterPickup;
+            if (iIndexOfPickup < iFacts.getRoute().getActivities().size())
+                actAfterPickup = iFacts.getRoute().getActivities().get(iIndexOfPickup);
+            else
+                actAfterPickup = nextAct;
             double distanceActBeforePickup2Pickup = distanceCalculator.getDistance(actBeforePickup.getLocation(), pickup.getLocation(), actBeforePickup.getEndTime(), iFacts.getNewVehicle());
             double distancePickup2ActAfterPickup = distanceCalculator.getDistance(pickup.getLocation(), actAfterPickup.getLocation(), iFacts.getRelatedActivityContext().getEndTime(), iFacts.getNewVehicle());
             double distanceBeforePickup2AfterPickup = distanceCalculator.getDistance(actBeforePickup.getLocation(), actAfterPickup.getLocation(), actBeforePickup.getEndTime(), iFacts.getNewVehicle());
-            additionalDistanceOfPickup = distanceActBeforePickup2Pickup  + distancePickup2ActAfterPickup - distanceBeforePickup2AfterPickup;
+            if (routeIsEmpty) distanceBeforePickup2AfterPickup = 0;
+            if (actAfterPickup instanceof End && !iFacts.getNewVehicle().isReturnToDepot()) {
+                distancePickup2ActAfterPickup = 0;
+                distanceBeforePickup2AfterPickup = 0;
+            }
+            additionalDistanceOfPickup = distanceActBeforePickup2Pickup + distancePickup2ActAfterPickup - distanceBeforePickup2AfterPickup;
         }
 
 
@@ -127,17 +122,13 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
     }
 
     private boolean hasMaxDistance(Vehicle newVehicle){
-        if(newVehicle.getIndex() >= maxDistances.length) {
-            return false;
-        }
-        return maxDistances[newVehicle.getIndex()] != null;
+        if(newVehicle.getIndex() >= this.maxDistances.length) return false;
+        return this.maxDistances[newVehicle.getIndex()] != null;
     }
 
     private double getMaxDistance(Vehicle newVehicle) {
-        Double maxDistance = maxDistances[newVehicle.getIndex()];
-        if(maxDistance == null) {
-            return Double.MAX_VALUE;
-        }
+        Double maxDistance = this.maxDistances[newVehicle.getIndex()];
+        if(maxDistance == null) return Double.MAX_VALUE;
         return maxDistance;
     }
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
index 05cafeaf9..a1ed51458 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
@@ -19,20 +19,8 @@
 package com.graphhopper.jsprit.core.problem.constraint;
 
 
-import static org.junit.Assert.assertEquals;
-
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-
 import com.graphhopper.jsprit.core.algorithm.state.StateId;
 import com.graphhopper.jsprit.core.algorithm.state.StateManager;
-import com.graphhopper.jsprit.core.distance.ManhattanDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.cost.TransportDistance;
@@ -40,6 +28,7 @@
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.job.Pickup;
 import com.graphhopper.jsprit.core.problem.job.Shipment;
+import com.graphhopper.jsprit.core.problem.misc.ActivityContext;
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
@@ -47,7 +36,15 @@
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
-import com.graphhopper.jsprit.core.util.DefaultCosts;
+import com.graphhopper.jsprit.core.util.ManhattanCosts;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.*;
+
+import static org.mockito.Mockito.mock;
 
 /**
  * Created by schroeder on 18/05/16.
@@ -66,54 +63,50 @@
 
     VehicleRoutingProblem vrp;
 
-    Delivery d1, d2, newDelivery;
+    Delivery d1,d2,newDelivery;
 
     Pickup pickup;
 
     Shipment s1;
 
-    Map<Vehicle, Double> maxDistanceMap;
+    Map<Vehicle,Double> maxDistanceMap;
 
 
     @Before
-    public void doBefore() {
-        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0, 0)).build();
-        vehicle2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(Location.newInstance(10, 10)).build();
+    public void doBefore(){
+        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0,0)).build();
+        vehicle2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(Location.newInstance(10,10)).build();
 
         maxDistanceMap = new HashMap<>();
-        maxDistanceMap.put(vehicle, 200d);
-        maxDistanceMap.put(vehicle2, 200d);
+        maxDistanceMap.put(vehicle,200d);
+        maxDistanceMap.put(vehicle2,200d);
 
-        d1 = Delivery.Builder.newInstance("d1").setLocation(Location.newInstance(10, 10)).build();
-        d2 = Delivery.Builder.newInstance("d2").setLocation(Location.newInstance(20, 15)).build();
-        pickup = Pickup.Builder.newInstance("pickup").setLocation(Location.newInstance(50, 50)).build();
-        s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(35, 30))
-                        .setDeliveryLocation(Location.newInstance(20, 25)).build();
+        d1 = Delivery.Builder.newInstance("d1").setLocation(Location.newInstance(10,10)).build();
+        d2 = Delivery.Builder.newInstance("d2").setLocation(Location.newInstance(20,15)).build();
+        pickup = Pickup.Builder.newInstance("pickup").setLocation(Location.newInstance(50,50)).build();
+        s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(35,30))
+            .setDeliveryLocation(Location.newInstance(20,25)).build();
 
-        newDelivery = Delivery.Builder.newInstance("new").setLocation(Location.newInstance(-10, 10)).build();
+        newDelivery = Delivery.Builder.newInstance("new").setLocation(Location.newInstance(-10,10)).build();
 
         vrp = VehicleRoutingProblem.Builder.newInstance()
-                        .setRoutingCost(new DefaultCosts(ManhattanDistanceCalculator.getInstance()))
-                        .addVehicle(vehicle).addVehicle(vehicle2)
-                        .addJob(d1).addJob(d2).addJob(s1).addJob(pickup).addJob(newDelivery).build();
+            .setRoutingCost(new ManhattanCosts()).addVehicle(vehicle).addVehicle(vehicle2)
+            .addJob(d1).addJob(d2).addJob(s1).addJob(pickup).addJob(newDelivery).build();
 
         route = VehicleRoute.Builder.newInstance(vehicle).setJobActivityFactory(vrp.getJobActivityFactory())
-                        .addDelivery(d1).addDelivery(d2).addPickup(s1).addPickup(pickup).addDelivery(s1).build();
+            .addDelivery(d1).addDelivery(d2).addPickup(s1).addPickup(pickup).addDelivery(s1).build();
 
         stateManager = new StateManager(vrp);
 
         traveledDistanceId = stateManager.createStateId("traveledDistance");
 
         com.graphhopper.jsprit.core.algorithm.state.VehicleDependentTraveledDistance traveledDistance =
-                        new com.graphhopper.jsprit.core.algorithm.state.VehicleDependentTraveledDistance(new TransportDistance() {
-                            @Override
-                            public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-                                return new DefaultCosts(ManhattanDistanceCalculator
-                                                .getInstance()).getDistance(from,
-                                                                to, departureTime,
-                                                                vehicle);
-                            }
-                        }, stateManager, traveledDistanceId, Arrays.asList(vehicle, vehicle2));
+            new com.graphhopper.jsprit.core.algorithm.state.VehicleDependentTraveledDistance(new TransportDistance() {
+                @Override
+                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                    return new ManhattanCosts().getDistance(from,to,departureTime,vehicle);
+                }
+        },stateManager,traveledDistanceId,Arrays.asList(vehicle,vehicle2));
 
         stateManager.addStateUpdater(traveledDistance);
         stateManager.informInsertionStarts(Arrays.asList(route), Collections.<Job>emptyList());
@@ -149,123 +142,216 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
 vehicle2 (max distance): 180.0
      */
     @Test
-    public void insertNewInVehicleShouldFail() {
+    public void insertNewInVehicleShouldFail(){
         MaxDistanceConstraint maxDistanceConstraint =
-                        new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
-                            @Override
-                            public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-                                return vrp.getTransportCosts().getTransportTime(from, to, departureTime, null, vehicle);
-                            }
-                        }, maxDistanceMap);
-        JobInsertionContext context = new JobInsertionContext(route, newDelivery, vehicle, null, 0);
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, route.getStart(), newAct(), act(0), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(0), newAct(), act(1), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(1), newAct(), act(2), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(2), newAct(), act(3), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(3), newAct(), act(4), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(4), newAct(), route.getEnd(), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+            new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
+                @Override
+                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                }
+            },maxDistanceMap);
+        JobInsertionContext context = new JobInsertionContext(route,newDelivery,vehicle,null,0);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,route.getStart(),newAct(),act(0),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(0),newAct(),act(1),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(1),newAct(),act(2),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(2),newAct(),act(3),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(3),newAct(),act(4),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(4),newAct(),route.getEnd(),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
     }
 
 
     @Test
-    public void insertNewInVehicle2ShouldBeCorrect() {
+    public void insertNewInVehicle2ShouldBeCorrect(){
         //current distance vehicle2: 160 allowed: 200
         MaxDistanceConstraint maxDistanceConstraint =
-                        new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
-                            @Override
-                            public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-                                return vrp.getTransportCosts().getTransportTime(from, to, departureTime, null, vehicle);
-                            }
-                        }, maxDistanceMap);
-        JobInsertionContext context = new JobInsertionContext(route, newDelivery, vehicle2, null, 0);
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, route.getStart(), newAct(), act(0), 0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+            new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
+                @Override
+                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                }
+            },maxDistanceMap);
+        JobInsertionContext context = new JobInsertionContext(route,newDelivery,vehicle2,null,0);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,route.getStart(),newAct(),act(0),0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
         //additional distance: 20+35-15=40
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(0), newAct(), act(1), 0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(0),newAct(),act(1),0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
         //additional distance: 35+65-30=70
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(1), newAct(), act(2), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(1),newAct(),act(2),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
         //additional distance: 65+100-35
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(2), newAct(), act(3), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(2),newAct(),act(3),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
         //additional distance: 100+45-55
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(3), newAct(), act(4), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(3),newAct(),act(4),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
         //additional distance: 45+20-25
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(4), newAct(), route.getEnd(), 0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(4),newAct(),route.getEnd(),0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
     }
 
     private TourActivity act(int i) {
         return route.getActivities().get(i);
     }
 
-    private TourActivity newAct() {
+    private TourActivity newAct(){
         return vrp.getActivities(newDelivery).get(0);
     }
 
     @Test
-    public void traveledDistanceShouldBeCorrect() {
-        assertEquals(20d, stateManager.getActivityState(route.getActivities().get(0), vehicle, traveledDistanceId, Double.class), 0.01);
-        assertEquals(35d, stateManager.getActivityState(route.getActivities().get(1), vehicle, traveledDistanceId, Double.class), 0.01);
-        assertEquals(65d, stateManager.getActivityState(route.getActivities().get(2), vehicle, traveledDistanceId, Double.class), 0.01);
-        assertEquals(100d, stateManager.getActivityState(route.getActivities().get(3), vehicle, traveledDistanceId, Double.class), 0.01);
-        assertEquals(155d, stateManager.getActivityState(route.getActivities().get(4), vehicle, traveledDistanceId, Double.class), 0.01);
+    public void traveledDistanceShouldBeCorrect(){
+        Assert.assertEquals(20d,stateManager.getActivityState(route.getActivities().get(0),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(35d,stateManager.getActivityState(route.getActivities().get(1),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(65d,stateManager.getActivityState(route.getActivities().get(2),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(100d,stateManager.getActivityState(route.getActivities().get(3),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(155d,stateManager.getActivityState(route.getActivities().get(4),vehicle,traveledDistanceId,Double.class),0.01);
 
     }
 
     @Test
-    public void traveledDistanceWithVehicle2ShouldBeCorrect() {
-        assertEquals(0d, stateManager.getActivityState(route.getActivities().get(0), vehicle2, traveledDistanceId, Double.class), 0.01);
-        assertEquals(15d, stateManager.getActivityState(route.getActivities().get(1), vehicle2, traveledDistanceId, Double.class), 0.01);
-        assertEquals(45d, stateManager.getActivityState(route.getActivities().get(2), vehicle2, traveledDistanceId, Double.class), 0.01);
-        assertEquals(80d, stateManager.getActivityState(route.getActivities().get(3), vehicle2, traveledDistanceId, Double.class), 0.01);
-        assertEquals(135d, stateManager.getActivityState(route.getActivities().get(4), vehicle2, traveledDistanceId, Double.class), 0.01);
+    public void traveledDistanceWithVehicle2ShouldBeCorrect(){
+        Assert.assertEquals(0d,stateManager.getActivityState(route.getActivities().get(0),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(15d,stateManager.getActivityState(route.getActivities().get(1),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(45d,stateManager.getActivityState(route.getActivities().get(2),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(80d,stateManager.getActivityState(route.getActivities().get(3),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(135d,stateManager.getActivityState(route.getActivities().get(4),vehicle2,traveledDistanceId,Double.class),0.01);
 
     }
 
     @Test
-    public void distanceOfShipmentInRoute() {
-        double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(2), vehicle, traveledDistanceId, Double.class);
+    public void distanceOfShipmentInRoute(){
+        double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(2), vehicle,traveledDistanceId, Double.class);
         double traveledDistanceBeforeDelivery = stateManager.getActivityState(route.getActivities().get(4), vehicle, traveledDistanceId, Double.class);
-        assertEquals(90d, traveledDistanceBeforeDelivery - traveledDistanceBeforePickup, 0.01);
+        Assert.assertEquals(90d,traveledDistanceBeforeDelivery-traveledDistanceBeforePickup,0.01);
     }
 
     @Test
-    public void distanceOfShipmentInRouteVehicle2() {
-        double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(2), vehicle2, traveledDistanceId, Double.class);
+    public void distanceOfShipmentInRouteVehicle2(){
+        double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(2), vehicle2,traveledDistanceId, Double.class);
         double traveledDistanceBeforeDelivery = stateManager.getActivityState(route.getActivities().get(4), vehicle2, traveledDistanceId, Double.class);
-        assertEquals(90d, traveledDistanceBeforeDelivery - traveledDistanceBeforePickup, 0.01);
+        Assert.assertEquals(90d,traveledDistanceBeforeDelivery-traveledDistanceBeforePickup,0.01);
     }
 
     @Test
-    public void distanceOfPickupInRoute() {
+    public void distanceOfPickupInRoute(){
         double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(3), vehicle, traveledDistanceId, Double.class);
-        double total = stateManager.getRouteState(route, vehicle, traveledDistanceId, Double.class);
-        assertEquals(100d, total - traveledDistanceBeforePickup, 0.01);
+        double total = stateManager.getRouteState(route, vehicle,traveledDistanceId, Double.class);
+        Assert.assertEquals(100d,total-traveledDistanceBeforePickup,0.01);
     }
 
     @Test
-    public void distanceOfPickupInRouteVehicle2() {
+    public void distanceOfPickupInRouteVehicle2(){
         double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(3), vehicle2, traveledDistanceId, Double.class);
-        double total = stateManager.getRouteState(route, vehicle2, traveledDistanceId, Double.class);
-        assertEquals(80d, total - traveledDistanceBeforePickup, 0.01);
+        double total = stateManager.getRouteState(route, vehicle2,traveledDistanceId, Double.class);
+        Assert.assertEquals(80d,total-traveledDistanceBeforePickup,0.01);
     }
 
     @Test
-    public void distanceToTravelShouldBeCorrect() {
+    public void distanceToTravelShouldBeCorrect(){
         double total = stateManager.getRouteState(route, vehicle, traveledDistanceId, Double.class);
-        assertEquals(180d, total - stateManager.getActivityState(route.getActivities().get(0), vehicle, traveledDistanceId, Double.class), 0.01);
-        assertEquals(165d, total - stateManager.getActivityState(route.getActivities().get(1), vehicle, traveledDistanceId, Double.class), 0.01);
-        assertEquals(135d, total - stateManager.getActivityState(route.getActivities().get(2), vehicle, traveledDistanceId, Double.class), 0.01);
-        assertEquals(100d, total - stateManager.getActivityState(route.getActivities().get(3), vehicle, traveledDistanceId, Double.class), 0.01);
-        assertEquals(45d, total - stateManager.getActivityState(route.getActivities().get(4), vehicle, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(180d,total - stateManager.getActivityState(route.getActivities().get(0),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(165d, total - stateManager.getActivityState(route.getActivities().get(1), vehicle, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(135d,total - stateManager.getActivityState(route.getActivities().get(2),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(100d, total - stateManager.getActivityState(route.getActivities().get(3), vehicle, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(45d, total - stateManager.getActivityState(route.getActivities().get(4), vehicle, traveledDistanceId, Double.class), 0.01);
 
     }
 
     @Test
-    public void distanceToTravelShouldBeCorrectVehicle2() {
+    public void distanceToTravelShouldBeCorrectVehicle2(){
         double total = stateManager.getRouteState(route, vehicle2, traveledDistanceId, Double.class);
-        assertEquals(160d, total - stateManager.getActivityState(route.getActivities().get(0), vehicle2, traveledDistanceId, Double.class), 0.01);
-        assertEquals(145d, total - stateManager.getActivityState(route.getActivities().get(1), vehicle2, traveledDistanceId, Double.class), 0.01);
-        assertEquals(115d, total - stateManager.getActivityState(route.getActivities().get(2), vehicle2, traveledDistanceId, Double.class), 0.01);
-        assertEquals(80d, total - stateManager.getActivityState(route.getActivities().get(3), vehicle2, traveledDistanceId, Double.class), 0.01);
-        assertEquals(25d, total - stateManager.getActivityState(route.getActivities().get(4), vehicle2, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(160d,total - stateManager.getActivityState(route.getActivities().get(0),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(145d, total - stateManager.getActivityState(route.getActivities().get(1), vehicle2, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(115d,total - stateManager.getActivityState(route.getActivities().get(2),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(80d, total - stateManager.getActivityState(route.getActivities().get(3), vehicle2, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(25d, total - stateManager.getActivityState(route.getActivities().get(4), vehicle2, traveledDistanceId, Double.class), 0.01);
 
     }
+
+    @Test
+    public void whenAddingDeliverShipment_constraintShouldWork() {
+        Shipment shipment = Shipment.Builder.newInstance("s")
+            .setPickupLocation(Location.newInstance(0, 3))
+            .setDeliveryLocation(Location.newInstance(4, 0))
+            .build();
+        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v")
+            .setStartLocation(Location.newInstance(0, 0))
+            .build();
+        final VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
+            .addJob(shipment)
+            .addVehicle(vehicle)
+            .build();
+        VehicleRoute route = VehicleRoute.emptyRoute();
+        JobInsertionContext context = new JobInsertionContext(route, shipment, vehicle, null, 0);
+        context.getAssociatedActivities().add(vrp.getActivities(shipment).get(0));
+        context.getAssociatedActivities().add(vrp.getActivities(shipment).get(1));
+        maxDistanceMap = new HashMap<>();
+        maxDistanceMap.put(vehicle,12d);
+
+        StateManager stateManager = new StateManager(vrp);
+        MaxDistanceConstraint maxDistanceConstraint =
+            new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
+                @Override
+                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                }
+            },maxDistanceMap);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,
+            new Start(vehicle.getStartLocation(), 0, Double.MAX_VALUE),
+            vrp.getActivities(shipment).get(0),
+            new End(vehicle.getEndLocation(), 0, Double.MAX_VALUE),
+            0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+
+        ActivityContext pickupContext = new ActivityContext();
+        pickupContext.setArrivalTime(3);
+        pickupContext.setEndTime(3);
+        pickupContext.setInsertionIndex(0);
+        context.setRelatedActivityContext(pickupContext);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,
+            vrp.getActivities(shipment).get(0),
+            vrp.getActivities(shipment).get(1),
+            new End(vehicle.getEndLocation(), 0, Double.MAX_VALUE),
+            3).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+    }
+
+    @Test
+    public void whenAddingDeliverShipmentWithVehDiffStartEndLocs_constraintShouldWork() {
+        Shipment shipment = Shipment.Builder.newInstance("s")
+            .setPickupLocation(Location.newInstance(0, 1))
+            .setDeliveryLocation(Location.newInstance(4, 1))
+            .build();
+        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v")
+            .setStartLocation(Location.newInstance(0, 0))
+            .setEndLocation(Location.newInstance(0, 4))
+            .build();
+        final VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
+            .addJob(shipment)
+            .addVehicle(vehicle)
+            .build();
+        VehicleRoute route = VehicleRoute.emptyRoute();
+        JobInsertionContext context = new JobInsertionContext(route, shipment, vehicle, null, 0);
+        context.getAssociatedActivities().add(vrp.getActivities(shipment).get(0));
+        context.getAssociatedActivities().add(vrp.getActivities(shipment).get(1));
+        maxDistanceMap = new HashMap<>();
+        maxDistanceMap.put(vehicle,10d);
+
+        StateManager stateManager = new StateManager(vrp);
+        MaxDistanceConstraint maxDistanceConstraint =
+            new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
+                @Override
+                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                }
+            },maxDistanceMap);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,
+            new Start(vehicle.getStartLocation(), 0, Double.MAX_VALUE),
+            vrp.getActivities(shipment).get(0),
+            new End(vehicle.getEndLocation(), 0, Double.MAX_VALUE),
+            0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+
+        ActivityContext pickupContext = new ActivityContext();
+        pickupContext.setArrivalTime(1);
+        pickupContext.setEndTime(1);
+        pickupContext.setInsertionIndex(0);
+        context.setRelatedActivityContext(pickupContext);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,
+            vrp.getActivities(shipment).get(0),
+            vrp.getActivities(shipment).get(1),
+            new End(vehicle.getEndLocation(), 0, Double.MAX_VALUE),
+            1).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+    }
 }
