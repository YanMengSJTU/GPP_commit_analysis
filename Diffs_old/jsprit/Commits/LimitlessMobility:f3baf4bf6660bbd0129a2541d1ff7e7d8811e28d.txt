diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/HereAPIs.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/HereAPIs.java
new file mode 100644
index 000000000..cdbf43612
--- /dev/null
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/HereAPIs.java
@@ -0,0 +1,340 @@
+package com.graphhopper.jsprit.examples;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Iterator;
+import java.util.List;
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonIOException;
+import com.graphhopper.jsprit.core.util.VehicleRoutingTransportCostsMatrix;
+import org.json.simple.parser.ParseException;
+
+//@Controller 
+//@RequestMapping("/HereAPIs")
+public class HereAPIs {
+	
+//@RequestMapping(value = "/HereDTMatrix")
+//@ResponseBody
+public VehicleRoutingTransportCostsMatrix HereDTMatrix_Truck(Locations locations) throws JsonIOException, ParseException, NumberFormatException, IOException {
+	
+	String output = "";
+	String toReturn = "";
+	String urlBuild_Start = "";
+	String urlBuild_Destination = "";
+	LocationAPI forEach = null;
+	List<LocationAPI> passLocations = locations.getLocations();
+	Iterator<LocationAPI> itLoc = passLocations.listIterator();
+
+	System.out.println("Latitude"+passLocations.size());
+	int i=0;
+	while (itLoc.hasNext())
+	{
+		forEach = itLoc.next(); 
+		urlBuild_Start += "start" + String.valueOf(i)+ "=" + forEach.getLatitude() + "," + forEach.getLongitude() + "&";
+		urlBuild_Destination += "destination" + String.valueOf(i)+ "=" + forEach.getLatitude() + "," + forEach.getLongitude() + "&";
+		i++;
+		
+	}
+
+	
+try {
+
+	URL url = new URL("https://matrix.route.cit.api.here.com/routing/7.2/calculatematrix.json?"+ urlBuild_Start + urlBuild_Destination+ "summaryAttributes=distance,traveltime&mode=fastest;truck&app_id=o5HCoO8n10C0uaygGbVR&app_code=FWOiaUCYVfglvEqXWNDbKQ");
+	HttpURLConnection conn = (HttpURLConnection) url.openConnection();
+	
+	 conn.setRequestProperty("Content-Type", "application/json"); 
+	 conn.setRequestProperty("charset", "utf-8");
+	 conn.setRequestProperty("Accept-Language","en");
+	
+	System.out.println("Response Code" +conn.getResponseCode());
+	if (conn.getResponseCode() != 200) {
+		throw new RuntimeException("Failed : HTTP error code : "
+				+ conn.getResponseCode());
+	}
+
+	BufferedReader br = new BufferedReader(new InputStreamReader(
+		(conn.getInputStream())));
+
+	
+	System.out.println("Output from Server .... \n");
+	while ((output = br.readLine()) != null) {
+		System.out.println(output);
+		toReturn += output;
+	}
+	
+	conn.disconnect();
+	
+	 
+  } catch (MalformedURLException e) {
+	  System.out.println(e);
+	e.printStackTrace();
+
+  } catch (IOException e) {
+	  System.out.println(e);
+	e.printStackTrace();
+
+  }
+
+
+
+	VehicleRoutingTransportCostsMatrix.Builder costMatrixBuilder = VehicleRoutingTransportCostsMatrix.Builder.newInstance(true);
+	Gson gson = new GsonBuilder().create();
+	Here_Response res = gson.fromJson(toReturn, Here_Response.class);
+	
+	MatrixEntry matrixEntry = null;
+	Iterator<MatrixEntry> ME = res.getResponse().getMatrixEntry().listIterator();
+	LocationAPI startLocation, endLocation;
+	
+	while (ME.hasNext()) {
+		matrixEntry = ME.next();
+		startLocation = passLocations.get(Integer.parseInt(matrixEntry.getStartIndex()));
+		endLocation = 	passLocations.get(Integer.parseInt(matrixEntry.getDestinationIndex()));
+		
+		if (matrixEntry.getStatus() != null && matrixEntry.getStatus().contains("failed")) 
+		{
+			//Point does not have truck route for delivery, get normal car values and place in Matrix.
+			MatrixEntry entry = matrixEntry;
+			
+			entry = GetCarRoute_2points(
+					passLocations.get(Integer.parseInt(matrixEntry.getStartIndex())).getLatitude()
+					+","+ 
+					passLocations.get(Integer.parseInt(matrixEntry.getStartIndex())).getLongitude() ,
+					passLocations.get(Integer.parseInt(matrixEntry.getDestinationIndex())).getLatitude()
+					+","+ 
+					passLocations.get(Integer.parseInt(matrixEntry.getDestinationIndex())).getLongitude()
+					);
+			
+			//return the value of the obtained path for points in car distance.
+				
+			costMatrixBuilder.addTransportDistance(startLocation.getId() ,endLocation.getId(),
+					Double.parseDouble(entry.getSummary().getDistance())) ;
+			costMatrixBuilder.addTransportTime(startLocation.getId() ,endLocation.getId(),
+					Double.parseDouble(entry.getSummary().getTravelTime())) ;	
+		}
+		else
+		{
+		
+		//continue with building costMatrix, if truck route available build directly, else fetch Car route and then build into matrix.
+		System.out.println("startid"+startLocation.getId()+" Endid"+endLocation.getId() +"Distance" +Double.parseDouble(matrixEntry.getSummary().getDistance()));
+		
+		costMatrixBuilder.addTransportDistance(startLocation.getId() ,endLocation.getId(),
+				Double.parseDouble(matrixEntry.getSummary().getDistance())) ;
+			
+		System.out.println("startid"+startLocation.getId()+" Endid"+endLocation.getId() + " Time" +Double.parseDouble(matrixEntry.getSummary().getTravelTime()));
+		costMatrixBuilder.addTransportTime(startLocation.getId() ,endLocation.getId(),
+				Double.parseDouble(matrixEntry.getSummary().getTravelTime())) ;	
+		
+		}
+		
+	}
+		  
+	return costMatrixBuilder.build();
+}
+
+//from and to should be in the format: latitude,longitude
+public MatrixEntry GetCarRoute_2points(String from, String to) throws IOException
+{
+	
+	String toReturn="";
+	URL url = new URL("https://matrix.route.cit.api.here.com/routing/7.2/calculatematrix.json?start0=" + from + "&destination0="+ to+"&summaryAttributes=distance,traveltime&mode=fastest;car&app_id=o5HCoO8n10C0uaygGbVR&app_code=FWOiaUCYVfglvEqXWNDbKQ");
+	HttpURLConnection conn = (HttpURLConnection) url.openConnection();
+	 conn.setRequestProperty("Content-Type", "application/json"); 
+	 conn.setRequestProperty("charset", "utf-8");
+	 conn.setRequestProperty("Accept-Language","en");
+	if (conn.getResponseCode() != 200) {
+		throw new RuntimeException("Failed : HTTP error code : "
+				+ conn.getResponseCode());
+	}
+
+	BufferedReader br = new BufferedReader(new InputStreamReader(
+		(conn.getInputStream())));
+
+	
+	//System.out.println("Output from Server for car Route .... \n");
+	String output;
+	while ((output = br.readLine()) != null) {
+		System.out.println(output);
+		 toReturn = output;
+	}
+	conn.disconnect();
+	
+	Gson gson = new GsonBuilder().create();
+	Here_Response res = gson.fromJson(toReturn, Here_Response.class);
+	return res.getResponse().getMatrixEntry().get(0);
+}
+
+public class LocationAPI {
+
+	String id;
+	String latitude;
+	String longitude;
+	
+	public String getLatitude() {
+		return latitude;
+	}
+	public void setLatitude(String latitude) {
+		this.latitude = latitude;
+	}
+	public String getLongitude() {
+		return longitude;
+	}
+	public void setLongitude(String longitude) {
+		this.longitude = longitude;
+	}
+	public String getId() {
+		return id;
+	}
+	public void setId(String id) {
+		this.id = id;
+	}
+	
+}
+public class Here_Response 
+
+{
+
+	private Data response;
+
+	public Data getResponse() {
+		return response;
+	}
+
+	public void setResponse(Data response) {
+		this.response = response;
+	}
+	
+ }
+
+public class Data
+{
+	private MetaInfo metaInfo;
+    private List<MatrixEntry> matrixEntry;
+    
+	public MetaInfo getMetaInfo() {
+		return metaInfo;
+	}
+	public void setMetaInfo(MetaInfo metaInfo) {
+		this.metaInfo = metaInfo;
+	}
+	public List<MatrixEntry> getMatrixEntry() {
+		return matrixEntry;
+	}
+	public void setMatrixEntry(List<MatrixEntry> matrixEntry) {
+		this.matrixEntry = matrixEntry;
+	}
+      
+
+}
+public class MetaInfo
+{
+	private String timestamp;
+	private String mapVersion;
+	private String moduleVersion;
+	private List<String> availableMapVersion;
+	
+	public String getTimestamp() {
+		return timestamp;
+	}
+	public void setTimestamp(String timestamp) {
+		this.timestamp = timestamp;
+	}
+	public String getMapVersion() {
+		return mapVersion;
+	}
+	public void setMapVersion(String mapVersion) {
+		this.mapVersion = mapVersion;
+	}
+	public String getModuleVersion() {
+		return moduleVersion;
+	}
+	public void setModuleVersion(String moduleVersion) {
+		this.moduleVersion = moduleVersion;
+	}
+	public List<String> getAvailableMapVersion() {
+		return availableMapVersion;
+	}
+	public void setAvailableMapVersion(List<String> availableMapVersion) {
+		this.availableMapVersion = availableMapVersion;
+	}
+	
+}
+public class MatrixEntry
+{
+	private String startIndex;
+	private String destinationIndex;
+	private Summary summary;
+	private String status;
+	
+	public String getStartIndex() {
+		return startIndex;
+	}
+	public void setStartIndex(String startIndex) {
+		this.startIndex = startIndex;
+	}
+	public String getDestinationIndex() {
+		return destinationIndex;
+	}
+	public void setDestinationIndex(String destinationIndex) {
+		this.destinationIndex = destinationIndex;
+	}
+	public Summary getSummary() {
+		return summary;
+	}
+	public void setSummary(Summary summary) {
+		this.summary = summary;
+	}
+	public String getStatus() {
+		return status;
+	}
+	public void setStatus(String status) {
+		this.status = status;
+	}
+	
+
+}
+public class Summary
+{
+	private String distance;
+	private String travelTime;
+	private String costFactor;
+	
+	public String getDistance() {
+		return distance;
+	}
+	public void setDistance(String distance) {
+		this.distance = distance;
+	}
+	public String getTravelTime() {
+		return travelTime;
+	}
+	public void setTravelTime(String travelTime) {
+		this.travelTime = travelTime;
+	}
+	public String getCostFactor() {
+		return costFactor;
+	}
+	public void setCostFactor(String costFactor) {
+		this.costFactor = costFactor;
+	}
+	
+	
+}
+public class Locations {
+List<LocationAPI> locations;
+
+public List<LocationAPI> getLocations() {
+	return locations;
+}
+
+public void setLocations(List<LocationAPI> locations) {
+	this.locations = locations;
+}
+
+
+}
+}
\ No newline at end of file
