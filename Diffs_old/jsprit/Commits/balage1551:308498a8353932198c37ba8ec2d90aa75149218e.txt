diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculatorV2.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculatorV2.java
new file mode 100644
index 000000000..5190f1550
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculatorV2.java
@@ -0,0 +1,375 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.jsprit.core.algorithm.recreate;
+
+import com.graphhopper.jsprit.core.problem.constraint.*;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
+import com.graphhopper.jsprit.core.problem.driver.Driver;
+import com.graphhopper.jsprit.core.problem.job.Job;
+import com.graphhopper.jsprit.core.problem.misc.ActivityContext;
+import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.*;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+
+final class GeneralJobInsertionCalculatorV2 implements JobInsertionCostsCalculator {
+
+    static class ActAndIndex {
+
+        private int index;
+
+        private TourActivity act;
+
+        public ActAndIndex(int index, TourActivity act) {
+            this.index = index;
+            this.act = act;
+        }
+    }
+
+    static class IndexedTourActivity {
+
+        int index;
+
+        TourActivity act;
+
+        public IndexedTourActivity(int index, TourActivity act) {
+            this.index = index;
+            this.act = act;
+        }
+
+        void setTourActivity(TourActivity act) {
+            this.act = act;
+        }
+    }
+
+    static class Route {
+
+        private IndexedTourActivity[] acts;
+
+        private int[] successors;
+
+        private int[] predecessors;
+
+        private IndexedTourActivity first;
+
+        private List<IndexedTourActivity> actsToInsert;
+
+        public Route(List<IndexedTourActivity> currentRoute, List<IndexedTourActivity> toInsert) {
+            actsToInsert = toInsert;
+            successors = new int[currentRoute.size() + toInsert.size()];
+            predecessors = new int[currentRoute.size() + toInsert.size()];
+            for (int i = 0; i < successors.length; i++) {
+                successors[i] = -1;
+                predecessors[i] = -1;
+            }
+            first = currentRoute.get(0);
+            ini(currentRoute, toInsert);
+        }
+
+        private void ini(List<IndexedTourActivity> currentRoute, List<IndexedTourActivity> toInsert) {
+            acts = new IndexedTourActivity[currentRoute.size() + toInsert.size()];
+            IndexedTourActivity prevAct = currentRoute.get(0);
+            acts[prevAct.index] = prevAct;
+            for (int i = 1; i < currentRoute.size(); i++) {
+                acts[currentRoute.get(i).index] = currentRoute.get(i);
+                setSuccessor(prevAct, currentRoute.get(i));
+                setPredecessor(currentRoute.get(i), prevAct);
+                prevAct = currentRoute.get(i);
+            }
+            for (IndexedTourActivity actToInsert : toInsert) {
+                acts[actToInsert.index] = actToInsert;
+            }
+        }
+
+        public IndexedTourActivity getFirst() {
+            return first;
+        }
+
+        void addAfter(IndexedTourActivity toInsert, IndexedTourActivity after) {
+            IndexedTourActivity actAfterAfter = getSuccessor(after);
+            setSuccessor(after, toInsert);
+            setSuccessor(toInsert, actAfterAfter);
+            setPredecessor(toInsert, after);
+            setPredecessor(actAfterAfter, toInsert);
+        }
+
+        IndexedTourActivity addAfter(JobActivity toInsert_, IndexedTourActivity after) {
+            IndexedTourActivity toInsert = find(toInsert_);
+            toInsert.setTourActivity(toInsert_);
+            IndexedTourActivity actAfterAfter = getSuccessor(after);
+            setSuccessor(after, toInsert);
+            setSuccessor(toInsert, actAfterAfter);
+            setPredecessor(toInsert, after);
+            setPredecessor(actAfterAfter, toInsert);
+            return toInsert;
+        }
+
+        private IndexedTourActivity find(JobActivity toInsert_) {
+            for (IndexedTourActivity a : actsToInsert) {
+                if (a.act.getIndex() == toInsert_.getIndex()) {
+                    return a;
+                }
+            }
+            throw new IllegalStateException("should not be");
+        }
+
+
+        void setSuccessor(IndexedTourActivity act, IndexedTourActivity successor) {
+            if (successor == null) successors[act.index] = -1;
+            else successors[act.index] = successor.index;
+        }
+
+        void setPredecessor(IndexedTourActivity act, IndexedTourActivity predecessor) {
+            if (predecessor == null) predecessors[act.index] = -1;
+            else predecessors[act.index] = predecessor.index;
+        }
+
+        void remove(IndexedTourActivity toRemove) {
+            IndexedTourActivity predecessor = getPredecessor(toRemove);
+            IndexedTourActivity successor = getSuccessor(toRemove);
+            setSuccessor(toRemove, null);
+            setPredecessor(toRemove, null);
+            setSuccessor(predecessor, successor);
+            setPredecessor(successor, predecessor);
+        }
+
+        void remove(JobActivity toRemove_) {
+            IndexedTourActivity toRemove = find(toRemove_);
+            IndexedTourActivity predecessor = getPredecessor(toRemove);
+            IndexedTourActivity successor = getSuccessor(toRemove);
+            setSuccessor(toRemove, null);
+            setPredecessor(toRemove, null);
+            setSuccessor(predecessor, successor);
+            setPredecessor(successor, predecessor);
+        }
+
+        IndexedTourActivity getSuccessor(IndexedTourActivity act) {
+            if (hasSuccessor(act)) {
+                return acts[successors[act.index]];
+            }
+            return null;
+        }
+
+        IndexedTourActivity getPredecessor(IndexedTourActivity act) {
+            if (hasPredecessor(act)) {
+                return acts[predecessors[act.index]];
+            }
+            return null;
+        }
+
+        boolean hasSuccessor(IndexedTourActivity act) {
+            return successors[act.index] != -1;
+        }
+
+        boolean hasPredecessor(IndexedTourActivity act) {
+            return predecessors[act.index] != -1;
+        }
+
+        Route copy() {
+            return null;
+        }
+
+        public ActAndIndex indexOf(TourActivity activity) {
+            int i = 0;
+            IndexedTourActivity prev = getFirst();
+            while (hasSuccessor(prev)) {
+                IndexedTourActivity succ = getSuccessor(prev);
+                if (succ.act.getIndex() == activity.getIndex()) {
+                    return new ActAndIndex(i + 1, succ.act);
+                }
+                i++;
+                prev = succ;
+            }
+            return null;
+        }
+
+    }
+
+    private static final Logger logger = LoggerFactory.getLogger(GeneralJobInsertionCalculatorV2.class);
+
+    private HardRouteConstraint hardRouteLevelConstraint;
+
+    private HardActivityConstraint hardActivityLevelConstraint;
+
+    private SoftRouteConstraint softRouteConstraint;
+
+    private SoftActivityConstraint softActivityConstraint;
+
+    private ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
+
+    private VehicleRoutingTransportCosts transportCosts;
+
+    private VehicleRoutingActivityCosts activityCosts;
+
+    private AdditionalAccessEgressCalculator additionalAccessEgressCalculator;
+
+    public GeneralJobInsertionCalculatorV2(VehicleRoutingTransportCosts routingCosts, VehicleRoutingActivityCosts activityCosts, ActivityInsertionCostsCalculator activityInsertionCostsCalculator, ConstraintManager constraintManager) {
+        super();
+        this.activityInsertionCostsCalculator = activityInsertionCostsCalculator;
+        hardRouteLevelConstraint = constraintManager;
+        hardActivityLevelConstraint = constraintManager;
+        softActivityConstraint = constraintManager;
+        softRouteConstraint = constraintManager;
+        transportCosts = routingCosts;
+        this.activityCosts = activityCosts;
+        additionalAccessEgressCalculator = new AdditionalAccessEgressCalculator(routingCosts);
+        logger.debug("initialise {}", this);
+    }
+
+    @Override
+    public String toString() {
+        return "[name=calculatesServiceInsertion]";
+    }
+
+    /**
+     * Calculates the marginal cost of inserting job i locally. This is based on the
+     * assumption that cost changes can entirely covered by only looking at the predecessors i-1 and its successor i+1.
+     */
+    @Override
+    public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job jobToInsert, final Vehicle newVehicle, double newVehicleDepartureTime, final Driver newDriver, final double bestKnownCosts) {
+        JobInsertionContext insertionContext = new JobInsertionContext(currentRoute, jobToInsert, newVehicle, newDriver, newVehicleDepartureTime);
+        List<JobActivity> actList = jobToInsert.getActivityList().getAllDuplicated();
+        insertionContext.getAssociatedActivities().addAll(actList);
+        /*
+        check hard route constraints
+         */
+        if (!hardRouteLevelConstraint.fulfilled(insertionContext)) {
+            return InsertionData.createEmptyInsertionData();
+        }
+        /*
+        check soft route constraints
+         */
+        double additionalICostsAtRouteLevel = softRouteConstraint.getCosts(insertionContext);
+        additionalICostsAtRouteLevel += additionalAccessEgressCalculator.getCosts(insertionContext);
+
+        Start start = new Start(newVehicle.getStartLocation(), newVehicle.getEarliestDeparture(), newVehicle.getLatestArrival());
+        start.setEndTime(newVehicleDepartureTime);
+        End end = new End(newVehicle.getEndLocation(), 0.0, newVehicle.getLatestArrival());
+
+        List<TourActivity> newRoute = new ArrayList<>();
+        newRoute.add(start);
+        newRoute.addAll(currentRoute.getTourActivities().getActivities());
+        newRoute.add(end);
+
+        List<IndexedTourActivity> current = makeIndices(newRoute, 0);
+        List<IndexedTourActivity> actsToInsert = makeIndices(actList, current.size());
+        Route route = new Route(current, actsToInsert);
+
+        List<Integer> insertionIndeces = new ArrayList<>();
+        List<InsertionData> bestData = calculateInsertionCosts(insertionContext, 0, route.getFirst(), route, actList, additionalICostsAtRouteLevel, newVehicleDepartureTime, insertionIndeces);
+        if (bestData.isEmpty()) {
+            return InsertionData.createEmptyInsertionData();
+        } else {
+            InsertionData best = InsertionData.createEmptyInsertionData();
+            for (InsertionData iD : bestData) {
+                if (iD.getInsertionCost() < best.getInsertionCost()) {
+                    best = iD;
+                }
+            }
+            return best;
+        }
+    }
+
+    private List<IndexedTourActivity> makeIndices(List<? extends TourActivity> acts, int startIndex) {
+        int index = startIndex;
+        List<IndexedTourActivity> indexed = new ArrayList<>();
+        for (TourActivity act : acts) {
+            indexed.add(new IndexedTourActivity(index, act));
+            index++;
+        }
+        return indexed;
+    }
+
+    private List<InsertionData> calculateInsertionCosts(JobInsertionContext insertionContext, int startIndex, IndexedTourActivity startAct, Route route, List<JobActivity> actList, double additionalCosts, double departureTime, List<Integer> insertionIndeces) {
+        List<InsertionData> iData = new ArrayList<>();
+        double departureTimeAtPrevAct = departureTime;
+        IndexedTourActivity prevAct = startAct;
+        int index = startIndex;
+        while (route.hasSuccessor(prevAct)) {
+            JobActivity jobActivity = actList.get(0);
+            if (jobActivity.getTimeWindows().isEmpty()) {
+                throw new IllegalStateException("at least a single time window must be set");
+            }
+            for (TimeWindow timeWindow : jobActivity.getTimeWindows()) {
+                JobActivity copiedJobActivity = (JobActivity) jobActivity.duplicate();
+                copiedJobActivity.setTheoreticalEarliestOperationStartTime(timeWindow.getStart());
+                copiedJobActivity.setTheoreticalLatestOperationStartTime(timeWindow.getEnd());
+                ActivityContext activityContext = new ActivityContext();
+                activityContext.setInsertionIndex(index + 1);
+                insertionContext.setActivityContext(activityContext);
+                HardActivityConstraint.ConstraintsStatus constraintStatus = hardActivityLevelConstraint.fulfilled(insertionContext, prevAct.act, copiedJobActivity, route.getSuccessor(prevAct).act, departureTimeAtPrevAct);
+                if (constraintStatus.equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED)) {
+                    continue;
+                } else if (constraintStatus.equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED_BREAK)) {
+                    return iData;
+                }
+                double miscCosts = softActivityConstraint.getCosts(insertionContext, prevAct.act, copiedJobActivity, route.getSuccessor(prevAct).act, departureTimeAtPrevAct);
+                double c = calculate(insertionContext, prevAct.act, copiedJobActivity, route.getSuccessor(prevAct).act, departureTimeAtPrevAct);
+                IndexedTourActivity toInsert = route.addAfter(copiedJobActivity, prevAct);
+                double totalCosts = additionalCosts + c + miscCosts;
+                if (actList.size() == 1) {
+                    InsertionData iD = new InsertionData(totalCosts, insertionContext.getNewDepTime(), insertionContext.getNewVehicle(), insertionContext.getNewDriver());
+                    iD.getEvents().add(new SwitchVehicle(insertionContext.getRoute(), insertionContext.getNewVehicle(), insertionContext.getNewDepTime()));
+                    iD.getEvents().addAll(getInsertActivityEvents(insertionContext, route));
+                    iData.add(iD);
+
+                } else {
+                    double departureTimeFromJobActivity = getDeparture(prevAct.act, copiedJobActivity, departureTimeAtPrevAct, insertionContext.getNewDriver(), insertionContext.getNewVehicle());
+                    insertionIndeces.add(index + 1);
+                    List<InsertionData> insertions = calculateInsertionCosts(insertionContext, index + 1, toInsert, route, actList.subList(1, actList.size()), totalCosts, departureTimeFromJobActivity, insertionIndeces);
+                    iData.addAll(insertions);
+                }
+                route.remove(toInsert);
+            }
+            departureTimeAtPrevAct = getDeparture(prevAct.act, route.getSuccessor(prevAct).act, departureTimeAtPrevAct, insertionContext.getNewDriver(), insertionContext.getNewVehicle());
+            prevAct = route.getSuccessor(prevAct);
+            index++;
+        }
+        return iData;
+    }
+
+    private double getDeparture(TourActivity prevAct, TourActivity activity, double departureTimeAtPrevAct, Driver driver, Vehicle vehicle) {
+        double actArrTime = departureTimeAtPrevAct + transportCosts.getTransportTime(prevAct.getLocation(), activity.getLocation(), departureTimeAtPrevAct, driver, vehicle);
+        double actStart = Math.max(actArrTime, activity.getTheoreticalEarliestOperationStartTime());
+        return actStart + activityCosts.getActivityDuration(activity, actArrTime, driver, vehicle);
+    }
+
+    private Collection<? extends Event> getInsertActivityEvents(JobInsertionContext insertionContext, Route modifiedRoute) {
+        List<InsertActivity> insertActivities = new ArrayList<>();
+        for (int i = insertionContext.getAssociatedActivities().size() - 1; i >= 0; i--) {
+            TourActivity activity = insertionContext.getAssociatedActivities().get(i);
+            ActAndIndex actAndIndex = modifiedRoute.indexOf(activity);
+            insertActivities.add(new InsertActivity(insertionContext.getRoute(), insertionContext.getNewVehicle(),
+                actAndIndex.act, actAndIndex.index - i - 1));
+        }
+        return insertActivities;
+    }
+
+    private double calculate(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double departureTimeAtPrevAct) {
+        return activityInsertionCostsCalculator.getCosts(iFacts, prevAct, nextAct, newAct, departureTimeAtPrevAct);
+
+    }
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java
index 56fb99b42..8b5ad42af 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java
@@ -272,7 +272,7 @@ private CalculatorPlusListeners createStandardLocal(final VehicleRoutingProblem
 //        ServiceInsertionCalculator serviceInsertion = new ServiceInsertionCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(), actInsertionCalc, constraintManager);
 //        serviceInsertion.setJobActivityFactory(activityFactory);
 
-        GeneralJobInsertionCalculator generalJobInsertionCalculator = new GeneralJobInsertionCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(), actInsertionCalc, constraintManager);
+        GeneralJobInsertionCalculatorV2 generalJobInsertionCalculator = new GeneralJobInsertionCalculatorV2(vrp.getTransportCosts(), vrp.getActivityCosts(), actInsertionCalc, constraintManager);
 
         BreakInsertionCalculator breakInsertionCalculator = new BreakInsertionCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(), actInsertionCalc, constraintManager);
         breakInsertionCalculator.setJobActivityFactory(activityFactory);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndLoadConstraintsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndLoadConstraintsTest.java
index 05c655807..be8214941 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndLoadConstraintsTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndLoadConstraintsTest.java
@@ -85,7 +85,7 @@ public boolean fulfilled(JobInsertionContext insertionContext) {
 
     ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
 
-    GeneralJobInsertionCalculator insertionCalculator;
+    GeneralJobInsertionCalculatorV2 insertionCalculator;
 
     VehicleRoutingProblem vehicleRoutingProblem;
 
@@ -104,7 +104,7 @@ public void doBefore() {
     private void createInsertionCalculator(HardRouteConstraint hardRouteLevelConstraint) {
         ConstraintManager constraintManager = new ConstraintManager(mock(VehicleRoutingProblem.class), mock(RouteAndActivityStateGetter.class));
         constraintManager.addConstraint(hardRouteLevelConstraint);
-        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        insertionCalculator = new GeneralJobInsertionCalculatorV2(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
     }
 
     @Test
@@ -129,7 +129,7 @@ public void whenInsertingServiceWhileNoCapIsAvailable_itMustReturnTheCorrectInse
         constraintManager.addLoadConstraint();
         stateManager.informInsertionStarts(Arrays.asList(route), null);
 
-        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        insertionCalculator = new GeneralJobInsertionCalculatorV2(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
 
         InsertionData iData = insertionCalculator.getInsertionData(route, pickup, vehicle, 0, DriverImpl.noDriver(), Double.MAX_VALUE);
         List<InsertActivity> insertActivities = iData.getUnmodifiableEventsByType(InsertActivity.class);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndTimeWindowConstraintsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndTimeWindowConstraintsTest.java
index bfc79a700..ff0243e50 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndTimeWindowConstraintsTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndTimeWindowConstraintsTest.java
@@ -85,7 +85,7 @@ public boolean fulfilled(JobInsertionContext insertionContext) {
 
     ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
 
-    GeneralJobInsertionCalculator insertionCalculator;
+    GeneralJobInsertionCalculatorV2 insertionCalculator;
 
     VehicleRoutingProblem vehicleRoutingProblem;
 
@@ -104,7 +104,7 @@ public void doBefore() {
     private void createInsertionCalculator(HardRouteConstraint hardRouteLevelConstraint) {
         ConstraintManager constraintManager = new ConstraintManager(mock(VehicleRoutingProblem.class), mock(RouteAndActivityStateGetter.class));
         constraintManager.addConstraint(hardRouteLevelConstraint);
-        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        insertionCalculator = new GeneralJobInsertionCalculatorV2(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
     }
 
     @Test
@@ -131,7 +131,7 @@ public void whenInsertingServiceWithTW_itMustReturnTheCorrectInsertionIndex() {
         constraintManager.addTimeWindowConstraint();
         stateManager.informInsertionStarts(Arrays.asList(route), null);
 
-        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        insertionCalculator = new GeneralJobInsertionCalculatorV2(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
 
         InsertionData iData = insertionCalculator.getInsertionData(route, pickup, vehicle, 0, DriverImpl.noDriver(), Double.MAX_VALUE);
         Assert.assertTrue(iData instanceof InsertionData.NoInsertionFound);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculatorTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculatorTest.java
new file mode 100644
index 000000000..0475d6a94
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculatorTest.java
@@ -0,0 +1,95 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.graphhopper.jsprit.core.algorithm.recreate;
+
+
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.Arrays;
+
+import static org.mockito.Mockito.mock;
+
+/**
+ * Created by schroeder on 19/11/16.
+ */
+public class GeneralJobInsertionCalculatorTest {
+
+    GeneralJobInsertionCalculatorV2.IndexedTourActivity start;
+
+    GeneralJobInsertionCalculatorV2.IndexedTourActivity act;
+
+    GeneralJobInsertionCalculatorV2.IndexedTourActivity end;
+
+    GeneralJobInsertionCalculatorV2.IndexedTourActivity toInsert;
+
+    @Before
+    public void doBefore() {
+        start = new GeneralJobInsertionCalculatorV2.IndexedTourActivity(0, mock(TourActivity.class));
+        act = new GeneralJobInsertionCalculatorV2.IndexedTourActivity(1, mock(TourActivity.class));
+        end = new GeneralJobInsertionCalculatorV2.IndexedTourActivity(2, mock(TourActivity.class));
+        toInsert = new GeneralJobInsertionCalculatorV2.IndexedTourActivity(3, mock(TourActivity.class));
+    }
+
+    @Test
+    public void testSuccessor() {
+        GeneralJobInsertionCalculatorV2.Route route = new GeneralJobInsertionCalculatorV2.Route(Arrays.asList(start, act, end), Arrays.asList(toInsert));
+        Assert.assertEquals(start, route.getFirst());
+        Assert.assertEquals(act, route.getSuccessor(route.getFirst()));
+        Assert.assertEquals(end, route.getSuccessor(act));
+        Assert.assertEquals(null, route.getSuccessor(toInsert));
+    }
+
+    @Test
+    public void testPredecessor() {
+        GeneralJobInsertionCalculatorV2.Route route = new GeneralJobInsertionCalculatorV2.Route(Arrays.asList(start, act, end), Arrays.asList(toInsert));
+        Assert.assertEquals(null, route.getPredecessor(route.getFirst()));
+        Assert.assertEquals(route.getFirst(), route.getPredecessor(act));
+        Assert.assertEquals(act, route.getPredecessor(route.getSuccessor(act)));
+        Assert.assertEquals(null, route.getSuccessor(toInsert));
+    }
+
+    @Test
+    public void insertNew() {
+        GeneralJobInsertionCalculatorV2.Route route = new GeneralJobInsertionCalculatorV2.Route(Arrays.asList(start, act, end), Arrays.asList(toInsert));
+        Assert.assertEquals(route.getFirst(), route.getPredecessor(act));
+        route.addAfter(toInsert, route.getFirst());
+        Assert.assertEquals(toInsert, route.getPredecessor(act));
+        Assert.assertEquals(route.getFirst(), route.getPredecessor(toInsert));
+        Assert.assertEquals(start, route.getFirst());
+        Assert.assertEquals(toInsert, route.getSuccessor(route.getFirst()));
+        Assert.assertEquals(act, route.getSuccessor(toInsert));
+    }
+
+    @Test
+    public void removeAct() {
+        GeneralJobInsertionCalculatorV2.Route route = new GeneralJobInsertionCalculatorV2.Route(Arrays.asList(start, act, end), Arrays.asList(toInsert));
+        Assert.assertEquals(route.getFirst(), route.getPredecessor(act));
+        route.remove(act);
+        Assert.assertEquals(null, route.getPredecessor(act));
+        Assert.assertEquals(null, route.getSuccessor(act));
+        Assert.assertEquals(start, route.getFirst());
+        Assert.assertEquals(end, route.getSuccessor(start));
+
+    }
+
+
+}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesAndLoadConstraintsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesAndLoadConstraintsTest.java
index 4c010764d..c1747586a 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesAndLoadConstraintsTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesAndLoadConstraintsTest.java
@@ -84,7 +84,7 @@ public boolean fulfilled(JobInsertionContext insertionContext) {
 
     ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
 
-    GeneralJobInsertionCalculator insertionCalculator;
+    GeneralJobInsertionCalculatorV2 insertionCalculator;
 
     VehicleRoutingProblem vehicleRoutingProblem;
 
@@ -121,7 +121,7 @@ public void whenInsertingServiceWhileNoCapIsAvailable_itMustReturnTheCorrectInse
         constraintManager.addLoadConstraint();
         stateManager.informInsertionStarts(Arrays.asList(route), null);
 
-        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        insertionCalculator = new GeneralJobInsertionCalculatorV2(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
 
         InsertionData iData = insertionCalculator.getInsertionData(route, pickup, vehicle, 0, DriverImpl.noDriver(), Double.MAX_VALUE);
         List<InsertActivity> insertActivities = iData.getUnmodifiableEventsByType(InsertActivity.class);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesTest.java
index f09d9db75..74e4b0965 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesTest.java
@@ -50,7 +50,7 @@
 
 public class GeneralJobInsertionWithServicesTest {
 
-    GeneralJobInsertionCalculator jobInsertion;
+    GeneralJobInsertionCalculatorV2 jobInsertion;
 
     VehicleRoutingTransportCosts costs;
 
@@ -127,7 +127,7 @@ public double getTransportCost(Location from, Location to, double departureTime,
 
         VehicleRoutingActivityCosts actCosts = mock(VehicleRoutingActivityCosts.class);
 
-        jobInsertion = new GeneralJobInsertionCalculator(costs, vrp.getActivityCosts(), new LocalActivityInsertionCostsCalculator(costs, actCosts, states), cManager);
+        jobInsertion = new GeneralJobInsertionCalculatorV2(costs, vrp.getActivityCosts(), new LocalActivityInsertionCostsCalculator(costs, actCosts, states), cManager);
     }
 
     @Test
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithShipmentsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithShipmentsTest.java
index 3dab8a0d4..b1fc0e681 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithShipmentsTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithShipmentsTest.java
@@ -85,7 +85,7 @@ public boolean fulfilled(JobInsertionContext insertionContext) {
 
     ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
 
-    GeneralJobInsertionCalculator insertionCalculator;
+    GeneralJobInsertionCalculatorV2 insertionCalculator;
 
     Vehicle vehicle;
 
@@ -102,12 +102,13 @@ public void doBefore() {
     private void createInsertionCalculator(HardRouteConstraint hardRouteLevelConstraint) {
         ConstraintManager constraintManager = new ConstraintManager(mock(VehicleRoutingProblem.class), mock(RouteAndActivityStateGetter.class));
         constraintManager.addConstraint(hardRouteLevelConstraint);
-        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        insertionCalculator = new GeneralJobInsertionCalculatorV2(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
     }
 
     @Test
     public void whenCalculatingInsertionCostsOfShipment_itShouldReturnCorrectCostValue() {
         Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
+        VehicleRoutingProblem.Builder.newInstance().addJob(shipment).build();
         VehicleRoute route = VehicleRoute.emptyRoute();
         InsertionData iData = insertionCalculator.getInsertionData(route, shipment, vehicle, 0.0, null, Double.MAX_VALUE);
         assertEquals(40.0, iData.getInsertionCost(), 0.05);
@@ -117,6 +118,9 @@ public void whenCalculatingInsertionCostsOfShipment_itShouldReturnCorrectCostVal
     public void whenCalculatingInsertionIntoExistingRoute_itShouldReturnCorrectCosts() {
         Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
         Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
+
+        VehicleRoutingProblem.Builder.newInstance().addJob(shipment).addJob(shipment2).build();
+
         VehicleRoute route = VehicleRoute.emptyRoute();
         List<JobActivity> tourActivities = getTourActivities(shipment);
         route.setVehicleAndDepartureTime(vehicle, 0);
@@ -141,6 +145,9 @@ public void whenCalculatingInsertionIntoExistingRoute_itShouldReturnCorrectCosts
     public void whenInsertingShipmentInRouteWithNotEnoughCapacity_itShouldReturnNoInsertion() {
         Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
         Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
+
+        VehicleRoutingProblem.Builder.newInstance().addJob(shipment).addJob(shipment2).build();
+
         VehicleRoute route = VehicleRoute.emptyRoute();
         List<JobActivity> tourActivities = getTourActivities(shipment);
         route.setVehicleAndDepartureTime(vehicle, 0);
@@ -160,6 +167,8 @@ public void whenInsertingThirdShipment_itShouldCalcCorrectVal() {
         Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
         Shipment shipment3 = Shipment.Builder.newInstance("s3").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("9,10")).build();
 
+        VehicleRoutingProblem.Builder.newInstance().addJob(shipment).addJob(shipment2).addJob(shipment3).build();
+
         VehicleRoute route = VehicleRoute.emptyRoute();
         List<JobActivity> shipmentActivities = getTourActivities(shipment);
         List<JobActivity> shipment2Activities = getTourActivities(shipment2);
@@ -180,6 +189,9 @@ public void whenInsertingThirdShipment_itShouldCalcCorrectVal2() {
         Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
         Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
         Shipment shipment3 = Shipment.Builder.newInstance("s3").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("9,9")).build();
+
+        VehicleRoutingProblem.Builder.newInstance().addJob(shipment).addJob(shipment2).addJob(shipment3).build();
+
         List<JobActivity> shipmentActivities = getTourActivities(shipment);
         List<JobActivity> shipment2Activities = getTourActivities(shipment2);
         VehicleRoute route = VehicleRoute.emptyRoute();
@@ -217,7 +229,7 @@ public void whenInstertingShipmentWithLoadConstraintWhereCapIsNotSufficient_capC
         constraintManager.addConstraint(new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager), ConstraintManager.Priority.CRITICAL);
         constraintManager.addConstraint(new ShipmentPickupsFirstConstraint(), ConstraintManager.Priority.CRITICAL);
 
-        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        insertionCalculator = new GeneralJobInsertionCalculatorV2(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
 
         InsertionData iData = insertionCalculator.getInsertionData(route, shipment3, vehicle, 0.0, DriverImpl.noDriver(), Double.MAX_VALUE);
         assertTrue(iData instanceof InsertionData.NoInsertionFound);
@@ -245,7 +257,7 @@ public void whenInsertingServiceWhileNoCapIsAvailable_itMustReturnNoInsertionDat
         ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
         constraintManager.addLoadConstraint();
 
-        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        insertionCalculator = new GeneralJobInsertionCalculatorV2(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
         stateManager.informInsertionStarts(Arrays.asList(route), null);
 
         //		Service service = new Service.Builder("pick", 1).setLocationId("5,5").build();
