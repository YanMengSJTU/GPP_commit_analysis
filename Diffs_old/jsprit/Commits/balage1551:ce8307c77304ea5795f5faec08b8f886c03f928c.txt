diff --git a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsRecorder.java b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsRecorder.java
index 4708c6cfa..e8276e23e 100644
--- a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsRecorder.java
+++ b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsRecorder.java
@@ -33,6 +33,7 @@
 import com.graphhopper.jsprit.core.problem.job.Shipment;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.AbstractActivityNEW;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
@@ -435,7 +436,7 @@ private void insertNode(String nodeId, int insertionIndex, InsertionData data, V
         if (isFirst(insertionIndex)) {
             node_i = makeStartId(data.getSelectedVehicle());
         } else {
-            JobActivity jobActivity = (JobActivity) route.getActivities().get(insertionIndex - 1);
+            AbstractActivityNEW jobActivity = (AbstractActivityNEW) route.getActivities().get(insertionIndex - 1);
             node_i = getNodeId(jobActivity);
         }
         String edgeId_1 = node_i + "_" + nodeId;
@@ -443,7 +444,7 @@ private void insertNode(String nodeId, int insertionIndex, InsertionData data, V
         if (isLast(insertionIndex, route)) {
             node_j = makeEndId(data.getSelectedVehicle());
         } else {
-            JobActivity jobActivity = (JobActivity) route.getActivities().get(insertionIndex);
+            AbstractActivityNEW jobActivity = (AbstractActivityNEW) route.getActivities().get(insertionIndex);
             node_j = getNodeId(jobActivity);
         }
         String edgeId_2 = nodeId + "_" + node_j;
diff --git a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/GraphStreamViewer.java b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/GraphStreamViewer.java
index fd4b3114e..584278e9a 100644
--- a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/GraphStreamViewer.java
+++ b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/GraphStreamViewer.java
@@ -24,9 +24,9 @@
 import com.graphhopper.jsprit.core.problem.job.Shipment;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivityNEW;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivityNEW;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.util.Time;
@@ -588,8 +588,8 @@ private void renderRoute(Graph g, VehicleRoute route, int routeId, long renderDe
                 actNode.addAttribute("ui.label", Time.parseSecondsToTime(act.getEndTime()));
             }
             g.addEdge(makeEdgeId(routeId, vehicle_edgeId), prevIdentifier, currIdentifier, true);
-            if (act instanceof PickupActivity) g.getNode(currIdentifier).addAttribute("ui.class", "pickupInRoute");
-            else if (act instanceof DeliveryActivity)
+            if (act instanceof PickupActivityNEW) g.getNode(currIdentifier).addAttribute("ui.class", "pickupInRoute");
+            else if (act instanceof DeliveryActivityNEW)
                 g.getNode(currIdentifier).addAttribute("ui.class", "deliveryInRoute");
             prevIdentifier = currIdentifier;
             vehicle_edgeId++;
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinClusters.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinClusters.java
index 6fecc0bd6..5da19e231 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinClusters.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinClusters.java
@@ -22,7 +22,7 @@
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.AbstractActivityNEW;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.util.RandomUtils;
 import org.apache.commons.math3.ml.clustering.Clusterable;
@@ -49,9 +49,9 @@ public void informIterationStarts(int i, VehicleRoutingProblem problem, Collecti
 
     public static class JobActivityWrapper implements Clusterable {
 
-        private JobActivity jobActivity;
+        private AbstractActivityNEW jobActivity;
 
-        public JobActivityWrapper(JobActivity jobActivity) {
+        public JobActivityWrapper(AbstractActivityNEW jobActivity) {
             this.jobActivity = jobActivity;
         }
 
@@ -60,7 +60,7 @@ public JobActivityWrapper(JobActivity jobActivity) {
             return new double[]{jobActivity.getLocation().getCoordinate().getX(), jobActivity.getLocation().getCoordinate().getY()};
         }
 
-        public JobActivity getActivity() {
+        public AbstractActivityNEW getActivity() {
             return jobActivity;
         }
     }
@@ -161,7 +161,7 @@ private void ruin(Collection<VehicleRoute> vehicleRoutes, int nOfJobs2BeRemoved,
     private List<JobActivityWrapper> wrap(List<TourActivity> activities) {
         List<JobActivityWrapper> wl = new ArrayList<JobActivityWrapper>();
         for (TourActivity act : activities) {
-            wl.add(new JobActivityWrapper((JobActivity) act));
+            wl.add(new JobActivityWrapper((AbstractActivityNEW) act));
         }
         return wl;
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyser.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyser.java
index 66709f36c..9b72f12eb 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyser.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyser.java
@@ -110,15 +110,15 @@ public void begin(VehicleRoute route) {
 
         @Override
         public void visit(TourActivity activity) {
-            if (activity instanceof PickupActivity) {
+            if (activity instanceof PickupActivityNEW) {
                 pickupCounter++;
-                pickedUp = Capacity.addup(pickedUp, ((PickupActivity) activity).getJob().getSize());
+                pickedUp = Capacity.addup(pickedUp, ((PickupActivityNEW) activity).getJob().getSize());
                 if (activity instanceof PickupService) {
                     deliverAtEndCounter++;
                 }
-            } else if (activity instanceof DeliveryActivity) {
+            } else if (activity instanceof DeliveryActivityNEW) {
                 deliveryCounter++;
-                delivered = Capacity.addup(delivered, ((DeliveryActivity) activity).getJob().getSize());
+                delivered = Capacity.addup(delivered, ((DeliveryActivityNEW) activity).getJob().getSize());
                 if (activity instanceof DeliverService) {
                     pickupAtBeginningCounter++;
                 }
@@ -192,7 +192,7 @@ public void visit(TourActivity activity) {
                 stateManager.putActivityState(activity, backhaul_id, true);
                 backhaulConstraintOnRouteViolated = true;
             } else {
-                if (activity instanceof PickupService || activity instanceof ServiceActivity || activity instanceof PickupShipment) {
+                if (activity instanceof PickupService || activity instanceof ServiceActivityNEW || activity instanceof PickupShipment) {
                     pickupOccured = true;
                     stateManager.putActivityState(activity, backhaul_id, false);
                 } else stateManager.putActivityState(activity, backhaul_id, false);
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Capacity.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Capacity.java
index 021f950f1..5fc6040d8 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Capacity.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Capacity.java
@@ -28,6 +28,8 @@
  */
 public class Capacity {
 
+    public static final Capacity EMPTY = Capacity.Builder.newInstance().build();
+
     /**
      * Adds up two capacities, i.e. sums up each and every capacity dimension, and returns the resulting Capacity.
      * <p>
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ServiceDeliveriesFirstConstraint.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ServiceDeliveriesFirstConstraint.java
index 065b55a5d..0ecca8152 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ServiceDeliveriesFirstConstraint.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ServiceDeliveriesFirstConstraint.java
@@ -27,13 +27,13 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
         if (newAct instanceof PickupService && nextAct instanceof DeliverService) {
             return ConstraintsStatus.NOT_FULFILLED;
         }
-        if (newAct instanceof ServiceActivity && nextAct instanceof DeliverService) {
+        if (newAct instanceof ServiceActivityNEW && nextAct instanceof DeliverService) {
             return ConstraintsStatus.NOT_FULFILLED;
         }
         if (newAct instanceof DeliverService && prevAct instanceof PickupService) {
             return ConstraintsStatus.NOT_FULFILLED_BREAK;
         }
-        if (newAct instanceof DeliverService && prevAct instanceof ServiceActivity) {
+        if (newAct instanceof DeliverService && prevAct instanceof ServiceActivityNEW) {
             return ConstraintsStatus.NOT_FULFILLED_BREAK;
         }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ServiceLoadActivityLevelConstraint.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ServiceLoadActivityLevelConstraint.java
index b53fd4386..5210c9dbb 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ServiceLoadActivityLevelConstraint.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ServiceLoadActivityLevelConstraint.java
@@ -59,7 +59,7 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
             if (prevMaxLoad == null) prevMaxLoad = defaultValue;
 
         }
-        if (newAct instanceof PickupService || newAct instanceof ServiceActivity) {
+        if (newAct instanceof PickupService || newAct instanceof ServiceActivityNEW) {
             if (!Capacity.addup(newAct.getSize(), futureMaxLoad).isLessOrEqual(iFacts.getNewVehicle().getType().getCapacityDimensions())) {
                 return ConstraintsStatus.NOT_FULFILLED;
             }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/AbstractActivityNEW.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/AbstractActivityNEW.java
new file mode 100644
index 000000000..a34d3d1b2
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/AbstractActivityNEW.java
@@ -0,0 +1,118 @@
+package com.graphhopper.jsprit.core.problem.solution.route.activity;
+
+
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+
+import com.graphhopper.jsprit.core.problem.Capacity;
+import com.graphhopper.jsprit.core.problem.IndexedActivity;
+import com.graphhopper.jsprit.core.problem.Location;
+
+public abstract class AbstractActivityNEW extends IndexedActivity {
+
+    protected Capacity capacity;
+    protected double arrTime;
+    protected double endTime;
+    protected double theoreticalEarliest = 0;
+    protected double theoreticalLatest = Double.MAX_VALUE;
+    protected String name;
+    protected Location location;
+
+
+    public AbstractActivityNEW(String name, Location location, Capacity capacity) {
+        super();
+        this.capacity = capacity;
+        this.name = name;
+        this.location = location;
+    }
+
+    public AbstractActivityNEW(AbstractActivityNEW sourceActivity) {
+        arrTime = sourceActivity.getArrTime();
+        endTime = sourceActivity.getEndTime();
+        capacity = sourceActivity.getSize();
+        setIndex(sourceActivity.getIndex());
+        theoreticalEarliest = sourceActivity.getTheoreticalEarliestOperationStartTime();
+        theoreticalLatest = sourceActivity.getTheoreticalLatestOperationStartTime();
+        name = sourceActivity.name;
+        location = sourceActivity.location;
+    }
+
+    @Override
+    public void setTheoreticalEarliestOperationStartTime(double earliest) {
+        theoreticalEarliest = earliest;
+    }
+
+    @Override
+    public void setTheoreticalLatestOperationStartTime(double latest) {
+        theoreticalLatest = latest;
+    }
+
+    @Override
+    public double getTheoreticalEarliestOperationStartTime() {
+        return theoreticalEarliest;
+    }
+
+    @Override
+    public double getTheoreticalLatestOperationStartTime() {
+        return theoreticalLatest;
+    }
+
+    @Override
+    public double getArrTime() {
+        return arrTime;
+    }
+
+    @Override
+    public double getEndTime() {
+        return endTime;
+    }
+
+    @Override
+    public void setArrTime(double arrTime) {
+        this.arrTime = arrTime;
+    }
+
+    @Override
+    public void setEndTime(double endTime) {
+        this.endTime = endTime;
+    }
+
+    @Override
+    public Capacity getSize() {
+        return capacity;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    @Override
+    public Location getLocation() {
+        return location;
+    }
+
+    @Override
+    public String toString() {
+        return "[type=" + getName() + "][locationId=" + getLocation().getId()
+                + "][size=" + getSize().toString()
+                + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
+                + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
+    }
+
+
+    @Override
+    public TourActivity duplicate() {
+        // TODO - Balage1551 - It uses safe reflection. But this is reflection which is expensive, so
+        // in case it is a bottlenect, this should be refactored
+        try {
+            Constructor<? extends AbstractActivityNEW> constructor = getClass().getConstructor(getClass());
+            return constructor.newInstance(this);
+        } catch (NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException
+                | InvocationTargetException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliverService.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliverService.java
index 4985e5416..616997bd8 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliverService.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliverService.java
@@ -22,7 +22,7 @@
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.job.Delivery;
 
-public final class DeliverService extends IndexedActivity implements DeliveryActivity {
+public final class DeliverService extends IndexedActivity implements DeliveryActivityNEW {
 
     private Delivery delivery;
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliverShipment.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliverShipment.java
index db280b2f7..e1b668d28 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliverShipment.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliverShipment.java
@@ -23,7 +23,7 @@
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.job.Shipment;
 
-public final class DeliverShipment extends IndexedActivity implements DeliveryActivity {
+public final class DeliverShipment extends IndexedActivity implements DeliveryActivityNEW {
 
     private Shipment shipment;
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupActivity.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliveryActivityNEW.java
similarity index 63%
rename from jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupActivity.java
rename to jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliveryActivityNEW.java
index 24f459749..a03da2514 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupActivity.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliveryActivityNEW.java
@@ -17,7 +17,18 @@
  */
 package com.graphhopper.jsprit.core.problem.solution.route.activity;
 
-public interface PickupActivity extends JobActivity {
+import com.graphhopper.jsprit.core.problem.AbstractJob;
+import com.graphhopper.jsprit.core.problem.Capacity;
+import com.graphhopper.jsprit.core.problem.Location;
 
+public class DeliveryActivityNEW extends JobActivity {
+
+    public DeliveryActivityNEW(AbstractJob job, String name, Location location, double operationTime, Capacity capacity) {
+        super(job, name, location, operationTime, capacity);
+    }
+
+    public DeliveryActivityNEW(JobActivity sourceActivity) {
+        super(sourceActivity);
+    }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/End.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/End.java
index 98c1ec76a..8b6216ad2 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/End.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/End.java
@@ -1,3 +1,21 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 /*
  * Licensed to GraphHopper GmbH under one or more contributor
  * license agreements. See the NOTICE file distributed with this work for
@@ -18,139 +36,129 @@
 package com.graphhopper.jsprit.core.problem.solution.route.activity;
 
 import com.graphhopper.jsprit.core.problem.Capacity;
-import com.graphhopper.jsprit.core.problem.IndexedActivity;
 import com.graphhopper.jsprit.core.problem.Location;
 
-public final class End extends IndexedActivity {
+public final class End extends InternalActivity {
 
-    public static End newInstance(String locationId, double earliestArrival, double latestArrival) {
-        return new End(locationId, earliestArrival, latestArrival);
+    public static End newInstance(String locationId, double theoreticalStart, double theoreticalEnd) {
+        Location loc = null;
+        if (locationId != null) {
+            loc = Location.Builder.newInstance().setId(locationId).build();
+        }
+        return new End(loc, theoreticalStart, theoreticalEnd);
     }
 
     public static End copyOf(End end) {
         return new End(end);
     }
 
-    private final static Capacity capacity = Capacity.Builder.newInstance().build();
-
-
-    private double endTime = -1;
-
-
-    private double theoretical_earliestOperationStartTime;
-
-    private double theoretical_latestOperationStartTime;
-
-    private double arrTime;
-
-    private Location location;
-
-    @Override
-    public void setTheoreticalEarliestOperationStartTime(double theoreticalEarliestOperationStartTime) {
-        theoretical_earliestOperationStartTime = theoreticalEarliestOperationStartTime;
-    }
-
-    @Override
-    public void setTheoreticalLatestOperationStartTime(double theoreticalLatestOperationStartTime) {
-        theoretical_latestOperationStartTime = theoreticalLatestOperationStartTime;
-    }
-
     public End(Location location, double theoreticalStart, double theoreticalEnd) {
-        super();
-        this.location = location;
-        theoretical_earliestOperationStartTime = theoreticalStart;
-        theoretical_latestOperationStartTime = theoreticalEnd;
-        endTime = theoreticalEnd;
-        setIndex(-2);
-    }
-
-    public End(String locationId, double theoreticalStart, double theoreticalEnd) {
-        super();
-        if (locationId != null) {
-            location = Location.Builder.newInstance().setId(locationId).build();
-        }
-        theoretical_earliestOperationStartTime = theoreticalStart;
-        theoretical_latestOperationStartTime = theoreticalEnd;
-        endTime = theoreticalEnd;
-        setIndex(-2);
-    }
-
-    public End(End end) {
-        location = end.getLocation();
-//		this.locationId = end.getLocation().getId();
-        theoretical_earliestOperationStartTime = end.getTheoreticalEarliestOperationStartTime();
-        theoretical_latestOperationStartTime = end.getTheoreticalLatestOperationStartTime();
-        arrTime = end.getArrTime();
-        endTime = end.getEndTime();
+        super("end", location, Capacity.EMPTY);
+        setTheoreticalEarliestOperationStartTime(theoreticalStart);
+        setTheoreticalLatestOperationStartTime(theoreticalEnd);
+        endTime = theoreticalStart;
         setIndex(-2);
     }
 
-    @Override
-    public double getTheoreticalEarliestOperationStartTime() {
-        return theoretical_earliestOperationStartTime;
-    }
-
-    @Override
-    public double getTheoreticalLatestOperationStartTime() {
-        return theoretical_latestOperationStartTime;
-    }
-
-    @Override
-    public double getEndTime() {
-        return endTime;
-    }
-
-    @Override
-    public void setEndTime(double endTime) {
-        this.endTime = endTime;
+    private End(End end) {
+        super(end);
     }
 
     public void setLocation(Location location) {
         this.location = location;
     }
 
-    @Override
-    public Location getLocation() {
-        return location;
-    }
-
     @Override
     public double getOperationTime() {
         return 0.0;
     }
 
-
     @Override
     public String toString() {
         return "[type=" + getName() + "][location=" + location
-                + "][twStart=" + Activities.round(theoretical_earliestOperationStartTime)
-                + "][twEnd=" + Activities.round(theoretical_latestOperationStartTime) + "]";
-    }
-
-    @Override
-    public String getName() {
-        return "end";
-    }
-
-    @Override
-    public double getArrTime() {
-        return arrTime;
-    }
-
-    @Override
-    public void setArrTime(double arrTime) {
-        this.arrTime = arrTime;
-
+                + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
+                + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
     }
 
-    @Override
-    public TourActivity duplicate() {
-        return new End(this);
-    }
+}
 
-    @Override
-    public Capacity getSize() {
-        return capacity;
-    }
 
-}
+/*
+ * package com.graphhopper.jsprit.core.problem.solution.route.activity;
+ * 
+ * import com.graphhopper.jsprit.core.problem.Capacity; import com.graphhopper.jsprit.core.problem.IndexedActivity;
+ * import com.graphhopper.jsprit.core.problem.Location;
+ * 
+ * public final class End extends IndexedActivity {
+ * 
+ * public static End newInstance(String locationId, double earliestArrival, double latestArrival) { return new
+ * End(locationId, earliestArrival, latestArrival); }
+ * 
+ * public static End copyOf(End end) { return new End(end); }
+ * 
+ * private final static Capacity capacity = Capacity.Builder.newInstance().build();
+ * 
+ * 
+ * private double endTime = -1;
+ * 
+ * 
+ * private double theoretical_earliestOperationStartTime;
+ * 
+ * private double theoretical_latestOperationStartTime;
+ * 
+ * private double arrTime;
+ * 
+ * private Location location;
+ * 
+ * @Override public void setTheoreticalEarliestOperationStartTime(double theoreticalEarliestOperationStartTime) {
+ * theoretical_earliestOperationStartTime = theoreticalEarliestOperationStartTime; }
+ * 
+ * @Override public void setTheoreticalLatestOperationStartTime(double theoreticalLatestOperationStartTime) {
+ * theoretical_latestOperationStartTime = theoreticalLatestOperationStartTime; }
+ * 
+ * public End(Location location, double theoreticalStart, double theoreticalEnd) { super(); this.location = location;
+ * theoretical_earliestOperationStartTime = theoreticalStart; theoretical_latestOperationStartTime = theoreticalEnd;
+ * endTime = theoreticalEnd; setIndex(-2); }
+ * 
+ * public End(String locationId, double theoreticalStart, double theoreticalEnd) { super(); if (locationId != null) {
+ * location = Location.Builder.newInstance().setId(locationId).build(); } theoretical_earliestOperationStartTime =
+ * theoreticalStart; theoretical_latestOperationStartTime = theoreticalEnd; endTime = theoreticalEnd; setIndex(-2); }
+ * 
+ * public End(End end) { location = end.getLocation(); // this.locationId = end.getLocation().getId();
+ * theoretical_earliestOperationStartTime = end.getTheoreticalEarliestOperationStartTime();
+ * theoretical_latestOperationStartTime = end.getTheoreticalLatestOperationStartTime(); arrTime = end.getArrTime();
+ * endTime = end.getEndTime(); setIndex(-2); }
+ * 
+ * @Override public double getTheoreticalEarliestOperationStartTime() { return theoretical_earliestOperationStartTime; }
+ * 
+ * @Override public double getTheoreticalLatestOperationStartTime() { return theoretical_latestOperationStartTime; }
+ * 
+ * @Override public double getEndTime() { return endTime; }
+ * 
+ * @Override public void setEndTime(double endTime) { this.endTime = endTime; }
+ * 
+ * public void setLocation(Location location) { this.location = location; }
+ * 
+ * @Override public Location getLocation() { return location; }
+ * 
+ * @Override public double getOperationTime() { return 0.0; }
+ * 
+ * 
+ * @Override public String toString() { return "[type=" + getName() + "][location=" + location + "][twStart=" +
+ * Activities.round(theoretical_earliestOperationStartTime) + "][twEnd=" +
+ * Activities.round(theoretical_latestOperationStartTime) + "]"; }
+ * 
+ * @Override public String getName() { return "end"; }
+ * 
+ * @Override public double getArrTime() { return arrTime; }
+ * 
+ * @Override public void setArrTime(double arrTime) { this.arrTime = arrTime;
+ * 
+ * }
+ * 
+ * @Override public TourActivity duplicate() { return new End(this); }
+ * 
+ * @Override public Capacity getSize() { return capacity; }
+ * 
+ * }
+ */
\ No newline at end of file
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ExchangeActivityNEW.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ExchangeActivityNEW.java
new file mode 100644
index 000000000..60d110045
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ExchangeActivityNEW.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.jsprit.core.problem.solution.route.activity;
+
+import com.graphhopper.jsprit.core.problem.AbstractJob;
+import com.graphhopper.jsprit.core.problem.Capacity;
+import com.graphhopper.jsprit.core.problem.Location;
+
+public class ExchangeActivityNEW extends JobActivity {
+
+    public ExchangeActivityNEW(AbstractJob job, String name, Location location, double operationTime, Capacity capacity) {
+        super(job, name, location, operationTime, capacity);
+    }
+
+    public ExchangeActivityNEW(JobActivity sourceActivity) {
+        super(sourceActivity);
+    }
+
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/InternalActivity.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/InternalActivity.java
new file mode 100644
index 000000000..321bd46ee
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/InternalActivity.java
@@ -0,0 +1,22 @@
+package com.graphhopper.jsprit.core.problem.solution.route.activity;
+
+import com.graphhopper.jsprit.core.problem.Capacity;
+import com.graphhopper.jsprit.core.problem.Location;
+
+/**
+ * Common ancesstor for non-job-based, internal activities
+ *
+ * @author balage
+ *
+ */
+public abstract class InternalActivity extends AbstractActivityNEW implements InternalActivityMarker {
+
+    public InternalActivity(String name, Location location, Capacity capacity) {
+        super(name, location, capacity);
+    }
+
+    public InternalActivity(InternalActivity sourceActivity) {
+        super(sourceActivity);
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/JobActivity.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/JobActivity.java
index 3193289cc..29187cfe6 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/JobActivity.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/JobActivity.java
@@ -1,11 +1,7 @@
 package com.graphhopper.jsprit.core.problem.solution.route.activity;
 
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-
 import com.graphhopper.jsprit.core.problem.AbstractJob;
 import com.graphhopper.jsprit.core.problem.Capacity;
-import com.graphhopper.jsprit.core.problem.IndexedActivity;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.job.Job;
 
@@ -17,26 +13,13 @@
  *
  * @author schroeder
  */
-public abstract class JobActivity extends IndexedActivity {
+public abstract class JobActivity extends AbstractActivityNEW {
 
     private AbstractJob job;
 
-    private Capacity capacity;
-
-    private double arrTime;
-
-    private double endTime;
-
-    private double theoreticalEarliest = 0;
-
-    private double theoreticalLatest = Double.MAX_VALUE;
-
-    private String name;
     private double operationTime;
-    protected Location location;
-
     public JobActivity(AbstractJob job, String name, Location location, double operationTime, Capacity capacity) {
-        super();
+        super(name, location, capacity);
         this.job = job;
         this.name = name;
         this.location = location;
@@ -45,15 +28,8 @@ public JobActivity(AbstractJob job, String name, Location location, double opera
     }
 
     protected JobActivity(JobActivity sourceActivity) {
+        super(sourceActivity);
         job = sourceActivity.getJob();
-        arrTime = sourceActivity.getArrTime();
-        endTime = sourceActivity.getEndTime();
-        capacity = sourceActivity.getSize();
-        setIndex(sourceActivity.getIndex());
-        theoreticalEarliest = sourceActivity.getTheoreticalEarliestOperationStartTime();
-        theoreticalLatest = sourceActivity.getTheoreticalLatestOperationStartTime();
-        name = sourceActivity.name;
-        location = sourceActivity.location;
         operationTime = sourceActivity.getOperationTime();
     }
 
@@ -61,87 +37,10 @@ public AbstractJob getJob() {
         return job;
     }
 
-    @Override
-    public void setTheoreticalEarliestOperationStartTime(double earliest) {
-        theoreticalEarliest = earliest;
-    }
-
-    @Override
-    public void setTheoreticalLatestOperationStartTime(double latest) {
-        theoreticalLatest = latest;
-    }
-
-
-    @Override
-    public double getTheoreticalEarliestOperationStartTime() {
-        return theoreticalEarliest;
-    }
-
-    @Override
-    public double getTheoreticalLatestOperationStartTime() {
-        return theoreticalLatest;
-    }
-
-    @Override
-    public double getArrTime() {
-        return arrTime;
-    }
-
-    @Override
-    public double getEndTime() {
-        return endTime;
-    }
-
-    @Override
-    public void setArrTime(double arrTime) {
-        this.arrTime = arrTime;
-    }
-
-    @Override
-    public void setEndTime(double endTime) {
-        this.endTime = endTime;
-    }
-
-    @Override
-    public String toString() {
-        return "[type=" + getName() + "][locationId=" + getLocation().getId()
-                + "][size=" + getSize().toString()
-                + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
-                + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
-    }
-
-    @Override
-    public Capacity getSize() {
-        return capacity;
-    }
-
-    @Override
-    public String getName() {
-        return name;
-    }
-
     @Override
     public double getOperationTime() {
         return operationTime;
     }
 
-    @Override
-    public Location getLocation() {
-        return location;
-    }
-
-    @Override
-    public TourActivity duplicate() {
-        // TODO - Balage1551 - It uses safe reflection. But this is reflection which is expensive, so
-        // in case it is a bottlenect, this should be refactored
-        try {
-            Constructor<? extends JobActivity> constructor = getClass().getConstructor(getClass());
-            return constructor.newInstance(this);
-        } catch (NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException
-                | InvocationTargetException e) {
-            throw new IllegalStateException(e);
-        }
-    }
-
 
 }
\ No newline at end of file
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliveryActivity.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupActivityNEW.java
similarity index 63%
rename from jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliveryActivity.java
rename to jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupActivityNEW.java
index 000da3dc8..87bbd85d8 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliveryActivity.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupActivityNEW.java
@@ -17,7 +17,19 @@
  */
 package com.graphhopper.jsprit.core.problem.solution.route.activity;
 
-public interface DeliveryActivity extends JobActivity {
+import com.graphhopper.jsprit.core.problem.AbstractJob;
+import com.graphhopper.jsprit.core.problem.Capacity;
+import com.graphhopper.jsprit.core.problem.Location;
+
+public class PickupActivityNEW extends JobActivity {
+
+    public PickupActivityNEW(AbstractJob job, String name, Location location, double operationTime, Capacity capacity) {
+        super(job, name, location, operationTime, capacity);
+    }
+
+    public PickupActivityNEW(JobActivity sourceActivity) {
+        super(sourceActivity);
+    }
 
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupService.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupService.java
index 9cc8cfd71..afdcc5ad7 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupService.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupService.java
@@ -23,7 +23,7 @@
 import com.graphhopper.jsprit.core.problem.job.Pickup;
 import com.graphhopper.jsprit.core.problem.job.Service;
 
-public final class PickupService extends IndexedActivity implements PickupActivity {
+public final class PickupService extends IndexedActivity implements PickupActivityNEW {
 
     private Service pickup;
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupShipment.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupShipment.java
index 6dbe94732..8d78dd82a 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupShipment.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupShipment.java
@@ -23,7 +23,7 @@
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.job.Shipment;
 
-public final class PickupShipment extends IndexedActivity implements PickupActivity{
+public final class PickupShipment extends IndexedActivity implements PickupActivityNEW{
 
     private Shipment shipment;
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ServiceActivity.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ServiceActivity.java
deleted file mode 100644
index e918ff0b9..000000000
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ServiceActivity.java
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.problem.solution.route.activity;
-
-import com.graphhopper.jsprit.core.problem.IndexedActivity;
-import com.graphhopper.jsprit.core.problem.Capacity;
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.job.Service;
-
-public class ServiceActivity extends IndexedActivity implements JobActivity {
-
-    public double arrTime;
-
-    public double endTime;
-
-    private double theoreticalEarliest;
-
-    private double theoreticalLatest;
-
-    /**
-     * @return the arrTime
-     */
-    public double getArrTime() {
-        return arrTime;
-    }
-
-    /**
-     * @param arrTime the arrTime to set
-     */
-    public void setArrTime(double arrTime) {
-        this.arrTime = arrTime;
-    }
-
-    /**
-     * @return the endTime
-     */
-    public double getEndTime() {
-        return endTime;
-    }
-
-    /**
-     * @param endTime the endTime to set
-     */
-    public void setEndTime(double endTime) {
-        this.endTime = endTime;
-    }
-
-    public static ServiceActivity copyOf(ServiceActivity serviceActivity) {
-        return new ServiceActivity(serviceActivity);
-    }
-
-    public static ServiceActivity newInstance(Service service) {
-        return new ServiceActivity(service);
-    }
-
-
-    private final Service service;
-
-    protected ServiceActivity(Service service) {
-        this.service = service;
-    }
-
-    protected ServiceActivity(ServiceActivity serviceActivity) {
-        this.service = serviceActivity.getJob();
-        this.arrTime = serviceActivity.getArrTime();
-        this.endTime = serviceActivity.getEndTime();
-        setIndex(serviceActivity.getIndex());
-        this.theoreticalEarliest = serviceActivity.getTheoreticalEarliestOperationStartTime();
-        this.theoreticalLatest = serviceActivity.getTheoreticalLatestOperationStartTime();
-    }
-
-
-    /* (non-Javadoc)
-     * @see java.lang.Object#hashCode()
-     */
-    @Override
-    public int hashCode() {
-        final int prime = 31;
-        int result = 1;
-        result = prime * result + ((service == null) ? 0 : service.hashCode());
-        return result;
-    }
-
-    /* (non-Javadoc)
-     * @see java.lang.Object#equals(java.lang.Object)
-     */
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj)
-            return true;
-        if (obj == null)
-            return false;
-        if (getClass() != obj.getClass())
-            return false;
-        ServiceActivity other = (ServiceActivity) obj;
-        if (service == null) {
-            if (other.service != null)
-                return false;
-        } else if (!service.equals(other.service))
-            return false;
-        return true;
-    }
-
-    public double getTheoreticalEarliestOperationStartTime() {
-        return theoreticalEarliest;
-    }
-
-    public double getTheoreticalLatestOperationStartTime() {
-        return theoreticalLatest;
-    }
-
-    @Override
-    public void setTheoreticalEarliestOperationStartTime(double earliest) {
-        theoreticalEarliest = earliest;
-    }
-
-    @Override
-    public void setTheoreticalLatestOperationStartTime(double latest) {
-        theoreticalLatest = latest;
-    }
-
-    @Override
-    public double getOperationTime() {
-        return service.getServiceDuration();
-    }
-
-    @Override
-    public Location getLocation() {
-        return service.getLocation();
-    }
-
-
-    @Override
-    public Service getJob() {
-        return service;
-    }
-
-
-    @Override
-    public String toString() {
-        return "[type=" + getName() + "][locationId=" + getLocation().getId()
-            + "][size=" + getSize().toString()
-            + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
-            + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
-    }
-
-    @Override
-    public String getName() {
-        return service.getType();
-    }
-
-    @Override
-    public TourActivity duplicate() {
-        return new ServiceActivity(this);
-    }
-
-    @Override
-    public Capacity getSize() {
-        return service.getSize();
-    }
-
-
-}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ServiceActivityNEW.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ServiceActivityNEW.java
new file mode 100644
index 000000000..ec2c9a80f
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ServiceActivityNEW.java
@@ -0,0 +1,186 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.jsprit.core.problem.solution.route.activity;
+
+import com.graphhopper.jsprit.core.problem.AbstractJob;
+import com.graphhopper.jsprit.core.problem.Capacity;
+import com.graphhopper.jsprit.core.problem.Location;
+
+public class ServiceActivityNEW extends JobActivity {
+
+    public ServiceActivityNEW(AbstractJob job, String name, Location location, double operationTime, Capacity capacity) {
+        super(job, name, location, operationTime, capacity);
+    }
+
+    public ServiceActivityNEW(JobActivity sourceActivity) {
+        super(sourceActivity);
+    }
+
+
+//    public double arrTime;
+//
+//    public double endTime;
+//
+//    private double theoreticalEarliest;
+//
+//    private double theoreticalLatest;
+//
+//    /**
+//     * @return the arrTime
+//     */
+//    public double getArrTime() {
+//        return arrTime;
+//    }
+//
+//    /**
+//     * @param arrTime the arrTime to set
+//     */
+//    public void setArrTime(double arrTime) {
+//        this.arrTime = arrTime;
+//    }
+//
+//    /**
+//     * @return the endTime
+//     */
+//    public double getEndTime() {
+//        return endTime;
+//    }
+//
+//    /**
+//     * @param endTime the endTime to set
+//     */
+//    public void setEndTime(double endTime) {
+//        this.endTime = endTime;
+//    }
+//
+//    public static ServiceActivityNEW copyOf(ServiceActivityNEW serviceActivity) {
+//        return new ServiceActivityNEW(serviceActivity);
+//    }
+//
+//    public static ServiceActivityNEW newInstance(Service service) {
+//        return new ServiceActivityNEW(service);
+//    }
+//
+//
+//    private final Service service;
+//
+//    protected ServiceActivityNEW(Service service) {
+//        this.service = service;
+//    }
+//
+//    protected ServiceActivityNEW(ServiceActivityNEW serviceActivity) {
+//        this.service = serviceActivity.getJob();
+//        this.arrTime = serviceActivity.getArrTime();
+//        this.endTime = serviceActivity.getEndTime();
+//        setIndex(serviceActivity.getIndex());
+//        this.theoreticalEarliest = serviceActivity.getTheoreticalEarliestOperationStartTime();
+//        this.theoreticalLatest = serviceActivity.getTheoreticalLatestOperationStartTime();
+//    }
+//
+//
+//    /* (non-Javadoc)
+//     * @see java.lang.Object#hashCode()
+//     */
+//    @Override
+//    public int hashCode() {
+//        final int prime = 31;
+//        int result = 1;
+//        result = prime * result + ((service == null) ? 0 : service.hashCode());
+//        return result;
+//    }
+//
+//    /* (non-Javadoc)
+//     * @see java.lang.Object#equals(java.lang.Object)
+//     */
+//    @Override
+//    public boolean equals(Object obj) {
+//        if (this == obj)
+//            return true;
+//        if (obj == null)
+//            return false;
+//        if (getClass() != obj.getClass())
+//            return false;
+//        ServiceActivityNEW other = (ServiceActivityNEW) obj;
+//        if (service == null) {
+//            if (other.service != null)
+//                return false;
+//        } else if (!service.equals(other.service))
+//            return false;
+//        return true;
+//    }
+//
+//    public double getTheoreticalEarliestOperationStartTime() {
+//        return theoreticalEarliest;
+//    }
+//
+//    public double getTheoreticalLatestOperationStartTime() {
+//        return theoreticalLatest;
+//    }
+//
+//    @Override
+//    public void setTheoreticalEarliestOperationStartTime(double earliest) {
+//        theoreticalEarliest = earliest;
+//    }
+//
+//    @Override
+//    public void setTheoreticalLatestOperationStartTime(double latest) {
+//        theoreticalLatest = latest;
+//    }
+//
+//    @Override
+//    public double getOperationTime() {
+//        return service.getServiceDuration();
+//    }
+//
+//    @Override
+//    public Location getLocation() {
+//        return service.getLocation();
+//    }
+//
+//
+//    @Override
+//    public Service getJob() {
+//        return service;
+//    }
+//
+//
+//    @Override
+//    public String toString() {
+//        return "[type=" + getName() + "][locationId=" + getLocation().getId()
+//            + "][size=" + getSize().toString()
+//            + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
+//            + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
+//    }
+//
+//    @Override
+//    public String getName() {
+//        return service.getType();
+//    }
+//
+//    @Override
+//    public TourActivity duplicate() {
+//        return new ServiceActivityNEW(this);
+//    }
+//
+//    @Override
+//    public Capacity getSize() {
+//        return service.getSize();
+//    }
+//
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/Start.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/Start.java
index 2ede81a7a..71e5a5dbe 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/Start.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/Start.java
@@ -17,91 +17,39 @@
  */
 package com.graphhopper.jsprit.core.problem.solution.route.activity;
 
-import com.graphhopper.jsprit.core.problem.IndexedActivity;
 import com.graphhopper.jsprit.core.problem.Capacity;
 import com.graphhopper.jsprit.core.problem.Location;
 
-public final class Start extends IndexedActivity implements TourActivity {
-
-    @Deprecated
-    public final static String ACTIVITY_NAME = "start";
-
-    private final static Capacity capacity = Capacity.Builder.newInstance().build();
+public final class Start extends InternalActivity {
 
     public static Start newInstance(String locationId, double theoreticalStart, double theoreticalEnd) {
-        return new Start(locationId, theoreticalStart, theoreticalEnd);
+        Location loc = null;
+        if (locationId != null) {
+            loc = Location.Builder.newInstance().setId(locationId).build();
+        }
+        return new Start(loc, theoreticalStart, theoreticalEnd);
     }
 
     public static Start copyOf(Start start) {
         return new Start(start);
     }
 
-    private String locationId;
-
-    private double theoretical_earliestOperationStartTime;
-
-    private double theoretical_latestOperationStartTime;
-
-    private double endTime;
-
-    private double arrTime;
-
-    private Location location;
-
-    private Start(String locationId, double theoreticalStart, double theoreticalEnd) {
-        super();
-        if (locationId != null) this.location = Location.Builder.newInstance().setId(locationId).build();
-        this.theoretical_earliestOperationStartTime = theoreticalStart;
-        this.theoretical_latestOperationStartTime = theoreticalEnd;
-        this.endTime = theoreticalStart;
-        setIndex(-1);
-    }
-
     public Start(Location location, double theoreticalStart, double theoreticalEnd) {
-        super();
-        this.location = location;
-        this.theoretical_earliestOperationStartTime = theoreticalStart;
-        this.theoretical_latestOperationStartTime = theoreticalEnd;
-        this.endTime = theoreticalStart;
+        super("start", location, Capacity.EMPTY);
+        setTheoreticalEarliestOperationStartTime(theoreticalStart);
+        setTheoreticalLatestOperationStartTime(theoreticalEnd);
+        endTime = theoreticalStart;
         setIndex(-1);
     }
 
     private Start(Start start) {
-        this.location = start.getLocation();
-        theoretical_earliestOperationStartTime = start.getTheoreticalEarliestOperationStartTime();
-        theoretical_latestOperationStartTime = start.getTheoreticalLatestOperationStartTime();
-        endTime = start.getEndTime();
-        setIndex(-1);
-    }
-
-    public double getTheoreticalEarliestOperationStartTime() {
-        return theoretical_earliestOperationStartTime;
+        super(start);
     }
 
     public void setLocation(Location location) {
         this.location = location;
     }
 
-    ;
-
-    public double getTheoreticalLatestOperationStartTime() {
-        return theoretical_latestOperationStartTime;
-    }
-
-
-    public void setTheoreticalEarliestOperationStartTime(double time) {
-        this.theoretical_earliestOperationStartTime = time;
-    }
-
-    public void setTheoreticalLatestOperationStartTime(double time) {
-        this.theoretical_latestOperationStartTime = time;
-    }
-
-    @Override
-    public Location getLocation() {
-        return location;
-    }
-
     @Override
     public double getOperationTime() {
         return 0.0;
@@ -110,43 +58,8 @@ public double getOperationTime() {
     @Override
     public String toString() {
         return "[type=" + getName() + "][location=" + location
-            + "][twStart=" + Activities.round(theoretical_earliestOperationStartTime)
-            + "][twEnd=" + Activities.round(theoretical_latestOperationStartTime) + "]";
-    }
-
-    @Override
-    public String getName() {
-        return "start";
-    }
-
-    @Override
-    public double getArrTime() {
-        return arrTime;
-    }
-
-    @Override
-    public double getEndTime() {
-        return endTime;
-    }
-
-    @Override
-    public void setArrTime(double arrTime) {
-        this.arrTime = arrTime;
-    }
-
-    @Override
-    public void setEndTime(double endTime) {
-        this.endTime = endTime;
-    }
-
-    @Override
-    public TourActivity duplicate() {
-        return new Start(this);
-    }
-
-    @Override
-    public Capacity getSize() {
-        return capacity;
+                + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
+                + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
     }
 
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestRouteLevelActivityInsertionCostEstimator.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestRouteLevelActivityInsertionCostEstimator.java
index 77b71e2e2..64727611d 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestRouteLevelActivityInsertionCostEstimator.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestRouteLevelActivityInsertionCostEstimator.java
@@ -30,7 +30,7 @@
 import com.graphhopper.jsprit.core.problem.job.Service;
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivityNEW;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupService;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
@@ -113,7 +113,7 @@ public double getActivityDuration(TourActivity tourAct, double arrivalTime, Driv
     @Test
     public void whenNewActInBetweenFirstAndSecond_and_forwardLookingIs0_itShouldReturnCorrectCosts() {
         Service s4 = Service.Builder.newInstance("s4").setLocation(Location.newInstance("5,0")).build();
-        PickupActivity pickupService = new PickupService(s4);
+        PickupActivityNEW pickupService = new PickupService(s4);
         JobInsertionContext context = new JobInsertionContext(route, s4, route.getVehicle(), route.getDriver(), 0.);
         RouteLevelActivityInsertionCostsEstimator estimator = new RouteLevelActivityInsertionCostsEstimator(routingCosts, activityCosts, stateManager);
         estimator.setForwardLooking(0);
@@ -124,7 +124,7 @@ public void whenNewActInBetweenFirstAndSecond_and_forwardLookingIs0_itShouldRetu
     @Test
     public void whenNewActWithTWInBetweenFirstAndSecond_and_forwardLookingIs0_itShouldReturnCorrectCosts() {
         Service s4 = Service.Builder.newInstance("s4").setLocation(Location.newInstance("5,0")).setTimeWindow(TimeWindow.newInstance(5., 5.)).build();
-        PickupActivity pickupService = new PickupService(s4);
+        PickupActivityNEW pickupService = new PickupService(s4);
         JobInsertionContext context = new JobInsertionContext(route, s4, route.getVehicle(), route.getDriver(), 0.);
         RouteLevelActivityInsertionCostsEstimator estimator = new RouteLevelActivityInsertionCostsEstimator(routingCosts, activityCosts, stateManager);
         estimator.setForwardLooking(0);
@@ -135,7 +135,7 @@ public void whenNewActWithTWInBetweenFirstAndSecond_and_forwardLookingIs0_itShou
     @Test
     public void whenNewActWithTWAndServiceTimeInBetweenFirstAndSecond_and_forwardLookingIs0_itShouldReturnCorrectCosts() {
         Service s4 = Service.Builder.newInstance("s4").setLocation(Location.newInstance("5,0")).setServiceTime(10.).setTimeWindow(TimeWindow.newInstance(5., 5.)).build();
-        PickupActivity pickupService = new PickupService(s4);
+        PickupActivityNEW pickupService = new PickupService(s4);
         pickupService.setTheoreticalEarliestOperationStartTime(5);
         pickupService.setTheoreticalLatestOperationStartTime(5);
 
@@ -151,7 +151,7 @@ public void whenNewActWithTWAndServiceTimeInBetweenFirstAndSecond_and_forwardLoo
     @Test
     public void whenNewActWithTWAndServiceTimeInBetweenFirstAndSecond_and_forwardLookingIs3_itShouldReturnCorrectCosts() {
         Service s4 = Service.Builder.newInstance("s4").setLocation(Location.newInstance("5,0")).setServiceTime(10.).setTimeWindow(TimeWindow.newInstance(5., 5.)).build();
-        PickupActivity pickupService = new PickupService(s4);
+        PickupActivityNEW pickupService = new PickupService(s4);
         JobInsertionContext context = new JobInsertionContext(route, s4, route.getVehicle(), route.getDriver(), 0.);
         RouteLevelActivityInsertionCostsEstimator estimator = new RouteLevelActivityInsertionCostsEstimator(routingCosts, activityCosts, stateManager);
         estimator.setForwardLooking(3);
@@ -164,7 +164,7 @@ public void whenNewActWithTWAndServiceTimeInBetweenFirstAndSecond_and_forwardLoo
     @Test
     public void whenNewActInBetweenSecondAndThird_and_forwardLookingIs0_itShouldReturnCorrectCosts() {
         Service s4 = Service.Builder.newInstance("s4").setLocation(Location.newInstance("5,0")).build();
-        PickupActivity pickupService = new PickupService(s4);
+        PickupActivityNEW pickupService = new PickupService(s4);
         JobInsertionContext context = new JobInsertionContext(route, s4, route.getVehicle(), route.getDriver(), 0.);
         RouteLevelActivityInsertionCostsEstimator estimator = new RouteLevelActivityInsertionCostsEstimator(routingCosts, activityCosts, stateManager);
         estimator.setForwardLooking(0);
@@ -178,7 +178,7 @@ public void whenNewActInBetweenSecondAndThird_and_forwardLookingIs0_itShouldRetu
     @Test
     public void whenNewActInBetweenSecondAndThird_and_forwardLookingIs3_itShouldReturnCorrectCosts() {
         Service s4 = Service.Builder.newInstance("s4").setLocation(Location.newInstance("5,0")).build();
-        PickupActivity pickupService = new PickupService(s4);
+        PickupActivityNEW pickupService = new PickupService(s4);
         JobInsertionContext context = new JobInsertionContext(route, s4, route.getVehicle(), route.getDriver(), 0.);
         RouteLevelActivityInsertionCostsEstimator estimator = new RouteLevelActivityInsertionCostsEstimator(routingCosts, activityCosts, stateManager);
         estimator.setForwardLooking(3);
@@ -192,7 +192,7 @@ public void whenNewActInBetweenSecondAndThird_and_forwardLookingIs3_itShouldRetu
     @Test
     public void whenNewActWithTWInBetweenSecondAndThird_and_forwardLookingIs3_itShouldReturnCorrectCosts() {
         Service s4 = Service.Builder.newInstance("s4").setLocation(Location.newInstance("5,0")).setTimeWindow(TimeWindow.newInstance(5., 5.)).build();
-        PickupActivity pickupService = new PickupService(s4);
+        PickupActivityNEW pickupService = new PickupService(s4);
         pickupService.setTheoreticalEarliestOperationStartTime(5);
         pickupService.setTheoreticalLatestOperationStartTime(5);
         JobInsertionContext context = new JobInsertionContext(route, s4, route.getVehicle(), route.getDriver(), 0.);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/StateManagerTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/StateManagerTest.java
index 2bfec6e98..c5016f05a 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/StateManagerTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/StateManagerTest.java
@@ -21,7 +21,7 @@
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.job.Service;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.ServiceActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.ServiceActivityNEW;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
@@ -44,7 +44,7 @@
 
         @Override
         public List<IndexedActivity> createActivities(Job job) {
-            ServiceActivity act = mock(ServiceActivity.class);
+            ServiceActivityNEW act = mock(ServiceActivityNEW.class);
             when(act.getIndex()).thenReturn(1);
             List<IndexedActivity> acts = new ArrayList<IndexedActivity>();
             acts.add(act);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/LoadConstraintTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/LoadConstraintTest.java
index 155cebc96..5e9c09ef9 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/LoadConstraintTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/LoadConstraintTest.java
@@ -134,7 +134,7 @@ public void whenServiceRouteAndNewServiceFitsInBetweenStartAndAct1_itShouldRetur
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
-        ServiceActivity newAct = mock(ServiceActivity.class);
+        ServiceActivityNEW newAct = mock(ServiceActivityNEW.class);
         when(newAct.getSize()).thenReturn(newSize);
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, serviceRoute.getStart(), newAct, serviceRoute.getActivities().get(0), 0.);
@@ -151,7 +151,7 @@ public void whenServiceRouteAndNewServiceFitsInBetweenAc1AndAct2_itShouldReturnF
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
-        ServiceActivity newAct = mock(ServiceActivity.class);
+        ServiceActivityNEW newAct = mock(ServiceActivityNEW.class);
         when(newAct.getSize()).thenReturn(newSize);
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, serviceRoute.getActivities().get(0), newAct, serviceRoute.getActivities().get(1), 0.);
@@ -168,7 +168,7 @@ public void whenServiceRouteAndNewServiceFitsInBetweenAc2AndEnd_itShouldReturnFu
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
-        ServiceActivity newAct = mock(ServiceActivity.class);
+        ServiceActivityNEW newAct = mock(ServiceActivityNEW.class);
         when(newAct.getSize()).thenReturn(newSize);
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, serviceRoute.getActivities().get(1), newAct, serviceRoute.getEnd(), 0.);
@@ -188,7 +188,7 @@ public void whenServiceRouteAndNewServiceDoesNotFitInBetweenStartAndAct1_itShoul
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
-        ServiceActivity newAct = mock(ServiceActivity.class);
+        ServiceActivityNEW newAct = mock(ServiceActivityNEW.class);
         when(newAct.getSize()).thenReturn(newSize);
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, serviceRoute.getStart(), newAct, serviceRoute.getActivities().get(0), 0.);
@@ -205,7 +205,7 @@ public void whenServiceRouteAndNewServiceDoesNotFitInBetweenAc1AndAct2_itShouldR
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
-        ServiceActivity newAct = mock(ServiceActivity.class);
+        ServiceActivityNEW newAct = mock(ServiceActivityNEW.class);
         when(newAct.getSize()).thenReturn(newSize);
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, serviceRoute.getActivities().get(0), newAct, serviceRoute.getActivities().get(1), 0.);
@@ -222,7 +222,7 @@ public void whenServiceRouteAndNewServiceDoesNotFitInBetweenAc2AndEnd_itShouldRe
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
-        ServiceActivity newAct = mock(ServiceActivity.class);
+        ServiceActivityNEW newAct = mock(ServiceActivityNEW.class);
         when(newAct.getSize()).thenReturn(newSize);
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, serviceRoute.getActivities().get(1), newAct, serviceRoute.getEnd(), 0.);
@@ -502,7 +502,7 @@ public void whenPDRouteAndNewServiceFitsInBetweenAc1AndAct2_itShouldReturnFulfil
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
-        ServiceActivity newAct = mock(ServiceActivity.class);
+        ServiceActivityNEW newAct = mock(ServiceActivityNEW.class);
         when(newAct.getSize()).thenReturn(newSize);
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, serviceRoute.getActivities().get(0), newAct, serviceRoute.getActivities().get(1), 0.);
@@ -519,7 +519,7 @@ public void whenPDRouteAndNewServiceFitsInBetweenAc2AndEnd_itShouldReturnFulfill
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
-        ServiceActivity newAct = mock(ServiceActivity.class);
+        ServiceActivityNEW newAct = mock(ServiceActivityNEW.class);
         when(newAct.getSize()).thenReturn(newSize);
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, serviceRoute.getActivities().get(1), newAct, serviceRoute.getEnd(), 0.);
@@ -539,7 +539,7 @@ public void whenPDRouteAndNewServiceDoesNotFitInBetweenStartAndAct1_itShouldRetu
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
-        ServiceActivity newAct = mock(ServiceActivity.class);
+        ServiceActivityNEW newAct = mock(ServiceActivityNEW.class);
         when(newAct.getSize()).thenReturn(newSize);
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, serviceRoute.getStart(), newAct, serviceRoute.getActivities().get(0), 0.);
@@ -556,7 +556,7 @@ public void whenPDRouteAndNewServiceDoesNotFitInBetweenAc1AndAct2_itShouldReturn
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
-        ServiceActivity newAct = mock(ServiceActivity.class);
+        ServiceActivityNEW newAct = mock(ServiceActivityNEW.class);
         when(newAct.getSize()).thenReturn(newSize);
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, serviceRoute.getActivities().get(0), newAct, serviceRoute.getActivities().get(1), 0.);
@@ -573,7 +573,7 @@ public void whenPDRouteAndNewServiceDoesNotFitInBetweenAc2AndEnd_itShouldReturnF
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
-        ServiceActivity newAct = mock(ServiceActivity.class);
+        ServiceActivityNEW newAct = mock(ServiceActivityNEW.class);
         when(newAct.getSize()).thenReturn(newSize);
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, serviceRoute.getActivities().get(1), newAct, serviceRoute.getEnd(), 0.);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/TestVehicleRoute.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/TestVehicleRoute.java
index 67b73e5a3..2ce3fac5a 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/TestVehicleRoute.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/TestVehicleRoute.java
@@ -26,7 +26,7 @@
 import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliverService;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupService;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.ServiceActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.ServiceActivityNEW;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
@@ -98,7 +98,7 @@ public void whenBuildingANonEmptyTour2Times_tourIterIteratesOverActivitiesCorrec
             assertEquals(1, count);
         }
         {
-            route.getTourActivities().addActivity(ServiceActivity.newInstance(Service.Builder.newInstance("3").addSizeDimension(0, 30).setLocation(Location.newInstance("1")).build()));
+            route.getTourActivities().addActivity(ServiceActivityNEW.newInstance(Service.Builder.newInstance("3").addSizeDimension(0, 30).setLocation(Location.newInstance("1")).build()));
             Iterator<TourActivity> iter = route.getTourActivities().iterator();
             int count = 0;
             while (iter.hasNext()) {
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/BreakActivityTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/BreakActivityTest.java
index 9f42f335e..17a1b7379 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/BreakActivityTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/BreakActivityTest.java
@@ -90,8 +90,8 @@ public void whenTwoDeliveriesHaveTheSameUnderlyingJob_theyAreEqual() {
         Service s1 = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).build();
         Service s2 = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).build();
 
-        ServiceActivity d1 = ServiceActivity.newInstance(s1);
-        ServiceActivity d2 = ServiceActivity.newInstance(s2);
+        ServiceActivityNEW d1 = ServiceActivityNEW.newInstance(s1);
+        ServiceActivityNEW d2 = ServiceActivityNEW.newInstance(s2);
 
         assertTrue(d1.equals(d2));
     }
@@ -101,8 +101,8 @@ public void whenTwoDeliveriesHaveTheDifferentUnderlyingJob_theyAreNotEqual() {
         Service s1 = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).build();
         Service s2 = Service.Builder.newInstance("s1").setLocation(Location.newInstance("loc")).build();
 
-        ServiceActivity d1 = ServiceActivity.newInstance(s1);
-        ServiceActivity d2 = ServiceActivity.newInstance(s2);
+        ServiceActivityNEW d1 = ServiceActivityNEW.newInstance(s1);
+        ServiceActivityNEW d2 = ServiceActivityNEW.newInstance(s2);
 
         assertFalse(d1.equals(d2));
     }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ServiceActivityTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ServiceActivityNEWTest.java
similarity index 88%
rename from jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ServiceActivityTest.java
rename to jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ServiceActivityNEWTest.java
index 4dedf751a..aee9b2561 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ServiceActivityTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ServiceActivityNEWTest.java
@@ -26,18 +26,18 @@
 import static org.junit.Assert.*;
 
 
-public class ServiceActivityTest {
+public class ServiceActivityNEWTest {
 
     private Service service;
 
-    private ServiceActivity serviceActivity;
+    private ServiceActivityNEW serviceActivity;
 
     @Before
     public void doBefore() {
         service = Service.Builder.newInstance("service").setLocation(Location.newInstance("loc")).
             setTimeWindow(TimeWindow.newInstance(1., 2.)).
             addSizeDimension(0, 10).addSizeDimension(1, 100).addSizeDimension(2, 1000).build();
-        serviceActivity = ServiceActivity.newInstance(service);
+        serviceActivity = ServiceActivityNEW.newInstance(service);
         serviceActivity.setTheoreticalEarliestOperationStartTime(service.getTimeWindow().getStart());
         serviceActivity.setTheoreticalLatestOperationStartTime(service.getTimeWindow().getEnd());
     }
@@ -79,7 +79,7 @@ public void whenIniLocationId_itShouldBeSetCorrectly() {
 
     @Test
     public void whenCopyingStart_itShouldBeDoneCorrectly() {
-        ServiceActivity copy = (ServiceActivity) serviceActivity.duplicate();
+        ServiceActivityNEW copy = (ServiceActivityNEW) serviceActivity.duplicate();
         assertEquals(1., copy.getTheoreticalEarliestOperationStartTime(), 0.01);
         assertEquals(2., copy.getTheoreticalLatestOperationStartTime(), 0.01);
         assertEquals("loc", copy.getLocation().getId());
@@ -92,8 +92,8 @@ public void whenTwoDeliveriesHaveTheSameUnderlyingJob_theyAreEqual() {
         Service s1 = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).build();
         Service s2 = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).build();
 
-        ServiceActivity d1 = ServiceActivity.newInstance(s1);
-        ServiceActivity d2 = ServiceActivity.newInstance(s2);
+        ServiceActivityNEW d1 = ServiceActivityNEW.newInstance(s1);
+        ServiceActivityNEW d2 = ServiceActivityNEW.newInstance(s2);
 
         assertTrue(d1.equals(d2));
     }
@@ -103,8 +103,8 @@ public void whenTwoDeliveriesHaveTheDifferentUnderlyingJob_theyAreNotEqual() {
         Service s1 = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).build();
         Service s2 = Service.Builder.newInstance("s1").setLocation(Location.newInstance("loc")).build();
 
-        ServiceActivity d1 = ServiceActivity.newInstance(s1);
-        ServiceActivity d2 = ServiceActivity.newInstance(s2);
+        ServiceActivityNEW d1 = ServiceActivityNEW.newInstance(s1);
+        ServiceActivityNEW d2 = ServiceActivityNEW.newInstance(s2);
 
         assertFalse(d1.equals(d2));
     }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TestTourActivities.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TestTourActivities.java
index 51fac31b2..5f8c2ef32 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TestTourActivities.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TestTourActivities.java
@@ -29,13 +29,13 @@
 public class TestTourActivities {
 
     private Service service;
-    private ServiceActivity act;
+    private ServiceActivityNEW act;
     private TourActivities tour;
 
     @Before
     public void doBefore() {
         service = Service.Builder.newInstance("yo").addSizeDimension(0, 10).setLocation(Location.newInstance("loc")).build();
-        act = ServiceActivity.newInstance(service);
+        act = ServiceActivityNEW.newInstance(service);
         tour = new TourActivities();
     }
 
