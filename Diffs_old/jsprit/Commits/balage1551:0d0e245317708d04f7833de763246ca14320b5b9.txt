diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionDataUpdater.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionDataUpdater.java
index df0fc6747..456658045 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionDataUpdater.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionDataUpdater.java
@@ -18,14 +18,21 @@
 
 package com.graphhopper.jsprit.core.algorithm.recreate;
 
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
+
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleFleetManager;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
 
-import java.util.*;
-
 /**
  * Created by schroeder on 15/10/15.
  */
@@ -33,13 +40,15 @@
 
     static boolean update(boolean addAllAvailable, Set<String> initialVehicleIds, VehicleFleetManager fleetManager, JobInsertionCostsCalculator insertionCostsCalculator, TreeSet<VersionedInsertionData> insertionDataSet, int updateRound, Job unassignedJob, Collection<VehicleRoute> routes) {
         for (VehicleRoute route : routes) {
-            Collection<Vehicle> relevantVehicles = new ArrayList<Vehicle>();
+            Collection<Vehicle> relevantVehicles = new ArrayList<>();
             if (!(route.getVehicle() instanceof VehicleImpl.NoVehicle)) {
                 relevantVehicles.add(route.getVehicle());
                 if (addAllAvailable && !initialVehicleIds.contains(route.getVehicle().getId())) {
                     relevantVehicles.addAll(fleetManager.getAvailableVehicles(route.getVehicle()));
                 }
-            } else relevantVehicles.addAll(fleetManager.getAvailableVehicles());
+            } else {
+                relevantVehicles.addAll(fleetManager.getAvailableVehicles());
+            }
             for (Vehicle v : relevantVehicles) {
                 double depTime = v.getEarliestDeparture();
                 InsertionData iData = insertionCostsCalculator.getInsertionData(route, unassignedJob, v, depTime, route.getDriver(), Double.MAX_VALUE);
@@ -67,13 +76,16 @@ static VehicleRoute findRoute(Collection<VehicleRoute> routes, Job job) {
         };
     }
 
-    static ScoredJob getBest(boolean switchAllowed, Set<String> initialVehicleIds, VehicleFleetManager fleetManager, JobInsertionCostsCalculator insertionCostsCalculator, ScoringFunction scoringFunction, TreeSet<VersionedInsertionData>[] priorityQueues, Map<VehicleRoute, Integer> updates, List<Job> unassignedJobList, List<Job> badJobs) {
+    static ScoredJob getBest(boolean switchAllowed, Set<String> initialVehicleIds, VehicleFleetManager fleetManager,
+            JobInsertionCostsCalculator insertionCostsCalculator, ScoringFunction scoringFunction,
+            Map<String, TreeSet<VersionedInsertionData>> priorityQueues, Map<VehicleRoute, Integer> updates,
+            List<Job> unassignedJobList, List<Job> badJobs) {
         ScoredJob bestScoredJob = null;
         for (Job j : unassignedJobList) {
             VehicleRoute bestRoute = null;
             InsertionData best = null;
             InsertionData secondBest = null;
-            TreeSet<VersionedInsertionData> priorityQueue = priorityQueues[j.getIndex()];
+            TreeSet<VersionedInsertionData> priorityQueue = priorityQueues.get(j.getId());
             Iterator<VersionedInsertionData> iterator = priorityQueue.iterator();
             while (iterator.hasNext()) {
                 VersionedInsertionData versionedIData = iterator.next();
@@ -82,11 +94,17 @@ static ScoredJob getBest(boolean switchAllowed, Set<String> initialVehicleIds, V
                         continue;
                     }
                 }
-                if (versionedIData.getiData() instanceof InsertionData.NoInsertionFound) continue;
+                if (versionedIData.getiData() instanceof InsertionData.NoInsertionFound) {
+                    continue;
+                }
                 if (!(versionedIData.getRoute().getVehicle() instanceof VehicleImpl.NoVehicle)) {
                     if (versionedIData.getiData().getSelectedVehicle() != versionedIData.getRoute().getVehicle()) {
-                        if (!switchAllowed) continue;
-                        if (initialVehicleIds.contains(versionedIData.getRoute().getVehicle().getId())) continue;
+                        if (!switchAllowed) {
+                            continue;
+                        }
+                        if (initialVehicleIds.contains(versionedIData.getRoute().getVehicle().getId())) {
+                            continue;
+                        }
                     }
                 }
                 if (versionedIData.getiData().getSelectedVehicle() != versionedIData.getRoute().getVehicle()) {
@@ -98,10 +116,14 @@ static ScoredJob getBest(boolean switchAllowed, Set<String> initialVehicleIds, V
                             for (Event e : oldData.getEvents()) {
                                 if (e instanceof SwitchVehicle) {
                                     newData.getEvents().add(new SwitchVehicle(versionedIData.getRoute(), available, oldData.getVehicleDepartureTime()));
-                                } else newData.getEvents().add(e);
+                                } else {
+                                    newData.getEvents().add(e);
+                                }
                             }
                             versionedIData = new VersionedInsertionData(newData, versionedIData.getVersion(), versionedIData.getRoute());
-                        } else continue;
+                        } else {
+                            continue;
+                        }
                     }
                 }
                 int currentDataVersion = updates.get(versionedIData.getRoute());
@@ -137,7 +159,9 @@ static ScoredJob getBest(boolean switchAllowed, Set<String> initialVehicleIds, V
             ScoredJob scoredJob;
             if (bestRoute == emptyRoute) {
                 scoredJob = new ScoredJob(j, score, best, bestRoute, true);
-            } else scoredJob = new ScoredJob(j, score, best, bestRoute, false);
+            } else {
+                scoredJob = new ScoredJob(j, score, best, bestRoute, false);
+            }
 
             if (bestScoredJob == null) {
                 bestScoredJob = scoredJob;
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionConcurrentFast.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionConcurrentFast.java
index 9f166871e..c253553f0 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionConcurrentFast.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionConcurrentFast.java
@@ -18,18 +18,28 @@
 
 package com.graphhopper.jsprit.core.algorithm.recreate;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.constraint.DependencyType;
 import com.graphhopper.jsprit.core.problem.job.Break;
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleFleetManager;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.*;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutorService;
 
 /**
  * Insertion based on regret approach.
@@ -58,7 +68,7 @@
 
     private boolean switchAllowed = true;
 
-    private DependencyType[] dependencyTypes = null;
+    private HashMap<String, DependencyType> dependencyTypes = null;
 
 
     /**
@@ -93,15 +103,15 @@ public void setSwitchAllowed(boolean switchAllowed) {
     }
 
     private Set<String> getInitialVehicleIds(VehicleRoutingProblem vehicleRoutingProblem) {
-        Set<String> ids = new HashSet<String>();
+        Set<String> ids = new HashSet<>();
         for (VehicleRoute r : vehicleRoutingProblem.getInitialVehicleRoutes()) {
             ids.add(r.getVehicle().getId());
         }
         return ids;
     }
 
-    public void setDependencyTypes(DependencyType[] dependencyTypes) {
-        this.dependencyTypes = dependencyTypes;
+    public void setDependencyTypes(HashMap<String, DependencyType> hashMap) {
+        this.dependencyTypes = hashMap;
     }
 
 
@@ -114,7 +124,7 @@ public void setDependencyTypes(DependencyType[] dependencyTypes) {
      */
     @Override
     public Collection<Job> insertUnassignedJobs(Collection<VehicleRoute> routes, Collection<Job> unassignedJobs) {
-        List<Job> badJobs = new ArrayList<Job>(unassignedJobs.size());
+        List<Job> badJobs = new ArrayList<>(unassignedJobs.size());
 
         Iterator<Job> jobIterator = unassignedJobs.iterator();
         while (jobIterator.hasNext()) {
@@ -135,18 +145,20 @@ public void setDependencyTypes(DependencyType[] dependencyTypes) {
             }
         }
 
-        List<Job> jobs = new ArrayList<Job>(unassignedJobs);
-        TreeSet<VersionedInsertionData>[] priorityQueues = new TreeSet[vrp.getJobs().values().size() + 2];
+        List<Job> jobs = new ArrayList<>(unassignedJobs);
+        Map<String, TreeSet<VersionedInsertionData>> priorityQueues = new HashMap<>(vrp.getJobs().values().size() + 2);
         VehicleRoute lastModified = null;
         boolean firstRun = true;
         int updateRound = 0;
-        Map<VehicleRoute, Integer> updates = new HashMap<VehicleRoute, Integer>();
+        Map<VehicleRoute, Integer> updates = new HashMap<>();
         while (!jobs.isEmpty()) {
-            List<Job> unassignedJobList = new ArrayList<Job>(jobs);
-            List<Job> badJobList = new ArrayList<Job>();
+            List<Job> unassignedJobList = new ArrayList<>(jobs);
+            List<Job> badJobList = new ArrayList<>();
             if (!firstRun && lastModified == null) throw new IllegalStateException("ho. this must not be.");
             updateInsertionData(priorityQueues, routes, unassignedJobList, updateRound, firstRun, lastModified, updates);
-            if (firstRun) firstRun = false;
+            if (firstRun) {
+                firstRun = false;
+            }
             updateRound++;
             ScoredJob bestScoredJob = InsertionDataUpdater.getBest(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator, scoringFunction, priorityQueues, updates, unassignedJobList, badJobList);
             if (bestScoredJob != null) {
@@ -156,7 +168,9 @@ public void setDependencyTypes(DependencyType[] dependencyTypes) {
                 insertJob(bestScoredJob.getJob(), bestScoredJob.getInsertionData(), bestScoredJob.getRoute());
                 jobs.remove(bestScoredJob.getJob());
                 lastModified = bestScoredJob.getRoute();
-            } else lastModified = null;
+            } else {
+                lastModified = null;
+            }
             for (Job bad : badJobList) {
                 jobs.remove(bad);
                 badJobs.add(bad);
@@ -165,32 +179,41 @@ public void setDependencyTypes(DependencyType[] dependencyTypes) {
         return badJobs;
     }
 
-    private void updateInsertionData(final TreeSet<VersionedInsertionData>[] priorityQueues, final Collection<VehicleRoute> routes, List<Job> unassignedJobList, final int updateRound, final boolean firstRun, final VehicleRoute lastModified, Map<VehicleRoute, Integer> updates) {
-        List<Callable<Boolean>> tasks = new ArrayList<Callable<Boolean>>();
+    private void updateInsertionData(final Map<String, TreeSet<VersionedInsertionData>> priorityQueues,
+            final Collection<VehicleRoute> routes, List<Job> unassignedJobList, final int updateRound,
+            final boolean firstRun, final VehicleRoute lastModified, Map<VehicleRoute, Integer> updates) {
+        List<Callable<Boolean>> tasks = new ArrayList<>();
         boolean updatedAllRoutes = false;
         for (final Job unassignedJob : unassignedJobList) {
-            if (priorityQueues[unassignedJob.getIndex()] == null) {
-                priorityQueues[unassignedJob.getIndex()] = new TreeSet<VersionedInsertionData>(InsertionDataUpdater.getComparator());
+            String unassignedJobId = unassignedJob.getId();
+            if (priorityQueues.get(unassignedJobId) == null) {
+                priorityQueues.put(unassignedJobId, new TreeSet<>(InsertionDataUpdater.getComparator()));
             }
             if (firstRun) {
                 updatedAllRoutes = true;
-                makeCallables(tasks, updatedAllRoutes, priorityQueues[unassignedJob.getIndex()], updateRound, unassignedJob, routes, lastModified);
+                makeCallables(tasks, updatedAllRoutes, priorityQueues.get(unassignedJobId), updateRound, unassignedJob,
+                        routes, lastModified);
             } else {
-                if (dependencyTypes == null || dependencyTypes[unassignedJob.getIndex()] == null) {
-                    makeCallables(tasks, updatedAllRoutes, priorityQueues[unassignedJob.getIndex()], updateRound, unassignedJob, routes, lastModified);
+                if (dependencyTypes == null || dependencyTypes.get(unassignedJobId) == null) {
+                    makeCallables(tasks, updatedAllRoutes, priorityQueues.get(unassignedJobId), updateRound,
+                            unassignedJob, routes, lastModified);
                 } else {
-                    DependencyType dependencyType = dependencyTypes[unassignedJob.getIndex()];
+                    DependencyType dependencyType = dependencyTypes.get(unassignedJobId);
                     if (dependencyType.equals(DependencyType.INTER_ROUTE) || dependencyType.equals(DependencyType.INTRA_ROUTE)) {
                         updatedAllRoutes = true;
-                        makeCallables(tasks, updatedAllRoutes, priorityQueues[unassignedJob.getIndex()], updateRound, unassignedJob, routes, lastModified);
+                        makeCallables(tasks, updatedAllRoutes, priorityQueues.get(unassignedJobId), updateRound,
+                                unassignedJob, routes, lastModified);
                     } else {
-                        makeCallables(tasks, updatedAllRoutes, priorityQueues[unassignedJob.getIndex()], updateRound, unassignedJob, routes, lastModified);
+                        makeCallables(tasks, updatedAllRoutes, priorityQueues.get(unassignedJobId), updateRound,
+                                unassignedJob, routes, lastModified);
                     }
                 }
             }
         }
         if (updatedAllRoutes) {
-            for (VehicleRoute r : routes) updates.put(r, updateRound);
+            for (VehicleRoute r : routes) {
+                updates.put(r, updateRound);
+            }
         } else {
             updates.put(lastModified, updateRound);
         }
@@ -204,19 +227,9 @@ private void updateInsertionData(final TreeSet<VersionedInsertionData>[] priorit
 
     private void makeCallables(List<Callable<Boolean>> tasks, boolean updateAll, final TreeSet<VersionedInsertionData> priorityQueue, final int updateRound, final Job unassignedJob, final Collection<VehicleRoute> routes, final VehicleRoute lastModified) {
         if (updateAll) {
-            tasks.add(new Callable<Boolean>() {
-                @Override
-                public Boolean call() throws Exception {
-                    return InsertionDataUpdater.update(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator, priorityQueue, updateRound, unassignedJob, routes);
-                }
-            });
+            tasks.add(() -> InsertionDataUpdater.update(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator, priorityQueue, updateRound, unassignedJob, routes));
         } else {
-            tasks.add(new Callable<Boolean>() {
-                @Override
-                public Boolean call() throws Exception {
-                    return InsertionDataUpdater.update(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator, priorityQueue, updateRound, unassignedJob, Arrays.asList(lastModified));
-                }
-            });
+            tasks.add(() -> InsertionDataUpdater.update(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator, priorityQueue, updateRound, unassignedJob, Arrays.asList(lastModified)));
         }
     }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionFast.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionFast.java
index de4b65a53..3d251c747 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionFast.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionFast.java
@@ -18,15 +18,24 @@
 
 package com.graphhopper.jsprit.core.algorithm.recreate;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.constraint.DependencyType;
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleFleetManager;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.*;
 
 /**
  * Insertion based on regret approach.
@@ -52,7 +61,7 @@
 
     private boolean switchAllowed = true;
 
-    private DependencyType[] dependencyTypes = null;
+    private Map<String, DependencyType> dependencyTypes = null;
 
     public RegretInsertionFast(JobInsertionCostsCalculator jobInsertionCalculator, VehicleRoutingProblem vehicleRoutingProblem, VehicleFleetManager fleetManager) {
         super(vehicleRoutingProblem);
@@ -79,12 +88,12 @@ public void setSwitchAllowed(boolean switchAllowed) {
         this.switchAllowed = switchAllowed;
     }
 
-    public void setDependencyTypes(DependencyType[] dependencyTypes) {
+    public void setDependencyTypes(Map<String, DependencyType> dependencyTypes) {
         this.dependencyTypes = dependencyTypes;
     }
 
     private Set<String> getInitialVehicleIds(VehicleRoutingProblem vehicleRoutingProblem) {
-        Set<String> ids = new HashSet<String>();
+        Set<String> ids = new HashSet<>();
         for (VehicleRoute r : vehicleRoutingProblem.getInitialVehicleRoutes()) {
             ids.add(r.getVehicle().getId());
         }
@@ -104,37 +113,37 @@ public String toString() {
      */
     @Override
     public Collection<Job> insertUnassignedJobs(Collection<VehicleRoute> routes, Collection<Job> unassignedJobs) {
-        List<Job> badJobs = new ArrayList<Job>(unassignedJobs.size());
-
-//        Iterator<Job> jobIterator = unassignedJobs.iterator();
-//        while (jobIterator.hasNext()){
-//            Job job = jobIterator.next();
-//            if(job instanceof Break){
-//                VehicleRoute route = InsertionDataUpdater.findRoute(routes, job);
-//                if(route == null){
-//                    badJobs.add(job);
-//                }
-//                else {
-//                    InsertionData iData = insertionCostsCalculator.getInsertionData(route, job, NO_NEW_VEHICLE_YET, NO_NEW_DEPARTURE_TIME_YET, NO_NEW_DRIVER_YET, Double.MAX_VALUE);
-//                    if (iData instanceof InsertionData.NoInsertionFound) {
-//                        badJobs.add(job);
-//                    } else {
-//                        insertJob(job, iData, route);
-//                    }
-//                }
-//                jobIterator.remove();
-//            }
-//        }
-
-        List<Job> jobs = new ArrayList<Job>(unassignedJobs);
-        TreeSet<VersionedInsertionData>[] priorityQueues = new TreeSet[vrp.getJobs().values().size() + 2];
+        List<Job> badJobs = new ArrayList<>(unassignedJobs.size());
+
+        //        Iterator<Job> jobIterator = unassignedJobs.iterator();
+        //        while (jobIterator.hasNext()){
+        //            Job job = jobIterator.next();
+        //            if(job instanceof Break){
+        //                VehicleRoute route = InsertionDataUpdater.findRoute(routes, job);
+        //                if(route == null){
+        //                    badJobs.add(job);
+        //                }
+        //                else {
+        //                    InsertionData iData = insertionCostsCalculator.getInsertionData(route, job, NO_NEW_VEHICLE_YET, NO_NEW_DEPARTURE_TIME_YET, NO_NEW_DRIVER_YET, Double.MAX_VALUE);
+        //                    if (iData instanceof InsertionData.NoInsertionFound) {
+        //                        badJobs.add(job);
+        //                    } else {
+        //                        insertJob(job, iData, route);
+        //                    }
+        //                }
+        //                jobIterator.remove();
+        //            }
+        //        }
+
+        List<Job> jobs = new ArrayList<>(unassignedJobs);
+        Map<String, TreeSet<VersionedInsertionData>> priorityQueues = new HashMap<>(vrp.getJobs().values().size() + 2);
         VehicleRoute lastModified = null;
         boolean firstRun = true;
         int updateRound = 0;
-        Map<VehicleRoute, Integer> updates = new HashMap<VehicleRoute, Integer>();
+        Map<VehicleRoute, Integer> updates = new HashMap<>();
         while (!jobs.isEmpty()) {
-            List<Job> unassignedJobList = new ArrayList<Job>(jobs);
-            List<Job> badJobList = new ArrayList<Job>();
+            List<Job> unassignedJobList = new ArrayList<>(jobs);
+            List<Job> badJobList = new ArrayList<>();
             if (!firstRun && lastModified == null)
                 throw new IllegalStateException("last modified route is null. this should not be.");
             if (firstRun) {
@@ -143,7 +152,7 @@ public String toString() {
             } else {
                 //update for all routes || remove history and only update modified route
                 updateInsertionData(priorityQueues, routes, unassignedJobList, updateRound, firstRun, lastModified, updates);
-//                updates.put(lastModified,updateRound);
+                //                updates.put(lastModified,updateRound);
             }
             updateRound++;
             ScoredJob bestScoredJob = InsertionDataUpdater.getBest(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator, scoringFunction, priorityQueues, updates, unassignedJobList, badJobList);
@@ -154,7 +163,9 @@ public String toString() {
                 insertJob(bestScoredJob.getJob(), bestScoredJob.getInsertionData(), bestScoredJob.getRoute());
                 jobs.remove(bestScoredJob.getJob());
                 lastModified = bestScoredJob.getRoute();
-            } else lastModified = null;
+            } else {
+                lastModified = null;
+            }
             for (Job bad : badJobList) {
                 jobs.remove(bad);
                 badJobs.add(bad);
@@ -163,25 +174,40 @@ public String toString() {
         return badJobs;
     }
 
-    private void updateInsertionData(TreeSet<VersionedInsertionData>[] priorityQueues, Collection<VehicleRoute> routes, List<Job> unassignedJobList, int updateRound, boolean firstRun, VehicleRoute lastModified, Map<VehicleRoute, Integer> updates) {
+    private void updateInsertionData(Map<String, TreeSet<VersionedInsertionData>> priorityQueues,
+            Collection<VehicleRoute> routes, List<Job> unassignedJobList, int updateRound, boolean firstRun,
+            VehicleRoute lastModified, Map<VehicleRoute, Integer> updates) {
         for (Job unassignedJob : unassignedJobList) {
-            if (priorityQueues[unassignedJob.getIndex()] == null) {
-                priorityQueues[unassignedJob.getIndex()] = new TreeSet<VersionedInsertionData>(InsertionDataUpdater.getComparator());
+            String unassignedJobId = unassignedJob.getId();
+            if (priorityQueues.get(unassignedJobId) == null) {
+                priorityQueues.put(unassignedJobId,
+                        new TreeSet<>(InsertionDataUpdater.getComparator()));
             }
             if (firstRun) {
-                InsertionDataUpdater.update(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator, priorityQueues[unassignedJob.getIndex()], updateRound, unassignedJob, routes);
-                for (VehicleRoute r : routes) updates.put(r, updateRound);
+                InsertionDataUpdater.update(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator,
+                        priorityQueues.get(unassignedJobId), updateRound, unassignedJob, routes);
+                for (VehicleRoute r : routes) {
+                    updates.put(r, updateRound);
+                }
             } else {
-                if (dependencyTypes == null || dependencyTypes[unassignedJob.getIndex()] == null) {
-                    InsertionDataUpdater.update(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator, priorityQueues[unassignedJob.getIndex()], updateRound, unassignedJob, Arrays.asList(lastModified));
+                if (dependencyTypes == null || dependencyTypes.get(unassignedJobId) == null) {
+                    InsertionDataUpdater.update(switchAllowed, initialVehicleIds, fleetManager,
+                            insertionCostsCalculator, priorityQueues.get(unassignedJobId), updateRound, unassignedJob,
+                            Arrays.asList(lastModified));
                     updates.put(lastModified, updateRound);
                 } else {
-                    DependencyType dependencyType = dependencyTypes[unassignedJob.getIndex()];
+                    DependencyType dependencyType = dependencyTypes.get(unassignedJobId);
                     if (dependencyType.equals(DependencyType.INTER_ROUTE) || dependencyType.equals(DependencyType.INTRA_ROUTE)) {
-                        InsertionDataUpdater.update(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator, priorityQueues[unassignedJob.getIndex()], updateRound, unassignedJob, routes);
-                        for (VehicleRoute r : routes) updates.put(r, updateRound);
+                        InsertionDataUpdater.update(switchAllowed, initialVehicleIds, fleetManager,
+                                insertionCostsCalculator, priorityQueues.get(unassignedJobId), updateRound,
+                                unassignedJob, routes);
+                        for (VehicleRoute r : routes) {
+                            updates.put(r, updateRound);
+                        }
                     } else {
-                        InsertionDataUpdater.update(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator, priorityQueues[unassignedJob.getIndex()], updateRound, unassignedJob, Arrays.asList(lastModified));
+                        InsertionDataUpdater.update(switchAllowed, initialVehicleIds, fleetManager,
+                                insertionCostsCalculator, priorityQueues.get(unassignedJobId), updateRound,
+                                unassignedJob, Arrays.asList(lastModified));
                         updates.put(lastModified, updateRound);
                     }
                 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsOptimized.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsOptimized.java
index 9d2b28270..3399a6fa2 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsOptimized.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsOptimized.java
@@ -18,14 +18,21 @@
 
 package com.graphhopper.jsprit.core.algorithm.ruin;
 
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import com.graphhopper.jsprit.core.algorithm.ruin.distance.JobDistance;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.util.StopWatch;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.*;
 
 /**
  * Created by schroeder on 07/01/15.
@@ -50,9 +57,8 @@ public ArrayIterator(int noItems, int[] itemArray, Job[] jobs) {
 
         @Override
         public boolean hasNext() {
-            if (index < noItems && index < itemArray.length) {
+            if (index < noItems && index < itemArray.length)
                 return true;
-            }
             return false;
         }
 
@@ -73,6 +79,8 @@ public void remove() {
 
     private VehicleRoutingProblem vrp;
 
+    private Map<Job, Integer> jobIndexMapping;
+
     private int[][] neighbors;
 
     private Job[] jobs;
@@ -90,12 +98,16 @@ public JobNeighborhoodsOptimized(VehicleRoutingProblem vrp, JobDistance jobDista
         this.capacity = capacity;
         neighbors = new int[vrp.getJobsInclusiveInitialJobsInRoutes().size() + 1][capacity];
         jobs = new Job[vrp.getJobsInclusiveInitialJobsInRoutes().size() + 1];
+        jobIndexMapping = new HashMap<>();
+        for (Job job : vrp.getJobsInclusiveInitialJobsInRoutes().values()) {
+            jobIndexMapping.put(job, jobIndexMapping.size());
+        }
         logger.debug("initialize {}", this);
     }
 
     @Override
     public Iterator<Job> getNearestNeighborsIterator(int nNeighbors, Job neighborTo) {
-        int[] neighbors = this.neighbors[neighborTo.getIndex() - 1];
+        int[] neighbors = this.neighbors[jobIndexMapping.get(neighborTo)];
         return new ArrayIterator(nNeighbors, neighbors, jobs);
     }
 
@@ -116,36 +128,37 @@ private void calculateDistancesFromJob2Job() {
         StopWatch stopWatch = new StopWatch();
         stopWatch.start();
         for (Job job_i : vrp.getJobsInclusiveInitialJobsInRoutes().values()) {
-            jobs[job_i.getIndex()] = job_i;
-            List<ReferencedJob> jobList = new ArrayList<ReferencedJob>(vrp.getJobsInclusiveInitialJobsInRoutes().values().size());
+            jobs[jobIndexMapping.get(job_i)] = job_i;
+            List<ReferencedJob> jobList = new ArrayList<>(vrp.getJobsInclusiveInitialJobsInRoutes().values().size());
             for (Job job_j : vrp.getJobsInclusiveInitialJobsInRoutes().values()) {
-                if (job_i == job_j) continue;
+                if (job_i == job_j) {
+                    continue;
+                }
                 double distance = jobDistance.getDistance(job_i, job_j);
-                if (distance > maxDistance) maxDistance = distance;
+                if (distance > maxDistance) {
+                    maxDistance = distance;
+                }
                 ReferencedJob referencedJob = new ReferencedJob(job_j, distance);
                 jobList.add(referencedJob);
             }
             Collections.sort(jobList, getComparator());
             int[] jobIndices = new int[capacity];
             for (int index = 0; index < capacity; index++) {
-                jobIndices[index] = jobList.get(index).getJob().getIndex();
+                jobIndices[index] = jobIndexMapping.get(jobList.get(index).getJob());
             }
-            neighbors[job_i.getIndex() - 1] = jobIndices;
+            neighbors[jobIndexMapping.get(job_i)] = jobIndices;
         }
         stopWatch.stop();
         logger.debug("pre-processing comp-time: {}", stopWatch);
     }
 
     private Comparator<ReferencedJob> getComparator() {
-        return new Comparator<ReferencedJob>() {
-            @Override
-            public int compare(ReferencedJob o1, ReferencedJob o2) {
-                if (o1.getDistance() < o2.getDistance()) {
-                    return -1;
-                } else if (o1.getDistance() > o2.getDistance()) {
-                    return 1;
-                } else return 0;
-            }
+        return (o1, o2) -> {
+            if (o1.getDistance() < o2.getDistance())
+                return -1;
+            else if (o1.getDistance() > o2.getDistance())
+                return 1;
+            else return 0;
         };
     }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
index 8b4338057..7c65a73ba 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
@@ -246,7 +246,7 @@ private FriendlyHandshake() {
         public Builder addJob(AbstractJob job) {
             if (tentativeJobs.containsKey(job.getId()))
                 throw new IllegalArgumentException("vehicle routing problem already contains a service or shipment with id " + job.getId() + ". make sure you use unique ids for all services and shipments");
-            job.impl_setIndex(FRIENDLY_HANDSHAKE, jobIndexCounter);
+            // job.impl_setIndex(FRIENDLY_HANDSHAKE, jobIndexCounter);
             incJobIndexCounter();
             tentativeJobs.put(job.getId(), job);
             addLocationToTentativeLocations(job);
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ConstraintManager.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ConstraintManager.java
index 1a15d35e3..617591486 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ConstraintManager.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ConstraintManager.java
@@ -17,19 +17,20 @@
  */
 package com.graphhopper.jsprit.core.problem.constraint;
 
-import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
-import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.state.RouteAndActivityStateGetter;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.state.RouteAndActivityStateGetter;
+
 /**
  * Manager that manage hard- and soft constraints, both on route and activity level.
  *
@@ -61,38 +62,31 @@
 
     private boolean skillconstraintSet = false;
 
-    private final DependencyType[] dependencyTypes;
+    private final HashMap<String, DependencyType> dependencyTypes;
 
     public ConstraintManager(VehicleRoutingProblem vrp, RouteAndActivityStateGetter stateManager) {
         this.vrp = vrp;
         this.stateManager = stateManager;
-        dependencyTypes = new DependencyType[vrp.getJobs().size() + 1];
+        dependencyTypes = new HashMap<>(vrp.getJobs().size() + 1);
     }
 
     public ConstraintManager(VehicleRoutingProblem vrp, RouteAndActivityStateGetter stateManager, Collection<Constraint> constraints) {
         this.vrp = vrp;
         this.stateManager = stateManager;
-        dependencyTypes = new DependencyType[vrp.getJobs().size() + 1];
+        dependencyTypes = new HashMap<>(vrp.getJobs().size() + 1);
         resolveConstraints(constraints);
     }
 
-    public DependencyType[] getDependencyTypes() {
+    public HashMap<String, DependencyType> getDependencyTypes() {
         return dependencyTypes;
     }
 
     public void setDependencyType(String jobId, DependencyType dependencyType) {
-        Job job = vrp.getJobs().get(jobId);
-        if (job != null) {
-            dependencyTypes[job.getIndex()] = dependencyType;
-        }
+        dependencyTypes.put(jobId, dependencyType);
     }
 
     public DependencyType getDependencyType(String jobId) {
-        Job job = vrp.getJobs().get(jobId);
-        if (job != null) {
-            return dependencyTypes[job.getIndex()];
-        }
-        return DependencyType.NO_TYPE;
+        return dependencyTypes.getOrDefault(jobId, DependencyType.NO_TYPE);
     }
 
     private void resolveConstraints(Collection<Constraint> constraints) {
@@ -145,7 +139,7 @@ public void addSkillsConstraint() {
         }
     }
 
-//	public void add
+    //	public void add
 
     public void addConstraint(HardActivityConstraint actLevelConstraint, Priority priority) {
         actLevelConstraintManager.addConstraint(actLevelConstraint, priority);
@@ -174,7 +168,7 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
     }
 
     public Collection<Constraint> getConstraints() {
-        List<Constraint> constraints = new ArrayList<Constraint>();
+        List<Constraint> constraints = new ArrayList<>();
         constraints.addAll(actLevelConstraintManager.getAllConstraints());
         constraints.addAll(routeLevelConstraintManager.getConstraints());
         constraints.addAll(softActivityConstraintManager.getConstraints());
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractJob.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractJob.java
index 39e6af9fe..6819fbbf2 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractJob.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractJob.java
@@ -27,7 +27,6 @@
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.SizeDimension;
 import com.graphhopper.jsprit.core.problem.Skills;
-import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem.Builder.FriendlyHandshake;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
 
@@ -381,27 +380,28 @@ protected AbstractJob(JobBuilder<?, ?> builder) {
     AbstractJob() {
     }
 
-    @Override
-    public int getIndex() {
-        return index;
-    }
-
-
-    /**
-     * Sets the index of the job within the problem.
-     * <p>
-     * <b>This method isn't part of the public API and should not be called! If
-     * it is still called, it will throw {@link IllegalStateException}.</b>
-     * </p>
-     *
-     * @param index
-     *            The index.
-     */
-    public void impl_setIndex(FriendlyHandshake handshake, int index) {
-        if (handshake == null)
-            throw new IllegalStateException();
-        this.index = index;
-    }
+    // @Override
+    // public int getIndex() {
+    // return index;
+    // }
+
+    //
+    // /**
+    // * Sets the index of the job within the problem.
+    // * <p>
+    // * <b>This method isn't part of the public API and should not be called!
+    // If
+    // * it is still called, it will throw {@link IllegalStateException}.</b>
+    // * </p>
+    // *
+    // * @param index
+    // * The index.
+    // */
+    // public void impl_setIndex(FriendlyHandshake handshake, int index) {
+    // if (handshake == null)
+    // throw new IllegalStateException();
+    // this.index = index;
+    // }
 
     /**
      * @return User-specific domain data associated with the job
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Job.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Job.java
index 5312c4517..200fac98c 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Job.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Job.java
@@ -22,7 +22,6 @@
 import java.util.List;
 
 import com.graphhopper.jsprit.core.problem.HasId;
-import com.graphhopper.jsprit.core.problem.HasIndex;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.SizeDimension;
 import com.graphhopper.jsprit.core.problem.Skills;
@@ -33,7 +32,7 @@
  *
  * @author schroeder
  */
-public interface Job extends HasId, HasIndex {
+public interface Job extends HasId {
 
     /**
      * Returns the unique identifier (id) of a job.
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
index b3d7b4ba8..45325575f 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
@@ -24,7 +24,6 @@
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.SizeDimension;
 import com.graphhopper.jsprit.core.problem.Skills;
-import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem.Builder.FriendlyHandshake;
 import com.graphhopper.jsprit.core.problem.job.CustomJob.BuilderBase.ActivityType;
 import com.graphhopper.jsprit.core.problem.job.CustomJob.BuilderBase.BuilderActivityInfo;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.ServiceActivity;
@@ -456,15 +455,15 @@ protected void createActivities(JobBuilder<? extends AbstractJob, ?> jobBuilder)
         // This is unused being a legacy implementation
     }
 
-    @Override
-    public int getIndex() {
-        return theRealJob.getIndex();
-    }
-
-    @Override
-    public void impl_setIndex(FriendlyHandshake handshake, int index) {
-        theRealJob.impl_setIndex(handshake, index);
-    }
+    //    @Override
+    //    public int getIndex() {
+    //        return theRealJob.getIndex();
+    //    }
+    //
+    // @Override
+    // public void impl_setIndex(FriendlyHandshake handshake, int index) {
+    // theRealJob.impl_setIndex(handshake, index);
+    // }
 
     @Override
     public List<Location> getAllLocations() {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
index bda9f53cf..5a21753c0 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
@@ -24,7 +24,6 @@
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.SizeDimension;
 import com.graphhopper.jsprit.core.problem.Skills;
-import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem.Builder.FriendlyHandshake;
 import com.graphhopper.jsprit.core.problem.job.CustomJob.BuilderBase.ActivityType;
 import com.graphhopper.jsprit.core.problem.job.CustomJob.BuilderBase.BuilderActivityInfo;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivity;
@@ -517,10 +516,10 @@ protected void createActivities(JobBuilder<? extends AbstractJob, ?> jobBuilder)
         // This is unused being a legacy implementation
     }
 
-    @Override
-    public int getIndex() {
-        return theRealJob.getIndex();
-    }
+    // @Override
+    // public int getIndex() {
+    // return theRealJob.getIndex();
+    // }
 
     @Override
     public Object getUserData() {
@@ -557,10 +556,10 @@ public String toString() {
         return theRealJob.toString();
     }
 
-    @Override
-    public void impl_setIndex(FriendlyHandshake handshake, int index) {
-        theRealJob.impl_setIndex(handshake, index);
-    }
+    // @Override
+    // public void impl_setIndex(FriendlyHandshake handshake, int index) {
+    // theRealJob.impl_setIndex(handshake, index);
+    // }
 
 
     @Override
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblemTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblemTest.java
index b1ad85795..74181d9d9 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblemTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblemTest.java
@@ -241,7 +241,7 @@ public void whenServicesAreAddedAllAtOnce_vrpShouldContainThem() {
         when(s2.getId()).thenReturn("s2");
         when(s2.getActivityList()).thenReturn(new SequentialJobActivityList(s2));
 
-        Collection<ServiceJob> services = new ArrayList<ServiceJob>();
+        Collection<ServiceJob> services = new ArrayList<>();
         services.add(s1);
         services.add(s2);
 
@@ -285,13 +285,13 @@ public void whenSettingRoutingCosts_vprShouldContainIt() {
 
             @Override
             public double getTransportTime(Location from, Location to,
-                            double departureTime, Driver driver, Vehicle vehicle) {
+                    double departureTime, Driver driver, Vehicle vehicle) {
                 return 0;
             }
 
             @Override
             public double getTransportCost(Location from, Location to,
-                            double departureTime, Driver driver, Vehicle vehicle) {
+                    double departureTime, Driver driver, Vehicle vehicle) {
                 return 4.0;
             }
         });
@@ -362,7 +362,7 @@ public void whenAddingTwoVehicleWithDiffType_getAddedVehicleTypesShouldReturnThe
     @Test
     public void whenAddingVehicleWithDiffStartAndEnd_startLocationMustBeRegisteredInLocationMap() {
         VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("start"))
-                        .setEndLocation(Location.newInstance("end")).build();
+                .setEndLocation(Location.newInstance("end")).build();
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.addVehicle(vehicle);
@@ -372,7 +372,7 @@ public void whenAddingVehicleWithDiffStartAndEnd_startLocationMustBeRegisteredIn
     @Test
     public void whenAddingVehicleWithDiffStartAndEnd_endLocationMustBeRegisteredInLocationMap() {
         VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("start"))
-                        .setEndLocation(Location.newInstance("end")).build();
+                .setEndLocation(Location.newInstance("end")).build();
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.addVehicle(vehicle);
@@ -382,7 +382,7 @@ public void whenAddingVehicleWithDiffStartAndEnd_endLocationMustBeRegisteredInLo
     @Test
     public void whenAddingInitialRoute_itShouldBeAddedCorrectly() {
         VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v")
-                        .setStartLocation(Location.newInstance("start")).setEndLocation(Location.newInstance("end")).build();
+                .setStartLocation(Location.newInstance("start")).setEndLocation(Location.newInstance("end")).build();
         VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, DriverImpl.noDriver()).build();
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.addInitialVehicleRoute(route);
@@ -393,11 +393,11 @@ public void whenAddingInitialRoute_itShouldBeAddedCorrectly() {
     @Test
     public void whenAddingInitialRoutes_theyShouldBeAddedCorrectly() {
         VehicleImpl vehicle1 = VehicleImpl.Builder.newInstance("v")
-                        .setStartLocation(Location.newInstance("start")).setEndLocation(Location.newInstance("end")).build();
+                .setStartLocation(Location.newInstance("start")).setEndLocation(Location.newInstance("end")).build();
         VehicleRoute route1 = VehicleRoute.Builder.newInstance(vehicle1, DriverImpl.noDriver()).build();
 
         VehicleImpl vehicle2 = VehicleImpl.Builder.newInstance("v")
-                        .setStartLocation(Location.newInstance("start")).setEndLocation(Location.newInstance("end")).build();
+                .setStartLocation(Location.newInstance("start")).setEndLocation(Location.newInstance("end")).build();
         VehicleRoute route2 = VehicleRoute.Builder.newInstance(vehicle2, DriverImpl.noDriver()).build();
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
@@ -413,8 +413,8 @@ public void whenAddingInitialRoute_locationOfVehicleMustBeMemorized() {
         Location start = TestUtils.loc("start", Coordinate.newInstance(0, 1));
         Location end = Location.newInstance("end");
         VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v")
-                        .setStartLocation(start)
-                        .setEndLocation(end).build();
+                .setStartLocation(start)
+                .setEndLocation(end).build();
         VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, DriverImpl.noDriver()).build();
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.addInitialVehicleRoute(route);
@@ -429,8 +429,8 @@ public void whenAddingJobAndInitialRouteWithThatJobAfterwards_thisJobShouldNotBe
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.addJob(service);
         VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v")
-                        .setStartLocation(TestUtils.loc("start", Coordinate.newInstance(0, 1)))
-                        .setEndLocation(Location.newInstance("end")).build();
+                .setStartLocation(TestUtils.loc("start", Coordinate.newInstance(0, 1)))
+                .setEndLocation(Location.newInstance("end")).build();
         VehicleRoute initialRoute = VehicleRoute.Builder.newInstance(vehicle).addService(service).build();
         vrpBuilder.addInitialVehicleRoute(initialRoute);
         VehicleRoutingProblem vrp = vrpBuilder.build();
@@ -438,21 +438,24 @@ public void whenAddingJobAndInitialRouteWithThatJobAfterwards_thisJobShouldNotBe
         assertEquals(3, vrp.getAllLocations().size());
     }
 
-    @Test
-    public void whenAddingTwoJobs_theyShouldHaveProperIndeces() {
-        ServiceJob service = new ServiceJob.Builder("myService").setLocation(Location.newInstance("loc")).build();
-        ShipmentJob shipment = new ShipmentJob.Builder("shipment").setPickupLocation(Location.Builder.newInstance().setId("pick").build())
-                        .setDeliveryLocation(Location.newInstance("del")).build();
-        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
-        vrpBuilder.addJob(service);
-        vrpBuilder.addJob(shipment);
-        VehicleRoutingProblem vrp = vrpBuilder.build();
-
-        assertEquals(1, service.getIndex());
-        assertEquals(2, shipment.getIndex());
-        assertEquals(3, vrp.getAllLocations().size());
-
-    }
+    // @Test
+    // public void whenAddingTwoJobs_theyShouldHaveProperIndeces() {
+    // ServiceJob service = new
+    // ServiceJob.Builder("myService").setLocation(Location.newInstance("loc")).build();
+    // ShipmentJob shipment = new
+    // ShipmentJob.Builder("shipment").setPickupLocation(Location.Builder.newInstance().setId("pick").build())
+    // .setDeliveryLocation(Location.newInstance("del")).build();
+    // VehicleRoutingProblem.Builder vrpBuilder =
+    // VehicleRoutingProblem.Builder.newInstance();
+    // vrpBuilder.addJob(service);
+    // vrpBuilder.addJob(shipment);
+    // VehicleRoutingProblem vrp = vrpBuilder.build();
+    //
+    // assertEquals(1, service.getIndex());
+    // assertEquals(2, shipment.getIndex());
+    // assertEquals(3, vrp.getAllLocations().size());
+    //
+    // }
 
     @Test(expected = IllegalArgumentException.class)
     public void whenAddingTwoServicesWithTheSameId_itShouldThrowException() {
@@ -467,9 +470,9 @@ public void whenAddingTwoServicesWithTheSameId_itShouldThrowException() {
     @Test(expected = IllegalArgumentException.class)
     public void whenAddingTwoShipmentsWithTheSameId_itShouldThrowException() {
         ShipmentJob shipment1 = new ShipmentJob.Builder("shipment").setPickupLocation(Location.Builder.newInstance().setId("pick").build())
-                        .setDeliveryLocation(Location.newInstance("del")).build();
+                .setDeliveryLocation(Location.newInstance("del")).build();
         ShipmentJob shipment2 = new ShipmentJob.Builder("shipment").setPickupLocation(Location.Builder.newInstance().setId("pick").build())
-                        .setDeliveryLocation(Location.newInstance("del")).build();
+                .setDeliveryLocation(Location.newInstance("del")).build();
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.addJob(shipment1);
         vrpBuilder.addJob(shipment2);
@@ -480,9 +483,9 @@ public void whenAddingTwoShipmentsWithTheSameId_itShouldThrowException() {
     @Test
     public void whenAddingTwoVehicles_theyShouldHaveProperIndices() {
         VehicleImpl veh1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(TestUtils.loc("start", Coordinate.newInstance(0, 1)))
-                        .setEndLocation(Location.newInstance("end")).build();
+                .setEndLocation(Location.newInstance("end")).build();
         VehicleImpl veh2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(TestUtils.loc("start", Coordinate.newInstance(0, 1)))
-                        .setEndLocation(Location.newInstance("end")).build();
+                .setEndLocation(Location.newInstance("end")).build();
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.addVehicle(veh1);
@@ -497,11 +500,11 @@ public void whenAddingTwoVehicles_theyShouldHaveProperIndices() {
     @Test
     public void whenAddingTwoVehiclesWithSameTypeIdentifier_typeIdentifiersShouldHaveSameIndices() {
         VehicleImpl veh1 = VehicleImpl.Builder.newInstance("v1")
-                        .setStartLocation(TestUtils.loc("start", Coordinate.newInstance(0, 1)))
-                        .setEndLocation(Location.newInstance("end")).build();
+                .setStartLocation(TestUtils.loc("start", Coordinate.newInstance(0, 1)))
+                .setEndLocation(Location.newInstance("end")).build();
         VehicleImpl veh2 = VehicleImpl.Builder.newInstance("v2")
-                        .setStartLocation(TestUtils.loc("start", Coordinate.newInstance(0, 1)))
-                        .setEndLocation(Location.newInstance("end")).build();
+                .setStartLocation(TestUtils.loc("start", Coordinate.newInstance(0, 1)))
+                .setEndLocation(Location.newInstance("end")).build();
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.addVehicle(veh1);
@@ -516,11 +519,11 @@ public void whenAddingTwoVehiclesWithSameTypeIdentifier_typeIdentifiersShouldHav
     @Test
     public void whenAddingTwoVehiclesDifferentTypeIdentifier_typeIdentifiersShouldHaveDifferentIndices() {
         VehicleImpl veh1 = VehicleImpl.Builder.newInstance("v1")
-                        .setStartLocation(TestUtils.loc("start", Coordinate.newInstance(0, 1)))
-                        .setEndLocation(Location.newInstance("end")).build();
+                .setStartLocation(TestUtils.loc("start", Coordinate.newInstance(0, 1)))
+                .setEndLocation(Location.newInstance("end")).build();
         VehicleImpl veh2 = VehicleImpl.Builder.newInstance("v2")
-                        .setStartLocation(TestUtils.loc("startLoc", Coordinate.newInstance(0, 1)))
-                        .setEndLocation(Location.newInstance("end")).build();
+                .setStartLocation(TestUtils.loc("startLoc", Coordinate.newInstance(0, 1)))
+                .setEndLocation(Location.newInstance("end")).build();
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.addVehicle(veh1);
