diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/InsertionInitialSolutionFactory.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/InsertionInitialSolutionFactory.java
index 137ad3446..801005826 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/InsertionInitialSolutionFactory.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/InsertionInitialSolutionFactory.java
@@ -19,6 +19,14 @@
 
 package com.graphhopper.jsprit.core.algorithm;
 
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.ModularSolutionCostCalculator;
 import com.graphhopper.jsprit.core.algorithm.recreate.InsertionStrategy;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.job.Job;
@@ -26,12 +34,6 @@
 import com.graphhopper.jsprit.core.problem.solution.SolutionCostCalculator;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
 
 
 public final class InsertionInitialSolutionFactory implements InitialSolutionFactory {
@@ -44,27 +46,31 @@
 
     public InsertionInitialSolutionFactory(InsertionStrategy insertionStrategy, SolutionCostCalculator solutionCostCalculator) {
         super();
-        this.insertion = insertionStrategy;
-        this.solutionCostsCalculator = solutionCostCalculator;
+        insertion = insertionStrategy;
+        solutionCostsCalculator = solutionCostCalculator;
     }
 
     @Override
     public VehicleRoutingProblemSolution createSolution(final VehicleRoutingProblem vrp) {
         logger.info("create initial solution");
-        List<VehicleRoute> vehicleRoutes = new ArrayList<VehicleRoute>();
+        List<VehicleRoute> vehicleRoutes = new ArrayList<>();
         vehicleRoutes.addAll(vrp.getInitialVehicleRoutes());
         Collection<Job> badJobs = insertion.insertJobs(vehicleRoutes, getUnassignedJobs(vrp));
         VehicleRoutingProblemSolution solution = new VehicleRoutingProblemSolution(vehicleRoutes, badJobs, Double.MAX_VALUE);
         double costs = solutionCostsCalculator.getCosts(solution);
         solution.setCost(costs);
+        if (solutionCostsCalculator instanceof ModularSolutionCostCalculator) {
+            ModularSolutionCostCalculator modCalc = (ModularSolutionCostCalculator) solutionCostsCalculator;
+            solution.setDetailedCost(modCalc.calculate(solution));
+        }
         return solution;
     }
 
     private List<Job> getUnassignedJobs(VehicleRoutingProblem vrp) {
-        ArrayList<Job> jobs = new ArrayList<Job>(vrp.getJobs().values());
-//        for (Vehicle v : vrp.getVehicles()) {
-//            if (v.getBreak() != null) jobs.add(v.getBreak());
-//        }
+        ArrayList<Job> jobs = new ArrayList<>(vrp.getJobs().values());
+        //        for (Vehicle v : vrp.getVehicles()) {
+        //            if (v.getBreak() != null) jobs.add(v.getBreak());
+        //        }
         return jobs;
     }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/SearchStrategy.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/SearchStrategy.java
index a68808e41..f22dbd7a2 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/SearchStrategy.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/SearchStrategy.java
@@ -17,18 +17,20 @@
  */
 package com.graphhopper.jsprit.core.algorithm;
 
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import com.graphhopper.jsprit.core.algorithm.acceptor.SolutionAcceptor;
 import com.graphhopper.jsprit.core.algorithm.listener.SearchStrategyModuleListener;
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.ModularSolutionCostCalculator;
 import com.graphhopper.jsprit.core.algorithm.selector.SolutionSelector;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.solution.SolutionCostCalculator;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
 
 
 public class SearchStrategy {
@@ -68,7 +70,7 @@ public String toString() {
 
     private static Logger logger = LoggerFactory.getLogger(SearchStrategy.class);
 
-    private final Collection<SearchStrategyModule> searchStrategyModules = new ArrayList<SearchStrategyModule>();
+    private final Collection<SearchStrategyModule> searchStrategyModules = new ArrayList<>();
 
     private final SolutionSelector solutionSelector;
 
@@ -81,7 +83,9 @@ public String toString() {
     private String name;
 
     public SearchStrategy(String id, SolutionSelector solutionSelector, SolutionAcceptor solutionAcceptor, SolutionCostCalculator solutionCostCalculator) {
-        if (id == null) throw new IllegalStateException("strategy id cannot be null");
+        if (id == null) {
+            throw new IllegalStateException("strategy id cannot be null");
+        }
         this.solutionSelector = solutionSelector;
         this.solutionAcceptor = solutionAcceptor;
         this.solutionCostCalculator = solutionCostCalculator;
@@ -136,26 +140,35 @@ public String toString() {
     @SuppressWarnings("UnusedParameters")
     public DiscoveredSolution run(VehicleRoutingProblem vrp, Collection<VehicleRoutingProblemSolution> solutions) {
         VehicleRoutingProblemSolution solution = solutionSelector.selectSolution(solutions);
-        if (solution == null) throw new IllegalStateException(getErrMsg());
+        if (solution == null) {
+            throw new IllegalStateException(getErrMsg());
+        }
         VehicleRoutingProblemSolution lastSolution = VehicleRoutingProblemSolution.copyOf(solution);
         for (SearchStrategyModule module : searchStrategyModules) {
             lastSolution = module.runAndGetSolution(lastSolution);
         }
         double costs = solutionCostCalculator.getCosts(lastSolution);
         lastSolution.setCost(costs);
+        if (solutionCostCalculator instanceof ModularSolutionCostCalculator) {
+            ModularSolutionCostCalculator modCalc = (ModularSolutionCostCalculator) solutionCostCalculator;
+            lastSolution.setDetailedCost(modCalc.calculate(lastSolution));
+        }
+
         boolean solutionAccepted = solutionAcceptor.acceptSolution(solutions, lastSolution);
         return new DiscoveredSolution(lastSolution, solutionAccepted, getId());
     }
 
     private String getErrMsg() {
         return "solution is null. check solutionSelector to return an appropriate solution. " +
-            "\nfigure out whether you start with an initial solution. either you set it manually by algorithm.addInitialSolution(...)"
-            + " or let the algorithm create an initial solution for you. then add the <construction>...</construction> xml-snippet to your algorithm's config file.";
+                        "\nfigure out whether you start with an initial solution. either you set it manually by algorithm.addInitialSolution(...)"
+                        + " or let the algorithm create an initial solution for you. then add the <construction>...</construction> xml-snippet to your algorithm's config file.";
     }
 
 
     public void addModule(SearchStrategyModule module) {
-        if (module == null) throw new IllegalStateException("module to be added is null.");
+        if (module == null) {
+            throw new IllegalStateException("module to be added is null.");
+        }
         searchStrategyModules.add(module);
         logger.debug("module added [module={}][#modules={}]", module, searchStrategyModules.size());
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
index b5c44875e..57e2ec665 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
@@ -32,6 +32,12 @@
 import com.graphhopper.jsprit.core.algorithm.listener.AlgorithmEndsListener;
 import com.graphhopper.jsprit.core.algorithm.listener.IterationStartsListener;
 import com.graphhopper.jsprit.core.algorithm.module.RuinAndRecreateModule;
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.ActivityCost;
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.FixCostPerVehicle;
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.MissedBreak;
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.ModularSolutionCostCalculator;
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.TransportCost;
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.UnassignedJobs;
 import com.graphhopper.jsprit.core.algorithm.recreate.AbstractInsertionStrategy;
 import com.graphhopper.jsprit.core.algorithm.recreate.ActivityInsertionCostsCalculator;
 import com.graphhopper.jsprit.core.algorithm.recreate.BestInsertion;
@@ -43,6 +49,7 @@
 import com.graphhopper.jsprit.core.algorithm.recreate.RegretInsertionConcurrent;
 import com.graphhopper.jsprit.core.algorithm.recreate.RegretInsertionConcurrentFast;
 import com.graphhopper.jsprit.core.algorithm.recreate.RegretInsertionFast;
+import com.graphhopper.jsprit.core.algorithm.recreate.ScoringFunction;
 import com.graphhopper.jsprit.core.algorithm.ruin.JobNeighborhoods;
 import com.graphhopper.jsprit.core.algorithm.ruin.JobNeighborhoodsFactory;
 import com.graphhopper.jsprit.core.algorithm.ruin.RuinClusters;
@@ -55,12 +62,8 @@
 import com.graphhopper.jsprit.core.algorithm.state.StateManager;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
-import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.solution.SolutionCostCalculator;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.BreakActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.vehicle.FiniteFleetManagerFactory;
 import com.graphhopper.jsprit.core.problem.vehicle.InfiniteFleetManagerFactory;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleFleetManager;
@@ -180,6 +183,8 @@ public static VehicleRoutingAlgorithm createAlgorithm(VehicleRoutingProblem vehi
 
         private SolutionAcceptor solutionAcceptor;
 
+        private ScoringFunction regretScorer = null;
+
         public static Builder newInstance(VehicleRoutingProblem vrp) {
             return new Builder(vrp);
         }
@@ -239,7 +244,7 @@ public Builder setExecutorService(ExecutorService es, int noThreads) {
             return this;
         }
 
-        public Builder setCustomAcceptor(SolutionAcceptor acceptor) {
+        public Builder setCustomAcceptor(SolutionAcceptor acceptor){
             solutionAcceptor = acceptor;
             return this;
         }
@@ -285,6 +290,11 @@ public Builder setActivityInsertionCalculator(ActivityInsertionCostsCalculator a
             return this;
         }
 
+        public Builder setRegretScorer(ScoringFunction scoringFunction) {
+            regretScorer = scoringFunction;
+            return this;
+        }
+
         public VehicleRoutingAlgorithm buildAlgorithm() {
             return new Jsprit(this).create(vrp);
         }
@@ -349,6 +359,8 @@ public int createNumberToBeRemoved() {
 
     private SolutionAcceptor acceptor;
 
+    private ScoringFunction regretScorer;
+
     private Jsprit(Builder builder) {
         stateManager = builder.stateManager;
         constraintManager = builder.constraintManager;
@@ -360,9 +372,17 @@ private Jsprit(Builder builder) {
         random = builder.random;
         activityInsertion = builder.activityInsertionCalculator;
         acceptor = builder.solutionAcceptor;
+        regretScorer = builder.regretScorer;
+    }
+
+    private void ini(VehicleRoutingProblem vrp) {
+        if (regretScorer == null) {
+            regretScorer = getRegretScorer(vrp);
+        }
     }
 
     private VehicleRoutingAlgorithm create(final VehicleRoutingProblem vrp) {
+        ini(vrp);
         VehicleFleetManager fm;
         if (vrp.getFleetSize().equals(VehicleRoutingProblem.FleetSize.INFINITE)) {
             fm = new InfiniteFleetManagerFactory(vrp.getVehicles()).createFleetManager();
@@ -396,7 +416,7 @@ private VehicleRoutingAlgorithm create(final VehicleRoutingProblem vrp) {
         jobNeighborhoods.initialise();
 
         final double maxCosts;
-        if (properties.containsKey(Parameter.MAX_TRANSPORT_COSTS.toString())) {
+        if(properties.containsKey(Parameter.MAX_TRANSPORT_COSTS.toString())){
             maxCosts = Double.parseDouble(getProperty(Parameter.MAX_TRANSPORT_COSTS.toString()));
         } else {
             maxCosts = jobNeighborhoods.getMaxDistance();
@@ -473,11 +493,11 @@ public double makeNoise() {
                         );
 
         AbstractInsertionStrategy regret;
-        final DefaultScorer scorer;
+        final ScoringFunction scorer;
 
         boolean fastRegret = Boolean.parseBoolean(getProperty(Parameter.FAST_REGRET.toString()));
         if (es != null) {
-            if (fastRegret) {
+            if(fastRegret){
                 RegretInsertionConcurrentFast regretInsertion = (RegretInsertionConcurrentFast) new InsertionBuilder(vrp, fm, stateManager, constraintManager)
                                 .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
                                 .setConcurrentMode(es, noThreads)
@@ -486,11 +506,12 @@ public double makeNoise() {
                                 .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
                                 .setActivityInsertionCostCalculator(activityInsertion)
                                 .build();
-                scorer = getRegretScorer(vrp);
+                scorer = regretScorer;
                 regretInsertion.setScoringFunction(scorer);
                 regretInsertion.setDependencyTypes(constraintManager.getDependencyTypes());
                 regret = regretInsertion;
-            } else {
+            }
+            else {
                 RegretInsertionConcurrent regretInsertion = (RegretInsertionConcurrent) new InsertionBuilder(vrp, fm, stateManager, constraintManager)
                                 .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
                                 .setConcurrentMode(es, noThreads)
@@ -498,12 +519,12 @@ public double makeNoise() {
                                 .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
                                 .setActivityInsertionCostCalculator(activityInsertion)
                                 .build();
-                scorer = getRegretScorer(vrp);
+                scorer = regretScorer;
                 regretInsertion.setScoringFunction(scorer);
                 regret = regretInsertion;
             }
         } else {
-            if (fastRegret) {
+            if(fastRegret) {
                 RegretInsertionFast regretInsertion = (RegretInsertionFast) new InsertionBuilder(vrp, fm, stateManager, constraintManager)
                                 .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
                                 .setFastRegret(true)
@@ -511,18 +532,19 @@ public double makeNoise() {
                                 .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
                                 .setActivityInsertionCostCalculator(activityInsertion)
                                 .build();
-                scorer = getRegretScorer(vrp);
+                scorer = regretScorer;
                 regretInsertion.setScoringFunction(scorer);
                 regretInsertion.setDependencyTypes(constraintManager.getDependencyTypes());
                 regret = regretInsertion;
-            } else {
+            }
+            else{
                 RegretInsertion regretInsertion = (RegretInsertion) new InsertionBuilder(vrp, fm, stateManager, constraintManager)
                                 .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
                                 .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
                                 .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
                                 .setActivityInsertionCostCalculator(activityInsertion)
                                 .build();
-                scorer = getRegretScorer(vrp);
+                scorer = regretScorer;
                 regretInsertion.setScoringFunction(scorer);
                 regret = regretInsertion;
             }
@@ -551,7 +573,7 @@ public double makeNoise() {
         best.setRandom(random);
 
         IterationStartsListener schrimpfThreshold = null;
-        if (acceptor == null) {
+        if(acceptor == null) {
             final SchrimpfAcceptance schrimpfAcceptance = new SchrimpfAcceptance(1, toDouble(getProperty(Parameter.THRESHOLD_ALPHA.toString())));
             schrimpfThreshold = new IterationStartsListener() {
                 @Override
@@ -565,7 +587,11 @@ public void informIterationStarts(int i, VehicleRoutingProblem problem, Collecti
             acceptor = schrimpfAcceptance;
         }
 
-        SolutionCostCalculator objectiveFunction = getObjectiveFunction(vrp, maxCosts);
+        SolutionCostCalculator objectiveFunction = getObjectiveFunction();
+        if (objectiveFunction instanceof ModularSolutionCostCalculator) {
+            ((ModularSolutionCostCalculator) objectiveFunction).beforeRun(vrp, maxCosts);
+        }
+
         SearchStrategy radial_regret = new SearchStrategy(Strategy.RADIAL_REGRET.toString(), new SelectBest(), acceptor, objectiveFunction);
         radial_regret.addModule(new RuinAndRecreateModule(Strategy.RADIAL_REGRET.toString(), regret, radial));
 
@@ -613,14 +639,14 @@ public void informIterationStarts(int i, VehicleRoutingProblem problem, Collecti
 
 
         VehicleRoutingAlgorithm vra = prettyBuilder.build();
-        if (schrimpfThreshold != null) {
+        if(schrimpfThreshold != null) {
             vra.addListener(schrimpfThreshold);
         }
         vra.addListener(noiseConfigurator);
         vra.addListener(noise);
         vra.addListener(clusters);
 
-        if (toBoolean(getProperty(Parameter.BREAK_SCHEDULING.toString()))) {
+        if(toBoolean(getProperty(Parameter.BREAK_SCHEDULING.toString()))) {
             vra.addListener(new BreakScheduling(vrp, stateManager, constraintManager));
         }
         handleExecutorShutdown(vra);
@@ -689,51 +715,43 @@ private double toDouble(String string) {
         return Double.valueOf(string);
     }
 
-    private SolutionCostCalculator getObjectiveFunction(final VehicleRoutingProblem vrp, final double maxCosts) {
+    private SolutionCostCalculator getObjectiveFunction() {
         if (objectiveFunction != null) {
             return objectiveFunction;
         }
 
-        SolutionCostCalculator solutionCostCalculator = new SolutionCostCalculator() {
-            @Override
-            public double getCosts(VehicleRoutingProblemSolution solution) {
-                double costs = 0.;
-
-                for (VehicleRoute route : solution.getRoutes()) {
-                    costs += route.getVehicle().getType().getVehicleCostParams().fix;
-                    boolean hasBreak = false;
-                    TourActivity prevAct = route.getStart();
-                    for (TourActivity act : route.getActivities()) {
-                        if (act instanceof BreakActivity) {
-                            hasBreak = true;
-                        }
-                        costs += vrp.getTransportCosts().getTransportCost(prevAct.getLocation(), act.getLocation(), prevAct.getEndTime(), route.getDriver(), route.getVehicle());
-                        costs += vrp.getActivityCosts().getActivityCost(act, act.getArrTime(), route.getDriver(), route.getVehicle());
-                        prevAct = act;
-                    }
-                    costs += vrp.getTransportCosts().getTransportCost(prevAct.getLocation(), route.getEnd().getLocation(), prevAct.getEndTime(), route.getDriver(), route.getVehicle());
-                    if (route.getVehicle().getBreak() != null) {
-                        if (!hasBreak) {
-                            //break defined and required but not assigned penalty
-                            if (route.getEnd().getArrTime() > route.getVehicle().getBreak()
-                                            .getActivity().getSingleTimeWindow()
-                                            .getEnd()) {
-                                costs += 4 * (maxCosts * 2 + route.getVehicle().getBreak()
-                                                .getActivity().getOperationTime()
-                                                * route.getVehicle().getType()
-                                                                .getVehicleCostParams().perServiceTimeUnit);
-                            }
-                        }
-                    }
-                }
-                for (Job j : solution.getUnassignedJobs()) {
-                    costs += maxCosts * 2 * (4 - j.getPriority());
-                }
-                return costs;
-            }
-        };
-        return solutionCostCalculator;
+        ModularSolutionCostCalculator modCalc = createDefaultSolutionCostCalculator();
+        return modCalc;
     }
 
+    /**
+     * Creates a default objective function calculator.
+     *
+     * <p>
+     * This function will contain the following components:
+     * <ul>
+     * <li>{@linkplain FixCostPerVehicle}</li>
+     * <li>{@linkplain MissedBreak}</li>
+     * <li>{@linkplain TransportCost}</li>
+     * <li>{@linkplain ActivityCost}</li>
+     * <li>{@linkplain UnassignedJobs}</li>
+     * </ul>
+     * </p>
+     * <p>
+     * All components will be initialized with their default parameters and will
+     * have the weight of 1.0.
+     * </p>
+     *
+     * @return The default objective function calculator
+     */
+    public static ModularSolutionCostCalculator createDefaultSolutionCostCalculator() {
+        ModularSolutionCostCalculator modCalc = new ModularSolutionCostCalculator();
+        modCalc.addComponent(new FixCostPerVehicle())
+        .addComponent(new MissedBreak())
+        .addComponent(new TransportCost())
+        .addComponent(new ActivityCost())
+        .addComponent(new UnassignedJobs());
+        return modCalc;
+    }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ActivityCost.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ActivityCost.java
new file mode 100644
index 000000000..74850fb90
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ActivityCost.java
@@ -0,0 +1,37 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+
+/**
+ * A cost calculator component for a all activity (operation) costs.
+ * <p>
+ * This cost calculator returns the sum of the activity cost of all the
+ * activities on the route.
+ * </p>
+ * <p>
+ * This is a route level component.
+ * </p>
+ *
+ * @author balage
+ *
+ */
+public class ActivityCost extends RouteLevelSolutionCostComponent {
+
+    public static final String COMPONENT_ID = "Activity";
+
+    public ActivityCost() {
+        super(COMPONENT_ID);
+    }
+
+    @Override
+    protected double calculateRouteLevelCost(VehicleRoutingProblem problem, VehicleRoute route) {
+        double costs = 0;
+        for (TourActivity act : route.getActivities()) {
+            costs += problem.getActivityCosts().getActivityCost(act, act.getArrTime(), route.getDriver(), route.getVehicle());
+        }
+        return costs;
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ComponentValue.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ComponentValue.java
new file mode 100644
index 000000000..5a9423c6c
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ComponentValue.java
@@ -0,0 +1,108 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+/**
+ * Data class to hold the value of a cost component.
+ *
+ * @author balage
+ *
+ * @see {@linkplain RouteLevelComponentValue}
+ * @see {@linkplain SolutionCostComponent}
+ */
+public class ComponentValue {
+    // The key of the component
+    private String key;
+    // The value (unweighted)
+    private double value = 0d;
+    // The weight
+    private double weight = 1d;
+
+    /**
+     * Constrictor with no value set.
+     *
+     * @param key
+     *            The key of the component.
+     */
+    public ComponentValue(String key) {
+        super();
+        this.key = key;
+    }
+
+    /**
+     * Constructor with value set.
+     *
+     * @param key
+     *            The key of the component.
+     * @param value
+     *            The cost value.
+     */
+    public ComponentValue(String key, double value) {
+        this(key);
+        this.value = value;
+    }
+
+    /**
+     * Alters the weight.
+     *
+     * @param weight
+     *            The new weight.
+     * @return The value object itself.
+     */
+    final ComponentValue withWeight(double weight) {
+        this.weight = weight;
+        return this;
+    }
+
+    /**
+     * @return The key of the component.
+     *
+     */
+    public String getKey() {
+        return key;
+    }
+
+    /**
+     * @return The cost value (unweighted).
+     */
+    public double getValue() {
+        return value;
+    }
+
+    /**
+     * @return The weight.
+     */
+    public double getWeight() {
+        return weight;
+    }
+
+    /**
+     * @return The weighted value.
+     */
+    public double getWeightedValue() {
+        return weight * value;
+    }
+
+    /**
+     * Increases the value.
+     *
+     * @param valueToAdd
+     *            The value to add to the current value.
+     */
+    protected void addToValue(double valueToAdd) {
+        value += valueToAdd;
+    }
+
+    @Override
+    public String toString() {
+        return "ComponentValue [key=" + key + ", weight=" + weight + ", value=" + value + "]";
+    }
+
+    /**
+     * Clones the value object.
+     * 
+     * @return A copy of the value object.
+     */
+    public ComponentValue copy() {
+        return new ComponentValue(key, value).withWeight(weight);
+    }
+
+}
\ No newline at end of file
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/FixCostPerVehicle.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/FixCostPerVehicle.java
new file mode 100644
index 000000000..56dcdb8cb
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/FixCostPerVehicle.java
@@ -0,0 +1,34 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+
+/**
+ * A cost calculator component for a per vehicle static cost.
+ * <p>
+ * This cost calculator returns the fixed cost of the vehicle type.
+ * </p>
+ * <p>
+ * This is a route level component.
+ * </p>
+ *
+ * @author balage
+ *
+ */
+public class FixCostPerVehicle extends RouteLevelSolutionCostComponent {
+
+    /**
+     * The unique id of the component.
+     */
+    public static final String COMPONENT_ID = "VehicleFix";
+
+    public FixCostPerVehicle() {
+        super(COMPONENT_ID);
+    }
+
+    @Override
+    protected double calculateRouteLevelCost(VehicleRoutingProblem problem, VehicleRoute route) {
+        return route.getVehicle().getType().getVehicleCostParams().fix;
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/MissedBreak.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/MissedBreak.java
new file mode 100644
index 000000000..ff9147ef8
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/MissedBreak.java
@@ -0,0 +1,47 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.BreakActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+
+/**
+ * A cost calculator component for penaltizing activities in break time.
+ * <p>
+ * This cost calculator returns a value proportional value to the length of the
+ * break.
+ * </p>
+ * <p>
+ * This is a route level component.
+ * </p>
+ *
+ * @author balage
+ *
+ */
+public class MissedBreak extends RouteLevelSolutionCostComponent {
+
+    public static final String COMPONENT_ID = "MissedBreak";
+
+    public MissedBreak() {
+        super(COMPONENT_ID);
+    }
+
+    @Override
+    protected double calculateRouteLevelCost(VehicleRoutingProblem problem, VehicleRoute route) {
+        for (TourActivity act : route.getActivities()) {
+            if (act instanceof BreakActivity) {
+                return 0d;
+            }
+        }
+        if (route.getVehicle().getBreak() != null) {
+            if (route.getEnd().getArrTime() > route.getVehicle().getBreak().getActivity().getSingleTimeWindow()
+                            .getEnd()) {
+                return 4 * (getMaxCosts() * 2 + route.getVehicle().getBreak().getActivity().getOperationTime()
+                                * route.getVehicle().getType().getVehicleCostParams().perServiceTimeUnit);
+
+            }
+        }
+        return 0d;
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java
new file mode 100644
index 000000000..8e7aeae69
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java
@@ -0,0 +1,259 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.stream.Collectors;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.solution.SolutionCostCalculator;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+
+/**
+ * A solution cost calculator implementation with customizable cost components.
+ *
+ * <p>
+ * This calculator uses {@linkplain SolutionCostComponent} implementations to
+ * calculate solution cost (objective function). The user can define and manage
+ * the set of components it has to take into account. The value of each
+ * component is calculated independently and stored. The aggregated cost will be
+ * sum of the wighted cost of each component.
+ * </p>
+ * <p>
+ * The calculator has two internal states. In the first one, the components are
+ * free to alter. However, by calling the
+ * {@linkplain #beforeRun(VehicleRoutingProblem, double)} function, the state
+ * change to initialized, and the components are not allowed to be altered any
+ * more. ({@linkplain IllegalStateException} is thrown.)
+ * </p>
+ *
+ * @author balage
+ *
+ */
+public class ModularSolutionCostCalculator implements SolutionCostCalculator {
+
+    // The problem the calculator works on
+    private VehicleRoutingProblem problem;
+    // The registered components
+    private Map<SolutionCostComponent, Double> components = new LinkedHashMap<>();
+
+    // Internal state flag
+    private boolean initialized = false;
+
+    /**
+     * Constructor. Creates a calculator with no components assigned to.
+     */
+    public ModularSolutionCostCalculator() {
+        super();
+    }
+
+    /**
+     * Registers a new component with a weight of 1.
+     *
+     * @param component
+     *            The component to register.
+     * @return The cost calculator itself.
+     */
+    public ModularSolutionCostCalculator addComponent(SolutionCostComponent component) {
+        return addComponent(component, 1d);
+    }
+
+    /**
+     * Registers several new components in one step, with each component having
+     * the weight of 1.
+     *
+     * @param component
+     *            The first component to register.
+     * @param components
+     *            The additional components.
+     * @return The cost calculator itself.
+     */
+    public ModularSolutionCostCalculator addComponents(SolutionCostComponent component, SolutionCostComponent... components) {
+        addComponent(component);
+        for (SolutionCostComponent c : components) {
+            addComponent(c);
+        }
+        return this;
+    }
+
+    /**
+     * Registers a new component with weight specified.
+     * <p>
+     * Note, that the weight could be zero (the component will be ignored), or
+     * even negative which makes the component a benefical (cost reducing)
+     * factor.
+     * </p>
+     *
+     * @param component
+     *            The component to register.
+     * @param weight
+     *            The weight of the component.
+     *
+     * @return The cost calculator itself.
+     * @throws IllegalArgumentException
+     *             If the component is already registered.
+     * @throws IllegalStateException
+     *             When called after the calculator is initialized.
+     */
+    public ModularSolutionCostCalculator addComponent(SolutionCostComponent component, double weight) {
+        if (isInitialized()) {
+            throw new IllegalStateException("Already initialized.");
+        }
+        if (components.containsKey(component)) {
+            throw new IllegalArgumentException("Cost component '" + component.getId() + "' is duplicated.");
+        }
+        components.put(component, weight);
+        return this;
+    }
+
+    /**
+     * @return The number of registered components.
+     */
+    public int getComponentCount() {
+        return components.size();
+    }
+
+    /**
+     * Returns the weight of a component.
+     *
+     * @param key
+     *            The key to look for.
+     * @return The weight of the component or empty if not registered.
+     */
+    public Optional<Double> getWeight(String key) {
+        return Optional.ofNullable(components.getOrDefault(findComponent(key).orElse(null), null));
+    }
+
+    /**
+     * Returns whether the component with the key is registered.
+     *
+     * @param key
+     *            The key to look for.
+     * @return True if the component is registered.
+     */
+    public boolean containsComponent(String key) {
+        return components.keySet().stream().anyMatch(c -> c.getId().equals(key));
+    }
+
+    /**
+     * Returns the component with the key.
+     *
+     * @param key
+     *            The key to look for.
+     * @return The registered component if registered or empty.
+     */
+    public Optional<SolutionCostComponent> findComponent(String key) {
+        return components.keySet().stream().filter(c -> c.getId().equals(key)).findAny();
+    }
+
+    /**
+     * Changes the weigth value of an already registered component. Does nothing
+     * if the component is not registered.
+     *
+     * @param key
+     *            The key to look for.
+     * @param newWeight
+     *            The new weight.
+     * @throws IllegalStateException
+     *             When called after the calculator is initialized.
+     */
+    public void changeComponentWeight(String key, double newWeight) {
+        if (isInitialized()) {
+            throw new IllegalStateException("Already initialized.");
+        }
+        findComponent(key).ifPresent(c -> components.put(c, newWeight));
+    }
+
+    /**
+     * Removes (unregisters) a component and returns it.
+     * <p>
+     * This makes it possible to start from a predefined calculator (such as the
+     * default one) and reconfiguring one of its components.
+     * </p>
+     *
+     * @param key
+     *            The key of the component to remove.
+     * @return The removed component or empty if the component was not
+     *         registered.
+     * @throws IllegalStateException
+     *             When called after the calculator is initialized.
+     */
+    public Optional<SolutionCostComponent> removeComponent(String key) {
+        if (isInitialized()) {
+            throw new IllegalStateException("Already initialized.");
+        }
+        Optional<SolutionCostComponent> optC = findComponent(key);
+        optC.ifPresent(c -> components.remove(c));
+        return optC;
+    }
+
+    /**
+     * Calculates the cost values of each component.
+     *
+     * @param solution
+     *            The solution to calculate the costs on.
+     * @return A list of calculated component cost values.
+     */
+    public List<ComponentValue> calculate(VehicleRoutingProblemSolution solution) {
+        if (!isInitialized()) {
+            throw new IllegalStateException("Not initialized.");
+        }
+        beforeSolution();
+        return components.entrySet().stream()
+                        .map(en -> en.getKey().calculateCost(problem, solution).withWeight(en.getValue()))
+                        .collect(Collectors.toList());
+    }
+
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * Calls the {@linkplain #calculate(VehicleRoutingProblemSolution)} function
+     * and aggregates the weighted sum of the components costs.
+     * </p>
+     */
+    @Override
+    public double getCosts(VehicleRoutingProblemSolution solution) {
+        if (!isInitialized()) {
+            throw new IllegalStateException("Not initialized.");
+        }
+        return calculate(solution).stream()
+                        .mapToDouble(cv -> cv.getWeightedValue())
+                        .sum();
+    }
+
+    /**
+     * Called by the optimizer to initialize the calculator.
+     * <p>
+     * This function changes the state of the calculator to initialized and no
+     * further component management is possible afterward.
+     * </p>
+     *
+     * @param problem
+     *            The problem the calculator works on.
+     * @param maxCosts
+     *            The maximum cost constant to use in cost components.
+     */
+    public void beforeRun(VehicleRoutingProblem problem, double maxCosts) {
+        this.problem = problem;
+        components.keySet().forEach(c -> c.beforeRun(problem, maxCosts));
+        initialized = true;
+    }
+
+    /**
+     * @return Whether the calculator is initialized.
+     */
+    public boolean isInitialized() {
+        return initialized;
+    }
+
+    /**
+     * Called by the calculator to make any pre solution initialization.
+     */
+    private void beforeSolution() {
+        components.keySet().forEach(c -> c.beforeSolution(problem));
+    }
+
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelComponentValue.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelComponentValue.java
new file mode 100644
index 000000000..546e92c76
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelComponentValue.java
@@ -0,0 +1,73 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+
+/**
+ * A cost value implementation which holds an additional per route cost
+ * information.
+ *
+ * @author balage
+ *
+ */
+public class RouteLevelComponentValue extends ComponentValue {
+
+    // The per route cost value
+    private Map<Integer, Double> routeLevelValue = new HashMap<>();
+
+    /**
+     * Constrictor with no value set.
+     *
+     * @param key
+     *            The key of the component.
+     */
+    public RouteLevelComponentValue(String key) {
+        super(key);
+    }
+
+    /**
+     * Sets the route value.
+     *
+     * @param routeId
+     *            The route id.
+     * @param value
+     *            The value of the route.
+     */
+    public void setRouteValue(int routeId, double value) {
+        getRouteValue(routeId).ifPresent(v -> addToValue(-v));
+        routeLevelValue.put(routeId, value);
+        addToValue(value);
+    }
+
+    /**
+     * Returns the cost value of the route.
+     * 
+     * @param routeId
+     *            The route id.
+     * @return The cost value of the route or empty if no value available for
+     *         the route.
+     */
+    public Optional<Double> getRouteValue(int routeId) {
+        if (routeLevelValue.containsKey(routeId)) {
+            return Optional.ofNullable(routeLevelValue.get(routeId));
+        } else {
+            return Optional.empty();
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "RouteLevelComponentValue [key=" + getKey() + ", weight="
+                        + getWeight() + ", value=" + getValue() + "routeLevel=" + routeLevelValue + "]";
+    }
+
+    @Override
+    public RouteLevelComponentValue copy() {
+        RouteLevelComponentValue copy = new RouteLevelComponentValue(getKey());
+        copy.withWeight(getWeight());
+        copy.routeLevelValue = new HashMap<>(routeLevelValue);
+        return copy;
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelSolutionCostComponent.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelSolutionCostComponent.java
new file mode 100644
index 000000000..3504968e1
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelSolutionCostComponent.java
@@ -0,0 +1,55 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+
+/**
+ * An implementation of solution cost component which calculates and keeps track
+ * of cost per route level.
+ *
+ * @author balage
+ *
+ */
+public abstract class RouteLevelSolutionCostComponent extends SolutionCostComponent {
+
+    /**
+     * Constructor.
+     *
+     * @param id
+     *            The unique id of the component.
+     */
+    public RouteLevelSolutionCostComponent(String id) {
+        super(id);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * This implementation calls the
+     * {@linkplain #calculateRouteLevelCost(VehicleRoutingProblem, VehicleRoute)}
+     * for each route in the solution and stores the calculated cost values,
+     * then returns the sum of them.
+     * </p>
+     */
+    @Override
+    public RouteLevelComponentValue calculateCost(VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution) {
+        RouteLevelComponentValue cv = new RouteLevelComponentValue(getId());
+        for (VehicleRoute route : solution.getRoutes()) {
+            double val = calculateRouteLevelCost(problem, route);
+            cv.setRouteValue(route.getId(), val);
+        }
+        return cv;
+    }
+
+    /**
+     * Calculates the cost of a route.
+     *
+     * @param problem
+     *            The problem the calculation will run on.
+     * @param route
+     *            The route to calculate the cost of.
+     * @return The cost value of the route.
+     */
+    protected abstract double calculateRouteLevelCost(VehicleRoutingProblem problem, VehicleRoute route);
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/SolutionCostComponent.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/SolutionCostComponent.java
new file mode 100644
index 000000000..c3a98cd8d
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/SolutionCostComponent.java
@@ -0,0 +1,119 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+
+/**
+ * Base class for solution cost calculator components.
+ *
+ * <p>
+ * Two components regarded as equal if their id is equal.
+ * </p>
+ *
+ * @author balage
+ * @see {@linkplain RouteLevelSolutionCostComponent}
+ */
+public abstract class SolutionCostComponent {
+
+    // The unique id of the component
+    private String id;
+
+    // The maximum costs variable
+    private double maxCosts;
+
+    /**
+     * Constructor.
+     *
+     * @param id
+     *            The unique id of the component.
+     */
+    public SolutionCostComponent(String id) {
+        super();
+        this.id = id;
+    }
+
+    /**
+     * Initialization of the component.
+     * <p>
+     * This implementation stores the maximum costs, therefore all overridden
+     * implementations should call the super implementation!
+     * </p>
+     *
+     * @param problem
+     *            The problem the calculation will run on.
+     * @param maxCosts
+     *            The maximum cost value.
+     */
+    public void beforeRun(VehicleRoutingProblem problem, double maxCosts) {
+        this.maxCosts = maxCosts;
+    }
+
+    /**
+     * Initilization called before each calculation on a solution.
+     * <p>
+     * This implementation does nothing.
+     * </p>
+     *
+     * @param problem
+     *            The problem the calculation will run on.
+     */
+    public void beforeSolution(VehicleRoutingProblem problem) {
+    }
+
+    /**
+     * Calculates the component cost of the solution.
+     *
+     * @param problem
+     *            The problem the calculation will run on.
+     * @param solution
+     *            The solution to calculate on.
+     * @return The calculated value.
+     */
+    public abstract ComponentValue calculateCost(VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution);
+
+
+    /**
+     * @return The unique id of the component.
+     */
+    public String getId() {
+        return id;
+    }
+
+    /**
+     * @return The maximum travel cost of the problem.
+     */
+    public double getMaxCosts() {
+        return maxCosts;
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((id == null) ? 0 : id.hashCode());
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        SolutionCostComponent other = (SolutionCostComponent) obj;
+        if (id == null) {
+            if (other.getId() != null) {
+                return false;
+            }
+        } else if (!getId().equals(other.getId())) {
+            return false;
+        }
+        return true;
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/TransportCost.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/TransportCost.java
new file mode 100644
index 000000000..f19d285ec
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/TransportCost.java
@@ -0,0 +1,42 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+
+/**
+ * A cost calculator component for a all transport costs.
+ * <p>
+ * This cost calculator returns the sum of the transport cost of all the
+ * activities on the route.
+ * </p>
+ * <p>
+ * This is a route level component.
+ * </p>
+ *
+ * @author balage
+ *
+ */
+public class TransportCost extends RouteLevelSolutionCostComponent {
+
+    public static final String COMPONENT_ID = "Transport";
+
+    public TransportCost() {
+        super(COMPONENT_ID);
+    }
+
+    @Override
+    protected double calculateRouteLevelCost(VehicleRoutingProblem problem, VehicleRoute route) {
+        double costs = 0;
+        TourActivity prevAct = route.getStart();
+        for (TourActivity act : route.getActivities()) {
+            costs += problem.getTransportCosts().getTransportCost(prevAct.getLocation(), act.getLocation(), prevAct.getEndTime(),
+                            route.getDriver(), route.getVehicle());
+            prevAct = act;
+        }
+        costs += problem.getTransportCosts().getTransportCost(prevAct.getLocation(), route.getEnd().getLocation(),
+                        prevAct.getEndTime(), route.getDriver(), route.getVehicle());
+        return costs;
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/UnassignedJobs.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/UnassignedJobs.java
new file mode 100644
index 000000000..0e18153e8
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/UnassignedJobs.java
@@ -0,0 +1,32 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.job.Job;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+
+/**
+ * A cost calculator component for penaltizing unassingned jobs.
+ *
+ * @author balage
+ *
+ */
+public class UnassignedJobs extends SolutionCostComponent {
+
+    public static final String COMPONENT_ID = "Unassigned";
+
+    public UnassignedJobs() {
+        super(COMPONENT_ID);
+    }
+
+
+    @Override
+    public ComponentValue calculateCost(VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution) {
+        double costs = 0d;
+        for (Job j : solution.getUnassignedJobs()) {
+            costs += getMaxCosts() * 2 * (4 - j.getPriority());
+        }
+        return new ComponentValue(COMPONENT_ID, costs);
+    }
+
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
index fb7f09eae..d56074627 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
@@ -88,7 +88,7 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
         double distancePrevAct2NewAct = distanceCalculator.getDistance(prevAct.getLocation(), newAct.getLocation(), iFacts.getNewDepTime(), iFacts.getNewVehicle());
         double distanceNewAct2nextAct = distanceCalculator.getDistance(newAct.getLocation(), nextAct.getLocation(), iFacts.getNewDepTime(), iFacts.getNewVehicle());
         double distancePrevAct2NextAct = distanceCalculator.getDistance(prevAct.getLocation(), nextAct.getLocation(), prevActDepTime, iFacts.getNewVehicle());
-        if(routeIsEmpty) {
+        if(prevAct instanceof Start && nextAct instanceof End) {
             distancePrevAct2NextAct = 0;
         }
         if(nextAct instanceof End && !iFacts.getNewVehicle().isReturnToDepot()){
@@ -100,6 +100,7 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
             return ConstraintsStatus.NOT_FULFILLED;
         }
 
+
         double additionalDistanceOfPickup = 0;
         if (newAct instanceof DeliveryActivity && AbstractActivity.isShipment(newAct)) {
             int iIndexOfPickup = iFacts.getRelatedActivityContext().getInsertionIndex();
@@ -110,12 +111,23 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
             } else {
                 actBeforePickup = new Start(iFacts.getNewVehicle().getStartLocation(),0,Double.MAX_VALUE);
             }
-            TourActivity actAfterPickup = iFacts.getRoute().getActivities().get(iIndexOfPickup);
-            //ToDo account here fore End and returnToDepot
+            TourActivity actAfterPickup;
+            if (iIndexOfPickup < iFacts.getRoute().getActivities().size()) {
+                actAfterPickup = iFacts.getRoute().getActivities().get(iIndexOfPickup);
+            } else {
+                actAfterPickup = nextAct;
+            }
             double distanceActBeforePickup2Pickup = distanceCalculator.getDistance(actBeforePickup.getLocation(), pickup.getLocation(), actBeforePickup.getEndTime(), iFacts.getNewVehicle());
             double distancePickup2ActAfterPickup = distanceCalculator.getDistance(pickup.getLocation(), actAfterPickup.getLocation(), iFacts.getRelatedActivityContext().getEndTime(), iFacts.getNewVehicle());
             double distanceBeforePickup2AfterPickup = distanceCalculator.getDistance(actBeforePickup.getLocation(), actAfterPickup.getLocation(), actBeforePickup.getEndTime(), iFacts.getNewVehicle());
-            additionalDistanceOfPickup = distanceActBeforePickup2Pickup  + distancePickup2ActAfterPickup - distanceBeforePickup2AfterPickup;
+            if (routeIsEmpty) {
+                distanceBeforePickup2AfterPickup = 0;
+            }
+            if (actAfterPickup instanceof End && !iFacts.getNewVehicle().isReturnToDepot()) {
+                distancePickup2ActAfterPickup = 0;
+                distanceBeforePickup2AfterPickup = 0;
+            }
+            additionalDistanceOfPickup = distanceActBeforePickup2Pickup + distancePickup2ActAfterPickup - distanceBeforePickup2AfterPickup;
         }
 
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolution.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolution.java
index ba374d1d6..92d9d4026 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolution.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolution.java
@@ -17,11 +17,15 @@
  */
 package com.graphhopper.jsprit.core.problem.solution;
 
-import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.ComponentValue;
+import com.graphhopper.jsprit.core.problem.job.Job;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 
 
 /**
@@ -41,19 +45,26 @@ public static VehicleRoutingProblemSolution copyOf(VehicleRoutingProblemSolution
         return new VehicleRoutingProblemSolution(solution2copy);
     }
 
-    private final Collection<VehicleRoute> routes;
+    private List<VehicleRoute> routes;
 
-    private Collection<Job> unassignedJobs = new ArrayList<Job>();
+    private List<ComponentValue> detailedCost;
+
+    private Collection<Job> unassignedJobs = new ArrayList<>();
 
     private double cost;
 
     private VehicleRoutingProblemSolution(VehicleRoutingProblemSolution solution) {
-        routes = new ArrayList<VehicleRoute>();
+        List<VehicleRoute> tmpRoutes = new ArrayList<>();
         for (VehicleRoute r : solution.getRoutes()) {
             VehicleRoute route = VehicleRoute.copyOf(r);
-            routes.add(route);
+            tmpRoutes.add(route);
+        }
+        setRoutes(tmpRoutes);
+        setCost(solution.getCost());
+        if (solution.getDetailedCost() != null) {
+            detailedCost = solution.getDetailedCost().stream().map(cv -> cv.copy()).collect(Collectors.toList());
         }
-        this.cost = solution.getCost();
+
         unassignedJobs.addAll(solution.getUnassignedJobs());
     }
 
@@ -65,8 +76,8 @@ private VehicleRoutingProblemSolution(VehicleRoutingProblemSolution solution) {
      */
     public VehicleRoutingProblemSolution(Collection<VehicleRoute> routes, double cost) {
         super();
-        this.routes = routes;
-        this.cost = cost;
+        setRoutes(routes);
+        setCost(cost);
     }
 
     /**
@@ -77,10 +88,19 @@ public VehicleRoutingProblemSolution(Collection<VehicleRoute> routes, double cos
      * @param cost           total costs of solution
      */
     public VehicleRoutingProblemSolution(Collection<VehicleRoute> routes, Collection<Job> unassignedJobs, double cost) {
-        super();
-        this.routes = routes;
+        this(routes, cost);
         this.unassignedJobs = unassignedJobs;
-        this.cost = cost;
+    }
+
+
+    private void setRoutes(Collection<VehicleRoute> routes) {
+        this.routes = routes instanceof List ? (List<VehicleRoute>) routes : new ArrayList<>(routes);
+        Collections.sort(this.routes, new com.graphhopper.jsprit.core.util.VehicleIndexComparator());
+
+        int counter = 1;
+        for (VehicleRoute r : routes) {
+            r.setId(counter++);
+        }
     }
 
     /**
@@ -88,7 +108,7 @@ public VehicleRoutingProblemSolution(Collection<VehicleRoute> routes, Collection
      *
      * @return collection of vehicle-routes
      */
-    public Collection<VehicleRoute> getRoutes() {
+    public List<VehicleRoute> getRoutes() {
         return routes;
     }
 
@@ -108,6 +128,15 @@ public double getCost() {
      */
     public void setCost(double cost) {
         this.cost = cost;
+        detailedCost = null;
+    }
+
+    public void setDetailedCost(List<ComponentValue> detailedCost) {
+        this.detailedCost = detailedCost;
+    }
+
+    public List<ComponentValue> getDetailedCost() {
+        return detailedCost;
     }
 
     /**
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRoute.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRoute.java
index 0b221af94..70151c967 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRoute.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRoute.java
@@ -43,7 +43,8 @@
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
 
 /**
- * Contains the tour, i.e. a number of activities, a vehicle servicing the tour and a driver.
+ * Contains the tour, i.e. a number of activities, a vehicle servicing the tour
+ * and a driver.
  *
  * @author stefan
  */
@@ -52,9 +53,11 @@
     /**
      * Returns a deep copy of this vehicleRoute.
      *
-     * @param route route to copy
+     * @param route
+     *            route to copy
      * @return copied route
-     * @throws IllegalArgumentException if route is null
+     * @throws IllegalArgumentException
+     *             if route is null
      */
     public static VehicleRoute copyOf(VehicleRoute route) {
         if (route == null) {
@@ -66,7 +69,9 @@ public static VehicleRoute copyOf(VehicleRoute route) {
     /**
      * Returns an empty route.
      * <p>
-     * <p>An empty route has an empty list of tour-activities, no driver (DriverImpl.noDriver()) and no vehicle (VehicleImpl.createNoVehicle()).
+     * <p>
+     * An empty route has an empty list of tour-activities, no driver
+     * (DriverImpl.noDriver()) and no vehicle (VehicleImpl.createNoVehicle()).
      *
      * @return empty route
      */
@@ -81,25 +86,34 @@ public static VehicleRoute emptyRoute() {
      */
     public static class Builder {
 
-        private Map<Shipment, TourActivity> openActivities = new HashMap<Shipment, TourActivity>();
+        private Map<Shipment, TourActivity> openActivities = new HashMap<>();
 
         /**
          * Returns new instance of this builder.
          * <p>
-         * <p><b>Construction-settings of vehicleRoute:</b>
-         * <p>startLocation == vehicle.getStartLocationId()
-         * <p>endLocation == vehicle.getEndLocationId()
-         * <p>departureTime == vehicle.getEarliestDepartureTime()
-         * <p>latestStart == Double.MAX_VALUE
-         * <p>earliestEnd == 0.0
+         * <p>
+         * <b>Construction-settings of vehicleRoute:</b>
+         * <p>
+         * startLocation == vehicle.getStartLocationId()
+         * <p>
+         * endLocation == vehicle.getEndLocationId()
+         * <p>
+         * departureTime == vehicle.getEarliestDepartureTime()
+         * <p>
+         * latestStart == Double.MAX_VALUE
+         * <p>
+         * earliestEnd == 0.0
          *
-         * @param vehicle employed vehicle
-         * @param driver  employed driver
+         * @param vehicle
+         *            employed vehicle
+         * @param driver
+         *            employed driver
          * @return this builder
          */
         public static Builder newInstance(Vehicle vehicle, Driver driver) {
             if (vehicle == null || driver == null) {
-                throw new IllegalArgumentException("null arguments not accepted. ini emptyRoute with VehicleImpl.createNoVehicle() and DriverImpl.noDriver()");
+                throw new IllegalArgumentException(
+                                "null arguments not accepted. ini emptyRoute with VehicleImpl.createNoVehicle() and DriverImpl.noDriver()");
             }
             return new Builder(vehicle, driver);
         }
@@ -107,19 +121,27 @@ public static Builder newInstance(Vehicle vehicle, Driver driver) {
         /**
          * Returns new instance of this builder.
          * <p>
-         * <p><b>Construction-settings of vehicleRoute:</b>
-         * <p>startLocation == vehicle.getStartLocationId()
-         * <p>endLocation == vehicle.getEndLocationId()
-         * <p>departureTime == vehicle.getEarliestDepartureTime()
-         * <p>latestStart == Double.MAX_VALUE
-         * <p>earliestEnd == 0.0
+         * <p>
+         * <b>Construction-settings of vehicleRoute:</b>
+         * <p>
+         * startLocation == vehicle.getStartLocationId()
+         * <p>
+         * endLocation == vehicle.getEndLocationId()
+         * <p>
+         * departureTime == vehicle.getEarliestDepartureTime()
+         * <p>
+         * latestStart == Double.MAX_VALUE
+         * <p>
+         * earliestEnd == 0.0
          *
-         * @param vehicle employed vehicle
+         * @param vehicle
+         *            employed vehicle
          * @return this builder
          */
         public static Builder newInstance(Vehicle vehicle) {
             if (vehicle == null) {
-                throw new IllegalArgumentException("null arguments not accepted. ini emptyRoute with VehicleImpl.createNoVehicle() and DriverImpl.noDriver()");
+                throw new IllegalArgumentException(
+                                "null arguments not accepted. ini emptyRoute with VehicleImpl.createNoVehicle() and DriverImpl.noDriver()");
             }
             return new Builder(vehicle, DriverImpl.noDriver());
         }
@@ -140,7 +162,7 @@ public static Builder newInstance(Vehicle vehicle) {
         // private TourShipmentActivityFactory shipmentActivityFactory = new
         // DefaultShipmentActivityFactory();
 
-        private Set<Shipment> openShipments = new HashSet<Shipment>();
+        private Set<Shipment> openShipments = new HashSet<>();
 
         private JobActivityFactory jobActivityFactory = new SimpleJobActivityFactory();
 
@@ -159,13 +181,18 @@ private Builder(Vehicle vehicle, Driver driver) {
         }
 
         /**
-         * Sets the departure-time of the route, i.e. which is the time the vehicle departs from start-location.
+         * Sets the departure-time of the route, i.e. which is the time the
+         * vehicle departs from start-location.
+         * <p>
          * <p>
-         * <p><b>Note</b> that departureTime cannot be lower than earliestDepartureTime of vehicle.
+         * <b>Note</b> that departureTime cannot be lower than
+         * earliestDepartureTime of vehicle.
          *
-         * @param departureTime departure time of vehicle being employed for this route
+         * @param departureTime
+         *            departure time of vehicle being employed for this route
          * @return builder
-         * @throws IllegalArgumentException if departureTime < vehicle.getEarliestDeparture()
+         * @throws IllegalArgumentException
+         *             if departureTime < vehicle.getEarliestDeparture()
          */
         public Builder setDepartureTime(double departureTime) {
             if (departureTime < start.getEndTime()) {
@@ -220,7 +247,6 @@ private Builder addSingleActivityJob(AbstractSingleActivityJob<?> service) {
             return addSingleActivityJob(service, service.getActivity().getSingleTimeWindow());
         }
 
-
         private Builder addSingleActivityJob(AbstractSingleActivityJob<?> service,
                         TimeWindow timeWindow) {
             if (service == null) {
@@ -234,7 +260,6 @@ private Builder addSingleActivityJob(AbstractSingleActivityJob<?> service,
             return this;
         }
 
-
         public Builder addBreak(Break currentbreak) {
             if (currentbreak == null) {
                 throw new IllegalArgumentException("break must not be null");
@@ -364,17 +389,19 @@ public Builder addDelivery(Shipment shipment, TimeWindow deliveryTimeWindow) {
                 tourActivities.addActivity(act);
                 openShipments.remove(shipment);
             } else {
-                throw new IllegalArgumentException("cannot deliver shipment. shipment " + shipment + " needs to be picked up first.");
+                throw new IllegalArgumentException(
+                                "cannot deliver shipment. shipment " + shipment + " needs to be picked up first.");
             }
             return this;
         }
 
-
         /**
          * Builds the route.
          *
          * @return {@link VehicleRoute}
-         * @throws IllegalArgumentException if there are still shipments that have been picked up though but not delivery.
+         * @throws IllegalArgumentException
+         *             if there are still shipments that have been picked up
+         *             though but not delivery.
          */
         public VehicleRoute build() {
             if (!openShipments.isEmpty()) {
@@ -400,10 +427,13 @@ public VehicleRoute build() {
 
     private End end;
 
+    private int id = 0;
+
     /**
      * Copy constructor copying a route.
      *
-     * @param route to copy
+     * @param route
+     *            to copy
      */
     private VehicleRoute(VehicleRoute route) {
         start = Start.copyOf(route.getStart());
@@ -416,7 +446,8 @@ private VehicleRoute(VehicleRoute route) {
     /**
      * Constructs route.
      *
-     * @param builder used to build route
+     * @param builder
+     *            used to build route
      */
     private VehicleRoute(Builder builder) {
         tourActivities = builder.tourActivities;
@@ -427,7 +458,8 @@ private VehicleRoute(Builder builder) {
     }
 
     /**
-     * Returns an unmodifiable list of activities on this route (without start/end).
+     * Returns an unmodifiable list of activities on this route (without
+     * start/end).
      *
      * @return list of tourActivities
      */
@@ -463,19 +495,37 @@ public Driver getDriver() {
     }
 
     /**
-     * Sets the vehicle and its departureTime from <code>vehicle.getStartLocationId()</code>.
+     * Sets the vehicle and its departureTime from
+     * <code>vehicle.getStartLocationId()</code>.
+     * <p>
      * <p>
-     * <p>This implies the following:<br>
+     * This implies the following:<br>
      * if start and end are null, new start and end activities are created.<br>
-     * <p>startActivity is initialized with the start-location of the specified vehicle (<code>vehicle.getStartLocationId()</code>). the time-window of this activity is initialized
-     * such that [<code>startActivity.getTheoreticalEarliestOperationStartTime()</code> = <code>vehicle.getEarliestDeparture()</code>][<code>startActivity.getTheoreticalLatestOperationStartTime()</code> = <code>vehicle.getLatestArrival()</code>]
-     * <p>endActivity is initialized with the end-location of the specified vehicle (<code>vehicle.getEndLocationId()</code>). The time-window of the
-     * endActivity is initialized such that [<code>endActivity.getTheoreticalEarliestOperationStartTime()</code> = <code>vehicle.getEarliestDeparture()</code>][<code>endActivity.getTheoreticalLatestOperationStartTime()</code> = <code>vehicle.getLatestArrival()</code>]
-     * <p>startActivity.endTime (<code>startActivity.getEndTime()</code>) is set to max{<code>vehicle.getEarliestDeparture()</code>, <code>vehicleDepTime</code>}.
-     * thus, <code>vehicle.getEarliestDeparture()</code> is a physical constraint that has to be met.
+     * <p>
+     * startActivity is initialized with the start-location of the specified
+     * vehicle (<code>vehicle.getStartLocationId()</code>). the time-window of
+     * this activity is initialized such that
+     * [<code>startActivity.getTheoreticalEarliestOperationStartTime()</code> =
+     * <code>vehicle.getEarliestDeparture()</code>][<code>startActivity.getTheoreticalLatestOperationStartTime()</code>
+     * = <code>vehicle.getLatestArrival()</code>]
+     * <p>
+     * endActivity is initialized with the end-location of the specified vehicle
+     * (<code>vehicle.getEndLocationId()</code>). The time-window of the
+     * endActivity is initialized such that
+     * [<code>endActivity.getTheoreticalEarliestOperationStartTime()</code> =
+     * <code>vehicle.getEarliestDeparture()</code>][<code>endActivity.getTheoreticalLatestOperationStartTime()</code>
+     * = <code>vehicle.getLatestArrival()</code>]
+     * <p>
+     * startActivity.endTime (<code>startActivity.getEndTime()</code>) is set to
+     * max{<code>vehicle.getEarliestDeparture()</code>,
+     * <code>vehicleDepTime</code>}. thus,
+     * <code>vehicle.getEarliestDeparture()</code> is a physical constraint that
+     * has to be met.
      *
-     * @param vehicle        to be employed
-     * @param vehicleDepTime of employed vehicle
+     * @param vehicle
+     *            to be employed
+     * @param vehicleDepTime
+     *            of employed vehicle
      */
     public void setVehicleAndDepartureTime(Vehicle vehicle, double vehicleDepTime) {
         this.vehicle = vehicle;
@@ -503,17 +553,20 @@ private void setStartAndEnd(Vehicle vehicle, double vehicleDepTime) {
      * Returns the departureTime of this vehicle in this route.
      *
      * @return departureTime
-     * @throws IllegalArgumentException if start is null
+     * @throws IllegalArgumentException
+     *             if start is null
      */
     public double getDepartureTime() {
         if (start == null) {
-            throw new IllegalArgumentException("cannot get departureTime without having a vehicle on this route. use setVehicle(vehicle,departureTime) instead.");
+            throw new IllegalArgumentException(
+                            "cannot get departureTime without having a vehicle on this route. use setVehicle(vehicle,departureTime) instead.");
         }
         return start.getEndTime();
     }
 
     /**
-     * Returns tour if tour-activity-sequence is empty, i.e. to activity on the tour yet.
+     * Returns tour if tour-activity-sequence is empty, i.e. to activity on the
+     * tour yet.
      *
      * @return true if route is empty
      */
@@ -541,7 +594,17 @@ public End getEnd() {
 
     @Override
     public String toString() {
-        return "[start=" + start + "][end=" + end + "][departureTime=" + start.getEndTime() + "][vehicle=" + vehicle + "][driver=" + driver + "][nuOfActs=" + tourActivities.getActivities().size() + "]";
+        return "[id=" + id + "][start=" + start + "][end=" + end + "][departureTime=" + start.getEndTime() + "][vehicle=" + vehicle
+                        + "][driver="
+                        + driver + "][nuOfActs=" + tourActivities.getActivities().size() + "]";
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public int getId() {
+        return id;
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
index 02ca45b59..d76ee5006 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
@@ -19,20 +19,26 @@
 
 import java.io.PrintWriter;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.function.Function;
 import java.util.stream.Collectors;
 
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.ComponentValue;
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.RouteLevelComponentValue;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem.FleetSize;
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.reporting.ConfigurableTablePrinter.CsvConfig;
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.Builder;
+import com.graphhopper.jsprit.core.reporting.DynamicTablePrinter.TableRow;
+import com.graphhopper.jsprit.core.reporting.columndefinition.ColumnAlignment;
 import com.graphhopper.jsprit.core.reporting.columndefinition.ColumnDefinition;
+import com.graphhopper.jsprit.core.reporting.columndefinition.DoubleColumnType;
 import com.graphhopper.jsprit.core.reporting.columndefinition.SolutionPrintColumnLists;
 import com.graphhopper.jsprit.core.reporting.columndefinition.SolutionPrintColumnLists.PredefinedList;
 import com.graphhopper.jsprit.core.reporting.columndefinition.StringColumnType;
@@ -188,6 +194,8 @@ private static void printVerbose(PrintWriter out, VehicleRoutingProblem problem,
 
     // New print functions (TODO old ones should be migrated into these)
 
+    // ----------------------------------------------------------
+
     /**
      * Prints costs and #vehicles to the given writer
      *
@@ -215,6 +223,8 @@ public static void printSummary(PrintWriter out, VehicleRoutingProblem problem,
 
         DynamicTablePrinter problemTablePrinter = new DynamicTablePrinter(problemTableDef);
         problemTablePrinter.addRow().add("fleetsize").add(problem.getFleetSize());
+        problemTablePrinter.addRow().add("maxNoVehicles")
+        .add(problem.getFleetSize() == FleetSize.FINITE ? problem.getVehicles().size() : "unlimited");
         problemTablePrinter.addSeparator();
         problemTablePrinter.addRow().add("noJobs").add(problem.getJobs().values().size());
         for (Entry<Class<? extends Job>, Long> jc : getNuOfJobs(problem).entrySet()) {
@@ -241,6 +251,93 @@ public static void printSummary(PrintWriter out, VehicleRoutingProblem problem,
 
     // ----------------------------------------------------------
 
+    public static void printCostDetails(VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution) {
+        printCostDetails(SYSTEM_OUT_AS_PRINT_WRITER, problem, solution);
+        SYSTEM_OUT_AS_PRINT_WRITER.flush();
+    }
+
+    public static void printCostDetails(PrintWriter out, VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution) {
+        if (solution.getDetailedCost() == null) {
+            out.println("No detailed cost info available.");
+            return;
+        }
+
+        DynamicTableDefinition compomentTableDef = new DynamicTableDefinition.Builder()
+                        .withHeading("Cost components")
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "component id")
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new DoubleColumnType(), "value")
+                                        .withAlignment(ColumnAlignment.RIGHT).build())
+                        .addColumn(new ColumnDefinition.Builder(new DoubleColumnType(), "weight")
+                                        .withAlignment(ColumnAlignment.RIGHT).build())
+                        .addColumn(new ColumnDefinition.Builder(new DoubleColumnType(), "weighted value")
+                                        .withAlignment(ColumnAlignment.RIGHT).build())
+                        .build();
+
+        DynamicTablePrinter componentTablePrinter = new DynamicTablePrinter(compomentTableDef);
+        for (ComponentValue cv : solution.getDetailedCost()) {
+            componentTablePrinter.addRow().add(cv.getKey()).add(cv.getValue()).add(cv.getWeight()).add(cv.getWeightedValue());
+        }
+        out.println(componentTablePrinter.print());
+
+        Builder routeLevelTableDefBuilder = new DynamicTableDefinition.Builder()
+                        .withHeading("Route level costs (weighted)")
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "Route")
+                                        .build());
+        DynamicTableDefinition routeLevelTableDef = routeLevelTableDefBuilder.build();
+        for (ComponentValue cv : solution.getDetailedCost()) {
+            if (cv instanceof RouteLevelComponentValue) {
+                routeLevelTableDefBuilder.addColumn(new ColumnDefinition.Builder(new DoubleColumnType(), cv.getKey())
+                                .withAlignment(ColumnAlignment.RIGHT).build());
+            }
+        }
+        routeLevelTableDefBuilder.addColumn(new ColumnDefinition.Builder(new DoubleColumnType(), "Total").build());
+
+        DynamicTablePrinter routeLevelTablePrinter = new DynamicTablePrinter(routeLevelTableDef);
+        TableRow row;
+        // row = routeLevelTablePrinter.addRow().add("Weight");
+        // for (ComponentValue cv : solution.getDetailedCost()) {
+        // if (cv instanceof RouteLevelComponentValue) {
+        // row.add(cv.getWeight());
+        // }
+        // }
+        // routeLevelTablePrinter.addSeparator();
+
+        for (VehicleRoute r : solution.getRoutes()) {
+            row = routeLevelTablePrinter.addRow().add(r.getId());
+            double sum = 0d;
+            for (ComponentValue cv : solution.getDetailedCost()) {
+                if (cv instanceof RouteLevelComponentValue) {
+                    Double val = ((RouteLevelComponentValue) cv).getRouteValue(r.getId()).orElse(null);
+                    if (val != null) {
+                        val *= cv.getWeight();
+                    }
+                    sum += val;
+                    row.add(val);
+                }
+            }
+            row.add(sum);
+        }
+        routeLevelTablePrinter.addSeparator();
+        row = routeLevelTablePrinter.addRow().add("Total");
+        double sum = 0d;
+        for (ComponentValue cv : solution.getDetailedCost()) {
+            if (cv instanceof RouteLevelComponentValue) {
+                Double val = ((RouteLevelComponentValue) cv).getValue();
+                if (val != null) {
+                    val *= cv.getWeight();
+                }
+                sum += val;
+                row.add(val);
+            }
+        }
+        row.add(sum);
+
+        out.println(routeLevelTablePrinter.print());
+    }
+
+    // ----------------------------------------------------------
+
     public static void printRouteDetails(VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution,
                     PrinterColumnList<RoutePrinterContext> columns) {
         printRouteDetails(SYSTEM_OUT_AS_PRINT_WRITER, problem, solution, columns);
@@ -270,16 +367,14 @@ public static void printRouteDetails(PrintWriter out, VehicleRoutingProblem prob
     protected static ConfigurableTablePrinter<RoutePrinterContext> buildRouteDetailsTable(VehicleRoutingProblem problem,
                     VehicleRoutingProblemSolution solution, PrinterColumnList<RoutePrinterContext> columns) {
         ConfigurableTablePrinter<RoutePrinterContext> tablePrinter = new ConfigurableTablePrinter<>(columns);
-        int routeNu = 1;
 
         List<VehicleRoute> list = new ArrayList<>(solution.getRoutes());
-        Collections.sort(list, new com.graphhopper.jsprit.core.util.VehicleIndexComparator());
         for (VehicleRoute route : list) {
-            if (routeNu != 1) {
+            if (route.getId() != 1) {
                 tablePrinter.addSeparator();
             }
 
-            RoutePrinterContext context = new RoutePrinterContext(routeNu, route, route.getStart(), problem);
+            RoutePrinterContext context = new RoutePrinterContext(route, route.getStart(), problem);
             tablePrinter.addRow(context);
 
             for (TourActivity act : route.getActivities()) {
@@ -289,8 +384,6 @@ public static void printRouteDetails(PrintWriter out, VehicleRoutingProblem prob
 
             context.setActivity(route.getEnd());
             tablePrinter.addRow(context);
-
-            routeNu++;
         }
         return tablePrinter;
     }
@@ -326,11 +419,9 @@ public static String exportVehicleSummary(VehicleRoutingProblem problem, Vehicle
                     VehicleRoutingProblemSolution solution, PrinterColumnList<VehicleSummaryContext> columns) {
         ConfigurableTablePrinter<VehicleSummaryContext> vehicleTablePrinter = new ConfigurableTablePrinter<>(columns);
 
-        List<VehicleRoute> list = new ArrayList<>(solution.getRoutes());
-        Collections.sort(list, new com.graphhopper.jsprit.core.util.VehicleIndexComparator());
-        int rn = 1;
+        List<VehicleRoute> list = solution.getRoutes();
         for (VehicleRoute route : list) {
-            vehicleTablePrinter.addRow(new VehicleSummaryContext(rn++, route, problem));
+            vehicleTablePrinter.addRow(new VehicleSummaryContext(route, problem));
         }
         return vehicleTablePrinter;
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/job/JobNamePrinterColumn.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/job/JobNamePrinterColumn.java
new file mode 100644
index 000000000..f141152ed
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/job/JobNamePrinterColumn.java
@@ -0,0 +1,53 @@
+package com.graphhopper.jsprit.core.reporting.job;
+
+import java.util.function.Consumer;
+
+import com.graphhopper.jsprit.core.problem.job.AbstractJob;
+import com.graphhopper.jsprit.core.problem.job.Job;
+import com.graphhopper.jsprit.core.reporting.AbstractPrinterColumn;
+import com.graphhopper.jsprit.core.reporting.columndefinition.ColumnDefinition;
+import com.graphhopper.jsprit.core.reporting.columndefinition.StringColumnType;
+
+/**
+ * Name (id) of the job.
+ *
+ * <p>
+ * This column provides the {@linkplain Job#getId()} of the associated job of
+ * the activity for job activities and null for other route activities.
+ * </p>
+ *
+ * @author balage
+ */
+public class JobNamePrinterColumn<T extends JobPrinterContext> extends AbstractPrinterColumn<T, String, JobNamePrinterColumn<T>> {
+
+    /**
+     * Constructor.
+     */
+    public JobNamePrinterColumn() {
+        super();
+    }
+
+    /**
+     * Constructor with a post creation decorator provided.
+     */
+    public JobNamePrinterColumn(Consumer<ColumnDefinition.Builder> decorator) {
+        super(decorator);
+    }
+
+    @Override
+    public ColumnDefinition.Builder getColumnBuilder() {
+        return new ColumnDefinition.Builder(new StringColumnType("-"));
+    }
+
+    @Override
+    protected String getDefaultTitle() {
+        return "job name";
+    }
+
+    @Override
+    public String getData(T context) {
+        AbstractJob job = context.getJob();
+        return job == null ? null : job.getId();
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/job/JobPrinterContext.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/job/JobPrinterContext.java
new file mode 100644
index 000000000..08e1bc591
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/job/JobPrinterContext.java
@@ -0,0 +1,21 @@
+package com.graphhopper.jsprit.core.reporting.job;
+
+import com.graphhopper.jsprit.core.problem.job.AbstractJob;
+import com.graphhopper.jsprit.core.reporting.PrinterContext;
+
+/**
+ * The context of the detailed route printer columns.
+ *
+ * <p>
+ * This is a semi-mutable class: only the activity could be altered. Therefore
+ * for each route a new instance should be created.
+ * </p>
+ *
+ * @author balage
+ *
+ */
+public interface JobPrinterContext extends PrinterContext {
+
+    public AbstractJob getJob();
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/job/JobPriorityPrinterColumn.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/job/JobPriorityPrinterColumn.java
new file mode 100644
index 000000000..524bdd7d8
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/job/JobPriorityPrinterColumn.java
@@ -0,0 +1,58 @@
+package com.graphhopper.jsprit.core.reporting.job;
+
+import java.util.function.Consumer;
+
+import com.graphhopper.jsprit.core.problem.job.AbstractJob;
+import com.graphhopper.jsprit.core.problem.job.Job;
+import com.graphhopper.jsprit.core.reporting.AbstractPrinterColumn;
+import com.graphhopper.jsprit.core.reporting.columndefinition.ColumnAlignment;
+import com.graphhopper.jsprit.core.reporting.columndefinition.ColumnDefinition;
+import com.graphhopper.jsprit.core.reporting.columndefinition.StringColumnType;
+
+/**
+ * Priority of the job.
+ *
+ * <p>
+ * This column provides the named (LOW, MEDIUM, HIGH) representation of
+ * {@linkplain Job#getPriority()} of the associated job of the activity for job
+ * activities and null for other route activities.
+ * </p>
+ *
+ * @author balage
+ */
+public class JobPriorityPrinterColumn<T extends JobPrinterContext>
+                extends AbstractPrinterColumn<T, String, JobPriorityPrinterColumn<T>> {
+
+    private static final String[] PRIORITY_NAMES = new String[] { "", "HIGH", "MEDIUM", "LOW" };
+
+    /**
+     * Constructor.
+     */
+    public JobPriorityPrinterColumn() {
+        super();
+    }
+
+    /**
+     * Constructor with a post creation decorator provided.
+     */
+    public JobPriorityPrinterColumn(Consumer<ColumnDefinition.Builder> decorator) {
+        super(decorator);
+    }
+
+    @Override
+    public ColumnDefinition.Builder getColumnBuilder() {
+        return new ColumnDefinition.Builder(new StringColumnType("-")).withAlignment(ColumnAlignment.CENTER);
+    }
+
+    @Override
+    protected String getDefaultTitle() {
+        return "priority";
+    }
+
+    @Override
+    public String getData(T context) {
+        AbstractJob job = context.getJob();
+        return job == null ? null : PRIORITY_NAMES[job.getPriority()];
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/job/JobTypePrinterColumn.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/job/JobTypePrinterColumn.java
new file mode 100644
index 000000000..e51a1c7bb
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/job/JobTypePrinterColumn.java
@@ -0,0 +1,52 @@
+package com.graphhopper.jsprit.core.reporting.job;
+
+import java.util.function.Consumer;
+
+import com.graphhopper.jsprit.core.problem.job.AbstractJob;
+import com.graphhopper.jsprit.core.reporting.AbstractPrinterColumn;
+import com.graphhopper.jsprit.core.reporting.columndefinition.ColumnDefinition;
+import com.graphhopper.jsprit.core.reporting.columndefinition.StringColumnType;
+
+/**
+ * Priority of the job.
+ *
+ * <p>
+ * This column provides the simple class name of the associated job of the
+ * activity for job activities and null for other route activities.
+ * </p>
+ *
+ * @author balage
+ */
+public class JobTypePrinterColumn<T extends JobPrinterContext> extends AbstractPrinterColumn<T, String, JobTypePrinterColumn<T>> {
+
+    /**
+     * Constructor.
+     */
+    public JobTypePrinterColumn() {
+        super();
+    }
+
+    /**
+     * Constructor with a post creation decorator provided.
+     */
+    public JobTypePrinterColumn(Consumer<ColumnDefinition.Builder> decorator) {
+        super(decorator);
+    }
+
+    @Override
+    public ColumnDefinition.Builder getColumnBuilder() {
+        return new ColumnDefinition.Builder(new StringColumnType("-"));
+    }
+
+    @Override
+    protected String getDefaultTitle() {
+        return "job type";
+    }
+
+    @Override
+    public String getData(JobPrinterContext context) {
+        AbstractJob job = context.getJob();
+        return job == null ? null : job.getClass().getSimpleName();
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/JobNamePrinterColumn.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/JobNamePrinterColumn.java
index 33919c687..d58fafbe9 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/JobNamePrinterColumn.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/JobNamePrinterColumn.java
@@ -2,9 +2,8 @@
 
 import java.util.function.Consumer;
 
+import com.graphhopper.jsprit.core.problem.job.AbstractJob;
 import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.reporting.AbstractPrinterColumn;
 import com.graphhopper.jsprit.core.reporting.columndefinition.ColumnDefinition;
 import com.graphhopper.jsprit.core.reporting.columndefinition.StringColumnType;
@@ -47,13 +46,8 @@ protected String getDefaultTitle() {
 
     @Override
     public String getData(RoutePrinterContext context) {
-        TourActivity act = context.getActivity();
-        if (act instanceof JobActivity) {
-            Job job = ((JobActivity) context.getActivity()).getJob();
-            return job.getId();
-        } else {
-            return null;
-        }
+        AbstractJob job = context.getJob();
+        return job == null ? null : job.getId();
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/JobPriorityPrinterColumn.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/JobPriorityPrinterColumn.java
index b22337afd..6846f4ece 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/JobPriorityPrinterColumn.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/JobPriorityPrinterColumn.java
@@ -2,9 +2,8 @@
 
 import java.util.function.Consumer;
 
+import com.graphhopper.jsprit.core.problem.job.AbstractJob;
 import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.reporting.AbstractPrinterColumn;
 import com.graphhopper.jsprit.core.reporting.columndefinition.ColumnAlignment;
 import com.graphhopper.jsprit.core.reporting.columndefinition.ColumnDefinition;
@@ -51,13 +50,8 @@ protected String getDefaultTitle() {
 
     @Override
     public String getData(RoutePrinterContext context) {
-        TourActivity act = context.getActivity();
-        if (act instanceof JobActivity) {
-            Job job = ((JobActivity) context.getActivity()).getJob();
-            return PRIORITY_NAMES[job.getPriority()];
-        } else {
-            return null;
-        }
+        AbstractJob job = context.getJob();
+        return job == null ? null : PRIORITY_NAMES[job.getPriority()];
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/JobTypePrinterColumn.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/JobTypePrinterColumn.java
index b4b50062b..670160eea 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/JobTypePrinterColumn.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/JobTypePrinterColumn.java
@@ -2,9 +2,7 @@
 
 import java.util.function.Consumer;
 
-import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+import com.graphhopper.jsprit.core.problem.job.AbstractJob;
 import com.graphhopper.jsprit.core.reporting.AbstractPrinterColumn;
 import com.graphhopper.jsprit.core.reporting.columndefinition.ColumnDefinition;
 import com.graphhopper.jsprit.core.reporting.columndefinition.StringColumnType;
@@ -47,13 +45,8 @@ protected String getDefaultTitle() {
 
     @Override
     public String getData(RoutePrinterContext context) {
-        TourActivity act = context.getActivity();
-        if (act instanceof JobActivity) {
-            Job job = ((JobActivity) context.getActivity()).getJob();
-            return job.getClass().getSimpleName();
-        } else {
-            return null;
-        }
+        AbstractJob job = context.getJob();
+        return job == null ? null : job.getClass().getSimpleName();
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/RouteNumberPrinterColumn.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/RouteNumberPrinterColumn.java
index d9a4dc4f1..d15cbeede 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/RouteNumberPrinterColumn.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/RouteNumberPrinterColumn.java
@@ -43,7 +43,7 @@ protected String getDefaultTitle() {
 
     @Override
     public Integer getData(RoutePrinterContext context) {
-        return context.getRouteNr();
+        return context.getRoute().getId();
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/RoutePrinterContext.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/RoutePrinterContext.java
index 08ec51c19..d868070bd 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/RoutePrinterContext.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/RoutePrinterContext.java
@@ -1,9 +1,11 @@
 package com.graphhopper.jsprit.core.reporting.route;
 
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.job.AbstractJob;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-import com.graphhopper.jsprit.core.reporting.PrinterContext;
+import com.graphhopper.jsprit.core.reporting.job.JobPrinterContext;
 
 /**
  * The context of the detailed route printer columns.
@@ -16,10 +18,8 @@
  * @author balage
  *
  */
-public class RoutePrinterContext implements PrinterContext {
+public class RoutePrinterContext implements JobPrinterContext {
 
-    // The route id
-    private int routeNr;
     // The route itself
     private VehicleRoute route;
     // The current activity
@@ -39,21 +39,13 @@
      * @param problem
      *            problem
      */
-    public RoutePrinterContext(int routeNr, VehicleRoute route, TourActivity activity, VehicleRoutingProblem problem) {
+    public RoutePrinterContext(VehicleRoute route, TourActivity activity, VehicleRoutingProblem problem) {
         super();
-        this.routeNr = routeNr;
         this.route = route;
         this.activity = activity;
         this.problem = problem;
     }
 
-    /**
-     * @return The route id.
-     */
-    public int getRouteNr() {
-        return routeNr;
-    }
-
     /**
      * @return The route itself.
      */
@@ -83,4 +75,9 @@ public VehicleRoutingProblem getProblem() {
         return problem;
     }
 
+    @Override
+    public AbstractJob getJob() {
+        return (getActivity() instanceof JobActivity) ? ((JobActivity) getActivity()).getJob() : null;
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/vehicle/VehicleSummaryContext.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/vehicle/VehicleSummaryContext.java
index 4b3505172..c658c1d97 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/vehicle/VehicleSummaryContext.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/vehicle/VehicleSummaryContext.java
@@ -25,8 +25,8 @@
     private long breakDuration;
     private long travelDistance;
 
-    public VehicleSummaryContext(int routeNr, VehicleRoute route, VehicleRoutingProblem problem) {
-        this.routeNr = routeNr;
+    public VehicleSummaryContext(VehicleRoute route, VehicleRoutingProblem problem) {
+        routeNr = route.getId();
         vehicle = route.getVehicle();
         driver = route.getDriver();
         start = (long) route.getStart().getEndTime();
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/VehicleIndexComparator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/VehicleIndexComparator.java
index 5b7c6585a..0e6954077 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/VehicleIndexComparator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/VehicleIndexComparator.java
@@ -23,7 +23,9 @@
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 
 public class VehicleIndexComparator implements Comparator<VehicleRoute> {
+    @Override
     public int compare(VehicleRoute a, VehicleRoute b) {
-        return a.getVehicle().getIndex() - b.getVehicle().getIndex();
+        return (a.getVehicle() == null ? 0 : a.getVehicle().getIndex()) -
+                        (b.getVehicle() == null ? 0 : b.getVehicle().getIndex());
     }
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculatorTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculatorTest.java
new file mode 100644
index 000000000..d2ba17f8d
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculatorTest.java
@@ -0,0 +1,150 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+
+import java.util.Optional;
+
+import org.junit.Test;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+
+public class ModularSolutionCostCalculatorTest {
+
+    @Test
+    public void whenModuleAdded_itIsThere() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        calc.addComponent(fix);
+        assertEquals(1, calc.getComponentCount());
+        assertEquals(true, calc.findComponent(FixCostPerVehicle.COMPONENT_ID).isPresent());
+        assertEquals(fix, calc.findComponent(FixCostPerVehicle.COMPONENT_ID).get());
+    }
+
+    @Test
+    public void whenAnotherModuleAdded_itIsAlsoThere() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        UnassignedJobs unassigned = new UnassignedJobs();
+        calc.addComponent(fix);
+        calc.addComponent(unassigned);
+        assertEquals(2, calc.getComponentCount());
+        assertEquals(true, calc.findComponent(FixCostPerVehicle.COMPONENT_ID).isPresent());
+        assertEquals(fix, calc.findComponent(FixCostPerVehicle.COMPONENT_ID).get());
+        assertEquals(true, calc.findComponent(UnassignedJobs.COMPONENT_ID).isPresent());
+        assertEquals(unassigned, calc.findComponent(UnassignedJobs.COMPONENT_ID).get());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenModuleAddedTwice_exceptionIsThrown() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        calc.addComponent(fix);
+        calc.addComponent(fix);
+    }
+
+    @Test
+    public void whenRegisteredModuleRemoved_itIsRemoved() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        UnassignedJobs unassigned = new UnassignedJobs();
+        calc.addComponent(fix);
+        calc.addComponent(unassigned);
+        calc.removeComponent(FixCostPerVehicle.COMPONENT_ID);
+
+        assertEquals(1, calc.getComponentCount());
+        assertEquals(false, calc.findComponent(FixCostPerVehicle.COMPONENT_ID).isPresent());
+        assertEquals(true, calc.findComponent(UnassignedJobs.COMPONENT_ID).isPresent());
+    }
+
+    @Test
+    public void whenRegisteredModuleRemoved_itIsReturned() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        UnassignedJobs unassigned = new UnassignedJobs();
+        calc.addComponent(fix);
+        calc.addComponent(unassigned);
+        Optional<SolutionCostComponent> res = calc.removeComponent(FixCostPerVehicle.COMPONENT_ID);
+
+        assertTrue(res.isPresent());
+        assertEquals(fix, res.get());
+    }
+
+    @Test
+    public void whenUnregisteredModuleRemoved_nothingHappens() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        UnassignedJobs unassigned = new UnassignedJobs();
+        calc.addComponent(unassigned);
+        Optional<SolutionCostComponent> res = calc.removeComponent(FixCostPerVehicle.COMPONENT_ID);
+
+        assertEquals(1, calc.getComponentCount());
+        assertEquals(true, calc.findComponent(UnassignedJobs.COMPONENT_ID).isPresent());
+        assertEquals(false, res.isPresent());
+    }
+
+    @Test
+    public void whenGettingTheWeightOfRegisteredComponent_theDefaultIsOne() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        calc.addComponent(fix);
+        Optional<Double> res = calc.getWeight(FixCostPerVehicle.COMPONENT_ID);
+
+        assertTrue(res.isPresent());
+        assertEquals(1d, res.get(), 0d);
+    }
+
+    @Test
+    public void whenGettingTheWeightOfUnregisteredComponent_theValueIsEmpty() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        calc.addComponent(fix);
+        Optional<Double> res = calc.getWeight(UnassignedJobs.COMPONENT_ID);
+
+        assertFalse(res.isPresent());
+    }
+
+    @Test
+    public void whenSettingTheWeightOfAComponentWhenRegistered_theWeightIsSet() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        calc.addComponent(fix, 2d);
+        Optional<Double> res = calc.getWeight(FixCostPerVehicle.COMPONENT_ID);
+
+        assertTrue(res.isPresent());
+        assertEquals(2d, res.get(), 0d);
+    }
+
+    @Test
+    public void whenSettingTheWeightOfAComponentLater_theWeightIsSet() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        calc.addComponent(fix);
+        calc.changeComponentWeight(FixCostPerVehicle.COMPONENT_ID, 2d);
+        Optional<Double> res = calc.getWeight(FixCostPerVehicle.COMPONENT_ID);
+
+        assertTrue(res.isPresent());
+        assertEquals(2d, res.get(), 0d);
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void whenCallingCalculatorFunctionsBeforeInitialization_itThrowsException() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        calc.addComponent(fix);
+        calc.calculate(mock(VehicleRoutingProblemSolution.class));
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void whenAddingComponentAfterInitialization_itThrowsException() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        UnassignedJobs unassigned = new UnassignedJobs();
+        calc.addComponent(fix);
+        calc.beforeRun(mock(VehicleRoutingProblem.class), 0d);
+        calc.addComponent(unassigned);
+    }
+
+}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
index 05cafeaf9..a1ed51458 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
@@ -19,20 +19,8 @@
 package com.graphhopper.jsprit.core.problem.constraint;
 
 
-import static org.junit.Assert.assertEquals;
-
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-
 import com.graphhopper.jsprit.core.algorithm.state.StateId;
 import com.graphhopper.jsprit.core.algorithm.state.StateManager;
-import com.graphhopper.jsprit.core.distance.ManhattanDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.cost.TransportDistance;
@@ -40,6 +28,7 @@
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.job.Pickup;
 import com.graphhopper.jsprit.core.problem.job.Shipment;
+import com.graphhopper.jsprit.core.problem.misc.ActivityContext;
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
@@ -47,7 +36,15 @@
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
-import com.graphhopper.jsprit.core.util.DefaultCosts;
+import com.graphhopper.jsprit.core.util.ManhattanCosts;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.*;
+
+import static org.mockito.Mockito.mock;
 
 /**
  * Created by schroeder on 18/05/16.
@@ -66,54 +63,50 @@
 
     VehicleRoutingProblem vrp;
 
-    Delivery d1, d2, newDelivery;
+    Delivery d1,d2,newDelivery;
 
     Pickup pickup;
 
     Shipment s1;
 
-    Map<Vehicle, Double> maxDistanceMap;
+    Map<Vehicle,Double> maxDistanceMap;
 
 
     @Before
-    public void doBefore() {
-        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0, 0)).build();
-        vehicle2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(Location.newInstance(10, 10)).build();
+    public void doBefore(){
+        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0,0)).build();
+        vehicle2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(Location.newInstance(10,10)).build();
 
         maxDistanceMap = new HashMap<>();
-        maxDistanceMap.put(vehicle, 200d);
-        maxDistanceMap.put(vehicle2, 200d);
+        maxDistanceMap.put(vehicle,200d);
+        maxDistanceMap.put(vehicle2,200d);
 
-        d1 = Delivery.Builder.newInstance("d1").setLocation(Location.newInstance(10, 10)).build();
-        d2 = Delivery.Builder.newInstance("d2").setLocation(Location.newInstance(20, 15)).build();
-        pickup = Pickup.Builder.newInstance("pickup").setLocation(Location.newInstance(50, 50)).build();
-        s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(35, 30))
-                        .setDeliveryLocation(Location.newInstance(20, 25)).build();
+        d1 = Delivery.Builder.newInstance("d1").setLocation(Location.newInstance(10,10)).build();
+        d2 = Delivery.Builder.newInstance("d2").setLocation(Location.newInstance(20,15)).build();
+        pickup = Pickup.Builder.newInstance("pickup").setLocation(Location.newInstance(50,50)).build();
+        s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(35,30))
+            .setDeliveryLocation(Location.newInstance(20,25)).build();
 
-        newDelivery = Delivery.Builder.newInstance("new").setLocation(Location.newInstance(-10, 10)).build();
+        newDelivery = Delivery.Builder.newInstance("new").setLocation(Location.newInstance(-10,10)).build();
 
         vrp = VehicleRoutingProblem.Builder.newInstance()
-                        .setRoutingCost(new DefaultCosts(ManhattanDistanceCalculator.getInstance()))
-                        .addVehicle(vehicle).addVehicle(vehicle2)
-                        .addJob(d1).addJob(d2).addJob(s1).addJob(pickup).addJob(newDelivery).build();
+            .setRoutingCost(new ManhattanCosts()).addVehicle(vehicle).addVehicle(vehicle2)
+            .addJob(d1).addJob(d2).addJob(s1).addJob(pickup).addJob(newDelivery).build();
 
         route = VehicleRoute.Builder.newInstance(vehicle).setJobActivityFactory(vrp.getJobActivityFactory())
-                        .addDelivery(d1).addDelivery(d2).addPickup(s1).addPickup(pickup).addDelivery(s1).build();
+            .addDelivery(d1).addDelivery(d2).addPickup(s1).addPickup(pickup).addDelivery(s1).build();
 
         stateManager = new StateManager(vrp);
 
         traveledDistanceId = stateManager.createStateId("traveledDistance");
 
         com.graphhopper.jsprit.core.algorithm.state.VehicleDependentTraveledDistance traveledDistance =
-                        new com.graphhopper.jsprit.core.algorithm.state.VehicleDependentTraveledDistance(new TransportDistance() {
-                            @Override
-                            public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-                                return new DefaultCosts(ManhattanDistanceCalculator
-                                                .getInstance()).getDistance(from,
-                                                                to, departureTime,
-                                                                vehicle);
-                            }
-                        }, stateManager, traveledDistanceId, Arrays.asList(vehicle, vehicle2));
+            new com.graphhopper.jsprit.core.algorithm.state.VehicleDependentTraveledDistance(new TransportDistance() {
+                @Override
+                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                    return new ManhattanCosts().getDistance(from,to,departureTime,vehicle);
+                }
+        },stateManager,traveledDistanceId,Arrays.asList(vehicle,vehicle2));
 
         stateManager.addStateUpdater(traveledDistance);
         stateManager.informInsertionStarts(Arrays.asList(route), Collections.<Job>emptyList());
@@ -149,123 +142,216 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
 vehicle2 (max distance): 180.0
      */
     @Test
-    public void insertNewInVehicleShouldFail() {
+    public void insertNewInVehicleShouldFail(){
         MaxDistanceConstraint maxDistanceConstraint =
-                        new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
-                            @Override
-                            public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-                                return vrp.getTransportCosts().getTransportTime(from, to, departureTime, null, vehicle);
-                            }
-                        }, maxDistanceMap);
-        JobInsertionContext context = new JobInsertionContext(route, newDelivery, vehicle, null, 0);
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, route.getStart(), newAct(), act(0), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(0), newAct(), act(1), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(1), newAct(), act(2), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(2), newAct(), act(3), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(3), newAct(), act(4), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(4), newAct(), route.getEnd(), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+            new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
+                @Override
+                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                }
+            },maxDistanceMap);
+        JobInsertionContext context = new JobInsertionContext(route,newDelivery,vehicle,null,0);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,route.getStart(),newAct(),act(0),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(0),newAct(),act(1),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(1),newAct(),act(2),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(2),newAct(),act(3),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(3),newAct(),act(4),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(4),newAct(),route.getEnd(),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
     }
 
 
     @Test
-    public void insertNewInVehicle2ShouldBeCorrect() {
+    public void insertNewInVehicle2ShouldBeCorrect(){
         //current distance vehicle2: 160 allowed: 200
         MaxDistanceConstraint maxDistanceConstraint =
-                        new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
-                            @Override
-                            public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-                                return vrp.getTransportCosts().getTransportTime(from, to, departureTime, null, vehicle);
-                            }
-                        }, maxDistanceMap);
-        JobInsertionContext context = new JobInsertionContext(route, newDelivery, vehicle2, null, 0);
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, route.getStart(), newAct(), act(0), 0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+            new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
+                @Override
+                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                }
+            },maxDistanceMap);
+        JobInsertionContext context = new JobInsertionContext(route,newDelivery,vehicle2,null,0);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,route.getStart(),newAct(),act(0),0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
         //additional distance: 20+35-15=40
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(0), newAct(), act(1), 0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(0),newAct(),act(1),0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
         //additional distance: 35+65-30=70
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(1), newAct(), act(2), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(1),newAct(),act(2),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
         //additional distance: 65+100-35
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(2), newAct(), act(3), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(2),newAct(),act(3),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
         //additional distance: 100+45-55
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(3), newAct(), act(4), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(3),newAct(),act(4),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
         //additional distance: 45+20-25
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(4), newAct(), route.getEnd(), 0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(4),newAct(),route.getEnd(),0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
     }
 
     private TourActivity act(int i) {
         return route.getActivities().get(i);
     }
 
-    private TourActivity newAct() {
+    private TourActivity newAct(){
         return vrp.getActivities(newDelivery).get(0);
     }
 
     @Test
-    public void traveledDistanceShouldBeCorrect() {
-        assertEquals(20d, stateManager.getActivityState(route.getActivities().get(0), vehicle, traveledDistanceId, Double.class), 0.01);
-        assertEquals(35d, stateManager.getActivityState(route.getActivities().get(1), vehicle, traveledDistanceId, Double.class), 0.01);
-        assertEquals(65d, stateManager.getActivityState(route.getActivities().get(2), vehicle, traveledDistanceId, Double.class), 0.01);
-        assertEquals(100d, stateManager.getActivityState(route.getActivities().get(3), vehicle, traveledDistanceId, Double.class), 0.01);
-        assertEquals(155d, stateManager.getActivityState(route.getActivities().get(4), vehicle, traveledDistanceId, Double.class), 0.01);
+    public void traveledDistanceShouldBeCorrect(){
+        Assert.assertEquals(20d,stateManager.getActivityState(route.getActivities().get(0),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(35d,stateManager.getActivityState(route.getActivities().get(1),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(65d,stateManager.getActivityState(route.getActivities().get(2),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(100d,stateManager.getActivityState(route.getActivities().get(3),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(155d,stateManager.getActivityState(route.getActivities().get(4),vehicle,traveledDistanceId,Double.class),0.01);
 
     }
 
     @Test
-    public void traveledDistanceWithVehicle2ShouldBeCorrect() {
-        assertEquals(0d, stateManager.getActivityState(route.getActivities().get(0), vehicle2, traveledDistanceId, Double.class), 0.01);
-        assertEquals(15d, stateManager.getActivityState(route.getActivities().get(1), vehicle2, traveledDistanceId, Double.class), 0.01);
-        assertEquals(45d, stateManager.getActivityState(route.getActivities().get(2), vehicle2, traveledDistanceId, Double.class), 0.01);
-        assertEquals(80d, stateManager.getActivityState(route.getActivities().get(3), vehicle2, traveledDistanceId, Double.class), 0.01);
-        assertEquals(135d, stateManager.getActivityState(route.getActivities().get(4), vehicle2, traveledDistanceId, Double.class), 0.01);
+    public void traveledDistanceWithVehicle2ShouldBeCorrect(){
+        Assert.assertEquals(0d,stateManager.getActivityState(route.getActivities().get(0),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(15d,stateManager.getActivityState(route.getActivities().get(1),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(45d,stateManager.getActivityState(route.getActivities().get(2),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(80d,stateManager.getActivityState(route.getActivities().get(3),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(135d,stateManager.getActivityState(route.getActivities().get(4),vehicle2,traveledDistanceId,Double.class),0.01);
 
     }
 
     @Test
-    public void distanceOfShipmentInRoute() {
-        double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(2), vehicle, traveledDistanceId, Double.class);
+    public void distanceOfShipmentInRoute(){
+        double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(2), vehicle,traveledDistanceId, Double.class);
         double traveledDistanceBeforeDelivery = stateManager.getActivityState(route.getActivities().get(4), vehicle, traveledDistanceId, Double.class);
-        assertEquals(90d, traveledDistanceBeforeDelivery - traveledDistanceBeforePickup, 0.01);
+        Assert.assertEquals(90d,traveledDistanceBeforeDelivery-traveledDistanceBeforePickup,0.01);
     }
 
     @Test
-    public void distanceOfShipmentInRouteVehicle2() {
-        double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(2), vehicle2, traveledDistanceId, Double.class);
+    public void distanceOfShipmentInRouteVehicle2(){
+        double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(2), vehicle2,traveledDistanceId, Double.class);
         double traveledDistanceBeforeDelivery = stateManager.getActivityState(route.getActivities().get(4), vehicle2, traveledDistanceId, Double.class);
-        assertEquals(90d, traveledDistanceBeforeDelivery - traveledDistanceBeforePickup, 0.01);
+        Assert.assertEquals(90d,traveledDistanceBeforeDelivery-traveledDistanceBeforePickup,0.01);
     }
 
     @Test
-    public void distanceOfPickupInRoute() {
+    public void distanceOfPickupInRoute(){
         double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(3), vehicle, traveledDistanceId, Double.class);
-        double total = stateManager.getRouteState(route, vehicle, traveledDistanceId, Double.class);
-        assertEquals(100d, total - traveledDistanceBeforePickup, 0.01);
+        double total = stateManager.getRouteState(route, vehicle,traveledDistanceId, Double.class);
+        Assert.assertEquals(100d,total-traveledDistanceBeforePickup,0.01);
     }
 
     @Test
-    public void distanceOfPickupInRouteVehicle2() {
+    public void distanceOfPickupInRouteVehicle2(){
         double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(3), vehicle2, traveledDistanceId, Double.class);
-        double total = stateManager.getRouteState(route, vehicle2, traveledDistanceId, Double.class);
-        assertEquals(80d, total - traveledDistanceBeforePickup, 0.01);
+        double total = stateManager.getRouteState(route, vehicle2,traveledDistanceId, Double.class);
+        Assert.assertEquals(80d,total-traveledDistanceBeforePickup,0.01);
     }
 
     @Test
-    public void distanceToTravelShouldBeCorrect() {
+    public void distanceToTravelShouldBeCorrect(){
         double total = stateManager.getRouteState(route, vehicle, traveledDistanceId, Double.class);
-        assertEquals(180d, total - stateManager.getActivityState(route.getActivities().get(0), vehicle, traveledDistanceId, Double.class), 0.01);
-        assertEquals(165d, total - stateManager.getActivityState(route.getActivities().get(1), vehicle, traveledDistanceId, Double.class), 0.01);
-        assertEquals(135d, total - stateManager.getActivityState(route.getActivities().get(2), vehicle, traveledDistanceId, Double.class), 0.01);
-        assertEquals(100d, total - stateManager.getActivityState(route.getActivities().get(3), vehicle, traveledDistanceId, Double.class), 0.01);
-        assertEquals(45d, total - stateManager.getActivityState(route.getActivities().get(4), vehicle, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(180d,total - stateManager.getActivityState(route.getActivities().get(0),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(165d, total - stateManager.getActivityState(route.getActivities().get(1), vehicle, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(135d,total - stateManager.getActivityState(route.getActivities().get(2),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(100d, total - stateManager.getActivityState(route.getActivities().get(3), vehicle, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(45d, total - stateManager.getActivityState(route.getActivities().get(4), vehicle, traveledDistanceId, Double.class), 0.01);
 
     }
 
     @Test
-    public void distanceToTravelShouldBeCorrectVehicle2() {
+    public void distanceToTravelShouldBeCorrectVehicle2(){
         double total = stateManager.getRouteState(route, vehicle2, traveledDistanceId, Double.class);
-        assertEquals(160d, total - stateManager.getActivityState(route.getActivities().get(0), vehicle2, traveledDistanceId, Double.class), 0.01);
-        assertEquals(145d, total - stateManager.getActivityState(route.getActivities().get(1), vehicle2, traveledDistanceId, Double.class), 0.01);
-        assertEquals(115d, total - stateManager.getActivityState(route.getActivities().get(2), vehicle2, traveledDistanceId, Double.class), 0.01);
-        assertEquals(80d, total - stateManager.getActivityState(route.getActivities().get(3), vehicle2, traveledDistanceId, Double.class), 0.01);
-        assertEquals(25d, total - stateManager.getActivityState(route.getActivities().get(4), vehicle2, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(160d,total - stateManager.getActivityState(route.getActivities().get(0),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(145d, total - stateManager.getActivityState(route.getActivities().get(1), vehicle2, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(115d,total - stateManager.getActivityState(route.getActivities().get(2),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(80d, total - stateManager.getActivityState(route.getActivities().get(3), vehicle2, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(25d, total - stateManager.getActivityState(route.getActivities().get(4), vehicle2, traveledDistanceId, Double.class), 0.01);
 
     }
+
+    @Test
+    public void whenAddingDeliverShipment_constraintShouldWork() {
+        Shipment shipment = Shipment.Builder.newInstance("s")
+            .setPickupLocation(Location.newInstance(0, 3))
+            .setDeliveryLocation(Location.newInstance(4, 0))
+            .build();
+        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v")
+            .setStartLocation(Location.newInstance(0, 0))
+            .build();
+        final VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
+            .addJob(shipment)
+            .addVehicle(vehicle)
+            .build();
+        VehicleRoute route = VehicleRoute.emptyRoute();
+        JobInsertionContext context = new JobInsertionContext(route, shipment, vehicle, null, 0);
+        context.getAssociatedActivities().add(vrp.getActivities(shipment).get(0));
+        context.getAssociatedActivities().add(vrp.getActivities(shipment).get(1));
+        maxDistanceMap = new HashMap<>();
+        maxDistanceMap.put(vehicle,12d);
+
+        StateManager stateManager = new StateManager(vrp);
+        MaxDistanceConstraint maxDistanceConstraint =
+            new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
+                @Override
+                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                }
+            },maxDistanceMap);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,
+            new Start(vehicle.getStartLocation(), 0, Double.MAX_VALUE),
+            vrp.getActivities(shipment).get(0),
+            new End(vehicle.getEndLocation(), 0, Double.MAX_VALUE),
+            0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+
+        ActivityContext pickupContext = new ActivityContext();
+        pickupContext.setArrivalTime(3);
+        pickupContext.setEndTime(3);
+        pickupContext.setInsertionIndex(0);
+        context.setRelatedActivityContext(pickupContext);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,
+            vrp.getActivities(shipment).get(0),
+            vrp.getActivities(shipment).get(1),
+            new End(vehicle.getEndLocation(), 0, Double.MAX_VALUE),
+            3).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+    }
+
+    @Test
+    public void whenAddingDeliverShipmentWithVehDiffStartEndLocs_constraintShouldWork() {
+        Shipment shipment = Shipment.Builder.newInstance("s")
+            .setPickupLocation(Location.newInstance(0, 1))
+            .setDeliveryLocation(Location.newInstance(4, 1))
+            .build();
+        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v")
+            .setStartLocation(Location.newInstance(0, 0))
+            .setEndLocation(Location.newInstance(0, 4))
+            .build();
+        final VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
+            .addJob(shipment)
+            .addVehicle(vehicle)
+            .build();
+        VehicleRoute route = VehicleRoute.emptyRoute();
+        JobInsertionContext context = new JobInsertionContext(route, shipment, vehicle, null, 0);
+        context.getAssociatedActivities().add(vrp.getActivities(shipment).get(0));
+        context.getAssociatedActivities().add(vrp.getActivities(shipment).get(1));
+        maxDistanceMap = new HashMap<>();
+        maxDistanceMap.put(vehicle,10d);
+
+        StateManager stateManager = new StateManager(vrp);
+        MaxDistanceConstraint maxDistanceConstraint =
+            new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
+                @Override
+                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                }
+            },maxDistanceMap);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,
+            new Start(vehicle.getStartLocation(), 0, Double.MAX_VALUE),
+            vrp.getActivities(shipment).get(0),
+            new End(vehicle.getEndLocation(), 0, Double.MAX_VALUE),
+            0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+
+        ActivityContext pickupContext = new ActivityContext();
+        pickupContext.setArrivalTime(1);
+        pickupContext.setEndTime(1);
+        pickupContext.setInsertionIndex(0);
+        context.setRelatedActivityContext(pickupContext);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,
+            vrp.getActivities(shipment).get(0),
+            vrp.getActivities(shipment).get(1),
+            new End(vehicle.getEndLocation(), 0, Double.MAX_VALUE),
+            1).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+    }
 }
