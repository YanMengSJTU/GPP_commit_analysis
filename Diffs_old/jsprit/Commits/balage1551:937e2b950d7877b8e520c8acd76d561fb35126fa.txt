diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
index 5f514d73e..06009522e 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
@@ -18,6 +18,12 @@
 
 package com.graphhopper.jsprit.core.algorithm.box;
 
+import java.util.Collection;
+import java.util.Properties;
+import java.util.Random;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
 import com.graphhopper.jsprit.core.algorithm.PrettyAlgorithmBuilder;
 import com.graphhopper.jsprit.core.algorithm.SearchStrategy;
 import com.graphhopper.jsprit.core.algorithm.VehicleRoutingAlgorithm;
@@ -26,9 +32,26 @@
 import com.graphhopper.jsprit.core.algorithm.listener.AlgorithmEndsListener;
 import com.graphhopper.jsprit.core.algorithm.listener.IterationStartsListener;
 import com.graphhopper.jsprit.core.algorithm.module.RuinAndRecreateModule;
-import com.graphhopper.jsprit.core.algorithm.recreate.*;
-import com.graphhopper.jsprit.core.algorithm.ruin.*;
-import com.graphhopper.jsprit.core.algorithm.ruin.distance.AvgServiceAndShipmentDistance;
+import com.graphhopper.jsprit.core.algorithm.recreate.AbstractInsertionStrategy;
+import com.graphhopper.jsprit.core.algorithm.recreate.ActivityInsertionCostsCalculator;
+import com.graphhopper.jsprit.core.algorithm.recreate.BestInsertion;
+import com.graphhopper.jsprit.core.algorithm.recreate.BestInsertionConcurrent;
+import com.graphhopper.jsprit.core.algorithm.recreate.BreakScheduling;
+import com.graphhopper.jsprit.core.algorithm.recreate.DefaultScorer;
+import com.graphhopper.jsprit.core.algorithm.recreate.InsertionBuilder;
+import com.graphhopper.jsprit.core.algorithm.recreate.RegretInsertion;
+import com.graphhopper.jsprit.core.algorithm.recreate.RegretInsertionConcurrent;
+import com.graphhopper.jsprit.core.algorithm.recreate.RegretInsertionConcurrentFast;
+import com.graphhopper.jsprit.core.algorithm.recreate.RegretInsertionFast;
+import com.graphhopper.jsprit.core.algorithm.recreate.ScoringFunction;
+import com.graphhopper.jsprit.core.algorithm.ruin.JobNeighborhoods;
+import com.graphhopper.jsprit.core.algorithm.ruin.JobNeighborhoodsFactory;
+import com.graphhopper.jsprit.core.algorithm.ruin.RuinClusters;
+import com.graphhopper.jsprit.core.algorithm.ruin.RuinRadial;
+import com.graphhopper.jsprit.core.algorithm.ruin.RuinRandom;
+import com.graphhopper.jsprit.core.algorithm.ruin.RuinShareFactory;
+import com.graphhopper.jsprit.core.algorithm.ruin.RuinWorst;
+import com.graphhopper.jsprit.core.algorithm.ruin.distance.DefaultJobDistance;
 import com.graphhopper.jsprit.core.algorithm.selector.SelectBest;
 import com.graphhopper.jsprit.core.algorithm.state.StateManager;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
@@ -46,12 +69,6 @@
 import com.graphhopper.jsprit.core.util.RandomNumberGeneration;
 import com.graphhopper.jsprit.core.util.Solutions;
 
-import java.util.Collection;
-import java.util.Properties;
-import java.util.Random;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
 
 public class Jsprit {
 
@@ -67,6 +84,7 @@
             this.name = name;
         }
 
+        @Override
         public String toString() {
             return name;
         }
@@ -90,6 +108,7 @@ public String toString() {
             this.strategyName = strategyName;
         }
 
+        @Override
         public String toString() {
             return strategyName;
         }
@@ -124,9 +143,10 @@ public String toString() {
         String paraName;
 
         Parameter(String name) {
-            this.paraName = name;
+            paraName = name;
         }
 
+        @Override
         public String toString() {
             return paraName;
         }
@@ -223,7 +243,7 @@ public Builder setExecutorService(ExecutorService es, int noThreads) {
         }
 
         public Builder setCustomAcceptor(SolutionAcceptor acceptor){
-            this.solutionAcceptor = acceptor;
+            solutionAcceptor = acceptor;
             return this;
         }
 
@@ -269,7 +289,7 @@ public Builder setActivityInsertionCalculator(ActivityInsertionCostsCalculator a
         }
 
         public Builder setRegretScorer(ScoringFunction scoringFunction) {
-            this.regretScorer = scoringFunction;
+            regretScorer = scoringFunction;
             return this;
         }
 
@@ -294,15 +314,17 @@ public void setRandom(Random random) {
         }
 
         public RuinShareFactoryImpl(int minShare, int maxShare) {
-            if (maxShare < minShare)
+            if (maxShare < minShare) {
                 throw new IllegalArgumentException("maxShare must be equal or greater than minShare");
+            }
             this.minShare = minShare;
             this.maxShare = maxShare;
         }
 
         public RuinShareFactoryImpl(int minShare, int maxShare, Random random) {
-            if (maxShare < minShare)
+            if (maxShare < minShare) {
                 throw new IllegalArgumentException("maxShare must be equal or greater than minShare");
+            }
             this.minShare = minShare;
             this.maxShare = maxShare;
             this.random = random;
@@ -338,21 +360,23 @@ public int createNumberToBeRemoved() {
     private ScoringFunction regretScorer;
 
     private Jsprit(Builder builder) {
-        this.stateManager = builder.stateManager;
-        this.constraintManager = builder.constraintManager;
-        this.es = builder.es;
-        this.noThreads = builder.noThreads;
-        this.addCoreConstraints = builder.addConstraints;
-        this.properties = builder.properties;
-        this.objectiveFunction = builder.objectiveFunction;
-        this.random = builder.random;
-        this.activityInsertion = builder.activityInsertionCalculator;
-        this.acceptor = builder.solutionAcceptor;
+        stateManager = builder.stateManager;
+        constraintManager = builder.constraintManager;
+        es = builder.es;
+        noThreads = builder.noThreads;
+        addCoreConstraints = builder.addConstraints;
+        properties = builder.properties;
+        objectiveFunction = builder.objectiveFunction;
+        random = builder.random;
+        activityInsertion = builder.activityInsertionCalculator;
+        acceptor = builder.solutionAcceptor;
         regretScorer = builder.regretScorer;
     }
 
     private void ini(VehicleRoutingProblem vrp) {
-        if (regretScorer == null) regretScorer = getRegretScorer(vrp);
+        if (regretScorer == null) {
+            regretScorer = getRegretScorer(vrp);
+        }
     }
 
     private VehicleRoutingAlgorithm create(final VehicleRoutingProblem vrp) {
@@ -386,14 +410,13 @@ private VehicleRoutingAlgorithm create(final VehicleRoutingProblem vrp) {
         double noiseLevel = toDouble(getProperty(Parameter.INSERTION_NOISE_LEVEL.toString()));
         double noiseProbability = toDouble(getProperty(Parameter.INSERTION_NOISE_PROB.toString()));
 
-        JobNeighborhoods jobNeighborhoods = new JobNeighborhoodsFactory().createNeighborhoods(vrp, new AvgServiceAndShipmentDistance(vrp.getTransportCosts()), (int) (vrp.getJobs().values().size() * 0.5));
+        JobNeighborhoods jobNeighborhoods = new JobNeighborhoodsFactory().createNeighborhoods(vrp, new DefaultJobDistance(vrp.getTransportCosts()), (int) (vrp.getJobs().values().size() * 0.5));
         jobNeighborhoods.initialise();
 
         final double maxCosts;
         if(properties.containsKey(Parameter.MAX_TRANSPORT_COSTS.toString())){
             maxCosts = Double.parseDouble(getProperty(Parameter.MAX_TRANSPORT_COSTS.toString()));
-        }
-        else{
+        } else {
             maxCosts = jobNeighborhoods.getMaxDistance();
         }
 
@@ -413,44 +436,47 @@ private VehicleRoutingAlgorithm create(final VehicleRoutingProblem vrp) {
         RuinRadial radial = new RuinRadial(vrp, vrp.getJobs().size(), jobNeighborhoods);
         radial.setRandom(random);
         radial.setRuinShareFactory(new RuinShareFactoryImpl(
-                toInteger(properties.getProperty(Parameter.RADIAL_MIN_SHARE.toString())),
-                toInteger(properties.getProperty(Parameter.RADIAL_MAX_SHARE.toString())),
-                random)
-        );
+                        toInteger(properties.getProperty(Parameter.RADIAL_MIN_SHARE.toString())),
+                        toInteger(properties.getProperty(Parameter.RADIAL_MAX_SHARE.toString())),
+                        random)
+                        );
 
         final RuinRandom random_for_regret = new RuinRandom(vrp, 0.5);
         random_for_regret.setRandom(random);
         random_for_regret.setRuinShareFactory(new RuinShareFactoryImpl(
-                toInteger(properties.getProperty(Parameter.RANDOM_REGRET_MIN_SHARE.toString())),
-                toInteger(properties.getProperty(Parameter.RANDOM_REGRET_MAX_SHARE.toString())),
-                random)
-        );
+                        toInteger(properties.getProperty(Parameter.RANDOM_REGRET_MIN_SHARE.toString())),
+                        toInteger(properties.getProperty(Parameter.RANDOM_REGRET_MAX_SHARE.toString())),
+                        random)
+                        );
 
         final RuinRandom random_for_best = new RuinRandom(vrp, 0.5);
         random_for_best.setRandom(random);
         random_for_best.setRuinShareFactory(new RuinShareFactoryImpl(
-                toInteger(properties.getProperty(Parameter.RANDOM_BEST_MIN_SHARE.toString())),
-                toInteger(properties.getProperty(Parameter.RANDOM_BEST_MAX_SHARE.toString())),
-                random)
-        );
+                        toInteger(properties.getProperty(Parameter.RANDOM_BEST_MIN_SHARE.toString())),
+                        toInteger(properties.getProperty(Parameter.RANDOM_BEST_MAX_SHARE.toString())),
+                        random)
+                        );
 
         final RuinWorst worst = new RuinWorst(vrp, (int) (vrp.getJobs().values().size() * 0.5));
         worst.setRandom(random);
         worst.setRuinShareFactory(new RuinShareFactoryImpl(
-                toInteger(properties.getProperty(Parameter.WORST_MIN_SHARE.toString())),
-                toInteger(properties.getProperty(Parameter.WORST_MAX_SHARE.toString())),
-                random)
-        );
+                        toInteger(properties.getProperty(Parameter.WORST_MIN_SHARE.toString())),
+                        toInteger(properties.getProperty(Parameter.WORST_MAX_SHARE.toString())),
+                        random)
+                        );
         IterationStartsListener noise = new IterationStartsListener() {
             @Override
             public void informIterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
                 worst.setNoiseMaker(new NoiseMaker() {
 
+                    @Override
                     public double makeNoise() {
                         if (random.nextDouble() < toDouble(getProperty(Parameter.RUIN_WORST_NOISE_PROB.toString()))) {
                             return toDouble(getProperty(Parameter.RUIN_WORST_NOISE_LEVEL.toString()))
-                                * maxCosts * random.nextDouble();
-                        } else return 0.;
+                                            * maxCosts * random.nextDouble();
+                        } else {
+                            return 0.;
+                        }
                     }
                 });
             }
@@ -459,10 +485,10 @@ public double makeNoise() {
         final RuinClusters clusters = new RuinClusters(vrp, (int) (vrp.getJobs().values().size() * 0.5), jobNeighborhoods);
         clusters.setRandom(random);
         clusters.setRuinShareFactory(new RuinShareFactoryImpl(
-                toInteger(properties.getProperty(Parameter.WORST_MIN_SHARE.toString())),
-                toInteger(properties.getProperty(Parameter.WORST_MAX_SHARE.toString())),
-                random)
-        );
+                        toInteger(properties.getProperty(Parameter.WORST_MIN_SHARE.toString())),
+                        toInteger(properties.getProperty(Parameter.WORST_MAX_SHARE.toString())),
+                        random)
+                        );
 
         AbstractInsertionStrategy regret;
         final ScoringFunction scorer;
@@ -471,13 +497,13 @@ public double makeNoise() {
         if (es != null) {
             if(fastRegret){
                 RegretInsertionConcurrentFast regretInsertion = (RegretInsertionConcurrentFast) new InsertionBuilder(vrp, fm, stateManager, constraintManager)
-                    .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
-                    .setConcurrentMode(es, noThreads)
-                    .setFastRegret(true)
-                    .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                    .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                    .setActivityInsertionCostCalculator(activityInsertion)
-                    .build();
+                                .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
+                                .setConcurrentMode(es, noThreads)
+                                .setFastRegret(true)
+                                .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                                .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                                .setActivityInsertionCostCalculator(activityInsertion)
+                                .build();
                 scorer = regretScorer;
                 regretInsertion.setScoringFunction(scorer);
                 regretInsertion.setDependencyTypes(constraintManager.getDependencyTypes());
@@ -485,12 +511,12 @@ public double makeNoise() {
             }
             else {
                 RegretInsertionConcurrent regretInsertion = (RegretInsertionConcurrent) new InsertionBuilder(vrp, fm, stateManager, constraintManager)
-                    .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
-                    .setConcurrentMode(es, noThreads)
-                    .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                    .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                    .setActivityInsertionCostCalculator(activityInsertion)
-                    .build();
+                                .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
+                                .setConcurrentMode(es, noThreads)
+                                .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                                .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                                .setActivityInsertionCostCalculator(activityInsertion)
+                                .build();
                 scorer = regretScorer;
                 regretInsertion.setScoringFunction(scorer);
                 regret = regretInsertion;
@@ -498,12 +524,12 @@ public double makeNoise() {
         } else {
             if(fastRegret) {
                 RegretInsertionFast regretInsertion = (RegretInsertionFast) new InsertionBuilder(vrp, fm, stateManager, constraintManager)
-                    .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
-                    .setFastRegret(true)
-                    .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                    .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                    .setActivityInsertionCostCalculator(activityInsertion)
-                    .build();
+                                .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
+                                .setFastRegret(true)
+                                .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                                .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                                .setActivityInsertionCostCalculator(activityInsertion)
+                                .build();
                 scorer = regretScorer;
                 regretInsertion.setScoringFunction(scorer);
                 regretInsertion.setDependencyTypes(constraintManager.getDependencyTypes());
@@ -511,11 +537,11 @@ public double makeNoise() {
             }
             else{
                 RegretInsertion regretInsertion = (RegretInsertion) new InsertionBuilder(vrp, fm, stateManager, constraintManager)
-                    .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
-                    .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                    .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                    .setActivityInsertionCostCalculator(activityInsertion)
-                    .build();
+                                .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
+                                .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                                .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                                .setActivityInsertionCostCalculator(activityInsertion)
+                                .build();
                 scorer = regretScorer;
                 regretInsertion.setScoringFunction(scorer);
                 regret = regretInsertion;
@@ -526,20 +552,20 @@ public double makeNoise() {
         AbstractInsertionStrategy best;
         if (vrp.getJobs().size() < 250 || es == null) {
             BestInsertion bestInsertion = (BestInsertion) new InsertionBuilder(vrp, fm, stateManager, constraintManager)
-                .setInsertionStrategy(InsertionBuilder.Strategy.BEST)
-                .considerFixedCosts(Double.valueOf(properties.getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                .setActivityInsertionCostCalculator(activityInsertion)
-                .build();
+                            .setInsertionStrategy(InsertionBuilder.Strategy.BEST)
+                            .considerFixedCosts(Double.valueOf(properties.getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                            .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                            .setActivityInsertionCostCalculator(activityInsertion)
+                            .build();
             best = bestInsertion;
         } else {
             BestInsertionConcurrent bestInsertion = (BestInsertionConcurrent) new InsertionBuilder(vrp, fm, stateManager, constraintManager)
-                .setInsertionStrategy(InsertionBuilder.Strategy.BEST)
-                .considerFixedCosts(Double.valueOf(properties.getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                .setConcurrentMode(es, noThreads)
-                .setActivityInsertionCostCalculator(activityInsertion)
-                .build();
+                            .setInsertionStrategy(InsertionBuilder.Strategy.BEST)
+                            .considerFixedCosts(Double.valueOf(properties.getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                            .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                            .setConcurrentMode(es, noThreads)
+                            .setActivityInsertionCostCalculator(activityInsertion)
+                            .build();
             best = bestInsertion;
         }
         best.setRandom(random);
@@ -591,13 +617,13 @@ public void informIterationStarts(int i, VehicleRoutingProblem problem, Collecti
             prettyBuilder.addCoreStateAndConstraintStuff();
         }
         prettyBuilder.withStrategy(radial_regret, toDouble(getProperty(Strategy.RADIAL_REGRET.toString())))
-            .withStrategy(radial_best, toDouble(getProperty(Strategy.RADIAL_BEST.toString())))
-            .withStrategy(random_best, toDouble(getProperty(Strategy.RANDOM_BEST.toString())))
-            .withStrategy(random_regret, toDouble(getProperty(Strategy.RANDOM_REGRET.toString())))
-            .withStrategy(worst_best, toDouble(getProperty(Strategy.WORST_BEST.toString())))
-            .withStrategy(worst_regret, toDouble(getProperty(Strategy.WORST_REGRET.toString())))
-            .withStrategy(clusters_regret, toDouble(getProperty(Strategy.CLUSTER_REGRET.toString())))
-            .withStrategy(clusters_best, toDouble(getProperty(Strategy.CLUSTER_BEST.toString())));
+        .withStrategy(radial_best, toDouble(getProperty(Strategy.RADIAL_BEST.toString())))
+        .withStrategy(random_best, toDouble(getProperty(Strategy.RANDOM_BEST.toString())))
+        .withStrategy(random_regret, toDouble(getProperty(Strategy.RANDOM_REGRET.toString())))
+        .withStrategy(worst_best, toDouble(getProperty(Strategy.WORST_BEST.toString())))
+        .withStrategy(worst_regret, toDouble(getProperty(Strategy.WORST_REGRET.toString())))
+        .withStrategy(clusters_regret, toDouble(getProperty(Strategy.CLUSTER_REGRET.toString())))
+        .withStrategy(clusters_best, toDouble(getProperty(Strategy.CLUSTER_BEST.toString())));
         if (getProperty(Parameter.CONSTRUCTION.toString()).equals(Construction.BEST_INSERTION.toString())) {
             prettyBuilder.constructInitialSolutionWith(best, objectiveFunction);
         } else {
@@ -635,6 +661,7 @@ private DefaultScorer getRegretScorer(VehicleRoutingProblem vrp) {
     private void handleExecutorShutdown(VehicleRoutingAlgorithm vra) {
         if (setupExecutorInternally) {
             final Thread hook = new Thread() {
+                @Override
                 public void run() {
                     if (!es.isShutdown()) {
                         System.err.println("shutdownHook shuts down executorService");
@@ -653,17 +680,17 @@ public void informAlgorithmEnds(VehicleRoutingProblem problem, Collection<Vehicl
 
             });
         }
-//        if (es != null) {
-//
-//            Runtime.getRuntime().addShutdownHook(hook);
-//            vra.addListener(new AlgorithmEndsListener() {
-//                @Override
-//                public void informAlgorithmEnds(VehicleRoutingProblem aProblem,
-//                                                Collection<VehicleRoutingProblemSolution> aSolutions) {
-//                    Runtime.getRuntime().removeShutdownHook(hook);
-//                }
-//            });
-//        }
+        //        if (es != null) {
+        //
+        //            Runtime.getRuntime().addShutdownHook(hook);
+        //            vra.addListener(new AlgorithmEndsListener() {
+        //                @Override
+        //                public void informAlgorithmEnds(VehicleRoutingProblem aProblem,
+        //                                                Collection<VehicleRoutingProblemSolution> aSolutions) {
+        //                    Runtime.getRuntime().removeShutdownHook(hook);
+        //                }
+        //            });
+        //        }
     }
 
     String getProperty(String key) {
@@ -683,7 +710,9 @@ private double toDouble(String string) {
     }
 
     private SolutionCostCalculator getObjectiveFunction(final VehicleRoutingProblem vrp, final double maxCosts) {
-        if (objectiveFunction != null) return objectiveFunction;
+        if (objectiveFunction != null) {
+            return objectiveFunction;
+        }
 
         SolutionCostCalculator solutionCostCalculator = new SolutionCostCalculator() {
             @Override
@@ -695,7 +724,9 @@ public double getCosts(VehicleRoutingProblemSolution solution) {
                     boolean hasBreak = false;
                     TourActivity prevAct = route.getStart();
                     for (TourActivity act : route.getActivities()) {
-                        if (act instanceof BreakActivity) hasBreak = true;
+                        if (act instanceof BreakActivity) {
+                            hasBreak = true;
+                        }
                         costs += vrp.getTransportCosts().getTransportCost(prevAct.getLocation(), act.getLocation(), prevAct.getEndTime(), route.getDriver(), route.getVehicle());
                         costs += vrp.getActivityCosts().getActivityCost(act, act.getArrTime(), route.getDriver(), route.getVehicle());
                         prevAct = act;
@@ -704,8 +735,10 @@ public double getCosts(VehicleRoutingProblemSolution solution) {
                     if (route.getVehicle().getBreak() != null) {
                         if (!hasBreak) {
                             //break defined and required but not assigned penalty
-                            if (route.getEnd().getArrTime() > route.getVehicle().getBreak().getTimeWindow().getEnd()) {
-                                costs += 4 * (maxCosts * 2 + route.getVehicle().getBreak().getServiceDuration() * route.getVehicle().getType().getVehicleCostParams().perServiceTimeUnit);
+                            if (route.getEnd().getArrTime() > route.getVehicle().getBreak().getActivity().getSingleTimeWindow()
+                                            .getEnd()) {
+                                costs += 4 * (maxCosts * 2 + route.getVehicle().getBreak().getActivity().getOperationTime()
+                                                * route.getVehicle().getType().getVehicleCostParams().perServiceTimeUnit);
                             }
                         }
                     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
index fac022db8..d56074627 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
@@ -18,19 +18,20 @@
 
 package com.graphhopper.jsprit.core.problem.constraint;
 
+import java.util.Collection;
+import java.util.Map;
+
 import com.graphhopper.jsprit.core.algorithm.state.StateId;
 import com.graphhopper.jsprit.core.algorithm.state.StateManager;
 import com.graphhopper.jsprit.core.problem.cost.TransportDistance;
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliverShipment;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.AbstractActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.Start;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 
-import java.util.Collection;
-import java.util.Map;
-
 /**
  * Created by schroeder on 11/10/16.
  */
@@ -62,50 +63,66 @@ private void makeArray(Map<Vehicle, Double> maxDistances) {
     private int getMaxIndex(Collection<Vehicle> vehicles) {
         int index = 0;
         for(Vehicle v : vehicles){
-            if(v.getIndex() > index) index = v.getIndex();
+            if(v.getIndex() > index) {
+                index = v.getIndex();
+            }
         }
         return index;
     }
 
     @Override
     public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime) {
-        if(!hasMaxDistance(iFacts.getNewVehicle())) return ConstraintsStatus.FULFILLED;
+        if(!hasMaxDistance(iFacts.getNewVehicle())) {
+            return ConstraintsStatus.FULFILLED;
+        }
         Double currentDistance = 0d;
         boolean routeIsEmpty = iFacts.getRoute().isEmpty();
         if(!routeIsEmpty){
             currentDistance = stateManager.getRouteState(iFacts.getRoute(),iFacts.getNewVehicle(), distanceId,Double.class);
         }
         double maxDistance = getMaxDistance(iFacts.getNewVehicle());
-        if(currentDistance > maxDistance) return ConstraintsStatus.NOT_FULFILLED_BREAK;
+        if(currentDistance > maxDistance) {
+            return ConstraintsStatus.NOT_FULFILLED_BREAK;
+        }
 
         double distancePrevAct2NewAct = distanceCalculator.getDistance(prevAct.getLocation(), newAct.getLocation(), iFacts.getNewDepTime(), iFacts.getNewVehicle());
         double distanceNewAct2nextAct = distanceCalculator.getDistance(newAct.getLocation(), nextAct.getLocation(), iFacts.getNewDepTime(), iFacts.getNewVehicle());
         double distancePrevAct2NextAct = distanceCalculator.getDistance(prevAct.getLocation(), nextAct.getLocation(), prevActDepTime, iFacts.getNewVehicle());
-        if(prevAct instanceof Start && nextAct instanceof End) distancePrevAct2NextAct = 0;
+        if(prevAct instanceof Start && nextAct instanceof End) {
+            distancePrevAct2NextAct = 0;
+        }
         if(nextAct instanceof End && !iFacts.getNewVehicle().isReturnToDepot()){
             distanceNewAct2nextAct = 0;
             distancePrevAct2NextAct = 0;
         }
         double additionalDistance = distancePrevAct2NewAct + distanceNewAct2nextAct - distancePrevAct2NextAct;
-        if(currentDistance + additionalDistance > maxDistance) return ConstraintsStatus.NOT_FULFILLED;
+        if(currentDistance + additionalDistance > maxDistance) {
+            return ConstraintsStatus.NOT_FULFILLED;
+        }
 
 
         double additionalDistanceOfPickup = 0;
-        if(newAct instanceof DeliverShipment){
+        if (newAct instanceof DeliveryActivity && AbstractActivity.isShipment(newAct)) {
             int iIndexOfPickup = iFacts.getRelatedActivityContext().getInsertionIndex();
             TourActivity pickup = iFacts.getAssociatedActivities().get(0);
             TourActivity actBeforePickup;
-            if(iIndexOfPickup > 0) actBeforePickup = iFacts.getRoute().getActivities().get(iIndexOfPickup-1);
-            else actBeforePickup = new Start(iFacts.getNewVehicle().getStartLocation(),0,Double.MAX_VALUE);
+            if(iIndexOfPickup > 0) {
+                actBeforePickup = iFacts.getRoute().getActivities().get(iIndexOfPickup-1);
+            } else {
+                actBeforePickup = new Start(iFacts.getNewVehicle().getStartLocation(),0,Double.MAX_VALUE);
+            }
             TourActivity actAfterPickup;
-            if (iIndexOfPickup < iFacts.getRoute().getActivities().size())
+            if (iIndexOfPickup < iFacts.getRoute().getActivities().size()) {
                 actAfterPickup = iFacts.getRoute().getActivities().get(iIndexOfPickup);
-            else
+            } else {
                 actAfterPickup = nextAct;
+            }
             double distanceActBeforePickup2Pickup = distanceCalculator.getDistance(actBeforePickup.getLocation(), pickup.getLocation(), actBeforePickup.getEndTime(), iFacts.getNewVehicle());
             double distancePickup2ActAfterPickup = distanceCalculator.getDistance(pickup.getLocation(), actAfterPickup.getLocation(), iFacts.getRelatedActivityContext().getEndTime(), iFacts.getNewVehicle());
             double distanceBeforePickup2AfterPickup = distanceCalculator.getDistance(actBeforePickup.getLocation(), actAfterPickup.getLocation(), actBeforePickup.getEndTime(), iFacts.getNewVehicle());
-            if (routeIsEmpty) distanceBeforePickup2AfterPickup = 0;
+            if (routeIsEmpty) {
+                distanceBeforePickup2AfterPickup = 0;
+            }
             if (actAfterPickup instanceof End && !iFacts.getNewVehicle().isReturnToDepot()) {
                 distancePickup2ActAfterPickup = 0;
                 distanceBeforePickup2AfterPickup = 0;
@@ -122,13 +139,17 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
     }
 
     private boolean hasMaxDistance(Vehicle newVehicle){
-        if(newVehicle.getIndex() >= this.maxDistances.length) return false;
-        return this.maxDistances[newVehicle.getIndex()] != null;
+        if(newVehicle.getIndex() >= maxDistances.length) {
+            return false;
+        }
+        return maxDistances[newVehicle.getIndex()] != null;
     }
 
     private double getMaxDistance(Vehicle newVehicle) {
-        Double maxDistance = this.maxDistances[newVehicle.getIndex()];
-        if(maxDistance == null) return Double.MAX_VALUE;
+        Double maxDistance = maxDistances[newVehicle.getIndex()];
+        if(maxDistance == null) {
+            return Double.MAX_VALUE;
+        }
         return maxDistance;
     }
 }
