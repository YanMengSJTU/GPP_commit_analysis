diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
index e71996dd4..1043cb8d4 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
@@ -587,7 +587,11 @@ public void informIterationStarts(int i, VehicleRoutingProblem problem, Collecti
             acceptor = schrimpfAcceptance;
         }
 
-        SolutionCostCalculator objectiveFunction = getObjectiveFunction(vrp, maxCosts);
+        SolutionCostCalculator objectiveFunction = getObjectiveFunction();
+        if (objectiveFunction instanceof ModularSolutionCostCalculator) {
+            ((ModularSolutionCostCalculator) objectiveFunction).beforeRun(vrp, maxCosts);
+        }
+
         SearchStrategy radial_regret = new SearchStrategy(Strategy.RADIAL_REGRET.toString(), new SelectBest(), acceptor, objectiveFunction);
         radial_regret.addModule(new RuinAndRecreateModule(Strategy.RADIAL_REGRET.toString(), regret, radial));
 
@@ -711,24 +715,23 @@ private double toDouble(String string) {
         return Double.valueOf(string);
     }
 
-    private SolutionCostCalculator getObjectiveFunction(final VehicleRoutingProblem vrp, final double maxCosts) {
+    private SolutionCostCalculator getObjectiveFunction() {
         if (objectiveFunction != null) {
             return objectiveFunction;
         }
 
-        ModularSolutionCostCalculator modCalc = new ModularSolutionCostCalculator(vrp, maxCosts);
+        ModularSolutionCostCalculator modCalc = createDefaultSolutionCostCalculator();
+        return modCalc;
+    }
+
+    public static ModularSolutionCostCalculator createDefaultSolutionCostCalculator() {
+        ModularSolutionCostCalculator modCalc = new ModularSolutionCostCalculator();
         modCalc.addComponent(new FixCostPerVehicle())
         .addComponent(new MissedBreak())
         .addComponent(new TransportCost())
         .addComponent(new ActivityCost())
         .addComponent(new UnassignedJobs());
-
-        // TODO: temporal, not to do here!
-        modCalc.beforeRun();
-        modCalc.beforeSolution();
-
         return modCalc;
     }
 
-
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java
index 8cdf1babc..03f5120c4 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java
@@ -3,6 +3,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.stream.Collectors;
 
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
@@ -13,12 +14,11 @@
 
     private VehicleRoutingProblem problem;
     private Map<SolutionCostComponent, Double> components = new LinkedHashMap<>();
-    private double maxCosts;
 
-    public ModularSolutionCostCalculator(VehicleRoutingProblem problem, double maxCosts) {
+    private boolean initialized = false;
+
+    public ModularSolutionCostCalculator() {
         super();
-        this.problem = problem;
-        this.maxCosts = maxCosts;
     }
 
     public ModularSolutionCostCalculator addComponent(SolutionCostComponent component) {
@@ -42,6 +42,10 @@ public ModularSolutionCostCalculator addComponent(SolutionCostComponent componen
     }
 
     public List<ComponentValue> calculate(VehicleRoutingProblemSolution solution) {
+        if (!isInitialized()) {
+            throw new IllegalStateException("Not initialized.");
+        }
+        beforeSolution();
         return components.entrySet().stream()
                         .map(en -> en.getKey().calculateCost(problem, solution).withWeight(en.getValue()))
                         .collect(Collectors.toList());}
@@ -49,18 +53,44 @@ public ModularSolutionCostCalculator addComponent(SolutionCostComponent componen
 
     @Override
     public double getCosts(VehicleRoutingProblemSolution solution) {
+        if (!isInitialized()) {
+            throw new IllegalStateException("Not initialized.");
+        }
         return calculate(solution).stream()
                         .mapToDouble(cv -> cv.getWeightedValue())
                         .sum();
     }
 
-    public void beforeRun() {
+    public void beforeRun(VehicleRoutingProblem problem, double maxCosts) {
+        this.problem = problem;
         components.keySet().forEach(c -> c.beforeRun(problem, maxCosts));
+        initialized = true;
+    }
+
+    public boolean isInitialized() {
+        return initialized;
     }
 
-    // TODO: Is it needed and can be easily integrated?
-    public void beforeSolution() {
+    private void beforeSolution() {
         components.keySet().forEach(c -> c.beforeSolution(problem));
     }
 
+    public boolean containsComponent(String key) {
+        return components.keySet().stream().anyMatch(c -> c.getId().equals(key));
+    }
+
+    public Optional<SolutionCostComponent> findComponent(String key) {
+        return components.keySet().stream().filter(c -> c.getId().equals(key)).findAny();
+    }
+
+    public void changeComponentWeight(String key, double newWeight) {
+        findComponent(key).ifPresent(c -> components.put(c, newWeight));
+    }
+
+    public Optional<SolutionCostComponent> removeComponent(String key) {
+        Optional<SolutionCostComponent> optC = findComponent(key);
+        optC.ifPresent(c -> components.remove(c));
+        return optC;
+    }
+
 }
