diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionCalculator.java
deleted file mode 100644
index 54fee780a..000000000
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionCalculator.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import com.graphhopper.jsprit.core.problem.JobActivityFactory;
-import com.graphhopper.jsprit.core.problem.constraint.*;
-import com.graphhopper.jsprit.core.problem.constraint.HardActivityConstraint.ConstraintsStatus;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.job.Service;
-import com.graphhopper.jsprit.core.problem.misc.ActivityContext;
-import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.Start;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.Iterator;
-
-/**
- * Calculator that calculates the best insertion position for a {@link Service}.
- *
- * @author schroeder
- */
-final class ServiceInsertionCalculator implements JobInsertionCostsCalculator {
-
-    private static final Logger logger = LoggerFactory.getLogger(ServiceInsertionCalculator.class);
-
-    private HardRouteConstraint hardRouteLevelConstraint;
-
-    private HardActivityConstraint hardActivityLevelConstraint;
-
-    private SoftRouteConstraint softRouteConstraint;
-
-    private SoftActivityConstraint softActivityConstraint;
-
-    private VehicleRoutingTransportCosts transportCosts;
-
-    private final VehicleRoutingActivityCosts activityCosts;
-
-    private ActivityInsertionCostsCalculator additionalTransportCostsCalculator;
-
-    private JobActivityFactory activityFactory;
-
-    private AdditionalAccessEgressCalculator additionalAccessEgressCalculator;
-
-    public ServiceInsertionCalculator(VehicleRoutingTransportCosts routingCosts, VehicleRoutingActivityCosts activityCosts, ActivityInsertionCostsCalculator additionalTransportCostsCalculator, ConstraintManager constraintManager) {
-        super();
-        this.transportCosts = routingCosts;
-        this.activityCosts = activityCosts;
-        hardRouteLevelConstraint = constraintManager;
-        hardActivityLevelConstraint = constraintManager;
-        softActivityConstraint = constraintManager;
-        softRouteConstraint = constraintManager;
-        this.additionalTransportCostsCalculator = additionalTransportCostsCalculator;
-        additionalAccessEgressCalculator = new AdditionalAccessEgressCalculator(routingCosts);
-        logger.debug("initialise {}", this);
-    }
-
-    public void setJobActivityFactory(JobActivityFactory jobActivityFactory) {
-        this.activityFactory = jobActivityFactory;
-    }
-
-    @Override
-    public String toString() {
-        return "[name=calculatesServiceInsertion]";
-    }
-
-    /**
-     * Calculates the marginal cost of inserting job i locally. This is based on the
-     * assumption that cost changes can entirely covered by only looking at the predecessor i-1 and its successor i+1.
-     */
-    @Override
-    public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job jobToInsert, final Vehicle newVehicle, double newVehicleDepartureTime, final Driver newDriver, final double bestKnownCosts) {
-        JobInsertionContext insertionContext = new JobInsertionContext(currentRoute, jobToInsert, newVehicle, newDriver, newVehicleDepartureTime);
-        Service service = (Service) jobToInsert;
-        int insertionIndex = InsertionData.NO_INDEX;
-
-        TourActivity deliveryAct2Insert = activityFactory.createActivities(service).get(0);
-        insertionContext.getAssociatedActivities().add(deliveryAct2Insert);
-
-        /*
-        check hard constraints at route level
-         */
-        if (!hardRouteLevelConstraint.fulfilled(insertionContext)) {
-            return InsertionData.createEmptyInsertionData();
-        }
-
-        /*
-        check soft constraints at route level
-         */
-        double additionalICostsAtRouteLevel = softRouteConstraint.getCosts(insertionContext);
-
-        double bestCost = bestKnownCosts;
-        additionalICostsAtRouteLevel += additionalAccessEgressCalculator.getCosts(insertionContext);
-        TimeWindow bestTimeWindow = null;
-
-        /*
-        generate new start and end for new vehicle
-         */
-        Start start = new Start(newVehicle.getStartLocation(), newVehicle.getEarliestDeparture(), Double.MAX_VALUE);
-        start.setEndTime(newVehicleDepartureTime);
-        End end = new End(newVehicle.getEndLocation(), 0.0, newVehicle.getLatestArrival());
-
-        TourActivity prevAct = start;
-        double prevActStartTime = newVehicleDepartureTime;
-        int actIndex = 0;
-        Iterator<TourActivity> activityIterator = currentRoute.getActivities().iterator();
-        boolean tourEnd = false;
-        while (!tourEnd) {
-            TourActivity nextAct;
-            if (activityIterator.hasNext()) nextAct = activityIterator.next();
-            else {
-                nextAct = end;
-                tourEnd = true;
-            }
-            boolean not_fulfilled_break = true;
-            for (TimeWindow timeWindow : service.getTimeWindows()) {
-                deliveryAct2Insert.setTheoreticalEarliestOperationStartTime(timeWindow.getStart());
-                deliveryAct2Insert.setTheoreticalLatestOperationStartTime(timeWindow.getEnd());
-                ActivityContext activityContext = new ActivityContext();
-                activityContext.setInsertionIndex(actIndex);
-                insertionContext.setActivityContext(activityContext);
-                ConstraintsStatus status = hardActivityLevelConstraint.fulfilled(insertionContext, prevAct, deliveryAct2Insert, nextAct, prevActStartTime);
-                if (status.equals(ConstraintsStatus.FULFILLED)) {
-                    double additionalICostsAtActLevel = softActivityConstraint.getCosts(insertionContext, prevAct, deliveryAct2Insert, nextAct, prevActStartTime);
-                    double additionalTransportationCosts = additionalTransportCostsCalculator.getCosts(insertionContext, prevAct, nextAct, deliveryAct2Insert, prevActStartTime);
-                    if (additionalICostsAtRouteLevel + additionalICostsAtActLevel + additionalTransportationCosts < bestCost) {
-                        bestCost = additionalICostsAtRouteLevel + additionalICostsAtActLevel + additionalTransportationCosts;
-                        insertionIndex = actIndex;
-                        bestTimeWindow = timeWindow;
-                    }
-                    not_fulfilled_break = false;
-                } else if (status.equals(ConstraintsStatus.NOT_FULFILLED)) {
-                    not_fulfilled_break = false;
-                }
-            }
-            if (not_fulfilled_break) break;
-            double nextActArrTime = prevActStartTime + transportCosts.getTransportTime(prevAct.getLocation(), nextAct.getLocation(), prevActStartTime, newDriver, newVehicle);
-            prevActStartTime = Math.max(nextActArrTime, nextAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct, nextActArrTime, newDriver, newVehicle);
-            prevAct = nextAct;
-            actIndex++;
-        }
-        if (insertionIndex == InsertionData.NO_INDEX) {
-            return InsertionData.createEmptyInsertionData();
-        }
-        InsertionData insertionData = new InsertionData(bestCost, newVehicleDepartureTime, newVehicle, newDriver);
-        deliveryAct2Insert.setTheoreticalEarliestOperationStartTime(bestTimeWindow.getStart());
-        deliveryAct2Insert.setTheoreticalLatestOperationStartTime(bestTimeWindow.getEnd());
-        insertionData.getEvents().add(new InsertActivity(currentRoute, newVehicle, deliveryAct2Insert, insertionIndex));
-        insertionData.getEvents().add(new SwitchVehicle(currentRoute, newVehicle, newVehicleDepartureTime));
-        return insertionData;
-    }
-}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculator.java
deleted file mode 100644
index a3cd313f1..000000000
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculator.java
+++ /dev/null
@@ -1,256 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import com.graphhopper.jsprit.core.problem.JobActivityFactory;
-import com.graphhopper.jsprit.core.problem.constraint.*;
-import com.graphhopper.jsprit.core.problem.constraint.HardActivityConstraint.ConstraintsStatus;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.job.Shipment;
-import com.graphhopper.jsprit.core.problem.misc.ActivityContext;
-import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.Start;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.List;
-
-
-final class ShipmentInsertionCalculator implements JobInsertionCostsCalculator {
-
-    private static final Logger logger = LoggerFactory.getLogger(ShipmentInsertionCalculator.class);
-
-    private HardRouteConstraint hardRouteLevelConstraint;
-
-    private HardActivityConstraint hardActivityLevelConstraint;
-
-    private SoftRouteConstraint softRouteConstraint;
-
-    private SoftActivityConstraint softActivityConstraint;
-
-    private ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
-
-    private VehicleRoutingTransportCosts transportCosts;
-
-    private VehicleRoutingActivityCosts activityCosts;
-
-    private JobActivityFactory activityFactory;
-
-    private AdditionalAccessEgressCalculator additionalAccessEgressCalculator;
-
-    public ShipmentInsertionCalculator(VehicleRoutingTransportCosts routingCosts, VehicleRoutingActivityCosts activityCosts, ActivityInsertionCostsCalculator activityInsertionCostsCalculator, ConstraintManager constraintManager) {
-        super();
-        this.activityInsertionCostsCalculator = activityInsertionCostsCalculator;
-        hardRouteLevelConstraint = constraintManager;
-        hardActivityLevelConstraint = constraintManager;
-        softActivityConstraint = constraintManager;
-        softRouteConstraint = constraintManager;
-        transportCosts = routingCosts;
-        this.activityCosts = activityCosts;
-        additionalAccessEgressCalculator = new AdditionalAccessEgressCalculator(routingCosts);
-        logger.debug("initialise {}", this);
-    }
-
-    public void setJobActivityFactory(JobActivityFactory activityFactory) {
-        this.activityFactory = activityFactory;
-    }
-
-    @Override
-    public String toString() {
-        return "[name=calculatesServiceInsertion]";
-    }
-
-    /**
-     * Calculates the marginal cost of inserting job i locally. This is based on the
-     * assumption that cost changes can entirely covered by only looking at the predecessor i-1 and its successor i+1.
-     */
-    @Override
-    public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job jobToInsert, final Vehicle newVehicle, double newVehicleDepartureTime, final Driver newDriver, final double bestKnownCosts) {
-        JobInsertionContext insertionContext = new JobInsertionContext(currentRoute, jobToInsert, newVehicle, newDriver, newVehicleDepartureTime);
-        Shipment shipment = (Shipment) jobToInsert;
-        // TourActivity pickupShipment =
-        // activityFactory.createActivities(shipment).get(0);
-        // TourActivity deliverShipment =
-        // activityFactory.createActivities(shipment).get(1);
-        TourActivity pickupShipment = shipment.getActivityList().getAll().get(0);
-        TourActivity deliverShipment = shipment.getActivityList().getAll().get(1);
-        insertionContext.getAssociatedActivities().add(pickupShipment);
-        insertionContext.getAssociatedActivities().add(deliverShipment);
-
-        /*
-        check hard route constraints
-         */
-        if (!hardRouteLevelConstraint.fulfilled(insertionContext)) {
-            return InsertionData.createEmptyInsertionData();
-        }
-        /*
-        check soft route constraints
-         */
-        double additionalICostsAtRouteLevel = softRouteConstraint.getCosts(insertionContext);
-
-        double bestCost = bestKnownCosts;
-        additionalICostsAtRouteLevel += additionalAccessEgressCalculator.getCosts(insertionContext);
-
-        int pickupInsertionIndex = InsertionData.NO_INDEX;
-        int deliveryInsertionIndex = InsertionData.NO_INDEX;
-
-        TimeWindow bestPickupTimeWindow = null;
-        TimeWindow bestDeliveryTimeWindow = null;
-
-        Start start = new Start(newVehicle.getStartLocation(), newVehicle.getEarliestDeparture(), newVehicle.getLatestArrival());
-        start.setEndTime(newVehicleDepartureTime);
-
-        End end = new End(newVehicle.getEndLocation(), 0.0, newVehicle.getLatestArrival());
-
-        ActivityContext pickupContext = new ActivityContext();
-
-        TourActivity prevAct = start;
-        double prevActEndTime = newVehicleDepartureTime;
-
-        //loops
-        int i = 0;
-        boolean tourEnd = false;
-        //pickupShipmentLoop
-        List<TourActivity> activities = currentRoute.getTourActivities().getActivities();
-
-        while (!tourEnd) {
-            TourActivity nextAct;
-            if (i < activities.size()) {
-                nextAct = activities.get(i);
-            } else {
-                nextAct = end;
-                tourEnd = true;
-            }
-
-            boolean pickupInsertionNotFulfilledBreak = true;
-            for (TimeWindow pickupTimeWindow : shipment.getPickupTimeWindows()) {
-                pickupShipment.setTheoreticalEarliestOperationStartTime(pickupTimeWindow.getStart());
-                pickupShipment.setTheoreticalLatestOperationStartTime(pickupTimeWindow.getEnd());
-                ActivityContext activityContext = new ActivityContext();
-                activityContext.setInsertionIndex(i);
-                insertionContext.setActivityContext(activityContext);
-                ConstraintsStatus pickupShipmentConstraintStatus = hardActivityLevelConstraint.fulfilled(insertionContext, prevAct, pickupShipment, nextAct, prevActEndTime);
-                if (pickupShipmentConstraintStatus.equals(ConstraintsStatus.NOT_FULFILLED)) {
-                    pickupInsertionNotFulfilledBreak = false;
-                    continue;
-                } else if (pickupShipmentConstraintStatus.equals(ConstraintsStatus.NOT_FULFILLED_BREAK)) {
-                    continue;
-                } else if (pickupShipmentConstraintStatus.equals(ConstraintsStatus.FULFILLED)) {
-                    pickupInsertionNotFulfilledBreak = false;
-                }
-                double additionalPickupICosts = softActivityConstraint.getCosts(insertionContext, prevAct, pickupShipment, nextAct, prevActEndTime);
-                double pickupAIC = calculate(insertionContext, prevAct, pickupShipment, nextAct, prevActEndTime);
-
-                TourActivity prevAct_deliveryLoop = pickupShipment;
-                double shipmentPickupArrTime = prevActEndTime + transportCosts.getTransportTime(prevAct.getLocation(), pickupShipment.getLocation(), prevActEndTime, newDriver, newVehicle);
-                double shipmentPickupEndTime = Math.max(shipmentPickupArrTime, pickupShipment.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(pickupShipment, shipmentPickupArrTime, newDriver, newVehicle);
-
-                pickupContext.setArrivalTime(shipmentPickupArrTime);
-                pickupContext.setEndTime(shipmentPickupEndTime);
-                pickupContext.setInsertionIndex(i);
-                insertionContext.setRelatedActivityContext(pickupContext);
-
-                double prevActEndTime_deliveryLoop = shipmentPickupEndTime;
-
-                /*
-            --------------------------------
-                 */
-                //deliverShipmentLoop
-                int j = i;
-                boolean tourEnd_deliveryLoop = false;
-                while (!tourEnd_deliveryLoop) {
-                    TourActivity nextAct_deliveryLoop;
-                    if (j < activities.size()) {
-                        nextAct_deliveryLoop = activities.get(j);
-                    } else {
-                        nextAct_deliveryLoop = end;
-                        tourEnd_deliveryLoop = true;
-                    }
-
-                    boolean deliveryInsertionNotFulfilledBreak = true;
-                    for (TimeWindow deliveryTimeWindow : shipment.getDeliveryTimeWindows()) {
-                        deliverShipment.setTheoreticalEarliestOperationStartTime(deliveryTimeWindow.getStart());
-                        deliverShipment.setTheoreticalLatestOperationStartTime(deliveryTimeWindow.getEnd());
-                        ActivityContext activityContext_ = new ActivityContext();
-                        activityContext_.setInsertionIndex(j);
-                        insertionContext.setActivityContext(activityContext_);
-                        ConstraintsStatus deliverShipmentConstraintStatus = hardActivityLevelConstraint.fulfilled(insertionContext, prevAct_deliveryLoop, deliverShipment, nextAct_deliveryLoop, prevActEndTime_deliveryLoop);
-                        if (deliverShipmentConstraintStatus.equals(ConstraintsStatus.FULFILLED)) {
-                            double additionalDeliveryICosts = softActivityConstraint.getCosts(insertionContext, prevAct_deliveryLoop, deliverShipment, nextAct_deliveryLoop, prevActEndTime_deliveryLoop);
-                            double deliveryAIC = calculate(insertionContext, prevAct_deliveryLoop, deliverShipment, nextAct_deliveryLoop, prevActEndTime_deliveryLoop);
-                            double totalActivityInsertionCosts = pickupAIC + deliveryAIC
-                                + additionalICostsAtRouteLevel + additionalPickupICosts + additionalDeliveryICosts;
-                            if (totalActivityInsertionCosts < bestCost) {
-                                bestCost = totalActivityInsertionCosts;
-                                pickupInsertionIndex = i;
-                                deliveryInsertionIndex = j;
-                                bestPickupTimeWindow = pickupTimeWindow;
-                                bestDeliveryTimeWindow = deliveryTimeWindow;
-                            }
-                            deliveryInsertionNotFulfilledBreak = false;
-                        } else if (deliverShipmentConstraintStatus.equals(ConstraintsStatus.NOT_FULFILLED)) {
-                            deliveryInsertionNotFulfilledBreak = false;
-                        }
-                    }
-                    if (deliveryInsertionNotFulfilledBreak) {
-                        break;
-                    }
-                    //update prevAct and endTime
-                    double nextActArrTime = prevActEndTime_deliveryLoop + transportCosts.getTransportTime(prevAct_deliveryLoop.getLocation(), nextAct_deliveryLoop.getLocation(), prevActEndTime_deliveryLoop, newDriver, newVehicle);
-                    prevActEndTime_deliveryLoop = Math.max(nextActArrTime, nextAct_deliveryLoop.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct_deliveryLoop, nextActArrTime, newDriver, newVehicle);
-                    prevAct_deliveryLoop = nextAct_deliveryLoop;
-                    j++;
-                }
-            }
-            if (pickupInsertionNotFulfilledBreak) {
-                break;
-            }
-            //update prevAct and endTime
-            double nextActArrTime = prevActEndTime + transportCosts.getTransportTime(prevAct.getLocation(), nextAct.getLocation(), prevActEndTime, newDriver, newVehicle);
-            prevActEndTime = Math.max(nextActArrTime, nextAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct, nextActArrTime, newDriver, newVehicle);
-            prevAct = nextAct;
-            i++;
-        }
-        if (pickupInsertionIndex == InsertionData.NO_INDEX) {
-            return InsertionData.createEmptyInsertionData();
-        }
-        InsertionData insertionData = new InsertionData(bestCost, pickupInsertionIndex, deliveryInsertionIndex, newVehicle, newDriver);
-        pickupShipment.setTheoreticalEarliestOperationStartTime(bestPickupTimeWindow.getStart());
-        pickupShipment.setTheoreticalLatestOperationStartTime(bestPickupTimeWindow.getEnd());
-        deliverShipment.setTheoreticalEarliestOperationStartTime(bestDeliveryTimeWindow.getStart());
-        deliverShipment.setTheoreticalLatestOperationStartTime(bestDeliveryTimeWindow.getEnd());
-        insertionData.setVehicleDepartureTime(newVehicleDepartureTime);
-        insertionData.getEvents().add(new InsertActivity(currentRoute, newVehicle, deliverShipment, deliveryInsertionIndex));
-        insertionData.getEvents().add(new InsertActivity(currentRoute, newVehicle, pickupShipment, pickupInsertionIndex));
-        insertionData.getEvents().add(new SwitchVehicle(currentRoute, newVehicle, newVehicleDepartureTime));
-        return insertionData;
-    }
-
-    private double calculate(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double departureTimeAtPrevAct) {
-        return activityInsertionCostsCalculator.getCosts(iFacts, prevAct, nextAct, newAct, departureTimeAtPrevAct);
-
-    }
-}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionAndLoadConstraintsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionAndLoadConstraintsTest.java
deleted file mode 100644
index 701084f3e..000000000
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionAndLoadConstraintsTest.java
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import com.graphhopper.jsprit.core.algorithm.state.StateManager;
-import com.graphhopper.jsprit.core.problem.CopyJobActivityFactory;
-import com.graphhopper.jsprit.core.problem.JobActivityFactory;
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
-import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
-import com.graphhopper.jsprit.core.problem.constraint.HardActivityConstraint;
-import com.graphhopper.jsprit.core.problem.constraint.HardRouteConstraint;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.driver.DriverImpl;
-import com.graphhopper.jsprit.core.problem.job.Delivery;
-import com.graphhopper.jsprit.core.problem.job.Pickup;
-import com.graphhopper.jsprit.core.problem.job.Shipment;
-import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.state.RouteAndActivityStateGetter;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
-import com.graphhopper.jsprit.core.util.CostFactory;
-import org.junit.Before;
-import org.junit.Test;
-
-import java.util.Arrays;
-import java.util.List;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-
-
-public class ServiceInsertionAndLoadConstraintsTest {
-
-    VehicleRoutingTransportCosts routingCosts;
-
-    VehicleRoutingActivityCosts activityCosts = new VehicleRoutingActivityCosts() {
-
-        @Override
-        public double getActivityCost(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
-            return 0;
-        }
-
-        @Override
-        public double getActivityDuration(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
-            return tourAct.getOperationTime();
-        }
-
-    };
-
-    HardActivityConstraint hardActivityLevelConstraint = new HardActivityConstraint() {
-
-        @Override
-        public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime) {
-            return ConstraintsStatus.FULFILLED;
-        }
-    };
-
-    HardRouteConstraint hardRouteLevelConstraint = new HardRouteConstraint() {
-
-        @Override
-        public boolean fulfilled(JobInsertionContext insertionContext) {
-            return true;
-        }
-
-    };
-
-    ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
-
-    ShipmentInsertionCalculator insertionCalculator;
-
-    VehicleRoutingProblem vehicleRoutingProblem;
-
-    Vehicle vehicle;
-
-    @Before
-    public void doBefore() {
-        routingCosts = CostFactory.createManhattanCosts();
-        VehicleType type = VehicleTypeImpl.Builder.newInstance("t").addCapacityDimension(0, 2).setCostPerDistance(1).build();
-        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("0,0")).setType(type).build();
-        activityInsertionCostsCalculator = new LocalActivityInsertionCostsCalculator(routingCosts, activityCosts, mock(StateManager.class));
-        createInsertionCalculator(hardRouteLevelConstraint);
-        vehicleRoutingProblem = mock(VehicleRoutingProblem.class);
-    }
-
-    private void createInsertionCalculator(HardRouteConstraint hardRouteLevelConstraint) {
-        ConstraintManager constraintManager = new ConstraintManager(mock(VehicleRoutingProblem.class), mock(RouteAndActivityStateGetter.class));
-        constraintManager.addConstraint(hardRouteLevelConstraint);
-        insertionCalculator = new ShipmentInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
-    }
-
-    @Test
-    public void whenInsertingServiceWhileNoCapIsAvailable_itMustReturnTheCorrectInsertionIndex() {
-        Delivery delivery = new Delivery.Builder("del").addSizeDimension(0, 41).setLocation(Location.newInstance("10,10")).build();
-        Pickup pickup = new Pickup.Builder("pick").addSizeDimension(0, 15).setLocation(Location.newInstance("0,10")).build();
-
-        VehicleType type = VehicleTypeImpl.Builder.newInstance("t").addCapacityDimension(0, 50).setCostPerDistance(1).build();
-        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("0,0")).setType(type).build();
-
-        final VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(delivery).addJob(pickup).addVehicle(vehicle).build();
-
-        VehicleRoute route = VehicleRoute.emptyRoute();
-        route.setVehicleAndDepartureTime(vehicle, 0.0);
-
-        route.getTourActivities().addActivity(0, vrp.copyAndGetActivities(delivery).get(0));
-
-        JobActivityFactory activityFactory = new CopyJobActivityFactory();
-
-        StateManager stateManager = new StateManager(vrp);
-        stateManager.updateLoadStates();
-
-        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
-        constraintManager.addLoadConstraint();
-        stateManager.informInsertionStarts(Arrays.asList(route), null);
-
-        JobCalculatorSwitcher switcher = new JobCalculatorSwitcher();
-        ServiceInsertionCalculator serviceInsertionCalc = new ServiceInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
-        serviceInsertionCalc.setJobActivityFactory(activityFactory);
-        ShipmentInsertionCalculator insertionCalculator = new ShipmentInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
-        insertionCalculator.setJobActivityFactory(activityFactory);
-
-        switcher.put(Pickup.class, serviceInsertionCalc);
-        switcher.put(Delivery.class, serviceInsertionCalc);
-        switcher.put(Shipment.class, insertionCalculator);
-
-        InsertionData iData = switcher.getInsertionData(route, pickup, vehicle, 0, DriverImpl.noDriver(), Double.MAX_VALUE);
-        List<InsertActivity> insertActivities = iData.getUnmodifiableEventsByType(InsertActivity.class);
-        assertEquals(1, insertActivities.get(0).getIndex());
-    }
-
-}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculatorTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculatorTest.java
deleted file mode 100644
index c94566608..000000000
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculatorTest.java
+++ /dev/null
@@ -1,316 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import com.graphhopper.jsprit.core.algorithm.state.StateManager;
-import com.graphhopper.jsprit.core.problem.JobActivityFactory;
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
-import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
-import com.graphhopper.jsprit.core.problem.constraint.HardRouteConstraint;
-import com.graphhopper.jsprit.core.problem.constraint.PickupAndDeliverShipmentLoadActivityLevelConstraint;
-import com.graphhopper.jsprit.core.problem.constraint.ShipmentPickupsFirstConstraint;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.driver.DriverImpl;
-import com.graphhopper.jsprit.core.problem.job.Pickup;
-import com.graphhopper.jsprit.core.problem.job.Service;
-import com.graphhopper.jsprit.core.problem.job.Shipment;
-import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.state.RouteAndActivityStateGetter;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
-import com.graphhopper.jsprit.core.util.CostFactory;
-
-
-public class ShipmentInsertionCalculatorTest {
-
-    VehicleRoutingTransportCosts routingCosts;
-
-    VehicleRoutingProblem vehicleRoutingProblem;
-
-    VehicleRoutingActivityCosts activityCosts = new VehicleRoutingActivityCosts() {
-
-        @Override
-        public double getActivityCost(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
-            return 0;
-        }
-
-        @Override
-        public double getActivityDuration(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
-            return tourAct.getOperationTime();
-        }
-
-    };
-
-    HardRouteConstraint hardRouteLevelConstraint = new HardRouteConstraint() {
-
-        @Override
-        public boolean fulfilled(JobInsertionContext insertionContext) {
-            return true;
-        }
-
-    };
-
-    ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
-
-    ShipmentInsertionCalculator insertionCalculator;
-
-    Vehicle vehicle;
-
-    @Before
-    public void doBefore() {
-        routingCosts = CostFactory.createManhattanCosts();
-        VehicleType type = VehicleTypeImpl.Builder.newInstance("t").addCapacityDimension(0, 2).setCostPerDistance(1).build();
-        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("0,0")).setType(type).build();
-        activityInsertionCostsCalculator = new LocalActivityInsertionCostsCalculator(routingCosts, activityCosts, mock(StateManager.class));
-        createInsertionCalculator(hardRouteLevelConstraint);
-        vehicleRoutingProblem = mock(VehicleRoutingProblem.class);
-    }
-
-    private void createInsertionCalculator(HardRouteConstraint hardRouteLevelConstraint) {
-        ConstraintManager constraintManager = new ConstraintManager(mock(VehicleRoutingProblem.class), mock(RouteAndActivityStateGetter.class));
-        constraintManager.addConstraint(hardRouteLevelConstraint);
-        insertionCalculator = new ShipmentInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
-    }
-
-    @Test
-    public void whenCalculatingInsertionCostsOfShipment_itShouldReturnCorrectCostValue() {
-        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
-        VehicleRoute route = VehicleRoute.emptyRoute();
-        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
-        List<JobActivity> activities = new ArrayList<>();
-        activities.add(shipment.getPickupActivity());
-        activities.add(shipment.getDeliveryActivity());
-        when(activityFactory.createActivities(shipment)).thenReturn(activities);
-        insertionCalculator.setJobActivityFactory(activityFactory);
-        InsertionData iData = insertionCalculator.getInsertionData(route, shipment, vehicle, 0.0, null, Double.MAX_VALUE);
-        assertEquals(40.0, iData.getInsertionCost(), 0.05);
-    }
-
-    @Test
-    public void whenCalculatingInsertionIntoExistingRoute_itShouldReturnCorrectCosts() {
-        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
-        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
-        VehicleRoute route = VehicleRoute.emptyRoute();
-        List<JobActivity> tourActivities = shipment.getActivityList().getAll();
-        route.setVehicleAndDepartureTime(vehicle, 0);
-        add(tourActivities, route, 0, 0);
-
-        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
-        List<JobActivity> activities = new ArrayList<>();
-        activities.add(shipment.getPickupActivity());
-        activities.add(shipment.getDeliveryActivity());
-        when(activityFactory.createActivities(shipment2)).thenReturn(activities);
-        insertionCalculator.setJobActivityFactory(activityFactory);
-
-        InsertionData iData = insertionCalculator.getInsertionData(route, shipment2, vehicle, 0.0, null, Double.MAX_VALUE);
-        assertEquals(0.0, iData.getInsertionCost(), 0.05);
-        assertEquals(1, iData.getUnmodifiableEventsByType(InsertActivity.class).get(1).getIndex());
-        assertEquals(2, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-
-    @Test
-    public void whenInsertingShipmentInRouteWithNotEnoughCapacity_itShouldReturnNoInsertion() {
-        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
-        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
-        VehicleRoute route = VehicleRoute.emptyRoute();
-        List<JobActivity> tourActivities = shipment.getActivityList().getAll();
-        route.setVehicleAndDepartureTime(vehicle, 0);
-        add(tourActivities, route, 0, 0);
-
-        createInsertionCalculator(insertionContext -> false);
-
-        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
-        List<JobActivity> activities = new ArrayList<JobActivity>();
-        activities.add(shipment2.getPickupActivity());
-        activities.add(shipment2.getDeliveryActivity());
-        when(activityFactory.createActivities(shipment2)).thenReturn(activities);
-        insertionCalculator.setJobActivityFactory(activityFactory);
-
-        InsertionData iData = insertionCalculator.getInsertionData(route, shipment2, vehicle, 0.0, null, Double.MAX_VALUE);
-        assertEquals(InsertionData.createEmptyInsertionData(), iData);
-
-    }
-
-
-    @Test
-    public void whenInsertingThirdShipment_itShouldCalcCorrectVal() {
-        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
-        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
-        Shipment shipment3 = Shipment.Builder.newInstance("s3").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("9,10")).build();
-
-        VehicleRoute route = VehicleRoute.emptyRoute();
-        List<JobActivity> shipmentActivities = shipment.getActivityList().getAll();
-        List<JobActivity> shipment2Activities = shipment2.getActivityList().getAll();
-
-        route.setVehicleAndDepartureTime(vehicle, 0d);
-        add(shipmentActivities, route, 0, 0);
-        add(shipment2Activities, route, 1, 2);
-
-        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
-        List<JobActivity> activities = new ArrayList<>();
-        activities.add(shipment3.getPickupActivity());
-        activities.add(shipment3.getDeliveryActivity());
-        when(activityFactory.createActivities(shipment3)).thenReturn(activities);
-        insertionCalculator.setJobActivityFactory(activityFactory);
-
-        InsertionData iData = insertionCalculator.getInsertionData(route, shipment3, vehicle, 0.0, null, Double.MAX_VALUE);
-        assertEquals(0.0, iData.getInsertionCost(), 0.05);
-        List<InsertActivity> unmodifiableEventsByType = iData.getUnmodifiableEventsByType(InsertActivity.class);
-        assertEquals(1, unmodifiableEventsByType.get(0).getIndex());
-        assertEquals(0, unmodifiableEventsByType.get(1).getIndex());
-    }
-
-    @Test
-    public void whenInsertingThirdShipment_itShouldCalcCorrectVal2() {
-        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
-        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
-        Shipment shipment3 = Shipment.Builder.newInstance("s3").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("9,9")).build();
-        List<JobActivity> shipmentActivities = shipment.getActivityList().getAll();
-        List<JobActivity> shipment2Activities = shipment2.getActivityList().getAll();
-        VehicleRoute route = VehicleRoute.emptyRoute();
-
-        route.setVehicleAndDepartureTime(vehicle, 0d);
-        add(shipmentActivities, route, 0, 0);
-        add(shipment2Activities, route, 1, 2);
-
-        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
-        List<JobActivity> activities = new ArrayList<>();
-        activities.add(shipment3.getPickupActivity());
-        activities.add(shipment3.getDeliveryActivity());
-        when(activityFactory.createActivities(shipment3)).thenReturn(activities);
-        insertionCalculator.setJobActivityFactory(activityFactory);
-
-
-        InsertionData iData = insertionCalculator.getInsertionData(route, shipment3, vehicle, 0.0, null, Double.MAX_VALUE);
-        assertEquals(2.0, iData.getInsertionCost(), 0.05);
-        assertEquals(0, iData.getUnmodifiableEventsByType(InsertActivity.class).get(1).getIndex());
-        assertEquals(1, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-    @Test
-    public void whenInstertingShipmentWithLoadConstraintWhereCapIsNotSufficient_capConstraintsAreFulfilled() {
-        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
-        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
-        Shipment shipment3 = Shipment.Builder.newInstance("s3").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("9,9")).build();
-
-        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
-        VehicleRoutingProblem vrp = vrpBuilder.addJob(shipment).addJob(shipment2).addJob(shipment3).build();
-
-        VehicleRoute route = VehicleRoute.emptyRoute();
-        route.setVehicleAndDepartureTime(vehicle, 0.0);
-
-        add(vrp, route, shipment, 0, 0);
-        add(vrp, route, shipment2, 1, 2);
-
-        StateManager stateManager = new StateManager(vrp);
-        stateManager.updateLoadStates();
-        stateManager.informInsertionStarts(Arrays.asList(route), null);
-
-        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
-        constraintManager.addConstraint(new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager), ConstraintManager.Priority.CRITICAL);
-        constraintManager.addConstraint(new ShipmentPickupsFirstConstraint(), ConstraintManager.Priority.CRITICAL);
-
-        ShipmentInsertionCalculator insertionCalculator = new ShipmentInsertionCalculator(routingCosts, activityCosts,
-                        activityInsertionCostsCalculator, constraintManager);
-        insertionCalculator.setJobActivityFactory(vrp.getJobActivityFactory());
-
-        InsertionData iData = insertionCalculator.getInsertionData(route, shipment3, vehicle, 0.0, DriverImpl.noDriver(), Double.MAX_VALUE);
-        assertTrue(iData instanceof InsertionData.NoInsertionFound);
-
-    }
-
-    @Test
-    public void whenInsertingServiceWhileNoCapIsAvailable_itMustReturnNoInsertionData() {
-        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
-        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
-
-        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
-        VehicleRoutingProblem vrp = vrpBuilder.addJob(shipment).addJob(shipment2).build();
-
-        VehicleRoute route = VehicleRoute.emptyRoute();
-        route.setVehicleAndDepartureTime(vehicle, 0.0);
-
-        add(vrp, route, shipment, 0, 0);
-        add(vrp, route, shipment2, 1, 2);
-
-        StateManager stateManager = new StateManager(vrp);
-        stateManager.updateLoadStates();
-        stateManager.informInsertionStarts(Arrays.asList(route), null);
-
-        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
-        constraintManager.addLoadConstraint();
-
-        stateManager.informInsertionStarts(Arrays.asList(route), null);
-
-        JobCalculatorSwitcher switcher = new JobCalculatorSwitcher();
-        ServiceInsertionCalculator serviceInsertionCalc = new ServiceInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
-        ShipmentInsertionCalculator insertionCalculator = new ShipmentInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
-        switcher.put(Pickup.class, serviceInsertionCalc);
-        switcher.put(Service.class, serviceInsertionCalc);
-        switcher.put(Shipment.class, insertionCalculator);
-
-        //		Service service = new Service.Builder("pick", 1).setLocationId("5,5").build();
-        Pickup service = new Pickup.Builder("pick").addSizeDimension(0, 1).setLocation(Location.newInstance("5,5")).build();
-
-        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
-        List<JobActivity> activities = new ArrayList<>();
-        activities.add(service.getServiceActivity());
-        when(activityFactory.createActivities(service)).thenReturn(activities);
-        insertionCalculator.setJobActivityFactory(activityFactory);
-        serviceInsertionCalc.setJobActivityFactory(activityFactory);
-
-        InsertionData iData = switcher.getInsertionData(route, service, vehicle, 0, DriverImpl.noDriver(), Double.MAX_VALUE);
-        //		routeActVisitor.visit(route);
-
-        assertEquals(3, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-    private void add(VehicleRoutingProblem vrp, VehicleRoute route, Shipment shipment, int pickI, int delI) {
-        List<JobActivity> shipmentActivities = vrp.copyAndGetActivities(shipment);
-        route.getTourActivities().addActivity(delI, shipmentActivities.get(1));
-        route.getTourActivities().addActivity(pickI, shipmentActivities.get(0));
-    }
-
-    private void add(List<JobActivity> shipmentActivities, VehicleRoute route, int pickI, int delI) {
-        route.getTourActivities().addActivity(delI, shipmentActivities.get(1));
-        route.getTourActivities().addActivity(pickI, shipmentActivities.get(0));
-    }
-
-
-}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertion.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertion.java
deleted file mode 100644
index 9f38aa06d..000000000
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertion.java
+++ /dev/null
@@ -1,255 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import com.graphhopper.jsprit.core.algorithm.state.StateManager;
-import com.graphhopper.jsprit.core.distance.EuclideanDistanceCalculator;
-import com.graphhopper.jsprit.core.distance.ManhattanDistanceCalculator;
-import com.graphhopper.jsprit.core.problem.CopyJobActivityFactory;
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
-import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
-import com.graphhopper.jsprit.core.problem.cost.AbstractForwardVehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.driver.DriverImpl;
-import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.job.Service;
-import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
-import com.graphhopper.jsprit.core.util.Coordinate;
-import com.graphhopper.jsprit.core.util.Locations;
-import org.junit.Before;
-import org.junit.Test;
-
-import java.util.*;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-
-
-public class TestCalculatesServiceInsertion {
-
-    ServiceInsertionCalculator serviceInsertion;
-
-    VehicleRoutingTransportCosts costs;
-
-    VehicleImpl vehicle;
-
-    VehicleImpl newVehicle;
-
-    private Service first;
-
-    private Service third;
-
-    private Service second;
-
-    private StateManager states;
-
-    private DriverImpl.NoDriver driver;
-
-    private VehicleRoutingProblem vrp;
-
-    @Before
-    public void setup() {
-
-        VehicleType t1 = VehicleTypeImpl.Builder.newInstance("t1").addCapacityDimension(0, 1000).setCostPerDistance(1.0).build();
-        vehicle = VehicleImpl.Builder.newInstance("vehicle").setLatestArrival(100.0).setStartLocation(Location.newInstance("0,0")).setType(t1).build();
-
-        VehicleType t2 = VehicleTypeImpl.Builder.newInstance("t2").addCapacityDimension(0, 1000).setCostPerDistance(2.0).build();
-        newVehicle = VehicleImpl.Builder.newInstance("newVehicle").setLatestArrival(100.0).setStartLocation(Location.newInstance("0,0")).setType(t2).build();
-
-        driver = DriverImpl.noDriver();
-
-        final Locations locations = new Locations() {
-
-            @Override
-            public Coordinate getCoord(String id) {
-                //assume: locationId="x,y"
-                String[] splitted = id.split(",");
-                return Coordinate.newInstance(Double.parseDouble(splitted[0]),
-                    Double.parseDouble(splitted[1]));
-            }
-
-        };
-        costs = new AbstractForwardVehicleRoutingTransportCosts() {
-
-            @Override
-            public double getTransportTime(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-                return ManhattanDistanceCalculator.getInstance().calculateDistance(
-                    locations.getCoord(from.getId()), locations.getCoord(to.getId()));
-            }
-
-            @Override
-            public double getTransportCost(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-                return vehicle.getType().getVehicleCostParams().perDistanceUnit
-                    * ManhattanDistanceCalculator.getInstance().calculateDistance(
-                    locations.getCoord(from.getId()),
-                    locations.getCoord(to.getId()));
-            }
-        };
-
-
-        first = new Service.Builder("1").addSizeDimension(0, 0).setLocation(Location.newInstance("0,10")).setTimeWindow(TimeWindow.newInstance(0.0, 100.0)).build();
-        second = new Service.Builder("2").addSizeDimension(0, 0).setLocation(Location.newInstance("10,10")).setTimeWindow(TimeWindow.newInstance(0.0, 100.0)).build();
-        third = new Service.Builder("3").addSizeDimension(0, 0).setLocation(Location.newInstance("10,0")).setTimeWindow(TimeWindow.newInstance(0.0, 100.0)).build();
-
-        Collection<Job> jobs = new ArrayList<Job>();
-        jobs.add(first);
-        jobs.add(third);
-        jobs.add(second);
-
-        vrp = VehicleRoutingProblem.Builder.newInstance().addAllJobs(jobs)
-            .addVehicle(vehicle).setRoutingCost(costs).build();
-
-        states = new StateManager(vrp);
-        states.updateLoadStates();
-        states.updateTimeWindowStates();
-
-
-        ConstraintManager cManager = new ConstraintManager(vrp, states);
-        cManager.addLoadConstraint();
-        cManager.addTimeWindowConstraint();
-
-        VehicleRoutingActivityCosts actCosts = mock(VehicleRoutingActivityCosts.class);
-
-        serviceInsertion = new ServiceInsertionCalculator(costs, vrp.getActivityCosts(), new LocalActivityInsertionCostsCalculator(costs, actCosts, states), cManager);
-        serviceInsertion.setJobActivityFactory(new CopyJobActivityFactory());
-    }
-
-    @Test
-    public void whenInsertingTheFirstJobInAnEmptyTourWithVehicle_itCalculatesMarginalCostChanges() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).build();
-        states.informInsertionStarts(Arrays.asList(route), null);
-
-        InsertionData iData = serviceInsertion.getInsertionData(route, first, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
-        assertEquals(20.0, iData.getInsertionCost(), 0.2);
-        assertEquals(0, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-    @Test
-    public void whenInsertingTheSecondJobInAnNonEmptyTourWithVehicle_itCalculatesMarginalCostChanges() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).build();
-        states.informInsertionStarts(Arrays.asList(route), null);
-
-        InsertionData iData = serviceInsertion.getInsertionData(route, third, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
-        assertEquals(20.0, iData.getInsertionCost(), 0.2);
-        assertEquals(0, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-    @Test
-    public void whenInsertingThirdJobWithVehicle_itCalculatesMarginalCostChanges() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).addService(third).build();
-        states.informInsertionStarts(Arrays.asList(route), null);
-
-        InsertionData iData = serviceInsertion.getInsertionData(route, second, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
-        assertEquals(0.0, iData.getInsertionCost(), 0.2);
-        assertEquals(1, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-    @Test
-    public void whenInsertingThirdJobWithNewVehicle_itCalculatesMarginalCostChanges() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).addService(third).build();
-        states.informInsertionStarts(Arrays.asList(route), null);
-
-        InsertionData iData = serviceInsertion.getInsertionData(route, second, newVehicle, newVehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
-        assertEquals(40.0, iData.getInsertionCost(), 0.2);
-        assertEquals(1, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-    @Test
-    public void whenInsertingASecondJobWithAVehicle_itCalculatesLocalMarginalCostChanges() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).addService(second).build();
-        states.informInsertionStarts(Arrays.asList(route), null);
-
-        InsertionData iData = serviceInsertion.getInsertionData(route, third, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
-        assertEquals(0.0, iData.getInsertionCost(), 0.2);
-        assertEquals(2, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-    @Test
-    public void whenInsertingASecondJobWithANewVehicle_itCalculatesLocalMarginalCostChanges() {
-
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).addService(second).build();
-
-        states.informInsertionStarts(Arrays.asList(route), null);
-
-        InsertionData iData = serviceInsertion.getInsertionData(route, third, newVehicle, newVehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
-        assertEquals(50.0, iData.getInsertionCost(), 0.2);
-        assertEquals(2, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-    @Test
-    public void whenInsertingJobAndCurrRouteIsEmpty_accessEggressCalcShouldReturnZero() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(VehicleImpl.createNoVehicle(), DriverImpl.noDriver()).build();
-        AdditionalAccessEgressCalculator accessEgressCalc = new AdditionalAccessEgressCalculator(costs);
-        Job job = new Service.Builder("1").addSizeDimension(0, 0).setLocation(Location.newInstance("1")).setTimeWindow(TimeWindow.newInstance(0.0, 100.0)).build();
-        JobInsertionContext iContex = new JobInsertionContext(route, job, newVehicle, mock(Driver.class), 0.0);
-        assertEquals(0.0, accessEgressCalc.getCosts(iContex), 0.01);
-    }
-
-    @Test
-    public void whenInsertingJobAndCurrRouteAndVehicleHaveTheSameLocation_accessEggressCalcShouldReturnZero() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(newVehicle, DriverImpl.noDriver())
-            .addService(first)
-            .build();
-
-        AdditionalAccessEgressCalculator accessEgressCalc = new AdditionalAccessEgressCalculator(costs);
-        JobInsertionContext iContex = new JobInsertionContext(route, first, newVehicle, mock(Driver.class), 0.0);
-        assertEquals(0.0, accessEgressCalc.getCosts(iContex), 0.01);
-    }
-
-    @Test
-    public void whenInsertingJobAndCurrRouteAndNewVehicleHaveDifferentLocations_accessEggressCostsMustBeCorrect() {
-        final Map<String, Coordinate> coords = new HashMap<String, Coordinate>();
-        coords.put("oldV", Coordinate.newInstance(1, 0));
-        coords.put("newV", Coordinate.newInstance(5, 0));
-        coords.put("service", Coordinate.newInstance(0, 0));
-
-        AbstractForwardVehicleRoutingTransportCosts routingCosts = new AbstractForwardVehicleRoutingTransportCosts() {
-
-            @Override
-            public double getTransportTime(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-                return getTransportCost(from, to, departureTime, driver, vehicle);
-            }
-
-            @Override
-            public double getTransportCost(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-                return EuclideanDistanceCalculator.getInstance().calculateDistance(coords.get(from.getId()), coords.get(to.getId()));
-            }
-        };
-        Vehicle oldVehicle = VehicleImpl.Builder.newInstance("oldV").setStartLocation(Location.newInstance("oldV")).build();
-
-        VehicleRoute route = VehicleRoute.Builder.newInstance(oldVehicle, DriverImpl.noDriver())
-            .addService(new Service.Builder("service").addSizeDimension(0, 0).setLocation(Location.newInstance("service")).build())
-            .build();
-
-        Vehicle newVehicle = VehicleImpl.Builder.newInstance("newV").setStartLocation(Location.newInstance("newV")).build();
-
-        AdditionalAccessEgressCalculator accessEgressCalc = new AdditionalAccessEgressCalculator(routingCosts);
-        Job job = new Service.Builder("service2").addSizeDimension(0, 0).setLocation(Location.newInstance("service")).build();
-        JobInsertionContext iContex = new JobInsertionContext(route, job, newVehicle, mock(Driver.class), 0.0);
-        assertEquals(8.0, accessEgressCalc.getCosts(iContex), 0.01);
-    }
-}
