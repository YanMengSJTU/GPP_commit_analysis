diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractListBackedJobActivityList.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractListBackedJobActivityList.java
new file mode 100644
index 000000000..0774b6e8b
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractListBackedJobActivityList.java
@@ -0,0 +1,66 @@
+package com.graphhopper.jsprit.core.problem.job;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
+
+/**
+ * Simple activity list implementation.
+ * <p>
+ * The inserted activities will define an sequential order.
+ * </p>
+ *
+ * @author balage
+ *
+ */
+public abstract class AbstractListBackedJobActivityList extends JobActivityList {
+
+    /**
+     * The primary container.
+     */
+    protected List<JobActivity> _activities = new ArrayList<>();
+    /**
+     * A read only container backed by the primary one. This will be returned.
+     */
+    protected List<JobActivity> unmodifiableActivities = Collections.unmodifiableList(_activities);
+
+    public AbstractListBackedJobActivityList(AbstractJob job) {
+        super(job);
+    }
+
+    @Override
+    public void addActivity(JobActivity activity) {
+        validateActivity(activity);
+        if (!_activities.contains(activity)) {
+            _activities.add(activity);
+        }
+    }
+
+    @Override
+    public int size() {
+        return _activities.size();
+    }
+
+    @Override
+    public List<JobActivity> getAll() {
+        return unmodifiableActivities;
+    }
+
+    /**
+     * @param activity
+     *            The activity to be found.
+     * @return The index of the activity in the sequential row.
+     * @throws IllegalArgumentException
+     *             When the activity is not in the queue.
+     */
+    protected int indexOf(JobActivity activity) {
+        int idx = _activities.indexOf(activity);
+        if (idx == -1) {
+            throw new IllegalArgumentException("Activity " + activity.getName() + " is not in the list.");
+        }
+        return idx;
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/GraphJobActivityList.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/GraphJobActivityList.java
index 34cac36da..e102e362e 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/GraphJobActivityList.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/GraphJobActivityList.java
@@ -1,8 +1,12 @@
 package com.graphhopper.jsprit.core.problem.job;
 
+import java.util.ArrayDeque;
+import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Deque;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.stream.Collectors;
@@ -18,10 +22,12 @@
  * @author balage
  *
  */
-public class GraphJobActivityList extends SequentialJobActivityList {
+public class GraphJobActivityList extends AbstractListBackedJobActivityList {
 
+    // Directly added dependencies
     protected Map<JobActivity, Set<JobActivity>> dependencies = new HashMap<>();
 
+    // Cached transitive dependencies
     protected Map<JobActivity, Set<JobActivity>> transitivePrecedingDependencyCache = new HashMap<>();
     protected Map<JobActivity, Set<JobActivity>> transitiveSubsequentDependencyCache = new HashMap<>();
 
@@ -31,16 +37,23 @@ public GraphJobActivityList(AbstractJob job) {
 
     @Override
     public void addActivity(JobActivity activity) {
-        validateActivity(activity);
-        if (_activities.contains(activity)) {
-            return;
-        }
-        _activities.add(activity);
+        super.addActivity(activity);
         dependencies.put(activity, new HashSet<JobActivity>());
         transitivePrecedingDependencyCache.put(activity, new HashSet<JobActivity>());
         transitiveSubsequentDependencyCache.put(activity, new HashSet<JobActivity>());
     }
 
+    /**
+     * Adds a dependency between two activities. If the activities not in the list, they are also added.
+     *
+     * @param priorActivity
+     *            The prior activity.
+     * @param subsequentActivity
+     *            The subsequent activity.
+     * @throws IllegalArgumentException
+     *             If the activities can't be added (see {@linkplain #addActivity(JobActivity)}) or if the new
+     *             dependency would create a cycle in the dependency graph.
+     */
     public void addDependency(JobActivity priorActivity, JobActivity subsequentActivity) {
         // Add activities if not added yet
         if (!_activities.contains(priorActivity)) {
@@ -56,7 +69,7 @@ public void addDependency(JobActivity priorActivity, JobActivity subsequentActiv
 
         // Check if the new dependency would create a cycle
         if (transitiveSubsequentDependencyCache.get(subsequentActivity).contains(priorActivity)) {
-            throw new IllegalArgumentException("Dependency between '"+priorActivity+"' and '"+subsequentActivity+"' would create a cycle.");
+            throw new IllegalArgumentException("Dependency between '" + priorActivity + "' and '" + subsequentActivity + "' would create a cycle.");
         }
 
         // Add new dependency
@@ -103,11 +116,16 @@ public void addDependency(JobActivity priorActivity, JobActivity subsequentActiv
         return Collections.unmodifiableSet(transitiveSubsequentDependencyCache.get(activity));
     }
 
+    /**
+     * Just for presentation purposes. It is too verbose for toString.
+     */
     public void printDetailed() {
         StringBuilder sb = new StringBuilder();
+        sb.append("------------------------------\n");
         sb.append("DIRECT DEPENDENCIES\n");
         sb.append(dependencies.entrySet().stream()
                 .flatMap(en -> en.getValue().stream().map(sa -> en.getKey().getName() + " -> " + sa.getName()))
+                .sorted()
                 .collect(Collectors.joining("\n")));
         sb.append("\nTRANSITIVE PRECEDING DEPENDENCIES\n");
         sb.append(transitivePrecedingDependencyCache.entrySet().stream()
@@ -124,11 +142,78 @@ public void printDetailed() {
                         .sorted()
                         .collect(Collectors.joining(", ")))
                 .collect(Collectors.joining("\n")));
+        sb.append("\nTOPOLOGICAL ORDERINGS\n");
+        sb.append(getPossibleOrderings().stream()
+                .sorted((l1, l2) -> {
+                    for (int i = 0; i < l1.size(); i++) {
+                        if (l1.get(i).equals(l2.get(i))) {
+                            continue;
+                        }
+                        return l1.get(i).getName().compareTo(l2.get(i).getName());
+                    }
+                    return 0;
+                })
+                .map(e -> e.stream().map(a -> a.getName()).collect(Collectors.joining(", ")))
+                .collect(Collectors.joining("\n")));
 
         System.out.println(sb.toString());
     }
 
+    @Override
+    public Set<List<JobActivity>> getPossibleOrderings() {
+        Set<List<JobActivity>> orderings = new HashSet<>();
+        boolean visited[] = new boolean[_activities.size()];
+        Deque<JobActivity> partialOrder = new ArrayDeque<>();
+        int indegree[] = new int[_activities.size()];
+        for (int i = 0; i < _activities.size(); i++) {
+            JobActivity act = _activities.get(i);
+            indegree[i] = (int) dependencies.entrySet().stream()
+                    .flatMap(en -> en.getValue().stream())
+                    .filter(a -> a.equals(act))
+                    .count();
+        }
+        allTopologicalSort(orderings, partialOrder, visited, indegree);
+        return orderings;
+    }
 
+    /**
+     * Recursive function for collection all possible topological orderings.
+     *
+     * <p>
+     * <i>Migrated from the original C++ source of
+     * <a href="http://www.geeksforgeeks.org/all-topological-sorts-of-a-directed-acyclic-graph/">Utkarsh Trivedi</a>
+     * .</i>
+     * </p>
+     *
+     * @param orderings
+     *            The list of found orderings.
+     * @param partialOrder
+     *            The partial ordering under construction.
+     * @param visited
+     *            Markers on the already visited nodes.
+     * @param indegree
+     *            Dependency level of the nodes.
+     */
+    private void allTopologicalSort(Set<List<JobActivity>> orderings, Deque<JobActivity> partialOrder, boolean[] visited, int[] indegree) {
+        boolean flag = false;
+        for (int i = 0; i < _activities.size(); i++) {
+            JobActivity act = _activities.get(i);
+            if (indegree[i] == 0 && !visited[i]) {
+                dependencies.get(act).forEach(ra -> indegree[indexOf(ra)]--);
+                partialOrder.addLast(act);
+                visited[i] = true;
+                allTopologicalSort(orderings, partialOrder, visited, indegree);
+
+                visited[i] = false;
+                partialOrder.removeLast();
+                dependencies.get(act).forEach(ra -> indegree[indexOf(ra)]++);
+                flag = true;
+            }
+        }
 
+        if (!flag) {
+            orderings.add(new ArrayList<>(partialOrder));
+        }
+    }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/JobActivityList.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/JobActivityList.java
index 8e5565529..d6904272d 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/JobActivityList.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/JobActivityList.java
@@ -100,4 +100,9 @@ protected void validateActivity(JobActivity activity) {
         return acts;
     }
 
+    /**
+     * @return Returns all possible orderings.
+     */
+    public abstract Set<List<JobActivity>> getPossibleOrderings();
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/SequentialJobActivityList.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/SequentialJobActivityList.java
index 0d13913c4..678d4eeb8 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/SequentialJobActivityList.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/SequentialJobActivityList.java
@@ -1,7 +1,5 @@
 package com.graphhopper.jsprit.core.problem.job;
 
-import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -17,52 +15,12 @@
  * @author balage
  *
  */
-public class SequentialJobActivityList extends JobActivityList {
-
-    /**
-     * The primary container.
-     */
-    protected List<JobActivity> _activities = new ArrayList<>();
-    /**
-     * A read only container backed by the primary one. This will be returned.
-     */
-    protected List<JobActivity> unmodifiableActivities = Collections.unmodifiableList(_activities);
+public class SequentialJobActivityList extends AbstractListBackedJobActivityList {
 
     public SequentialJobActivityList(AbstractJob job) {
         super(job);
     }
 
-    @Override
-    public void addActivity(JobActivity activity) {
-        validateActivity(activity);
-        _activities.add(activity);
-    }
-
-    @Override
-    public int size() {
-        return _activities.size();
-    }
-
-    @Override
-    public List<JobActivity> getAll() {
-        return unmodifiableActivities;
-    }
-
-    /**
-     * @param activity
-     *            The activity to be found.
-     * @return The index of the activity in the sequential row.
-     * @throws IllegalArgumentException
-     *             When the activity is not in the queue.
-     */
-    private int indexOf(JobActivity activity) {
-        int idx = _activities.indexOf(activity);
-        if (idx == -1) {
-            throw new IllegalArgumentException("Activity " + activity.getName() + " is not in the list.");
-        }
-        return idx;
-    }
-
     @Override
     public Set<JobActivity> getPreceding(JobActivity activity) {
         return new HashSet<>(unmodifiableActivities.subList(0, indexOf(activity)));
@@ -73,4 +31,12 @@ private int indexOf(JobActivity activity) {
         return new HashSet<>(unmodifiableActivities.subList(indexOf(activity), unmodifiableActivities.size()));
     }
 
+    @Override
+    public Set<List<JobActivity>> getPossibleOrderings() {
+        Set<List<JobActivity>> res = new HashSet<List<JobActivity>>();
+        res.add(unmodifiableActivities);
+        return res;
+    }
+
+
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/GraphJobActivityListTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/GraphJobActivityListTest.java
index 2a5fff90d..b4fa1e46a 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/GraphJobActivityListTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/GraphJobActivityListTest.java
@@ -154,7 +154,7 @@ public void complexTest() {
         assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actC));
         assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actD));
         assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actE));
-
+        list.printDetailed();
 
         list.addDependency(actB, actE);
         assertEquals(setOf(), list.transitivePrecedingDependencyCache.get(actA));
@@ -167,6 +167,7 @@ public void complexTest() {
         assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actC));
         assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actD));
         assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actE));
+        list.printDetailed();
 
         list.addDependency(actC, actD);
         assertEquals(setOf(), list.transitivePrecedingDependencyCache.get(actA));
@@ -179,6 +180,7 @@ public void complexTest() {
         assertEquals(setOf(actD), list.transitiveSubsequentDependencyCache.get(actC));
         assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actD));
         assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actE));
+        list.printDetailed();
 
         list.addDependency(actD, actE);
         assertEquals(setOf(), list.transitivePrecedingDependencyCache.get(actA));
@@ -192,8 +194,7 @@ public void complexTest() {
         assertEquals(setOf(actE), list.transitiveSubsequentDependencyCache.get(actD));
         assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actE));
 
+        list.printDetailed();
     }
 
-
-
 }
