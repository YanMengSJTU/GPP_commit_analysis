diff --git a/.travis.settings.xml b/.travis.settings.xml
new file mode 100644
index 000000000..fd37913ec
--- /dev/null
+++ b/.travis.settings.xml
@@ -0,0 +1,27 @@
+<!--
+  ~ Licensed to GraphHopper GmbH under one or more contributor
+  ~ license agreements. See the NOTICE file distributed with this work for
+  ~ additional information regarding copyright ownership.
+  ~
+  ~ GraphHopper GmbH licenses this file to you under the Apache License,
+  ~ Version 2.0 (the "License"); you may not use this file except in
+  ~ compliance with the License. You may obtain a copy of the License at
+  ~
+  ~       http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">
+    <servers>
+        <server>
+            <id>packagecloud-graphhopper</id>
+            <password>${env.PACKAGECLOUD_TOKEN}</password>
+        </server>
+    </servers>
+</settings>
diff --git a/.travis.yml b/.travis.yml
index 2406cbd9d..40e6f9fc1 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -4,3 +4,20 @@ jdk:
   - oraclejdk7
   - oraclejdk8
 
+deploy:
+  provider: script
+  script: "cp .travis.settings.xml $HOME/.m2/settings.xml && mvn deploy"
+  skip_cleanup: true
+  on:
+    tags: true
+
+# do not install anything instead return true via unix command true
+install: true
+script: mvn clean test
+notifications:
+  email:
+    - github@graphhopper.com
+
+# enable container-based stack
+sudo: false
+
diff --git a/README.md b/README.md
index 4255b26f3..1bf8726cf 100644
--- a/README.md
+++ b/README.md
@@ -17,7 +17,7 @@ It is lightweight, flexible and easy-to-use, and based on a single all-purpose [
 - Various combination of these types
 
 Setting up the problem, defining additional constraints, modifying the algorithms and visualising the discovered solutions is as easy and handy as
-reading classical VRP instances to benchmark your algorithm. It is fit for change and extension due to a modular design and a comprehensive set of unit and integration-tests. [More features ...](../docs/Features.textile)
+reading classical VRP instances to benchmark your algorithm. It is fit for change and extension due to a modular design and a comprehensive set of unit and integration-tests. [More features ...](https://github.com/graphhopper/jsprit/blob/master/docs/Features.textile)
 
 ## Getting Started with Documentation
 Please visit [docs](https://github.com/graphhopper/jsprit/blob/master/docs/Home.md) to learn more.The best way to get to know jsprit is by looking at [code examples](https://github.com/graphhopper/jsprit/tree/master/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples).
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/VehicleRoutingAlgorithm.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/VehicleRoutingAlgorithm.java
index 7bdeae780..1155955bd 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/VehicleRoutingAlgorithm.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/VehicleRoutingAlgorithm.java
@@ -35,6 +35,8 @@
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
 
 
 /**
@@ -57,9 +59,8 @@ void addTermination(PrematureAlgorithmTermination termination) {
         @Override
         public boolean isPrematureBreak(DiscoveredSolution discoveredSolution) {
             for (PrematureAlgorithmTermination termination : terminationCriteria) {
-                if (termination.isPrematureBreak(discoveredSolution)) {
+                if (termination.isPrematureBreak(discoveredSolution))
                     return true;
-                }
             }
             return false;
         }
@@ -140,30 +141,36 @@ public VehicleRoutingAlgorithm(VehicleRoutingProblem problem, SearchStrategyMana
      * @param solution the solution to be added
      */
     public void addInitialSolution(VehicleRoutingProblemSolution solution) {
+        // We will make changes so let's make a copy
+        solution = VehicleRoutingProblemSolution.copyOf(solution);
         verify(solution);
         initialSolutions.add(solution);
     }
 
     private void verify(VehicleRoutingProblemSolution solution) {
-        int nuJobs = 0;
+        Set<Job> allJobs = new HashSet<Job>(problem.getJobs().values());
+        allJobs.removeAll(solution.getUnassignedJobs());
         for (VehicleRoute route : solution.getRoutes()) {
-            nuJobs += route.getTourActivities().getJobs().size();
+            allJobs.removeAll(route.getTourActivities().getJobs());
             if (route.getVehicle().getIndex() == 0)
                 throw new IllegalStateException("vehicle used in initial solution has no index. probably a vehicle is used that has not been added to the " +
                     " the VehicleRoutingProblem. only use vehicles that have already been added to the problem.");
             for (TourActivity act : route.getActivities()) {
-                if (act.getIndex() == 0) {
+                if (act.getIndex() == 0)
                     throw new IllegalStateException("act in initial solution has no index. activities are created and associated to their job in VehicleRoutingProblem\n." +
                         " thus if you build vehicle-routes use the jobActivityFactory from vehicle routing problem like that \n" +
                         " VehicleRoute.Builder.newInstance(knownVehicle).setJobActivityFactory(vrp.getJobActivityFactory).addService(..)....build() \n" +
                         " then the activities that are created to build the route are identical to the ones used in VehicleRoutingProblem");
-                }
             }
         }
-//        if (nuJobs != problem.getJobs().values().size()) {
-//            logger.warn("number of jobs in initial solution ({}) is not equal nuJobs in vehicle routing problem ({})" +
-//                "\n this might yield unintended effects, e.g. initial solution cannot be improved anymore.", nuJobs, problem.getJobs().values().size());
-//        }
+
+        solution.getUnassignedJobs().addAll(allJobs);
+        solution.setCost(getObjectiveFunction().getCosts(solution));
+
+        //        if (nuJobs != problem.getJobs().values().size()) {
+        //            logger.warn("number of jobs in initial solution ({}) is not equal nuJobs in vehicle routing problem ({})" +
+        //                "\n this might yield unintended effects, e.g. initial solution cannot be improved anymore.", nuJobs, problem.getJobs().values().size());
+        //        }
     }
 
     /**
@@ -214,7 +221,9 @@ public SearchStrategyManager getSearchStrategyManager() {
         Collection<VehicleRoutingProblemSolution> solutions = new ArrayList<VehicleRoutingProblemSolution>(initialSolutions);
         algorithmStarts(problem, solutions);
         bestEver = Solutions.bestOf(solutions);
-        if (logger.isTraceEnabled()) log(solutions);
+        if (logger.isTraceEnabled()) {
+            log(solutions);
+        }
         logger.info("iterations start");
         for (int i = 0; i < maxIterations; i++) {
             iterationStarts(i + 1, problem, solutions);
@@ -222,7 +231,9 @@ public SearchStrategyManager getSearchStrategyManager() {
             counter.incCounter();
             SearchStrategy strategy = searchStrategyManager.getRandomStrategy();
             DiscoveredSolution discoveredSolution = strategy.run(problem, solutions);
-            if (logger.isTraceEnabled()) log(discoveredSolution);
+            if (logger.isTraceEnabled()) {
+                log(discoveredSolution);
+            }
             memorizeIfBestEver(discoveredSolution);
             selectedStrategy(discoveredSolution, problem, solutions);
             if (terminationManager.isPrematureBreak(discoveredSolution)) {
@@ -240,11 +251,15 @@ public SearchStrategyManager getSearchStrategyManager() {
     }
 
     private void addBestEver(Collection<VehicleRoutingProblemSolution> solutions) {
-        if (bestEver != null) solutions.add(bestEver);
+        if (bestEver != null) {
+            solutions.add(bestEver);
+        }
     }
 
     private void log(Collection<VehicleRoutingProblemSolution> solutions) {
-        for (VehicleRoutingProblemSolution sol : solutions) log(sol);
+        for (VehicleRoutingProblemSolution sol : solutions) {
+            log(sol);
+        }
     }
 
     private void log(VehicleRoutingProblemSolution solution) {
@@ -277,9 +292,11 @@ private void log(DiscoveredSolution discoveredSolution) {
 
     private void memorizeIfBestEver(DiscoveredSolution discoveredSolution) {
         if (discoveredSolution == null) return;
-        if (bestEver == null) bestEver = discoveredSolution.getSolution();
-        else if (discoveredSolution.getSolution().getCost() < bestEver.getCost())
+        if (bestEver == null) {
+            bestEver = discoveredSolution.getSolution();
+        } else if (discoveredSolution.getSolution().getCost() < bestEver.getCost()) {
             bestEver = discoveredSolution.getSolution();
+        }
     }
 
 
@@ -297,10 +314,12 @@ public VehicleRoutingAlgorithmListeners getAlgorithmListeners() {
 
     public void addListener(VehicleRoutingAlgorithmListener l) {
         algoListeners.addListener(l);
-        if (l instanceof SearchStrategyListener)
+        if (l instanceof SearchStrategyListener) {
             searchStrategyManager.addSearchStrategyListener((SearchStrategyListener) l);
-        if (l instanceof SearchStrategyModuleListener)
+        }
+        if (l instanceof SearchStrategyModuleListener) {
             searchStrategyManager.addSearchStrategyModuleListener((SearchStrategyModuleListener) l);
+        }
     }
 
     private void iterationEnds(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/acceptor/SchrimpfAcceptance.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/acceptor/SchrimpfAcceptance.java
index f89960b09..f104a1cad 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/acceptor/SchrimpfAcceptance.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/acceptor/SchrimpfAcceptance.java
@@ -25,7 +25,9 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.ArrayList;
 import java.util.Collection;
+import java.util.List;
 
 
 /**
@@ -78,7 +80,6 @@
 
     private final int solutionMemory;
 
-
     public SchrimpfAcceptance(int solutionMemory, double alpha) {
         this.alpha = alpha;
         this.solutionMemory = solutionMemory;
@@ -110,6 +111,32 @@ public boolean acceptSolution(Collection<VehicleRoutingProblemSolution> solution
         return solutionAccepted;
     }
 
+    public boolean acceptSolution(VehicleRoutingProblemSolution solution, VehicleRoutingProblemSolution newSolution) {
+        List<VehicleRoutingProblemSolution> solutions = new ArrayList<>();
+        solutions.add(solution);
+        boolean solutionAccepted = false;
+        if (solutions.size() < solutionMemory) {
+            solutions.add(newSolution);
+            solutionAccepted = true;
+        } else {
+            VehicleRoutingProblemSolution worst = null;
+            double threshold = getThreshold(currentIteration);
+            for (VehicleRoutingProblemSolution solutionInMemory : solutions) {
+                if (worst == null) worst = solutionInMemory;
+                else if (solutionInMemory.getCost() > worst.getCost()) worst = solutionInMemory;
+            }
+            if (worst == null) {
+                solutions.add(newSolution);
+                solutionAccepted = true;
+            } else if (newSolution.getCost() < worst.getCost() + threshold) {
+                solutions.remove(worst);
+                solutions.add(newSolution);
+                solutionAccepted = true;
+            }
+        }
+        return solutionAccepted;
+    }
+
     @Override
     public String toString() {
         return "[name=SchrimpfAcceptance][alpha=" + alpha + "]";
@@ -136,6 +163,16 @@ public void setInitialThreshold(double initialThreshold) {
         this.initialThreshold = initialThreshold;
     }
 
+    public void setMaxIterations(int maxIteration) {
+        this.maxIterations = maxIteration;
+    }
+
+    public void incIteration() {
+        currentIteration++;
+    }
+
+    ;
+
     @Override
     public void informAlgorithmStarts(VehicleRoutingProblem problem, VehicleRoutingAlgorithm algorithm, Collection<VehicleRoutingProblemSolution> solutions) {
         reset();
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AccordingToPriorities.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AccordingToPriorities.java
new file mode 100644
index 000000000..928e41a82
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AccordingToPriorities.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.graphhopper.jsprit.core.algorithm.recreate;
+
+import com.graphhopper.jsprit.core.problem.job.Job;
+
+import java.util.Comparator;
+
+/**
+ * Created by schroeder on 30/06/17.
+ */
+class AccordingToPriorities implements Comparator<Job> {
+
+    @Override
+    public int compare(Job o1, Job o2) {
+        return o1.getPriority() - o2.getPriority();
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertion.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertion.java
index 329a05ffb..576e41f48 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertion.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertion.java
@@ -24,7 +24,10 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
 
 
 /**
@@ -63,7 +66,7 @@ public String toString() {
         List<Job> badJobs = new ArrayList<Job>(unassignedJobs.size());
         List<Job> unassignedJobList = new ArrayList<Job>(unassignedJobs);
         Collections.shuffle(unassignedJobList, random);
-        sometimesSortPriorities(unassignedJobList);
+        Collections.sort(unassignedJobList, new AccordingToPriorities());
         for (Job unassignedJob : unassignedJobList) {
             Insertion bestInsertion = null;
             InsertionData empty = new InsertionData.NoInsertionFound();
@@ -98,16 +101,4 @@ public String toString() {
         return badJobs;
     }
 
-
-    private void sometimesSortPriorities(List<Job> unassignedJobList) {
-        if(random.nextDouble() < 0.5){
-            Collections.sort(unassignedJobList, new Comparator<Job>() {
-                @Override
-                public int compare(Job o1, Job o2) {
-                    return o1.getPriority() - o2.getPriority();
-                }
-            });
-        }
-    }
-
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertionConcurrent.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertionConcurrent.java
index 2b014df08..c7e6ae945 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertionConcurrent.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertionConcurrent.java
@@ -27,7 +27,10 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
 import java.util.concurrent.*;
 
 
@@ -99,7 +102,7 @@ public String toString() {
         List<Job> badJobs = new ArrayList<Job>(unassignedJobs.size());
         List<Job> unassignedJobList = new ArrayList<Job>(unassignedJobs);
         Collections.shuffle(unassignedJobList, random);
-        sometimesSortPriorities(unassignedJobList);
+        Collections.sort(unassignedJobList, new AccordingToPriorities());
         List<Batch> batches = distributeRoutes(vehicleRoutes, nuOfBatches);
         List<String> failedConstraintNames = new ArrayList<>();
         for (final Job unassignedJob : unassignedJobList) {
@@ -149,16 +152,6 @@ public Insertion call() throws Exception {
         return badJobs;
     }
 
-    private void sometimesSortPriorities(List<Job> unassignedJobList) {
-        if(random.nextDouble() < 0.5){
-            Collections.sort(unassignedJobList, new Comparator<Job>() {
-                @Override
-                public int compare(Job o1, Job o2) {
-                    return o1.getPriority() - o2.getPriority();
-                }
-            });
-        }
-    }
 
     private Insertion getBestInsertion(Batch batch, Job unassignedJob) {
         Insertion bestInsertion = null;
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicle.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicle.java
new file mode 100644
index 000000000..cd80bc26d
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicle.java
@@ -0,0 +1,247 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.graphhopper.jsprit.core.algorithm.state;
+
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.cost.TransportTime;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
+import com.graphhopper.jsprit.core.problem.job.Job;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.*;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+
+import java.util.*;
+
+/**
+ * Created by schroeder on 15/09/16.
+ */
+public class UpdateMaxTimeInVehicle implements StateUpdater, ActivityVisitor{
+
+    private Map<Integer,Map<Job,Double>> openPickupEndTimes = new HashMap<>();
+
+    private Map<Integer,Map<TourActivity,Double>> slackTimes = new HashMap<>();
+
+    private Map<Integer,Map<TourActivity,Double>> actStartTimes = new HashMap<>();
+
+    private VehicleRoute route;
+
+    private final StateManager stateManager;
+
+    private final StateId latestStartId;
+
+    private double[] prevActEndTimes;
+
+    private Location[] prevActLocations;
+
+    private Collection<Vehicle> vehicles;
+
+    private final TransportTime transportTime;
+
+    private final VehicleRoutingActivityCosts activityCosts;
+
+    private UpdateVehicleDependentPracticalTimeWindows.VehiclesToUpdate vehiclesToUpdate = new UpdateVehicleDependentPracticalTimeWindows.VehiclesToUpdate() {
+
+        @Override
+        public Collection<Vehicle> get(VehicleRoute route) {
+            return Arrays.asList(route.getVehicle());
+        }
+
+    };
+
+
+    public UpdateMaxTimeInVehicle(StateManager stateManager, StateId slackTimeId, TransportTime transportTime, VehicleRoutingActivityCosts activityCosts) {
+        this.stateManager = stateManager;
+        this.latestStartId = slackTimeId;
+        this.transportTime = transportTime;
+        prevActEndTimes = new double[stateManager.getMaxIndexOfVehicleTypeIdentifiers() + 1];
+        prevActLocations = new Location[stateManager.getMaxIndexOfVehicleTypeIdentifiers() + 1];
+        this.activityCosts = activityCosts;
+    }
+
+
+    public void setVehiclesToUpdate(UpdateVehicleDependentPracticalTimeWindows.VehiclesToUpdate vehiclesToUpdate) {
+        this.vehiclesToUpdate = vehiclesToUpdate;
+    }
+
+
+    @Override
+    public void begin(VehicleRoute route) {
+        openPickupEndTimes.clear();
+        slackTimes.clear();
+        actStartTimes.clear();
+        vehicles = vehiclesToUpdate.get(route);
+        this.route = route;
+        for(Vehicle v : vehicles){
+            int vehicleIndex = v.getVehicleTypeIdentifier().getIndex();
+            openPickupEndTimes.put(vehicleIndex,new HashMap<Job, Double>());
+            slackTimes.put(vehicleIndex,new HashMap<TourActivity, Double>());
+            actStartTimes.put(vehicleIndex,new HashMap<TourActivity, Double>());
+            prevActEndTimes[vehicleIndex] = v.getEarliestDeparture();
+            prevActLocations[vehicleIndex] = v.getStartLocation();
+        }
+    }
+
+    @Override
+    public void visit(TourActivity activity) {
+        double maxTime = getMaxTimeInVehicle(activity);
+
+        for(Vehicle v : vehicles) {
+            int vehicleIndex = v.getVehicleTypeIdentifier().getIndex();
+            Location prevActLocation = prevActLocations[vehicleIndex];
+            double prevActEndTime = prevActEndTimes[v.getVehicleTypeIdentifier().getIndex()];
+            double activityArrival = prevActEndTimes[v.getVehicleTypeIdentifier().getIndex()] + transportTime.getTransportTime(prevActLocation,activity.getLocation(),prevActEndTime,route.getDriver(),v);
+            double activityStart = Math.max(activityArrival,activity.getTheoreticalEarliestOperationStartTime());
+            memorizeActStart(activity,v,activityStart);
+            double activityEnd = activityStart + activityCosts.getActivityDuration(activity, activityArrival, route.getDriver(), v);
+            Map<Job, Double> openPickups = openPickupEndTimes.get(vehicleIndex);
+            if (activity instanceof ServiceActivity || activity instanceof PickupActivity) {
+                openPickups.put(((TourActivity.JobActivity) activity).getJob(), activityEnd);
+            } else if (activity instanceof DeliveryActivity) {
+                Job job = ((TourActivity.JobActivity) activity).getJob();
+                double pickupEnd;
+                if (openPickups.containsKey(job)) {
+                    pickupEnd = openPickups.get(job);
+                    openPickups.remove(job);
+                } else pickupEnd = v.getEarliestDeparture();
+                double slackTime = maxTime - (activityStart - pickupEnd);
+                slackTimes.get(vehicleIndex).put(activity, slackTime);
+            }
+            prevActLocations[vehicleIndex] = activity.getLocation();
+            prevActEndTimes[vehicleIndex] = activityEnd;
+        }
+
+    }
+
+    private double getMaxTimeInVehicle(TourActivity activity) {
+        double maxTime = Double.MAX_VALUE;
+        if(activity instanceof TourActivity.JobActivity){
+            maxTime = ((TourActivity.JobActivity) activity).getJob().getMaxTimeInVehicle();
+        }
+        return maxTime;
+    }
+
+//    private double getMaxTimeInVehicle(String jobId) {
+//        double maxTime = Double.MAX_VALUE;
+//        if(maxTimes.containsKey(jobId)){
+//            maxTime = maxTimes.get(jobId);
+//        }
+//        return maxTime;
+//    }
+
+    private void memorizeActStart(TourActivity activity, Vehicle v, double activityStart) {
+        actStartTimes.get(v.getVehicleTypeIdentifier().getIndex()).put(activity,activityStart);
+    }
+
+    @Override
+    public void finish() {
+        for(Vehicle v : vehicles) {
+            int vehicleIndex = v.getVehicleTypeIdentifier().getIndex();
+
+            //!!! open routes !!!
+            double routeEnd;
+            if(!v.isReturnToDepot()) routeEnd = prevActEndTimes[vehicleIndex];
+            else routeEnd = prevActEndTimes[vehicleIndex] + transportTime.getTransportTime(prevActLocations[vehicleIndex],v.getEndLocation(),prevActEndTimes[vehicleIndex],route.getDriver(),v);
+
+            Map<String, Double> openDeliveries = new HashMap<>();
+            for (Job job : openPickupEndTimes.get(vehicleIndex).keySet()) {
+                double actEndTime = openPickupEndTimes.get(vehicleIndex).get(job);
+                double slackTime = job.getMaxTimeInVehicle() - (routeEnd - actEndTime);
+                openDeliveries.put(job.getId(), slackTime);
+            }
+
+            double minSlackTimeAtEnd = minSlackTime(openDeliveries);
+            stateManager.putRouteState(route, v, latestStartId, routeEnd + minSlackTimeAtEnd);
+            List<TourActivity> acts = new ArrayList<>(this.route.getActivities());
+            Collections.reverse(acts);
+            for (TourActivity act : acts) {
+                if (act instanceof ServiceActivity || act instanceof PickupActivity) {
+                    String jobId = ((TourActivity.JobActivity) act).getJob().getId();
+                    openDeliveries.remove(jobId);
+                    double minSlackTime = minSlackTime(openDeliveries);
+                    double latestStart = actStart(act, v) + minSlackTime;
+                    stateManager.putActivityState(act, v, latestStartId, latestStart);
+                } else {
+                    String jobId = ((TourActivity.JobActivity) act).getJob().getId();
+                    if(slackTimes.get(vehicleIndex).containsKey(act)){
+                        double slackTime = slackTimes.get(vehicleIndex).get(act);
+                        openDeliveries.put(jobId,slackTime);
+                    }
+                    double minSlackTime = minSlackTime(openDeliveries);
+                    double latestStart = actStart(act, v) + minSlackTime;
+                    stateManager.putActivityState(act, v, latestStartId, latestStart);
+                }
+            }
+        }
+    }
+
+    public void finish(List<TourActivity> activities, Job ignore) {
+        for (Vehicle v : vehicles) {
+            int vehicleIndex = v.getVehicleTypeIdentifier().getIndex();
+
+            //!!! open routes !!!
+            double routeEnd;
+            if (!v.isReturnToDepot()) routeEnd = prevActEndTimes[vehicleIndex];
+            else
+                routeEnd = prevActEndTimes[vehicleIndex] + transportTime.getTransportTime(prevActLocations[vehicleIndex], v.getEndLocation(), prevActEndTimes[vehicleIndex], route.getDriver(), v);
+
+            Map<String, Double> openDeliveries = new HashMap<>();
+            for (Job job : openPickupEndTimes.get(vehicleIndex).keySet()) {
+                if (job == ignore) continue;
+                double actEndTime = openPickupEndTimes.get(vehicleIndex).get(job);
+                double slackTime = job.getMaxTimeInVehicle() - (routeEnd - actEndTime);
+                openDeliveries.put(job.getId(), slackTime);
+            }
+
+            double minSlackTimeAtEnd = minSlackTime(openDeliveries);
+            stateManager.putRouteState(route, v, latestStartId, routeEnd + minSlackTimeAtEnd);
+            List<TourActivity> acts = new ArrayList<>(activities);
+            Collections.reverse(acts);
+            for (TourActivity act : acts) {
+                if (act instanceof ServiceActivity || act instanceof PickupActivity) {
+                    String jobId = ((TourActivity.JobActivity) act).getJob().getId();
+                    openDeliveries.remove(jobId);
+                    double minSlackTime = minSlackTime(openDeliveries);
+                    double latestStart = actStart(act, v) + minSlackTime;
+                    stateManager.putActivityState(act, v, latestStartId, latestStart);
+                } else {
+                    String jobId = ((TourActivity.JobActivity) act).getJob().getId();
+                    if (slackTimes.get(vehicleIndex).containsKey(act)) {
+                        double slackTime = slackTimes.get(vehicleIndex).get(act);
+                        openDeliveries.put(jobId, slackTime);
+                    }
+                    double minSlackTime = minSlackTime(openDeliveries);
+                    double latestStart = actStart(act, v) + minSlackTime;
+                    stateManager.putActivityState(act, v, latestStartId, latestStart);
+                }
+            }
+        }
+    }
+
+    private double actStart(TourActivity act, Vehicle v) {
+        return actStartTimes.get(v.getVehicleTypeIdentifier().getIndex()).get(act);
+    }
+
+    private double minSlackTime(Map<String, Double> openDeliveries) {
+        double min = Double.MAX_VALUE;
+        for(Double value : openDeliveries.values()){
+           if(value < min) min = value;
+        }
+        return min;
+    }
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/VehicleDependentTraveledDistance.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/VehicleDependentTraveledDistance.java
index bde4058b8..4fa68ca79 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/VehicleDependentTraveledDistance.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/VehicleDependentTraveledDistance.java
@@ -63,7 +63,7 @@ public double getDistance() {
 
     private List<Vehicle> uniqueVehicles;
 
-    private Map<VehicleTypeKey,State> states;
+    private Map<VehicleTypeKey, State> states;
 
     public VehicleDependentTraveledDistance(TransportDistance transportCostMatrices, StateManager stateManager, StateId distanceInRouteId, Collection<Vehicle> vehicles) {
         this.transportDistance = transportCostMatrices;
@@ -75,8 +75,8 @@ public VehicleDependentTraveledDistance(TransportDistance transportCostMatrices,
     private List<Vehicle> getUniqueVehicles(Collection<Vehicle> vehicles) {
         Set<VehicleTypeKey> types = new HashSet<>();
         List<Vehicle> uniqueVehicles = new ArrayList<>();
-        for(Vehicle v : vehicles){
-            if(!types.contains(v.getVehicleTypeIdentifier())){
+        for (Vehicle v : vehicles) {
+            if (!types.contains(v.getVehicleTypeIdentifier())) {
                 types.add(v.getVehicleTypeIdentifier());
                 uniqueVehicles.add(v);
             }
@@ -88,32 +88,32 @@ public VehicleDependentTraveledDistance(TransportDistance transportCostMatrices,
     public void begin(VehicleRoute route) {
         this.route = route;
         states = new HashMap<>();
-        for(Vehicle v : uniqueVehicles){
-            State state = new State(v.getStartLocation(),0);
-            states.put(v.getVehicleTypeIdentifier(),state);
+        for (Vehicle v : uniqueVehicles) {
+            State state = new State(v.getStartLocation(), 0);
+            states.put(v.getVehicleTypeIdentifier(), state);
         }
     }
 
     @Override
     public void visit(TourActivity activity) {
-        for(Vehicle v : uniqueVehicles){
+        for (Vehicle v : uniqueVehicles) {
             State old = states.get(v.getVehicleTypeIdentifier());
             double distance = old.getDistance();
-            distance += transportDistance.getDistance(old.getPrevLocation(),activity.getLocation(),0,v);
-            stateManager.putActivityState(activity,v,traveledDistanceId,distance);
-            states.put(v.getVehicleTypeIdentifier(),new State(activity.getLocation(),distance));
+            distance += transportDistance.getDistance(old.getPrevLocation(), activity.getLocation(), 0, v);
+            stateManager.putActivityState(activity, v, traveledDistanceId, distance);
+            states.put(v.getVehicleTypeIdentifier(), new State(activity.getLocation(), distance));
         }
     }
 
     @Override
     public void finish() {
-        for(Vehicle v : uniqueVehicles){
+        for (Vehicle v : uniqueVehicles) {
             State old = states.get(v.getVehicleTypeIdentifier());
             double distance = old.getDistance();
-            if(v.isReturnToDepot()) {
+            if (v.isReturnToDepot()) {
                 distance += transportDistance.getDistance(old.getPrevLocation(), v.getEndLocation(), 0, v);
             }
-            stateManager.putRouteState(route,v,traveledDistanceId, distance);
+            stateManager.putRouteState(route, v, traveledDistanceId, distance);
         }
     }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/termination/VariationCoefficientTermination.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/termination/VariationCoefficientTermination.java
index 5e900b358..5f177c3d6 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/termination/VariationCoefficientTermination.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/termination/VariationCoefficientTermination.java
@@ -30,7 +30,9 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.ArrayList;
 import java.util.Collection;
+import java.util.List;
 
 
 /**
@@ -119,9 +121,22 @@ public void informIterationEnds(int i, VehicleRoutingProblem problem, Collection
         }
     }
 
+    public void informIterationEnds(int i, VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution) {
+        informIterationEnds(i, problem, toList(solution));
+    }
+
+    private List<VehicleRoutingProblemSolution> toList(VehicleRoutingProblemSolution solution) {
+        List<VehicleRoutingProblemSolution> solutions = new ArrayList<>();
+        solutions.add(solution);
+        return solutions;
+    }
+
     @Override
     public void informIterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
         if (lastAccepted == null) lastAccepted = Solutions.bestOf(solutions);
     }
 
+    public void informIterationStarts(int i, VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution) {
+        informIterationStarts(i, problem, toList(solution));
+    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/AbstractVehicle.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/AbstractVehicle.java
index c8f69d2b5..4f614e04c 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/AbstractVehicle.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/AbstractVehicle.java
@@ -45,35 +45,35 @@ public void setIndex(int index) {
 
     private VehicleTypeKey vehicleIdentifier;
 
-	private Object userData;
+    private Object userData;
 
-	/**
-	 * @return User-specific domain data associated with the vehicle
-	 */
-	@Override
+    /**
+     * @return User-specific domain data associated with the vehicle
+     */
+    @Override
     public Object getUserData() {
-		return userData;
-	}
-
-	protected void setUserData(Object userData) {
-		this.userData = userData;
-	}
-
-	@Override
-	public int getIndex() {
-		return index;
-	}
-
-	protected void setIndex(int index) {
-		this.index = index;
-	}
-
-	@Override
-	public VehicleTypeKey getVehicleTypeIdentifier() {
-		return vehicleIdentifier;
-	}
-
-	protected void setVehicleIdentifier(VehicleTypeKey vehicleTypeIdentifier) {
-		this.vehicleIdentifier = vehicleTypeIdentifier;
-	}
+        return userData;
+    }
+
+    protected void setUserData(Object userData) {
+        this.userData = userData;
+    }
+
+    @Override
+    public int getIndex() {
+        return index;
+    }
+
+    protected void setIndex(int index) {
+        this.index = index;
+    }
+
+    @Override
+    public VehicleTypeKey getVehicleTypeIdentifier() {
+        return vehicleIdentifier;
+    }
+
+    protected void setVehicleIdentifier(VehicleTypeKey vehicleTypeIdentifier) {
+        this.vehicleIdentifier = vehicleTypeIdentifier;
+    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Location.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Location.java
index 233a71a9b..51c74612c 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Location.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Location.java
@@ -74,15 +74,14 @@ public static Builder newInstance() {
 
         /**
          * Sets user specific domain data associated with the object.
-         *
+         * <p>
          * <p>
          * The user data is a black box for the framework, it only stores it,
          * but never interacts with it in any way.
          * </p>
          *
-         * @param userData
-         *            any object holding the domain specific user data
-         *            associated with the object.
+         * @param userData any object holding the domain specific user data
+         *                 associated with the object.
          * @return builder
          */
         public Builder setUserData(Object userData) {
@@ -130,7 +129,7 @@ public Builder setId(String id) {
          * @param name
          * @return
          */
-        public Builder setName(String name){
+        public Builder setName(String name) {
             this.name = name;
             return this;
         }
@@ -191,7 +190,9 @@ public Coordinate getCoordinate() {
         return coordinate;
     }
 
-    public String getName() { return name; }
+    public String getName() {
+        return name;
+    }
 
     @Override
     public boolean equals(Object o) {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
index 544c4fe93..4e88701e0 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
@@ -281,8 +281,11 @@ private void addJobToFinalJobMapAndCreateActivities(Job job) {
 
         private boolean addBreaksToActivityMap() {
             boolean hasBreaks = false;
+            Set<String> uniqueBreakIds = new HashSet<>();
             for (Vehicle v : uniqueVehicles) {
                 if (v.getBreak() != null) {
+                    if (!uniqueBreakIds.add(v.getBreak().getId()))
+                        throw new IllegalArgumentException("problem already contains a vehicle break with id " + v.getBreak().getId() + ". choose unique ids for each vehicle break.");
                     hasBreaks = true;
                     List<AbstractActivity> breakActivities = jobActivityFactory.createActivities(v.getBreak());
                     if(breakActivities.isEmpty()) throw new IllegalArgumentException("at least one activity for break needs to be created by activityFactory");
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
index fac022db8..bb88358b1 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
@@ -34,7 +34,7 @@
 /**
  * Created by schroeder on 11/10/16.
  */
-public class MaxDistanceConstraint implements HardActivityConstraint{
+public class MaxDistanceConstraint implements HardActivityConstraint {
 
     private StateManager stateManager;
 
@@ -44,7 +44,7 @@
 
     private Double[] maxDistances;
 
-    public MaxDistanceConstraint(StateManager stateManager, StateId distanceId, TransportDistance distanceCalculator, Map<Vehicle,Double> maxDistancePerVehicleMap) {
+    public MaxDistanceConstraint(StateManager stateManager, StateId distanceId, TransportDistance distanceCalculator, Map<Vehicle, Double> maxDistancePerVehicleMap) {
         this.stateManager = stateManager;
         this.distanceId = distanceId;
         this.distanceCalculator = distanceCalculator;
@@ -53,50 +53,50 @@ public MaxDistanceConstraint(StateManager stateManager, StateId distanceId, Tran
 
     private void makeArray(Map<Vehicle, Double> maxDistances) {
         int maxIndex = getMaxIndex(maxDistances.keySet());
-        this.maxDistances = new Double[maxIndex+1];
-        for(Vehicle v : maxDistances.keySet()){
-            this.maxDistances[v.getIndex()]=maxDistances.get(v);
+        this.maxDistances = new Double[maxIndex + 1];
+        for (Vehicle v : maxDistances.keySet()) {
+            this.maxDistances[v.getIndex()] = maxDistances.get(v);
         }
     }
 
     private int getMaxIndex(Collection<Vehicle> vehicles) {
         int index = 0;
-        for(Vehicle v : vehicles){
-            if(v.getIndex() > index) index = v.getIndex();
+        for (Vehicle v : vehicles) {
+            if (v.getIndex() > index) index = v.getIndex();
         }
         return index;
     }
 
     @Override
     public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime) {
-        if(!hasMaxDistance(iFacts.getNewVehicle())) return ConstraintsStatus.FULFILLED;
+        if (!hasMaxDistance(iFacts.getNewVehicle())) return ConstraintsStatus.FULFILLED;
         Double currentDistance = 0d;
         boolean routeIsEmpty = iFacts.getRoute().isEmpty();
-        if(!routeIsEmpty){
-            currentDistance = stateManager.getRouteState(iFacts.getRoute(),iFacts.getNewVehicle(), distanceId,Double.class);
+        if (!routeIsEmpty) {
+            currentDistance = stateManager.getRouteState(iFacts.getRoute(), iFacts.getNewVehicle(), distanceId, Double.class);
         }
         double maxDistance = getMaxDistance(iFacts.getNewVehicle());
-        if(currentDistance > maxDistance) return ConstraintsStatus.NOT_FULFILLED_BREAK;
+        if (currentDistance > maxDistance) return ConstraintsStatus.NOT_FULFILLED_BREAK;
 
         double distancePrevAct2NewAct = distanceCalculator.getDistance(prevAct.getLocation(), newAct.getLocation(), iFacts.getNewDepTime(), iFacts.getNewVehicle());
         double distanceNewAct2nextAct = distanceCalculator.getDistance(newAct.getLocation(), nextAct.getLocation(), iFacts.getNewDepTime(), iFacts.getNewVehicle());
         double distancePrevAct2NextAct = distanceCalculator.getDistance(prevAct.getLocation(), nextAct.getLocation(), prevActDepTime, iFacts.getNewVehicle());
-        if(prevAct instanceof Start && nextAct instanceof End) distancePrevAct2NextAct = 0;
-        if(nextAct instanceof End && !iFacts.getNewVehicle().isReturnToDepot()){
+        if (prevAct instanceof Start && nextAct instanceof End) distancePrevAct2NextAct = 0;
+        if (nextAct instanceof End && !iFacts.getNewVehicle().isReturnToDepot()) {
             distanceNewAct2nextAct = 0;
             distancePrevAct2NextAct = 0;
         }
         double additionalDistance = distancePrevAct2NewAct + distanceNewAct2nextAct - distancePrevAct2NextAct;
-        if(currentDistance + additionalDistance > maxDistance) return ConstraintsStatus.NOT_FULFILLED;
+        if (currentDistance + additionalDistance > maxDistance) return ConstraintsStatus.NOT_FULFILLED;
 
 
         double additionalDistanceOfPickup = 0;
-        if(newAct instanceof DeliverShipment){
+        if (newAct instanceof DeliverShipment) {
             int iIndexOfPickup = iFacts.getRelatedActivityContext().getInsertionIndex();
             TourActivity pickup = iFacts.getAssociatedActivities().get(0);
             TourActivity actBeforePickup;
-            if(iIndexOfPickup > 0) actBeforePickup = iFacts.getRoute().getActivities().get(iIndexOfPickup-1);
-            else actBeforePickup = new Start(iFacts.getNewVehicle().getStartLocation(),0,Double.MAX_VALUE);
+            if (iIndexOfPickup > 0) actBeforePickup = iFacts.getRoute().getActivities().get(iIndexOfPickup - 1);
+            else actBeforePickup = new Start(iFacts.getNewVehicle().getStartLocation(), 0, Double.MAX_VALUE);
             TourActivity actAfterPickup;
             if (iIndexOfPickup < iFacts.getRoute().getActivities().size())
                 actAfterPickup = iFacts.getRoute().getActivities().get(iIndexOfPickup);
@@ -114,21 +114,21 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
         }
 
 
-        if(currentDistance + additionalDistance + additionalDistanceOfPickup > maxDistance){
+        if (currentDistance + additionalDistance + additionalDistanceOfPickup > maxDistance) {
             return ConstraintsStatus.NOT_FULFILLED;
         }
 
         return ConstraintsStatus.FULFILLED;
     }
 
-    private boolean hasMaxDistance(Vehicle newVehicle){
-        if(newVehicle.getIndex() >= this.maxDistances.length) return false;
+    private boolean hasMaxDistance(Vehicle newVehicle) {
+        if (newVehicle.getIndex() >= this.maxDistances.length) return false;
         return this.maxDistances[newVehicle.getIndex()] != null;
     }
 
     private double getMaxDistance(Vehicle newVehicle) {
         Double maxDistance = this.maxDistances[newVehicle.getIndex()];
-        if(maxDistance == null) return Double.MAX_VALUE;
+        if (maxDistance == null) return Double.MAX_VALUE;
         return maxDistance;
     }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraint.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraint.java
new file mode 100644
index 000000000..fa23b277f
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraint.java
@@ -0,0 +1,156 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.graphhopper.jsprit.core.problem.constraint;
+
+import com.graphhopper.jsprit.core.algorithm.state.StateId;
+import com.graphhopper.jsprit.core.algorithm.state.StateManager;
+import com.graphhopper.jsprit.core.algorithm.state.UpdateMaxTimeInVehicle;
+import com.graphhopper.jsprit.core.algorithm.state.UpdateVehicleDependentPracticalTimeWindows;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.cost.TransportTime;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
+import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * Created by schroeder on 15/09/16.
+ */
+public class MaxTimeInVehicleConstraint implements HardActivityConstraint {
+
+    private final VehicleRoutingProblem vrp;
+
+    private final TransportTime transportTime;
+
+    private final VehicleRoutingActivityCosts activityCosts;
+
+    private final StateId latestStartId;
+
+    private final StateManager stateManager;
+
+    public MaxTimeInVehicleConstraint(TransportTime transportTime, VehicleRoutingActivityCosts activityCosts, StateId latestStartId, StateManager stateManager, VehicleRoutingProblem vrp) {
+        this.transportTime = transportTime;
+        this.latestStartId = latestStartId;
+        this.stateManager = stateManager;
+        this.activityCosts = activityCosts;
+        this.vrp = vrp;
+    }
+
+    @Override
+    public ConstraintsStatus fulfilled(final JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime) {
+        boolean newActIsPickup = newAct instanceof PickupActivity;
+        boolean newActIsDelivery = newAct instanceof DeliveryActivity;
+
+        /*
+        1. check whether insertion of new shipment satisfies own max-in-vehicle-constraint
+        2. check whether insertion of new shipment satisfies all other max-in-vehicle-constraints
+         */
+        //************ 1. check whether insertion of new shipment satisfies own max-in-vehicle-constraint
+        double newActArrival = prevActDepTime + transportTime.getTransportTime(prevAct.getLocation(),newAct.getLocation(),prevActDepTime,iFacts.getNewDriver(),iFacts.getNewVehicle());
+        double newActStart = Math.max(newActArrival, newAct.getTheoreticalEarliestOperationStartTime());
+        double newActDeparture = newActStart + activityCosts.getActivityDuration(newAct, newActArrival, iFacts.getNewDriver(), iFacts.getNewVehicle());
+        double nextActArrival = newActDeparture + transportTime.getTransportTime(newAct.getLocation(),nextAct.getLocation(),newActDeparture,iFacts.getNewDriver(),iFacts.getNewVehicle());
+        double nextActStart = Math.max(nextActArrival,nextAct.getTheoreticalEarliestOperationStartTime());
+        if(newAct instanceof DeliveryActivity){
+            double pickupEnd;
+            if(iFacts.getAssociatedActivities().size() == 1){
+                pickupEnd = iFacts.getNewDepTime();
+            }
+            else {
+                pickupEnd = iFacts.getRelatedActivityContext().getEndTime();
+            }
+            double timeInVehicle = newActStart - pickupEnd;
+            double maxTimeInVehicle = ((TourActivity.JobActivity)newAct).getJob().getMaxTimeInVehicle();
+            if(timeInVehicle > maxTimeInVehicle) return ConstraintsStatus.NOT_FULFILLED;
+
+        }
+        else if(newActIsPickup){
+            if(iFacts.getAssociatedActivities().size() == 1){
+                double maxTimeInVehicle = ((TourActivity.JobActivity)newAct).getJob().getMaxTimeInVehicle();
+                //ToDo - estimate in vehicle time of pickups here - This seems to trickier than I thought
+                double nextActDeparture = nextActStart + activityCosts.getActivityDuration(nextAct, nextActArrival, iFacts.getNewDriver(), iFacts.getNewVehicle());
+//                if(!nextAct instanceof End)
+                double timeToEnd = 0; //newAct.end + tt(newAct,nextAct) + t@nextAct + t_to_end
+                if(timeToEnd > maxTimeInVehicle) return ConstraintsStatus.NOT_FULFILLED;
+            }
+        }
+
+        //************ 2. check whether insertion of new shipment satisfies all other max-in-vehicle-constraints
+
+        if(newActIsPickup || iFacts.getAssociatedActivities().size() == 1) {
+            double latest;
+            if (iFacts.getRoute().isEmpty()) latest = Double.MAX_VALUE;
+            else if (nextAct instanceof End) {
+                latest = stateManager.getRouteState(iFacts.getRoute(), iFacts.getNewVehicle(), latestStartId, Double.class);
+            } else latest = stateManager.getActivityState(nextAct, iFacts.getNewVehicle(), latestStartId, Double.class);
+
+            if (nextActStart > latest) {
+                return ConstraintsStatus.NOT_FULFILLED;
+            }
+
+        } else {
+            boolean isShipment = iFacts.getAssociatedActivities().size() == 2;
+            if (newActIsDelivery && isShipment) {
+                StateManager localStateManager = new StateManager(vrp);
+                StateId stateId = localStateManager.createStateId("local-slack");
+                UpdateMaxTimeInVehicle updateMaxTimeInVehicle = new UpdateMaxTimeInVehicle(localStateManager, stateId, transportTime, activityCosts);
+                updateMaxTimeInVehicle.setVehiclesToUpdate(new UpdateVehicleDependentPracticalTimeWindows.VehiclesToUpdate() {
+                    @Override
+                    public Collection<Vehicle> get(VehicleRoute route) {
+                        return Arrays.asList(iFacts.getNewVehicle());
+                    }
+                });
+                updateMaxTimeInVehicle.begin(iFacts.getRoute());
+                List<TourActivity> tourActivities = new ArrayList<>(iFacts.getRoute().getActivities());
+                tourActivities.add(iFacts.getRelatedActivityContext().getInsertionIndex(), iFacts.getAssociatedActivities().get(0));
+                for (TourActivity act : tourActivities) {
+                    updateMaxTimeInVehicle.visit(act);
+                }
+                updateMaxTimeInVehicle.finish(tourActivities, iFacts.getJob());
+
+                double latest;
+                if (iFacts.getRoute().isEmpty()) latest = Double.MAX_VALUE;
+                else if (nextAct instanceof End) {
+                    latest = localStateManager.getRouteState(iFacts.getRoute(), iFacts.getNewVehicle(), stateId, Double.class);
+                } else
+                    latest = localStateManager.getActivityState(nextAct, iFacts.getNewVehicle(), stateId, Double.class);
+
+                if (nextActStart > latest) {
+                    return ConstraintsStatus.NOT_FULFILLED;
+                }
+
+            }
+        }
+        return ConstraintsStatus.FULFILLED;
+    }
+
+//    private double getMaxTime(String jobId) {
+//        if(maxTimes.containsKey(jobId)) return maxTimes.get(jobId);
+//        else return Double.MAX_VALUE;
+//    }
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Delivery.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Delivery.java
index d99e3c3e9..f31b25ef2 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Delivery.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Delivery.java
@@ -41,6 +41,13 @@ public static Builder newInstance(String id) {
             super(id);
         }
 
+
+        public Builder setMaxTimeInVehicle(double maxTimeInVehicle){
+            if(maxTimeInVehicle < 0) throw new IllegalArgumentException("maxTimeInVehicle should be positive");
+            this.maxTimeInVehicle = maxTimeInVehicle;
+            return this;
+        }
+
         /**
          * Builds Delivery.
          *
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Job.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Job.java
index 161e3ee74..557282353 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Job.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Job.java
@@ -62,4 +62,6 @@
      */
     public int getPriority();
 
+    public double getMaxTimeInVehicle();
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Pickup.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Pickup.java
index a30ff92b4..2a893d5f0 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Pickup.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Pickup.java
@@ -41,6 +41,13 @@ public static Builder newInstance(String id) {
             super(id);
         }
 
+        public Builder setMaxTimeInVehicle(double maxTimeInVehicle){
+            throw new UnsupportedOperationException("maxTimeInVehicle is not yet supported for Pickups and Services (only for Deliveries and Shipments)");
+//            if(maxTimeInVehicle < 0) throw new IllegalArgumentException("maxTimeInVehicle should be positive");
+//            this.maxTimeInVehicle = maxTimeInVehicle;
+//            return this;
+        }
+
         /**
          * Builds Pickup.
          * <p>
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
index 57ed0639a..ab54929e1 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
@@ -40,6 +40,8 @@
  */
 public class Service extends AbstractJob {
 
+
+
     /**
      * Builder that builds a service.
      *
@@ -91,11 +93,11 @@ public static Builder newInstance(String id) {
         private int priority = 2;
         protected Object userData;
 
-        Builder(String id){
-            this.id = id;
-            timeWindows = new TimeWindowsImpl();
-            timeWindows.add(timeWindow);
-        }
+		protected double maxTimeInVehicle = Double.MAX_VALUE;Builder(String id){
+			this.id = id;
+			timeWindows = new TimeWindowsImpl();
+			timeWindows.add(timeWindow);
+		}
 
         /**
          * Protected method to set the type-name of the service.
@@ -244,6 +246,13 @@ public T build() {
             this.priority = priority;
             return this;
         }
+
+        public Builder<T> setMaxTimeInVehicle(double maxTimeInVehicle){
+            throw new UnsupportedOperationException("maxTimeInVehicle is not yet supported for Pickups and Services (only for Deliveries and Shipments)");
+//            if(maxTimeInVehicle < 0) throw new IllegalArgumentException("maxTimeInVehicle should be positive");
+//            this.maxTimeInVehicle = maxTimeInVehicle;
+//            return this;
+        }
     }
 
     private final String id;
@@ -266,6 +275,8 @@ public T build() {
 
     private final int priority;
 
+    private final double maxTimeInVehicle;
+
     Service(Builder<?> builder) {
         setUserData(builder.userData);
         id = builder.id;
@@ -278,7 +289,7 @@ public T build() {
         location = builder.location;
         timeWindowManager = builder.timeWindows;
         priority = builder.priority;
-    }
+	maxTimeInVehicle = builder.maxTimeInVehicle;}
 
     public Collection<TimeWindow> getTimeWindows(){
         return timeWindowManager.getTimeWindows();
@@ -392,4 +403,9 @@ public int getPriority() {
         return priority;
     }
 
+    @Override
+    public double getMaxTimeInVehicle() {
+        return this.maxTimeInVehicle;
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
index b2281fe25..22c551cd4 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
@@ -91,6 +91,8 @@
 
         public Object userData;
 
+        public double maxTimeInVehicle = Double.MAX_VALUE;
+
         /**
          * Returns new instance of this builder.
          *
@@ -303,6 +305,18 @@ public Builder setPriority(int priority) {
             this.priority = priority;
             return this;
         }
+
+        /**
+         * Sets maximal time the job can be in vehicle.
+         *
+         * @param maxTimeInVehicle
+         * @return
+         */
+        public Builder setMaxTimeInVehicle(double maxTimeInVehicle){
+            if(maxTimeInVehicle < 0) throw new IllegalArgumentException("maxTimeInVehicle should be positive");
+            this.maxTimeInVehicle = maxTimeInVehicle;
+            return this;
+        }
     }
 
     private final String id;
@@ -331,6 +345,8 @@ public Builder setPriority(int priority) {
 
     private final int priority;
 
+    private final double maxTimeInVehicle;
+
     Shipment(Builder builder) {
         setUserData(builder.userData);
         this.id = builder.id;
@@ -346,6 +362,7 @@ public Builder setPriority(int priority) {
         this.deliveryTimeWindows = builder.deliveryTimeWindows;
         this.pickupTimeWindows = builder.pickupTimeWindows;
         this.priority = builder.priority;
+        this.maxTimeInVehicle = builder.maxTimeInVehicle;
     }
 
     @Override
@@ -464,4 +481,9 @@ public String getName() {
     public int getPriority() {
         return priority;
     }
+
+    @Override
+    public double getMaxTimeInVehicle() {
+        return maxTimeInVehicle;
+    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/Vehicle.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/Vehicle.java
index fd19feac1..6d430655c 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/Vehicle.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/Vehicle.java
@@ -72,14 +72,15 @@
     public abstract VehicleTypeKey getVehicleTypeIdentifier();
 
     public abstract Skills getSkills();
-	/**
-	 * @return User-specific domain data associated with the vehicle
-	 */
-	public Object getUserData();
+
+    /**
+     * @return User-specific domain data associated with the vehicle
+     */
+    public Object getUserData();
 
     public abstract Break getBreak();
-	// Switch to this as soon as we switct to Java 8:
-	// default Object getUserData() {
-	// return null;
-	// };
+    // Switch to this as soon as we switct to Java 8:
+    // default Object getUserData() {
+    // return null;
+    // };
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleImpl.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleImpl.java
index 143cd6a72..f77f7b9c7 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleImpl.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleImpl.java
@@ -17,13 +17,12 @@
  */
 package com.graphhopper.jsprit.core.problem.vehicle;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import com.graphhopper.jsprit.core.problem.AbstractVehicle;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.Skills;
 import com.graphhopper.jsprit.core.problem.job.Break;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 
 /**
@@ -153,15 +152,14 @@ public Builder setType(VehicleType type) {
 
         /**
          * Sets user specific domain data associated with the object.
-         *
+         * <p>
          * <p>
          * The user data is a black box for the framework, it only stores it,
          * but never interacts with it in any way.
          * </p>
          *
-         * @param userData
-         *            any object holding the domain specific user data
-         *            associated with the object.
+         * @param userData any object holding the domain specific user data
+         *                 associated with the object.
          * @return builder
          */
         public Builder setUserData(Object userData) {
@@ -260,7 +258,7 @@ public VehicleImpl build() {
             if (startLocation != null && endLocation != null) {
                 if (!startLocation.getId().equals(endLocation.getId()) && !returnToDepot)
                     throw new IllegalArgumentException("this must not be. you specified both endLocationId and open-routes. this is contradictory. <br>" +
-                            "if you set endLocation, returnToDepot must be true. if returnToDepot is false, endLocationCoord must not be specified.");
+                        "if you set endLocation, returnToDepot must be true. if returnToDepot is false, endLocationCoord must not be specified.");
             }
             if (startLocation != null && endLocation == null) {
                 endLocation = startLocation;
@@ -344,11 +342,11 @@ private VehicleImpl(Builder builder) {
     @Override
     public String toString() {
         return "[id=" + id + "]" +
-                "[type=" + type + "]" +
-                "[startLocation=" + startLocation + "]" +
-                "[endLocation=" + endLocation + "]" +
-                "[isReturnToDepot=" + isReturnToDepot() + "]" +
-                "[skills=" + skills + "]";
+            "[type=" + type + "]" +
+            "[startLocation=" + startLocation + "]" +
+            "[endLocation=" + endLocation + "]" +
+            "[isReturnToDepot=" + isReturnToDepot() + "]" +
+            "[skills=" + skills + "]";
     }
 
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeImpl.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeImpl.java
index 7f033e5cf..3e8da61df 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeImpl.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeImpl.java
@@ -263,8 +263,8 @@ public Builder addCapacityDimension(int dimIndex, int dimVal) {
             if (dimVal < 0) throw new IllegalArgumentException("capacity value cannot be negative");
             if (capacityDimensions != null)
                 throw new IllegalArgumentException("either build your dimension with build your dimensions with " +
-                        "addCapacityDimension(int dimIndex, int dimVal) or set the already built dimensions with .setCapacityDimensions(Capacity capacity)." +
-                        "You used both methods.");
+                    "addCapacityDimension(int dimIndex, int dimVal) or set the already built dimensions with .setCapacityDimensions(Capacity capacity)." +
+                    "You used both methods.");
             dimensionAdded = true;
             capacityBuilder.addDimension(dimIndex, dimVal);
             return this;
@@ -284,8 +284,8 @@ public Builder addCapacityDimension(int dimIndex, int dimVal) {
         public Builder setCapacityDimensions(Capacity capacity) {
             if (dimensionAdded)
                 throw new IllegalArgumentException("either build your dimension with build your dimensions with " +
-                        "addCapacityDimension(int dimIndex, int dimVal) or set the already built dimensions with .setCapacityDimensions(Capacity capacity)." +
-                        "You used both methods.");
+                    "addCapacityDimension(int dimIndex, int dimVal) or set the already built dimensions with .setCapacityDimensions(Capacity capacity)." +
+                    "You used both methods.");
             this.capacityDimensions = capacity;
             return this;
         }
@@ -301,7 +301,7 @@ public int hashCode() {
         final int prime = 31;
         int result = 1;
         result = prime * result
-                + ((typeId == null) ? 0 : typeId.hashCode());
+            + ((typeId == null) ? 0 : typeId.hashCode());
         return result;
     }
 
@@ -381,8 +381,8 @@ public String getTypeId() {
     @Override
     public String toString() {
         return "[typeId=" + typeId + "]" +
-                "[capacity=" + capacityDimensions + "]" +
-                "[costs=" + vehicleCostParams + "]";
+            "[capacity=" + capacityDimensions + "]" +
+            "[costs=" + vehicleCostParams + "]";
     }
 
     @Override
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/FastVehicleRoutingTransportCostsMatrix.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/FastVehicleRoutingTransportCostsMatrix.java
index 5e6a5d1dd..28a0422cc 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/FastVehicleRoutingTransportCostsMatrix.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/FastVehicleRoutingTransportCostsMatrix.java
@@ -97,9 +97,9 @@ public Builder addTransportTime(int fromIndex, int toIndex, double time) {
             return this;
         }
 
-        public Builder addTransportTimeAndDistance(int fromIndex, int toIndex, double time, double distance){
+        public Builder addTransportTimeAndDistance(int fromIndex, int toIndex, double time, double distance) {
             addTransportTime(fromIndex, toIndex, time);
-            addTransportDistance(fromIndex,toIndex,distance);
+            addTransportDistance(fromIndex, toIndex, distance);
             return this;
         }
         /**
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/UnassignedJobReasonTracker.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/UnassignedJobReasonTracker.java
index 0a9999530..63dbf9388 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/UnassignedJobReasonTracker.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/UnassignedJobReasonTracker.java
@@ -29,19 +29,34 @@
  */
 public class UnassignedJobReasonTracker implements JobUnassignedListener {
 
-    Map<String, Frequency> reasons = new HashMap<>();
+    public static String getMostLikelyFailedConstraintName(Frequency failedConstraintNamesFrequency) {
+        if (failedConstraintNamesFrequency == null) return "no reason found";
+        Iterator<Map.Entry<Comparable<?>, Long>> entryIterator = failedConstraintNamesFrequency.entrySetIterator();
+        int maxCount = 0;
+        String mostLikely = null;
+        while (entryIterator.hasNext()) {
+            Map.Entry<Comparable<?>, Long> entry = entryIterator.next();
+            if (entry.getValue() > maxCount) {
+                Comparable<?> key = entry.getKey();
+                mostLikely = key.toString();
+            }
+        }
+        return mostLikely;
+    }
+
+    Map<String, Frequency> failedConstraintNamesFrequencyMapping = new HashMap<>();
 
-    Map<Integer, String> codesToReason = new HashMap<>();
+    Map<Integer, String> codesToHumanReadableReason = new HashMap<>();
 
     Map<String, Integer> failedConstraintNamesToCode = new HashMap<>();
 
-    Set<String> constraintsToBeIgnored = new HashSet<>();
+    Set<String> failedConstraintNamesToBeIgnored = new HashSet<>();
 
     public UnassignedJobReasonTracker() {
-        codesToReason.put(1, "cannot serve required skill");
-        codesToReason.put(2, "cannot be visited within time window");
-        codesToReason.put(3, "does not fit into any vehicle due to capacity");
-        codesToReason.put(4, "cannot be assigned due to max distance constraint of vehicle");
+        codesToHumanReadableReason.put(1, "cannot serve required skill");
+        codesToHumanReadableReason.put(2, "cannot be visited within time window");
+        codesToHumanReadableReason.put(3, "does not fit into any vehicle due to capacity");
+        codesToHumanReadableReason.put(4, "cannot be assigned due to max distance constraint of vehicle");
 
         failedConstraintNamesToCode.put("HardSkillConstraint", 1);
         failedConstraintNamesToCode.put("VehicleDependentTimeWindowConstraints", 2);
@@ -52,24 +67,24 @@ public UnassignedJobReasonTracker() {
     }
 
     public void ignore(String simpleNameOfConstraint) {
-        constraintsToBeIgnored.add(simpleNameOfConstraint);
+        failedConstraintNamesToBeIgnored.add(simpleNameOfConstraint);
     }
 
     @Override
     public void informJobUnassigned(Job unassigned, Collection<String> failedConstraintNames) {
-        if (!this.reasons.containsKey(unassigned.getId())) {
-            this.reasons.put(unassigned.getId(), new Frequency());
+        if (!this.failedConstraintNamesFrequencyMapping.containsKey(unassigned.getId())) {
+            this.failedConstraintNamesFrequencyMapping.put(unassigned.getId(), new Frequency());
         }
         for (String r : failedConstraintNames) {
-            if (constraintsToBeIgnored.contains(r)) continue;
-            this.reasons.get(unassigned.getId()).addValue(r);
+            if (failedConstraintNamesToBeIgnored.contains(r)) continue;
+            this.failedConstraintNamesFrequencyMapping.get(unassigned.getId()).addValue(r);
         }
     }
 
     public void put(String simpleNameOfFailedConstraint, int code, String reason) {
         if (code <= 20)
             throw new IllegalArgumentException("first 20 codes are reserved internally. choose a code > 20");
-        codesToReason.put(code, reason);
+        codesToHumanReadableReason.put(code, reason);
         if (failedConstraintNamesToCode.containsKey(simpleNameOfFailedConstraint)) {
             throw new IllegalArgumentException(simpleNameOfFailedConstraint + " already assigned to code and reason");
         } else failedConstraintNamesToCode.put(simpleNameOfFailedConstraint, code);
@@ -80,8 +95,18 @@ public void put(String simpleNameOfFailedConstraint, int code, String reason) {
      *
      * @return
      */
+    @Deprecated
     public Map<String, Frequency> getReasons() {
-        return Collections.unmodifiableMap(reasons);
+        return Collections.unmodifiableMap(failedConstraintNamesFrequencyMapping);
+    }
+
+    /**
+     * For each job id, it returns frequency distribution of failed constraints (simple name of constraint) in an unmodifiable map.
+     *
+     * @return
+     */
+    public Map<String, Frequency> getFailedConstraintNamesFrequencyMapping() {
+        return Collections.unmodifiableMap(failedConstraintNamesFrequencyMapping);
     }
 
     /**
@@ -90,7 +115,7 @@ public void put(String simpleNameOfFailedConstraint, int code, String reason) {
      * @return
      */
     public Map<Integer, String> getCodesToReason() {
-        return Collections.unmodifiableMap(codesToReason);
+        return Collections.unmodifiableMap(codesToHumanReadableReason);
     }
 
     /**
@@ -102,9 +127,21 @@ public void put(String simpleNameOfFailedConstraint, int code, String reason) {
         return Collections.unmodifiableMap(failedConstraintNamesToCode);
     }
 
+    public int getCode(String failedConstraintName) {
+        return toCode(failedConstraintName);
+    }
+
+    public String getHumanReadableReason(int code) {
+        return getCodesToReason().get(code);
+    }
+
+    public String getHumanReadableReason(String failedConstraintName) {
+        return getCodesToReason().get(getCode(failedConstraintName));
+    }
+
     /**
      * Returns the most likely reason code i.e. the reason (failed constraint) being observed most often.
-     *
+     * <p>
      * 1 --> "cannot serve required skill
      * 2 --> "cannot be visited within time window"
      * 3 --> "does not fit into any vehicle due to capacity"
@@ -114,9 +151,9 @@ public void put(String simpleNameOfFailedConstraint, int code, String reason) {
      * @return
      */
     public int getMostLikelyReasonCode(String jobId) {
-        if (!this.reasons.containsKey(jobId)) return -1;
-        Frequency reasons = this.reasons.get(jobId);
-        String mostLikelyReason = getMostLikely(reasons);
+        if (!this.failedConstraintNamesFrequencyMapping.containsKey(jobId)) return -1;
+        Frequency reasons = this.failedConstraintNamesFrequencyMapping.get(jobId);
+        String mostLikelyReason = getMostLikelyFailedConstraintName(reasons);
         return toCode(mostLikelyReason);
     }
 
@@ -127,12 +164,12 @@ public int getMostLikelyReasonCode(String jobId) {
      * @return
      */
     public String getMostLikelyReason(String jobId) {
-        if (!this.reasons.containsKey(jobId)) return "no reason found";
-        Frequency reasons = this.reasons.get(jobId);
-        String mostLikelyReason = getMostLikely(reasons);
+        if (!this.failedConstraintNamesFrequencyMapping.containsKey(jobId)) return "no reason found";
+        Frequency reasons = this.failedConstraintNamesFrequencyMapping.get(jobId);
+        String mostLikelyReason = getMostLikelyFailedConstraintName(reasons);
         int code = toCode(mostLikelyReason);
         if (code == -1) return mostLikelyReason;
-        else return codesToReason.get(code);
+        else return codesToHumanReadableReason.get(code);
     }
 
     private int toCode(String mostLikelyReason) {
@@ -141,20 +178,5 @@ private int toCode(String mostLikelyReason) {
         else return -1;
     }
 
-    private String getMostLikely(Frequency reasons) {
-        if (reasons == null) return "no reason found";
-        Iterator<Map.Entry<Comparable<?>, Long>> entryIterator = reasons.entrySetIterator();
-        int maxCount = 0;
-        String mostLikely = null;
-        while (entryIterator.hasNext()) {
-            Map.Entry<Comparable<?>, Long> entry = entryIterator.next();
-            if (entry.getValue() > maxCount) {
-                Comparable<?> key = entry.getKey();
-                mostLikely = key.toString();
-            }
-        }
-        return mostLikely;
-    }
-
 
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MaxTimeInVehicle_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MaxTimeInVehicle_IT.java
new file mode 100644
index 000000000..18285a11a
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MaxTimeInVehicle_IT.java
@@ -0,0 +1,68 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.graphhopper.jsprit.core.algorithm;
+
+import com.graphhopper.jsprit.core.algorithm.box.Jsprit;
+import com.graphhopper.jsprit.core.algorithm.state.StateId;
+import com.graphhopper.jsprit.core.algorithm.state.StateManager;
+import com.graphhopper.jsprit.core.algorithm.state.UpdateMaxTimeInVehicle;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
+import com.graphhopper.jsprit.core.problem.constraint.MaxTimeInVehicleConstraint;
+import com.graphhopper.jsprit.core.problem.job.Shipment;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
+import com.graphhopper.jsprit.core.reporting.SolutionPrinter;
+import com.graphhopper.jsprit.core.util.Solutions;
+import org.junit.Test;
+
+/**
+ * Created by schroeder on 20/09/16.
+ */
+public class MaxTimeInVehicle_IT {
+
+    @Test
+    public void test(){
+
+        Shipment s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(0,0)).setDeliveryLocation(Location.newInstance(100,0)).setDeliveryServiceTime(10)
+            .setMaxTimeInVehicle(100d)
+            .build();
+        Shipment s2 = Shipment.Builder.newInstance("s2").setPickupLocation(Location.newInstance(0,0)).setDeliveryLocation(Location.newInstance(100,0)).setDeliveryServiceTime(10)
+            .setMaxTimeInVehicle(100d)
+            .build();
+
+        VehicleImpl v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0,0)).build();
+
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addVehicle(v).addJob(s1).addJob(s2).build();
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId id = stateManager.createStateId("max-time");
+        stateManager.addStateUpdater(new UpdateMaxTimeInVehicle(stateManager,id,vrp.getTransportCosts(),vrp.getActivityCosts()));
+
+        ConstraintManager constraintManager = new ConstraintManager(vrp,stateManager);
+        constraintManager.addConstraint(new MaxTimeInVehicleConstraint(vrp.getTransportCosts(),vrp.getActivityCosts(),id,stateManager, vrp), ConstraintManager.Priority.CRITICAL);
+
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
+        VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
+
+//        Assert.assertEquals(400, solution.getCost(), 0.001);
+        SolutionPrinter.print(vrp,solution, SolutionPrinter.Print.VERBOSE);
+    }
+}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestLocalActivityInsertionCostsCalculator.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestLocalActivityInsertionCostsCalculator.java
index b9e4f6316..55127bd54 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestLocalActivityInsertionCostsCalculator.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestLocalActivityInsertionCostsCalculator.java
@@ -115,8 +115,8 @@ public void whenAddingServiceBetweenDiffStartAndEnd_costMustBeCorrect() {
                 new StateManager(vrp));
         double cost = localActivityInsertionCostsCalculator.getCosts(
             jobInsertionContext,
-            new Start(v.getStartLocation(),0,Double.MAX_VALUE),
-            new End(v.getEndLocation(),0,Double.MAX_VALUE),
+            new Start(v.getStartLocation(), 0, Double.MAX_VALUE),
+            new End(v.getEndLocation(), 0, Double.MAX_VALUE),
             vrp.getActivities(s).get(0),
             0);
         assertEquals(20., cost, Math.ulp(20.));
@@ -146,15 +146,15 @@ public void whenAddingShipmentBetweenDiffStartAndEnd_costMustBeCorrect() {
                 new StateManager(vrp));
         double cost = localActivityInsertionCostsCalculator.getCosts(
             jobInsertionContext,
-            new Start(v.getStartLocation(),0,Double.MAX_VALUE),
-            new End(v.getEndLocation(),0,Double.MAX_VALUE),
+            new Start(v.getStartLocation(), 0, Double.MAX_VALUE),
+            new End(v.getEndLocation(), 0, Double.MAX_VALUE),
             vrp.getActivities(s).get(0),
             0);
         assertEquals(20., cost, Math.ulp(20.));
         cost = localActivityInsertionCostsCalculator.getCosts(
             jobInsertionContext,
             vrp.getActivities(s).get(0),
-            new End(v.getEndLocation(),0,Double.MAX_VALUE),
+            new End(v.getEndLocation(), 0, Double.MAX_VALUE),
             vrp.getActivities(s).get(1),
             0);
         assertEquals(10, cost, Math.ulp(10.));
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicleTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicleTest.java
new file mode 100644
index 000000000..f39164d1e
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicleTest.java
@@ -0,0 +1,203 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.graphhopper.jsprit.core.algorithm.state;
+
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.job.Delivery;
+import com.graphhopper.jsprit.core.problem.job.Pickup;
+import com.graphhopper.jsprit.core.problem.job.Shipment;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Created by schroeder on 15/09/16.
+ */
+public class UpdateMaxTimeInVehicleTest {
+
+    private VehicleRoute route;
+
+    private VehicleRoute route2;
+
+    private VehicleImpl vehicle;
+
+    private VehicleImpl v;
+
+    private VehicleImpl vehicle2;
+
+    private VehicleRoutingProblem vrp;
+
+    private com.graphhopper.jsprit.core.algorithm.state.UpdateMaxTimeInVehicle maxTimeInVehicleConstraint;
+
+    private StateManager stateManager;
+
+    private StateId latestStartId;
+
+    @Before
+    public void doBefore() {
+        VehicleType type = VehicleTypeImpl.Builder.newInstance("t").build();
+
+        v = VehicleImpl.Builder.newInstance("v0").setStartLocation(Location.newInstance(0, 0))
+            .setType(type).build();
+
+        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0,0))
+            .setEndLocation(Location.newInstance(0,50)).setType(type).build();
+
+        vehicle2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(Location.newInstance(0,10))
+            .setEndLocation(Location.newInstance(0,40)).setType(type).build();
+
+        Pickup service = Pickup.Builder.newInstance("s").setLocation(Location.newInstance(0, 10)).build();
+        Pickup service2 = Pickup.Builder.newInstance("s2").setLocation(Location.newInstance(0, 20)).build();
+
+        Pickup service3 = Pickup.Builder.newInstance("s3").setLocation(Location.newInstance(0, 30)).build();
+        Pickup service4 = Pickup.Builder.newInstance("s4").setLocation(Location.newInstance(0, 40)).build();
+
+        Delivery d1 = Delivery.Builder.newInstance("d1").setLocation(Location.newInstance(10,0)).build();
+
+        Shipment shipment = Shipment.Builder.newInstance("shipment").setPickupLocation(Location.newInstance(20,0))
+            .setDeliveryLocation(Location.newInstance(40,0))
+            .setMaxTimeInVehicle(20d)
+            .build();
+
+        Delivery d2 = Delivery.Builder.newInstance("d2").setLocation(Location.newInstance(30,0)).setServiceTime(10).build();
+
+
+        vrp = VehicleRoutingProblem.Builder.newInstance().addVehicle(v).addVehicle(vehicle).addVehicle(vehicle2).addJob(service)
+            .addJob(service2).addJob(service3).addJob(service4)
+            .addJob(d1).addJob(shipment).addJob(d2)
+            .build();
+
+        route = VehicleRoute.Builder.newInstance(vehicle).setJobActivityFactory(vrp.getJobActivityFactory())
+            .addService(service).addService(service2).addService(service3).addService(service4).build();
+
+        route2 = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory())
+            .addDelivery(d1).addPickup(shipment).addDelivery(shipment).build();
+
+        stateManager = new StateManager(vrp);
+        stateManager.addStateUpdater(new UpdateActivityTimes(vrp.getTransportCosts(),vrp.getActivityCosts()));
+        stateManager.informInsertionStarts(Arrays.asList(route), null);
+
+        latestStartId = stateManager.createStateId("slack-time-id");
+
+//        Map<String,Double> maxTimes = new HashMap<>();
+//        maxTimes.put("s",40d);
+//        maxTimes.put("shipment",20d);
+        maxTimeInVehicleConstraint = new UpdateMaxTimeInVehicle(stateManager, latestStartId,vrp.getTransportCosts(), vrp.getActivityCosts());
+        maxTimeInVehicleConstraint.setVehiclesToUpdate(new UpdateVehicleDependentPracticalTimeWindows.VehiclesToUpdate() {
+            @Override
+            public Collection<Vehicle> get(VehicleRoute route) {
+                return Arrays.asList((Vehicle)vehicle,(Vehicle)vehicle2,v);
+            }
+        });
+        stateManager.addStateUpdater(maxTimeInVehicleConstraint);
+    }
+
+//    @Test
+//    public void testVehicle(){
+//        stateManager.informInsertionStarts(Arrays.asList(route), null);
+//        for(TourActivity act : route.getActivities()){
+//            String jobId = ((TourActivity.JobActivity)act).getJob().getId();
+//            if(jobId.equals("s4")){
+//                Double slackTime = stateManager.getActivityState(act,route.getVehicle(), latestStartId,Double.class);
+//                Assert.assertEquals(40, slackTime, 0.001);
+//            }
+//            if(jobId.equals("s3")){
+//                Double slackTime = stateManager.getActivityState(act,route.getVehicle(), latestStartId,Double.class);
+//                Assert.assertEquals(30, slackTime, 0.001);
+//            }
+//            if(jobId.equals("s2")){
+//                Double slackTime = stateManager.getActivityState(act,route.getVehicle(), latestStartId,Double.class);
+//                Assert.assertEquals(20, slackTime, 0.001);
+//            }
+//            if(jobId.equals("s")){
+//                Double slackTime = stateManager.getActivityState(act,route.getVehicle(), latestStartId,Double.class);
+//                Assert.assertEquals(Double.MAX_VALUE, slackTime, 0.001);
+//            }
+//        }
+//        Double slackTime = stateManager.getRouteState(route,route.getVehicle(), latestStartId,Double.class);
+//        Assert.assertNotNull(slackTime);
+//        Assert.assertEquals(50,slackTime,0.001);
+//    }
+//
+//    @Test
+//    public void testVehicle2(){
+//        stateManager.informInsertionStarts(Arrays.asList(route), null);
+//        for(TourActivity act : route.getActivities()){
+//            String jobId = ((TourActivity.JobActivity)act).getJob().getId();
+//            if(jobId.equals("s4")){
+//                Double slackTime = stateManager.getActivityState(act,vehicle2, latestStartId,Double.class);
+//                Assert.assertEquals(40, slackTime, 0.001);
+//            }
+//            if(jobId.equals("s3")){
+//                Double slackTime = stateManager.getActivityState(act,vehicle2, latestStartId,Double.class);
+//                Assert.assertEquals(30, slackTime, 0.001);
+//            }
+//            if(jobId.equals("s2")){
+//                Double slackTime = stateManager.getActivityState(act,vehicle2, latestStartId,Double.class);
+//                Assert.assertEquals(20, slackTime, 0.001);
+//            }
+//            if(jobId.equals("s")){
+//                Double slackTime = stateManager.getActivityState(act,vehicle2, latestStartId,Double.class);
+//                Assert.assertEquals(Double.MAX_VALUE, slackTime, 0.001);
+//            }
+//        }
+//        Double slackTime = stateManager.getRouteState(route,vehicle2, latestStartId,Double.class);
+//        Assert.assertNotNull(slackTime);
+//        Assert.assertEquals(40,slackTime,0.001);
+//    }
+
+    @Test
+    public void testWithShipment(){
+        stateManager.informInsertionStarts(Arrays.asList(route2), null);
+        for(TourActivity act : route2.getActivities()){
+            String jobId = ((TourActivity.JobActivity)act).getJob().getId();
+            if(jobId.equals("d1")){
+                Double slackTime = stateManager.getActivityState(act,v, latestStartId,Double.class);
+                Assert.assertEquals(Double.MAX_VALUE, slackTime, 0.001);
+            }
+            if(jobId.equals("shipment")){
+                if(act instanceof PickupActivity){
+                    Double slackTime = stateManager.getActivityState(act,v, latestStartId,Double.class);
+                    Assert.assertEquals(Double.MAX_VALUE, slackTime, 0.001);
+                }
+                else{
+                    Double slackTime = stateManager.getActivityState(act,v, latestStartId,Double.class);
+                    Assert.assertEquals(40, slackTime, 0.001);
+                }
+
+            }
+        }
+    }
+
+
+}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/LocationTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/LocationTest.java
index 00e416667..4dc9bf677 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/LocationTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/LocationTest.java
@@ -18,17 +18,14 @@
 
 package com.graphhopper.jsprit.core.problem;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import com.graphhopper.jsprit.core.util.Coordinate;
+import org.junit.Assert;
+import org.junit.Test;
 
 import java.util.HashMap;
 import java.util.Map;
 
-import org.junit.Assert;
-import org.junit.Test;
-
-import com.graphhopper.jsprit.core.util.Coordinate;
+import static org.junit.Assert.*;
 
 /**
  * Created by schroeder on 16.12.14.
@@ -45,7 +42,7 @@ public void whenIndexSet_buildLocation() {
     @Test
     public void whenNameSet_buildLocation() {
         Location l = Location.Builder.newInstance().setName("mystreet 6a").setIndex(1).build();
-        Assert.assertEquals("mystreet 6a",l.getName());
+        Assert.assertEquals("mystreet 6a", l.getName());
     }
 
     @Test
@@ -82,8 +79,8 @@ public void whenIdSetWithFactory_returnCorrectLocation() {
     @Test
     public void whenCoordinateSet_build() {
         Location l = Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(10, 20)).build();
-        Assert.assertEquals(10., l.getCoordinate().getX(),0.001);
-        Assert.assertEquals(20., l.getCoordinate().getY(),0.001);
+        Assert.assertEquals(10., l.getCoordinate().getX(), 0.001);
+        Assert.assertEquals(20., l.getCoordinate().getY(), 0.001);
         Assert.assertTrue(true);
     }
 
@@ -91,8 +88,8 @@ public void whenCoordinateSet_build() {
     public void whenCoordinateSetWithFactory_returnCorrectLocation() {
         //        Location l = Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(10,20)).build();
         Location l = Location.newInstance(10, 20);
-        Assert.assertEquals(10., l.getCoordinate().getX(),0.001);
-        Assert.assertEquals(20., l.getCoordinate().getY(),0.001);
+        Assert.assertEquals(10., l.getCoordinate().getX(), 0.001);
+        Assert.assertEquals(20., l.getCoordinate().getY(), 0.001);
         Assert.assertTrue(true);
     }
 
@@ -100,7 +97,7 @@ public void whenCoordinateSetWithFactory_returnCorrectLocation() {
     @Test
     public void whenSettingUserData_itIsAssociatedWithTheLocation() {
         Location one = Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(10, 20))
-                .setUserData(new HashMap<String, Object>()).build();
+            .setUserData(new HashMap<String, Object>()).build();
         Location two = Location.Builder.newInstance().setIndex(1).setUserData(42).build();
         Location three = Location.Builder.newInstance().setIndex(2).build();
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblemTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblemTest.java
index 0722a5513..4ad1eec7c 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblemTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblemTest.java
@@ -22,10 +22,7 @@
 import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
 import com.graphhopper.jsprit.core.problem.driver.Driver;
 import com.graphhopper.jsprit.core.problem.driver.DriverImpl;
-import com.graphhopper.jsprit.core.problem.job.Delivery;
-import com.graphhopper.jsprit.core.problem.job.Pickup;
-import com.graphhopper.jsprit.core.problem.job.Service;
-import com.graphhopper.jsprit.core.problem.job.Shipment;
+import com.graphhopper.jsprit.core.problem.job.*;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
@@ -312,7 +309,22 @@ public void whenAddingVehiclesWithSameId_itShouldThrowException(){
         VehicleImpl vehicle2 = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("loc")).setType(type).build();
         builder.addVehicle(vehicle1);
         builder.addVehicle(vehicle2);
+    }
 
+    @Test(expected = IllegalArgumentException.class)
+    public void whenBuildingProblemWithSameBreakId_itShouldThrowException(){
+        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
+        VehicleType type = VehicleTypeImpl.Builder.newInstance("type").build();
+        VehicleImpl vehicle1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(Location.newInstance("loc")).setType(type)
+            .setBreak(Break.Builder.newInstance("break").build())
+            .build();
+        VehicleImpl vehicle2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(Location.newInstance("loc")).setType(type)
+            .setBreak(Break.Builder.newInstance("break").build())
+            .build();
+        builder.addVehicle(vehicle1);
+        builder.addVehicle(vehicle2);
+        builder.setFleetSize(FleetSize.FINITE);
+        builder.build();
     }
 
     @Test
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraintTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraintTest.java
new file mode 100644
index 000000000..3e96ef7cc
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraintTest.java
@@ -0,0 +1,362 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.graphhopper.jsprit.core.problem.constraint;
+
+import com.graphhopper.jsprit.core.algorithm.state.StateId;
+import com.graphhopper.jsprit.core.algorithm.state.StateManager;
+import com.graphhopper.jsprit.core.algorithm.state.UpdateMaxTimeInVehicle;
+import com.graphhopper.jsprit.core.problem.AbstractActivity;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.job.Delivery;
+import com.graphhopper.jsprit.core.problem.job.Job;
+import com.graphhopper.jsprit.core.problem.job.Pickup;
+import com.graphhopper.jsprit.core.problem.job.Shipment;
+import com.graphhopper.jsprit.core.problem.misc.ActivityContext;
+import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.*;
+
+/**
+ * Created by schroeder on 19/09/16.
+ */
+public class MaxTimeInVehicleConstraintTest {
+
+    Delivery d1;
+
+    Shipment s1;
+
+    Shipment s2;
+
+    Delivery d2;
+
+    Pickup p1;
+
+    Pickup p2;
+
+    Vehicle v;
+
+    VehicleRoute route;
+
+    VehicleRoutingProblem vrp;
+
+    @Before
+    public void doBefore(){
+
+    }
+
+    private void ini(double maxTimeShipment, double maxTimeDelivery, double maxTimePickup) {
+        d1 = Delivery.Builder.newInstance("d1").setLocation(Location.newInstance(10,0)).build();
+
+        s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(20,0))
+            .setDeliveryLocation(Location.newInstance(40, 0)).setMaxTimeInVehicle(maxTimeShipment).build();
+
+        s2 = Shipment.Builder.newInstance("s2").setPickupLocation(Location.newInstance(20,0))
+            .setDeliveryLocation(Location.newInstance(40, 0)).setMaxTimeInVehicle(maxTimeShipment).build();
+
+        d2 = Delivery.Builder.newInstance("d2")
+            .setMaxTimeInVehicle(maxTimeDelivery)
+            .setLocation(Location.newInstance(30, 0)).setServiceTime(10).build();
+
+        p1 = Pickup.Builder.newInstance("p1").setLocation(Location.newInstance(10, 0)).build();
+        p2 = Pickup.Builder.newInstance("p2")
+//            .setMaxTimeInVehicle(maxTimePickup)
+            .setLocation(Location.newInstance(20, 0)).build();
+
+        v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0,0)).build();
+
+        vrp = VehicleRoutingProblem.Builder.newInstance().addJob(d1).addJob(s1).addJob(d2).addJob(p1).addJob(p2)
+            .addVehicle(v).build();
+
+        route = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory())
+            .addDelivery(d1).addPickup(s1).addDelivery(s1).build();
+    }
+
+    @Test
+    public void shiftOfExistingShipmentsShouldWork(){
+        Vehicle v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0,0)).build();
+
+        Shipment s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(20,0))
+            .setDeliveryLocation(Location.newInstance(40,0)).setMaxTimeInVehicle(20).build();
+
+        Shipment s2 = Shipment.Builder.newInstance("s2").setPickupLocation(Location.newInstance(20,0))
+            .setPickupServiceTime(10)
+            .setDeliveryLocation(Location.newInstance(40,0)).setMaxTimeInVehicle(20).build();
+
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(s1).addJob(s2).addVehicle(v).build();
+
+        VehicleRoute route = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory())
+            .addPickup(s1).addDelivery(s1).build();
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId latestStartId = stateManager.createStateId("latest-start-id");
+
+        UpdateMaxTimeInVehicle updater = new UpdateMaxTimeInVehicle(stateManager,latestStartId,vrp.getTransportCosts(), vrp.getActivityCosts());
+        stateManager.addStateUpdater(updater);
+        stateManager.informInsertionStarts(Arrays.asList(route),new ArrayList<Job>());
+
+        MaxTimeInVehicleConstraint constraint = new MaxTimeInVehicleConstraint(vrp.getTransportCosts(),vrp.getActivityCosts() , latestStartId, stateManager, vrp);
+        JobInsertionContext c = new JobInsertionContext(route,s2,v,route.getDriver(),0.);
+        List<AbstractActivity> acts = vrp.getActivities(s2);
+
+        c.getAssociatedActivities().add(acts.get(0));
+        c.getAssociatedActivities().add(acts.get(1));
+
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, route.getStart(), acts.get(0), route.getActivities().get(0), 0));
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED, constraint.fulfilled(c, act(route,0), acts.get(0), act(route,1), 20));
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, act(route,1), acts.get(0), route.getEnd(), 40));
+
+        //insert pickup at 0
+        c.setRelatedActivityContext(new ActivityContext());
+        c.getRelatedActivityContext().setArrivalTime(20);
+        c.getRelatedActivityContext().setEndTime(30);
+        c.getRelatedActivityContext().setInsertionIndex(0);
+
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, acts.get(0), acts.get(1), act(route,0), 30));
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, act(route,0), acts.get(1), act(route,1), 30));
+    }
+
+    private TourActivity act(VehicleRoute route, int index){
+        return route.getActivities().get(index);
+    }
+
+    @Test
+    public void insertingDeliveryAtAnyPositionShouldWork(){
+        ini(30d, Double.MAX_VALUE, Double.MAX_VALUE);
+        StateManager stateManager = new StateManager(vrp);
+        StateId latestStartId = stateManager.createStateId("latest-start-id");
+
+        UpdateMaxTimeInVehicle updater = new UpdateMaxTimeInVehicle(stateManager,latestStartId,vrp.getTransportCosts(), vrp.getActivityCosts());
+        stateManager.addStateUpdater(updater);
+        stateManager.informInsertionStarts(Arrays.asList(route),new ArrayList<Job>());
+
+        MaxTimeInVehicleConstraint constraint = new MaxTimeInVehicleConstraint(vrp.getTransportCosts(),vrp.getActivityCosts() , latestStartId, stateManager, vrp);
+        JobInsertionContext c = new JobInsertionContext(route,d2,v,route.getDriver(),0.);
+        List<AbstractActivity> acts = vrp.getActivities(d2);
+        c.getAssociatedActivities().add(acts.get(0));
+
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, route.getStart(), acts.get(0), route.getActivities().get(0), 0));
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, route.getActivities().get(0), acts.get(0), route.getActivities().get(1), 10));
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, route.getActivities().get(1), acts.get(0), route.getActivities().get(2), 20));
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, route.getActivities().get(2), acts.get(0), route.getEnd(), 40));
+
+    }
+
+    @Test
+    public void insertingDeliveryInBetweenShipmentShouldFail(){
+        ini(20d, 30, Double.MAX_VALUE);
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId latestStartId = stateManager.createStateId("latest-start-id");
+
+        UpdateMaxTimeInVehicle updater = new UpdateMaxTimeInVehicle(stateManager,latestStartId,vrp.getTransportCosts(),vrp.getActivityCosts());
+        stateManager.addStateUpdater(updater);
+        stateManager.informInsertionStarts(Arrays.asList(route),new ArrayList<Job>());
+
+        MaxTimeInVehicleConstraint constraint = new MaxTimeInVehicleConstraint(vrp.getTransportCosts(),vrp.getActivityCosts() , latestStartId, stateManager, vrp);
+        JobInsertionContext c = new JobInsertionContext(route,d2,v,route.getDriver(),0.);
+        List<AbstractActivity> acts = vrp.getActivities(d2);
+        c.getAssociatedActivities().add(acts.get(0));
+
+        Assert.assertEquals("inserting d2 just after start should work", HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, route.getStart(), acts.get(0), route.getActivities().get(0), 0));
+        Assert.assertEquals("inserting d2 after first delivery should work", HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, route.getActivities().get(0), acts.get(0), route.getActivities().get(1), 10));
+        Assert.assertEquals("inserting d2 between pickup and delivery shipment should fail due to max-in-vehicle constraint of shipment", HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED, constraint.fulfilled(c, route.getActivities().get(1), acts.get(0), route.getActivities().get(2), 20));
+        Assert.assertEquals("inserting d2 at end should fail", HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED, constraint.fulfilled(c, route.getActivities().get(2), acts.get(0), route.getEnd(), 40));
+    }
+
+
+
+    @Test
+    public void insertingPickupShipmentAtAnyPositionShouldWork(){
+        ini(25d, Double.MAX_VALUE, Double.MAX_VALUE);
+        VehicleRoute r = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory())
+            .addDelivery(d1).addDelivery(d2).build();
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId latestStartId = stateManager.createStateId("latest-start-id");
+
+        UpdateMaxTimeInVehicle updater = new UpdateMaxTimeInVehicle(stateManager,latestStartId,vrp.getTransportCosts(), vrp.getActivityCosts());
+        stateManager.addStateUpdater(updater);
+        stateManager.informInsertionStarts(Arrays.asList(r),new ArrayList<Job>());
+
+        MaxTimeInVehicleConstraint constraint = new MaxTimeInVehicleConstraint(vrp.getTransportCosts(),vrp.getActivityCosts() , latestStartId, stateManager, vrp);
+        JobInsertionContext c = new JobInsertionContext(r, s1,v,r.getDriver(),0.);
+        List<AbstractActivity> acts = vrp.getActivities(s1);
+        c.getAssociatedActivities().add(acts.get(0));
+        c.getAssociatedActivities().add(acts.get(1));
+
+
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, r.getStart(), acts.get(0), r.getActivities().get(0), 0));
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, r.getActivities().get(0), acts.get(0), r.getActivities().get(1), 10));
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, r.getActivities().get(1), acts.get(0), r.getEnd(), 40));
+    }
+
+    @Test
+    public void insertingPickupShipmentShouldWork() {
+
+        ini(30, Double.MAX_VALUE, Double.MAX_VALUE);
+        VehicleRoute r = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory())
+            .addPickup(p1).addDelivery(d2).build();
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId latestStartId = stateManager.createStateId("latest-start-id");
+
+        UpdateMaxTimeInVehicle updater = new UpdateMaxTimeInVehicle(stateManager, latestStartId, vrp.getTransportCosts(), vrp.getActivityCosts());
+        stateManager.addStateUpdater(updater);
+        stateManager.informInsertionStarts(Arrays.asList(r), new ArrayList<Job>());
+
+        MaxTimeInVehicleConstraint constraint = new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), latestStartId, stateManager, vrp);
+        JobInsertionContext c = new JobInsertionContext(r, s1, v, r.getDriver(), 0.);
+        List<AbstractActivity> acts = vrp.getActivities(s1);
+        c.getAssociatedActivities().add(acts.get(0));
+        c.getAssociatedActivities().add(acts.get(1));
+
+
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, r.getStart(), acts.get(0), r.getActivities().get(0), 0));
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, r.getActivities().get(0), acts.get(0), r.getActivities().get(1), 10));
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, r.getActivities().get(1), acts.get(0), r.getEnd(), 30));
+
+    }
+
+    @Test
+    public void insertingPickupShipmentShouldWork2() {
+
+        ini(30, 30, Double.MAX_VALUE);
+        VehicleRoute r = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory())
+            .addPickup(p1).addDelivery(d2).build();
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId latestStartId = stateManager.createStateId("latest-start-id");
+
+        UpdateMaxTimeInVehicle updater = new UpdateMaxTimeInVehicle(stateManager, latestStartId, vrp.getTransportCosts(), vrp.getActivityCosts());
+        stateManager.addStateUpdater(updater);
+        stateManager.informInsertionStarts(Arrays.asList(r), new ArrayList<Job>());
+
+        MaxTimeInVehicleConstraint constraint = new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), latestStartId, stateManager, vrp);
+        JobInsertionContext c = new JobInsertionContext(r, s1, v, r.getDriver(), 0.);
+        List<AbstractActivity> acts = vrp.getActivities(s1);
+        c.getAssociatedActivities().add(acts.get(0));
+        c.getAssociatedActivities().add(acts.get(1));
+
+        Assert.assertEquals("pickup shipment cannot happen at first pos. since d2 has max in-vehicle time", HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED, constraint.fulfilled(c, r.getStart(), acts.get(0), r.getActivities().get(0), 0));
+        Assert.assertEquals("pickup shipment can happen at second pos.", HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, r.getActivities().get(0), acts.get(0), r.getActivities().get(1), 10));
+        Assert.assertEquals("d2 has been delivered so pickup shipment is possible", HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, r.getActivities().get(1), acts.get(0), r.getEnd(), 30));
+    }
+
+    @Test
+    public void testOpenRoutes() {
+        /*
+        max time of deliveries and shipment should not be influenced at all by open routes
+        when pickups are supported it should matter
+         */
+        Assert.assertTrue(true);
+    }
+
+//    @Test(expected = UnsupportedOperationException.class)
+//    public void insertingPickupShouldWork(){
+//        ini(30, Double.MAX_VALUE, 30);
+//        VehicleRoute r = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory())
+//            .addPickup(p1).addPickup(s1).addDelivery(s1).build();
+//
+//        StateManager stateManager = new StateManager(vrp);
+//        StateId latestStartId = stateManager.createStateId("latest-start-id");
+//
+//        UpdateMaxTimeInVehicle updater = new UpdateMaxTimeInVehicle(stateManager, latestStartId, vrp.getTransportCosts(), vrp.getActivityCosts());
+//        stateManager.addStateUpdater(updater);
+//        stateManager.informInsertionStarts(Arrays.asList(r), new ArrayList<Job>());
+//
+//        MaxTimeInVehicleConstraint constraint = new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), latestStartId, stateManager, vrp);
+//        JobInsertionContext c = new JobInsertionContext(r, p2, v, r.getDriver(), 0.);
+//        List<AbstractActivity> acts = vrp.getActivities(p2);
+//        c.getAssociatedActivities().add(acts.get(0));
+//
+//
+//        Assert.assertEquals("p2 cannot be done at first pos. due to its own max in-vehicle time restriction",HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED, constraint.fulfilled(c, r.getStart(), acts.get(0), r.getActivities().get(0), 0));
+//        Assert.assertEquals("p2 cannot be done at second pos. due to its own max in-vehicle time restriction",HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED, constraint.fulfilled(c, r.getActivities().get(0), acts.get(0), r.getActivities().get(1), 10));
+//        Assert.assertEquals("p2 cannot be done at third pos. due to its own max in-vehicle time restriction", HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED, constraint.fulfilled(c, r.getActivities().get(1), acts.get(0), r.getActivities().get(2), 20));
+//        Assert.assertEquals("p2 can be done at last", HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, r.getActivities().get(2), acts.get(0), r.getEnd(), 40));
+//    }
+
+    @Test
+    public void whenPickupIsInsertedAt0_insertingDeliveryShipmentShouldFailWhereConstraintIsBroken(){
+        ini(25d, Double.MAX_VALUE, Double.MAX_VALUE);
+        VehicleRoute r = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory())
+            .addDelivery(d1).addDelivery(d2).build();
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId latestStartId = stateManager.createStateId("latest-start-id");
+
+        UpdateMaxTimeInVehicle updater = new UpdateMaxTimeInVehicle(stateManager,latestStartId,vrp.getTransportCosts(), vrp.getActivityCosts());
+        stateManager.addStateUpdater(updater);
+        stateManager.informInsertionStarts(Arrays.asList(r),new ArrayList<Job>());
+
+        MaxTimeInVehicleConstraint constraint = new MaxTimeInVehicleConstraint(vrp.getTransportCosts(),vrp.getActivityCosts() , latestStartId, stateManager, vrp);
+        JobInsertionContext c = new JobInsertionContext(r, s1,v,r.getDriver(),0.);
+        List<AbstractActivity> acts = vrp.getActivities(s1);
+        c.getAssociatedActivities().add(acts.get(0));
+        c.getAssociatedActivities().add(acts.get(1));
+
+        ActivityContext ac = new ActivityContext();
+        ac.setArrivalTime(20);
+        ac.setEndTime(20);
+        c.setRelatedActivityContext(ac);
+
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, acts.get(0), acts.get(1), r.getActivities().get(0), 20));
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED, constraint.fulfilled(c, r.getActivities().get(0), acts.get(1), r.getActivities().get(1), 30));
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED, constraint.fulfilled(c, r.getActivities().get(1), acts.get(1), r.getEnd(), 40));
+    }
+
+    @Test
+    public void whenPickupIsInsertedAt1_insertingDeliveryShipmentShouldFailWhereConstraintIsBroken(){
+        ini(25d, Double.MAX_VALUE, Double.MAX_VALUE);
+        VehicleRoute r = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory())
+            .addDelivery(d1).addDelivery(d2).build();
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId latestStartId = stateManager.createStateId("latest-start-id");
+
+        Map<String,Double> maxTimes = new HashMap<>();
+        maxTimes.put("s1",25d);
+        UpdateMaxTimeInVehicle updater = new UpdateMaxTimeInVehicle(stateManager,latestStartId,vrp.getTransportCosts(), vrp.getActivityCosts());
+        stateManager.addStateUpdater(updater);
+        stateManager.informInsertionStarts(Arrays.asList(r),new ArrayList<Job>());
+
+        MaxTimeInVehicleConstraint constraint = new MaxTimeInVehicleConstraint(vrp.getTransportCosts(),vrp.getActivityCosts() , latestStartId, stateManager, vrp);
+        JobInsertionContext c = new JobInsertionContext(r, s1,v,r.getDriver(),0.);
+        List<AbstractActivity> acts = vrp.getActivities(s1);
+        c.getAssociatedActivities().add(acts.get(0));
+        c.getAssociatedActivities().add(acts.get(1));
+
+        ActivityContext ac = new ActivityContext();
+        ac.setArrivalTime(20);
+        ac.setEndTime(20);
+        c.setRelatedActivityContext(ac);
+
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, acts.get(0), acts.get(1), r.getActivities().get(1), 20));
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED, constraint.fulfilled(c, r.getActivities().get(1), acts.get(1), r.getEnd(), 40));
+//        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED, constraint.fulfilled(c, r.getActivities().get(1), acts.get(1), r.getEnd(), 40));
+    }
+}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
index a1ed51458..5ca261555 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
@@ -37,14 +37,14 @@
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
 import com.graphhopper.jsprit.core.util.ManhattanCosts;
-
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.*;
-
-import static org.mockito.Mockito.mock;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * Created by schroeder on 18/05/16.
@@ -63,31 +63,31 @@
 
     VehicleRoutingProblem vrp;
 
-    Delivery d1,d2,newDelivery;
+    Delivery d1, d2, newDelivery;
 
     Pickup pickup;
 
     Shipment s1;
 
-    Map<Vehicle,Double> maxDistanceMap;
+    Map<Vehicle, Double> maxDistanceMap;
 
 
     @Before
-    public void doBefore(){
-        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0,0)).build();
-        vehicle2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(Location.newInstance(10,10)).build();
+    public void doBefore() {
+        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0, 0)).build();
+        vehicle2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(Location.newInstance(10, 10)).build();
 
         maxDistanceMap = new HashMap<>();
-        maxDistanceMap.put(vehicle,200d);
-        maxDistanceMap.put(vehicle2,200d);
+        maxDistanceMap.put(vehicle, 200d);
+        maxDistanceMap.put(vehicle2, 200d);
 
-        d1 = Delivery.Builder.newInstance("d1").setLocation(Location.newInstance(10,10)).build();
-        d2 = Delivery.Builder.newInstance("d2").setLocation(Location.newInstance(20,15)).build();
-        pickup = Pickup.Builder.newInstance("pickup").setLocation(Location.newInstance(50,50)).build();
-        s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(35,30))
-            .setDeliveryLocation(Location.newInstance(20,25)).build();
+        d1 = Delivery.Builder.newInstance("d1").setLocation(Location.newInstance(10, 10)).build();
+        d2 = Delivery.Builder.newInstance("d2").setLocation(Location.newInstance(20, 15)).build();
+        pickup = Pickup.Builder.newInstance("pickup").setLocation(Location.newInstance(50, 50)).build();
+        s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(35, 30))
+            .setDeliveryLocation(Location.newInstance(20, 25)).build();
 
-        newDelivery = Delivery.Builder.newInstance("new").setLocation(Location.newInstance(-10,10)).build();
+        newDelivery = Delivery.Builder.newInstance("new").setLocation(Location.newInstance(-10, 10)).build();
 
         vrp = VehicleRoutingProblem.Builder.newInstance()
             .setRoutingCost(new ManhattanCosts()).addVehicle(vehicle).addVehicle(vehicle2)
@@ -104,35 +104,35 @@ public void doBefore(){
             new com.graphhopper.jsprit.core.algorithm.state.VehicleDependentTraveledDistance(new TransportDistance() {
                 @Override
                 public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-                    return new ManhattanCosts().getDistance(from,to,departureTime,vehicle);
+                    return new ManhattanCosts().getDistance(from, to, departureTime, vehicle);
                 }
-        },stateManager,traveledDistanceId,Arrays.asList(vehicle,vehicle2));
+            }, stateManager, traveledDistanceId, Arrays.asList(vehicle, vehicle2));
 
         stateManager.addStateUpdater(traveledDistance);
         stateManager.informInsertionStarts(Arrays.asList(route), Collections.<Job>emptyList());
     }
 
     @Test
-    public void whenEndLocationIsSet_constraintShouldWork(){
-        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0,0))
-            .setEndLocation(Location.newInstance(10,0)).build();
-        Pickup pickup = Pickup.Builder.newInstance("pickup").setLocation(Location.newInstance(10,0)).build();
+    public void whenEndLocationIsSet_constraintShouldWork() {
+        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0, 0))
+            .setEndLocation(Location.newInstance(10, 0)).build();
+        Pickup pickup = Pickup.Builder.newInstance("pickup").setLocation(Location.newInstance(10, 0)).build();
         vrp = VehicleRoutingProblem.Builder.newInstance().addVehicle(vehicle).addJob(pickup).build();
         route = VehicleRoute.emptyRoute();
         maxDistanceMap = new HashMap<>();
-        maxDistanceMap.put(vehicle,5d);
+        maxDistanceMap.put(vehicle, 5d);
 
         MaxDistanceConstraint maxDistanceConstraint =
             new MaxDistanceConstraint(new StateManager(vrp), traveledDistanceId, new TransportDistance() {
                 @Override
                 public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                    return vrp.getTransportCosts().getTransportTime(from, to, departureTime, null, vehicle);
                 }
-            },maxDistanceMap);
-        JobInsertionContext context = new JobInsertionContext(route,pickup,vehicle,null,0);
+            }, maxDistanceMap);
+        JobInsertionContext context = new JobInsertionContext(route, pickup, vehicle, null, 0);
         Assert.assertTrue(maxDistanceConstraint.fulfilled(context,
-            new Start(vehicle.getStartLocation(),0,Double.MAX_VALUE),vrp.getActivities(pickup).get(0),
-            new End(vehicle.getEndLocation(),0,Double.MAX_VALUE),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+            new Start(vehicle.getStartLocation(), 0, Double.MAX_VALUE), vrp.getActivities(pickup).get(0),
+            new End(vehicle.getEndLocation(), 0, Double.MAX_VALUE), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
     }
 
     /*
@@ -142,121 +142,121 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
 vehicle2 (max distance): 180.0
      */
     @Test
-    public void insertNewInVehicleShouldFail(){
+    public void insertNewInVehicleShouldFail() {
         MaxDistanceConstraint maxDistanceConstraint =
             new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
                 @Override
                 public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                    return vrp.getTransportCosts().getTransportTime(from, to, departureTime, null, vehicle);
                 }
-            },maxDistanceMap);
-        JobInsertionContext context = new JobInsertionContext(route,newDelivery,vehicle,null,0);
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,route.getStart(),newAct(),act(0),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(0),newAct(),act(1),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(1),newAct(),act(2),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(2),newAct(),act(3),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(3),newAct(),act(4),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(4),newAct(),route.getEnd(),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+            }, maxDistanceMap);
+        JobInsertionContext context = new JobInsertionContext(route, newDelivery, vehicle, null, 0);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, route.getStart(), newAct(), act(0), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(0), newAct(), act(1), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(1), newAct(), act(2), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(2), newAct(), act(3), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(3), newAct(), act(4), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(4), newAct(), route.getEnd(), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
     }
 
 
     @Test
-    public void insertNewInVehicle2ShouldBeCorrect(){
+    public void insertNewInVehicle2ShouldBeCorrect() {
         //current distance vehicle2: 160 allowed: 200
         MaxDistanceConstraint maxDistanceConstraint =
             new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
                 @Override
                 public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                    return vrp.getTransportCosts().getTransportTime(from, to, departureTime, null, vehicle);
                 }
-            },maxDistanceMap);
-        JobInsertionContext context = new JobInsertionContext(route,newDelivery,vehicle2,null,0);
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,route.getStart(),newAct(),act(0),0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+            }, maxDistanceMap);
+        JobInsertionContext context = new JobInsertionContext(route, newDelivery, vehicle2, null, 0);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, route.getStart(), newAct(), act(0), 0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
         //additional distance: 20+35-15=40
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(0),newAct(),act(1),0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(0), newAct(), act(1), 0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
         //additional distance: 35+65-30=70
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(1),newAct(),act(2),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(1), newAct(), act(2), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
         //additional distance: 65+100-35
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(2),newAct(),act(3),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(2), newAct(), act(3), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
         //additional distance: 100+45-55
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(3),newAct(),act(4),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(3), newAct(), act(4), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
         //additional distance: 45+20-25
-        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(4),newAct(),route.getEnd(),0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(4), newAct(), route.getEnd(), 0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
     }
 
     private TourActivity act(int i) {
         return route.getActivities().get(i);
     }
 
-    private TourActivity newAct(){
+    private TourActivity newAct() {
         return vrp.getActivities(newDelivery).get(0);
     }
 
     @Test
-    public void traveledDistanceShouldBeCorrect(){
-        Assert.assertEquals(20d,stateManager.getActivityState(route.getActivities().get(0),vehicle,traveledDistanceId,Double.class),0.01);
-        Assert.assertEquals(35d,stateManager.getActivityState(route.getActivities().get(1),vehicle,traveledDistanceId,Double.class),0.01);
-        Assert.assertEquals(65d,stateManager.getActivityState(route.getActivities().get(2),vehicle,traveledDistanceId,Double.class),0.01);
-        Assert.assertEquals(100d,stateManager.getActivityState(route.getActivities().get(3),vehicle,traveledDistanceId,Double.class),0.01);
-        Assert.assertEquals(155d,stateManager.getActivityState(route.getActivities().get(4),vehicle,traveledDistanceId,Double.class),0.01);
+    public void traveledDistanceShouldBeCorrect() {
+        Assert.assertEquals(20d, stateManager.getActivityState(route.getActivities().get(0), vehicle, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(35d, stateManager.getActivityState(route.getActivities().get(1), vehicle, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(65d, stateManager.getActivityState(route.getActivities().get(2), vehicle, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(100d, stateManager.getActivityState(route.getActivities().get(3), vehicle, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(155d, stateManager.getActivityState(route.getActivities().get(4), vehicle, traveledDistanceId, Double.class), 0.01);
 
     }
 
     @Test
-    public void traveledDistanceWithVehicle2ShouldBeCorrect(){
-        Assert.assertEquals(0d,stateManager.getActivityState(route.getActivities().get(0),vehicle2,traveledDistanceId,Double.class),0.01);
-        Assert.assertEquals(15d,stateManager.getActivityState(route.getActivities().get(1),vehicle2,traveledDistanceId,Double.class),0.01);
-        Assert.assertEquals(45d,stateManager.getActivityState(route.getActivities().get(2),vehicle2,traveledDistanceId,Double.class),0.01);
-        Assert.assertEquals(80d,stateManager.getActivityState(route.getActivities().get(3),vehicle2,traveledDistanceId,Double.class),0.01);
-        Assert.assertEquals(135d,stateManager.getActivityState(route.getActivities().get(4),vehicle2,traveledDistanceId,Double.class),0.01);
+    public void traveledDistanceWithVehicle2ShouldBeCorrect() {
+        Assert.assertEquals(0d, stateManager.getActivityState(route.getActivities().get(0), vehicle2, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(15d, stateManager.getActivityState(route.getActivities().get(1), vehicle2, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(45d, stateManager.getActivityState(route.getActivities().get(2), vehicle2, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(80d, stateManager.getActivityState(route.getActivities().get(3), vehicle2, traveledDistanceId, Double.class), 0.01);
+        Assert.assertEquals(135d, stateManager.getActivityState(route.getActivities().get(4), vehicle2, traveledDistanceId, Double.class), 0.01);
 
     }
 
     @Test
-    public void distanceOfShipmentInRoute(){
-        double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(2), vehicle,traveledDistanceId, Double.class);
+    public void distanceOfShipmentInRoute() {
+        double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(2), vehicle, traveledDistanceId, Double.class);
         double traveledDistanceBeforeDelivery = stateManager.getActivityState(route.getActivities().get(4), vehicle, traveledDistanceId, Double.class);
-        Assert.assertEquals(90d,traveledDistanceBeforeDelivery-traveledDistanceBeforePickup,0.01);
+        Assert.assertEquals(90d, traveledDistanceBeforeDelivery - traveledDistanceBeforePickup, 0.01);
     }
 
     @Test
-    public void distanceOfShipmentInRouteVehicle2(){
-        double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(2), vehicle2,traveledDistanceId, Double.class);
+    public void distanceOfShipmentInRouteVehicle2() {
+        double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(2), vehicle2, traveledDistanceId, Double.class);
         double traveledDistanceBeforeDelivery = stateManager.getActivityState(route.getActivities().get(4), vehicle2, traveledDistanceId, Double.class);
-        Assert.assertEquals(90d,traveledDistanceBeforeDelivery-traveledDistanceBeforePickup,0.01);
+        Assert.assertEquals(90d, traveledDistanceBeforeDelivery - traveledDistanceBeforePickup, 0.01);
     }
 
     @Test
-    public void distanceOfPickupInRoute(){
+    public void distanceOfPickupInRoute() {
         double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(3), vehicle, traveledDistanceId, Double.class);
-        double total = stateManager.getRouteState(route, vehicle,traveledDistanceId, Double.class);
-        Assert.assertEquals(100d,total-traveledDistanceBeforePickup,0.01);
+        double total = stateManager.getRouteState(route, vehicle, traveledDistanceId, Double.class);
+        Assert.assertEquals(100d, total - traveledDistanceBeforePickup, 0.01);
     }
 
     @Test
-    public void distanceOfPickupInRouteVehicle2(){
+    public void distanceOfPickupInRouteVehicle2() {
         double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(3), vehicle2, traveledDistanceId, Double.class);
-        double total = stateManager.getRouteState(route, vehicle2,traveledDistanceId, Double.class);
-        Assert.assertEquals(80d,total-traveledDistanceBeforePickup,0.01);
+        double total = stateManager.getRouteState(route, vehicle2, traveledDistanceId, Double.class);
+        Assert.assertEquals(80d, total - traveledDistanceBeforePickup, 0.01);
     }
 
     @Test
-    public void distanceToTravelShouldBeCorrect(){
+    public void distanceToTravelShouldBeCorrect() {
         double total = stateManager.getRouteState(route, vehicle, traveledDistanceId, Double.class);
-        Assert.assertEquals(180d,total - stateManager.getActivityState(route.getActivities().get(0),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(180d, total - stateManager.getActivityState(route.getActivities().get(0), vehicle, traveledDistanceId, Double.class), 0.01);
         Assert.assertEquals(165d, total - stateManager.getActivityState(route.getActivities().get(1), vehicle, traveledDistanceId, Double.class), 0.01);
-        Assert.assertEquals(135d,total - stateManager.getActivityState(route.getActivities().get(2),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(135d, total - stateManager.getActivityState(route.getActivities().get(2), vehicle, traveledDistanceId, Double.class), 0.01);
         Assert.assertEquals(100d, total - stateManager.getActivityState(route.getActivities().get(3), vehicle, traveledDistanceId, Double.class), 0.01);
         Assert.assertEquals(45d, total - stateManager.getActivityState(route.getActivities().get(4), vehicle, traveledDistanceId, Double.class), 0.01);
 
     }
 
     @Test
-    public void distanceToTravelShouldBeCorrectVehicle2(){
+    public void distanceToTravelShouldBeCorrectVehicle2() {
         double total = stateManager.getRouteState(route, vehicle2, traveledDistanceId, Double.class);
-        Assert.assertEquals(160d,total - stateManager.getActivityState(route.getActivities().get(0),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(160d, total - stateManager.getActivityState(route.getActivities().get(0), vehicle2, traveledDistanceId, Double.class), 0.01);
         Assert.assertEquals(145d, total - stateManager.getActivityState(route.getActivities().get(1), vehicle2, traveledDistanceId, Double.class), 0.01);
-        Assert.assertEquals(115d,total - stateManager.getActivityState(route.getActivities().get(2),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(115d, total - stateManager.getActivityState(route.getActivities().get(2), vehicle2, traveledDistanceId, Double.class), 0.01);
         Assert.assertEquals(80d, total - stateManager.getActivityState(route.getActivities().get(3), vehicle2, traveledDistanceId, Double.class), 0.01);
         Assert.assertEquals(25d, total - stateManager.getActivityState(route.getActivities().get(4), vehicle2, traveledDistanceId, Double.class), 0.01);
 
@@ -280,16 +280,16 @@ public void whenAddingDeliverShipment_constraintShouldWork() {
         context.getAssociatedActivities().add(vrp.getActivities(shipment).get(0));
         context.getAssociatedActivities().add(vrp.getActivities(shipment).get(1));
         maxDistanceMap = new HashMap<>();
-        maxDistanceMap.put(vehicle,12d);
+        maxDistanceMap.put(vehicle, 12d);
 
         StateManager stateManager = new StateManager(vrp);
         MaxDistanceConstraint maxDistanceConstraint =
             new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
                 @Override
                 public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                    return vrp.getTransportCosts().getTransportTime(from, to, departureTime, null, vehicle);
                 }
-            },maxDistanceMap);
+            }, maxDistanceMap);
         Assert.assertTrue(maxDistanceConstraint.fulfilled(context,
             new Start(vehicle.getStartLocation(), 0, Double.MAX_VALUE),
             vrp.getActivities(shipment).get(0),
@@ -327,16 +327,16 @@ public void whenAddingDeliverShipmentWithVehDiffStartEndLocs_constraintShouldWor
         context.getAssociatedActivities().add(vrp.getActivities(shipment).get(0));
         context.getAssociatedActivities().add(vrp.getActivities(shipment).get(1));
         maxDistanceMap = new HashMap<>();
-        maxDistanceMap.put(vehicle,10d);
+        maxDistanceMap.put(vehicle, 10d);
 
         StateManager stateManager = new StateManager(vrp);
         MaxDistanceConstraint maxDistanceConstraint =
             new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
                 @Override
                 public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                    return vrp.getTransportCosts().getTransportTime(from, to, departureTime, null, vehicle);
                 }
-            },maxDistanceMap);
+            }, maxDistanceMap);
         Assert.assertTrue(maxDistanceConstraint.fulfilled(context,
             new Start(vehicle.getStartLocation(), 0, Double.MAX_VALUE),
             vrp.getActivities(shipment).get(0),
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/DeliveryTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/DeliveryTest.java
index 3eb0b141f..3ee2dadc6 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/DeliveryTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/DeliveryTest.java
@@ -17,18 +17,14 @@
  */
 package com.graphhopper.jsprit.core.problem.job;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import com.graphhopper.jsprit.core.problem.Location;
+import org.junit.Assert;
+import org.junit.Test;
 
 import java.util.HashMap;
 import java.util.Map;
 
-import org.junit.Assert;
-import org.junit.Test;
-
-import com.graphhopper.jsprit.core.problem.Location;
+import static org.junit.Assert.*;
 
 public class DeliveryTest {
 
@@ -40,9 +36,9 @@ public void whenNeitherLocationIdNorCoordIsSet_itThrowsException() {
     @Test
     public void whenAddingTwoCapDimension_nuOfDimsShouldBeTwo() {
         Delivery one = Delivery.Builder.newInstance("s").setLocation(Location.newInstance("foofoo"))
-                .addSizeDimension(0, 2)
-                .addSizeDimension(1, 4)
-                .build();
+            .addSizeDimension(0, 2)
+            .addSizeDimension(1, 4)
+            .build();
         assertEquals(2, one.getSize().getNuOfDimensions());
         assertEquals(2, one.getSize().get(0));
         assertEquals(4, one.getSize().get(1));
@@ -52,7 +48,7 @@ public void whenAddingTwoCapDimension_nuOfDimsShouldBeTwo() {
     @Test
     public void whenPickupIsBuiltWithoutSpecifyingCapacity_itShouldHvCapWithOneDimAndDimValOfZero() {
         Delivery one = Delivery.Builder.newInstance("s").setLocation(Location.newInstance("foofoo"))
-                .build();
+            .build();
         assertEquals(1, one.getSize().getNuOfDimensions());
         assertEquals(0, one.getSize().get(0));
     }
@@ -60,7 +56,7 @@ public void whenPickupIsBuiltWithoutSpecifyingCapacity_itShouldHvCapWithOneDimAn
     @Test
     public void whenPickupIsBuiltWithConstructorWhereSizeIsSpecified_capacityShouldBeSetCorrectly() {
         Delivery one = Delivery.Builder.newInstance("s").addSizeDimension(0, 1).setLocation(Location.newInstance("foofoo"))
-                .build();
+            .build();
         assertEquals(1, one.getSize().getNuOfDimensions());
         assertEquals(1, one.getSize().get(0));
     }
@@ -68,7 +64,7 @@ public void whenPickupIsBuiltWithConstructorWhereSizeIsSpecified_capacityShouldB
     @Test
     public void whenAddingSkills_theyShouldBeAddedCorrectly() {
         Delivery s = Delivery.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .addRequiredSkill("drill").addRequiredSkill("screwdriver").build();
+            .addRequiredSkill("drill").addRequiredSkill("screwdriver").build();
         assertTrue(s.getRequiredSkills().containsSkill("drill"));
         assertTrue(s.getRequiredSkills().containsSkill("ScrewDriver"));
     }
@@ -76,7 +72,7 @@ public void whenAddingSkills_theyShouldBeAddedCorrectly() {
     @Test
     public void whenAddingSkillsCaseSens_theyShouldBeAddedCorrectly() {
         Delivery s = Delivery.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .addRequiredSkill("DriLl").addRequiredSkill("screwDriver").build();
+            .addRequiredSkill("DriLl").addRequiredSkill("screwDriver").build();
         assertTrue(s.getRequiredSkills().containsSkill("drill"));
         assertTrue(s.getRequiredSkills().containsSkill("drilL"));
     }
@@ -84,7 +80,7 @@ public void whenAddingSkillsCaseSens_theyShouldBeAddedCorrectly() {
     @Test
     public void whenAddingSkillsCaseSensV2_theyShouldBeAddedCorrectly() {
         Delivery s = Delivery.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .addRequiredSkill("screwDriver").build();
+            .addRequiredSkill("screwDriver").build();
         assertFalse(s.getRequiredSkills().containsSkill("drill"));
         assertFalse(s.getRequiredSkills().containsSkill("drilL"));
     }
@@ -92,31 +88,46 @@ public void whenAddingSkillsCaseSensV2_theyShouldBeAddedCorrectly() {
     @Test
     public void nameShouldBeAssigned() {
         Delivery s = Delivery.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .setName("name").build();
+            .setName("name").build();
         assertEquals("name", s.getName());
     }
 
     @Test
     public void whenSettingPriorities_itShouldBeSetCorrectly(){
         Delivery s = Delivery.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .setPriority(3).build();
+            .setPriority(3).build();
         Assert.assertEquals(3, s.getPriority());
     }
 
     @Test
     public void whenNotSettingPriorities_defaultShouldBe(){
         Delivery s = Delivery.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .build();
+            .build();
         Assert.assertEquals(2, s.getPriority());
     }
 
+    @Test
+    public void whenAddingMaxTimeInVehicle_itShouldBeSet(){
+        Delivery s = Delivery.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+            .setMaxTimeInVehicle(10)
+            .build();
+        Assert.assertEquals(10, s.getMaxTimeInVehicle(),0.001);
+    }
+
+    @Test
+    public void whenNotAddingMaxTimeInVehicle_itShouldBeDefault(){
+        Delivery s = Delivery.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+            .build();
+        Assert.assertEquals(Double.MAX_VALUE, s.getMaxTimeInVehicle(),0.001);
+    }
+
 
     @Test
     public void whenSettingUserData_itIsAssociatedWithTheJob() {
         Delivery one = Delivery.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .setUserData(new HashMap<String, Object>()).build();
+            .setUserData(new HashMap<String, Object>()).build();
         Delivery two = Delivery.Builder.newInstance("s2").setLocation(Location.newInstance("loc")).setUserData(42)
-                .build();
+            .build();
         Delivery three = Delivery.Builder.newInstance("s3").setLocation(Location.newInstance("loc")).build();
 
         assertTrue(one.getUserData() instanceof Map);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/PickupTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/PickupTest.java
index 9f36a40f9..b480b5296 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/PickupTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/PickupTest.java
@@ -17,18 +17,14 @@
  */
 package com.graphhopper.jsprit.core.problem.job;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import com.graphhopper.jsprit.core.problem.Location;
+import org.junit.Assert;
+import org.junit.Test;
 
 import java.util.HashMap;
 import java.util.Map;
 
-import org.junit.Assert;
-import org.junit.Test;
-
-import com.graphhopper.jsprit.core.problem.Location;
+import static org.junit.Assert.*;
 
 public class PickupTest {
 
@@ -40,9 +36,9 @@ public void whenNeitherLocationIdNorCoordIsSet_itThrowsException() {
     @Test
     public void whenAddingTwoCapDimension_nuOfDimsShouldBeTwo() {
         Pickup one = Pickup.Builder.newInstance("s").setLocation(Location.newInstance("foofoo"))
-                .addSizeDimension(0, 2)
-                .addSizeDimension(1, 4)
-                .build();
+            .addSizeDimension(0, 2)
+            .addSizeDimension(1, 4)
+            .build();
         assertEquals(2, one.getSize().getNuOfDimensions());
         assertEquals(2, one.getSize().get(0));
         assertEquals(4, one.getSize().get(1));
@@ -52,7 +48,7 @@ public void whenAddingTwoCapDimension_nuOfDimsShouldBeTwo() {
     @Test
     public void whenPickupIsBuiltWithoutSpecifyingCapacity_itShouldHvCapWithOneDimAndDimValOfZero() {
         Pickup one = Pickup.Builder.newInstance("s").setLocation(Location.newInstance("foofoo"))
-                .build();
+            .build();
         assertEquals(1, one.getSize().getNuOfDimensions());
         assertEquals(0, one.getSize().get(0));
     }
@@ -60,7 +56,7 @@ public void whenPickupIsBuiltWithoutSpecifyingCapacity_itShouldHvCapWithOneDimAn
     @Test
     public void whenPickupIsBuiltWithConstructorWhereSizeIsSpecified_capacityShouldBeSetCorrectly() {
         Pickup one = Pickup.Builder.newInstance("s").addSizeDimension(0, 1).setLocation(Location.newInstance("foofoo"))
-                .build();
+            .build();
         assertEquals(1, one.getSize().getNuOfDimensions());
         assertEquals(1, one.getSize().get(0));
     }
@@ -68,7 +64,7 @@ public void whenPickupIsBuiltWithConstructorWhereSizeIsSpecified_capacityShouldB
     @Test
     public void whenAddingSkills_theyShouldBeAddedCorrectly() {
         Pickup s = Pickup.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .addRequiredSkill("drill").addRequiredSkill("screwdriver").build();
+            .addRequiredSkill("drill").addRequiredSkill("screwdriver").build();
         assertTrue(s.getRequiredSkills().containsSkill("drill"));
         assertTrue(s.getRequiredSkills().containsSkill("drill"));
         assertTrue(s.getRequiredSkills().containsSkill("ScrewDriver"));
@@ -77,7 +73,7 @@ public void whenAddingSkills_theyShouldBeAddedCorrectly() {
     @Test
     public void whenAddingSkillsCaseSens_theyShouldBeAddedCorrectly() {
         Pickup s = Pickup.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .addRequiredSkill("DriLl").addRequiredSkill("screwDriver").build();
+            .addRequiredSkill("DriLl").addRequiredSkill("screwDriver").build();
         assertTrue(s.getRequiredSkills().containsSkill("drill"));
         assertTrue(s.getRequiredSkills().containsSkill("drilL"));
     }
@@ -85,7 +81,7 @@ public void whenAddingSkillsCaseSens_theyShouldBeAddedCorrectly() {
     @Test
     public void whenAddingSkillsCaseSensV2_theyShouldBeAddedCorrectly() {
         Pickup s = Pickup.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .addRequiredSkill("screwDriver").build();
+            .addRequiredSkill("screwDriver").build();
         assertFalse(s.getRequiredSkills().containsSkill("drill"));
         assertFalse(s.getRequiredSkills().containsSkill("drilL"));
     }
@@ -93,7 +89,7 @@ public void whenAddingSkillsCaseSensV2_theyShouldBeAddedCorrectly() {
     @Test
     public void nameShouldBeAssigned() {
         Pickup s = Pickup.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .setName("name").build();
+            .setName("name").build();
         assertEquals("name", s.getName());
     }
 
@@ -101,21 +97,21 @@ public void nameShouldBeAssigned() {
     @Test
     public void whenSettingPriorities_itShouldBeSetCorrectly(){
         Pickup s = Pickup.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .setPriority(3).build();
+            .setPriority(3).build();
         Assert.assertEquals(3, s.getPriority());
     }
 
     @Test
     public void whenNotSettingPriorities_defaultShouldBe(){
         Pickup s = Pickup.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .build();
+            .build();
         Assert.assertEquals(2, s.getPriority());
     }
 
     @Test
     public void whenSettingUserData_itIsAssociatedWithTheJob() {
         Pickup one = Pickup.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .setUserData(new HashMap<String, Object>()).build();
+            .setUserData(new HashMap<String, Object>()).build();
         Pickup two = Pickup.Builder.newInstance("s2").setLocation(Location.newInstance("loc")).setUserData(42).build();
         Pickup three = Pickup.Builder.newInstance("s3").setLocation(Location.newInstance("loc")).build();
 
@@ -123,4 +119,19 @@ public void whenSettingUserData_itIsAssociatedWithTheJob() {
         assertEquals(42, two.getUserData());
         assertNull(three.getUserData());
     }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void whenAddingMaxTimeInVehicle_itShouldThrowEx(){
+        Pickup s = Pickup.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+            .setMaxTimeInVehicle(10)
+            .build();
+    }
+
+    @Test
+    public void whenNotAddingMaxTimeInVehicle_itShouldBeDefault(){
+        Pickup s = Pickup.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+            .build();
+        Assert.assertEquals(Double.MAX_VALUE, s.getMaxTimeInVehicle(),0.001);
+    }
+
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ServiceTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ServiceTest.java
index 6b051e84c..9ab100159 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ServiceTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ServiceTest.java
@@ -17,25 +17,19 @@
  */
 package com.graphhopper.jsprit.core.problem.job;
 
-import static org.hamcrest.core.Is.is;
-import static org.hamcrest.core.IsCollectionContaining.hasItem;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
+import org.junit.Assert;
+import org.junit.Test;
 
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
-import org.junit.Assert;
-import org.junit.Test;
-
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
+import static org.hamcrest.core.Is.is;
+import static org.hamcrest.core.IsCollectionContaining.hasItem;
+import static org.junit.Assert.*;
 
 public class ServiceTest {
 
@@ -75,16 +69,16 @@ public void whenCapacityDimValueIsNegative_throwIllegalStateExpception() {
     @Test
     public void whenAddingTwoCapDimension_nuOfDimsShouldBeTwo() {
         Service one = Service.Builder.newInstance("s").setLocation(Location.newInstance("foofoo"))
-                .addSizeDimension(0, 2)
-                .addSizeDimension(1, 4)
-                .build();
+            .addSizeDimension(0, 2)
+            .addSizeDimension(1, 4)
+            .build();
         assertEquals(2, one.getSize().getNuOfDimensions());
     }
 
     @Test
     public void whenShipmentIsBuiltWithoutSpecifyingCapacity_itShouldHvCapWithOneDimAndDimValOfZero() {
         Service one = Service.Builder.newInstance("s").setLocation(Location.newInstance("foofoo"))
-                .build();
+            .build();
         assertEquals(1, one.getSize().getNuOfDimensions());
         assertEquals(0, one.getSize().get(0));
     }
@@ -92,7 +86,7 @@ public void whenShipmentIsBuiltWithoutSpecifyingCapacity_itShouldHvCapWithOneDim
     @Test
     public void whenShipmentIsBuiltWithConstructorWhereSizeIsSpecified_capacityShouldBeSetCorrectly() {
         Service one = Service.Builder.newInstance("s").addSizeDimension(0, 1).setLocation(Location.newInstance("foofoo"))
-                .build();
+            .build();
         assertEquals(1, one.getSize().getNuOfDimensions());
         assertEquals(1, one.getSize().get(0));
     }
@@ -125,58 +119,58 @@ public void whenSettingLocation_itShouldWork() {
 
 
     @Test
-    public void whenSettingLocationCoord_itShouldBeSetCorrectly(){
+    public void whenSettingLocationCoord_itShouldBeSetCorrectly() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance(1, 2)).build();
-        assertEquals(1.0,s.getLocation().getCoordinate().getX(),0.01);
-        assertEquals(2.0,s.getLocation().getCoordinate().getY(),0.01);
+        assertEquals(1.0, s.getLocation().getCoordinate().getX(), 0.01);
+        assertEquals(2.0, s.getLocation().getCoordinate().getY(), 0.01);
         assertEquals(1.0,s.getLocation().getCoordinate().getX(),0.01);
         assertEquals(2.0,s.getLocation().getCoordinate().getY(),0.01);
     }
 
-    @Test(expected=IllegalArgumentException.class)
-    public void whenSettingNeitherLocationIdNorCoord_throwsException(){
+    @Test(expected = IllegalArgumentException.class)
+    public void whenSettingNeitherLocationIdNorCoord_throwsException() {
         @SuppressWarnings("unused")
         Service s = Service.Builder.newInstance("s").build();
     }
 
-    @Test(expected=IllegalArgumentException.class)
-    public void whenServiceTimeSmallerZero_throwIllegalStateException(){
+    @Test(expected = IllegalArgumentException.class)
+    public void whenServiceTimeSmallerZero_throwIllegalStateException() {
         @SuppressWarnings("unused")
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).setServiceTime(-1).build();
     }
 
     @Test
-    public void whenSettingServiceTime_itShouldBeSetCorrectly(){
+    public void whenSettingServiceTime_itShouldBeSetCorrectly() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).setServiceTime(1).build();
-        assertEquals(1.0,s.getServiceDuration(),0.01);
+        assertEquals(1.0, s.getServiceDuration(), 0.01);
     }
 
-    @Test(expected=IllegalArgumentException.class)
-    public void whenTimeWindowIsNull_throwException(){
+    @Test(expected = IllegalArgumentException.class)
+    public void whenTimeWindowIsNull_throwException() {
         @SuppressWarnings("unused")
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).setTimeWindow(null).build();
     }
 
     @Test
-    public void whenSettingTimeWindow_itShouldBeSetCorrectly(){
+    public void whenSettingTimeWindow_itShouldBeSetCorrectly() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).setTimeWindow(TimeWindow.newInstance(1.0, 2.0)).build();
-        assertEquals(1.0,s.getTimeWindow().getStart(),0.01);
-        assertEquals(2.0,s.getTimeWindow().getEnd(),0.01);
+        assertEquals(1.0, s.getTimeWindow().getStart(), 0.01);
+        assertEquals(2.0, s.getTimeWindow().getEnd(), 0.01);
     }
 
     @Test
-    public void whenAddingSkills_theyShouldBeAddedCorrectly(){
+    public void whenAddingSkills_theyShouldBeAddedCorrectly() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .addRequiredSkill("drill").addRequiredSkill("screwdriver").build();
+            .addRequiredSkill("drill").addRequiredSkill("screwdriver").build();
         assertTrue(s.getRequiredSkills().containsSkill("drill"));
         assertTrue(s.getRequiredSkills().containsSkill("drill"));
         assertTrue(s.getRequiredSkills().containsSkill("ScrewDriver"));
     }
 
     @Test
-    public void whenAddingSkillsCaseSens_theyShouldBeAddedCorrectly(){
+    public void whenAddingSkillsCaseSens_theyShouldBeAddedCorrectly() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .addRequiredSkill("DriLl").addRequiredSkill("screwDriver").build();
+            .addRequiredSkill("DriLl").addRequiredSkill("screwDriver").build();
         assertTrue(s.getRequiredSkills().containsSkill("drill"));
         assertTrue(s.getRequiredSkills().containsSkill("drilL"));
     }
@@ -186,9 +180,9 @@ public void whenAddingSeveralTimeWindows_itShouldBeSetCorrectly(){
         TimeWindow tw1 = TimeWindow.newInstance(1.0, 2.0);
         TimeWindow tw2 = TimeWindow.newInstance(3.0, 5.0);
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .addTimeWindow(tw1)
-                .addTimeWindow(tw2)
-                .build();
+            .addTimeWindow(tw1)
+            .addTimeWindow(tw2)
+            .build();
         assertEquals(2, s.getTimeWindows().size());
         assertThat(s.getTimeWindows(),hasItem(is(tw1)));
         assertThat(s.getTimeWindows(),hasItem(is(tw2)));
@@ -197,7 +191,7 @@ public void whenAddingSeveralTimeWindows_itShouldBeSetCorrectly(){
     @Test
     public void whenAddingTimeWindow_itShouldBeSetCorrectly(){
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .addTimeWindow(TimeWindow.newInstance(1.0, 2.0)).build();
+            .addTimeWindow(TimeWindow.newInstance(1.0, 2.0)).build();
         assertEquals(1.0, s.getTimeWindow().getStart(), 0.01);
         assertEquals(2.0, s.getTimeWindow().getEnd(), 0.01);
     }
@@ -208,7 +202,7 @@ public void whenAddingTimeWindow_itShouldBeSetCorrectly(){
     @Test
     public void whenAddingSkillsCaseSensV2_theyShouldBeAddedCorrectly() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .addRequiredSkill("screwDriver").build();
+            .addRequiredSkill("screwDriver").build();
         assertFalse(s.getRequiredSkills().containsSkill("drill"));
         assertFalse(s.getRequiredSkills().containsSkill("drilL"));
     }
@@ -216,83 +210,97 @@ public void whenAddingSkillsCaseSensV2_theyShouldBeAddedCorrectly() {
     @Test
     public void nameShouldBeAssigned() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .setName("name").build();
+            .setName("name").build();
         assertEquals("name", s.getName());
     }
 
     @Test
-    public void shouldKnowMultipleTimeWindows(){
+    public void shouldKnowMultipleTimeWindows() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .addTimeWindow(TimeWindow.newInstance(0., 10.)).addTimeWindow(TimeWindow.newInstance(20., 30.))
-                .setName("name").build();
-        assertEquals(2,s.getTimeWindows().size());
+            .addTimeWindow(TimeWindow.newInstance(0., 10.)).addTimeWindow(TimeWindow.newInstance(20., 30.))
+            .setName("name").build();
+        assertEquals(2, s.getTimeWindows().size());
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void whenMultipleTWOverlap_throwEx(){
+    public void whenMultipleTWOverlap_throwEx() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .addTimeWindow(TimeWindow.newInstance(0.,10.))
-                .addTimeWindow(TimeWindow.newInstance(5., 30.))
-                .setName("name").build();
+            .addTimeWindow(TimeWindow.newInstance(0., 10.))
+            .addTimeWindow(TimeWindow.newInstance(5., 30.))
+            .setName("name").build();
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void whenMultipleTWOverlap2_throwEx(){
+    public void whenMultipleTWOverlap2_throwEx() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .addTimeWindow(TimeWindow.newInstance(20., 30.))
-                .addTimeWindow(TimeWindow.newInstance(0., 25.))
-                .setName("name").build();
+            .addTimeWindow(TimeWindow.newInstance(20., 30.))
+            .addTimeWindow(TimeWindow.newInstance(0., 25.))
+            .setName("name").build();
     }
 
     @Test
     public void whenSettingPriorities_itShouldBeSetCorrectly(){
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .setPriority(1).build();
+            .setPriority(1).build();
         Assert.assertEquals(1, s.getPriority());
     }
 
     @Test
     public void whenSettingPriorities_itShouldBeSetCorrectly2(){
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .setPriority(3).build();
+            .setPriority(3).build();
         Assert.assertEquals(3, s.getPriority());
     }
 
     @Test
     public void whenSettingPriorities_itShouldBeSetCorrectly3() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .setPriority(10).build();
+            .setPriority(10).build();
         Assert.assertEquals(10, s.getPriority());
     }
 
     @Test
     public void whenNotSettingPriorities_defaultShouldBe2(){
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .build();
+            .build();
         Assert.assertEquals(2, s.getPriority());
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void whenSettingIncorrectPriorities_itShouldThrowException(){
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .setPriority(30).build();
+            .setPriority(30).build();
 
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void whenSettingIncorrectPriorities_itShouldThrowException2(){
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .setPriority(0).build();
+            .setPriority(0).build();
 
     }
 
+    @Test(expected = UnsupportedOperationException.class)
+    public void whenAddingMaxTimeInVehicle_itShouldThrowEx(){
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+            .setMaxTimeInVehicle(10)
+            .build();
+    }
+
+    @Test
+    public void whenNotAddingMaxTimeInVehicle_itShouldBeDefault(){
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+            .build();
+        Assert.assertEquals(Double.MAX_VALUE, s.getMaxTimeInVehicle(),0.001);
+    }
+
 
     @Test
     public void whenSettingUserData_itIsAssociatedWithTheJob() {
         Service one = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
-                .setUserData(new HashMap<String, Object>()).build();
+            .setUserData(new HashMap<String, Object>()).build();
         Service two = Service.Builder.newInstance("s2").setLocation(Location.newInstance("loc")).setUserData(42)
-                .build();
+            .build();
         Service three = Service.Builder.newInstance("s3").setLocation(Location.newInstance("loc")).build();
 
         assertTrue(one.getUserData() instanceof Map);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ShipmentTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ShipmentTest.java
index e7caf2c11..7e271092e 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ShipmentTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ShipmentTest.java
@@ -17,34 +17,28 @@
  */
 package com.graphhopper.jsprit.core.problem.job;
 
-import static org.hamcrest.core.Is.is;
-import static org.hamcrest.core.IsCollectionContaining.hasItem;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.junit.Assert;
-import org.junit.Test;
-
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
 import com.graphhopper.jsprit.core.util.Coordinate;
 import com.graphhopper.jsprit.core.util.TestUtils;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.hamcrest.core.Is.is;
+import static org.hamcrest.core.IsCollectionContaining.hasItem;
+import static org.junit.Assert.*;
 
 public class ShipmentTest {
 
     @Test
     public void whenTwoShipmentsHaveTheSameId_theyReferencesShouldBeUnEqual() {
         Shipment one = Shipment.Builder.newInstance("s").addSizeDimension(0, 10).setPickupLocation(Location.Builder.newInstance().setId("foo").build()).
-                setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
+            setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
         Shipment two = Shipment.Builder.newInstance("s").addSizeDimension(0, 10).setPickupLocation(Location.Builder.newInstance().setId("foo").build()).
-                setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
+            setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
 
         assertTrue(one != two);
     }
@@ -52,9 +46,9 @@ public void whenTwoShipmentsHaveTheSameId_theyReferencesShouldBeUnEqual() {
     @Test
     public void whenTwoShipmentsHaveTheSameId_theyShouldBeEqual() {
         Shipment one = Shipment.Builder.newInstance("s").addSizeDimension(0, 10).setPickupLocation(Location.Builder.newInstance().setId("foo").build()).
-                setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
+            setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
         Shipment two = Shipment.Builder.newInstance("s").addSizeDimension(0, 10).setPickupLocation(Location.Builder.newInstance().setId("foo").build()).
-                setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
+            setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
 
         assertTrue(one.equals(two));
     }
@@ -62,7 +56,7 @@ public void whenTwoShipmentsHaveTheSameId_theyShouldBeEqual() {
     @Test
     public void whenShipmentIsInstantiatedWithASizeOf10_theSizeShouldBe10() {
         Shipment one = Shipment.Builder.newInstance("s").addSizeDimension(0, 10).setPickupLocation(Location.Builder.newInstance().setId("foo").build()).
-                setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
+            setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
         assertEquals(10, one.getSize().get(0));
     }
 
@@ -70,24 +64,24 @@ public void whenShipmentIsInstantiatedWithASizeOf10_theSizeShouldBe10() {
     public void whenShipmentIsBuiltWithNegativeDemand_itShouldThrowException() {
         @SuppressWarnings("unused")
         Shipment one = Shipment.Builder.newInstance("s").addSizeDimension(0, -10)
-        .setPickupLocation(Location.Builder.newInstance().setId("foo").build())
-        .setDeliveryLocation(TestUtils.loc("foofoo")).build();
+            .setPickupLocation(Location.Builder.newInstance().setId("foo").build())
+            .setDeliveryLocation(TestUtils.loc("foofoo")).build();
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void whenShipmentIsBuiltWithNegativeDemand_itShouldThrowException_v2() {
         @SuppressWarnings("unused")
         Shipment one = Shipment.Builder.newInstance("s").addSizeDimension(0, -10)
-        .setPickupLocation(Location.Builder.newInstance().setId("foo").build())
-        .setDeliveryLocation(TestUtils.loc("foofoo")).build();
+            .setPickupLocation(Location.Builder.newInstance().setId("foo").build())
+            .setDeliveryLocation(TestUtils.loc("foofoo")).build();
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void whenIdIsNull_itShouldThrowException() {
         @SuppressWarnings("unused")
         Shipment one = Shipment.Builder.newInstance(null).addSizeDimension(0, 10)
-        .setPickupLocation(Location.Builder.newInstance().setId("foo").build())
-        .setDeliveryLocation(TestUtils.loc("foofoo")).build();
+            .setPickupLocation(Location.Builder.newInstance().setId("foo").build())
+            .setDeliveryLocation(TestUtils.loc("foofoo")).build();
     }
 
     @Test
@@ -124,7 +118,7 @@ public void whenPickupLocationIsNull_itThrowsException() {
     @Test
     public void whenPickupCoordIsSet_itShouldBeDoneCorrectly() {
         Shipment s = Shipment.Builder.newInstance("s")
-                .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").setCoordinate(Coordinate.newInstance(1, 2)).build()).build();
+            .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").setCoordinate(Coordinate.newInstance(1, 2)).build()).build();
         assertEquals(1.0, s.getPickupLocation().getCoordinate().getX(), 0.01);
         assertEquals(2.0, s.getPickupLocation().getCoordinate().getY(), 0.01);
         assertEquals(1.0, s.getPickupLocation().getCoordinate().getX(), 0.01);
@@ -135,7 +129,7 @@ public void whenPickupCoordIsSet_itShouldBeDoneCorrectly() {
     @Test
     public void whenDeliveryLocationIdIsSet_itShouldBeDoneCorrectly() {
         Shipment s = Shipment.Builder.newInstance("s")
-                .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+            .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
         assertEquals("delLoc", s.getDeliveryLocation().getId());
         assertEquals("delLoc", s.getDeliveryLocation().getId());
     }
@@ -144,8 +138,8 @@ public void whenDeliveryLocationIdIsSet_itShouldBeDoneCorrectly() {
     @Test
     public void whenDeliveryCoordIsSet_itShouldBeDoneCorrectly() {
         Shipment s = Shipment.Builder.newInstance("s").setDeliveryLocation(TestUtils.loc("delLoc", Coordinate.newInstance(1, 2)))
-                .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
-                .build();
+            .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
+            .build();
         assertEquals(1.0, s.getDeliveryLocation().getCoordinate().getX(), 0.01);
         assertEquals(2.0, s.getDeliveryLocation().getCoordinate().getY(), 0.01);
         assertEquals(1.0, s.getDeliveryLocation().getCoordinate().getX(), 0.01);
@@ -155,22 +149,22 @@ public void whenDeliveryCoordIsSet_itShouldBeDoneCorrectly() {
     @Test
     public void whenPickupServiceTimeIsNotSet_itShouldBeZero() {
         Shipment s = Shipment.Builder.newInstance("s")
-                .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+            .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
         assertEquals(0.0, s.getPickupServiceTime(), 0.01);
     }
 
     @Test
     public void whenDeliveryServiceTimeIsNotSet_itShouldBeZero() {
         Shipment s = Shipment.Builder.newInstance("s")
-                .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+            .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
         assertEquals(0.0, s.getDeliveryServiceTime(), 0.01);
     }
 
     @Test
     public void whenPickupServiceTimeIsSet_itShouldBeDoneCorrectly() {
         Shipment s = Shipment.Builder.newInstance("s")
-                .setPickupServiceTime(2.0)
-                .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+            .setPickupServiceTime(2.0)
+            .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
         assertEquals(2.0, s.getPickupServiceTime(), 0.01);
     }
 
@@ -178,13 +172,13 @@ public void whenPickupServiceTimeIsSet_itShouldBeDoneCorrectly() {
     public void whenPickupServiceIsSmallerThanZero_itShouldThrowException() {
         @SuppressWarnings("unused")
         Shipment s = Shipment.Builder.newInstance("s").setPickupServiceTime(-2.0)
-        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+            .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
     }
 
     @Test
     public void whenDeliveryServiceTimeIsSet_itShouldBeDoneCorrectly() {
         Shipment s = Shipment.Builder.newInstance("s").setDeliveryServiceTime(2.0)
-                .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+            .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
         assertEquals(2.0, s.getDeliveryServiceTime(), 0.01);
     }
 
@@ -210,7 +204,7 @@ public void whenPickupTimeWindowIsNull_itShouldThrowException() {
     @Test
     public void whenPickupTimeWindowIsSet_itShouldBeDoneCorrectly() {
         Shipment s = Shipment.Builder.newInstance("s").setPickupTimeWindow(TimeWindow.newInstance(1, 2))
-                .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+            .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
         assertEquals(1.0, s.getPickupTimeWindow().getStart(), 0.01);
         assertEquals(2.0, s.getPickupTimeWindow().getEnd(), 0.01);
     }
@@ -231,7 +225,7 @@ public void whenDeliveryTimeWindowIsNull_itShouldThrowException() {
     @Test
     public void whenDeliveryTimeWindowIsSet_itShouldBeDoneCorrectly() {
         Shipment s = Shipment.Builder.newInstance("s").setDeliveryTimeWindow(TimeWindow.newInstance(1, 2))
-                .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+            .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
         assertEquals(1.0, s.getDeliveryTimeWindow().getStart(), 0.01);
         assertEquals(2.0, s.getDeliveryTimeWindow().getEnd(), 0.01);
     }
@@ -239,7 +233,7 @@ public void whenDeliveryTimeWindowIsSet_itShouldBeDoneCorrectly() {
     @Test
     public void whenUsingAddDeliveryTimeWindow_itShouldBeDoneCorrectly() {
         Shipment s = Shipment.Builder.newInstance("s").addDeliveryTimeWindow(TimeWindow.newInstance(1, 2))
-                .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+            .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
         assertEquals(1.0, s.getDeliveryTimeWindow().getStart(), 0.01);
         assertEquals(2.0, s.getDeliveryTimeWindow().getEnd(), 0.01);
     }
@@ -247,7 +241,7 @@ public void whenUsingAddDeliveryTimeWindow_itShouldBeDoneCorrectly() {
     @Test
     public void whenUsingAddDeliveryTimeWindow2_itShouldBeDoneCorrectly() {
         Shipment s = Shipment.Builder.newInstance("s").addDeliveryTimeWindow(1, 2)
-                .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+            .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
         assertEquals(1.0, s.getDeliveryTimeWindow().getStart(), 0.01);
         assertEquals(2.0, s.getDeliveryTimeWindow().getEnd(), 0.01);
     }
@@ -257,7 +251,7 @@ public void whenAddingMultipleDeliveryTimeWindows_itShouldBeDoneCorrectly() {
         TimeWindow tw1 = TimeWindow.newInstance(1,2);
         TimeWindow tw2 = TimeWindow.newInstance(4,5);
         Shipment s = Shipment.Builder.newInstance("s").addDeliveryTimeWindow(tw1).addDeliveryTimeWindow(tw2)
-                .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+            .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
         assertEquals(s.getDeliveryTimeWindows().size(),2);
         assertThat(s.getDeliveryTimeWindows(),hasItem(is(tw1)));
         assertThat(s.getDeliveryTimeWindows(),hasItem(is(tw2)));
@@ -266,7 +260,7 @@ public void whenAddingMultipleDeliveryTimeWindows_itShouldBeDoneCorrectly() {
     @Test(expected = IllegalArgumentException.class)
     public void whenAddingMultipleOverlappingDeliveryTimeWindows_itShouldThrowException() {
         Shipment s = Shipment.Builder.newInstance("s").addDeliveryTimeWindow(1, 3).addDeliveryTimeWindow(2,5)
-                .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+            .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
         assertEquals(1.0, s.getDeliveryTimeWindow().getStart(), 0.01);
         assertEquals(2.0, s.getDeliveryTimeWindow().getEnd(), 0.01);
     }
@@ -276,7 +270,7 @@ public void whenAddingMultipleOverlappingDeliveryTimeWindows_itShouldThrowExcept
     @Test
     public void whenUsingAddPickupTimeWindow_itShouldBeDoneCorrectly() {
         Shipment s = Shipment.Builder.newInstance("s").addPickupTimeWindow(TimeWindow.newInstance(1, 2))
-                .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+            .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
         assertEquals(1.0, s.getPickupTimeWindow().getStart(), 0.01);
         assertEquals(2.0, s.getPickupTimeWindow().getEnd(), 0.01);
     }
@@ -284,7 +278,7 @@ public void whenUsingAddPickupTimeWindow_itShouldBeDoneCorrectly() {
     @Test
     public void whenUsingAddPickupTimeWindow2_itShouldBeDoneCorrectly() {
         Shipment s = Shipment.Builder.newInstance("s").addPickupTimeWindow(1, 2)
-                .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+            .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
         assertEquals(1.0, s.getPickupTimeWindow().getStart(), 0.01);
         assertEquals(2.0, s.getPickupTimeWindow().getEnd(), 0.01);
     }
@@ -294,7 +288,7 @@ public void whenAddingMultiplePickupTimeWindows_itShouldBeDoneCorrectly() {
         TimeWindow tw1 = TimeWindow.newInstance(1,2);
         TimeWindow tw2 = TimeWindow.newInstance(4,5);
         Shipment s = Shipment.Builder.newInstance("s").addPickupTimeWindow(tw1).addPickupTimeWindow(tw2)
-                .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+            .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
         assertEquals(s.getPickupTimeWindows().size(),2);
         assertThat(s.getPickupTimeWindows(), hasItem(is(tw1)));
         assertThat(s.getPickupTimeWindows(), hasItem(is(tw2)));
@@ -303,7 +297,7 @@ public void whenAddingMultiplePickupTimeWindows_itShouldBeDoneCorrectly() {
     @Test(expected = IllegalArgumentException.class)
     public void whenAddingMultipleOverlappingPickupTimeWindows_itShouldThrowException() {
         Shipment s = Shipment.Builder.newInstance("s").addPickupTimeWindow(1, 3).addPickupTimeWindow(2,5)
-                .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+            .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
         assertEquals(1.0, s.getPickupTimeWindow().getStart(), 0.01);
         assertEquals(2.0, s.getPickupTimeWindow().getEnd(), 0.01);
     }
@@ -314,26 +308,26 @@ public void whenAddingMultipleOverlappingPickupTimeWindows_itShouldThrowExceptio
     public void whenShipmentHasNegativeCapacityVal_throwIllegalStateExpception() {
         @SuppressWarnings("unused")
         Shipment one = Shipment.Builder.newInstance("s").setPickupLocation(Location.Builder.newInstance().setId("foo").build())
-        .setDeliveryLocation(TestUtils.loc("foofoo"))
-        .addSizeDimension(0, -2)
-        .build();
+            .setDeliveryLocation(TestUtils.loc("foofoo"))
+            .addSizeDimension(0, -2)
+            .build();
     }
 
     @Test
     public void whenAddingTwoCapDimension_nuOfDimsShouldBeTwo() {
         Shipment one = Shipment.Builder.newInstance("s").setPickupLocation(Location.Builder.newInstance().setId("foo").build())
-                .setDeliveryLocation(TestUtils.loc("foofoo"))
-                .addSizeDimension(0, 2)
-                .addSizeDimension(1, 4)
-                .build();
+            .setDeliveryLocation(TestUtils.loc("foofoo"))
+            .addSizeDimension(0, 2)
+            .addSizeDimension(1, 4)
+            .build();
         assertEquals(2, one.getSize().getNuOfDimensions());
     }
 
     @Test
     public void whenShipmentIsBuiltWithoutSpecifyingCapacity_itShouldHvCapWithOneDimAndDimValOfZero() {
         Shipment one = Shipment.Builder.newInstance("s")
-                .setPickupLocation(Location.Builder.newInstance().setId("foo").setCoordinate(Coordinate.newInstance(0, 0)).build())
-                .setDeliveryLocation(TestUtils.loc("foofoo")).build();
+            .setPickupLocation(Location.Builder.newInstance().setId("foo").setCoordinate(Coordinate.newInstance(0, 0)).build())
+            .setDeliveryLocation(TestUtils.loc("foofoo")).build();
         assertEquals(1, one.getSize().getNuOfDimensions());
         assertEquals(0, one.getSize().get(0));
     }
@@ -341,8 +335,8 @@ public void whenShipmentIsBuiltWithoutSpecifyingCapacity_itShouldHvCapWithOneDim
     @Test
     public void whenShipmentIsBuiltWithConstructorWhereSizeIsSpecified_capacityShouldBeSetCorrectly() {
         Shipment one = Shipment.Builder.newInstance("s").addSizeDimension(0, 1)
-                .setPickupLocation(Location.Builder.newInstance().setId("foo").setCoordinate(Coordinate.newInstance(0, 0)).build())
-                .setDeliveryLocation(TestUtils.loc("foofoo")).build();
+            .setPickupLocation(Location.Builder.newInstance().setId("foo").setCoordinate(Coordinate.newInstance(0, 0)).build())
+            .setDeliveryLocation(TestUtils.loc("foofoo")).build();
         assertEquals(1, one.getSize().getNuOfDimensions());
         assertEquals(1, one.getSize().get(0));
     }
@@ -350,8 +344,8 @@ public void whenShipmentIsBuiltWithConstructorWhereSizeIsSpecified_capacityShoul
     @Test
     public void whenAddingSkills_theyShouldBeAddedCorrectly() {
         Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.Builder.newInstance().setId("loc").build())
-                .setDeliveryLocation(TestUtils.loc("delLoc"))
-                .addRequiredSkill("drill").addRequiredSkill("screwdriver").build();
+            .setDeliveryLocation(TestUtils.loc("delLoc"))
+            .addRequiredSkill("drill").addRequiredSkill("screwdriver").build();
         assertTrue(s.getRequiredSkills().containsSkill("drill"));
         assertTrue(s.getRequiredSkills().containsSkill("drill"));
         assertTrue(s.getRequiredSkills().containsSkill("ScrewDriver"));
@@ -360,9 +354,9 @@ public void whenAddingSkills_theyShouldBeAddedCorrectly() {
     @Test
     public void whenAddingSkillsCaseSens_theyShouldBeAddedCorrectly() {
         Shipment s = Shipment.Builder.newInstance("s")
-                .setPickupLocation(Location.Builder.newInstance().setId("pick").build())
-                .setDeliveryLocation(TestUtils.loc("del"))
-                .addRequiredSkill("DriLl").addRequiredSkill("screwDriver").build();
+            .setPickupLocation(Location.Builder.newInstance().setId("pick").build())
+            .setDeliveryLocation(TestUtils.loc("del"))
+            .addRequiredSkill("DriLl").addRequiredSkill("screwDriver").build();
         assertTrue(s.getRequiredSkills().containsSkill("drill"));
         assertTrue(s.getRequiredSkills().containsSkill("drilL"));
     }
@@ -370,8 +364,8 @@ public void whenAddingSkillsCaseSens_theyShouldBeAddedCorrectly() {
     @Test
     public void whenAddingSkillsCaseSensV2_theyShouldBeAddedCorrectly() {
         Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.Builder.newInstance().setId("loc").build())
-                .setDeliveryLocation(TestUtils.loc("del"))
-                .addRequiredSkill("screwDriver").build();
+            .setDeliveryLocation(TestUtils.loc("del"))
+            .addRequiredSkill("screwDriver").build();
         assertFalse(s.getRequiredSkills().containsSkill("drill"));
         assertFalse(s.getRequiredSkills().containsSkill("drilL"));
     }
@@ -379,15 +373,15 @@ public void whenAddingSkillsCaseSensV2_theyShouldBeAddedCorrectly() {
     @Test
     public void nameShouldBeAssigned() {
         Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.Builder.newInstance().setId("loc").build())
-                .setDeliveryLocation(TestUtils.loc("del"))
-                .setName("name").build();
+            .setDeliveryLocation(TestUtils.loc("del"))
+            .setName("name").build();
         assertEquals("name", s.getName());
     }
 
     @Test
     public void whenSettingLocation_itShouldWork() {
         Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.Builder.newInstance().setId("loc").build())
-                .setDeliveryLocation(Location.Builder.newInstance().setId("del").build()).build();
+            .setDeliveryLocation(Location.Builder.newInstance().setId("del").build()).build();
         assertEquals("loc", s.getPickupLocation().getId());
         assertEquals("loc", s.getPickupLocation().getId());
         assertEquals("del", s.getDeliveryLocation().getId());
@@ -397,62 +391,77 @@ public void whenSettingLocation_itShouldWork() {
     @Test
     public void whenSettingPriorities_itShouldBeSetCorrectly(){
         Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc"))
-                .setDeliveryLocation(Location.newInstance("loc"))
-                .setPriority(1).build();
+            .setDeliveryLocation(Location.newInstance("loc"))
+            .setPriority(1).build();
         Assert.assertEquals(1, s.getPriority());
     }
 
     @Test
     public void whenSettingPriorities_itShouldBeSetCorrectly2(){
         Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc"))
-                .setDeliveryLocation(Location.newInstance("loc"))
-                .setPriority(3).build();
+            .setDeliveryLocation(Location.newInstance("loc"))
+            .setPriority(3).build();
         Assert.assertEquals(3, s.getPriority());
     }
 
     @Test
     public void whenSettingPriorities_itShouldBeSetCorrectly3() {
         Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc"))
-                .setDeliveryLocation(Location.newInstance("loc"))
-                .setPriority(10).build();
+            .setDeliveryLocation(Location.newInstance("loc"))
+            .setPriority(10).build();
         Assert.assertEquals(10, s.getPriority());
     }
 
     @Test
     public void whenNotSettingPriorities_defaultShouldBe2(){
         Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc"))
-                .setDeliveryLocation(Location.newInstance("loc"))
-                .build();
+            .setDeliveryLocation(Location.newInstance("loc"))
+            .build();
         Assert.assertEquals(2, s.getPriority());
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void whenSettingIncorrectPriorities_itShouldThrowException(){
         Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc"))
-                .setDeliveryLocation(Location.newInstance("loc"))
-                .setPriority(30).build();
+            .setDeliveryLocation(Location.newInstance("loc"))
+            .setPriority(30).build();
 
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void whenSettingIncorrectPriorities_itShouldThrowException2(){
         Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc"))
-                .setDeliveryLocation(Location.newInstance("loc"))
-                .setPriority(0).build();
+            .setDeliveryLocation(Location.newInstance("loc"))
+            .setPriority(0).build();
 
     }
 
     @Test
     public void whenSettingUserData_itIsAssociatedWithTheJob() {
         Shipment one = Shipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc"))
-                .setDeliveryLocation(Location.newInstance("loc")).setUserData(new HashMap<String, Object>()).build();
+            .setDeliveryLocation(Location.newInstance("loc")).setUserData(new HashMap<String, Object>()).build();
         Shipment two = Shipment.Builder.newInstance("s2").setPickupLocation(Location.newInstance("loc"))
-                .setDeliveryLocation(Location.newInstance("loc")).setUserData(42).build();
+            .setDeliveryLocation(Location.newInstance("loc")).setUserData(42).build();
         Shipment three = Shipment.Builder.newInstance("s3").setPickupLocation(Location.newInstance("loc"))
-                .setDeliveryLocation(Location.newInstance("loc")).build();
+            .setDeliveryLocation(Location.newInstance("loc")).build();
 
         assertTrue(one.getUserData() instanceof Map);
         assertEquals(42, two.getUserData());
         assertNull(three.getUserData());
     }
+    @Test
+    public void whenAddingMaxTimeInVehicle_itShouldBeSet(){
+        Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc")).setDeliveryLocation(Location.newInstance("loc"))
+            .setMaxTimeInVehicle(10)
+            .build();
+        Assert.assertEquals(10, s.getMaxTimeInVehicle(),0.001);
+    }
+
+    @Test
+    public void whenNotAddingMaxTimeInVehicle_itShouldBeDefault(){
+        Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc")).setDeliveryLocation(Location.newInstance("loc"))
+            .build();
+        Assert.assertEquals(Double.MAX_VALUE, s.getMaxTimeInVehicle(),0.001);
+    }
+
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleImplTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleImplTest.java
index 99ac6ab76..cf276e48d 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleImplTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleImplTest.java
@@ -18,20 +18,15 @@
 package com.graphhopper.jsprit.core.problem.vehicle;
 
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.job.Break;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
+import org.junit.Test;
 
 import java.util.HashMap;
 import java.util.Map;
 
-import org.junit.Test;
-
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.job.Break;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
+import static org.junit.Assert.*;
 
 
 public class VehicleImplTest {
@@ -49,8 +44,8 @@ public void whenAddingDriverBreak_itShouldBeAddedCorrectly() {
         VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("type").build();
         Break aBreak = Break.Builder.newInstance("break").setTimeWindow(TimeWindow.newInstance(100, 200)).setServiceTime(30).build();
         Vehicle v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("start"))
-                .setType(type1).setEndLocation(Location.newInstance("start"))
-                .setBreak(aBreak).build();
+            .setType(type1).setEndLocation(Location.newInstance("start"))
+            .setBreak(aBreak).build();
         assertNotNull(v.getBreak());
         assertEquals(100., v.getBreak().getTimeWindow().getStart(), 0.1);
         assertEquals(200., v.getBreak().getTimeWindow().getEnd(), 0.1);
@@ -62,7 +57,7 @@ public void whenAddingDriverBreak_itShouldBeAddedCorrectly() {
     public void whenAddingSkills_theyShouldBeAddedCorrectly() {
         VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("type").build();
         Vehicle v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("start")).setType(type1).setEndLocation(Location.newInstance("start"))
-                .addSkill("drill").addSkill("screwdriver").build();
+            .addSkill("drill").addSkill("screwdriver").build();
         assertTrue(v.getSkills().containsSkill("drill"));
         assertTrue(v.getSkills().containsSkill("drill"));
         assertTrue(v.getSkills().containsSkill("screwdriver"));
@@ -72,7 +67,7 @@ public void whenAddingSkills_theyShouldBeAddedCorrectly() {
     public void whenAddingSkillsCaseSens_theyShouldBeAddedCorrectly() {
         VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("type").build();
         Vehicle v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("start")).setType(type1).setEndLocation(Location.newInstance("start"))
-                .addSkill("drill").addSkill("screwdriver").build();
+            .addSkill("drill").addSkill("screwdriver").build();
         assertTrue(v.getSkills().containsSkill("drill"));
         assertTrue(v.getSkills().containsSkill("dRill"));
         assertTrue(v.getSkills().containsSkill("ScrewDriver"));
@@ -241,7 +236,7 @@ public void whenTwoVehiclesHaveTheSameId_theyShouldBeEqual() {
     public void whenAddingSkillsCaseSensV2_theyShouldBeAddedCorrectly() {
         VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("type").build();
         Vehicle v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("start")).setType(type1).setEndLocation(Location.newInstance("start"))
-                .addSkill("drill").build();
+            .addSkill("drill").build();
         assertFalse(v.getSkills().containsSkill("ScrewDriver"));
     }
 
@@ -249,11 +244,11 @@ public void whenAddingSkillsCaseSensV2_theyShouldBeAddedCorrectly() {
     public void whenSettingUserData_itIsAssociatedWithTheVehicle() {
         VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("type").build();
         Vehicle one = VehicleImpl.Builder.newInstance("v").setType(type1)
-                .setStartLocation(Location.newInstance("start")).setUserData(new HashMap<String, Object>()).build();
+            .setStartLocation(Location.newInstance("start")).setUserData(new HashMap<String, Object>()).build();
         Vehicle two = VehicleImpl.Builder.newInstance("v").setType(type1)
-                .setStartLocation(Location.newInstance("start")).setUserData(42).build();
+            .setStartLocation(Location.newInstance("start")).setUserData(42).build();
         Vehicle three = VehicleImpl.Builder.newInstance("v").setType(type1)
-                .setStartLocation(Location.newInstance("start")).build();
+            .setStartLocation(Location.newInstance("start")).build();
 
         assertTrue(one.getUserData() instanceof Map);
         assertEquals(42, two.getUserData());
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeImplTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeImplTest.java
index f01593766..0c85b96ad 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeImplTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeImplTest.java
@@ -17,15 +17,12 @@
  */
 package com.graphhopper.jsprit.core.problem.vehicle;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import org.junit.Test;
 
 import java.util.HashMap;
 import java.util.Map;
 
-import org.junit.Test;
+import static org.junit.Assert.*;
 
 public class VehicleTypeImplTest {
 
@@ -38,18 +35,18 @@ public void whenTypeHasNegativeCapacityVal_throwIllegalStateExpception() {
     @Test
     public void whenAddingTwoCapDimension_nuOfDimsShouldBeTwo() {
         VehicleTypeImpl type = VehicleTypeImpl.Builder.newInstance("t")
-                .addCapacityDimension(0, 2)
-                .addCapacityDimension(1, 4)
-                .build();
+            .addCapacityDimension(0, 2)
+            .addCapacityDimension(1, 4)
+            .build();
         assertEquals(2, type.getCapacityDimensions().getNuOfDimensions());
     }
 
     @Test
     public void whenAddingTwoCapDimension_dimValuesMustBeCorrect() {
         VehicleTypeImpl type = VehicleTypeImpl.Builder.newInstance("t")
-                .addCapacityDimension(0, 2)
-                .addCapacityDimension(1, 4)
-                .build();
+            .addCapacityDimension(0, 2)
+            .addCapacityDimension(1, 4)
+            .build();
         assertEquals(2, type.getCapacityDimensions().get(0));
         assertEquals(4, type.getCapacityDimensions().get(1));
     }
@@ -161,7 +158,7 @@ public void whenAddingProfile_itShouldBeCorrect() {
     @Test
     public void whenSettingUserData_itIsAssociatedWithTheVehicleType() {
         VehicleType one = VehicleTypeImpl.Builder.newInstance("type").setUserData(new HashMap<String, Object>())
-                .build();
+            .build();
         VehicleType two = VehicleTypeImpl.Builder.newInstance("type").setUserData(42).build();
         VehicleType three = VehicleTypeImpl.Builder.newInstance("type").build();
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/FastVehicleRoutingTransportCostsMatrixTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/FastVehicleRoutingTransportCostsMatrixTest.java
index bde92c11d..4e1361eec 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/FastVehicleRoutingTransportCostsMatrixTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/FastVehicleRoutingTransportCostsMatrixTest.java
@@ -66,7 +66,7 @@ public void whenAddingTimeToSymmetricMatrix_itShouldReturnCorrectValues() {
     @Test
     public void whenAddingTimeAndDistanceToSymmetricMatrix_itShouldReturnCorrectValues2() {
         FastVehicleRoutingTransportCostsMatrix.Builder matrixBuilder = FastVehicleRoutingTransportCostsMatrix.Builder.newInstance(3, true);
-        matrixBuilder.addTransportTimeAndDistance(1, 2, 2.,100.);
+        matrixBuilder.addTransportTimeAndDistance(1, 2, 2., 100.);
         FastVehicleRoutingTransportCostsMatrix matrix = matrixBuilder.build();
         assertEquals(2., matrix.getTransportTime(loc(1), loc(2), 0.0, null, null), 0.1);
         assertEquals(2., matrix.getTransportTime(loc(2), loc(1), 0.0, null, null), 0.1);
diff --git a/jsprit-io/src/main/java/com/graphhopper/jsprit/io/problem/VrpXMLWriter.java b/jsprit-io/src/main/java/com/graphhopper/jsprit/io/problem/VrpXMLWriter.java
index 024d49586..57ba77f2f 100644
--- a/jsprit-io/src/main/java/com/graphhopper/jsprit/io/problem/VrpXMLWriter.java
+++ b/jsprit-io/src/main/java/com/graphhopper/jsprit/io/problem/VrpXMLWriter.java
@@ -41,9 +41,7 @@
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.Writer;
+import java.io.*;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -94,8 +92,36 @@ public VrpXMLWriter(VehicleRoutingProblem vrp) {
     public void write(String filename) {
         if (!filename.endsWith(".xml")) filename += ".xml";
         log.info("write vrp: " + filename);
+        XMLConf xmlConfig = createXMLConfiguration();
+
+        try {
+            xmlConfig.setFileName(filename);
+            Writer out = new FileWriter(filename);
+            XMLSerializer serializer = new XMLSerializer(out, createOutputFormat());
+            serializer.serialize(xmlConfig.getDocument());
+            out.close();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public OutputStream write() {
+        XMLConf xmlConfig = createXMLConfiguration();
+        OutputStream out = new ByteArrayOutputStream();
+
+        try {
+            XMLSerializer serializer = new XMLSerializer(out, createOutputFormat());
+            serializer.serialize(xmlConfig.getDocument());
+            out.close();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+
+        return out;
+    }
+
+    private XMLConf createXMLConfiguration() {
         XMLConf xmlConfig = new XMLConf();
-        xmlConfig.setFileName(filename);
         xmlConfig.setRootElementName("problem");
         xmlConfig.setAttributeSplittingDisabled(true);
         xmlConfig.setDelimiterParsingDisabled(true);
@@ -123,10 +149,6 @@ public void write(String filename) {
         writeSolutions(xmlConfig);
 
 
-        OutputFormat format = new OutputFormat();
-        format.setIndenting(true);
-        format.setIndent(5);
-
         try {
             Document document = xmlConfig.createDoc();
 
@@ -138,17 +160,14 @@ public void write(String filename) {
         } catch (ConfigurationException e) {
             throw new RuntimeException(e);
         }
+        return xmlConfig;
+    }
 
-        try {
-            Writer out = new FileWriter(filename);
-            XMLSerializer serializer = new XMLSerializer(out, format);
-            serializer.serialize(xmlConfig.getDocument());
-            out.close();
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-
-
+    private OutputFormat createOutputFormat() {
+        OutputFormat format = new OutputFormat();
+        format.setIndenting(true);
+        format.setIndent(5);
+        return format;
     }
 
     private void writeInitialRoutes(XMLConf xmlConfig) {
diff --git a/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/VrpXMLWriterTest.java b/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/VrpXMLWriterTest.java
index e75e1ba82..57f743261 100644
--- a/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/VrpXMLWriterTest.java
+++ b/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/VrpXMLWriterTest.java
@@ -31,9 +31,11 @@
 import com.graphhopper.jsprit.core.util.Solutions;
 import com.graphhopper.jsprit.io.util.TestUtils;
 import org.junit.Assert;
-import org.junit.Before;
 import org.junit.Test;
 
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
@@ -42,77 +44,15 @@
 
 public class VrpXMLWriterTest {
 
-    private String infileName;
-
-    @Before
-    public void doBefore() {
-        infileName = "src/test/resources/infiniteWriterV2Test.xml";
-    }
-
-    @Test
-    public void whenWritingInfiniteVrp_itWritesCorrectly() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-        builder.setFleetSize(VehicleRoutingProblem.FleetSize.INFINITE);
-        VehicleTypeImpl type = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
-        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("myVehicle").setStartLocation(TestUtils.loc("loc")).setType(type).build();
-        builder.addVehicle(vehicle);
-        VehicleRoutingProblem vrp = builder.build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-    }
-
-    @Test
-    public void whenWritingFiniteVrp_itWritesCorrectly() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-        builder.setFleetSize(VehicleRoutingProblem.FleetSize.FINITE);
-        VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
-        VehicleTypeImpl type2 = VehicleTypeImpl.Builder.newInstance("vehType2").addCapacityDimension(0, 200).build();
-        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(TestUtils.loc("loc")).setType(type1).build();
-        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(TestUtils.loc("loc")).setType(type2).build();
-        builder.addVehicle(v1);
-        builder.addVehicle(v2);
-        VehicleRoutingProblem vrp = builder.build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-    }
-
-    @Test
-    public void t() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-        builder.setFleetSize(VehicleRoutingProblem.FleetSize.FINITE);
-        VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
-        VehicleTypeImpl type2 = VehicleTypeImpl.Builder.newInstance("vehType2").addCapacityDimension(0, 200).build();
-        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(TestUtils.loc("loc")).setType(type1).build();
-        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(TestUtils.loc("loc")).setType(type2).build();
-        builder.addVehicle(v1);
-        builder.addVehicle(v2);
-        VehicleRoutingProblem vrp = builder.build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-    }
-
     @Test
     public void whenWritingServices_itWritesThemCorrectly() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-
-        VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
-        VehicleTypeImpl type2 = VehicleTypeImpl.Builder.newInstance("vehType2").addCapacityDimension(0, 200).build();
-        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(TestUtils.loc("loc")).setType(type1).build();
-        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(TestUtils.loc("loc")).setType(type2).build();
-
-        builder.addVehicle(v1);
-        builder.addVehicle(v2);
-
+        VehicleRoutingProblem.Builder builder = twoVehicleTypesAndImpls();
 
         Service s1 = Service.Builder.newInstance("1").addSizeDimension(0, 1).setLocation(TestUtils.loc("loc")).setServiceTime(2.0).build();
         Service s2 = Service.Builder.newInstance("2").addSizeDimension(0, 1).setLocation(TestUtils.loc("loc2")).setServiceTime(4.0).build();
 
         VehicleRoutingProblem vrp = builder.addJob(s1).addJob(s2).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
         assertEquals(2, readVrp.getJobs().size());
 
         Service s1_read = (Service) vrp.getJobs().get("1");
@@ -128,11 +68,7 @@ public void shouldWriteNameOfService() {
         Service s1 = Service.Builder.newInstance("1").setName("cleaning").addSizeDimension(0, 1).setLocation(TestUtils.loc("loc")).setServiceTime(2.0).build();
 
         VehicleRoutingProblem vrp = builder.addJob(s1).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
         Service s1_read = (Service) readVrp.getJobs().get("1");
         assertTrue(s1_read.getName().equals("cleaning"));
     }
@@ -146,11 +82,7 @@ public void shouldWriteNameOfShipment() {
             .setDeliveryLocation(TestUtils.loc("del")).build();
 
         VehicleRoutingProblem vrp = builder.addJob(s1).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
         Shipment s1_read = (Shipment) readVrp.getJobs().get("1");
         assertTrue(s1_read.getName().equals("cleaning"));
         Assert.assertEquals(1, s1_read.getPickupLocation().getIndex());
@@ -167,32 +99,20 @@ public void whenWritingServicesWithSeveralCapacityDimensions_itWritesThemCorrect
         Service s2 = Service.Builder.newInstance("2").addSizeDimension(0, 1).setLocation(TestUtils.loc("loc2")).setServiceTime(4.0).build();
 
         VehicleRoutingProblem vrp = builder.addJob(s1).addJob(s2).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
         assertEquals(2, readVrp.getJobs().size());
 
         Service s1_read = (Service) vrp.getJobs().get("1");
 
-        Assert.assertEquals(2, s1_read.getSize().getNuOfDimensions());
-        Assert.assertEquals(20, s1_read.getSize().get(0));
-        Assert.assertEquals(200, s1_read.getSize().get(1));
+        assertEquals(2, s1_read.getSize().getNuOfDimensions());
+        assertEquals(20, s1_read.getSize().get(0));
+        assertEquals(200, s1_read.getSize().get(1));
 
     }
 
     @Test
     public void whenWritingShipments_readingThemAgainMustReturnTheWrittenLocationIdsOfS1() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-
-        VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
-        VehicleTypeImpl type2 = VehicleTypeImpl.Builder.newInstance("vehType2").addCapacityDimension(0, 200).build();
-        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(TestUtils.loc("loc")).setType(type1).build();
-        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(TestUtils.loc("loc")).setType(type2).build();
-
-        builder.addVehicle(v1);
-        builder.addVehicle(v2);
+        VehicleRoutingProblem.Builder builder = twoVehicleTypesAndImpls();
 
         Shipment s1 = Shipment.Builder.newInstance("1").addSizeDimension(0, 10)
             .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
@@ -205,29 +125,17 @@ public void whenWritingShipments_readingThemAgainMustReturnTheWrittenLocationIds
 
 
         VehicleRoutingProblem vrp = builder.addJob(s1).addJob(s2).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
         assertEquals(2, readVrp.getJobs().size());
 
-        Assert.assertEquals("pickLoc", ((Shipment) readVrp.getJobs().get("1")).getPickupLocation().getId());
-        Assert.assertEquals("delLoc", ((Shipment) readVrp.getJobs().get("1")).getDeliveryLocation().getId());
+        assertEquals("pickLoc", ((Shipment) readVrp.getJobs().get("1")).getPickupLocation().getId());
+        assertEquals("delLoc", ((Shipment) readVrp.getJobs().get("1")).getDeliveryLocation().getId());
 
     }
 
     @Test
     public void whenWritingShipments_readingThemAgainMustReturnTheWrittenPickupTimeWindowsOfS1() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-
-        VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
-        VehicleTypeImpl type2 = VehicleTypeImpl.Builder.newInstance("vehType2").addCapacityDimension(0, 200).build();
-        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(TestUtils.loc("loc")).setType(type1).build();
-        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(TestUtils.loc("loc")).setType(type2).build();
-
-        builder.addVehicle(v1);
-        builder.addVehicle(v2);
+        VehicleRoutingProblem.Builder builder = twoVehicleTypesAndImpls();
 
         Shipment s1 = Shipment.Builder.newInstance("1").addSizeDimension(0, 10)
             .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
@@ -240,30 +148,18 @@ public void whenWritingShipments_readingThemAgainMustReturnTheWrittenPickupTimeW
 
 
         VehicleRoutingProblem vrp = builder.addJob(s1).addJob(s2).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
         assertEquals(2, readVrp.getJobs().size());
 
-        Assert.assertEquals(1.0, ((Shipment) readVrp.getJobs().get("1")).getPickupTimeWindow().getStart(), 0.01);
-        Assert.assertEquals(2.0, ((Shipment) readVrp.getJobs().get("1")).getPickupTimeWindow().getEnd(), 0.01);
+        assertEquals(1.0, ((Shipment) readVrp.getJobs().get("1")).getPickupTimeWindow().getStart(), 0.01);
+        assertEquals(2.0, ((Shipment) readVrp.getJobs().get("1")).getPickupTimeWindow().getEnd(), 0.01);
 
 
     }
 
     @Test
     public void whenWritingShipments_readingThemAgainMustReturnTheWrittenDeliveryTimeWindowsOfS1() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-
-        VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
-        VehicleTypeImpl type2 = VehicleTypeImpl.Builder.newInstance("vehType2").addCapacityDimension(0, 200).build();
-        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(TestUtils.loc("loc")).setType(type1).build();
-        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(TestUtils.loc("loc")).setType(type2).build();
-
-        builder.addVehicle(v1);
-        builder.addVehicle(v2);
+        VehicleRoutingProblem.Builder builder = twoVehicleTypesAndImpls();
 
         Shipment s1 = Shipment.Builder.newInstance("1").addSizeDimension(0, 10)
             .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
@@ -276,29 +172,17 @@ public void whenWritingShipments_readingThemAgainMustReturnTheWrittenDeliveryTim
 
 
         VehicleRoutingProblem vrp = builder.addJob(s1).addJob(s2).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
         assertEquals(2, readVrp.getJobs().size());
 
-        Assert.assertEquals(3.0, ((Shipment) readVrp.getJobs().get("1")).getDeliveryTimeWindow().getStart(), 0.01);
-        Assert.assertEquals(4.0, ((Shipment) readVrp.getJobs().get("1")).getDeliveryTimeWindow().getEnd(), 0.01);
+        assertEquals(3.0, ((Shipment) readVrp.getJobs().get("1")).getDeliveryTimeWindow().getStart(), 0.01);
+        assertEquals(4.0, ((Shipment) readVrp.getJobs().get("1")).getDeliveryTimeWindow().getEnd(), 0.01);
 
     }
 
     @Test
     public void whenWritingShipments_readingThemAgainMustReturnTheWrittenDeliveryServiceTimeOfS1() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-
-        VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
-        VehicleTypeImpl type2 = VehicleTypeImpl.Builder.newInstance("vehType2").addCapacityDimension(0, 200).build();
-        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(TestUtils.loc("loc")).setType(type1).build();
-        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(TestUtils.loc("loc")).setType(type2).build();
-
-        builder.addVehicle(v1);
-        builder.addVehicle(v2);
+        VehicleRoutingProblem.Builder builder = twoVehicleTypesAndImpls();
 
         Shipment s1 = Shipment.Builder.newInstance("1").addSizeDimension(0, 10)
             .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
@@ -311,11 +195,7 @@ public void whenWritingShipments_readingThemAgainMustReturnTheWrittenDeliverySer
 
 
         VehicleRoutingProblem vrp = builder.addJob(s1).addJob(s2).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
         assertEquals(2, readVrp.getJobs().size());
 
         assertEquals(100.0, ((Shipment) readVrp.getJobs().get("1")).getPickupServiceTime(), 0.01);
@@ -325,15 +205,7 @@ public void whenWritingShipments_readingThemAgainMustReturnTheWrittenDeliverySer
 
     @Test
     public void whenWritingShipments_readingThemAgainMustReturnTheWrittenLocationIdOfS1() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-
-        VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
-        VehicleTypeImpl type2 = VehicleTypeImpl.Builder.newInstance("vehType2").addCapacityDimension(0, 200).build();
-        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(TestUtils.loc("loc")).setType(type1).build();
-        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(TestUtils.loc("loc")).setType(type2).build();
-
-        builder.addVehicle(v1);
-        builder.addVehicle(v2);
+        VehicleRoutingProblem.Builder builder = twoVehicleTypesAndImpls();
 
         Shipment s1 = Shipment.Builder.newInstance("1").addSizeDimension(0, 10)
             .setPickupLocation(TestUtils.loc(Coordinate.newInstance(1, 2))).setDeliveryLocation(TestUtils.loc("delLoc")).setPickupTimeWindow(TimeWindow.newInstance(1, 2))
@@ -345,37 +217,14 @@ public void whenWritingShipments_readingThemAgainMustReturnTheWrittenLocationIdO
 
 
         VehicleRoutingProblem vrp = builder.addJob(s1).addJob(s2).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
         assertEquals(2, readVrp.getJobs().size());
 
-        Assert.assertEquals("[x=1.0][y=2.0]", ((Shipment) readVrp.getJobs().get("1")).getPickupLocation().getId());
-    }
-
-    @Test
-    public void whenWritingVehicles_vehShouldHave2Skills() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-        VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
-        VehicleImpl v = VehicleImpl.Builder.newInstance("v1").addSkill("SKILL5").addSkill("skill1").addSkill("Skill2")
-            .setStartLocation(TestUtils.loc("loc")).setType(type1).build();
-        builder.addVehicle(v);
-
-        VehicleRoutingProblem vrp = builder.build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
-        Vehicle veh1 = getVehicle("v1", readVrp);
-
-        Assert.assertEquals(3, veh1.getSkills().values().size());
+        assertEquals("[x=1.0][y=2.0]", ((Shipment) readVrp.getJobs().get("1")).getPickupLocation().getId());
     }
 
     @Test
-    public void whenWritingVehicles_vehShouldContain_skill5() {
+    public void whenWritingVehicles_vehShouldHave3Skills() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
         VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
         VehicleImpl v = VehicleImpl.Builder.newInstance("v1").addSkill("SKILL5").addSkill("skill1").addSkill("Skill2")
@@ -383,51 +232,12 @@ public void whenWritingVehicles_vehShouldContain_skill5() {
         builder.addVehicle(v);
 
         VehicleRoutingProblem vrp = builder.build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
         Vehicle veh1 = getVehicle("v1", readVrp);
 
+        assertEquals(3, veh1.getSkills().values().size());
         assertTrue(veh1.getSkills().containsSkill("skill5"));
-    }
-
-    @Test
-    public void whenWritingVehicles_vehShouldContain_skill1() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-        VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
-        VehicleImpl v = VehicleImpl.Builder.newInstance("v1").addSkill("SKILL5").addSkill("skill1").addSkill("Skill2")
-            .setStartLocation(TestUtils.loc("loc")).setType(type1).build();
-        builder.addVehicle(v);
-
-        VehicleRoutingProblem vrp = builder.build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
-        Vehicle veh1 = getVehicle("v1", readVrp);
-
         assertTrue(veh1.getSkills().containsSkill("skill1"));
-    }
-
-    @Test
-    public void whenWritingVehicles_vehShouldContain_skill2() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-        VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
-        VehicleImpl v = VehicleImpl.Builder.newInstance("v1").addSkill("SKILL5").addSkill("skill1").addSkill("Skill2")
-            .setStartLocation(TestUtils.loc("loc")).setType(type1).build();
-        builder.addVehicle(v);
-
-        VehicleRoutingProblem vrp = builder.build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
-        Vehicle veh1 = getVehicle("v1", readVrp);
-
         assertTrue(veh1.getSkills().containsSkill("skill2"));
     }
 
@@ -439,14 +249,10 @@ public void whenWritingVehicles_vehShouldHave0Skills() {
         builder.addVehicle(v);
 
         VehicleRoutingProblem vrp = builder.build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
         Vehicle veh = getVehicle("v1", readVrp);
 
-        Assert.assertEquals(0, veh.getSkills().values().size());
+        assertEquals(0, veh.getSkills().values().size());
     }
 
     private Vehicle getVehicle(String v1, VehicleRoutingProblem readVrp) {
@@ -468,89 +274,17 @@ public void whenWritingShipments_shipmentShouldHaveCorrectNuSkills() {
             .setDeliveryTimeWindow(TimeWindow.newInstance(3, 4)).setPickupServiceTime(100).setDeliveryServiceTime(50).build();
 
         VehicleRoutingProblem vrp = builder.addJob(s).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
-
-        Assert.assertEquals(3, readVrp.getJobs().get("1").getRequiredSkills().values().size());
-    }
-
-    @Test
-    public void whenWritingShipments_shipmentShouldContain_skill1() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-
-        Shipment s = Shipment.Builder.newInstance("1").addRequiredSkill("skill1").addRequiredSkill("skill2").addRequiredSkill("skill3")
-            .addSizeDimension(0, 10)
-            .setPickupLocation(TestUtils.loc(Coordinate.newInstance(1, 2)))
-            .setDeliveryLocation(TestUtils.loc("delLoc", Coordinate.newInstance(5, 6)))
-            .setPickupTimeWindow(TimeWindow.newInstance(1, 2))
-            .setDeliveryTimeWindow(TimeWindow.newInstance(3, 4)).setPickupServiceTime(100).setDeliveryServiceTime(50).build();
-
-        VehicleRoutingProblem vrp = builder.addJob(s).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
 
+        assertEquals(3, readVrp.getJobs().get("1").getRequiredSkills().values().size());
         assertTrue(readVrp.getJobs().get("1").getRequiredSkills().containsSkill("skill1"));
-    }
-
-    @Test
-    public void whenWritingShipments_shipmentShouldContain_skill2() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-
-        Shipment s = Shipment.Builder.newInstance("1").addRequiredSkill("skill1").addRequiredSkill("Skill2").addRequiredSkill("skill3")
-            .addSizeDimension(0, 10)
-            .setPickupLocation(TestUtils.loc(Coordinate.newInstance(1, 2)))
-            .setDeliveryLocation(TestUtils.loc("delLoc", Coordinate.newInstance(5, 6)))
-            .setPickupTimeWindow(TimeWindow.newInstance(1, 2))
-            .setDeliveryTimeWindow(TimeWindow.newInstance(3, 4)).setPickupServiceTime(100).setDeliveryServiceTime(50).build();
-
-        VehicleRoutingProblem vrp = builder.addJob(s).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
-
         assertTrue(readVrp.getJobs().get("1").getRequiredSkills().containsSkill("skill2"));
-    }
-
-    @Test
-    public void whenWritingShipments_shipmentShouldContain_skill3() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-
-        Shipment s = Shipment.Builder.newInstance("1").addRequiredSkill("skill1").addRequiredSkill("Skill2").addRequiredSkill("skill3")
-            .addSizeDimension(0, 10)
-            .setPickupLocation(TestUtils.loc(Coordinate.newInstance(1, 2)))
-            .setDeliveryLocation(TestUtils.loc("delLoc", Coordinate.newInstance(5, 6)))
-            .setPickupTimeWindow(TimeWindow.newInstance(1, 2))
-            .setDeliveryTimeWindow(TimeWindow.newInstance(3, 4)).setPickupServiceTime(100).setDeliveryServiceTime(50).build();
-
-        VehicleRoutingProblem vrp = builder.addJob(s).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
-
         assertTrue(readVrp.getJobs().get("1").getRequiredSkills().containsSkill("skill3"));
     }
 
     @Test
     public void whenWritingShipments_readingThemAgainMustReturnTheWrittenLocationCoordinateOfS1() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-
-        VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
-        VehicleTypeImpl type2 = VehicleTypeImpl.Builder.newInstance("vehType2").addCapacityDimension(0, 200).build();
-        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(TestUtils.loc("loc")).setType(type1).build();
-        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(TestUtils.loc("loc")).setType(type2).build();
-
-        builder.addVehicle(v1);
-        builder.addVehicle(v2);
+        VehicleRoutingProblem.Builder builder = twoVehicleTypesAndImpls();
 
         Shipment s1 = Shipment.Builder.newInstance("1").addSizeDimension(0, 10).setPickupLocation(TestUtils.loc(Coordinate.newInstance(1, 2)))
             .setDeliveryLocation(TestUtils.loc("delLoc", Coordinate.newInstance(5, 6)))
@@ -564,18 +298,14 @@ public void whenWritingShipments_readingThemAgainMustReturnTheWrittenLocationCoo
 
 
         VehicleRoutingProblem vrp = builder.addJob(s1).addJob(s2).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
         assertEquals(2, readVrp.getJobs().size());
 
-        Assert.assertEquals(1.0, ((Shipment) readVrp.getJobs().get("1")).getPickupLocation().getCoordinate().getX(), 0.01);
-        Assert.assertEquals(2.0, ((Shipment) readVrp.getJobs().get("1")).getPickupLocation().getCoordinate().getY(), 0.01);
+        assertEquals(1.0, ((Shipment) readVrp.getJobs().get("1")).getPickupLocation().getCoordinate().getX(), 0.01);
+        assertEquals(2.0, ((Shipment) readVrp.getJobs().get("1")).getPickupLocation().getCoordinate().getY(), 0.01);
 
-        Assert.assertEquals(5.0, ((Shipment) readVrp.getJobs().get("1")).getDeliveryLocation().getCoordinate().getX(), 0.01);
-        Assert.assertEquals(6.0, ((Shipment) readVrp.getJobs().get("1")).getDeliveryLocation().getCoordinate().getY(), 0.01);
+        assertEquals(5.0, ((Shipment) readVrp.getJobs().get("1")).getDeliveryLocation().getCoordinate().getX(), 0.01);
+        assertEquals(6.0, ((Shipment) readVrp.getJobs().get("1")).getDeliveryLocation().getCoordinate().getY(), 0.01);
     }
 
     @Test
@@ -597,100 +327,64 @@ public void whenWritingShipmentWithSeveralCapacityDimension_itShouldWriteAndRead
             .setDeliveryTimeWindow(TimeWindow.newInstance(7, 8)).build();
 
         VehicleRoutingProblem vrp = builder.addJob(s1).addJob(s2).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
 
-        Assert.assertEquals(3, (readVrp.getJobs().get("1")).getSize().getNuOfDimensions());
-        Assert.assertEquals(10, (readVrp.getJobs().get("1")).getSize().get(0));
-        Assert.assertEquals(0, (readVrp.getJobs().get("1")).getSize().get(1));
-        Assert.assertEquals(100, (readVrp.getJobs().get("1")).getSize().get(2));
+        assertEquals(3, (readVrp.getJobs().get("1")).getSize().getNuOfDimensions());
+        assertEquals(10, (readVrp.getJobs().get("1")).getSize().get(0));
+        assertEquals(0, (readVrp.getJobs().get("1")).getSize().get(1));
+        assertEquals(100, (readVrp.getJobs().get("1")).getSize().get(2));
 
-        Assert.assertEquals(1, (readVrp.getJobs().get("2")).getSize().getNuOfDimensions());
-        Assert.assertEquals(20, (readVrp.getJobs().get("2")).getSize().get(0));
+        assertEquals(1, (readVrp.getJobs().get("2")).getSize().getNuOfDimensions());
+        assertEquals(20, (readVrp.getJobs().get("2")).getSize().get(0));
     }
 
     @Test
     public void whenWritingVehicleV1_itsStartLocationMustBeWrittenCorrectly() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-
-        VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
-        VehicleTypeImpl type2 = VehicleTypeImpl.Builder.newInstance("vehType2").addCapacityDimension(0, 200).build();
-        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(TestUtils.loc("loc")).setType(type1).build();
-        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(TestUtils.loc("loc")).setType(type2).build();
-
-        builder.addVehicle(v1);
-        builder.addVehicle(v2);
+        VehicleRoutingProblem.Builder builder = twoVehicleTypesAndImpls();
 
         Service s1 = Service.Builder.newInstance("1").addSizeDimension(0, 1).setLocation(TestUtils.loc("loc")).setServiceTime(2.0).build();
         Service s2 = Service.Builder.newInstance("2").addSizeDimension(0, 1).setLocation(TestUtils.loc("loc2")).setServiceTime(4.0).build();
 
         VehicleRoutingProblem vrp = builder.addJob(s1).addJob(s2).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
 
         Vehicle v = getVehicle("v1", readVrp.getVehicles());
-        Assert.assertEquals("loc", v.getStartLocation().getId());
-        Assert.assertEquals("loc", v.getEndLocation().getId());
+        assertEquals("loc", v.getStartLocation().getId());
+        assertEquals("loc", v.getEndLocation().getId());
 
     }
 
-    @Test
-    public void whenWritingService_itShouldHaveTheCorrectNuSkills() {
+    private VehicleRoutingProblem.Builder twoVehicleTypesAndImpls() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
 
-        Service s = Service.Builder.newInstance("1").addRequiredSkill("sKill1").addRequiredSkill("skill2").addSizeDimension(0, 1)
-            .setLocation(TestUtils.loc("loc")).setServiceTime(2.0).build();
-
-        VehicleRoutingProblem vrp = builder.addJob(s).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
+        VehicleTypeImpl type2 = VehicleTypeImpl.Builder.newInstance("vehType2").addCapacityDimension(0, 200).build();
+        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(TestUtils.loc("loc")).setType(type1).build();
+        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(TestUtils.loc("loc")).setType(type2).build();
 
-        Assert.assertEquals(2, readVrp.getJobs().get("1").getRequiredSkills().values().size());
+        builder.addVehicle(v1);
+        builder.addVehicle(v2);
+        return builder;
     }
 
     @Test
-    public void whenWritingService_itShouldContain_skill1() {
+    public void whenWritingService_itShouldContain_bothSkills() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
 
-        Service s = Service.Builder.newInstance("1").addRequiredSkill("sKill1").addRequiredSkill("skill2").addSizeDimension(0, 1)
+        //skill names are case-insensitive
+        Service s = Service.Builder.newInstance("1").addRequiredSkill("skill1").addRequiredSkill("SKILL2").addSizeDimension(0, 1)
             .setLocation(TestUtils.loc("loc")).setServiceTime(2.0).build();
 
         VehicleRoutingProblem vrp = builder.addJob(s).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
 
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
 
+        assertEquals(2, readVrp.getJobs().get("1").getRequiredSkills().values().size());
         assertTrue(readVrp.getJobs().get("1").getRequiredSkills().containsSkill("skill1"));
-    }
-
-    @Test
-    public void whenWritingService_itShouldContain_skill2() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-
-        Service s = Service.Builder.newInstance("1").addRequiredSkill("sKill1").addRequiredSkill("skill2").addSizeDimension(0, 1)
-            .setLocation(TestUtils.loc("loc")).setServiceTime(2.0).build();
-
-        VehicleRoutingProblem vrp = builder.addJob(s).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
-
         assertTrue(readVrp.getJobs().get("1").getRequiredSkills().containsSkill("skill2"));
     }
 
+
     @Test
     public void whenWritingVehicleV1_itDoesNotReturnToDepotMustBeWrittenCorrectly() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
@@ -708,11 +402,7 @@ public void whenWritingVehicleV1_itDoesNotReturnToDepotMustBeWrittenCorrectly()
         Service s2 = Service.Builder.newInstance("2").addSizeDimension(0, 1).setLocation(TestUtils.loc("loc2")).setServiceTime(4.0).build();
 
         VehicleRoutingProblem vrp = builder.addJob(s1).addJob(s2).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
 
         Vehicle v = getVehicle("v1", readVrp.getVehicles());
         assertFalse(v.isReturnToDepot());
@@ -734,11 +424,7 @@ public void whenWritingVehicleV1_readingAgainAssignsCorrectType() {
         Service s2 = Service.Builder.newInstance("2").addSizeDimension(0, 1).setLocation(TestUtils.loc("loc2")).setServiceTime(4.0).build();
 
         VehicleRoutingProblem vrp = builder.addJob(s1).addJob(s2).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
 
         Vehicle v = getVehicle("v1", readVrp.getVehicles());
         assertEquals("vehType", v.getType().getTypeId());
@@ -760,15 +446,11 @@ public void whenWritingVehicleV2_readingAgainAssignsCorrectType() {
         Service s2 = Service.Builder.newInstance("2").addSizeDimension(0, 1).setLocation(TestUtils.loc("loc2")).setServiceTime(4.0).build();
 
         VehicleRoutingProblem vrp = builder.addJob(s1).addJob(s2).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
 
         Vehicle v = getVehicle("v2", readVrp.getVehicles());
         assertEquals("vehType2", v.getType().getTypeId());
-        Assert.assertEquals(200, v.getType().getCapacityDimensions().get(0));
+        assertEquals(200, v.getType().getCapacityDimensions().get(0));
 
     }
 
@@ -776,35 +458,6 @@ public void whenWritingVehicleV2_readingAgainAssignsCorrectType() {
     public void whenWritingVehicleV2_readingItsLocationsAgainReturnsCorrectLocations() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
 
-        VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
-        VehicleTypeImpl type2 = VehicleTypeImpl.Builder.newInstance("vehType2").addCapacityDimension(0, 200).build();
-        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setReturnToDepot(false).setStartLocation(TestUtils.loc("loc")).setType(type1).build();
-        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2")
-            .setStartLocation(TestUtils.loc("startLoc", Coordinate.newInstance(1, 2)))
-            .setEndLocation(TestUtils.loc("endLoc", Coordinate.newInstance(4, 5))).setType(type2).build();
-
-        builder.addVehicle(v1);
-        builder.addVehicle(v2);
-
-        Service s1 = Service.Builder.newInstance("1").addSizeDimension(0, 1).setLocation(TestUtils.loc("loc")).setServiceTime(2.0).build();
-        Service s2 = Service.Builder.newInstance("2").addSizeDimension(0, 1).setLocation(TestUtils.loc("loc2")).setServiceTime(4.0).build();
-
-        VehicleRoutingProblem vrp = builder.addJob(s1).addJob(s2).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
-
-        Vehicle v = getVehicle("v2", readVrp.getVehicles());
-        Assert.assertEquals("startLoc", v.getStartLocation().getId());
-        Assert.assertEquals("endLoc", v.getEndLocation().getId());
-    }
-
-    @Test
-    public void whenWritingVehicleV2_readingItsLocationsCoordsAgainReturnsCorrectLocationsCoords() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-
         VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
         VehicleTypeImpl type2 = VehicleTypeImpl.Builder.newInstance("vehType2").addCapacityDimension(0, 200).build();
         VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setReturnToDepot(false)
@@ -820,20 +473,18 @@ public void whenWritingVehicleV2_readingItsLocationsCoordsAgainReturnsCorrectLoc
         Service s2 = Service.Builder.newInstance("2").addSizeDimension(0, 1).setLocation(TestUtils.loc("loc2")).setServiceTime(4.0).build();
 
         VehicleRoutingProblem vrp = builder.addJob(s1).addJob(s2).build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
 
         Vehicle v = getVehicle("v2", readVrp.getVehicles());
-        Assert.assertEquals(1.0, v.getStartLocation().getCoordinate().getX(), 0.01);
-        Assert.assertEquals(2.0, v.getStartLocation().getCoordinate().getY(), 0.01);
-
-        Assert.assertEquals(4.0, v.getEndLocation().getCoordinate().getX(), 0.01);
-        Assert.assertEquals(5.0, v.getEndLocation().getCoordinate().getY(), 0.01);
+        assertEquals("startLoc", v.getStartLocation().getId());
+        assertEquals("endLoc", v.getEndLocation().getId());
+        assertEquals(1.0, v.getStartLocation().getCoordinate().getX(), 0.01);
+        assertEquals(2.0, v.getStartLocation().getCoordinate().getY(), 0.01);
+        assertEquals(4.0, v.getEndLocation().getCoordinate().getX(), 0.01);
+        assertEquals(5.0, v.getEndLocation().getCoordinate().getY(), 0.01);
     }
 
+
     @Test
     public void whenWritingVehicleWithSeveralCapacityDimensions_itShouldBeWrittenAndRereadCorrectly() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
@@ -850,17 +501,13 @@ public void whenWritingVehicleWithSeveralCapacityDimensions_itShouldBeWrittenAnd
         builder.addVehicle(v2);
 
         VehicleRoutingProblem vrp = builder.build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
 
         Vehicle v = getVehicle("v", readVrp.getVehicles());
-        Assert.assertEquals(3, v.getType().getCapacityDimensions().getNuOfDimensions());
-        Assert.assertEquals(100, v.getType().getCapacityDimensions().get(0));
-        Assert.assertEquals(1000, v.getType().getCapacityDimensions().get(1));
-        Assert.assertEquals(10000, v.getType().getCapacityDimensions().get(2));
+        assertEquals(3, v.getType().getCapacityDimensions().getNuOfDimensions());
+        assertEquals(100, v.getType().getCapacityDimensions().get(0));
+        assertEquals(1000, v.getType().getCapacityDimensions().get(1));
+        assertEquals(10000, v.getType().getCapacityDimensions().get(2));
     }
 
     @Test
@@ -879,16 +526,12 @@ public void whenWritingVehicleWithSeveralCapacityDimensions_itShouldBeWrittenAnd
         builder.addVehicle(v2);
 
         VehicleRoutingProblem vrp = builder.build();
-        new VrpXMLWriter(vrp, null).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(infileName);
-        VehicleRoutingProblem readVrp = vrpToReadBuilder.build();
+        VehicleRoutingProblem readVrp = writeAndRereadXml(vrp);
 
         Vehicle v = getVehicle("v", readVrp.getVehicles());
-        Assert.assertEquals(11, v.getType().getCapacityDimensions().getNuOfDimensions());
-        Assert.assertEquals(0, v.getType().getCapacityDimensions().get(9));
-        Assert.assertEquals(10000, v.getType().getCapacityDimensions().get(10));
+        assertEquals(11, v.getType().getCapacityDimensions().getNuOfDimensions());
+        assertEquals(0, v.getType().getCapacityDimensions().get(9));
+        assertEquals(10000, v.getType().getCapacityDimensions().get(10));
     }
 
     private Vehicle getVehicle(String string, Collection<Vehicle> vehicles) {
@@ -916,14 +559,10 @@ public void solutionWithoutUnassignedJobsShouldBeWrittenCorrectly() {
         List<VehicleRoutingProblemSolution> solutions = new ArrayList<VehicleRoutingProblemSolution>();
         solutions.add(solution);
 
-        new VrpXMLWriter(vrp, solutions).write(infileName);
-
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        List<VehicleRoutingProblemSolution> solutionsToRead = new ArrayList<VehicleRoutingProblemSolution>();
-        new VrpXMLReader(vrpToReadBuilder, solutionsToRead).read(infileName);
+        List<VehicleRoutingProblemSolution> solutionsToRead = writeAndRereadXmlWithSolutions(vrp, solutions);
 
         assertEquals(1, solutionsToRead.size());
-        Assert.assertEquals(10., Solutions.bestOf(solutionsToRead).getCost(), 0.01);
+        assertEquals(10., Solutions.bestOf(solutionsToRead).getCost(), 0.01);
         assertTrue(Solutions.bestOf(solutionsToRead).getUnassignedJobs().isEmpty());
     }
 
@@ -948,16 +587,46 @@ public void solutionWithUnassignedJobsShouldBeWrittenCorrectly() {
         List<VehicleRoutingProblemSolution> solutions = new ArrayList<VehicleRoutingProblemSolution>();
         solutions.add(solution);
 
-        new VrpXMLWriter(vrp, solutions).write(infileName);
+        List<VehicleRoutingProblemSolution> solutionsToRead = writeAndRereadXmlWithSolutions(vrp, solutions);
+
+        assertEquals(1, solutionsToRead.size());
+        assertEquals(10., Solutions.bestOf(solutionsToRead).getCost(), 0.01);
+        assertEquals(1, Solutions.bestOf(solutionsToRead).getUnassignedJobs().size());
+        assertEquals("2", Solutions.bestOf(solutionsToRead).getUnassignedJobs().iterator().next().getId());
+    }
+
+    @Test
+    public void outputStreamAndFileContentsAreEqual() throws IOException {
+        VehicleRoutingProblem.Builder builder = twoVehicleTypesAndImpls();
+        VehicleRoutingProblem vrp = builder.build();
+
+        VrpXMLWriter vrpXMLWriter = new VrpXMLWriter(vrp, null);
+        ByteArrayOutputStream os = (ByteArrayOutputStream) vrpXMLWriter.write();
 
+        String outputStringFromFile = new String(os.toByteArray());
+        String outputStringFromStream = new VrpXMLWriter(vrp, null).write().toString();
+
+        assertEquals(outputStringFromFile, outputStringFromStream);
+
+    }
+
+    private VehicleRoutingProblem writeAndRereadXml(VehicleRoutingProblem vrp) {
+        VrpXMLWriter vrpXMLWriter = new VrpXMLWriter(vrp, null);
+        ByteArrayOutputStream os = (ByteArrayOutputStream) vrpXMLWriter.write();
+        ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
         VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        List<VehicleRoutingProblemSolution> solutionsToRead = new ArrayList<VehicleRoutingProblemSolution>();
-        new VrpXMLReader(vrpToReadBuilder, solutionsToRead).read(infileName);
+        new VrpXMLReader(vrpToReadBuilder, null).read(is);
+        return vrpToReadBuilder.build();
+    }
 
-        assertEquals(1, solutionsToRead.size());
-        Assert.assertEquals(10., Solutions.bestOf(solutionsToRead).getCost(), 0.01);
-        Assert.assertEquals(1, Solutions.bestOf(solutionsToRead).getUnassignedJobs().size());
-        Assert.assertEquals("2", Solutions.bestOf(solutionsToRead).getUnassignedJobs().iterator().next().getId());
+    private List<VehicleRoutingProblemSolution> writeAndRereadXmlWithSolutions(VehicleRoutingProblem vrp, List<VehicleRoutingProblemSolution> solutions) {
+        VrpXMLWriter vrpXMLWriter = new VrpXMLWriter(vrp, solutions);
+        ByteArrayOutputStream os = (ByteArrayOutputStream) vrpXMLWriter.write();
+        ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
+        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
+        List<VehicleRoutingProblemSolution> solutionsToRead = new ArrayList<VehicleRoutingProblemSolution>();
+        new VrpXMLReader(vrpToReadBuilder, solutionsToRead).read(is);
+        return solutionsToRead;
     }
 
 }
diff --git a/jsprit-io/src/test/resources/infiniteWriterV2Test.xml b/jsprit-io/src/test/resources/infiniteWriterV2Test.xml
deleted file mode 100644
index 9d8638971..000000000
--- a/jsprit-io/src/test/resources/infiniteWriterV2Test.xml
+++ /dev/null
@@ -1,41 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<problem xmlns="http://www.w3schools.com"
-     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
-     <problemType>
-          <fleetSize>INFINITE</fleetSize>
-     </problemType>
-     <shipments>
-          <shipment id="1">
-               <pickup>
-                    <location>
-                         <id>[x=1.0][y=2.0]</id>
-                         <coord x="1.0" y="2.0"/>
-                    </location>
-                    <duration>100.0</duration>
-                    <timeWindows>
-                         <timeWindow>
-                              <start>1.0</start>
-                              <end>2.0</end>
-                         </timeWindow>
-                    </timeWindows>
-               </pickup>
-               <delivery>
-                    <location>
-                         <id>delLoc</id>
-                         <coord x="5.0" y="6.0"/>
-                    </location>
-                    <duration>50.0</duration>
-                    <timeWindows>
-                         <timeWindow>
-                              <start>3.0</start>
-                              <end>4.0</end>
-                         </timeWindow>
-                    </timeWindows>
-               </delivery>
-               <capacity-dimensions>
-                    <dimension index="0">10</dimension>
-               </capacity-dimensions>
-               <requiredSkills>skill3, skill1, skill2</requiredSkills>
-          </shipment>
-     </shipments>
-</problem>
diff --git a/pom.xml b/pom.xml
index 2a1147c06..7b669fe80 100644
--- a/pom.xml
+++ b/pom.xml
@@ -56,6 +56,7 @@
         <tag>HEAD</tag>
     </scm>
 
+
     <issueManagement>
         <system>github</system>
         <url>https://github.com/graphhopper/jsprit/issues</url>
@@ -81,6 +82,15 @@
     </properties>
 
     <build>
+
+        <extensions>
+            <extension>
+                <groupId>io.packagecloud.maven.wagon</groupId>
+                <artifactId>maven-packagecloud-wagon</artifactId>
+                <version>0.0.4</version>
+            </extension>
+        </extensions>
+
         <sourceDirectory>src/main/java</sourceDirectory>
         <testSourceDirectory>src/test/java</testSourceDirectory>
         <directory>target</directory>
@@ -180,9 +190,13 @@
     </dependencies>
 
     <distributionManagement>
+        <repository>
+            <id>packagecloud-graphhopper</id>
+            <url>packagecloud+https://packagecloud.io/graphhopper/jsprit</url>
+        </repository>
         <snapshotRepository>
-            <id>ossrh</id>
-            <url>https://oss.sonatype.org/content/repositories/snapshots</url>
+            <id>packagecloud-graphhopper</id>
+            <url>packagecloud+https://packagecloud.io/graphhopper/jsprit</url>
         </snapshotRepository>
     </distributionManagement>
 
