diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/SimpleJobActivityFactory.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/SimpleJobActivityFactory.java
index 314fb3ef2..6c7cf661c 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/SimpleJobActivityFactory.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/SimpleJobActivityFactory.java
@@ -6,6 +6,7 @@
 import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
 
 public class SimpleJobActivityFactory implements JobActivityFactory {
+
     @Override
     public List<JobActivity> createActivities(Job job) {
         return job.getActivityList().getAll();
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractJob.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractJob.java
index 774e02b0f..f28e0f6a1 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractJob.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractJob.java
@@ -59,13 +59,17 @@ protected void addLocation(Location location) {
         return allLocations;
     }
 
+    protected abstract void addLocations();
+
     protected abstract void createActivities();
 
+    protected void setActivities(JobActivityList list) {
+        activityList = list;
+    }
+
+    @Override
     public JobActivityList getActivityList() {
         return activityList;
     }
 
-
-
-
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Break.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Break.java
index 7a1c6713f..b8c15de15 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Break.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Break.java
@@ -51,8 +51,10 @@ public Break build() {
                 variableLocation = false;
             }
             setType("break");
-            postProcess();
-            return new Break(this);
+            preProcess();
+            Break instance = new Break(this);
+            postProcess(instance);
+            return instance;
         }
 
     }
@@ -66,7 +68,9 @@ public Break build() {
 
     @Override
     protected void createActivities() {
-        getActivityList().addActivity(BreakActivity.newInstance(this));
+        JobActivityList list = new SequentialJobActivityList(this);
+        list.addActivity(BreakActivity.newInstance(this));
+        setActivities(list);
     }
 
     public boolean hasVariableLocation() {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Delivery.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Delivery.java
index 3c79d8498..3a7f10b33 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Delivery.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Delivery.java
@@ -46,8 +46,10 @@ public Delivery build() {
                 throw new IllegalArgumentException("location is missing");
             }
             setType("delivery");
-            postProcess();
-            return new Delivery(this);
+            preProcess();
+            Delivery delivery = new Delivery(this);
+            postProcess(delivery);
+            return delivery;
         }
     }
 
@@ -57,9 +59,11 @@ public Delivery build() {
 
     @Override
     protected void createActivities() {
+        JobActivityList list = new SequentialJobActivityList(this);
         // TODO - Balage1551
-        getActivityList().addActivity(new DeliverServiceDEPRECATED(this));
-//        addActivity(new DeliveryActivityNEW(this, "delivery", getLocation(), getServiceDuration(), getSize()));
+//      list.addActivity(new DeliveryActivityNEW(this, "delivery", getLocation(), getServiceDuration(), getSize()));
+        list.addActivity(new DeliverServiceDEPRECATED(this));
+        setActivities(list);
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/GraphJobActivityList.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/GraphJobActivityList.java
new file mode 100644
index 000000000..34cac36da
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/GraphJobActivityList.java
@@ -0,0 +1,134 @@
+package com.graphhopper.jsprit.core.problem.job;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
+
+/**
+ * DAG (Directed Acyclic Graph) based activity list implementation.
+ * <p>
+ * The inserted activities and their relations create the dependency graph.
+ * </p>
+ *
+ * @author balage
+ *
+ */
+public class GraphJobActivityList extends SequentialJobActivityList {
+
+    protected Map<JobActivity, Set<JobActivity>> dependencies = new HashMap<>();
+
+    protected Map<JobActivity, Set<JobActivity>> transitivePrecedingDependencyCache = new HashMap<>();
+    protected Map<JobActivity, Set<JobActivity>> transitiveSubsequentDependencyCache = new HashMap<>();
+
+    public GraphJobActivityList(AbstractJob job) {
+        super(job);
+    }
+
+    @Override
+    public void addActivity(JobActivity activity) {
+        validateActivity(activity);
+        if (_activities.contains(activity)) {
+            return;
+        }
+        _activities.add(activity);
+        dependencies.put(activity, new HashSet<JobActivity>());
+        transitivePrecedingDependencyCache.put(activity, new HashSet<JobActivity>());
+        transitiveSubsequentDependencyCache.put(activity, new HashSet<JobActivity>());
+    }
+
+    public void addDependency(JobActivity priorActivity, JobActivity subsequentActivity) {
+        // Add activities if not added yet
+        if (!_activities.contains(priorActivity)) {
+            addActivity(priorActivity);
+        }
+        if (!_activities.contains(subsequentActivity)) {
+            addActivity(subsequentActivity);
+        }
+        // Check if dependency already in there
+        if (dependencies.get(priorActivity).contains(subsequentActivity)) {
+            return;
+        }
+
+        // Check if the new dependency would create a cycle
+        if (transitiveSubsequentDependencyCache.get(subsequentActivity).contains(priorActivity)) {
+            throw new IllegalArgumentException("Dependency between '"+priorActivity+"' and '"+subsequentActivity+"' would create a cycle.");
+        }
+
+        // Add new dependency
+        dependencies.get(priorActivity).add(subsequentActivity);
+
+        // Update cache
+        // === Subsequent =======
+        // The new subsequent abilities are the subsequent and its subsesequent abilities
+        Set<JobActivity> subsequentActivitiesToAdd = new HashSet<>(transitiveSubsequentDependencyCache.get(subsequentActivity));
+        subsequentActivitiesToAdd.add(subsequentActivity);
+        // The abilities to add the new ones to: the prior and its prior abilities
+        Set<JobActivity> subsequentActivitiesToUpdate = new HashSet<>(transitivePrecedingDependencyCache.get(priorActivity));
+        subsequentActivitiesToUpdate.add(priorActivity);
+
+        // === Preceding =======
+        // The new prior abilities are the prior and its trasitive prior abilities
+        Set<JobActivity> priorActivitiesToAdd = new HashSet<>(transitivePrecedingDependencyCache.get(priorActivity));
+        priorActivitiesToAdd.add(priorActivity);
+        // The abilities to add the new ones to: the subsequent and its transitively subsequent abilities
+        Set<JobActivity> priorActivitiesToUpdate = new HashSet<>(transitiveSubsequentDependencyCache.get(subsequentActivity));
+        priorActivitiesToUpdate.add(subsequentActivity);
+
+        // Do the updates
+        subsequentActivitiesToUpdate.forEach(a -> transitiveSubsequentDependencyCache.get(a).addAll(subsequentActivitiesToAdd));
+        priorActivitiesToUpdate.forEach(a -> transitivePrecedingDependencyCache.get(a).addAll(priorActivitiesToAdd));
+    }
+
+
+    @Override
+    public Set<JobActivity> getPreceding(JobActivity activity) {
+        if (!_activities.contains(activity)) {
+            throw new IllegalArgumentException("Activity '" + activity + "' is not in the list.");
+        }
+
+        return Collections.unmodifiableSet(transitivePrecedingDependencyCache.get(activity));
+    }
+
+    @Override
+    public Set<JobActivity> getSubsequent(JobActivity activity) {
+        if (!_activities.contains(activity)) {
+            throw new IllegalArgumentException("Activity '" + activity + "' is not in the list.");
+        }
+
+        return Collections.unmodifiableSet(transitiveSubsequentDependencyCache.get(activity));
+    }
+
+    public void printDetailed() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("DIRECT DEPENDENCIES\n");
+        sb.append(dependencies.entrySet().stream()
+                .flatMap(en -> en.getValue().stream().map(sa -> en.getKey().getName() + " -> " + sa.getName()))
+                .collect(Collectors.joining("\n")));
+        sb.append("\nTRANSITIVE PRECEDING DEPENDENCIES\n");
+        sb.append(transitivePrecedingDependencyCache.entrySet().stream()
+                .sorted((e1, e2) -> e1.getKey().getName().compareTo(e2.getKey().getName()))
+                .map(en -> en.getKey().getName() + ": " + en.getValue().stream()
+                        .map(pa -> pa.getName())
+                        .collect(Collectors.joining(", ")))
+                .collect(Collectors.joining("\n")));
+        sb.append("\nTRANSITIVE SUBSEQUENT DEPENDENCIES\n");
+        sb.append(transitiveSubsequentDependencyCache.entrySet().stream()
+                .sorted((e1, e2) -> e1.getKey().getName().compareTo(e2.getKey().getName()))
+                .map(en -> en.getKey().getName() + ": " + en.getValue().stream()
+                        .map(pa -> pa.getName())
+                        .sorted()
+                        .collect(Collectors.joining(", ")))
+                .collect(Collectors.joining("\n")));
+
+        System.out.println(sb.toString());
+    }
+
+
+
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/JobActivityList.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/JobActivityList.java
index 7669708b7..8e5565529 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/JobActivityList.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/JobActivityList.java
@@ -2,6 +2,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 
 import com.graphhopper.jsprit.core.problem.solution.route.activity.InternalActivityMarker;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
@@ -18,6 +19,8 @@
  */
 public abstract class JobActivityList {
 
+//    TODO getRElation of two activities: PRIOR, SUBSEQUENT or UNRELATED
+
     private AbstractJob job;
 
     public JobActivityList(AbstractJob job) {
@@ -75,7 +78,7 @@ protected void validateActivity(JobActivity activity) {
      *            The activity to compare to.
      * @return The list of the preceding activities.
      */
-    public abstract List<JobActivity> getPreceding(JobActivity activity);
+    public abstract Set<JobActivity> getPreceding(JobActivity activity);
 
     /**
      * Returns all the activities to be done after the <code>activity</code>.
@@ -84,7 +87,7 @@ protected void validateActivity(JobActivity activity) {
      *            The activity to compare to.
      * @return The list of the subsequent activities.
      */
-    public abstract List<JobActivity> getSubsequent(JobActivity activity);
+    public abstract Set<JobActivity> getSubsequent(JobActivity activity);
 
     /**
      * @return Returns the duplicated copy of the activities.
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Pickup.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Pickup.java
index 00e9143b3..8353768dd 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Pickup.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Pickup.java
@@ -47,8 +47,10 @@ public Pickup build() {
                 throw new IllegalArgumentException("location is missing");
             }
             setType("pickup");
-            postProcess();
-            return new Pickup(this);
+            preProcess();
+            Pickup pickup = new Pickup(this);
+            postProcess(pickup);
+            return pickup;
         }
 
     }
@@ -59,10 +61,11 @@ public Pickup build() {
 
     @Override
     protected void createActivities() {
+        JobActivityList list = new SequentialJobActivityList(this);
         // TODO - Balage1551
-        getActivityList().addActivity(new PickupServiceDEPRECATED(this));
-
-//        addActivity(new PickupActivityNEW(this, "pickup", getLocation(), getServiceDuration(), getSize()));
+//      addActivity(new PickupActivityNEW(this, "pickup", getLocation(), getServiceDuration(), getSize()));
+        list.addActivity(new PickupServiceDEPRECATED(this));
+        setActivities(list);
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/SequentialJobActivityList.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/SequentialJobActivityList.java
index 8251e90f9..0d13913c4 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/SequentialJobActivityList.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/SequentialJobActivityList.java
@@ -2,7 +2,9 @@
 
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 
 import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
 
@@ -20,11 +22,11 @@
     /**
      * The primary container.
      */
-    private List<JobActivity> _activities = new ArrayList<>();
+    protected List<JobActivity> _activities = new ArrayList<>();
     /**
      * A read only container backed by the primary one. This will be returned.
      */
-    private List<JobActivity> unmodifiableActivities = Collections.unmodifiableList(_activities);
+    protected List<JobActivity> unmodifiableActivities = Collections.unmodifiableList(_activities);
 
     public SequentialJobActivityList(AbstractJob job) {
         super(job);
@@ -62,16 +64,13 @@ private int indexOf(JobActivity activity) {
     }
 
     @Override
-    public List<JobActivity> getPreceding(JobActivity activity) {
-        return unmodifiableActivities.subList(0, indexOf(activity));
+    public Set<JobActivity> getPreceding(JobActivity activity) {
+        return new HashSet<>(unmodifiableActivities.subList(0, indexOf(activity)));
     }
 
     @Override
-    public List<JobActivity> getSubsequent(JobActivity activity) {
-        return unmodifiableActivities.subList(indexOf(activity), unmodifiableActivities.size());
+    public Set<JobActivity> getSubsequent(JobActivity activity) {
+        return new HashSet<>(unmodifiableActivities.subList(indexOf(activity), unmodifiableActivities.size()));
     }
 
-
-
-
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
index d9d3e9ccc..d04fa81d4 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
@@ -172,11 +172,6 @@ public B addTimeWindow(double earliest, double latest) {
         }
 
 
-        protected void postProcess() {
-            capacity = capacityBuilder.build();
-            skills = skillBuilder.build();
-        }
-
         @SuppressWarnings("unchecked")
         public B addRequiredSkill(String skill) {
             skillBuilder.addSkill(skill);
@@ -225,11 +220,39 @@ public B setPriority(int priority) {
         /**
          * Builds the service.
          *
+         * <p>
+         * The implementation of the builder <b>may</b> call the function {@linkplain #preProcess()} prior creating the
+         * instant and <b>MUST</b> call the {@linkplain #postProcess(Service)} method after the instance is constructed:
+         *
+         * <pre>
+         *    &#64;Override
+         *    public Service build() {
+         *        [...]
+         *        preProcess();
+         *        Service service = new Service(this);
+         *        postProcess(service);
+         *        return service;
+         *    }
+         * </pre>
+         *
+         * </p>
+         *
          * @return {@link Service}
          * @throws IllegalArgumentException
          *             if neither locationId nor coordinate is set.
          */
         public abstract <T extends Service> T build();
+
+        protected <T extends Service> void preProcess() {
+            capacity = capacityBuilder.build();
+            skills = skillBuilder.build();
+        }
+
+        protected <T extends Service> void postProcess(T service) {
+            // initiate caches
+            service.addLocations();
+            service.createActivities();
+        }
     }
 
 
@@ -253,32 +276,34 @@ public Service build() {
                 throw new IllegalArgumentException("location is missing");
             }
             setType("service");
-            postProcess();
-            return new Service(this);
+            preProcess();
+            Service service = new Service(this);
+            postProcess(service);
+            return service;
         }
 
     }
 
 
-    private final String id;
+    private String id;
 
-    private final String type;
+    private String type;
 
-    private final double serviceTime;
+    private double serviceTime;
 
-    private final TimeWindow timeWindow;
+    private TimeWindow timeWindow;
 
-    private final Capacity size;
+    private Capacity size;
 
-    private final Skills skills;
+    private Skills skills;
 
-    private final String name;
+    private String name;
 
-    private final Location location;
+    private Location location;
 
-    private final TimeWindows timeWindowManager;
+    private TimeWindows timeWindowManager;
 
-    private final int priority;
+    private int priority;
 
     Service(ServiceBuilderBase<?> builder) {
         id = builder.id;
@@ -291,16 +316,21 @@ public Service build() {
         location = builder.location;
         timeWindowManager = builder.timeWindows;
         priority = builder.priority;
-
-        addLocation(location);
-        createActivities();
     }
 
+
     @Override
     protected void createActivities() {
+        JobActivityList list = new SequentialJobActivityList(this);
         // TODO - Balage1551
-        getActivityList().addActivity(new PickupServiceDEPRECATED(this));
-//        getActivityList().addActivity(new ServiceActivityNEW(this, "service", getLocation(), getServiceDuration(), getSize()));
+//        list.addActivity(new ServiceActivityNEW(this, "service", getLocation(), getServiceDuration(), getSize()));
+        list.addActivity(new PickupServiceDEPRECATED(this));
+        setActivities(list);
+    }
+
+
+    protected void addLocations() {
+        addLocation(location);
     }
 
     public Collection<TimeWindow> getTimeWindows(){
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
index d1fcee781..e355ee0f2 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
@@ -258,28 +258,6 @@ public Builder addSizeDimension(int dimensionIndex, int dimensionValue) {
             return this;
         }
 
-
-        /**
-         * Builds the shipment.
-         *
-         * @return shipment
-         * @throws IllegalArgumentException
-         *             if neither pickup-location nor pickup-coord is set or if
-         *             neither delivery-location nor delivery-coord is set
-         */
-        public Shipment build() {
-            if (pickupLocation_ == null) {
-                throw new IllegalArgumentException("pickup location is missing");
-            }
-            if (deliveryLocation_ == null) {
-                throw new IllegalArgumentException("delivery location is missing");
-            }
-            capacity = capacityBuilder.build();
-            skills = skillBuilder.build();
-            return new Shipment(this);
-        }
-
-
         public Builder addRequiredSkill(String skill) {
             skillBuilder.addSkill(skill);
             return this;
@@ -339,6 +317,57 @@ public Builder setPriority(int priority) {
             this.priority = priority;
             return this;
         }
+
+
+        /**
+         * Builds a shipment.
+         *
+         * <p>
+         * The implementation of the builder <b>may</b> call the function {@linkplain #preProcess()} prior creating the
+         * instant and <b>MUST</b> call the {@linkplain #postProcess(Service)} method after the instance is constructed:
+         *
+         * <pre>
+         *    &#64;Override
+         *    public {@link Shipment} build() {
+         *        [...]
+         *        preProcess();
+         *        Shipment shipment= new Service(this);
+         *        postProcess(shipment);
+         *        return shipment;
+         *    }
+         * </pre>
+         *
+         * </p>
+         *
+         * @return shipment
+         * @throws IllegalArgumentException
+         *             if neither pickup-location nor pickup-coord is set or if neither delivery-location nor
+         *             delivery-coord is set
+         */
+        public Shipment build() {
+            if (pickupLocation_ == null) {
+                throw new IllegalArgumentException("pickup location is missing");
+            }
+            if (deliveryLocation_ == null) {
+                throw new IllegalArgumentException("delivery location is missing");
+            }
+            preProcess();
+            Shipment shipment = new Shipment(this);
+            postProcess(shipment);
+            return shipment;
+        }
+
+        protected void preProcess() {
+            capacity = capacityBuilder.build();
+            skills = skillBuilder.build();
+        }
+
+        protected <T extends Shipment> void postProcess(T shipment) {
+            // initiate caches
+            shipment.addLocations();
+            shipment.createActivities();
+        }
+
     }
 
     private final String id;
@@ -375,20 +404,24 @@ public Builder setPriority(int priority) {
         deliveryTimeWindows = builder.deliveryTimeWindows;
         pickupTimeWindows = builder.pickupTimeWindows;
         priority = builder.priority;
-
-        addLocation(pickupLocation_);
-        addLocation(deliveryLocation_);
-        createActivities();
     }
 
     @Override
     protected void createActivities() {
+        JobActivityList list = new SequentialJobActivityList(this);
         // TODO - Balage1551
-        getActivityList().addActivity(new PickupShipmentDEPRECATED(this));
-        getActivityList().addActivity(new DeliverShipmentDEPRECATED(this));
+//      list.addActivity(new PickupActivityNEW(this, "pickup", getPickupLocation(), getPickupServiceTime(), getSize()));
+//      list.addActivity(new PickupActivityNEW(this, "delivery", getDeliveryLocation(), getDeliveryServiceTime(), getSize()));
+        list.addActivity(new PickupShipmentDEPRECATED(this));
+        list.addActivity(new DeliverShipmentDEPRECATED(this));
+        setActivities(list);
+    }
+
 
-//        addActivity(new PickupActivityNEW(this, "pickup", getPickupLocation(), getPickupServiceTime(), getSize()));
-//        addActivity(new PickupActivityNEW(this, "delivery", getDeliveryLocation(), getDeliveryServiceTime(), getSize()));
+    @Override
+    protected void addLocations() {
+        addLocation(pickupLocation_);
+        addLocation(deliveryLocation_);
     }
 
     @Override
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/GraphJobActivityListTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/GraphJobActivityListTest.java
new file mode 100644
index 000000000..2a5fff90d
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/GraphJobActivityListTest.java
@@ -0,0 +1,199 @@
+package com.graphhopper.jsprit.core.problem.job;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.ServiceActivityNEW;
+
+public class GraphJobActivityListTest {
+
+    private AbstractJob job;
+
+    @Before
+    public void beforeClass() {
+        job = mock(Service.class);
+    }
+
+
+    private ServiceActivityNEW createActivity(AbstractJob job, String name) {
+        ServiceActivityNEW act = mock(ServiceActivityNEW.class);
+        when(act.getName()).thenReturn(name);
+        when(act.getJob()).thenReturn(job);
+        when(act.toString()).thenReturn(name);
+        return act;
+    }
+
+    private Set<JobActivity> setOf(JobActivity... actA) {
+        return new HashSet<>(Arrays.asList(actA));
+    }
+
+
+    @Test
+    public void whenCreatingList_itMustGiveBackTheCorrectJob() {
+        GraphJobActivityList list = new GraphJobActivityList(job);
+        assertEquals(job, list.getJob());
+    }
+
+    @Test
+    public void whenAddingAnActivity_itMustHaveTheCorrectJob() {
+        GraphJobActivityList list = new GraphJobActivityList(job);
+        ServiceActivityNEW actA = createActivity(job, "A");
+        list.addActivity(actA);
+        assertEquals(1, list.size());
+        assertEquals(actA, list.getAll().get(0));
+    }
+
+    @Test
+    public void whenAddingAnActivity_itMustInitializeTheCache() {
+        GraphJobActivityList list = new GraphJobActivityList(job);
+        ServiceActivityNEW actA = createActivity(job, "A");
+        list.addActivity(actA);
+        assertEquals(1, list.dependencies.size());
+        assertEquals(setOf(actA), list.dependencies.keySet());
+        assertEquals(1, list.transitivePrecedingDependencyCache.size());
+        assertEquals(setOf(actA), list.transitivePrecedingDependencyCache.keySet());
+        assertEquals(1, list.transitiveSubsequentDependencyCache.size());
+        assertEquals(setOf(actA), list.transitiveSubsequentDependencyCache.keySet());
+    }
+
+
+    @Test
+    public void whenAddingAnActivityTwice_itMustHaveToAddOnlyOnce() {
+        GraphJobActivityList list = new GraphJobActivityList(job);
+        ServiceActivityNEW actA = createActivity(job, "A");
+        list.addActivity(actA);
+        list.addActivity(actA);
+        assertEquals(1, list.size());
+        assertEquals(actA, list.getAll().get(0));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenAddingAnActivityWithWrongJob_itMustThrowException() {
+        GraphJobActivityList list = new GraphJobActivityList(job);
+        list.addActivity(createActivity(mock(Service.class), "A"));
+    }
+
+    @Test
+    public void whenAddingADependency_itMustAddTheActivities() {
+        GraphJobActivityList list = new GraphJobActivityList(job);
+        ServiceActivityNEW actA = createActivity(job, "A");
+        ServiceActivityNEW actB = createActivity(job, "B");
+        list.addActivity(actA);
+        list.addDependency(actA, actB);
+        assertEquals(2, list.size());
+        assertEquals(actA, list.getAll().get(0));
+        assertEquals(actB, list.getAll().get(1));
+    }
+
+    @Test
+    public void whenAddingADependency_itMustUpdateCaches() {
+        GraphJobActivityList list = new GraphJobActivityList(job);
+        ServiceActivityNEW actA = createActivity(job, "A");
+        ServiceActivityNEW actB = createActivity(job, "B");
+        list.addDependency(actA, actB);
+        assertEquals(setOf(actB), list.dependencies.get(actA));
+        assertEquals(setOf(actA), list.transitivePrecedingDependencyCache.get(actB));
+        assertEquals(setOf(actB), list.transitiveSubsequentDependencyCache.get(actA));
+    }
+
+    @Test
+    public void whenAddingASecondDependency_itMustUpdateCachesTransitively() {
+        GraphJobActivityList list = new GraphJobActivityList(job);
+        ServiceActivityNEW actA = createActivity(job, "A");
+        ServiceActivityNEW actB = createActivity(job, "B");
+        ServiceActivityNEW actC = createActivity(job, "C");
+        list.addDependency(actA, actB);
+        list.addDependency(actB, actC);
+        assertEquals(setOf(actB), list.dependencies.get(actA));
+        assertEquals(setOf(actC), list.dependencies.get(actB));
+        assertEquals(setOf(actA), list.transitivePrecedingDependencyCache.get(actB));
+        assertEquals(setOf(actA, actB), list.transitivePrecedingDependencyCache.get(actC));
+        assertEquals(setOf(actB, actC), list.transitiveSubsequentDependencyCache.get(actA));
+        assertEquals(setOf(actC), list.transitiveSubsequentDependencyCache.get(actB));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenAddingADependencyWhichCreatesCycly_itMustThrowAnException() {
+        GraphJobActivityList list = new GraphJobActivityList(job);
+        ServiceActivityNEW actA = createActivity(job, "A");
+        ServiceActivityNEW actB = createActivity(job, "B");
+        list.addDependency(actA, actB);
+        list.addDependency(actB, actA);
+    }
+
+
+    @Test
+    public void complexTest() {
+        ServiceActivityNEW actA = createActivity(job, "A");
+        ServiceActivityNEW actB = createActivity(job, "B");
+        ServiceActivityNEW actC = createActivity(job, "C");
+        ServiceActivityNEW actD = createActivity(job, "D");
+        ServiceActivityNEW actE = createActivity(job, "E");
+
+        GraphJobActivityList list = new GraphJobActivityList(job);
+        list.addDependency(actA, actB);
+        list.addDependency(actA, actC);
+        list.addDependency(actB, actD);
+        list.addActivity(actE);
+        assertEquals(setOf(), list.transitivePrecedingDependencyCache.get(actA));
+        assertEquals(setOf(actA), list.transitivePrecedingDependencyCache.get(actB));
+        assertEquals(setOf(actA), list.transitivePrecedingDependencyCache.get(actC));
+        assertEquals(setOf(actA, actB), list.transitivePrecedingDependencyCache.get(actD));
+        assertEquals(setOf(), list.transitivePrecedingDependencyCache.get(actE));
+        assertEquals(setOf(actB, actC, actD), list.transitiveSubsequentDependencyCache.get(actA));
+        assertEquals(setOf(actD), list.transitiveSubsequentDependencyCache.get(actB));
+        assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actC));
+        assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actD));
+        assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actE));
+
+
+        list.addDependency(actB, actE);
+        assertEquals(setOf(), list.transitivePrecedingDependencyCache.get(actA));
+        assertEquals(setOf(actA), list.transitivePrecedingDependencyCache.get(actB));
+        assertEquals(setOf(actA), list.transitivePrecedingDependencyCache.get(actC));
+        assertEquals(setOf(actA, actB), list.transitivePrecedingDependencyCache.get(actD));
+        assertEquals(setOf(actA, actB), list.transitivePrecedingDependencyCache.get(actE));
+        assertEquals(setOf(actB, actC, actD, actE), list.transitiveSubsequentDependencyCache.get(actA));
+        assertEquals(setOf(actD, actE), list.transitiveSubsequentDependencyCache.get(actB));
+        assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actC));
+        assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actD));
+        assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actE));
+
+        list.addDependency(actC, actD);
+        assertEquals(setOf(), list.transitivePrecedingDependencyCache.get(actA));
+        assertEquals(setOf(actA), list.transitivePrecedingDependencyCache.get(actB));
+        assertEquals(setOf(actA), list.transitivePrecedingDependencyCache.get(actC));
+        assertEquals(setOf(actA, actB, actC), list.transitivePrecedingDependencyCache.get(actD));
+        assertEquals(setOf(actA, actB), list.transitivePrecedingDependencyCache.get(actE));
+        assertEquals(setOf(actB, actC, actD, actE), list.transitiveSubsequentDependencyCache.get(actA));
+        assertEquals(setOf(actD, actE), list.transitiveSubsequentDependencyCache.get(actB));
+        assertEquals(setOf(actD), list.transitiveSubsequentDependencyCache.get(actC));
+        assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actD));
+        assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actE));
+
+        list.addDependency(actD, actE);
+        assertEquals(setOf(), list.transitivePrecedingDependencyCache.get(actA));
+        assertEquals(setOf(actA), list.transitivePrecedingDependencyCache.get(actB));
+        assertEquals(setOf(actA), list.transitivePrecedingDependencyCache.get(actC));
+        assertEquals(setOf(actA, actB, actC), list.transitivePrecedingDependencyCache.get(actD));
+        assertEquals(setOf(actA, actB, actC, actD), list.transitivePrecedingDependencyCache.get(actE));
+        assertEquals(setOf(actB, actC, actD, actE), list.transitiveSubsequentDependencyCache.get(actA));
+        assertEquals(setOf(actD, actE), list.transitiveSubsequentDependencyCache.get(actB));
+        assertEquals(setOf(actD, actE), list.transitiveSubsequentDependencyCache.get(actC));
+        assertEquals(setOf(actE), list.transitiveSubsequentDependencyCache.get(actD));
+        assertEquals(setOf(), list.transitiveSubsequentDependencyCache.get(actE));
+
+    }
+
+
+
+}
