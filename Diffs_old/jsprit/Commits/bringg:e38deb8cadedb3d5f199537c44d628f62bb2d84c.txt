diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/CalcVehicleTypeDependentServiceInsertionTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/CalcVehicleTypeDependentServiceInsertionTest.java
index 109d85458..b7c57ad45 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/CalcVehicleTypeDependentServiceInsertionTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/CalcVehicleTypeDependentServiceInsertionTest.java
@@ -24,11 +24,11 @@
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
 import com.graphhopper.jsprit.core.problem.vehicle.*;
-import org.junit.Before;
 import org.junit.Test;
 
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.Random;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
@@ -37,19 +37,18 @@
 
 
 public class CalcVehicleTypeDependentServiceInsertionTest {
-
+    final static Random RANDOM = new Random();
     Vehicle veh1;
     Vehicle veh2;
     VehicleFleetManager fleetManager;
     Service service;
     VehicleRoute vehicleRoute;
 
-    @Before
-    public void doBefore() {
+    public void initVehicles(double fixedCost1, double fixedCost2) {
         veh1 = mock(Vehicle.class);
         veh2 = mock(Vehicle.class);
-        when(veh1.getType()).thenReturn(VehicleTypeImpl.Builder.newInstance("type1").build());
-        when(veh2.getType()).thenReturn(VehicleTypeImpl.Builder.newInstance("type2").build());
+        when(veh1.getType()).thenReturn(VehicleTypeImpl.Builder.newInstance("type1").setFixedCost(fixedCost1).build());
+        when(veh2.getType()).thenReturn(VehicleTypeImpl.Builder.newInstance("type2").setFixedCost(fixedCost2).build());
         when(veh1.getStartLocation()).thenReturn(Location.newInstance("loc1"));
         when(veh2.getStartLocation()).thenReturn(Location.newInstance("loc2"));
         fleetManager = mock(VehicleFleetManager.class);
@@ -60,9 +59,6 @@ public void doBefore() {
 
         VehicleType type = mock(VehicleType.class);
         when(type.getCapacityDimensions()).thenReturn(Capacity.Builder.newInstance().addDimension(0, 10).build());
-        when(veh1.getType()).thenReturn(type);
-
-        when(veh2.getType()).thenReturn(type);
 
         when(service.getSize()).thenReturn(Capacity.Builder.newInstance().build());
         when(service.getTimeWindow()).thenReturn(TimeWindow.newInstance(0.0, Double.MAX_VALUE));
@@ -73,6 +69,7 @@ public void doBefore() {
 
     @Test
     public void whenHaving2Vehicle_calcInsertionOfCheapest() {
+        initVehicles(.0, .0);
         JobInsertionCostsCalculator calc = mock(JobInsertionCostsCalculator.class);
         InsertionData iDataVeh1 = new InsertionData(10.0, InsertionData.NO_INDEX, 1, veh1, null);
         InsertionData iDataVeh2 = new InsertionData(20.0, InsertionData.NO_INDEX, 1, veh2, null);
@@ -89,6 +86,7 @@ public void whenHaving2Vehicle_calcInsertionOfCheapest() {
 
     @Test
     public void whenHaving2Vehicle_calcInsertionOfCheapest2() {
+        initVehicles(.0, .0);
         JobInsertionCostsCalculator calc = mock(JobInsertionCostsCalculator.class);
         InsertionData iDataVeh1 = new InsertionData(20.0, InsertionData.NO_INDEX, 1, veh1, null);
         InsertionData iDataVeh2 = new InsertionData(10.0, InsertionData.NO_INDEX, 1, veh2, null);
@@ -102,4 +100,25 @@ public void whenHaving2Vehicle_calcInsertionOfCheapest2() {
         assertThat(iData.getSelectedVehicle(), is(veh2));
 
     }
+
+    @Test
+    public void whenHaving2VehicleCalcInsertionOfCheapestByFixedCost2() {
+        double insertionCost2 = RANDOM.nextInt(100);
+        double insertionCost1 = insertionCost2 + RANDOM.nextInt(100);
+        double fixed1 = RANDOM.nextDouble() + 1;
+        double fixed2 = RANDOM.nextDouble() + fixed1 + insertionCost2;
+        initVehicles(fixed1, fixed2);
+        JobInsertionCostsCalculator calc = mock(JobInsertionCostsCalculator.class);
+        InsertionData iDataVeh1 = new InsertionData(insertionCost1, InsertionData.NO_INDEX, 1, veh1, null);
+        InsertionData iDataVeh2 = new InsertionData(insertionCost2, InsertionData.NO_INDEX, 1, veh2, null);
+        when(calc.getInsertionData(vehicleRoute, service, veh1, veh1.getEarliestDeparture(), null, Double.MAX_VALUE)).thenReturn(iDataVeh1);
+        when(calc.getInsertionData(vehicleRoute, service, veh2, veh2.getEarliestDeparture(), null, Double.MAX_VALUE)).thenReturn(iDataVeh2);
+        when(calc.getInsertionData(vehicleRoute, service, veh2, veh2.getEarliestDeparture(), null, insertionCost1 + fixed1)).thenReturn(iDataVeh1);
+        VehicleRoutingProblem vrp = mock(VehicleRoutingProblem.class);
+        when(vrp.getInitialVehicleRoutes()).thenReturn(Collections.<VehicleRoute>emptyList());
+        VehicleTypeDependentJobInsertionCalculator insertion = new VehicleTypeDependentJobInsertionCalculator(vrp, fleetManager, calc);
+        InsertionData iData = insertion.getInsertionData(vehicleRoute, service, null, 0.0, null, Double.MAX_VALUE);
+        assertThat(iData.getSelectedVehicle(), is(veh1));
+
+    }
 }
