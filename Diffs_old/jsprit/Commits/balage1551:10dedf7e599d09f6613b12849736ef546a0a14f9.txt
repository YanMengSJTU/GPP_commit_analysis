diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
index 1043cb8d4..57e2ec665 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
@@ -724,6 +724,26 @@ private SolutionCostCalculator getObjectiveFunction() {
         return modCalc;
     }
 
+    /**
+     * Creates a default objective function calculator.
+     *
+     * <p>
+     * This function will contain the following components:
+     * <ul>
+     * <li>{@linkplain FixCostPerVehicle}</li>
+     * <li>{@linkplain MissedBreak}</li>
+     * <li>{@linkplain TransportCost}</li>
+     * <li>{@linkplain ActivityCost}</li>
+     * <li>{@linkplain UnassignedJobs}</li>
+     * </ul>
+     * </p>
+     * <p>
+     * All components will be initialized with their default parameters and will
+     * have the weight of 1.0.
+     * </p>
+     *
+     * @return The default objective function calculator
+     */
     public static ModularSolutionCostCalculator createDefaultSolutionCostCalculator() {
         ModularSolutionCostCalculator modCalc = new ModularSolutionCostCalculator();
         modCalc.addComponent(new FixCostPerVehicle())
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ActivityCost.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ActivityCost.java
index d14543306..74850fb90 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ActivityCost.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ActivityCost.java
@@ -4,6 +4,19 @@
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 
+/**
+ * A cost calculator component for a all activity (operation) costs.
+ * <p>
+ * This cost calculator returns the sum of the activity cost of all the
+ * activities on the route.
+ * </p>
+ * <p>
+ * This is a route level component.
+ * </p>
+ *
+ * @author balage
+ *
+ */
 public class ActivityCost extends RouteLevelSolutionCostComponent {
 
     public static final String COMPONENT_ID = "Activity";
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ComponentValue.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ComponentValue.java
index 53101db63..5a9423c6c 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ComponentValue.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ComponentValue.java
@@ -1,41 +1,92 @@
 package com.graphhopper.jsprit.core.algorithm.objectivefunction;
 
+/**
+ * Data class to hold the value of a cost component.
+ *
+ * @author balage
+ *
+ * @see {@linkplain RouteLevelComponentValue}
+ * @see {@linkplain SolutionCostComponent}
+ */
 public class ComponentValue {
+    // The key of the component
     private String key;
+    // The value (unweighted)
     private double value = 0d;
+    // The weight
     private double weight = 1d;
 
+    /**
+     * Constrictor with no value set.
+     *
+     * @param key
+     *            The key of the component.
+     */
     public ComponentValue(String key) {
         super();
         this.key = key;
     }
 
+    /**
+     * Constructor with value set.
+     *
+     * @param key
+     *            The key of the component.
+     * @param value
+     *            The cost value.
+     */
     public ComponentValue(String key, double value) {
         this(key);
         this.value = value;
     }
 
+    /**
+     * Alters the weight.
+     *
+     * @param weight
+     *            The new weight.
+     * @return The value object itself.
+     */
     final ComponentValue withWeight(double weight) {
         this.weight = weight;
         return this;
     }
 
+    /**
+     * @return The key of the component.
+     *
+     */
     public String getKey() {
         return key;
     }
 
+    /**
+     * @return The cost value (unweighted).
+     */
     public double getValue() {
         return value;
     }
 
+    /**
+     * @return The weight.
+     */
     public double getWeight() {
         return weight;
     }
 
+    /**
+     * @return The weighted value.
+     */
     public double getWeightedValue() {
         return weight * value;
     }
 
+    /**
+     * Increases the value.
+     *
+     * @param valueToAdd
+     *            The value to add to the current value.
+     */
     protected void addToValue(double valueToAdd) {
         value += valueToAdd;
     }
@@ -45,6 +96,11 @@ public String toString() {
         return "ComponentValue [key=" + key + ", weight=" + weight + ", value=" + value + "]";
     }
 
+    /**
+     * Clones the value object.
+     * 
+     * @return A copy of the value object.
+     */
     public ComponentValue copy() {
         return new ComponentValue(key, value).withWeight(weight);
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/FixCostPerVehicle.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/FixCostPerVehicle.java
index 9d11987d6..56dcdb8cb 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/FixCostPerVehicle.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/FixCostPerVehicle.java
@@ -3,8 +3,23 @@
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 
+/**
+ * A cost calculator component for a per vehicle static cost.
+ * <p>
+ * This cost calculator returns the fixed cost of the vehicle type.
+ * </p>
+ * <p>
+ * This is a route level component.
+ * </p>
+ *
+ * @author balage
+ *
+ */
 public class FixCostPerVehicle extends RouteLevelSolutionCostComponent {
 
+    /**
+     * The unique id of the component.
+     */
     public static final String COMPONENT_ID = "VehicleFix";
 
     public FixCostPerVehicle() {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/MissedBreak.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/MissedBreak.java
index 30e5dd240..ff9147ef8 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/MissedBreak.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/MissedBreak.java
@@ -5,6 +5,19 @@
 import com.graphhopper.jsprit.core.problem.solution.route.activity.BreakActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 
+/**
+ * A cost calculator component for penaltizing activities in break time.
+ * <p>
+ * This cost calculator returns a value proportional value to the length of the
+ * break.
+ * </p>
+ * <p>
+ * This is a route level component.
+ * </p>
+ *
+ * @author balage
+ *
+ */
 public class MissedBreak extends RouteLevelSolutionCostComponent {
 
     public static final String COMPONENT_ID = "MissedBreak";
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java
index 03f5120c4..2eb260540 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java
@@ -10,21 +10,65 @@
 import com.graphhopper.jsprit.core.problem.solution.SolutionCostCalculator;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 
+/**
+ * A solution cost calculator implementation with customizable cost components.
+ *
+ * <p>
+ * This calculator uses {@linkplain SolutionCostComponent} implementations to
+ * calculate solution cost (objective function). The user can define and manage
+ * the set of components it has to take into account. The value of each
+ * component is calculated independently and stored. The aggregated cost will be
+ * sum of the wighted cost of each component.
+ * </p>
+ * <p>
+ * The calculator has two internal states. In the first one, the components are
+ * free to alter. However, by calling the
+ * {@linkplain #beforeRun(VehicleRoutingProblem, double)} function, the state
+ * change to initialized, and the components are not allowed to be altered any
+ * more. ({@linkplain IllegalStateException} is thrown.)
+ * </p>
+ *
+ * @author balage
+ *
+ */
 public class ModularSolutionCostCalculator implements SolutionCostCalculator {
 
+    // The problem the calculator works on
     private VehicleRoutingProblem problem;
+    // The registered components
     private Map<SolutionCostComponent, Double> components = new LinkedHashMap<>();
 
+    // Internal state flag
     private boolean initialized = false;
 
+    /**
+     * Constructor. Creates a calculator with no components assigned to.
+     */
     public ModularSolutionCostCalculator() {
         super();
     }
 
+    /**
+     * Registers a new component with a weight of 1.
+     *
+     * @param component
+     *            The component to register.
+     * @return The cost calculator itself.
+     */
     public ModularSolutionCostCalculator addComponent(SolutionCostComponent component) {
         return addComponent(component, 1d);
     }
 
+    /**
+     * Registers several new components in one step, with each component having
+     * the weight of 1.
+     *
+     * @param component
+     *            The first component to register.
+     * @param components
+     *            The additional components.
+     * @return The cost calculator itself.
+     */
     public ModularSolutionCostCalculator addComponents(SolutionCostComponent component, SolutionCostComponent... components) {
         addComponent(component);
         for (SolutionCostComponent c : components) {
@@ -33,6 +77,23 @@ public ModularSolutionCostCalculator addComponents(SolutionCostComponent compone
         return this;
     }
 
+    /**
+     * Registers a new component with weight specified.
+     * <p>
+     * Note, that the weight could be zero (the component will be ignored), or
+     * even negative which makes the component a benefical (cost reducing)
+     * factor.
+     * </p>
+     *
+     * @param component
+     *            The component to register.
+     * @param weight
+     *            The weight of the component.
+     *
+     * @return The cost calculator itself.
+     * @throws IllegalArgumentException
+     *             If the component is already registered.
+     */
     public ModularSolutionCostCalculator addComponent(SolutionCostComponent component, double weight) {
         if (components.containsKey(component.getId())) {
             throw new IllegalArgumentException("Cost component '" + component.getId() + "' is duplicated.");
@@ -41,6 +102,67 @@ public ModularSolutionCostCalculator addComponent(SolutionCostComponent componen
         return this;
     }
 
+
+    /**
+     * Returns whether the component with the key is registered.
+     *
+     * @param key
+     *            The key to look for.
+     * @return True if the component is registered.
+     */
+    public boolean containsComponent(String key) {
+        return components.keySet().stream().anyMatch(c -> c.getId().equals(key));
+    }
+
+    /**
+     * Returns the component with the key.
+     *
+     * @param key
+     *            The key to look for.
+     * @return The registered component if registered or empty.
+     */
+    public Optional<SolutionCostComponent> findComponent(String key) {
+        return components.keySet().stream().filter(c -> c.getId().equals(key)).findAny();
+    }
+
+    /**
+     * Changes the weigth value of an already registered component. Does nothing
+     * if the component is not registered.
+     *
+     * @param key
+     *            The key to look for.
+     * @param newWeight
+     *            The new weight.
+     */
+    public void changeComponentWeight(String key, double newWeight) {
+        findComponent(key).ifPresent(c -> components.put(c, newWeight));
+    }
+
+    /**
+     * Removes (unregisters) a component and returns it.
+     * <p>
+     * This makes it possible to start from a predefined calculator (such as the
+     * default one) and reconfiguring one of its components.
+     * </p>
+     * 
+     * @param key
+     *            The key of the component to remove.
+     * @return The removed component or empty if the component was not
+     *         registered.
+     */
+    public Optional<SolutionCostComponent> removeComponent(String key) {
+        Optional<SolutionCostComponent> optC = findComponent(key);
+        optC.ifPresent(c -> components.remove(c));
+        return optC;
+    }
+
+    /**
+     * Calculates the cost values of each component.
+     *
+     * @param solution
+     *            The solution to calculate the costs on.
+     * @return A list of calculated component cost values.
+     */
     public List<ComponentValue> calculate(VehicleRoutingProblemSolution solution) {
         if (!isInitialized()) {
             throw new IllegalStateException("Not initialized.");
@@ -48,9 +170,17 @@ public ModularSolutionCostCalculator addComponent(SolutionCostComponent componen
         beforeSolution();
         return components.entrySet().stream()
                         .map(en -> en.getKey().calculateCost(problem, solution).withWeight(en.getValue()))
-                        .collect(Collectors.toList());}
+                        .collect(Collectors.toList());
+    }
 
 
+    /**
+     * {@inheritDoc}
+     * <p>
+     * Calls the {@linkplain #calculate(VehicleRoutingProblemSolution)} function
+     * and aggregates the weighted sum of the components costs.
+     * </p>
+     */
     @Override
     public double getCosts(VehicleRoutingProblemSolution solution) {
         if (!isInitialized()) {
@@ -61,36 +191,36 @@ public double getCosts(VehicleRoutingProblemSolution solution) {
                         .sum();
     }
 
+    /**
+     * Called by the optimizer to initialize the calculator.
+     * <p>
+     * This function changes the state of the calculator to initialized and no
+     * further component management is possible afterward.
+     * </p>
+     *
+     * @param problem
+     *            The problem the calculator works on.
+     * @param maxCosts
+     *            The maximum cost constant to use in cost components.
+     */
     public void beforeRun(VehicleRoutingProblem problem, double maxCosts) {
         this.problem = problem;
         components.keySet().forEach(c -> c.beforeRun(problem, maxCosts));
         initialized = true;
     }
 
+    /**
+     * @return Whether the calculator is initialized.
+     */
     public boolean isInitialized() {
         return initialized;
     }
 
+    /**
+     * Called by the calculator to make any pre solution initialization.
+     */
     private void beforeSolution() {
         components.keySet().forEach(c -> c.beforeSolution(problem));
     }
 
-    public boolean containsComponent(String key) {
-        return components.keySet().stream().anyMatch(c -> c.getId().equals(key));
-    }
-
-    public Optional<SolutionCostComponent> findComponent(String key) {
-        return components.keySet().stream().filter(c -> c.getId().equals(key)).findAny();
-    }
-
-    public void changeComponentWeight(String key, double newWeight) {
-        findComponent(key).ifPresent(c -> components.put(c, newWeight));
-    }
-
-    public Optional<SolutionCostComponent> removeComponent(String key) {
-        Optional<SolutionCostComponent> optC = findComponent(key);
-        optC.ifPresent(c -> components.remove(c));
-        return optC;
-    }
-
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelComponentValue.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelComponentValue.java
index f193fd7eb..546e92c76 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelComponentValue.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelComponentValue.java
@@ -4,19 +4,50 @@
 import java.util.Map;
 import java.util.Optional;
 
+/**
+ * A cost value implementation which holds an additional per route cost
+ * information.
+ *
+ * @author balage
+ *
+ */
 public class RouteLevelComponentValue extends ComponentValue {
 
+    // The per route cost value
     private Map<Integer, Double> routeLevelValue = new HashMap<>();
 
+    /**
+     * Constrictor with no value set.
+     *
+     * @param key
+     *            The key of the component.
+     */
     public RouteLevelComponentValue(String key) {
         super(key);
     }
 
+    /**
+     * Sets the route value.
+     *
+     * @param routeId
+     *            The route id.
+     * @param value
+     *            The value of the route.
+     */
     public void setRouteValue(int routeId, double value) {
+        getRouteValue(routeId).ifPresent(v -> addToValue(-v));
         routeLevelValue.put(routeId, value);
         addToValue(value);
     }
 
+    /**
+     * Returns the cost value of the route.
+     * 
+     * @param routeId
+     *            The route id.
+     * @return The cost value of the route or empty if no value available for
+     *         the route.
+     */
     public Optional<Double> getRouteValue(int routeId) {
         if (routeLevelValue.containsKey(routeId)) {
             return Optional.ofNullable(routeLevelValue.get(routeId));
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelSolutionCostComponent.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelSolutionCostComponent.java
index 8c7de45a2..3504968e1 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelSolutionCostComponent.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelSolutionCostComponent.java
@@ -4,12 +4,34 @@
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 
+/**
+ * An implementation of solution cost component which calculates and keeps track
+ * of cost per route level.
+ *
+ * @author balage
+ *
+ */
 public abstract class RouteLevelSolutionCostComponent extends SolutionCostComponent {
 
+    /**
+     * Constructor.
+     *
+     * @param id
+     *            The unique id of the component.
+     */
     public RouteLevelSolutionCostComponent(String id) {
         super(id);
     }
 
+    /**
+     * {@inheritDoc}
+     * <p>
+     * This implementation calls the
+     * {@linkplain #calculateRouteLevelCost(VehicleRoutingProblem, VehicleRoute)}
+     * for each route in the solution and stores the calculated cost values,
+     * then returns the sum of them.
+     * </p>
+     */
     @Override
     public RouteLevelComponentValue calculateCost(VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution) {
         RouteLevelComponentValue cv = new RouteLevelComponentValue(getId());
@@ -20,5 +42,14 @@ public RouteLevelComponentValue calculateCost(VehicleRoutingProblem problem, Veh
         return cv;
     }
 
+    /**
+     * Calculates the cost of a route.
+     *
+     * @param problem
+     *            The problem the calculation will run on.
+     * @param route
+     *            The route to calculate the cost of.
+     * @return The cost value of the route.
+     */
     protected abstract double calculateRouteLevelCost(VehicleRoutingProblem problem, VehicleRoute route);
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/SolutionCostComponent.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/SolutionCostComponent.java
index 4e7c10650..c3a98cd8d 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/SolutionCostComponent.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/SolutionCostComponent.java
@@ -3,31 +3,85 @@
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 
+/**
+ * Base class for solution cost calculator components.
+ *
+ * <p>
+ * Two components regarded as equal if their id is equal.
+ * </p>
+ *
+ * @author balage
+ * @see {@linkplain RouteLevelSolutionCostComponent}
+ */
 public abstract class SolutionCostComponent {
 
+    // The unique id of the component
     private String id;
 
+    // The maximum costs variable
     private double maxCosts;
 
+    /**
+     * Constructor.
+     *
+     * @param id
+     *            The unique id of the component.
+     */
     public SolutionCostComponent(String id) {
         super();
         this.id = id;
     }
 
+    /**
+     * Initialization of the component.
+     * <p>
+     * This implementation stores the maximum costs, therefore all overridden
+     * implementations should call the super implementation!
+     * </p>
+     *
+     * @param problem
+     *            The problem the calculation will run on.
+     * @param maxCosts
+     *            The maximum cost value.
+     */
     public void beforeRun(VehicleRoutingProblem problem, double maxCosts) {
         this.maxCosts = maxCosts;
     }
 
+    /**
+     * Initilization called before each calculation on a solution.
+     * <p>
+     * This implementation does nothing.
+     * </p>
+     *
+     * @param problem
+     *            The problem the calculation will run on.
+     */
     public void beforeSolution(VehicleRoutingProblem problem) {
     }
 
+    /**
+     * Calculates the component cost of the solution.
+     *
+     * @param problem
+     *            The problem the calculation will run on.
+     * @param solution
+     *            The solution to calculate on.
+     * @return The calculated value.
+     */
     public abstract ComponentValue calculateCost(VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution);
 
 
+    /**
+     * @return The unique id of the component.
+     */
     public String getId() {
         return id;
     }
 
+    /**
+     * @return The maximum travel cost of the problem.
+     */
     public double getMaxCosts() {
         return maxCosts;
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/TransportCost.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/TransportCost.java
index 7a77343ad..f19d285ec 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/TransportCost.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/TransportCost.java
@@ -4,6 +4,19 @@
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 
+/**
+ * A cost calculator component for a all transport costs.
+ * <p>
+ * This cost calculator returns the sum of the transport cost of all the
+ * activities on the route.
+ * </p>
+ * <p>
+ * This is a route level component.
+ * </p>
+ *
+ * @author balage
+ *
+ */
 public class TransportCost extends RouteLevelSolutionCostComponent {
 
     public static final String COMPONENT_ID = "Transport";
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/UnassignedJobs.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/UnassignedJobs.java
index b28aa02de..0e18153e8 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/UnassignedJobs.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/UnassignedJobs.java
@@ -4,6 +4,12 @@
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 
+/**
+ * A cost calculator component for penaltizing unassingned jobs.
+ *
+ * @author balage
+ *
+ */
 public class UnassignedJobs extends SolutionCostComponent {
 
     public static final String COMPONENT_ID = "Unassigned";
