diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculator.java
new file mode 100644
index 000000000..c15e1b99b
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculator.java
@@ -0,0 +1,191 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.jsprit.core.algorithm.recreate;
+
+import com.graphhopper.jsprit.core.problem.JobActivityFactory;
+import com.graphhopper.jsprit.core.problem.constraint.*;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
+import com.graphhopper.jsprit.core.problem.driver.Driver;
+import com.graphhopper.jsprit.core.problem.job.Job;
+import com.graphhopper.jsprit.core.problem.misc.ActivityContext;
+import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.*;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+
+final class GeneralJobInsertionCalculator implements JobInsertionCostsCalculator {
+
+    private static final Logger logger = LoggerFactory.getLogger(GeneralJobInsertionCalculator.class);
+
+    private HardRouteConstraint hardRouteLevelConstraint;
+
+    private HardActivityConstraint hardActivityLevelConstraint;
+
+    private SoftRouteConstraint softRouteConstraint;
+
+    private SoftActivityConstraint softActivityConstraint;
+
+    private ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
+
+    private VehicleRoutingTransportCosts transportCosts;
+
+    private VehicleRoutingActivityCosts activityCosts;
+
+    private JobActivityFactory activityFactory;
+
+    private AdditionalAccessEgressCalculator additionalAccessEgressCalculator;
+
+    public GeneralJobInsertionCalculator(VehicleRoutingTransportCosts routingCosts, VehicleRoutingActivityCosts activityCosts, ActivityInsertionCostsCalculator activityInsertionCostsCalculator, ConstraintManager constraintManager) {
+        super();
+        this.activityInsertionCostsCalculator = activityInsertionCostsCalculator;
+        hardRouteLevelConstraint = constraintManager;
+        hardActivityLevelConstraint = constraintManager;
+        softActivityConstraint = constraintManager;
+        softRouteConstraint = constraintManager;
+        transportCosts = routingCosts;
+        this.activityCosts = activityCosts;
+        additionalAccessEgressCalculator = new AdditionalAccessEgressCalculator(routingCosts);
+        logger.debug("initialise {}", this);
+    }
+
+    public void setJobActivityFactory(JobActivityFactory activityFactory) {
+        this.activityFactory = activityFactory;
+    }
+
+    @Override
+    public String toString() {
+        return "[name=calculatesServiceInsertion]";
+    }
+
+    /**
+     * Calculates the marginal cost of inserting job i locally. This is based on the
+     * assumption that cost changes can entirely covered by only looking at the predecessor i-1 and its successor i+1.
+     */
+    @Override
+    public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job jobToInsert, final Vehicle newVehicle, double newVehicleDepartureTime, final Driver newDriver, final double bestKnownCosts) {
+        JobInsertionContext insertionContext = new JobInsertionContext(currentRoute, jobToInsert, newVehicle, newDriver, newVehicleDepartureTime);
+        List<JobActivity> actList = jobToInsert.getActivityList().getAllDuplicated();
+        insertionContext.getAssociatedActivities().addAll(actList);
+        /*
+        check hard route constraints
+         */
+        if (!hardRouteLevelConstraint.fulfilled(insertionContext)) {
+            return InsertionData.createEmptyInsertionData();
+        }
+        /*
+        check soft route constraints
+         */
+        double additionalICostsAtRouteLevel = softRouteConstraint.getCosts(insertionContext);
+        additionalICostsAtRouteLevel += additionalAccessEgressCalculator.getCosts(insertionContext);
+
+        Start start = new Start(newVehicle.getStartLocation(), newVehicle.getEarliestDeparture(), newVehicle.getLatestArrival());
+        start.setEndTime(newVehicleDepartureTime);
+        End end = new End(newVehicle.getEndLocation(), 0.0, newVehicle.getLatestArrival());
+
+        List<TourActivity> newRoute = new ArrayList<>();
+        newRoute.add(start);
+        newRoute.addAll(currentRoute.getTourActivities().getActivities());
+        newRoute.add(end);
+
+        List<InsertionData> bestData = calculateInsertionCosts(insertionContext,1,actList,newRoute,additionalICostsAtRouteLevel, newVehicleDepartureTime);
+        if(bestData.isEmpty()) return InsertionData.createEmptyInsertionData();
+        else{
+            InsertionData best = InsertionData.createEmptyInsertionData();
+            for(InsertionData iD : bestData){
+                if(iD.getInsertionCost() < best.getInsertionCost()) best = iD;
+            }
+            return best;
+        }
+    }
+
+    private List<InsertionData> calculateInsertionCosts(JobInsertionContext insertionContext, int index, List<JobActivity> actList, List<TourActivity> newRoute, double additionalCosts, double departureTime) {
+        List<InsertionData> iData = new ArrayList<>();
+        double departureTimeAtPrevAct = departureTime;
+        TourActivity prevAct = newRoute.get(index-1);
+        for(int i=index;i<newRoute.size();i++) {
+            JobActivity jobActivity = actList.get(0);
+            if(jobActivity.getTimeWindows().isEmpty()) throw new IllegalStateException("at least a single time window must be set");
+            for(TimeWindow timeWindow : jobActivity.getTimeWindows()) {
+                JobActivity copiedJobActivity = (JobActivity) jobActivity.duplicate();
+                copiedJobActivity.setTheoreticalEarliestOperationStartTime(timeWindow.getStart());
+                copiedJobActivity.setTheoreticalLatestOperationStartTime(timeWindow.getEnd());
+                ActivityContext activityContext = new ActivityContext();
+                activityContext.setInsertionIndex(i);
+                insertionContext.setActivityContext(activityContext);
+                HardActivityConstraint.ConstraintsStatus constraintStatus = hardActivityLevelConstraint.fulfilled(insertionContext, prevAct, copiedJobActivity, newRoute.get(i), departureTimeAtPrevAct);
+                if(constraintStatus.equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED)){
+                    continue;
+                }
+                else if(constraintStatus.equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED_BREAK)){
+                    return iData;
+                }
+                double miscCosts = softActivityConstraint.getCosts(insertionContext, prevAct, copiedJobActivity, newRoute.get(i), departureTimeAtPrevAct);
+                double c = calculate(insertionContext, prevAct, copiedJobActivity, newRoute.get(i), departureTimeAtPrevAct);
+                List<TourActivity> modifiedRoute = new ArrayList<>(newRoute);
+                modifiedRoute.add(i, copiedJobActivity);
+                double totalCosts = additionalCosts + c + miscCosts;
+                if (actList.size() == 1) {
+                    InsertionData iD = new InsertionData(totalCosts,insertionContext.getNewDepTime(),insertionContext.getNewVehicle(),insertionContext.getNewDriver());
+                    iD.getEvents().add(new SwitchVehicle(insertionContext.getRoute(),insertionContext.getNewVehicle(),insertionContext.getNewDepTime()));
+                    iD.getEvents().addAll(getInsertActivityEvents(insertionContext,modifiedRoute));
+                    iData.add(iD);
+
+                } else {
+                    double departureTimeFromJobActivity = getDeparture(prevAct,copiedJobActivity,departureTimeAtPrevAct,insertionContext.getNewDriver(),insertionContext.getNewVehicle());
+                    List<InsertionData> insertions = calculateInsertionCosts(insertionContext, i + 1, actList.subList(1, actList.size()), modifiedRoute, totalCosts, departureTimeFromJobActivity);
+                    iData.addAll(insertions);
+                }
+            }
+            departureTimeAtPrevAct = getDeparture(prevAct,newRoute.get(i),departureTimeAtPrevAct,insertionContext.getNewDriver(),insertionContext.getNewVehicle());
+            prevAct = newRoute.get(i);
+        }
+        return iData;
+    }
+
+    private double getDeparture(TourActivity prevAct, TourActivity activity, double departureTimeAtPrevAct,Driver driver, Vehicle vehicle) {
+        double actArrTime = departureTimeAtPrevAct + transportCosts.getTransportTime(prevAct.getLocation(),activity.getLocation(),departureTimeAtPrevAct,driver,vehicle);
+        double actStart = Math.max(actArrTime,activity.getTheoreticalEarliestOperationStartTime());
+        return actStart + activityCosts.getActivityDuration(activity,actArrTime,driver,vehicle);
+    }
+
+    private Collection<? extends Event> getInsertActivityEvents(JobInsertionContext insertionContext, List<TourActivity> modifiedRoute) {
+        List<InsertActivity> insertActivities = new ArrayList<>();
+        for(int i=insertionContext.getAssociatedActivities().size()-1;i>=0;i--){
+            TourActivity activity = insertionContext.getAssociatedActivities().get(i);
+            int activityIndexInModifiedRoute = modifiedRoute.indexOf(activity);
+            TourActivity activityInModifiedRoute = modifiedRoute.get(activityIndexInModifiedRoute);
+            insertActivities.add(new InsertActivity(insertionContext.getRoute(),insertionContext.getNewVehicle(),
+                activityInModifiedRoute, activityIndexInModifiedRoute -i-1));
+        }
+        return insertActivities;
+    }
+
+    private double calculate(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double departureTimeAtPrevAct) {
+        return activityInsertionCostsCalculator.getCosts(iFacts, prevAct, nextAct, newAct, departureTimeAtPrevAct);
+
+    }
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionBuilder.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionBuilder.java
index 99981409d..fbed7073a 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionBuilder.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionBuilder.java
@@ -89,6 +89,7 @@ public InsertionBuilder setInsertionStrategy(Strategy strategy) {
         return this;
     }
 
+    @Deprecated
     public InsertionBuilder setRouteLevel(int forwardLooking, int memory) {
         local = false;
         this.forwaredLooking = forwardLooking;
@@ -96,6 +97,7 @@ public InsertionBuilder setRouteLevel(int forwardLooking, int memory) {
         return this;
     }
 
+    @Deprecated
     public InsertionBuilder setRouteLevel(int forwardLooking, int memory, boolean addDefaultMarginalCostCalculation) {
         local = false;
         this.forwaredLooking = forwardLooking;
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobCalculatorSwitcher.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobCalculatorSwitcher.java
index 2878c9c02..c7c7f12a2 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobCalculatorSwitcher.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobCalculatorSwitcher.java
@@ -36,7 +36,7 @@ void put(Class<? extends Job> jobClass, JobInsertionCostsCalculator jic) {
 
     public InsertionData getInsertionData(VehicleRoute currentRoute, Job jobToInsert, Vehicle newVehicle, double newVehicleDepartureTime, Driver newDriver, double bestKnownScore) {
         JobInsertionCostsCalculator jic = calcMap.get(jobToInsert.getClass());
-        if (jic == null) throw new IllegalStateException("cannot find calculator for " + jobToInsert.getClass());
+        if (jic == null) jic = calcMap.get(Job.class);
         return jic.getInsertionData(currentRoute, jobToInsert, newVehicle, newVehicleDepartureTime, newDriver, bestKnownScore);
     }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java
index 99e233659..2565a4189 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java
@@ -174,6 +174,7 @@ public JobInsertionCostsCalculatorBuilder setActivityInsertionCostsCalculator(Ac
      * @param memory
      * @param addDefaultMarginalCostCalc
      */
+    @Deprecated
     public JobInsertionCostsCalculatorBuilder setRouteLevel(int forwardLooking, int memory, boolean addDefaultMarginalCostCalc) {
         local = false;
         this.forwardLooking = forwardLooking;
@@ -193,6 +194,7 @@ public JobInsertionCostsCalculatorBuilder considerFixedCosts(double weightOfFixe
         return this;
     }
 
+    @Deprecated
     public JobInsertionCostsCalculatorBuilder experimentalTimeScheduler(double timeSlice, int neighbors) {
         timeScheduling = true;
         this.timeSlice = timeSlice;
@@ -278,40 +280,28 @@ private CalculatorPlusListeners createStandardLocal(final VehicleRoutingProblem
             actInsertionCalc = new LocalActivityInsertionCostsCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(), statesManager);
             configLocal = new ConfigureLocalActivityInsertionCalculator(vrp, (LocalActivityInsertionCostsCalculator) actInsertionCalc);
         } else if (activityInsertionCostCalculator == null && !addDefaultCostCalc) {
-            actInsertionCalc = new ActivityInsertionCostsCalculator() {
-
-                @Override
-                public double getCosts(JobInsertionContext iContext, TourActivity prevAct, TourActivity nextAct, TourActivity newAct,
-                        double depTimeAtPrevAct) {
-                    return 0.;
-                }
-
-            };
+            actInsertionCalc = (iContext, prevAct, nextAct, newAct, depTimeAtPrevAct) -> 0.;
         } else {
             actInsertionCalc = activityInsertionCostCalculator;
         }
 
-        JobActivityFactory activityFactory = new JobActivityFactory() {
+        JobActivityFactory activityFactory = job -> vrp.copyAndGetActivities(job);
 
-            @Override
-            public List<JobActivity> createActivities(Job job) {
-                return vrp.copyAndGetActivities(job);
-            }
+//        ShipmentInsertionCalculator shipmentInsertion = new ShipmentInsertionCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(),actInsertionCalc, constraintManager);
+//        shipmentInsertion.setJobActivityFactory(activityFactory);
+//        ServiceInsertionCalculator serviceInsertion = new ServiceInsertionCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(), actInsertionCalc, constraintManager);
+//        serviceInsertion.setJobActivityFactory(activityFactory);
 
-        };
-        ShipmentInsertionCalculator shipmentInsertion = new ShipmentInsertionCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(),actInsertionCalc, constraintManager);
-        shipmentInsertion.setJobActivityFactory(activityFactory);
-        ServiceInsertionCalculator serviceInsertion = new ServiceInsertionCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(), actInsertionCalc, constraintManager);
-        serviceInsertion.setJobActivityFactory(activityFactory);
+        GeneralJobInsertionCalculator generalJobInsertionCalculator = new GeneralJobInsertionCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(),actInsertionCalc, constraintManager);
 
         BreakInsertionCalculator breakInsertionCalculator = new BreakInsertionCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(), actInsertionCalc, constraintManager);
         breakInsertionCalculator.setJobActivityFactory(activityFactory);
 
         JobCalculatorSwitcher switcher = new JobCalculatorSwitcher();
-        switcher.put(Shipment.class, shipmentInsertion);
-        switcher.put(Service.class, serviceInsertion);
-        switcher.put(Pickup.class, serviceInsertion);
-        switcher.put(Delivery.class, serviceInsertion);
+        switcher.put(Job.class, generalJobInsertionCalculator);
+//        switcher.put(Service.class, serviceInsertion);
+//        switcher.put(Pickup.class, serviceInsertion);
+//        switcher.put(Delivery.class, serviceInsertion);
         switcher.put(Break.class, breakInsertionCalculator);
 
         CalculatorPlusListeners calculatorPlusListeners = new CalculatorPlusListeners(switcher);
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionCalculator.java
index c3c444caf..7e8c015f4 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionCalculator.java
@@ -170,12 +170,11 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
         if(insertionIndex == InsertionData.NO_INDEX) {
             return InsertionData.createEmptyInsertionData();
         }
-        InsertionData insertionData = new InsertionData(bestCost, InsertionData.NO_INDEX, insertionIndex, newVehicle, newDriver);
+        InsertionData insertionData = new InsertionData(bestCost, newVehicleDepartureTime, newVehicle, newDriver);
         deliveryAct2Insert.setTheoreticalEarliestOperationStartTime(bestTimeWindow.getStart());
         deliveryAct2Insert.setTheoreticalLatestOperationStartTime(bestTimeWindow.getEnd());
         insertionData.getEvents().add(new InsertActivity(currentRoute, newVehicle, deliveryAct2Insert, insertionIndex));
         insertionData.getEvents().add(new SwitchVehicle(currentRoute,newVehicle,newVehicleDepartureTime));
-        insertionData.setVehicleDepartureTime(newVehicleDepartureTime);
         return insertionData;
     }
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobExample.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobExample.java
index c871b4225..bb036313d 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobExample.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobExample.java
@@ -32,9 +32,11 @@
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
 import com.graphhopper.jsprit.core.reporting.SolutionPrinter;
 import com.graphhopper.jsprit.core.util.Solutions;
+import org.junit.Assert;
 import org.junit.Test;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
@@ -105,7 +107,7 @@ protected void createActivities(JobBuilder<? extends AbstractJob, ?> jobBuilder)
             Builder builder = (Builder) jobBuilder;
             JobActivityList list = new SequentialJobActivityList(this);
             for(Location loc : builder.getLocs()){
-                list.addActivity(new PickupActivityNEW(this,"pick",loc,0,Capacity.EMPTY,Collections.emptyList()));
+                list.addActivity(new PickupActivityNEW(this,"pick",loc,0,Capacity.EMPTY, Arrays.asList(TimeWindow.ETERNITY)));
             }
             setActivities(list);
         }
@@ -122,5 +124,6 @@ public void test(){
         VehicleRoutingAlgorithm vra = Jsprit.createAlgorithm(vrp);
         VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
         SolutionPrinter.print(vrp,solution, SolutionPrinter.Print.VERBOSE);
+        Assert.assertTrue(solution.getUnassignedJobs().isEmpty());
     }
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobWithMultipleActivitiesExample.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobWithMultipleActivitiesExample.java
new file mode 100644
index 000000000..9429cc49a
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobWithMultipleActivitiesExample.java
@@ -0,0 +1,138 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.graphhopper.jsprit.core.algorithm;
+
+import com.graphhopper.jsprit.core.algorithm.box.Jsprit;
+import com.graphhopper.jsprit.core.problem.Capacity;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.job.AbstractJob;
+import com.graphhopper.jsprit.core.problem.job.JobActivityList;
+import com.graphhopper.jsprit.core.problem.job.SequentialJobActivityList;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivityNEW;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
+import com.graphhopper.jsprit.core.reporting.SolutionPrinter;
+import com.graphhopper.jsprit.core.util.Solutions;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Created by schroeder on 11/11/16.
+ */
+public class FirstCustomJobWithMultipleActivitiesExample {
+
+    static class CustomJob extends AbstractJob {
+
+        public static abstract class BuilderBase<T extends CustomJob, B extends BuilderBase<T, B>>
+            extends JobBuilder<T, B> {
+
+            List<Location> locs = new ArrayList<>();
+
+            List<Capacity> cap = new ArrayList<>();
+
+            public BuilderBase(String id) {
+                super(id);
+            }
+
+            public BuilderBase<T,B> addPickup(Location location, Capacity capacity){
+                locs.add(location);
+                cap.add(capacity);
+                return this;
+            }
+
+            public List<Location> getLocs() {
+                return locs;
+            }
+
+            public List<Capacity> getCaps() { return cap; }
+
+            protected void validate(){
+
+            }
+        }
+
+        public static final class Builder extends BuilderBase<CustomJob, Builder> {
+
+            public static Builder newInstance(String id) {
+                return new Builder(id);
+            }
+
+            public Builder(String id) {
+                super(id);
+            }
+
+            @Override
+            protected CustomJob createInstance() {
+                return new CustomJob(this);
+            }
+
+        }
+        /**
+         * Builder based constructor.
+         *
+         * @param builder The builder instance.
+         * @see JobBuilder
+         */
+        protected CustomJob(JobBuilder<?, ?> builder) {
+            super(builder);
+
+        }
+
+        @Override
+        public Capacity getSize() {
+            return Capacity.EMPTY;
+        }
+
+        @Override
+        protected void createActivities(JobBuilder<? extends AbstractJob, ?> jobBuilder) {
+            Builder builder = (Builder) jobBuilder;
+            JobActivityList list = new SequentialJobActivityList(this);
+            for(int i=0;i<builder.getLocs().size();i++){
+                list.addActivity(new PickupActivityNEW(this,"pick",builder.getLocs().get(i),0,builder.getCaps().get(i), Arrays.asList(TimeWindow.ETERNITY)));
+            }
+            setActivities(list);
+        }
+    }
+
+
+
+    @Test
+    public void test(){
+        CustomJob cj = CustomJob.Builder.newInstance("job")
+            .addPickup(Location.newInstance(10,0),Capacity.Builder.newInstance().addDimension(0,1).build())
+            .addPickup(Location.newInstance(5,0),Capacity.Builder.newInstance().addDimension(0,2).build())
+            .addPickup(Location.newInstance(20,0),Capacity.Builder.newInstance().addDimension(0,1).build())
+            .build();
+        Vehicle v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0,0)).build();
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
+            .addJob(cj).addVehicle(v).build();
+        VehicleRoutingAlgorithm vra = Jsprit.createAlgorithm(vrp);
+        vra.setMaxIterations(0);
+        VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
+        SolutionPrinter.print(vrp,solution, SolutionPrinter.Print.VERBOSE);
+        Assert.assertTrue(solution.getUnassignedJobs().isEmpty());
+    }
+}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/Solomon_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/Solomon_IT.java
index dca532474..9f7b155bb 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/Solomon_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/Solomon_IT.java
@@ -29,6 +29,7 @@
 import com.graphhopper.jsprit.core.util.SolomonReader;
 import com.graphhopper.jsprit.core.util.Solutions;
 
+
 /**
  * Created by schroeder on 23.07.14.
  */
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndLoadConstraintsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndLoadConstraintsTest.java
new file mode 100644
index 000000000..96964c2ef
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndLoadConstraintsTest.java
@@ -0,0 +1,142 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.jsprit.core.algorithm.recreate;
+
+import com.graphhopper.jsprit.core.algorithm.state.StateManager;
+import com.graphhopper.jsprit.core.problem.CopyJobActivityFactory;
+import com.graphhopper.jsprit.core.problem.JobActivityFactory;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
+import com.graphhopper.jsprit.core.problem.constraint.HardActivityConstraint;
+import com.graphhopper.jsprit.core.problem.constraint.HardRouteConstraint;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
+import com.graphhopper.jsprit.core.problem.driver.Driver;
+import com.graphhopper.jsprit.core.problem.driver.DriverImpl;
+import com.graphhopper.jsprit.core.problem.job.Delivery;
+import com.graphhopper.jsprit.core.problem.job.Pickup;
+import com.graphhopper.jsprit.core.problem.job.Shipment;
+import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.state.RouteAndActivityStateGetter;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
+import com.graphhopper.jsprit.core.util.CostFactory;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.Arrays;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+
+
+public class GeneralJobInsertionAndLoadConstraintsTest {
+
+    VehicleRoutingTransportCosts routingCosts;
+
+    VehicleRoutingActivityCosts activityCosts = new VehicleRoutingActivityCosts() {
+
+        @Override
+        public double getActivityCost(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
+            return 0;
+        }
+
+        @Override
+        public double getActivityDuration(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
+            return tourAct.getOperationTime();
+        }
+
+    };
+
+    HardActivityConstraint hardActivityLevelConstraint = new HardActivityConstraint() {
+
+        @Override
+        public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime) {
+            return ConstraintsStatus.FULFILLED;
+        }
+    };
+
+    HardRouteConstraint hardRouteLevelConstraint = new HardRouteConstraint() {
+
+        @Override
+        public boolean fulfilled(JobInsertionContext insertionContext) {
+            return true;
+        }
+
+    };
+
+    ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
+
+    GeneralJobInsertionCalculator insertionCalculator;
+
+    VehicleRoutingProblem vehicleRoutingProblem;
+
+    Vehicle vehicle;
+
+    @Before
+    public void doBefore() {
+        routingCosts = CostFactory.createManhattanCosts();
+        VehicleType type = VehicleTypeImpl.Builder.newInstance("t").addCapacityDimension(0, 2).setCostPerDistance(1).build();
+        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("0,0")).setType(type).build();
+        activityInsertionCostsCalculator = new LocalActivityInsertionCostsCalculator(routingCosts, activityCosts, mock(StateManager.class));
+        createInsertionCalculator(hardRouteLevelConstraint);
+        vehicleRoutingProblem = mock(VehicleRoutingProblem.class);
+    }
+
+    private void createInsertionCalculator(HardRouteConstraint hardRouteLevelConstraint) {
+        ConstraintManager constraintManager = new ConstraintManager(mock(VehicleRoutingProblem.class), mock(RouteAndActivityStateGetter.class));
+        constraintManager.addConstraint(hardRouteLevelConstraint);
+        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+    }
+
+    @Test
+    public void whenInsertingServiceWhileNoCapIsAvailable_itMustReturnTheCorrectInsertionIndex() {
+        Delivery delivery = new Delivery.Builder("del").addSizeDimension(0, 41).setLocation(Location.newInstance("10,10")).build();
+        Pickup pickup = new Pickup.Builder("pick").addSizeDimension(0, 15).setLocation(Location.newInstance("0,10")).build();
+
+        VehicleType type = VehicleTypeImpl.Builder.newInstance("t").addCapacityDimension(0, 50).setCostPerDistance(1).build();
+        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("0,0")).setType(type).build();
+
+        final VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(delivery).addJob(pickup).addVehicle(vehicle).build();
+
+        VehicleRoute route = VehicleRoute.emptyRoute();
+        route.setVehicleAndDepartureTime(vehicle, 0.0);
+
+        route.getTourActivities().addActivity(0,vrp.copyAndGetActivities(delivery).get(0));
+
+        StateManager stateManager = new StateManager(vrp);
+        stateManager.updateLoadStates();
+
+        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
+        constraintManager.addLoadConstraint();
+        stateManager.informInsertionStarts(Arrays.asList(route), null);
+
+        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+
+        InsertionData iData = insertionCalculator.getInsertionData(route, pickup, vehicle, 0, DriverImpl.noDriver(), Double.MAX_VALUE);
+        List<InsertActivity> insertActivities = iData.getUnmodifiableEventsByType(InsertActivity.class);
+        assertEquals(1, insertActivities.get(0).getIndex());
+    }
+
+}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndTimeWindowConstraintsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndTimeWindowConstraintsTest.java
new file mode 100644
index 000000000..304827a4c
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndTimeWindowConstraintsTest.java
@@ -0,0 +1,143 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.jsprit.core.algorithm.recreate;
+
+import com.graphhopper.jsprit.core.algorithm.state.StateManager;
+import com.graphhopper.jsprit.core.algorithm.state.UpdateVehicleDependentPracticalTimeWindows;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
+import com.graphhopper.jsprit.core.problem.constraint.HardActivityConstraint;
+import com.graphhopper.jsprit.core.problem.constraint.HardRouteConstraint;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
+import com.graphhopper.jsprit.core.problem.driver.Driver;
+import com.graphhopper.jsprit.core.problem.driver.DriverImpl;
+import com.graphhopper.jsprit.core.problem.job.Delivery;
+import com.graphhopper.jsprit.core.problem.job.Pickup;
+import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.state.RouteAndActivityStateGetter;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
+import com.graphhopper.jsprit.core.util.CostFactory;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.Arrays;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+
+
+public class GeneralJobInsertionAndTimeWindowConstraintsTest {
+
+    VehicleRoutingTransportCosts routingCosts;
+
+    VehicleRoutingActivityCosts activityCosts = new VehicleRoutingActivityCosts() {
+
+        @Override
+        public double getActivityCost(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
+            return 0;
+        }
+
+        @Override
+        public double getActivityDuration(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
+            return tourAct.getOperationTime();
+        }
+
+    };
+
+    HardActivityConstraint hardActivityLevelConstraint = new HardActivityConstraint() {
+
+        @Override
+        public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime) {
+            return ConstraintsStatus.FULFILLED;
+        }
+    };
+
+    HardRouteConstraint hardRouteLevelConstraint = new HardRouteConstraint() {
+
+        @Override
+        public boolean fulfilled(JobInsertionContext insertionContext) {
+            return true;
+        }
+
+    };
+
+    ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
+
+    GeneralJobInsertionCalculator insertionCalculator;
+
+    VehicleRoutingProblem vehicleRoutingProblem;
+
+    Vehicle vehicle;
+
+    @Before
+    public void doBefore() {
+        routingCosts = CostFactory.createManhattanCosts();
+        VehicleType type = VehicleTypeImpl.Builder.newInstance("t").addCapacityDimension(0, 2).setCostPerDistance(1).build();
+        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("0,0")).setType(type).build();
+        activityInsertionCostsCalculator = new LocalActivityInsertionCostsCalculator(routingCosts, activityCosts, mock(StateManager.class));
+        createInsertionCalculator(hardRouteLevelConstraint);
+        vehicleRoutingProblem = mock(VehicleRoutingProblem.class);
+    }
+
+    private void createInsertionCalculator(HardRouteConstraint hardRouteLevelConstraint) {
+        ConstraintManager constraintManager = new ConstraintManager(mock(VehicleRoutingProblem.class), mock(RouteAndActivityStateGetter.class));
+        constraintManager.addConstraint(hardRouteLevelConstraint);
+        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+    }
+
+    @Test
+    public void whenInsertingServiceWithTW_itMustReturnTheCorrectInsertionIndex() {
+        Delivery delivery = new Delivery.Builder("del").addTimeWindow(30,40).setLocation(Location.newInstance("10,10")).build();
+        Pickup pickup = new Pickup.Builder("pick").addTimeWindow(60,80).setLocation(Location.newInstance("0,10")).build();
+
+        VehicleType type = VehicleTypeImpl.Builder.newInstance("t").setCostPerDistance(1).build();
+        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setLatestArrival(40).setStartLocation(Location.newInstance("0,0")).setType(type).build();
+
+        final VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
+            .setRoutingCost(routingCosts).setActivityCosts(activityCosts)
+            .addJob(delivery).addJob(pickup).addVehicle(vehicle).build();
+
+        VehicleRoute route = VehicleRoute.emptyRoute();
+        route.setVehicleAndDepartureTime(vehicle, 0.0);
+
+        route.getTourActivities().addActivity(0,vrp.copyAndGetActivities(delivery).get(0));
+
+        StateManager stateManager = new StateManager(vrp);
+        stateManager.addStateUpdater(new UpdateVehicleDependentPracticalTimeWindows(stateManager,routingCosts,activityCosts));
+
+        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
+        constraintManager.addTimeWindowConstraint();
+        stateManager.informInsertionStarts(Arrays.asList(route), null);
+
+        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+
+        InsertionData iData = insertionCalculator.getInsertionData(route, pickup, vehicle, 0, DriverImpl.noDriver(), Double.MAX_VALUE);
+        Assert.assertTrue(iData instanceof InsertionData.NoInsertionFound);
+
+    }
+
+}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesAndLoadConstraintsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesAndLoadConstraintsTest.java
new file mode 100644
index 000000000..be4d94ccd
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesAndLoadConstraintsTest.java
@@ -0,0 +1,135 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.jsprit.core.algorithm.recreate;
+
+import com.graphhopper.jsprit.core.algorithm.state.StateManager;
+import com.graphhopper.jsprit.core.problem.CopyJobActivityFactory;
+import com.graphhopper.jsprit.core.problem.JobActivityFactory;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
+import com.graphhopper.jsprit.core.problem.constraint.HardActivityConstraint;
+import com.graphhopper.jsprit.core.problem.constraint.HardRouteConstraint;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
+import com.graphhopper.jsprit.core.problem.driver.Driver;
+import com.graphhopper.jsprit.core.problem.driver.DriverImpl;
+import com.graphhopper.jsprit.core.problem.job.Delivery;
+import com.graphhopper.jsprit.core.problem.job.Pickup;
+import com.graphhopper.jsprit.core.problem.job.Shipment;
+import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.state.RouteAndActivityStateGetter;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
+import com.graphhopper.jsprit.core.util.CostFactory;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.Arrays;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+
+
+public class GeneralJobInsertionWithServicesAndLoadConstraintsTest {
+
+    VehicleRoutingTransportCosts routingCosts;
+
+    VehicleRoutingActivityCosts activityCosts = new VehicleRoutingActivityCosts() {
+
+        @Override
+        public double getActivityCost(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
+            return 0;
+        }
+
+        @Override
+        public double getActivityDuration(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
+            return tourAct.getOperationTime();
+        }
+
+    };
+
+    HardActivityConstraint hardActivityLevelConstraint = new HardActivityConstraint() {
+
+        @Override
+        public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime) {
+            return ConstraintsStatus.FULFILLED;
+        }
+    };
+
+    HardRouteConstraint hardRouteLevelConstraint = new HardRouteConstraint() {
+
+        @Override
+        public boolean fulfilled(JobInsertionContext insertionContext) {
+            return true;
+        }
+
+    };
+
+    ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
+
+    GeneralJobInsertionCalculator insertionCalculator;
+
+    VehicleRoutingProblem vehicleRoutingProblem;
+
+    Vehicle vehicle;
+
+    @Before
+    public void doBefore() {
+        routingCosts = CostFactory.createManhattanCosts();
+        VehicleType type = VehicleTypeImpl.Builder.newInstance("t").addCapacityDimension(0, 2).setCostPerDistance(1).build();
+        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("0,0")).setType(type).build();
+        activityInsertionCostsCalculator = new LocalActivityInsertionCostsCalculator(routingCosts, activityCosts, mock(StateManager.class));
+        vehicleRoutingProblem = mock(VehicleRoutingProblem.class);
+    }
+
+    @Test
+    public void whenInsertingServiceWhileNoCapIsAvailable_itMustReturnTheCorrectInsertionIndex() {
+        Delivery delivery = new Delivery.Builder("del").addSizeDimension(0, 41).setLocation(Location.newInstance("10,10")).build();
+        Pickup pickup = new Pickup.Builder("pick").addSizeDimension(0, 15).setLocation(Location.newInstance("0,10")).build();
+
+        VehicleType type = VehicleTypeImpl.Builder.newInstance("t").addCapacityDimension(0, 50).setCostPerDistance(1).build();
+        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("0,0")).setType(type).build();
+
+        final VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(delivery).addJob(pickup).addVehicle(vehicle).build();
+
+        VehicleRoute route = VehicleRoute.emptyRoute();
+        route.setVehicleAndDepartureTime(vehicle, 0.0);
+
+        route.getTourActivities().addActivity(0,vrp.copyAndGetActivities(delivery).get(0));
+
+        StateManager stateManager = new StateManager(vrp);
+        stateManager.updateLoadStates();
+
+        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
+        constraintManager.addLoadConstraint();
+        stateManager.informInsertionStarts(Arrays.asList(route), null);
+
+        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+
+        InsertionData iData = insertionCalculator.getInsertionData(route, pickup, vehicle, 0, DriverImpl.noDriver(), Double.MAX_VALUE);
+        List<InsertActivity> insertActivities = iData.getUnmodifiableEventsByType(InsertActivity.class);
+        assertEquals(1, insertActivities.get(0).getIndex());
+    }
+
+}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesTest.java
new file mode 100644
index 000000000..cfdd240be
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesTest.java
@@ -0,0 +1,249 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.jsprit.core.algorithm.recreate;
+
+import com.graphhopper.jsprit.core.algorithm.state.StateManager;
+import com.graphhopper.jsprit.core.distance.EuclideanDistanceCalculator;
+import com.graphhopper.jsprit.core.distance.ManhattanDistanceCalculator;
+import com.graphhopper.jsprit.core.problem.CopyJobActivityFactory;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
+import com.graphhopper.jsprit.core.problem.cost.AbstractForwardVehicleRoutingTransportCosts;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
+import com.graphhopper.jsprit.core.problem.driver.Driver;
+import com.graphhopper.jsprit.core.problem.driver.DriverImpl;
+import com.graphhopper.jsprit.core.problem.job.Job;
+import com.graphhopper.jsprit.core.problem.job.Service;
+import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
+import com.graphhopper.jsprit.core.util.Coordinate;
+import com.graphhopper.jsprit.core.util.Locations;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.*;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+
+
+public class GeneralJobInsertionWithServicesTest {
+
+    GeneralJobInsertionCalculator jobInsertion;
+
+    VehicleRoutingTransportCosts costs;
+
+    VehicleImpl vehicle;
+
+    VehicleImpl newVehicle;
+
+    private Service first;
+
+    private Service third;
+
+    private Service second;
+
+    private StateManager states;
+
+    private DriverImpl.NoDriver driver;
+
+    private VehicleRoutingProblem vrp;
+
+    @Before
+    public void setup() {
+
+        VehicleType t1 = VehicleTypeImpl.Builder.newInstance("t1").addCapacityDimension(0, 1000).setCostPerDistance(1.0).build();
+        vehicle = VehicleImpl.Builder.newInstance("vehicle").setLatestArrival(100.0).setStartLocation(Location.newInstance("0,0")).setType(t1).build();
+
+        VehicleType t2 = VehicleTypeImpl.Builder.newInstance("t2").addCapacityDimension(0, 1000).setCostPerDistance(2.0).build();
+        newVehicle = VehicleImpl.Builder.newInstance("newVehicle").setLatestArrival(100.0).setStartLocation(Location.newInstance("0,0")).setType(t2).build();
+
+        driver = DriverImpl.noDriver();
+
+        final Locations locations = id -> {
+            String[] splitted = id.split(",");
+            return Coordinate.newInstance(Double.parseDouble(splitted[0]),
+                            Double.parseDouble(splitted[1]));
+        };
+        costs = new AbstractForwardVehicleRoutingTransportCosts() {
+
+            @Override
+            public double getTransportTime(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
+                return ManhattanDistanceCalculator.getInstance().calculateDistance(
+                                locations.getCoord(from.getId()), locations.getCoord(to.getId()));
+            }
+
+            @Override
+            public double getTransportCost(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
+                return vehicle.getType().getVehicleCostParams().perDistanceUnit
+                                * ManhattanDistanceCalculator.getInstance().calculateDistance(
+                                                locations.getCoord(from.getId()),
+                                                locations.getCoord(to.getId()));
+            }
+        };
+
+
+        first = new Service.Builder("1").addSizeDimension(0, 0).setLocation(Location.newInstance("0,10")).setTimeWindow(TimeWindow.newInstance(0.0, 100.0)).build();
+        second = new Service.Builder("2").addSizeDimension(0, 0).setLocation(Location.newInstance("10,10")).setTimeWindow(TimeWindow.newInstance(0.0, 100.0)).build();
+        third = new Service.Builder("3").addSizeDimension(0, 0).setLocation(Location.newInstance("10,0")).setTimeWindow(TimeWindow.newInstance(0.0, 100.0)).build();
+
+        Collection<Job> jobs = new ArrayList<>();
+        jobs.add(first);
+        jobs.add(third);
+        jobs.add(second);
+
+        vrp = VehicleRoutingProblem.Builder.newInstance().addAllJobs(jobs)
+                        .addVehicle(vehicle).setRoutingCost(costs).build();
+
+        states = new StateManager(vrp);
+        states.updateLoadStates();
+        states.updateTimeWindowStates();
+
+
+        ConstraintManager cManager = new ConstraintManager(vrp, states);
+        cManager.addLoadConstraint();
+        cManager.addTimeWindowConstraint();
+
+        VehicleRoutingActivityCosts actCosts = mock(VehicleRoutingActivityCosts.class);
+
+        jobInsertion = new GeneralJobInsertionCalculator(costs, vrp.getActivityCosts(), new LocalActivityInsertionCostsCalculator(costs, actCosts, states), cManager);
+        jobInsertion.setJobActivityFactory(new CopyJobActivityFactory());
+    }
+
+    @Test
+    public void whenInsertingTheFirstJobInAnEmptyTourWithVehicle_itCalculatesMarginalCostChanges() {
+        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).build();
+        states.informInsertionStarts(Arrays.asList(route), null);
+
+        InsertionData iData = jobInsertion.getInsertionData(route, first, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
+        assertEquals(20.0, iData.getInsertionCost(), 0.2);
+        assertEquals(0, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
+    }
+
+    @Test
+    public void whenInsertingTheSecondJobInAnNonEmptyTourWithVehicle_itCalculatesMarginalCostChanges() {
+        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).build();
+        states.informInsertionStarts(Arrays.asList(route), null);
+
+        InsertionData iData = jobInsertion.getInsertionData(route, third, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
+        assertEquals(20.0, iData.getInsertionCost(), 0.2);
+        assertEquals(0, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
+    }
+
+    @Test
+    public void whenInsertingThirdJobWithVehicle_itCalculatesMarginalCostChanges() {
+        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).addService(third).build();
+        states.informInsertionStarts(Arrays.asList(route), null);
+
+        InsertionData iData = jobInsertion.getInsertionData(route, second, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
+        assertEquals(0.0, iData.getInsertionCost(), 0.2);
+        assertEquals(1, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
+    }
+
+    @Test
+    public void whenInsertingThirdJobWithNewVehicle_itCalculatesMarginalCostChanges() {
+        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).addService(third).build();
+        states.informInsertionStarts(Arrays.asList(route), null);
+
+        InsertionData iData = jobInsertion.getInsertionData(route, second, newVehicle, newVehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
+        assertEquals(40.0, iData.getInsertionCost(), 0.2);
+        assertEquals(1, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
+    }
+
+    @Test
+    public void whenInsertingASecondJobWithAVehicle_itCalculatesLocalMarginalCostChanges() {
+        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).addService(second).build();
+        states.informInsertionStarts(Arrays.asList(route), null);
+
+        InsertionData iData = jobInsertion.getInsertionData(route, third, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
+        assertEquals(0.0, iData.getInsertionCost(), 0.2);
+        assertEquals(2, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
+    }
+
+    @Test
+    public void whenInsertingASecondJobWithANewVehicle_itCalculatesLocalMarginalCostChanges() {
+
+        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).addService(second).build();
+
+        states.informInsertionStarts(Arrays.asList(route), null);
+
+        InsertionData iData = jobInsertion.getInsertionData(route, third, newVehicle, newVehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
+        assertEquals(50.0, iData.getInsertionCost(), 0.2);
+        assertEquals(2, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
+    }
+
+    @Test
+    public void whenInsertingJobAndCurrRouteIsEmpty_accessEggressCalcShouldReturnZero() {
+        VehicleRoute route = VehicleRoute.Builder.newInstance(VehicleImpl.createNoVehicle(), DriverImpl.noDriver()).build();
+        AdditionalAccessEgressCalculator accessEgressCalc = new AdditionalAccessEgressCalculator(costs);
+        Job job = new Service.Builder("1").addSizeDimension(0, 0).setLocation(Location.newInstance("1")).setTimeWindow(TimeWindow.newInstance(0.0, 100.0)).build();
+        JobInsertionContext iContex = new JobInsertionContext(route, job, newVehicle, mock(Driver.class), 0.0);
+        assertEquals(0.0, accessEgressCalc.getCosts(iContex), 0.01);
+    }
+
+    @Test
+    public void whenInsertingJobAndCurrRouteAndVehicleHaveTheSameLocation_accessEggressCalcShouldReturnZero() {
+        VehicleRoute route = VehicleRoute.Builder.newInstance(newVehicle, DriverImpl.noDriver())
+                        .addService(first)
+                        .build();
+
+        AdditionalAccessEgressCalculator accessEgressCalc = new AdditionalAccessEgressCalculator(costs);
+        JobInsertionContext iContex = new JobInsertionContext(route, first, newVehicle, mock(Driver.class), 0.0);
+        assertEquals(0.0, accessEgressCalc.getCosts(iContex), 0.01);
+    }
+
+    @Test
+    public void whenInsertingJobAndCurrRouteAndNewVehicleHaveDifferentLocations_accessEggressCostsMustBeCorrect() {
+        final Map<String, Coordinate> coords = new HashMap<String, Coordinate>();
+        coords.put("oldV", Coordinate.newInstance(1, 0));
+        coords.put("newV", Coordinate.newInstance(5, 0));
+        coords.put("service", Coordinate.newInstance(0, 0));
+
+        AbstractForwardVehicleRoutingTransportCosts routingCosts = new AbstractForwardVehicleRoutingTransportCosts() {
+
+            @Override
+            public double getTransportTime(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
+                return getTransportCost(from, to, departureTime, driver, vehicle);
+            }
+
+            @Override
+            public double getTransportCost(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
+                return EuclideanDistanceCalculator.getInstance().calculateDistance(coords.get(from.getId()), coords.get(to.getId()));
+            }
+        };
+        Vehicle oldVehicle = VehicleImpl.Builder.newInstance("oldV").setStartLocation(Location.newInstance("oldV")).build();
+
+        VehicleRoute route = VehicleRoute.Builder.newInstance(oldVehicle, DriverImpl.noDriver())
+                        .addService(new Service.Builder("service").addSizeDimension(0, 0).setLocation(Location.newInstance("service")).build())
+                        .build();
+
+        Vehicle newVehicle = VehicleImpl.Builder.newInstance("newV").setStartLocation(Location.newInstance("newV")).build();
+
+        AdditionalAccessEgressCalculator accessEgressCalc = new AdditionalAccessEgressCalculator(routingCosts);
+        Job job = new Service.Builder("service2").addSizeDimension(0, 0).setLocation(Location.newInstance("service")).build();
+        JobInsertionContext iContex = new JobInsertionContext(route, job, newVehicle, mock(Driver.class), 0.0);
+        assertEquals(8.0, accessEgressCalc.getCosts(iContex), 0.01);
+    }
+}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithShipmentsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithShipmentsTest.java
new file mode 100644
index 000000000..04946c6bd
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithShipmentsTest.java
@@ -0,0 +1,314 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.jsprit.core.algorithm.recreate;
+
+import com.graphhopper.jsprit.core.algorithm.state.StateManager;
+import com.graphhopper.jsprit.core.problem.JobActivityFactory;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
+import com.graphhopper.jsprit.core.problem.constraint.HardRouteConstraint;
+import com.graphhopper.jsprit.core.problem.constraint.PickupAndDeliverShipmentLoadActivityLevelConstraint;
+import com.graphhopper.jsprit.core.problem.constraint.ShipmentPickupsFirstConstraint;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
+import com.graphhopper.jsprit.core.problem.driver.Driver;
+import com.graphhopper.jsprit.core.problem.driver.DriverImpl;
+import com.graphhopper.jsprit.core.problem.job.Pickup;
+import com.graphhopper.jsprit.core.problem.job.Service;
+import com.graphhopper.jsprit.core.problem.job.Shipment;
+import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.*;
+import com.graphhopper.jsprit.core.problem.solution.route.state.RouteAndActivityStateGetter;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
+import com.graphhopper.jsprit.core.util.CostFactory;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+
+public class GeneralJobInsertionWithShipmentsTest {
+
+    VehicleRoutingTransportCosts routingCosts;
+
+    VehicleRoutingProblem vehicleRoutingProblem;
+
+    VehicleRoutingActivityCosts activityCosts = new VehicleRoutingActivityCosts() {
+
+        @Override
+        public double getActivityCost(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
+            return 0;
+        }
+
+        @Override
+        public double getActivityDuration(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
+            return tourAct.getOperationTime();
+        }
+
+    };
+
+    HardRouteConstraint hardRouteLevelConstraint = new HardRouteConstraint() {
+
+        @Override
+        public boolean fulfilled(JobInsertionContext insertionContext) {
+            return true;
+        }
+
+    };
+
+    ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
+
+    GeneralJobInsertionCalculator insertionCalculator;
+
+    Vehicle vehicle;
+
+    @Before
+    public void doBefore() {
+        routingCosts = CostFactory.createManhattanCosts();
+        VehicleType type = VehicleTypeImpl.Builder.newInstance("t").addCapacityDimension(0, 2).setCostPerDistance(1).build();
+        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("0,0")).setType(type).build();
+        activityInsertionCostsCalculator = new LocalActivityInsertionCostsCalculator(routingCosts, activityCosts, mock(StateManager.class));
+        createInsertionCalculator(hardRouteLevelConstraint);
+        vehicleRoutingProblem = mock(VehicleRoutingProblem.class);
+    }
+
+    private void createInsertionCalculator(HardRouteConstraint hardRouteLevelConstraint) {
+        ConstraintManager constraintManager = new ConstraintManager(mock(VehicleRoutingProblem.class), mock(RouteAndActivityStateGetter.class));
+        constraintManager.addConstraint(hardRouteLevelConstraint);
+        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+    }
+
+    @Test
+    public void whenCalculatingInsertionCostsOfShipment_itShouldReturnCorrectCostValue() {
+        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
+        VehicleRoute route = VehicleRoute.emptyRoute();
+        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
+        List<JobActivity> activities = new ArrayList<>();
+        activities.add(new PickupShipmentDEPRECATED(shipment));
+        activities.add(new DeliverShipmentDEPRECATED(shipment));
+        when(activityFactory.createActivities(shipment)).thenReturn(activities);
+        insertionCalculator.setJobActivityFactory(activityFactory);
+        InsertionData iData = insertionCalculator.getInsertionData(route, shipment, vehicle, 0.0, null, Double.MAX_VALUE);
+        assertEquals(40.0, iData.getInsertionCost(), 0.05);
+    }
+
+    @Test
+    public void whenCalculatingInsertionIntoExistingRoute_itShouldReturnCorrectCosts() {
+        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
+        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
+        VehicleRoute route = VehicleRoute.emptyRoute();
+        List<JobActivity> tourActivities = getTourActivities(shipment);
+        route.setVehicleAndDepartureTime(vehicle,0);
+        add(tourActivities,route,0,0);
+
+        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
+        List<JobActivity> activities = new ArrayList<>();
+        activities.add(new PickupShipmentDEPRECATED(shipment2));
+        activities.add(new DeliverShipmentDEPRECATED(shipment2));
+        when(activityFactory.createActivities(shipment2)).thenReturn(activities);
+        insertionCalculator.setJobActivityFactory(activityFactory);
+
+        InsertionData iData = insertionCalculator.getInsertionData(route, shipment2, vehicle, 0.0, null, Double.MAX_VALUE);
+        assertEquals(0.0, iData.getInsertionCost(), 0.05);
+        assertEquals(1, iData.getUnmodifiableEventsByType(InsertActivity.class).get(1).getIndex());
+        assertEquals(2, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
+    }
+
+    private List<JobActivity> getTourActivities(Shipment shipment) {
+        List<JobActivity> acts = new ArrayList<>();
+        PickupShipmentDEPRECATED pick = new PickupShipmentDEPRECATED(shipment);
+        DeliverShipmentDEPRECATED del = new DeliverShipmentDEPRECATED(shipment);
+        acts.add(pick);
+        acts.add(del);
+        return acts;
+    }
+
+    @Test
+    public void whenInsertingShipmentInRouteWithNotEnoughCapacity_itShouldReturnNoInsertion() {
+        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
+        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
+        VehicleRoute route = VehicleRoute.emptyRoute();
+        List<JobActivity> tourActivities = getTourActivities(shipment);
+        route.setVehicleAndDepartureTime(vehicle,0);
+        add(tourActivities,route,0,0);
+
+        createInsertionCalculator(insertionContext -> false);
+
+        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
+        List<JobActivity> activities = new ArrayList<JobActivity>();
+        activities.add(new PickupShipmentDEPRECATED(shipment2));
+        activities.add(new DeliverShipmentDEPRECATED(shipment2));
+        when(activityFactory.createActivities(shipment2)).thenReturn(activities);
+        insertionCalculator.setJobActivityFactory(activityFactory);
+
+        InsertionData iData = insertionCalculator.getInsertionData(route, shipment2, vehicle, 0.0, null, Double.MAX_VALUE);
+        assertEquals(InsertionData.createEmptyInsertionData(), iData);
+
+    }
+
+
+    @Test
+    public void whenInsertingThirdShipment_itShouldCalcCorrectVal() {
+        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
+        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
+        Shipment shipment3 = Shipment.Builder.newInstance("s3").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("9,10")).build();
+
+        VehicleRoute route = VehicleRoute.emptyRoute();
+        List<JobActivity> shipmentActivities = getTourActivities(shipment);
+        List<JobActivity> shipment2Activities = getTourActivities(shipment2);
+
+        route.setVehicleAndDepartureTime(vehicle,0d);
+        add(shipmentActivities,route,0,0);
+        add(shipment2Activities,route,1,2);
+
+        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
+        List<JobActivity> activities = new ArrayList<>();
+        activities.add(new PickupShipmentDEPRECATED(shipment3));
+        activities.add(new DeliverShipmentDEPRECATED(shipment3));
+        when(activityFactory.createActivities(shipment3)).thenReturn(activities);
+        insertionCalculator.setJobActivityFactory(activityFactory);
+
+        InsertionData iData = insertionCalculator.getInsertionData(route, shipment3, vehicle, 0.0, null, Double.MAX_VALUE);
+        assertEquals(0.0, iData.getInsertionCost(), 0.05);
+        List<InsertActivity> unmodifiableEventsByType = iData.getUnmodifiableEventsByType(InsertActivity.class);
+        assertEquals(1, unmodifiableEventsByType.get(0).getIndex());
+        assertEquals(0, unmodifiableEventsByType.get(1).getIndex());
+    }
+
+    @Test
+    public void whenInsertingThirdShipment_itShouldCalcCorrectVal2() {
+        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
+        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
+        Shipment shipment3 = Shipment.Builder.newInstance("s3").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("9,9")).build();
+        List<JobActivity> shipmentActivities = getTourActivities(shipment);
+        List<JobActivity> shipment2Activities = getTourActivities(shipment2);
+        VehicleRoute route = VehicleRoute.emptyRoute();
+
+        route.setVehicleAndDepartureTime(vehicle,0d);
+        add(shipmentActivities,route,0,0);
+        add(shipment2Activities,route,1,2);
+
+        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
+        List<JobActivity> activities = new ArrayList<>();
+        activities.add(new PickupShipmentDEPRECATED(shipment3));
+        activities.add(new DeliverShipmentDEPRECATED(shipment3));
+        when(activityFactory.createActivities(shipment3)).thenReturn(activities);
+        insertionCalculator.setJobActivityFactory(activityFactory);
+
+
+        InsertionData iData = insertionCalculator.getInsertionData(route, shipment3, vehicle, 0.0, null, Double.MAX_VALUE);
+        assertEquals(2.0, iData.getInsertionCost(), 0.05);
+        assertEquals(0, iData.getUnmodifiableEventsByType(InsertActivity.class).get(1).getIndex());
+        assertEquals(1, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
+    }
+
+    @Test
+    public void whenInstertingShipmentWithLoadConstraintWhereCapIsNotSufficient_capConstraintsAreFulfilled() {
+        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
+        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
+        Shipment shipment3 = Shipment.Builder.newInstance("s3").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("9,9")).build();
+
+        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
+        VehicleRoutingProblem vrp = vrpBuilder.addJob(shipment).addJob(shipment2).addJob(shipment3).build();
+
+        VehicleRoute route = VehicleRoute.emptyRoute();
+        route.setVehicleAndDepartureTime(vehicle, 0.0);
+
+        add(vrp,route,shipment,0,0);
+        add(vrp,route,shipment2,1,2);
+
+        StateManager stateManager = new StateManager(vrp);
+        stateManager.updateLoadStates();
+        stateManager.informInsertionStarts(Arrays.asList(route), null);
+
+        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
+        constraintManager.addConstraint(new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager), ConstraintManager.Priority.CRITICAL);
+        constraintManager.addConstraint(new ShipmentPickupsFirstConstraint(), ConstraintManager.Priority.CRITICAL);
+
+        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        insertionCalculator.setJobActivityFactory(vrp.getJobActivityFactory());
+
+        InsertionData iData = insertionCalculator.getInsertionData(route, shipment3, vehicle, 0.0, DriverImpl.noDriver(), Double.MAX_VALUE);
+        assertTrue(iData instanceof InsertionData.NoInsertionFound);
+
+    }
+
+    @Test
+    public void whenInsertingServiceWhileNoCapIsAvailable_itMustReturnNoInsertionData() {
+        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
+        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
+
+        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
+        VehicleRoutingProblem vrp = vrpBuilder.addJob(shipment).addJob(shipment2).build();
+
+        VehicleRoute route = VehicleRoute.emptyRoute();
+        route.setVehicleAndDepartureTime(vehicle, 0.0);
+
+        add(vrp,route,shipment,0,0);
+        add(vrp,route,shipment2,1,2);
+
+        StateManager stateManager = new StateManager(vrp);
+        stateManager.updateLoadStates();
+        stateManager.informInsertionStarts(Arrays.asList(route), null);
+
+        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
+        constraintManager.addLoadConstraint();
+
+        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        stateManager.informInsertionStarts(Arrays.asList(route), null);
+
+        //		Service service = new Service.Builder("pick", 1).setLocationId("5,5").build();
+        Pickup service = new Pickup.Builder("pick").addSizeDimension(0, 1).setLocation(Location.newInstance("5,5")).build();
+
+        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
+        List<JobActivity> activities = new ArrayList<>();
+        activities.add(new PickupServiceDEPRECATED(service));
+        when(activityFactory.createActivities(service)).thenReturn(activities);
+        insertionCalculator.setJobActivityFactory(activityFactory);
+
+        InsertionData iData = insertionCalculator.getInsertionData(route, service, vehicle, 0, DriverImpl.noDriver(), Double.MAX_VALUE);
+        //		routeActVisitor.visit(route);
+
+        assertEquals(3, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
+    }
+
+    private void add(VehicleRoutingProblem vrp, VehicleRoute route, Shipment shipment, int pickI, int delI) {
+        List<JobActivity> shipmentActivities = vrp.copyAndGetActivities(shipment);
+        route.getTourActivities().addActivity(delI, shipmentActivities.get(1));
+        route.getTourActivities().addActivity(pickI, shipmentActivities.get(0));
+    }
+
+    private void add(List<JobActivity> shipmentActivities, VehicleRoute route, int pickI, int delI) {
+        route.getTourActivities().addActivity(delI, shipmentActivities.get(1));
+        route.getTourActivities().addActivity(pickI, shipmentActivities.get(0));
+    }
+
+
+}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/CustomJobTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/CustomJobTest.java
new file mode 100644
index 000000000..13f2af83b
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/CustomJobTest.java
@@ -0,0 +1,122 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.graphhopper.jsprit.core.problem.job;
+
+import com.graphhopper.jsprit.core.algorithm.FirstCustomJobWithMultipleActivitiesExample;
+import com.graphhopper.jsprit.core.problem.Capacity;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivityNEW;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Created by schroeder on 16/11/16.
+ */
+public class CustomJobTest {
+
+    static class CustomJob extends AbstractJob {
+
+        public static abstract class BuilderBase<T extends CustomJob, B extends CustomJob.BuilderBase<T, B>>
+            extends JobBuilder<T, B> {
+
+            List<Location> locs = new ArrayList<>();
+
+            List<Capacity> cap = new ArrayList<>();
+
+            public BuilderBase(String id) {
+                super(id);
+            }
+
+            public CustomJob.BuilderBase<T,B> addPickup(Location location, Capacity capacity){
+                locs.add(location);
+                cap.add(capacity);
+                return this;
+            }
+
+            public List<Location> getLocs() {
+                return locs;
+            }
+
+            public List<Capacity> getCaps() { return cap; }
+
+            protected void validate(){
+
+            }
+        }
+
+        public static final class Builder extends CustomJob.BuilderBase<CustomJob, CustomJob.Builder> {
+
+            public static CustomJob.Builder newInstance(String id) {
+                return new CustomJob.Builder(id);
+            }
+
+            public Builder(String id) {
+                super(id);
+            }
+
+            @Override
+            protected CustomJob createInstance() {
+                return new CustomJob(this);
+            }
+
+        }
+        /**
+         * Builder based constructor.
+         *
+         * @param builder The builder instance.
+         * @see JobBuilder
+         */
+        protected CustomJob(JobBuilder<?, ?> builder) {
+            super(builder);
+
+        }
+
+        @Override
+        public Capacity getSize() {
+            return Capacity.EMPTY;
+        }
+
+        @Override
+        protected void createActivities(JobBuilder<? extends AbstractJob, ?> jobBuilder) {
+            CustomJob.Builder builder = (CustomJob.Builder) jobBuilder;
+            JobActivityList list = new SequentialJobActivityList(this);
+            for(int i=0;i<builder.getLocs().size();i++){
+                list.addActivity(new PickupActivityNEW(this,"pick",builder.getLocs().get(i),0,builder.getCaps().get(i), Arrays.asList(TimeWindow.ETERNITY)));
+            }
+            setActivities(list);
+        }
+    }
+
+    @Test
+    public void whenCreatingANewJobWithThreeDistinctActivities_jobShouldContainActivities(){
+        CustomJob cj = CustomJob.Builder.newInstance("job")
+            .addPickup(Location.newInstance(10,0),Capacity.Builder.newInstance().addDimension(0,1).build())
+            .addPickup(Location.newInstance(5,0),Capacity.Builder.newInstance().addDimension(0,2).build())
+            .addPickup(Location.newInstance(20,0),Capacity.Builder.newInstance().addDimension(0,1).build())
+            .build();
+        Assert.assertEquals(3,cj.getActivityList().size());
+
+    }
+
+}
