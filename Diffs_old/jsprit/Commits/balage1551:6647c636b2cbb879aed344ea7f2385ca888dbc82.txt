diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculator.java
index 2f918c3d6..24e3cb73e 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculator.java
@@ -37,6 +37,177 @@
 
 final class GeneralJobInsertionCalculator implements JobInsertionCostsCalculator {
 
+    static class ActAndIndex {
+
+        private int index;
+
+        private TourActivity act;
+
+        public ActAndIndex(int index, TourActivity act) {
+            this.index = index;
+            this.act = act;
+        }
+    }
+
+    static class IndexedTourActivity {
+
+        int index;
+
+        TourActivity act;
+
+        public IndexedTourActivity(int index, TourActivity act) {
+            this.index = index;
+            this.act = act;
+        }
+
+        void setTourActivity(TourActivity act) {
+            this.act = act;
+        }
+    }
+
+    static class Route {
+
+        private IndexedTourActivity[] acts;
+
+        private int[] successors;
+
+        private int[] predecessors;
+
+        private IndexedTourActivity first;
+
+        private List<IndexedTourActivity> actsToInsert;
+
+        public Route(List<IndexedTourActivity> currentRoute, List<IndexedTourActivity> toInsert) {
+            actsToInsert = toInsert;
+            successors = new int[currentRoute.size() + toInsert.size()];
+            predecessors = new int[currentRoute.size() + toInsert.size()];
+            for (int i = 0; i < successors.length; i++) {
+                successors[i] = -1;
+                predecessors[i] = -1;
+            }
+            first = currentRoute.get(0);
+            ini(currentRoute, toInsert);
+        }
+
+        private void ini(List<IndexedTourActivity> currentRoute, List<IndexedTourActivity> toInsert) {
+            acts = new IndexedTourActivity[currentRoute.size() + toInsert.size()];
+            IndexedTourActivity prevAct = currentRoute.get(0);
+            acts[prevAct.index] = prevAct;
+            for (int i = 1; i < currentRoute.size(); i++) {
+                acts[currentRoute.get(i).index] = currentRoute.get(i);
+                setSuccessor(prevAct, currentRoute.get(i));
+                setPredecessor(currentRoute.get(i), prevAct);
+                prevAct = currentRoute.get(i);
+            }
+            for (IndexedTourActivity actToInsert : toInsert) {
+                acts[actToInsert.index] = actToInsert;
+            }
+        }
+
+        public IndexedTourActivity getFirst() {
+            return first;
+        }
+
+        void addAfter(IndexedTourActivity toInsert, IndexedTourActivity after) {
+            IndexedTourActivity actAfterAfter = getSuccessor(after);
+            setSuccessor(after, toInsert);
+            setSuccessor(toInsert, actAfterAfter);
+            setPredecessor(toInsert, after);
+            setPredecessor(actAfterAfter, toInsert);
+        }
+
+        IndexedTourActivity addAfter(JobActivity toInsert_, IndexedTourActivity after) {
+            IndexedTourActivity toInsert = find(toInsert_);
+            toInsert.setTourActivity(toInsert_);
+            IndexedTourActivity actAfterAfter = getSuccessor(after);
+            setSuccessor(after, toInsert);
+            setSuccessor(toInsert, actAfterAfter);
+            setPredecessor(toInsert, after);
+            setPredecessor(actAfterAfter, toInsert);
+            return toInsert;
+        }
+
+        private IndexedTourActivity find(JobActivity toInsert_) {
+            for (IndexedTourActivity a : actsToInsert) {
+                if (a.act.getIndex() == toInsert_.getIndex()) {
+                    return a;
+                }
+            }
+            throw new IllegalStateException("should not be");
+        }
+
+
+        void setSuccessor(IndexedTourActivity act, IndexedTourActivity successor) {
+            if (successor == null) successors[act.index] = -1;
+            else successors[act.index] = successor.index;
+        }
+
+        void setPredecessor(IndexedTourActivity act, IndexedTourActivity predecessor) {
+            if (predecessor == null) predecessors[act.index] = -1;
+            else predecessors[act.index] = predecessor.index;
+        }
+
+        void remove(IndexedTourActivity toRemove) {
+            IndexedTourActivity predecessor = getPredecessor(toRemove);
+            IndexedTourActivity successor = getSuccessor(toRemove);
+            setSuccessor(toRemove, null);
+            setPredecessor(toRemove, null);
+            setSuccessor(predecessor, successor);
+            setPredecessor(successor, predecessor);
+        }
+
+        void remove(JobActivity toRemove_) {
+            IndexedTourActivity toRemove = find(toRemove_);
+            IndexedTourActivity predecessor = getPredecessor(toRemove);
+            IndexedTourActivity successor = getSuccessor(toRemove);
+            setSuccessor(toRemove, null);
+            setPredecessor(toRemove, null);
+            setSuccessor(predecessor, successor);
+            setPredecessor(successor, predecessor);
+        }
+
+        IndexedTourActivity getSuccessor(IndexedTourActivity act) {
+            if (hasSuccessor(act)) {
+                return acts[successors[act.index]];
+            }
+            return null;
+        }
+
+        IndexedTourActivity getPredecessor(IndexedTourActivity act) {
+            if (hasPredecessor(act)) {
+                return acts[predecessors[act.index]];
+            }
+            return null;
+        }
+
+        boolean hasSuccessor(IndexedTourActivity act) {
+            return successors[act.index] != -1;
+        }
+
+        boolean hasPredecessor(IndexedTourActivity act) {
+            return predecessors[act.index] != -1;
+        }
+
+        Route copy() {
+            return null;
+        }
+
+        public ActAndIndex indexOf(TourActivity activity) {
+            int i = 0;
+            IndexedTourActivity prev = getFirst();
+            while (hasSuccessor(prev)) {
+                IndexedTourActivity succ = getSuccessor(prev);
+                if (succ.act.getIndex() == activity.getIndex()) {
+                    return new ActAndIndex(i + 1, succ.act);
+                }
+                i++;
+                prev = succ;
+            }
+            return null;
+        }
+
+    }
+
     private static final Logger logger = LoggerFactory.getLogger(GeneralJobInsertionCalculator.class);
 
     private HardRouteConstraint hardRouteLevelConstraint;
@@ -75,7 +246,7 @@ public String toString() {
 
     /**
      * Calculates the marginal cost of inserting job i locally. This is based on the
-     * assumption that cost changes can entirely covered by only looking at the predecessor i-1 and its successor i+1.
+     * assumption that cost changes can entirely covered by only looking at the predecessors i-1 and its successor i+1.
      */
     @Override
     public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job jobToInsert, final Vehicle newVehicle, double newVehicleDepartureTime, final Driver newDriver, final double bestKnownCosts) {
@@ -103,7 +274,12 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
         newRoute.addAll(currentRoute.getTourActivities().getActivities());
         newRoute.add(end);
 
-        List<InsertionData> bestData = calculateInsertionCosts(insertionContext, 1, actList, newRoute, additionalICostsAtRouteLevel, newVehicleDepartureTime);
+        List<IndexedTourActivity> current = makeIndices(newRoute, 0);
+        List<IndexedTourActivity> actsToInsert = makeIndices(actList, current.size());
+        Route route = new Route(current, actsToInsert);
+
+        List<Integer> insertionIndices = new ArrayList<>();
+        List<InsertionData> bestData = calculateInsertionCosts(insertionContext, 0, route.getFirst(), route, actList, additionalICostsAtRouteLevel, newVehicleDepartureTime, insertionIndices);
         if (bestData.isEmpty()) {
             return InsertionData.createEmptyInsertionData();
         } else {
@@ -117,11 +293,22 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
         }
     }
 
-    private List<InsertionData> calculateInsertionCosts(JobInsertionContext insertionContext, int index, List<JobActivity> actList, List<TourActivity> newRoute, double additionalCosts, double departureTime) {
+    private List<IndexedTourActivity> makeIndices(List<? extends TourActivity> acts, int startIndex) {
+        int index = startIndex;
+        List<IndexedTourActivity> indexed = new ArrayList<>();
+        for (TourActivity act : acts) {
+            indexed.add(new IndexedTourActivity(index, act));
+            index++;
+        }
+        return indexed;
+    }
+
+    private List<InsertionData> calculateInsertionCosts(JobInsertionContext insertionContext, int startIndex, IndexedTourActivity startAct, Route route, List<JobActivity> actList, double additionalCosts, double departureTime, List<Integer> insertionIndeces) {
         List<InsertionData> iData = new ArrayList<>();
         double departureTimeAtPrevAct = departureTime;
-        TourActivity prevAct = newRoute.get(index - 1);
-        for (int i = index; i < newRoute.size(); i++) {
+        IndexedTourActivity prevAct = startAct;
+        int index = startIndex;
+        while (route.hasSuccessor(prevAct)) {
             JobActivity jobActivity = actList.get(0);
             if (jobActivity.getTimeWindows().isEmpty()) {
                 throw new IllegalStateException("at least a single time window must be set");
@@ -130,34 +317,38 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
                 JobActivity copiedJobActivity = (JobActivity) jobActivity.duplicate();
                 copiedJobActivity.setTheoreticalEarliestOperationStartTime(timeWindow.getStart());
                 copiedJobActivity.setTheoreticalLatestOperationStartTime(timeWindow.getEnd());
+                //Todo: add correct info, e.g. arrival and end time - assure functionality by unit tests - current no info set, but no unit test fails -> this should not be
                 ActivityContext activityContext = new ActivityContext();
-                activityContext.setInsertionIndex(i);
+                activityContext.setInsertionIndex(index + 1);
+//                activityContext.setArrivalTime();
                 insertionContext.setActivityContext(activityContext);
-                HardActivityConstraint.ConstraintsStatus constraintStatus = hardActivityLevelConstraint.fulfilled(insertionContext, prevAct, copiedJobActivity, newRoute.get(i), departureTimeAtPrevAct);
+                HardActivityConstraint.ConstraintsStatus constraintStatus = hardActivityLevelConstraint.fulfilled(insertionContext, prevAct.act, copiedJobActivity, route.getSuccessor(prevAct).act, departureTimeAtPrevAct);
                 if (constraintStatus.equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED)) {
                     continue;
                 } else if (constraintStatus.equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED_BREAK)) {
                     return iData;
                 }
-                double miscCosts = softActivityConstraint.getCosts(insertionContext, prevAct, copiedJobActivity, newRoute.get(i), departureTimeAtPrevAct);
-                double c = calculate(insertionContext, prevAct, copiedJobActivity, newRoute.get(i), departureTimeAtPrevAct);
-                List<TourActivity> modifiedRoute = new ArrayList<>(newRoute);
-                modifiedRoute.add(i, copiedJobActivity);
+                double miscCosts = softActivityConstraint.getCosts(insertionContext, prevAct.act, copiedJobActivity, route.getSuccessor(prevAct).act, departureTimeAtPrevAct);
+                double c = calculate(insertionContext, prevAct.act, copiedJobActivity, route.getSuccessor(prevAct).act, departureTimeAtPrevAct);
+                IndexedTourActivity toInsert = route.addAfter(copiedJobActivity, prevAct);
                 double totalCosts = additionalCosts + c + miscCosts;
                 if (actList.size() == 1) {
                     InsertionData iD = new InsertionData(totalCosts, insertionContext.getNewDepTime(), insertionContext.getNewVehicle(), insertionContext.getNewDriver());
                     iD.getEvents().add(new SwitchVehicle(insertionContext.getRoute(), insertionContext.getNewVehicle(), insertionContext.getNewDepTime()));
-                    iD.getEvents().addAll(getInsertActivityEvents(insertionContext, modifiedRoute));
+                    iD.getEvents().addAll(getInsertActivityEvents(insertionContext, route));
                     iData.add(iD);
 
                 } else {
-                    double departureTimeFromJobActivity = getDeparture(prevAct, copiedJobActivity, departureTimeAtPrevAct, insertionContext.getNewDriver(), insertionContext.getNewVehicle());
-                    List<InsertionData> insertions = calculateInsertionCosts(insertionContext, i + 1, actList.subList(1, actList.size()), modifiedRoute, totalCosts, departureTimeFromJobActivity);
+                    double departureTimeFromJobActivity = getDeparture(prevAct.act, copiedJobActivity, departureTimeAtPrevAct, insertionContext.getNewDriver(), insertionContext.getNewVehicle());
+                    insertionIndeces.add(index + 1);
+                    List<InsertionData> insertions = calculateInsertionCosts(insertionContext, index + 1, toInsert, route, actList.subList(1, actList.size()), totalCosts, departureTimeFromJobActivity, insertionIndeces);
                     iData.addAll(insertions);
                 }
+                route.remove(toInsert);
             }
-            departureTimeAtPrevAct = getDeparture(prevAct, newRoute.get(i), departureTimeAtPrevAct, insertionContext.getNewDriver(), insertionContext.getNewVehicle());
-            prevAct = newRoute.get(i);
+            departureTimeAtPrevAct = getDeparture(prevAct.act, route.getSuccessor(prevAct).act, departureTimeAtPrevAct, insertionContext.getNewDriver(), insertionContext.getNewVehicle());
+            prevAct = route.getSuccessor(prevAct);
+            index++;
         }
         return iData;
     }
@@ -168,14 +359,13 @@ private double getDeparture(TourActivity prevAct, TourActivity activity, double
         return actStart + activityCosts.getActivityDuration(activity, actArrTime, driver, vehicle);
     }
 
-    private Collection<? extends Event> getInsertActivityEvents(JobInsertionContext insertionContext, List<TourActivity> modifiedRoute) {
+    private Collection<? extends Event> getInsertActivityEvents(JobInsertionContext insertionContext, Route modifiedRoute) {
         List<InsertActivity> insertActivities = new ArrayList<>();
         for (int i = insertionContext.getAssociatedActivities().size() - 1; i >= 0; i--) {
             TourActivity activity = insertionContext.getAssociatedActivities().get(i);
-            int activityIndexInModifiedRoute = modifiedRoute.indexOf(activity);
-            TourActivity activityInModifiedRoute = modifiedRoute.get(activityIndexInModifiedRoute);
+            ActAndIndex actAndIndex = modifiedRoute.indexOf(activity);
             insertActivities.add(new InsertActivity(insertionContext.getRoute(), insertionContext.getNewVehicle(),
-                activityInModifiedRoute, activityIndexInModifiedRoute - i - 1));
+                actAndIndex.act, actAndIndex.index - i - 1));
         }
         return insertActivities;
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculatorV2.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculatorV2.java
deleted file mode 100644
index 5190f1550..000000000
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculatorV2.java
+++ /dev/null
@@ -1,375 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import com.graphhopper.jsprit.core.problem.constraint.*;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.misc.ActivityContext;
-import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.*;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-
-final class GeneralJobInsertionCalculatorV2 implements JobInsertionCostsCalculator {
-
-    static class ActAndIndex {
-
-        private int index;
-
-        private TourActivity act;
-
-        public ActAndIndex(int index, TourActivity act) {
-            this.index = index;
-            this.act = act;
-        }
-    }
-
-    static class IndexedTourActivity {
-
-        int index;
-
-        TourActivity act;
-
-        public IndexedTourActivity(int index, TourActivity act) {
-            this.index = index;
-            this.act = act;
-        }
-
-        void setTourActivity(TourActivity act) {
-            this.act = act;
-        }
-    }
-
-    static class Route {
-
-        private IndexedTourActivity[] acts;
-
-        private int[] successors;
-
-        private int[] predecessors;
-
-        private IndexedTourActivity first;
-
-        private List<IndexedTourActivity> actsToInsert;
-
-        public Route(List<IndexedTourActivity> currentRoute, List<IndexedTourActivity> toInsert) {
-            actsToInsert = toInsert;
-            successors = new int[currentRoute.size() + toInsert.size()];
-            predecessors = new int[currentRoute.size() + toInsert.size()];
-            for (int i = 0; i < successors.length; i++) {
-                successors[i] = -1;
-                predecessors[i] = -1;
-            }
-            first = currentRoute.get(0);
-            ini(currentRoute, toInsert);
-        }
-
-        private void ini(List<IndexedTourActivity> currentRoute, List<IndexedTourActivity> toInsert) {
-            acts = new IndexedTourActivity[currentRoute.size() + toInsert.size()];
-            IndexedTourActivity prevAct = currentRoute.get(0);
-            acts[prevAct.index] = prevAct;
-            for (int i = 1; i < currentRoute.size(); i++) {
-                acts[currentRoute.get(i).index] = currentRoute.get(i);
-                setSuccessor(prevAct, currentRoute.get(i));
-                setPredecessor(currentRoute.get(i), prevAct);
-                prevAct = currentRoute.get(i);
-            }
-            for (IndexedTourActivity actToInsert : toInsert) {
-                acts[actToInsert.index] = actToInsert;
-            }
-        }
-
-        public IndexedTourActivity getFirst() {
-            return first;
-        }
-
-        void addAfter(IndexedTourActivity toInsert, IndexedTourActivity after) {
-            IndexedTourActivity actAfterAfter = getSuccessor(after);
-            setSuccessor(after, toInsert);
-            setSuccessor(toInsert, actAfterAfter);
-            setPredecessor(toInsert, after);
-            setPredecessor(actAfterAfter, toInsert);
-        }
-
-        IndexedTourActivity addAfter(JobActivity toInsert_, IndexedTourActivity after) {
-            IndexedTourActivity toInsert = find(toInsert_);
-            toInsert.setTourActivity(toInsert_);
-            IndexedTourActivity actAfterAfter = getSuccessor(after);
-            setSuccessor(after, toInsert);
-            setSuccessor(toInsert, actAfterAfter);
-            setPredecessor(toInsert, after);
-            setPredecessor(actAfterAfter, toInsert);
-            return toInsert;
-        }
-
-        private IndexedTourActivity find(JobActivity toInsert_) {
-            for (IndexedTourActivity a : actsToInsert) {
-                if (a.act.getIndex() == toInsert_.getIndex()) {
-                    return a;
-                }
-            }
-            throw new IllegalStateException("should not be");
-        }
-
-
-        void setSuccessor(IndexedTourActivity act, IndexedTourActivity successor) {
-            if (successor == null) successors[act.index] = -1;
-            else successors[act.index] = successor.index;
-        }
-
-        void setPredecessor(IndexedTourActivity act, IndexedTourActivity predecessor) {
-            if (predecessor == null) predecessors[act.index] = -1;
-            else predecessors[act.index] = predecessor.index;
-        }
-
-        void remove(IndexedTourActivity toRemove) {
-            IndexedTourActivity predecessor = getPredecessor(toRemove);
-            IndexedTourActivity successor = getSuccessor(toRemove);
-            setSuccessor(toRemove, null);
-            setPredecessor(toRemove, null);
-            setSuccessor(predecessor, successor);
-            setPredecessor(successor, predecessor);
-        }
-
-        void remove(JobActivity toRemove_) {
-            IndexedTourActivity toRemove = find(toRemove_);
-            IndexedTourActivity predecessor = getPredecessor(toRemove);
-            IndexedTourActivity successor = getSuccessor(toRemove);
-            setSuccessor(toRemove, null);
-            setPredecessor(toRemove, null);
-            setSuccessor(predecessor, successor);
-            setPredecessor(successor, predecessor);
-        }
-
-        IndexedTourActivity getSuccessor(IndexedTourActivity act) {
-            if (hasSuccessor(act)) {
-                return acts[successors[act.index]];
-            }
-            return null;
-        }
-
-        IndexedTourActivity getPredecessor(IndexedTourActivity act) {
-            if (hasPredecessor(act)) {
-                return acts[predecessors[act.index]];
-            }
-            return null;
-        }
-
-        boolean hasSuccessor(IndexedTourActivity act) {
-            return successors[act.index] != -1;
-        }
-
-        boolean hasPredecessor(IndexedTourActivity act) {
-            return predecessors[act.index] != -1;
-        }
-
-        Route copy() {
-            return null;
-        }
-
-        public ActAndIndex indexOf(TourActivity activity) {
-            int i = 0;
-            IndexedTourActivity prev = getFirst();
-            while (hasSuccessor(prev)) {
-                IndexedTourActivity succ = getSuccessor(prev);
-                if (succ.act.getIndex() == activity.getIndex()) {
-                    return new ActAndIndex(i + 1, succ.act);
-                }
-                i++;
-                prev = succ;
-            }
-            return null;
-        }
-
-    }
-
-    private static final Logger logger = LoggerFactory.getLogger(GeneralJobInsertionCalculatorV2.class);
-
-    private HardRouteConstraint hardRouteLevelConstraint;
-
-    private HardActivityConstraint hardActivityLevelConstraint;
-
-    private SoftRouteConstraint softRouteConstraint;
-
-    private SoftActivityConstraint softActivityConstraint;
-
-    private ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
-
-    private VehicleRoutingTransportCosts transportCosts;
-
-    private VehicleRoutingActivityCosts activityCosts;
-
-    private AdditionalAccessEgressCalculator additionalAccessEgressCalculator;
-
-    public GeneralJobInsertionCalculatorV2(VehicleRoutingTransportCosts routingCosts, VehicleRoutingActivityCosts activityCosts, ActivityInsertionCostsCalculator activityInsertionCostsCalculator, ConstraintManager constraintManager) {
-        super();
-        this.activityInsertionCostsCalculator = activityInsertionCostsCalculator;
-        hardRouteLevelConstraint = constraintManager;
-        hardActivityLevelConstraint = constraintManager;
-        softActivityConstraint = constraintManager;
-        softRouteConstraint = constraintManager;
-        transportCosts = routingCosts;
-        this.activityCosts = activityCosts;
-        additionalAccessEgressCalculator = new AdditionalAccessEgressCalculator(routingCosts);
-        logger.debug("initialise {}", this);
-    }
-
-    @Override
-    public String toString() {
-        return "[name=calculatesServiceInsertion]";
-    }
-
-    /**
-     * Calculates the marginal cost of inserting job i locally. This is based on the
-     * assumption that cost changes can entirely covered by only looking at the predecessors i-1 and its successor i+1.
-     */
-    @Override
-    public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job jobToInsert, final Vehicle newVehicle, double newVehicleDepartureTime, final Driver newDriver, final double bestKnownCosts) {
-        JobInsertionContext insertionContext = new JobInsertionContext(currentRoute, jobToInsert, newVehicle, newDriver, newVehicleDepartureTime);
-        List<JobActivity> actList = jobToInsert.getActivityList().getAllDuplicated();
-        insertionContext.getAssociatedActivities().addAll(actList);
-        /*
-        check hard route constraints
-         */
-        if (!hardRouteLevelConstraint.fulfilled(insertionContext)) {
-            return InsertionData.createEmptyInsertionData();
-        }
-        /*
-        check soft route constraints
-         */
-        double additionalICostsAtRouteLevel = softRouteConstraint.getCosts(insertionContext);
-        additionalICostsAtRouteLevel += additionalAccessEgressCalculator.getCosts(insertionContext);
-
-        Start start = new Start(newVehicle.getStartLocation(), newVehicle.getEarliestDeparture(), newVehicle.getLatestArrival());
-        start.setEndTime(newVehicleDepartureTime);
-        End end = new End(newVehicle.getEndLocation(), 0.0, newVehicle.getLatestArrival());
-
-        List<TourActivity> newRoute = new ArrayList<>();
-        newRoute.add(start);
-        newRoute.addAll(currentRoute.getTourActivities().getActivities());
-        newRoute.add(end);
-
-        List<IndexedTourActivity> current = makeIndices(newRoute, 0);
-        List<IndexedTourActivity> actsToInsert = makeIndices(actList, current.size());
-        Route route = new Route(current, actsToInsert);
-
-        List<Integer> insertionIndeces = new ArrayList<>();
-        List<InsertionData> bestData = calculateInsertionCosts(insertionContext, 0, route.getFirst(), route, actList, additionalICostsAtRouteLevel, newVehicleDepartureTime, insertionIndeces);
-        if (bestData.isEmpty()) {
-            return InsertionData.createEmptyInsertionData();
-        } else {
-            InsertionData best = InsertionData.createEmptyInsertionData();
-            for (InsertionData iD : bestData) {
-                if (iD.getInsertionCost() < best.getInsertionCost()) {
-                    best = iD;
-                }
-            }
-            return best;
-        }
-    }
-
-    private List<IndexedTourActivity> makeIndices(List<? extends TourActivity> acts, int startIndex) {
-        int index = startIndex;
-        List<IndexedTourActivity> indexed = new ArrayList<>();
-        for (TourActivity act : acts) {
-            indexed.add(new IndexedTourActivity(index, act));
-            index++;
-        }
-        return indexed;
-    }
-
-    private List<InsertionData> calculateInsertionCosts(JobInsertionContext insertionContext, int startIndex, IndexedTourActivity startAct, Route route, List<JobActivity> actList, double additionalCosts, double departureTime, List<Integer> insertionIndeces) {
-        List<InsertionData> iData = new ArrayList<>();
-        double departureTimeAtPrevAct = departureTime;
-        IndexedTourActivity prevAct = startAct;
-        int index = startIndex;
-        while (route.hasSuccessor(prevAct)) {
-            JobActivity jobActivity = actList.get(0);
-            if (jobActivity.getTimeWindows().isEmpty()) {
-                throw new IllegalStateException("at least a single time window must be set");
-            }
-            for (TimeWindow timeWindow : jobActivity.getTimeWindows()) {
-                JobActivity copiedJobActivity = (JobActivity) jobActivity.duplicate();
-                copiedJobActivity.setTheoreticalEarliestOperationStartTime(timeWindow.getStart());
-                copiedJobActivity.setTheoreticalLatestOperationStartTime(timeWindow.getEnd());
-                ActivityContext activityContext = new ActivityContext();
-                activityContext.setInsertionIndex(index + 1);
-                insertionContext.setActivityContext(activityContext);
-                HardActivityConstraint.ConstraintsStatus constraintStatus = hardActivityLevelConstraint.fulfilled(insertionContext, prevAct.act, copiedJobActivity, route.getSuccessor(prevAct).act, departureTimeAtPrevAct);
-                if (constraintStatus.equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED)) {
-                    continue;
-                } else if (constraintStatus.equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED_BREAK)) {
-                    return iData;
-                }
-                double miscCosts = softActivityConstraint.getCosts(insertionContext, prevAct.act, copiedJobActivity, route.getSuccessor(prevAct).act, departureTimeAtPrevAct);
-                double c = calculate(insertionContext, prevAct.act, copiedJobActivity, route.getSuccessor(prevAct).act, departureTimeAtPrevAct);
-                IndexedTourActivity toInsert = route.addAfter(copiedJobActivity, prevAct);
-                double totalCosts = additionalCosts + c + miscCosts;
-                if (actList.size() == 1) {
-                    InsertionData iD = new InsertionData(totalCosts, insertionContext.getNewDepTime(), insertionContext.getNewVehicle(), insertionContext.getNewDriver());
-                    iD.getEvents().add(new SwitchVehicle(insertionContext.getRoute(), insertionContext.getNewVehicle(), insertionContext.getNewDepTime()));
-                    iD.getEvents().addAll(getInsertActivityEvents(insertionContext, route));
-                    iData.add(iD);
-
-                } else {
-                    double departureTimeFromJobActivity = getDeparture(prevAct.act, copiedJobActivity, departureTimeAtPrevAct, insertionContext.getNewDriver(), insertionContext.getNewVehicle());
-                    insertionIndeces.add(index + 1);
-                    List<InsertionData> insertions = calculateInsertionCosts(insertionContext, index + 1, toInsert, route, actList.subList(1, actList.size()), totalCosts, departureTimeFromJobActivity, insertionIndeces);
-                    iData.addAll(insertions);
-                }
-                route.remove(toInsert);
-            }
-            departureTimeAtPrevAct = getDeparture(prevAct.act, route.getSuccessor(prevAct).act, departureTimeAtPrevAct, insertionContext.getNewDriver(), insertionContext.getNewVehicle());
-            prevAct = route.getSuccessor(prevAct);
-            index++;
-        }
-        return iData;
-    }
-
-    private double getDeparture(TourActivity prevAct, TourActivity activity, double departureTimeAtPrevAct, Driver driver, Vehicle vehicle) {
-        double actArrTime = departureTimeAtPrevAct + transportCosts.getTransportTime(prevAct.getLocation(), activity.getLocation(), departureTimeAtPrevAct, driver, vehicle);
-        double actStart = Math.max(actArrTime, activity.getTheoreticalEarliestOperationStartTime());
-        return actStart + activityCosts.getActivityDuration(activity, actArrTime, driver, vehicle);
-    }
-
-    private Collection<? extends Event> getInsertActivityEvents(JobInsertionContext insertionContext, Route modifiedRoute) {
-        List<InsertActivity> insertActivities = new ArrayList<>();
-        for (int i = insertionContext.getAssociatedActivities().size() - 1; i >= 0; i--) {
-            TourActivity activity = insertionContext.getAssociatedActivities().get(i);
-            ActAndIndex actAndIndex = modifiedRoute.indexOf(activity);
-            insertActivities.add(new InsertActivity(insertionContext.getRoute(), insertionContext.getNewVehicle(),
-                actAndIndex.act, actAndIndex.index - i - 1));
-        }
-        return insertActivities;
-    }
-
-    private double calculate(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double departureTimeAtPrevAct) {
-        return activityInsertionCostsCalculator.getCosts(iFacts, prevAct, nextAct, newAct, departureTimeAtPrevAct);
-
-    }
-}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java
index 8b5ad42af..56fb99b42 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java
@@ -272,7 +272,7 @@ private CalculatorPlusListeners createStandardLocal(final VehicleRoutingProblem
 //        ServiceInsertionCalculator serviceInsertion = new ServiceInsertionCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(), actInsertionCalc, constraintManager);
 //        serviceInsertion.setJobActivityFactory(activityFactory);
 
-        GeneralJobInsertionCalculatorV2 generalJobInsertionCalculator = new GeneralJobInsertionCalculatorV2(vrp.getTransportCosts(), vrp.getActivityCosts(), actInsertionCalc, constraintManager);
+        GeneralJobInsertionCalculator generalJobInsertionCalculator = new GeneralJobInsertionCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(), actInsertionCalc, constraintManager);
 
         BreakInsertionCalculator breakInsertionCalculator = new BreakInsertionCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(), actInsertionCalc, constraintManager);
         breakInsertionCalculator.setJobActivityFactory(activityFactory);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndLoadConstraintsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndLoadConstraintsTest.java
index be8214941..05c655807 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndLoadConstraintsTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndLoadConstraintsTest.java
@@ -85,7 +85,7 @@ public boolean fulfilled(JobInsertionContext insertionContext) {
 
     ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
 
-    GeneralJobInsertionCalculatorV2 insertionCalculator;
+    GeneralJobInsertionCalculator insertionCalculator;
 
     VehicleRoutingProblem vehicleRoutingProblem;
 
@@ -104,7 +104,7 @@ public void doBefore() {
     private void createInsertionCalculator(HardRouteConstraint hardRouteLevelConstraint) {
         ConstraintManager constraintManager = new ConstraintManager(mock(VehicleRoutingProblem.class), mock(RouteAndActivityStateGetter.class));
         constraintManager.addConstraint(hardRouteLevelConstraint);
-        insertionCalculator = new GeneralJobInsertionCalculatorV2(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
     }
 
     @Test
@@ -129,7 +129,7 @@ public void whenInsertingServiceWhileNoCapIsAvailable_itMustReturnTheCorrectInse
         constraintManager.addLoadConstraint();
         stateManager.informInsertionStarts(Arrays.asList(route), null);
 
-        insertionCalculator = new GeneralJobInsertionCalculatorV2(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
 
         InsertionData iData = insertionCalculator.getInsertionData(route, pickup, vehicle, 0, DriverImpl.noDriver(), Double.MAX_VALUE);
         List<InsertActivity> insertActivities = iData.getUnmodifiableEventsByType(InsertActivity.class);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndTimeWindowConstraintsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndTimeWindowConstraintsTest.java
index ff0243e50..bfc79a700 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndTimeWindowConstraintsTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionAndTimeWindowConstraintsTest.java
@@ -85,7 +85,7 @@ public boolean fulfilled(JobInsertionContext insertionContext) {
 
     ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
 
-    GeneralJobInsertionCalculatorV2 insertionCalculator;
+    GeneralJobInsertionCalculator insertionCalculator;
 
     VehicleRoutingProblem vehicleRoutingProblem;
 
@@ -104,7 +104,7 @@ public void doBefore() {
     private void createInsertionCalculator(HardRouteConstraint hardRouteLevelConstraint) {
         ConstraintManager constraintManager = new ConstraintManager(mock(VehicleRoutingProblem.class), mock(RouteAndActivityStateGetter.class));
         constraintManager.addConstraint(hardRouteLevelConstraint);
-        insertionCalculator = new GeneralJobInsertionCalculatorV2(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
     }
 
     @Test
@@ -131,7 +131,7 @@ public void whenInsertingServiceWithTW_itMustReturnTheCorrectInsertionIndex() {
         constraintManager.addTimeWindowConstraint();
         stateManager.informInsertionStarts(Arrays.asList(route), null);
 
-        insertionCalculator = new GeneralJobInsertionCalculatorV2(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
 
         InsertionData iData = insertionCalculator.getInsertionData(route, pickup, vehicle, 0, DriverImpl.noDriver(), Double.MAX_VALUE);
         Assert.assertTrue(iData instanceof InsertionData.NoInsertionFound);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculatorTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculatorTest.java
index 0475d6a94..672908768 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculatorTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculatorTest.java
@@ -33,25 +33,25 @@
  */
 public class GeneralJobInsertionCalculatorTest {
 
-    GeneralJobInsertionCalculatorV2.IndexedTourActivity start;
+    GeneralJobInsertionCalculator.IndexedTourActivity start;
 
-    GeneralJobInsertionCalculatorV2.IndexedTourActivity act;
+    GeneralJobInsertionCalculator.IndexedTourActivity act;
 
-    GeneralJobInsertionCalculatorV2.IndexedTourActivity end;
+    GeneralJobInsertionCalculator.IndexedTourActivity end;
 
-    GeneralJobInsertionCalculatorV2.IndexedTourActivity toInsert;
+    GeneralJobInsertionCalculator.IndexedTourActivity toInsert;
 
     @Before
     public void doBefore() {
-        start = new GeneralJobInsertionCalculatorV2.IndexedTourActivity(0, mock(TourActivity.class));
-        act = new GeneralJobInsertionCalculatorV2.IndexedTourActivity(1, mock(TourActivity.class));
-        end = new GeneralJobInsertionCalculatorV2.IndexedTourActivity(2, mock(TourActivity.class));
-        toInsert = new GeneralJobInsertionCalculatorV2.IndexedTourActivity(3, mock(TourActivity.class));
+        start = new GeneralJobInsertionCalculator.IndexedTourActivity(0, mock(TourActivity.class));
+        act = new GeneralJobInsertionCalculator.IndexedTourActivity(1, mock(TourActivity.class));
+        end = new GeneralJobInsertionCalculator.IndexedTourActivity(2, mock(TourActivity.class));
+        toInsert = new GeneralJobInsertionCalculator.IndexedTourActivity(3, mock(TourActivity.class));
     }
 
     @Test
     public void testSuccessor() {
-        GeneralJobInsertionCalculatorV2.Route route = new GeneralJobInsertionCalculatorV2.Route(Arrays.asList(start, act, end), Arrays.asList(toInsert));
+        GeneralJobInsertionCalculator.Route route = new GeneralJobInsertionCalculator.Route(Arrays.asList(start, act, end), Arrays.asList(toInsert));
         Assert.assertEquals(start, route.getFirst());
         Assert.assertEquals(act, route.getSuccessor(route.getFirst()));
         Assert.assertEquals(end, route.getSuccessor(act));
@@ -60,7 +60,7 @@ public void testSuccessor() {
 
     @Test
     public void testPredecessor() {
-        GeneralJobInsertionCalculatorV2.Route route = new GeneralJobInsertionCalculatorV2.Route(Arrays.asList(start, act, end), Arrays.asList(toInsert));
+        GeneralJobInsertionCalculator.Route route = new GeneralJobInsertionCalculator.Route(Arrays.asList(start, act, end), Arrays.asList(toInsert));
         Assert.assertEquals(null, route.getPredecessor(route.getFirst()));
         Assert.assertEquals(route.getFirst(), route.getPredecessor(act));
         Assert.assertEquals(act, route.getPredecessor(route.getSuccessor(act)));
@@ -69,7 +69,7 @@ public void testPredecessor() {
 
     @Test
     public void insertNew() {
-        GeneralJobInsertionCalculatorV2.Route route = new GeneralJobInsertionCalculatorV2.Route(Arrays.asList(start, act, end), Arrays.asList(toInsert));
+        GeneralJobInsertionCalculator.Route route = new GeneralJobInsertionCalculator.Route(Arrays.asList(start, act, end), Arrays.asList(toInsert));
         Assert.assertEquals(route.getFirst(), route.getPredecessor(act));
         route.addAfter(toInsert, route.getFirst());
         Assert.assertEquals(toInsert, route.getPredecessor(act));
@@ -81,7 +81,7 @@ public void insertNew() {
 
     @Test
     public void removeAct() {
-        GeneralJobInsertionCalculatorV2.Route route = new GeneralJobInsertionCalculatorV2.Route(Arrays.asList(start, act, end), Arrays.asList(toInsert));
+        GeneralJobInsertionCalculator.Route route = new GeneralJobInsertionCalculator.Route(Arrays.asList(start, act, end), Arrays.asList(toInsert));
         Assert.assertEquals(route.getFirst(), route.getPredecessor(act));
         route.remove(act);
         Assert.assertEquals(null, route.getPredecessor(act));
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesAndLoadConstraintsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesAndLoadConstraintsTest.java
index c1747586a..4c010764d 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesAndLoadConstraintsTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesAndLoadConstraintsTest.java
@@ -84,7 +84,7 @@ public boolean fulfilled(JobInsertionContext insertionContext) {
 
     ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
 
-    GeneralJobInsertionCalculatorV2 insertionCalculator;
+    GeneralJobInsertionCalculator insertionCalculator;
 
     VehicleRoutingProblem vehicleRoutingProblem;
 
@@ -121,7 +121,7 @@ public void whenInsertingServiceWhileNoCapIsAvailable_itMustReturnTheCorrectInse
         constraintManager.addLoadConstraint();
         stateManager.informInsertionStarts(Arrays.asList(route), null);
 
-        insertionCalculator = new GeneralJobInsertionCalculatorV2(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
 
         InsertionData iData = insertionCalculator.getInsertionData(route, pickup, vehicle, 0, DriverImpl.noDriver(), Double.MAX_VALUE);
         List<InsertActivity> insertActivities = iData.getUnmodifiableEventsByType(InsertActivity.class);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesTest.java
index 74e4b0965..f09d9db75 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithServicesTest.java
@@ -50,7 +50,7 @@
 
 public class GeneralJobInsertionWithServicesTest {
 
-    GeneralJobInsertionCalculatorV2 jobInsertion;
+    GeneralJobInsertionCalculator jobInsertion;
 
     VehicleRoutingTransportCosts costs;
 
@@ -127,7 +127,7 @@ public double getTransportCost(Location from, Location to, double departureTime,
 
         VehicleRoutingActivityCosts actCosts = mock(VehicleRoutingActivityCosts.class);
 
-        jobInsertion = new GeneralJobInsertionCalculatorV2(costs, vrp.getActivityCosts(), new LocalActivityInsertionCostsCalculator(costs, actCosts, states), cManager);
+        jobInsertion = new GeneralJobInsertionCalculator(costs, vrp.getActivityCosts(), new LocalActivityInsertionCostsCalculator(costs, actCosts, states), cManager);
     }
 
     @Test
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithShipmentsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithShipmentsTest.java
index b1fc0e681..ed92e8c53 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithShipmentsTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithShipmentsTest.java
@@ -85,7 +85,7 @@ public boolean fulfilled(JobInsertionContext insertionContext) {
 
     ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
 
-    GeneralJobInsertionCalculatorV2 insertionCalculator;
+    GeneralJobInsertionCalculator insertionCalculator;
 
     Vehicle vehicle;
 
@@ -102,7 +102,7 @@ public void doBefore() {
     private void createInsertionCalculator(HardRouteConstraint hardRouteLevelConstraint) {
         ConstraintManager constraintManager = new ConstraintManager(mock(VehicleRoutingProblem.class), mock(RouteAndActivityStateGetter.class));
         constraintManager.addConstraint(hardRouteLevelConstraint);
-        insertionCalculator = new GeneralJobInsertionCalculatorV2(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
     }
 
     @Test
@@ -229,7 +229,7 @@ public void whenInstertingShipmentWithLoadConstraintWhereCapIsNotSufficient_capC
         constraintManager.addConstraint(new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager), ConstraintManager.Priority.CRITICAL);
         constraintManager.addConstraint(new ShipmentPickupsFirstConstraint(), ConstraintManager.Priority.CRITICAL);
 
-        insertionCalculator = new GeneralJobInsertionCalculatorV2(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
 
         InsertionData iData = insertionCalculator.getInsertionData(route, shipment3, vehicle, 0.0, DriverImpl.noDriver(), Double.MAX_VALUE);
         assertTrue(iData instanceof InsertionData.NoInsertionFound);
@@ -257,7 +257,7 @@ public void whenInsertingServiceWhileNoCapIsAvailable_itMustReturnNoInsertionDat
         ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
         constraintManager.addLoadConstraint();
 
-        insertionCalculator = new GeneralJobInsertionCalculatorV2(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
+        insertionCalculator = new GeneralJobInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
         stateManager.informInsertionStarts(Arrays.asList(route), null);
 
         //		Service service = new Service.Builder("pick", 1).setLocationId("5,5").build();
