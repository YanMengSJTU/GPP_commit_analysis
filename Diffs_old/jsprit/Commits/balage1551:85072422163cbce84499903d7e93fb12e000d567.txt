diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java
index 2eb260540..8e7aeae69 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java
@@ -93,15 +93,37 @@ public ModularSolutionCostCalculator addComponents(SolutionCostComponent compone
      * @return The cost calculator itself.
      * @throws IllegalArgumentException
      *             If the component is already registered.
+     * @throws IllegalStateException
+     *             When called after the calculator is initialized.
      */
     public ModularSolutionCostCalculator addComponent(SolutionCostComponent component, double weight) {
-        if (components.containsKey(component.getId())) {
+        if (isInitialized()) {
+            throw new IllegalStateException("Already initialized.");
+        }
+        if (components.containsKey(component)) {
             throw new IllegalArgumentException("Cost component '" + component.getId() + "' is duplicated.");
         }
         components.put(component, weight);
         return this;
     }
 
+    /**
+     * @return The number of registered components.
+     */
+    public int getComponentCount() {
+        return components.size();
+    }
+
+    /**
+     * Returns the weight of a component.
+     *
+     * @param key
+     *            The key to look for.
+     * @return The weight of the component or empty if not registered.
+     */
+    public Optional<Double> getWeight(String key) {
+        return Optional.ofNullable(components.getOrDefault(findComponent(key).orElse(null), null));
+    }
 
     /**
      * Returns whether the component with the key is registered.
@@ -133,8 +155,13 @@ public boolean containsComponent(String key) {
      *            The key to look for.
      * @param newWeight
      *            The new weight.
+     * @throws IllegalStateException
+     *             When called after the calculator is initialized.
      */
     public void changeComponentWeight(String key, double newWeight) {
+        if (isInitialized()) {
+            throw new IllegalStateException("Already initialized.");
+        }
         findComponent(key).ifPresent(c -> components.put(c, newWeight));
     }
 
@@ -144,13 +171,18 @@ public void changeComponentWeight(String key, double newWeight) {
      * This makes it possible to start from a predefined calculator (such as the
      * default one) and reconfiguring one of its components.
      * </p>
-     * 
+     *
      * @param key
      *            The key of the component to remove.
      * @return The removed component or empty if the component was not
      *         registered.
+     * @throws IllegalStateException
+     *             When called after the calculator is initialized.
      */
     public Optional<SolutionCostComponent> removeComponent(String key) {
+        if (isInitialized()) {
+            throw new IllegalStateException("Already initialized.");
+        }
         Optional<SolutionCostComponent> optC = findComponent(key);
         optC.ifPresent(c -> components.remove(c));
         return optC;
@@ -223,4 +255,5 @@ private void beforeSolution() {
         components.keySet().forEach(c -> c.beforeSolution(problem));
     }
 
+
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculatorTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculatorTest.java
new file mode 100644
index 000000000..d2ba17f8d
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculatorTest.java
@@ -0,0 +1,150 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+
+import java.util.Optional;
+
+import org.junit.Test;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+
+public class ModularSolutionCostCalculatorTest {
+
+    @Test
+    public void whenModuleAdded_itIsThere() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        calc.addComponent(fix);
+        assertEquals(1, calc.getComponentCount());
+        assertEquals(true, calc.findComponent(FixCostPerVehicle.COMPONENT_ID).isPresent());
+        assertEquals(fix, calc.findComponent(FixCostPerVehicle.COMPONENT_ID).get());
+    }
+
+    @Test
+    public void whenAnotherModuleAdded_itIsAlsoThere() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        UnassignedJobs unassigned = new UnassignedJobs();
+        calc.addComponent(fix);
+        calc.addComponent(unassigned);
+        assertEquals(2, calc.getComponentCount());
+        assertEquals(true, calc.findComponent(FixCostPerVehicle.COMPONENT_ID).isPresent());
+        assertEquals(fix, calc.findComponent(FixCostPerVehicle.COMPONENT_ID).get());
+        assertEquals(true, calc.findComponent(UnassignedJobs.COMPONENT_ID).isPresent());
+        assertEquals(unassigned, calc.findComponent(UnassignedJobs.COMPONENT_ID).get());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenModuleAddedTwice_exceptionIsThrown() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        calc.addComponent(fix);
+        calc.addComponent(fix);
+    }
+
+    @Test
+    public void whenRegisteredModuleRemoved_itIsRemoved() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        UnassignedJobs unassigned = new UnassignedJobs();
+        calc.addComponent(fix);
+        calc.addComponent(unassigned);
+        calc.removeComponent(FixCostPerVehicle.COMPONENT_ID);
+
+        assertEquals(1, calc.getComponentCount());
+        assertEquals(false, calc.findComponent(FixCostPerVehicle.COMPONENT_ID).isPresent());
+        assertEquals(true, calc.findComponent(UnassignedJobs.COMPONENT_ID).isPresent());
+    }
+
+    @Test
+    public void whenRegisteredModuleRemoved_itIsReturned() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        UnassignedJobs unassigned = new UnassignedJobs();
+        calc.addComponent(fix);
+        calc.addComponent(unassigned);
+        Optional<SolutionCostComponent> res = calc.removeComponent(FixCostPerVehicle.COMPONENT_ID);
+
+        assertTrue(res.isPresent());
+        assertEquals(fix, res.get());
+    }
+
+    @Test
+    public void whenUnregisteredModuleRemoved_nothingHappens() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        UnassignedJobs unassigned = new UnassignedJobs();
+        calc.addComponent(unassigned);
+        Optional<SolutionCostComponent> res = calc.removeComponent(FixCostPerVehicle.COMPONENT_ID);
+
+        assertEquals(1, calc.getComponentCount());
+        assertEquals(true, calc.findComponent(UnassignedJobs.COMPONENT_ID).isPresent());
+        assertEquals(false, res.isPresent());
+    }
+
+    @Test
+    public void whenGettingTheWeightOfRegisteredComponent_theDefaultIsOne() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        calc.addComponent(fix);
+        Optional<Double> res = calc.getWeight(FixCostPerVehicle.COMPONENT_ID);
+
+        assertTrue(res.isPresent());
+        assertEquals(1d, res.get(), 0d);
+    }
+
+    @Test
+    public void whenGettingTheWeightOfUnregisteredComponent_theValueIsEmpty() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        calc.addComponent(fix);
+        Optional<Double> res = calc.getWeight(UnassignedJobs.COMPONENT_ID);
+
+        assertFalse(res.isPresent());
+    }
+
+    @Test
+    public void whenSettingTheWeightOfAComponentWhenRegistered_theWeightIsSet() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        calc.addComponent(fix, 2d);
+        Optional<Double> res = calc.getWeight(FixCostPerVehicle.COMPONENT_ID);
+
+        assertTrue(res.isPresent());
+        assertEquals(2d, res.get(), 0d);
+    }
+
+    @Test
+    public void whenSettingTheWeightOfAComponentLater_theWeightIsSet() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        calc.addComponent(fix);
+        calc.changeComponentWeight(FixCostPerVehicle.COMPONENT_ID, 2d);
+        Optional<Double> res = calc.getWeight(FixCostPerVehicle.COMPONENT_ID);
+
+        assertTrue(res.isPresent());
+        assertEquals(2d, res.get(), 0d);
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void whenCallingCalculatorFunctionsBeforeInitialization_itThrowsException() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        calc.addComponent(fix);
+        calc.calculate(mock(VehicleRoutingProblemSolution.class));
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void whenAddingComponentAfterInitialization_itThrowsException() {
+        ModularSolutionCostCalculator calc = new ModularSolutionCostCalculator();
+        FixCostPerVehicle fix = new FixCostPerVehicle();
+        UnassignedJobs unassigned = new UnassignedJobs();
+        calc.addComponent(fix);
+        calc.beforeRun(mock(VehicleRoutingProblem.class), 0d);
+        calc.addComponent(unassigned);
+    }
+
+}
