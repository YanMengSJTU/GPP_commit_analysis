diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculator.java
index 2f918c3d6..24e3cb73e 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculator.java
@@ -37,6 +37,177 @@
 
 final class GeneralJobInsertionCalculator implements JobInsertionCostsCalculator {
 
+    static class ActAndIndex {
+
+        private int index;
+
+        private TourActivity act;
+
+        public ActAndIndex(int index, TourActivity act) {
+            this.index = index;
+            this.act = act;
+        }
+    }
+
+    static class IndexedTourActivity {
+
+        int index;
+
+        TourActivity act;
+
+        public IndexedTourActivity(int index, TourActivity act) {
+            this.index = index;
+            this.act = act;
+        }
+
+        void setTourActivity(TourActivity act) {
+            this.act = act;
+        }
+    }
+
+    static class Route {
+
+        private IndexedTourActivity[] acts;
+
+        private int[] successors;
+
+        private int[] predecessors;
+
+        private IndexedTourActivity first;
+
+        private List<IndexedTourActivity> actsToInsert;
+
+        public Route(List<IndexedTourActivity> currentRoute, List<IndexedTourActivity> toInsert) {
+            actsToInsert = toInsert;
+            successors = new int[currentRoute.size() + toInsert.size()];
+            predecessors = new int[currentRoute.size() + toInsert.size()];
+            for (int i = 0; i < successors.length; i++) {
+                successors[i] = -1;
+                predecessors[i] = -1;
+            }
+            first = currentRoute.get(0);
+            ini(currentRoute, toInsert);
+        }
+
+        private void ini(List<IndexedTourActivity> currentRoute, List<IndexedTourActivity> toInsert) {
+            acts = new IndexedTourActivity[currentRoute.size() + toInsert.size()];
+            IndexedTourActivity prevAct = currentRoute.get(0);
+            acts[prevAct.index] = prevAct;
+            for (int i = 1; i < currentRoute.size(); i++) {
+                acts[currentRoute.get(i).index] = currentRoute.get(i);
+                setSuccessor(prevAct, currentRoute.get(i));
+                setPredecessor(currentRoute.get(i), prevAct);
+                prevAct = currentRoute.get(i);
+            }
+            for (IndexedTourActivity actToInsert : toInsert) {
+                acts[actToInsert.index] = actToInsert;
+            }
+        }
+
+        public IndexedTourActivity getFirst() {
+            return first;
+        }
+
+        void addAfter(IndexedTourActivity toInsert, IndexedTourActivity after) {
+            IndexedTourActivity actAfterAfter = getSuccessor(after);
+            setSuccessor(after, toInsert);
+            setSuccessor(toInsert, actAfterAfter);
+            setPredecessor(toInsert, after);
+            setPredecessor(actAfterAfter, toInsert);
+        }
+
+        IndexedTourActivity addAfter(JobActivity toInsert_, IndexedTourActivity after) {
+            IndexedTourActivity toInsert = find(toInsert_);
+            toInsert.setTourActivity(toInsert_);
+            IndexedTourActivity actAfterAfter = getSuccessor(after);
+            setSuccessor(after, toInsert);
+            setSuccessor(toInsert, actAfterAfter);
+            setPredecessor(toInsert, after);
+            setPredecessor(actAfterAfter, toInsert);
+            return toInsert;
+        }
+
+        private IndexedTourActivity find(JobActivity toInsert_) {
+            for (IndexedTourActivity a : actsToInsert) {
+                if (a.act.getIndex() == toInsert_.getIndex()) {
+                    return a;
+                }
+            }
+            throw new IllegalStateException("should not be");
+        }
+
+
+        void setSuccessor(IndexedTourActivity act, IndexedTourActivity successor) {
+            if (successor == null) successors[act.index] = -1;
+            else successors[act.index] = successor.index;
+        }
+
+        void setPredecessor(IndexedTourActivity act, IndexedTourActivity predecessor) {
+            if (predecessor == null) predecessors[act.index] = -1;
+            else predecessors[act.index] = predecessor.index;
+        }
+
+        void remove(IndexedTourActivity toRemove) {
+            IndexedTourActivity predecessor = getPredecessor(toRemove);
+            IndexedTourActivity successor = getSuccessor(toRemove);
+            setSuccessor(toRemove, null);
+            setPredecessor(toRemove, null);
+            setSuccessor(predecessor, successor);
+            setPredecessor(successor, predecessor);
+        }
+
+        void remove(JobActivity toRemove_) {
+            IndexedTourActivity toRemove = find(toRemove_);
+            IndexedTourActivity predecessor = getPredecessor(toRemove);
+            IndexedTourActivity successor = getSuccessor(toRemove);
+            setSuccessor(toRemove, null);
+            setPredecessor(toRemove, null);
+            setSuccessor(predecessor, successor);
+            setPredecessor(successor, predecessor);
+        }
+
+        IndexedTourActivity getSuccessor(IndexedTourActivity act) {
+            if (hasSuccessor(act)) {
+                return acts[successors[act.index]];
+            }
+            return null;
+        }
+
+        IndexedTourActivity getPredecessor(IndexedTourActivity act) {
+            if (hasPredecessor(act)) {
+                return acts[predecessors[act.index]];
+            }
+            return null;
+        }
+
+        boolean hasSuccessor(IndexedTourActivity act) {
+            return successors[act.index] != -1;
+        }
+
+        boolean hasPredecessor(IndexedTourActivity act) {
+            return predecessors[act.index] != -1;
+        }
+
+        Route copy() {
+            return null;
+        }
+
+        public ActAndIndex indexOf(TourActivity activity) {
+            int i = 0;
+            IndexedTourActivity prev = getFirst();
+            while (hasSuccessor(prev)) {
+                IndexedTourActivity succ = getSuccessor(prev);
+                if (succ.act.getIndex() == activity.getIndex()) {
+                    return new ActAndIndex(i + 1, succ.act);
+                }
+                i++;
+                prev = succ;
+            }
+            return null;
+        }
+
+    }
+
     private static final Logger logger = LoggerFactory.getLogger(GeneralJobInsertionCalculator.class);
 
     private HardRouteConstraint hardRouteLevelConstraint;
@@ -75,7 +246,7 @@ public String toString() {
 
     /**
      * Calculates the marginal cost of inserting job i locally. This is based on the
-     * assumption that cost changes can entirely covered by only looking at the predecessor i-1 and its successor i+1.
+     * assumption that cost changes can entirely covered by only looking at the predecessors i-1 and its successor i+1.
      */
     @Override
     public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job jobToInsert, final Vehicle newVehicle, double newVehicleDepartureTime, final Driver newDriver, final double bestKnownCosts) {
@@ -103,7 +274,12 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
         newRoute.addAll(currentRoute.getTourActivities().getActivities());
         newRoute.add(end);
 
-        List<InsertionData> bestData = calculateInsertionCosts(insertionContext, 1, actList, newRoute, additionalICostsAtRouteLevel, newVehicleDepartureTime);
+        List<IndexedTourActivity> current = makeIndices(newRoute, 0);
+        List<IndexedTourActivity> actsToInsert = makeIndices(actList, current.size());
+        Route route = new Route(current, actsToInsert);
+
+        List<Integer> insertionIndices = new ArrayList<>();
+        List<InsertionData> bestData = calculateInsertionCosts(insertionContext, 0, route.getFirst(), route, actList, additionalICostsAtRouteLevel, newVehicleDepartureTime, insertionIndices);
         if (bestData.isEmpty()) {
             return InsertionData.createEmptyInsertionData();
         } else {
@@ -117,11 +293,22 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
         }
     }
 
-    private List<InsertionData> calculateInsertionCosts(JobInsertionContext insertionContext, int index, List<JobActivity> actList, List<TourActivity> newRoute, double additionalCosts, double departureTime) {
+    private List<IndexedTourActivity> makeIndices(List<? extends TourActivity> acts, int startIndex) {
+        int index = startIndex;
+        List<IndexedTourActivity> indexed = new ArrayList<>();
+        for (TourActivity act : acts) {
+            indexed.add(new IndexedTourActivity(index, act));
+            index++;
+        }
+        return indexed;
+    }
+
+    private List<InsertionData> calculateInsertionCosts(JobInsertionContext insertionContext, int startIndex, IndexedTourActivity startAct, Route route, List<JobActivity> actList, double additionalCosts, double departureTime, List<Integer> insertionIndeces) {
         List<InsertionData> iData = new ArrayList<>();
         double departureTimeAtPrevAct = departureTime;
-        TourActivity prevAct = newRoute.get(index - 1);
-        for (int i = index; i < newRoute.size(); i++) {
+        IndexedTourActivity prevAct = startAct;
+        int index = startIndex;
+        while (route.hasSuccessor(prevAct)) {
             JobActivity jobActivity = actList.get(0);
             if (jobActivity.getTimeWindows().isEmpty()) {
                 throw new IllegalStateException("at least a single time window must be set");
@@ -130,34 +317,38 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
                 JobActivity copiedJobActivity = (JobActivity) jobActivity.duplicate();
                 copiedJobActivity.setTheoreticalEarliestOperationStartTime(timeWindow.getStart());
                 copiedJobActivity.setTheoreticalLatestOperationStartTime(timeWindow.getEnd());
+                //Todo: add correct info, e.g. arrival and end time - assure functionality by unit tests - current no info set, but no unit test fails -> this should not be
                 ActivityContext activityContext = new ActivityContext();
-                activityContext.setInsertionIndex(i);
+                activityContext.setInsertionIndex(index + 1);
+//                activityContext.setArrivalTime();
                 insertionContext.setActivityContext(activityContext);
-                HardActivityConstraint.ConstraintsStatus constraintStatus = hardActivityLevelConstraint.fulfilled(insertionContext, prevAct, copiedJobActivity, newRoute.get(i), departureTimeAtPrevAct);
+                HardActivityConstraint.ConstraintsStatus constraintStatus = hardActivityLevelConstraint.fulfilled(insertionContext, prevAct.act, copiedJobActivity, route.getSuccessor(prevAct).act, departureTimeAtPrevAct);
                 if (constraintStatus.equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED)) {
                     continue;
                 } else if (constraintStatus.equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED_BREAK)) {
                     return iData;
                 }
-                double miscCosts = softActivityConstraint.getCosts(insertionContext, prevAct, copiedJobActivity, newRoute.get(i), departureTimeAtPrevAct);
-                double c = calculate(insertionContext, prevAct, copiedJobActivity, newRoute.get(i), departureTimeAtPrevAct);
-                List<TourActivity> modifiedRoute = new ArrayList<>(newRoute);
-                modifiedRoute.add(i, copiedJobActivity);
+                double miscCosts = softActivityConstraint.getCosts(insertionContext, prevAct.act, copiedJobActivity, route.getSuccessor(prevAct).act, departureTimeAtPrevAct);
+                double c = calculate(insertionContext, prevAct.act, copiedJobActivity, route.getSuccessor(prevAct).act, departureTimeAtPrevAct);
+                IndexedTourActivity toInsert = route.addAfter(copiedJobActivity, prevAct);
                 double totalCosts = additionalCosts + c + miscCosts;
                 if (actList.size() == 1) {
                     InsertionData iD = new InsertionData(totalCosts, insertionContext.getNewDepTime(), insertionContext.getNewVehicle(), insertionContext.getNewDriver());
                     iD.getEvents().add(new SwitchVehicle(insertionContext.getRoute(), insertionContext.getNewVehicle(), insertionContext.getNewDepTime()));
-                    iD.getEvents().addAll(getInsertActivityEvents(insertionContext, modifiedRoute));
+                    iD.getEvents().addAll(getInsertActivityEvents(insertionContext, route));
                     iData.add(iD);
 
                 } else {
-                    double departureTimeFromJobActivity = getDeparture(prevAct, copiedJobActivity, departureTimeAtPrevAct, insertionContext.getNewDriver(), insertionContext.getNewVehicle());
-                    List<InsertionData> insertions = calculateInsertionCosts(insertionContext, i + 1, actList.subList(1, actList.size()), modifiedRoute, totalCosts, departureTimeFromJobActivity);
+                    double departureTimeFromJobActivity = getDeparture(prevAct.act, copiedJobActivity, departureTimeAtPrevAct, insertionContext.getNewDriver(), insertionContext.getNewVehicle());
+                    insertionIndeces.add(index + 1);
+                    List<InsertionData> insertions = calculateInsertionCosts(insertionContext, index + 1, toInsert, route, actList.subList(1, actList.size()), totalCosts, departureTimeFromJobActivity, insertionIndeces);
                     iData.addAll(insertions);
                 }
+                route.remove(toInsert);
             }
-            departureTimeAtPrevAct = getDeparture(prevAct, newRoute.get(i), departureTimeAtPrevAct, insertionContext.getNewDriver(), insertionContext.getNewVehicle());
-            prevAct = newRoute.get(i);
+            departureTimeAtPrevAct = getDeparture(prevAct.act, route.getSuccessor(prevAct).act, departureTimeAtPrevAct, insertionContext.getNewDriver(), insertionContext.getNewVehicle());
+            prevAct = route.getSuccessor(prevAct);
+            index++;
         }
         return iData;
     }
@@ -168,14 +359,13 @@ private double getDeparture(TourActivity prevAct, TourActivity activity, double
         return actStart + activityCosts.getActivityDuration(activity, actArrTime, driver, vehicle);
     }
 
-    private Collection<? extends Event> getInsertActivityEvents(JobInsertionContext insertionContext, List<TourActivity> modifiedRoute) {
+    private Collection<? extends Event> getInsertActivityEvents(JobInsertionContext insertionContext, Route modifiedRoute) {
         List<InsertActivity> insertActivities = new ArrayList<>();
         for (int i = insertionContext.getAssociatedActivities().size() - 1; i >= 0; i--) {
             TourActivity activity = insertionContext.getAssociatedActivities().get(i);
-            int activityIndexInModifiedRoute = modifiedRoute.indexOf(activity);
-            TourActivity activityInModifiedRoute = modifiedRoute.get(activityIndexInModifiedRoute);
+            ActAndIndex actAndIndex = modifiedRoute.indexOf(activity);
             insertActivities.add(new InsertActivity(insertionContext.getRoute(), insertionContext.getNewVehicle(),
-                activityInModifiedRoute, activityIndexInModifiedRoute - i - 1));
+                actAndIndex.act, actAndIndex.index - i - 1));
         }
         return insertActivities;
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionCalculator.java
deleted file mode 100644
index cf93e9be6..000000000
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionCalculator.java
+++ /dev/null
@@ -1,184 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import java.util.Iterator;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import com.graphhopper.jsprit.core.problem.JobActivityFactory;
-import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
-import com.graphhopper.jsprit.core.problem.constraint.HardActivityConstraint;
-import com.graphhopper.jsprit.core.problem.constraint.HardActivityConstraint.ConstraintsStatus;
-import com.graphhopper.jsprit.core.problem.constraint.HardRouteConstraint;
-import com.graphhopper.jsprit.core.problem.constraint.SoftActivityConstraint;
-import com.graphhopper.jsprit.core.problem.constraint.SoftRouteConstraint;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.job.AbstractSingleActivityJob;
-import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.job.Service;
-import com.graphhopper.jsprit.core.problem.misc.ActivityContext;
-import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.Start;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
-
-/**
- * Calculator that calculates the best insertion position for a {@link Service}.
- *
- * @author schroeder
- */
-final class ServiceInsertionCalculator implements JobInsertionCostsCalculator {
-
-    private static final Logger logger = LoggerFactory.getLogger(ServiceInsertionCalculator.class);
-
-    private HardRouteConstraint hardRouteLevelConstraint;
-
-    private HardActivityConstraint hardActivityLevelConstraint;
-
-    private SoftRouteConstraint softRouteConstraint;
-
-    private SoftActivityConstraint softActivityConstraint;
-
-    private VehicleRoutingTransportCosts transportCosts;
-
-    private final VehicleRoutingActivityCosts activityCosts;
-
-    private ActivityInsertionCostsCalculator additionalTransportCostsCalculator;
-
-    private JobActivityFactory activityFactory;
-
-    private AdditionalAccessEgressCalculator additionalAccessEgressCalculator;
-
-    public ServiceInsertionCalculator(VehicleRoutingTransportCosts routingCosts, VehicleRoutingActivityCosts activityCosts, ActivityInsertionCostsCalculator additionalTransportCostsCalculator, ConstraintManager constraintManager) {
-        super();
-        transportCosts = routingCosts;
-        this.activityCosts = activityCosts;
-        hardRouteLevelConstraint = constraintManager;
-        hardActivityLevelConstraint = constraintManager;
-        softActivityConstraint = constraintManager;
-        softRouteConstraint = constraintManager;
-        this.additionalTransportCostsCalculator = additionalTransportCostsCalculator;
-        additionalAccessEgressCalculator = new AdditionalAccessEgressCalculator(routingCosts);
-        logger.debug("initialise {}", this);
-    }
-
-    public void setJobActivityFactory(JobActivityFactory jobActivityFactory) {
-        activityFactory = jobActivityFactory;
-    }
-
-    @Override
-    public String toString() {
-        return "[name=calculatesServiceInsertion]";
-    }
-
-    /**
-     * Calculates the marginal cost of inserting job i locally. This is based on the
-     * assumption that cost changes can entirely covered by only looking at the predecessor i-1 and its successor i+1.
-     */
-    @Override
-    public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job jobToInsert, final Vehicle newVehicle, double newVehicleDepartureTime, final Driver newDriver, final double bestKnownCosts) {
-        JobInsertionContext insertionContext = new JobInsertionContext(currentRoute, jobToInsert, newVehicle, newDriver, newVehicleDepartureTime);
-        AbstractSingleActivityJob<?> service = (AbstractSingleActivityJob<?>) jobToInsert;
-        int insertionIndex = InsertionData.NO_INDEX;
-
-        TourActivity deliveryAct2Insert = activityFactory.createActivities(service).get(0);
-        insertionContext.getAssociatedActivities().add(deliveryAct2Insert);
-
-        /*
-        check hard constraints at route level
-         */
-        if (!hardRouteLevelConstraint.fulfilled(insertionContext)) {
-            return InsertionData.createEmptyInsertionData();
-        }
-
-        /*
-        check soft constraints at route level
-         */
-        double additionalICostsAtRouteLevel = softRouteConstraint.getCosts(insertionContext);
-
-        double bestCost = bestKnownCosts;
-        additionalICostsAtRouteLevel += additionalAccessEgressCalculator.getCosts(insertionContext);
-        TimeWindow bestTimeWindow = null;
-
-        /*
-        generate new start and end for new vehicle
-         */
-        Start start = new Start(newVehicle.getStartLocation(), newVehicle.getEarliestDeparture(), Double.MAX_VALUE);
-        start.setEndTime(newVehicleDepartureTime);
-        End end = new End(newVehicle.getEndLocation(), 0.0, newVehicle.getLatestArrival());
-
-        TourActivity prevAct = start;
-        double prevActStartTime = newVehicleDepartureTime;
-        int actIndex = 0;
-        Iterator<TourActivity> activityIterator = currentRoute.getActivities().iterator();
-        boolean tourEnd = false;
-        while (!tourEnd) {
-            TourActivity nextAct;
-            if (activityIterator.hasNext()) {
-                nextAct = activityIterator.next();
-            } else {
-                nextAct = end;
-                tourEnd = true;
-            }
-            boolean not_fulfilled_break = true;
-            for (TimeWindow timeWindow : service.getTimeWindows()) {
-                deliveryAct2Insert.setTheoreticalEarliestOperationStartTime(timeWindow.getStart());
-                deliveryAct2Insert.setTheoreticalLatestOperationStartTime(timeWindow.getEnd());
-                ActivityContext activityContext = new ActivityContext();
-                activityContext.setInsertionIndex(actIndex);
-                insertionContext.setActivityContext(activityContext);
-                ConstraintsStatus status = hardActivityLevelConstraint.fulfilled(insertionContext, prevAct, deliveryAct2Insert, nextAct, prevActStartTime);
-                if (status.equals(ConstraintsStatus.FULFILLED)) {
-                    double additionalICostsAtActLevel = softActivityConstraint.getCosts(insertionContext, prevAct, deliveryAct2Insert, nextAct, prevActStartTime);
-                    double additionalTransportationCosts = additionalTransportCostsCalculator.getCosts(insertionContext, prevAct, nextAct, deliveryAct2Insert, prevActStartTime);
-                    if (additionalICostsAtRouteLevel + additionalICostsAtActLevel + additionalTransportationCosts < bestCost) {
-                        bestCost = additionalICostsAtRouteLevel + additionalICostsAtActLevel + additionalTransportationCosts;
-                        insertionIndex = actIndex;
-                        bestTimeWindow = timeWindow;
-                    }
-                    not_fulfilled_break = false;
-                } else if (status.equals(ConstraintsStatus.NOT_FULFILLED)) {
-                    not_fulfilled_break = false;
-                }
-            }
-            if (not_fulfilled_break) {
-                break;
-            }
-            double nextActArrTime = prevActStartTime + transportCosts.getTransportTime(prevAct.getLocation(), nextAct.getLocation(), prevActStartTime, newDriver, newVehicle);
-            prevActStartTime = Math.max(nextActArrTime, nextAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct, nextActArrTime, newDriver, newVehicle);
-            prevAct = nextAct;
-            actIndex++;
-        }
-        if (insertionIndex == InsertionData.NO_INDEX) {
-            return InsertionData.createEmptyInsertionData();
-        }
-        InsertionData insertionData = new InsertionData(bestCost, newVehicleDepartureTime, newVehicle, newDriver);
-        deliveryAct2Insert.setTheoreticalEarliestOperationStartTime(bestTimeWindow.getStart());
-        deliveryAct2Insert.setTheoreticalLatestOperationStartTime(bestTimeWindow.getEnd());
-        insertionData.getEvents().add(new InsertActivity(currentRoute, newVehicle, deliveryAct2Insert, insertionIndex));
-        insertionData.getEvents().add(new SwitchVehicle(currentRoute, newVehicle, newVehicleDepartureTime));
-        return insertionData;
-    }
-}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculator.java
deleted file mode 100644
index a3cd313f1..000000000
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculator.java
+++ /dev/null
@@ -1,256 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import com.graphhopper.jsprit.core.problem.JobActivityFactory;
-import com.graphhopper.jsprit.core.problem.constraint.*;
-import com.graphhopper.jsprit.core.problem.constraint.HardActivityConstraint.ConstraintsStatus;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.job.Shipment;
-import com.graphhopper.jsprit.core.problem.misc.ActivityContext;
-import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.Start;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.List;
-
-
-final class ShipmentInsertionCalculator implements JobInsertionCostsCalculator {
-
-    private static final Logger logger = LoggerFactory.getLogger(ShipmentInsertionCalculator.class);
-
-    private HardRouteConstraint hardRouteLevelConstraint;
-
-    private HardActivityConstraint hardActivityLevelConstraint;
-
-    private SoftRouteConstraint softRouteConstraint;
-
-    private SoftActivityConstraint softActivityConstraint;
-
-    private ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
-
-    private VehicleRoutingTransportCosts transportCosts;
-
-    private VehicleRoutingActivityCosts activityCosts;
-
-    private JobActivityFactory activityFactory;
-
-    private AdditionalAccessEgressCalculator additionalAccessEgressCalculator;
-
-    public ShipmentInsertionCalculator(VehicleRoutingTransportCosts routingCosts, VehicleRoutingActivityCosts activityCosts, ActivityInsertionCostsCalculator activityInsertionCostsCalculator, ConstraintManager constraintManager) {
-        super();
-        this.activityInsertionCostsCalculator = activityInsertionCostsCalculator;
-        hardRouteLevelConstraint = constraintManager;
-        hardActivityLevelConstraint = constraintManager;
-        softActivityConstraint = constraintManager;
-        softRouteConstraint = constraintManager;
-        transportCosts = routingCosts;
-        this.activityCosts = activityCosts;
-        additionalAccessEgressCalculator = new AdditionalAccessEgressCalculator(routingCosts);
-        logger.debug("initialise {}", this);
-    }
-
-    public void setJobActivityFactory(JobActivityFactory activityFactory) {
-        this.activityFactory = activityFactory;
-    }
-
-    @Override
-    public String toString() {
-        return "[name=calculatesServiceInsertion]";
-    }
-
-    /**
-     * Calculates the marginal cost of inserting job i locally. This is based on the
-     * assumption that cost changes can entirely covered by only looking at the predecessor i-1 and its successor i+1.
-     */
-    @Override
-    public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job jobToInsert, final Vehicle newVehicle, double newVehicleDepartureTime, final Driver newDriver, final double bestKnownCosts) {
-        JobInsertionContext insertionContext = new JobInsertionContext(currentRoute, jobToInsert, newVehicle, newDriver, newVehicleDepartureTime);
-        Shipment shipment = (Shipment) jobToInsert;
-        // TourActivity pickupShipment =
-        // activityFactory.createActivities(shipment).get(0);
-        // TourActivity deliverShipment =
-        // activityFactory.createActivities(shipment).get(1);
-        TourActivity pickupShipment = shipment.getActivityList().getAll().get(0);
-        TourActivity deliverShipment = shipment.getActivityList().getAll().get(1);
-        insertionContext.getAssociatedActivities().add(pickupShipment);
-        insertionContext.getAssociatedActivities().add(deliverShipment);
-
-        /*
-        check hard route constraints
-         */
-        if (!hardRouteLevelConstraint.fulfilled(insertionContext)) {
-            return InsertionData.createEmptyInsertionData();
-        }
-        /*
-        check soft route constraints
-         */
-        double additionalICostsAtRouteLevel = softRouteConstraint.getCosts(insertionContext);
-
-        double bestCost = bestKnownCosts;
-        additionalICostsAtRouteLevel += additionalAccessEgressCalculator.getCosts(insertionContext);
-
-        int pickupInsertionIndex = InsertionData.NO_INDEX;
-        int deliveryInsertionIndex = InsertionData.NO_INDEX;
-
-        TimeWindow bestPickupTimeWindow = null;
-        TimeWindow bestDeliveryTimeWindow = null;
-
-        Start start = new Start(newVehicle.getStartLocation(), newVehicle.getEarliestDeparture(), newVehicle.getLatestArrival());
-        start.setEndTime(newVehicleDepartureTime);
-
-        End end = new End(newVehicle.getEndLocation(), 0.0, newVehicle.getLatestArrival());
-
-        ActivityContext pickupContext = new ActivityContext();
-
-        TourActivity prevAct = start;
-        double prevActEndTime = newVehicleDepartureTime;
-
-        //loops
-        int i = 0;
-        boolean tourEnd = false;
-        //pickupShipmentLoop
-        List<TourActivity> activities = currentRoute.getTourActivities().getActivities();
-
-        while (!tourEnd) {
-            TourActivity nextAct;
-            if (i < activities.size()) {
-                nextAct = activities.get(i);
-            } else {
-                nextAct = end;
-                tourEnd = true;
-            }
-
-            boolean pickupInsertionNotFulfilledBreak = true;
-            for (TimeWindow pickupTimeWindow : shipment.getPickupTimeWindows()) {
-                pickupShipment.setTheoreticalEarliestOperationStartTime(pickupTimeWindow.getStart());
-                pickupShipment.setTheoreticalLatestOperationStartTime(pickupTimeWindow.getEnd());
-                ActivityContext activityContext = new ActivityContext();
-                activityContext.setInsertionIndex(i);
-                insertionContext.setActivityContext(activityContext);
-                ConstraintsStatus pickupShipmentConstraintStatus = hardActivityLevelConstraint.fulfilled(insertionContext, prevAct, pickupShipment, nextAct, prevActEndTime);
-                if (pickupShipmentConstraintStatus.equals(ConstraintsStatus.NOT_FULFILLED)) {
-                    pickupInsertionNotFulfilledBreak = false;
-                    continue;
-                } else if (pickupShipmentConstraintStatus.equals(ConstraintsStatus.NOT_FULFILLED_BREAK)) {
-                    continue;
-                } else if (pickupShipmentConstraintStatus.equals(ConstraintsStatus.FULFILLED)) {
-                    pickupInsertionNotFulfilledBreak = false;
-                }
-                double additionalPickupICosts = softActivityConstraint.getCosts(insertionContext, prevAct, pickupShipment, nextAct, prevActEndTime);
-                double pickupAIC = calculate(insertionContext, prevAct, pickupShipment, nextAct, prevActEndTime);
-
-                TourActivity prevAct_deliveryLoop = pickupShipment;
-                double shipmentPickupArrTime = prevActEndTime + transportCosts.getTransportTime(prevAct.getLocation(), pickupShipment.getLocation(), prevActEndTime, newDriver, newVehicle);
-                double shipmentPickupEndTime = Math.max(shipmentPickupArrTime, pickupShipment.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(pickupShipment, shipmentPickupArrTime, newDriver, newVehicle);
-
-                pickupContext.setArrivalTime(shipmentPickupArrTime);
-                pickupContext.setEndTime(shipmentPickupEndTime);
-                pickupContext.setInsertionIndex(i);
-                insertionContext.setRelatedActivityContext(pickupContext);
-
-                double prevActEndTime_deliveryLoop = shipmentPickupEndTime;
-
-                /*
-            --------------------------------
-                 */
-                //deliverShipmentLoop
-                int j = i;
-                boolean tourEnd_deliveryLoop = false;
-                while (!tourEnd_deliveryLoop) {
-                    TourActivity nextAct_deliveryLoop;
-                    if (j < activities.size()) {
-                        nextAct_deliveryLoop = activities.get(j);
-                    } else {
-                        nextAct_deliveryLoop = end;
-                        tourEnd_deliveryLoop = true;
-                    }
-
-                    boolean deliveryInsertionNotFulfilledBreak = true;
-                    for (TimeWindow deliveryTimeWindow : shipment.getDeliveryTimeWindows()) {
-                        deliverShipment.setTheoreticalEarliestOperationStartTime(deliveryTimeWindow.getStart());
-                        deliverShipment.setTheoreticalLatestOperationStartTime(deliveryTimeWindow.getEnd());
-                        ActivityContext activityContext_ = new ActivityContext();
-                        activityContext_.setInsertionIndex(j);
-                        insertionContext.setActivityContext(activityContext_);
-                        ConstraintsStatus deliverShipmentConstraintStatus = hardActivityLevelConstraint.fulfilled(insertionContext, prevAct_deliveryLoop, deliverShipment, nextAct_deliveryLoop, prevActEndTime_deliveryLoop);
-                        if (deliverShipmentConstraintStatus.equals(ConstraintsStatus.FULFILLED)) {
-                            double additionalDeliveryICosts = softActivityConstraint.getCosts(insertionContext, prevAct_deliveryLoop, deliverShipment, nextAct_deliveryLoop, prevActEndTime_deliveryLoop);
-                            double deliveryAIC = calculate(insertionContext, prevAct_deliveryLoop, deliverShipment, nextAct_deliveryLoop, prevActEndTime_deliveryLoop);
-                            double totalActivityInsertionCosts = pickupAIC + deliveryAIC
-                                + additionalICostsAtRouteLevel + additionalPickupICosts + additionalDeliveryICosts;
-                            if (totalActivityInsertionCosts < bestCost) {
-                                bestCost = totalActivityInsertionCosts;
-                                pickupInsertionIndex = i;
-                                deliveryInsertionIndex = j;
-                                bestPickupTimeWindow = pickupTimeWindow;
-                                bestDeliveryTimeWindow = deliveryTimeWindow;
-                            }
-                            deliveryInsertionNotFulfilledBreak = false;
-                        } else if (deliverShipmentConstraintStatus.equals(ConstraintsStatus.NOT_FULFILLED)) {
-                            deliveryInsertionNotFulfilledBreak = false;
-                        }
-                    }
-                    if (deliveryInsertionNotFulfilledBreak) {
-                        break;
-                    }
-                    //update prevAct and endTime
-                    double nextActArrTime = prevActEndTime_deliveryLoop + transportCosts.getTransportTime(prevAct_deliveryLoop.getLocation(), nextAct_deliveryLoop.getLocation(), prevActEndTime_deliveryLoop, newDriver, newVehicle);
-                    prevActEndTime_deliveryLoop = Math.max(nextActArrTime, nextAct_deliveryLoop.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct_deliveryLoop, nextActArrTime, newDriver, newVehicle);
-                    prevAct_deliveryLoop = nextAct_deliveryLoop;
-                    j++;
-                }
-            }
-            if (pickupInsertionNotFulfilledBreak) {
-                break;
-            }
-            //update prevAct and endTime
-            double nextActArrTime = prevActEndTime + transportCosts.getTransportTime(prevAct.getLocation(), nextAct.getLocation(), prevActEndTime, newDriver, newVehicle);
-            prevActEndTime = Math.max(nextActArrTime, nextAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct, nextActArrTime, newDriver, newVehicle);
-            prevAct = nextAct;
-            i++;
-        }
-        if (pickupInsertionIndex == InsertionData.NO_INDEX) {
-            return InsertionData.createEmptyInsertionData();
-        }
-        InsertionData insertionData = new InsertionData(bestCost, pickupInsertionIndex, deliveryInsertionIndex, newVehicle, newDriver);
-        pickupShipment.setTheoreticalEarliestOperationStartTime(bestPickupTimeWindow.getStart());
-        pickupShipment.setTheoreticalLatestOperationStartTime(bestPickupTimeWindow.getEnd());
-        deliverShipment.setTheoreticalEarliestOperationStartTime(bestDeliveryTimeWindow.getStart());
-        deliverShipment.setTheoreticalLatestOperationStartTime(bestDeliveryTimeWindow.getEnd());
-        insertionData.setVehicleDepartureTime(newVehicleDepartureTime);
-        insertionData.getEvents().add(new InsertActivity(currentRoute, newVehicle, deliverShipment, deliveryInsertionIndex));
-        insertionData.getEvents().add(new InsertActivity(currentRoute, newVehicle, pickupShipment, pickupInsertionIndex));
-        insertionData.getEvents().add(new SwitchVehicle(currentRoute, newVehicle, newVehicleDepartureTime));
-        return insertionData;
-    }
-
-    private double calculate(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double departureTimeAtPrevAct) {
-        return activityInsertionCostsCalculator.getCosts(iFacts, prevAct, nextAct, newAct, departureTimeAtPrevAct);
-
-    }
-}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculatorTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculatorTest.java
new file mode 100644
index 000000000..672908768
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionCalculatorTest.java
@@ -0,0 +1,95 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.graphhopper.jsprit.core.algorithm.recreate;
+
+
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.Arrays;
+
+import static org.mockito.Mockito.mock;
+
+/**
+ * Created by schroeder on 19/11/16.
+ */
+public class GeneralJobInsertionCalculatorTest {
+
+    GeneralJobInsertionCalculator.IndexedTourActivity start;
+
+    GeneralJobInsertionCalculator.IndexedTourActivity act;
+
+    GeneralJobInsertionCalculator.IndexedTourActivity end;
+
+    GeneralJobInsertionCalculator.IndexedTourActivity toInsert;
+
+    @Before
+    public void doBefore() {
+        start = new GeneralJobInsertionCalculator.IndexedTourActivity(0, mock(TourActivity.class));
+        act = new GeneralJobInsertionCalculator.IndexedTourActivity(1, mock(TourActivity.class));
+        end = new GeneralJobInsertionCalculator.IndexedTourActivity(2, mock(TourActivity.class));
+        toInsert = new GeneralJobInsertionCalculator.IndexedTourActivity(3, mock(TourActivity.class));
+    }
+
+    @Test
+    public void testSuccessor() {
+        GeneralJobInsertionCalculator.Route route = new GeneralJobInsertionCalculator.Route(Arrays.asList(start, act, end), Arrays.asList(toInsert));
+        Assert.assertEquals(start, route.getFirst());
+        Assert.assertEquals(act, route.getSuccessor(route.getFirst()));
+        Assert.assertEquals(end, route.getSuccessor(act));
+        Assert.assertEquals(null, route.getSuccessor(toInsert));
+    }
+
+    @Test
+    public void testPredecessor() {
+        GeneralJobInsertionCalculator.Route route = new GeneralJobInsertionCalculator.Route(Arrays.asList(start, act, end), Arrays.asList(toInsert));
+        Assert.assertEquals(null, route.getPredecessor(route.getFirst()));
+        Assert.assertEquals(route.getFirst(), route.getPredecessor(act));
+        Assert.assertEquals(act, route.getPredecessor(route.getSuccessor(act)));
+        Assert.assertEquals(null, route.getSuccessor(toInsert));
+    }
+
+    @Test
+    public void insertNew() {
+        GeneralJobInsertionCalculator.Route route = new GeneralJobInsertionCalculator.Route(Arrays.asList(start, act, end), Arrays.asList(toInsert));
+        Assert.assertEquals(route.getFirst(), route.getPredecessor(act));
+        route.addAfter(toInsert, route.getFirst());
+        Assert.assertEquals(toInsert, route.getPredecessor(act));
+        Assert.assertEquals(route.getFirst(), route.getPredecessor(toInsert));
+        Assert.assertEquals(start, route.getFirst());
+        Assert.assertEquals(toInsert, route.getSuccessor(route.getFirst()));
+        Assert.assertEquals(act, route.getSuccessor(toInsert));
+    }
+
+    @Test
+    public void removeAct() {
+        GeneralJobInsertionCalculator.Route route = new GeneralJobInsertionCalculator.Route(Arrays.asList(start, act, end), Arrays.asList(toInsert));
+        Assert.assertEquals(route.getFirst(), route.getPredecessor(act));
+        route.remove(act);
+        Assert.assertEquals(null, route.getPredecessor(act));
+        Assert.assertEquals(null, route.getSuccessor(act));
+        Assert.assertEquals(start, route.getFirst());
+        Assert.assertEquals(end, route.getSuccessor(start));
+
+    }
+
+
+}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithShipmentsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithShipmentsTest.java
index 9fb1bdbfb..0ff8d5662 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithShipmentsTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/GeneralJobInsertionWithShipmentsTest.java
@@ -17,16 +17,6 @@
  */
 package com.graphhopper.jsprit.core.algorithm.recreate;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-
-import java.util.Arrays;
-import java.util.List;
-
-import org.junit.Before;
-import org.junit.Test;
-
 import com.graphhopper.jsprit.core.algorithm.state.StateManager;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
@@ -50,6 +40,15 @@
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
 import com.graphhopper.jsprit.core.util.CostFactory;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.Arrays;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
 
 
 public class GeneralJobInsertionWithShipmentsTest {
@@ -106,6 +105,7 @@ private void createInsertionCalculator(HardRouteConstraint hardRouteLevelConstra
     @Test
     public void whenCalculatingInsertionCostsOfShipment_itShouldReturnCorrectCostValue() {
         Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
+        VehicleRoutingProblem.Builder.newInstance().addJob(shipment).build();
         VehicleRoute route = VehicleRoute.emptyRoute();
         InsertionData iData = insertionCalculator.getInsertionData(route, shipment, vehicle, 0.0, null, Double.MAX_VALUE);
         assertEquals(40.0, iData.getInsertionCost(), 0.05);
@@ -115,6 +115,9 @@ public void whenCalculatingInsertionCostsOfShipment_itShouldReturnCorrectCostVal
     public void whenCalculatingInsertionIntoExistingRoute_itShouldReturnCorrectCosts() {
         Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
         Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
+
+        VehicleRoutingProblem.Builder.newInstance().addJob(shipment).addJob(shipment2).build();
+
         VehicleRoute route = VehicleRoute.emptyRoute();
         List<JobActivity> tourActivities = shipment.getActivityList().getAll();
         route.setVehicleAndDepartureTime(vehicle, 0);
@@ -131,6 +134,9 @@ public void whenCalculatingInsertionIntoExistingRoute_itShouldReturnCorrectCosts
     public void whenInsertingShipmentInRouteWithNotEnoughCapacity_itShouldReturnNoInsertion() {
         Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
         Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
+
+        VehicleRoutingProblem.Builder.newInstance().addJob(shipment).addJob(shipment2).build();
+
         VehicleRoute route = VehicleRoute.emptyRoute();
         List<JobActivity> tourActivities = shipment.getActivityList().getAll();
         route.setVehicleAndDepartureTime(vehicle, 0);
@@ -150,6 +156,8 @@ public void whenInsertingThirdShipment_itShouldCalcCorrectVal() {
         Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
         Shipment shipment3 = Shipment.Builder.newInstance("s3").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("9,10")).build();
 
+        VehicleRoutingProblem.Builder.newInstance().addJob(shipment).addJob(shipment2).addJob(shipment3).build();
+
         VehicleRoute route = VehicleRoute.emptyRoute();
         List<JobActivity> shipmentActivities = shipment.getActivityList().getAll();
         List<JobActivity> shipment2Activities = shipment2.getActivityList().getAll();
@@ -170,6 +178,9 @@ public void whenInsertingThirdShipment_itShouldCalcCorrectVal2() {
         Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
         Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
         Shipment shipment3 = Shipment.Builder.newInstance("s3").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("9,9")).build();
+
+        VehicleRoutingProblem.Builder.newInstance().addJob(shipment).addJob(shipment2).addJob(shipment3).build();
+
         List<JobActivity> shipmentActivities = shipment.getActivityList().getAll();
         List<JobActivity> shipment2Activities = shipment2.getActivityList().getAll();
         VehicleRoute route = VehicleRoute.emptyRoute();
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionAndLoadConstraintsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionAndLoadConstraintsTest.java
deleted file mode 100644
index 701084f3e..000000000
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionAndLoadConstraintsTest.java
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import com.graphhopper.jsprit.core.algorithm.state.StateManager;
-import com.graphhopper.jsprit.core.problem.CopyJobActivityFactory;
-import com.graphhopper.jsprit.core.problem.JobActivityFactory;
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
-import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
-import com.graphhopper.jsprit.core.problem.constraint.HardActivityConstraint;
-import com.graphhopper.jsprit.core.problem.constraint.HardRouteConstraint;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.driver.DriverImpl;
-import com.graphhopper.jsprit.core.problem.job.Delivery;
-import com.graphhopper.jsprit.core.problem.job.Pickup;
-import com.graphhopper.jsprit.core.problem.job.Shipment;
-import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.state.RouteAndActivityStateGetter;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
-import com.graphhopper.jsprit.core.util.CostFactory;
-import org.junit.Before;
-import org.junit.Test;
-
-import java.util.Arrays;
-import java.util.List;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-
-
-public class ServiceInsertionAndLoadConstraintsTest {
-
-    VehicleRoutingTransportCosts routingCosts;
-
-    VehicleRoutingActivityCosts activityCosts = new VehicleRoutingActivityCosts() {
-
-        @Override
-        public double getActivityCost(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
-            return 0;
-        }
-
-        @Override
-        public double getActivityDuration(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
-            return tourAct.getOperationTime();
-        }
-
-    };
-
-    HardActivityConstraint hardActivityLevelConstraint = new HardActivityConstraint() {
-
-        @Override
-        public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime) {
-            return ConstraintsStatus.FULFILLED;
-        }
-    };
-
-    HardRouteConstraint hardRouteLevelConstraint = new HardRouteConstraint() {
-
-        @Override
-        public boolean fulfilled(JobInsertionContext insertionContext) {
-            return true;
-        }
-
-    };
-
-    ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
-
-    ShipmentInsertionCalculator insertionCalculator;
-
-    VehicleRoutingProblem vehicleRoutingProblem;
-
-    Vehicle vehicle;
-
-    @Before
-    public void doBefore() {
-        routingCosts = CostFactory.createManhattanCosts();
-        VehicleType type = VehicleTypeImpl.Builder.newInstance("t").addCapacityDimension(0, 2).setCostPerDistance(1).build();
-        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("0,0")).setType(type).build();
-        activityInsertionCostsCalculator = new LocalActivityInsertionCostsCalculator(routingCosts, activityCosts, mock(StateManager.class));
-        createInsertionCalculator(hardRouteLevelConstraint);
-        vehicleRoutingProblem = mock(VehicleRoutingProblem.class);
-    }
-
-    private void createInsertionCalculator(HardRouteConstraint hardRouteLevelConstraint) {
-        ConstraintManager constraintManager = new ConstraintManager(mock(VehicleRoutingProblem.class), mock(RouteAndActivityStateGetter.class));
-        constraintManager.addConstraint(hardRouteLevelConstraint);
-        insertionCalculator = new ShipmentInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
-    }
-
-    @Test
-    public void whenInsertingServiceWhileNoCapIsAvailable_itMustReturnTheCorrectInsertionIndex() {
-        Delivery delivery = new Delivery.Builder("del").addSizeDimension(0, 41).setLocation(Location.newInstance("10,10")).build();
-        Pickup pickup = new Pickup.Builder("pick").addSizeDimension(0, 15).setLocation(Location.newInstance("0,10")).build();
-
-        VehicleType type = VehicleTypeImpl.Builder.newInstance("t").addCapacityDimension(0, 50).setCostPerDistance(1).build();
-        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("0,0")).setType(type).build();
-
-        final VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(delivery).addJob(pickup).addVehicle(vehicle).build();
-
-        VehicleRoute route = VehicleRoute.emptyRoute();
-        route.setVehicleAndDepartureTime(vehicle, 0.0);
-
-        route.getTourActivities().addActivity(0, vrp.copyAndGetActivities(delivery).get(0));
-
-        JobActivityFactory activityFactory = new CopyJobActivityFactory();
-
-        StateManager stateManager = new StateManager(vrp);
-        stateManager.updateLoadStates();
-
-        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
-        constraintManager.addLoadConstraint();
-        stateManager.informInsertionStarts(Arrays.asList(route), null);
-
-        JobCalculatorSwitcher switcher = new JobCalculatorSwitcher();
-        ServiceInsertionCalculator serviceInsertionCalc = new ServiceInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
-        serviceInsertionCalc.setJobActivityFactory(activityFactory);
-        ShipmentInsertionCalculator insertionCalculator = new ShipmentInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
-        insertionCalculator.setJobActivityFactory(activityFactory);
-
-        switcher.put(Pickup.class, serviceInsertionCalc);
-        switcher.put(Delivery.class, serviceInsertionCalc);
-        switcher.put(Shipment.class, insertionCalculator);
-
-        InsertionData iData = switcher.getInsertionData(route, pickup, vehicle, 0, DriverImpl.noDriver(), Double.MAX_VALUE);
-        List<InsertActivity> insertActivities = iData.getUnmodifiableEventsByType(InsertActivity.class);
-        assertEquals(1, insertActivities.get(0).getIndex());
-    }
-
-}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculatorTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculatorTest.java
deleted file mode 100644
index bf12e2319..000000000
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculatorTest.java
+++ /dev/null
@@ -1,316 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import com.graphhopper.jsprit.core.algorithm.state.StateManager;
-import com.graphhopper.jsprit.core.problem.JobActivityFactory;
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
-import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
-import com.graphhopper.jsprit.core.problem.constraint.HardRouteConstraint;
-import com.graphhopper.jsprit.core.problem.constraint.PickupAndDeliverShipmentLoadActivityLevelConstraint;
-import com.graphhopper.jsprit.core.problem.constraint.ShipmentPickupsFirstConstraint;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.driver.DriverImpl;
-import com.graphhopper.jsprit.core.problem.job.Pickup;
-import com.graphhopper.jsprit.core.problem.job.Service;
-import com.graphhopper.jsprit.core.problem.job.Shipment;
-import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.state.RouteAndActivityStateGetter;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
-import com.graphhopper.jsprit.core.util.CostFactory;
-
-
-public class ShipmentInsertionCalculatorTest {
-
-    VehicleRoutingTransportCosts routingCosts;
-
-    VehicleRoutingProblem vehicleRoutingProblem;
-
-    VehicleRoutingActivityCosts activityCosts = new VehicleRoutingActivityCosts() {
-
-        @Override
-        public double getActivityCost(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
-            return 0;
-        }
-
-        @Override
-        public double getActivityDuration(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
-            return tourAct.getOperationTime();
-        }
-
-    };
-
-    HardRouteConstraint hardRouteLevelConstraint = new HardRouteConstraint() {
-
-        @Override
-        public boolean fulfilled(JobInsertionContext insertionContext) {
-            return true;
-        }
-
-    };
-
-    ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
-
-    ShipmentInsertionCalculator insertionCalculator;
-
-    Vehicle vehicle;
-
-    @Before
-    public void doBefore() {
-        routingCosts = CostFactory.createManhattanCosts();
-        VehicleType type = VehicleTypeImpl.Builder.newInstance("t").addCapacityDimension(0, 2).setCostPerDistance(1).build();
-        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("0,0")).setType(type).build();
-        activityInsertionCostsCalculator = new LocalActivityInsertionCostsCalculator(routingCosts, activityCosts, mock(StateManager.class));
-        createInsertionCalculator(hardRouteLevelConstraint);
-        vehicleRoutingProblem = mock(VehicleRoutingProblem.class);
-    }
-
-    private void createInsertionCalculator(HardRouteConstraint hardRouteLevelConstraint) {
-        ConstraintManager constraintManager = new ConstraintManager(mock(VehicleRoutingProblem.class), mock(RouteAndActivityStateGetter.class));
-        constraintManager.addConstraint(hardRouteLevelConstraint);
-        insertionCalculator = new ShipmentInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
-    }
-
-    @Test
-    public void whenCalculatingInsertionCostsOfShipment_itShouldReturnCorrectCostValue() {
-        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
-        VehicleRoute route = VehicleRoute.emptyRoute();
-        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
-        List<JobActivity> activities = new ArrayList<>();
-        activities.add(shipment.getPickupActivity());
-        activities.add(shipment.getDeliveryActivity());
-        when(activityFactory.createActivities(shipment)).thenReturn(activities);
-        insertionCalculator.setJobActivityFactory(activityFactory);
-        InsertionData iData = insertionCalculator.getInsertionData(route, shipment, vehicle, 0.0, null, Double.MAX_VALUE);
-        assertEquals(40.0, iData.getInsertionCost(), 0.05);
-    }
-
-    @Test
-    public void whenCalculatingInsertionIntoExistingRoute_itShouldReturnCorrectCosts() {
-        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
-        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
-        VehicleRoute route = VehicleRoute.emptyRoute();
-        List<JobActivity> tourActivities = shipment.getActivityList().getAll();
-        route.setVehicleAndDepartureTime(vehicle, 0);
-        add(tourActivities, route, 0, 0);
-
-        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
-        List<JobActivity> activities = new ArrayList<>();
-        activities.add(shipment.getPickupActivity());
-        activities.add(shipment.getDeliveryActivity());
-        when(activityFactory.createActivities(shipment2)).thenReturn(activities);
-        insertionCalculator.setJobActivityFactory(activityFactory);
-
-        InsertionData iData = insertionCalculator.getInsertionData(route, shipment2, vehicle, 0.0, null, Double.MAX_VALUE);
-        assertEquals(0.0, iData.getInsertionCost(), 0.05);
-        assertEquals(1, iData.getUnmodifiableEventsByType(InsertActivity.class).get(1).getIndex());
-        assertEquals(2, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-
-    @Test
-    public void whenInsertingShipmentInRouteWithNotEnoughCapacity_itShouldReturnNoInsertion() {
-        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
-        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
-        VehicleRoute route = VehicleRoute.emptyRoute();
-        List<JobActivity> tourActivities = shipment.getActivityList().getAll();
-        route.setVehicleAndDepartureTime(vehicle, 0);
-        add(tourActivities, route, 0, 0);
-
-        createInsertionCalculator(insertionContext -> false);
-
-        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
-        List<JobActivity> activities = new ArrayList<JobActivity>();
-        activities.add(shipment2.getPickupActivity());
-        activities.add(shipment2.getDeliveryActivity());
-        when(activityFactory.createActivities(shipment2)).thenReturn(activities);
-        insertionCalculator.setJobActivityFactory(activityFactory);
-
-        InsertionData iData = insertionCalculator.getInsertionData(route, shipment2, vehicle, 0.0, null, Double.MAX_VALUE);
-        assertEquals(InsertionData.createEmptyInsertionData(), iData);
-
-    }
-
-
-    @Test
-    public void whenInsertingThirdShipment_itShouldCalcCorrectVal() {
-        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
-        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
-        Shipment shipment3 = Shipment.Builder.newInstance("s3").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("9,10")).build();
-
-        VehicleRoute route = VehicleRoute.emptyRoute();
-        List<JobActivity> shipmentActivities = shipment.getActivityList().getAll();
-        List<JobActivity> shipment2Activities = shipment2.getActivityList().getAll();
-
-        route.setVehicleAndDepartureTime(vehicle, 0d);
-        add(shipmentActivities, route, 0, 0);
-        add(shipment2Activities, route, 1, 2);
-
-        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
-        List<JobActivity> activities = new ArrayList<>();
-        activities.add(shipment3.getPickupActivity());
-        activities.add(shipment3.getDeliveryActivity());
-        when(activityFactory.createActivities(shipment3)).thenReturn(activities);
-        insertionCalculator.setJobActivityFactory(activityFactory);
-
-        InsertionData iData = insertionCalculator.getInsertionData(route, shipment3, vehicle, 0.0, null, Double.MAX_VALUE);
-        assertEquals(0.0, iData.getInsertionCost(), 0.05);
-        List<InsertActivity> unmodifiableEventsByType = iData.getUnmodifiableEventsByType(InsertActivity.class);
-        assertEquals(1, unmodifiableEventsByType.get(0).getIndex());
-        assertEquals(0, unmodifiableEventsByType.get(1).getIndex());
-    }
-
-    @Test
-    public void whenInsertingThirdShipment_itShouldCalcCorrectVal2() {
-        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
-        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
-        Shipment shipment3 = Shipment.Builder.newInstance("s3").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("9,9")).build();
-        List<JobActivity> shipmentActivities = shipment.getActivityList().getAll();
-        List<JobActivity> shipment2Activities = shipment2.getActivityList().getAll();
-        VehicleRoute route = VehicleRoute.emptyRoute();
-
-        route.setVehicleAndDepartureTime(vehicle, 0d);
-        add(shipmentActivities, route, 0, 0);
-        add(shipment2Activities, route, 1, 2);
-
-        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
-        List<JobActivity> activities = new ArrayList<>();
-        activities.add(shipment3.getPickupActivity());
-        activities.add(shipment3.getDeliveryActivity());
-        when(activityFactory.createActivities(shipment3)).thenReturn(activities);
-        insertionCalculator.setJobActivityFactory(activityFactory);
-
-
-        InsertionData iData = insertionCalculator.getInsertionData(route, shipment3, vehicle, 0.0, null, Double.MAX_VALUE);
-        assertEquals(2.0, iData.getInsertionCost(), 0.05);
-        assertEquals(0, iData.getUnmodifiableEventsByType(InsertActivity.class).get(1).getIndex());
-        assertEquals(1, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-    @Test
-    public void whenInstertingShipmentWithLoadConstraintWhereCapIsNotSufficient_capConstraintsAreFulfilled() {
-        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
-        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
-        Shipment shipment3 = Shipment.Builder.newInstance("s3").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("9,9")).build();
-
-        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
-        VehicleRoutingProblem vrp = vrpBuilder.addJob(shipment).addJob(shipment2).addJob(shipment3).build();
-
-        VehicleRoute route = VehicleRoute.emptyRoute();
-        route.setVehicleAndDepartureTime(vehicle, 0.0);
-
-        add(vrp, route, shipment, 0, 0);
-        add(vrp, route, shipment2, 1, 2);
-
-        StateManager stateManager = new StateManager(vrp);
-        stateManager.updateLoadStates();
-        stateManager.informInsertionStarts(Arrays.asList(route), null);
-
-        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
-        constraintManager.addConstraint(new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager), ConstraintManager.Priority.CRITICAL);
-        constraintManager.addConstraint(new ShipmentPickupsFirstConstraint(), ConstraintManager.Priority.CRITICAL);
-
-        ShipmentInsertionCalculator insertionCalculator = new ShipmentInsertionCalculator(routingCosts, activityCosts,
-                        activityInsertionCostsCalculator, constraintManager);
-        insertionCalculator.setJobActivityFactory(vrp.getJobActivityFactory());
-
-        InsertionData iData = insertionCalculator.getInsertionData(route, shipment3, vehicle, 0.0, DriverImpl.noDriver(), Double.MAX_VALUE);
-        assertTrue(iData instanceof InsertionData.NoInsertionFound);
-
-    }
-
-    @Test
-    public void whenInsertingServiceWhileNoCapIsAvailable_itMustReturnNoInsertionData() {
-        Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
-        Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
-
-        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
-        VehicleRoutingProblem vrp = vrpBuilder.addJob(shipment).addJob(shipment2).build();
-
-        VehicleRoute route = VehicleRoute.emptyRoute();
-        route.setVehicleAndDepartureTime(vehicle, 0.0);
-
-        add(vrp, route, shipment, 0, 0);
-        add(vrp, route, shipment2, 1, 2);
-
-        StateManager stateManager = new StateManager(vrp);
-        stateManager.updateLoadStates();
-        stateManager.informInsertionStarts(Arrays.asList(route), null);
-
-        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
-        constraintManager.addLoadConstraint();
-
-        stateManager.informInsertionStarts(Arrays.asList(route), null);
-
-        JobCalculatorSwitcher switcher = new JobCalculatorSwitcher();
-        ServiceInsertionCalculator serviceInsertionCalc = new ServiceInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
-        ShipmentInsertionCalculator insertionCalculator = new ShipmentInsertionCalculator(routingCosts, activityCosts, activityInsertionCostsCalculator, constraintManager);
-        switcher.put(Pickup.class, serviceInsertionCalc);
-        switcher.put(Service.class, serviceInsertionCalc);
-        switcher.put(Shipment.class, insertionCalculator);
-
-        //		Service service = new Service.Builder("pick", 1).setLocationId("5,5").build();
-        Pickup service = new Pickup.Builder("pick").addSizeDimension(0, 1).setLocation(Location.newInstance("5,5")).build();
-
-        JobActivityFactory activityFactory = mock(JobActivityFactory.class);
-        List<JobActivity> activities = new ArrayList<>();
-        activities.add(service.getActivity());
-        when(activityFactory.createActivities(service)).thenReturn(activities);
-        insertionCalculator.setJobActivityFactory(activityFactory);
-        serviceInsertionCalc.setJobActivityFactory(activityFactory);
-
-        InsertionData iData = switcher.getInsertionData(route, service, vehicle, 0, DriverImpl.noDriver(), Double.MAX_VALUE);
-        //		routeActVisitor.visit(route);
-
-        assertEquals(3, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-    private void add(VehicleRoutingProblem vrp, VehicleRoute route, Shipment shipment, int pickI, int delI) {
-        List<JobActivity> shipmentActivities = vrp.copyAndGetActivities(shipment);
-        route.getTourActivities().addActivity(delI, shipmentActivities.get(1));
-        route.getTourActivities().addActivity(pickI, shipmentActivities.get(0));
-    }
-
-    private void add(List<JobActivity> shipmentActivities, VehicleRoute route, int pickI, int delI) {
-        route.getTourActivities().addActivity(delI, shipmentActivities.get(1));
-        route.getTourActivities().addActivity(pickI, shipmentActivities.get(0));
-    }
-
-
-}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertion.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertion.java
deleted file mode 100644
index 9f38aa06d..000000000
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertion.java
+++ /dev/null
@@ -1,255 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import com.graphhopper.jsprit.core.algorithm.state.StateManager;
-import com.graphhopper.jsprit.core.distance.EuclideanDistanceCalculator;
-import com.graphhopper.jsprit.core.distance.ManhattanDistanceCalculator;
-import com.graphhopper.jsprit.core.problem.CopyJobActivityFactory;
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
-import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
-import com.graphhopper.jsprit.core.problem.cost.AbstractForwardVehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.driver.DriverImpl;
-import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.job.Service;
-import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
-import com.graphhopper.jsprit.core.util.Coordinate;
-import com.graphhopper.jsprit.core.util.Locations;
-import org.junit.Before;
-import org.junit.Test;
-
-import java.util.*;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-
-
-public class TestCalculatesServiceInsertion {
-
-    ServiceInsertionCalculator serviceInsertion;
-
-    VehicleRoutingTransportCosts costs;
-
-    VehicleImpl vehicle;
-
-    VehicleImpl newVehicle;
-
-    private Service first;
-
-    private Service third;
-
-    private Service second;
-
-    private StateManager states;
-
-    private DriverImpl.NoDriver driver;
-
-    private VehicleRoutingProblem vrp;
-
-    @Before
-    public void setup() {
-
-        VehicleType t1 = VehicleTypeImpl.Builder.newInstance("t1").addCapacityDimension(0, 1000).setCostPerDistance(1.0).build();
-        vehicle = VehicleImpl.Builder.newInstance("vehicle").setLatestArrival(100.0).setStartLocation(Location.newInstance("0,0")).setType(t1).build();
-
-        VehicleType t2 = VehicleTypeImpl.Builder.newInstance("t2").addCapacityDimension(0, 1000).setCostPerDistance(2.0).build();
-        newVehicle = VehicleImpl.Builder.newInstance("newVehicle").setLatestArrival(100.0).setStartLocation(Location.newInstance("0,0")).setType(t2).build();
-
-        driver = DriverImpl.noDriver();
-
-        final Locations locations = new Locations() {
-
-            @Override
-            public Coordinate getCoord(String id) {
-                //assume: locationId="x,y"
-                String[] splitted = id.split(",");
-                return Coordinate.newInstance(Double.parseDouble(splitted[0]),
-                    Double.parseDouble(splitted[1]));
-            }
-
-        };
-        costs = new AbstractForwardVehicleRoutingTransportCosts() {
-
-            @Override
-            public double getTransportTime(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-                return ManhattanDistanceCalculator.getInstance().calculateDistance(
-                    locations.getCoord(from.getId()), locations.getCoord(to.getId()));
-            }
-
-            @Override
-            public double getTransportCost(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-                return vehicle.getType().getVehicleCostParams().perDistanceUnit
-                    * ManhattanDistanceCalculator.getInstance().calculateDistance(
-                    locations.getCoord(from.getId()),
-                    locations.getCoord(to.getId()));
-            }
-        };
-
-
-        first = new Service.Builder("1").addSizeDimension(0, 0).setLocation(Location.newInstance("0,10")).setTimeWindow(TimeWindow.newInstance(0.0, 100.0)).build();
-        second = new Service.Builder("2").addSizeDimension(0, 0).setLocation(Location.newInstance("10,10")).setTimeWindow(TimeWindow.newInstance(0.0, 100.0)).build();
-        third = new Service.Builder("3").addSizeDimension(0, 0).setLocation(Location.newInstance("10,0")).setTimeWindow(TimeWindow.newInstance(0.0, 100.0)).build();
-
-        Collection<Job> jobs = new ArrayList<Job>();
-        jobs.add(first);
-        jobs.add(third);
-        jobs.add(second);
-
-        vrp = VehicleRoutingProblem.Builder.newInstance().addAllJobs(jobs)
-            .addVehicle(vehicle).setRoutingCost(costs).build();
-
-        states = new StateManager(vrp);
-        states.updateLoadStates();
-        states.updateTimeWindowStates();
-
-
-        ConstraintManager cManager = new ConstraintManager(vrp, states);
-        cManager.addLoadConstraint();
-        cManager.addTimeWindowConstraint();
-
-        VehicleRoutingActivityCosts actCosts = mock(VehicleRoutingActivityCosts.class);
-
-        serviceInsertion = new ServiceInsertionCalculator(costs, vrp.getActivityCosts(), new LocalActivityInsertionCostsCalculator(costs, actCosts, states), cManager);
-        serviceInsertion.setJobActivityFactory(new CopyJobActivityFactory());
-    }
-
-    @Test
-    public void whenInsertingTheFirstJobInAnEmptyTourWithVehicle_itCalculatesMarginalCostChanges() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).build();
-        states.informInsertionStarts(Arrays.asList(route), null);
-
-        InsertionData iData = serviceInsertion.getInsertionData(route, first, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
-        assertEquals(20.0, iData.getInsertionCost(), 0.2);
-        assertEquals(0, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-    @Test
-    public void whenInsertingTheSecondJobInAnNonEmptyTourWithVehicle_itCalculatesMarginalCostChanges() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).build();
-        states.informInsertionStarts(Arrays.asList(route), null);
-
-        InsertionData iData = serviceInsertion.getInsertionData(route, third, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
-        assertEquals(20.0, iData.getInsertionCost(), 0.2);
-        assertEquals(0, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-    @Test
-    public void whenInsertingThirdJobWithVehicle_itCalculatesMarginalCostChanges() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).addService(third).build();
-        states.informInsertionStarts(Arrays.asList(route), null);
-
-        InsertionData iData = serviceInsertion.getInsertionData(route, second, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
-        assertEquals(0.0, iData.getInsertionCost(), 0.2);
-        assertEquals(1, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-    @Test
-    public void whenInsertingThirdJobWithNewVehicle_itCalculatesMarginalCostChanges() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).addService(third).build();
-        states.informInsertionStarts(Arrays.asList(route), null);
-
-        InsertionData iData = serviceInsertion.getInsertionData(route, second, newVehicle, newVehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
-        assertEquals(40.0, iData.getInsertionCost(), 0.2);
-        assertEquals(1, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-    @Test
-    public void whenInsertingASecondJobWithAVehicle_itCalculatesLocalMarginalCostChanges() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).addService(second).build();
-        states.informInsertionStarts(Arrays.asList(route), null);
-
-        InsertionData iData = serviceInsertion.getInsertionData(route, third, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
-        assertEquals(0.0, iData.getInsertionCost(), 0.2);
-        assertEquals(2, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-    @Test
-    public void whenInsertingASecondJobWithANewVehicle_itCalculatesLocalMarginalCostChanges() {
-
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).addService(second).build();
-
-        states.informInsertionStarts(Arrays.asList(route), null);
-
-        InsertionData iData = serviceInsertion.getInsertionData(route, third, newVehicle, newVehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
-        assertEquals(50.0, iData.getInsertionCost(), 0.2);
-        assertEquals(2, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
-    }
-
-    @Test
-    public void whenInsertingJobAndCurrRouteIsEmpty_accessEggressCalcShouldReturnZero() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(VehicleImpl.createNoVehicle(), DriverImpl.noDriver()).build();
-        AdditionalAccessEgressCalculator accessEgressCalc = new AdditionalAccessEgressCalculator(costs);
-        Job job = new Service.Builder("1").addSizeDimension(0, 0).setLocation(Location.newInstance("1")).setTimeWindow(TimeWindow.newInstance(0.0, 100.0)).build();
-        JobInsertionContext iContex = new JobInsertionContext(route, job, newVehicle, mock(Driver.class), 0.0);
-        assertEquals(0.0, accessEgressCalc.getCosts(iContex), 0.01);
-    }
-
-    @Test
-    public void whenInsertingJobAndCurrRouteAndVehicleHaveTheSameLocation_accessEggressCalcShouldReturnZero() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(newVehicle, DriverImpl.noDriver())
-            .addService(first)
-            .build();
-
-        AdditionalAccessEgressCalculator accessEgressCalc = new AdditionalAccessEgressCalculator(costs);
-        JobInsertionContext iContex = new JobInsertionContext(route, first, newVehicle, mock(Driver.class), 0.0);
-        assertEquals(0.0, accessEgressCalc.getCosts(iContex), 0.01);
-    }
-
-    @Test
-    public void whenInsertingJobAndCurrRouteAndNewVehicleHaveDifferentLocations_accessEggressCostsMustBeCorrect() {
-        final Map<String, Coordinate> coords = new HashMap<String, Coordinate>();
-        coords.put("oldV", Coordinate.newInstance(1, 0));
-        coords.put("newV", Coordinate.newInstance(5, 0));
-        coords.put("service", Coordinate.newInstance(0, 0));
-
-        AbstractForwardVehicleRoutingTransportCosts routingCosts = new AbstractForwardVehicleRoutingTransportCosts() {
-
-            @Override
-            public double getTransportTime(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-                return getTransportCost(from, to, departureTime, driver, vehicle);
-            }
-
-            @Override
-            public double getTransportCost(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-                return EuclideanDistanceCalculator.getInstance().calculateDistance(coords.get(from.getId()), coords.get(to.getId()));
-            }
-        };
-        Vehicle oldVehicle = VehicleImpl.Builder.newInstance("oldV").setStartLocation(Location.newInstance("oldV")).build();
-
-        VehicleRoute route = VehicleRoute.Builder.newInstance(oldVehicle, DriverImpl.noDriver())
-            .addService(new Service.Builder("service").addSizeDimension(0, 0).setLocation(Location.newInstance("service")).build())
-            .build();
-
-        Vehicle newVehicle = VehicleImpl.Builder.newInstance("newV").setStartLocation(Location.newInstance("newV")).build();
-
-        AdditionalAccessEgressCalculator accessEgressCalc = new AdditionalAccessEgressCalculator(routingCosts);
-        Job job = new Service.Builder("service2").addSizeDimension(0, 0).setLocation(Location.newInstance("service")).build();
-        JobInsertionContext iContex = new JobInsertionContext(route, job, newVehicle, mock(Driver.class), 0.0);
-        assertEquals(8.0, accessEgressCalc.getCosts(iContex), 0.01);
-    }
-}
