diff --git a/jsprit-analysis/src/test/java/com/graphhopper/jsprit/analysis/toolbox/CustomJob.java b/jsprit-analysis/src/test/java/com/graphhopper/jsprit/analysis/toolbox/CustomJob.java
deleted file mode 100644
index 2009c06fa..000000000
--- a/jsprit-analysis/src/test/java/com/graphhopper/jsprit/analysis/toolbox/CustomJob.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.graphhopper.jsprit.analysis.toolbox;
-
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.SizeDimension;
-import com.graphhopper.jsprit.core.problem.job.AbstractJob;
-import com.graphhopper.jsprit.core.problem.job.JobActivityList;
-import com.graphhopper.jsprit.core.problem.job.SequentialJobActivityList;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.ExchangeActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Created by schroeder on 16/11/16.
- */
-public class CustomJob extends AbstractJob {
-
-    public static abstract class BuilderBase<T extends CustomJob, B extends CustomJob.BuilderBase<T, B>>
-        extends JobBuilder<T, B> {
-
-        List<Location> locs = new ArrayList<>();
-
-        List<SizeDimension> cap = new ArrayList<>();
-
-        List<String> types = new ArrayList<>();
-
-        public BuilderBase(String id) {
-            super(id);
-        }
-
-        public CustomJob.BuilderBase<T, B> addPickup(Location location, SizeDimension loadChange) {
-            add(location, loadChange);
-            types.add("pickup");
-            return this;
-        }
-
-        private void add(Location location, SizeDimension loadChange) {
-            locs.add(location);
-            cap.add(loadChange);
-        }
-
-        public CustomJob.BuilderBase<T, B> addDelivery(Location location, SizeDimension loadChange) {
-            add(location, loadChange);
-            types.add("delivery");
-            return this;
-        }
-
-        public CustomJob.BuilderBase<T, B> addExchange(Location location, SizeDimension loadChange) {
-            add(location, loadChange);
-            types.add("exchange");
-            return this;
-        }
-
-
-
-        public List<Location> getLocs() {
-            return locs;
-        }
-
-        public List<SizeDimension> getCaps() {
-            return cap;
-        }
-
-        public List<String> getTypes() {
-            return types;
-        }
-
-        protected void validate() {
-
-        }
-    }
-
-    public static final class Builder extends CustomJob.BuilderBase<CustomJob, CustomJob.Builder> {
-
-        public static CustomJob.Builder newInstance(String id) {
-            return new CustomJob.Builder(id);
-        }
-
-        public Builder(String id) {
-            super(id);
-        }
-
-        @Override
-        protected CustomJob createInstance() {
-            return new CustomJob(this);
-        }
-
-    }
-
-    /**
-     * Builder based constructor.
-     *
-     * @param builder The builder instance.
-     * @see JobBuilder
-     */
-    protected CustomJob(JobBuilder<?, ?> builder) {
-        super(builder);
-
-    }
-
-    @Override
-    public SizeDimension getSize() {
-        return SizeDimension.EMPTY;
-    }
-
-    @Override
-    protected void createActivities(JobBuilder<? extends AbstractJob, ?> jobBuilder) {
-        CustomJob.Builder builder = (CustomJob.Builder) jobBuilder;
-        JobActivityList list = new SequentialJobActivityList(this);
-        for (int i = 0; i < builder.getLocs().size(); i++) {
-            if (builder.getTypes().get(i).equals("pickup")) {
-                list.addActivity(new PickupActivity(this, "pick", builder.getLocs().get(i), 0, builder.getCaps().get(i), Arrays.asList(TimeWindow.ETERNITY)));
-            } else if (builder.getTypes().get(i).equals("delivery")) {
-                list.addActivity(new DeliveryActivity(this, "delivery", builder.getLocs().get(i), 0, builder.getCaps().get(i).invert(), Arrays.asList(TimeWindow.ETERNITY)));
-            } else {
-                list.addActivity(new ExchangeActivity(this, "exchange", builder.getLocs().get(i), 0, builder.getCaps().get(i), Arrays.asList(TimeWindow.ETERNITY)));
-            }
-        }
-        setActivities(list);
-    }
-}
-
diff --git a/jsprit-analysis/src/test/java/com/graphhopper/jsprit/analysis/toolbox/GraphStreamViewerTest.java b/jsprit-analysis/src/test/java/com/graphhopper/jsprit/analysis/toolbox/GraphStreamViewerTest.java
index d5ebc5fe8..d1f1014c7 100644
--- a/jsprit-analysis/src/test/java/com/graphhopper/jsprit/analysis/toolbox/GraphStreamViewerTest.java
+++ b/jsprit-analysis/src/test/java/com/graphhopper/jsprit/analysis/toolbox/GraphStreamViewerTest.java
@@ -18,11 +18,15 @@
 
 package com.graphhopper.jsprit.analysis.toolbox;
 
+import org.junit.Ignore;
+import org.junit.Test;
+
 import com.graphhopper.jsprit.core.algorithm.box.Jsprit;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.SizeDimension;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.job.Break;
+import com.graphhopper.jsprit.core.problem.job.CustomJob;
 import com.graphhopper.jsprit.core.problem.job.Shipment;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
@@ -30,8 +34,6 @@
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
 import com.graphhopper.jsprit.core.util.Solutions;
-import org.junit.Ignore;
-import org.junit.Test;
 
 /**
  * Created by schroeder on 18/11/16.
@@ -42,14 +44,16 @@
     @Test
     public void testPlotCustomJob() {
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0, 50).build();
-        Vehicle vehicle = VehicleImpl.Builder.newInstance("vehicle").setType(type).setBreak(Break.Builder.newInstance("myBreak").addTimeWindow(5, 10).build()).setStartLocation(Location.newInstance(0, 0))
-            .build();
+        Vehicle vehicle = VehicleImpl.Builder.newInstance("vehicle").setType(type).setBreak(Break.Builder.newInstance("myBreak").addTimeWindow(5, 10).build())
+                .setStartLocation(Location.newInstance(0, 0))
+                .build();
         CustomJob cj = CustomJob.Builder.newInstance("job")
-            .addPickup(Location.newInstance(10, 0), SizeDimension.Builder.newInstance().addDimension(0, 1).build())
-            .addPickup(Location.newInstance(5, 0), SizeDimension.Builder.newInstance().addDimension(0, 2).build())
-            .addDelivery(Location.newInstance(20, 0), SizeDimension.Builder.newInstance().addDimension(0, 3).build())
-            .build();
-        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().setFleetSize(VehicleRoutingProblem.FleetSize.FINITE).addJob(cj).addVehicle(vehicle).build();
+                .addPickup(Location.newInstance(10, 0), SizeDimension.Builder.newInstance().addDimension(0, 1).build())
+                .addPickup(Location.newInstance(5, 0), SizeDimension.Builder.newInstance().addDimension(0, 2).build())
+                .addDelivery(Location.newInstance(20, 0), SizeDimension.Builder.newInstance().addDimension(0, 3).build())
+                .build();
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().setFleetSize(VehicleRoutingProblem.FleetSize.FINITE).addJob(cj)
+                .addVehicle(vehicle).build();
         VehicleRoutingProblemSolution solution = Solutions.bestOf(Jsprit.createAlgorithm(vrp).searchSolutions());
         new GraphStreamViewer(vrp, solution).display();
     }
@@ -58,12 +62,12 @@ public void testPlotCustomJob() {
     public void testPlotCustomJobSolution() {
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0, 3).build();
         Vehicle vehicle = VehicleImpl.Builder.newInstance("vehicle").setStartLocation(Location.newInstance(0, 0))
-            .setType(type).build();
+                .setType(type).build();
         CustomJob cj = CustomJob.Builder.newInstance("job")
-            .addPickup(Location.newInstance(10, 0), SizeDimension.Builder.newInstance().addDimension(0, 1).build())
-            .addPickup(Location.newInstance(-5, 4), SizeDimension.Builder.newInstance().addDimension(0, 2).build())
-            .addDelivery(Location.newInstance(20, 10), SizeDimension.Builder.newInstance().addDimension(0, 3).build())
-            .build();
+                .addPickup(Location.newInstance(10, 0), SizeDimension.Builder.newInstance().addDimension(0, 1).build())
+                .addPickup(Location.newInstance(-5, 4), SizeDimension.Builder.newInstance().addDimension(0, 2).build())
+                .addDelivery(Location.newInstance(20, 10), SizeDimension.Builder.newInstance().addDimension(0, 3).build())
+                .build();
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(cj).addVehicle(vehicle).build();
         VehicleRoutingProblemSolution solution = Solutions.bestOf(Jsprit.createAlgorithm(vrp).searchSolutions());
         new Plotter(vrp, solution).plot("output/plotSolution", "plot");
@@ -73,12 +77,12 @@ public void testPlotCustomJobSolution() {
     public void testPlotWithExchange() {
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0, 3).addCapacityDimension(1, 3).build();
         Vehicle vehicle = VehicleImpl.Builder.newInstance("vehicle").setStartLocation(Location.newInstance(0, 0))
-            .setType(type).build();
+                .setType(type).build();
         CustomJob cj = CustomJob.Builder.newInstance("job")
-            .addPickup(Location.newInstance(10, 0), SizeDimension.Builder.newInstance().addDimension(0, 1).addDimension(1, 1).build())
-            .addExchange(Location.newInstance(-5, 4), SizeDimension.Builder.newInstance().addDimension(0, -1).addDimension(1, 1).build())
-            .addDelivery(Location.newInstance(20, 10), SizeDimension.Builder.newInstance().addDimension(0, 3).build())
-            .build();
+                .addPickup(Location.newInstance(10, 0), SizeDimension.Builder.newInstance().addDimension(0, 1).addDimension(1, 1).build())
+                .addExchange(Location.newInstance(-5, 4), SizeDimension.Builder.newInstance().addDimension(0, -1).addDimension(1, 1).build())
+                .addDelivery(Location.newInstance(20, 10), SizeDimension.Builder.newInstance().addDimension(0, 3).build())
+                .build();
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(cj).addVehicle(vehicle).build();
         VehicleRoutingProblemSolution solution = Solutions.bestOf(Jsprit.createAlgorithm(vrp).searchSolutions());
         new Plotter(vrp).plotJobRelations(true).plot("output/plotExchange", "plot");
@@ -89,9 +93,9 @@ public void testPlotWithExchange() {
     public void testPlotWithShipments() {
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0, 3).build();
         Vehicle vehicle = VehicleImpl.Builder.newInstance("vehicle").setStartLocation(Location.newInstance(0, 0))
-            .setType(type).build();
+                .setType(type).build();
         Shipment shipment = Shipment.Builder.newInstance("shipment").setPickupLocation(Location.newInstance(-5, 4))
-            .addSizeDimension(0, 2).setDeliveryLocation(Location.newInstance(20, 10)).build();
+                .addSizeDimension(0, 2).setDeliveryLocation(Location.newInstance(20, 10)).build();
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(shipment).addVehicle(vehicle).build();
         VehicleRoutingProblemSolution solution = Solutions.bestOf(Jsprit.createAlgorithm(vrp).searchSolutions());
         new Plotter(vrp).plotJobRelations(true).plot("output/plotJobs", "plot");
diff --git a/jsprit-analysis/src/test/java/com/graphhopper/jsprit/analysis/toolbox/PlotterTest.java b/jsprit-analysis/src/test/java/com/graphhopper/jsprit/analysis/toolbox/PlotterTest.java
index 585d255c5..9c32c2f16 100644
--- a/jsprit-analysis/src/test/java/com/graphhopper/jsprit/analysis/toolbox/PlotterTest.java
+++ b/jsprit-analysis/src/test/java/com/graphhopper/jsprit/analysis/toolbox/PlotterTest.java
@@ -18,10 +18,14 @@
 
 package com.graphhopper.jsprit.analysis.toolbox;
 
+import org.junit.Ignore;
+import org.junit.Test;
+
 import com.graphhopper.jsprit.core.algorithm.box.Jsprit;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.SizeDimension;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.job.CustomJob;
 import com.graphhopper.jsprit.core.problem.job.Shipment;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
@@ -29,8 +33,6 @@
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
 import com.graphhopper.jsprit.core.util.Solutions;
-import org.junit.Ignore;
-import org.junit.Test;
 
 /**
  * Created by schroeder on 18/11/16.
@@ -42,12 +44,12 @@
     public void testPlotCustomJob() {
 
         Vehicle vehicle = VehicleImpl.Builder.newInstance("vehicle").setStartLocation(Location.newInstance(0, 0))
-            .build();
+                .build();
         CustomJob cj = CustomJob.Builder.newInstance("job")
-            .addPickup(Location.newInstance(10, 0), SizeDimension.Builder.newInstance().addDimension(0, 1).build())
-            .addPickup(Location.newInstance(5, 0), SizeDimension.Builder.newInstance().addDimension(0, 2).build())
-            .addDelivery(Location.newInstance(20, 00), SizeDimension.Builder.newInstance().addDimension(0, 3).build())
-            .build();
+                .addPickup(Location.newInstance(10, 0), SizeDimension.Builder.newInstance().addDimension(0, 1).build())
+                .addPickup(Location.newInstance(5, 0), SizeDimension.Builder.newInstance().addDimension(0, 2).build())
+                .addDelivery(Location.newInstance(20, 00), SizeDimension.Builder.newInstance().addDimension(0, 3).build())
+                .build();
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(cj).addVehicle(vehicle).build();
         new Plotter(vrp).plot("output/plot", "plot");
     }
@@ -56,12 +58,12 @@ public void testPlotCustomJob() {
     public void testPlotCustomJobSolution() {
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0, 3).build();
         Vehicle vehicle = VehicleImpl.Builder.newInstance("vehicle").setStartLocation(Location.newInstance(0, 0))
-            .setType(type).build();
+                .setType(type).build();
         CustomJob cj = CustomJob.Builder.newInstance("job")
-            .addPickup(Location.newInstance(10, 0), SizeDimension.Builder.newInstance().addDimension(0, 1).build())
-            .addPickup(Location.newInstance(-5, 4), SizeDimension.Builder.newInstance().addDimension(0, 2).build())
-            .addDelivery(Location.newInstance(20, 10), SizeDimension.Builder.newInstance().addDimension(0, 3).build())
-            .build();
+                .addPickup(Location.newInstance(10, 0), SizeDimension.Builder.newInstance().addDimension(0, 1).build())
+                .addPickup(Location.newInstance(-5, 4), SizeDimension.Builder.newInstance().addDimension(0, 2).build())
+                .addDelivery(Location.newInstance(20, 10), SizeDimension.Builder.newInstance().addDimension(0, 3).build())
+                .build();
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(cj).addVehicle(vehicle).build();
         VehicleRoutingProblemSolution solution = Solutions.bestOf(Jsprit.createAlgorithm(vrp).searchSolutions());
         new Plotter(vrp, solution).plot("output/plotSolution", "plot");
@@ -71,12 +73,12 @@ public void testPlotCustomJobSolution() {
     public void testPlotWithExchange() {
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0, 3).addCapacityDimension(1, 3).build();
         Vehicle vehicle = VehicleImpl.Builder.newInstance("vehicle").setStartLocation(Location.newInstance(0, 0))
-            .setType(type).build();
+                .setType(type).build();
         CustomJob cj = CustomJob.Builder.newInstance("job")
-            .addPickup(Location.newInstance(10, 0), SizeDimension.Builder.newInstance().addDimension(0, 1).addDimension(1, 1).build())
-            .addExchange(Location.newInstance(-5, 4), SizeDimension.Builder.newInstance().addDimension(0, -1).addDimension(1, 1).build())
-            .addDelivery(Location.newInstance(20, 10), SizeDimension.Builder.newInstance().addDimension(0, 3).build())
-            .build();
+                .addPickup(Location.newInstance(10, 0), SizeDimension.Builder.newInstance().addDimension(0, 1).addDimension(1, 1).build())
+                .addExchange(Location.newInstance(-5, 4), SizeDimension.Builder.newInstance().addDimension(0, -1).addDimension(1, 1).build())
+                .addDelivery(Location.newInstance(20, 10), SizeDimension.Builder.newInstance().addDimension(0, 3).build())
+                .build();
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(cj).addVehicle(vehicle).build();
         VehicleRoutingProblemSolution solution = Solutions.bestOf(Jsprit.createAlgorithm(vrp).searchSolutions());
         new Plotter(vrp).plotJobRelations(true).plot("output/plotExchange", "plot");
@@ -87,9 +89,9 @@ public void testPlotWithExchange() {
     public void testPlotWithShipments() {
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0, 3).build();
         Vehicle vehicle = VehicleImpl.Builder.newInstance("vehicle").setStartLocation(Location.newInstance(0, 0))
-            .setType(type).build();
+                .setType(type).build();
         Shipment shipment = Shipment.Builder.newInstance("shipment").setPickupLocation(Location.newInstance(-5, 4))
-            .addSizeDimension(0, 2).setDeliveryLocation(Location.newInstance(20, 10)).build();
+                .addSizeDimension(0, 2).setDeliveryLocation(Location.newInstance(20, 10)).build();
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(shipment).addVehicle(vehicle).build();
         VehicleRoutingProblemSolution solution = Solutions.bestOf(Jsprit.createAlgorithm(vrp).searchSolutions());
         new Plotter(vrp).plotJobRelations(true).plot("output/plotJobs", "plot");
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/LocalActivityInsertionCostsCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/LocalActivityInsertionCostsCalculator.java
index 795f1f3cb..2e16583f0 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/LocalActivityInsertionCostsCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/LocalActivityInsertionCostsCalculator.java
@@ -22,6 +22,8 @@
 import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
 import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.AbstractActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.state.RouteAndActivityStateGetter;
@@ -51,7 +53,7 @@
     public LocalActivityInsertionCostsCalculator(VehicleRoutingTransportCosts routingCosts, VehicleRoutingActivityCosts actCosts, RouteAndActivityStateGetter stateManager) {
         super();
         this.routingCosts = routingCosts;
-        this.activityCosts = actCosts;
+        activityCosts = actCosts;
         this.stateManager = stateManager;
     }
 
@@ -65,8 +67,9 @@ public double getCosts(JobInsertionContext iFacts, TourActivity prevAct, TourAct
 
         double act_costs_newAct = activityCosts.getActivityCost(newAct, newAct_arrTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
 
-        if (isEnd(nextAct) && !toDepot(iFacts.getNewVehicle()))
+        if (isEnd(nextAct) && !toDepot(iFacts.getNewVehicle())) {
             return tp_costs_prevAct_newAct + solutionCompletenessRatio * activityCostsWeight * act_costs_newAct;
+        }
 
         double tp_costs_newAct_nextAct = routingCosts.getTransportCost(newAct.getLocation(), nextAct.getLocation(), newAct_endTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
         double tp_time_newAct_nextAct = routingCosts.getTransportTime(newAct.getLocation(), nextAct.getLocation(), newAct_endTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
@@ -78,7 +81,10 @@ public double getCosts(JobInsertionContext iFacts, TourActivity prevAct, TourAct
 
         double oldCosts = 0.;
         if (iFacts.getRoute().isEmpty()) {
-            double tp_costs_prevAct_nextAct = routingCosts.getTransportCost(prevAct.getLocation(), nextAct.getLocation(), depTimeAtPrevAct, iFacts.getNewDriver(), iFacts.getNewVehicle());
+            double tp_costs_prevAct_nextAct = 0.;
+            if (newAct instanceof DeliveryActivity && AbstractActivity.isShipment(newAct)) {
+                tp_costs_prevAct_nextAct = routingCosts.getTransportCost(prevAct.getLocation(), nextAct.getLocation(), depTimeAtPrevAct, iFacts.getNewDriver(), iFacts.getNewVehicle());
+            }
             oldCosts += tp_costs_prevAct_nextAct;
         } else {
             double tp_costs_prevAct_nextAct = routingCosts.getTransportCost(prevAct.getLocation(), nextAct.getLocation(), prevAct.getEndTime(), iFacts.getRoute().getDriver(), iFacts.getRoute().getVehicle());
@@ -88,7 +94,9 @@ public double getCosts(JobInsertionContext iFacts, TourActivity prevAct, TourAct
 
             double endTimeDelay_nextAct = Math.max(0, endTime_nextAct_new - endTime_nextAct_old);
             Double futureWaiting = stateManager.getActivityState(nextAct, iFacts.getRoute().getVehicle(), InternalStates.FUTURE_WAITING, Double.class);
-            if (futureWaiting == null) futureWaiting = 0.;
+            if (futureWaiting == null) {
+                futureWaiting = 0.;
+            }
             double waitingTime_savings_timeUnit = Math.min(futureWaiting, endTimeDelay_nextAct);
             double waitingTime_savings = waitingTime_savings_timeUnit * iFacts.getRoute().getVehicle().getType().getVehicleCostParams().perWaitingTimeUnit;
             oldCosts += solutionCompletenessRatio * activityCostsWeight * waitingTime_savings;
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/SizeDimension.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/SizeDimension.java
index 4ad2bceec..2bb5ff78e 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/SizeDimension.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/SizeDimension.java
@@ -72,6 +72,19 @@ public static SizeDimension copyOf(SizeDimension sizeDimension) {
         return new SizeDimension(sizeDimension);
     }
 
+    public static SizeDimension of(int value) {
+        return Builder.newInstance().addDimension(0, value).build();
+    }
+
+    public static SizeDimension of(int value, int value2) {
+        return Builder.newInstance().addDimension(0, value).addDimension(1, value2).build();
+    }
+
+    public static SizeDimension of(int value, int value2, int value3) {
+        return Builder.newInstance().addDimension(0, value).addDimension(1, value2)
+                        .addDimension(2, value3).build();
+    }
+
     /**
      * Builder that builds SizeDimension
      *
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
index cad486386..fb7f09eae 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
@@ -35,7 +35,7 @@
 /**
  * Created by schroeder on 11/10/16.
  */
-public class MaxDistanceConstraint implements HardActivityConstraint {
+public class MaxDistanceConstraint implements HardActivityConstraint{
 
     private StateManager stateManager;
 
@@ -45,7 +45,7 @@
 
     private Double[] maxDistances;
 
-    public MaxDistanceConstraint(StateManager stateManager, StateId distanceId, TransportDistance distanceCalculator, Map<Vehicle, Double> maxDistancePerVehicleMap) {
+    public MaxDistanceConstraint(StateManager stateManager, StateId distanceId, TransportDistance distanceCalculator, Map<Vehicle,Double> maxDistancePerVehicleMap) {
         this.stateManager = stateManager;
         this.distanceId = distanceId;
         this.distanceCalculator = distanceCalculator;
@@ -54,16 +54,16 @@ public MaxDistanceConstraint(StateManager stateManager, StateId distanceId, Tran
 
     private void makeArray(Map<Vehicle, Double> maxDistances) {
         int maxIndex = getMaxIndex(maxDistances.keySet());
-        this.maxDistances = new Double[maxIndex + 1];
-        for (Vehicle v : maxDistances.keySet()) {
-            this.maxDistances[v.getIndex()] = maxDistances.get(v);
+        this.maxDistances = new Double[maxIndex+1];
+        for(Vehicle v : maxDistances.keySet()){
+            this.maxDistances[v.getIndex()]=maxDistances.get(v);
         }
     }
 
     private int getMaxIndex(Collection<Vehicle> vehicles) {
         int index = 0;
-        for (Vehicle v : vehicles) {
-            if (v.getIndex() > index) {
+        for(Vehicle v : vehicles){
+            if(v.getIndex() > index) {
                 index = v.getIndex();
             }
         }
@@ -72,60 +72,62 @@ private int getMaxIndex(Collection<Vehicle> vehicles) {
 
     @Override
     public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime) {
-        if (!hasMaxDistance(iFacts.getNewVehicle())) {
+        if(!hasMaxDistance(iFacts.getNewVehicle())) {
             return ConstraintsStatus.FULFILLED;
         }
         Double currentDistance = 0d;
-        if (!iFacts.getRoute().isEmpty()) {
-            currentDistance = stateManager.getRouteState(iFacts.getRoute(), iFacts.getNewVehicle(), distanceId, Double.class);
+        boolean routeIsEmpty = iFacts.getRoute().isEmpty();
+        if(!routeIsEmpty){
+            currentDistance = stateManager.getRouteState(iFacts.getRoute(),iFacts.getNewVehicle(), distanceId,Double.class);
         }
         double maxDistance = getMaxDistance(iFacts.getNewVehicle());
-        if (currentDistance > maxDistance) {
+        if(currentDistance > maxDistance) {
             return ConstraintsStatus.NOT_FULFILLED_BREAK;
         }
 
         double distancePrevAct2NewAct = distanceCalculator.getDistance(prevAct.getLocation(), newAct.getLocation(), iFacts.getNewDepTime(), iFacts.getNewVehicle());
         double distanceNewAct2nextAct = distanceCalculator.getDistance(newAct.getLocation(), nextAct.getLocation(), iFacts.getNewDepTime(), iFacts.getNewVehicle());
         double distancePrevAct2NextAct = distanceCalculator.getDistance(prevAct.getLocation(), nextAct.getLocation(), prevActDepTime, iFacts.getNewVehicle());
-        if (nextAct instanceof End && !iFacts.getNewVehicle().isReturnToDepot()) {
+        if(routeIsEmpty) {
+            distancePrevAct2NextAct = 0;
+        }
+        if(nextAct instanceof End && !iFacts.getNewVehicle().isReturnToDepot()){
             distanceNewAct2nextAct = 0;
             distancePrevAct2NextAct = 0;
         }
         double additionalDistance = distancePrevAct2NewAct + distanceNewAct2nextAct - distancePrevAct2NextAct;
-        if (currentDistance + additionalDistance > maxDistance) {
+        if(currentDistance + additionalDistance > maxDistance) {
             return ConstraintsStatus.NOT_FULFILLED;
         }
 
-
         double additionalDistanceOfPickup = 0;
-        // Balage1551 - Temporal solution to eliminate DEPRECATED
         if (newAct instanceof DeliveryActivity && AbstractActivity.isShipment(newAct)) {
             int iIndexOfPickup = iFacts.getRelatedActivityContext().getInsertionIndex();
             TourActivity pickup = iFacts.getAssociatedActivities().get(0);
             TourActivity actBeforePickup;
-            if (iIndexOfPickup > 0) {
-                actBeforePickup = iFacts.getRoute().getActivities().get(iIndexOfPickup - 1);
+            if(iIndexOfPickup > 0) {
+                actBeforePickup = iFacts.getRoute().getActivities().get(iIndexOfPickup-1);
             } else {
-                actBeforePickup = new Start(iFacts.getNewVehicle().getStartLocation(), 0, Double.MAX_VALUE);
+                actBeforePickup = new Start(iFacts.getNewVehicle().getStartLocation(),0,Double.MAX_VALUE);
             }
             TourActivity actAfterPickup = iFacts.getRoute().getActivities().get(iIndexOfPickup);
             //ToDo account here fore End and returnToDepot
             double distanceActBeforePickup2Pickup = distanceCalculator.getDistance(actBeforePickup.getLocation(), pickup.getLocation(), actBeforePickup.getEndTime(), iFacts.getNewVehicle());
             double distancePickup2ActAfterPickup = distanceCalculator.getDistance(pickup.getLocation(), actAfterPickup.getLocation(), iFacts.getRelatedActivityContext().getEndTime(), iFacts.getNewVehicle());
             double distanceBeforePickup2AfterPickup = distanceCalculator.getDistance(actBeforePickup.getLocation(), actAfterPickup.getLocation(), actBeforePickup.getEndTime(), iFacts.getNewVehicle());
-            additionalDistanceOfPickup = distanceActBeforePickup2Pickup + distancePickup2ActAfterPickup - distanceBeforePickup2AfterPickup;
+            additionalDistanceOfPickup = distanceActBeforePickup2Pickup  + distancePickup2ActAfterPickup - distanceBeforePickup2AfterPickup;
         }
 
 
-        if (currentDistance + additionalDistance + additionalDistanceOfPickup > maxDistance) {
+        if(currentDistance + additionalDistance + additionalDistanceOfPickup > maxDistance){
             return ConstraintsStatus.NOT_FULFILLED;
         }
 
         return ConstraintsStatus.FULFILLED;
     }
 
-    private boolean hasMaxDistance(Vehicle newVehicle) {
-        if (newVehicle.getIndex() >= maxDistances.length) {
+    private boolean hasMaxDistance(Vehicle newVehicle){
+        if(newVehicle.getIndex() >= maxDistances.length) {
             return false;
         }
         return maxDistances[newVehicle.getIndex()] != null;
@@ -133,7 +135,7 @@ private boolean hasMaxDistance(Vehicle newVehicle) {
 
     private double getMaxDistance(Vehicle newVehicle) {
         Double maxDistance = maxDistances[newVehicle.getIndex()];
-        if (maxDistance == null) {
+        if(maxDistance == null) {
             return Double.MAX_VALUE;
         }
         return maxDistance;
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/CustomJob.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/CustomJob.java
new file mode 100644
index 000000000..1214c2209
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/CustomJob.java
@@ -0,0 +1,344 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.graphhopper.jsprit.core.problem.job;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.SizeDimension;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.ExchangeActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.ServiceActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindows;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindowsImpl;
+
+/**
+ * Created by schroeder on 16/11/16.
+ *
+ * @author schroeder
+ * @author balage
+ */
+public class CustomJob extends AbstractJob {
+
+
+    public static abstract class BuilderBase<T extends CustomJob, B extends CustomJob.BuilderBase<T, B>>
+    extends JobBuilder<T, B> {
+
+        public enum ActivityType {
+            SERVICE {
+
+                @Override
+                public JobActivity create(CustomJob job, BuilderActivityInfo info) {
+                    return new ServiceActivity(job, info.getName() == null ? name().toLowerCase() : info.getName(),
+                                    info.getLocation(), info.getOperationTime(), info.getSize(), prepareTimeWindows(info));
+                }
+            },
+            PICKUP {
+
+                @Override
+                public JobActivity create(CustomJob job, BuilderActivityInfo info) {
+                    return new PickupActivity(job, info.getName() == null ? name().toLowerCase() : info.getName(),
+                                    info.getLocation(), info.getOperationTime(), info.getSize(), prepareTimeWindows(info));
+                }
+            },
+            DELIVERY {
+
+                @Override
+                public JobActivity create(CustomJob job, BuilderActivityInfo info) {
+                    return new DeliveryActivity(job, info.getName() == null ? name().toLowerCase() : info.getName(),
+                                    info.getLocation(), info.getOperationTime(), info.getSize(), prepareTimeWindows(info));
+                }
+            },
+            EXCHANGE {
+
+                @Override
+                public JobActivity create(CustomJob job, BuilderActivityInfo info) {
+                    return new ExchangeActivity(job, info.getName() == null ? name().toLowerCase() : info.getName(),
+                                    info.getLocation(), info.getOperationTime(), info.getSize(), prepareTimeWindows(info));
+                }
+            };
+
+            public abstract JobActivity create(CustomJob job, BuilderActivityInfo builderActivityInfo);
+
+            private static Collection<TimeWindow> prepareTimeWindows(BuilderActivityInfo info) {
+                TimeWindows tws = info.getTimeWindows();
+                if (tws.getTimeWindows().isEmpty()) {
+                    tws = TimeWindows.ANY_TIME;
+                }
+                return tws.getTimeWindows();
+            }
+        }
+
+
+        public static class BuilderActivityInfo {
+            private ActivityType type;
+            private Location locs;
+            private SizeDimension size = SizeDimension.EMPTY;
+            private String name = null;
+            private double operationTime = 0;
+            private TimeWindowsImpl timeWindows = new TimeWindowsImpl();
+
+
+            public BuilderActivityInfo(ActivityType type, Location locs) {
+                super();
+                this.type = type;
+                this.locs = locs;
+            }
+
+            public ActivityType getType() {
+                return type;
+            }
+
+            public Location getLocation() {
+                return locs;
+            }
+
+            public SizeDimension getSize() {
+                return size;
+            }
+
+            public BuilderActivityInfo withSize(SizeDimension size) {
+                this.size = size;
+                return this;
+            }
+
+            public String getName() {
+                return name;
+            }
+
+            public BuilderActivityInfo withName(String name) {
+                this.name = name;
+                return this;
+            }
+
+            public TimeWindows getTimeWindows() {
+                return timeWindows;
+            }
+
+            public BuilderActivityInfo withTimeWindow(TimeWindow timeWindow) {
+                timeWindows.add(timeWindow);
+                return this;
+            }
+
+            public BuilderActivityInfo withTimeWindows(TimeWindow... tws) {
+                timeWindows.addAll(tws);
+                return this;
+            }
+
+            public BuilderActivityInfo withTimeWindows(Collection<TimeWindow> tws) {
+                timeWindows.addAll(tws);
+                return this;
+            }
+
+            public double getOperationTime() {
+                return operationTime;
+            }
+
+            public BuilderActivityInfo withOperationTime(double operationTime) {
+                this.operationTime = operationTime;
+                return this;
+            }
+        }
+
+        List<BuilderActivityInfo> acts = new ArrayList<>();
+
+        public BuilderBase(String id) {
+            super(id);
+        }
+
+        public BuilderBase<T, B> addActivity(BuilderActivityInfo act) {
+            acts.add(act);
+            return this;
+        }
+
+
+        private void add(ActivityType type, Location location, double operationTime, SizeDimension size, String name,
+                        Collection<TimeWindow> tws) {
+            BuilderActivityInfo builderActivityInfo = new BuilderActivityInfo(type, location);
+            builderActivityInfo.withOperationTime(operationTime);
+            if (name != null) {
+                builderActivityInfo.withName(name);
+            }
+            if (size != null) {
+                builderActivityInfo.withSize(size);
+            }
+            if (tws != null) {
+                builderActivityInfo.withTimeWindows(tws);
+            }
+
+            acts.add(builderActivityInfo);
+        }
+
+        // Service
+
+        public CustomJob.BuilderBase<T, B> addService(Location location) {
+            add(ActivityType.SERVICE, location, 0d, null, null, null);
+            return this;
+        }
+
+        public CustomJob.BuilderBase<T, B> addService(Location location, SizeDimension size) {
+            add(ActivityType.SERVICE, location, 0d, size, null, null);
+            return this;
+        }
+
+        public CustomJob.BuilderBase<T, B> addService(Location location, SizeDimension size, double operationTime) {
+            add(ActivityType.SERVICE, location, operationTime, size, null, null);
+            return this;
+        }
+
+        public CustomJob.BuilderBase<T, B> addService(Location location, SizeDimension size, double operationTime,
+                        TimeWindow tw) {
+            add(ActivityType.SERVICE, location, operationTime, size, null, Collections.singleton(tw));
+            return this;
+        }
+
+
+        // Pickup
+
+        public CustomJob.BuilderBase<T, B> addPickup(Location location) {
+            add(ActivityType.PICKUP, location, 0d, null, null, null);
+            return this;
+        }
+
+        public CustomJob.BuilderBase<T, B> addPickup(Location location, SizeDimension size) {
+            add(ActivityType.PICKUP, location, 0d, size, null, null);
+            return this;
+        }
+
+        public CustomJob.BuilderBase<T, B> addPickup(Location location, SizeDimension size, double operationTime) {
+            add(ActivityType.PICKUP, location, operationTime, size, null, null);
+            return this;
+        }
+
+        public CustomJob.BuilderBase<T, B> addPickup(Location location, SizeDimension size, double operationTime,
+                        TimeWindow tw) {
+            add(ActivityType.PICKUP, location, operationTime, size, null, Collections.singleton(tw));
+            return this;
+        }
+
+        // Delivery
+
+        public CustomJob.BuilderBase<T, B> addDelivery(Location location) {
+            add(ActivityType.DELIVERY, location, 0d, null, null, null);
+            return this;
+        }
+
+        public CustomJob.BuilderBase<T, B> addDelivery(Location location, SizeDimension size) {
+            add(ActivityType.DELIVERY, location, 0d, size, null, null);
+            return this;
+        }
+
+        public CustomJob.BuilderBase<T, B> addDelivery(Location location, SizeDimension size, double operationTime) {
+            add(ActivityType.DELIVERY, location, operationTime, size, null, null);
+            return this;
+        }
+
+        public CustomJob.BuilderBase<T, B> addDelivery(Location location, SizeDimension size, double operationTime,
+                        TimeWindow tw) {
+            add(ActivityType.DELIVERY, location, operationTime, size, null, Collections.singleton(tw));
+            return this;
+        }
+
+        // Exchange
+
+        public CustomJob.BuilderBase<T, B> addExchange(Location location) {
+            add(ActivityType.EXCHANGE, location, 0d, null, null, null);
+            return this;
+        }
+
+        public CustomJob.BuilderBase<T, B> addExchange(Location location, SizeDimension size) {
+            add(ActivityType.EXCHANGE, location, 0d, size, null, null);
+            return this;
+        }
+
+        public CustomJob.BuilderBase<T, B> addExchange(Location location, SizeDimension size, double operationTime) {
+            add(ActivityType.EXCHANGE, location, operationTime, size, null, null);
+            return this;
+        }
+
+        public CustomJob.BuilderBase<T, B> addExchange(Location location, SizeDimension size, double operationTime,
+                        TimeWindow tw) {
+            add(ActivityType.EXCHANGE, location, operationTime, size, null, Collections.singleton(tw));
+            return this;
+        }
+
+        @Override
+        protected void validate() {
+            if (acts.isEmpty()) {
+                throw new IllegalStateException("There is no activities defined on this job.");
+            }
+        }
+
+        public List<BuilderActivityInfo> getActs() {
+            return Collections.unmodifiableList(acts);
+        }
+
+    }
+
+    public static final class Builder extends CustomJob.BuilderBase<CustomJob, CustomJob.Builder> {
+
+        public static CustomJob.Builder newInstance(String id) {
+            return new CustomJob.Builder(id);
+        }
+
+        public Builder(String id) {
+            super(id);
+        }
+
+        @Override
+        protected CustomJob createInstance() {
+            return new CustomJob(this);
+        }
+
+    }
+
+    /**
+     * Builder based constructor.
+     *
+     * @param builder The builder instance.
+     * @see JobBuilder
+     */
+    protected CustomJob(JobBuilder<?, ?> builder) {
+        super(builder);
+
+    }
+
+    @Override
+    public SizeDimension getSize() {
+        return SizeDimension.EMPTY;
+    }
+
+    @Override
+    protected void createActivities(JobBuilder<? extends AbstractJob, ?> jobBuilder) {
+        CustomJob.Builder builder = (CustomJob.Builder) jobBuilder;
+        JobActivityList list = new SequentialJobActivityList(this);
+        for (CustomJob.Builder.BuilderActivityInfo info : builder.getActs()) {
+            JobActivity act = info.getType().create(this, info);
+            list.addActivity(act);
+        }
+        setActivities(list);
+    }
+}
+
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/ReturnedShipment.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/ReturnedShipment.java
index f7cd1b81b..6dd23cdd4 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/ReturnedShipment.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/ReturnedShipment.java
@@ -17,9 +17,13 @@
  */
 package com.graphhopper.jsprit.core.problem.job;
 
-import com.graphhopper.jsprit.core.problem.SizeDimension;
 import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.*;
+import com.graphhopper.jsprit.core.problem.SizeDimension;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.ExchangeActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindowsImpl;
 
 
 /**
@@ -30,9 +34,7 @@
  */
 public final class ReturnedShipment extends Shipment {
 
-    public static final String ACTIVITY_NAME_PICKUP = "pickup";
-    public static final String ACTIVITY_NAME_DELIVERY = "delivery";
-    public static final String ACTIVITY_NAME_BACKHAUL = "backhaul";
+    public static final String BACKHAUL_ACTIVITY_NAME = "backhaul";
 
     /**
      * Builder that builds the shipment.
@@ -201,43 +203,41 @@ protected ReturnedShipment createInstance() {
     protected void createActivities(JobBuilder<?, ?> builder) {
         Builder shipmentBuilder = (Builder) builder;
         JobActivityList list = new SequentialJobActivityList(this);
-        list.addActivity(new PickupActivity(this, ACTIVITY_NAME_PICKUP,
-            shipmentBuilder.getPickupLocation(),
-            shipmentBuilder.getPickupServiceTime(), shipmentBuilder.getCapacity(),
-            shipmentBuilder.getPickupTimeWindows().getTimeWindows()));
-        list.addActivity(new ExchangeActivity(this, ACTIVITY_NAME_DELIVERY,
-            shipmentBuilder.getDeliveryLocation(),
-            shipmentBuilder.getDeliveryServiceTime(),
-            shipmentBuilder.getBackhaulCapacity()
-                .subtract(shipmentBuilder.getCapacity()),
-            shipmentBuilder.getDeliveryTimeWindows().getTimeWindows()));
-        list.addActivity(new DeliveryActivity(this, ACTIVITY_NAME_BACKHAUL,
-            shipmentBuilder.getBackhaulLocation(),
-            shipmentBuilder.getBackhaulServiceTime(),
-            shipmentBuilder.getBackhaulCapacity(),
-            shipmentBuilder.getBackhaulTimeWindows().getTimeWindows()));
+        list.addActivity(new PickupActivity(this, PICKUP_ACTIVITY_NAME,
+                        shipmentBuilder.getPickupLocation(),
+                        shipmentBuilder.getPickupServiceTime(), shipmentBuilder.getCapacity(),
+                        shipmentBuilder.getPickupTimeWindows().getTimeWindows()));
+        list.addActivity(new ExchangeActivity(this, DELIVERY_ACTIVITY_NAME,
+                        shipmentBuilder.getDeliveryLocation(),
+                        shipmentBuilder.getDeliveryServiceTime(),
+                        shipmentBuilder.getBackhaulCapacity()
+                        .subtract(shipmentBuilder.getCapacity()),
+                        shipmentBuilder.getDeliveryTimeWindows().getTimeWindows()));
+        list.addActivity(new DeliveryActivity(this, BACKHAUL_ACTIVITY_NAME,
+                        shipmentBuilder.getBackhaulLocation(),
+                        shipmentBuilder.getBackhaulServiceTime(),
+                        shipmentBuilder.getBackhaulCapacity(),
+                        shipmentBuilder.getBackhaulTimeWindows().getTimeWindows()));
         setActivities(list);
     }
 
-    // TODO: RENAME WHEN SHIPMENT IS RETURNING THE SAME TYPE OF ACTIVIT
-    public PickupActivity getPickupActivityTO_BE_RENAMED_LATER() {
+    @Override
+    public PickupActivity getPickupActivity() {
         return (PickupActivity) getActivityList()
-            .findByType(ACTIVITY_NAME_PICKUP)
-            .get();
+                        .findByType(PICKUP_ACTIVITY_NAME)
+                        .get();
     }
 
-    // TODO: RENAME WHEN SHIPMENT IS RETURNING THE SAME TYPE OF ACTIVIT
-    public ExchangeActivity getDeliveryActivityTO_BE_RENAMED_LATER() {
+    public ExchangeActivity getExchangeActivity() {
         return (ExchangeActivity) getActivityList()
-            .findByType(ACTIVITY_NAME_DELIVERY)
-            .get();
+                        .findByType(DELIVERY_ACTIVITY_NAME)
+                        .get();
     }
 
-    public DeliveryActivity getBackhaulActivityTO_BE_RENAMED_LATER() {
+    public DeliveryActivity getBackhaulActivity() {
         return (DeliveryActivity) getActivityList()
-            .findByType(ACTIVITY_NAME_BACKHAUL)
-            .get();
+                        .findByType(BACKHAUL_ACTIVITY_NAME)
+                        .get();
     }
 
-
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
index 42790b724..cfb07e966 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
@@ -52,6 +52,9 @@
  */
 public class Shipment extends AbstractJob {
 
+    public static final String DELIVERY_ACTIVITY_NAME = "deliverShipment";
+    public static final String PICKUP_ACTIVITY_NAME = "pickupShipment";
+
     /**
      * Builder that builds the shipment.
      *
@@ -297,11 +300,11 @@ protected Shipment createInstance() {
     protected void createActivities(JobBuilder<?, ?> builder) {
         Builder shipmentBuilder = (Builder) builder;
         JobActivityList list = new SequentialJobActivityList(this);
-        list.addActivity(new PickupActivity(this, "pickupShipment",
+        list.addActivity(new PickupActivity(this, PICKUP_ACTIVITY_NAME,
                         shipmentBuilder.getPickupLocation(),
                         shipmentBuilder.getPickupServiceTime(), shipmentBuilder.getCapacity(),
                         shipmentBuilder.getPickupTimeWindows().getTimeWindows()));
-        list.addActivity(new DeliveryActivity(this, "deliverShipment",
+        list.addActivity(new DeliveryActivity(this, DELIVERY_ACTIVITY_NAME,
                         shipmentBuilder.getDeliveryLocation(),
                         shipmentBuilder.getDeliveryServiceTime(),
                         shipmentBuilder.getCapacity().invert(),
@@ -311,11 +314,11 @@ protected void createActivities(JobBuilder<?, ?> builder) {
     }
 
     public PickupActivity getPickupActivity() {
-        return (PickupActivity) getActivityList().findByType("pickupShipment").get();
+        return (PickupActivity) getActivityList().findByType(PICKUP_ACTIVITY_NAME).get();
     }
 
     public DeliveryActivity getDeliveryActivity() {
-        return (DeliveryActivity) getActivityList().findByType("deliverShipment").get();
+        return (DeliveryActivity) getActivityList().findByType(DELIVERY_ACTIVITY_NAME).get();
     }
 
     // =================== DEPRECATED GETTERS
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindows.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindows.java
index 0e49736f1..c3c8ebfbd 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindows.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindows.java
@@ -32,4 +32,29 @@
     public final TimeWindows ANY_TIME = TimeWindowsImpl.INTERNAL_ANY_TIME;
 
     public Collection<TimeWindow> getTimeWindows();
+
+
+    public static TimeWindows of(TimeWindow tw) {
+        TimeWindowsImpl tws = new TimeWindowsImpl();
+        tws.add(tw);
+        return tws;
+    }
+
+    public static TimeWindows of(TimeWindow tw, TimeWindow tw2) {
+        TimeWindowsImpl tws = new TimeWindowsImpl();
+        tws.add(tw);
+        tws.add(tw2);
+        return tws;
+    }
+
+    public static TimeWindows of(TimeWindow tw, TimeWindow tw2, TimeWindow... others) {
+        TimeWindowsImpl tws = new TimeWindowsImpl();
+        tws.add(tw);
+        tws.add(tw2);
+        for (TimeWindow otw : others) {
+            tws.add(otw);
+        }
+        return tws;
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindowsImpl.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindowsImpl.java
index f913cfa9a..7c79579ef 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindowsImpl.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindowsImpl.java
@@ -65,6 +65,22 @@ public void add(TimeWindow timeWindow) {
         timeWindows.add(timeWindow);
     }
 
+    public void addAll(TimeWindows timeWindows) {
+        addAll(timeWindows.getTimeWindows());
+    }
+
+    public void addAll(Collection<TimeWindow> timeWindows) {
+        for (TimeWindow tw : timeWindows) {
+            add(tw);
+        }
+    }
+
+    public void addAll(TimeWindow... otherTimeWindows) {
+        for (TimeWindow tw : otherTimeWindows) {
+            add(tw);
+        }
+    }
+
     @Override
     public Collection<TimeWindow> getTimeWindows() {
         return Collections.unmodifiableCollection(timeWindows);
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/DynamicTableDefinition.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/DynamicTableDefinition.java
new file mode 100644
index 000000000..9bd5b2716
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/DynamicTableDefinition.java
@@ -0,0 +1,387 @@
+package com.graphhopper.jsprit.core.reporting;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * @author balage
+ */
+public class DynamicTableDefinition {
+
+    public static interface ColumnType<T> {
+        public String convert(Object data);
+
+        public boolean accepts(Object data);
+    }
+
+    public static abstract class AbstractColumnType<T> implements ColumnType<T> {
+
+        private String nullValue = "";
+
+
+        public AbstractColumnType() {
+            super();
+        }
+
+        public AbstractColumnType(String nullValue) {
+            super();
+            this.nullValue = nullValue;
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public String convert(Object data) {
+            if (data == null) {
+                return nullValue;
+            } else {
+                if (accepts(data)) {
+                    return convertNotNull((T) data);
+                } else {
+                    throw new ClassCastException();
+                }
+            }
+        }
+
+        protected abstract String convertNotNull(T data);
+    }
+
+    public static class StringColumnType extends AbstractColumnType<Object> {
+
+        public StringColumnType() {
+            super();
+        }
+
+        public StringColumnType(String nullValue) {
+            super(nullValue);
+        }
+
+        @Override
+        protected String convertNotNull(Object data) {
+            return data.toString();
+        }
+
+        @Override
+        public boolean accepts(Object data) {
+            return true;
+        }
+
+    }
+
+    public static class IntColumnType extends AbstractColumnType<Integer> {
+
+        public IntColumnType() {
+            super();
+        }
+
+        public IntColumnType(String nullValue) {
+            super(nullValue);
+        }
+
+        @Override
+        protected String convertNotNull(Integer data) {
+            return data.toString();
+        }
+
+        @Override
+        public boolean accepts(Object data) {
+            return data instanceof Integer;
+        }
+
+    }
+
+    public static class LongColumnType extends AbstractColumnType<Long> {
+
+        public LongColumnType() {
+            super();
+        }
+
+        public LongColumnType(String nullValue) {
+            super(nullValue);
+        }
+
+        @Override
+        protected String convertNotNull(Long data) {
+            return data.toString();
+        }
+
+        @Override
+        public boolean accepts(Object data) {
+            return data instanceof Long;
+        }
+
+
+    }
+
+    public static class DoubleColumnType extends AbstractColumnType<Double> {
+
+        private int decimals = 2;
+
+        public DoubleColumnType() {
+            super();
+        }
+
+        public DoubleColumnType(String nullValue) {
+            super(nullValue);
+        }
+
+        public DoubleColumnType(int decimals) {
+            super();
+            this.decimals = decimals;
+        }
+
+        public DoubleColumnType(String nullValue, int decimals) {
+            super(nullValue);
+            this.decimals = decimals;
+        }
+
+        @Override
+        protected String convertNotNull(Double data) {
+            return String.format("%50." + decimals + "f", data).trim();
+        }
+
+        @Override
+        public boolean accepts(Object data) {
+            return data instanceof Double;
+        }
+
+
+    }
+
+
+    public static class BooleanColumnType extends AbstractColumnType<Boolean> {
+        private String trueValue = "true";
+        private String falseValue = "false";
+
+        public BooleanColumnType() {
+            super();
+        }
+
+        public BooleanColumnType(String nullValue) {
+            super(nullValue);
+        }
+
+        public BooleanColumnType(String trueValue, String falseValue) {
+            super();
+            this.trueValue = trueValue;
+            this.falseValue = falseValue;
+        }
+
+        public BooleanColumnType(String trueValue, String falseValue, String nullValue) {
+            super(nullValue);
+            this.trueValue = trueValue;
+            this.falseValue = falseValue;
+        }
+
+        @Override
+        protected String convertNotNull(Boolean data) {
+            return data ? trueValue : falseValue;
+        }
+
+        @Override
+        public boolean accepts(Object data) {
+            return data instanceof Boolean;
+        }
+    }
+
+    public enum Alignment {
+        LEFT {
+
+            @Override
+            public String align(String data, int width) {
+                if (data.length() > width) {
+                    return data.substring(0, width);
+                }
+                return String.format("%1$-" + width + "s", data);
+            }
+
+        }, RIGHT {
+
+            @Override
+            public String align(String data, int width) {
+                if (data.length() > width) {
+                    return data.substring(0, width);
+                }
+                return String.format("%1$" + width + "s", data);
+            }
+
+        }, CENTER {
+            @Override
+            public String align(String data, int width) {
+                if (data.length() > width) {
+                    return data.substring(0, width);
+                }
+                int leftPad = (width - data.length())/2;
+                return LEFT.align(RIGHT.align(data, width-leftPad), width);
+            }
+        };
+
+        public abstract String align(String data, int width);
+    }
+
+    public static class ColumnDefinition {
+
+        public static class Builder {
+            private ColumnType<?> type;
+            private String title;
+            private int minWidth = 0;
+            private int maxWidth = Integer.MAX_VALUE;
+            private Alignment alignment = Alignment.LEFT;
+
+            public Builder(ColumnType<?> type, String title) {
+                super();
+                this.type = type;
+                this.title = title;
+            }
+
+            public Builder withMinWidth(int minWidth) {
+                this.minWidth = minWidth;
+                return this;
+            }
+
+            public Builder withMaxWidth(int maxWidth) {
+                this.maxWidth = maxWidth;
+                return this;
+            }
+
+            public Builder withAlignment(Alignment alignment) {
+                this.alignment = alignment;
+                return this;
+            }
+
+            public ColumnDefinition build() {
+                return new ColumnDefinition(this);
+            }
+
+        }
+
+        private ColumnType<?> type;
+        private String title;
+        private int minWidth = 0;
+        private int maxWidth = Integer.MAX_VALUE;
+        private Alignment alignment = Alignment.LEFT;
+
+        private ColumnDefinition(Builder builder) {
+            type = builder.type;
+            title = builder.title;
+            minWidth = builder.minWidth;
+            maxWidth = builder.maxWidth;
+            alignment = builder.alignment;
+        }
+
+        public ColumnType<?> getType() {
+            return type;
+        }
+
+        public String getTitle() {
+            return title;
+        }
+
+        public int getMinWidth() {
+            return minWidth;
+        }
+
+        public int getMaxWidth() {
+            return maxWidth;
+        }
+
+        public Alignment getAlignment() {
+            return alignment;
+        }
+
+    }
+
+
+    public static class Builder {
+        private char corner = '+';
+        private char vertical = '|';
+        private char horizontal = '-';
+
+        private String heading = null;
+        private List<ColumnDefinition> columns = new ArrayList<>();
+
+        private int padding = 1;
+
+        public Builder withCorner(char corner) {
+            this.corner = corner;
+            return this;
+        }
+
+        public Builder withVertical(char vertical) {
+            this.vertical = vertical;
+            return this;
+        }
+
+        public Builder withHorizontal(char horizontal) {
+            this.horizontal = horizontal;
+            return this;
+        }
+
+        public Builder withHeading(String heading) {
+            this.heading = heading;
+            return this;
+        }
+
+        public Builder addColumn(ColumnDefinition column) {
+            columns.add(column);
+            return this;
+        }
+
+        public Builder withPadding(int padding) {
+            this.padding = Math.max(0, padding);
+            return this;
+        }
+
+        public DynamicTableDefinition build() {
+            return new DynamicTableDefinition(this);
+        }
+    }
+
+
+    private char corner = '+';
+    private char vertical = '|';
+    private char horizontal = '-';
+
+    private String heading = null;
+    private List<ColumnDefinition> columns = new ArrayList<>();
+
+    private int padding = 1;
+
+    private DynamicTableDefinition(Builder builder) {
+        corner = builder.corner;
+        vertical = builder.vertical;
+        horizontal = builder.horizontal;
+        heading = builder.heading;
+        columns = Collections.unmodifiableList(builder.columns);
+        padding = builder.padding;
+    }
+
+    public char getCorner() {
+        return corner;
+    }
+
+    public char getVertical() {
+        return vertical;
+    }
+
+    public char getHorizontal() {
+        return horizontal;
+    }
+
+    public String getHeading() {
+        return heading;
+    }
+
+    public List<ColumnDefinition> getColumns() {
+        return columns;
+    }
+
+    public int getPadding() {
+        return padding;
+    }
+
+    public int size() {
+        return columns.size();
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/DynamicTablePrinter.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/DynamicTablePrinter.java
new file mode 100644
index 000000000..59abfdfb1
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/DynamicTablePrinter.java
@@ -0,0 +1,210 @@
+package com.graphhopper.jsprit.core.reporting;
+
+import java.nio.CharBuffer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.IntStream;
+
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.Alignment;
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.ColumnDefinition;
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.DoubleColumnType;
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.StringColumnType;
+
+/**
+ * @author balage
+ */
+public class DynamicTablePrinter {
+
+    public class TableRow {
+        private String row[] = new String[tableDef.size()];
+        private int lastIndex = 0;
+
+        public TableRow() {
+            super();
+            Arrays.fill(row, "");
+        }
+
+        public TableRow set(int index, Object data) {
+            if (index < 0 || index >= row.length) {
+                throw new IndexOutOfBoundsException("Invalid index: " + index);
+            }
+            if (data != null) {
+                if (!tableDef.getColumns().get(index).getType().accepts(data)) {
+                    throw new ClassCastException("Cannot assign " + data.getClass().getSimpleName()
+                                    + " to " + tableDef.getColumns().get(index).getType().getClass()
+                                    .getSimpleName()
+                                    + "( index: " + index + ")");
+                }
+            }
+            String val = tableDef.getColumns().get(index).getType().convert(data);
+
+            row[index] = val;
+            return this;
+        }
+
+        public TableRow add(Object data) {
+            return set(lastIndex++, data);
+        }
+
+        public TableRow add(int data) {
+            return add(new Integer(data));
+        }
+
+        public TableRow add(long data) {
+            return add(new Long(data));
+        }
+
+        public TableRow add(double data) {
+            return add(new Double(data));
+        }
+
+        public TableRow add(boolean data) {
+            return add(Boolean.valueOf(data));
+        }
+
+        public String get(int index) {
+            if (index < 0 || index >= row.length) {
+                throw new IndexOutOfBoundsException("Invalid index: " + index);
+            }
+            return row[index];
+        }
+    }
+
+    private class Separator extends TableRow {
+    }
+
+    DynamicTableDefinition tableDef;
+
+    List<TableRow> rows = new ArrayList<>();
+
+    public DynamicTablePrinter(DynamicTableDefinition tableDef) {
+        this.tableDef = tableDef;
+    }
+
+    public TableRow addRow() {
+        TableRow row = new TableRow();
+        rows.add(row);
+        return row;
+    }
+
+    public void addSeparator() {
+        rows.add(new Separator());
+    }
+
+
+    private String repeat(char c, int w) {
+        return CharBuffer.allocate(w).toString().replace('\0', c);
+    }
+
+    public String print() {
+        StringBuilder sb = new StringBuilder();
+        int[] colWidth = calculateWidthInfo();
+        int totalWidth = colWidth.length * (tableDef.getPadding() * 2 + 1) + 1;
+        for (int w : colWidth) {
+            totalWidth += w;
+        }
+
+        char corner = tableDef.getCorner();
+        char horizontal = tableDef.getHorizontal();
+        char vertical = tableDef.getVertical();
+        int padding = tableDef.getPadding();
+
+        String paddingChars = repeat(' ', padding);
+
+        StringBuilder sbSep = new StringBuilder();
+        sbSep.append(corner);
+        for (int w : colWidth) {
+            sbSep.append(repeat(horizontal, w + 2 * padding)).append(corner);
+        }
+        sbSep.append("\n");
+        String separatorLine = sbSep.toString();
+
+        if (tableDef.getHeading() != null) {
+            sb.append(corner).append(repeat(horizontal, totalWidth - 2)).append(corner)
+            .append("\n");
+            sb.append(vertical).append(paddingChars)
+            .append(Alignment.LEFT.align(tableDef.getHeading(),
+                            totalWidth - 2 * padding - 2))
+            .append(paddingChars)
+            .append(vertical)
+            .append("\n");
+        }
+
+        sb.append(separatorLine);
+        sb.append(vertical);
+        for (int i = 0; i < tableDef.size(); i++) {
+            ColumnDefinition cd = tableDef.getColumns().get(i);
+            sb.append(paddingChars).append(Alignment.LEFT.align(cd.getTitle(), colWidth[i]))
+            .append(paddingChars).append(vertical);
+        }
+        sb.append("\n");
+        sb.append(separatorLine);
+
+        for(TableRow row : rows) {
+            if (row instanceof Separator) {
+                sb.append(separatorLine);
+            } else {
+                sb.append(vertical);
+                for (int i = 0; i < tableDef.size(); i++) {
+                    ColumnDefinition cd = tableDef.getColumns().get(i);
+                    sb.append(paddingChars).append(cd.getAlignment().align(row.get(i), colWidth[i]))
+                    .append(paddingChars).append(vertical);
+                }
+                sb.append("\n");
+            }
+        }
+        sb.append(separatorLine);
+
+        return sb.toString();
+    }
+
+    private int[] calculateWidthInfo() {
+        int colWidth[] = new int[tableDef.size()];
+        IntStream.range(0, tableDef.size()).forEach(i -> {
+            int max = rows.stream()
+                            .filter(r -> r instanceof TableRow)
+                            .map(r -> r.get(i))
+                            .filter(d -> d != null)
+                            .mapToInt(d -> d.length())
+                            .max().orElse(0);
+            ColumnDefinition colDef = tableDef.getColumns().get(i);
+            colWidth[i] = Math.max(colDef.getTitle().length(),
+                            Math.max(colDef.getMinWidth(), Math.min(colDef.getMaxWidth(), max)));
+        });
+        return colWidth;
+    }
+
+    public static void main(String[] args) {
+        DynamicTableDefinition td = new DynamicTableDefinition.Builder()
+                        // .withHeading("Test")
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "string")
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(),
+                                        "right-string")
+                                        .withAlignment(Alignment.CENTER).build())
+                        .addColumn(new ColumnDefinition.Builder(new DoubleColumnType(),
+                                        "double")
+                                        .withMinWidth(10)
+                                        .withAlignment(Alignment.RIGHT).build())
+                        .build();
+
+        DynamicTablePrinter p = new DynamicTablePrinter(td);
+
+        TableRow r;
+        r = p.addRow();
+        r.add("apple");
+        r.add("one");
+        r.add(Math.PI);
+        r = p.addRow();
+        r.add("banana");
+        r.add("two");
+        r.add(2d);
+        p.addSeparator();
+        r = p.addRow();
+        r.add("cherry");
+        r.add("four");
+
+        System.out.println(p.print());
+    }
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
index 52088d94b..35669a99c 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
@@ -17,6 +17,16 @@
  */
 package com.graphhopper.jsprit.core.reporting;
 
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.SizeDimension;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.job.Job;
@@ -25,13 +35,11 @@
 import com.graphhopper.jsprit.core.problem.solution.route.activity.AbstractActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-
-import java.io.PrintWriter;
-import java.nio.CharBuffer;
-import java.util.*;
-import java.util.function.Function;
-import java.util.regex.Pattern;
-import java.util.stream.Collectors;
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.Alignment;
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.ColumnDefinition;
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.IntColumnType;
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.LongColumnType;
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.StringColumnType;
 
 
 /**
@@ -90,29 +98,6 @@ public static void print(VehicleRoutingProblem problem, VehicleRoutingProblemSol
         SYSTEM_OUT_AS_PRINT_WRITER.flush();
     }
 
-    protected static String drawLineBase(String pattern, int count) {
-        Object[] par = new Object[count];
-        Arrays.fill(par, "");
-        String text = String.format(pattern, par);
-        return text;
-    }
-
-    protected static String drawLine(String pattern, int count) {
-        String text = drawLineBase(pattern, count);
-        return text.replaceAll(" ", "-").replaceAll(Pattern.quote("|"), "+");
-    }
-
-
-    protected static String drawHeading(String pattern, int count, String text) {
-        String base = drawLineBase(pattern, count).trim();
-        int internalWidth = base.lastIndexOf('|') - base.indexOf('|') - 1;
-        if (text == null) {
-            return "+" + CharBuffer.allocate(internalWidth).toString().replace('\0', '-') + "+\n";
-        } else {
-            return "| " + String.format("%-" + (internalWidth - 2) + "s", text) + " |\n";
-        }
-    }
-
     /**
      * Prints costs and #vehicles to the given writer
      *
@@ -120,30 +105,39 @@ protected static String drawHeading(String pattern, int count, String text) {
      * @param solution the solution to be printed
      */
     public static void print(PrintWriter out, VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution, Print print) {
-        String leftAlign = "| %-30s | %-8s |%n";
-
-        out.printf(drawHeading(leftAlign, 2, null));
-        out.printf(drawHeading(leftAlign, 2, "problem"));
-        out.printf(drawLine(leftAlign, 2));
-        out.format(leftAlign, "indicator", "value");
-        out.printf(drawLine(leftAlign, 2));
-
-        out.format(leftAlign, "noJobs", problem.getJobs().values().size());
-        getNuOfJobs(problem).entrySet().forEach(en -> out.format(leftAlign, "   " + en.getKey().getSimpleName(), en.getValue()));
-        out.format(leftAlign, "fleetsize", problem.getFleetSize().toString());
-        out.printf(drawLine(leftAlign, 2));
-
-
-        String leftAlignSolution = "| %-13s | %-40s |%n";
-        out.printf(drawHeading(leftAlignSolution, 2, null));
-        out.printf(drawHeading(leftAlignSolution, 2, "solution"));
-        out.printf(drawLine(leftAlignSolution, 2));
-        out.format(leftAlignSolution, "indicator", "value");
-        out.printf(drawLine(leftAlignSolution, 2));
-        out.format(leftAlignSolution, "costs", solution.getCost());
-        out.format(leftAlignSolution, "noVehicles", solution.getRoutes().size());
-        out.format(leftAlignSolution, "unassgndJobs", solution.getUnassignedJobs().size());
-        out.printf(drawLine(leftAlignSolution, 2));
+
+        DynamicTableDefinition problemTableDef = new DynamicTableDefinition.Builder()
+                        .withHeading("Problem")
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "indicator")
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "value")
+                                        .build())
+                        .build();
+
+        DynamicTablePrinter problemTablePrinter = new DynamicTablePrinter(problemTableDef);
+        problemTablePrinter.addRow().add("fleetsize").add(problem.getFleetSize());
+        problemTablePrinter.addSeparator();
+        problemTablePrinter.addRow().add("noJobs").add(problem.getJobs().values().size());
+        for (Entry<Class<? extends Job>, Long> jc : getNuOfJobs(problem).entrySet()) {
+            problemTablePrinter.addRow().add("   " + jc.getKey().getSimpleName())
+            .add(jc.getValue());
+        }
+        out.println(problemTablePrinter.print());
+
+        DynamicTableDefinition solutionTableDef = new DynamicTableDefinition.Builder()
+                        .withHeading("Solution")
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "indicator")
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "value")
+                                        .build())
+                        .build();
+
+        DynamicTablePrinter solutionTablePrinter = new DynamicTablePrinter(solutionTableDef);
+        solutionTablePrinter.addRow().add("costs")
+        .add(String.format("%6.2f", solution.getCost()).trim());
+        solutionTablePrinter.addRow().add("noVehicles").add(solution.getRoutes().size());
+        solutionTablePrinter.addRow().add("unassgndJobs").add(solution.getUnassignedJobs().size());
+        out.println(solutionTablePrinter.print());
 
         if (print.equals(Print.VERBOSE)) {
             printVerbose(out, problem, solution);
@@ -157,20 +151,51 @@ private static void printVerbose(VehicleRoutingProblem problem, VehicleRoutingPr
     }
 
     private static void printVerbose(PrintWriter out, VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution) {
-        String leftAlgin = "| %-7s | %-20s | %-21s | %-15s | %-15s | %-15s | %-15s | %-15s |%n";
-        out.format("+--------------------------------------------------------------------------------------------------------------------------------------------------+%n");
-        out.printf("| detailed solution                                                                                                                                |%n");
-        out.format("+---------+----------------------+-----------------------+-----------------+-----------------+-----------------+-----------------+-----------------+%n");
-        out.printf("| route   | vehicle              | activity              | job             | load            | arrTime         | endTime         | costs           |%n");
+
+        DynamicTableDefinition tableDef = new DynamicTableDefinition.Builder()
+                        .withHeading("Detailed solution")
+                        .addColumn(new ColumnDefinition.Builder(new IntColumnType(), "route")
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "vehicle")
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "activity")
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType("-"), "job")
+                                        .withMinWidth(10)
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "load")
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "location")
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new LongColumnType("-"), "arrTime")
+                                        .withAlignment(Alignment.RIGHT)
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new LongColumnType("-"), "endTime")
+                                        .withAlignment(Alignment.RIGHT)
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new LongColumnType(), "cost")
+                                        .withAlignment(Alignment.RIGHT)
+                                        .build())
+                        .build();
+
+        DynamicTablePrinter tablePrinter = new DynamicTablePrinter(tableDef);
         int routeNu = 1;
 
         List<VehicleRoute> list = new ArrayList<VehicleRoute>(solution.getRoutes());
         Collections.sort(list, new com.graphhopper.jsprit.core.util.VehicleIndexComparator());
         for (VehicleRoute route : list) {
-            out.format("+---------+----------------------+-----------------------+-----------------+-----------------+-----------------+-----------------+-----------------+%n");
+            if (routeNu != 1) {
+                tablePrinter.addSeparator();
+            }
+
             double costs = 0;
             SizeDimension load = getInitialLoad(route);
-            out.format(leftAlgin, routeNu, getVehicleString(route), route.getStart().getName(), "-", getString(load), "undef", Math.round(route.getStart().getEndTime()), Math.round(costs));
+            tablePrinter.addRow().add(routeNu).add(getVehicleString(route)).add(route.getStart().getName()).add(null)
+            .add(getString(load))
+            .add(getLocationString(route.getStart().getLocation()))
+            .add(null)
+            .add(Math.round(route.getStart().getEndTime())).add(Math.round(costs));
+
             TourActivity prevAct = route.getStart();
             for (TourActivity act : route.getActivities()) {
                 String jobId;
@@ -180,43 +205,72 @@ private static void printVerbose(PrintWriter out, VehicleRoutingProblem problem,
                     jobId = "-";
                 }
                 String type = (act instanceof AbstractActivity)
-                    ? ((AbstractActivity) act).getType() : act.getName();
-                double c = problem.getTransportCosts().getTransportCost(prevAct.getLocation(), act.getLocation(), prevAct.getEndTime(), route.getDriver(),
-                    route.getVehicle());
-                c += problem.getActivityCosts().getActivityCost(act, act.getArrTime(), route.getDriver(), route.getVehicle());
-                costs += c;
-                load = load.add(act.getLoadChange());
-                out.format(leftAlgin, routeNu, getVehicleString(route), type, jobId, getString(load),
-                    Math.round(act.getArrTime()),
-                    Math.round(act.getEndTime()), Math.round(costs));
-                prevAct = act;
+                                ? ((AbstractActivity) act).getType() : act.getName();
+                                double c = problem.getTransportCosts().getTransportCost(prevAct.getLocation(), act.getLocation(), prevAct.getEndTime(), route.getDriver(),
+                                                route.getVehicle());
+                                c += problem.getActivityCosts().getActivityCost(act, act.getArrTime(), route.getDriver(), route.getVehicle());
+                                costs += c;
+                                load = load.add(act.getLoadChange());
+
+                                tablePrinter.addRow().add(routeNu).add(getVehicleString(route)).add(type).add(jobId)
+                                .add(getString(load)).add(getLocationString(act.getLocation()))
+                                .add(Math.round(act.getArrTime()))
+                                .add(Math.round(act.getEndTime())).add(Math.round(costs));
+                                prevAct = act;
             }
             double c = problem.getTransportCosts().getTransportCost(prevAct.getLocation(), route.getEnd().getLocation(), prevAct.getEndTime(),
-                route.getDriver(), route.getVehicle());
+                            route.getDriver(), route.getVehicle());
             c += problem.getActivityCosts().getActivityCost(route.getEnd(), route.getEnd().getArrTime(), route.getDriver(), route.getVehicle());
             costs += c;
-            out.format(leftAlgin, routeNu, getVehicleString(route), route.getEnd().getName(), "-", getString(load), Math.round(route.getEnd().getArrTime()), "undef",
-                Math.round(costs));
+
+            tablePrinter.addRow().add(routeNu).add(getVehicleString(route))
+            .add(route.getEnd().getName()).add(null)
+            .add(getString(load))
+            .add(getLocationString(route.getEnd().getLocation()))
+            .add(null).add(Math.round(route.getEnd().getEndTime()))
+            .add(Math.round(costs));
+
             routeNu++;
         }
-        out.format("+--------------------------------------------------------------------------------------------------------------------------------------------------+%n");
+        out.println(tablePrinter.print());
+
+
         if (!solution.getUnassignedJobs().isEmpty()) {
-            out.format("+----------------+%n");
-            out.format("| unassignedJobs |%n");
-            out.format("+----------------+%n");
-            String unassignedJobAlgin = "| %-14s |%n";
+
+            DynamicTableDefinition unassignedTableDef = new DynamicTableDefinition.Builder()
+                            .withHeading("Unassigned jobs")
+                            .addColumn(new ColumnDefinition.Builder(new StringColumnType(),
+                                            "id")
+                                            .withMinWidth(10)
+                                            .build())
+                            .addColumn(new ColumnDefinition.Builder(new StringColumnType(),
+                                            "type")
+                                            .build())
+                            .build();
+
+            DynamicTablePrinter unassignedTablePrinter = new DynamicTablePrinter(unassignedTableDef);
+
             for (Job j : solution.getUnassignedJobs()) {
-                out.format(unassignedJobAlgin, j.getId());
+                unassignedTablePrinter.addRow().add(j.getId()).add(j.getClass().getSimpleName());
             }
-            out.format("+----------------+%n");
+            out.println(unassignedTablePrinter.print());
+        }
+    }
+
+    private static String getLocationString(Location l) {
+        if (l == null) {
+            return null;
+        } else {
+            return l.getId();
         }
     }
 
     private static String getString(SizeDimension load) {
         String l = "[";
         for (int i = 0; i < load.getNuOfDimensions(); i++) {
-            if (i > 0) l += ", " + load.get(i);
-            else {
+            if (i > 0) {
+                l += ", " + load.get(i);
+            } else {
                 l += load.get(i);
             }
         }
@@ -239,8 +293,8 @@ private static String getVehicleString(VehicleRoute route) {
 
     private static Map<Class<? extends Job>, Long> getNuOfJobs(VehicleRoutingProblem problem) {
         return problem.getJobs().values().stream()
-            .map(j -> (Class<? extends Job>) j.getClass())
-            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
+                        .map(j -> (Class<? extends Job>) j.getClass())
+                        .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
     }
 
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobExample.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobExample.java
index 345a5da1c..7ed274caf 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobExample.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobExample.java
@@ -25,11 +25,11 @@
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.SizeDimension;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.job.CustomJob;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
 import com.graphhopper.jsprit.core.reporting.SolutionPrinter;
-import com.graphhopper.jsprit.core.util.CustomJob;
 import com.graphhopper.jsprit.core.util.Solutions;
 
 /**
@@ -39,10 +39,11 @@
 
     @Test
     public void test() {
-        CustomJob cj = CustomJob.Builder.newInstance("job").addPickup(Location.newInstance(10, 0), SizeDimension.EMPTY).build();
+        CustomJob cj = CustomJob.Builder.newInstance("job")
+                        .addPickup(Location.newInstance(10, 0), SizeDimension.EMPTY).build();
         Vehicle v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0, 0)).build();
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
-            .addJob(cj).addVehicle(v).build();
+                        .addJob(cj).addVehicle(v).build();
         VehicleRoutingAlgorithm vra = Jsprit.createAlgorithm(vrp);
         VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
         SolutionPrinter.print(vrp, solution, SolutionPrinter.Print.VERBOSE);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobWithMultipleActivitiesExample.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobWithMultipleActivitiesExample.java
index c00ddf2c3..c1751092d 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobWithMultipleActivitiesExample.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobWithMultipleActivitiesExample.java
@@ -27,13 +27,13 @@
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.SizeDimension;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.job.CustomJob;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
 import com.graphhopper.jsprit.core.reporting.SolutionPrinter;
-import com.graphhopper.jsprit.core.util.CustomJob;
 import com.graphhopper.jsprit.core.util.Solutions;
 
 /**
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestLocalActivityInsertionCostsCalculator.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestLocalActivityInsertionCostsCalculator.java
index 18b0789d2..2a7cc9fcd 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestLocalActivityInsertionCostsCalculator.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestLocalActivityInsertionCostsCalculator.java
@@ -38,6 +38,7 @@
 import com.graphhopper.jsprit.core.problem.cost.WaitingTimeCosts;
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.job.Service;
+import com.graphhopper.jsprit.core.problem.job.Shipment;
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
@@ -92,6 +93,74 @@ private Location loc(String i) {
         return Location.Builder.newInstance().setId(i).build();
     }
 
+    @Test
+    public void whenAddingServiceBetweenDiffStartAndEnd_costMustBeCorrect() {
+        VehicleImpl v = VehicleImpl.Builder.newInstance("v")
+            .setStartLocation(Location.newInstance(0, 0))
+            .setEndLocation(Location.newInstance(20, 0))
+            .build();
+        Service s = Service.Builder.newInstance("s")
+            .setLocation(Location.newInstance(10, 0))
+            .build();
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
+            .addVehicle(v)
+            .addJob(s)
+            .build();
+        VehicleRoute route = VehicleRoute.emptyRoute();
+        JobInsertionContext jobInsertionContext =
+            new JobInsertionContext(route, s, v, null, 0);
+        LocalActivityInsertionCostsCalculator localActivityInsertionCostsCalculator =
+            new LocalActivityInsertionCostsCalculator(
+                vrp.getTransportCosts(),
+                vrp.getActivityCosts(),
+                new StateManager(vrp));
+        double cost = localActivityInsertionCostsCalculator.getCosts(
+            jobInsertionContext,
+            new Start(v.getStartLocation(),0,Double.MAX_VALUE),
+            new End(v.getEndLocation(),0,Double.MAX_VALUE),
+            vrp.getActivities(s).get(0),
+            0);
+        assertEquals(20., cost, Math.ulp(20.));
+    }
+
+    @Test
+    public void whenAddingShipmentBetweenDiffStartAndEnd_costMustBeCorrect() {
+        VehicleImpl v = VehicleImpl.Builder.newInstance("v")
+            .setStartLocation(Location.newInstance(0, 0))
+            .setEndLocation(Location.newInstance(20, 0))
+            .build();
+        Shipment s = Shipment.Builder.newInstance("p")
+            .setPickupLocation(Location.newInstance(10, 0))
+            .setDeliveryLocation(Location.newInstance(10, 7.5))
+            .build();
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
+            .addVehicle(v)
+            .addJob(s)
+            .build();
+        VehicleRoute route = VehicleRoute.emptyRoute();
+        JobInsertionContext jobInsertionContext =
+            new JobInsertionContext(route, s, v, null, 0);
+        LocalActivityInsertionCostsCalculator localActivityInsertionCostsCalculator =
+            new LocalActivityInsertionCostsCalculator(
+                vrp.getTransportCosts(),
+                vrp.getActivityCosts(),
+                new StateManager(vrp));
+        double cost = localActivityInsertionCostsCalculator.getCosts(
+            jobInsertionContext,
+            new Start(v.getStartLocation(),0,Double.MAX_VALUE),
+            new End(v.getEndLocation(),0,Double.MAX_VALUE),
+            vrp.getActivities(s).get(0),
+            0);
+        assertEquals(20., cost, Math.ulp(20.));
+        cost = localActivityInsertionCostsCalculator.getCosts(
+            jobInsertionContext,
+            vrp.getActivities(s).get(0),
+            new End(v.getEndLocation(),0,Double.MAX_VALUE),
+            vrp.getActivities(s).get(1),
+            0);
+        assertEquals(10, cost, Math.ulp(10.));
+    }
+
     @Test
     public void whenInsertingActBetweenTwoRouteActs_itCalcsMarginalTpCosts() {
         TourActivity prevAct = mock(TourActivity.class);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/LoadConstraintTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/LoadConstraintTest.java
index 7bce56cdb..367062d9f 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/LoadConstraintTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/LoadConstraintTest.java
@@ -37,6 +37,7 @@
 import com.graphhopper.jsprit.core.problem.SizeDimension;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.job.Delivery;
+import com.graphhopper.jsprit.core.problem.job.CustomJob;
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.job.Pickup;
 import com.graphhopper.jsprit.core.problem.job.Service;
@@ -51,7 +52,6 @@
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
-import com.graphhopper.jsprit.core.util.CustomJob;
 
 /**
  * unit tests to test load constraints
@@ -112,10 +112,10 @@ public void doBefore() {
     @Test
     public void whenCustomJob_itShouldNotIgnoreCapacity() {
         CustomJob cj = CustomJob.Builder.newInstance("job")
-            .addPickup(Location.newInstance(10, 0), SizeDimension.Builder.newInstance().addDimension(0, 1).build())
-            .addPickup(Location.newInstance(5, 0), SizeDimension.Builder.newInstance().addDimension(0, 2).build())
-            .addPickup(Location.newInstance(20, 0), SizeDimension.Builder.newInstance().addDimension(0, 1).build())
-            .build();
+                        .addPickup(Location.newInstance(10, 0), SizeDimension.Builder.newInstance().addDimension(0, 1).build())
+                        .addPickup(Location.newInstance(5, 0), SizeDimension.Builder.newInstance().addDimension(0, 2).build())
+                        .addPickup(Location.newInstance(20, 0), SizeDimension.Builder.newInstance().addDimension(0, 1).build())
+                        .build();
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0, 2).build();
         Vehicle v = VehicleImpl.Builder.newInstance("v").setType(type).setStartLocation(Location.newInstance(0, 0)).build();
         VehicleRoutingProblem.Builder.newInstance().addJob(cj).addVehicle(v).build();
@@ -134,7 +134,7 @@ public void whenCustomJob_itShouldNotIgnoreCapacity() {
     public void whenServiceRouteAndNewServiceFitsIn_itShouldReturnFulfilled() {
         stateManager.informInsertionStarts(Arrays.asList(serviceRoute), Collections.emptyList());
         Service s = Service.Builder.newInstance("service").setLocation(Location.newInstance(0))
-            .addSizeDimension(0, 5).build();
+                        .addSizeDimension(0, 5).build();
         ServiceLoadRouteLevelConstraint loadConstraint = new ServiceLoadRouteLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
@@ -283,8 +283,8 @@ public void whenPDRouteRouteAndNewDeliveryFitsIn_itShouldReturnFulfilled() {
     public void whenPDRouteRouteAndNewPickupDoesNotFitIn_itShouldReturnNotFulfilled() {
         stateManager.informInsertionStarts(Arrays.asList(pickupDeliveryRoute), Collections.<Job>emptyList());
         Pickup s = Pickup.Builder.newInstance("pickup")
-            .setLocation(Location.newInstance(0))
-            .addSizeDimension(0, 11).build();
+                        .setLocation(Location.newInstance(0))
+                        .addSizeDimension(0, 11).build();
         ServiceLoadRouteLevelConstraint loadConstraint = new ServiceLoadRouteLevelConstraint(stateManager);
         JobInsertionContext context = new JobInsertionContext(pickupDeliveryRoute, s, serviceRoute.getVehicle(), null, 0.);
         assertFalse(loadConstraint.fulfilled(context));
@@ -294,7 +294,7 @@ public void whenPDRouteRouteAndNewPickupDoesNotFitIn_itShouldReturnNotFulfilled(
     public void whenPDRouteRouteAndNewDeliveryDoesNotFitIn_itShouldReturnNotFulfilled() {
         stateManager.informInsertionStarts(Arrays.asList(pickupDeliveryRoute), Collections.<Job>emptyList());
         Delivery s = Delivery.Builder.newInstance("del").setLocation(Location.newInstance(0))
-            .addSizeDimension(0, 16).build();
+                        .addSizeDimension(0, 16).build();
         ServiceLoadRouteLevelConstraint loadConstraint = new ServiceLoadRouteLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(pickupDeliveryRoute, s, serviceRoute.getVehicle(), null, 0.);
@@ -314,7 +314,7 @@ public void whenPDRoute_newPickupShouldFitInBetweenStartAndAct1() {
 
         JobInsertionContext context = new JobInsertionContext(pickupDeliveryRoute, s, pickupDeliveryRoute.getVehicle(), null, 0.);
         PickupActivity newAct = new PickupActivity(s, "pick", null, 0, newSize,
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickupDeliveryRoute.getStart(), newAct, pickupDeliveryRoute.getActivities().get(0), 0.);
 
@@ -331,7 +331,7 @@ public void whenPDRoute_newPickupShouldFitInBetweenAct1AndAct2() {
 
         JobInsertionContext context = new JobInsertionContext(pickupDeliveryRoute, s, pickupDeliveryRoute.getVehicle(), null, 0.);
         PickupActivity newAct = new PickupActivity(s, "pick", null, 0, newSize,
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickupDeliveryRoute.getActivities().get(0), newAct, pickupDeliveryRoute.getActivities().get(1), 0.);
 
@@ -348,7 +348,7 @@ public void whenPDRoute_newPickupShouldFitInBetweenAct2AndEnd() {
 
         JobInsertionContext context = new JobInsertionContext(pickupDeliveryRoute, s, pickupDeliveryRoute.getVehicle(), null, 0.);
         PickupActivity newAct = new PickupActivity(s, "pick", null, 0, newSize,
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickupDeliveryRoute.getActivities().get(1), newAct, pickupDeliveryRoute.getEnd(), 0.);
 
@@ -368,7 +368,7 @@ public void whenPDRoute_newPickupShouldNotFitInBetweenStartAndAct1() {
 
         JobInsertionContext context = new JobInsertionContext(pickupDeliveryRoute, s, pickupDeliveryRoute.getVehicle(), null, 0.);
         PickupActivity newAct = new PickupActivity(s, "pick", null, 0, newSize,
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickupDeliveryRoute.getStart(), newAct, pickupDeliveryRoute.getActivities().get(0), 0.);
 
@@ -385,7 +385,7 @@ public void whenPDRoute_newPickupShouldNotFitInBetweenAct1AndAct2() {
 
         JobInsertionContext context = new JobInsertionContext(pickupDeliveryRoute, s, pickupDeliveryRoute.getVehicle(), null, 0.);
         PickupActivity newAct = new PickupActivity(s, "pick", null, 0, newSize,
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickupDeliveryRoute.getActivities().get(0), newAct, pickupDeliveryRoute.getActivities().get(1), 0.);
 
@@ -402,7 +402,7 @@ public void whenPDRoute_newPickupShouldNotFitInBetweenAct2AndEnd() {
 
         JobInsertionContext context = new JobInsertionContext(pickupDeliveryRoute, s, pickupDeliveryRoute.getVehicle(), null, 0.);
         PickupActivity newAct = new PickupActivity(s, "pick", null, 0, newSize,
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickupDeliveryRoute.getActivities().get(1), newAct, pickupDeliveryRoute.getEnd(), 0.);
 
@@ -423,8 +423,8 @@ public void whenPDRoute_newDeliveryShouldFitInBetweenStartAndAct1() {
 
         JobInsertionContext context = new JobInsertionContext(pickupDeliveryRoute, s, pickupDeliveryRoute.getVehicle(), null, 0.);
         DeliveryActivity newAct = new DeliveryActivity(s, "del", null, 0,
-            newSize.invert(),
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        newSize.invert(),
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickupDeliveryRoute.getStart(), newAct, pickupDeliveryRoute.getActivities().get(0), 0.);
 
@@ -441,8 +441,8 @@ public void whenPDRoute_newDeliveryShouldNotFitInBetweenStartAndAct1() {
 
         JobInsertionContext context = new JobInsertionContext(pickupDeliveryRoute, s, pickupDeliveryRoute.getVehicle(), null, 0.);
         DeliveryActivity newAct = new DeliveryActivity(s, "del", null, 0,
-            newSize.invert(),
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        newSize.invert(),
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickupDeliveryRoute.getStart(), newAct, pickupDeliveryRoute.getActivities().get(0), 0.);
 
@@ -459,8 +459,8 @@ public void whenPDRoute_newDeliveryShouldFitInBetweenAct1AndAct2() {
 
         JobInsertionContext context = new JobInsertionContext(pickupDeliveryRoute, s, pickupDeliveryRoute.getVehicle(), null, 0.);
         DeliveryActivity newAct = new DeliveryActivity(s, "del", null, 0,
-            newSize.invert(),
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        newSize.invert(),
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickupDeliveryRoute.getActivities().get(0), newAct, pickupDeliveryRoute.getActivities().get(1), 0.);
 
@@ -477,8 +477,8 @@ public void whenPDRoute_newDeliveryNotShouldFitInBetweenAct1AndAct2() {
 
         JobInsertionContext context = new JobInsertionContext(pickupDeliveryRoute, s, pickupDeliveryRoute.getVehicle(), null, 0.);
         DeliveryActivity newAct = new DeliveryActivity(s, "del", null, 0,
-            newSize.invert(),
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        newSize.invert(),
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickupDeliveryRoute.getActivities().get(0), newAct, pickupDeliveryRoute.getActivities().get(1), 0.);
 
@@ -495,8 +495,8 @@ public void whenPDRoute_newDeliveryShouldFitInBetweenAct2AndEnd() {
 
         JobInsertionContext context = new JobInsertionContext(pickupDeliveryRoute, s, pickupDeliveryRoute.getVehicle(), null, 0.);
         DeliveryActivity newAct = new DeliveryActivity(s, "del", null, 0,
-            newSize.invert(),
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        newSize.invert(),
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickupDeliveryRoute.getActivities().get(1), newAct, pickupDeliveryRoute.getEnd(), 0.);
 
@@ -513,8 +513,8 @@ public void whenPDRoute_newDeliveryShouldNotFitInBetweenAct2AndEnd() {
 
         JobInsertionContext context = new JobInsertionContext(pickupDeliveryRoute, s, pickupDeliveryRoute.getVehicle(), null, 0.);
         DeliveryActivity newAct = new DeliveryActivity(s, "del", null, 0,
-            newSize.invert(),
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        newSize.invert(),
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickupDeliveryRoute.getActivities().get(1), newAct, pickupDeliveryRoute.getEnd(), 0.);
 
@@ -637,7 +637,7 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldFitInBetweenStartAndAct
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         PickupActivity newAct = new PickupActivity(s, "pick", null, 0, newSize,
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getStart(), newAct, shipmentRoute.getActivities().get(0), 0.);
 
@@ -655,7 +655,7 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldNotFitInBetweenStartAnd
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         PickupActivity newAct = new PickupActivity(s, "pick", null, 0, newSize,
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getStart(), newAct, shipmentRoute.getActivities().get(0), 0.);
 
@@ -673,7 +673,7 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldFitInBetweenAct1AndAct2
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         PickupActivity newAct = new PickupActivity(s, "pick", null, 0, newSize,
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getActivities().get(0), newAct, shipmentRoute.getActivities().get(1), 0.);
 
@@ -691,7 +691,7 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldNotFitInBetweenAct1AndA
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         PickupActivity newAct = new PickupActivity(s, "pick", null, 0, newSize,
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getActivities().get(0), newAct, shipmentRoute.getActivities().get(1), 0.);
 
@@ -709,7 +709,7 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldFitInBetweenAct2AndAct3
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         PickupActivity newAct = new PickupActivity(s, "pick", null, 0, newSize,
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getActivities().get(1), newAct, shipmentRoute.getActivities().get(2), 0.);
 
@@ -727,7 +727,7 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldNotFitInBetweenAct2AndA
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         PickupActivity newAct = new PickupActivity(s, "pick", null, 0, newSize,
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getActivities().get(1), newAct, shipmentRoute.getActivities().get(2), 0.);
 
@@ -745,7 +745,7 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldFitInBetweenAct3AndAct4
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         PickupActivity newAct = new PickupActivity(s, "pick", null, 0, newSize,
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getActivities().get(2), newAct, shipmentRoute.getActivities().get(3), 0.);
 
@@ -763,7 +763,7 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldNotFitInBetweenAct3AndA
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         PickupActivity newAct = new PickupActivity(s, "pick", null, 0, newSize,
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getActivities().get(2), newAct, shipmentRoute.getActivities().get(3), 0.);
 
@@ -781,7 +781,7 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldFitInBetweenAct4AndEnd(
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         PickupActivity newAct = new PickupActivity(s, "pick", null, 0, newSize,
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getActivities().get(3), newAct, shipmentRoute.getEnd(), 0.);
 
@@ -799,7 +799,7 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldNotFitInBetweenAct4AndE
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         PickupActivity newAct = new PickupActivity(s, "pick", null, 0, newSize,
-            TimeWindows.ANY_TIME.getTimeWindows());
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getActivities().get(3), newAct, shipmentRoute.getEnd(), 0.);
 
@@ -821,7 +821,7 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldFitInBetweenStartAndA
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         DeliveryActivity newAct = new DeliveryActivity(s, "pick", null, 0,
-            newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
+                        newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getStart(), newAct, shipmentRoute.getActivities().get(0), 0.);
 
@@ -839,7 +839,7 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldNotFitInBetweenStartA
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         DeliveryActivity newAct = new DeliveryActivity(s, "pick", null, 0,
-            newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
+                        newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getStart(), newAct, shipmentRoute.getActivities().get(0), 0.);
 
@@ -857,7 +857,7 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldFitInBetweenAct1AndAc
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         DeliveryActivity newAct = new DeliveryActivity(s, "pick", null, 0,
-            newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
+                        newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getActivities().get(0), newAct, shipmentRoute.getActivities().get(1), 0.);
 
@@ -875,7 +875,7 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldNotFitInBetweenAct1An
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         DeliveryActivity newAct = new DeliveryActivity(s, "pick", null, 0,
-            newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
+                        newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getActivities().get(0), newAct, shipmentRoute.getActivities().get(1), 0.);
 
@@ -893,7 +893,7 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldFitInBetweenAct2AndAc
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         DeliveryActivity newAct = new DeliveryActivity(s, "pick", null, 0,
-            newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
+                        newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getActivities().get(1), newAct, shipmentRoute.getActivities().get(2), 0.);
 
@@ -911,7 +911,7 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldNotFitInBetweenAct2An
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         DeliveryActivity newAct = new DeliveryActivity(s, "pick", null, 0,
-            newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
+                        newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getActivities().get(1), newAct, shipmentRoute.getActivities().get(2), 0.);
 
@@ -929,7 +929,7 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldFitInBetweenAct3AndAc
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         DeliveryActivity newAct = new DeliveryActivity(s, "pick", null, 0,
-            newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
+                        newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getActivities().get(2), newAct, shipmentRoute.getActivities().get(3), 0.);
 
@@ -947,7 +947,7 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldNotFitInBetweenAct3An
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         DeliveryActivity newAct = new DeliveryActivity(s, "pick", null, 0,
-            newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
+                        newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getActivities().get(2), newAct, shipmentRoute.getActivities().get(3), 0.);
 
@@ -965,7 +965,7 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldFitInBetweenAct4AndEn
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         DeliveryActivity newAct = new DeliveryActivity(s, "pick", null, 0,
-            newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
+                        newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getActivities().get(3), newAct, shipmentRoute.getEnd(), 0.);
 
@@ -982,7 +982,7 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldNotFitInBetweenAct4An
         JobInsertionContext context = new JobInsertionContext(shipmentRoute, s, shipmentRoute.getVehicle(), null, 0.);
 
         DeliveryActivity newAct = new DeliveryActivity(s, "pick", null, 0,
-            newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
+                        newSize.invert(), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipmentRoute.getActivities().get(3), newAct, shipmentRoute.getEnd(), 0.);
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
index 5dcb0e0bb..05cafeaf9 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
@@ -42,6 +42,8 @@
 import com.graphhopper.jsprit.core.problem.job.Shipment;
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.Start;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
@@ -117,6 +119,29 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
         stateManager.informInsertionStarts(Arrays.asList(route), Collections.<Job>emptyList());
     }
 
+    @Test
+    public void whenEndLocationIsSet_constraintShouldWork(){
+        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0,0))
+            .setEndLocation(Location.newInstance(10,0)).build();
+        Pickup pickup = Pickup.Builder.newInstance("pickup").setLocation(Location.newInstance(10,0)).build();
+        vrp = VehicleRoutingProblem.Builder.newInstance().addVehicle(vehicle).addJob(pickup).build();
+        route = VehicleRoute.emptyRoute();
+        maxDistanceMap = new HashMap<>();
+        maxDistanceMap.put(vehicle,5d);
+
+        MaxDistanceConstraint maxDistanceConstraint =
+            new MaxDistanceConstraint(new StateManager(vrp), traveledDistanceId, new TransportDistance() {
+                @Override
+                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                }
+            },maxDistanceMap);
+        JobInsertionContext context = new JobInsertionContext(route,pickup,vehicle,null,0);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,
+            new Start(vehicle.getStartLocation(),0,Double.MAX_VALUE),vrp.getActivities(pickup).get(0),
+            new End(vehicle.getEndLocation(),0,Double.MAX_VALUE),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+    }
+
     /*
     vehicle: 200.0
 vehicle (max distance): 200.0
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ReturnedShipmentTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ReturnedShipmentTest.java
new file mode 100644
index 000000000..400b4cd66
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ReturnedShipmentTest.java
@@ -0,0 +1,559 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.jsprit.core.problem.job;
+
+import static org.hamcrest.core.Is.is;
+import static org.hamcrest.core.IsCollectionContaining.hasItem;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import com.graphhopper.jsprit.core.algorithm.VehicleRoutingAlgorithm;
+import com.graphhopper.jsprit.core.algorithm.box.Jsprit;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.SizeDimension;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem.FleetSize;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
+import com.graphhopper.jsprit.core.reporting.SolutionPrinter;
+import com.graphhopper.jsprit.core.util.Coordinate;
+import com.graphhopper.jsprit.core.util.Solutions;
+import com.graphhopper.jsprit.core.util.TestUtils;
+
+public class ReturnedShipmentTest {
+
+    @Test
+    public void whenTwoReturnedShipmentsHaveTheSameId_theyReferencesShouldBeUnEqual() {
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, 10)
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").build()).
+                        setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
+        ReturnedShipment two = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, 10)
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").build()).
+                        setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
+
+        assertTrue(one != two);
+    }
+
+    @Test
+    public void sizeAtStartAndEndShouldBeCorrect() {
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, 10)
+                        .addSizeDimension(1, 5)
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").build()).
+                        setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
+        SizeDimension cap = SizeDimension.Builder.newInstance().addDimension(0, 0).addDimension(1, 0).build();
+        assertTrue(one.getSizeAtStart().equals(cap));
+        assertTrue(one.getSizeAtEnd().equals(cap));
+    }
+
+    @Test
+    public void whenTwoReturnedShipmentsHaveTheSameId_theyShouldBeEqual() {
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, 10)
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").build()).
+                        setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
+        ReturnedShipment two = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, 10)
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").build()).
+                        setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
+
+        assertTrue(one.equals(two));
+    }
+
+    @Test
+    public void whenReturnedShipmentIsInstantiatedWithASizeOf10_theSizeShouldBe10() {
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, 10)
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").build()).
+                        setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
+        assertEquals(10, one.getSize().get(0));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenReturnedShipmentIsBuiltWithNegativeDemand_itShouldThrowException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, -10)
+        .setPickupLocation(Location.Builder.newInstance().setId("foo").build())
+        .setDeliveryLocation(TestUtils.loc("foofoo")).build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenReturnedShipmentIsBuiltWithNegativeDemand_itShouldThrowException_v2() {
+        @SuppressWarnings("unused")
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, -10)
+        .setPickupLocation(Location.Builder.newInstance().setId("foo").build())
+        .setDeliveryLocation(TestUtils.loc("foofoo")).build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenIdIsNull_itShouldThrowException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance(null).addSizeDimension(0, 10)
+        .setPickupLocation(Location.Builder.newInstance().setId("foo").build())
+        .setDeliveryLocation(TestUtils.loc("foofoo")).build();
+    }
+
+    @Test
+    public void whenCallingForANewBuilderInstance_itShouldReturnBuilderCorrectly() {
+        ReturnedShipment.Builder builder = ReturnedShipment.Builder.newInstance("s");
+        assertNotNull(builder);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenNeitherPickupLocationIdNorPickupCoord_itThrowsException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+        .setDeliveryLocation(TestUtils.loc("delLoc")).build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenNeitherDeliveryLocationIdNorDeliveryCoord_itThrowsException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+        .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
+        .build();
+    }
+
+    @Test
+    public void whenPickupLocationIdIsSet_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryLocation(TestUtils.loc("delLoc"))
+                        .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
+                        .build();
+        assertEquals("pickLoc", s.getPickupActivity().getLocation().getId());
+        assertEquals("pickLoc", s.getPickupActivity().getLocation().getId());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenPickupLocationIsNull_itThrowsException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment.Builder builder = ReturnedShipment.Builder.newInstance("s")
+        .setPickupLocation(Location.Builder.newInstance().setId(null).build());
+    }
+
+    @Test
+    public void whenPickupCoordIsSet_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").setCoordinate(Coordinate.newInstance(1, 2)).build()).build();
+        assertEquals(1.0, s.getPickupActivity().getLocation().getCoordinate().getX(), 0.01);
+        assertEquals(2.0, s.getPickupActivity().getLocation().getCoordinate().getY(), 0.01);
+        assertEquals(1.0, s.getPickupActivity().getLocation().getCoordinate().getX(), 0.01);
+        assertEquals(2.0, s.getPickupActivity().getLocation().getCoordinate().getY(), 0.01);
+    }
+
+
+    @Test
+    public void whenDeliveryLocationIdIsSet_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals("delLoc", s.getExchangeActivity().getLocation().getId());
+        assertEquals("delLoc", s.getExchangeActivity().getLocation().getId());
+    }
+
+
+    @Test
+    public void whenDeliveryCoordIsSet_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryLocation(TestUtils.loc("delLoc", Coordinate.newInstance(1, 2)))
+                        .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
+                        .build();
+        assertEquals(1.0, s.getExchangeActivity().getLocation().getCoordinate().getX(), 0.01);
+        assertEquals(2.0, s.getExchangeActivity().getLocation().getCoordinate().getY(), 0.01);
+        assertEquals(1.0, s.getExchangeActivity().getLocation().getCoordinate().getX(), 0.01);
+        assertEquals(2.0, s.getExchangeActivity().getLocation().getCoordinate().getY(), 0.01);
+    }
+
+    @Test
+    public void whenPickupServiceTimeIsNotSet_itShouldBeZero() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(0.0, s.getPickupActivity().getOperationTime(), 0.01);
+    }
+
+    @Test
+    public void whenDeliveryServiceTimeIsNotSet_itShouldBeZero() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(0.0, s.getExchangeActivity().getOperationTime(), 0.01);
+    }
+
+    @Test
+    public void whenPickupServiceTimeIsSet_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupServiceTime(2.0)
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(2.0, s.getPickupActivity().getOperationTime(), 0.01);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenPickupServiceIsSmallerThanZero_itShouldThrowException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").setPickupServiceTime(-2.0)
+        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+    }
+
+    @Test
+    public void whenDeliveryServiceTimeIsSet_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").setDeliveryServiceTime(2.0)
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(2.0, s.getExchangeActivity().getOperationTime(), 0.01);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenDeliveryServiceIsSmallerThanZero_itShouldThrowException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").setDeliveryServiceTime(-2.0)
+        .setDeliveryLocation(TestUtils.loc("delLoc"))
+        .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
+        .build();
+    }
+
+    @Test
+    public void whenPickupTimeWindowIsNotSet_itShouldBeTheDefaultOne() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryLocation(TestUtils.loc("delLoc"))
+                        .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
+                        .build();
+        assertEquals(0.0, s.getPickupActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(Double.MAX_VALUE,
+                        s.getPickupActivity().getSingleTimeWindow().getEnd(), 0.01);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenPickupTimeWindowIsNull_itShouldThrowException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").setPickupTimeWindow(null)
+        .setDeliveryLocation(TestUtils.loc("delLoc"))
+        .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
+        .build();
+    }
+
+    @Test
+    public void whenPickupTimeWindowIsSet_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupTimeWindow(TimeWindow.newInstance(1, 2))
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(1.0, s.getPickupActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(2.0, s.getPickupActivity().getSingleTimeWindow().getEnd(), 0.01);
+    }
+
+    @Test
+    public void whenDeliveryTimeWindowIsNotSet_itShouldBeTheDefaultOne() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryLocation(TestUtils.loc("delLoc"))
+                        .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
+                        .build();
+        assertEquals(0.0, s.getExchangeActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(Double.MAX_VALUE,
+                        s.getExchangeActivity().getSingleTimeWindow().getEnd(), 0.01);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenDeliveryTimeWindowIsNull_itShouldThrowException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").setDeliveryTimeWindow(null)
+        .setDeliveryLocation(TestUtils.loc("delLoc"))
+        .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
+        .build();
+    }
+
+    @Test
+    public void whenDeliveryTimeWindowIsSet_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryTimeWindow(TimeWindow.newInstance(1, 2))
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(1.0, s.getExchangeActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(2.0, s.getExchangeActivity().getSingleTimeWindow().getEnd(),
+                        0.01);
+    }
+
+    @Test
+    public void whenUsingAddDeliveryTimeWindow_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .addDeliveryTimeWindow(TimeWindow.newInstance(1, 2))
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(1.0, s.getExchangeActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(2.0, s.getExchangeActivity().getSingleTimeWindow().getEnd(),
+                        0.01);
+    }
+
+    @Test
+    public void whenUsingAddDeliveryTimeWindow2_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").addDeliveryTimeWindow(1, 2)
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(1.0, s.getExchangeActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(2.0, s.getExchangeActivity().getSingleTimeWindow().getEnd(),
+                        0.01);
+    }
+
+    @Test
+    public void whenAddingMultipleDeliveryTimeWindows_itShouldBeDoneCorrectly() {
+        TimeWindow tw1 = TimeWindow.newInstance(1, 2);
+        TimeWindow tw2 = TimeWindow.newInstance(4, 5);
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").addDeliveryTimeWindow(tw1)
+                        .addDeliveryTimeWindow(tw2)
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(s.getExchangeActivity().getTimeWindows().size(), 2);
+        assertThat(s.getExchangeActivity().getTimeWindows(), hasItem(is(tw1)));
+        assertThat(s.getExchangeActivity().getTimeWindows(), hasItem(is(tw2)));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenAddingMultipleOverlappingDeliveryTimeWindows_itShouldThrowException() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").addDeliveryTimeWindow(1, 3)
+                        .addDeliveryTimeWindow(2, 5)
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(1.0, s.getExchangeActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(2.0, s.getExchangeActivity().getSingleTimeWindow().getEnd(),
+                        0.01);
+    }
+
+
+    @Test
+    public void whenUsingAddPickupTimeWindow_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .addPickupTimeWindow(TimeWindow.newInstance(1, 2))
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(1.0, s.getPickupActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(2.0, s.getPickupActivity().getSingleTimeWindow().getEnd(), 0.01);
+    }
+
+    @Test
+    public void whenUsingAddPickupTimeWindow2_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").addPickupTimeWindow(1, 2)
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(1.0, s.getPickupActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(2.0, s.getPickupActivity().getSingleTimeWindow().getEnd(), 0.01);
+    }
+
+    @Test
+    public void whenAddingMultiplePickupTimeWindows_itShouldBeDoneCorrectly() {
+        TimeWindow tw1 = TimeWindow.newInstance(1, 2);
+        TimeWindow tw2 = TimeWindow.newInstance(4, 5);
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").addPickupTimeWindow(tw1)
+                        .addPickupTimeWindow(tw2)
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(s.getPickupActivity().getTimeWindows().size(), 2);
+        assertThat(s.getPickupActivity().getTimeWindows(), hasItem(is(tw1)));
+        assertThat(s.getPickupActivity().getTimeWindows(), hasItem(is(tw2)));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenAddingMultipleOverlappingPickupTimeWindows_itShouldThrowException() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").addPickupTimeWindow(1, 3)
+                        .addPickupTimeWindow(2, 5)
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(1.0, s.getPickupActivity().getSingleTimeWindow().getStart(), 0.01);
+        assertEquals(2.0, s.getPickupActivity().getSingleTimeWindow().getEnd(), 0.01);
+    }
+
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenReturnedShipmentHasNegativeCapacityVal_throwIllegalStateExpception() {
+        @SuppressWarnings("unused")
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s")
+        .setPickupLocation(Location.Builder.newInstance().setId("foo").build())
+        .setDeliveryLocation(TestUtils.loc("foofoo"))
+        .addSizeDimension(0, -2)
+        .build();
+    }
+
+    @Test
+    public void whenAddingTwoCapDimension_nuOfDimsShouldBeTwo() {
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").build())
+                        .setDeliveryLocation(TestUtils.loc("foofoo"))
+                        .addSizeDimension(0, 2)
+                        .addSizeDimension(1, 4)
+                        .addBackhaulSizeDimension(0, 3)
+                        .addBackhaulSizeDimension(1, 5)
+                        .build();
+        assertEquals(2, one.getSize().getNuOfDimensions());
+        assertEquals(2, one.getBackhaulActivity().getLoadChange().getNuOfDimensions());
+    }
+
+    @Test
+    public void whenReturnedShipmentIsBuiltWithoutSpecifyingCapacity_itShouldHvCapWithOneDimAndDimValOfZero() {
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").setCoordinate(Coordinate.newInstance(0, 0)).build())
+                        .setDeliveryLocation(TestUtils.loc("foofoo")).build();
+        assertEquals(1, one.getSize().getNuOfDimensions());
+        assertEquals(0, one.getSize().get(0));
+        assertEquals(1, one.getBackhaulActivity().getLoadChange().getNuOfDimensions());
+    }
+
+    @Test
+    public void whenReturnedShipmentIsBuiltWithConstructorWhereSizeIsSpecified_capacityShouldBeSetCorrectly() {
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, 1)
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").setCoordinate(Coordinate.newInstance(0, 0)).build())
+                        .setDeliveryLocation(TestUtils.loc("foofoo")).build();
+        assertEquals(1, one.getSize().getNuOfDimensions());
+        assertEquals(1, one.getSize().get(0));
+    }
+
+    @Test
+    public void whenAddingSkills_theyShouldBeAddedCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.Builder.newInstance().setId("loc").build())
+                        .setDeliveryLocation(TestUtils.loc("delLoc"))
+                        .addRequiredSkill("drill").addRequiredSkill("screwdriver").build();
+        assertTrue(s.getRequiredSkills().containsSkill("drill"));
+        assertTrue(s.getRequiredSkills().containsSkill("drill"));
+        assertTrue(s.getRequiredSkills().containsSkill("ScrewDriver"));
+    }
+
+    @Test
+    public void whenAddingSkillsCaseSens_theyShouldBeAddedCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.Builder.newInstance().setId("pick").build())
+                        .setDeliveryLocation(TestUtils.loc("del"))
+                        .addRequiredSkill("DriLl").addRequiredSkill("screwDriver").build();
+        assertTrue(s.getRequiredSkills().containsSkill("drill"));
+        assertTrue(s.getRequiredSkills().containsSkill("drilL"));
+    }
+
+    @Test
+    public void whenAddingSkillsCaseSensV2_theyShouldBeAddedCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.Builder.newInstance().setId("loc").build())
+                        .setDeliveryLocation(TestUtils.loc("del"))
+                        .addRequiredSkill("screwDriver").build();
+        assertFalse(s.getRequiredSkills().containsSkill("drill"));
+        assertFalse(s.getRequiredSkills().containsSkill("drilL"));
+    }
+
+    @Test
+    public void nameShouldBeAssigned() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.Builder.newInstance().setId("loc").build())
+                        .setDeliveryLocation(TestUtils.loc("del"))
+                        .setName("name").build();
+        assertEquals("name", s.getName());
+    }
+
+    @Test
+    public void whenSettingLocation_itShouldWork() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.Builder.newInstance().setId("loc").build())
+                        .setDeliveryLocation(Location.Builder.newInstance().setId("del").build())
+                        .setBackhaulLocation(Location.Builder.newInstance().setId("back").build())
+                        .build();
+        assertEquals("loc", s.getPickupActivity().getLocation().getId());
+        assertEquals("del", s.getExchangeActivity().getLocation().getId());
+        assertEquals("back", s.getBackhaulActivity().getLocation().getId());
+    }
+
+    @Test
+    public void whenSettingPriorities_itShouldBeSetCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.newInstance("loc"))
+                        .setDeliveryLocation(Location.newInstance("loc"))
+                        .setPriority(1).build();
+        assertEquals(1, s.getPriority());
+    }
+
+    @Test
+    public void whenSettingPriorities_itShouldBeSetCorrectly2() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.newInstance("loc"))
+                        .setDeliveryLocation(Location.newInstance("loc"))
+                        .setPriority(3).build();
+        assertEquals(3, s.getPriority());
+    }
+
+    @Test
+    public void whenNotSettingPriorities_defaultShouldBe2() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.newInstance("loc"))
+                        .setDeliveryLocation(Location.newInstance("loc"))
+                        .build();
+        assertEquals(2, s.getPriority());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenSettingIncorrectPriorities_itShouldThrowException() {
+        ReturnedShipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc"))
+        .setDeliveryLocation(Location.newInstance("loc"))
+        .setPriority(30).build();
+
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenSettingIncorrectPriorities_itShouldThrowException2() {
+        ReturnedShipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc"))
+        .setDeliveryLocation(Location.newInstance("loc"))
+        .setPriority(0).build();
+
+    }
+
+    @Test
+    public void firstTest() {
+        Set<Job> jobs = new HashSet<>();
+        jobs.add(CustomJob.Builder.newInstance("job")
+                        .addPickup(Location.newInstance(10, 0), SizeDimension.of(1), 0d, TimeWindow.newInstance(0, 30))
+                        .addExchange(Location.newInstance(5, 30)).addDelivery(Location.newInstance(10, 0), SizeDimension.of(1))
+                        .build());
+        jobs.add(CustomJob.Builder.newInstance("job2")
+                        .addPickup(Location.newInstance(20, 0), SizeDimension.of(1))
+                        .addExchange(Location.newInstance(20, 30), SizeDimension.EMPTY)
+                        .addDelivery(Location.newInstance(20, 0), SizeDimension.of(1))
+                        .build());
+        jobs.add(CustomJob.Builder.newInstance("job3")
+                        .addPickup(Location.newInstance(20, 30), SizeDimension.of(1))
+                        .addExchange(Location.newInstance(40, 30), SizeDimension.EMPTY)
+                        .addDelivery(Location.newInstance(20, 30), SizeDimension.of(1))
+                        .build());
+        jobs.add(CustomJob.Builder.newInstance("job4")
+                        .addPickup(Location.newInstance(20, 30), SizeDimension.of(1))
+                        .addExchange(Location.newInstance(40, 30), SizeDimension.EMPTY)
+                        .addDelivery(Location.newInstance(20, 30), SizeDimension.of(1))
+                        .build());
+        VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0, 2)
+                        .build();
+        Vehicle v = VehicleImpl.Builder.newInstance("v").setType(type)
+                        .setStartLocation(Location.newInstance(0, 0)).build();
+        Vehicle v2 = VehicleImpl.Builder.newInstance("v2").setType(type)
+                        .setStartLocation(Location.newInstance(0, 0)).build();
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
+                        .setFleetSize(FleetSize.FINITE)
+                        .addAllJobs(jobs).addVehicle(v).addVehicle(v2).build();
+        VehicleRoutingAlgorithm vra = Jsprit.createAlgorithm(vrp);
+        vra.setMaxIterations(10);
+        VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
+        SolutionPrinter.print(vrp, solution, SolutionPrinter.Print.VERBOSE);
+        Assert.assertTrue(solution.getUnassignedJobs().isEmpty());
+    }
+}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/CustomJob.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/CustomJob.java
deleted file mode 100644
index 9cf74cad8..000000000
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/CustomJob.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.graphhopper.jsprit.core.util;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.SizeDimension;
-import com.graphhopper.jsprit.core.problem.job.AbstractJob;
-import com.graphhopper.jsprit.core.problem.job.JobActivityList;
-import com.graphhopper.jsprit.core.problem.job.SequentialJobActivityList;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.ExchangeActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
-
-/**
- * Created by schroeder on 16/11/16.
- */
-public class CustomJob extends AbstractJob {
-
-    public static abstract class BuilderBase<T extends CustomJob, B extends CustomJob.BuilderBase<T, B>>
-        extends JobBuilder<T, B> {
-
-        List<Location> locs = new ArrayList<>();
-
-        List<SizeDimension> cap = new ArrayList<>();
-
-        List<String> types = new ArrayList<>();
-
-        public BuilderBase(String id) {
-            super(id);
-        }
-
-        public CustomJob.BuilderBase<T, B> addPickup(Location location, SizeDimension loadChange) {
-            add(location, loadChange);
-            types.add("pickup");
-            return this;
-        }
-
-        private void add(Location location, SizeDimension loadChange) {
-            locs.add(location);
-            cap.add(loadChange);
-        }
-
-        public CustomJob.BuilderBase<T, B> addDelivery(Location location, SizeDimension loadChange) {
-            add(location, loadChange);
-            types.add("delivery");
-            return this;
-        }
-
-        public CustomJob.BuilderBase<T, B> addExchange(Location location, SizeDimension loadChange) {
-            add(location, loadChange);
-            types.add("exchange");
-            return this;
-        }
-
-
-
-        public List<Location> getLocs() {
-            return locs;
-        }
-
-        public List<SizeDimension> getCaps() {
-            return cap;
-        }
-
-        public List<String> getTypes() {
-            return types;
-        }
-
-        protected void validate() {
-
-        }
-    }
-
-    public static final class Builder extends CustomJob.BuilderBase<CustomJob, CustomJob.Builder> {
-
-        public static CustomJob.Builder newInstance(String id) {
-            return new CustomJob.Builder(id);
-        }
-
-        public Builder(String id) {
-            super(id);
-        }
-
-        @Override
-        protected CustomJob createInstance() {
-            return new CustomJob(this);
-        }
-
-    }
-
-    /**
-     * Builder based constructor.
-     *
-     * @param builder The builder instance.
-     * @see JobBuilder
-     */
-    protected CustomJob(JobBuilder<?, ?> builder) {
-        super(builder);
-
-    }
-
-    @Override
-    public SizeDimension getSize() {
-        return SizeDimension.EMPTY;
-    }
-
-    @Override
-    protected void createActivities(JobBuilder<? extends AbstractJob, ?> jobBuilder) {
-        CustomJob.Builder builder = (CustomJob.Builder) jobBuilder;
-        JobActivityList list = new SequentialJobActivityList(this);
-        for (int i = 0; i < builder.getLocs().size(); i++) {
-            if (builder.getTypes().get(i).equals("pickup")) {
-                list.addActivity(new PickupActivity(this, "pick", builder.getLocs().get(i), 0, builder.getCaps().get(i), Arrays.asList(TimeWindow.ETERNITY)));
-            } else if (builder.getTypes().get(i).equals("delivery")) {
-                list.addActivity(new DeliveryActivity(this, "delivery", builder.getLocs().get(i), 0, builder.getCaps().get(i).invert(), Arrays.asList(TimeWindow.ETERNITY)));
-            } else {
-                list.addActivity(new ExchangeActivity(this, "exchange", builder.getLocs().get(i), 0, builder.getCaps().get(i), Arrays.asList(TimeWindow.ETERNITY)));
-            }
-        }
-        setActivities(list);
-    }
-}
-
