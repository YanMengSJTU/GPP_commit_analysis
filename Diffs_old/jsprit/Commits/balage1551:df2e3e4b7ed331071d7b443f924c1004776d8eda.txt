diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/LocalActivityInsertionCostsCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/LocalActivityInsertionCostsCalculator.java
index 795f1f3cb..2e16583f0 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/LocalActivityInsertionCostsCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/LocalActivityInsertionCostsCalculator.java
@@ -22,6 +22,8 @@
 import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
 import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.AbstractActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.state.RouteAndActivityStateGetter;
@@ -51,7 +53,7 @@
     public LocalActivityInsertionCostsCalculator(VehicleRoutingTransportCosts routingCosts, VehicleRoutingActivityCosts actCosts, RouteAndActivityStateGetter stateManager) {
         super();
         this.routingCosts = routingCosts;
-        this.activityCosts = actCosts;
+        activityCosts = actCosts;
         this.stateManager = stateManager;
     }
 
@@ -65,8 +67,9 @@ public double getCosts(JobInsertionContext iFacts, TourActivity prevAct, TourAct
 
         double act_costs_newAct = activityCosts.getActivityCost(newAct, newAct_arrTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
 
-        if (isEnd(nextAct) && !toDepot(iFacts.getNewVehicle()))
+        if (isEnd(nextAct) && !toDepot(iFacts.getNewVehicle())) {
             return tp_costs_prevAct_newAct + solutionCompletenessRatio * activityCostsWeight * act_costs_newAct;
+        }
 
         double tp_costs_newAct_nextAct = routingCosts.getTransportCost(newAct.getLocation(), nextAct.getLocation(), newAct_endTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
         double tp_time_newAct_nextAct = routingCosts.getTransportTime(newAct.getLocation(), nextAct.getLocation(), newAct_endTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
@@ -78,7 +81,10 @@ public double getCosts(JobInsertionContext iFacts, TourActivity prevAct, TourAct
 
         double oldCosts = 0.;
         if (iFacts.getRoute().isEmpty()) {
-            double tp_costs_prevAct_nextAct = routingCosts.getTransportCost(prevAct.getLocation(), nextAct.getLocation(), depTimeAtPrevAct, iFacts.getNewDriver(), iFacts.getNewVehicle());
+            double tp_costs_prevAct_nextAct = 0.;
+            if (newAct instanceof DeliveryActivity && AbstractActivity.isShipment(newAct)) {
+                tp_costs_prevAct_nextAct = routingCosts.getTransportCost(prevAct.getLocation(), nextAct.getLocation(), depTimeAtPrevAct, iFacts.getNewDriver(), iFacts.getNewVehicle());
+            }
             oldCosts += tp_costs_prevAct_nextAct;
         } else {
             double tp_costs_prevAct_nextAct = routingCosts.getTransportCost(prevAct.getLocation(), nextAct.getLocation(), prevAct.getEndTime(), iFacts.getRoute().getDriver(), iFacts.getRoute().getVehicle());
@@ -88,7 +94,9 @@ public double getCosts(JobInsertionContext iFacts, TourActivity prevAct, TourAct
 
             double endTimeDelay_nextAct = Math.max(0, endTime_nextAct_new - endTime_nextAct_old);
             Double futureWaiting = stateManager.getActivityState(nextAct, iFacts.getRoute().getVehicle(), InternalStates.FUTURE_WAITING, Double.class);
-            if (futureWaiting == null) futureWaiting = 0.;
+            if (futureWaiting == null) {
+                futureWaiting = 0.;
+            }
             double waitingTime_savings_timeUnit = Math.min(futureWaiting, endTimeDelay_nextAct);
             double waitingTime_savings = waitingTime_savings_timeUnit * iFacts.getRoute().getVehicle().getType().getVehicleCostParams().perWaitingTimeUnit;
             oldCosts += solutionCompletenessRatio * activityCostsWeight * waitingTime_savings;
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
index cad486386..fb7f09eae 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
@@ -35,7 +35,7 @@
 /**
  * Created by schroeder on 11/10/16.
  */
-public class MaxDistanceConstraint implements HardActivityConstraint {
+public class MaxDistanceConstraint implements HardActivityConstraint{
 
     private StateManager stateManager;
 
@@ -45,7 +45,7 @@
 
     private Double[] maxDistances;
 
-    public MaxDistanceConstraint(StateManager stateManager, StateId distanceId, TransportDistance distanceCalculator, Map<Vehicle, Double> maxDistancePerVehicleMap) {
+    public MaxDistanceConstraint(StateManager stateManager, StateId distanceId, TransportDistance distanceCalculator, Map<Vehicle,Double> maxDistancePerVehicleMap) {
         this.stateManager = stateManager;
         this.distanceId = distanceId;
         this.distanceCalculator = distanceCalculator;
@@ -54,16 +54,16 @@ public MaxDistanceConstraint(StateManager stateManager, StateId distanceId, Tran
 
     private void makeArray(Map<Vehicle, Double> maxDistances) {
         int maxIndex = getMaxIndex(maxDistances.keySet());
-        this.maxDistances = new Double[maxIndex + 1];
-        for (Vehicle v : maxDistances.keySet()) {
-            this.maxDistances[v.getIndex()] = maxDistances.get(v);
+        this.maxDistances = new Double[maxIndex+1];
+        for(Vehicle v : maxDistances.keySet()){
+            this.maxDistances[v.getIndex()]=maxDistances.get(v);
         }
     }
 
     private int getMaxIndex(Collection<Vehicle> vehicles) {
         int index = 0;
-        for (Vehicle v : vehicles) {
-            if (v.getIndex() > index) {
+        for(Vehicle v : vehicles){
+            if(v.getIndex() > index) {
                 index = v.getIndex();
             }
         }
@@ -72,60 +72,62 @@ private int getMaxIndex(Collection<Vehicle> vehicles) {
 
     @Override
     public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime) {
-        if (!hasMaxDistance(iFacts.getNewVehicle())) {
+        if(!hasMaxDistance(iFacts.getNewVehicle())) {
             return ConstraintsStatus.FULFILLED;
         }
         Double currentDistance = 0d;
-        if (!iFacts.getRoute().isEmpty()) {
-            currentDistance = stateManager.getRouteState(iFacts.getRoute(), iFacts.getNewVehicle(), distanceId, Double.class);
+        boolean routeIsEmpty = iFacts.getRoute().isEmpty();
+        if(!routeIsEmpty){
+            currentDistance = stateManager.getRouteState(iFacts.getRoute(),iFacts.getNewVehicle(), distanceId,Double.class);
         }
         double maxDistance = getMaxDistance(iFacts.getNewVehicle());
-        if (currentDistance > maxDistance) {
+        if(currentDistance > maxDistance) {
             return ConstraintsStatus.NOT_FULFILLED_BREAK;
         }
 
         double distancePrevAct2NewAct = distanceCalculator.getDistance(prevAct.getLocation(), newAct.getLocation(), iFacts.getNewDepTime(), iFacts.getNewVehicle());
         double distanceNewAct2nextAct = distanceCalculator.getDistance(newAct.getLocation(), nextAct.getLocation(), iFacts.getNewDepTime(), iFacts.getNewVehicle());
         double distancePrevAct2NextAct = distanceCalculator.getDistance(prevAct.getLocation(), nextAct.getLocation(), prevActDepTime, iFacts.getNewVehicle());
-        if (nextAct instanceof End && !iFacts.getNewVehicle().isReturnToDepot()) {
+        if(routeIsEmpty) {
+            distancePrevAct2NextAct = 0;
+        }
+        if(nextAct instanceof End && !iFacts.getNewVehicle().isReturnToDepot()){
             distanceNewAct2nextAct = 0;
             distancePrevAct2NextAct = 0;
         }
         double additionalDistance = distancePrevAct2NewAct + distanceNewAct2nextAct - distancePrevAct2NextAct;
-        if (currentDistance + additionalDistance > maxDistance) {
+        if(currentDistance + additionalDistance > maxDistance) {
             return ConstraintsStatus.NOT_FULFILLED;
         }
 
-
         double additionalDistanceOfPickup = 0;
-        // Balage1551 - Temporal solution to eliminate DEPRECATED
         if (newAct instanceof DeliveryActivity && AbstractActivity.isShipment(newAct)) {
             int iIndexOfPickup = iFacts.getRelatedActivityContext().getInsertionIndex();
             TourActivity pickup = iFacts.getAssociatedActivities().get(0);
             TourActivity actBeforePickup;
-            if (iIndexOfPickup > 0) {
-                actBeforePickup = iFacts.getRoute().getActivities().get(iIndexOfPickup - 1);
+            if(iIndexOfPickup > 0) {
+                actBeforePickup = iFacts.getRoute().getActivities().get(iIndexOfPickup-1);
             } else {
-                actBeforePickup = new Start(iFacts.getNewVehicle().getStartLocation(), 0, Double.MAX_VALUE);
+                actBeforePickup = new Start(iFacts.getNewVehicle().getStartLocation(),0,Double.MAX_VALUE);
             }
             TourActivity actAfterPickup = iFacts.getRoute().getActivities().get(iIndexOfPickup);
             //ToDo account here fore End and returnToDepot
             double distanceActBeforePickup2Pickup = distanceCalculator.getDistance(actBeforePickup.getLocation(), pickup.getLocation(), actBeforePickup.getEndTime(), iFacts.getNewVehicle());
             double distancePickup2ActAfterPickup = distanceCalculator.getDistance(pickup.getLocation(), actAfterPickup.getLocation(), iFacts.getRelatedActivityContext().getEndTime(), iFacts.getNewVehicle());
             double distanceBeforePickup2AfterPickup = distanceCalculator.getDistance(actBeforePickup.getLocation(), actAfterPickup.getLocation(), actBeforePickup.getEndTime(), iFacts.getNewVehicle());
-            additionalDistanceOfPickup = distanceActBeforePickup2Pickup + distancePickup2ActAfterPickup - distanceBeforePickup2AfterPickup;
+            additionalDistanceOfPickup = distanceActBeforePickup2Pickup  + distancePickup2ActAfterPickup - distanceBeforePickup2AfterPickup;
         }
 
 
-        if (currentDistance + additionalDistance + additionalDistanceOfPickup > maxDistance) {
+        if(currentDistance + additionalDistance + additionalDistanceOfPickup > maxDistance){
             return ConstraintsStatus.NOT_FULFILLED;
         }
 
         return ConstraintsStatus.FULFILLED;
     }
 
-    private boolean hasMaxDistance(Vehicle newVehicle) {
-        if (newVehicle.getIndex() >= maxDistances.length) {
+    private boolean hasMaxDistance(Vehicle newVehicle){
+        if(newVehicle.getIndex() >= maxDistances.length) {
             return false;
         }
         return maxDistances[newVehicle.getIndex()] != null;
@@ -133,7 +135,7 @@ private boolean hasMaxDistance(Vehicle newVehicle) {
 
     private double getMaxDistance(Vehicle newVehicle) {
         Double maxDistance = maxDistances[newVehicle.getIndex()];
-        if (maxDistance == null) {
+        if(maxDistance == null) {
             return Double.MAX_VALUE;
         }
         return maxDistance;
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestLocalActivityInsertionCostsCalculator.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestLocalActivityInsertionCostsCalculator.java
index 18b0789d2..2a7cc9fcd 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestLocalActivityInsertionCostsCalculator.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestLocalActivityInsertionCostsCalculator.java
@@ -38,6 +38,7 @@
 import com.graphhopper.jsprit.core.problem.cost.WaitingTimeCosts;
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.job.Service;
+import com.graphhopper.jsprit.core.problem.job.Shipment;
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
@@ -92,6 +93,74 @@ private Location loc(String i) {
         return Location.Builder.newInstance().setId(i).build();
     }
 
+    @Test
+    public void whenAddingServiceBetweenDiffStartAndEnd_costMustBeCorrect() {
+        VehicleImpl v = VehicleImpl.Builder.newInstance("v")
+            .setStartLocation(Location.newInstance(0, 0))
+            .setEndLocation(Location.newInstance(20, 0))
+            .build();
+        Service s = Service.Builder.newInstance("s")
+            .setLocation(Location.newInstance(10, 0))
+            .build();
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
+            .addVehicle(v)
+            .addJob(s)
+            .build();
+        VehicleRoute route = VehicleRoute.emptyRoute();
+        JobInsertionContext jobInsertionContext =
+            new JobInsertionContext(route, s, v, null, 0);
+        LocalActivityInsertionCostsCalculator localActivityInsertionCostsCalculator =
+            new LocalActivityInsertionCostsCalculator(
+                vrp.getTransportCosts(),
+                vrp.getActivityCosts(),
+                new StateManager(vrp));
+        double cost = localActivityInsertionCostsCalculator.getCosts(
+            jobInsertionContext,
+            new Start(v.getStartLocation(),0,Double.MAX_VALUE),
+            new End(v.getEndLocation(),0,Double.MAX_VALUE),
+            vrp.getActivities(s).get(0),
+            0);
+        assertEquals(20., cost, Math.ulp(20.));
+    }
+
+    @Test
+    public void whenAddingShipmentBetweenDiffStartAndEnd_costMustBeCorrect() {
+        VehicleImpl v = VehicleImpl.Builder.newInstance("v")
+            .setStartLocation(Location.newInstance(0, 0))
+            .setEndLocation(Location.newInstance(20, 0))
+            .build();
+        Shipment s = Shipment.Builder.newInstance("p")
+            .setPickupLocation(Location.newInstance(10, 0))
+            .setDeliveryLocation(Location.newInstance(10, 7.5))
+            .build();
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
+            .addVehicle(v)
+            .addJob(s)
+            .build();
+        VehicleRoute route = VehicleRoute.emptyRoute();
+        JobInsertionContext jobInsertionContext =
+            new JobInsertionContext(route, s, v, null, 0);
+        LocalActivityInsertionCostsCalculator localActivityInsertionCostsCalculator =
+            new LocalActivityInsertionCostsCalculator(
+                vrp.getTransportCosts(),
+                vrp.getActivityCosts(),
+                new StateManager(vrp));
+        double cost = localActivityInsertionCostsCalculator.getCosts(
+            jobInsertionContext,
+            new Start(v.getStartLocation(),0,Double.MAX_VALUE),
+            new End(v.getEndLocation(),0,Double.MAX_VALUE),
+            vrp.getActivities(s).get(0),
+            0);
+        assertEquals(20., cost, Math.ulp(20.));
+        cost = localActivityInsertionCostsCalculator.getCosts(
+            jobInsertionContext,
+            vrp.getActivities(s).get(0),
+            new End(v.getEndLocation(),0,Double.MAX_VALUE),
+            vrp.getActivities(s).get(1),
+            0);
+        assertEquals(10, cost, Math.ulp(10.));
+    }
+
     @Test
     public void whenInsertingActBetweenTwoRouteActs_itCalcsMarginalTpCosts() {
         TourActivity prevAct = mock(TourActivity.class);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
index 5dcb0e0bb..05cafeaf9 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
@@ -42,6 +42,8 @@
 import com.graphhopper.jsprit.core.problem.job.Shipment;
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.Start;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
@@ -117,6 +119,29 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
         stateManager.informInsertionStarts(Arrays.asList(route), Collections.<Job>emptyList());
     }
 
+    @Test
+    public void whenEndLocationIsSet_constraintShouldWork(){
+        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0,0))
+            .setEndLocation(Location.newInstance(10,0)).build();
+        Pickup pickup = Pickup.Builder.newInstance("pickup").setLocation(Location.newInstance(10,0)).build();
+        vrp = VehicleRoutingProblem.Builder.newInstance().addVehicle(vehicle).addJob(pickup).build();
+        route = VehicleRoute.emptyRoute();
+        maxDistanceMap = new HashMap<>();
+        maxDistanceMap.put(vehicle,5d);
+
+        MaxDistanceConstraint maxDistanceConstraint =
+            new MaxDistanceConstraint(new StateManager(vrp), traveledDistanceId, new TransportDistance() {
+                @Override
+                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                }
+            },maxDistanceMap);
+        JobInsertionContext context = new JobInsertionContext(route,pickup,vehicle,null,0);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,
+            new Start(vehicle.getStartLocation(),0,Double.MAX_VALUE),vrp.getActivities(pickup).get(0),
+            new End(vehicle.getEndLocation(),0,Double.MAX_VALUE),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+    }
+
     /*
     vehicle: 200.0
 vehicle (max distance): 200.0
