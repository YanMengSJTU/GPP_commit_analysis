diff --git a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsRecorder.java b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsRecorder.java
index 69aacc67a..a622f320c 100644
--- a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsRecorder.java
+++ b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsRecorder.java
@@ -56,7 +56,7 @@
  */
 public class AlgorithmEventsRecorder implements RuinListener, IterationStartsListener, InsertionStartsListener, BeforeJobInsertionListener, InsertionEndsListener, AlgorithmEndsListener {
 
-    private final boolean renderShipments;
+    private final boolean renderShipments = true;
 
     public static final int BEFORE_RUIN_RENDER_SOLUTION = 2;
 
diff --git a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/GraphStreamViewer.java b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/GraphStreamViewer.java
index b296668e0..b6c6e0a2e 100644
--- a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/GraphStreamViewer.java
+++ b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/GraphStreamViewer.java
@@ -49,7 +49,7 @@
         public static String BLUE_FOREST =
             "graph { fill-color: #141F2E; }" +
                 "node {" +
-                "	size: 7px, 7px;" +
+                "	size:157px, 15px;" +
                 "   fill-color: #A0FFA0;" +
                 "	text-alignment: at-right;" +
                 " 	stroke-mode: plain;" +
@@ -57,7 +57,7 @@
                 "	stroke-width: 1.0;" +
                 "	text-font: couriernew;" +
                 " 	text-offset: 2,-5;" +
-                "	text-size: 8;" +
+                "	text-size: 16;" +
                 "}" +
                 "node.pickup {" +
                 " 	fill-color: #6CC644;" +
@@ -117,7 +117,7 @@
         @SuppressWarnings("UnusedDeclaration")
         public static String SIMPLE_WHITE =
             "node {" +
-                "	size: 10px, 10px;" +
+                "	size: 40px, 40px;" +
                 "   fill-color: #6CC644;" +
                 "	text-alignment: at-right;" +
                 " 	stroke-mode: plain;" +
@@ -180,13 +180,17 @@ public static Graph createMultiGraph(String name, String style) {
     public static ViewPanel createEmbeddedView(Graph graph, double scaling) {
         Viewer viewer = new Viewer(graph, Viewer.ThreadingModel.GRAPH_IN_ANOTHER_THREAD);
         ViewPanel view = viewer.addDefaultView(false);
+        view.setBackground(Color.BLACK);
+        viewer.enableXYZfeedback(true);
+
         view.setPreferredSize(new Dimension((int) (698 * scaling), (int) (440 * scaling)));
         return view;
     }
 
     public static String STYLESHEET =
-        "node {" +
-            "	size: 10px, 10px;" +
+            "graph { canvas-color: #000000; } " +
+            "node {" +
+            "	size: 50px, 50px;" +
             "   fill-color: #6CC644;" +
             "	text-alignment: at-right;" +
             " 	stroke-mode: plain;" +
@@ -194,7 +198,7 @@ public static ViewPanel createEmbeddedView(Graph graph, double scaling) {
             "	stroke-width: 1.0;" +
             "	text-font: couriernew;" +
             " 	text-offset: 2,-5;" +
-            "	text-size: 8;" +
+            "	text-size: 16;" +
             "}" +
             "node.pickup {" +
             " 	fill-color: #6CC644;" +
@@ -328,7 +332,12 @@ public void display() {
 
     private JFrame createJFrame(ViewPanel view, double scaling) {
         JFrame jframe = new JFrame();
+        jframe.setIgnoreRepaint(true);
+        jframe.setBackground(Color.BLACK);
+        jframe.getRootPane().setBackground(Color.BLACK);
+
         JPanel basicPanel = new JPanel();
+        basicPanel.setOpaque(false);
         basicPanel.setLayout(new BoxLayout(basicPanel, BoxLayout.Y_AXIS));
 
         //result-panel
@@ -337,13 +346,15 @@ private JFrame createJFrame(ViewPanel view, double scaling) {
 
 
         JPanel graphStreamPanel = new JPanel();
+        graphStreamPanel.setOpaque(false);
         graphStreamPanel.setPreferredSize(new Dimension((int) (800 * scaling), (int) (460 * scaling)));
-        graphStreamPanel.setBackground(Color.WHITE);
+        graphStreamPanel.setBackground(Color.BLACK);
 
         JPanel graphStreamBackPanel = new JPanel();
+        graphStreamBackPanel.setOpaque(false);
         graphStreamBackPanel.setPreferredSize(new Dimension((int) (700 * scaling), (int) (450 * scaling)));
         graphStreamBackPanel.setBorder(BorderFactory.createLineBorder(Color.LIGHT_GRAY, 1));
-        graphStreamBackPanel.setBackground(Color.WHITE);
+        graphStreamBackPanel.setBackground(Color.BLACK);
 
         graphStreamBackPanel.add(view);
         graphStreamPanel.add(graphStreamBackPanel);
@@ -371,6 +382,10 @@ private Graph createMultiGraph(String name) {
     }
 
     private void render(Graph g, ViewPanel view) {
+        view.setOpaque(false);
+        view.setBackground(Color.BLACK);
+        view.getCamera().setAutoFitView(true);
+
         if (center != null) {
             view.resizeFrame(view.getWidth(), view.getHeight());
             alignCamera(view);
@@ -418,12 +433,12 @@ private JPanel createResultPanel() {
 
         JPanel panel = new JPanel();
         panel.setPreferredSize(new Dimension((int) (width * scaling), (int) (height * scaling)));
-        panel.setBackground(Color.WHITE);
+        panel.setBackground(Color.BLACK);
 
         JPanel subpanel = new JPanel();
         subpanel.setLayout(new FlowLayout());
         subpanel.setPreferredSize(new Dimension((int) (700 * scaling), (int) (40 * scaling)));
-        subpanel.setBackground(Color.WHITE);
+        subpanel.setBackground(Color.BLACK);
         subpanel.setBorder(BorderFactory.createLineBorder(Color.LIGHT_GRAY, 1));
 
         Font font = Font.decode("couriernew");
@@ -598,8 +613,8 @@ else if (act instanceof DeliveryActivity)
         }
     }
 
-    private String makeEdgeId(int routeId, int vehicle_edgeId) {
-        return Integer.valueOf(routeId) + "." + Integer.valueOf(vehicle_edgeId);
+    static String makeEdgeId(int routeId, int vehicle_edgeId) {
+        return routeId + "." + vehicle_edgeId;
     }
 
     //	public void saveAsPNG(String filename){
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/InsertionInitialSolutionFactory.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/InsertionInitialSolutionFactory.java
index 5bd3d360e..7eb1eed44 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/InsertionInitialSolutionFactory.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/InsertionInitialSolutionFactory.java
@@ -32,6 +32,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
+import java.util.Set;
 
 
 public final class InsertionInitialSolutionFactory implements InitialSolutionFactory {
@@ -48,22 +49,24 @@ public InsertionInitialSolutionFactory(InsertionStrategy insertionStrategy, Solu
     }
 
     @Override
-    public VehicleRoutingProblemSolution createSolution(final VehicleRoutingProblem vrp) {
+    public VehicleRoutingProblemSolution solution(final VehicleRoutingProblem vrp) {
         logger.info("create initial solution");
-        List<VehicleRoute> vehicleRoutes = new ArrayList<>(vrp.initialVehicleRoutes());
-        Collection<Job> badJobs = insertion.insertJobs(vehicleRoutes, getUnassignedJobs(vrp));
+        Set<VehicleRoute> vehicleRoutes = vrp.initialVehicleRoutes();
+        Collection<Job> badJobs = insertion.insertJobs(vehicleRoutes, jobsUnassigned(vrp));
         VehicleRoutingProblemSolution solution = new VehicleRoutingProblemSolution(vehicleRoutes, badJobs, Double.MAX_VALUE);
         double costs = solutionCostsCalculator.getCosts(solution);
         solution.setCost(costs);
         return solution;
     }
 
-    private static Collection<Job> getUnassignedJobs(VehicleRoutingProblem vrp) {
-        List<Job> jobs = new ArrayList<>(vrp.jobs().values());
-//        for (Vehicle v : vrp.getVehicles()) {
-//            if (v.getBreak() != null) jobs.add(v.getBreak());
-//        }
-        return jobs;
+    private static Collection<Job> jobsUnassigned(VehicleRoutingProblem vrp) {
+        return vrp.jobs().values();
+
+//        List<Job> jobs = new ArrayList<>();
+////        for (Vehicle v : vrp.getVehicles()) {
+////            if (v.getBreak() != null) jobs.add(v.getBreak());
+////        }
+//        return jobs;
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/PrettyAlgorithmBuilder.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/PrettyAlgorithmBuilder.java
index a22ec09a8..d3999b977 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/PrettyAlgorithmBuilder.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/PrettyAlgorithmBuilder.java
@@ -29,7 +29,6 @@
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
 import com.graphhopper.jsprit.core.problem.solution.SolutionCostCalculator;
-import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleFleetManager;
 
 import java.util.*;
@@ -108,7 +107,7 @@ public VehicleRoutingAlgorithm build() {
                 iniInsertionStrategy.addListener(stateManager);
             vra.addListener((AlgorithmStartsListener) (problem, algorithm, solutions) -> {
                 if (solutions.isEmpty()) {
-                    solutions.add(new InsertionInitialSolutionFactory(iniInsertionStrategy, iniObjFunction).createSolution(vrp));
+                    solutions.add(new InsertionInitialSolutionFactory(iniInsertionStrategy, iniObjFunction).solution(vrp));
                 }
             });
         }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AbstractInsertionCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AbstractInsertionCalculator.java
index b3f144865..0100c1594 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AbstractInsertionCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AbstractInsertionCalculator.java
@@ -25,9 +25,8 @@
 import com.graphhopper.jsprit.core.problem.constraint.HardRouteConstraint;
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
+import java.util.*;
+import java.util.stream.Collectors;
 
 /**
  * Created by schroeder on 06/02/17.
@@ -46,8 +45,11 @@ static InsertionData checkRouteContraints(JobInsertionContext insertionContext,
     }
 
     static ConstraintsStatus fulfilled(JobInsertionContext iFacts, AbstractActivity prevAct, AbstractActivity newAct, AbstractActivity nextAct, double prevActDepTime, Collection<String> failedActivityConstraints, ConstraintManager constraintManager) {
+
         ConstraintsStatus notFulfilled = null;
-        Collection<String> failed = new ArrayList<>();
+
+        Set<Class> failed = new HashSet<>();
+
         for (HardActivityConstraint c : constraintManager.getCriticalHardActivityConstraints()) {
             ConstraintsStatus status = c.fulfilled(iFacts, prevAct, newAct, nextAct, prevActDepTime);
             if (status == ConstraintsStatus.NOT_FULFILLED_BREAK) {
@@ -55,30 +57,29 @@ static ConstraintsStatus fulfilled(JobInsertionContext iFacts, AbstractActivity
                 return status;
             } else {
                 if (status == ConstraintsStatus.NOT_FULFILLED) {
-                    failed.add(c.getClass().getSimpleName());
+                    failed.add(c.getClass());
                     notFulfilled = status;
                 }
             }
         }
-        if (notFulfilled != null) {
-            failedActivityConstraints.addAll(failed);
-            return notFulfilled;
-        }
 
-        for (HardActivityConstraint c : constraintManager.getHighPrioHardActivityConstraints()) {
-            ConstraintsStatus status = c.fulfilled(iFacts, prevAct, newAct, nextAct, prevActDepTime);
-            if (status == ConstraintsStatus.NOT_FULFILLED_BREAK) {
-                failedActivityConstraints.add(c.getClass().getSimpleName());
-                return status;
-            } else {
-                if (status == ConstraintsStatus.NOT_FULFILLED) {
-                    failed.add(c.getClass().getSimpleName());
-                    notFulfilled = status;
+        if (notFulfilled == null) {
+            for (HardActivityConstraint c : constraintManager.getHighPrioHardActivityConstraints()) {
+                ConstraintsStatus status = c.fulfilled(iFacts, prevAct, newAct, nextAct, prevActDepTime);
+                if (status == ConstraintsStatus.NOT_FULFILLED_BREAK) {
+                    failedActivityConstraints.add(c.getClass().getSimpleName());
+                    return status;
+                } else {
+                    if (status == ConstraintsStatus.NOT_FULFILLED) {
+                        failed.add(c.getClass());
+                        notFulfilled = status;
+                    }
                 }
             }
         }
+
         if (notFulfilled != null) {
-            failedActivityConstraints.addAll(failed);
+            failed.stream().map(Class::getSimpleName).collect(Collectors.toCollection(()->failedActivityConstraints));
             return notFulfilled;
         }
 
@@ -89,6 +90,7 @@ static ConstraintsStatus fulfilled(JobInsertionContext iFacts, AbstractActivity
                 return status;
             }
         }
+
         return ConstraintsStatus.FULFILLED;
     }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AccordingToPriorities.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AccordingToPriorities.java
index 5b422819c..a543e3595 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AccordingToPriorities.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AccordingToPriorities.java
@@ -25,11 +25,9 @@
 /**
  * Created by schroeder on 30/06/17.
  */
-class AccordingToPriorities implements Comparator<Job> {
+class AccordingToPriorities {
 
-    @Override
-    public int compare(Job o1, Job o2) {
-        return o1.pri() - o2.pri();
-    }
+    public final static Comparator<Job> PRIORITY_COMPARATOR =
+            Comparator.comparingInt(Job::pri);
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertion.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertion.java
index daf05c709..c4fc3e0e3 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertion.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertion.java
@@ -29,6 +29,8 @@
 import java.util.Collections;
 import java.util.List;
 
+import static com.graphhopper.jsprit.core.algorithm.recreate.AccordingToPriorities.PRIORITY_COMPARATOR;
+
 
 /**
  * Best insertion that insert the job where additional costs are minimal.
@@ -46,7 +48,7 @@
     public BestInsertion(JobInsertionCostsCalculator jobInsertionCalculator, VehicleRoutingProblem vehicleRoutingProblem) {
         super(vehicleRoutingProblem);
         bestInsertionCostCalculator = jobInsertionCalculator;
-        logger.debug("initialise {}", this);
+        //logger.debug("initialise {}", this);
     }
 
     @Override
@@ -54,16 +56,18 @@ public String toString() {
         return "[name=bestInsertion]";
     }
 
+
     @Override
     public Collection<Job> insertUnassignedJobs(Collection<VehicleRoute> vehicleRoutes, Collection<Job> unassignedJobs) {
         Collection<Job> badJobs = new ArrayList<>(unassignedJobs.size());
         List<Job> unassignedJobList = new ArrayList<>(unassignedJobs);
         Collections.shuffle(unassignedJobList, random);
-        unassignedJobList.sort(new AccordingToPriorities());
+
+        unassignedJobList.sort(PRIORITY_COMPARATOR);
         for (Job unassignedJob : unassignedJobList) {
             Insertion bestInsertion = null;
             InsertionData empty = new InsertionData.NoInsertionFound();
-            double bestInsertionCost = Double.MAX_VALUE;
+            double bestInsertionCost = Double.POSITIVE_INFINITY;
             for (VehicleRoute vehicleRoute : vehicleRoutes) {
                 InsertionData iData = bestInsertionCostCalculator.getInsertionData(vehicleRoute, unassignedJob, NO_NEW_VEHICLE_YET, NO_NEW_DEPARTURE_TIME_YET, NO_NEW_DRIVER_YET, bestInsertionCost);
                 if (iData instanceof InsertionData.NoInsertionFound) {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertionConcurrent.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertionConcurrent.java
index a3161e2fd..baabe66fe 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertionConcurrent.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertionConcurrent.java
@@ -101,7 +101,7 @@ public String toString() {
         Collection<Job> badJobs = new ArrayList<>(unassignedJobs.size());
         List<Job> unassignedJobList = new ArrayList<>(unassignedJobs);
         Collections.shuffle(unassignedJobList, random);
-        unassignedJobList.sort(new AccordingToPriorities());
+        unassignedJobList.sort(AccordingToPriorities.PRIORITY_COMPARATOR);
         List<Batch> batches = distributeRoutes(vehicleRoutes, nuOfBatches);
         List<String> failedConstraintNames = new ArrayList<>();
         for (final Job unassignedJob : unassignedJobList) {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionData.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionData.java
index e5e7f6c2e..ecadf0c81 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionData.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionData.java
@@ -41,7 +41,7 @@ public NoInsertionFound() {
 
     }
 
-    private static final InsertionData noInsertion = new NoInsertionFound();
+    public static final InsertionData noInsertion = new NoInsertionFound();
 
     /**
      * Returns an instance of InsertionData that represents an EmptyInsertionData (which might indicate
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionDataUpdater.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionDataUpdater.java
index 67e7a5071..42172864a 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionDataUpdater.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionDataUpdater.java
@@ -25,6 +25,7 @@
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
 
 import java.util.*;
+import java.util.stream.Stream;
 
 /**
  * Created by schroeder on 15/10/15.
@@ -32,55 +33,66 @@
 class InsertionDataUpdater {
 
     static boolean update(boolean addAllAvailable, Collection<String> initialVehicleIds, VehicleFleetManager fleetManager, JobInsertionCostsCalculator insertionCostsCalculator, Set<VersionedInsertionData> insertionDataSet, int updateRound, Job unassignedJob, Iterable<VehicleRoute> routes) {
-        for(VehicleRoute route : routes) {
-            Collection<Vehicle> relevantVehicles = new ArrayList<>();
-            if (!(route.vehicle() instanceof VehicleImpl.NoVehicle)) {
-                relevantVehicles.add(route.vehicle());
-                if(addAllAvailable && !initialVehicleIds.contains(route.vehicle().id())){
-                    relevantVehicles.addAll(fleetManager.vehiclesAvailable(route.vehicle()));
+        for (VehicleRoute route : routes) {
+
+            Stream<Vehicle> relevantVehicles;
+
+            Vehicle vehicle = route.vehicle();
+            if (!(vehicle instanceof VehicleImpl.NoVehicle)) {
+                relevantVehicles = Stream.of(vehicle);
+                if (addAllAvailable && !initialVehicleIds.contains(vehicle.id())) {
+                    relevantVehicles = Stream.concat(
+                            relevantVehicles,
+                            fleetManager.vehiclesAvailable(vehicle).stream() );
                 }
-            } else relevantVehicles.addAll(fleetManager.vehiclesAvailable());
-            for (Vehicle v : relevantVehicles) {
+            } else {
+                relevantVehicles = fleetManager.vehiclesAvailable().stream();
+            }
+            relevantVehicles.forEach(v -> {
+
                 double depTime = v.earliestDeparture();
+
                 InsertionData iData = insertionCostsCalculator.getInsertionData(route, unassignedJob, v, depTime, route.driver, Double.MAX_VALUE);
+
                 if (iData instanceof InsertionData.NoInsertionFound) {
-                    continue;
+                    return;
                 }
                 insertionDataSet.add(new VersionedInsertionData(iData, updateRound, route));
-            }
+
+            });
         }
         return true;
     }
 
 
-
     static VehicleRoute findRoute(Iterable<VehicleRoute> routes, Job job) {
-        for(VehicleRoute r : routes){
-            if(r.vehicle().aBreak() == job) return r;
+        for (VehicleRoute r : routes) {
+            if (r.vehicle().aBreak() == job)
+                return r;
         }
         return null;
     }
 
-    static Comparator<VersionedInsertionData> getComparator(){
+    static Comparator<VersionedInsertionData> getComparator() {
         return (o1, o2) -> {
-            if(o1.getiData().getInsertionCost() < o2.getiData().getInsertionCost()) return -1;
+            if (o1.getiData().getInsertionCost() < o2.getiData().getInsertionCost()) return -1;
             return 1;
         };
     }
 
     static ScoredJob getBest(boolean switchAllowed, Collection<String> initialVehicleIds, VehicleFleetManager fleetManager, JobInsertionCostsCalculator insertionCostsCalculator, ScoringFunction scoringFunction, TreeSet<VersionedInsertionData>[] priorityQueues, Map<VehicleRoute, Integer> updates, Iterable<Job> unassignedJobList, Collection<ScoredJob> badJobs) {
         ScoredJob bestScoredJob = null;
-        for(Job j : unassignedJobList){
+        for (Job j : unassignedJobList) {
             VehicleRoute bestRoute = null;
             InsertionData best = null;
             InsertionData secondBest = null;
             TreeSet<VersionedInsertionData> priorityQueue = priorityQueues[j.index()];
             Iterator<VersionedInsertionData> iterator = priorityQueue.iterator();
             List<String> failedConstraintNames = new ArrayList<>();
-            while(iterator.hasNext()){
+            while (iterator.hasNext()) {
                 VersionedInsertionData versionedIData = iterator.next();
-                if(bestRoute != null){
-                    if(versionedIData.getRoute() == bestRoute){
+                if (bestRoute != null) {
+                    if (versionedIData.getRoute() == bestRoute) {
                         continue;
                     }
                 }
@@ -88,37 +100,35 @@ static ScoredJob getBest(boolean switchAllowed, Collection<String> initialVehicl
                     failedConstraintNames.addAll(versionedIData.getiData().getFailedConstraintNames());
                     continue;
                 }
-                if(!(versionedIData.getRoute().vehicle() instanceof VehicleImpl.NoVehicle)) {
+                if (!(versionedIData.getRoute().vehicle() instanceof VehicleImpl.NoVehicle)) {
                     if (versionedIData.getiData().getSelectedVehicle() != versionedIData.getRoute().vehicle()) {
                         if (!switchAllowed) continue;
                         if (initialVehicleIds.contains(versionedIData.getRoute().vehicle().id())) continue;
                     }
                 }
-                if(versionedIData.getiData().getSelectedVehicle() != versionedIData.getRoute().vehicle()) {
+                if (versionedIData.getiData().getSelectedVehicle() != versionedIData.getRoute().vehicle()) {
                     if (fleetManager.isLocked(versionedIData.getiData().getSelectedVehicle())) {
                         Vehicle available = fleetManager.vehicleAvailable(versionedIData.getiData().getSelectedVehicle().vehicleType());
                         if (available != null) {
                             InsertionData oldData = versionedIData.getiData();
                             InsertionData newData = new InsertionData(oldData.getInsertionCost(), oldData.getPickupInsertionIndex(),
-                                oldData.getDeliveryInsertionIndex(), available, oldData.getSelectedDriver());
+                                    oldData.getDeliveryInsertionIndex(), available, oldData.getSelectedDriver());
                             newData.setVehicleDepartureTime(oldData.getVehicleDepartureTime());
-                            for(Event e : oldData.getEvents()){
-                                if(e instanceof SwitchVehicle){
-                                    newData.getEvents().add(new SwitchVehicle(versionedIData.getRoute(),available,oldData.getVehicleDepartureTime()));
-                                }
-                                else newData.getEvents().add(e);
+                            for (Event e : oldData.getEvents()) {
+                                if (e instanceof SwitchVehicle) {
+                                    newData.getEvents().add(new SwitchVehicle(versionedIData.getRoute(), available, oldData.getVehicleDepartureTime()));
+                                } else newData.getEvents().add(e);
                             }
                             versionedIData = new VersionedInsertionData(newData, versionedIData.getVersion(), versionedIData.getRoute());
                         } else continue;
                     }
                 }
                 int currentDataVersion = updates.get(versionedIData.getRoute());
-                if(versionedIData.getVersion() == currentDataVersion){
-                    if(best == null) {
+                if (versionedIData.getVersion() == currentDataVersion) {
+                    if (best == null) {
                         best = versionedIData.getiData();
                         bestRoute = versionedIData.getRoute();
-                    }
-                    else {
+                    } else {
                         secondBest = versionedIData.getiData();
                         break;
                     }
@@ -126,7 +136,7 @@ static ScoredJob getBest(boolean switchAllowed, Collection<String> initialVehicl
             }
             VehicleRoute emptyRoute = VehicleRoute.emptyRoute();
             InsertionData iData = insertionCostsCalculator.getInsertionData(emptyRoute, j, null, -1, null, Double.MAX_VALUE);
-            if(!(iData instanceof InsertionData.NoInsertionFound)){
+            if (!(iData instanceof InsertionData.NoInsertionFound)) {
                 if (best == null) {
                     best = iData;
                     bestRoute = emptyRoute;
@@ -146,10 +156,9 @@ static ScoredJob getBest(boolean switchAllowed, Collection<String> initialVehicl
             ScoredJob scoredJob;
             scoredJob = bestRoute == emptyRoute ? new ScoredJob(j, score, best, bestRoute, true) : new ScoredJob(j, score, best, bestRoute, false);
 
-            if(bestScoredJob == null){
+            if (bestScoredJob == null) {
                 bestScoredJob = scoredJob;
-            }
-            else if(scoredJob.getScore() > bestScoredJob.getScore()){
+            } else if (scoredJob.getScore() > bestScoredJob.getScore()) {
                 bestScoredJob = scoredJob;
             }
         }
@@ -157,7 +166,7 @@ else if(scoredJob.getScore() > bestScoredJob.getScore()){
     }
 
     static double score(Job unassignedJob, InsertionData best, InsertionData secondBest, ScoringFunction scoringFunction) {
-        return Scorer.score(unassignedJob,best,secondBest,scoringFunction);
+        return Scorer.score(unassignedJob, best, secondBest, scoringFunction);
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionOnRouteLevelCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionOnRouteLevelCalculator.java
index 7901298b5..3ae8092ab 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionOnRouteLevelCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionOnRouteLevelCalculator.java
@@ -287,7 +287,7 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
 
     private void initialiseStartAndEnd(final Vehicle newVehicle, double newVehicleDepartureTime) {
         if (start == null) {
-            start = new Start(newVehicle.start(), newVehicle.earliestDeparture(), Double.MAX_VALUE);
+            start = new Start(newVehicle.start(), newVehicle.earliestDeparture(), Double.POSITIVE_INFINITY);
             start.end(newVehicleDepartureTime);
         } else {
             start.setLocation(Location.the(newVehicle.start().id));
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/listener/InsertionListeners.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/listener/InsertionListeners.java
index 92b62e695..991ece4c6 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/listener/InsertionListeners.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/listener/InsertionListeners.java
@@ -25,18 +25,23 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
+import java.util.Objects;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 
 public class InsertionListeners {
 
-    private final Collection<InsertionListener> listeners = new ArrayList<>();
+    private final Collection<InsertionListener> listeners = new CopyOnWriteArrayList<>();
+
+    /** for fast iteration, updated after listeners changed */
+    private InsertionListener[] listenersArray = new InsertionListener[0];
 
     public Collection<InsertionListener> getListeners() {
         return listeners;
     }
 
     public void informJobInserted(Job insertedJob, VehicleRoute inRoute, double additionalCosts, double additionalTime) {
-        for (InsertionListener l : listeners) {
+        for (InsertionListener l : listenersArray) {
             if (l instanceof JobInsertedListener) {
                 ((JobInsertedListener) l).informJobInserted(insertedJob, inRoute, additionalCosts, additionalTime);
             }
@@ -44,7 +49,7 @@ public void informJobInserted(Job insertedJob, VehicleRoute inRoute, double addi
     }
 
     public void informVehicleSwitched(VehicleRoute route, Vehicle oldVehicle, Vehicle newVehicle) {
-        for (InsertionListener l : listeners) {
+        for (InsertionListener l : listenersArray) {
             if (l instanceof VehicleSwitchedListener) {
                 ((VehicleSwitchedListener) l).vehicleSwitched(route, oldVehicle, newVehicle);
             }
@@ -52,7 +57,7 @@ public void informVehicleSwitched(VehicleRoute route, Vehicle oldVehicle, Vehicl
     }
 
     public void informBeforeJobInsertion(Job job, InsertionData data, VehicleRoute route) {
-        for (InsertionListener l : listeners) {
+        for (InsertionListener l : listenersArray) {
             if (l instanceof BeforeJobInsertionListener) {
                 ((BeforeJobInsertionListener) l).informBeforeJobInsertion(job, data, route);
             }
@@ -60,7 +65,7 @@ public void informBeforeJobInsertion(Job job, InsertionData data, VehicleRoute r
     }
 
     public void informInsertionStarts(Collection<VehicleRoute> vehicleRoutes, Collection<Job> unassignedJobs) {
-        for (InsertionListener l : listeners) {
+        for (InsertionListener l : listenersArray) {
             if (l instanceof InsertionStartsListener) {
                 ((InsertionStartsListener) l).informInsertionStarts(vehicleRoutes, unassignedJobs);
             }
@@ -68,7 +73,7 @@ public void informInsertionStarts(Collection<VehicleRoute> vehicleRoutes, Collec
     }
 
     public void informInsertionEndsListeners(Collection<VehicleRoute> vehicleRoutes) {
-        for (InsertionListener l : listeners) {
+        for (InsertionListener l : listenersArray) {
             if (l instanceof InsertionEndsListener) {
                 ((InsertionEndsListener) l).informInsertionEnds(vehicleRoutes);
             }
@@ -76,7 +81,7 @@ public void informInsertionEndsListeners(Collection<VehicleRoute> vehicleRoutes)
     }
 
     public void informJobUnassignedListeners(Job unassigned, Collection<String> reasons) {
-        for (InsertionListener l : listeners) {
+        for (InsertionListener l : listenersArray) {
             if (l instanceof JobUnassignedListener) {
                 ((JobUnassignedListener) l).informJobUnassigned(unassigned, reasons);
             }
@@ -84,15 +89,22 @@ public void informJobUnassignedListeners(Job unassigned, Collection<String> reas
     }
 
     public void addListener(InsertionListener insertionListener) {
-        listeners.add(insertionListener);
+        if (listeners.add(insertionListener))
+            commit();
     }
 
     public void removeListener(InsertionListener insertionListener) {
-        listeners.remove(insertionListener);
+
+        if (listeners.remove(insertionListener))
+            commit();
     }
 
-    public void addAllListeners(Iterable<InsertionListener> listeners) {
-        for (InsertionListener l : listeners) addListener(l);
+    private void commit() {
+        this.listenersArray = listeners.toArray(new InsertionListener[listeners.size()]);
     }
 
+//    public void addAllListeners(Iterable<InsertionListener> listeners) {
+//        for (InsertionListener l : listeners) addListener(l);
+//    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinWorst.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinWorst.java
index 6b7586179..4474c7ebf 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinWorst.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinWorst.java
@@ -40,7 +40,7 @@
 
 public final class RuinWorst extends AbstractRuinStrategy {
 
-    private final Logger logger = LoggerFactory.getLogger(RuinWorst.class);
+    private static final Logger logger = LoggerFactory.getLogger(RuinWorst.class);
 
     private NoiseMaker noiseMaker = () -> 0;
 
@@ -83,11 +83,12 @@ private void ruin(Collection<VehicleRoute> vehicleRoutes, int nOfJobs2BeRemoved,
 
     private Job getWorst(Iterable<VehicleRoute> copied) {
         Job worst = null;
-        double bestSavings = Double.MIN_VALUE;
+        double bestSavings = Double.NEGATIVE_INFINITY;
 
+        Map<Job, Double> savingsMap = new LinkedHashMap<>();
         for (VehicleRoute route : copied) {
+            savingsMap.clear();
             if (route.isEmpty()) continue;
-            Map<Job, Double> savingsMap = new HashMap<>();
             AbstractActivity actBefore = route.start;
             AbstractActivity actToEval = null;
             for (AbstractActivity act : route.activities()) {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Capacity.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Capacity.java
index 3e136b289..ac211b971 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Capacity.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Capacity.java
@@ -42,9 +42,10 @@
      */
     public static Capacity addup(Capacity cap1, Capacity cap2) {
         if (cap1 == null || cap2 == null)
-            throw new NullPointerException("arguments must not be null");
+            throw new NullPointerException();
         Capacity.Builder capacityBuilder = Capacity.Builder.get();
-        for (int i = 0; i < Math.max(cap1.dim(), cap2.dim()); i++) {
+        int max = Math.max(cap1.dim(), cap2.dim());
+        for (int i = 0; i < max; i++) {
             capacityBuilder.addDimension(i, cap1.get(i) + cap2.get(i));
         }
         return capacityBuilder.build();
@@ -62,7 +63,8 @@ public static Capacity addup(Capacity cap1, Capacity cap2) {
     public static Capacity subtract(Capacity cap, Capacity cap2subtract) {
         if (cap == null || cap2subtract == null) throw new NullPointerException("arguments must not be null");
         Capacity.Builder capacityBuilder = Capacity.Builder.get();
-        for (int i = 0; i < Math.max(cap.dim(), cap2subtract.dim()); i++) {
+        int max = Math.max(cap.dim(), cap2subtract.dim());
+        for (int i = 0; i < max; i++) {
             int dimValue = cap.get(i) - cap2subtract.get(i);
             capacityBuilder.addDimension(i, dimValue);
         }
@@ -79,7 +81,8 @@ public static Capacity subtract(Capacity cap, Capacity cap2subtract) {
     public static Capacity invert(Capacity cap2invert) {
         if (cap2invert == null) throw new NullPointerException("arguments must not be null");
         Capacity.Builder capacityBuilder = Capacity.Builder.get();
-        for (int i = 0; i < cap2invert.dim(); i++) {
+        int d = cap2invert.dim();
+        for (int i = 0; i < d; i++) {
             int dimValue = cap2invert.get(i) * -1;
             capacityBuilder.addDimension(i, dimValue);
         }
@@ -101,18 +104,20 @@ public static Capacity invert(Capacity cap2invert) {
     public static double divide(Capacity numerator, Capacity denominator) {
         int nuOfDimensions = 0;
         double sumQuotients = 0.0;
-        for (int index = 0; index < Math.max(numerator.dim(), denominator.dim()); index++) {
-            if (numerator.get(index) != 0 && denominator.get(index) == 0) {
+        int max = Math.max(numerator.dim(), denominator.dim());
+        for (int index = 0; index < max; index++) {
+            int ni = numerator.get(index);
+            int di = denominator.get(index);
+            if (ni != 0 && di == 0) {
                 throw new IllegalArgumentException("numerator > 0 and denominator = 0. cannot divide by 0");
-            } else if (numerator.get(index) == 0 && denominator.get(index) == 0) {
+            } else if (ni == 0 && di == 0) {
                 continue;
             } else {
                 nuOfDimensions++;
-                sumQuotients += (double) numerator.get(index) / (double) denominator.get(index);
+                sumQuotients += ((double) ni) / di;
             }
         }
-        if (nuOfDimensions > 0) return sumQuotients / (double) nuOfDimensions;
-        return 0.0;
+        return nuOfDimensions > 0 ? sumQuotients / nuOfDimensions : 0.0;
     }
 
 //    /**
@@ -243,10 +248,10 @@ public boolean lessOrEq(Capacity toCompare) {
         //int d = this.dim();
         int[] cc = this.dimensions;
         int[] dd = toCompare.dimensions;
-        int d = cc.length;
-        if (dd.length > d) return true;
-
-        for (int i = 0; i < d; i++) {
+        int cLen = cc.length;
+        int dLen = dd.length;
+        if (cLen!=dLen) return cLen < dLen;
+        for (int i = 0; i < cLen; i++) {
             if (cc[i] > dd[i]) return false;
         }
         return true;
@@ -264,9 +269,10 @@ public boolean greaterOrEq(Capacity toCompare) {
         //int d = Math.max(this.dim(), toCompare.dim());
         int[] cc = this.dimensions;
         int[] dd = toCompare.dimensions;
-        int d = cc.length;
-        if (d > dd.length) return true;
-        for (int i = 0; i < d; i++) {
+        int cLen = cc.length;
+        int dLen = dd.length;
+        if (cLen!=dLen) return cLen > dLen;
+        for (int i = 0; i < cLen; i++) {
             if (cc[i] < dd[i]) return false;
         }
         return true;
@@ -291,7 +297,8 @@ public String toString() {
     public static Capacity max(Capacity cap1, Capacity cap2) {
 //        if (cap1 == null || cap2 == null) throw new IllegalArgumentException("arg must not be null");
         Capacity.Builder toReturnBuilder = Capacity.Builder.get();
-        for (int i = 0; i < Math.max(cap1.dim(), cap2.dim()); i++) {
+        int max = Math.max(cap1.dim(), cap2.dim());
+        for (int i = 0; i < max; i++) {
             toReturnBuilder.addDimension(i, Math.max(cap1.get(i), cap2.get(i)));
         }
         return toReturnBuilder.build();
@@ -300,7 +307,8 @@ public static Capacity max(Capacity cap1, Capacity cap2) {
     public static Capacity min(Capacity cap1, Capacity cap2) {
 //        if (cap1 == null || cap2 == null) throw new IllegalArgumentException("arg must not be null");
         Capacity.Builder toReturnBuilder = Capacity.Builder.get();
-        for (int i = 0; i < Math.max(cap1.dim(), cap2.dim()); i++) {
+        int max = Math.max(cap1.dim(), cap2.dim());
+        for (int i = 0; i < max; i++) {
             toReturnBuilder.addDimension(i, Math.min(cap1.get(i), cap2.get(i)));
         }
         return toReturnBuilder.build();
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
index f446d5064..90c5178f0 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
@@ -78,19 +78,19 @@ public static Builder get() {
 
         private final Map<String, Job> tentativeJobs = new LinkedHashMap<>();
 
-        private final Collection<Job> jobsInInitialRoutes = new HashSet<>();
+        private final Set<Job> jobsInInitialRoutes = new HashSet<>();
 
         private final Map<String, v2> tentative_coordinates = new HashMap<>();
 
         private FleetSize fleetSize = FleetSize.INFINITE;
 
-        private final Collection<VehicleType> vehicleTypes = new ArrayList<>();
+        private final Set<VehicleType> vehicleTypes = new HashSet<>();
 
-        private final Collection<VehicleRoute> initialRoutes = new ArrayList<>();
+        private final Set<VehicleRoute> initialRoutes = new LinkedHashSet();
 
-        private final Collection<Vehicle> uniqueVehicles = new LinkedHashSet<>();
+        private final Set<Vehicle> uniqueVehicles = new LinkedHashSet<>();
 
-        private final Collection<String> addedVehicleIds = new LinkedHashSet<>();
+        private final Set<String> addedVehicleIds = new LinkedHashSet<>();
 
 //        private final boolean hasBreaks;
 
@@ -135,7 +135,7 @@ private void incVehicleTypeIdIndexCounter() {
             vehicleTypeIdIndexCounter++;
         }
 
-        private final Collection<Location> allLocations = new HashSet<>();
+        private final Set<Location> allLocations = new LinkedHashSet<>();
 
         /**
          * Returns the unmodifiable map of collected locations (mapped by their location-id).
@@ -228,8 +228,8 @@ private void addLocationToTentativeLocations(Job job) {
         }
 
         private void addLocationToTentativeLocations(Location location) {
-            tentative_coordinates.put(location.id, location.coord);
-            allLocations.add(location);
+            if (allLocations.add(location))
+                tentative_coordinates.put(location.id, location.coord);
         }
 
         private void addJobToFinalJobMapAndCreateActivities(Job job) {
@@ -280,7 +280,6 @@ private boolean addBreaksToActivityMap() {
         public Builder addInitialVehicleRoute(VehicleRoute route) {
             if(!addedVehicleIds.contains(route.vehicle().id())){
                 addVehicle((AbstractVehicle) route.vehicle());
-                addedVehicleIds.add(route.vehicle().id());
             }
             for (AbstractActivity act : route.activities()) {
                 AbstractActivity abstractAct = act;
@@ -288,9 +287,10 @@ public Builder addInitialVehicleRoute(VehicleRoute route) {
                 incActivityIndexCounter();
                 if (act instanceof JobActivity) {
                     Job job = ((JobActivity) act).job();
-                    jobsInInitialRoutes.add(job);
-                    addLocationToTentativeLocations(job);
-                    registerJobAndActivity((JobActivity) abstractAct, job);
+                    if (jobsInInitialRoutes.add(job)) {
+                        addLocationToTentativeLocations(job);
+                        registerJobAndActivity((JobActivity) abstractAct, job);
+                    }
                 }
             }
             initialRoutes.add(route);
@@ -300,14 +300,7 @@ public Builder addInitialVehicleRoute(VehicleRoute route) {
 
 
         private void registerJobAndActivity(JobActivity abstractAct, Job job) {
-            List<JobActivity> jobs = activityMap.get(job);
-            if (jobs != null) {
-                jobs.add(abstractAct);
-            } else {
-                List<JobActivity> actList = new ArrayList<>(1);
-                actList.add(abstractAct);
-                activityMap.put(job, actList);
-            }
+            activityMap.computeIfAbsent(job, (k)->new ArrayList()).add(abstractAct);
         }
 
         /**
@@ -324,13 +317,12 @@ public Builder addInitialVehicleRoutes(Iterable<VehicleRoute> routes) {
         }
 
         private void addShipment(Job job) {
-            if (jobs.containsKey(job.id())) {
+            if (jobs.putIfAbsent(job.id(), job)!=null) {
                 logger.warn("job {} already in job list. overrides existing job.", job);
             }
             addLocationToTentativeLocations(job);
 //            tentative_coordinates.put(job.getPickupLocation().getId(), job.getPickupLocation().getCoordinate());
 //            tentative_coordinates.put(job.getDeliveryLocation().getId(), job.getDeliveryLocation().getCoordinate());
-            jobs.put(job.id(), job);
         }
 
         /**
@@ -352,10 +344,10 @@ public Builder addVehicle(Vehicle vehicle) {
          * @return this builder
          */
         public Builder addVehicle(AbstractVehicle vehicle) {
-            if(addedVehicleIds.contains(vehicle.id())){
+            if(!addedVehicleIds.add(vehicle.id())){
                 throw new IllegalArgumentException("problem already contains a vehicle with id " + vehicle.id() + ". choose unique ids for each vehicle.");
             }
-            else addedVehicleIds.add(vehicle.id());
+
             if (!uniqueVehicles.contains(vehicle)) {
                 vehicle.setIndex(vehicleIndexCounter);
                 incVehicleIndexCounter();
@@ -368,9 +360,9 @@ public Builder addVehicle(AbstractVehicle vehicle) {
                 incVehicleTypeIdIndexCounter();
             }
             uniqueVehicles.add(vehicle);
-            if (!vehicleTypes.contains(vehicle.type())) {
-                vehicleTypes.add(vehicle.type());
-            }
+
+            vehicleTypes.add(vehicle.type());
+
             String startLocationId = vehicle.start().id;
             addLocationToTentativeLocations(vehicle.start());
 //            tentative_coordinates.put(startLocationId, vehicle.getStartLocation().getCoordinate());
@@ -608,8 +600,8 @@ public FleetSize getFleetSize() {
      *
      * @return copied collection of initial vehicle routes
      */
-    public Collection<VehicleRoute> initialVehicleRoutes() {
-        Collection<VehicleRoute> copiedInitialRoutes = new ArrayList<>(initialVehicleRoutes.size());
+    public Set<VehicleRoute> initialVehicleRoutes() {
+        Set<VehicleRoute> copiedInitialRoutes = new HashSet<>(initialVehicleRoutes.size());
         for (VehicleRoute route : initialVehicleRoutes) {
             copiedInitialRoutes.add(VehicleRoute.copyOf(route));
         }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/HardActivityLevelConstraintManager.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/HardActivityLevelConstraintManager.java
index 0afb17eae..e8bdba193 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/HardActivityLevelConstraintManager.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/HardActivityLevelConstraintManager.java
@@ -45,15 +45,15 @@ public void addConstraint(HardActivityConstraint constraint, ConstraintManager.P
     }
 
     Collection<HardActivityConstraint> getCriticalConstraints() {
-        return Collections.unmodifiableCollection(criticalConstraints);
+        return /*Collections.unmodifiableCollection*/(criticalConstraints);
     }
 
     Collection<HardActivityConstraint> getHighPrioConstraints() {
-        return Collections.unmodifiableCollection(highPrioConstraints);
+        return /*Collections.unmodifiableCollection*/(highPrioConstraints);
     }
 
     Collection<HardActivityConstraint> getLowPrioConstraints() {
-        return Collections.unmodifiableCollection(lowPrioConstraints);
+        return /*Collections.unmodifiableCollection*/(lowPrioConstraints);
     }
 
     Collection<HardActivityConstraint> getAllConstraints() {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTimeWindowConstraints.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTimeWindowConstraints.java
index c29605b52..331039da5 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTimeWindowConstraints.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTimeWindowConstraints.java
@@ -108,12 +108,14 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, AbstractActivity
         }
         //			log.info("check insertion of " + newAct + " between " + prevAct + " and " + nextAct + ". prevActDepTime=" + prevActDepTime);
         double arrTimeAtNewAct = prevActDepTime + routingCosts.transportTime(prevAct.location(), newAct.location(), prevActDepTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
-        double endTimeAtNewAct = Math.max(arrTimeAtNewAct, newAct.startEarliest()) + activityCosts.getActivityDuration(newAct, arrTimeAtNewAct,iFacts.getNewDriver(),iFacts.getNewVehicle());
+        double activityDuration = activityCosts.getActivityDuration(newAct, arrTimeAtNewAct, iFacts.getNewDriver(), iFacts.getNewVehicle());
+        double endTimeAtNewAct = Math.max(arrTimeAtNewAct, newAct.startEarliest())
+                + activityDuration;
         double latestArrTimeAtNewAct =
             Math.min(newAct.startLatest(),
                 latestArrTimeAtNextAct -
                     routingCosts.transportTimeReverse(newAct.location(), nextActLocation, latestArrTimeAtNextAct, iFacts.getNewDriver(), iFacts.getNewVehicle())
-                    - activityCosts.getActivityDuration(newAct, arrTimeAtNewAct, iFacts.getNewDriver(), iFacts.getNewVehicle())
+                    - activityDuration
             );
 
 			/*
@@ -139,10 +141,8 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, AbstractActivity
 			 *                       		                 |--- vehicle's arrival @nextAct
 			 *        latest arrival of vehicle @nextAct ---|
 			 */
-        if (arrTimeAtNextAct > latestArrTimeAtNextAct) {
-            return ConstraintsStatus.NOT_FULFILLED;
-        }
-        return ConstraintsStatus.FULFILLED;
+        return arrTimeAtNextAct > latestArrTimeAtNextAct ?
+                ConstraintsStatus.NOT_FULFILLED : ConstraintsStatus.FULFILLED;
     }
 }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
index 24ba79f5f..90dffea16 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
@@ -297,7 +297,7 @@ public final TimeWindows timeWindows(){
     }
 
     @Override
-    public final String id() {
+    public String id() {
         return id;
     }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/InitialSolutionFactory.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/InitialSolutionFactory.java
index 792bde83f..aa5724c25 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/InitialSolutionFactory.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/InitialSolutionFactory.java
@@ -32,6 +32,6 @@
      * @param vrp
      * @return
      */
-    VehicleRoutingProblemSolution createSolution(VehicleRoutingProblem vrp);
+    VehicleRoutingProblemSolution solution(VehicleRoutingProblem vrp);
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolution.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolution.java
index 1a3e70b3d..4c6f17291 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolution.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolution.java
@@ -20,8 +20,7 @@
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 
-import java.util.ArrayList;
-import java.util.Collection;
+import java.util.*;
 
 
 /**
@@ -41,7 +40,7 @@ public static VehicleRoutingProblemSolution copyOf(VehicleRoutingProblemSolution
         return new VehicleRoutingProblemSolution(solution2copy);
     }
 
-    public final Collection<VehicleRoute> routes;
+    public final Set<VehicleRoute> routes;
 
     public final Collection<Job> jobsUnassigned;
 
@@ -49,13 +48,12 @@ public static VehicleRoutingProblemSolution copyOf(VehicleRoutingProblemSolution
 
     private VehicleRoutingProblemSolution(VehicleRoutingProblemSolution solution) {
         if (solution.routes!=null) {
-            routes = new ArrayList<>(solution.routes.size());
+            routes = new LinkedHashSet<>(solution.routes.size());
             for (VehicleRoute r : solution.routes) {
-                VehicleRoute route = VehicleRoute.copyOf(r);
-                routes.add(route);
+                routes.add(VehicleRoute.copyOf(r));
             }
         } else {
-            routes = new ArrayList(0);
+            routes = new LinkedHashSet();
         }
         this.cost = solution.cost();
 
@@ -69,12 +67,17 @@ private VehicleRoutingProblemSolution(VehicleRoutingProblemSolution solution) {
      * @param cost   total costs of solution
      */
     public VehicleRoutingProblemSolution(Collection<VehicleRoute> routes, double cost) {
-        this.routes = routes;
         assert(routes!=null);
+        this.routes = initRoutes(routes);
         this.cost = cost;
         jobsUnassigned = new ArrayList<>();
     }
 
+    private Set<VehicleRoute> initRoutes(Collection<VehicleRoute> routes) {
+        return routes instanceof Set ?
+                (Set<VehicleRoute>) routes : new LinkedHashSet<>(routes);
+    }
+
     /**
      * Constructs a solution with a number of {@link VehicleRoute}s, bad jobs and their corresponding aggregate cost value.
      *
@@ -82,8 +85,8 @@ public VehicleRoutingProblemSolution(Collection<VehicleRoute> routes, double cos
      * @param jobsUnassigned jobs that could not be assigned to any vehicle
      * @param cost           total costs of solution
      */
-    public VehicleRoutingProblemSolution(Collection<VehicleRoute> routes, Collection<Job> jobsUnassigned, double cost) {
-        this.routes = routes;
+    public VehicleRoutingProblemSolution(Set<VehicleRoute> routes, Collection<Job> jobsUnassigned, double cost) {
+        this.routes = initRoutes(routes);
         assert(routes!=null);
         this.jobsUnassigned = jobsUnassigned;
         this.cost = cost;
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/UnassignedJobReasonTracker.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/UnassignedJobReasonTracker.java
index 45d7156f2..9895cca2f 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/UnassignedJobReasonTracker.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/UnassignedJobReasonTracker.java
@@ -22,6 +22,7 @@
 import com.graphhopper.jsprit.core.problem.job.Job;
 import org.apache.commons.math3.stat.Frequency;
 
+
 import java.util.*;
 
 /**
@@ -31,114 +32,119 @@
 
     public static String getMostLikelyFailedConstraintName(Frequency failedConstraintNamesFrequency) {
         if (failedConstraintNamesFrequency == null) return "no reason found";
-        Iterator<Map.Entry<Comparable<?>, Long>> entryIterator = failedConstraintNamesFrequency.entrySetIterator();
         long maxCount = 0;
-        String mostLikely = null;
+        Comparable<?> mostLikely = null;
+        Iterator<Map.Entry<Comparable<?>, Long>> entryIterator = failedConstraintNamesFrequency.entrySetIterator();
         while (entryIterator.hasNext()) {
             Map.Entry<Comparable<?>, Long> entry = entryIterator.next();
-            if (entry.getValue() > maxCount) {
-                Comparable<?> key = entry.getKey();
-                maxCount = entry.getValue();
-                mostLikely = key.toString();
+            long ev = entry.getValue();
+            if (ev > maxCount) {
+                maxCount = ev;
+                mostLikely = entry.getKey();
             }
         }
-        return mostLikely;
+        java.util.
+        return mostLikely.toString();
     }
 
     final Map<String, Frequency> failedConstraintNamesFrequencyMapping = new HashMap<>();
 
-    final Map<Integer, String> codesToHumanReadableReason = new HashMap<>();
+    static final String[] codesToHumanReadableReason = new String[]{
+        /* 0 */ null,
+        /* 1 */ "cannot serve required skill",
+        /* 2 */ "cannot be visited within time window",
+        /* 3 */ "does not fit into any vehicle due to capacity",
+        /* 4 */ "cannot be assigned due to max distance constraint of vehicle"
+    };
+
+    static final Map<String, Integer> failedConstraintNamesToCode = Map.of(
+            "HardSkillConstraint", 1,
+            "VehicleDependentTimeWindowConstraints", 2,
+            "ServiceLoadRouteLevelConstraint", 3,
+            "PickupAndDeliverShipmentLoadActivityLevelConstraint", 3,
+            "ServiceLoadActivityLevelConstraint", 3,
+            "MaxDistanceConstraint", 4
+    );
+
+//    final Collection<String> failedConstraintNamesToBeIgnored = new HashSet<>();
 
-    final Map<String, Integer> failedConstraintNamesToCode = new HashMap<>();
+    public UnassignedJobReasonTracker() {
 
-    final Collection<String> failedConstraintNamesToBeIgnored = new HashSet<>();
 
-    public UnassignedJobReasonTracker() {
-        codesToHumanReadableReason.put(1, "cannot serve required skill");
-        codesToHumanReadableReason.put(2, "cannot be visited within time window");
-        codesToHumanReadableReason.put(3, "does not fit into any vehicle due to capacity");
-        codesToHumanReadableReason.put(4, "cannot be assigned due to max distance constraint of vehicle");
-
-        failedConstraintNamesToCode.put("HardSkillConstraint", 1);
-        failedConstraintNamesToCode.put("VehicleDependentTimeWindowConstraints", 2);
-        failedConstraintNamesToCode.put("ServiceLoadRouteLevelConstraint", 3);
-        failedConstraintNamesToCode.put("PickupAndDeliverShipmentLoadActivityLevelConstraint", 3);
-        failedConstraintNamesToCode.put("ServiceLoadActivityLevelConstraint", 3);
-        failedConstraintNamesToCode.put("MaxDistanceConstraint", 4);
     }
 
-    public void ignore(String simpleNameOfConstraint) {
-        failedConstraintNamesToBeIgnored.add(simpleNameOfConstraint);
-    }
+//    public void ignore(String simpleNameOfConstraint) {
+//        failedConstraintNamesToBeIgnored.add(simpleNameOfConstraint);
+//    }
 
     @Override
     public void informJobUnassigned(Job unassigned, Collection<String> failedConstraintNames) {
-        if (!this.failedConstraintNamesFrequencyMapping.containsKey(unassigned.id())) {
-            this.failedConstraintNamesFrequencyMapping.put(unassigned.id(), new Frequency());
-        }
+        String uid = unassigned.id();
+        Frequency m = this.failedConstraintNamesFrequencyMapping
+                .computeIfAbsent(uid, (x) -> new Frequency());
         for (String r : failedConstraintNames) {
-            if (failedConstraintNamesToBeIgnored.contains(r)) continue;
-            this.failedConstraintNamesFrequencyMapping.get(unassigned.id()).addValue(r);
+//            if (failedConstraintNamesToBeIgnored.contains(r)) continue;
+            m.addValue(r);
         }
     }
 
-    public void put(String simpleNameOfFailedConstraint, int code, String reason) {
-        if (code <= 20)
-            throw new IllegalArgumentException("first 20 codes are reserved internally. choose a code > 20");
-        codesToHumanReadableReason.put(code, reason);
-        if (failedConstraintNamesToCode.containsKey(simpleNameOfFailedConstraint)) {
-            throw new IllegalArgumentException(simpleNameOfFailedConstraint + " already assigned to code and reason");
-        } else failedConstraintNamesToCode.put(simpleNameOfFailedConstraint, code);
-    }
-
-    /**
-     * For each job id, it returns frequency distribution of failed constraints (simple name of constraint) in an unmodifiable map.
-     *
-     * @return
-     */
-    @Deprecated
-    public Map<String, Frequency> getReasons() {
-        return Collections.unmodifiableMap(failedConstraintNamesFrequencyMapping);
-    }
-
-    /**
-     * For each job id, it returns frequency distribution of failed constraints (simple name of constraint) in an unmodifiable map.
-     *
-     * @return
-     */
-    public Map<String, Frequency> getFailedConstraintNamesFrequencyMapping() {
-        return Collections.unmodifiableMap(failedConstraintNamesFrequencyMapping);
-    }
-
-    /**
-     * Returns an unmodifiable map of codes and reason pairs.
-     *
-     * @return
-     */
-    public Map<Integer, String> getCodesToReason() {
-        return Collections.unmodifiableMap(codesToHumanReadableReason);
-    }
-
-    /**
-     * Returns an unmodifiable map of constraint names (simple name of constraint) and reason code pairs.
-     *
-     * @return
-     */
-    public Map<String, Integer> getFailedConstraintNamesToCode() {
-        return Collections.unmodifiableMap(failedConstraintNamesToCode);
-    }
-
-    public int getCode(String failedConstraintName) {
-        return toCode(failedConstraintName);
-    }
-
-    public String getHumanReadableReason(int code) {
-        return getCodesToReason().get(code);
-    }
-
-    public String getHumanReadableReason(String failedConstraintName) {
-        return getCodesToReason().get(getCode(failedConstraintName));
-    }
+//    public void put(String simpleNameOfFailedConstraint, int code, String reason) {
+//        if (code <= 20)
+//            throw new IllegalArgumentException("first 20 codes are reserved internally. choose a code > 20");
+//        codesToHumanReadableReason.put(code, reason);
+//        if (failedConstraintNamesToCode.containsKey(simpleNameOfFailedConstraint)) {
+//            throw new IllegalArgumentException(simpleNameOfFailedConstraint + " already assigned to code and reason");
+//        } else failedConstraintNamesToCode.put(simpleNameOfFailedConstraint, code);
+//    }
+
+//    /**
+//     * For each job id, it returns frequency distribution of failed constraints (simple name of constraint) in an unmodifiable map.
+//     *
+//     * @return
+//     */
+//    @Deprecated
+//    public Map<String, Frequency> getReasons() {
+//        return Collections.unmodifiableMap(failedConstraintNamesFrequencyMapping);
+//    }
+
+//    /**
+//     * For each job id, it returns frequency distribution of failed constraints (simple name of constraint) in an unmodifiable map.
+//     *
+//     * @return
+//     */
+//    public Map<String, Frequency> getFailedConstraintNamesFrequencyMapping() {
+//        return Collections.unmodifiableMap(failedConstraintNamesFrequencyMapping);
+//    }
+
+//    /**
+//     * Returns an unmodifiable map of codes and reason pairs.
+//     *
+//     * @return
+//     */
+//    public Map<Integer, String> getCodesToReason() {
+//        return Collections.unmodifiableMap(codesToHumanReadableReason);
+//    }
+
+//    /**
+//     * Returns an unmodifiable map of constraint names (simple name of constraint) and reason code pairs.
+//     *
+//     * @return
+//     */
+//    public Map<String, Integer> getFailedConstraintNamesToCode() {
+//        return Collections.unmodifiableMap(failedConstraintNamesToCode);
+//    }
+
+//    public int getCode(String failedConstraintName) {
+//        return toCode(failedConstraintName);
+//    }
+
+//    public String getHumanReadableReason(int code) {
+//        return getCodesToReason().get(code);
+//    }
+//
+//    public String getHumanReadableReason(String failedConstraintName) {
+//        return getCodesToReason().get(getCode(failedConstraintName));
+//    }
 
     /**
      * Returns the most likely reason code i.e. the reason (failed constraint) being observed most often.
@@ -152,26 +158,28 @@ public String getHumanReadableReason(String failedConstraintName) {
      * @return
      */
     public int getMostLikelyReasonCode(String jobId) {
-        if (!this.failedConstraintNamesFrequencyMapping.containsKey(jobId)) return -1;
-        Frequency reasons = this.failedConstraintNamesFrequencyMapping.get(jobId);
-        String mostLikelyReason = getMostLikelyFailedConstraintName(reasons);
-        return toCode(mostLikelyReason);
-    }
 
-    /**
-     * Returns the most likely reason i.e. the reason (failed constraint) being observed most often.
-     *
-     * @param jobId
-     * @return
-     */
-    public String getMostLikelyReason(String jobId) {
-        if (!this.failedConstraintNamesFrequencyMapping.containsKey(jobId)) return "no reason found";
         Frequency reasons = this.failedConstraintNamesFrequencyMapping.get(jobId);
-        String mostLikelyReason = getMostLikelyFailedConstraintName(reasons);
-        int code = toCode(mostLikelyReason);
-        return code == -1 ? mostLikelyReason : codesToHumanReadableReason.get(code);
+        if (reasons == null)
+            return -1;
+
+        return toCode(getMostLikelyFailedConstraintName(reasons));
     }
 
+//    /**
+//     * Returns the most likely reason i.e. the reason (failed constraint) being observed most often.
+//     *
+//     * @param jobId
+//     * @return
+//     */
+//    public String getMostLikelyReason(String jobId) {
+//        if (!this.failedConstraintNamesFrequencyMapping.containsKey(jobId)) return "no reason found";
+//        Frequency reasons = this.failedConstraintNamesFrequencyMapping.get(jobId);
+//        String mostLikelyReason = getMostLikelyFailedConstraintName(reasons);
+//        int code = toCode(mostLikelyReason);
+//        return code == -1 ? mostLikelyReason : codesToHumanReadableReason.get(code);
+//    }
+
     private int toCode(String mostLikelyReason) {
         return failedConstraintNamesToCode.getOrDefault(mostLikelyReason, -1);
     }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithMatrix_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithMatrix_IT.java
index 1621cefd4..fb4cd3448 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithMatrix_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithMatrix_IT.java
@@ -30,9 +30,7 @@
 import org.junit.Assert;
 import org.junit.Test;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
+import java.util.*;
 
 import static org.junit.Assert.*;
 
@@ -82,7 +80,7 @@ public void whenCalcTimeWithSolutionAnalyser_itShouldWork() {
 
     private VehicleRoutingProblem createVrpWithLocationIndecesAndMatrix(VehicleRoutingProblem vrp_, boolean return_to_depot) {
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.get();
-        List<Location> locations = new ArrayList<Location>();
+        Set<Location> locations = new LinkedHashSet<Location>();
         for (Vehicle v : vrp_.vehicles()) {
             Location l = Location.Builder.the().setIndex(getIndex()).setId(v.start().id)
                 .setCoord(v.start().coord).build();
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ExternalInitialSolutionIsInValidTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ExternalInitialSolutionIsInValidTest.java
index a14d25d7a..820b34583 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ExternalInitialSolutionIsInValidTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ExternalInitialSolutionIsInValidTest.java
@@ -29,6 +29,7 @@
 import org.junit.Test;
 
 import java.util.Arrays;
+import java.util.Set;
 
 
 public class ExternalInitialSolutionIsInValidTest {
@@ -50,7 +51,7 @@ public void itShouldSolveProblemWithIniSolutionExternallyCreated() {
          */
         VehicleRoute route1 = VehicleRoute.Builder.newInstance(vehicle).setJobActivityFactory(vrp.jobActivityFactory()).addService(s1).build();
 
-        vra.addInitialSolution(new VehicleRoutingProblemSolution(Arrays.asList(route1), 20.));
+        vra.addInitialSolution(new VehicleRoutingProblemSolution(Set.of(route1), 20.));
 
         try {
             vra.searchSolutions();
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/CalcVehicleTypeDependentServiceInsertionTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/CalcVehicleTypeDependentServiceInsertionTest.java
index de459390e..809b9f85d 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/CalcVehicleTypeDependentServiceInsertionTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/CalcVehicleTypeDependentServiceInsertionTest.java
@@ -29,6 +29,7 @@
 
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.Set;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
@@ -67,7 +68,7 @@ public void doBefore() {
         when(service.size()).thenReturn(Capacity.Builder.get().build());
         when(service.timeWindow()).thenReturn(TimeWindow.the(0.0, Double.MAX_VALUE));
 
-        when(vehicleRoute.driver).thenReturn(null);
+        when(vehicleRoute.driver()).thenReturn(null);
         when(vehicleRoute.vehicle()).thenReturn(VehicleImpl.get());
     }
 
@@ -80,7 +81,7 @@ public void whenHaving2Vehicle_calcInsertionOfCheapest() {
         when(calc.getInsertionData(vehicleRoute, service, veh2, veh2.earliestDeparture(), null, Double.MAX_VALUE)).thenReturn(iDataVeh2);
         when(calc.getInsertionData(vehicleRoute, service, veh2, veh2.earliestDeparture(), null, 10.0)).thenReturn(iDataVeh2);
         VehicleRoutingProblem vrp = mock(VehicleRoutingProblem.class);
-        when(vrp.initialVehicleRoutes()).thenReturn(Collections.emptyList());
+        when(vrp.initialVehicleRoutes()).thenReturn(Set.of());
         VehicleTypeDependentJobInsertionCalculator insertion = new VehicleTypeDependentJobInsertionCalculator(vrp, fleetManager, calc);
         InsertionData iData = insertion.getInsertionData(vehicleRoute, service, null, 0.0, null, Double.MAX_VALUE);
         assertThat(iData.getSelectedVehicle(), is(veh1));
@@ -96,7 +97,7 @@ public void whenHaving2Vehicle_calcInsertionOfCheapest2() {
         when(calc.getInsertionData(vehicleRoute, service, veh2, veh2.earliestDeparture(), null, Double.MAX_VALUE)).thenReturn(iDataVeh2);
         when(calc.getInsertionData(vehicleRoute, service, veh2, veh2.earliestDeparture(), null, 20.0)).thenReturn(iDataVeh2);
         VehicleRoutingProblem vrp = mock(VehicleRoutingProblem.class);
-        when(vrp.initialVehicleRoutes()).thenReturn(Collections.emptyList());
+        when(vrp.initialVehicleRoutes()).thenReturn(Set.of());
         VehicleTypeDependentJobInsertionCalculator insertion = new VehicleTypeDependentJobInsertionCalculator(vrp, fleetManager, calc);
         InsertionData iData = insertion.getInsertionData(vehicleRoute, service, null, 0.0, null, Double.MAX_VALUE);
         assertThat(iData.getSelectedVehicle(), is(veh2));
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestInserter.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestInserter.java
index 8915e2b2c..dc8fa56ee 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestInserter.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestInserter.java
@@ -71,7 +71,7 @@ public void whenInsertingServiceAndRouteIsClosed_itInsertsCorrectly() {
         inserter.insertJob(serviceToInsert, iData, route);
 
         assertEquals(2, route.tourActivities().activities().size());
-        assertEquals(route.tourActivities().activities().get(1).location().id, serviceToInsert.location.id);
+        assertEquals(route.tourActivities().activities().get(1).location().id, serviceToInsert.location.id());
         assertEquals(route.end.location().id, vehicle.end().id);
     }
 
@@ -105,7 +105,7 @@ public void whenInsertingServiceAndRouteIsOpen_itInsertsCorrectlyAndSwitchesEndL
         inserter.insertJob(serviceToInsert, iData, route);
 
         assertEquals(2, route.tourActivities().activities().size());
-        assertEquals(route.tourActivities().activities().get(1).location().id, serviceToInsert.location.id);
+        assertEquals(route.tourActivities().activities().get(1).location().id, serviceToInsert.location.id());
         assertEquals(route.end.location().id, serviceToInsert.location.id);
     }
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyserTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyserTest.java
index 997c68899..2d1433c14 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyserTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyserTest.java
@@ -44,6 +44,7 @@
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Set;
 
 import static org.junit.Assert.*;
 
@@ -99,7 +100,8 @@ public void doBefore() {
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.get().addVehicle(vehicle)
             .addVehicle(vehicle2)
             .addJob(s1)
-            .addJob(s2).addJob(shipment1).addJob(s3).addJob(s4).addJob(shipment2).setFleetSize(VehicleRoutingProblem.FleetSize.INFINITE);
+            .addJob(s2).addJob(shipment1).addJob(s3).addJob(s4).addJob(shipment2)
+                .setFleetSize(VehicleRoutingProblem.FleetSize.INFINITE);
         vrpBuilder.setRoutingCost(new ManhattanCosts(vrpBuilder.getLocations()));
         vrp = vrpBuilder.build();
 
@@ -109,7 +111,7 @@ public void doBefore() {
         VehicleRoute route2 = VehicleRoute.Builder.newInstance(vehicle).setJobActivityFactory(vrp.jobActivityFactory())
             .addService(s3).addPickup(shipment2).addDelivery(shipment2).addService(s4).build();
 
-        solution = new VehicleRoutingProblemSolution(Arrays.asList(route1, route2), 42);
+        solution = new VehicleRoutingProblemSolution(List.of(route1, route2), 42);
     }
 
 
@@ -168,7 +170,7 @@ public void buildAnotherScenarioWithOnlyOneVehicleAndWithoutAnyConstraintsBefore
             .addPickup(s1)
             .build();
 
-        solution = new VehicleRoutingProblemSolution(Arrays.asList(route), 300);
+        solution = new VehicleRoutingProblemSolution(Set.of(route), 300);
     }
 
     /**
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblemTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblemTest.java
index 85dcd5d79..197f4a36e 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblemTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblemTest.java
@@ -130,11 +130,11 @@ public void whenShipmentsAreAdded_vrpShouldContainThem() {
     @Test
     public void whenServicesAreAdded_vrpShouldContainThem() {
         Service s1 = mock(Service.class);
-        when(s1.id).thenReturn("s1");
-        when(s1.location).thenReturn(Location.Builder.the().setIndex(1).build());
+        when(s1.id()).thenReturn("s1");
+        when(s1.location()).thenReturn(Location.Builder.the().setIndex(1).build());
         Service s2 = mock(Service.class);
-        when(s2.id).thenReturn("s2");
-        when(s2.location).thenReturn(Location.Builder.the().setIndex(1).build());
+        when(s2.id()).thenReturn("s2");
+        when(s2.location()).thenReturn(Location.Builder.the().setIndex(1).build());
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.get();
         vrpBuilder.addJob(s1).addJob(s2);
@@ -151,11 +151,11 @@ public void whenServicesAreAdded_vrpShouldContainThem() {
     @Test
     public void whenPickupsAreAdded_vrpShouldContainThem() {
         Pickup s1 = mock(Pickup.class);
-        when(s1.id).thenReturn("s1");
-        when(s1.location).thenReturn(Location.Builder.the().setIndex(1).build());
+        when(s1.id()).thenReturn("s1");
+        when(s1.location()).thenReturn(Location.Builder.the().setIndex(1).build());
         Pickup s2 = mock(Pickup.class);
-        when(s2.id).thenReturn("s2");
-        when(s2.location).thenReturn(Location.Builder.the().setIndex(1).build());
+        when(s2.id()).thenReturn("s2");
+        when(s2.location()).thenReturn(Location.Builder.the().setIndex(1).build());
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.get();
         vrpBuilder.addJob(s1).addJob(s2);
@@ -170,11 +170,11 @@ public void whenPickupsAreAdded_vrpShouldContainThem() {
     @Test
     public void whenPickupsAreAddedAllAtOnce_vrpShouldContainThem() {
         Pickup s1 = mock(Pickup.class);
-        when(s1.id).thenReturn("s1");
-        when(s1.location).thenReturn(Location.Builder.the().setIndex(1).build());
+        when(s1.id()).thenReturn("s1");
+        when(s1.location()).thenReturn(Location.Builder.the().setIndex(1).build());
         Pickup s2 = mock(Pickup.class);
-        when(s2.id).thenReturn("s2");
-        when(s2.location).thenReturn(Location.Builder.the().setIndex(1).build());
+        when(s2.id()).thenReturn("s2");
+        when(s2.location()).thenReturn(Location.Builder.the().setIndex(1).build());
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.get();
         vrpBuilder.addAllJobs(Arrays.asList(s1, s2));
@@ -189,13 +189,13 @@ public void whenPickupsAreAddedAllAtOnce_vrpShouldContainThem() {
     @Test
     public void whenDelivieriesAreAdded_vrpShouldContainThem() {
         Delivery s1 = mock(Delivery.class);
-        when(s1.id).thenReturn("s1");
-        when(s1.size).thenReturn(Capacity.Builder.get().build());
-        when(s1.location).thenReturn(Location.Builder.the().setIndex(1).build());
+        when(s1.id()).thenReturn("s1");
+        when(s1.size()).thenReturn(Capacity.Builder.get().build());
+        when(s1.location()).thenReturn(Location.Builder.the().setIndex(1).build());
         Delivery s2 = mock(Delivery.class);
-        when(s2.id).thenReturn("s2");
-        when(s2.size).thenReturn(Capacity.Builder.get().build());
-        when(s2.location).thenReturn(Location.Builder.the().setIndex(1).build());
+        when(s2.id()).thenReturn("s2");
+        when(s2.size()).thenReturn(Capacity.Builder.get().build());
+        when(s2.location()).thenReturn(Location.Builder.the().setIndex(1).build());
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.get();
         vrpBuilder.addJob(s1).addJob(s2);
@@ -210,13 +210,13 @@ public void whenDelivieriesAreAdded_vrpShouldContainThem() {
     @Test
     public void whenDelivieriesAreAddedAllAtOnce_vrpShouldContainThem() {
         Delivery s1 = mock(Delivery.class);
-        when(s1.id).thenReturn("s1");
-        when(s1.size).thenReturn(Capacity.Builder.get().build());
-        when(s1.location).thenReturn(Location.Builder.the().setIndex(1).build());
+        when(s1.id()).thenReturn("s1");
+        when(s1.size()).thenReturn(Capacity.Builder.get().build());
+        when(s1.location()).thenReturn(Location.Builder.the().setIndex(1).build());
         Delivery s2 = mock(Delivery.class);
-        when(s2.id).thenReturn("s2");
-        when(s2.size).thenReturn(Capacity.Builder.get().build());
-        when(s2.location).thenReturn(Location.Builder.the().setIndex(1).build());
+        when(s2.id()).thenReturn("s2");
+        when(s2.size()).thenReturn(Capacity.Builder.get().build());
+        when(s2.location()).thenReturn(Location.Builder.the().setIndex(1).build());
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.get();
         vrpBuilder.addAllJobs(Arrays.asList(s1, s2));
@@ -231,11 +231,11 @@ public void whenDelivieriesAreAddedAllAtOnce_vrpShouldContainThem() {
     @Test
     public void whenServicesAreAddedAllAtOnce_vrpShouldContainThem() {
         Service s1 = mock(Service.class);
-        when(s1.id).thenReturn("s1");
-        when(s1.location).thenReturn(Location.Builder.the().setIndex(1).build());
+        when(s1.id()).thenReturn("s1");
+        when(s1.location()).thenReturn(Location.Builder.the().setIndex(1).build());
         Service s2 = mock(Service.class);
-        when(s2.id).thenReturn("s2");
-        when(s2.location).thenReturn(Location.Builder.the().setIndex(1).build());
+        when(s2.id()).thenReturn("s2");
+        when(s2.location()).thenReturn(Location.Builder.the().setIndex(1).build());
 
         Collection<Service> services = new ArrayList<Service>();
         services.add(s1);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolutionTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolutionTest.java
index 7374b6bdd..682185f80 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolutionTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolutionTest.java
@@ -34,19 +34,19 @@ public void whenCreatingSolutionWithTwoRoutes_solutionShouldContainTheseRoutes()
         VehicleRoute r1 = mock(VehicleRoute.class);
         VehicleRoute r2 = mock(VehicleRoute.class);
 
-        VehicleRoutingProblemSolution sol = new VehicleRoutingProblemSolution(Arrays.asList(r1, r2), 0.0);
+        VehicleRoutingProblemSolution sol = new VehicleRoutingProblemSolution(Set.of(r1, r2), 0.0);
         assertEquals(2, sol.routes.size());
     }
 
     @Test
     public void whenSettingSolutionCostsTo10_solutionCostsShouldBe10() {
-        VehicleRoutingProblemSolution sol = new VehicleRoutingProblemSolution(Collections.emptyList(), 10.0);
+        VehicleRoutingProblemSolution sol = new VehicleRoutingProblemSolution(new HashSet(), 10.0);
         assertEquals(10.0, sol.cost(), 0.01);
     }
 
     @Test
     public void whenCreatingSolWithCostsOf10AndSettingCostsAfterwardsTo20_solutionCostsShouldBe20() {
-        VehicleRoutingProblemSolution sol = new VehicleRoutingProblemSolution(Collections.emptyList(), 10.0);
+        VehicleRoutingProblemSolution sol = new VehicleRoutingProblemSolution(new HashSet(), 10.0);
         sol.setCost(20.0);
         assertEquals(20.0, sol.cost(), 0.01);
     }
@@ -56,7 +56,7 @@ public void sizeOfBadJobsShouldBeCorrect() {
         Job badJob = mock(Job.class);
         List<Job> badJobs = new ArrayList<Job>();
         badJobs.add(badJob);
-        VehicleRoutingProblemSolution sol = new VehicleRoutingProblemSolution(Collections.emptyList(), badJobs, 10.0);
+        VehicleRoutingProblemSolution sol = new VehicleRoutingProblemSolution(new HashSet(), badJobs, 10.0);
         assertEquals(1, sol.jobsUnassigned.size());
     }
 
@@ -65,7 +65,7 @@ public void sizeOfBadJobsShouldBeCorrect_2() {
         Job badJob = mock(Job.class);
         List<Job> badJobs = new ArrayList<Job>();
         badJobs.add(badJob);
-        VehicleRoutingProblemSolution sol = new VehicleRoutingProblemSolution(Collections.emptyList(), 10.0);
+        VehicleRoutingProblemSolution sol = new VehicleRoutingProblemSolution(new HashSet(), 10.0);
         sol.jobsUnassigned.addAll(badJobs);
         assertEquals(1, sol.jobsUnassigned.size());
     }
@@ -75,7 +75,7 @@ public void badJobsShouldBeCorrect() {
         Job badJob = mock(Job.class);
         List<Job> badJobs = new ArrayList<Job>();
         badJobs.add(badJob);
-        VehicleRoutingProblemSolution sol = new VehicleRoutingProblemSolution(Collections.emptyList(), badJobs, 10.0);
+        VehicleRoutingProblemSolution sol = new VehicleRoutingProblemSolution(new HashSet(), badJobs, 10.0);
         Assert.assertEquals(badJob, sol.jobsUnassigned.iterator().next());
     }
 
@@ -84,7 +84,7 @@ public void badJobsShouldBeCorrect_2() {
         Job badJob = mock(Job.class);
         List<Job> badJobs = new ArrayList<Job>();
         badJobs.add(badJob);
-        VehicleRoutingProblemSolution sol = new VehicleRoutingProblemSolution(Collections.emptyList(), 10.0);
+        VehicleRoutingProblemSolution sol = new VehicleRoutingProblemSolution(new HashSet(), 10.0);
         sol.jobsUnassigned.addAll(badJobs);
         Assert.assertEquals(badJob, sol.jobsUnassigned.iterator().next());
     }
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BicycleMessenger.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BicycleMessenger.java
index 2baa3449b..ab150a22c 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BicycleMessenger.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BicycleMessenger.java
@@ -41,17 +41,17 @@
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.ReverseActivityVisitor;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.ReverseActivityVisitor;
 import com.graphhopper.jsprit.core.problem.solution.route.state.RouteAndActivityStateGetter;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
 import com.graphhopper.jsprit.core.reporting.SolutionPrinter;
-import com.graphhopper.jsprit.core.util.v2;
 import com.graphhopper.jsprit.core.util.CrowFlyCosts;
 import com.graphhopper.jsprit.core.util.Solutions;
+import com.graphhopper.jsprit.core.util.v2;
 import com.graphhopper.jsprit.util.Examples;
 
 import java.io.BufferedReader;
@@ -212,7 +212,7 @@ public void begin(VehicleRoute route) {
         public void visit(AbstractActivity currAct) {
             double timeOfNearestMessenger = bestMessengers.get(((JobActivity) currAct).job().id());
             double potential_latest_arrTime_at_currAct =
-                latest_arrTime_at_prevAct - routingCosts.transportTimeReverse(currAct.location(), prevAct.location(), latest_arrTime_at_prevAct, route.driver, route.vehicle()) - currAct.operationTime();
+                    latest_arrTime_at_prevAct - routingCosts.transportTimeReverse(currAct.location(), prevAct.location(), latest_arrTime_at_prevAct, route.driver, route.vehicle()) - currAct.operationTime();
             double latest_arrTime_at_currAct = Math.min(3 * timeOfNearestMessenger, potential_latest_arrTime_at_currAct);
             stateManager.putActivityState(currAct, latest_act_arrival_time_state, latest_arrTime_at_currAct);
             assert currAct.arrTime() <= latest_arrTime_at_currAct : "this must not be since it breaks condition; actArrTime: " + currAct.arrTime() + " latestArrTime: " + latest_arrTime_at_currAct + " vehicle: " + route.vehicle().id();
@@ -266,7 +266,7 @@ public static void main(String[] args) throws IOException {
         constraintManager.addConstraint(new IgnoreMessengerThatCanNeverMeetTimeRequirements(nearestMessengers, routingCosts));
 
         VehicleRoutingAlgorithm algorithm = Jsprit.Builder.newInstance(bicycleMessengerProblem)
-            .setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
+                .setStateAndConstraintManager(stateManager, constraintManager).buildAlgorithm();
 
         algorithm.setMaxIterations(2000);
 
@@ -287,7 +287,7 @@ public static void main(String[] args) throws IOException {
 //        VariationCoefficientTermination prematureAlgorithmTermination = new VariationCoefficientTermination(200, 0.001);
 //        algorithm.setPrematureAlgorithmTermination(prematureAlgorithmTermination);
 //        algorithm.addListener(prematureAlgorithmTermination);
-        algorithm.addListener(new AlgorithmSearchProgressChartListener("output/progress.png"));
+        algorithm.addListener(new AlgorithmSearchProgressChartListener("/tmp/progress.png"));
 
         //search
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
@@ -301,22 +301,28 @@ public static void main(String[] args) throws IOException {
         Plotter plotter = new Plotter(bicycleMessengerProblem);
 //		plotter.setBoundingBox(10000, 47500, 20000, 67500);
         plotter.plotShipments(true);
-        plotter.plot("output/bicycleMessengerProblem.png", "bicycleMessenger");
+        plotter.plot("/tmp/bicycleMessengerProblem.png", "bicycleMessenger");
 
         //and the problem as well as the solution
         Plotter plotter1 = new Plotter(bicycleMessengerProblem, Solutions.bestOf(solutions));
         plotter1.setLabel(Plotter.Label.ID);
         plotter1.plotShipments(false);
 //		plotter1.setBoundingBox(5000, 45500, 25000, 66500);
-        plotter1.plot("output/bicycleMessengerSolution.png", "bicycleMessenger");
+        plotter1.plot("/tmp/bicycleMessengerSolution.png", "bicycleMessenger");
 
         //and write out your solution in xml
-//		new VrpXMLWriter(bicycleMessengerProblem, solutions).write("output/bicycleMessenger.xml");
+//		new VrpXMLWriter(bicycleMessengerProblem, solutions).write("/tmp/bicycleMessenger.xml");
 
 
-        new GraphStreamViewer(bicycleMessengerProblem).labelWith(Label.ID).setRenderShipments(true).setRenderDelay(150).display();
+        new GraphStreamViewer(bicycleMessengerProblem).labelWith(Label.ID)
+                .setGraphStreamFrameScalingFactor(10.5)
+                .setRenderShipments(true).setRenderDelay(150).display();
 //
-        new GraphStreamViewer(bicycleMessengerProblem, Solutions.bestOf(solutions)).setGraphStreamFrameScalingFactor(1.5).setCameraView(12500, 55000, 0.25).labelWith(Label.ACTIVITY).setRenderShipments(true).setRenderDelay(150).display();
+        new GraphStreamViewer(bicycleMessengerProblem, Solutions.bestOf(solutions))
+                .setRenderShipments(true)
+                .setGraphStreamFrameScalingFactor(10.5)
+                .setCameraView(12500, 55000, 0.95)
+                .labelWith(Label.ACTIVITY).setRenderShipments(true).setRenderDelay(150).display();
 
     }
 
@@ -350,11 +356,15 @@ private static void validateSolution(VehicleRoutingProblemSolution bestOf, Vehic
     static double getTimeOfDirectRoute(Job job, Vehicle v, VehicleRoutingTransportCosts routingCosts) {
         Shipment envelope = (Shipment) job;
         return routingCosts.transportTime(v.start(), envelope.getPickupLocation(), 0.0, DriverImpl.noDriver(), v) +
-            routingCosts.transportTime(envelope.getPickupLocation(), envelope.getDeliveryLocation(), 0.0, DriverImpl.noDriver(), v);
+                routingCosts.transportTime(envelope.getPickupLocation(), envelope.getDeliveryLocation(), 0.0, DriverImpl.noDriver(), v);
     }
 
+    //TODO use correct resource path
+    static final String PATH = "/home/me/jsprit/jsprit-examples/input/";
+
     private static void readEnvelopes(Builder problemBuilder) throws IOException {
-        BufferedReader reader = new BufferedReader(new FileReader(new File("input/bicycle_messenger_demand.txt")));
+        BufferedReader reader = new BufferedReader(new FileReader(
+                new File(PATH + "bicycle_messenger_demand.txt")));
         String line;
         boolean firstLine = true;
         while ((line = reader.readLine()) != null) {
@@ -365,24 +375,25 @@ private static void readEnvelopes(Builder problemBuilder) throws IOException {
             String[] tokens = line.split("\\s+");
             //define your envelope which is basically a shipment from A to B
             Shipment envelope = Shipment.Builder.newInstance(tokens[1]).addSizeDimension(0, 1)
-                .setPickupLocation(Location.Builder.the().setCoord(v2.the(Double.parseDouble(tokens[2]), Double.parseDouble(tokens[3]))).build())
-                .setDeliveryLocation(Location.Builder.the().setCoord(v2.the(Double.parseDouble(tokens[4]), Double.parseDouble(tokens[5]))).build()).build();
+                    .setPickupLocation(Location.Builder.the().setCoord(v2.the(Double.parseDouble(tokens[2]), Double.parseDouble(tokens[3]))).build())
+                    .setDeliveryLocation(Location.Builder.the().setCoord(v2.the(Double.parseDouble(tokens[4]), Double.parseDouble(tokens[5]))).build()).build();
             problemBuilder.addJob(envelope);
         }
         reader.close();
     }
 
     private static void readMessengers(Builder problemBuilder) throws IOException {
-        BufferedReader reader = new BufferedReader(new FileReader(new File("input/bicycle_messenger_supply.txt")));
+        BufferedReader reader = new BufferedReader(new FileReader(new File(
+                PATH + "bicycle_messenger_supply.txt")));
         String line;
         boolean firstLine = true;
         VehicleType messengerType = VehicleTypeImpl.Builder.the("messengerType").addCapacityDimension(0, 15).setCostPerDistance(1).build();
         /*
          * the algo requires some time and space to search for a valid solution. if you ommit a penalty-type, it probably throws an Exception once it cannot insert an envelope anymore
-		 * thus, give it space by defining a penalty/shadow vehicle with higher variable and fixed costs to up the pressure to find solutions without penalty type
-		 *
-		 * it is important to give it the same typeId as the type you want to shadow
-		 */
+         * thus, give it space by defining a penalty/shadow vehicle with higher variable and fixed costs to up the pressure to find solutions without penalty type
+         *
+         * it is important to give it the same typeId as the type you want to shadow
+         */
         while ((line = reader.readLine()) != null) {
             if (firstLine) {
                 firstLine = false;
@@ -391,8 +402,8 @@ private static void readMessengers(Builder problemBuilder) throws IOException {
             String[] tokens = line.split("\\s+");
             //build your vehicle
             VehicleImpl vehicle = VehicleImpl.Builder.newInstance(tokens[1])
-                .setStartLocation(Location.Builder.the().setCoord(v2.the(Double.parseDouble(tokens[2]), Double.parseDouble(tokens[3]))).build())
-                .setReturnToDepot(false).setType(messengerType).build();
+                    .setStartLocation(Location.Builder.the().setCoord(v2.the(Double.parseDouble(tokens[2]), Double.parseDouble(tokens[3]))).build())
+                    .setReturnToDepot(false).setType(messengerType).build();
             problemBuilder.addVehicle(vehicle);
         }
         reader.close();
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/EnRoutePickupAndDeliveryWithMultipleDepotsAndOpenRoutesExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/EnRoutePickupAndDeliveryWithMultipleDepotsAndOpenRoutesExample.java
index f06e53365..6f8dcf8b4 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/EnRoutePickupAndDeliveryWithMultipleDepotsAndOpenRoutesExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/EnRoutePickupAndDeliveryWithMultipleDepotsAndOpenRoutesExample.java
@@ -160,7 +160,9 @@ public static void main(String[] args) {
         solutionPlotter.plotShipments(true);
         solutionPlotter.plot("output/enRoutePickupAndDeliveryWithMultipleLocationsExample_solution.png", "en-route pickup and delivery");
 
-        new GraphStreamViewer(problem, Solutions.bestOf(solutions)).labelWith(Label.ACTIVITY).setRenderDelay(100).setRenderShipments(true).display();
+        new GraphStreamViewer(problem, Solutions.bestOf(solutions)).labelWith(Label.ACTIVITY)
+                .setGraphStreamFrameScalingFactor(4)
+                .setRenderDelay(100).setRenderShipments(true).display();
 
     }
 
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExampleWithPriorities.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExampleWithPriorities.java
index b65b4ca63..83e5ad186 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExampleWithPriorities.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExampleWithPriorities.java
@@ -98,7 +98,7 @@ public static void main(String[] args) {
 		 */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
-        new VrpXMLWriter(problem, solutions).write("output/problem-with-solution.xml");
+        new VrpXMLWriter(problem, solutions).write("/tmp/problem-with-solution.xml");
 
         SolutionPrinter.print(problem, bestSolution, SolutionPrinter.Print.VERBOSE);
 
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/util/Examples.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/util/Examples.java
index c93d57315..a2732abd1 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/util/Examples.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/util/Examples.java
@@ -18,17 +18,20 @@
 package com.graphhopper.jsprit.util;
 
 import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
 
 public class Examples {
 
     public static void createOutputFolder() {
-        File dir = new File("output");
-        // if the directory does not exist, create it
-        if (!dir.exists()) {
-            System.out.println("creating directory ./output");
-            boolean result = dir.mkdir();
-            if (result) System.out.println("./output created");
+        File dir = null; //File("output");
+        try {
+            dir = Files.createTempDirectory("jtrips").toFile();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
         }
+        // if the directory does not exist, create it
+        System.err.println("temporary " + dir + " created");
     }
 
 }
diff --git a/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/VrpXMLWriterTest.java b/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/VrpXMLWriterTest.java
index 1d68d1af1..850615a3e 100644
--- a/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/VrpXMLWriterTest.java
+++ b/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/VrpXMLWriterTest.java
@@ -38,6 +38,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
+import java.util.Set;
 
 import static org.junit.Assert.*;
 
@@ -552,9 +553,8 @@ public void solutionWithoutUnassignedJobsShouldBeWrittenCorrectly() {
         VehicleRoutingProblem vrp = builder.addJob(s1).addJob(s2).build();
 
         VehicleRoute route = VehicleRoute.Builder.newInstance(v1).addService(s1).addService(s2).build();
-        List<VehicleRoute> routes = new ArrayList<VehicleRoute>();
-        routes.add(route);
-        VehicleRoutingProblemSolution solution = new VehicleRoutingProblemSolution(routes, 10.);
+
+        VehicleRoutingProblemSolution solution = new VehicleRoutingProblemSolution(Set.of(route), 10.);
         List<VehicleRoutingProblemSolution> solutions = new ArrayList<VehicleRoutingProblemSolution>();
         solutions.add(solution);
 
@@ -579,12 +579,10 @@ public void solutionWithUnassignedJobsShouldBeWrittenCorrectly() {
         VehicleRoutingProblem vrp = builder.addJob(s1).addJob(s2).build();
 
         VehicleRoute route = VehicleRoute.Builder.newInstance(v1).addService(s1).build();
-        List<VehicleRoute> routes = new ArrayList<VehicleRoute>();
-        routes.add(route);
-        VehicleRoutingProblemSolution solution = new VehicleRoutingProblemSolution(routes, 10.);
+
+        VehicleRoutingProblemSolution solution = new VehicleRoutingProblemSolution(Set.of(route), 10.);
         solution.jobsUnassigned.add(s2);
-        List<VehicleRoutingProblemSolution> solutions = new ArrayList<VehicleRoutingProblemSolution>();
-        solutions.add(solution);
+        List<VehicleRoutingProblemSolution> solutions = List.of(solution);
 
         List<VehicleRoutingProblemSolution> solutionsToRead = writeAndRereadXmlWithSolutions(vrp, solutions);
 
