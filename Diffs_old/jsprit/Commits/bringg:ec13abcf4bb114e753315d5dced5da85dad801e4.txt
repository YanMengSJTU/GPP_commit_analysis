diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AbstractInsertionStrategy.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AbstractInsertionStrategy.java
index 0d9d4fa2a..35f36815e 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AbstractInsertionStrategy.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AbstractInsertionStrategy.java
@@ -75,15 +75,9 @@ public InsertionData getInsertionData() {
 
     protected VehicleRoutingProblem vrp;
 
-    protected double minVehicleCost = Double.POSITIVE_INFINITY;
-
     public AbstractInsertionStrategy(VehicleRoutingProblem vrp) {
         this.insertionsListeners = new InsertionListeners();
         this.vrp = vrp;
-        for (Vehicle vehicle : vrp.getVehicles()) {
-            minVehicleCost = Math.min(vehicle.getType().getVehicleCostParams().fix, minVehicleCost);
-        }
-
         eventListeners = new EventListeners();
     }
 
@@ -133,4 +127,9 @@ protected void insertJob(Job unassignedJob, InsertionData iData, VehicleRoute in
         insertionsListeners.informJobInserted(unassignedJob, inRoute, iData.getInsertionCost(), iData.getAdditionalTime());
     }
 
+    protected static void updateNewRouteInsertionData(InsertionData iData) {
+        if (iData.getSelectedVehicle() != null)
+            iData.setInsertionCost(iData.getInsertionCost() + iData.getSelectedVehicle().getType().getVehicleCostParams().fix);
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertion.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertion.java
index 9b6d7f130..e34474d18 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertion.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertion.java
@@ -63,8 +63,8 @@ public String toString() {
 
     @Override
     public Collection<Job> insertUnassignedJobs(Collection<VehicleRoute> vehicleRoutes, Collection<Job> unassignedJobs) {
-        List<Job> badJobs = new ArrayList<Job>(unassignedJobs.size());
-        List<Job> unassignedJobList = new ArrayList<Job>(unassignedJobs);
+        List<Job> badJobs = new ArrayList<>(unassignedJobs.size());
+        List<Job> unassignedJobList = new ArrayList<>(unassignedJobs);
         Collections.shuffle(unassignedJobList, random);
         Collections.sort(unassignedJobList, new AccordingToPriorities());
         for (Job unassignedJob : unassignedJobList) {
@@ -85,7 +85,7 @@ public String toString() {
             VehicleRoute newRoute = VehicleRoute.emptyRoute();
             InsertionData newIData = bestInsertionCostCalculator.getInsertionData(newRoute, unassignedJob, NO_NEW_VEHICLE_YET, NO_NEW_DEPARTURE_TIME_YET, NO_NEW_DRIVER_YET, bestInsertionCost);
             if (!(newIData instanceof InsertionData.NoInsertionFound)) {
-                newIData.setInsertionCost(newIData.getInsertionCost() + minVehicleCost);
+                updateNewRouteInsertionData(newIData);
                 if (newIData.getInsertionCost() < bestInsertionCost + noiseMaker.makeNoise()) {
                     bestInsertion = new Insertion(newRoute, newIData);
                     vehicleRoutes.add(newRoute);
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertionConcurrent.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertionConcurrent.java
index bd299f12a..ffb7ae92d 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertionConcurrent.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertionConcurrent.java
@@ -138,7 +138,7 @@ public Insertion call() throws Exception {
             }
             VehicleRoute newRoute = VehicleRoute.emptyRoute();
             InsertionData newIData = bestInsertionCostCalculator.getInsertionData(newRoute, unassignedJob, NO_NEW_VEHICLE_YET, NO_NEW_DEPARTURE_TIME_YET, NO_NEW_DRIVER_YET, bestInsertionCost);
-            newIData.setInsertionCost(newIData.getInsertionCost() + minVehicleCost);
+            updateNewRouteInsertionData(newIData);
             if (newIData.getInsertionCost() < bestInsertionCost) {
                 bestInsertion = new Insertion(newRoute, newIData);
                 vehicleRoutes.add(newRoute);
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertion.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertion.java
index 665131619..1470676d7 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertion.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertion.java
@@ -137,7 +137,7 @@ private VehicleRoute findRoute(Collection<VehicleRoute> routes, Job job) {
     private ScoredJob nextJob(Collection<VehicleRoute> routes, Collection<Job> unassignedJobList, List<ScoredJob> badJobs) {
         ScoredJob bestScoredJob = null;
         for (Job unassignedJob : unassignedJobList) {
-            ScoredJob scoredJob = getScoredJob(routes, unassignedJob, insertionCostsCalculator, scoringFunction, minVehicleCost);
+            ScoredJob scoredJob = getScoredJob(routes, unassignedJob, insertionCostsCalculator, scoringFunction);
             if (scoredJob instanceof ScoredJob.BadJob) {
                 badJobs.add(scoredJob);
                 continue;
@@ -156,7 +156,7 @@ private ScoredJob nextJob(Collection<VehicleRoute> routes, Collection<Job> unass
         return bestScoredJob;
     }
 
-    static ScoredJob getScoredJob(Collection<VehicleRoute> routes, Job unassignedJob, JobInsertionCostsCalculator insertionCostsCalculator, ScoringFunction scoringFunction, double newVehicleCost) {
+    static ScoredJob getScoredJob(Collection<VehicleRoute> routes, Job unassignedJob, JobInsertionCostsCalculator insertionCostsCalculator, ScoringFunction scoringFunction) {
         InsertionData best = null;
         InsertionData secondBest = null;
         VehicleRoute bestRoute = null;
@@ -186,7 +186,7 @@ static ScoredJob getScoredJob(Collection<VehicleRoute> routes, Job unassignedJob
         VehicleRoute emptyRoute = VehicleRoute.emptyRoute();
         InsertionData iData = insertionCostsCalculator.getInsertionData(emptyRoute, unassignedJob, NO_NEW_VEHICLE_YET, NO_NEW_DEPARTURE_TIME_YET, NO_NEW_DRIVER_YET, benchmark);
         if (!(iData instanceof InsertionData.NoInsertionFound)) {
-            iData.setInsertionCost(iData.getInsertionCost() + newVehicleCost);
+            updateNewRouteInsertionData(iData);
             if (best == null) {
                 best = iData;
                 bestRoute = emptyRoute;
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionConcurrent.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionConcurrent.java
index eac42f466..b71ac5ab7 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionConcurrent.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionConcurrent.java
@@ -139,7 +139,7 @@ private ScoredJob nextJob(final Collection<VehicleRoute> routes, List<Job> unass
 
                 @Override
                 public ScoredJob call() throws Exception {
-                    return RegretInsertion.getScoredJob(routes, unassignedJob, insertionCostsCalculator, scoringFunction, minVehicleCost);
+                    return RegretInsertion.getScoredJob(routes, unassignedJob, insertionCostsCalculator, scoringFunction);
                 }
 
             });
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/AbstractInsertionStrategyTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/AbstractInsertionStrategyTest.java
new file mode 100644
index 000000000..7f4aa87f5
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/AbstractInsertionStrategyTest.java
@@ -0,0 +1,58 @@
+package com.graphhopper.jsprit.core.algorithm.recreate;
+
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
+import org.junit.Test;
+
+import java.util.Random;
+import java.util.UUID;
+
+import static org.junit.Assert.assertEquals;
+
+public class AbstractInsertionStrategyTest {
+    Random random = new Random();
+
+    @Test
+    public void updateNewRouteInsertionDataNoInsertion() {
+        InsertionData iData = new InsertionData.NoInsertionFound();
+        AbstractInsertionStrategy.updateNewRouteInsertionData(iData);
+        assertEquals(iData.getInsertionCost(), Double.MAX_VALUE, .001);
+    }
+
+    @Test
+    public void updateNewRouteInsertionDataNewInsertionNoVehicle() {
+        double insertionCost = random.nextDouble();
+        Vehicle vehicle = new VehicleImpl.NoVehicle();
+        InsertionData iData = new InsertionData(insertionCost, -1, -1, vehicle, null);
+        AbstractInsertionStrategy.updateNewRouteInsertionData(iData);
+        assertEquals(iData.getInsertionCost(), insertionCost, .001);
+    }
+
+    @Test
+    public void updateNewRouteInsertionDataNewInsertionVehicleWithFixedCost() {
+        double insertionCost = random.nextDouble();
+        double fixedCost = random.nextDouble();
+        Vehicle vehicle = VehicleImpl.Builder.newInstance(UUID.randomUUID().toString())
+            .setType(VehicleTypeImpl.Builder.newInstance(UUID.randomUUID().toString()).setFixedCost(fixedCost).build())
+            .setStartLocation(Location.newInstance(random.nextDouble(), random.nextDouble()))
+            .build();
+
+        InsertionData iData = new InsertionData(insertionCost, -1, -1, vehicle, null);
+        AbstractInsertionStrategy.updateNewRouteInsertionData(iData);
+        assertEquals(iData.getInsertionCost(), insertionCost + fixedCost, .001);
+    }
+
+    @Test
+    public void updateNewRouteInsertionDataNewInsertionVehicleWithoutType() {
+        double insertionCost = random.nextDouble();
+        Vehicle vehicle = VehicleImpl.Builder.newInstance(UUID.randomUUID().toString())
+            .setStartLocation(Location.newInstance(random.nextDouble(), random.nextDouble()))
+            .build();
+
+        InsertionData iData = new InsertionData(insertionCost, -1, -1, vehicle, null);
+        AbstractInsertionStrategy.updateNewRouteInsertionData(iData);
+        assertEquals(iData.getInsertionCost(), insertionCost, .001);
+    }
+}
