diff --git a/.travis.settings.xml b/.travis.settings.xml
index fd37913ec..dfeeeb093 100644
--- a/.travis.settings.xml
+++ b/.travis.settings.xml
@@ -16,7 +16,7 @@
   ~ limitations under the License.
   -->
 
-<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<settings xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/SETTINGS/1.0.0"
           xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">
     <servers>
         <server>
diff --git a/jsprit-analysis/pom.xml b/jsprit-analysis/pom.xml
index e4dd3e4b7..1a9651064 100644
--- a/jsprit-analysis/pom.xml
+++ b/jsprit-analysis/pom.xml
@@ -16,7 +16,8 @@
   ~ limitations under the License.
   -->
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>jsprit</artifactId>
diff --git a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsRecorder.java b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsRecorder.java
index 441026240..910248112 100644
--- a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsRecorder.java
+++ b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsRecorder.java
@@ -56,17 +56,11 @@
  */
 public class AlgorithmEventsRecorder implements RuinListener, IterationStartsListener, InsertionStartsListener, BeforeJobInsertionListener, InsertionEndsListener, AlgorithmEndsListener {
 
-    private boolean renderShipments = false;
-
     public static final int BEFORE_RUIN_RENDER_SOLUTION = 2;
-
     public static final int RUIN = 0;
-
     public static final int RECREATE = 1;
-
     public static final int CLEAR_SOLUTION = 3;
-
-
+    private boolean renderShipments = false;
     private Graph graph;
 
     private FileSinkDGS fileSink;
@@ -103,6 +97,94 @@ public AlgorithmEventsRecorder(VehicleRoutingProblem vrp, String dgsFileLocation
         initialiseGraph(vrp);
     }
 
+    private void initialiseGraph(VehicleRoutingProblem problem) {
+        for (Vehicle vehicle : problem.getVehicles()) {
+            addVehicle(vehicle);
+        }
+        for (Job job : problem.getJobs().values()) {
+            addJob(job);
+        }
+    }
+
+    private void addVehicle(Vehicle vehicle) {
+        String startId = makeStartId(vehicle);
+        Node node = graph.addNode(startId);
+        node.addAttribute("x", vehicle.getStartLocation().getCoordinate().getX());
+        node.addAttribute("y", vehicle.getStartLocation().getCoordinate().getY());
+        node.addAttribute("ui.class", "depot");
+
+        String endId = makeEndId(vehicle);
+        if (!startId.equals(endId)) {
+            Node endNode = graph.addNode(endId);
+            endNode.addAttribute("x", vehicle.getEndLocation().getCoordinate().getX());
+            endNode.addAttribute("y", vehicle.getEndLocation().getCoordinate().getY());
+            endNode.addAttribute("ui.class", "depot");
+        }
+    }
+
+    private void addJob(Job job) {
+        if (job instanceof Service) {
+            Service service = (Service) job;
+            addNode(service.getId(), service.getLocation().getCoordinate());
+            markService(service);
+        } else if (job instanceof Shipment) {
+            Shipment shipment = (Shipment) job;
+            String fromNodeId = getFromNodeId(shipment);
+            addNode(fromNodeId, shipment.getPickupLocation().getCoordinate());
+            String toNodeId = getToNodeId(shipment);
+            addNode(toNodeId, shipment.getDeliveryLocation().getCoordinate());
+            markShipment(shipment);
+            if (renderShipments) {
+                Edge e = graph.addEdge("shipment_" + fromNodeId + "_" + toNodeId, fromNodeId, toNodeId, true);
+                e.addAttribute("ui.class", "shipment");
+            }
+        }
+    }
+
+    private String makeStartId(Vehicle vehicle) {
+        return vehicle.getId() + "_start";
+    }
+
+    private String makeEndId(Vehicle vehicle) {
+        if (vehicle.getStartLocation().getId().equals(vehicle.getEndLocation().getId())) return makeStartId(vehicle);
+        return vehicle.getId() + "_end";
+    }
+
+    private void addNode(String nodeId, Coordinate nodeCoord) {
+        Node node = graph.addNode(nodeId);
+        node.addAttribute("x", nodeCoord.getX());
+        node.addAttribute("y", nodeCoord.getY());
+    }
+
+    private void markService(Service service) {
+        if (service instanceof Delivery) {
+            markDelivery(service.getId());
+        } else {
+            markPickup(service.getId());
+        }
+    }
+
+    private String getFromNodeId(Shipment shipment) {
+        return shipment.getId() + "_pickup";
+    }
+
+    private String getToNodeId(Shipment shipment) {
+        return shipment.getId() + "_delivery";
+    }
+
+    private void markShipment(Shipment shipment) {
+        markPickup(getFromNodeId(shipment));
+        markDelivery(getToNodeId(shipment));
+    }
+
+    private void markDelivery(String id) {
+        graph.getNode(id).addAttribute("ui.class", "delivery");
+    }
+
+    private void markPickup(String id) {
+        graph.getNode(id).addAttribute("ui.class", "pickup");
+    }
+
     public void setRecordingRange(int startIteration, int endIteration) {
         this.start_recording_at = startIteration;
         this.end_recording_at = endIteration;
@@ -117,6 +199,10 @@ public void ruinStarts(Collection<VehicleRoute> routes) {
         fileSink.stepBegins(graph.getId(), 0, RUIN);
     }
 
+    private boolean record() {
+        return currentIteration >= start_recording_at && currentIteration <= end_recording_at;
+    }
+
     private void markAllNodesAsInserted() {
         for (Job j : vrp.getJobs().values()) {
             markInserted(j);
@@ -139,6 +225,14 @@ private void addRoutes(Collection<VehicleRoute> routes) {
         }
     }
 
+    private void markInserted(Job job) {
+        if (job instanceof Service) {
+            markService((Service) job);
+        } else {
+            markShipment((Shipment) job);
+        }
+    }
+
     private String getNodeId(TourActivity act) {
         String nodeId = null;
         if (act instanceof TourActivity.JobActivity) {
@@ -153,8 +247,14 @@ private String getNodeId(TourActivity act) {
         return nodeId;
     }
 
-    private boolean record() {
-        return currentIteration >= start_recording_at && currentIteration <= end_recording_at;
+    private void addEdge(String edgeId, String fromNode, String toNode) {
+        graph.addEdge(edgeId, fromNode, toNode, true);
+        markEdgeInserted(edgeId);
+    }
+
+    private void markEdgeInserted(String edgeId) {
+        graph.getEdge(edgeId).addAttribute("ui.class", "inserted");
+        graph.getEdge(edgeId).removeAttribute("ui.class");
     }
 
     @Override
@@ -231,14 +331,6 @@ private Edge getEnteringEdge(String toNodeId) {
         return null;
     }
 
-    private String getToNodeId(Shipment shipment) {
-        return shipment.getId() + "_delivery";
-    }
-
-    private String getFromNodeId(Shipment shipment) {
-        return shipment.getId() + "_pickup";
-    }
-
     private void removeService(Job job, VehicleRoute fromRoute) {
         String nodeId = job.getId();
         removeNodeAndBelongingEdges(nodeId, fromRoute);
@@ -295,86 +387,6 @@ public void informIterationStarts(int i, VehicleRoutingProblem problem, Collecti
         currentIteration = i;
     }
 
-    private void initialiseGraph(VehicleRoutingProblem problem) {
-        for (Vehicle vehicle : problem.getVehicles()) {
-            addVehicle(vehicle);
-        }
-        for (Job job : problem.getJobs().values()) {
-            addJob(job);
-        }
-    }
-
-    private void addJob(Job job) {
-        if (job instanceof Service) {
-            Service service = (Service) job;
-            addNode(service.getId(), service.getLocation().getCoordinate());
-            markService(service);
-        } else if (job instanceof Shipment) {
-            Shipment shipment = (Shipment) job;
-            String fromNodeId = getFromNodeId(shipment);
-            addNode(fromNodeId, shipment.getPickupLocation().getCoordinate());
-            String toNodeId = getToNodeId(shipment);
-            addNode(toNodeId, shipment.getDeliveryLocation().getCoordinate());
-            markShipment(shipment);
-            if (renderShipments) {
-                Edge e = graph.addEdge("shipment_" + fromNodeId + "_" + toNodeId, fromNodeId, toNodeId, true);
-                e.addAttribute("ui.class", "shipment");
-            }
-        }
-    }
-
-    private void markShipment(Shipment shipment) {
-        markPickup(getFromNodeId(shipment));
-        markDelivery(getToNodeId(shipment));
-    }
-
-    private void markService(Service service) {
-        if (service instanceof Delivery) {
-            markDelivery(service.getId());
-        } else {
-            markPickup(service.getId());
-        }
-    }
-
-    private void markPickup(String id) {
-        graph.getNode(id).addAttribute("ui.class", "pickup");
-    }
-
-    private void markDelivery(String id) {
-        graph.getNode(id).addAttribute("ui.class", "delivery");
-    }
-
-    private void addVehicle(Vehicle vehicle) {
-        String startId = makeStartId(vehicle);
-        Node node = graph.addNode(startId);
-        node.addAttribute("x", vehicle.getStartLocation().getCoordinate().getX());
-        node.addAttribute("y", vehicle.getStartLocation().getCoordinate().getY());
-        node.addAttribute("ui.class", "depot");
-
-        String endId = makeEndId(vehicle);
-        if (!startId.equals(endId)) {
-            Node endNode = graph.addNode(endId);
-            endNode.addAttribute("x", vehicle.getEndLocation().getCoordinate().getX());
-            endNode.addAttribute("y", vehicle.getEndLocation().getCoordinate().getY());
-            endNode.addAttribute("ui.class", "depot");
-        }
-    }
-
-    private String makeStartId(Vehicle vehicle) {
-        return vehicle.getId() + "_start";
-    }
-
-    private String makeEndId(Vehicle vehicle) {
-        if (vehicle.getStartLocation().getId().equals(vehicle.getEndLocation().getId())) return makeStartId(vehicle);
-        return vehicle.getId() + "_end";
-    }
-
-    private void addNode(String nodeId, Coordinate nodeCoord) {
-        Node node = graph.addNode(nodeId);
-        node.addAttribute("x", nodeCoord.getX());
-        node.addAttribute("y", nodeCoord.getY());
-    }
-
     @Override
     public void informInsertionEnds(Collection<VehicleRoute> vehicleRoutes) {
         if (!record()) return;
@@ -397,6 +409,15 @@ private void removeRoutes(Collection<VehicleRoute> vehicleRoutes) {
         }
     }
 
+    private void removeEdge(String edgeId) {
+        markEdgeRemoved(edgeId);
+        graph.removeEdge(edgeId);
+    }
+
+    private void markEdgeRemoved(String edgeId) {
+        graph.getEdge(edgeId).addAttribute("ui.class", "removed");
+    }
+
     @Override
     public void informBeforeJobInsertion(Job job, InsertionData data, VehicleRoute route) {
         if (!record()) return;
@@ -485,23 +506,6 @@ private void handleVehicleSwitch(InsertionData data, VehicleRoute route) {
         }
     }
 
-    private void markInserted(Job job) {
-        if (job instanceof Service) {
-            markService((Service) job);
-        } else {
-            markShipment((Shipment) job);
-        }
-    }
-
-    private void removeEdge(String edgeId) {
-        markEdgeRemoved(edgeId);
-        graph.removeEdge(edgeId);
-    }
-
-    private void markEdgeRemoved(String edgeId) {
-        graph.getEdge(edgeId).addAttribute("ui.class", "removed");
-    }
-
     private boolean isFirst(int index) {
         return index == 0;
     }
@@ -510,16 +514,6 @@ private boolean isLast(int index, VehicleRoute route) {
         return index == route.getActivities().size();
     }
 
-    private void addEdge(String edgeId, String fromNode, String toNode) {
-        graph.addEdge(edgeId, fromNode, toNode, true);
-        markEdgeInserted(edgeId);
-    }
-
-    private void markEdgeInserted(String edgeId) {
-        graph.getEdge(edgeId).addAttribute("ui.class", "inserted");
-        graph.getEdge(edgeId).removeAttribute("ui.class");
-    }
-
     @Override
     public void informInsertionStarts(Collection<VehicleRoute> vehicleRoutes, Collection<Job> unassignedJobs) {
         if (!record()) return;
diff --git a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsViewer.java b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsViewer.java
index 2bc87c97b..4bbc0b302 100644
--- a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsViewer.java
+++ b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsViewer.java
@@ -28,6 +28,70 @@
 
 public class AlgorithmEventsViewer {
 
+    private double zoomFactor;
+    private double scaling = 1.0;
+    private long delayRecreation = 5;
+    private long delayRuin = 5;
+    private long delay = 2;
+
+    public static void main(String[] args) throws IOException {
+        AlgorithmEventsViewer viewer = new AlgorithmEventsViewer();
+        viewer.setRuinDelay(10);
+        viewer.setRecreationDelay(5);
+        viewer.display("output/events.dgs.gz");
+    }
+
+    public void setRuinDelay(long delay_in_ms) {
+        this.delayRuin = delay_in_ms;
+    }
+
+    public void setRecreationDelay(long delay_in_ms) {
+        this.delayRecreation = delay_in_ms;
+    }
+
+    public void display(String dgsFile) {
+        System.setProperty("org.graphstream.ui.renderer", "org.graphstream.ui.j2dviewer.J2DGraphRenderer");
+        Graph graph = GraphStreamViewer.createMultiGraph("g", GraphStreamViewer.StyleSheets.BLUE_FOREST);
+        Viewer viewer = graph.display();
+        viewer.disableAutoLayout();
+
+        FileSource fs = new FileSourceDGS();
+        fs.addSink(graph);
+
+        DelayContainer delayContainer = new DelayContainer();
+        DelaySink delaySink = new DelaySink(delayContainer);
+        delaySink.setDelay(delay);
+        delaySink.setRecreateDelay(delayRecreation);
+        delaySink.setRuinDelay(delayRuin);
+        fs.addSink(delaySink);
+
+        try {
+            fs.begin(dgsFile);
+            while (fs.nextEvents()) {
+                sleep(delayContainer.delay);
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        try {
+            fs.end();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+            fs.removeSink(graph);
+        }
+    }
+
+    private static void sleep(long renderDelay_in_ms2) {
+        try {
+            Thread.sleep(renderDelay_in_ms2);
+        } catch (InterruptedException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+    }
+
     private static class DelayContainer {
 
         long delay = 0;
@@ -145,72 +209,4 @@ public void stepBegins(String sourceId, long timeId, double step) {
         }
     }
 
-    private double zoomFactor;
-
-    private double scaling = 1.0;
-
-    private long delayRecreation = 5;
-
-    private long delayRuin = 5;
-
-    private long delay = 2;
-
-    public void setRecreationDelay(long delay_in_ms) {
-        this.delayRecreation = delay_in_ms;
-    }
-
-    public void setRuinDelay(long delay_in_ms) {
-        this.delayRuin = delay_in_ms;
-    }
-
-    public void display(String dgsFile) {
-        System.setProperty("org.graphstream.ui.renderer", "org.graphstream.ui.j2dviewer.J2DGraphRenderer");
-        Graph graph = GraphStreamViewer.createMultiGraph("g", GraphStreamViewer.StyleSheets.BLUE_FOREST);
-        Viewer viewer = graph.display();
-        viewer.disableAutoLayout();
-
-        FileSource fs = new FileSourceDGS();
-        fs.addSink(graph);
-
-        DelayContainer delayContainer = new DelayContainer();
-        DelaySink delaySink = new DelaySink(delayContainer);
-        delaySink.setDelay(delay);
-        delaySink.setRecreateDelay(delayRecreation);
-        delaySink.setRuinDelay(delayRuin);
-        fs.addSink(delaySink);
-
-        try {
-            fs.begin(dgsFile);
-            while (fs.nextEvents()) {
-                sleep(delayContainer.delay);
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-
-        try {
-            fs.end();
-        } catch (IOException e) {
-            e.printStackTrace();
-        } finally {
-            fs.removeSink(graph);
-        }
-    }
-
-    public static void main(String[] args) throws IOException {
-        AlgorithmEventsViewer viewer = new AlgorithmEventsViewer();
-        viewer.setRuinDelay(10);
-        viewer.setRecreationDelay(5);
-        viewer.display("output/events.dgs.gz");
-    }
-
-    private static void sleep(long renderDelay_in_ms2) {
-        try {
-            Thread.sleep(renderDelay_in_ms2);
-        } catch (InterruptedException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        }
-    }
-
 }
diff --git a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/GraphStreamViewer.java b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/GraphStreamViewer.java
index e04097f3c..9842e1886 100644
--- a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/GraphStreamViewer.java
+++ b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/GraphStreamViewer.java
@@ -44,146 +44,6 @@
 
 public class GraphStreamViewer {
 
-    public static class StyleSheets {
-
-        public static String BLUE_FOREST =
-            "graph { fill-color: #141F2E; }" +
-                "node {" +
-                "	size: 7px, 7px;" +
-                "   fill-color: #A0FFA0;" +
-                "	text-alignment: at-right;" +
-                " 	stroke-mode: plain;" +
-                "	stroke-color: #999;" +
-                "	stroke-width: 1.0;" +
-                "	text-font: couriernew;" +
-                " 	text-offset: 2,-5;" +
-                "	text-size: 8;" +
-                "}" +
-                "node.pickup {" +
-                " 	fill-color: #6CC644;" +
-                "}" +
-                "node.delivery {" +
-                " 	fill-color: #f93;" +
-                "}" +
-                "node.pickupInRoute {" +
-                "	fill-color: #6CC644;" +
-                " 	stroke-mode: plain;" +
-                "	stroke-color: #333;" +
-                "   stroke-width: 2.0;" +
-                "}" +
-                "node.deliveryInRoute {" +
-                " 	fill-color: #f93;" +
-                " 	stroke-mode: plain;" +
-                "	stroke-color: #333;" +
-                "   stroke-width: 2.0;" +
-                "}" +
-                "node.depot {" +
-                " 	fill-color: #BD2C00;" +
-                "	size: 10px, 10px;" +
-                " 	shape: box;" +
-                "}" +
-                "node.removed {" +
-                " 	fill-color: #FF8080;" +
-                "	size: 10px, 10px;" +
-                " 	stroke-mode: plain;" +
-                "	stroke-color: #CCF;" +
-                "   stroke-width: 2.0;" +
-                "   shadow-mode: gradient-radial;" +
-                "   shadow-width: 10px; shadow-color: #EEF, #000; shadow-offset: 0px;" +
-                "}" +
-
-                "edge {" +
-                "	fill-color: #D3D3D3;" +
-                "	arrow-size: 6px,3px;" +
-                "}" +
-//                    "edge.inserted {" +
-//                    "	fill-color: #A0FFA0;" +
-//                    "	arrow-size: 6px,3px;" +
-//                    "   shadow-mode: gradient-radial;" +
-//                    "   shadow-width: 10px; shadow-color: #EEF, #000; shadow-offset: 0px;" +
-//                    "}" +
-//                    "edge.removed {" +
-//                    "	fill-color: #FF0000;" +
-//                    "	arrow-size: 6px,3px;" +
-//                    "   shadow-mode: gradient-radial;" +
-//                    "   shadow-width: 10px; shadow-color: #EEF, #000; shadow-offset: 0px;" +
-//                    "}" +
-                "edge.shipment {" +
-                "	fill-color: #999;" +
-                "	arrow-size: 6px,3px;" +
-                "}";
-
-
-        @SuppressWarnings("UnusedDeclaration")
-        public static String SIMPLE_WHITE =
-            "node {" +
-                "	size: 10px, 10px;" +
-                "   fill-color: #6CC644;" +
-                "	text-alignment: at-right;" +
-                " 	stroke-mode: plain;" +
-                "	stroke-color: #999;" +
-                "	stroke-width: 1.0;" +
-                "	text-font: couriernew;" +
-                " 	text-offset: 2,-5;" +
-                "	text-size: 8;" +
-                "}" +
-                "node.pickup {" +
-                " 	fill-color: #6CC644;" +
-                "}" +
-                "node.delivery {" +
-                " 	fill-color: #f93;" +
-                "}" +
-                "node.pickupInRoute {" +
-                "	fill-color: #6CC644;" +
-                " 	stroke-mode: plain;" +
-                "	stroke-color: #333;" +
-                "   stroke-width: 2.0;" +
-                "}" +
-                "node.deliveryInRoute {" +
-                " 	fill-color: #f93;" +
-                " 	stroke-mode: plain;" +
-                "	stroke-color: #333;" +
-                "   stroke-width: 2.0;" +
-                "}" +
-                "node.depot {" +
-                " 	fill-color: #BD2C00;" +
-                "	size: 10px, 10px;" +
-                " 	shape: box;" +
-                "}" +
-                "node.removed {" +
-                " 	fill-color: #BD2C00;" +
-                "	size: 10px, 10px;" +
-                " 	stroke-mode: plain;" +
-                "	stroke-color: #333;" +
-                "   stroke-width: 2.0;" +
-                "}" +
-
-                "edge {" +
-                "	fill-color: #333;" +
-                "	arrow-size: 6px,3px;" +
-                "}" +
-                "edge.shipment {" +
-                "	fill-color: #999;" +
-                "	arrow-size: 6px,3px;" +
-                "}";
-
-    }
-
-    public static Graph createMultiGraph(String name, String style) {
-        Graph g = new MultiGraph(name);
-        g.addAttribute("ui.quality");
-        g.addAttribute("ui.antialias");
-        g.addAttribute("ui.stylesheet", style);
-        return g;
-    }
-
-    public static ViewPanel createEmbeddedView(Graph graph, double scaling) {
-        Viewer viewer = new Viewer(graph, Viewer.ThreadingModel.GRAPH_IN_ANOTHER_THREAD);
-        ViewPanel view = viewer.addDefaultView(false);
-        view.setPreferredSize(new Dimension((int) (698 * scaling), (int) (440 * scaling)));
-        return view;
-    }
-
     public static String STYLESHEET =
         "node {" +
             "	size: 10px, 10px;" +
@@ -235,40 +95,15 @@ public static ViewPanel createEmbeddedView(Graph graph, double scaling) {
             "	fill-color: #999;" +
             "	arrow-size: 6px,3px;" +
             "}";
-
-    public static enum Label {
-        NO_LABEL, ID, JOB_NAME, ARRIVAL_TIME, DEPARTURE_TIME, ACTIVITY
-    }
-
-    private static class Center {
-        final double x;
-        final double y;
-
-        public Center(double x, double y) {
-            super();
-            this.x = x;
-            this.y = y;
-        }
-
-    }
-
     private Label label = Label.NO_LABEL;
-
     private long renderDelay_in_ms = 0;
-
     private boolean renderShipments = false;
-
     private Center center;
-
     private VehicleRoutingProblem vrp;
-
     private VehicleRoutingProblemSolution solution;
-
     private double zoomFactor;
-
     private double scaling = 1.0;
 
-
     public GraphStreamViewer(VehicleRoutingProblem vrp) {
         super();
         this.vrp = vrp;
@@ -329,6 +164,17 @@ public void display() {
         render(g, view);
     }
 
+    public static ViewPanel createEmbeddedView(Graph graph, double scaling) {
+        Viewer viewer = new Viewer(graph, Viewer.ThreadingModel.GRAPH_IN_ANOTHER_THREAD);
+        ViewPanel view = viewer.addDefaultView(false);
+        view.setPreferredSize(new Dimension((int) (698 * scaling), (int) (440 * scaling)));
+        return view;
+    }
+
+    private Graph createMultiGraph(String name) {
+        return GraphStreamViewer.createMultiGraph(name, STYLESHEET);
+    }
+
     private JFrame createJFrame(ViewPanel view, double scaling) {
         JFrame jframe = new JFrame();
         JPanel basicPanel = new JPanel();
@@ -369,10 +215,6 @@ private JFrame createJFrame(ViewPanel view, double scaling) {
         return jframe;
     }
 
-    private Graph createMultiGraph(String name) {
-        return GraphStreamViewer.createMultiGraph(name, STYLESHEET);
-    }
-
     private void render(Graph g, ViewPanel view) {
         if (center != null) {
             view.resizeFrame(view.getWidth(), view.getHeight());
@@ -404,15 +246,12 @@ private void render(Graph g, ViewPanel view) {
 
     }
 
-    private void alignCamera(View view) {
-        view.getCamera().setViewCenter(center.x, center.y, 0);
-        view.getCamera().setViewPercent(zoomFactor);
-    }
-
-    private JLabel createEmptyLabel() {
-        JLabel emptyLabel1 = new JLabel();
-        emptyLabel1.setPreferredSize(new Dimension((int) (40 * scaling), (int) (25 * scaling)));
-        return emptyLabel1;
+    public static Graph createMultiGraph(String name, String style) {
+        Graph g = new MultiGraph(name);
+        g.addAttribute("ui.quality");
+        g.addAttribute("ui.antialias");
+        g.addAttribute("ui.stylesheet", style);
+        return g;
     }
 
     private JPanel createResultPanel() {
@@ -491,14 +330,41 @@ private JPanel createResultPanel() {
         return panel;
     }
 
-    private Integer getNoRoutes() {
-        if (solution != null) return solution.getRoutes().size();
-        return 0;
+    private void alignCamera(View view) {
+        view.getCamera().setViewCenter(center.x, center.y, 0);
+        view.getCamera().setViewPercent(zoomFactor);
     }
 
-    private Double getSolutionCosts() {
-        if (solution != null) return solution.getCost();
-        return 0.0;
+    private void renderVehicle(Graph g, Vehicle vehicle, Label label) {
+        String nodeId = makeId(vehicle.getId(), vehicle.getStartLocation().getId());
+        Node vehicleStart = g.addNode(nodeId);
+        if (label.equals(Label.ID)) vehicleStart.addAttribute("ui.label", "depot");
+//		if(label.equals(Label.ACTIVITY)) n.addAttribute("ui.label", "start");
+        vehicleStart.addAttribute("x", vehicle.getStartLocation().getCoordinate().getX());
+        vehicleStart.addAttribute("y", vehicle.getStartLocation().getCoordinate().getY());
+        vehicleStart.setAttribute("ui.class", "depot");
+
+        if (!vehicle.getStartLocation().getId().equals(vehicle.getEndLocation().getId())) {
+            Node vehicleEnd = g.addNode(makeId(vehicle.getId(), vehicle.getEndLocation().getId()));
+            if (label.equals(Label.ID)) vehicleEnd.addAttribute("ui.label", "depot");
+            vehicleEnd.addAttribute("x", vehicle.getEndLocation().getCoordinate().getX());
+            vehicleEnd.addAttribute("y", vehicle.getEndLocation().getCoordinate().getY());
+            vehicleEnd.setAttribute("ui.class", "depot");
+
+        }
+    }
+
+    private String makeId(String id, String locationId) {
+        return id + "_" + locationId;
+    }
+
+    private void sleep(long renderDelay_in_ms2) {
+        try {
+            Thread.sleep(renderDelay_in_ms2);
+        } catch (InterruptedException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
     }
 
     private void renderShipment(Graph g, Shipment shipment, Label label, boolean renderShipments) {
@@ -523,47 +389,6 @@ private void renderShipment(Graph g, Shipment shipment, Label label, boolean ren
 
     }
 
-    private void sleep(long renderDelay_in_ms2) {
-        try {
-            Thread.sleep(renderDelay_in_ms2);
-        } catch (InterruptedException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        }
-    }
-
-    private void renderService(Graph g, Service service, Label label) {
-        Node n = g.addNode(makeId(service.getId(), service.getLocation().getId()));
-        if (label.equals(Label.ID)) n.addAttribute("ui.label", service.getId());
-        n.addAttribute("x", service.getLocation().getCoordinate().getX());
-        n.addAttribute("y", service.getLocation().getCoordinate().getY());
-        if (service.getType().equals("pickup")) n.setAttribute("ui.class", "pickup");
-        if (service.getType().equals("delivery")) n.setAttribute("ui.class", "delivery");
-    }
-
-    private String makeId(String id, String locationId) {
-        return id + "_" + locationId;
-    }
-
-    private void renderVehicle(Graph g, Vehicle vehicle, Label label) {
-        String nodeId = makeId(vehicle.getId(), vehicle.getStartLocation().getId());
-        Node vehicleStart = g.addNode(nodeId);
-        if (label.equals(Label.ID)) vehicleStart.addAttribute("ui.label", "depot");
-//		if(label.equals(Label.ACTIVITY)) n.addAttribute("ui.label", "start");
-        vehicleStart.addAttribute("x", vehicle.getStartLocation().getCoordinate().getX());
-        vehicleStart.addAttribute("y", vehicle.getStartLocation().getCoordinate().getY());
-        vehicleStart.setAttribute("ui.class", "depot");
-
-        if (!vehicle.getStartLocation().getId().equals(vehicle.getEndLocation().getId())) {
-            Node vehicleEnd = g.addNode(makeId(vehicle.getId(), vehicle.getEndLocation().getId()));
-            if (label.equals(Label.ID)) vehicleEnd.addAttribute("ui.label", "depot");
-            vehicleEnd.addAttribute("x", vehicle.getEndLocation().getCoordinate().getX());
-            vehicleEnd.addAttribute("y", vehicle.getEndLocation().getCoordinate().getY());
-            vehicleEnd.setAttribute("ui.class", "depot");
-
-        }
-    }
-
     private void renderRoute(Graph g, VehicleRoute route, int routeId, long renderDelay_in_ms, Label label) {
         int vehicle_edgeId = 1;
         String prevIdentifier = makeId(route.getVehicle().getId(), route.getVehicle().getStartLocation().getId());
@@ -601,10 +426,176 @@ else if (act instanceof DeliveryActivity)
         }
     }
 
+    private void renderService(Graph g, Service service, Label label) {
+        Node n = g.addNode(makeId(service.getId(), service.getLocation().getId()));
+        if (label.equals(Label.ID)) n.addAttribute("ui.label", service.getId());
+        n.addAttribute("x", service.getLocation().getCoordinate().getX());
+        n.addAttribute("y", service.getLocation().getCoordinate().getY());
+        if (service.getType().equals("pickup")) n.setAttribute("ui.class", "pickup");
+        if (service.getType().equals("delivery")) n.setAttribute("ui.class", "delivery");
+    }
+
+    private Double getSolutionCosts() {
+        if (solution != null) return solution.getCost();
+        return 0.0;
+    }
+
+    private Integer getNoRoutes() {
+        if (solution != null) return solution.getRoutes().size();
+        return 0;
+    }
+
+    private JLabel createEmptyLabel() {
+        JLabel emptyLabel1 = new JLabel();
+        emptyLabel1.setPreferredSize(new Dimension((int) (40 * scaling), (int) (25 * scaling)));
+        return emptyLabel1;
+    }
+
     private String makeEdgeId(int routeId, int vehicle_edgeId) {
         return Integer.valueOf(routeId).toString() + "." + Integer.valueOf(vehicle_edgeId).toString();
     }
 
+    public static enum Label {
+        NO_LABEL, ID, JOB_NAME, ARRIVAL_TIME, DEPARTURE_TIME, ACTIVITY
+    }
+
+    public static class StyleSheets {
+
+        public static String BLUE_FOREST =
+            "graph { fill-color: #141F2E; }" +
+                "node {" +
+                "	size: 7px, 7px;" +
+                "   fill-color: #A0FFA0;" +
+                "	text-alignment: at-right;" +
+                " 	stroke-mode: plain;" +
+                "	stroke-color: #999;" +
+                "	stroke-width: 1.0;" +
+                "	text-font: couriernew;" +
+                " 	text-offset: 2,-5;" +
+                "	text-size: 8;" +
+                "}" +
+                "node.pickup {" +
+                " 	fill-color: #6CC644;" +
+                "}" +
+                "node.delivery {" +
+                " 	fill-color: #f93;" +
+                "}" +
+                "node.pickupInRoute {" +
+                "	fill-color: #6CC644;" +
+                " 	stroke-mode: plain;" +
+                "	stroke-color: #333;" +
+                "   stroke-width: 2.0;" +
+                "}" +
+                "node.deliveryInRoute {" +
+                " 	fill-color: #f93;" +
+                " 	stroke-mode: plain;" +
+                "	stroke-color: #333;" +
+                "   stroke-width: 2.0;" +
+                "}" +
+                "node.depot {" +
+                " 	fill-color: #BD2C00;" +
+                "	size: 10px, 10px;" +
+                " 	shape: box;" +
+                "}" +
+                "node.removed {" +
+                " 	fill-color: #FF8080;" +
+                "	size: 10px, 10px;" +
+                " 	stroke-mode: plain;" +
+                "	stroke-color: #CCF;" +
+                "   stroke-width: 2.0;" +
+                "   shadow-mode: gradient-radial;" +
+                "   shadow-width: 10px; shadow-color: #EEF, #000; shadow-offset: 0px;" +
+                "}" +
+
+                "edge {" +
+                "	fill-color: #D3D3D3;" +
+                "	arrow-size: 6px,3px;" +
+                "}" +
+//                    "edge.inserted {" +
+//                    "	fill-color: #A0FFA0;" +
+//                    "	arrow-size: 6px,3px;" +
+//                    "   shadow-mode: gradient-radial;" +
+//                    "   shadow-width: 10px; shadow-color: #EEF, #000; shadow-offset: 0px;" +
+//                    "}" +
+//                    "edge.removed {" +
+//                    "	fill-color: #FF0000;" +
+//                    "	arrow-size: 6px,3px;" +
+//                    "   shadow-mode: gradient-radial;" +
+//                    "   shadow-width: 10px; shadow-color: #EEF, #000; shadow-offset: 0px;" +
+//                    "}" +
+                "edge.shipment {" +
+                "	fill-color: #999;" +
+                "	arrow-size: 6px,3px;" +
+                "}";
+
+
+        @SuppressWarnings("UnusedDeclaration")
+        public static String SIMPLE_WHITE =
+            "node {" +
+                "	size: 10px, 10px;" +
+                "   fill-color: #6CC644;" +
+                "	text-alignment: at-right;" +
+                " 	stroke-mode: plain;" +
+                "	stroke-color: #999;" +
+                "	stroke-width: 1.0;" +
+                "	text-font: couriernew;" +
+                " 	text-offset: 2,-5;" +
+                "	text-size: 8;" +
+                "}" +
+                "node.pickup {" +
+                " 	fill-color: #6CC644;" +
+                "}" +
+                "node.delivery {" +
+                " 	fill-color: #f93;" +
+                "}" +
+                "node.pickupInRoute {" +
+                "	fill-color: #6CC644;" +
+                " 	stroke-mode: plain;" +
+                "	stroke-color: #333;" +
+                "   stroke-width: 2.0;" +
+                "}" +
+                "node.deliveryInRoute {" +
+                " 	fill-color: #f93;" +
+                " 	stroke-mode: plain;" +
+                "	stroke-color: #333;" +
+                "   stroke-width: 2.0;" +
+                "}" +
+                "node.depot {" +
+                " 	fill-color: #BD2C00;" +
+                "	size: 10px, 10px;" +
+                " 	shape: box;" +
+                "}" +
+                "node.removed {" +
+                " 	fill-color: #BD2C00;" +
+                "	size: 10px, 10px;" +
+                " 	stroke-mode: plain;" +
+                "	stroke-color: #333;" +
+                "   stroke-width: 2.0;" +
+                "}" +
+
+                "edge {" +
+                "	fill-color: #333;" +
+                "	arrow-size: 6px,3px;" +
+                "}" +
+                "edge.shipment {" +
+                "	fill-color: #999;" +
+                "	arrow-size: 6px,3px;" +
+                "}";
+
+    }
+
+    private static class Center {
+        final double x;
+        final double y;
+
+        public Center(double x, double y) {
+            super();
+            this.x = x;
+            this.y = y;
+        }
+
+    }
+
     //	public void saveAsPNG(String filename){
     //
     //	}
diff --git a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/Plotter.java b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/Plotter.java
index 2124fb02e..31c7fb0fe 100644
--- a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/Plotter.java
+++ b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/Plotter.java
@@ -65,121 +65,21 @@
     private final static Color SERVICE_COLOR = Color.BLUE;
 
     private final static Shape ELLIPSE = new Ellipse2D.Double(-3, -3, 6, 6);
-
-    private static class MyActivityRenderer extends XYLineAndShapeRenderer {
-
-        /**
-         *
-         */
-        private static final long serialVersionUID = 1L;
-
-        private XYSeriesCollection seriesCollection;
-
-        private Map<XYDataItem, Activity> activities;
-
-        private Set<XYDataItem> firstActivities;
-
-        public MyActivityRenderer(XYSeriesCollection seriesCollection, Map<XYDataItem, Activity> activities, Set<XYDataItem> firstActivities) {
-            super(false, true);
-            this.seriesCollection = seriesCollection;
-            this.activities = activities;
-            this.firstActivities = firstActivities;
-            super.setSeriesOutlinePaint(0, Color.DARK_GRAY);
-            super.setUseOutlinePaint(true);
-        }
-
-        @Override
-        public Shape getItemShape(int seriesIndex, int itemIndex) {
-            XYDataItem dataItem = seriesCollection.getSeries(seriesIndex).getDataItem(itemIndex);
-            if (firstActivities.contains(dataItem)) {
-                return ShapeUtilities.createUpTriangle(4.0f);
-            }
-            return ELLIPSE;
-        }
-
-        @Override
-        public Paint getItemOutlinePaint(int seriesIndex, int itemIndex) {
-            XYDataItem dataItem = seriesCollection.getSeries(seriesIndex).getDataItem(itemIndex);
-            if (firstActivities.contains(dataItem)) {
-                return Color.BLACK;
-            }
-            return super.getItemOutlinePaint(seriesIndex, itemIndex);
-        }
-
-        @Override
-        public Paint getItemPaint(int seriesIndex, int itemIndex) {
-            XYDataItem dataItem = seriesCollection.getSeries(seriesIndex).getDataItem(itemIndex);
-            Activity activity = activities.get(dataItem);
-            if (activity.equals(Activity.PICKUP)) return PICKUP_COLOR;
-            if (activity.equals(Activity.DELIVERY)) return DELIVERY_COLOR;
-            if (activity.equals(Activity.SERVICE)) return SERVICE_COLOR;
-            if (activity.equals(Activity.START)) return START_COLOR;
-            if (activity.equals(Activity.END)) return END_COLOR;
-            throw new IllegalStateException("activity at " + dataItem.toString() + " cannot be assigned to a color");
-        }
-
-    }
-
-    private static class BoundingBox {
-        double minX;
-        double minY;
-        double maxX;
-        double maxY;
-
-        public BoundingBox(double minX, double minY, double maxX, double maxY) {
-            super();
-            this.minX = minX;
-            this.minY = minY;
-            this.maxX = maxX;
-            this.maxY = maxY;
-        }
-
-    }
-
-    private enum Activity {
-        START, END, PICKUP, DELIVERY, SERVICE
-    }
-
-
     private static Logger log = LoggerFactory.getLogger(Plotter.class);
-
-    /**
-     * Label to label ID (=jobId), SIZE (=jobSize=jobCapacityDimensions)
-     *
-     * @author schroeder
-     */
-    public static enum Label {
-        ID, SIZE, @SuppressWarnings("UnusedDeclaration")NO_LABEL
-    }
-
     private Label label = Label.SIZE;
-
     private VehicleRoutingProblem vrp;
-
     private boolean plotSolutionAsWell = false;
-
     private boolean plotShipments = true;
-
     private Collection<VehicleRoute> routes;
-
     private BoundingBox boundingBox = null;
-
     private Map<XYDataItem, Activity> activitiesByDataItem = new HashMap<XYDataItem, Plotter.Activity>();
-
     private Map<XYDataItem, String> labelsByDataItem = new HashMap<XYDataItem, String>();
-
     private XYSeries activities;
-
     private Set<XYDataItem> firstActivities = new HashSet<XYDataItem>();
-
     private boolean containsPickupAct = false;
-
     private boolean containsDeliveryAct = false;
-
     private boolean containsServiceAct = false;
-
     private double scalingFactor = 1.;
-
     private boolean invert = false;
 
     /**
@@ -311,6 +211,72 @@ private BufferedImage plot(VehicleRoutingProblem vrp, final Collection<VehicleRo
 
     }
 
+    private void retrieveActivities(VehicleRoutingProblem vrp) throws NoLocationFoundException {
+        activities = new XYSeries("activities", false, true);
+        for (Vehicle v : vrp.getVehicles()) {
+            Coordinate start_coordinate = getCoordinate(v.getStartLocation().getCoordinate());
+            if (start_coordinate == null) throw new NoLocationFoundException();
+            XYDataItem item = new XYDataItem(start_coordinate.getX() * scalingFactor, start_coordinate.getY() * scalingFactor);
+            markItem(item, Activity.START);
+            activities.add(item);
+
+            if (!v.getStartLocation().getId().equals(v.getEndLocation().getId())) {
+                Coordinate end_coordinate = getCoordinate(v.getEndLocation().getCoordinate());
+                if (end_coordinate == null) throw new NoLocationFoundException();
+                XYDataItem end_item = new XYDataItem(end_coordinate.getX() * scalingFactor, end_coordinate.getY() * scalingFactor);
+                markItem(end_item, Activity.END);
+                activities.add(end_item);
+            }
+        }
+        for (Job job : vrp.getJobs().values()) {
+            addJob(activities, job);
+        }
+        for (VehicleRoute r : vrp.getInitialVehicleRoutes()) {
+            for (Job job : r.getTourActivities().getJobs()) {
+                addJob(activities, job);
+            }
+        }
+    }
+
+    private Coordinate getCoordinate(Coordinate coordinate) {
+        if (invert) {
+            return Coordinate.newInstance(coordinate.getY(), coordinate.getX());
+        }
+        return coordinate;
+    }
+
+    private void markItem(XYDataItem item, Activity activity) {
+        activitiesByDataItem.put(item, activity);
+    }
+
+    private XYSeriesCollection makeShipmentSeries(Collection<Job> jobs) throws NoLocationFoundException {
+        XYSeriesCollection coll = new XYSeriesCollection();
+        if (!plotShipments) return coll;
+        int sCounter = 1;
+        String ship = "shipment";
+        boolean first = true;
+        for (Job job : jobs) {
+            if (!(job instanceof Shipment)) {
+                continue;
+            }
+            Shipment shipment = (Shipment) job;
+            XYSeries shipmentSeries;
+            if (first) {
+                first = false;
+                shipmentSeries = new XYSeries(ship, false, true);
+            } else {
+                shipmentSeries = new XYSeries(sCounter, false, true);
+                sCounter++;
+            }
+            Coordinate pickupCoordinate = getCoordinate(shipment.getPickupLocation().getCoordinate());
+            Coordinate delCoordinate = getCoordinate(shipment.getDeliveryLocation().getCoordinate());
+            shipmentSeries.add(pickupCoordinate.getX() * scalingFactor, pickupCoordinate.getY() * scalingFactor);
+            shipmentSeries.add(delCoordinate.getX() * scalingFactor, delCoordinate.getY() * scalingFactor);
+            coll.addSeries(shipmentSeries);
+        }
+        return coll;
+    }
+
     private LegendTitle createLegend(final Collection<VehicleRoute> routes, final XYSeriesCollection shipments, final XYPlot plot) {
         LegendItemSource lis = new LegendItemSource() {
 
@@ -366,92 +332,6 @@ public LegendItemCollection getLegendItems() {
         return legend;
     }
 
-    private XYItemRenderer getShipmentRenderer(XYSeriesCollection shipments) {
-        XYItemRenderer shipmentsRenderer = new XYLineAndShapeRenderer(true, false);   // Shapes only
-        for (int i = 0; i < shipments.getSeriesCount(); i++) {
-            shipmentsRenderer.setSeriesPaint(i, Color.DARK_GRAY);
-            shipmentsRenderer.setSeriesStroke(i, new BasicStroke(
-                    1.0f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND,
-                    1.f, new float[]{4.0f, 4.0f}, 0.0f
-            ));
-        }
-        return shipmentsRenderer;
-    }
-
-    private MyActivityRenderer getProblemRenderer(final XYSeriesCollection problem) {
-        MyActivityRenderer problemRenderer = new MyActivityRenderer(problem, activitiesByDataItem, firstActivities);
-        problemRenderer.setBaseItemLabelGenerator(new XYItemLabelGenerator() {
-
-            @Override
-            public String generateLabel(XYDataset arg0, int arg1, int arg2) {
-                XYDataItem item = problem.getSeries(arg1).getDataItem(arg2);
-                return labelsByDataItem.get(item);
-            }
-
-        });
-        problemRenderer.setBaseItemLabelsVisible(true);
-        problemRenderer.setBaseItemLabelPaint(Color.BLACK);
-
-        return problemRenderer;
-    }
-
-    private Range getRange(final XYSeriesCollection seriesCol) {
-        if (this.boundingBox == null) return seriesCol.getRangeBounds(false);
-        else return new Range(boundingBox.minY, boundingBox.maxY);
-    }
-
-    private Range getDomainRange(final XYSeriesCollection seriesCol) {
-        if (this.boundingBox == null) return seriesCol.getDomainBounds(true);
-        else return new Range(boundingBox.minX, boundingBox.maxX);
-    }
-
-    private XYPlot createPlot(final XYSeriesCollection problem, XYSeriesCollection shipments, XYSeriesCollection solution) {
-        XYPlot plot = new XYPlot();
-        plot.setBackgroundPaint(Color.LIGHT_GRAY);
-        plot.setRangeGridlinePaint(Color.LIGHT_GRAY);
-        plot.setDomainGridlinePaint(Color.LIGHT_GRAY);
-
-        XYLineAndShapeRenderer problemRenderer = getProblemRenderer(problem);
-        plot.setDataset(0, problem);
-        plot.setRenderer(0, problemRenderer);
-
-        XYItemRenderer shipmentsRenderer = getShipmentRenderer(shipments);
-        plot.setDataset(1, shipments);
-        plot.setRenderer(1, shipmentsRenderer);
-
-        if (solution != null) {
-            XYItemRenderer solutionRenderer = getRouteRenderer(solution);
-            plot.setDataset(2, solution);
-            plot.setRenderer(2, solutionRenderer);
-        }
-
-        NumberAxis xAxis = new NumberAxis();
-        NumberAxis yAxis = new NumberAxis();
-
-        if (boundingBox == null) {
-            xAxis.setRangeWithMargins(getDomainRange(problem));
-            yAxis.setRangeWithMargins(getRange(problem));
-        } else {
-            xAxis.setRangeWithMargins(new Range(boundingBox.minX, boundingBox.maxX));
-            yAxis.setRangeWithMargins(new Range(boundingBox.minY, boundingBox.maxY));
-        }
-
-        plot.setDomainAxis(xAxis);
-        plot.setRangeAxis(yAxis);
-
-        return plot;
-    }
-
-    private XYItemRenderer getRouteRenderer(XYSeriesCollection solutionColl) {
-        XYItemRenderer solutionRenderer = new XYLineAndShapeRenderer(true, false);   // Lines only
-        for (int i = 0; i < solutionColl.getSeriesCount(); i++) {
-            XYSeries s = solutionColl.getSeries(i);
-            XYDataItem firstCustomer = s.getDataItem(1);
-            firstActivities.add(firstCustomer);
-        }
-        return solutionRenderer;
-    }
-
     private void save(JFreeChart chart, String pngFile) {
         try {
             ChartUtilities.saveChartAsPNG(new File(pngFile), chart, 1000, 600);
@@ -494,34 +374,6 @@ private XYSeriesCollection makeSolutionSeries(VehicleRoutingProblem vrp, Collect
         return coords;
     }
 
-    private XYSeriesCollection makeShipmentSeries(Collection<Job> jobs) throws NoLocationFoundException {
-        XYSeriesCollection coll = new XYSeriesCollection();
-        if (!plotShipments) return coll;
-        int sCounter = 1;
-        String ship = "shipment";
-        boolean first = true;
-        for (Job job : jobs) {
-            if (!(job instanceof Shipment)) {
-                continue;
-            }
-            Shipment shipment = (Shipment) job;
-            XYSeries shipmentSeries;
-            if (first) {
-                first = false;
-                shipmentSeries = new XYSeries(ship, false, true);
-            } else {
-                shipmentSeries = new XYSeries(sCounter, false, true);
-                sCounter++;
-            }
-            Coordinate pickupCoordinate = getCoordinate(shipment.getPickupLocation().getCoordinate());
-            Coordinate delCoordinate = getCoordinate(shipment.getDeliveryLocation().getCoordinate());
-            shipmentSeries.add(pickupCoordinate.getX() * scalingFactor, pickupCoordinate.getY() * scalingFactor);
-            shipmentSeries.add(delCoordinate.getX() * scalingFactor, delCoordinate.getY() * scalingFactor);
-            coll.addSeries(shipmentSeries);
-        }
-        return coll;
-    }
-
     private void addJob(XYSeries activities, Job job) {
         if (job instanceof Shipment) {
             Shipment s = (Shipment) job;
@@ -567,6 +419,92 @@ private void addJob(XYSeries activities, Job job) {
         }
     }
 
+    private XYPlot createPlot(final XYSeriesCollection problem, XYSeriesCollection shipments, XYSeriesCollection solution) {
+        XYPlot plot = new XYPlot();
+        plot.setBackgroundPaint(Color.LIGHT_GRAY);
+        plot.setRangeGridlinePaint(Color.LIGHT_GRAY);
+        plot.setDomainGridlinePaint(Color.LIGHT_GRAY);
+
+        XYLineAndShapeRenderer problemRenderer = getProblemRenderer(problem);
+        plot.setDataset(0, problem);
+        plot.setRenderer(0, problemRenderer);
+
+        XYItemRenderer shipmentsRenderer = getShipmentRenderer(shipments);
+        plot.setDataset(1, shipments);
+        plot.setRenderer(1, shipmentsRenderer);
+
+        if (solution != null) {
+            XYItemRenderer solutionRenderer = getRouteRenderer(solution);
+            plot.setDataset(2, solution);
+            plot.setRenderer(2, solutionRenderer);
+        }
+
+        NumberAxis xAxis = new NumberAxis();
+        NumberAxis yAxis = new NumberAxis();
+
+        if (boundingBox == null) {
+            xAxis.setRangeWithMargins(getDomainRange(problem));
+            yAxis.setRangeWithMargins(getRange(problem));
+        } else {
+            xAxis.setRangeWithMargins(new Range(boundingBox.minX, boundingBox.maxX));
+            yAxis.setRangeWithMargins(new Range(boundingBox.minY, boundingBox.maxY));
+        }
+
+        plot.setDomainAxis(xAxis);
+        plot.setRangeAxis(yAxis);
+
+        return plot;
+    }
+
+    private MyActivityRenderer getProblemRenderer(final XYSeriesCollection problem) {
+        MyActivityRenderer problemRenderer = new MyActivityRenderer(problem, activitiesByDataItem, firstActivities);
+        problemRenderer.setBaseItemLabelGenerator(new XYItemLabelGenerator() {
+
+            @Override
+            public String generateLabel(XYDataset arg0, int arg1, int arg2) {
+                XYDataItem item = problem.getSeries(arg1).getDataItem(arg2);
+                return labelsByDataItem.get(item);
+            }
+
+        });
+        problemRenderer.setBaseItemLabelsVisible(true);
+        problemRenderer.setBaseItemLabelPaint(Color.BLACK);
+
+        return problemRenderer;
+    }
+
+    private XYItemRenderer getShipmentRenderer(XYSeriesCollection shipments) {
+        XYItemRenderer shipmentsRenderer = new XYLineAndShapeRenderer(true, false);   // Shapes only
+        for (int i = 0; i < shipments.getSeriesCount(); i++) {
+            shipmentsRenderer.setSeriesPaint(i, Color.DARK_GRAY);
+            shipmentsRenderer.setSeriesStroke(i, new BasicStroke(
+                1.0f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND,
+                1.f, new float[]{4.0f, 4.0f}, 0.0f
+            ));
+        }
+        return shipmentsRenderer;
+    }
+
+    private XYItemRenderer getRouteRenderer(XYSeriesCollection solutionColl) {
+        XYItemRenderer solutionRenderer = new XYLineAndShapeRenderer(true, false);   // Lines only
+        for (int i = 0; i < solutionColl.getSeriesCount(); i++) {
+            XYSeries s = solutionColl.getSeries(i);
+            XYDataItem firstCustomer = s.getDataItem(1);
+            firstActivities.add(firstCustomer);
+        }
+        return solutionRenderer;
+    }
+
+    private Range getDomainRange(final XYSeriesCollection seriesCol) {
+        if (this.boundingBox == null) return seriesCol.getDomainBounds(true);
+        else return new Range(boundingBox.minX, boundingBox.maxX);
+    }
+
+    private Range getRange(final XYSeriesCollection seriesCol) {
+        if (this.boundingBox == null) return seriesCol.getRangeBounds(false);
+        else return new Range(boundingBox.minY, boundingBox.maxY);
+    }
+
     private void addLabel(Job job, XYDataItem dataItem) {
         if (this.label.equals(Label.SIZE)) {
             labelsByDataItem.put(dataItem, getSizeString(job));
@@ -592,42 +530,87 @@ private String getSizeString(Job job) {
         return builder.toString();
     }
 
-    private Coordinate getCoordinate(Coordinate coordinate) {
-        if (invert) {
-            return Coordinate.newInstance(coordinate.getY(), coordinate.getX());
-        }
-        return coordinate;
+    private enum Activity {
+        START, END, PICKUP, DELIVERY, SERVICE
     }
 
-    private void retrieveActivities(VehicleRoutingProblem vrp) throws NoLocationFoundException {
-        activities = new XYSeries("activities", false, true);
-        for (Vehicle v : vrp.getVehicles()) {
-            Coordinate start_coordinate = getCoordinate(v.getStartLocation().getCoordinate());
-            if (start_coordinate == null) throw new NoLocationFoundException();
-            XYDataItem item = new XYDataItem(start_coordinate.getX() * scalingFactor, start_coordinate.getY() * scalingFactor);
-            markItem(item, Activity.START);
-            activities.add(item);
+    /**
+     * Label to label ID (=jobId), SIZE (=jobSize=jobCapacityDimensions)
+     *
+     * @author schroeder
+     */
+    public static enum Label {
+        ID, SIZE, @SuppressWarnings("UnusedDeclaration") NO_LABEL
+    }
 
-            if (!v.getStartLocation().getId().equals(v.getEndLocation().getId())) {
-                Coordinate end_coordinate = getCoordinate(v.getEndLocation().getCoordinate());
-                if (end_coordinate == null) throw new NoLocationFoundException();
-                XYDataItem end_item = new XYDataItem(end_coordinate.getX() * scalingFactor, end_coordinate.getY() * scalingFactor);
-                markItem(end_item, Activity.END);
-                activities.add(end_item);
-            }
+    private static class MyActivityRenderer extends XYLineAndShapeRenderer {
+
+        /**
+         *
+         */
+        private static final long serialVersionUID = 1L;
+
+        private XYSeriesCollection seriesCollection;
+
+        private Map<XYDataItem, Activity> activities;
+
+        private Set<XYDataItem> firstActivities;
+
+        public MyActivityRenderer(XYSeriesCollection seriesCollection, Map<XYDataItem, Activity> activities, Set<XYDataItem> firstActivities) {
+            super(false, true);
+            this.seriesCollection = seriesCollection;
+            this.activities = activities;
+            this.firstActivities = firstActivities;
+            super.setSeriesOutlinePaint(0, Color.DARK_GRAY);
+            super.setUseOutlinePaint(true);
         }
-        for (Job job : vrp.getJobs().values()) {
-            addJob(activities, job);
+
+        @Override
+        public Paint getItemPaint(int seriesIndex, int itemIndex) {
+            XYDataItem dataItem = seriesCollection.getSeries(seriesIndex).getDataItem(itemIndex);
+            Activity activity = activities.get(dataItem);
+            if (activity.equals(Activity.PICKUP)) return PICKUP_COLOR;
+            if (activity.equals(Activity.DELIVERY)) return DELIVERY_COLOR;
+            if (activity.equals(Activity.SERVICE)) return SERVICE_COLOR;
+            if (activity.equals(Activity.START)) return START_COLOR;
+            if (activity.equals(Activity.END)) return END_COLOR;
+            throw new IllegalStateException("activity at " + dataItem.toString() + " cannot be assigned to a color");
         }
-        for (VehicleRoute r : vrp.getInitialVehicleRoutes()) {
-            for (Job job : r.getTourActivities().getJobs()) {
-                addJob(activities, job);
+
+        @Override
+        public Paint getItemOutlinePaint(int seriesIndex, int itemIndex) {
+            XYDataItem dataItem = seriesCollection.getSeries(seriesIndex).getDataItem(itemIndex);
+            if (firstActivities.contains(dataItem)) {
+                return Color.BLACK;
+            }
+            return super.getItemOutlinePaint(seriesIndex, itemIndex);
+        }
+
+        @Override
+        public Shape getItemShape(int seriesIndex, int itemIndex) {
+            XYDataItem dataItem = seriesCollection.getSeries(seriesIndex).getDataItem(itemIndex);
+            if (firstActivities.contains(dataItem)) {
+                return ShapeUtilities.createUpTriangle(4.0f);
             }
+            return ELLIPSE;
         }
+
     }
 
-    private void markItem(XYDataItem item, Activity activity) {
-        activitiesByDataItem.put(item, activity);
+    private static class BoundingBox {
+        double minX;
+        double minY;
+        double maxX;
+        double maxY;
+
+        public BoundingBox(double minX, double minY, double maxX, double maxY) {
+            super();
+            this.minX = minX;
+            this.minY = minY;
+            this.maxX = maxX;
+            this.maxY = maxY;
+        }
+
     }
 
 
diff --git a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/StopWatch.java b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/StopWatch.java
index 3cd60e904..5de8274bd 100644
--- a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/StopWatch.java
+++ b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/StopWatch.java
@@ -43,8 +43,13 @@ public void informAlgorithmStarts(VehicleRoutingProblem problem, VehicleRoutingA
         start();
     }
 
-    public double getCompTimeInSeconds() {
-        return (ran) / 1000.0;
+    public void reset() {
+        startTime = 0;
+        ran = 0;
+    }
+
+    public void start() {
+        startTime = System.currentTimeMillis();
     }
 
     @Override
@@ -57,13 +62,8 @@ public void stop() {
         ran += System.currentTimeMillis() - startTime;
     }
 
-    public void start() {
-        startTime = System.currentTimeMillis();
-    }
-
-    public void reset() {
-        startTime = 0;
-        ran = 0;
+    public double getCompTimeInSeconds() {
+        return (ran) / 1000.0;
     }
 
     @Override
diff --git a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/StrategyAnalyser.java b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/StrategyAnalyser.java
index 522df545d..f3a7be0b3 100644
--- a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/StrategyAnalyser.java
+++ b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/StrategyAnalyser.java
@@ -36,60 +36,8 @@
 public class StrategyAnalyser implements AlgorithmEndsListener, StrategySelectedListener, IterationStartsListener {
 
 
-    public static class Strategy {
-
-        private final String id;
-
-        private int selected = 0;
-
-        private int improved = 0;
-
-        private int countNewSolution = 0;
-
-        private List<Double> improvements = new ArrayList<>();
-
-        public Strategy(String id) {
-            this.id = id;
-        }
-
-        public void selected() {
-            selected++;
-        }
-
-        public void improvedSolution(double improvement) {
-            improved++;
-            improvements.add(improvement);
-        }
-
-        public void newSolution() {
-            countNewSolution++;
-        }
-
-        public String getId() {
-            return id;
-        }
-
-        public int getCountSelected() {
-            return selected;
-        }
-
-        public int getCountImproved() {
-            return improved;
-        }
-
-        public int getCountNewSolution() {
-            return countNewSolution;
-        }
-
-        public List<Double> getImprovements() {
-            return improvements;
-        }
-    }
-
     private Map<String, Strategy> strategyMap = new HashMap<>();
-
     private Collection<VehicleRoutingProblemSolution> last;
-
     private Writer out;
 
     @Override
@@ -112,6 +60,25 @@ public void informSelectedStrategy(SearchStrategy.DiscoveredSolution discoveredS
         }
     }
 
+    private boolean isBetter(Collection<VehicleRoutingProblemSolution> vehicleRoutingProblemSolutions, Collection<VehicleRoutingProblemSolution> last) {
+        for (VehicleRoutingProblemSolution solution : vehicleRoutingProblemSolutions) {
+            for (VehicleRoutingProblemSolution lastSolution : last) {
+                if (solution.getCost() < lastSolution.getCost()) return true;
+            }
+        }
+        return false;
+    }
+
+    private double getImprovement(Collection<VehicleRoutingProblemSolution> vehicleRoutingProblemSolutions, Collection<VehicleRoutingProblemSolution> last) {
+        for (VehicleRoutingProblemSolution solution : vehicleRoutingProblemSolutions) {
+            for (VehicleRoutingProblemSolution lastSolution : last) {
+                if (solution.getCost() < lastSolution.getCost())
+                    return Math.round(lastSolution.getCost() - solution.getCost());
+            }
+        }
+        return 0;
+    }
+
     public void setOutWriter(Writer out) {
         this.out = out;
     }
@@ -137,26 +104,57 @@ public void informAlgorithmEnds(VehicleRoutingProblem problem, Collection<Vehicl
         }
     }
 
-    private double getImprovement(Collection<VehicleRoutingProblemSolution> vehicleRoutingProblemSolutions, Collection<VehicleRoutingProblemSolution> last) {
-        for (VehicleRoutingProblemSolution solution : vehicleRoutingProblemSolutions) {
-            for (VehicleRoutingProblemSolution lastSolution : last) {
-                if (solution.getCost() < lastSolution.getCost())
-                    return Math.round(lastSolution.getCost() - solution.getCost());
-            }
-        }
-        return 0;
+    public Map<String, Strategy> getStrategies() {
+        return strategyMap;
     }
 
-    private boolean isBetter(Collection<VehicleRoutingProblemSolution> vehicleRoutingProblemSolutions, Collection<VehicleRoutingProblemSolution> last) {
-        for (VehicleRoutingProblemSolution solution : vehicleRoutingProblemSolutions) {
-            for (VehicleRoutingProblemSolution lastSolution : last) {
-                if (solution.getCost() < lastSolution.getCost()) return true;
-            }
+    public static class Strategy {
+
+        private final String id;
+
+        private int selected = 0;
+
+        private int improved = 0;
+
+        private int countNewSolution = 0;
+
+        private List<Double> improvements = new ArrayList<>();
+
+        public Strategy(String id) {
+            this.id = id;
         }
-        return false;
-    }
 
-    public Map<String, Strategy> getStrategies() {
-        return strategyMap;
+        public void selected() {
+            selected++;
+        }
+
+        public void improvedSolution(double improvement) {
+            improved++;
+            improvements.add(improvement);
+        }
+
+        public void newSolution() {
+            countNewSolution++;
+        }
+
+        public String getId() {
+            return id;
+        }
+
+        public int getCountSelected() {
+            return selected;
+        }
+
+        public int getCountImproved() {
+            return improved;
+        }
+
+        public int getCountNewSolution() {
+            return countNewSolution;
+        }
+
+        public List<Double> getImprovements() {
+            return improvements;
+        }
     }
 }
diff --git a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/XYLineChartBuilder.java b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/XYLineChartBuilder.java
index 8e456e7a1..13aa2699b 100644
--- a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/XYLineChartBuilder.java
+++ b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/XYLineChartBuilder.java
@@ -35,6 +35,17 @@
  */
 public class XYLineChartBuilder {
 
+    private final String xDomain;
+    private final String yDomain;
+    private final String chartName;
+    private ConcurrentHashMap<String, XYSeries> seriesMap = new ConcurrentHashMap<String, XYSeries>();
+
+    private XYLineChartBuilder(String chartName, String xDomainName, String yDomainName) {
+        this.xDomain = xDomainName;
+        this.yDomain = yDomainName;
+        this.chartName = chartName;
+    }
+
     /**
      * Helper that just saves the chart as specified png-file. The width of the image is 1000 and height 600.
      *
@@ -61,20 +72,6 @@ public static XYLineChartBuilder newInstance(String chartTitle, String xDomainNa
         return new XYLineChartBuilder(chartTitle, xDomainName, yDomainName);
     }
 
-    private ConcurrentHashMap<String, XYSeries> seriesMap = new ConcurrentHashMap<String, XYSeries>();
-
-    private final String xDomain;
-
-    private final String yDomain;
-
-    private final String chartName;
-
-    private XYLineChartBuilder(String chartName, String xDomainName, String yDomainName) {
-        this.xDomain = xDomainName;
-        this.yDomain = yDomainName;
-        this.chartName = chartName;
-    }
-
     /**
      * Adds data to the according series (i.e. XYLine).
      *
diff --git a/jsprit-core/pom.xml b/jsprit-core/pom.xml
index d925760b1..0f35b8d83 100644
--- a/jsprit-core/pom.xml
+++ b/jsprit-core/pom.xml
@@ -1,4 +1,3 @@
-
 <!--
   ~ Licensed to GraphHopper GmbH under one or more contributor
   ~ license agreements. See the NOTICE file distributed with this work for
@@ -17,7 +16,8 @@
   ~ limitations under the License.
   -->
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>jsprit</artifactId>
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/AlgorithmUtil.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/AlgorithmUtil.java
index 0cdd76ce7..66e3b8167 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/AlgorithmUtil.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/AlgorithmUtil.java
@@ -22,12 +22,7 @@
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
 import com.graphhopper.jsprit.core.problem.constraint.SwitchNotFeasible;
-import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.solution.SolutionCostCalculator;
-import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.BreakActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeKey;
 import com.graphhopper.jsprit.core.util.ActivityTimeTracker;
@@ -42,7 +37,7 @@
  */
 public class AlgorithmUtil {
 
-    public static void addCoreConstraints(ConstraintManager constraintManager, StateManager stateManager, final VehicleRoutingProblem vrp){
+    public static void addCoreConstraints(ConstraintManager constraintManager, StateManager stateManager, final VehicleRoutingProblem vrp) {
         constraintManager.addTimeWindowConstraint();
         constraintManager.addLoadConstraint();
         constraintManager.addSkillsConstraint();
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/PrettyAlgorithmBuilder.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/PrettyAlgorithmBuilder.java
index 7d6c4e170..46331dcc8 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/PrettyAlgorithmBuilder.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/PrettyAlgorithmBuilder.java
@@ -23,19 +23,15 @@
 import com.graphhopper.jsprit.core.algorithm.listener.AlgorithmStartsListener;
 import com.graphhopper.jsprit.core.algorithm.recreate.InsertionStrategy;
 import com.graphhopper.jsprit.core.algorithm.recreate.VehicleSwitched;
-import com.graphhopper.jsprit.core.algorithm.state.*;
+import com.graphhopper.jsprit.core.algorithm.state.StateManager;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
-import com.graphhopper.jsprit.core.problem.constraint.SwitchNotFeasible;
 import com.graphhopper.jsprit.core.problem.solution.SolutionCostCalculator;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleFleetManager;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeKey;
-import com.graphhopper.jsprit.core.util.ActivityTimeTracker;
 
-import java.util.*;
+import java.util.Collection;
+import java.util.Random;
 
 /**
  * Created by schroeder on 10.12.14.
@@ -60,10 +56,6 @@
 
     private SolutionCostCalculator objectiveFunction = null;
 
-    public static PrettyAlgorithmBuilder newInstance(VehicleRoutingProblem vrp, VehicleFleetManager fleetManager, StateManager stateManager, ConstraintManager constraintManager) {
-        return new PrettyAlgorithmBuilder(vrp, fleetManager, stateManager, constraintManager);
-    }
-
     PrettyAlgorithmBuilder(VehicleRoutingProblem vrp, VehicleFleetManager fleetManager, StateManager stateManager, ConstraintManager constraintManager) {
         this.vrp = vrp;
         this.fleetManager = fleetManager;
@@ -72,6 +64,10 @@ public static PrettyAlgorithmBuilder newInstance(VehicleRoutingProblem vrp, Vehi
         this.searchStrategyManager = new SearchStrategyManager();
     }
 
+    public static PrettyAlgorithmBuilder newInstance(VehicleRoutingProblem vrp, VehicleFleetManager fleetManager, StateManager stateManager, ConstraintManager constraintManager) {
+        return new PrettyAlgorithmBuilder(vrp, fleetManager, stateManager, constraintManager);
+    }
+
     public PrettyAlgorithmBuilder setRandom(Random random) {
         searchStrategyManager.setRandom(random);
         return this;
@@ -90,7 +86,7 @@ public PrettyAlgorithmBuilder constructInitialSolutionWith(InsertionStrategy ins
 
     public VehicleRoutingAlgorithm build() {
         if (coreStuff) {
-            AlgorithmUtil.addCoreConstraints(constraintManager,stateManager,vrp);
+            AlgorithmUtil.addCoreConstraints(constraintManager, stateManager, vrp);
         }
         VehicleRoutingAlgorithm vra = new VehicleRoutingAlgorithm(vrp, searchStrategyManager, objectiveFunction);
         vra.addListener(stateManager);
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/SearchStrategy.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/SearchStrategy.java
index a68808e41..22c526223 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/SearchStrategy.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/SearchStrategy.java
@@ -33,51 +33,12 @@
 
 public class SearchStrategy {
 
-    public static class DiscoveredSolution {
-
-        private VehicleRoutingProblemSolution solution;
-
-        private boolean accepted;
-
-        private String strategyId;
-
-        public DiscoveredSolution(VehicleRoutingProblemSolution solution, boolean accepted, String strategyId) {
-            super();
-            this.solution = solution;
-            this.accepted = accepted;
-            this.strategyId = strategyId;
-        }
-
-        public VehicleRoutingProblemSolution getSolution() {
-            return solution;
-        }
-
-        public boolean isAccepted() {
-            return accepted;
-        }
-
-        public String getStrategyId() {
-            return strategyId;
-        }
-
-        @Override
-        public String toString() {
-            return "[strategyId=" + strategyId + "][solution=" + solution + "][accepted=" + accepted + "]";
-        }
-    }
-
     private static Logger logger = LoggerFactory.getLogger(SearchStrategy.class);
-
     private final Collection<SearchStrategyModule> searchStrategyModules = new ArrayList<SearchStrategyModule>();
-
     private final SolutionSelector solutionSelector;
-
     private final SolutionCostCalculator solutionCostCalculator;
-
     private final SolutionAcceptor solutionAcceptor;
-
     private final String id;
-
     private String name;
 
     public SearchStrategy(String id, SolutionSelector solutionSelector, SolutionAcceptor solutionAcceptor, SolutionCostCalculator solutionCostCalculator) {
@@ -89,10 +50,6 @@ public SearchStrategy(String id, SolutionSelector solutionSelector, SolutionAcce
         logger.debug("initialise {}", this);
     }
 
-    public String getId() {
-        return id;
-    }
-
     public String getName() {
         return name;
     }
@@ -115,11 +72,6 @@ public SolutionAcceptor getSolutionAcceptor() {
         return solutionAcceptor;
     }
 
-    @Override
-    public String toString() {
-        return "searchStrategy [#modules=" + searchStrategyModules.size() + "][selector=" + solutionSelector + "][acceptor=" + solutionAcceptor + "]";
-    }
-
     /**
      * Runs the search-strategy and its according modules, and returns DiscoveredSolution.
      * <p>
@@ -153,6 +105,14 @@ private String getErrMsg() {
             + " or let the algorithm create an initial solution for you. then add the <construction>...</construction> xml-snippet to your algorithm's config file.";
     }
 
+    public String getId() {
+        return id;
+    }
+
+    @Override
+    public String toString() {
+        return "searchStrategy [#modules=" + searchStrategyModules.size() + "][selector=" + solutionSelector + "][acceptor=" + solutionAcceptor + "]";
+    }
 
     public void addModule(SearchStrategyModule module) {
         if (module == null) throw new IllegalStateException("module to be added is null.");
@@ -167,4 +127,39 @@ public void addModuleListener(SearchStrategyModuleListener moduleListener) {
 
     }
 
+    public static class DiscoveredSolution {
+
+        private VehicleRoutingProblemSolution solution;
+
+        private boolean accepted;
+
+        private String strategyId;
+
+        public DiscoveredSolution(VehicleRoutingProblemSolution solution, boolean accepted, String strategyId) {
+            super();
+            this.solution = solution;
+            this.accepted = accepted;
+            this.strategyId = strategyId;
+        }
+
+        public VehicleRoutingProblemSolution getSolution() {
+            return solution;
+        }
+
+        public boolean isAccepted() {
+            return accepted;
+        }
+
+        public String getStrategyId() {
+            return strategyId;
+        }
+
+        @Override
+        public String toString() {
+            return "[strategyId=" + strategyId + "][solution=" + solution + "][accepted=" + accepted + "]";
+        }
+    }
+
+
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/VehicleRoutingAlgorithm.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/VehicleRoutingAlgorithm.java
index 1155955bd..bd4e93d05 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/VehicleRoutingAlgorithm.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/VehicleRoutingAlgorithm.java
@@ -47,70 +47,17 @@
 public class VehicleRoutingAlgorithm {
 
 
-
-    private static class TerminationManager implements PrematureAlgorithmTermination {
-
-        private Collection<PrematureAlgorithmTermination> terminationCriteria = new ArrayList<PrematureAlgorithmTermination>();
-
-        void addTermination(PrematureAlgorithmTermination termination) {
-            terminationCriteria.add(termination);
-        }
-
-        @Override
-        public boolean isPrematureBreak(DiscoveredSolution discoveredSolution) {
-            for (PrematureAlgorithmTermination termination : terminationCriteria) {
-                if (termination.isPrematureBreak(discoveredSolution))
-                    return true;
-            }
-            return false;
-        }
-    }
-
-    private static class Counter {
-        private final String name;
-        private long counter = 0;
-        private long nextCounter = 1;
-        private static final Logger log = LoggerFactory.getLogger(Counter.class);
-
-        public Counter(final String name) {
-            this.name = name;
-        }
-
-        public void incCounter() {
-            long i = ++counter;
-            long n = nextCounter;
-            if (i >= n) {
-                nextCounter = n * 2;
-                log.info(this.name + n);
-            }
-        }
-
-        public void reset() {
-            counter = 0;
-            nextCounter = 1;
-        }
-    }
-
     private final static Logger logger = LoggerFactory.getLogger(VehicleRoutingAlgorithm.class);
-
     private final Counter counter = new Counter("iterations ");
-
     private final VehicleRoutingProblem problem;
-
     private final SearchStrategyManager searchStrategyManager;
-
     private final VehicleRoutingAlgorithmListeners algoListeners = new VehicleRoutingAlgorithmListeners();
-
     private final Collection<VehicleRoutingProblemSolution> initialSolutions;
-
+    private final SolutionCostCalculator objectiveFunction;
     private int maxIterations = 100;
-
     private TerminationManager terminationManager = new TerminationManager();
-
     private VehicleRoutingProblemSolution bestEver = null;
 
-    private final SolutionCostCalculator objectiveFunction;
-
     public VehicleRoutingAlgorithm(VehicleRoutingProblem problem, SearchStrategyManager searchStrategyManager) {
         super();
         this.problem = problem;
@@ -173,6 +120,10 @@ private void verify(VehicleRoutingProblemSolution solution) {
         //        }
     }
 
+    public SolutionCostCalculator getObjectiveFunction() {
+        return objectiveFunction;
+    }
+
     /**
      * Sets premature termination and overrides existing termination criteria. If existing ones should not be
      * overridden use <code>.addTerminationCriterion(...)</code>.
@@ -250,10 +201,8 @@ public SearchStrategyManager getSearchStrategyManager() {
         return solutions;
     }
 
-    private void addBestEver(Collection<VehicleRoutingProblemSolution> solutions) {
-        if (bestEver != null) {
-            solutions.add(bestEver);
-        }
+    private void algorithmStarts(VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
+        algoListeners.algorithmStarts(problem, this, solutions);
     }
 
     private void log(Collection<VehicleRoutingProblemSolution> solutions) {
@@ -262,26 +211,8 @@ private void log(Collection<VehicleRoutingProblemSolution> solutions) {
         }
     }
 
-    private void log(VehicleRoutingProblemSolution solution) {
-        logger.trace("solution costs: {}", solution.getCost());
-        for (VehicleRoute r : solution.getRoutes()) {
-            StringBuilder b = new StringBuilder();
-            b.append(r.getVehicle().getId()).append(" : ").append("[ ");
-            for (TourActivity act : r.getActivities()) {
-                if (act instanceof TourActivity.JobActivity) {
-                    b.append(((TourActivity.JobActivity) act).getJob().getId()).append(" ");
-                }
-            }
-            b.append("]");
-            logger.trace(b.toString());
-        }
-        StringBuilder b = new StringBuilder();
-        b.append("unassigned : [ ");
-        for (Job j : solution.getUnassignedJobs()) {
-            b.append(j.getId()).append(" ");
-        }
-        b.append("]");
-        logger.trace(b.toString());
+    private void iterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
+        algoListeners.iterationStarts(i, problem, solutions);
     }
 
     private void log(DiscoveredSolution discoveredSolution) {
@@ -289,7 +220,6 @@ private void log(DiscoveredSolution discoveredSolution) {
         log(discoveredSolution.getSolution());
     }
 
-
     private void memorizeIfBestEver(DiscoveredSolution discoveredSolution) {
         if (discoveredSolution == null) return;
         if (bestEver == null) {
@@ -299,15 +229,46 @@ private void memorizeIfBestEver(DiscoveredSolution discoveredSolution) {
         }
     }
 
-
     private void selectedStrategy(DiscoveredSolution discoveredSolution, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
         algoListeners.selectedStrategy(discoveredSolution, problem, solutions);
     }
 
+    private void iterationEnds(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
+        algoListeners.iterationEnds(i, problem, solutions);
+    }
+
+    private void addBestEver(Collection<VehicleRoutingProblemSolution> solutions) {
+        if (bestEver != null) {
+            solutions.add(bestEver);
+        }
+    }
+
     private void algorithmEnds(VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
         algoListeners.algorithmEnds(problem, solutions);
     }
 
+    private void log(VehicleRoutingProblemSolution solution) {
+        logger.trace("solution costs: {}", solution.getCost());
+        for (VehicleRoute r : solution.getRoutes()) {
+            StringBuilder b = new StringBuilder();
+            b.append(r.getVehicle().getId()).append(" : ").append("[ ");
+            for (TourActivity act : r.getActivities()) {
+                if (act instanceof TourActivity.JobActivity) {
+                    b.append(((TourActivity.JobActivity) act).getJob().getId()).append(" ");
+                }
+            }
+            b.append("]");
+            logger.trace(b.toString());
+        }
+        StringBuilder b = new StringBuilder();
+        b.append("unassigned : [ ");
+        for (Job j : solution.getUnassignedJobs()) {
+            b.append(j.getId()).append(" ");
+        }
+        b.append("]");
+        logger.trace(b.toString());
+    }
+
     public VehicleRoutingAlgorithmListeners getAlgorithmListeners() {
         return algoListeners;
     }
@@ -322,16 +283,13 @@ public void addListener(VehicleRoutingAlgorithmListener l) {
         }
     }
 
-    private void iterationEnds(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
-        algoListeners.iterationEnds(i, problem, solutions);
-    }
-
-    private void iterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
-        algoListeners.iterationStarts(i, problem, solutions);
-    }
-
-    private void algorithmStarts(VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
-        algoListeners.algorithmStarts(problem, this, solutions);
+    /**
+     * Gets max number of iterations.
+     *
+     * @return max number of iterations
+     */
+    public int getMaxIterations() {
+        return maxIterations;
     }
 
     /**
@@ -344,17 +302,47 @@ public void setMaxIterations(int maxIterations) {
         logger.debug("set maxIterations to {}", this.maxIterations);
     }
 
-    /**
-     * Gets max number of iterations.
-     *
-     * @return max number of iterations
-     */
-    public int getMaxIterations() {
-        return maxIterations;
+    private static class TerminationManager implements PrematureAlgorithmTermination {
+
+        private Collection<PrematureAlgorithmTermination> terminationCriteria = new ArrayList<PrematureAlgorithmTermination>();
+
+        void addTermination(PrematureAlgorithmTermination termination) {
+            terminationCriteria.add(termination);
+        }
+
+        @Override
+        public boolean isPrematureBreak(DiscoveredSolution discoveredSolution) {
+            for (PrematureAlgorithmTermination termination : terminationCriteria) {
+                if (termination.isPrematureBreak(discoveredSolution))
+                    return true;
+            }
+            return false;
+        }
     }
 
-    public SolutionCostCalculator getObjectiveFunction(){
-        return objectiveFunction;
+    private static class Counter {
+        private static final Logger log = LoggerFactory.getLogger(Counter.class);
+        private final String name;
+        private long counter = 0;
+        private long nextCounter = 1;
+
+        public Counter(final String name) {
+            this.name = name;
+        }
+
+        public void incCounter() {
+            long i = ++counter;
+            long n = nextCounter;
+            if (i >= n) {
+                nextCounter = n * 2;
+                log.info(this.name + n);
+            }
+        }
+
+        public void reset() {
+            counter = 0;
+            nextCounter = 1;
+        }
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/acceptor/ExperimentalSchrimpfAcceptance.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/acceptor/ExperimentalSchrimpfAcceptance.java
index 68ef0dbb9..a77492951 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/acceptor/ExperimentalSchrimpfAcceptance.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/acceptor/ExperimentalSchrimpfAcceptance.java
@@ -38,17 +38,12 @@
     final static Logger logger = LoggerFactory.getLogger(ExperimentalSchrimpfAcceptance.class.getName());
 
     private final double alpha;
-
+    private final int nOfRandomWalks;
+    private final int solutionMemory;
     private int nOfTotalIterations = 1000;
-
     private int currentIteration = 0;
-
     private double initialThreshold = 0.0;
 
-    private final int nOfRandomWalks;
-
-    private final int solutionMemory;
-
 
     public ExperimentalSchrimpfAcceptance(int solutionMemory, double alpha, int nOfWarmupIterations) {
         super();
@@ -85,11 +80,6 @@ public boolean acceptSolution(Collection<VehicleRoutingProblemSolution> solution
         return solutionAccepted;
     }
 
-    @Override
-    public String toString() {
-        return "[name=schrimpfAcceptanceFunction][alpha=" + alpha + "][warmup=" + nOfRandomWalks + "]";
-    }
-
     private double getThreshold(int iteration) {
         double scheduleVariable = (double) iteration / (double) nOfTotalIterations;
 //		logger.debug("iter={} totalIter={} scheduling={}", iteration, nOfTotalIterations, scheduleVariable);
@@ -97,6 +87,10 @@ private double getThreshold(int iteration) {
         return currentThreshold;
     }
 
+    @Override
+    public String toString() {
+        return "[name=schrimpfAcceptanceFunction][alpha=" + alpha + "][warmup=" + nOfRandomWalks + "]";
+    }
 
     @Override
     public void informAlgorithmStarts(VehicleRoutingProblem problem, VehicleRoutingAlgorithm algorithm, Collection<VehicleRoutingProblemSolution> solutions) {
@@ -107,9 +101,9 @@ public void informAlgorithmStarts(VehicleRoutingProblem problem, VehicleRoutingA
         double now = System.currentTimeMillis();
         this.nOfTotalIterations = algorithm.getMaxIterations();
 
-		/*
+        /*
          * randomWalk to determine standardDev
-		 */
+         */
         final double[] results = new double[nOfRandomWalks];
 
         Jsprit.Builder builder = new GreedySchrimpfFactory().createGreedyAlgorithmBuilder(problem);
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/acceptor/SchrimpfAcceptance.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/acceptor/SchrimpfAcceptance.java
index f104a1cad..edbcf86c8 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/acceptor/SchrimpfAcceptance.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/acceptor/SchrimpfAcceptance.java
@@ -71,15 +71,11 @@
     private static Logger logger = LoggerFactory.getLogger(SchrimpfAcceptance.class.getName());
 
     private final double alpha;
-
+    private final int solutionMemory;
     private int maxIterations = 1000;
-
     private int currentIteration = 0;
-
     private double initialThreshold = 0.0;
 
-    private final int solutionMemory;
-
     public SchrimpfAcceptance(int solutionMemory, double alpha) {
         this.alpha = alpha;
         this.solutionMemory = solutionMemory;
@@ -111,6 +107,11 @@ public boolean acceptSolution(Collection<VehicleRoutingProblemSolution> solution
         return solutionAccepted;
     }
 
+    private double getThreshold(int iteration) {
+        double scheduleVariable = (double) iteration / (double) maxIterations;
+        return initialThreshold * Math.exp(-1. * Math.log(2) * scheduleVariable / alpha);
+    }
+
     public boolean acceptSolution(VehicleRoutingProblemSolution solution, VehicleRoutingProblemSolution newSolution) {
         List<VehicleRoutingProblemSolution> solutions = new ArrayList<>();
         solutions.add(solution);
@@ -142,12 +143,6 @@ public String toString() {
         return "[name=SchrimpfAcceptance][alpha=" + alpha + "]";
     }
 
-    private double getThreshold(int iteration) {
-        double scheduleVariable = (double) iteration / (double) maxIterations;
-        return initialThreshold * Math.exp(-1. * Math.log(2) * scheduleVariable / alpha);
-    }
-
-
     @SuppressWarnings("UnusedDeclaration")
     public double getInitialThreshold() {
         return initialThreshold;
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/acceptor/SchrimpfInitialThresholdGenerator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/acceptor/SchrimpfInitialThresholdGenerator.java
index 5be4180a8..66a6cc3dd 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/acceptor/SchrimpfInitialThresholdGenerator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/acceptor/SchrimpfInitialThresholdGenerator.java
@@ -50,9 +50,9 @@ public void informAlgorithmStarts(VehicleRoutingProblem problem, VehicleRoutingA
         logger.info("prepare schrimpfAcceptanceFunction, i.e. determine initial threshold");
         double now = System.currentTimeMillis();
 
-		/*
+        /*
          * randomWalk to determine standardDev
-		 */
+         */
         final double[] results = new double[nOfRandomWalks];
 
         Jsprit.Builder builder = new GreedySchrimpfFactory().createGreedyAlgorithmBuilder(problem);
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/GreedySchrimpfFactory.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/GreedySchrimpfFactory.java
index 6ac2afba1..c9a49e96b 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/GreedySchrimpfFactory.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/GreedySchrimpfFactory.java
@@ -56,7 +56,7 @@ public VehicleRoutingAlgorithm createAlgorithm(VehicleRoutingProblem vrp) {
         int randomShare = (int) (vrp.getJobs().size() * 0.5);
 
         Jsprit.Builder builder = Jsprit.Builder.newInstance(vrp);
-        builder.setProperty(Jsprit.Parameter.THRESHOLD_ALPHA,"0.0");
+        builder.setProperty(Jsprit.Parameter.THRESHOLD_ALPHA, "0.0");
         builder.setProperty(Jsprit.Strategy.RADIAL_BEST, "0.5");
         builder.setProperty(Jsprit.Strategy.RADIAL_REGRET, "0.0");
         builder.setProperty(Jsprit.Strategy.RANDOM_BEST, "0.5");
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
index 14e33fd3d..3ac726055 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
@@ -54,742 +54,724 @@
 public class Jsprit {
 
     private final ActivityInsertionCostsCalculator activityInsertion;
+    private final Map<SearchStrategy, Double> customStrategies = new HashMap<>();
+    private StateManager stateManager = null;
+    private ConstraintManager constraintManager = null;
+    private ExecutorService es = null;
+    private Integer noThreads;
+    private boolean setupExecutorInternally = false;
+    private boolean addCoreConstraints;
+    private SolutionCostCalculator objectiveFunction = null;
+    private Properties properties;
+    private Random random;
+    private SolutionAcceptor acceptor;
+    private ScoringFunction regretScorer;
+    private VehicleFleetManager vehicleFleetManager;
 
-    public enum Construction {
-
-        BEST_INSERTION("best_insertion"), REGRET_INSERTION("regret_insertion");
+    private Jsprit(Builder builder) {
+        this.stateManager = builder.stateManager;
+        this.constraintManager = builder.constraintManager;
+        this.es = builder.es;
+        this.noThreads = builder.noThreads;
+        this.addCoreConstraints = builder.addConstraints;
+        this.properties = builder.properties;
+        this.objectiveFunction = builder.objectiveFunction;
+        this.random = builder.random;
+        this.activityInsertion = builder.activityInsertionCalculator;
+        this.acceptor = builder.solutionAcceptor;
+        regretScorer = builder.regretScorer;
+        customStrategies.putAll(builder.customStrategies);
+        vehicleFleetManager = builder.fleetManager;
+    }
 
-        String name;
+    public static VehicleRoutingAlgorithm createAlgorithm(VehicleRoutingProblem vehicleRoutingProblem) {
+        return Jsprit.Builder.newInstance(vehicleRoutingProblem).buildAlgorithm();
+    }
 
-        Construction(String name) {
-            this.name = name;
+    private VehicleRoutingAlgorithm create(final VehicleRoutingProblem vrp) {
+        ini(vrp);
+        if (vehicleFleetManager == null) {
+            if (vrp.getFleetSize().equals(VehicleRoutingProblem.FleetSize.INFINITE)) {
+                vehicleFleetManager = new InfiniteFleetManagerFactory(vrp.getVehicles()).createFleetManager();
+            } else {
+                FiniteFleetManagerFactory finiteFleetManagerFactory = new FiniteFleetManagerFactory(vrp.getVehicles());
+                finiteFleetManagerFactory.setRandom(random);
+                vehicleFleetManager = finiteFleetManagerFactory.createFleetManager();
+            }
         }
 
-        public String toString() {
-            return name;
+        if (stateManager == null) {
+            stateManager = new StateManager(vrp);
         }
-
-    }
-
-    public enum Strategy {
-
-        RADIAL_BEST("radial_best"),
-        RADIAL_REGRET("radial_regret"),
-        RANDOM_BEST("random_best"),
-        RANDOM_REGRET("random_regret"),
-        WORST_BEST("worst_best"),
-        WORST_REGRET("worst_regret"),
-        CLUSTER_BEST("cluster_best"),
-        CLUSTER_REGRET("cluster_regret"),
-        STRING_BEST("string_best"),
-        STRING_REGRET("string_regret");
-
-        String strategyName;
-
-        Strategy(String strategyName) {
-            this.strategyName = strategyName;
+        if (constraintManager == null) {
+            constraintManager = new ConstraintManager(vrp, stateManager);
         }
 
-        public String toString() {
-            return strategyName;
+        if (noThreads == null) {
+            noThreads = toInteger(getProperty(Parameter.THREADS.toString()));
+        }
+        if (noThreads > 1) {
+            if (es == null) {
+                setupExecutorInternally = true;
+                es = Executors.newFixedThreadPool(noThreads);
+            }
         }
-    }
-
-    public enum Parameter {
 
-        FIXED_COST_PARAM("fixed_cost_param"), VEHICLE_SWITCH("vehicle_switch"), REGRET_TIME_WINDOW_SCORER("regret.tw_scorer"),
-        REGRET_DISTANCE_SCORER("regret.distance_scorer"), INITIAL_THRESHOLD("initial_threshold"), ITERATIONS("iterations"),
-        THREADS("threads"),
-        RANDOM_REGRET_MIN_SHARE("random_regret.min_share"),
-        RANDOM_REGRET_MAX_SHARE("random_regret.max_share"),
-        RANDOM_BEST_MIN_SHARE("random_best.min_share"),
-        RANDOM_BEST_MAX_SHARE("random_best.max_share"),
-        RADIAL_MIN_SHARE("radial.min_share"),
-        RADIAL_MAX_SHARE("radial.max_share"),
-        CLUSTER_MIN_SHARE("cluster.min_share"),
-        CLUSTER_MAX_SHARE("cluster.max_share"),
-        WORST_MIN_SHARE("worst.min_share"),
-        WORST_MAX_SHARE("worst.max_share"),
-        THRESHOLD_ALPHA("threshold.alpha"),
-        THRESHOLD_INI("threshold.ini"),
-        THRESHOLD_INI_ABS("threshold.ini_abs"),
-        INSERTION_NOISE_LEVEL("insertion.noise_level"),
-        INSERTION_NOISE_PROB("insertion.noise_prob"),
-        RUIN_WORST_NOISE_LEVEL("worst.noise_level"),
-        RUIN_WORST_NOISE_PROB("worst.noise_prob"),
-        FAST_REGRET("regret.fast"),
-        MAX_TRANSPORT_COSTS("max_transport_costs"),
-        CONSTRUCTION("construction"),
-        BREAK_SCHEDULING("break_scheduling"),
-        STRING_K_MIN("string_kmin"),
-        STRING_K_MAX("string_kmax"),
-        STRING_L_MIN("string_lmin"),
-        STRING_L_MAX("string_lmax");
+        double fixedCostParam = toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString()));
+        IncreasingAbsoluteFixedCosts increasingAbsoluteFixedCosts = null;
+        if (fixedCostParam > 0d) {
+            increasingAbsoluteFixedCosts = new IncreasingAbsoluteFixedCosts(vrp.getJobs().size());
+            increasingAbsoluteFixedCosts.setWeightOfFixCost(fixedCostParam);
+            constraintManager.addConstraint(increasingAbsoluteFixedCosts);
+        }
 
+        double noiseLevel = toDouble(getProperty(Parameter.INSERTION_NOISE_LEVEL.toString()));
+        double noiseProbability = toDouble(getProperty(Parameter.INSERTION_NOISE_PROB.toString()));
 
-        String paraName;
+        JobNeighborhoods jobNeighborhoods = new JobNeighborhoodsFactory().createNeighborhoods(vrp, new AvgServiceAndShipmentDistance(vrp.getTransportCosts()), (int) (vrp.getJobs().values().size() * 0.5));
+        jobNeighborhoods.initialise();
 
-        Parameter(String name) {
-            this.paraName = name;
+        final double maxCosts;
+        if (properties.containsKey(Parameter.MAX_TRANSPORT_COSTS.toString())) {
+            maxCosts = Double.parseDouble(getProperty(Parameter.MAX_TRANSPORT_COSTS.toString()));
+        } else {
+            maxCosts = jobNeighborhoods.getMaxDistance();
         }
 
-        public String toString() {
-            return paraName;
+        IterationStartsListener noiseConfigurator;
+        if (noThreads > 1) {
+            ConcurrentInsertionNoiseMaker noiseMaker = new ConcurrentInsertionNoiseMaker(vrp, maxCosts, noiseLevel, noiseProbability);
+            noiseMaker.setRandom(random);
+            constraintManager.addConstraint(noiseMaker);
+            noiseConfigurator = noiseMaker;
+        } else {
+            InsertionNoiseMaker noiseMaker = new InsertionNoiseMaker(vrp, maxCosts, noiseLevel, noiseProbability);
+            noiseMaker.setRandom(random);
+            constraintManager.addConstraint(noiseMaker);
+            noiseConfigurator = noiseMaker;
         }
 
-    }
-
-    public static VehicleRoutingAlgorithm createAlgorithm(VehicleRoutingProblem vehicleRoutingProblem) {
-        return Jsprit.Builder.newInstance(vehicleRoutingProblem).buildAlgorithm();
-    }
-
-    public static class Builder {
+        RuinRadial radial = new RuinRadial(vrp, vrp.getJobs().size(), jobNeighborhoods);
+        radial.setRandom(random);
+        radial.setRuinShareFactory(new RuinShareFactoryImpl(
+            toInteger(properties.getProperty(Parameter.RADIAL_MIN_SHARE.toString())),
+            toInteger(properties.getProperty(Parameter.RADIAL_MAX_SHARE.toString())),
+            random)
+        );
 
-        private VehicleRoutingProblem vrp;
+        final RuinRandom random_for_regret = new RuinRandom(vrp, 0.5);
+        random_for_regret.setRandom(random);
+        random_for_regret.setRuinShareFactory(new RuinShareFactoryImpl(
+            toInteger(properties.getProperty(Parameter.RANDOM_REGRET_MIN_SHARE.toString())),
+            toInteger(properties.getProperty(Parameter.RANDOM_REGRET_MAX_SHARE.toString())),
+            random)
+        );
 
-        private ExecutorService es;
+        final RuinRandom random_for_best = new RuinRandom(vrp, 0.5);
+        random_for_best.setRandom(random);
+        random_for_best.setRuinShareFactory(new RuinShareFactoryImpl(
+            toInteger(properties.getProperty(Parameter.RANDOM_BEST_MIN_SHARE.toString())),
+            toInteger(properties.getProperty(Parameter.RANDOM_BEST_MAX_SHARE.toString())),
+            random)
+        );
 
-        private Integer noThreads;
+        final RuinWorst worst = new RuinWorst(vrp, (int) (vrp.getJobs().values().size() * 0.5));
+        worst.setRandom(random);
+        worst.setRuinShareFactory(new RuinShareFactoryImpl(
+            toInteger(properties.getProperty(Parameter.WORST_MIN_SHARE.toString())),
+            toInteger(properties.getProperty(Parameter.WORST_MAX_SHARE.toString())),
+            random)
+        );
+        IterationStartsListener noise = new IterationStartsListener() {
+            @Override
+            public void informIterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
+                worst.setNoiseMaker(new NoiseMaker() {
 
-        private StateManager stateManager = null;
+                    public double makeNoise() {
+                        if (random.nextDouble() < toDouble(getProperty(Parameter.RUIN_WORST_NOISE_PROB.toString()))) {
+                            return toDouble(getProperty(Parameter.RUIN_WORST_NOISE_LEVEL.toString()))
+                                * maxCosts * random.nextDouble();
+                        } else return 0.;
+                    }
+                });
+            }
+        };
 
-        private ConstraintManager constraintManager = null;
+        final RuinClusters clusters = new RuinClusters(vrp, (int) (vrp.getJobs().values().size() * 0.5), jobNeighborhoods);
+        clusters.setRandom(random);
+        clusters.setRuinShareFactory(new RuinShareFactoryImpl(
+            toInteger(properties.getProperty(Parameter.WORST_MIN_SHARE.toString())),
+            toInteger(properties.getProperty(Parameter.WORST_MAX_SHARE.toString())),
+            random)
+        );
 
-        private SolutionCostCalculator objectiveFunction = null;
+        int kMin = toInteger(properties.getProperty(Parameter.STRING_K_MIN.toString()));
+        int kMax = toInteger(properties.getProperty(Parameter.STRING_K_MAX.toString()));
+        int lMin = toInteger(properties.getProperty(Parameter.STRING_L_MIN.toString()));
+        int lMax = toInteger(properties.getProperty(Parameter.STRING_L_MAX.toString()));
 
-        private Properties properties;
+        final RuinString stringRuin = new RuinString(vrp, jobNeighborhoods);
+        stringRuin.setNoRoutes(kMin, kMax);
+        stringRuin.setStringLength(lMin, lMax);
+        stringRuin.setRandom(random);
 
-        private boolean addConstraints = true;
+        AbstractInsertionStrategy regret;
+        final ScoringFunction scorer;
 
-        private Random random = RandomNumberGeneration.newInstance();
+        boolean fastRegret = Boolean.parseBoolean(getProperty(Parameter.FAST_REGRET.toString()));
+        if (es != null) {
+            if (fastRegret) {
+                RegretInsertionConcurrentFast regretInsertion = (RegretInsertionConcurrentFast) new InsertionBuilder(vrp, vehicleFleetManager, stateManager, constraintManager)
+                    .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
+                    .setConcurrentMode(es, noThreads)
+                    .setFastRegret(true)
+                    .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                    .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                    .setActivityInsertionCostCalculator(activityInsertion)
+                    .build();
+                scorer = regretScorer;
+                regretInsertion.setScoringFunction(scorer);
+                regretInsertion.setDependencyTypes(constraintManager.getDependencyTypes());
+                regret = regretInsertion;
+            } else {
+                RegretInsertionConcurrent regretInsertion = (RegretInsertionConcurrent) new InsertionBuilder(vrp, vehicleFleetManager, stateManager, constraintManager)
+                    .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
+                    .setConcurrentMode(es, noThreads)
+                    .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                    .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                    .setActivityInsertionCostCalculator(activityInsertion)
+                    .build();
+                scorer = regretScorer;
+                regretInsertion.setScoringFunction(scorer);
+                regret = regretInsertion;
+            }
+        } else {
+            if (fastRegret) {
+                RegretInsertionFast regretInsertion = (RegretInsertionFast) new InsertionBuilder(vrp, vehicleFleetManager, stateManager, constraintManager)
+                    .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
+                    .setFastRegret(true)
+                    .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                    .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                    .setActivityInsertionCostCalculator(activityInsertion)
+                    .build();
+                scorer = regretScorer;
+                regretInsertion.setScoringFunction(scorer);
+                regretInsertion.setDependencyTypes(constraintManager.getDependencyTypes());
+                regret = regretInsertion;
+            } else {
+                RegretInsertion regretInsertion = (RegretInsertion) new InsertionBuilder(vrp, vehicleFleetManager, stateManager, constraintManager)
+                    .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
+                    .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                    .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                    .setActivityInsertionCostCalculator(activityInsertion)
+                    .build();
+                scorer = regretScorer;
+                regretInsertion.setScoringFunction(scorer);
+                regret = regretInsertion;
+            }
+        }
+        regret.setRandom(random);
 
-        private ActivityInsertionCostsCalculator activityInsertionCalculator;
-
-        private SolutionAcceptor solutionAcceptor;
-
-        private ScoringFunction regretScorer = null;
-
-        private Map<SearchStrategy, Double> customStrategies = new HashMap<>();
-
-        private VehicleFleetManager fleetManager = null;
-
-        public static Builder newInstance(VehicleRoutingProblem vrp) {
-            return new Builder(vrp);
+        AbstractInsertionStrategy best;
+        if (vrp.getJobs().size() < 250 || es == null) {
+            BestInsertion bestInsertion = (BestInsertion) new InsertionBuilder(vrp, vehicleFleetManager, stateManager, constraintManager)
+                .setInsertionStrategy(InsertionBuilder.Strategy.BEST)
+                .considerFixedCosts(Double.valueOf(properties.getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                .setActivityInsertionCostCalculator(activityInsertion)
+                .build();
+            best = bestInsertion;
+        } else {
+            BestInsertionConcurrent bestInsertion = (BestInsertionConcurrent) new InsertionBuilder(vrp, vehicleFleetManager, stateManager, constraintManager)
+                .setInsertionStrategy(InsertionBuilder.Strategy.BEST)
+                .considerFixedCosts(Double.valueOf(properties.getProperty(Parameter.FIXED_COST_PARAM.toString())))
+                .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
+                .setConcurrentMode(es, noThreads)
+                .setActivityInsertionCostCalculator(activityInsertion)
+                .build();
+            best = bestInsertion;
         }
+        best.setRandom(random);
 
-        private Builder(VehicleRoutingProblem vrp) {
-            this.vrp = vrp;
-            properties = new Properties(createDefaultProperties());
+        IterationStartsListener schrimpfThreshold = null;
+        if (acceptor == null) {
+            final SchrimpfAcceptance schrimpfAcceptance = new SchrimpfAcceptance(1, toDouble(getProperty(Parameter.THRESHOLD_ALPHA.toString())));
+            if (properties.containsKey(Parameter.THRESHOLD_INI_ABS.toString())) {
+                schrimpfAcceptance.setInitialThreshold(Double.valueOf(properties.getProperty(Parameter.THRESHOLD_INI_ABS.toString())));
+            } else {
+                schrimpfThreshold = new IterationStartsListener() {
+                    @Override
+                    public void informIterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
+                        if (i == 1) {
+                            double initialThreshold = Solutions.bestOf(solutions).getCost() * toDouble(getProperty(Parameter.THRESHOLD_INI.toString()));
+                            schrimpfAcceptance.setInitialThreshold(initialThreshold);
+                        }
+                    }
+                };
+            }
+            acceptor = schrimpfAcceptance;
         }
 
-        private Properties createDefaultProperties() {
-            Properties defaults = new Properties();
-            defaults.put(Strategy.RADIAL_BEST.toString(), "0.");
-            defaults.put(Strategy.RADIAL_REGRET.toString(), ".5");
-            defaults.put(Strategy.RANDOM_BEST.toString(), ".5");
-            defaults.put(Strategy.RANDOM_REGRET.toString(), ".5");
-
-            defaults.put(Strategy.STRING_BEST.toString(), "0.0");
-            defaults.put(Strategy.STRING_REGRET.toString(), "0.0");
-
-            defaults.put(Parameter.STRING_K_MIN.toString(), "1");
-            defaults.put(Parameter.STRING_K_MAX.toString(), "6");
-            defaults.put(Parameter.STRING_L_MIN.toString(), "10");
-            defaults.put(Parameter.STRING_L_MAX.toString(), "30");
-
-            defaults.put(Strategy.WORST_BEST.toString(), "0.");
-            defaults.put(Strategy.WORST_REGRET.toString(), "1.");
-            defaults.put(Strategy.CLUSTER_BEST.toString(), "0.");
-            defaults.put(Strategy.CLUSTER_REGRET.toString(), "1.");
-
+        SolutionCostCalculator objectiveFunction = getObjectiveFunction(vrp, maxCosts);
+        SearchStrategy radial_regret = new SearchStrategy(Strategy.RADIAL_REGRET.toString(), new SelectBest(), acceptor, objectiveFunction);
+        radial_regret.addModule(new RuinAndRecreateModule(Strategy.RADIAL_REGRET.toString(), regret, radial));
 
-            defaults.put(Parameter.FIXED_COST_PARAM.toString(), "0.");
-            defaults.put(Parameter.VEHICLE_SWITCH.toString(), "true");
-            defaults.put(Parameter.ITERATIONS.toString(), "2000");
-            defaults.put(Parameter.REGRET_DISTANCE_SCORER.toString(), ".05");
-            defaults.put(Parameter.REGRET_TIME_WINDOW_SCORER.toString(), "-.1");
-            defaults.put(Parameter.THREADS.toString(), "1");
-            int minShare = (int) Math.min(20, Math.max(3, vrp.getJobs().size() * 0.05));
-            int maxShare = (int) Math.min(50, Math.max(5, vrp.getJobs().size() * 0.3));
-            defaults.put(Parameter.RADIAL_MIN_SHARE.toString(), String.valueOf(minShare));
-            defaults.put(Parameter.RADIAL_MAX_SHARE.toString(), String.valueOf(maxShare));
-            defaults.put(Parameter.WORST_MIN_SHARE.toString(), String.valueOf(minShare));
-            defaults.put(Parameter.WORST_MAX_SHARE.toString(), String.valueOf(maxShare));
-            defaults.put(Parameter.CLUSTER_MIN_SHARE.toString(), String.valueOf(minShare));
-            defaults.put(Parameter.CLUSTER_MAX_SHARE.toString(), String.valueOf(maxShare));
-            int minShare_ = (int) Math.min(70, Math.max(5, vrp.getJobs().size() * 0.5));
-            int maxShare_ = (int) Math.min(70, Math.max(5, vrp.getJobs().size() * 0.5));
-            defaults.put(Parameter.RANDOM_REGRET_MIN_SHARE.toString(), String.valueOf(minShare_));
-            defaults.put(Parameter.RANDOM_REGRET_MAX_SHARE.toString(), String.valueOf(maxShare_));
-            defaults.put(Parameter.RANDOM_BEST_MIN_SHARE.toString(), String.valueOf(minShare_));
-            defaults.put(Parameter.RANDOM_BEST_MAX_SHARE.toString(), String.valueOf(maxShare_));
-            defaults.put(Parameter.THRESHOLD_ALPHA.toString(), String.valueOf(0.15));
-            defaults.put(Parameter.THRESHOLD_INI.toString(), String.valueOf(0.03));
-            defaults.put(Parameter.INSERTION_NOISE_LEVEL.toString(), String.valueOf(0.15));
-            defaults.put(Parameter.INSERTION_NOISE_PROB.toString(), String.valueOf(0.2));
-            defaults.put(Parameter.RUIN_WORST_NOISE_LEVEL.toString(), String.valueOf(0.15));
-            defaults.put(Parameter.RUIN_WORST_NOISE_PROB.toString(), String.valueOf(0.2));
-            defaults.put(Parameter.VEHICLE_SWITCH.toString(), String.valueOf(true));
-            defaults.put(Parameter.FAST_REGRET.toString(), String.valueOf(false));
-            defaults.put(Parameter.BREAK_SCHEDULING.toString(), String.valueOf(true));
-            defaults.put(Parameter.CONSTRUCTION.toString(), Construction.REGRET_INSERTION.toString());
-            return defaults;
-        }
+        SearchStrategy radial_best = new SearchStrategy(Strategy.RADIAL_BEST.toString(), new SelectBest(), acceptor, objectiveFunction);
+        radial_best.addModule(new RuinAndRecreateModule(Strategy.RADIAL_BEST.toString(), best, radial));
 
+        SearchStrategy random_best = new SearchStrategy(Strategy.RANDOM_BEST.toString(), new SelectBest(), acceptor, objectiveFunction);
+        random_best.addModule(new RuinAndRecreateModule(Strategy.RANDOM_BEST.toString(), best, random_for_best));
 
-        public Builder addSearchStrategy(SearchStrategy searchStrategy, double weight) {
-            customStrategies.put(searchStrategy, weight);
-            return this;
-        }
+        SearchStrategy random_regret = new SearchStrategy(Strategy.RANDOM_REGRET.toString(), new SelectBest(), acceptor, objectiveFunction);
+        random_regret.addModule(new RuinAndRecreateModule(Strategy.RANDOM_REGRET.toString(), regret, random_for_regret));
 
-        public Builder setVehicleFleetManager(VehicleFleetManager fleetManager) {
-            this.fleetManager = fleetManager;
-            return this;
-        }
+        SearchStrategy worst_regret = new SearchStrategy(Strategy.WORST_REGRET.toString(), new SelectBest(), acceptor, objectiveFunction);
+        worst_regret.addModule(new RuinAndRecreateModule(Strategy.WORST_REGRET.toString(), regret, worst));
 
-        public Builder setExecutorService(ExecutorService es, int noThreads) {
-            this.es = es;
-            this.noThreads = noThreads;
-            return this;
-        }
+        SearchStrategy worst_best = new SearchStrategy(Strategy.WORST_BEST.toString(), new SelectBest(), acceptor, objectiveFunction);
+        worst_best.addModule(new RuinAndRecreateModule(Strategy.WORST_BEST.toString(), best, worst));
 
-        public Builder setCustomAcceptor(SolutionAcceptor acceptor){
-            this.solutionAcceptor = acceptor;
-            return this;
-        }
+        final SearchStrategy clusters_regret = new SearchStrategy(Strategy.CLUSTER_REGRET.toString(), new SelectBest(), acceptor, objectiveFunction);
+        clusters_regret.addModule(new RuinAndRecreateModule(Strategy.CLUSTER_REGRET.toString(), regret, clusters));
 
-        public Builder setRandom(Random random) {
-            this.random = random;
-            return this;
-        }
+        final SearchStrategy clusters_best = new SearchStrategy(Strategy.CLUSTER_BEST.toString(), new SelectBest(), acceptor, objectiveFunction);
+        clusters_best.addModule(new RuinAndRecreateModule(Strategy.CLUSTER_BEST.toString(), best, clusters));
 
-        public Builder setProperty(String key, String value) {
-            properties.put(key, value);
-            return this;
-        }
+        SearchStrategy stringRegret = new SearchStrategy(Strategy.STRING_REGRET.toString(), new SelectBest(), acceptor, objectiveFunction);
+        stringRegret.addModule(new RuinAndRecreateModule(Strategy.STRING_REGRET.toString(), regret, stringRuin));
 
-        public Builder setProperty(Parameter parameter, String value) {
-            setProperty(parameter.toString(), value);
-            return this;
-        }
+        SearchStrategy stringBest = new SearchStrategy(Strategy.STRING_BEST.toString(), new SelectBest(), acceptor, objectiveFunction);
+        stringBest.addModule(new RuinAndRecreateModule(Strategy.STRING_BEST.toString(), best, stringRuin));
 
-        public Builder setProperty(Strategy strategy, String value) {
-            setProperty(strategy.toString(), value);
-            return this;
+        PrettyAlgorithmBuilder prettyBuilder = PrettyAlgorithmBuilder.newInstance(vrp, vehicleFleetManager, stateManager, constraintManager);
+        prettyBuilder.setRandom(random);
+        if (addCoreConstraints) {
+            prettyBuilder.addCoreStateAndConstraintStuff();
         }
+        prettyBuilder.withStrategy(radial_regret, toDouble(getProperty(Strategy.RADIAL_REGRET.toString())))
+            .withStrategy(radial_best, toDouble(getProperty(Strategy.RADIAL_BEST.toString())))
+            .withStrategy(random_best, toDouble(getProperty(Strategy.RANDOM_BEST.toString())))
+            .withStrategy(random_regret, toDouble(getProperty(Strategy.RANDOM_REGRET.toString())))
+            .withStrategy(worst_best, toDouble(getProperty(Strategy.WORST_BEST.toString())))
+            .withStrategy(worst_regret, toDouble(getProperty(Strategy.WORST_REGRET.toString())))
+            .withStrategy(clusters_regret, toDouble(getProperty(Strategy.CLUSTER_REGRET.toString())))
+            .withStrategy(clusters_best, toDouble(getProperty(Strategy.CLUSTER_BEST.toString())))
+            .withStrategy(stringBest, toDouble(getProperty(Strategy.STRING_BEST.toString())))
+            .withStrategy(stringRegret, toDouble(getProperty(Strategy.STRING_REGRET.toString())));
 
-        public Builder setStateAndConstraintManager(StateManager stateManager, ConstraintManager constraintManager) {
-            this.stateManager = stateManager;
-            this.constraintManager = constraintManager;
-            return this;
+        for (SearchStrategy customStrategy : customStrategies.keySet()) {
+            prettyBuilder.withStrategy(customStrategy, customStrategies.get(customStrategy));
         }
 
-        public Builder setObjectiveFunction(SolutionCostCalculator objectiveFunction) {
-            this.objectiveFunction = objectiveFunction;
-            return this;
+        if (getProperty(Parameter.CONSTRUCTION.toString()).equals(Construction.BEST_INSERTION.toString())) {
+            prettyBuilder.constructInitialSolutionWith(best, objectiveFunction);
+        } else {
+            prettyBuilder.constructInitialSolutionWith(regret, objectiveFunction);
         }
+        prettyBuilder.withObjectiveFunction(objectiveFunction);
 
-        public Builder addCoreStateAndConstraintStuff(boolean addConstraints) {
-            this.addConstraints = addConstraints;
-            return this;
-        }
 
-        public Builder setActivityInsertionCalculator(ActivityInsertionCostsCalculator activityInsertionCalculator) {
-            this.activityInsertionCalculator = activityInsertionCalculator;
-            return this;
+        VehicleRoutingAlgorithm vra = prettyBuilder.build();
+        if (schrimpfThreshold != null) {
+            vra.addListener(schrimpfThreshold);
         }
+        vra.addListener(noiseConfigurator);
+        vra.addListener(noise);
+        vra.addListener(clusters);
+        if (increasingAbsoluteFixedCosts != null) vra.addListener(increasingAbsoluteFixedCosts);
 
-        public Builder setRegretScorer(ScoringFunction scoringFunction) {
-            this.regretScorer = scoringFunction;
-            return this;
+        if (toBoolean(getProperty(Parameter.BREAK_SCHEDULING.toString()))) {
+            vra.addListener(new BreakScheduling(vrp, stateManager, constraintManager));
         }
+        handleExecutorShutdown(vra);
+        vra.setMaxIterations(Integer.valueOf(properties.getProperty(Parameter.ITERATIONS.toString())));
 
-        public VehicleRoutingAlgorithm buildAlgorithm() {
-            return new Jsprit(this).create(vrp);
-        }
+        return vra;
 
     }
 
-    static class RuinShareFactoryImpl implements RuinShareFactory
-
-    {
-
-        private int maxShare;
-
-        private int minShare;
-
-        private Random random = RandomNumberGeneration.getRandom();
-
-        public void setRandom(Random random) {
-            this.random = random;
-        }
+    private void ini(VehicleRoutingProblem vrp) {
+        if (regretScorer == null) regretScorer = getRegretScorer(vrp);
+    }
 
-        public RuinShareFactoryImpl(int minShare, int maxShare) {
-            if (maxShare < minShare)
-                throw new IllegalArgumentException("maxShare must be equal or greater than minShare");
-            this.minShare = minShare;
-            this.maxShare = maxShare;
-        }
+    private int toInteger(String string) {
+        return Integer.valueOf(string);
+    }
 
-        public RuinShareFactoryImpl(int minShare, int maxShare, Random random) {
-            if (maxShare < minShare)
-                throw new IllegalArgumentException("maxShare must be equal or greater than minShare");
-            this.minShare = minShare;
-            this.maxShare = maxShare;
-            this.random = random;
-        }
+    String getProperty(String key) {
+        return properties.getProperty(key);
+    }
 
-        @Override
-        public int createNumberToBeRemoved() {
-            return (int) (minShare + (maxShare - minShare) * random.nextDouble());
-        }
+    private double toDouble(String string) {
+        return Double.valueOf(string);
+    }
 
+    private boolean toBoolean(String property) {
+        return Boolean.valueOf(property);
     }
 
-    private StateManager stateManager = null;
+    private SolutionCostCalculator getObjectiveFunction(final VehicleRoutingProblem vrp, final double maxCosts) {
+        if (objectiveFunction != null) return objectiveFunction;
 
-    private ConstraintManager constraintManager = null;
+        SolutionCostCalculator solutionCostCalculator = new SolutionCostCalculator() {
+            @Override
+            public double getCosts(VehicleRoutingProblemSolution solution) {
+                double costs = 0.;
 
-    private ExecutorService es = null;
-
-    private Integer noThreads;
+                for (VehicleRoute route : solution.getRoutes()) {
+                    costs += route.getVehicle().getType().getVehicleCostParams().fix;
+                    boolean hasBreak = false;
+                    TourActivity prevAct = route.getStart();
+                    for (TourActivity act : route.getActivities()) {
+                        if (act instanceof BreakActivity) hasBreak = true;
+                        costs += vrp.getTransportCosts().getTransportCost(prevAct.getLocation(), act.getLocation(), prevAct.getEndTime(), route.getDriver(), route.getVehicle());
+                        costs += vrp.getActivityCosts().getActivityCost(act, act.getArrTime(), route.getDriver(), route.getVehicle());
+                        prevAct = act;
+                    }
+                    costs += vrp.getTransportCosts().getTransportCost(prevAct.getLocation(), route.getEnd().getLocation(), prevAct.getEndTime(), route.getDriver(), route.getVehicle());
+                    if (route.getVehicle().getBreak() != null) {
+                        if (!hasBreak) {
+                            //break defined and required but not assigned penalty
+                            if (route.getEnd().getArrTime() > route.getVehicle().getBreak().getTimeWindow().getEnd()) {
+                                costs += 4 * (maxCosts * 2 + route.getVehicle().getBreak().getServiceDuration() * route.getVehicle().getType().getVehicleCostParams().perServiceTimeUnit);
+                            }
+                        }
+                    }
+                }
+                for (Job j : solution.getUnassignedJobs()) {
+                    costs += maxCosts * 2 * (11 - j.getPriority());
+                }
+                return costs;
+            }
+        };
+        return solutionCostCalculator;
+    }
 
-    private boolean setupExecutorInternally = false;
+    private void handleExecutorShutdown(VehicleRoutingAlgorithm vra) {
+        if (setupExecutorInternally) {
+            final Thread hook = new Thread() {
+                public void run() {
+                    if (!es.isShutdown()) {
+                        System.err.println("shutdownHook shuts down executorService");
+                        es.shutdown();
+                    }
+                }
+            };
+            Runtime.getRuntime().addShutdownHook(hook);
+            vra.addListener(new AlgorithmEndsListener() {
 
-    private boolean addCoreConstraints;
+                @Override
+                public void informAlgorithmEnds(VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
+                    es.shutdown();
+                    Runtime.getRuntime().removeShutdownHook(hook);
+                }
 
-    private SolutionCostCalculator objectiveFunction = null;
+            });
+        }
+//        if (es != null) {
+//
+//            Runtime.getRuntime().addShutdownHook(hook);
+//            vra.addListener(new AlgorithmEndsListener() {
+//                @Override
+//                public void informAlgorithmEnds(VehicleRoutingProblem aProblem,
+//                                                Collection<VehicleRoutingProblemSolution> aSolutions) {
+//                    Runtime.getRuntime().removeShutdownHook(hook);
+//                }
+//            });
+//        }
+    }
 
-    private Properties properties;
+    private DefaultScorer getRegretScorer(VehicleRoutingProblem vrp) {
+        DefaultScorer scorer = new DefaultScorer(vrp);
+        scorer.setTimeWindowParam(Double.valueOf(properties.getProperty(Parameter.REGRET_TIME_WINDOW_SCORER.toString())));
+        scorer.setDepotDistanceParam(Double.valueOf(properties.getProperty(Parameter.REGRET_DISTANCE_SCORER.toString())));
+        return scorer;
+    }
 
-    private Random random;
+    public enum Construction {
 
-    private SolutionAcceptor acceptor;
+        BEST_INSERTION("best_insertion"), REGRET_INSERTION("regret_insertion");
 
-    private ScoringFunction regretScorer;
+        String name;
 
-    private final Map<SearchStrategy, Double> customStrategies = new HashMap<>();
+        Construction(String name) {
+            this.name = name;
+        }
 
-    private VehicleFleetManager vehicleFleetManager;
+        public String toString() {
+            return name;
+        }
 
-    private Jsprit(Builder builder) {
-        this.stateManager = builder.stateManager;
-        this.constraintManager = builder.constraintManager;
-        this.es = builder.es;
-        this.noThreads = builder.noThreads;
-        this.addCoreConstraints = builder.addConstraints;
-        this.properties = builder.properties;
-        this.objectiveFunction = builder.objectiveFunction;
-        this.random = builder.random;
-        this.activityInsertion = builder.activityInsertionCalculator;
-        this.acceptor = builder.solutionAcceptor;
-        regretScorer = builder.regretScorer;
-        customStrategies.putAll(builder.customStrategies);
-        vehicleFleetManager = builder.fleetManager;
     }
 
-    private void ini(VehicleRoutingProblem vrp) {
-        if (regretScorer == null) regretScorer = getRegretScorer(vrp);
-    }
+    public enum Strategy {
 
-    private VehicleRoutingAlgorithm create(final VehicleRoutingProblem vrp) {
-        ini(vrp);
-        if (vehicleFleetManager == null) {
-            if (vrp.getFleetSize().equals(VehicleRoutingProblem.FleetSize.INFINITE)) {
-                vehicleFleetManager = new InfiniteFleetManagerFactory(vrp.getVehicles()).createFleetManager();
-            } else {
-                FiniteFleetManagerFactory finiteFleetManagerFactory = new FiniteFleetManagerFactory(vrp.getVehicles());
-                finiteFleetManagerFactory.setRandom(random);
-                vehicleFleetManager = finiteFleetManagerFactory.createFleetManager();
-            }
-        }
+        RADIAL_BEST("radial_best"),
+        RADIAL_REGRET("radial_regret"),
+        RANDOM_BEST("random_best"),
+        RANDOM_REGRET("random_regret"),
+        WORST_BEST("worst_best"),
+        WORST_REGRET("worst_regret"),
+        CLUSTER_BEST("cluster_best"),
+        CLUSTER_REGRET("cluster_regret"),
+        STRING_BEST("string_best"),
+        STRING_REGRET("string_regret");
 
-        if (stateManager == null) {
-            stateManager = new StateManager(vrp);
-        }
-        if (constraintManager == null) {
-            constraintManager = new ConstraintManager(vrp, stateManager);
-        }
+        String strategyName;
 
-        if (noThreads == null) {
-            noThreads = toInteger(getProperty(Parameter.THREADS.toString()));
-        }
-        if (noThreads > 1) {
-            if (es == null) {
-                setupExecutorInternally = true;
-                es = Executors.newFixedThreadPool(noThreads);
-            }
+        Strategy(String strategyName) {
+            this.strategyName = strategyName;
         }
 
-        double fixedCostParam = toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString()));
-        IncreasingAbsoluteFixedCosts increasingAbsoluteFixedCosts = null;
-        if (fixedCostParam > 0d) {
-            increasingAbsoluteFixedCosts = new IncreasingAbsoluteFixedCosts(vrp.getJobs().size());
-            increasingAbsoluteFixedCosts.setWeightOfFixCost(fixedCostParam);
-            constraintManager.addConstraint(increasingAbsoluteFixedCosts);
+        public String toString() {
+            return strategyName;
         }
+    }
 
-        double noiseLevel = toDouble(getProperty(Parameter.INSERTION_NOISE_LEVEL.toString()));
-        double noiseProbability = toDouble(getProperty(Parameter.INSERTION_NOISE_PROB.toString()));
+    public enum Parameter {
 
-        JobNeighborhoods jobNeighborhoods = new JobNeighborhoodsFactory().createNeighborhoods(vrp, new AvgServiceAndShipmentDistance(vrp.getTransportCosts()), (int) (vrp.getJobs().values().size() * 0.5));
-        jobNeighborhoods.initialise();
+        FIXED_COST_PARAM("fixed_cost_param"), VEHICLE_SWITCH("vehicle_switch"), REGRET_TIME_WINDOW_SCORER("regret.tw_scorer"),
+        REGRET_DISTANCE_SCORER("regret.distance_scorer"), INITIAL_THRESHOLD("initial_threshold"), ITERATIONS("iterations"),
+        THREADS("threads"),
+        RANDOM_REGRET_MIN_SHARE("random_regret.min_share"),
+        RANDOM_REGRET_MAX_SHARE("random_regret.max_share"),
+        RANDOM_BEST_MIN_SHARE("random_best.min_share"),
+        RANDOM_BEST_MAX_SHARE("random_best.max_share"),
+        RADIAL_MIN_SHARE("radial.min_share"),
+        RADIAL_MAX_SHARE("radial.max_share"),
+        CLUSTER_MIN_SHARE("cluster.min_share"),
+        CLUSTER_MAX_SHARE("cluster.max_share"),
+        WORST_MIN_SHARE("worst.min_share"),
+        WORST_MAX_SHARE("worst.max_share"),
+        THRESHOLD_ALPHA("threshold.alpha"),
+        THRESHOLD_INI("threshold.ini"),
+        THRESHOLD_INI_ABS("threshold.ini_abs"),
+        INSERTION_NOISE_LEVEL("insertion.noise_level"),
+        INSERTION_NOISE_PROB("insertion.noise_prob"),
+        RUIN_WORST_NOISE_LEVEL("worst.noise_level"),
+        RUIN_WORST_NOISE_PROB("worst.noise_prob"),
+        FAST_REGRET("regret.fast"),
+        MAX_TRANSPORT_COSTS("max_transport_costs"),
+        CONSTRUCTION("construction"),
+        BREAK_SCHEDULING("break_scheduling"),
+        STRING_K_MIN("string_kmin"),
+        STRING_K_MAX("string_kmax"),
+        STRING_L_MIN("string_lmin"),
+        STRING_L_MAX("string_lmax");
 
-        final double maxCosts;
-        if(properties.containsKey(Parameter.MAX_TRANSPORT_COSTS.toString())){
-            maxCosts = Double.parseDouble(getProperty(Parameter.MAX_TRANSPORT_COSTS.toString()));
-        }
-        else{
-            maxCosts = jobNeighborhoods.getMaxDistance();
+
+        String paraName;
+
+        Parameter(String name) {
+            this.paraName = name;
         }
 
-        IterationStartsListener noiseConfigurator;
-        if (noThreads > 1) {
-            ConcurrentInsertionNoiseMaker noiseMaker = new ConcurrentInsertionNoiseMaker(vrp, maxCosts, noiseLevel, noiseProbability);
-            noiseMaker.setRandom(random);
-            constraintManager.addConstraint(noiseMaker);
-            noiseConfigurator = noiseMaker;
-        } else {
-            InsertionNoiseMaker noiseMaker = new InsertionNoiseMaker(vrp, maxCosts, noiseLevel, noiseProbability);
-            noiseMaker.setRandom(random);
-            constraintManager.addConstraint(noiseMaker);
-            noiseConfigurator = noiseMaker;
+        public String toString() {
+            return paraName;
         }
 
-        RuinRadial radial = new RuinRadial(vrp, vrp.getJobs().size(), jobNeighborhoods);
-        radial.setRandom(random);
-        radial.setRuinShareFactory(new RuinShareFactoryImpl(
-                toInteger(properties.getProperty(Parameter.RADIAL_MIN_SHARE.toString())),
-                toInteger(properties.getProperty(Parameter.RADIAL_MAX_SHARE.toString())),
-                random)
-        );
+    }
 
-        final RuinRandom random_for_regret = new RuinRandom(vrp, 0.5);
-        random_for_regret.setRandom(random);
-        random_for_regret.setRuinShareFactory(new RuinShareFactoryImpl(
-                toInteger(properties.getProperty(Parameter.RANDOM_REGRET_MIN_SHARE.toString())),
-                toInteger(properties.getProperty(Parameter.RANDOM_REGRET_MAX_SHARE.toString())),
-                random)
-        );
+    public static class Builder {
 
-        final RuinRandom random_for_best = new RuinRandom(vrp, 0.5);
-        random_for_best.setRandom(random);
-        random_for_best.setRuinShareFactory(new RuinShareFactoryImpl(
-                toInteger(properties.getProperty(Parameter.RANDOM_BEST_MIN_SHARE.toString())),
-                toInteger(properties.getProperty(Parameter.RANDOM_BEST_MAX_SHARE.toString())),
-                random)
-        );
+        private VehicleRoutingProblem vrp;
 
-        final RuinWorst worst = new RuinWorst(vrp, (int) (vrp.getJobs().values().size() * 0.5));
-        worst.setRandom(random);
-        worst.setRuinShareFactory(new RuinShareFactoryImpl(
-                toInteger(properties.getProperty(Parameter.WORST_MIN_SHARE.toString())),
-                toInteger(properties.getProperty(Parameter.WORST_MAX_SHARE.toString())),
-                random)
-        );
-        IterationStartsListener noise = new IterationStartsListener() {
-            @Override
-            public void informIterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
-                worst.setNoiseMaker(new NoiseMaker() {
+        private ExecutorService es;
 
-                    public double makeNoise() {
-                        if (random.nextDouble() < toDouble(getProperty(Parameter.RUIN_WORST_NOISE_PROB.toString()))) {
-                            return toDouble(getProperty(Parameter.RUIN_WORST_NOISE_LEVEL.toString()))
-                                * maxCosts * random.nextDouble();
-                        } else return 0.;
-                    }
-                });
-            }
-        };
+        private Integer noThreads;
 
-        final RuinClusters clusters = new RuinClusters(vrp, (int) (vrp.getJobs().values().size() * 0.5), jobNeighborhoods);
-        clusters.setRandom(random);
-        clusters.setRuinShareFactory(new RuinShareFactoryImpl(
-                toInteger(properties.getProperty(Parameter.WORST_MIN_SHARE.toString())),
-                toInteger(properties.getProperty(Parameter.WORST_MAX_SHARE.toString())),
-                random)
-        );
+        private StateManager stateManager = null;
 
-        int kMin = toInteger(properties.getProperty(Parameter.STRING_K_MIN.toString()));
-        int kMax = toInteger(properties.getProperty(Parameter.STRING_K_MAX.toString()));
-        int lMin = toInteger(properties.getProperty(Parameter.STRING_L_MIN.toString()));
-        int lMax = toInteger(properties.getProperty(Parameter.STRING_L_MAX.toString()));
+        private ConstraintManager constraintManager = null;
 
-        final RuinString stringRuin = new RuinString(vrp, jobNeighborhoods);
-        stringRuin.setNoRoutes(kMin, kMax);
-        stringRuin.setStringLength(lMin, lMax);
-        stringRuin.setRandom(random);
+        private SolutionCostCalculator objectiveFunction = null;
 
-        AbstractInsertionStrategy regret;
-        final ScoringFunction scorer;
+        private Properties properties;
 
-        boolean fastRegret = Boolean.parseBoolean(getProperty(Parameter.FAST_REGRET.toString()));
-        if (es != null) {
-            if(fastRegret){
-                RegretInsertionConcurrentFast regretInsertion = (RegretInsertionConcurrentFast) new InsertionBuilder(vrp, vehicleFleetManager, stateManager, constraintManager)
-                    .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
-                    .setConcurrentMode(es, noThreads)
-                    .setFastRegret(true)
-                    .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                    .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                    .setActivityInsertionCostCalculator(activityInsertion)
-                    .build();
-                scorer = regretScorer;
-                regretInsertion.setScoringFunction(scorer);
-                regretInsertion.setDependencyTypes(constraintManager.getDependencyTypes());
-                regret = regretInsertion;
-            }
-            else {
-                RegretInsertionConcurrent regretInsertion = (RegretInsertionConcurrent) new InsertionBuilder(vrp, vehicleFleetManager, stateManager, constraintManager)
-                    .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
-                    .setConcurrentMode(es, noThreads)
-                    .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                    .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                    .setActivityInsertionCostCalculator(activityInsertion)
-                    .build();
-                scorer = regretScorer;
-                regretInsertion.setScoringFunction(scorer);
-                regret = regretInsertion;
-            }
-        } else {
-            if(fastRegret) {
-                RegretInsertionFast regretInsertion = (RegretInsertionFast) new InsertionBuilder(vrp, vehicleFleetManager, stateManager, constraintManager)
-                    .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
-                    .setFastRegret(true)
-                    .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                    .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                    .setActivityInsertionCostCalculator(activityInsertion)
-                    .build();
-                scorer = regretScorer;
-                regretInsertion.setScoringFunction(scorer);
-                regretInsertion.setDependencyTypes(constraintManager.getDependencyTypes());
-                regret = regretInsertion;
-            }
-            else{
-                RegretInsertion regretInsertion = (RegretInsertion) new InsertionBuilder(vrp, vehicleFleetManager, stateManager, constraintManager)
-                    .setInsertionStrategy(InsertionBuilder.Strategy.REGRET)
-                    .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                    .considerFixedCosts(toDouble(getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                    .setActivityInsertionCostCalculator(activityInsertion)
-                    .build();
-                scorer = regretScorer;
-                regretInsertion.setScoringFunction(scorer);
-                regret = regretInsertion;
-            }
-        }
-        regret.setRandom(random);
+        private boolean addConstraints = true;
 
-        AbstractInsertionStrategy best;
-        if (vrp.getJobs().size() < 250 || es == null) {
-            BestInsertion bestInsertion = (BestInsertion) new InsertionBuilder(vrp, vehicleFleetManager, stateManager, constraintManager)
-                .setInsertionStrategy(InsertionBuilder.Strategy.BEST)
-                .considerFixedCosts(Double.valueOf(properties.getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                .setActivityInsertionCostCalculator(activityInsertion)
-                .build();
-            best = bestInsertion;
-        } else {
-            BestInsertionConcurrent bestInsertion = (BestInsertionConcurrent) new InsertionBuilder(vrp, vehicleFleetManager, stateManager, constraintManager)
-                .setInsertionStrategy(InsertionBuilder.Strategy.BEST)
-                .considerFixedCosts(Double.valueOf(properties.getProperty(Parameter.FIXED_COST_PARAM.toString())))
-                .setAllowVehicleSwitch(toBoolean(getProperty(Parameter.VEHICLE_SWITCH.toString())))
-                .setConcurrentMode(es, noThreads)
-                .setActivityInsertionCostCalculator(activityInsertion)
-                .build();
-            best = bestInsertion;
-        }
-        best.setRandom(random);
+        private Random random = RandomNumberGeneration.newInstance();
 
-        IterationStartsListener schrimpfThreshold = null;
-        if(acceptor == null) {
-            final SchrimpfAcceptance schrimpfAcceptance = new SchrimpfAcceptance(1, toDouble(getProperty(Parameter.THRESHOLD_ALPHA.toString())));
-            if (properties.containsKey(Parameter.THRESHOLD_INI_ABS.toString())) {
-                schrimpfAcceptance.setInitialThreshold(Double.valueOf(properties.getProperty(Parameter.THRESHOLD_INI_ABS.toString())));
-            } else {
-                schrimpfThreshold = new IterationStartsListener() {
-                    @Override
-                    public void informIterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
-                        if (i == 1) {
-                            double initialThreshold = Solutions.bestOf(solutions).getCost() * toDouble(getProperty(Parameter.THRESHOLD_INI.toString()));
-                            schrimpfAcceptance.setInitialThreshold(initialThreshold);
-                        }
-                    }
-                };
-            }
-            acceptor = schrimpfAcceptance;
+        private ActivityInsertionCostsCalculator activityInsertionCalculator;
+
+        private SolutionAcceptor solutionAcceptor;
+
+        private ScoringFunction regretScorer = null;
+
+        private Map<SearchStrategy, Double> customStrategies = new HashMap<>();
+
+        private VehicleFleetManager fleetManager = null;
+
+        private Builder(VehicleRoutingProblem vrp) {
+            this.vrp = vrp;
+            properties = new Properties(createDefaultProperties());
         }
 
-        SolutionCostCalculator objectiveFunction = getObjectiveFunction(vrp, maxCosts);
-        SearchStrategy radial_regret = new SearchStrategy(Strategy.RADIAL_REGRET.toString(), new SelectBest(), acceptor, objectiveFunction);
-        radial_regret.addModule(new RuinAndRecreateModule(Strategy.RADIAL_REGRET.toString(), regret, radial));
+        private Properties createDefaultProperties() {
+            Properties defaults = new Properties();
+            defaults.put(Strategy.RADIAL_BEST.toString(), "0.");
+            defaults.put(Strategy.RADIAL_REGRET.toString(), ".5");
+            defaults.put(Strategy.RANDOM_BEST.toString(), ".5");
+            defaults.put(Strategy.RANDOM_REGRET.toString(), ".5");
+
+            defaults.put(Strategy.STRING_BEST.toString(), "0.0");
+            defaults.put(Strategy.STRING_REGRET.toString(), "0.0");
+
+            defaults.put(Parameter.STRING_K_MIN.toString(), "1");
+            defaults.put(Parameter.STRING_K_MAX.toString(), "6");
+            defaults.put(Parameter.STRING_L_MIN.toString(), "10");
+            defaults.put(Parameter.STRING_L_MAX.toString(), "30");
 
-        SearchStrategy radial_best = new SearchStrategy(Strategy.RADIAL_BEST.toString(), new SelectBest(), acceptor, objectiveFunction);
-        radial_best.addModule(new RuinAndRecreateModule(Strategy.RADIAL_BEST.toString(), best, radial));
+            defaults.put(Strategy.WORST_BEST.toString(), "0.");
+            defaults.put(Strategy.WORST_REGRET.toString(), "1.");
+            defaults.put(Strategy.CLUSTER_BEST.toString(), "0.");
+            defaults.put(Strategy.CLUSTER_REGRET.toString(), "1.");
 
-        SearchStrategy random_best = new SearchStrategy(Strategy.RANDOM_BEST.toString(), new SelectBest(), acceptor, objectiveFunction);
-        random_best.addModule(new RuinAndRecreateModule(Strategy.RANDOM_BEST.toString(), best, random_for_best));
 
-        SearchStrategy random_regret = new SearchStrategy(Strategy.RANDOM_REGRET.toString(), new SelectBest(), acceptor, objectiveFunction);
-        random_regret.addModule(new RuinAndRecreateModule(Strategy.RANDOM_REGRET.toString(), regret, random_for_regret));
+            defaults.put(Parameter.FIXED_COST_PARAM.toString(), "0.");
+            defaults.put(Parameter.VEHICLE_SWITCH.toString(), "true");
+            defaults.put(Parameter.ITERATIONS.toString(), "2000");
+            defaults.put(Parameter.REGRET_DISTANCE_SCORER.toString(), ".05");
+            defaults.put(Parameter.REGRET_TIME_WINDOW_SCORER.toString(), "-.1");
+            defaults.put(Parameter.THREADS.toString(), "1");
+            int minShare = (int) Math.min(20, Math.max(3, vrp.getJobs().size() * 0.05));
+            int maxShare = (int) Math.min(50, Math.max(5, vrp.getJobs().size() * 0.3));
+            defaults.put(Parameter.RADIAL_MIN_SHARE.toString(), String.valueOf(minShare));
+            defaults.put(Parameter.RADIAL_MAX_SHARE.toString(), String.valueOf(maxShare));
+            defaults.put(Parameter.WORST_MIN_SHARE.toString(), String.valueOf(minShare));
+            defaults.put(Parameter.WORST_MAX_SHARE.toString(), String.valueOf(maxShare));
+            defaults.put(Parameter.CLUSTER_MIN_SHARE.toString(), String.valueOf(minShare));
+            defaults.put(Parameter.CLUSTER_MAX_SHARE.toString(), String.valueOf(maxShare));
+            int minShare_ = (int) Math.min(70, Math.max(5, vrp.getJobs().size() * 0.5));
+            int maxShare_ = (int) Math.min(70, Math.max(5, vrp.getJobs().size() * 0.5));
+            defaults.put(Parameter.RANDOM_REGRET_MIN_SHARE.toString(), String.valueOf(minShare_));
+            defaults.put(Parameter.RANDOM_REGRET_MAX_SHARE.toString(), String.valueOf(maxShare_));
+            defaults.put(Parameter.RANDOM_BEST_MIN_SHARE.toString(), String.valueOf(minShare_));
+            defaults.put(Parameter.RANDOM_BEST_MAX_SHARE.toString(), String.valueOf(maxShare_));
+            defaults.put(Parameter.THRESHOLD_ALPHA.toString(), String.valueOf(0.15));
+            defaults.put(Parameter.THRESHOLD_INI.toString(), String.valueOf(0.03));
+            defaults.put(Parameter.INSERTION_NOISE_LEVEL.toString(), String.valueOf(0.15));
+            defaults.put(Parameter.INSERTION_NOISE_PROB.toString(), String.valueOf(0.2));
+            defaults.put(Parameter.RUIN_WORST_NOISE_LEVEL.toString(), String.valueOf(0.15));
+            defaults.put(Parameter.RUIN_WORST_NOISE_PROB.toString(), String.valueOf(0.2));
+            defaults.put(Parameter.VEHICLE_SWITCH.toString(), String.valueOf(true));
+            defaults.put(Parameter.FAST_REGRET.toString(), String.valueOf(false));
+            defaults.put(Parameter.BREAK_SCHEDULING.toString(), String.valueOf(true));
+            defaults.put(Parameter.CONSTRUCTION.toString(), Construction.REGRET_INSERTION.toString());
+            return defaults;
+        }
 
-        SearchStrategy worst_regret = new SearchStrategy(Strategy.WORST_REGRET.toString(), new SelectBest(), acceptor, objectiveFunction);
-        worst_regret.addModule(new RuinAndRecreateModule(Strategy.WORST_REGRET.toString(), regret, worst));
+        public static Builder newInstance(VehicleRoutingProblem vrp) {
+            return new Builder(vrp);
+        }
 
-        SearchStrategy worst_best = new SearchStrategy(Strategy.WORST_BEST.toString(), new SelectBest(), acceptor, objectiveFunction);
-        worst_best.addModule(new RuinAndRecreateModule(Strategy.WORST_BEST.toString(), best, worst));
+        public Builder addSearchStrategy(SearchStrategy searchStrategy, double weight) {
+            customStrategies.put(searchStrategy, weight);
+            return this;
+        }
 
-        final SearchStrategy clusters_regret = new SearchStrategy(Strategy.CLUSTER_REGRET.toString(), new SelectBest(), acceptor, objectiveFunction);
-        clusters_regret.addModule(new RuinAndRecreateModule(Strategy.CLUSTER_REGRET.toString(), regret, clusters));
+        public Builder setVehicleFleetManager(VehicleFleetManager fleetManager) {
+            this.fleetManager = fleetManager;
+            return this;
+        }
 
-        final SearchStrategy clusters_best = new SearchStrategy(Strategy.CLUSTER_BEST.toString(), new SelectBest(), acceptor, objectiveFunction);
-        clusters_best.addModule(new RuinAndRecreateModule(Strategy.CLUSTER_BEST.toString(), best, clusters));
+        public Builder setExecutorService(ExecutorService es, int noThreads) {
+            this.es = es;
+            this.noThreads = noThreads;
+            return this;
+        }
 
-        SearchStrategy stringRegret = new SearchStrategy(Strategy.STRING_REGRET.toString(), new SelectBest(), acceptor, objectiveFunction);
-        stringRegret.addModule(new RuinAndRecreateModule(Strategy.STRING_REGRET.toString(), regret, stringRuin));
+        public Builder setCustomAcceptor(SolutionAcceptor acceptor) {
+            this.solutionAcceptor = acceptor;
+            return this;
+        }
 
-        SearchStrategy stringBest = new SearchStrategy(Strategy.STRING_BEST.toString(), new SelectBest(), acceptor, objectiveFunction);
-        stringBest.addModule(new RuinAndRecreateModule(Strategy.STRING_BEST.toString(), best, stringRuin));
+        public Builder setRandom(Random random) {
+            this.random = random;
+            return this;
+        }
 
-        PrettyAlgorithmBuilder prettyBuilder = PrettyAlgorithmBuilder.newInstance(vrp, vehicleFleetManager, stateManager, constraintManager);
-        prettyBuilder.setRandom(random);
-        if (addCoreConstraints) {
-            prettyBuilder.addCoreStateAndConstraintStuff();
+        public Builder setProperty(Parameter parameter, String value) {
+            setProperty(parameter.toString(), value);
+            return this;
         }
-        prettyBuilder.withStrategy(radial_regret, toDouble(getProperty(Strategy.RADIAL_REGRET.toString())))
-            .withStrategy(radial_best, toDouble(getProperty(Strategy.RADIAL_BEST.toString())))
-            .withStrategy(random_best, toDouble(getProperty(Strategy.RANDOM_BEST.toString())))
-            .withStrategy(random_regret, toDouble(getProperty(Strategy.RANDOM_REGRET.toString())))
-            .withStrategy(worst_best, toDouble(getProperty(Strategy.WORST_BEST.toString())))
-            .withStrategy(worst_regret, toDouble(getProperty(Strategy.WORST_REGRET.toString())))
-            .withStrategy(clusters_regret, toDouble(getProperty(Strategy.CLUSTER_REGRET.toString())))
-            .withStrategy(clusters_best, toDouble(getProperty(Strategy.CLUSTER_BEST.toString())))
-            .withStrategy(stringBest, toDouble(getProperty(Strategy.STRING_BEST.toString())))
-            .withStrategy(stringRegret, toDouble(getProperty(Strategy.STRING_REGRET.toString())));
 
-        for (SearchStrategy customStrategy : customStrategies.keySet()) {
-            prettyBuilder.withStrategy(customStrategy, customStrategies.get(customStrategy));
+        public Builder setProperty(String key, String value) {
+            properties.put(key, value);
+            return this;
         }
 
-        if (getProperty(Parameter.CONSTRUCTION.toString()).equals(Construction.BEST_INSERTION.toString())) {
-            prettyBuilder.constructInitialSolutionWith(best, objectiveFunction);
-        } else {
-            prettyBuilder.constructInitialSolutionWith(regret, objectiveFunction);
+        public Builder setProperty(Strategy strategy, String value) {
+            setProperty(strategy.toString(), value);
+            return this;
         }
-        prettyBuilder.withObjectiveFunction(objectiveFunction);
 
+        public Builder setStateAndConstraintManager(StateManager stateManager, ConstraintManager constraintManager) {
+            this.stateManager = stateManager;
+            this.constraintManager = constraintManager;
+            return this;
+        }
 
-        VehicleRoutingAlgorithm vra = prettyBuilder.build();
-        if(schrimpfThreshold != null) {
-            vra.addListener(schrimpfThreshold);
+        public Builder setObjectiveFunction(SolutionCostCalculator objectiveFunction) {
+            this.objectiveFunction = objectiveFunction;
+            return this;
         }
-        vra.addListener(noiseConfigurator);
-        vra.addListener(noise);
-        vra.addListener(clusters);
-        if (increasingAbsoluteFixedCosts != null) vra.addListener(increasingAbsoluteFixedCosts);
 
-        if(toBoolean(getProperty(Parameter.BREAK_SCHEDULING.toString()))) {
-            vra.addListener(new BreakScheduling(vrp, stateManager, constraintManager));
+        public Builder addCoreStateAndConstraintStuff(boolean addConstraints) {
+            this.addConstraints = addConstraints;
+            return this;
         }
-        handleExecutorShutdown(vra);
-        vra.setMaxIterations(Integer.valueOf(properties.getProperty(Parameter.ITERATIONS.toString())));
 
-        return vra;
+        public Builder setActivityInsertionCalculator(ActivityInsertionCostsCalculator activityInsertionCalculator) {
+            this.activityInsertionCalculator = activityInsertionCalculator;
+            return this;
+        }
 
-    }
+        public Builder setRegretScorer(ScoringFunction scoringFunction) {
+            this.regretScorer = scoringFunction;
+            return this;
+        }
 
-    private DefaultScorer getRegretScorer(VehicleRoutingProblem vrp) {
-        DefaultScorer scorer = new DefaultScorer(vrp);
-        scorer.setTimeWindowParam(Double.valueOf(properties.getProperty(Parameter.REGRET_TIME_WINDOW_SCORER.toString())));
-        scorer.setDepotDistanceParam(Double.valueOf(properties.getProperty(Parameter.REGRET_DISTANCE_SCORER.toString())));
-        return scorer;
-    }
+        public VehicleRoutingAlgorithm buildAlgorithm() {
+            return new Jsprit(this).create(vrp);
+        }
 
+    }
 
-    private void handleExecutorShutdown(VehicleRoutingAlgorithm vra) {
-        if (setupExecutorInternally) {
-            final Thread hook = new Thread() {
-                public void run() {
-                    if (!es.isShutdown()) {
-                        System.err.println("shutdownHook shuts down executorService");
-                        es.shutdown();
-                    }
-                }
-            };
-            Runtime.getRuntime().addShutdownHook(hook);
-            vra.addListener(new AlgorithmEndsListener() {
+    static class RuinShareFactoryImpl implements RuinShareFactory
 
-                @Override
-                public void informAlgorithmEnds(VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
-                    es.shutdown();
-                    Runtime.getRuntime().removeShutdownHook(hook);
-                }
+    {
 
-            });
-        }
-//        if (es != null) {
-//
-//            Runtime.getRuntime().addShutdownHook(hook);
-//            vra.addListener(new AlgorithmEndsListener() {
-//                @Override
-//                public void informAlgorithmEnds(VehicleRoutingProblem aProblem,
-//                                                Collection<VehicleRoutingProblemSolution> aSolutions) {
-//                    Runtime.getRuntime().removeShutdownHook(hook);
-//                }
-//            });
-//        }
-    }
+        private int maxShare;
 
-    String getProperty(String key) {
-        return properties.getProperty(key);
-    }
+        private int minShare;
 
-    private boolean toBoolean(String property) {
-        return Boolean.valueOf(property);
-    }
+        private Random random = RandomNumberGeneration.getRandom();
 
-    private int toInteger(String string) {
-        return Integer.valueOf(string);
-    }
+        public RuinShareFactoryImpl(int minShare, int maxShare) {
+            if (maxShare < minShare)
+                throw new IllegalArgumentException("maxShare must be equal or greater than minShare");
+            this.minShare = minShare;
+            this.maxShare = maxShare;
+        }
 
-    private double toDouble(String string) {
-        return Double.valueOf(string);
-    }
+        public RuinShareFactoryImpl(int minShare, int maxShare, Random random) {
+            if (maxShare < minShare)
+                throw new IllegalArgumentException("maxShare must be equal or greater than minShare");
+            this.minShare = minShare;
+            this.maxShare = maxShare;
+            this.random = random;
+        }
 
-    private SolutionCostCalculator getObjectiveFunction(final VehicleRoutingProblem vrp, final double maxCosts) {
-        if (objectiveFunction != null) return objectiveFunction;
+        public void setRandom(Random random) {
+            this.random = random;
+        }
 
-        SolutionCostCalculator solutionCostCalculator = new SolutionCostCalculator() {
-            @Override
-            public double getCosts(VehicleRoutingProblemSolution solution) {
-                double costs = 0.;
+        @Override
+        public int createNumberToBeRemoved() {
+            return (int) (minShare + (maxShare - minShare) * random.nextDouble());
+        }
 
-                for (VehicleRoute route : solution.getRoutes()) {
-                    costs += route.getVehicle().getType().getVehicleCostParams().fix;
-                    boolean hasBreak = false;
-                    TourActivity prevAct = route.getStart();
-                    for (TourActivity act : route.getActivities()) {
-                        if (act instanceof BreakActivity) hasBreak = true;
-                        costs += vrp.getTransportCosts().getTransportCost(prevAct.getLocation(), act.getLocation(), prevAct.getEndTime(), route.getDriver(), route.getVehicle());
-                        costs += vrp.getActivityCosts().getActivityCost(act, act.getArrTime(), route.getDriver(), route.getVehicle());
-                        prevAct = act;
-                    }
-                    costs += vrp.getTransportCosts().getTransportCost(prevAct.getLocation(), route.getEnd().getLocation(), prevAct.getEndTime(), route.getDriver(), route.getVehicle());
-                    if (route.getVehicle().getBreak() != null) {
-                        if (!hasBreak) {
-                            //break defined and required but not assigned penalty
-                            if (route.getEnd().getArrTime() > route.getVehicle().getBreak().getTimeWindow().getEnd()) {
-                                costs += 4 * (maxCosts * 2 + route.getVehicle().getBreak().getServiceDuration() * route.getVehicle().getType().getVehicleCostParams().perServiceTimeUnit);
-                            }
-                        }
-                    }
-                }
-                for(Job j : solution.getUnassignedJobs()){
-                    costs += maxCosts * 2 * (11 - j.getPriority());
-                }
-                return costs;
-            }
-        };
-        return solutionCostCalculator;
     }
 
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/SchrimpfFactory.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/SchrimpfFactory.java
index 836b34f15..475d6b261 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/SchrimpfFactory.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/SchrimpfFactory.java
@@ -53,7 +53,7 @@ public VehicleRoutingAlgorithm createAlgorithm(VehicleRoutingProblem vrp) {
         int radialShare = (int) (vrp.getJobs().size() * 0.3);
         int randomShare = (int) (vrp.getJobs().size() * 0.5);
         Jsprit.Builder builder = Jsprit.Builder.newInstance(vrp);
-        builder.setProperty(Jsprit.Parameter.THRESHOLD_ALPHA,"0.0");
+        builder.setProperty(Jsprit.Parameter.THRESHOLD_ALPHA, "0.0");
         builder.setProperty(Jsprit.Strategy.RADIAL_BEST, "0.5");
         builder.setProperty(Jsprit.Strategy.RADIAL_REGRET, "0.0");
         builder.setProperty(Jsprit.Strategy.RANDOM_BEST, "0.5");
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/listener/VehicleRoutingAlgorithmListeners.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/listener/VehicleRoutingAlgorithmListeners.java
index bb4c3cf0d..78a8a5258 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/listener/VehicleRoutingAlgorithmListeners.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/listener/VehicleRoutingAlgorithmListeners.java
@@ -27,32 +27,6 @@
 
 public class VehicleRoutingAlgorithmListeners {
 
-    public static class PrioritizedVRAListener {
-
-        Priority priority;
-        VehicleRoutingAlgorithmListener l;
-
-        public PrioritizedVRAListener(Priority priority, VehicleRoutingAlgorithmListener l) {
-            super();
-            this.priority = priority;
-            this.l = l;
-        }
-
-        public Priority getPriority() {
-            return priority;
-        }
-
-        public VehicleRoutingAlgorithmListener getListener() {
-            return l;
-        }
-
-    }
-
-    public enum Priority {
-        HIGH, MEDIUM, LOW
-    }
-
-
     private TreeSet<PrioritizedVRAListener> algorithmListeners = new TreeSet<PrioritizedVRAListener>(new Comparator<PrioritizedVRAListener>() {
 
         @Override
@@ -71,7 +45,6 @@ public int compare(PrioritizedVRAListener o1, PrioritizedVRAListener o2) {
         }
     });
 
-
     public Collection<VehicleRoutingAlgorithmListener> getAlgorithmListeners() {
         List<VehicleRoutingAlgorithmListener> list = new ArrayList<VehicleRoutingAlgorithmListener>();
         for (PrioritizedVRAListener l : algorithmListeners) {
@@ -87,14 +60,14 @@ public void remove(PrioritizedVRAListener listener) {
         }
     }
 
-    public void addListener(VehicleRoutingAlgorithmListener listener, Priority priority) {
-        algorithmListeners.add(new PrioritizedVRAListener(priority, listener));
-    }
-
     public void addListener(VehicleRoutingAlgorithmListener listener) {
         addListener(listener, Priority.LOW);
     }
 
+    public void addListener(VehicleRoutingAlgorithmListener listener, Priority priority) {
+        algorithmListeners.add(new PrioritizedVRAListener(priority, listener));
+    }
+
     public void algorithmEnds(VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
         for (PrioritizedVRAListener l : algorithmListeners) {
             if (l.getListener() instanceof AlgorithmEndsListener) {
@@ -112,7 +85,6 @@ public void iterationEnds(int i, VehicleRoutingProblem problem, Collection<Vehic
         }
     }
 
-
     public void iterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
         for (PrioritizedVRAListener l : algorithmListeners) {
             if (l.getListener() instanceof IterationStartsListener) {
@@ -121,7 +93,6 @@ public void iterationStarts(int i, VehicleRoutingProblem problem, Collection<Veh
         }
     }
 
-
     public void algorithmStarts(VehicleRoutingProblem problem, VehicleRoutingAlgorithm algorithm, Collection<VehicleRoutingProblemSolution> solutions) {
         for (PrioritizedVRAListener l : algorithmListeners) {
             if (l.getListener() instanceof AlgorithmStartsListener) {
@@ -147,4 +118,29 @@ public void selectedStrategy(SearchStrategy.DiscoveredSolution discoveredSolutio
             }
         }
     }
+
+    public enum Priority {
+        HIGH, MEDIUM, LOW
+    }
+
+    public static class PrioritizedVRAListener {
+
+        Priority priority;
+        VehicleRoutingAlgorithmListener l;
+
+        public PrioritizedVRAListener(Priority priority, VehicleRoutingAlgorithmListener l) {
+            super();
+            this.priority = priority;
+            this.l = l;
+        }
+
+        public Priority getPriority() {
+            return priority;
+        }
+
+        public VehicleRoutingAlgorithmListener getListener() {
+            return l;
+        }
+
+    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AbstractInsertionStrategy.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AbstractInsertionStrategy.java
index 5f5973f5a..082061f2a 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AbstractInsertionStrategy.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AbstractInsertionStrategy.java
@@ -37,44 +37,16 @@
 
 public abstract class AbstractInsertionStrategy implements InsertionStrategy {
 
-    protected class Insertion {
-
-        private final VehicleRoute route;
-
-        private final InsertionData insertionData;
-
-        public Insertion(VehicleRoute vehicleRoute, InsertionData insertionData) {
-            super();
-            this.route = vehicleRoute;
-            this.insertionData = insertionData;
-        }
-
-        public VehicleRoute getRoute() {
-            return route;
-        }
-
-        public InsertionData getInsertionData() {
-            return insertionData;
-        }
-
-    }
-
-    private final static Logger logger = LoggerFactory.getLogger(AbstractInsertionStrategy.class);
-
-    protected Random random = RandomNumberGeneration.getRandom();
-
     protected final static double NO_NEW_DEPARTURE_TIME_YET = -12345.12345;
-
     protected final static Vehicle NO_NEW_VEHICLE_YET = null;
-
     protected final static Driver NO_NEW_DRIVER_YET = null;
-
+    private final static Logger logger = LoggerFactory.getLogger(AbstractInsertionStrategy.class);
+    protected Random random = RandomNumberGeneration.getRandom();
+    protected VehicleRoutingProblem vrp;
     private InsertionListeners insertionsListeners;
 
     private EventListeners eventListeners;
 
-    protected VehicleRoutingProblem vrp;
-
     public AbstractInsertionStrategy(VehicleRoutingProblem vrp) {
         this.insertionsListeners = new InsertionListeners();
         this.vrp = vrp;
@@ -93,12 +65,14 @@ public void setRandom(Random random) {
         return badJobs;
     }
 
-    public void markUnassigned(Job unassigned, List<String> reasons) {
-        insertionsListeners.informJobUnassignedListeners(unassigned, reasons);
-    }
-
     public abstract Collection<Job> insertUnassignedJobs(Collection<VehicleRoute> vehicleRoutes, Collection<Job> unassignedJobs);
 
+    @Override
+    public void addListener(InsertionListener insertionListener) {
+        insertionsListeners.addListener(insertionListener);
+
+    }
+
     @Override
     public void removeListener(InsertionListener insertionListener) {
         insertionsListeners.removeListener(insertionListener);
@@ -109,10 +83,8 @@ public void removeListener(InsertionListener insertionListener) {
         return Collections.unmodifiableCollection(insertionsListeners.getListeners());
     }
 
-    @Override
-    public void addListener(InsertionListener insertionListener) {
-        insertionsListeners.addListener(insertionListener);
-
+    public void markUnassigned(Job unassigned, List<String> reasons) {
+        insertionsListeners.informJobUnassignedListeners(unassigned, reasons);
     }
 
     protected void insertJob(Job unassignedJob, InsertionData iData, VehicleRoute inRoute) {
@@ -127,4 +99,26 @@ protected void insertJob(Job unassignedJob, InsertionData iData, VehicleRoute in
         insertionsListeners.informJobInserted(unassignedJob, inRoute, iData.getInsertionCost(), iData.getAdditionalTime());
     }
 
+    protected class Insertion {
+
+        private final VehicleRoute route;
+
+        private final InsertionData insertionData;
+
+        public Insertion(VehicleRoute vehicleRoute, InsertionData insertionData) {
+            super();
+            this.route = vehicleRoute;
+            this.insertionData = insertionData;
+        }
+
+        public VehicleRoute getRoute() {
+            return route;
+        }
+
+        public InsertionData getInsertionData() {
+            return insertionData;
+        }
+
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ActivityInsertionCostsCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ActivityInsertionCostsCalculator.java
index 2a478a60c..40e756f94 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ActivityInsertionCostsCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ActivityInsertionCostsCalculator.java
@@ -23,6 +23,8 @@
 
 public interface ActivityInsertionCostsCalculator {
 
+    public double getCosts(JobInsertionContext iContext, TourActivity prevAct, TourActivity nextAct, TourActivity newAct, double depTimeAtPrevAct);
+
     public class ActivityInsertionCosts {
 
         private double additionalCosts;
@@ -51,6 +53,4 @@ public double getAdditionalTime() {
 
     }
 
-    public double getCosts(JobInsertionContext iContext, TourActivity prevAct, TourActivity nextAct, TourActivity newAct, double depTimeAtPrevAct);
-
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AuxilliaryCostCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AuxilliaryCostCalculator.java
index 1ec6ad3f0..5389629a9 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AuxilliaryCostCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/AuxilliaryCostCalculator.java
@@ -68,7 +68,7 @@ public double costOfPath(final List<TourActivity> path, final double depTime, fi
             double transportTime = routingCosts.getTransportTime(prevAct.getLocation(), act.getLocation(), departureTimePrevAct, driver, vehicle);
             cost += transportCost;
             double actStartTime = departureTimePrevAct + transportTime;
-            departureTimePrevAct = Math.max(actStartTime, act.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(act,actStartTime,driver,vehicle);
+            departureTimePrevAct = Math.max(actStartTime, act.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(act, actStartTime, driver, vehicle);
             cost += activityCosts.getActivityCost(act, actStartTime, driver, vehicle);
             prevAct = act;
         }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertion.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertion.java
index 576e41f48..9aaa20f5d 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertion.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertion.java
@@ -95,8 +95,7 @@ public String toString() {
             if (bestInsertion == null) {
                 badJobs.add(unassignedJob);
                 markUnassigned(unassignedJob, empty.getFailedConstraintNames());
-            }
-            else insertJob(unassignedJob, bestInsertion.getInsertionData(), bestInsertion.getRoute());
+            } else insertJob(unassignedJob, bestInsertion.getInsertionData(), bestInsertion.getRoute());
         }
         return badJobs;
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertionConcurrent.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertionConcurrent.java
index c7e6ae945..e32b8eee3 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertionConcurrent.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BestInsertionConcurrent.java
@@ -40,47 +40,13 @@
 
 public final class BestInsertionConcurrent extends AbstractInsertionStrategy {
 
-    static class Batch {
-        List<VehicleRoute> routes = new ArrayList<VehicleRoute>();
-
-    }
-
-    class Insertion {
-
-        private final VehicleRoute route;
-
-        private final InsertionData insertionData;
-
-        public Insertion(VehicleRoute vehicleRoute, InsertionData insertionData) {
-            super();
-            this.route = vehicleRoute;
-            this.insertionData = insertionData;
-        }
-
-        public VehicleRoute getRoute() {
-            return route;
-        }
-
-        public InsertionData getInsertionData() {
-            return insertionData;
-        }
-
-    }
-
-    private static Logger logger = LoggerFactory.getLogger(BestInsertionConcurrent.class);
-
     private final static double NO_NEW_DEPARTURE_TIME_YET = -12345.12345;
-
     private final static Vehicle NO_NEW_VEHICLE_YET = null;
-
     private final static Driver NO_NEW_DRIVER_YET = null;
-
+    private static Logger logger = LoggerFactory.getLogger(BestInsertionConcurrent.class);
     private InsertionListeners insertionsListeners;
-
     private JobInsertionCostsCalculator bestInsertionCostCalculator;
-
     private int nuOfBatches;
-
     private ExecutorCompletionService<Insertion> completionService;
 
     public BestInsertionConcurrent(JobInsertionCostsCalculator jobInsertionCalculator, ExecutorService executorService, int nuOfBatches, VehicleRoutingProblem vehicleRoutingProblem) {
@@ -146,39 +112,18 @@ public Insertion call() throws Exception {
             if (bestInsertion == null) {
                 badJobs.add(unassignedJob);
                 markUnassigned(unassignedJob, failedConstraintNames);
-            }
-            else insertJob(unassignedJob, bestInsertion.getInsertionData(), bestInsertion.getRoute());
+            } else insertJob(unassignedJob, bestInsertion.getInsertionData(), bestInsertion.getRoute());
         }
         return badJobs;
     }
 
-
-    private Insertion getBestInsertion(Batch batch, Job unassignedJob) {
-        Insertion bestInsertion = null;
-        InsertionData empty = new InsertionData.NoInsertionFound();
-        double bestInsertionCost = Double.MAX_VALUE;
-        for (VehicleRoute vehicleRoute : batch.routes) {
-            InsertionData iData = bestInsertionCostCalculator.getInsertionData(vehicleRoute, unassignedJob, NO_NEW_VEHICLE_YET, NO_NEW_DEPARTURE_TIME_YET, NO_NEW_DRIVER_YET, bestInsertionCost);
-            if (iData instanceof NoInsertionFound) {
-                empty.getFailedConstraintNames().addAll(iData.getFailedConstraintNames());
-                continue;
-            }
-            if (iData.getInsertionCost() < bestInsertionCost) {
-                bestInsertion = new Insertion(vehicleRoute, iData);
-                bestInsertionCost = iData.getInsertionCost();
-            }
-        }
-        if (bestInsertion == null) return new Insertion(null, empty);
-        return bestInsertion;
-    }
-
     private List<Batch> distributeRoutes(Collection<VehicleRoute> vehicleRoutes, int nuOfBatches) {
         List<Batch> batches = new ArrayList<Batch>();
         for (int i = 0; i < nuOfBatches; i++) batches.add(new Batch());
         /*
          * if route.size < nuOfBatches add as much routes as empty batches are available
-		 * else add one empty route anyway
-		 */
+         * else add one empty route anyway
+         */
         if (vehicleRoutes.size() < nuOfBatches) {
             int nOfNewRoutes = nuOfBatches - vehicleRoutes.size();
             for (int i = 0; i < nOfNewRoutes; i++) {
@@ -189,7 +134,7 @@ private Insertion getBestInsertion(Batch batch, Job unassignedJob) {
         }
         /*
          * distribute routes to batches equally
-		 */
+         */
         int count = 0;
         for (VehicleRoute route : vehicleRoutes) {
             if (count == nuOfBatches) count = 0;
@@ -199,5 +144,51 @@ private Insertion getBestInsertion(Batch batch, Job unassignedJob) {
         return batches;
     }
 
+    private Insertion getBestInsertion(Batch batch, Job unassignedJob) {
+        Insertion bestInsertion = null;
+        InsertionData empty = new InsertionData.NoInsertionFound();
+        double bestInsertionCost = Double.MAX_VALUE;
+        for (VehicleRoute vehicleRoute : batch.routes) {
+            InsertionData iData = bestInsertionCostCalculator.getInsertionData(vehicleRoute, unassignedJob, NO_NEW_VEHICLE_YET, NO_NEW_DEPARTURE_TIME_YET, NO_NEW_DRIVER_YET, bestInsertionCost);
+            if (iData instanceof NoInsertionFound) {
+                empty.getFailedConstraintNames().addAll(iData.getFailedConstraintNames());
+                continue;
+            }
+            if (iData.getInsertionCost() < bestInsertionCost) {
+                bestInsertion = new Insertion(vehicleRoute, iData);
+                bestInsertionCost = iData.getInsertionCost();
+            }
+        }
+        if (bestInsertion == null) return new Insertion(null, empty);
+        return bestInsertion;
+    }
+
+    static class Batch {
+        List<VehicleRoute> routes = new ArrayList<VehicleRoute>();
+
+    }
+
+    class Insertion {
+
+        private final VehicleRoute route;
+
+        private final InsertionData insertionData;
+
+        public Insertion(VehicleRoute vehicleRoute, InsertionData insertionData) {
+            super();
+            this.route = vehicleRoute;
+            this.insertionData = insertionData;
+        }
+
+        public VehicleRoute getRoute() {
+            return route;
+        }
+
+        public InsertionData getInsertionData() {
+            return insertionData;
+        }
+
+    }
+
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BreakInsertionCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BreakInsertionCalculator.java
index f706f4a06..55fd31466 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BreakInsertionCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BreakInsertionCalculator.java
@@ -48,19 +48,12 @@
 final class BreakInsertionCalculator implements JobInsertionCostsCalculator {
 
     private static final Logger logger = LoggerFactory.getLogger(BreakInsertionCalculator.class);
-
+    private final VehicleRoutingActivityCosts activityCosts;
     private HardRouteConstraint hardRouteLevelConstraint;
-
     private HardActivityConstraint hardActivityLevelConstraint;
-
     private SoftRouteConstraint softRouteConstraint;
-
     private SoftActivityConstraint softActivityConstraint;
-
     private VehicleRoutingTransportCosts transportCosts;
-
-    private final VehicleRoutingActivityCosts activityCosts;
-
     private ActivityInsertionCostsCalculator additionalTransportCostsCalculator;
 
     private JobActivityFactory activityFactory;
@@ -165,7 +158,7 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
                 }
             }
             double nextActArrTime = prevActStartTime + transportCosts.getTransportTime(prevAct.getLocation(), nextAct.getLocation(), prevActStartTime, newDriver, newVehicle);
-            prevActStartTime = Math.max(nextActArrTime, nextAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct,nextActArrTime,newDriver,newVehicle);
+            prevActStartTime = Math.max(nextActArrTime, nextAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct, nextActArrTime, newDriver, newVehicle);
             prevAct = nextAct;
             actIndex++;
             if (breakThis) break;
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BreakScheduling.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BreakScheduling.java
index 90a7076f7..39ad4d4ee 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BreakScheduling.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/BreakScheduling.java
@@ -35,7 +35,7 @@
 /**
  * Created by schroeder on 07/04/16.
  */
-public class BreakScheduling implements InsertionStartsListener,JobInsertedListener, RuinListener {
+public class BreakScheduling implements InsertionStartsListener, JobInsertedListener, RuinListener {
 
     private final static Logger logger = LoggerFactory.getLogger(BreakScheduling.class);
 
@@ -49,7 +49,7 @@
 
     public BreakScheduling(VehicleRoutingProblem vrp, StateManager stateManager, ConstraintManager constraintManager) {
         this.stateManager = stateManager;
-        this.breakInsertionCalculator = new BreakInsertionCalculator(vrp.getTransportCosts(),vrp.getActivityCosts(),new LocalActivityInsertionCostsCalculator(vrp.getTransportCosts(),vrp.getActivityCosts(),stateManager),constraintManager);
+        this.breakInsertionCalculator = new BreakInsertionCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(), new LocalActivityInsertionCostsCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(), stateManager), constraintManager);
         this.breakInsertionCalculator.setJobActivityFactory(vrp.getJobActivityFactory());
         eventListeners = new EventListeners();
     }
@@ -57,21 +57,21 @@ public BreakScheduling(VehicleRoutingProblem vrp, StateManager stateManager, Con
     @Override
     public void informJobInserted(Job job2insert, VehicleRoute inRoute, double additionalCosts, double additionalTime) {
         Break aBreak = inRoute.getVehicle().getBreak();
-        if(aBreak != null){
+        if (aBreak != null) {
             boolean removed = inRoute.getTourActivities().removeJob(aBreak);
-            if(removed){
+            if (removed) {
                 logger.trace("ruin: {}", aBreak.getId());
-                stateManager.removed(aBreak,inRoute);
+                stateManager.removed(aBreak, inRoute);
                 stateManager.reCalculateStates(inRoute);
             }
-            if(inRoute.getEnd().getArrTime() > aBreak.getTimeWindow().getEnd()){
+            if (inRoute.getEnd().getArrTime() > aBreak.getTimeWindow().getEnd()) {
                 InsertionData iData = breakInsertionCalculator.getInsertionData(inRoute, aBreak, inRoute.getVehicle(), inRoute.getDepartureTime(), inRoute.getDriver(), Double.MAX_VALUE);
-                if(!(iData instanceof InsertionData.NoInsertionFound)){
+                if (!(iData instanceof InsertionData.NoInsertionFound)) {
                     logger.trace("insert: [jobId={}]{}", aBreak.getId(), iData);
-                    for(Event e : iData.getEvents()){
+                    for (Event e : iData.getEvents()) {
                         eventListeners.inform(e);
                     }
-                    stateManager.informJobInserted(aBreak,inRoute,0,0);
+                    stateManager.informJobInserted(aBreak, inRoute, 0, 0);
                 }
             }
         }
@@ -84,10 +84,10 @@ public void ruinStarts(Collection<VehicleRoute> routes) {
 
     @Override
     public void ruinEnds(Collection<VehicleRoute> routes, Collection<Job> unassignedJobs) {
-        for(VehicleRoute route : routes){
+        for (VehicleRoute route : routes) {
             Break aBreak = route.getVehicle().getBreak();
             boolean removed = route.getTourActivities().removeJob(aBreak);
-            if(removed) logger.trace("ruin: {}", aBreak.getId());
+            if (removed) logger.trace("ruin: {}", aBreak.getId());
         }
         List<Break> breaks = new ArrayList<Break>();
         for (Job j : unassignedJobs) {
@@ -95,27 +95,29 @@ public void ruinEnds(Collection<VehicleRoute> routes, Collection<Job> unassigned
                 breaks.add((Break) j);
             }
         }
-        for(Break b : breaks){ unassignedJobs.remove(b); }
+        for (Break b : breaks) {
+            unassignedJobs.remove(b);
+        }
     }
 
     @Override
     public void removed(Job job, VehicleRoute fromRoute) {
-        if(fromRoute.getVehicle().getBreak() != null) modifiedRoutes.add(fromRoute);
+        if (fromRoute.getVehicle().getBreak() != null) modifiedRoutes.add(fromRoute);
     }
 
     @Override
     public void informInsertionStarts(Collection<VehicleRoute> vehicleRoutes, Collection<Job> unassignedJobs) {
-        for(VehicleRoute route : vehicleRoutes){
+        for (VehicleRoute route : vehicleRoutes) {
             Break aBreak = route.getVehicle().getBreak();
-            if(aBreak != null && !route.getTourActivities().servesJob(aBreak)){
-                if(route.getEnd().getArrTime() > aBreak.getTimeWindow().getEnd()){
+            if (aBreak != null && !route.getTourActivities().servesJob(aBreak)) {
+                if (route.getEnd().getArrTime() > aBreak.getTimeWindow().getEnd()) {
                     InsertionData iData = breakInsertionCalculator.getInsertionData(route, aBreak, route.getVehicle(), route.getDepartureTime(), route.getDriver(), Double.MAX_VALUE);
-                    if(!(iData instanceof InsertionData.NoInsertionFound)){
+                    if (!(iData instanceof InsertionData.NoInsertionFound)) {
                         logger.trace("insert: [jobId={}]{}", aBreak.getId(), iData);
-                        for(Event e : iData.getEvents()){
+                        for (Event e : iData.getEvents()) {
                             eventListeners.inform(e);
                         }
-                        stateManager.informJobInserted(aBreak,route,0,0);
+                        stateManager.informJobInserted(aBreak, route, 0, 0);
                     }
                 }
             }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/CalculatesServiceInsertionWithTimeScheduling.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/CalculatesServiceInsertionWithTimeScheduling.java
index 44401a8b7..6d5782266 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/CalculatesServiceInsertionWithTimeScheduling.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/CalculatesServiceInsertionWithTimeScheduling.java
@@ -36,40 +36,9 @@
 class CalculatesServiceInsertionWithTimeScheduling implements JobInsertionCostsCalculator {
 
 
-    public static class KnowledgeInjection implements InsertionStartsListener {
-        private CalculatesServiceInsertionWithTimeScheduling c;
-
-        public KnowledgeInjection(CalculatesServiceInsertionWithTimeScheduling c) {
-            super();
-            this.c = c;
-        }
-
-        @Override
-        public void informInsertionStarts(Collection<VehicleRoute> vehicleRoutes, Collection<Job> unassignedJobs) {
-            List<Double> knowledge = new ArrayList<Double>();
-            if (vehicleRoutes.isEmpty()) {
-//                System.out.println("hmm");
-            }
-            for (VehicleRoute route : vehicleRoutes) {
-//                if(route.getDepartureTime() == 21600.){
-//                    System.out.println("hu");
-//                }
-                knowledge.add(route.getDepartureTime());
-            }
-            c.setDepartureTimeKnowledge(knowledge);
-        }
-    }
-
     private static Logger log = LoggerFactory.getLogger(CalculatesServiceInsertionWithTimeScheduling.class);
-
     private JobInsertionCostsCalculator jic;
-
     private List<Double> departureTimeKnowledge = new ArrayList<Double>();
-
-    public void setRandom(Random random) {
-        this.random = random;
-    }
-
     private Random random = RandomNumberGeneration.getRandom();
 
     CalculatesServiceInsertionWithTimeScheduling(JobInsertionCostsCalculator jic, double t, double f) {
@@ -78,6 +47,10 @@ public void setRandom(Random random) {
         log.debug("initialise " + this);
     }
 
+    public void setRandom(Random random) {
+        this.random = random;
+    }
+
     @Override
     public String toString() {
         return "[name=" + this.getClass().toString() + "]";
@@ -104,4 +77,28 @@ public InsertionData getInsertionData(VehicleRoute currentRoute, Job jobToInsert
     public void setDepartureTimeKnowledge(List<Double> departureTimes) {
         departureTimeKnowledge = departureTimes;
     }
+
+    public static class KnowledgeInjection implements InsertionStartsListener {
+        private CalculatesServiceInsertionWithTimeScheduling c;
+
+        public KnowledgeInjection(CalculatesServiceInsertionWithTimeScheduling c) {
+            super();
+            this.c = c;
+        }
+
+        @Override
+        public void informInsertionStarts(Collection<VehicleRoute> vehicleRoutes, Collection<Job> unassignedJobs) {
+            List<Double> knowledge = new ArrayList<Double>();
+            if (vehicleRoutes.isEmpty()) {
+//                System.out.println("hmm");
+            }
+            for (VehicleRoute route : vehicleRoutes) {
+//                if(route.getDepartureTime() == 21600.){
+//                    System.out.println("hu");
+//                }
+                knowledge.add(route.getDepartureTime());
+            }
+            c.setDepartureTimeKnowledge(knowledge);
+        }
+    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/DecreasingRelativeFixedCosts.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/DecreasingRelativeFixedCosts.java
index 4f5b67f4c..176bd5079 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/DecreasingRelativeFixedCosts.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/DecreasingRelativeFixedCosts.java
@@ -53,12 +53,6 @@ public String toString() {
         return "[name=DecreasingRelativeFixedCosts][weightOfFixedCostSavings=" + weightDeltaFixCost + "]";
     }
 
-    private Capacity getCurrentMaxLoadInRoute(VehicleRoute route) {
-        Capacity maxLoad = stateGetter.getRouteState(route, InternalStates.MAXLOAD, Capacity.class);
-        if (maxLoad == null) maxLoad = Capacity.Builder.newInstance().build();
-        return maxLoad;
-    }
-
     @Override
     public double getCosts(JobInsertionContext insertionContext) {
         VehicleRoute route = insertionContext.getRoute();
@@ -73,5 +67,11 @@ public double getCosts(JobInsertionContext insertionContext) {
         return weightDeltaFixCost * solutionCompletenessRatio * decreasingRelativeFixedCosts;
     }
 
+    private Capacity getCurrentMaxLoadInRoute(VehicleRoute route) {
+        Capacity maxLoad = stateGetter.getRouteState(route, InternalStates.MAXLOAD, Capacity.class);
+        if (maxLoad == null) maxLoad = Capacity.Builder.newInstance().build();
+        return maxLoad;
+    }
+
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/DefaultScorer.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/DefaultScorer.java
index 280de34d2..6534a85dc 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/DefaultScorer.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/DefaultScorer.java
@@ -27,7 +27,7 @@
 /**
  * Created by schroeder on 15/10/15.
  */
-public class DefaultScorer implements ScoringFunction  {
+public class DefaultScorer implements ScoringFunction {
 
     private VehicleRoutingProblem vrp;
 
@@ -60,6 +60,19 @@ public double score(InsertionData best, Job job) {
         return score;
     }
 
+    private double scoreService(InsertionData best, Job job) {
+        Location location = ((Service) job).getLocation();
+        double maxDepotDistance = 0;
+        if (location != null) {
+            maxDepotDistance = Math.max(
+                getDistance(best.getSelectedVehicle().getStartLocation(), location),
+                getDistance(best.getSelectedVehicle().getEndLocation(), location)
+            );
+        }
+        return Math.max(timeWindowParam * (((Service) job).getTimeWindow().getEnd() - ((Service) job).getTimeWindow().getStart()), minTimeWindowScore) +
+            depotDistanceParam * maxDepotDistance;
+    }
+
     private double scoreShipment(InsertionData best, Job job) {
         Shipment shipment = (Shipment) job;
         double maxDepotDistance_1 = Math.max(
@@ -76,20 +89,6 @@ private double scoreShipment(InsertionData best, Job job) {
         return Math.max(timeWindowParam * minTimeToOperate, minTimeWindowScore) + depotDistanceParam * maxDepotDistance;
     }
 
-    private double scoreService(InsertionData best, Job job) {
-        Location location = ((Service) job).getLocation();
-        double maxDepotDistance = 0;
-        if (location != null) {
-            maxDepotDistance = Math.max(
-                getDistance(best.getSelectedVehicle().getStartLocation(), location),
-                getDistance(best.getSelectedVehicle().getEndLocation(), location)
-            );
-        }
-        return Math.max(timeWindowParam * (((Service) job).getTimeWindow().getEnd() - ((Service) job).getTimeWindow().getStart()), minTimeWindowScore) +
-            depotDistanceParam * maxDepotDistance;
-    }
-
-
     private double getDistance(Location loc1, Location loc2) {
         return vrp.getTransportCosts().getTransportCost(loc1, loc2, 0., null, null);
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/DellAmicoFixCostCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/DellAmicoFixCostCalculator.java
index a08fe6d76..7c870f627 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/DellAmicoFixCostCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/DellAmicoFixCostCalculator.java
@@ -29,11 +29,9 @@
 
 public class DellAmicoFixCostCalculator implements SoftRouteConstraint, InsertionStartsListener, JobInsertedListener {
 
-    private int nuOfJobsToRecreate;
-
     private final IncreasingAbsoluteFixedCosts calculator;
-
     private final int nuOfJobs;
+    private int nuOfJobsToRecreate;
 
     public DellAmicoFixCostCalculator(final int nuOfJobs, final RouteAndActivityStateGetter stateGetter) {
         super();
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/Inserter.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/Inserter.java
index 0a50d6301..687ea7042 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/Inserter.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/Inserter.java
@@ -31,6 +31,32 @@
 
 class Inserter {
 
+    private InsertionListeners insertionListeners;
+    private JobInsertionHandler jobInsertionHandler;
+    private VehicleRoutingProblem vehicleRoutingProblem;
+
+    public Inserter(InsertionListeners insertionListeners, VehicleRoutingProblem vehicleRoutingProblem) {
+        this.insertionListeners = insertionListeners;
+        new DefaultTourActivityFactory();
+        jobInsertionHandler = new ServiceInsertionHandler(vehicleRoutingProblem);
+        jobInsertionHandler.setNextHandler(new ShipmentInsertionHandler(vehicleRoutingProblem));
+    }
+
+    public void insertJob(Job job, InsertionData insertionData, VehicleRoute vehicleRoute) {
+        insertionListeners.informBeforeJobInsertion(job, insertionData, vehicleRoute);
+
+        if (insertionData == null || (insertionData instanceof NoInsertionFound))
+            throw new IllegalStateException("insertionData null. cannot insert job.");
+        if (job == null) throw new IllegalStateException("cannot insert null-job");
+        if (!(vehicleRoute.getVehicle().getId().equals(insertionData.getSelectedVehicle().getId()))) {
+            insertionListeners.informVehicleSwitched(vehicleRoute, vehicleRoute.getVehicle(), insertionData.getSelectedVehicle());
+            vehicleRoute.setVehicleAndDepartureTime(insertionData.getSelectedVehicle(), insertionData.getVehicleDepartureTime());
+        }
+        jobInsertionHandler.handleJobInsertion(job, insertionData, vehicleRoute);
+
+        insertionListeners.informJobInserted(job, vehicleRoute, insertionData.getInsertionCost(), insertionData.getAdditionalTime());
+    }
+
     interface JobInsertionHandler {
 
         void handleJobInsertion(Job job, InsertionData iData, VehicleRoute route);
@@ -127,32 +153,4 @@ public void setNextHandler(JobInsertionHandler jobInsertionHandler) {
         }
 
     }
-
-    private InsertionListeners insertionListeners;
-
-    private JobInsertionHandler jobInsertionHandler;
-
-    private VehicleRoutingProblem vehicleRoutingProblem;
-
-    public Inserter(InsertionListeners insertionListeners, VehicleRoutingProblem vehicleRoutingProblem) {
-        this.insertionListeners = insertionListeners;
-        new DefaultTourActivityFactory();
-        jobInsertionHandler = new ServiceInsertionHandler(vehicleRoutingProblem);
-        jobInsertionHandler.setNextHandler(new ShipmentInsertionHandler(vehicleRoutingProblem));
-    }
-
-    public void insertJob(Job job, InsertionData insertionData, VehicleRoute vehicleRoute) {
-        insertionListeners.informBeforeJobInsertion(job, insertionData, vehicleRoute);
-
-        if (insertionData == null || (insertionData instanceof NoInsertionFound))
-            throw new IllegalStateException("insertionData null. cannot insert job.");
-        if (job == null) throw new IllegalStateException("cannot insert null-job");
-        if (!(vehicleRoute.getVehicle().getId().equals(insertionData.getSelectedVehicle().getId()))) {
-            insertionListeners.informVehicleSwitched(vehicleRoute, vehicleRoute.getVehicle(), insertionData.getSelectedVehicle());
-            vehicleRoute.setVehicleAndDepartureTime(insertionData.getSelectedVehicle(), insertionData.getVehicleDepartureTime());
-        }
-        jobInsertionHandler.handleJobInsertion(job, insertionData, vehicleRoute);
-
-        insertionListeners.informJobInserted(job, vehicleRoute, insertionData.getInsertionCost(), insertionData.getAdditionalTime());
-    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionBuilder.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionBuilder.java
index 98e30be41..c9a960b15 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionBuilder.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionBuilder.java
@@ -32,48 +32,24 @@
 public class InsertionBuilder {
 
     private boolean fastRegret;
-
-
-    public enum Strategy {
-        REGRET, BEST
-    }
-
     private VehicleRoutingProblem vrp;
-
     private StateManager stateManager;
-
     private boolean local = true;
-
     private ConstraintManager constraintManager;
-
     private VehicleFleetManager fleetManager;
-
     private double weightOfFixedCosts;
-
     private boolean considerFixedCosts = false;
-
     private ActivityInsertionCostsCalculator actInsertionCostsCalculator = null;
-
     private int forwaredLooking;
-
     private int memory;
-
     private ExecutorService executor;
-
     private int nuOfThreads;
-
     private double timeSlice;
-
     private int nNeighbors;
-
     private boolean timeScheduling = false;
-
     private boolean allowVehicleSwitch = true;
-
     private boolean addDefaultCostCalc = true;
-
     private Strategy strategy = Strategy.BEST;
-
     private boolean isFastRegret = false;
 
     public InsertionBuilder(VehicleRoutingProblem vrp, VehicleFleetManager vehicleFleetManager, StateManager stateManager, ConstraintManager constraintManager) {
@@ -109,7 +85,6 @@ public InsertionBuilder setFastRegret(boolean fastRegret) {
         return this;
     }
 
-
     public InsertionBuilder setLocalLevel() {
         local = true;
         return this;
@@ -145,7 +120,6 @@ public InsertionBuilder setConcurrentMode(ExecutorService executor, int nuOfThre
         return this;
     }
 
-
     public InsertionStrategy build() {
         List<InsertionListener> iListeners = new ArrayList<InsertionListener>();
         List<VehicleRoutingAlgorithmListeners.PrioritizedVRAListener> algorithmListeners = new ArrayList<VehicleRoutingAlgorithmListeners.PrioritizedVRAListener>();
@@ -178,23 +152,21 @@ public InsertionStrategy build() {
             }
         } else if (strategy.equals(Strategy.REGRET)) {
             if (executor == null) {
-                if(isFastRegret){
+                if (isFastRegret) {
                     RegretInsertionFast regret = new RegretInsertionFast(costCalculator, vrp, fleetManager);
                     regret.setSwitchAllowed(allowVehicleSwitch);
                     insertion = regret;
-                }
-                else {
+                } else {
                     RegretInsertion regret = new RegretInsertion(costCalculator, vrp);
                     insertion = regret;
                 }
 
             } else {
-                if(isFastRegret){
+                if (isFastRegret) {
                     RegretInsertionConcurrentFast regret = new RegretInsertionConcurrentFast(costCalculator, vrp, executor, fleetManager);
                     regret.setSwitchAllowed(allowVehicleSwitch);
                     insertion = regret;
-                }
-                else{
+                } else {
                     RegretInsertionConcurrent regret = new RegretInsertionConcurrent(costCalculator, vrp, executor);
                     insertion = regret;
                 }
@@ -210,5 +182,9 @@ public InsertionBuilder setAllowVehicleSwitch(boolean allowVehicleSwitch) {
         return this;
     }
 
+    public enum Strategy {
+        REGRET, BEST
+    }
+
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionData.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionData.java
index fd78b3e9e..e8467c591 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionData.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionData.java
@@ -32,16 +32,26 @@
 public class InsertionData {
 
 
-    public static class NoInsertionFound extends InsertionData {
-
-        public NoInsertionFound() {
-            super(Double.MAX_VALUE, NO_INDEX, NO_INDEX, null, null);
-        }
+    static int NO_INDEX = -1;
+    private static InsertionData noInsertion = new NoInsertionFound();
+    private final double insertionCost;
+    private final int pickupInsertionIndex;
+    private final int deliveryInsertionIndex;
+    private final Vehicle selectedVehicle;
+    private final Driver selectedDriver;
+    private double departureTime;
+    private double additionalTime;
+    private List<Event> events = new ArrayList<Event>();
+    private List<String> reasons = new ArrayList<>();
 
+    public InsertionData(double insertionCost, int pickupInsertionIndex, int deliveryInsertionIndex, Vehicle vehicle, Driver driver) {
+        this.insertionCost = insertionCost;
+        this.pickupInsertionIndex = pickupInsertionIndex;
+        this.deliveryInsertionIndex = deliveryInsertionIndex;
+        this.selectedVehicle = vehicle;
+        this.selectedDriver = driver;
     }
 
-    private static InsertionData noInsertion = new NoInsertionFound();
-
     /**
      * Returns an instance of InsertionData that represents an EmptyInsertionData (which might indicate
      * that no insertion has been found). It is internally instantiated as follows:<br>
@@ -54,30 +64,10 @@ public static InsertionData createEmptyInsertionData() {
         return noInsertion;
     }
 
-    static int NO_INDEX = -1;
-
-    private final double insertionCost;
-
-    private final int pickupInsertionIndex;
-
-    private final int deliveryInsertionIndex;
-
-    private final Vehicle selectedVehicle;
-
-    private final Driver selectedDriver;
-
-    private double departureTime;
-
-    private double additionalTime;
-
-    private List<Event> events = new ArrayList<Event>();
-
     List<Event> getEvents() {
         return events;
     }
 
-    private List<String> reasons = new ArrayList<>();
-
     /**
      * @return the additionalTime
      */
@@ -85,14 +75,6 @@ public double getAdditionalTime() {
         return additionalTime;
     }
 
-    public void addFailedConstrainName(String name) {
-        reasons.add(name);
-    }
-
-    public List<String> getFailedConstraintNames() {
-        return reasons;
-    }
-
     /**
      * @param additionalTime the additionalTime to set
      */
@@ -100,12 +82,12 @@ public void setAdditionalTime(double additionalTime) {
         this.additionalTime = additionalTime;
     }
 
-    public InsertionData(double insertionCost, int pickupInsertionIndex, int deliveryInsertionIndex, Vehicle vehicle, Driver driver) {
-        this.insertionCost = insertionCost;
-        this.pickupInsertionIndex = pickupInsertionIndex;
-        this.deliveryInsertionIndex = deliveryInsertionIndex;
-        this.selectedVehicle = vehicle;
-        this.selectedDriver = driver;
+    public void addFailedConstrainName(String name) {
+        reasons.add(name);
+    }
+
+    public List<String> getFailedConstraintNames() {
+        return reasons;
     }
 
     @Override
@@ -172,5 +154,13 @@ public void setVehicleDepartureTime(double departureTime) {
         this.departureTime = departureTime;
     }
 
+    public static class NoInsertionFound extends InsertionData {
+
+        public NoInsertionFound() {
+            super(Double.MAX_VALUE, NO_INDEX, NO_INDEX, null, null);
+        }
+
+    }
+
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionDataUpdater.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionDataUpdater.java
index 8d019e2c2..3eca3ac11 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionDataUpdater.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionDataUpdater.java
@@ -32,11 +32,11 @@
 class InsertionDataUpdater {
 
     static boolean update(boolean addAllAvailable, Set<String> initialVehicleIds, VehicleFleetManager fleetManager, JobInsertionCostsCalculator insertionCostsCalculator, TreeSet<VersionedInsertionData> insertionDataSet, int updateRound, Job unassignedJob, Collection<VehicleRoute> routes) {
-        for(VehicleRoute route : routes) {
+        for (VehicleRoute route : routes) {
             Collection<Vehicle> relevantVehicles = new ArrayList<>();
             if (!(route.getVehicle() instanceof VehicleImpl.NoVehicle)) {
                 relevantVehicles.add(route.getVehicle());
-                if(addAllAvailable && !initialVehicleIds.contains(route.getVehicle().getId())){
+                if (addAllAvailable && !initialVehicleIds.contains(route.getVehicle().getId())) {
                     relevantVehicles.addAll(fleetManager.getAvailableVehicles(route.getVehicle()));
                 }
             } else relevantVehicles.addAll(fleetManager.getAvailableVehicles());
@@ -53,19 +53,18 @@ static boolean update(boolean addAllAvailable, Set<String> initialVehicleIds, Ve
     }
 
 
-
     static VehicleRoute findRoute(Collection<VehicleRoute> routes, Job job) {
-        for(VehicleRoute r : routes){
-            if(r.getVehicle().getBreak() == job) return r;
+        for (VehicleRoute r : routes) {
+            if (r.getVehicle().getBreak() == job) return r;
         }
         return null;
     }
 
-    static Comparator<VersionedInsertionData> getComparator(){
+    static Comparator<VersionedInsertionData> getComparator() {
         return new Comparator<VersionedInsertionData>() {
             @Override
             public int compare(VersionedInsertionData o1, VersionedInsertionData o2) {
-                if(o1.getiData().getInsertionCost() < o2.getiData().getInsertionCost()) return -1;
+                if (o1.getiData().getInsertionCost() < o2.getiData().getInsertionCost()) return -1;
                 return 1;
             }
         };
@@ -73,17 +72,17 @@ public int compare(VersionedInsertionData o1, VersionedInsertionData o2) {
 
     static ScoredJob getBest(boolean switchAllowed, Set<String> initialVehicleIds, VehicleFleetManager fleetManager, JobInsertionCostsCalculator insertionCostsCalculator, ScoringFunction scoringFunction, TreeSet<VersionedInsertionData>[] priorityQueues, Map<VehicleRoute, Integer> updates, List<Job> unassignedJobList, List<ScoredJob> badJobs) {
         ScoredJob bestScoredJob = null;
-        for(Job j : unassignedJobList){
+        for (Job j : unassignedJobList) {
             VehicleRoute bestRoute = null;
             InsertionData best = null;
             InsertionData secondBest = null;
             TreeSet<VersionedInsertionData> priorityQueue = priorityQueues[j.getIndex()];
             Iterator<VersionedInsertionData> iterator = priorityQueue.iterator();
             List<String> failedConstraintNames = new ArrayList<>();
-            while(iterator.hasNext()){
+            while (iterator.hasNext()) {
                 VersionedInsertionData versionedIData = iterator.next();
-                if(bestRoute != null){
-                    if(versionedIData.getRoute() == bestRoute){
+                if (bestRoute != null) {
+                    if (versionedIData.getRoute() == bestRoute) {
                         continue;
                     }
                 }
@@ -91,13 +90,13 @@ static ScoredJob getBest(boolean switchAllowed, Set<String> initialVehicleIds, V
                     failedConstraintNames.addAll(versionedIData.getiData().getFailedConstraintNames());
                     continue;
                 }
-                if(!(versionedIData.getRoute().getVehicle() instanceof VehicleImpl.NoVehicle)) {
+                if (!(versionedIData.getRoute().getVehicle() instanceof VehicleImpl.NoVehicle)) {
                     if (versionedIData.getiData().getSelectedVehicle() != versionedIData.getRoute().getVehicle()) {
                         if (!switchAllowed) continue;
                         if (initialVehicleIds.contains(versionedIData.getRoute().getVehicle().getId())) continue;
                     }
                 }
-                if(versionedIData.getiData().getSelectedVehicle() != versionedIData.getRoute().getVehicle()) {
+                if (versionedIData.getiData().getSelectedVehicle() != versionedIData.getRoute().getVehicle()) {
                     if (fleetManager.isLocked(versionedIData.getiData().getSelectedVehicle())) {
                         Vehicle available = fleetManager.getAvailableVehicle(versionedIData.getiData().getSelectedVehicle().getVehicleTypeIdentifier());
                         if (available != null) {
@@ -105,23 +104,21 @@ static ScoredJob getBest(boolean switchAllowed, Set<String> initialVehicleIds, V
                             InsertionData newData = new InsertionData(oldData.getInsertionCost(), oldData.getPickupInsertionIndex(),
                                 oldData.getDeliveryInsertionIndex(), available, oldData.getSelectedDriver());
                             newData.setVehicleDepartureTime(oldData.getVehicleDepartureTime());
-                            for(Event e : oldData.getEvents()){
-                                if(e instanceof SwitchVehicle){
-                                    newData.getEvents().add(new SwitchVehicle(versionedIData.getRoute(),available,oldData.getVehicleDepartureTime()));
-                                }
-                                else newData.getEvents().add(e);
+                            for (Event e : oldData.getEvents()) {
+                                if (e instanceof SwitchVehicle) {
+                                    newData.getEvents().add(new SwitchVehicle(versionedIData.getRoute(), available, oldData.getVehicleDepartureTime()));
+                                } else newData.getEvents().add(e);
                             }
                             versionedIData = new VersionedInsertionData(newData, versionedIData.getVersion(), versionedIData.getRoute());
                         } else continue;
                     }
                 }
                 int currentDataVersion = updates.get(versionedIData.getRoute());
-                if(versionedIData.getVersion() == currentDataVersion){
-                    if(best == null) {
+                if (versionedIData.getVersion() == currentDataVersion) {
+                    if (best == null) {
                         best = versionedIData.getiData();
                         bestRoute = versionedIData.getRoute();
-                    }
-                    else {
+                    } else {
                         secondBest = versionedIData.getiData();
                         break;
                     }
@@ -129,7 +126,7 @@ static ScoredJob getBest(boolean switchAllowed, Set<String> initialVehicleIds, V
             }
             VehicleRoute emptyRoute = VehicleRoute.emptyRoute();
             InsertionData iData = insertionCostsCalculator.getInsertionData(emptyRoute, j, null, -1, null, Double.MAX_VALUE);
-            if(!(iData instanceof InsertionData.NoInsertionFound)){
+            if (!(iData instanceof InsertionData.NoInsertionFound)) {
                 if (best == null) {
                     best = iData;
                     bestRoute = emptyRoute;
@@ -151,10 +148,9 @@ static ScoredJob getBest(boolean switchAllowed, Set<String> initialVehicleIds, V
                 scoredJob = new ScoredJob(j, score, best, bestRoute, true);
             } else scoredJob = new ScoredJob(j, score, best, bestRoute, false);
 
-            if(bestScoredJob == null){
+            if (bestScoredJob == null) {
                 bestScoredJob = scoredJob;
-            }
-            else if(scoredJob.getScore() > bestScoredJob.getScore()){
+            } else if (scoredJob.getScore() > bestScoredJob.getScore()) {
                 bestScoredJob = scoredJob;
             }
         }
@@ -162,7 +158,7 @@ else if(scoredJob.getScore() > bestScoredJob.getScore()){
     }
 
     static double score(Job unassignedJob, InsertionData best, InsertionData secondBest, ScoringFunction scoringFunction) {
-        return Scorer.score(unassignedJob,best,secondBest,scoringFunction);
+        return Scorer.score(unassignedJob, best, secondBest, scoringFunction);
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java
index 1135adb88..c22aa4ec7 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java
@@ -35,63 +35,22 @@
 
 public class JobInsertionCostsCalculatorBuilder {
 
-    private static class CalculatorPlusListeners {
-
-        private JobInsertionCostsCalculator calculator;
-
-        public JobInsertionCostsCalculator getCalculator() {
-            return calculator;
-        }
-
-        private List<PrioritizedVRAListener> algorithmListener = new ArrayList<PrioritizedVRAListener>();
-        private List<InsertionListener> insertionListener = new ArrayList<InsertionListener>();
-
-        public CalculatorPlusListeners(JobInsertionCostsCalculator calculator) {
-            super();
-            this.calculator = calculator;
-        }
-
-        public List<PrioritizedVRAListener> getAlgorithmListener() {
-            return algorithmListener;
-        }
-
-        public List<InsertionListener> getInsertionListener() {
-            return insertionListener;
-        }
-    }
-
     private List<InsertionListener> insertionListeners;
-
     private List<PrioritizedVRAListener> algorithmListeners;
-
     private VehicleRoutingProblem vrp;
-
     private RouteAndActivityStateGetter states;
-
     private boolean local = true;
-
     private int forwardLooking = 0;
-
     private int memory = 1;
-
     private boolean considerFixedCost = false;
-
     private double weightOfFixedCost = 0;
-
     private VehicleFleetManager fleetManager;
-
     private boolean timeScheduling = false;
-
     private double timeSlice;
-
     private int neighbors;
-
     private ConstraintManager constraintManager;
-
     private ActivityInsertionCostsCalculator activityInsertionCostCalculator = null;
-
     private boolean allowVehicleSwitch = true;
-
     private boolean addDefaultCostCalc = true;
 
     /**
@@ -234,29 +193,6 @@ public JobInsertionCostsCalculator build() {
         return createFinalInsertion(fleetManager, baseCalculator, states);
     }
 
-    private void checkServicesOnly() {
-        for (Job j : vrp.getJobs().values()) {
-            if (j instanceof Shipment) {
-                throw new UnsupportedOperationException("currently the 'insert-on-route-level' option is only available for services (i.e. service, pickup, delivery), \n" +
-                    "if you want to deal with shipments switch to option 'local-level' by either setting bestInsertionBuilder.setLocalLevel() or \n"
-                    + "by omitting the xml-tag '<level forwardLooking=2 memory=1>route</level>' when defining your insertionStrategy in algo-config.xml file");
-            }
-        }
-
-    }
-
-    private void addInsertionListeners(List<InsertionListener> list) {
-        for (InsertionListener iL : list) {
-            insertionListeners.add(iL);
-        }
-    }
-
-    private void addAlgorithmListeners(List<PrioritizedVRAListener> list) {
-        for (PrioritizedVRAListener aL : list) {
-            algorithmListeners.add(aL);
-        }
-    }
-
     private CalculatorPlusListeners createStandardLocal(final VehicleRoutingProblem vrp, RouteAndActivityStateGetter statesManager) {
         if (constraintManager == null) throw new IllegalStateException("constraint-manager is null");
 
@@ -287,7 +223,7 @@ public double getCosts(JobInsertionContext iContext, TourActivity prevAct, TourA
             }
 
         };
-        ShipmentInsertionCalculator shipmentInsertion = new ShipmentInsertionCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(),actInsertionCalc, constraintManager);
+        ShipmentInsertionCalculator shipmentInsertion = new ShipmentInsertionCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(), actInsertionCalc, constraintManager);
         shipmentInsertion.setJobActivityFactory(activityFactory);
         ServiceInsertionCalculator serviceInsertion = new ServiceInsertionCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(), actInsertionCalc, constraintManager);
         serviceInsertion.setJobActivityFactory(activityFactory);
@@ -309,6 +245,17 @@ public double getCosts(JobInsertionContext iContext, TourActivity prevAct, TourA
         return calculatorPlusListeners;
     }
 
+    private void checkServicesOnly() {
+        for (Job j : vrp.getJobs().values()) {
+            if (j instanceof Shipment) {
+                throw new UnsupportedOperationException("currently the 'insert-on-route-level' option is only available for services (i.e. service, pickup, delivery), \n" +
+                    "if you want to deal with shipments switch to option 'local-level' by either setting bestInsertionBuilder.setLocalLevel() or \n"
+                    + "by omitting the xml-tag '<level forwardLooking=2 memory=1>route</level>' when defining your insertionStrategy in algo-config.xml file");
+            }
+        }
+
+    }
+
     private CalculatorPlusListeners createStandardRoute(final VehicleRoutingProblem vrp, RouteAndActivityStateGetter activityStates2, int forwardLooking, int solutionMemory) {
         ActivityInsertionCostsCalculator routeLevelCostEstimator;
         if (activityInsertionCostCalculator == null && addDefaultCostCalc) {
@@ -343,6 +290,18 @@ public double getCosts(JobInsertionContext iContext, TourActivity prevAct, TourA
         return new CalculatorPlusListeners(jobInsertionCalculator);
     }
 
+    private void addAlgorithmListeners(List<PrioritizedVRAListener> list) {
+        for (PrioritizedVRAListener aL : list) {
+            algorithmListeners.add(aL);
+        }
+    }
+
+    private void addInsertionListeners(List<InsertionListener> list) {
+        for (InsertionListener iL : list) {
+            insertionListeners.add(iL);
+        }
+    }
+
     private JobInsertionCostsCalculator createFinalInsertion(VehicleFleetManager fleetManager, JobInsertionCostsCalculator baseCalc, RouteAndActivityStateGetter activityStates2) {
         VehicleTypeDependentJobInsertionCalculator vehicleTypeDependentJobInsertionCalculator = new VehicleTypeDependentJobInsertionCalculator(vrp, fleetManager, baseCalc);
         vehicleTypeDependentJobInsertionCalculator.setVehicleSwitchAllowed(allowVehicleSwitch);
@@ -359,6 +318,30 @@ public JobInsertionCostsCalculatorBuilder setAllowVehicleSwitch(boolean allowVeh
         return this;
     }
 
+    private static class CalculatorPlusListeners {
+
+        private JobInsertionCostsCalculator calculator;
+        private List<PrioritizedVRAListener> algorithmListener = new ArrayList<PrioritizedVRAListener>();
+        private List<InsertionListener> insertionListener = new ArrayList<InsertionListener>();
+
+        public CalculatorPlusListeners(JobInsertionCostsCalculator calculator) {
+            super();
+            this.calculator = calculator;
+        }
+
+        public JobInsertionCostsCalculator getCalculator() {
+            return calculator;
+        }
+
+        public List<PrioritizedVRAListener> getAlgorithmListener() {
+            return algorithmListener;
+        }
+
+        public List<InsertionListener> getInsertionListener() {
+            return insertionListener;
+        }
+    }
+
 }
 
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/LocalActivityInsertionCostsCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/LocalActivityInsertionCostsCalculator.java
index 0f91eab1d..78adab683 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/LocalActivityInsertionCostsCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/LocalActivityInsertionCostsCalculator.java
@@ -66,7 +66,8 @@ public double getCosts(JobInsertionContext iFacts, TourActivity prevAct, TourAct
 
         double act_costs_newAct = activityCosts.getActivityCost(newAct, newAct_arrTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
 
-        if (isEnd(nextAct) && !toDepot(iFacts.getNewVehicle())) return tp_costs_prevAct_newAct + solutionCompletenessRatio * activityCostsWeight * act_costs_newAct;
+        if (isEnd(nextAct) && !toDepot(iFacts.getNewVehicle()))
+            return tp_costs_prevAct_newAct + solutionCompletenessRatio * activityCostsWeight * act_costs_newAct;
 
         double tp_costs_newAct_nextAct = routingCosts.getTransportCost(newAct.getLocation(), nextAct.getLocation(), newAct_endTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
         double tp_time_newAct_nextAct = routingCosts.getTransportTime(newAct.getLocation(), nextAct.getLocation(), newAct_endTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
@@ -85,7 +86,7 @@ public double getCosts(JobInsertionContext iFacts, TourActivity prevAct, TourAct
         } else {
             double tp_costs_prevAct_nextAct = routingCosts.getTransportCost(prevAct.getLocation(), nextAct.getLocation(), prevAct.getEndTime(), iFacts.getRoute().getDriver(), iFacts.getRoute().getVehicle());
             double arrTime_nextAct = depTimeAtPrevAct + routingCosts.getTransportTime(prevAct.getLocation(), nextAct.getLocation(), prevAct.getEndTime(), iFacts.getRoute().getDriver(), iFacts.getRoute().getVehicle());
-            double endTime_nextAct_old = Math.max(arrTime_nextAct, nextAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct, arrTime_nextAct, iFacts.getRoute().getDriver(),iFacts.getRoute().getVehicle());
+            double endTime_nextAct_old = Math.max(arrTime_nextAct, nextAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct, arrTime_nextAct, iFacts.getRoute().getDriver(), iFacts.getRoute().getVehicle());
             double actCost_nextAct = activityCosts.getActivityCost(nextAct, arrTime_nextAct, iFacts.getRoute().getDriver(), iFacts.getRoute().getVehicle());
 
             double endTimeDelay_nextAct = Math.max(0, endTime_nextAct_new - endTime_nextAct_old);
@@ -99,14 +100,14 @@ public double getCosts(JobInsertionContext iFacts, TourActivity prevAct, TourAct
         return totalCosts - oldCosts;
     }
 
-    private boolean toDepot(Vehicle newVehicle) {
-        return newVehicle.isReturnToDepot();
-    }
-
     private boolean isEnd(TourActivity nextAct) {
         return nextAct instanceof End;
     }
 
+    private boolean toDepot(Vehicle newVehicle) {
+        return newVehicle.isReturnToDepot();
+    }
+
     public void setSolutionCompletenessRatio(double solutionCompletenessRatio) {
         this.solutionCompletenessRatio = solutionCompletenessRatio;
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/NoSolutionFoundException.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/NoSolutionFoundException.java
index e46506c2b..484272793 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/NoSolutionFoundException.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/NoSolutionFoundException.java
@@ -19,13 +19,13 @@
 
 public class NoSolutionFoundException extends IllegalStateException {
 
-    public NoSolutionFoundException(String errorMsg) {
-        super(errorMsg);
-    }
-
     /**
      *
      */
     private static final long serialVersionUID = 1L;
 
+    public NoSolutionFoundException(String errorMsg) {
+        super(errorMsg);
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertion.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertion.java
index 30a7a98a4..7360efdd2 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertion.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertion.java
@@ -43,7 +43,6 @@
 public class RegretInsertion extends AbstractInsertionStrategy {
 
 
-
     private static Logger logger = LoggerFactory.getLogger(RegretInsertionFast.class);
 
     private ScoringFunction scoringFunction;
@@ -51,17 +50,6 @@
     private JobInsertionCostsCalculator insertionCostsCalculator;
 
 
-    /**
-     * Sets the scoring function.
-     * <p>
-     * <p>By default, the this.TimeWindowScorer is used.
-     *
-     * @param scoringFunction to score
-     */
-    public void setScoringFunction(ScoringFunction scoringFunction) {
-        this.scoringFunction = scoringFunction;
-    }
-
     public RegretInsertion(JobInsertionCostsCalculator jobInsertionCalculator, VehicleRoutingProblem vehicleRoutingProblem) {
         super(vehicleRoutingProblem);
         this.scoringFunction = new DefaultScorer(vehicleRoutingProblem);
@@ -70,11 +58,25 @@ public RegretInsertion(JobInsertionCostsCalculator jobInsertionCalculator, Vehic
         logger.debug("initialise {}", this);
     }
 
+    static double score(Job unassignedJob, InsertionData best, InsertionData secondBest, ScoringFunction scoringFunction) {
+        return Scorer.score(unassignedJob, best, secondBest, scoringFunction);
+    }
+
     @Override
     public String toString() {
         return "[name=regretInsertion][additionalScorer=" + scoringFunction + "]";
     }
 
+    /**
+     * Sets the scoring function.
+     * <p>
+     * <p>By default, the this.TimeWindowScorer is used.
+     *
+     * @param scoringFunction to score
+     */
+    public void setScoringFunction(ScoringFunction scoringFunction) {
+        this.scoringFunction = scoringFunction;
+    }
 
     /**
      * Runs insertion.
@@ -86,14 +88,13 @@ public String toString() {
         List<Job> badJobs = new ArrayList<Job>(unassignedJobs.size());
 
         Iterator<Job> jobIterator = unassignedJobs.iterator();
-        while (jobIterator.hasNext()){
+        while (jobIterator.hasNext()) {
             Job job = jobIterator.next();
-            if(job instanceof Break){
-                VehicleRoute route = findRoute(routes,job);
-                if(route == null){
+            if (job instanceof Break) {
+                VehicleRoute route = findRoute(routes, job);
+                if (route == null) {
                     badJobs.add(job);
-                }
-                else {
+                } else {
                     InsertionData iData = insertionCostsCalculator.getInsertionData(route, job, NO_NEW_VEHICLE_YET, NO_NEW_DEPARTURE_TIME_YET, NO_NEW_DRIVER_YET, Double.MAX_VALUE);
                     if (iData instanceof InsertionData.NoInsertionFound) {
                         badJobs.add(job);
@@ -127,13 +128,6 @@ public String toString() {
         return badJobs;
     }
 
-    private VehicleRoute findRoute(Collection<VehicleRoute> routes, Job job) {
-        for(VehicleRoute r : routes){
-            if(r.getVehicle().getBreak() == job) return r;
-        }
-        return null;
-    }
-
     private ScoredJob nextJob(Collection<VehicleRoute> routes, Collection<Job> unassignedJobList, List<ScoredJob> badJobs) {
         ScoredJob bestScoredJob = null;
         for (Job unassignedJob : unassignedJobList) {
@@ -209,9 +203,11 @@ static ScoredJob getScoredJob(Collection<VehicleRoute> routes, Job unassignedJob
         return scoredJob;
     }
 
-
-    static double score(Job unassignedJob, InsertionData best, InsertionData secondBest, ScoringFunction scoringFunction) {
-        return Scorer.score(unassignedJob,best,secondBest,scoringFunction);
+    private VehicleRoute findRoute(Collection<VehicleRoute> routes, Job job) {
+        for (VehicleRoute r : routes) {
+            if (r.getVehicle().getBreak() == job) return r;
+        }
+        return null;
     }
 
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionConcurrent.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionConcurrent.java
index b71ac5ab7..f9c85df2d 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionConcurrent.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionConcurrent.java
@@ -45,12 +45,18 @@
 
 
     private static Logger logger = LoggerFactory.getLogger(RegretInsertionConcurrentFast.class);
-
-    private ScoringFunction scoringFunction;
-
     private final JobInsertionCostsCalculator insertionCostsCalculator;
-
     private final ExecutorCompletionService<ScoredJob> completionService;
+    private ScoringFunction scoringFunction;
+
+    public RegretInsertionConcurrent(JobInsertionCostsCalculator jobInsertionCalculator, VehicleRoutingProblem vehicleRoutingProblem, ExecutorService executorService) {
+        super(vehicleRoutingProblem);
+        this.scoringFunction = new DefaultScorer(vehicleRoutingProblem);
+        this.insertionCostsCalculator = jobInsertionCalculator;
+        this.vrp = vehicleRoutingProblem;
+        completionService = new ExecutorCompletionService<ScoredJob>(executorService);
+        logger.debug("initialise " + this);
+    }
 
     /**
      * Sets the scoring function.
@@ -63,15 +69,6 @@ public void setScoringFunction(ScoringFunction scoringFunction) {
         this.scoringFunction = scoringFunction;
     }
 
-    public RegretInsertionConcurrent(JobInsertionCostsCalculator jobInsertionCalculator, VehicleRoutingProblem vehicleRoutingProblem, ExecutorService executorService) {
-        super(vehicleRoutingProblem);
-        this.scoringFunction = new DefaultScorer(vehicleRoutingProblem);
-        this.insertionCostsCalculator = jobInsertionCalculator;
-        this.vrp = vehicleRoutingProblem;
-        completionService = new ExecutorCompletionService<ScoredJob>(executorService);
-        logger.debug("initialise " + this);
-    }
-
     @Override
     public String toString() {
         return "[name=regretInsertion][additionalScorer=" + scoringFunction + "]";
@@ -90,14 +87,13 @@ public String toString() {
         List<Job> badJobs = new ArrayList<Job>(unassignedJobs.size());
 
         Iterator<Job> jobIterator = unassignedJobs.iterator();
-        while (jobIterator.hasNext()){
+        while (jobIterator.hasNext()) {
             Job job = jobIterator.next();
-            if(job instanceof Break){
-                VehicleRoute route = findRoute(routes,job);
-                if(route == null){
+            if (job instanceof Break) {
+                VehicleRoute route = findRoute(routes, job);
+                if (route == null) {
                     badJobs.add(job);
-                }
-                else {
+                } else {
                     InsertionData iData = insertionCostsCalculator.getInsertionData(route, job, NO_NEW_VEHICLE_YET, NO_NEW_DEPARTURE_TIME_YET, NO_NEW_DRIVER_YET, Double.MAX_VALUE);
                     if (iData instanceof InsertionData.NoInsertionFound) {
                         badJobs.add(job);
@@ -131,6 +127,13 @@ public String toString() {
         return badJobs;
     }
 
+    private VehicleRoute findRoute(Collection<VehicleRoute> routes, Job job) {
+        for (VehicleRoute r : routes) {
+            if (r.getVehicle().getBreak() == job) return r;
+        }
+        return null;
+    }
+
     private ScoredJob nextJob(final Collection<VehicleRoute> routes, List<Job> unassignedJobList, List<ScoredJob> badJobList) {
         ScoredJob bestScoredJob = null;
 
@@ -172,12 +175,5 @@ public ScoredJob call() throws Exception {
         return bestScoredJob;
     }
 
-    private VehicleRoute findRoute(Collection<VehicleRoute> routes, Job job) {
-        for(VehicleRoute r : routes){
-            if(r.getVehicle().getBreak() == job) return r;
-        }
-        return null;
-    }
-
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionConcurrentFast.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionConcurrentFast.java
index be4f5d118..599729f35 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionConcurrentFast.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionConcurrentFast.java
@@ -45,13 +45,9 @@
 
 
     private static Logger logger = LoggerFactory.getLogger(RegretInsertionConcurrentFast.class);
-
-    private ScoringFunction scoringFunction;
-
     private final JobInsertionCostsCalculator insertionCostsCalculator;
-
     private final ExecutorService executor;
-
+    private ScoringFunction scoringFunction;
     private VehicleFleetManager fleetManager;
 
     private Set<String> initialVehicleIds;
@@ -61,17 +57,6 @@
     private DependencyType[] dependencyTypes = null;
 
 
-    /**
-     * Sets the scoring function.
-     * <p>
-     * <p>By default, the this.TimeWindowScorer is used.
-     *
-     * @param scoringFunction to score
-     */
-    public void setScoringFunction(ScoringFunction scoringFunction) {
-        this.scoringFunction = scoringFunction;
-    }
-
     public RegretInsertionConcurrentFast(JobInsertionCostsCalculator jobInsertionCalculator, VehicleRoutingProblem vehicleRoutingProblem, ExecutorService executorService, VehicleFleetManager fleetManager) {
         super(vehicleRoutingProblem);
         this.scoringFunction = new DefaultScorer(vehicleRoutingProblem);
@@ -83,6 +68,25 @@ public RegretInsertionConcurrentFast(JobInsertionCostsCalculator jobInsertionCal
         logger.debug("initialise " + this);
     }
 
+    private Set<String> getInitialVehicleIds(VehicleRoutingProblem vehicleRoutingProblem) {
+        Set<String> ids = new HashSet<String>();
+        for (VehicleRoute r : vehicleRoutingProblem.getInitialVehicleRoutes()) {
+            ids.add(r.getVehicle().getId());
+        }
+        return ids;
+    }
+
+    /**
+     * Sets the scoring function.
+     * <p>
+     * <p>By default, the this.TimeWindowScorer is used.
+     *
+     * @param scoringFunction to score
+     */
+    public void setScoringFunction(ScoringFunction scoringFunction) {
+        this.scoringFunction = scoringFunction;
+    }
+
     @Override
     public String toString() {
         return "[name=regretInsertion][additionalScorer=" + scoringFunction + "]";
@@ -92,15 +96,7 @@ public void setSwitchAllowed(boolean switchAllowed) {
         this.switchAllowed = switchAllowed;
     }
 
-    private Set<String> getInitialVehicleIds(VehicleRoutingProblem vehicleRoutingProblem) {
-        Set<String> ids = new HashSet<String>();
-        for(VehicleRoute r : vehicleRoutingProblem.getInitialVehicleRoutes()){
-            ids.add(r.getVehicle().getId());
-        }
-        return ids;
-    }
-
-    public void setDependencyTypes(DependencyType[] dependencyTypes){
+    public void setDependencyTypes(DependencyType[] dependencyTypes) {
         this.dependencyTypes = dependencyTypes;
     }
 
@@ -117,14 +113,13 @@ public void setDependencyTypes(DependencyType[] dependencyTypes){
         List<Job> badJobs = new ArrayList<Job>(unassignedJobs.size());
 
         Iterator<Job> jobIterator = unassignedJobs.iterator();
-        while (jobIterator.hasNext()){
+        while (jobIterator.hasNext()) {
             Job job = jobIterator.next();
-            if(job instanceof Break){
+            if (job instanceof Break) {
                 VehicleRoute route = InsertionDataUpdater.findRoute(routes, job);
-                if(route == null){
+                if (route == null) {
                     badJobs.add(job);
-                }
-                else {
+                } else {
                     InsertionData iData = insertionCostsCalculator.getInsertionData(route, job, NO_NEW_VEHICLE_YET, NO_NEW_DEPARTURE_TIME_YET, NO_NEW_DRIVER_YET, Double.MAX_VALUE);
                     if (iData instanceof InsertionData.NoInsertionFound) {
                         badJobs.add(job);
@@ -141,15 +136,15 @@ public void setDependencyTypes(DependencyType[] dependencyTypes){
         VehicleRoute lastModified = null;
         boolean firstRun = true;
         int updateRound = 0;
-        Map<VehicleRoute,Integer> updates = new HashMap<VehicleRoute, Integer>();
+        Map<VehicleRoute, Integer> updates = new HashMap<VehicleRoute, Integer>();
         while (!jobs.isEmpty()) {
             List<Job> unassignedJobList = new ArrayList<>(jobs);
             List<ScoredJob> badJobList = new ArrayList<>();
-            if(!firstRun && lastModified == null) throw new IllegalStateException("ho. this must not be.");
-            updateInsertionData(priorityQueues, routes, unassignedJobList, updateRound,firstRun,lastModified,updates);
-            if(firstRun) firstRun = false;
+            if (!firstRun && lastModified == null) throw new IllegalStateException("ho. this must not be.");
+            updateInsertionData(priorityQueues, routes, unassignedJobList, updateRound, firstRun, lastModified, updates);
+            if (firstRun) firstRun = false;
             updateRound++;
-            ScoredJob bestScoredJob = InsertionDataUpdater.getBest(switchAllowed,initialVehicleIds,fleetManager, insertionCostsCalculator, scoringFunction, priorityQueues, updates, unassignedJobList, badJobList);
+            ScoredJob bestScoredJob = InsertionDataUpdater.getBest(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator, scoringFunction, priorityQueues, updates, unassignedJobList, badJobList);
             if (bestScoredJob != null) {
                 if (bestScoredJob.isNewRoute()) {
                     routes.add(bestScoredJob.getRoute());
@@ -157,8 +152,7 @@ public void setDependencyTypes(DependencyType[] dependencyTypes){
                 insertJob(bestScoredJob.getJob(), bestScoredJob.getInsertionData(), bestScoredJob.getRoute());
                 jobs.remove(bestScoredJob.getJob());
                 lastModified = bestScoredJob.getRoute();
-            }
-            else lastModified = null;
+            } else lastModified = null;
             for (ScoredJob bad : badJobList) {
                 Job unassigned = bad.getJob();
                 jobs.remove(unassigned);
@@ -173,18 +167,16 @@ private void updateInsertionData(final TreeSet<VersionedInsertionData>[] priorit
         List<Callable<Boolean>> tasks = new ArrayList<Callable<Boolean>>();
         boolean updatedAllRoutes = false;
         for (final Job unassignedJob : unassignedJobList) {
-            if(priorityQueues[unassignedJob.getIndex()] == null){
+            if (priorityQueues[unassignedJob.getIndex()] == null) {
                 priorityQueues[unassignedJob.getIndex()] = new TreeSet<>(InsertionDataUpdater.getComparator());
             }
-            if(firstRun) {
+            if (firstRun) {
                 updatedAllRoutes = true;
                 makeCallables(tasks, updatedAllRoutes, priorityQueues[unassignedJob.getIndex()], updateRound, unassignedJob, routes, lastModified);
-            }
-            else{
-                if(dependencyTypes == null || dependencyTypes[unassignedJob.getIndex()] == null){
+            } else {
+                if (dependencyTypes == null || dependencyTypes[unassignedJob.getIndex()] == null) {
                     makeCallables(tasks, updatedAllRoutes, priorityQueues[unassignedJob.getIndex()], updateRound, unassignedJob, routes, lastModified);
-                }
-                else {
+                } else {
                     DependencyType dependencyType = dependencyTypes[unassignedJob.getIndex()];
                     if (dependencyType.equals(DependencyType.INTER_ROUTE) || dependencyType.equals(DependencyType.INTRA_ROUTE)) {
                         updatedAllRoutes = true;
@@ -195,11 +187,10 @@ private void updateInsertionData(final TreeSet<VersionedInsertionData>[] priorit
                 }
             }
         }
-        if(updatedAllRoutes){
-            for(VehicleRoute r : routes) updates.put(r,updateRound);
-        }
-        else{
-            updates.put(lastModified,updateRound);
+        if (updatedAllRoutes) {
+            for (VehicleRoute r : routes) updates.put(r, updateRound);
+        } else {
+            updates.put(lastModified, updateRound);
         }
         try {
             executor.invokeAll(tasks);
@@ -210,15 +201,14 @@ private void updateInsertionData(final TreeSet<VersionedInsertionData>[] priorit
     }
 
     private void makeCallables(List<Callable<Boolean>> tasks, boolean updateAll, final TreeSet<VersionedInsertionData> priorityQueue, final int updateRound, final Job unassignedJob, final Collection<VehicleRoute> routes, final VehicleRoute lastModified) {
-        if(updateAll) {
+        if (updateAll) {
             tasks.add(new Callable<Boolean>() {
                 @Override
                 public Boolean call() throws Exception {
                     return InsertionDataUpdater.update(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator, priorityQueue, updateRound, unassignedJob, routes);
                 }
             });
-        }
-        else {
+        } else {
             tasks.add(new Callable<Boolean>() {
                 @Override
                 public Boolean call() throws Exception {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionFast.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionFast.java
index d805e55d9..1a33e411a 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionFast.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionFast.java
@@ -64,6 +64,14 @@ public RegretInsertionFast(JobInsertionCostsCalculator jobInsertionCalculator, V
         logger.debug("initialise {}", this);
     }
 
+    private Set<String> getInitialVehicleIds(VehicleRoutingProblem vehicleRoutingProblem) {
+        Set<String> ids = new HashSet<String>();
+        for (VehicleRoute r : vehicleRoutingProblem.getInitialVehicleRoutes()) {
+            ids.add(r.getVehicle().getId());
+        }
+        return ids;
+    }
+
     /**
      * Sets the scoring function.
      * <p>
@@ -79,18 +87,10 @@ public void setSwitchAllowed(boolean switchAllowed) {
         this.switchAllowed = switchAllowed;
     }
 
-    public void setDependencyTypes(DependencyType[] dependencyTypes){
+    public void setDependencyTypes(DependencyType[] dependencyTypes) {
         this.dependencyTypes = dependencyTypes;
     }
 
-    private Set<String> getInitialVehicleIds(VehicleRoutingProblem vehicleRoutingProblem) {
-        Set<String> ids = new HashSet<String>();
-        for(VehicleRoute r : vehicleRoutingProblem.getInitialVehicleRoutes()){
-            ids.add(r.getVehicle().getId());
-        }
-        return ids;
-    }
-
     @Override
     public String toString() {
         return "[name=regretInsertion][additionalScorer=" + scoringFunction + "]";
@@ -135,18 +135,18 @@ public String toString() {
         while (!jobs.isEmpty()) {
             List<Job> unassignedJobList = new ArrayList<>(jobs);
             List<ScoredJob> badJobList = new ArrayList<>();
-            if(!firstRun && lastModified == null) throw new IllegalStateException("last modified route is null. this should not be.");
-            if(firstRun){
+            if (!firstRun && lastModified == null)
+                throw new IllegalStateException("last modified route is null. this should not be.");
+            if (firstRun) {
                 updateInsertionData(priorityQueues, routes, unassignedJobList, updateRound, firstRun, lastModified, updates);
                 firstRun = false;
-            }
-            else{
+            } else {
                 //update for all routes || remove history and only update modified route
                 updateInsertionData(priorityQueues, routes, unassignedJobList, updateRound, firstRun, lastModified, updates);
 //                updates.put(lastModified,updateRound);
             }
             updateRound++;
-            ScoredJob bestScoredJob = InsertionDataUpdater.getBest(switchAllowed,initialVehicleIds,fleetManager,insertionCostsCalculator,scoringFunction,priorityQueues,updates,unassignedJobList,badJobList);
+            ScoredJob bestScoredJob = InsertionDataUpdater.getBest(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator, scoringFunction, priorityQueues, updates, unassignedJobList, badJobList);
             if (bestScoredJob != null) {
                 if (bestScoredJob.isNewRoute()) {
                     routes.add(bestScoredJob.getRoute());
@@ -154,8 +154,7 @@ public String toString() {
                 insertJob(bestScoredJob.getJob(), bestScoredJob.getInsertionData(), bestScoredJob.getRoute());
                 jobs.remove(bestScoredJob.getJob());
                 lastModified = bestScoredJob.getRoute();
-            }
-            else lastModified = null;
+            } else lastModified = null;
             for (ScoredJob bad : badJobList) {
                 Job unassigned = bad.getJob();
                 jobs.remove(unassigned);
@@ -168,26 +167,24 @@ public String toString() {
 
     private void updateInsertionData(TreeSet<VersionedInsertionData>[] priorityQueues, Collection<VehicleRoute> routes, List<Job> unassignedJobList, int updateRound, boolean firstRun, VehicleRoute lastModified, Map<VehicleRoute, Integer> updates) {
         for (Job unassignedJob : unassignedJobList) {
-            if(priorityQueues[unassignedJob.getIndex()] == null){
+            if (priorityQueues[unassignedJob.getIndex()] == null) {
                 priorityQueues[unassignedJob.getIndex()] = new TreeSet<>(InsertionDataUpdater.getComparator());
             }
-            if(firstRun) {
+            if (firstRun) {
                 InsertionDataUpdater.update(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator, priorityQueues[unassignedJob.getIndex()], updateRound, unassignedJob, routes);
-                for(VehicleRoute r : routes) updates.put(r,updateRound);
-            }
-            else{
-                if(dependencyTypes == null || dependencyTypes[unassignedJob.getIndex()] == null){
+                for (VehicleRoute r : routes) updates.put(r, updateRound);
+            } else {
+                if (dependencyTypes == null || dependencyTypes[unassignedJob.getIndex()] == null) {
                     InsertionDataUpdater.update(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator, priorityQueues[unassignedJob.getIndex()], updateRound, unassignedJob, Arrays.asList(lastModified));
-                    updates.put(lastModified,updateRound);
-                }
-                else {
+                    updates.put(lastModified, updateRound);
+                } else {
                     DependencyType dependencyType = dependencyTypes[unassignedJob.getIndex()];
                     if (dependencyType.equals(DependencyType.INTER_ROUTE) || dependencyType.equals(DependencyType.INTRA_ROUTE)) {
                         InsertionDataUpdater.update(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator, priorityQueues[unassignedJob.getIndex()], updateRound, unassignedJob, routes);
-                        for(VehicleRoute r : routes) updates.put(r,updateRound);
+                        for (VehicleRoute r : routes) updates.put(r, updateRound);
                     } else {
                         InsertionDataUpdater.update(switchAllowed, initialVehicleIds, fleetManager, insertionCostsCalculator, priorityQueues[unassignedJob.getIndex()], updateRound, unassignedJob, Arrays.asList(lastModified));
-                        updates.put(lastModified,updateRound);
+                        updates.put(lastModified, updateRound);
                     }
                 }
             }
@@ -195,5 +192,4 @@ private void updateInsertionData(TreeSet<VersionedInsertionData>[] priorityQueue
     }
 
 
-
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RouteLevelActivityInsertionCostsEstimator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RouteLevelActivityInsertionCostsEstimator.java
index d6fc01b48..3b775ce2c 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RouteLevelActivityInsertionCostsEstimator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RouteLevelActivityInsertionCostsEstimator.java
@@ -62,24 +62,13 @@ public double getCosts(JobInsertionContext iFacts, TourActivity prevAct, TourAct
             path.addAll(getForwardLookingPath(iFacts.getRoute(), actIndex));
         }
 
-		/*
+        /*
          * calculates the path costs with new vehicle, c(forwardPath,newVehicle).
-		 */
+         */
         double forwardPathCost_newVehicle = auxilliaryPathCostCalculator.costOfPath(path, depTimeAtPrevAct, iFacts.getNewDriver(), iFacts.getNewVehicle());
         return forwardPathCost_newVehicle - (actCostsOld(iFacts.getRoute(), path.get(path.size() - 1)) - actCostsOld(iFacts.getRoute(), prevAct));
     }
 
-    private double actCostsOld(VehicleRoute vehicleRoute, TourActivity act) {
-        Double cost_at_act;
-        if (act instanceof End) {
-            cost_at_act = stateManager.getRouteState(vehicleRoute, InternalStates.COSTS, Double.class);
-        } else {
-            cost_at_act = stateManager.getActivityState(act, InternalStates.COSTS, Double.class);
-        }
-        if (cost_at_act == null) cost_at_act = 0.;
-        return cost_at_act;
-    }
-
     private List<TourActivity> getForwardLookingPath(VehicleRoute route, int actIndex) {
         List<TourActivity> forwardLookingPath = new ArrayList<TourActivity>();
         int nuOfActsInPath = 0;
@@ -95,6 +84,17 @@ private double actCostsOld(VehicleRoute vehicleRoute, TourActivity act) {
         return forwardLookingPath;
     }
 
+    private double actCostsOld(VehicleRoute vehicleRoute, TourActivity act) {
+        Double cost_at_act;
+        if (act instanceof End) {
+            cost_at_act = stateManager.getRouteState(vehicleRoute, InternalStates.COSTS, Double.class);
+        } else {
+            cost_at_act = stateManager.getActivityState(act, InternalStates.COSTS, Double.class);
+        }
+        if (cost_at_act == null) cost_at_act = 0.;
+        return cost_at_act;
+    }
+
     public void setForwardLooking(int nActivities) {
         this.nuOfActivities2LookForward = nActivities;
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ScoredJob.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ScoredJob.java
index f0f8950fa..c1f20e44a 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ScoredJob.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ScoredJob.java
@@ -28,30 +28,12 @@
  */
 class ScoredJob {
 
-    static class BadJob extends ScoredJob {
-
-        BadJob(Job job, List<String> failedConstraintNames) {
-            super(job, 0., getEmptyInsertion(failedConstraintNames), null, false);
-        }
-
-        private static InsertionData getEmptyInsertion(List<String> failedConstraintNames) {
-            InsertionData empty = new InsertionData.NoInsertionFound();
-            empty.getFailedConstraintNames().addAll(failedConstraintNames);
-            return empty;
-        }
-    }
-
     private Job job;
-
     private double score;
-
     private InsertionData insertionData;
-
     private VehicleRoute route;
-
     private boolean newRoute;
 
-
     ScoredJob(Job job, double score, InsertionData insertionData, VehicleRoute route, boolean isNewRoute) {
         this.job = job;
         this.score = score;
@@ -80,4 +62,17 @@ public VehicleRoute getRoute() {
         return route;
     }
 
+    static class BadJob extends ScoredJob {
+
+        BadJob(Job job, List<String> failedConstraintNames) {
+            super(job, 0., getEmptyInsertion(failedConstraintNames), null, false);
+        }
+
+        private static InsertionData getEmptyInsertion(List<String> failedConstraintNames) {
+            InsertionData empty = new InsertionData.NoInsertionFound();
+            empty.getFailedConstraintNames().addAll(failedConstraintNames);
+            return empty;
+        }
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/Scorer.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/Scorer.java
index a6607d26f..9f5a89251 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/Scorer.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/Scorer.java
@@ -25,7 +25,7 @@
  */
 class Scorer {
 
-    static double score(Job unassignedJob, InsertionData best, InsertionData secondBest, ScoringFunction scoringFunction){
+    static double score(Job unassignedJob, InsertionData best, InsertionData secondBest, ScoringFunction scoringFunction) {
         if (best == null) {
             throw new IllegalStateException("cannot insert job " + unassignedJob.getId());
         }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionCalculator.java
index 9f91ff9bf..63f4b4d76 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionCalculator.java
@@ -54,15 +54,10 @@
 //    private HardRouteConstraint hardRouteLevelConstraint;
 
 //    private HardActivityConstraint hardActivityLevelConstraint;
-
+private final VehicleRoutingActivityCosts activityCosts;
     private SoftRouteConstraint softRouteConstraint;
-
     private SoftActivityConstraint softActivityConstraint;
-
     private VehicleRoutingTransportCosts transportCosts;
-
-    private final VehicleRoutingActivityCosts activityCosts;
-
     private ActivityInsertionCostsCalculator additionalTransportCostsCalculator;
 
     private JobActivityFactory activityFactory;
@@ -120,7 +115,7 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
 
         double bestCost = bestKnownCosts;
         additionalICostsAtRouteLevel += additionalAccessEgressCalculator.getCosts(insertionContext);
-		TimeWindow bestTimeWindow = null;
+        TimeWindow bestTimeWindow = null;
 
         /*
         generate new start and end for new vehicle
@@ -134,15 +129,15 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
         int actIndex = 0;
         Iterator<TourActivity> activityIterator = currentRoute.getActivities().iterator();
         boolean tourEnd = false;
-        while(!tourEnd){
+        while (!tourEnd) {
             TourActivity nextAct;
-            if(activityIterator.hasNext()) nextAct = activityIterator.next();
-            else{
+            if (activityIterator.hasNext()) nextAct = activityIterator.next();
+            else {
                 nextAct = end;
                 tourEnd = true;
             }
             boolean not_fulfilled_break = true;
-			for(TimeWindow timeWindow : service.getTimeWindows()) {
+            for (TimeWindow timeWindow : service.getTimeWindows()) {
                 deliveryAct2Insert.setTheoreticalEarliestOperationStartTime(timeWindow.getStart());
                 deliveryAct2Insert.setTheoreticalLatestOperationStartTime(timeWindow.getEnd());
                 ActivityContext activityContext = new ActivityContext();
@@ -161,14 +156,14 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
                 } else if (status.equals(ConstraintsStatus.NOT_FULFILLED)) {
                     not_fulfilled_break = false;
                 }
-			}
-            if(not_fulfilled_break) break;
+            }
+            if (not_fulfilled_break) break;
             double nextActArrTime = prevActStartTime + transportCosts.getTransportTime(prevAct.getLocation(), nextAct.getLocation(), prevActStartTime, newDriver, newVehicle);
-            prevActStartTime = Math.max(nextActArrTime, nextAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct,nextActArrTime,newDriver,newVehicle);
+            prevActStartTime = Math.max(nextActArrTime, nextAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct, nextActArrTime, newDriver, newVehicle);
             prevAct = nextAct;
             actIndex++;
         }
-        if(insertionIndex == InsertionData.NO_INDEX) {
+        if (insertionIndex == InsertionData.NO_INDEX) {
             InsertionData emptyInsertionData = new InsertionData.NoInsertionFound();
             emptyInsertionData.getFailedConstraintNames().addAll(failedActivityConstraints);
             return emptyInsertionData;
@@ -177,7 +172,7 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
         deliveryAct2Insert.setTheoreticalEarliestOperationStartTime(bestTimeWindow.getStart());
         deliveryAct2Insert.setTheoreticalLatestOperationStartTime(bestTimeWindow.getEnd());
         insertionData.getEvents().add(new InsertActivity(currentRoute, newVehicle, deliveryAct2Insert, insertionIndex));
-        insertionData.getEvents().add(new SwitchVehicle(currentRoute,newVehicle,newVehicleDepartureTime));
+        insertionData.getEvents().add(new SwitchVehicle(currentRoute, newVehicle, newVehicleDepartureTime));
         insertionData.setVehicleDepartureTime(newVehicleDepartureTime);
         return insertionData;
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionOnRouteLevelCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionOnRouteLevelCalculator.java
index a600f3f62..78db10fcf 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionOnRouteLevelCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionOnRouteLevelCalculator.java
@@ -74,15 +74,6 @@
 
     private End end;
 
-    public void setJobActivityFactory(JobActivityFactory jobActivityFactory) {
-        this.activityFactory = jobActivityFactory;
-    }
-
-    public void setMemorySize(int memorySize) {
-        this.memorySize = memorySize;
-        logger.debug("set [solutionMemory={}]", memorySize);
-    }
-
     public ServiceInsertionOnRouteLevelCalculator(VehicleRoutingTransportCosts vehicleRoutingCosts, VehicleRoutingActivityCosts costFunc, ActivityInsertionCostsCalculator activityInsertionCostsCalculator, HardRouteConstraint hardRouteLevelConstraint, HardActivityConstraint hardActivityLevelConstraint) {
         super();
         this.transportCosts = vehicleRoutingCosts;
@@ -94,6 +85,14 @@ public ServiceInsertionOnRouteLevelCalculator(VehicleRoutingTransportCosts vehic
         logger.debug("initialise {}", this);
     }
 
+    public void setJobActivityFactory(JobActivityFactory jobActivityFactory) {
+        this.activityFactory = jobActivityFactory;
+    }
+
+    public void setMemorySize(int memorySize) {
+        this.memorySize = memorySize;
+        logger.debug("set [solutionMemory={}]", memorySize);
+    }
 
     public void setStates(RouteAndActivityStateGetter stateManager) {
         this.stateManager = stateManager;
@@ -204,7 +203,7 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
             /**
              * departure time at nextAct with new vehicle
              */
-            double depTime_nextAct_newVehicle = Math.max(arrTime_nextAct_newVehicle, nextAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct, arrTime_nextAct_newVehicle,newDriver,newVehicle);
+            double depTime_nextAct_newVehicle = Math.max(arrTime_nextAct_newVehicle, nextAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct, arrTime_nextAct_newVehicle, newDriver, newVehicle);
 
             /**
              * set previous to next
@@ -286,6 +285,21 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
         return insertionData;
     }
 
+    private Comparator<InsertionData> getComparator() {
+        return new Comparator<InsertionData>() {
+
+            @Override
+            public int compare(InsertionData o1, InsertionData o2) {
+                if (o1.getInsertionCost() < o2.getInsertionCost()) {
+                    return -1;
+                } else {
+                    return 1;
+                }
+
+            }
+        };
+    }
+
     private void initialiseStartAndEnd(final Vehicle newVehicle, double newVehicleDepartureTime) {
         if (start == null) {
             start = new Start(newVehicle.getStartLocation(), newVehicle.getEarliestDeparture(), Double.MAX_VALUE);
@@ -314,19 +328,4 @@ private double sumOf_prevCosts_oldVehicle(VehicleRoute vehicleRoute, TourActivit
         if (prevCost == null) prevCost = 0.;
         return prevCost;
     }
-
-    private Comparator<InsertionData> getComparator() {
-        return new Comparator<InsertionData>() {
-
-            @Override
-            public int compare(InsertionData o1, InsertionData o2) {
-                if (o1.getInsertionCost() < o2.getInsertionCost()) {
-                    return -1;
-                } else {
-                    return 1;
-                }
-
-            }
-        };
-    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculator.java
index e86984835..6988557f9 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculator.java
@@ -146,7 +146,7 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
             }
 
             boolean pickupInsertionNotFulfilledBreak = true;
-            for(TimeWindow pickupTimeWindow : shipment.getPickupTimeWindows()) {
+            for (TimeWindow pickupTimeWindow : shipment.getPickupTimeWindows()) {
                 pickupShipment.setTheoreticalEarliestOperationStartTime(pickupTimeWindow.getStart());
                 pickupShipment.setTheoreticalLatestOperationStartTime(pickupTimeWindow.getEnd());
                 ActivityContext activityContext = new ActivityContext();
@@ -156,10 +156,9 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
                 if (pickupShipmentConstraintStatus.equals(ConstraintsStatus.NOT_FULFILLED)) {
                     pickupInsertionNotFulfilledBreak = false;
                     continue;
-                } else if(pickupShipmentConstraintStatus.equals(ConstraintsStatus.NOT_FULFILLED_BREAK)) {
+                } else if (pickupShipmentConstraintStatus.equals(ConstraintsStatus.NOT_FULFILLED_BREAK)) {
                     continue;
-                }
-                else if (pickupShipmentConstraintStatus.equals(ConstraintsStatus.FULFILLED)) {
+                } else if (pickupShipmentConstraintStatus.equals(ConstraintsStatus.FULFILLED)) {
                     pickupInsertionNotFulfilledBreak = false;
                 }
                 double additionalPickupICosts = softActivityConstraint.getCosts(insertionContext, prevAct, pickupShipment, nextAct, prevActEndTime);
@@ -219,17 +218,17 @@ else if (pickupShipmentConstraintStatus.equals(ConstraintsStatus.FULFILLED)) {
                     if (deliveryInsertionNotFulfilledBreak) break;
                     //update prevAct and endTime
                     double nextActArrTime = prevActEndTime_deliveryLoop + transportCosts.getTransportTime(prevAct_deliveryLoop.getLocation(), nextAct_deliveryLoop.getLocation(), prevActEndTime_deliveryLoop, newDriver, newVehicle);
-                    prevActEndTime_deliveryLoop = Math.max(nextActArrTime, nextAct_deliveryLoop.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct_deliveryLoop,nextActArrTime,newDriver,newVehicle);
+                    prevActEndTime_deliveryLoop = Math.max(nextActArrTime, nextAct_deliveryLoop.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct_deliveryLoop, nextActArrTime, newDriver, newVehicle);
                     prevAct_deliveryLoop = nextAct_deliveryLoop;
                     j++;
                 }
             }
-            if(pickupInsertionNotFulfilledBreak){
+            if (pickupInsertionNotFulfilledBreak) {
                 break;
             }
             //update prevAct and endTime
             double nextActArrTime = prevActEndTime + transportCosts.getTransportTime(prevAct.getLocation(), nextAct.getLocation(), prevActEndTime, newDriver, newVehicle);
-            prevActEndTime = Math.max(nextActArrTime, nextAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct,nextActArrTime,newDriver,newVehicle);
+            prevActEndTime = Math.max(nextActArrTime, nextAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct, nextActArrTime, newDriver, newVehicle);
             prevAct = nextAct;
             i++;
         }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/SolutionCompletenessRatio.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/SolutionCompletenessRatio.java
index 9f0590887..d121edd14 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/SolutionCompletenessRatio.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/SolutionCompletenessRatio.java
@@ -30,24 +30,22 @@
  */
 class SolutionCompletenessRatio implements InsertionStartsListener, JobInsertedListener {
 
-    protected double solutionCompletenessRatio = 0.5;
-
     private final int nuOfJobs;
-
+    protected double solutionCompletenessRatio = 0.5;
     private int nuOfJobsToRecreate;
 
     public SolutionCompletenessRatio(int nuOfJobs) {
         this.nuOfJobs = nuOfJobs;
     }
 
-    public void setSolutionCompletenessRatio(double ratio) {
-        solutionCompletenessRatio = ratio;
-    }
-
     public double getSolutionCompletenessRatio() {
         return solutionCompletenessRatio;
     }
 
+    public void setSolutionCompletenessRatio(double ratio) {
+        solutionCompletenessRatio = ratio;
+    }
+
     @Override
     public void informInsertionStarts(Collection<VehicleRoute> routes, Collection<Job> unassignedJobs) {
         this.nuOfJobsToRecreate = unassignedJobs.size();
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/SwitchVehicleListener.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/SwitchVehicleListener.java
index 5af563539..037d65f0a 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/SwitchVehicleListener.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/SwitchVehicleListener.java
@@ -35,11 +35,11 @@ public void inform(Event event) {
         if (event instanceof SwitchVehicle) {
             SwitchVehicle switchVehicle = (SwitchVehicle) event;
             if (vehiclesDifferent((SwitchVehicle) event)) {
-                logger.trace("switch vehicle ({} to {})",((SwitchVehicle) event).getRoute().getVehicle().getId(),((SwitchVehicle) event).getVehicle().getId());
+                logger.trace("switch vehicle ({} to {})", ((SwitchVehicle) event).getRoute().getVehicle().getId(), ((SwitchVehicle) event).getVehicle().getId());
                 Break aBreak = ((SwitchVehicle) event).getRoute().getVehicle().getBreak();
                 if (aBreak != null) {
                     boolean removed = ((SwitchVehicle) event).getRoute().getTourActivities().removeJob(aBreak);
-                    if (removed) logger.trace("remove {}",aBreak.getId());
+                    if (removed) logger.trace("remove {}", aBreak.getId());
                 }
             }
             switchVehicle.getRoute().setVehicleAndDepartureTime(switchVehicle.getVehicle(), ((SwitchVehicle) event).getDepartureTime());
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/VariableTransportCostCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/VariableTransportCostCalculator.java
index 8e1fcb647..814da7217 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/VariableTransportCostCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/VariableTransportCostCalculator.java
@@ -42,7 +42,7 @@ public double getCosts(JobInsertionContext iFacts, TourActivity prevAct, TourAct
         double tp_time_prevAct_newAct = routingCosts.getTransportTime(prevAct.getLocation(), newAct.getLocation(), depTimeAtPrevAct, iFacts.getNewDriver(), iFacts.getNewVehicle());
 
         double newAct_arrTime = depTimeAtPrevAct + tp_time_prevAct_newAct;
-        double newAct_endTime = Math.max(newAct_arrTime, newAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(newAct,newAct_arrTime,iFacts.getNewDriver(),iFacts.getNewVehicle());
+        double newAct_endTime = Math.max(newAct_arrTime, newAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(newAct, newAct_arrTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
 
         //open routes
         if (nextAct instanceof End) {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/VehicleTypeDependentJobInsertionCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/VehicleTypeDependentJobInsertionCalculator.java
index ad522012e..8b3b3ae3f 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/VehicleTypeDependentJobInsertionCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/VehicleTypeDependentJobInsertionCalculator.java
@@ -35,14 +35,10 @@
 
 final class VehicleTypeDependentJobInsertionCalculator implements JobInsertionCostsCalculator {
 
-    private Logger logger = LoggerFactory.getLogger(VehicleTypeDependentJobInsertionCalculator.class);
-
     private final VehicleFleetManager fleetManager;
-
     private final JobInsertionCostsCalculator insertionCalculator;
-
     private final VehicleRoutingProblem vrp;
-
+    private Logger logger = LoggerFactory.getLogger(VehicleTypeDependentJobInsertionCalculator.class);
     private Set<String> initialVehicleIds = new HashSet<String>();
 
     /**
@@ -93,7 +89,7 @@ public void setVehicleSwitchAllowed(boolean vehicleSwitchAllowed) {
     }
 
     public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job jobToInsert, final Vehicle vehicle, double newVehicleDepartureTime, final Driver driver, final double bestKnownCost) {
-        if(vehicle != null){
+        if (vehicle != null) {
             return insertionCalculator.getInsertionData(currentRoute, jobToInsert, vehicle, newVehicleDepartureTime, driver, bestKnownCost);
         }
         Vehicle selectedVehicle = currentRoute.getVehicle();
@@ -126,12 +122,12 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
         return bestIData;
     }
 
-    VehicleFleetManager getFleetManager(){
-        return fleetManager;
-    }
-
     private boolean isVehicleWithInitialRoute(Vehicle selectedVehicle) {
         return initialVehicleIds.contains(selectedVehicle.getId());
     }
 
+    VehicleFleetManager getFleetManager() {
+        return fleetManager;
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/listener/InsertionListeners.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/listener/InsertionListeners.java
index f0c5e9a8e..9de232484 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/listener/InsertionListeners.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/listener/InsertionListeners.java
@@ -83,10 +83,6 @@ public void informJobUnassignedListeners(Job unassigned, List<String> reasons) {
         }
     }
 
-    public void addListener(InsertionListener insertionListener) {
-        listeners.add(insertionListener);
-    }
-
     public void removeListener(InsertionListener insertionListener) {
         listeners.remove(insertionListener);
     }
@@ -95,4 +91,8 @@ public void addAllListeners(Collection<InsertionListener> listeners) {
         for (InsertionListener l : listeners) addListener(l);
     }
 
+    public void addListener(InsertionListener insertionListener) {
+        listeners.add(insertionListener);
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/AbstractRuinStrategy.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/AbstractRuinStrategy.java
index 37552b35f..7f518690d 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/AbstractRuinStrategy.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/AbstractRuinStrategy.java
@@ -34,30 +34,26 @@
 public abstract class AbstractRuinStrategy implements RuinStrategy {
 
     private final static Logger logger = LoggerFactory.getLogger(AbstractRuinStrategy.class);
-
-    private RuinListeners ruinListeners;
-
     protected Random random = RandomNumberGeneration.getRandom();
-
     protected VehicleRoutingProblem vrp;
+    protected RuinShareFactory ruinShareFactory;
+    private RuinListeners ruinListeners;
 
-    public void setRandom(Random random) {
-        this.random = random;
+    protected AbstractRuinStrategy(VehicleRoutingProblem vrp) {
+        this.vrp = vrp;
+        ruinListeners = new RuinListeners();
     }
 
-    protected RuinShareFactory ruinShareFactory;
-
-    public void setRuinShareFactory(RuinShareFactory ruinShareFactory) {
-        this.ruinShareFactory = ruinShareFactory;
+    public void setRandom(Random random) {
+        this.random = random;
     }
 
     public RuinShareFactory getRuinShareFactory() {
         return ruinShareFactory;
     }
 
-    protected AbstractRuinStrategy(VehicleRoutingProblem vrp) {
-        this.vrp = vrp;
-        ruinListeners = new RuinListeners();
+    public void setRuinShareFactory(RuinShareFactory ruinShareFactory) {
+        this.ruinShareFactory = ruinShareFactory;
     }
 
     @Override
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/ClusterRuinStrategyFactory.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/ClusterRuinStrategyFactory.java
index 2fb3d3852..57fb4dd06 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/ClusterRuinStrategyFactory.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/ClusterRuinStrategyFactory.java
@@ -2,7 +2,7 @@
 
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 
-public class ClusterRuinStrategyFactory implements RuinStrategyFactory  {
+public class ClusterRuinStrategyFactory implements RuinStrategyFactory {
 
     private int initialNumberJobsToRemove;
     private JobNeighborhoods jobNeighborhoods;
@@ -17,4 +17,4 @@ public ClusterRuinStrategyFactory(int initialNumberJobsToRemove, JobNeighborhood
     public RuinStrategy createStrategy(VehicleRoutingProblem vrp) {
         return new RuinClusters(vrp, initialNumberJobsToRemove, jobNeighborhoods);
     }
-}
\ No newline at end of file
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/DBSCANClusterer.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/DBSCANClusterer.java
index d73bf10a8..e28c859ae 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/DBSCANClusterer.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/DBSCANClusterer.java
@@ -36,99 +36,21 @@
  */
 public class DBSCANClusterer {
 
-    private static class LocationWrapper implements Clusterable {
-
-        private static int objCounter = 0;
-
-        private final Job job;
-
-        private List<Location> locations;
-
-        private int id;
-
-        public LocationWrapper(Job job, List<Location> locations) {
-            this.locations = locations;
-            objCounter++;
-            this.job = job;
-            this.id = objCounter;
-        }
-
-//        private List<Location> getLocations(Job job){
-//            List<Location> locs = new ArrayList<Location>();
-//            if(job instanceof Service) {
-//                locs.add(((Service) job).getLocation());
-//            }
-//            else if(job instanceof Shipment){
-//                locs.add(((Shipment) job).getPickupLocation());
-//                locs.add(((Shipment) job).getDeliveryLocation());
-//            }
-//            return locs;
-//        }
-
-        public List<Location> getLocations() {
-            return locations;
-        }
-
-        @Override
-        public double[] getPoint() {
-            return new double[]{id};
-        }
-
-        public Job getJob() {
-            return job;
-        }
-    }
-
-    private static class MyDistance implements DistanceMeasure {
-
-        private Map<Integer, LocationWrapper> locations;
-
-        private VehicleRoutingTransportCosts costs;
-
-        public MyDistance(List<LocationWrapper> locations, VehicleRoutingTransportCosts costs) {
-            this.locations = new HashMap<Integer, LocationWrapper>();
-            for (LocationWrapper lw : locations) {
-                this.locations.put((int) lw.getPoint()[0], lw);
-            }
-            this.costs = costs;
-        }
-
-        @Override
-        public double compute(double[] doubles, double[] doubles1) {
-            LocationWrapper l1 = locations.get((int) doubles[0]);
-            LocationWrapper l2 = locations.get((int) doubles1[0]);
-            int count = 0;
-            double sum = 0;
-            for (Location loc_1 : l1.getLocations()) {
-                for (Location loc_2 : l2.getLocations()) {
-                    sum += costs.getTransportCost(loc_1, loc_2, 0, null, null);
-                    count++;
-                }
-            }
-            return sum / (double) count;
-        }
-    }
-
     private VehicleRoutingTransportCosts costs;
-
     private int minNoOfJobsInCluster = 1;
-
     private int noDistanceSamples = 10;
-
     private double epsFactor = 0.8;
-
     private Double epsDistance;
-
     private Random random = RandomNumberGeneration.getRandom();
 
-    public void setRandom(Random random) {
-        this.random = random;
-    }
-
     public DBSCANClusterer(VehicleRoutingTransportCosts costs) {
         this.costs = costs;
     }
 
+    public void setRandom(Random random) {
+        this.random = random;
+    }
+
     public void setMinPts(int pts) {
         this.minNoOfJobsInCluster = pts;
     }
@@ -182,6 +104,21 @@ public void setEpsDistance(double epsDistance) {
         return l;
     }
 
+    private double sample(VehicleRoutingTransportCosts costs, VehicleRoute r) {
+        double min = Double.MAX_VALUE;
+        double sum = 0;
+        for (int i = 0; i < noDistanceSamples; i++) {
+            TourActivity act1 = RandomUtils.nextItem(r.getActivities(), random);
+            TourActivity act2 = RandomUtils.nextItem(r.getActivities(), random);
+            double dist = costs.getTransportCost(act1.getLocation(), act2.getLocation(),
+                0., null, r.getVehicle());
+            if (dist < min) min = dist;
+            sum += dist;
+        }
+        double avg = sum / ((double) noDistanceSamples);
+        return (avg - min) * epsFactor;
+    }
+
     private List<Job> getJobList(Cluster<LocationWrapper> c) {
         List<Job> l_ = new ArrayList<Job>();
         if (c == null) return l_;
@@ -200,19 +137,77 @@ public void setEpsDistance(double epsDistance) {
         return getJobList(randomCluster);
     }
 
-    private double sample(VehicleRoutingTransportCosts costs, VehicleRoute r) {
-        double min = Double.MAX_VALUE;
-        double sum = 0;
-        for (int i = 0; i < noDistanceSamples; i++) {
-            TourActivity act1 = RandomUtils.nextItem(r.getActivities(), random);
-            TourActivity act2 = RandomUtils.nextItem(r.getActivities(), random);
-            double dist = costs.getTransportCost(act1.getLocation(), act2.getLocation(),
-                0., null, r.getVehicle());
-            if (dist < min) min = dist;
-            sum += dist;
+    private static class LocationWrapper implements Clusterable {
+
+        private static int objCounter = 0;
+
+        private final Job job;
+
+        private List<Location> locations;
+
+        private int id;
+
+        public LocationWrapper(Job job, List<Location> locations) {
+            this.locations = locations;
+            objCounter++;
+            this.job = job;
+            this.id = objCounter;
+        }
+
+//        private List<Location> getLocations(Job job){
+//            List<Location> locs = new ArrayList<Location>();
+//            if(job instanceof Service) {
+//                locs.add(((Service) job).getLocation());
+//            }
+//            else if(job instanceof Shipment){
+//                locs.add(((Shipment) job).getPickupLocation());
+//                locs.add(((Shipment) job).getDeliveryLocation());
+//            }
+//            return locs;
+//        }
+
+        public List<Location> getLocations() {
+            return locations;
+        }
+
+        @Override
+        public double[] getPoint() {
+            return new double[]{id};
+        }
+
+        public Job getJob() {
+            return job;
+        }
+    }
+
+    private static class MyDistance implements DistanceMeasure {
+
+        private Map<Integer, LocationWrapper> locations;
+
+        private VehicleRoutingTransportCosts costs;
+
+        public MyDistance(List<LocationWrapper> locations, VehicleRoutingTransportCosts costs) {
+            this.locations = new HashMap<Integer, LocationWrapper>();
+            for (LocationWrapper lw : locations) {
+                this.locations.put((int) lw.getPoint()[0], lw);
+            }
+            this.costs = costs;
+        }
+
+        @Override
+        public double compute(double[] doubles, double[] doubles1) {
+            LocationWrapper l1 = locations.get((int) doubles[0]);
+            LocationWrapper l2 = locations.get((int) doubles1[0]);
+            int count = 0;
+            double sum = 0;
+            for (Location loc_1 : l1.getLocations()) {
+                for (Location loc_2 : l2.getLocations()) {
+                    sum += costs.getTransportCost(loc_1, loc_2, 0, null, null);
+                    count++;
+                }
+            }
+            return sum / (double) count;
         }
-        double avg = sum / ((double) noDistanceSamples);
-        return (avg - min) * epsFactor;
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsOptimized.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsOptimized.java
index 58e7a4f05..439febc5b 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsOptimized.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsOptimized.java
@@ -32,55 +32,12 @@
  */
 class JobNeighborhoodsOptimized implements JobNeighborhoods {
 
-    static class ArrayIterator implements Iterator<Job> {
-
-        private final int noItems;
-
-        private final int[] itemArray;
-
-        private final Job[] jobs;
-
-        private int index = 0;
-
-        public ArrayIterator(int noItems, int[] itemArray, Job[] jobs) {
-            this.noItems = noItems;
-            this.itemArray = itemArray;
-            this.jobs = jobs;
-        }
-
-        @Override
-        public boolean hasNext() {
-            if(index < noItems && index < itemArray.length) {
-                return true;
-            }
-            return false;
-        }
-
-        @Override
-        public Job next() {
-            Job job = jobs[itemArray[index]];
-            index++;
-            return job;
-        }
-
-        @Override
-        public void remove() {
-            throw new UnsupportedOperationException();
-        }
-    }
-
     private static Logger logger = LoggerFactory.getLogger(JobNeighborhoodsOptimized.class);
-
     private VehicleRoutingProblem vrp;
-
     private int[][] neighbors;
-
     private Job[] jobs;
-
     private JobDistance jobDistance;
-
     private int capacity;
-
     private double maxDistance = 0.;
 
     public JobNeighborhoodsOptimized(VehicleRoutingProblem vrp, JobDistance jobDistance, int capacity) {
@@ -88,15 +45,15 @@ public JobNeighborhoodsOptimized(VehicleRoutingProblem vrp, JobDistance jobDista
         this.vrp = vrp;
         this.jobDistance = jobDistance;
         this.capacity = capacity;
-        neighbors = new int[vrp.getJobsInclusiveInitialJobsInRoutes().size()+1][capacity];
-        jobs = new Job[vrp.getJobsInclusiveInitialJobsInRoutes().size()+1];
+        neighbors = new int[vrp.getJobsInclusiveInitialJobsInRoutes().size() + 1][capacity];
+        jobs = new Job[vrp.getJobsInclusiveInitialJobsInRoutes().size() + 1];
         logger.debug("initialize {}", this);
     }
 
     @Override
     public Iterator<Job> getNearestNeighborsIterator(int nNeighbors, Job neighborTo) {
-        int[] neighbors = this.neighbors[neighborTo.getIndex()-1];
-        return new ArrayIterator(nNeighbors,neighbors,jobs);
+        int[] neighbors = this.neighbors[neighborTo.getIndex() - 1];
+        return new ArrayIterator(nNeighbors, neighbors, jobs);
     }
 
     @Override
@@ -125,27 +82,26 @@ private void calculateDistancesFromJob2Job() {
                 ReferencedJob referencedJob = new ReferencedJob(job_j, distance);
                 jobList.add(referencedJob);
             }
-            Collections.sort(jobList,getComparator());
+            Collections.sort(jobList, getComparator());
             int[] jobIndices = new int[capacity];
-            for(int index=0;index<capacity;index++){
+            for (int index = 0; index < capacity; index++) {
                 jobIndices[index] = jobList.get(index).getJob().getIndex();
             }
-            neighbors[job_i.getIndex()-1] = jobIndices;
+            neighbors[job_i.getIndex() - 1] = jobIndices;
         }
         stopWatch.stop();
         logger.debug("pre-processing comp-time: {}", stopWatch);
     }
 
-    private Comparator<ReferencedJob> getComparator(){
+    private Comparator<ReferencedJob> getComparator() {
         return new Comparator<ReferencedJob>() {
             @Override
             public int compare(ReferencedJob o1, ReferencedJob o2) {
                 if (o1.getDistance() < o2.getDistance()) {
                     return -1;
-                } else if (o1.getDistance() > o2.getDistance()){
+                } else if (o1.getDistance() > o2.getDistance()) {
                     return 1;
-                }
-                else return 0;
+                } else return 0;
             }
         };
     }
@@ -155,4 +111,41 @@ public String toString() {
         return "[name=neighborhoodWithCapRestriction][capacity=" + capacity + "]";
     }
 
+    static class ArrayIterator implements Iterator<Job> {
+
+        private final int noItems;
+
+        private final int[] itemArray;
+
+        private final Job[] jobs;
+
+        private int index = 0;
+
+        public ArrayIterator(int noItems, int[] itemArray, Job[] jobs) {
+            this.noItems = noItems;
+            this.itemArray = itemArray;
+            this.jobs = jobs;
+        }
+
+        @Override
+        public boolean hasNext() {
+            if (index < noItems && index < itemArray.length) {
+                return true;
+            }
+            return false;
+        }
+
+        @Override
+        public Job next() {
+            Job job = jobs[itemArray[index]];
+            index++;
+            return job;
+        }
+
+        @Override
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinClusters.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinClusters.java
index 4e00ac677..6363bdd04 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinClusters.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinClusters.java
@@ -40,41 +40,11 @@
 
 public final class RuinClusters extends AbstractRuinStrategy implements IterationStartsListener {
 
-    @Override
-    public void informIterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
-        minPts = 1 + random.nextInt(2);
-        epsFactor = 0.5 + random.nextDouble();
-    }
-
-    public static class JobActivityWrapper implements Clusterable {
-
-        private TourActivity.JobActivity jobActivity;
-
-        public JobActivityWrapper(TourActivity.JobActivity jobActivity) {
-            this.jobActivity = jobActivity;
-        }
-
-        @Override
-        public double[] getPoint() {
-            return new double[]{jobActivity.getLocation().getCoordinate().getX(), jobActivity.getLocation().getCoordinate().getY()};
-        }
-
-        public TourActivity.JobActivity getActivity() {
-            return jobActivity;
-        }
-    }
-
     private Logger logger = LoggerFactory.getLogger(RuinClusters.class);
-
     private VehicleRoutingProblem vrp;
-
-
     private JobNeighborhoods jobNeighborhoods;
-
     private int noClusters = 2;
-
     private int minPts = 1;
-
     private double epsFactor = 0.8;
 
     public RuinClusters(VehicleRoutingProblem vrp, final int initialNumberJobsToRemove, JobNeighborhoods jobNeighborhoods) {
@@ -90,6 +60,12 @@ public int createNumberToBeRemoved() {
         logger.debug("initialise {}", this);
     }
 
+    @Override
+    public void informIterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
+        minPts = 1 + random.nextInt(2);
+        epsFactor = 0.5 + random.nextDouble();
+    }
+
     public void setNoClusters(int noClusters) {
         this.noClusters = noClusters;
     }
@@ -157,14 +133,6 @@ private void ruin(Collection<VehicleRoute> vehicleRoutes, int nOfJobs2BeRemoved,
         }
     }
 
-    private List<JobActivityWrapper> wrap(List<TourActivity> activities) {
-        List<JobActivityWrapper> wl = new ArrayList<JobActivityWrapper>();
-        for (TourActivity act : activities) {
-            wl.add(new JobActivityWrapper((TourActivity.JobActivity) act));
-        }
-        return wl;
-    }
-
     private Map<Job, VehicleRoute> map(Collection<VehicleRoute> vehicleRoutes) {
         Map<Job, VehicleRoute> map = new HashMap<Job, VehicleRoute>(vrp.getJobs().size());
         for (VehicleRoute r : vehicleRoutes) {
@@ -175,9 +143,35 @@ private void ruin(Collection<VehicleRoute> vehicleRoutes, int nOfJobs2BeRemoved,
         return map;
     }
 
+    private List<JobActivityWrapper> wrap(List<TourActivity> activities) {
+        List<JobActivityWrapper> wl = new ArrayList<JobActivityWrapper>();
+        for (TourActivity act : activities) {
+            wl.add(new JobActivityWrapper((TourActivity.JobActivity) act));
+        }
+        return wl;
+    }
+
     @Override
     public String toString() {
         return "[name=clusterRuin]";
     }
 
+    public static class JobActivityWrapper implements Clusterable {
+
+        private TourActivity.JobActivity jobActivity;
+
+        public JobActivityWrapper(TourActivity.JobActivity jobActivity) {
+            this.jobActivity = jobActivity;
+        }
+
+        @Override
+        public double[] getPoint() {
+            return new double[]{jobActivity.getLocation().getCoordinate().getX(), jobActivity.getLocation().getCoordinate().getY()};
+        }
+
+        public TourActivity.JobActivity getActivity() {
+            return jobActivity;
+        }
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinRadial.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinRadial.java
index e4ea4fc20..fbc753ba3 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinRadial.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinRadial.java
@@ -37,14 +37,11 @@
  */
 public final class RuinRadial extends AbstractRuinStrategy {
 
+    private final int noJobsToMemorize;
     private Logger logger = LoggerFactory.getLogger(RuinRadial.class);
-
     private VehicleRoutingProblem vrp;
-
     private JobNeighborhoods jobNeighborhoods;
 
-    private final int noJobsToMemorize;
-
     /**
      * Constructs RuinRadial.
      *
@@ -129,7 +126,6 @@ public String toString() {
 
     /**
      * Removes targetJob and its neighborhood and returns the removed jobs.
-     *
      */
     private Collection<Job> ruinRoutes(Collection<VehicleRoute> vehicleRoutes, Job targetJob, int nOfJobs2BeRemoved) {
         List<Job> unassignedJobs = new ArrayList<Job>();
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinRadialMultipleCenters.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinRadialMultipleCenters.java
index 17fc53f28..53bb9f362 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinRadialMultipleCenters.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinRadialMultipleCenters.java
@@ -37,14 +37,10 @@
 @Deprecated
 public final class RuinRadialMultipleCenters extends AbstractRuinStrategy {
 
+    private final int noJobsToMemorize;
     private Logger logger = LoggerFactory.getLogger(RuinRadialMultipleCenters.class);
-
     private VehicleRoutingProblem vrp;
-
     private JobNeighborhoods jobNeighborhoods;
-
-    private final int noJobsToMemorize;
-
     private int noCenters = 1;
 
     public RuinRadialMultipleCenters(VehicleRoutingProblem vrp, int neighborhoodSize, JobDistance jobDistance) {
@@ -98,6 +94,17 @@ public String toString() {
         return ruined;
     }
 
+    private Job pickRandomJob(Set<Job> available) {
+        int randomIndex = random.nextInt(available.size());
+        int i = 0;
+        for (Job j : available) {
+            if (i >= randomIndex) {
+                return j;
+            } else i++;
+        }
+        return null;
+    }
+
     private Collection<Job> ruinRoutes_(Collection<VehicleRoute> vehicleRoutes, Job targetJob, int nOfJobs2BeRemoved, Set<Job> available) {
         List<Job> unassignedJobs = new ArrayList<Job>();
         int nNeighbors = nOfJobs2BeRemoved - 1;
@@ -114,15 +121,4 @@ public String toString() {
         return unassignedJobs;
     }
 
-    private Job pickRandomJob(Set<Job> available) {
-        int randomIndex = random.nextInt(available.size());
-        int i = 0;
-        for (Job j : available) {
-            if (i >= randomIndex) {
-                return j;
-            } else i++;
-        }
-        return null;
-    }
-
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinRandom.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinRandom.java
index 74a083745..fa738f1d4 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinRandom.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinRandom.java
@@ -63,6 +63,10 @@ public int createNumberToBeRemoved() {
         logger.debug("initialise {}", this);
     }
 
+    private int selectNuOfJobs2BeRemoved() {
+        return (int) Math.ceil(vrp.getJobs().values().size() * fractionOfAllNodes2beRuined);
+    }
+
     /**
      * Removes a fraction of jobs from vehicleRoutes.
      * <p>
@@ -94,9 +98,5 @@ public String toString() {
         return "[name=randomRuin][noJobsToBeRemoved=" + selectNuOfJobs2BeRemoved() + "]";
     }
 
-    private int selectNuOfJobs2BeRemoved() {
-        return (int) Math.ceil(vrp.getJobs().values().size() * fractionOfAllNodes2beRuined);
-    }
-
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinString.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinString.java
index 8452dde2d..52184cca9 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinString.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinString.java
@@ -121,6 +121,41 @@ private VehicleRoute getRouteOf(Job job, Collection<VehicleRoute> vehicleRoutes)
         return null;
     }
 
+    private void ruinRouteWithStringRuin(VehicleRoute seedRoute, Job prevJob, Set<Job> unassignedJobs) {
+        int stringLength = lMin + random.nextInt(lMax - lMin);
+        stringLength = Math.min(stringLength, seedRoute.getActivities().size());
+        List<AbstractActivity> acts = vrp.getActivities(prevJob);
+        AbstractActivity randomSeedAct = RandomUtils.nextItem(acts, random);
+        int seedIndex = 0;
+        int noActivities = seedRoute.getActivities().size();
+        int index = 0;
+        for (TourActivity act : seedRoute.getActivities()) {
+            if (act.getIndex() == randomSeedAct.getIndex()) {
+                seedIndex = index;
+                break;
+            }
+            index++;
+        }
+        List<Integer> stringBounds = StringUtil.getLowerBoundsOfAllStrings(stringLength, seedIndex, noActivities);
+        if (stringBounds.isEmpty()) return;
+        int lowerBound = RandomUtils.nextItem(stringBounds, random);
+        List<Job> jobs2Remove = new ArrayList<>();
+        for (int i = lowerBound; i < (lowerBound + stringLength); i++) {
+            TourActivity act = seedRoute.getActivities().get(i);
+            if (act instanceof TourActivity.JobActivity) {
+                Job job = ((TourActivity.JobActivity) act).getJob();
+                if (vrp.getJobs().containsKey(job.getId())) {
+                    jobs2Remove.add(job);
+                }
+            }
+        }
+        for (Job job : jobs2Remove) {
+            removeJob(job, seedRoute);
+            unassignedJobs.add(job);
+        }
+
+    }
+
     private void ruinRouteWithSplitStringRuin(VehicleRoute seedRoute, Job prevJob, Set<Job> unassignedJobs) {
         int noActivities = seedRoute.getActivities().size();
         int stringLength;
@@ -179,40 +214,4 @@ private void ruinRouteWithSplitStringRuin(VehicleRoute seedRoute, Job prevJob, S
     }
 
 
-    private void ruinRouteWithStringRuin(VehicleRoute seedRoute, Job prevJob, Set<Job> unassignedJobs) {
-        int stringLength = lMin + random.nextInt(lMax - lMin);
-        stringLength = Math.min(stringLength, seedRoute.getActivities().size());
-        List<AbstractActivity> acts = vrp.getActivities(prevJob);
-        AbstractActivity randomSeedAct = RandomUtils.nextItem(acts, random);
-        int seedIndex = 0;
-        int noActivities = seedRoute.getActivities().size();
-        int index = 0;
-        for (TourActivity act : seedRoute.getActivities()) {
-            if (act.getIndex() == randomSeedAct.getIndex()) {
-                seedIndex = index;
-                break;
-            }
-            index++;
-        }
-        List<Integer> stringBounds = StringUtil.getLowerBoundsOfAllStrings(stringLength, seedIndex, noActivities);
-        if (stringBounds.isEmpty()) return;
-        int lowerBound = RandomUtils.nextItem(stringBounds, random);
-        List<Job> jobs2Remove = new ArrayList<>();
-        for (int i = lowerBound; i < (lowerBound + stringLength); i++) {
-            TourActivity act = seedRoute.getActivities().get(i);
-            if (act instanceof TourActivity.JobActivity) {
-                Job job = ((TourActivity.JobActivity) act).getJob();
-                if (vrp.getJobs().containsKey(job.getId())) {
-                    jobs2Remove.add(job);
-                }
-            }
-        }
-        for (Job job : jobs2Remove) {
-            removeJob(job, seedRoute);
-            unassignedJobs.add(job);
-        }
-
-    }
-
-
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinWorst.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinWorst.java
index 620d1feda..81fd3f33f 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinWorst.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinWorst.java
@@ -51,10 +51,6 @@ public double makeNoise() {
         }
     };
 
-    public void setNoiseMaker(NoiseMaker noiseMaker) {
-        this.noiseMaker = noiseMaker;
-    }
-
     public RuinWorst(VehicleRoutingProblem vrp, final int initialNumberJobsToRemove) {
         super(vrp);
         this.vrp = vrp;
@@ -67,6 +63,10 @@ public int createNumberToBeRemoved() {
         logger.debug("initialise {}", this);
     }
 
+    public void setNoiseMaker(NoiseMaker noiseMaker) {
+        this.noiseMaker = noiseMaker;
+    }
+
     /**
      * Removes a fraction of jobs from vehicleRoutes.
      * <p>
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/selector/SelectRandomly.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/selector/SelectRandomly.java
index 67c462ceb..88a7c3f61 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/selector/SelectRandomly.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/selector/SelectRandomly.java
@@ -29,6 +29,7 @@
 public class SelectRandomly implements SolutionSelector {
 
     private static SelectRandomly selector = null;
+    private Random random = RandomNumberGeneration.getRandom();
 
     public static SelectRandomly getInstance() {
         if (selector == null) {
@@ -38,8 +39,6 @@ public static SelectRandomly getInstance() {
         return selector;
     }
 
-    private Random random = RandomNumberGeneration.getRandom();
-
     @Override
     public VehicleRoutingProblemSolution selectSolution(Collection<VehicleRoutingProblemSolution> solutions) {
         if (solutions.isEmpty()) return null;
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/StateFactory.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/StateFactory.java
index 32f0db162..9a723088e 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/StateFactory.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/StateFactory.java
@@ -37,13 +37,16 @@ static StateId createId(String name) {
         return new StateIdImpl(name, -1);
     }
 
+    static void throwReservedIdException(String name) {
+        throw new IllegalStateException("state-id with name '" + name + "' cannot be created. it is already reserved internally.");
+    }
+
     static StateId createId(String name, int index) {
         if (reservedIds.contains(name)) throwReservedIdException(name);
         if (index < 10) throwReservedIdException(name);
         return new StateIdImpl(name, index);
     }
 
-
     static boolean isReservedId(String stateId) {
         return reservedIds.contains(stateId);
     }
@@ -52,14 +55,16 @@ static boolean isReservedId(StateId stateId) {
         return reservedIds.contains(stateId.toString());
     }
 
-    static void throwReservedIdException(String name) {
-        throw new IllegalStateException("state-id with name '" + name + "' cannot be created. it is already reserved internally.");
-    }
-
-
     static class StateIdImpl implements StateId {
 
         private int index;
+        private String name;
+
+        public StateIdImpl(String name, int index) {
+            super();
+            this.name = name;
+            this.index = index;
+        }
 
         public int getIndex() {
             return index;
@@ -96,14 +101,6 @@ public boolean equals(Object obj) {
             return true;
         }
 
-        private String name;
-
-        public StateIdImpl(String name, int index) {
-            super();
-            this.name = name;
-            this.index = index;
-        }
-
         public String toString() {
             return name;
         }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/StateManager.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/StateManager.java
index 9d9fbb63e..79f77f87d 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/StateManager.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/StateManager.java
@@ -46,84 +46,29 @@
  */
 public class StateManager implements RouteAndActivityStateGetter, IterationStartsListener, RuinListener, InsertionStartsListener, JobInsertedListener, InsertionEndsListener {
 
+    private final int initialNoStates = 21;
+    private final boolean isIndexedBased;
     private RouteActivityVisitor routeActivityVisitor = new RouteActivityVisitor();
-
     private ReverseRouteActivityVisitor revRouteActivityVisitor = new ReverseRouteActivityVisitor();
-
     private Collection<RouteVisitor> routeVisitors = new ArrayList<RouteVisitor>();
-
     private RuinListeners ruinListeners = new RuinListeners();
-
     private InsertionListeners insertionListeners = new InsertionListeners();
-
     private Collection<StateUpdater> updaters = new ArrayList<StateUpdater>();
-
     private boolean updateLoad = false;
-
     private boolean updateTWs = false;
-
-    private final int initialNoStates = 21;
-
     private int stateIndexCounter;
-
     private Map<String, StateId> createdStateIds = new HashMap<String, StateId>();
-
     private int nuActivities;
-
     private int nuVehicleTypeKeys;
-
     private Object[] problemStates;
-
     private Object[][] activityStates;
-
     private Object[][][] vehicleDependentActivityStates;
-
     private Map<VehicleRoute, Object[]> routeStateMap;
-
     private Map<VehicleRoute, Object[][]> vehicleDependentRouteStateMap;
-
     private Object[][] routeStatesArr;
-
     private Object[][][] vehicleDependentRouteStatesArr;
-
     private VehicleRoutingProblem vrp;
 
-    private final boolean isIndexedBased;
-
-    int getMaxIndexOfVehicleTypeIdentifiers() {
-        return nuVehicleTypeKeys;
-    }
-
-    /**
-     * Create and returns a stateId with the specified state-name.
-     * <p>
-     * <p>If a stateId with the specified name has already been created, it returns the created stateId.</p>
-     * <p>If the specified is equal to a name that is already used internally, it throws an IllegalStateException</p>
-     *
-     * @param name the specified name of the state
-     * @return the stateId with which a state can be identified, no matter if it is a problem, route or activity state.
-     * @throws java.lang.IllegalStateException if name of state is already used internally
-     */
-    public StateId createStateId(String name) {
-        if (createdStateIds.containsKey(name)) return createdStateIds.get(name);
-        if (stateIndexCounter >= activityStates[0].length) {
-            activityStates = new Object[nuActivities][stateIndexCounter + 1];
-            vehicleDependentActivityStates = new Object[nuActivities][nuVehicleTypeKeys][stateIndexCounter + 1];
-            routeStatesArr = new Object[vrp.getVehicles().size() + 2][stateIndexCounter+1];
-            vehicleDependentRouteStatesArr = new Object[vrp.getVehicles().size() + 2][nuVehicleTypeKeys][stateIndexCounter+1];
-            problemStates = new Object[stateIndexCounter+1];
-        }
-        StateId id = StateFactory.createId(name, stateIndexCounter);
-        incStateIndexCounter();
-        createdStateIds.put(name, id);
-        return id;
-    }
-
-    private void incStateIndexCounter() {
-        stateIndexCounter++;
-    }
-
-
     /**
      * Constructs the stateManager with the specified VehicleRoutingProblem.
      *
@@ -143,9 +88,9 @@ public StateManager(VehicleRoutingProblem vehicleRoutingProblem) {
 //            vehicleDependentRouteStatesArr = new Object[vrp.getVehicles().size() + 2][nuVehicleTypeKeys][initialStateArrayLength];
 //        }
 //        else {
-            isIndexedBased = false;
-            routeStateMap = new HashMap<VehicleRoute, Object[]>();
-            vehicleDependentRouteStateMap = new HashMap<VehicleRoute, Object[][]>();
+        isIndexedBased = false;
+        routeStateMap = new HashMap<VehicleRoute, Object[]>();
+        vehicleDependentRouteStateMap = new HashMap<VehicleRoute, Object[][]>();
 //        }
         problemStates = new Object[initialStateArrayLength];
     }
@@ -158,6 +103,39 @@ private int getNuVehicleTypes(VehicleRoutingProblem vrp) {
         return maxIndex;
     }
 
+    int getMaxIndexOfVehicleTypeIdentifiers() {
+        return nuVehicleTypeKeys;
+    }
+
+    /**
+     * Create and returns a stateId with the specified state-name.
+     * <p>
+     * <p>If a stateId with the specified name has already been created, it returns the created stateId.</p>
+     * <p>If the specified is equal to a name that is already used internally, it throws an IllegalStateException</p>
+     *
+     * @param name the specified name of the state
+     * @return the stateId with which a state can be identified, no matter if it is a problem, route or activity state.
+     * @throws java.lang.IllegalStateException if name of state is already used internally
+     */
+    public StateId createStateId(String name) {
+        if (createdStateIds.containsKey(name)) return createdStateIds.get(name);
+        if (stateIndexCounter >= activityStates[0].length) {
+            activityStates = new Object[nuActivities][stateIndexCounter + 1];
+            vehicleDependentActivityStates = new Object[nuActivities][nuVehicleTypeKeys][stateIndexCounter + 1];
+            routeStatesArr = new Object[vrp.getVehicles().size() + 2][stateIndexCounter + 1];
+            vehicleDependentRouteStatesArr = new Object[vrp.getVehicles().size() + 2][nuVehicleTypeKeys][stateIndexCounter + 1];
+            problemStates = new Object[stateIndexCounter + 1];
+        }
+        StateId id = StateFactory.createId(name, stateIndexCounter);
+        incStateIndexCounter();
+        createdStateIds.put(name, id);
+        return id;
+    }
+
+    private void incStateIndexCounter() {
+        stateIndexCounter++;
+    }
+
     /**
      * Associates the specified state to the stateId. If there already exists a state value for the stateId, this old
      * value is replaced by the new value.
@@ -185,37 +163,6 @@ private int getNuVehicleTypes(VehicleRoutingProblem vrp) {
         return type.cast(problemStates[stateId.getIndex()]);
     }
 
-    /**
-     * Clears all states, i.e. set all value to null.
-     */
-    public void clear() {
-        fill_twoDimArr(activityStates, null);
-        fill_threeDimArr(vehicleDependentActivityStates, null);
-        if(isIndexedBased) {
-            fill_twoDimArr(routeStatesArr, null);
-            fill_threeDimArr(vehicleDependentRouteStatesArr, null);
-        }
-        else{
-            routeStateMap.clear();
-            vehicleDependentRouteStateMap.clear();
-        }
-        Arrays.fill(problemStates,null);
-    }
-
-    private void fill_threeDimArr(Object[][][] states, Object o) {
-        for (Object[][] twoDimArr : states) {
-            for (Object[] oneDimArr : twoDimArr) {
-                Arrays.fill(oneDimArr, o);
-            }
-        }
-    }
-
-    private void fill_twoDimArr(Object[][] states, Object o) {
-        for (Object[] rows : states) {
-            Arrays.fill(rows, o);
-        }
-    }
-
     /**
      * Returns associated state for the specified activity and stateId, or it returns null if no value is associated.
      * <p>If type class is not equal to the associated type class of the requested state value, it throws a ClassCastException.</p>
@@ -241,20 +188,6 @@ private void fill_twoDimArr(Object[][] states, Object o) {
         return state;
     }
 
-    /**
-     * Returns true if a state value is associated to the specified activity, vehicle and stateId.
-     *
-     * @param act     the activity for which a state value is associated to
-     * @param vehicle the vehicle for which a state value is associated to
-     * @param stateId the stateId which is the associated key to the problem state
-     * @return true if a state value is associated otherwise false
-     * @throws java.lang.IllegalStateException if <code>act.getIndex()==0</code> since this suggests that act has no index at all
-     */
-    public boolean hasActivityState(TourActivity act, Vehicle vehicle, StateId stateId) {
-        if (act.getIndex() == 0) throw new IllegalStateException("activity index is 0. this should not be.");
-        return vehicleDependentActivityStates[act.getIndex()][vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()] != null;
-    }
-
     /**
      * Returns the associated state value to the specified activity, vehicle and stateId, or null if no state value is
      * associated.
@@ -283,10 +216,6 @@ public boolean hasActivityState(TourActivity act, Vehicle vehicle, StateId state
         return state;
     }
 
-    private ClassCastException getClassCastException(ClassCastException e, StateId stateId, String requestedTypeClass, String memorizedTypeClass) {
-        return new ClassCastException(e + "\n" + "state with stateId '" + stateId.toString() + "' is of " + memorizedTypeClass + ". cannot cast it to " + requestedTypeClass + ".");
-    }
-
     /**
      * Returns the route state that is associated to the route and stateId, or null if no state is associated.
      * <p>If type class is not equal to the associated type class of the requested state value, it throws a ClassCastException.</p>
@@ -303,14 +232,13 @@ private ClassCastException getClassCastException(ClassCastException e, StateId s
     public <T> T getRouteState(VehicleRoute route, StateId stateId, Class<T> type) {
         if (route.isEmpty()) return null;
         T state = null;
-        if(isIndexedBased){
+        if (isIndexedBased) {
             try {
                 state = type.cast(routeStatesArr[route.getVehicle().getIndex()][stateId.getIndex()]);
             } catch (ClassCastException e) {
-                throw getClassCastException(e,stateId,type.toString(),routeStatesArr[route.getVehicle().getIndex()][stateId.getIndex()].getClass().toString());
+                throw getClassCastException(e, stateId, type.toString(), routeStatesArr[route.getVehicle().getIndex()][stateId.getIndex()].getClass().toString());
             }
-        }
-        else {
+        } else {
             try {
                 if (routeStateMap.containsKey(route)) {
                     state = type.cast(routeStateMap.get(route)[stateId.getIndex()]);
@@ -322,21 +250,6 @@ private ClassCastException getClassCastException(ClassCastException e, StateId s
         return state;
     }
 
-    /**
-     * Returns true if a state is assigned to the specified route, vehicle and stateId. Otherwise it returns false.
-     *
-     * @param route   the route for which the state is requested
-     * @param vehicle the vehicle for which the state is requested
-     * @param stateId the stateId(entifier) for the state that is requested
-     * @return true if state exists and false otherwise
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public boolean hasRouteState(VehicleRoute route, Vehicle vehicle, StateId stateId) {
-        if (!vehicleDependentRouteStateMap.containsKey(route)) return false;
-        return vehicleDependentRouteStateMap.get(route)[vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()] != null;
-//        return vehicle_dependent_route_states[route.getActivities().get(0).getIndex()][vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()] != null;
-    }
-
     /**
      * Returns the route state that is assigned to the specified route, vehicle and stateId.
      * <p>Returns null if no state can be found</p>
@@ -353,14 +266,13 @@ public boolean hasRouteState(VehicleRoute route, Vehicle vehicle, StateId stateI
     public <T> T getRouteState(VehicleRoute route, Vehicle vehicle, StateId stateId, Class<T> type) {
         if (route.isEmpty()) return null;
         T state = null;
-        if(isIndexedBased){
+        if (isIndexedBased) {
             try {
                 state = type.cast(vehicleDependentRouteStatesArr[route.getVehicle().getIndex()][vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()]);
             } catch (ClassCastException e) {
                 throw getClassCastException(e, stateId, type.toString(), vehicleDependentRouteStatesArr[route.getVehicle().getIndex()][vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()].getClass().toString());
             }
-        }
-        else {
+        } else {
             try {
                 if (vehicleDependentRouteStateMap.containsKey(route)) {
                     state = type.cast(vehicleDependentRouteStateMap.get(route)[vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()]);
@@ -372,6 +284,39 @@ public boolean hasRouteState(VehicleRoute route, Vehicle vehicle, StateId stateI
         return state;
     }
 
+    private ClassCastException getClassCastException(ClassCastException e, StateId stateId, String requestedTypeClass, String memorizedTypeClass) {
+        return new ClassCastException(e + "\n" + "state with stateId '" + stateId.toString() + "' is of " + memorizedTypeClass + ". cannot cast it to " + requestedTypeClass + ".");
+    }
+
+    /**
+     * Returns true if a state value is associated to the specified activity, vehicle and stateId.
+     *
+     * @param act     the activity for which a state value is associated to
+     * @param vehicle the vehicle for which a state value is associated to
+     * @param stateId the stateId which is the associated key to the problem state
+     * @return true if a state value is associated otherwise false
+     * @throws java.lang.IllegalStateException if <code>act.getIndex()==0</code> since this suggests that act has no index at all
+     */
+    public boolean hasActivityState(TourActivity act, Vehicle vehicle, StateId stateId) {
+        if (act.getIndex() == 0) throw new IllegalStateException("activity index is 0. this should not be.");
+        return vehicleDependentActivityStates[act.getIndex()][vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()] != null;
+    }
+
+    /**
+     * Returns true if a state is assigned to the specified route, vehicle and stateId. Otherwise it returns false.
+     *
+     * @param route   the route for which the state is requested
+     * @param vehicle the vehicle for which the state is requested
+     * @param stateId the stateId(entifier) for the state that is requested
+     * @return true if state exists and false otherwise
+     */
+    @SuppressWarnings("UnusedDeclaration")
+    public boolean hasRouteState(VehicleRoute route, Vehicle vehicle, StateId stateId) {
+        if (!vehicleDependentRouteStateMap.containsKey(route)) return false;
+        return vehicleDependentRouteStateMap.get(route)[vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()] != null;
+//        return vehicle_dependent_route_states[route.getActivities().get(0).getIndex()][vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()] != null;
+    }
+
     /**
      * Associates the specified activity and stateId to the state value. If a state value is already associated to the
      * specified activity and stateId, it is replaced by the new state value.
@@ -394,6 +339,10 @@ public boolean hasRouteState(VehicleRoute route, Vehicle vehicle, StateId stateI
         putInternalTypedActivityState(act, stateId, state);
     }
 
+    <T> void putInternalTypedActivityState(TourActivity act, StateId stateId, T state) {
+        activityStates[act.getIndex()][stateId.getIndex()] = state;
+    }
+
     /**
      * Associates the specified activity, vehicle and stateId to the state value. If a state value is already associated to the
      * specified activity and stateId, it is replaced by the new state value.
@@ -417,10 +366,6 @@ public boolean hasRouteState(VehicleRoute route, Vehicle vehicle, StateId stateI
         putInternalTypedActivityState(act, vehicle, stateId, state);
     }
 
-    <T> void putInternalTypedActivityState(TourActivity act, StateId stateId, T state) {
-        activityStates[act.getIndex()][stateId.getIndex()] = state;
-    }
-
     <T> void putInternalTypedActivityState(TourActivity act, Vehicle vehicle, StateId stateId, T state) {
         vehicleDependentActivityStates[act.getIndex()][vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()] = state;
     }
@@ -440,6 +385,18 @@ public boolean hasRouteState(VehicleRoute route, Vehicle vehicle, StateId stateI
         putTypedInternalRouteState(route, stateId, state);
     }
 
+    <T> void putTypedInternalRouteState(VehicleRoute route, StateId stateId, T state) {
+        if (route.isEmpty()) return;
+        if (isIndexedBased) {
+            routeStatesArr[route.getVehicle().getIndex()][stateId.getIndex()] = state;
+        } else {
+            if (!routeStateMap.containsKey(route)) {
+                routeStateMap.put(route, new Object[stateIndexCounter]);
+            }
+            routeStateMap.get(route)[stateId.getIndex()] = state;
+        }
+    }
+
     /**
      * Associates the specified route, vehicle and stateId to the state value. If a state value is already associated to the
      * specified activity and stateId, it is replaced by the new state value.
@@ -457,25 +414,11 @@ public boolean hasRouteState(VehicleRoute route, Vehicle vehicle, StateId stateI
         putTypedInternalRouteState(route, vehicle, stateId, state);
     }
 
-    <T> void putTypedInternalRouteState(VehicleRoute route, StateId stateId, T state) {
-        if (route.isEmpty()) return;
-        if(isIndexedBased){
-            routeStatesArr[route.getVehicle().getIndex()][stateId.getIndex()] = state;
-        }
-        else {
-            if (!routeStateMap.containsKey(route)) {
-                routeStateMap.put(route, new Object[stateIndexCounter]);
-            }
-            routeStateMap.get(route)[stateId.getIndex()] = state;
-        }
-    }
-
     <T> void putTypedInternalRouteState(VehicleRoute route, Vehicle vehicle, StateId stateId, T state) {
         if (route.isEmpty()) return;
-        if(isIndexedBased){
+        if (isIndexedBased) {
             vehicleDependentRouteStatesArr[route.getVehicle().getIndex()][vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()] = state;
-        }
-        else {
+        } else {
             if (!vehicleDependentRouteStateMap.containsKey(route)) {
                 vehicleDependentRouteStateMap.put(route, new Object[nuVehicleTypeKeys][stateIndexCounter]);
             }
@@ -484,6 +427,10 @@ public boolean hasRouteState(VehicleRoute route, Vehicle vehicle, StateId stateI
 
     }
 
+    public void addAllStateUpdater(Collection<StateUpdater> updaters) {
+        for (StateUpdater u : updaters) addStateUpdater(u);
+    }
+
     /**
      * Adds state updater.
      * <p>
@@ -505,20 +452,6 @@ public void addStateUpdater(StateUpdater updater) {
         updaters.add(updater);
     }
 
-    public void addAllStateUpdater(Collection<StateUpdater> updaters) {
-        for (StateUpdater u : updaters) addStateUpdater(u);
-    }
-
-    /**
-     * Returns an unmodifiable collections of stateUpdaters that have been added to this stateManager.
-     *
-     * @return an unmodifiable collections of stateUpdaters that have been added to this stateManager.
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    Collection<StateUpdater> getStateUpdaters() {
-        return Collections.unmodifiableCollection(updaters);
-    }
-
     /**
      * Adds an activityVisitor.
      * <p>This visitor visits all activities in a route subsequently in two cases. First, if insertionStart (after ruinStrategies have removed activities from routes)
@@ -545,12 +478,22 @@ void addRouteVisitor(RouteVisitor routeVisitor) {
         routeVisitors.add(routeVisitor);
     }
 
+    void addListener(InsertionListener insertionListener) {
+        insertionListeners.addListener(insertionListener);
+    }
+
     void addListener(RuinListener ruinListener) {
         ruinListeners.addListener(ruinListener);
     }
 
-    void addListener(InsertionListener insertionListener) {
-        insertionListeners.addListener(insertionListener);
+    /**
+     * Returns an unmodifiable collections of stateUpdaters that have been added to this stateManager.
+     *
+     * @return an unmodifiable collections of stateUpdaters that have been added to this stateManager.
+     */
+    @SuppressWarnings("UnusedDeclaration")
+    Collection<StateUpdater> getStateUpdaters() {
+        return Collections.unmodifiableCollection(updaters);
     }
 
     @Override
@@ -564,6 +507,10 @@ public void informJobInserted(Job job2insert, VehicleRoute inRoute, double addit
         revRouteActivityVisitor.visit(inRoute);
     }
 
+    public void reCalculateStates(VehicleRoute route) {
+        informInsertionStarts(Arrays.asList(route), Collections.<Job>emptyList());
+    }
+
     @Override
     public void informInsertionStarts(Collection<VehicleRoute> vehicleRoutes, Collection<Job> unassignedJobs) {
         insertionListeners.informInsertionStarts(vehicleRoutes, unassignedJobs);
@@ -576,15 +523,41 @@ public void informInsertionStarts(Collection<VehicleRoute> vehicleRoutes, Collec
         }
     }
 
-    public void reCalculateStates(VehicleRoute route){
-        informInsertionStarts(Arrays.asList(route),Collections.<Job>emptyList());
-    }
-
     @Override
     public void informIterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
         clear();
     }
 
+    /**
+     * Clears all states, i.e. set all value to null.
+     */
+    public void clear() {
+        fill_twoDimArr(activityStates, null);
+        fill_threeDimArr(vehicleDependentActivityStates, null);
+        if (isIndexedBased) {
+            fill_twoDimArr(routeStatesArr, null);
+            fill_threeDimArr(vehicleDependentRouteStatesArr, null);
+        } else {
+            routeStateMap.clear();
+            vehicleDependentRouteStateMap.clear();
+        }
+        Arrays.fill(problemStates, null);
+    }
+
+    private void fill_twoDimArr(Object[][] states, Object o) {
+        for (Object[] rows : states) {
+            Arrays.fill(rows, o);
+        }
+    }
+
+    private void fill_threeDimArr(Object[][][] states, Object o) {
+        for (Object[][] twoDimArr : states) {
+            for (Object[] oneDimArr : twoDimArr) {
+                Arrays.fill(oneDimArr, o);
+            }
+        }
+    }
+
     @Override
     public void ruinStarts(Collection<VehicleRoute> routes) {
         ruinListeners.ruinStarts(routes);
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateActivityTimes.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateActivityTimes.java
index edf4c8dec..8f041861d 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateActivityTimes.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateActivityTimes.java
@@ -49,7 +49,7 @@
      */
     public UpdateActivityTimes(ForwardTransportTime transportTime, VehicleRoutingActivityCosts activityCosts) {
         super();
-        timeTracker = new ActivityTimeTracker(transportTime,activityCosts );
+        timeTracker = new ActivityTimeTracker(transportTime, activityCosts);
     }
 
     public UpdateActivityTimes(ForwardTransportTime transportTime, ActivityTimeTracker.ActivityPolicy activityPolicy, VehicleRoutingActivityCosts activityCosts) {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateFutureWaitingTimes.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateFutureWaitingTimes.java
index 5c28802d0..48df23677 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateFutureWaitingTimes.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateFutureWaitingTimes.java
@@ -53,9 +53,9 @@ public void begin(VehicleRoute route) {
     @Override
     public void visit(TourActivity activity) {
         states.putInternalTypedActivityState(activity, route.getVehicle(), InternalStates.FUTURE_WAITING, futureWaiting);
-		if(!(activity instanceof BreakActivity)) {
+        if (!(activity instanceof BreakActivity)) {
             futureWaiting += Math.max(activity.getTheoreticalEarliestOperationStartTime() - activity.getArrTime(), 0);
-		}
+        }
     }
 
     @Override
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateLoads.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateLoads.java
index 3fd7bd039..bfea81076 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateLoads.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateLoads.java
@@ -80,6 +80,13 @@ public void finish() {
         currentLoad = Capacity.Builder.newInstance().build();
     }
 
+    @Override
+    public void informInsertionStarts(Collection<VehicleRoute> vehicleRoutes, Collection<Job> unassignedJobs) {
+        for (VehicleRoute route : vehicleRoutes) {
+            insertionStarts(route);
+        }
+    }
+
     void insertionStarts(VehicleRoute route) {
         Capacity loadAtDepot = Capacity.Builder.newInstance().build();
         Capacity loadAtEnd = Capacity.Builder.newInstance().build();
@@ -94,13 +101,6 @@ void insertionStarts(VehicleRoute route) {
         stateManager.putTypedInternalRouteState(route, InternalStates.LOAD_AT_END, loadAtEnd);
     }
 
-    @Override
-    public void informInsertionStarts(Collection<VehicleRoute> vehicleRoutes, Collection<Job> unassignedJobs) {
-        for (VehicleRoute route : vehicleRoutes) {
-            insertionStarts(route);
-        }
-    }
-
     @Override
     public void informJobInserted(Job job2insert, VehicleRoute inRoute, double additionalCosts, double additionalTime) {
         if (job2insert instanceof Delivery) {
@@ -114,7 +114,7 @@ public void informJobInserted(Job job2insert, VehicleRoute inRoute, double addit
         }
     }
 
-    public void informRouteChanged(VehicleRoute route){
+    public void informRouteChanged(VehicleRoute route) {
         insertionStarts(route);
     }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicle.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicle.java
index dc8fbcadc..7fb6f83a3 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicle.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicle.java
@@ -31,32 +31,20 @@
 /**
  * Created by schroeder on 15/09/16.
  */
-public class UpdateMaxTimeInVehicle implements StateUpdater, ActivityVisitor{
+public class UpdateMaxTimeInVehicle implements StateUpdater, ActivityVisitor {
 
+    private final StateManager stateManager;
+    private final StateId minSlackId;
+    private final StateId openJobsId;
+    private final TransportTime transportTime;
+    private final VehicleRoutingActivityCosts activityCosts;
     private Map<Integer, Map<Job, Double>> openPickupEndTimesPerVehicle = new HashMap<>();
-
     private Map<Integer, Map<TourActivity, Double>> slackTimesPerVehicle = new HashMap<>();
-
     private Map<Integer, Map<TourActivity, Double>> actStartTimesPerVehicle = new HashMap<>();
-
     private VehicleRoute route;
-
-    private final StateManager stateManager;
-
-    private final StateId minSlackId;
-
-    private final StateId openJobsId;
-
     private double[] prevActEndTimes;
-
     private Location[] prevActLocations;
-
     private Collection<Vehicle> vehicles;
-
-    private final TransportTime transportTime;
-
-    private final VehicleRoutingActivityCosts activityCosts;
-
     private UpdateVehicleDependentPracticalTimeWindows.VehiclesToUpdate vehiclesToUpdate = new UpdateVehicleDependentPracticalTimeWindows.VehiclesToUpdate() {
 
         @Override
@@ -90,7 +78,7 @@ public void begin(VehicleRoute route) {
         actStartTimesPerVehicle.clear();
         vehicles = vehiclesToUpdate.get(route);
         this.route = route;
-        for(Vehicle v : vehicles){
+        for (Vehicle v : vehicles) {
             int vehicleIndex = v.getVehicleTypeIdentifier().getIndex();
             openPickupEndTimesPerVehicle.put(vehicleIndex, new HashMap<Job, Double>());
             slackTimesPerVehicle.put(vehicleIndex, new HashMap<TourActivity, Double>());
@@ -104,13 +92,13 @@ public void begin(VehicleRoute route) {
     public void visit(TourActivity activity) {
         double maxTime = getMaxTimeInVehicle(activity);
 
-        for(Vehicle v : vehicles) {
+        for (Vehicle v : vehicles) {
             int vehicleIndex = v.getVehicleTypeIdentifier().getIndex();
             Location prevActLocation = prevActLocations[vehicleIndex];
             double prevActEndTime = prevActEndTimes[v.getVehicleTypeIdentifier().getIndex()];
-            double activityArrival = prevActEndTimes[v.getVehicleTypeIdentifier().getIndex()] + transportTime.getTransportTime(prevActLocation,activity.getLocation(),prevActEndTime,route.getDriver(),v);
-            double activityStart = Math.max(activityArrival,activity.getTheoreticalEarliestOperationStartTime());
-            memorizeActStart(activity,v,activityStart);
+            double activityArrival = prevActEndTimes[v.getVehicleTypeIdentifier().getIndex()] + transportTime.getTransportTime(prevActLocation, activity.getLocation(), prevActEndTime, route.getDriver(), v);
+            double activityStart = Math.max(activityArrival, activity.getTheoreticalEarliestOperationStartTime());
+            memorizeActStart(activity, v, activityStart);
             double activityEnd = activityStart + activityCosts.getActivityDuration(activity, activityArrival, route.getDriver(), v);
             Map<Job, Double> openPickups = openPickupEndTimesPerVehicle.get(vehicleIndex);
             if (activity instanceof ServiceActivity || activity instanceof PickupActivity) {
@@ -133,7 +121,7 @@ public void visit(TourActivity activity) {
 
     private double getMaxTimeInVehicle(TourActivity activity) {
         double maxTime = Double.MAX_VALUE;
-        if(activity instanceof TourActivity.JobActivity){
+        if (activity instanceof TourActivity.JobActivity) {
             maxTime = ((TourActivity.JobActivity) activity).getJob().getMaxTimeInVehicle();
         }
         return maxTime;
@@ -145,13 +133,14 @@ private void memorizeActStart(TourActivity activity, Vehicle v, double activityS
 
     @Override
     public void finish() {
-        for(Vehicle v : vehicles) {
+        for (Vehicle v : vehicles) {
             int vehicleIndex = v.getVehicleTypeIdentifier().getIndex();
 
             //!!! open routes !!!
             double routeEnd;
-            if(!v.isReturnToDepot()) routeEnd = prevActEndTimes[vehicleIndex];
-            else routeEnd = prevActEndTimes[vehicleIndex] + transportTime.getTransportTime(prevActLocations[vehicleIndex],v.getEndLocation(),prevActEndTimes[vehicleIndex],route.getDriver(),v);
+            if (!v.isReturnToDepot()) routeEnd = prevActEndTimes[vehicleIndex];
+            else
+                routeEnd = prevActEndTimes[vehicleIndex] + transportTime.getTransportTime(prevActLocations[vehicleIndex], v.getEndLocation(), prevActEndTimes[vehicleIndex], route.getDriver(), v);
 
             Map<Job, Double> openDeliveries = new HashMap<>();
             for (Job job : openPickupEndTimesPerVehicle.get(vehicleIndex).keySet()) {
@@ -187,6 +176,14 @@ public void finish() {
         }
     }
 
+    private double minSlackTime(Map<Job, Double> openDeliveries) {
+        double min = Double.MAX_VALUE;
+        for (Double value : openDeliveries.values()) {
+            if (value < min) min = value;
+        }
+        return min;
+    }
+
     public void finish(List<TourActivity> activities, Job ignore) {
         for (Vehicle v : vehicles) {
             int vehicleIndex = v.getVehicleTypeIdentifier().getIndex();
@@ -233,12 +230,4 @@ public void finish(List<TourActivity> activities, Job ignore) {
     private double actStart(TourActivity act, Vehicle v) {
         return actStartTimesPerVehicle.get(v.getVehicleTypeIdentifier().getIndex()).get(act);
     }
-
-    private double minSlackTime(Map<Job, Double> openDeliveries) {
-        double min = Double.MAX_VALUE;
-        for(Double value : openDeliveries.values()){
-           if(value < min) min = value;
-        }
-        return min;
-    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdatePracticalTimeWindows.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdatePracticalTimeWindows.java
index 075eed7ff..aa5f0ecd6 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdatePracticalTimeWindows.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdatePracticalTimeWindows.java
@@ -58,7 +58,7 @@ public void begin(VehicleRoute route) {
 
     @Override
     public void visit(TourActivity activity) {
-        double potentialLatestArrivalTimeAtCurrAct = latestArrTimeAtPrevAct - transportCosts.getBackwardTransportTime(activity.getLocation(), prevAct.getLocation(), latestArrTimeAtPrevAct, route.getDriver(), route.getVehicle()) - activityCosts.getActivityDuration(activity,latestArrTimeAtPrevAct,route.getDriver(),route.getVehicle());
+        double potentialLatestArrivalTimeAtCurrAct = latestArrTimeAtPrevAct - transportCosts.getBackwardTransportTime(activity.getLocation(), prevAct.getLocation(), latestArrTimeAtPrevAct, route.getDriver(), route.getVehicle()) - activityCosts.getActivityDuration(activity, latestArrTimeAtPrevAct, route.getDriver(), route.getVehicle());
         double latestArrivalTime = Math.min(activity.getTheoreticalLatestOperationStartTime(), potentialLatestArrivalTimeAtCurrAct);
 
         states.putInternalTypedActivityState(activity, InternalStates.LATEST_OPERATION_START_TIME, latestArrivalTime);
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateVehicleDependentPracticalTimeWindows.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateVehicleDependentPracticalTimeWindows.java
index 0fb6e0f8d..8a66869c3 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateVehicleDependentPracticalTimeWindows.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateVehicleDependentPracticalTimeWindows.java
@@ -32,22 +32,9 @@
 
 public class UpdateVehicleDependentPracticalTimeWindows implements RouteVisitor, StateUpdater {
 
-    @Override
-    public void visit(VehicleRoute route) {
-        begin(route);
-        Iterator<TourActivity> revIterator = route.getTourActivities().reverseActivityIterator();
-        while (revIterator.hasNext()) {
-            visit(revIterator.next());
-        }
-        finish();
-    }
-
-    public static interface VehiclesToUpdate {
-
-        public Collection<Vehicle> get(VehicleRoute route);
-
-    }
-
+    private final StateManager stateManager;
+    private final VehicleRoutingTransportCosts transportCosts;
+    private final VehicleRoutingActivityCosts activityCosts;
     private VehiclesToUpdate vehiclesToUpdate = new VehiclesToUpdate() {
 
         @Override
@@ -56,19 +43,9 @@ public void visit(VehicleRoute route) {
         }
 
     };
-
-    private final StateManager stateManager;
-
-    private final VehicleRoutingTransportCosts transportCosts;
-
-    private final VehicleRoutingActivityCosts activityCosts;
-
     private VehicleRoute route;
-
     private double[] latest_arrTimes_at_prevAct;
-
     private Location[] location_of_prevAct;
-
     private Collection<Vehicle> vehicles;
 
     public UpdateVehicleDependentPracticalTimeWindows(StateManager stateManager, VehicleRoutingTransportCosts tpCosts, VehicleRoutingActivityCosts activityCosts) {
@@ -80,25 +57,29 @@ public UpdateVehicleDependentPracticalTimeWindows(StateManager stateManager, Veh
         location_of_prevAct = new Location[stateManager.getMaxIndexOfVehicleTypeIdentifiers() + 1];
     }
 
-    public void setVehiclesToUpdate(VehiclesToUpdate vehiclesToUpdate) {
-        this.vehiclesToUpdate = vehiclesToUpdate;
+    @Override
+    public void visit(VehicleRoute route) {
+        begin(route);
+        Iterator<TourActivity> revIterator = route.getTourActivities().reverseActivityIterator();
+        while (revIterator.hasNext()) {
+            visit(revIterator.next());
+        }
+        finish();
     }
 
-
     public void begin(VehicleRoute route) {
         this.route = route;
         vehicles = vehiclesToUpdate.get(route);
         for (Vehicle vehicle : vehicles) {
             latest_arrTimes_at_prevAct[vehicle.getVehicleTypeIdentifier().getIndex()] = vehicle.getLatestArrival();
             Location location = vehicle.getEndLocation();
-            if(!vehicle.isReturnToDepot()){
+            if (!vehicle.isReturnToDepot()) {
                 location = route.getEnd().getLocation();
             }
             location_of_prevAct[vehicle.getVehicleTypeIdentifier().getIndex()] = location;
         }
     }
 
-
     public void visit(TourActivity activity) {
         for (Vehicle vehicle : vehicles) {
             double latestArrTimeAtPrevAct = latest_arrTimes_at_prevAct[vehicle.getVehicleTypeIdentifier().getIndex()];
@@ -115,9 +96,19 @@ public void visit(TourActivity activity) {
         }
     }
 
-
     public void finish() {
     }
 
+    public void setVehiclesToUpdate(VehiclesToUpdate vehiclesToUpdate) {
+        this.vehiclesToUpdate = vehiclesToUpdate;
+    }
+
+
+    public static interface VehiclesToUpdate {
+
+        public Collection<Vehicle> get(VehicleRoute route);
+
+    }
+
 }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/VehicleDependentTraveledDistance.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/VehicleDependentTraveledDistance.java
index 4fa68ca79..8884f8fd7 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/VehicleDependentTraveledDistance.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/VehicleDependentTraveledDistance.java
@@ -33,36 +33,11 @@
  */
 public class VehicleDependentTraveledDistance implements StateUpdater, ActivityVisitor {
 
-    static class State {
-
-        Location prevLocation;
-
-        double distance;
-
-        public State(Location prevLocation, double distance) {
-            this.prevLocation = prevLocation;
-            this.distance = distance;
-        }
-
-        public Location getPrevLocation() {
-            return prevLocation;
-        }
-
-        public double getDistance() {
-            return distance;
-        }
-    }
-
     private final TransportDistance transportDistance;
-
     private final StateManager stateManager;
-
     private final StateId traveledDistanceId;
-
     private VehicleRoute route;
-
     private List<Vehicle> uniqueVehicles;
-
     private Map<VehicleTypeKey, State> states;
 
     public VehicleDependentTraveledDistance(TransportDistance transportCostMatrices, StateManager stateManager, StateId distanceInRouteId, Collection<Vehicle> vehicles) {
@@ -117,4 +92,24 @@ public void finish() {
         }
     }
 
+    static class State {
+
+        Location prevLocation;
+
+        double distance;
+
+        public State(Location prevLocation, double distance) {
+            this.prevLocation = prevLocation;
+            this.distance = distance;
+        }
+
+        public Location getPrevLocation() {
+            return prevLocation;
+        }
+
+        public double getDistance() {
+            return distance;
+        }
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/termination/TimeTermination.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/termination/TimeTermination.java
index 39bfd0085..43e9e9aa9 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/termination/TimeTermination.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/termination/TimeTermination.java
@@ -41,16 +41,8 @@
  */
 public class TimeTermination implements PrematureAlgorithmTermination, AlgorithmStartsListener {
 
-    public static interface TimeGetter {
-
-        public long getCurrentTime();
-
-    }
-
     private static Logger logger = LoggerFactory.getLogger(TimeTermination.class);
-
     private final long timeThreshold;
-
     private TimeGetter timeGetter = new TimeGetter() {
 
         @Override
@@ -59,7 +51,6 @@ public long getCurrentTime() {
         }
 
     };
-
     private long startTime;
 
     /**
@@ -87,10 +78,6 @@ public boolean isPrematureBreak(SearchStrategy.DiscoveredSolution discoveredSolu
         return (now() - startTime) > timeThreshold;
     }
 
-    void start(long startTime) {
-        this.startTime = startTime;
-    }
-
     private long now() {
         return timeGetter.getCurrentTime();
     }
@@ -100,4 +87,14 @@ public void informAlgorithmStarts(VehicleRoutingProblem problem, VehicleRoutingA
         start(timeGetter.getCurrentTime());
     }
 
+    void start(long startTime) {
+        this.startTime = startTime;
+    }
+
+    public static interface TimeGetter {
+
+        public long getCurrentTime();
+
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/termination/VariationCoefficientTermination.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/termination/VariationCoefficientTermination.java
index 5f177c3d6..9bc3416cc 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/termination/VariationCoefficientTermination.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/termination/VariationCoefficientTermination.java
@@ -103,13 +103,17 @@ public boolean isPrematureBreak(SearchStrategy.DiscoveredSolution discoveredSolu
         return false;
     }
 
+    @Override
+    public void informAlgorithmStarts(VehicleRoutingProblem problem, VehicleRoutingAlgorithm algorithm, Collection<VehicleRoutingProblemSolution> solutions) {
+        reset();
+    }
+
     private void reset() {
         currentIteration = 0;
     }
 
-    @Override
-    public void informAlgorithmStarts(VehicleRoutingProblem problem, VehicleRoutingAlgorithm algorithm, Collection<VehicleRoutingProblemSolution> solutions) {
-        reset();
+    public void informIterationEnds(int i, VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution) {
+        informIterationEnds(i, problem, toList(solution));
     }
 
     @Override
@@ -121,22 +125,18 @@ public void informIterationEnds(int i, VehicleRoutingProblem problem, Collection
         }
     }
 
-    public void informIterationEnds(int i, VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution) {
-        informIterationEnds(i, problem, toList(solution));
-    }
-
     private List<VehicleRoutingProblemSolution> toList(VehicleRoutingProblemSolution solution) {
         List<VehicleRoutingProblemSolution> solutions = new ArrayList<>();
         solutions.add(solution);
         return solutions;
     }
 
+    public void informIterationStarts(int i, VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution) {
+        informIterationStarts(i, problem, toList(solution));
+    }
+
     @Override
     public void informIterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
         if (lastAccepted == null) lastAccepted = Solutions.bestOf(solutions);
     }
-
-    public void informIterationStarts(int i, VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution) {
-        informIterationStarts(i, problem, toList(solution));
-    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyser.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyser.java
index e6cedd77b..2de761833 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyser.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyser.java
@@ -53,1161 +53,1117 @@
     private final static String LOAD_PICKED = "load-picked";
 
     private final static String LOAD_DELIVERED = "load-delivered";
-
-
-
-
-    private static class LoadAndActivityCounter implements StateUpdater, ActivityVisitor {
-
-        private final StateManager stateManager;
-
-        private int pickupCounter;
-
-        private int pickupAtBeginningCounter;
-
-        private int deliveryCounter;
-
-        private int deliverAtEndCounter;
-
-        private Capacity pickedUp;
-
-        private Capacity delivered;
-
-        private StateId pickup_count_id;
-
-        private StateId pickup_at_beginning_count_id;
-
-        private StateId delivery_count_id;
-
-        private StateId delivery_at_end_count_id;
-
-        private StateId load_picked_id;
-
-        private StateId load_delivered_id;
-
-        private VehicleRoute route;
-
-        private LoadAndActivityCounter(StateManager stateManager) {
-            this.stateManager = stateManager;
-            pickup_count_id = stateManager.createStateId(PICKUP_COUNT);
-            delivery_count_id = stateManager.createStateId(DELIVERY_COUNT);
-            load_picked_id = stateManager.createStateId(LOAD_PICKED);
-            load_delivered_id = stateManager.createStateId(LOAD_DELIVERED);
-            pickup_at_beginning_count_id = stateManager.createStateId(PICKUP_COUNT_AT_BEGINNING);
-            delivery_at_end_count_id = stateManager.createStateId(DELIVERY_COUNT_AT_END);
-        }
-
-        @Override
-        public void begin(VehicleRoute route) {
-            this.route = route;
-            pickupCounter = 0;
-            pickupAtBeginningCounter = 0;
-            deliveryCounter = 0;
-            deliverAtEndCounter = 0;
-            pickedUp = Capacity.Builder.newInstance().build();
-            delivered = Capacity.Builder.newInstance().build();
-        }
-
-        @Override
-        public void visit(TourActivity activity) {
-            if (activity instanceof PickupActivity) {
-                pickupCounter++;
-                pickedUp = Capacity.addup(pickedUp, ((PickupActivity) activity).getJob().getSize());
-                if (activity instanceof PickupService) {
-                    deliverAtEndCounter++;
-                }
-            } else if (activity instanceof DeliveryActivity) {
-                deliveryCounter++;
-                delivered = Capacity.addup(delivered, ((DeliveryActivity) activity).getJob().getSize());
-                if (activity instanceof DeliverService) {
-                    pickupAtBeginningCounter++;
-                }
-            }
-        }
-
-        @Override
-        public void finish() {
-            stateManager.putRouteState(route, pickup_count_id, pickupCounter);
-            stateManager.putRouteState(route, delivery_count_id, deliveryCounter);
-            stateManager.putRouteState(route, load_picked_id, pickedUp);
-            stateManager.putRouteState(route, load_delivered_id, delivered);
-            stateManager.putRouteState(route, pickup_at_beginning_count_id, pickupAtBeginningCounter);
-            stateManager.putRouteState(route, delivery_at_end_count_id, deliverAtEndCounter);
-        }
-    }
-
-    private static class BackhaulAndShipmentUpdater implements StateUpdater, ActivityVisitor {
-
-        private final StateId backhaul_id;
-
-        private final StateId shipment_id;
-
-        private final StateManager stateManager;
-
-        private Map<String, PickupShipment> openShipments;
-
-        private VehicleRoute route;
-
-        private Boolean shipmentConstraintOnRouteViolated;
-
-        private Boolean backhaulConstraintOnRouteViolated;
-
-        private boolean pickupOccured;
-
-        private BackhaulAndShipmentUpdater(StateId backhaul_id, StateId shipment_id, StateManager stateManager) {
-            this.stateManager = stateManager;
-            this.backhaul_id = backhaul_id;
-            this.shipment_id = shipment_id;
-        }
-
-        @Override
-        public void begin(VehicleRoute route) {
-            this.route = route;
-            openShipments = new HashMap<String, PickupShipment>();
-            pickupOccured = false;
-            shipmentConstraintOnRouteViolated = false;
-            backhaulConstraintOnRouteViolated = false;
-        }
-
-        @Override
-        public void visit(TourActivity activity) {
-            //shipment
-            if (activity instanceof PickupShipment) {
-                openShipments.put(((PickupShipment) activity).getJob().getId(), (PickupShipment) activity);
-            } else if (activity instanceof DeliverShipment) {
-                String jobId = ((DeliverShipment) activity).getJob().getId();
-                if (!openShipments.containsKey(jobId)) {
-                    //deliverShipment without pickupShipment
-                    stateManager.putActivityState(activity, shipment_id, true);
-                    shipmentConstraintOnRouteViolated = true;
-                } else {
-                    PickupShipment removed = openShipments.remove(jobId);
-                    stateManager.putActivityState(removed, shipment_id, false);
-                    stateManager.putActivityState(activity, shipment_id, false);
-                }
-            } else stateManager.putActivityState(activity, shipment_id, false);
-
-            //backhaul
-            if (activity instanceof DeliverService && pickupOccured) {
-                stateManager.putActivityState(activity, backhaul_id, true);
-                backhaulConstraintOnRouteViolated = true;
-            } else {
-                if (activity instanceof PickupService || activity instanceof ServiceActivity || activity instanceof PickupShipment) {
-                    pickupOccured = true;
-                    stateManager.putActivityState(activity, backhaul_id, false);
-                } else stateManager.putActivityState(activity, backhaul_id, false);
-            }
-        }
-
-        @Override
-        public void finish() {
-            //shipment
-            //pickups without deliveries
-            for (TourActivity act : openShipments.values()) {
-                stateManager.putActivityState(act, shipment_id, true);
-                shipmentConstraintOnRouteViolated = true;
-            }
-            stateManager.putRouteState(route, shipment_id, shipmentConstraintOnRouteViolated);
-            //backhaul
-            stateManager.putRouteState(route, backhaul_id, backhaulConstraintOnRouteViolated);
-        }
-    }
-
-    private static class SumUpActivityTimes implements StateUpdater, ActivityVisitor {
-
-        private StateId waiting_time_id;
-
-        private StateId transport_time_id;
-
-        private StateId service_time_id;
-
-        private StateId too_late_id;
-
-        private StateManager stateManager;
-
-        private final VehicleRoutingActivityCosts activityCosts;
-
-        private ActivityTimeTracker.ActivityPolicy activityPolicy;
-
-        private VehicleRoute route;
-
-        double sum_waiting_time = 0.;
-
-        double sum_transport_time = 0.;
-
-        double sum_service_time = 0.;
-
-        double sum_too_late = 0.;
-
-        double prevActDeparture;
-
-        private SumUpActivityTimes(StateId waiting_time_id, StateId transport_time_id, StateId service_time_id, StateId too_late_id, StateManager stateManager, ActivityTimeTracker.ActivityPolicy activityPolicy, VehicleRoutingActivityCosts activityCosts) {
-            this.waiting_time_id = waiting_time_id;
-            this.transport_time_id = transport_time_id;
-            this.service_time_id = service_time_id;
-            this.too_late_id = too_late_id;
-            this.stateManager = stateManager;
-            this.activityPolicy = activityPolicy;
-            this.activityCosts = activityCosts;
-        }
-
-        @Override
-        public void begin(VehicleRoute route) {
-            this.route = route;
-            sum_waiting_time = 0.;
-            sum_transport_time = 0.;
-            sum_service_time = 0.;
-            sum_too_late = 0.;
-            prevActDeparture = route.getDepartureTime();
-        }
-
-        @Override
-        public void visit(TourActivity activity) {
-            //waiting time & toolate
-            double waitAtAct = 0.;
-            double tooLate = 0.;
-            if (activityPolicy.equals(ActivityTimeTracker.ActivityPolicy.AS_SOON_AS_TIME_WINDOW_OPENS)) {
-                waitAtAct = Math.max(0, activity.getTheoreticalEarliestOperationStartTime() - activity.getArrTime());
-                tooLate = Math.max(0, activity.getArrTime() - activity.getTheoreticalLatestOperationStartTime());
-            }
-            sum_waiting_time += waitAtAct;
-            sum_too_late += tooLate;
-            //transport time
-            double transportTime = activity.getArrTime() - prevActDeparture;
-            sum_transport_time += transportTime;
-            prevActDeparture = activity.getEndTime();
-            //service time
-            sum_service_time += activityCosts.getActivityDuration(activity, activity.getArrTime(), route.getDriver(), route.getVehicle());
-
-            stateManager.putActivityState(activity, transport_time_id, sum_transport_time);
-
-        }
-
-        @Override
-        public void finish() {
-            sum_transport_time += route.getEnd().getArrTime() - prevActDeparture;
-            sum_too_late += Math.max(0, route.getEnd().getArrTime() - route.getEnd().getTheoreticalLatestOperationStartTime());
-            stateManager.putRouteState(route, transport_time_id, sum_transport_time);
-            stateManager.putRouteState(route, waiting_time_id, sum_waiting_time);
-            stateManager.putRouteState(route, service_time_id, sum_service_time);
-            stateManager.putRouteState(route, too_late_id, sum_too_late);
-        }
-    }
-
-    private static class LastTransportUpdater implements StateUpdater, ActivityVisitor {
-        private final StateManager stateManager;
-        private final VehicleRoutingTransportCosts transportCost;
-        private final TransportDistance distanceCalculator;
-        private final StateId last_transport_distance_id;
-        private final StateId last_transport_time_id;
-        private final StateId last_transport_cost_id;
-        private TourActivity prevAct;
-        private double prevActDeparture;
-        private VehicleRoute route;
-
-
-        private LastTransportUpdater(StateManager stateManager, VehicleRoutingTransportCosts transportCost, TransportDistance distanceCalculator, StateId last_distance_id, StateId last_time_id, StateId last_cost_id) {
-            this.stateManager = stateManager;
-            this.transportCost = transportCost;
-            this.distanceCalculator = distanceCalculator;
-            this.last_transport_distance_id = last_distance_id;
-            this.last_transport_time_id = last_time_id;
-            this.last_transport_cost_id = last_cost_id;
-        }
-
-        @Override
-        public void begin(VehicleRoute route) {
-            this.route = route;
-            this.prevAct = route.getStart();
-            this.prevActDeparture = route.getDepartureTime();
-        }
-
-        @Override
-        public void visit(TourActivity activity) {
-            stateManager.putActivityState(activity, last_transport_distance_id, distance(activity));
-            stateManager.putActivityState(activity, last_transport_time_id, transportTime(activity));
-            stateManager.putActivityState(activity, last_transport_cost_id, transportCost(activity));
-
-            prevAct = activity;
-            prevActDeparture = activity.getEndTime();
-        }
-
-        private double transportCost(TourActivity activity) {
-            return transportCost.getTransportCost(prevAct.getLocation(), activity.getLocation(), prevActDeparture, route.getDriver(), route.getVehicle());
-        }
-
-        private double transportTime(TourActivity activity) {
-            return activity.getArrTime() - prevActDeparture;
-        }
-
-        private double distance(TourActivity activity) {
-            return distanceCalculator.getDistance(prevAct.getLocation(), activity.getLocation(),prevActDeparture, route.getVehicle());
-        }
-
-        @Override
-        public void finish() {
-            stateManager.putRouteState(route, last_transport_distance_id, distance(route.getEnd()));
-            stateManager.putRouteState(route, last_transport_time_id, transportTime(route.getEnd()));
-            stateManager.putRouteState(route, last_transport_cost_id, transportCost(route.getEnd()));
-        }
-
+    private static final Logger log = LoggerFactory.getLogger(SolutionAnalyser.class);
+    private final SolutionCostCalculator solutionCostCalculator;
+    private VehicleRoutingProblem vrp;
+    private StateManager stateManager;
+    private TransportDistance distanceCalculator;
+    private StateId waiting_time_id;
+    private StateId transport_time_id;
+    private StateId service_time_id;
+    private StateId distance_id;
+    private StateId too_late_id;
+    private StateId shipment_id;
+    private StateId backhaul_id;
+    private StateId skill_id;
+    private StateId last_transport_distance_id;
+    private StateId last_transport_time_id;
+    private StateId last_transport_cost_id;
+    private ActivityTimeTracker.ActivityPolicy activityPolicy;
+    private Double tp_distance;
+    private Double tp_time;
+    private Double waiting_time;
+    private Double service_time;
+    private Double operation_time;
+    private Double tw_violation;
+    private Capacity cap_violation;
+    private Double fixed_costs;
+    private Double variable_transport_costs;
+    private Boolean hasSkillConstraintViolation;
+    private Boolean hasBackhaulConstraintViolation;
+    private Boolean hasShipmentConstraintViolation;
+    private Integer noPickups;
+    private Integer noPickupsAtBeginning;
+    private Integer noDeliveries;
+    private Integer noDeliveriesAtEnd;
+    private Capacity pickupLoad;
+    private Capacity pickupLoadAtBeginning;
+    private Capacity deliveryLoad;
+    private Capacity deliveryLoadAtEnd;
+    private double maxOperationTime;
+    private Double total_costs;
+    private VehicleRoutingProblemSolution solution;
+    /**
+     * @param vrp
+     * @param solution
+     * @param distanceCalculator
+     */
+    public SolutionAnalyser(VehicleRoutingProblem vrp, VehicleRoutingProblemSolution solution, TransportDistance distanceCalculator) {
+        this.vrp = vrp;
+        this.solution = solution;
+        this.distanceCalculator = distanceCalculator;
+        initialise();
+        this.solutionCostCalculator = new VariablePlusFixedSolutionCostCalculatorFactory(stateManager).createCalculator();
+        refreshStates();
     }
 
-    private static class DistanceUpdater implements StateUpdater, ActivityVisitor {
-
-        private StateId distance_id;
-
-        private StateManager stateManager;
-
-        private double sum_distance = 0.;
-
-        private TransportDistance distanceCalculator;
-
-        private TourActivity prevAct;
-
-        private VehicleRoute route;
-
-        private DistanceUpdater(StateId distance_id, StateManager stateManager, TransportDistance distanceCalculator) {
-            this.distance_id = distance_id;
-            this.stateManager = stateManager;
-            this.distanceCalculator = distanceCalculator;
-        }
-
-        @Override
-        public void begin(VehicleRoute route) {
-            sum_distance = 0.;
-            this.route = route;
-            this.prevAct = route.getStart();
-        }
-
-        @Override
-        public void visit(TourActivity activity) {
-            double distance = distanceCalculator.getDistance(prevAct.getLocation(), activity.getLocation(), prevAct.getEndTime(), route.getVehicle());
-            sum_distance += distance;
-            stateManager.putActivityState(activity, distance_id, sum_distance);
-            prevAct = activity;
-        }
+    private void initialise() {
+        this.stateManager = new StateManager(vrp);
+        this.stateManager.updateTimeWindowStates();
+        this.stateManager.updateLoadStates();
+        this.stateManager.updateSkillStates();
+        activityPolicy = ActivityTimeTracker.ActivityPolicy.AS_SOON_AS_TIME_WINDOW_OPENS;
+        this.stateManager.addStateUpdater(new UpdateActivityTimes(vrp.getTransportCosts(), activityPolicy, vrp.getActivityCosts()));
+        this.stateManager.addStateUpdater(new UpdateVariableCosts(vrp.getActivityCosts(), vrp.getTransportCosts(), stateManager));
+        waiting_time_id = stateManager.createStateId("waiting-time");
+        transport_time_id = stateManager.createStateId("transport-time");
+        service_time_id = stateManager.createStateId("service-time");
+        distance_id = stateManager.createStateId("distance");
+        too_late_id = stateManager.createStateId("too-late");
+        shipment_id = stateManager.createStateId("shipment");
+        backhaul_id = stateManager.createStateId("backhaul");
+        skill_id = stateManager.createStateId("skills-violated");
+        last_transport_cost_id = stateManager.createStateId("last-transport-cost");
+        last_transport_distance_id = stateManager.createStateId("last-transport-distance");
+        last_transport_time_id = stateManager.createStateId("last-transport-time");
 
-        @Override
-        public void finish() {
-            double distance = distanceCalculator.getDistance(prevAct.getLocation(), route.getEnd().getLocation(),prevAct.getEndTime(), route.getVehicle());
-            sum_distance += distance;
-            stateManager.putRouteState(route, distance_id, sum_distance);
-        }
+        stateManager.addStateUpdater(new SumUpActivityTimes(waiting_time_id, transport_time_id, service_time_id, too_late_id, stateManager, activityPolicy, vrp.getActivityCosts()));
+        stateManager.addStateUpdater(new DistanceUpdater(distance_id, stateManager, distanceCalculator));
+        stateManager.addStateUpdater(new BackhaulAndShipmentUpdater(backhaul_id, shipment_id, stateManager));
+        stateManager.addStateUpdater(new SkillUpdater(stateManager, skill_id));
+        stateManager.addStateUpdater(new LoadAndActivityCounter(stateManager));
+        stateManager.addStateUpdater(new LastTransportUpdater(stateManager, vrp.getTransportCosts(), distanceCalculator, last_transport_distance_id, last_transport_time_id, last_transport_cost_id));
     }
 
-    private static class SkillUpdater implements StateUpdater, ActivityVisitor {
-
-        private StateManager stateManager;
-
-        private StateId skill_id;
-
-        private VehicleRoute route;
-
-        private boolean skillConstraintViolatedOnRoute;
-
-        private SkillUpdater(StateManager stateManager, StateId skill_id) {
-            this.stateManager = stateManager;
-            this.skill_id = skill_id;
-        }
+    private void refreshStates() {
+        stateManager.clear();
+        stateManager.informInsertionStarts(solution.getRoutes(), null);
+        clearSolutionIndicators();
+        recalculateSolutionIndicators();
+    }
 
-        @Override
-        public void begin(VehicleRoute route) {
-            this.route = route;
-            skillConstraintViolatedOnRoute = false;
-        }
+    public SolutionAnalyser(VehicleRoutingProblem vrp, VehicleRoutingProblemSolution solution, SolutionCostCalculator solutionCostCalculator, TransportDistance distanceCalculator) {
+        this.vrp = vrp;
+        this.solution = solution;
+        this.distanceCalculator = distanceCalculator;
+        this.solutionCostCalculator = solutionCostCalculator;
+        initialise();
+        refreshStates();
+    }
 
-        @Override
-        public void visit(TourActivity activity) {
-            boolean violatedAtActivity = false;
-            if (activity instanceof TourActivity.JobActivity) {
-                Set<String> requiredForActivity = ((TourActivity.JobActivity) activity).getJob().getRequiredSkills().values();
-                for (String skill : requiredForActivity) {
-                    if (!route.getVehicle().getSkills().containsSkill(skill)) {
-                        violatedAtActivity = true;
-                        skillConstraintViolatedOnRoute = true;
-                    }
-                }
-            }
-            stateManager.putActivityState(activity, skill_id, violatedAtActivity);
-        }
+    private void clearSolutionIndicators() {
+        maxOperationTime = 0.;
+        tp_distance = 0.;
+        tp_time = 0.;
+        waiting_time = 0.;
+        service_time = 0.;
+        operation_time = 0.;
+        tw_violation = 0.;
+        cap_violation = Capacity.Builder.newInstance().build();
+        fixed_costs = 0.;
+        variable_transport_costs = 0.;
+        total_costs = 0.;
+        hasBackhaulConstraintViolation = false;
+        hasShipmentConstraintViolation = false;
+        hasSkillConstraintViolation = false;
+        noPickups = 0;
+        noPickupsAtBeginning = 0;
+        noDeliveries = 0;
+        noDeliveriesAtEnd = 0;
+        pickupLoad = Capacity.Builder.newInstance().build();
+        pickupLoadAtBeginning = Capacity.Builder.newInstance().build();
+        deliveryLoad = Capacity.Builder.newInstance().build();
+        deliveryLoadAtEnd = Capacity.Builder.newInstance().build();
+    }
 
-        @Override
-        public void finish() {
-            stateManager.putRouteState(route, skill_id, skillConstraintViolatedOnRoute);
+    private void recalculateSolutionIndicators() {
+        for (VehicleRoute route : solution.getRoutes()) {
+            maxOperationTime = Math.max(maxOperationTime, getOperationTime(route));
+            tp_distance += getDistance(route);
+            tp_time += getTransportTime(route);
+            waiting_time += getWaitingTime(route);
+            service_time += getServiceTime(route);
+            operation_time += getOperationTime(route);
+            tw_violation += getTimeWindowViolation(route);
+            cap_violation = Capacity.addup(cap_violation, getCapacityViolation(route));
+            fixed_costs += getFixedCosts(route);
+            variable_transport_costs += getVariableTransportCosts(route);
+            if (hasSkillConstraintViolation(route)) hasSkillConstraintViolation = true;
+            if (hasShipmentConstraintViolation(route)) hasShipmentConstraintViolation = true;
+            if (hasBackhaulConstraintViolation(route)) hasBackhaulConstraintViolation = true;
+            noPickups += getNumberOfPickups(route);
+            noPickupsAtBeginning += getNumberOfPickupsAtBeginning(route);
+            noDeliveries += getNumberOfDeliveries(route);
+            noDeliveriesAtEnd += getNumberOfDeliveriesAtEnd(route);
+            pickupLoad = Capacity.addup(pickupLoad, getLoadPickedUp(route));
+            pickupLoadAtBeginning = Capacity.addup(pickupLoadAtBeginning, getLoadAtBeginning(route));
+            deliveryLoad = Capacity.addup(deliveryLoad, getLoadDelivered(route));
+            deliveryLoadAtEnd = Capacity.addup(deliveryLoadAtEnd, getLoadAtEnd(route));
         }
+        total_costs = solutionCostCalculator.getCosts(this.solution);
     }
 
-    private static final Logger log = LoggerFactory.getLogger(SolutionAnalyser.class);
-
-    private VehicleRoutingProblem vrp;
+    /**
+     * @param route to get the total operation time from
+     * @return operation time of this route, i.e. endTime - startTime of specified route
+     */
+    public Double getOperationTime(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return route.getEnd().getArrTime() - route.getStart().getEndTime();
+    }
 
-    private StateManager stateManager;
+    /**
+     * @param route to get the distance from
+     * @return total distance of route
+     */
+    public Double getDistance(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return stateManager.getRouteState(route, distance_id, Double.class);
+    }
 
-    private TransportDistance distanceCalculator;
+    /**
+     * @param route to get the total transport time from
+     * @return total transport time of specified route. Returns null if no time value exists for the specified route.
+     */
+    public Double getTransportTime(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return stateManager.getRouteState(route, transport_time_id, Double.class);
+    }
 
-    private StateId waiting_time_id;
+    /**
+     * @param route to get the total waiting time from
+     * @return total waiting time of this route, i.e. sum of waiting times at activities.
+     * Returns null if no waiting time value exists for the specified route
+     */
+    public Double getWaitingTime(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return stateManager.getRouteState(route, waiting_time_id, Double.class);
+    }
 
-    private StateId transport_time_id;
+    /**
+     * @param route to get the total service time from
+     * @return total service time of specified route. Returns null if no time value exists for specified route.
+     */
+    public Double getServiceTime(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return stateManager.getRouteState(route, service_time_id, Double.class);
+    }
 
-    private StateId service_time_id;
+    /**
+     * @param route to get the time window violation from
+     * @return time violation of route, i.e. sum of individual activity time window violations.
+     */
+    public Double getTimeWindowViolation(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return stateManager.getRouteState(route, too_late_id, Double.class);
+    }
 
-    private StateId distance_id;
+    /**
+     * @param route to get the capacity violation from
+     * @return the capacity violation on this route, i.e. maxLoad - vehicleCapacity
+     */
+    public Capacity getCapacityViolation(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        Capacity maxLoad = getMaxLoad(route);
+        return Capacity.max(Capacity.Builder.newInstance().build(), Capacity.subtract(maxLoad, route.getVehicle().getType().getCapacityDimensions()));
+    }
 
-    private StateId too_late_id;
+    /**
+     * @param route to get the fixed costs from
+     * @return fixed costs of route, i.e. fixed costs of employed vehicle on this route.
+     */
+    public Double getFixedCosts(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return route.getVehicle().getType().getVehicleCostParams().fix;
+    }
 
-    private StateId shipment_id;
+    /**
+     * @param route to get the transport costs from
+     * @return total variable transport costs of route, i.e. sum of transport costs specified by
+     * vrp.getTransportCosts().getTransportCost(fromId,toId,...)
+     */
+    public Double getVariableTransportCosts(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
 
-    private StateId backhaul_id;
+        return stateManager.getRouteState(route, InternalStates.COSTS, Double.class);
+    }
 
-    private StateId skill_id;
+    /**
+     * @param route to check skill constraint
+     * @return true if skill constraint is violated, i.e. if vehicle does not have the required skills to conduct all
+     * activities on the specified route. Returns null if route is null or skill state cannot be found.
+     */
+    public Boolean hasSkillConstraintViolation(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return stateManager.getRouteState(route, skill_id, Boolean.class);
+    }
 
-    private StateId last_transport_distance_id;
+    /**
+     * Returns true, if shipment constraint is violated. Two activities are associated to a shipment: pickupShipment
+     * and deliverShipment. If both shipments are not in the same route OR deliverShipment occurs before pickupShipment
+     * then the shipment constraint is violated.
+     *
+     * @param route to check the shipment constraint.
+     * @return true if violated, false otherwise. Null if no state can be found or specified route is null.
+     */
+    public Boolean hasShipmentConstraintViolation(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return stateManager.getRouteState(route, shipment_id, Boolean.class);
+    }
 
-    private StateId last_transport_time_id;
+    /**
+     * Returns true if backhaul constraint is violated (false otherwise). Backhaul constraint is violated if either a
+     * pickupService, serviceActivity (which is basically modeled as pickupService) or a pickupShipment occur before
+     * a deliverService activity or - to put it in other words - if a depot bounded delivery occurs after a pickup, thus
+     * the backhaul ensures depot bounded delivery activities first.
+     *
+     * @param route to check backhaul constraint
+     * @return true if backhaul constraint for specified route is violated. returns null if route is null or no backhaul
+     * state can be found. In latter case try routeChanged(route).
+     */
+    public Boolean hasBackhaulConstraintViolation(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return stateManager.getRouteState(route, backhaul_id, Boolean.class);
+    }
 
-    private StateId last_transport_cost_id;
+    /**
+     * @param route to get number of pickups from
+     * @return number of pickups picked up on specified route (without load at beginning)
+     */
+    public Integer getNumberOfPickups(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return stateManager.getRouteState(route, stateManager.createStateId(PICKUP_COUNT), Integer.class);
+    }
 
+    /**
+     * @param route to get the number of pickups at beginning from
+     * @return number of pickups at beginning
+     */
+    public Integer getNumberOfPickupsAtBeginning(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return stateManager.getRouteState(route, stateManager.createStateId(PICKUP_COUNT_AT_BEGINNING), Integer.class);
+    }
 
-    private ActivityTimeTracker.ActivityPolicy activityPolicy;
+    /**
+     * @param route to get number of deliveries from
+     * @return number of deliveries delivered on specified route (without load at end)
+     */
+    public Integer getNumberOfDeliveries(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return stateManager.getRouteState(route, stateManager.createStateId(DELIVERY_COUNT), Integer.class);
+    }
 
-    private final SolutionCostCalculator solutionCostCalculator;
+    /**
+     * @param route to get the number of deliveries at end from
+     * @return number of deliveries at end of specified route
+     */
+    public Integer getNumberOfDeliveriesAtEnd(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return stateManager.getRouteState(route, stateManager.createStateId(DELIVERY_COUNT_AT_END), Integer.class);
+    }
 
-    private Double tp_distance;
-    private Double tp_time;
-    private Double waiting_time;
-    private Double service_time;
-    private Double operation_time;
-    private Double tw_violation;
-    private Capacity cap_violation;
-    private Double fixed_costs;
-    private Double variable_transport_costs;
-    private Boolean hasSkillConstraintViolation;
-    private Boolean hasBackhaulConstraintViolation;
-    private Boolean hasShipmentConstraintViolation;
-    private Integer noPickups;
-    private Integer noPickupsAtBeginning;
-    private Integer noDeliveries;
-    private Integer noDeliveriesAtEnd;
-    private Capacity pickupLoad;
-    private Capacity pickupLoadAtBeginning;
-    private Capacity deliveryLoad;
-    private Capacity deliveryLoadAtEnd;
+    /**
+     * @param route to get the load at beginning from
+     * @return load at start location of specified route
+     */
+    public Capacity getLoadAtBeginning(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return stateManager.getRouteState(route, InternalStates.LOAD_AT_BEGINNING, Capacity.class);
+    }
 
-    private double maxOperationTime;
+    /**
+     * @param route to get the picked load from
+     * @return picked load (without load at beginning)
+     */
+    public Capacity getLoadPickedUp(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return stateManager.getRouteState(route, stateManager.createStateId(LOAD_PICKED), Capacity.class);
+    }
 
+    /**
+     * @param route to get the load at the end from
+     * @return load at end location of specified route
+     */
+    public Capacity getLoadAtEnd(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return stateManager.getRouteState(route, InternalStates.LOAD_AT_END, Capacity.class);
+    }
 
-    private Double total_costs;
+    /**
+     * @param route to get max load from
+     * @return max load of specified route, i.e. for each capacity dimension the max value.
+     */
+    public Capacity getMaxLoad(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return stateManager.getRouteState(route, InternalStates.MAXLOAD, Capacity.class);
+    }
 
-    private VehicleRoutingProblemSolution solution;
+    /**
+     * @param route to get delivered load from
+     * @return delivered laod (without load at end)
+     */
+    public Capacity getLoadDelivered(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        return stateManager.getRouteState(route, stateManager.createStateId(LOAD_DELIVERED), Capacity.class);
+    }
 
     /**
-     * @param vrp
-     * @param solution
-     * @param distanceCalculator
+     * Sets the specified solution and calculates all necessary indicators again.
      *
+     * @param newSolution to be analysed
      */
-    public SolutionAnalyser(VehicleRoutingProblem vrp, VehicleRoutingProblemSolution solution, TransportDistance distanceCalculator) {
-        this.vrp = vrp;
-        this.solution = solution;
-        this.distanceCalculator = distanceCalculator;
-        initialise();
-        this.solutionCostCalculator = new VariablePlusFixedSolutionCostCalculatorFactory(stateManager).createCalculator();
+    public void informSolutionChanged(VehicleRoutingProblemSolution newSolution) {
+        this.solution = newSolution;
         refreshStates();
     }
 
-    public SolutionAnalyser(VehicleRoutingProblem vrp, VehicleRoutingProblemSolution solution, SolutionCostCalculator solutionCostCalculator, TransportDistance distanceCalculator) {
-        this.vrp = vrp;
-        this.solution = solution;
-        this.distanceCalculator = distanceCalculator;
-        this.solutionCostCalculator = solutionCostCalculator;
-        initialise();
-        refreshStates();
+    /**
+     * @param activity to get the load from (before activity)
+     * @return load just before the specified activity. If act is Start, it returns the load atBeginning of the specified
+     * route. If act is End, it returns the load atEnd of specified route.
+     */
+    public Capacity getLoadJustBeforeActivity(TourActivity activity, VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        if (activity == null) throw new IllegalArgumentException("activity is missing.");
+        if (activity instanceof Start) return getLoadAtBeginning(route);
+        if (activity instanceof End) return getLoadAtEnd(route);
+        verifyThatRouteContainsAct(activity, route);
+        Capacity afterAct = stateManager.getActivityState(activity, InternalStates.LOAD, Capacity.class);
+        if (afterAct != null && activity.getSize() != null) {
+            return Capacity.subtract(afterAct, activity.getSize());
+        } else if (afterAct != null) return afterAct;
+        else return null;
     }
 
-    private void initialise() {
-        this.stateManager = new StateManager(vrp);
-        this.stateManager.updateTimeWindowStates();
-        this.stateManager.updateLoadStates();
-        this.stateManager.updateSkillStates();
-        activityPolicy = ActivityTimeTracker.ActivityPolicy.AS_SOON_AS_TIME_WINDOW_OPENS;
-        this.stateManager.addStateUpdater(new UpdateActivityTimes(vrp.getTransportCosts(), activityPolicy, vrp.getActivityCosts()));
-        this.stateManager.addStateUpdater(new UpdateVariableCosts(vrp.getActivityCosts(), vrp.getTransportCosts(), stateManager));
-        waiting_time_id = stateManager.createStateId("waiting-time");
-        transport_time_id = stateManager.createStateId("transport-time");
-        service_time_id = stateManager.createStateId("service-time");
-        distance_id = stateManager.createStateId("distance");
-        too_late_id = stateManager.createStateId("too-late");
-        shipment_id = stateManager.createStateId("shipment");
-        backhaul_id = stateManager.createStateId("backhaul");
-        skill_id = stateManager.createStateId("skills-violated");
-        last_transport_cost_id = stateManager.createStateId("last-transport-cost");
-        last_transport_distance_id = stateManager.createStateId("last-transport-distance");
-        last_transport_time_id = stateManager.createStateId("last-transport-time");
+    /**
+     * @param activity to get the load from (after activity)
+     * @return load right after the specified activity. If act is Start, it returns the load atBeginning of the specified
+     * route. If act is End, it returns the load atEnd of specified route.
+     * Returns null if no load can be found.
+     */
+    public Capacity getLoadRightAfterActivity(TourActivity activity, VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        if (activity == null) throw new IllegalArgumentException("activity is missing.");
+        if (activity instanceof Start) return getLoadAtBeginning(route);
+        if (activity instanceof End) return getLoadAtEnd(route);
+        verifyThatRouteContainsAct(activity, route);
+        return stateManager.getActivityState(activity, InternalStates.LOAD, Capacity.class);
+    }
 
-        stateManager.addStateUpdater(new SumUpActivityTimes(waiting_time_id, transport_time_id, service_time_id, too_late_id, stateManager, activityPolicy, vrp.getActivityCosts()));
-        stateManager.addStateUpdater(new DistanceUpdater(distance_id, stateManager, distanceCalculator));
-        stateManager.addStateUpdater(new BackhaulAndShipmentUpdater(backhaul_id, shipment_id, stateManager));
-        stateManager.addStateUpdater(new SkillUpdater(stateManager, skill_id));
-        stateManager.addStateUpdater(new LoadAndActivityCounter(stateManager));
-        stateManager.addStateUpdater(new LastTransportUpdater(stateManager, vrp.getTransportCosts(), distanceCalculator, last_transport_distance_id, last_transport_time_id, last_transport_cost_id));
+    /**
+     * @param route to get the capacity violation from (at beginning of the route)
+     * @return violation, i.e. all dimensions and their corresponding violation. For example, if vehicle has two capacity
+     * dimension with dimIndex=0 and dimIndex=1 and dimIndex=1 is violated by 4 units then this method returns
+     * [[dimIndex=0][dimValue=0][dimIndex=1][dimValue=4]]
+     */
+    public Capacity getCapacityViolationAtBeginning(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        Capacity atBeginning = getLoadAtBeginning(route);
+        return Capacity.max(Capacity.Builder.newInstance().build(), Capacity.subtract(atBeginning, route.getVehicle().getType().getCapacityDimensions()));
+    }
+
+    /**
+     * @param route to get the capacity violation from (at end of the route)
+     * @return violation, i.e. all dimensions and their corresponding violation. For example, if vehicle has two capacity
+     * dimension with dimIndex=0 and dimIndex=1 and dimIndex=1 is violated by 4 units then this method returns
+     * [[dimIndex=0][dimValue=0][dimIndex=1][dimValue=4]]
+     */
+    public Capacity getCapacityViolationAtEnd(VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        Capacity atEnd = getLoadAtEnd(route);
+        return Capacity.max(Capacity.Builder.newInstance().build(), Capacity.subtract(atEnd, route.getVehicle().getType().getCapacityDimensions()));
+    }
+
+    /**
+     * @param route to get the capacity violation from (at activity of the route)
+     * @return violation, i.e. all dimensions and their corresponding violation. For example, if vehicle has two capacity
+     * dimension with dimIndex=0 and dimIndex=1 and dimIndex=1 is violated by 4 units then this method returns
+     * [[dimIndex=0][dimValue=0][dimIndex=1][dimValue=4]]
+     */
+    public Capacity getCapacityViolationAfterActivity(TourActivity activity, VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        if (activity == null) throw new IllegalArgumentException("activity is missing.");
+        Capacity afterAct = getLoadRightAfterActivity(activity, route);
+        return Capacity.max(Capacity.Builder.newInstance().build(), Capacity.subtract(afterAct, route.getVehicle().getType().getCapacityDimensions()));
     }
 
-
-    private void refreshStates() {
-        stateManager.clear();
-        stateManager.informInsertionStarts(solution.getRoutes(), null);
-        clearSolutionIndicators();
-        recalculateSolutionIndicators();
+    private void verifyThatRouteContainsAct(TourActivity activity, VehicleRoute route) {
+        if (!route.getActivities().contains(activity)) {
+            throw new IllegalArgumentException("specified route does not contain specified activity " + activity);
+        }
     }
 
-    private void recalculateSolutionIndicators() {
-        for (VehicleRoute route : solution.getRoutes()) {
-            maxOperationTime = Math.max(maxOperationTime,getOperationTime(route));
-            tp_distance += getDistance(route);
-            tp_time += getTransportTime(route);
-            waiting_time += getWaitingTime(route);
-            service_time += getServiceTime(route);
-            operation_time += getOperationTime(route);
-            tw_violation += getTimeWindowViolation(route);
-            cap_violation = Capacity.addup(cap_violation, getCapacityViolation(route));
-            fixed_costs += getFixedCosts(route);
-            variable_transport_costs += getVariableTransportCosts(route);
-            if (hasSkillConstraintViolation(route)) hasSkillConstraintViolation = true;
-            if (hasShipmentConstraintViolation(route)) hasShipmentConstraintViolation = true;
-            if (hasBackhaulConstraintViolation(route)) hasBackhaulConstraintViolation = true;
-            noPickups += getNumberOfPickups(route);
-            noPickupsAtBeginning += getNumberOfPickupsAtBeginning(route);
-            noDeliveries += getNumberOfDeliveries(route);
-            noDeliveriesAtEnd += getNumberOfDeliveriesAtEnd(route);
-            pickupLoad = Capacity.addup(pickupLoad, getLoadPickedUp(route));
-            pickupLoadAtBeginning = Capacity.addup(pickupLoadAtBeginning, getLoadAtBeginning(route));
-            deliveryLoad = Capacity.addup(deliveryLoad, getLoadDelivered(route));
-            deliveryLoadAtEnd = Capacity.addup(deliveryLoadAtEnd, getLoadAtEnd(route));
-        }
-        total_costs = solutionCostCalculator.getCosts(this.solution);
+    /**
+     * @param activity to get the time window violation from
+     * @param route    where activity needs to be part of
+     * @return time violation of activity
+     */
+    public Double getTimeWindowViolationAtActivity(TourActivity activity, VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        if (activity == null) throw new IllegalArgumentException("activity is missing.");
+        return Math.max(0, activity.getArrTime() - activity.getTheoreticalLatestOperationStartTime());
     }
 
-    private void clearSolutionIndicators() {
-        maxOperationTime = 0.;
-        tp_distance = 0.;
-        tp_time = 0.;
-        waiting_time = 0.;
-        service_time = 0.;
-        operation_time = 0.;
-        tw_violation = 0.;
-        cap_violation = Capacity.Builder.newInstance().build();
-        fixed_costs = 0.;
-        variable_transport_costs = 0.;
-        total_costs = 0.;
-        hasBackhaulConstraintViolation = false;
-        hasShipmentConstraintViolation = false;
-        hasSkillConstraintViolation = false;
-        noPickups = 0;
-        noPickupsAtBeginning = 0;
-        noDeliveries = 0;
-        noDeliveriesAtEnd = 0;
-        pickupLoad = Capacity.Builder.newInstance().build();
-        pickupLoadAtBeginning = Capacity.Builder.newInstance().build();
-        deliveryLoad = Capacity.Builder.newInstance().build();
-        deliveryLoadAtEnd = Capacity.Builder.newInstance().build();
+    /**
+     * @param activity to check skill constraint
+     * @param route    that must contain specified activity
+     * @return true if vehicle does not have the skills to conduct specified activity, false otherwise. Returns null
+     * if specified route or activity is null or if route does not contain specified activity or if skill state connot be
+     * found. If specified activity is Start or End, it returns false.
+     */
+    public Boolean hasSkillConstraintViolationAtActivity(TourActivity activity, VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        if (activity == null) throw new IllegalArgumentException("activity is missing.");
+        if (activity instanceof Start) return false;
+        if (activity instanceof End) return false;
+        verifyThatRouteContainsAct(activity, route);
+        return stateManager.getActivityState(activity, skill_id, Boolean.class);
     }
 
     /**
-     * Sets the specified solution and calculates all necessary indicators again.
-     *
-     * @param newSolution to be analysed
+     * @param activity to check backhaul violation
+     * @param route    that must contain the specified activity
+     * @return true if backhaul constraint is violated, false otherwise. Null if either specified route or activity is null.
+     * Null if specified route does not contain specified activity.
      */
-    public void informSolutionChanged(VehicleRoutingProblemSolution newSolution) {
-        this.solution = newSolution;
-        refreshStates();
+    public Boolean hasBackhaulConstraintViolationAtActivity(TourActivity activity, VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        if (activity == null) throw new IllegalArgumentException("activity is missing.");
+        if (activity instanceof Start) return false;
+        if (activity instanceof End) return false;
+        verifyThatRouteContainsAct(activity, route);
+        return stateManager.getActivityState(activity, backhaul_id, Boolean.class);
     }
 
     /**
-     * @param route to get the load at beginning from
-     * @return load at start location of specified route
+     * Returns true if shipment constraint is violated, i.e. if activity is deliverShipment but no pickupShipment can be
+     * found before OR activity is pickupShipment and no deliverShipment can be found afterwards.
+     *
+     * @param activity to check the shipment constraint
+     * @param route    that must contain specified activity
+     * @return true if shipment constraint is violated, false otherwise. If activity is either Start or End, it returns
+     * false. Returns null if either specified activity or route is null or route does not containt activity.
      */
-    public Capacity getLoadAtBeginning(VehicleRoute route) {
+    public Boolean hasShipmentConstraintViolationAtActivity(TourActivity activity, VehicleRoute route) {
         if (route == null) throw new IllegalArgumentException("route is missing.");
-        return stateManager.getRouteState(route, InternalStates.LOAD_AT_BEGINNING, Capacity.class);
+        if (activity == null) throw new IllegalArgumentException("activity is missing.");
+        if (activity instanceof Start) return false;
+        if (activity instanceof End) return false;
+        verifyThatRouteContainsAct(activity, route);
+        return stateManager.getActivityState(activity, shipment_id, Boolean.class);
     }
 
     /**
-     * @param route to get the load at the end from
-     * @return load at end location of specified route
+     * @param activity to get the variable transport costs from
+     * @param route    where the activity should be part of
+     * @return variable transport costs at activity, i.e. sum of transport costs from start of route to the specified activity
+     * If activity is start, it returns 0.. If it is end, it returns .getVariableTransportCosts(route).
      */
-    public Capacity getLoadAtEnd(VehicleRoute route) {
+    public Double getVariableTransportCostsAtActivity(TourActivity activity, VehicleRoute route) {
         if (route == null) throw new IllegalArgumentException("route is missing.");
-        return stateManager.getRouteState(route, InternalStates.LOAD_AT_END, Capacity.class);
+        if (activity == null) throw new IllegalArgumentException("activity is missing.");
+        if (activity instanceof Start) return 0.;
+        if (activity instanceof End) return getVariableTransportCosts(route);
+        verifyThatRouteContainsAct(activity, route);
+        return stateManager.getActivityState(activity, InternalStates.COSTS, Double.class);
     }
 
     /**
-     * @param route to get max load from
-     * @return max load of specified route, i.e. for each capacity dimension the max value.
+     * @param activity to get the transport time from
+     * @param route    where the activity should be part of
+     * @return transport time at the activity, i.e. the total time spent driving since the start of the route to the specified activity.
      */
-    public Capacity getMaxLoad(VehicleRoute route) {
+    public Double getTransportTimeAtActivity(TourActivity activity, VehicleRoute route) {
         if (route == null) throw new IllegalArgumentException("route is missing.");
-        return stateManager.getRouteState(route, InternalStates.MAXLOAD, Capacity.class);
+        if (activity == null) throw new IllegalArgumentException("activity is missing.");
+        if (activity instanceof Start) return 0.;
+        if (activity instanceof End) return getTransportTime(route);
+        verifyThatRouteContainsAct(activity, route);
+        return stateManager.getActivityState(activity, transport_time_id, Double.class);
     }
 
     /**
-     * @param activity to get the load from (after activity)
-     * @return load right after the specified activity. If act is Start, it returns the load atBeginning of the specified
-     * route. If act is End, it returns the load atEnd of specified route.
-     * Returns null if no load can be found.
+     * @param activity to get the last transport time from
+     * @param route    where the activity should be part of
+     * @return The transport time from the previous activity to this one.
      */
-    public Capacity getLoadRightAfterActivity(TourActivity activity, VehicleRoute route) {
+    public Double getLastTransportTimeAtActivity(TourActivity activity, VehicleRoute route) {
+        return getLastTransport(activity, route, last_transport_time_id);
+    }
+
+    private Double getLastTransport(TourActivity activity, VehicleRoute route, StateId id) {
         if (route == null) throw new IllegalArgumentException("route is missing.");
         if (activity == null) throw new IllegalArgumentException("activity is missing.");
-        if (activity instanceof Start) return getLoadAtBeginning(route);
-        if (activity instanceof End) return getLoadAtEnd(route);
+        if (activity instanceof Start) return 0.;
+        if (activity instanceof End) return stateManager.getRouteState(route, id, Double.class);
         verifyThatRouteContainsAct(activity, route);
-        return stateManager.getActivityState(activity, InternalStates.LOAD, Capacity.class);
+        return stateManager.getActivityState(activity, id, Double.class);
     }
 
-    private void verifyThatRouteContainsAct(TourActivity activity, VehicleRoute route) {
-        if (!route.getActivities().contains(activity)) {
-            throw new IllegalArgumentException("specified route does not contain specified activity " + activity);
+    /**
+     * @param activity to get the last transport distance from
+     * @param route    where the activity should be part of
+     * @return The transport distance from the previous activity to this one.
+     */
+    public Double getLastTransportDistanceAtActivity(TourActivity activity, VehicleRoute route) {
+        return getLastTransport(activity, route, last_transport_distance_id);
+    }
+
+    /**
+     * @param activity to get the last transport cost from
+     * @param route    where the activity should be part of
+     * @return The transport cost from the previous activity to this one.
+     */
+    public Double getLastTransportCostAtActivity(TourActivity activity, VehicleRoute route) {
+        return getLastTransport(activity, route, last_transport_cost_id);
+    }
+
+    /**
+     * @param activity to get the waiting from
+     * @param route    where activity should be part of
+     * @return waiting time at activity
+     */
+    public Double getWaitingTimeAtActivity(TourActivity activity, VehicleRoute route) {
+        if (route == null) throw new IllegalArgumentException("route is missing.");
+        if (activity == null) throw new IllegalArgumentException("activity is missing.");
+        double waitingTime = 0.;
+        if (activityPolicy.equals(ActivityTimeTracker.ActivityPolicy.AS_SOON_AS_TIME_WINDOW_OPENS)) {
+            waitingTime = Math.max(0, activity.getTheoreticalEarliestOperationStartTime() - activity.getArrTime());
         }
+        return waitingTime;
     }
 
     /**
-     * @param activity to get the load from (before activity)
-     * @return load just before the specified activity. If act is Start, it returns the load atBeginning of the specified
-     * route. If act is End, it returns the load atEnd of specified route.
+     * @param activity at which is distance of the current route is measured
+     * @return distance at activity
      */
-    public Capacity getLoadJustBeforeActivity(TourActivity activity, VehicleRoute route) {
+    public Double getDistanceAtActivity(TourActivity activity, VehicleRoute route) {
         if (route == null) throw new IllegalArgumentException("route is missing.");
         if (activity == null) throw new IllegalArgumentException("activity is missing.");
-        if (activity instanceof Start) return getLoadAtBeginning(route);
-        if (activity instanceof End) return getLoadAtEnd(route);
+        if (activity instanceof Start) return 0.;
+        if (activity instanceof End) return getDistance(route);
         verifyThatRouteContainsAct(activity, route);
-        Capacity afterAct = stateManager.getActivityState(activity, InternalStates.LOAD, Capacity.class);
-        if (afterAct != null && activity.getSize() != null) {
-            return Capacity.subtract(afterAct, activity.getSize());
-        } else if (afterAct != null) return afterAct;
-        else return null;
+        return stateManager.getActivityState(activity, distance_id, Double.class);
     }
 
     /**
-     * @param route to get number of pickups from
-     * @return number of pickups picked up on specified route (without load at beginning)
+     * @return number of pickups in specified solution (without load at beginning of each route)
      */
-    public Integer getNumberOfPickups(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        return stateManager.getRouteState(route, stateManager.createStateId(PICKUP_COUNT), Integer.class);
+    public Integer getNumberOfPickups() {
+        return noPickups;
+    }
+
+    /**
+     * @return number of pickups in specified solution at beginning of each route
+     */
+    public Integer getNumberOfPickupsAtBeginning() {
+        return noPickupsAtBeginning;
+    }
+
+    /**
+     * @return number of deliveries in specified solution (without load at end of each route)
+     */
+    public Integer getNumberOfDeliveries() {
+        return noDeliveries;
+    }
+
+    /**
+     * @return number of deliveries in specified solution at end of each route
+     */
+    public Integer getNumberOfDeliveriesAtEnd() {
+        return noDeliveriesAtEnd;
+    }
+
+    /**
+     * @return load picked up in solution (without load at beginning of each route)
+     */
+    public Capacity getLoadPickedUp() {
+        return pickupLoad;
+    }
+
+    /**
+     * @return load picked up in solution at beginning of each route
+     */
+    public Capacity getLoadAtBeginning() {
+        return pickupLoadAtBeginning;
     }
 
     /**
-     * @param route to get number of deliveries from
-     * @return number of deliveries delivered on specified route (without load at end)
+     * @return load delivered in solution (without load at end of each route)
      */
-    public Integer getNumberOfDeliveries(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        return stateManager.getRouteState(route, stateManager.createStateId(DELIVERY_COUNT), Integer.class);
+    public Capacity getLoadDelivered() {
+        return deliveryLoad;
     }
 
     /**
-     * @param route to get the picked load from
-     * @return picked load (without load at beginning)
+     * @return load delivered in solution at end of each route
      */
-    public Capacity getLoadPickedUp(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        return stateManager.getRouteState(route, stateManager.createStateId(LOAD_PICKED), Capacity.class);
+    public Capacity getLoadAtEnd() {
+        return deliveryLoadAtEnd;
     }
 
     /**
-     * @param route to get delivered load from
-     * @return delivered laod (without load at end)
+     * @return total distance for specified solution
      */
-    public Capacity getLoadDelivered(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        return stateManager.getRouteState(route, stateManager.createStateId(LOAD_DELIVERED), Capacity.class);
+    public Double getDistance() {
+        return tp_distance;
     }
 
     /**
-     * @param route to get the capacity violation from
-     * @return the capacity violation on this route, i.e. maxLoad - vehicleCapacity
+     * @return total operation time for specified solution
      */
-    public Capacity getCapacityViolation(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        Capacity maxLoad = getMaxLoad(route);
-        return Capacity.max(Capacity.Builder.newInstance().build(), Capacity.subtract(maxLoad, route.getVehicle().getType().getCapacityDimensions()));
+    public Double getOperationTime() {
+        return operation_time;
+    }
+
+    public Double getMaxOperationTime() {
+        return maxOperationTime;
     }
 
     /**
-     * @param route to get the capacity violation from (at beginning of the route)
-     * @return violation, i.e. all dimensions and their corresponding violation. For example, if vehicle has two capacity
-     * dimension with dimIndex=0 and dimIndex=1 and dimIndex=1 is violated by 4 units then this method returns
-     * [[dimIndex=0][dimValue=0][dimIndex=1][dimValue=4]]
+     * @return total waiting time for specified solution
      */
-    public Capacity getCapacityViolationAtBeginning(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        Capacity atBeginning = getLoadAtBeginning(route);
-        return Capacity.max(Capacity.Builder.newInstance().build(), Capacity.subtract(atBeginning, route.getVehicle().getType().getCapacityDimensions()));
+    public Double getWaitingTime() {
+        return waiting_time;
     }
 
     /**
-     * @param route to get the capacity violation from (at end of the route)
-     * @return violation, i.e. all dimensions and their corresponding violation. For example, if vehicle has two capacity
-     * dimension with dimIndex=0 and dimIndex=1 and dimIndex=1 is violated by 4 units then this method returns
-     * [[dimIndex=0][dimValue=0][dimIndex=1][dimValue=4]]
+     * @return total transportation time
      */
-    public Capacity getCapacityViolationAtEnd(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        Capacity atEnd = getLoadAtEnd(route);
-        return Capacity.max(Capacity.Builder.newInstance().build(), Capacity.subtract(atEnd, route.getVehicle().getType().getCapacityDimensions()));
+    public Double getTransportTime() {
+        return tp_time;
     }
 
-
     /**
-     * @param route to get the capacity violation from (at activity of the route)
-     * @return violation, i.e. all dimensions and their corresponding violation. For example, if vehicle has two capacity
-     * dimension with dimIndex=0 and dimIndex=1 and dimIndex=1 is violated by 4 units then this method returns
-     * [[dimIndex=0][dimValue=0][dimIndex=1][dimValue=4]]
+     * @return total time window violation for specified solution
      */
-    public Capacity getCapacityViolationAfterActivity(TourActivity activity, VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        if (activity == null) throw new IllegalArgumentException("activity is missing.");
-        Capacity afterAct = getLoadRightAfterActivity(activity, route);
-        return Capacity.max(Capacity.Builder.newInstance().build(), Capacity.subtract(afterAct, route.getVehicle().getType().getCapacityDimensions()));
+    public Double getTimeWindowViolation() {
+        return tw_violation;
     }
 
     /**
-     * @param route to get the time window violation from
-     * @return time violation of route, i.e. sum of individual activity time window violations.
+     * @return total capacity violation for specified solution
      */
-    public Double getTimeWindowViolation(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        return stateManager.getRouteState(route, too_late_id, Double.class);
+    public Capacity getCapacityViolation() {
+        return cap_violation;
     }
 
     /**
-     * @param activity to get the time window violation from
-     * @param route    where activity needs to be part of
-     * @return time violation of activity
+     * @return total service time for specified solution
      */
-    public Double getTimeWindowViolationAtActivity(TourActivity activity, VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        if (activity == null) throw new IllegalArgumentException("activity is missing.");
-        return Math.max(0, activity.getArrTime() - activity.getTheoreticalLatestOperationStartTime());
+    public Double getServiceTime() {
+        return service_time;
     }
 
     /**
-     * @param route to check skill constraint
-     * @return true if skill constraint is violated, i.e. if vehicle does not have the required skills to conduct all
-     * activities on the specified route. Returns null if route is null or skill state cannot be found.
+     * @return total fixed costs for specified solution
      */
-    public Boolean hasSkillConstraintViolation(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        return stateManager.getRouteState(route, skill_id, Boolean.class);
+    public Double getFixedCosts() {
+        return fixed_costs;
     }
 
     /**
-     * @param activity to check skill constraint
-     * @param route    that must contain specified activity
-     * @return true if vehicle does not have the skills to conduct specified activity, false otherwise. Returns null
-     * if specified route or activity is null or if route does not contain specified activity or if skill state connot be
-     * found. If specified activity is Start or End, it returns false.
+     * @return total variable transport costs for specified solution
      */
-    public Boolean hasSkillConstraintViolationAtActivity(TourActivity activity, VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        if (activity == null) throw new IllegalArgumentException("activity is missing.");
-        if (activity instanceof Start) return false;
-        if (activity instanceof End) return false;
-        verifyThatRouteContainsAct(activity, route);
-        return stateManager.getActivityState(activity, skill_id, Boolean.class);
+    public Double getVariableTransportCosts() {
+        return variable_transport_costs;
     }
 
     /**
-     * Returns true if backhaul constraint is violated (false otherwise). Backhaul constraint is violated if either a
-     * pickupService, serviceActivity (which is basically modeled as pickupService) or a pickupShipment occur before
-     * a deliverService activity or - to put it in other words - if a depot bounded delivery occurs after a pickup, thus
-     * the backhaul ensures depot bounded delivery activities first.
-     *
-     * @param route to check backhaul constraint
-     * @return true if backhaul constraint for specified route is violated. returns null if route is null or no backhaul
-     * state can be found. In latter case try routeChanged(route).
+     * @return total costs defined by solutionCostCalculator
      */
-    public Boolean hasBackhaulConstraintViolation(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        return stateManager.getRouteState(route, backhaul_id, Boolean.class);
+    public Double getTotalCosts() {
+        return total_costs;
     }
 
     /**
-     * @param activity to check backhaul violation
-     * @param route    that must contain the specified activity
-     * @return true if backhaul constraint is violated, false otherwise. Null if either specified route or activity is null.
-     * Null if specified route does not contain specified activity.
+     * @return true if at least one route in specified solution has shipment constraint violation
      */
-    public Boolean hasBackhaulConstraintViolationAtActivity(TourActivity activity, VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        if (activity == null) throw new IllegalArgumentException("activity is missing.");
-        if (activity instanceof Start) return false;
-        if (activity instanceof End) return false;
-        verifyThatRouteContainsAct(activity, route);
-        return stateManager.getActivityState(activity, backhaul_id, Boolean.class);
+    public Boolean hasShipmentConstraintViolation() {
+        return hasShipmentConstraintViolation;
     }
 
     /**
-     * Returns true, if shipment constraint is violated. Two activities are associated to a shipment: pickupShipment
-     * and deliverShipment. If both shipments are not in the same route OR deliverShipment occurs before pickupShipment
-     * then the shipment constraint is violated.
-     *
-     * @param route to check the shipment constraint.
-     * @return true if violated, false otherwise. Null if no state can be found or specified route is null.
+     * @return true if at least one route in specified solution has backhaul constraint violation
      */
-    public Boolean hasShipmentConstraintViolation(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        return stateManager.getRouteState(route, shipment_id, Boolean.class);
+    public Boolean hasBackhaulConstraintViolation() {
+        return hasBackhaulConstraintViolation;
     }
 
     /**
-     * Returns true if shipment constraint is violated, i.e. if activity is deliverShipment but no pickupShipment can be
-     * found before OR activity is pickupShipment and no deliverShipment can be found afterwards.
-     *
-     * @param activity to check the shipment constraint
-     * @param route    that must contain specified activity
-     * @return true if shipment constraint is violated, false otherwise. If activity is either Start or End, it returns
-     * false. Returns null if either specified activity or route is null or route does not containt activity.
+     * @return true if at least one route in specified solution has skill constraint violation
      */
-    public Boolean hasShipmentConstraintViolationAtActivity(TourActivity activity, VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        if (activity == null) throw new IllegalArgumentException("activity is missing.");
-        if (activity instanceof Start) return false;
-        if (activity instanceof End) return false;
-        verifyThatRouteContainsAct(activity, route);
-        return stateManager.getActivityState(activity, shipment_id, Boolean.class);
+    public Boolean hasSkillConstraintViolation() {
+        return hasSkillConstraintViolation;
+    }
+
+    private static class LoadAndActivityCounter implements StateUpdater, ActivityVisitor {
+
+        private final StateManager stateManager;
+
+        private int pickupCounter;
+
+        private int pickupAtBeginningCounter;
+
+        private int deliveryCounter;
+
+        private int deliverAtEndCounter;
+
+        private Capacity pickedUp;
+
+        private Capacity delivered;
+
+        private StateId pickup_count_id;
+
+        private StateId pickup_at_beginning_count_id;
+
+        private StateId delivery_count_id;
+
+        private StateId delivery_at_end_count_id;
+
+        private StateId load_picked_id;
+
+        private StateId load_delivered_id;
+
+        private VehicleRoute route;
+
+        private LoadAndActivityCounter(StateManager stateManager) {
+            this.stateManager = stateManager;
+            pickup_count_id = stateManager.createStateId(PICKUP_COUNT);
+            delivery_count_id = stateManager.createStateId(DELIVERY_COUNT);
+            load_picked_id = stateManager.createStateId(LOAD_PICKED);
+            load_delivered_id = stateManager.createStateId(LOAD_DELIVERED);
+            pickup_at_beginning_count_id = stateManager.createStateId(PICKUP_COUNT_AT_BEGINNING);
+            delivery_at_end_count_id = stateManager.createStateId(DELIVERY_COUNT_AT_END);
+        }
+
+        @Override
+        public void begin(VehicleRoute route) {
+            this.route = route;
+            pickupCounter = 0;
+            pickupAtBeginningCounter = 0;
+            deliveryCounter = 0;
+            deliverAtEndCounter = 0;
+            pickedUp = Capacity.Builder.newInstance().build();
+            delivered = Capacity.Builder.newInstance().build();
+        }
+
+        @Override
+        public void visit(TourActivity activity) {
+            if (activity instanceof PickupActivity) {
+                pickupCounter++;
+                pickedUp = Capacity.addup(pickedUp, ((PickupActivity) activity).getJob().getSize());
+                if (activity instanceof PickupService) {
+                    deliverAtEndCounter++;
+                }
+            } else if (activity instanceof DeliveryActivity) {
+                deliveryCounter++;
+                delivered = Capacity.addup(delivered, ((DeliveryActivity) activity).getJob().getSize());
+                if (activity instanceof DeliverService) {
+                    pickupAtBeginningCounter++;
+                }
+            }
+        }
+
+        @Override
+        public void finish() {
+            stateManager.putRouteState(route, pickup_count_id, pickupCounter);
+            stateManager.putRouteState(route, delivery_count_id, deliveryCounter);
+            stateManager.putRouteState(route, load_picked_id, pickedUp);
+            stateManager.putRouteState(route, load_delivered_id, delivered);
+            stateManager.putRouteState(route, pickup_at_beginning_count_id, pickupAtBeginningCounter);
+            stateManager.putRouteState(route, delivery_at_end_count_id, deliverAtEndCounter);
+        }
     }
 
+    private static class BackhaulAndShipmentUpdater implements StateUpdater, ActivityVisitor {
+
+        private final StateId backhaul_id;
+
+        private final StateId shipment_id;
+
+        private final StateManager stateManager;
 
-    /**
-     * @param route to get the total operation time from
-     * @return operation time of this route, i.e. endTime - startTime of specified route
-     */
-    public Double getOperationTime(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        return route.getEnd().getArrTime() - route.getStart().getEndTime();
-    }
+        private Map<String, PickupShipment> openShipments;
 
-    /**
-     * @param route to get the total waiting time from
-     * @return total waiting time of this route, i.e. sum of waiting times at activities.
-     * Returns null if no waiting time value exists for the specified route
-     */
-    public Double getWaitingTime(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        return stateManager.getRouteState(route, waiting_time_id, Double.class);
-    }
+        private VehicleRoute route;
 
-    /**
-     * @param route to get the total transport time from
-     * @return total transport time of specified route. Returns null if no time value exists for the specified route.
-     */
-    public Double getTransportTime(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        return stateManager.getRouteState(route, transport_time_id, Double.class);
-    }
+        private Boolean shipmentConstraintOnRouteViolated;
 
-    /**
-     * @param route to get the total service time from
-     * @return total service time of specified route. Returns null if no time value exists for specified route.
-     */
-    public Double getServiceTime(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        return stateManager.getRouteState(route, service_time_id, Double.class);
-    }
+        private Boolean backhaulConstraintOnRouteViolated;
 
-    /**
-     * @param route to get the transport costs from
-     * @return total variable transport costs of route, i.e. sum of transport costs specified by
-     * vrp.getTransportCosts().getTransportCost(fromId,toId,...)
-     */
-    public Double getVariableTransportCosts(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
+        private boolean pickupOccured;
 
-        return stateManager.getRouteState(route, InternalStates.COSTS, Double.class);
-    }
+        private BackhaulAndShipmentUpdater(StateId backhaul_id, StateId shipment_id, StateManager stateManager) {
+            this.stateManager = stateManager;
+            this.backhaul_id = backhaul_id;
+            this.shipment_id = shipment_id;
+        }
 
-    /**
-     * @param route to get the fixed costs from
-     * @return fixed costs of route, i.e. fixed costs of employed vehicle on this route.
-     */
-    public Double getFixedCosts(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        return route.getVehicle().getType().getVehicleCostParams().fix;
-    }
+        @Override
+        public void begin(VehicleRoute route) {
+            this.route = route;
+            openShipments = new HashMap<String, PickupShipment>();
+            pickupOccured = false;
+            shipmentConstraintOnRouteViolated = false;
+            backhaulConstraintOnRouteViolated = false;
+        }
 
+        @Override
+        public void visit(TourActivity activity) {
+            //shipment
+            if (activity instanceof PickupShipment) {
+                openShipments.put(((PickupShipment) activity).getJob().getId(), (PickupShipment) activity);
+            } else if (activity instanceof DeliverShipment) {
+                String jobId = ((DeliverShipment) activity).getJob().getId();
+                if (!openShipments.containsKey(jobId)) {
+                    //deliverShipment without pickupShipment
+                    stateManager.putActivityState(activity, shipment_id, true);
+                    shipmentConstraintOnRouteViolated = true;
+                } else {
+                    PickupShipment removed = openShipments.remove(jobId);
+                    stateManager.putActivityState(removed, shipment_id, false);
+                    stateManager.putActivityState(activity, shipment_id, false);
+                }
+            } else stateManager.putActivityState(activity, shipment_id, false);
 
-    /**
-     * @param activity to get the variable transport costs from
-     * @param route    where the activity should be part of
-     * @return variable transport costs at activity, i.e. sum of transport costs from start of route to the specified activity
-     * If activity is start, it returns 0.. If it is end, it returns .getVariableTransportCosts(route).
-     */
-    public Double getVariableTransportCostsAtActivity(TourActivity activity, VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        if (activity == null) throw new IllegalArgumentException("activity is missing.");
-        if (activity instanceof Start) return 0.;
-        if (activity instanceof End) return getVariableTransportCosts(route);
-        verifyThatRouteContainsAct(activity, route);
-        return stateManager.getActivityState(activity, InternalStates.COSTS, Double.class);
-    }
+            //backhaul
+            if (activity instanceof DeliverService && pickupOccured) {
+                stateManager.putActivityState(activity, backhaul_id, true);
+                backhaulConstraintOnRouteViolated = true;
+            } else {
+                if (activity instanceof PickupService || activity instanceof ServiceActivity || activity instanceof PickupShipment) {
+                    pickupOccured = true;
+                    stateManager.putActivityState(activity, backhaul_id, false);
+                } else stateManager.putActivityState(activity, backhaul_id, false);
+            }
+        }
 
-    /**
-     * @param activity to get the transport time from
-     * @param route    where the activity should be part of
-     * @return transport time at the activity, i.e. the total time spent driving since the start of the route to the specified activity.
-     */
-    public Double getTransportTimeAtActivity(TourActivity activity, VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        if (activity == null) throw new IllegalArgumentException("activity is missing.");
-        if (activity instanceof Start) return 0.;
-        if (activity instanceof End) return getTransportTime(route);
-        verifyThatRouteContainsAct(activity, route);
-        return stateManager.getActivityState(activity, transport_time_id, Double.class);
+        @Override
+        public void finish() {
+            //shipment
+            //pickups without deliveries
+            for (TourActivity act : openShipments.values()) {
+                stateManager.putActivityState(act, shipment_id, true);
+                shipmentConstraintOnRouteViolated = true;
+            }
+            stateManager.putRouteState(route, shipment_id, shipmentConstraintOnRouteViolated);
+            //backhaul
+            stateManager.putRouteState(route, backhaul_id, backhaulConstraintOnRouteViolated);
+        }
     }
 
-    /**
-     * @param activity to get the last transport time from
-     * @param route    where the activity should be part of
-     * @return The transport time from the previous activity to this one.
-     */
-    public Double getLastTransportTimeAtActivity(TourActivity activity, VehicleRoute route) {
-        return getLastTransport(activity, route, last_transport_time_id);
-    }
+    private static class SumUpActivityTimes implements StateUpdater, ActivityVisitor {
 
-    /**
-     * @param activity to get the last transport distance from
-     * @param route    where the activity should be part of
-     * @return The transport distance from the previous activity to this one.
-     */
-    public Double getLastTransportDistanceAtActivity(TourActivity activity, VehicleRoute route) {
-        return getLastTransport(activity, route, last_transport_distance_id);
-    }
+        private final VehicleRoutingActivityCosts activityCosts;
+        double sum_waiting_time = 0.;
+        double sum_transport_time = 0.;
+        double sum_service_time = 0.;
+        double sum_too_late = 0.;
+        double prevActDeparture;
+        private StateId waiting_time_id;
+        private StateId transport_time_id;
+        private StateId service_time_id;
+        private StateId too_late_id;
+        private StateManager stateManager;
+        private ActivityTimeTracker.ActivityPolicy activityPolicy;
+        private VehicleRoute route;
 
-    /**
-     * @param activity to get the last transport cost from
-     * @param route    where the activity should be part of
-     * @return The transport cost from the previous activity to this one.
-     */
-    public Double getLastTransportCostAtActivity(TourActivity activity, VehicleRoute route) {
-        return getLastTransport(activity, route, last_transport_cost_id);
-    }
+        private SumUpActivityTimes(StateId waiting_time_id, StateId transport_time_id, StateId service_time_id, StateId too_late_id, StateManager stateManager, ActivityTimeTracker.ActivityPolicy activityPolicy, VehicleRoutingActivityCosts activityCosts) {
+            this.waiting_time_id = waiting_time_id;
+            this.transport_time_id = transport_time_id;
+            this.service_time_id = service_time_id;
+            this.too_late_id = too_late_id;
+            this.stateManager = stateManager;
+            this.activityPolicy = activityPolicy;
+            this.activityCosts = activityCosts;
+        }
+
+        @Override
+        public void begin(VehicleRoute route) {
+            this.route = route;
+            sum_waiting_time = 0.;
+            sum_transport_time = 0.;
+            sum_service_time = 0.;
+            sum_too_late = 0.;
+            prevActDeparture = route.getDepartureTime();
+        }
+
+        @Override
+        public void visit(TourActivity activity) {
+            //waiting time & toolate
+            double waitAtAct = 0.;
+            double tooLate = 0.;
+            if (activityPolicy.equals(ActivityTimeTracker.ActivityPolicy.AS_SOON_AS_TIME_WINDOW_OPENS)) {
+                waitAtAct = Math.max(0, activity.getTheoreticalEarliestOperationStartTime() - activity.getArrTime());
+                tooLate = Math.max(0, activity.getArrTime() - activity.getTheoreticalLatestOperationStartTime());
+            }
+            sum_waiting_time += waitAtAct;
+            sum_too_late += tooLate;
+            //transport time
+            double transportTime = activity.getArrTime() - prevActDeparture;
+            sum_transport_time += transportTime;
+            prevActDeparture = activity.getEndTime();
+            //service time
+            sum_service_time += activityCosts.getActivityDuration(activity, activity.getArrTime(), route.getDriver(), route.getVehicle());
 
+            stateManager.putActivityState(activity, transport_time_id, sum_transport_time);
 
-    private Double getLastTransport(TourActivity activity, VehicleRoute route, StateId id) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        if (activity == null) throw new IllegalArgumentException("activity is missing.");
-        if (activity instanceof Start) return 0.;
-        if (activity instanceof End) return stateManager.getRouteState(route, id, Double.class);
-        verifyThatRouteContainsAct(activity, route);
-        return stateManager.getActivityState(activity, id, Double.class);
+        }
+
+        @Override
+        public void finish() {
+            sum_transport_time += route.getEnd().getArrTime() - prevActDeparture;
+            sum_too_late += Math.max(0, route.getEnd().getArrTime() - route.getEnd().getTheoreticalLatestOperationStartTime());
+            stateManager.putRouteState(route, transport_time_id, sum_transport_time);
+            stateManager.putRouteState(route, waiting_time_id, sum_waiting_time);
+            stateManager.putRouteState(route, service_time_id, sum_service_time);
+            stateManager.putRouteState(route, too_late_id, sum_too_late);
+        }
     }
 
-    /**
-     * @param activity to get the waiting from
-     * @param route    where activity should be part of
-     * @return waiting time at activity
-     */
-    public Double getWaitingTimeAtActivity(TourActivity activity, VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        if (activity == null) throw new IllegalArgumentException("activity is missing.");
-        double waitingTime = 0.;
-        if (activityPolicy.equals(ActivityTimeTracker.ActivityPolicy.AS_SOON_AS_TIME_WINDOW_OPENS)) {
-            waitingTime = Math.max(0, activity.getTheoreticalEarliestOperationStartTime() - activity.getArrTime());
+    private static class LastTransportUpdater implements StateUpdater, ActivityVisitor {
+        private final StateManager stateManager;
+        private final VehicleRoutingTransportCosts transportCost;
+        private final TransportDistance distanceCalculator;
+        private final StateId last_transport_distance_id;
+        private final StateId last_transport_time_id;
+        private final StateId last_transport_cost_id;
+        private TourActivity prevAct;
+        private double prevActDeparture;
+        private VehicleRoute route;
+
+
+        private LastTransportUpdater(StateManager stateManager, VehicleRoutingTransportCosts transportCost, TransportDistance distanceCalculator, StateId last_distance_id, StateId last_time_id, StateId last_cost_id) {
+            this.stateManager = stateManager;
+            this.transportCost = transportCost;
+            this.distanceCalculator = distanceCalculator;
+            this.last_transport_distance_id = last_distance_id;
+            this.last_transport_time_id = last_time_id;
+            this.last_transport_cost_id = last_cost_id;
         }
-        return waitingTime;
-    }
 
-    /**
-     * @param route to get the distance from
-     * @return total distance of route
-     */
-    public Double getDistance(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        return stateManager.getRouteState(route, distance_id, Double.class);
-    }
+        @Override
+        public void begin(VehicleRoute route) {
+            this.route = route;
+            this.prevAct = route.getStart();
+            this.prevActDeparture = route.getDepartureTime();
+        }
 
-    /**
-     * @param activity at which is distance of the current route is measured
-     * @return distance at activity
-     */
-    public Double getDistanceAtActivity(TourActivity activity, VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        if (activity == null) throw new IllegalArgumentException("activity is missing.");
-        if (activity instanceof Start) return 0.;
-        if (activity instanceof End) return getDistance(route);
-        verifyThatRouteContainsAct(activity, route);
-        return stateManager.getActivityState(activity, distance_id, Double.class);
-    }
+        @Override
+        public void visit(TourActivity activity) {
+            stateManager.putActivityState(activity, last_transport_distance_id, distance(activity));
+            stateManager.putActivityState(activity, last_transport_time_id, transportTime(activity));
+            stateManager.putActivityState(activity, last_transport_cost_id, transportCost(activity));
 
-    /**
-     * @return number of pickups in specified solution (without load at beginning of each route)
-     */
-    public Integer getNumberOfPickups() {
-        return noPickups;
-    }
+            prevAct = activity;
+            prevActDeparture = activity.getEndTime();
+        }
 
-    /**
-     * @param route to get the number of pickups at beginning from
-     * @return number of pickups at beginning
-     */
-    public Integer getNumberOfPickupsAtBeginning(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        return stateManager.getRouteState(route, stateManager.createStateId(PICKUP_COUNT_AT_BEGINNING), Integer.class);
-    }
+        private double transportCost(TourActivity activity) {
+            return transportCost.getTransportCost(prevAct.getLocation(), activity.getLocation(), prevActDeparture, route.getDriver(), route.getVehicle());
+        }
 
-    /**
-     * @return number of pickups in specified solution at beginning of each route
-     */
-    public Integer getNumberOfPickupsAtBeginning() {
-        return noPickupsAtBeginning;
-    }
+        private double transportTime(TourActivity activity) {
+            return activity.getArrTime() - prevActDeparture;
+        }
 
-    /**
-     * @return number of deliveries in specified solution (without load at end of each route)
-     */
-    public Integer getNumberOfDeliveries() {
-        return noDeliveries;
-    }
+        private double distance(TourActivity activity) {
+            return distanceCalculator.getDistance(prevAct.getLocation(), activity.getLocation(), prevActDeparture, route.getVehicle());
+        }
 
-    /**
-     * @return number of deliveries in specified solution at end of each route
-     */
-    public Integer getNumberOfDeliveriesAtEnd() {
-        return noDeliveriesAtEnd;
-    }
+        @Override
+        public void finish() {
+            stateManager.putRouteState(route, last_transport_distance_id, distance(route.getEnd()));
+            stateManager.putRouteState(route, last_transport_time_id, transportTime(route.getEnd()));
+            stateManager.putRouteState(route, last_transport_cost_id, transportCost(route.getEnd()));
+        }
 
-    /**
-     * @param route to get the number of deliveries at end from
-     * @return number of deliveries at end of specified route
-     */
-    public Integer getNumberOfDeliveriesAtEnd(VehicleRoute route) {
-        if (route == null) throw new IllegalArgumentException("route is missing.");
-        return stateManager.getRouteState(route, stateManager.createStateId(DELIVERY_COUNT_AT_END), Integer.class);
     }
 
-    /**
-     * @return load picked up in solution (without load at beginning of each route)
-     */
-    public Capacity getLoadPickedUp() {
-        return pickupLoad;
-    }
+    private static class DistanceUpdater implements StateUpdater, ActivityVisitor {
 
-    /**
-     * @return load picked up in solution at beginning of each route
-     */
-    public Capacity getLoadAtBeginning() {
-        return pickupLoadAtBeginning;
-    }
+        private StateId distance_id;
 
-    /**
-     * @return load delivered in solution (without load at end of each route)
-     */
-    public Capacity getLoadDelivered() {
-        return deliveryLoad;
-    }
+        private StateManager stateManager;
 
-    /**
-     * @return load delivered in solution at end of each route
-     */
-    public Capacity getLoadAtEnd() {
-        return deliveryLoadAtEnd;
-    }
+        private double sum_distance = 0.;
 
+        private TransportDistance distanceCalculator;
 
-    /**
-     * @return total distance for specified solution
-     */
-    public Double getDistance() {
-        return tp_distance;
-    }
+        private TourActivity prevAct;
 
-    /**
-     * @return total operation time for specified solution
-     */
-    public Double getOperationTime() {
-        return operation_time;
-    }
+        private VehicleRoute route;
 
-    public Double getMaxOperationTime() { return maxOperationTime; }
+        private DistanceUpdater(StateId distance_id, StateManager stateManager, TransportDistance distanceCalculator) {
+            this.distance_id = distance_id;
+            this.stateManager = stateManager;
+            this.distanceCalculator = distanceCalculator;
+        }
 
-    /**
-     * @return total waiting time for specified solution
-     */
-    public Double getWaitingTime() {
-        return waiting_time;
-    }
+        @Override
+        public void begin(VehicleRoute route) {
+            sum_distance = 0.;
+            this.route = route;
+            this.prevAct = route.getStart();
+        }
 
-    /**
-     * @return total transportation time
-     */
-    public Double getTransportTime() {
-        return tp_time;
-    }
+        @Override
+        public void visit(TourActivity activity) {
+            double distance = distanceCalculator.getDistance(prevAct.getLocation(), activity.getLocation(), prevAct.getEndTime(), route.getVehicle());
+            sum_distance += distance;
+            stateManager.putActivityState(activity, distance_id, sum_distance);
+            prevAct = activity;
+        }
 
-    /**
-     * @return total time window violation for specified solution
-     */
-    public Double getTimeWindowViolation() {
-        return tw_violation;
+        @Override
+        public void finish() {
+            double distance = distanceCalculator.getDistance(prevAct.getLocation(), route.getEnd().getLocation(), prevAct.getEndTime(), route.getVehicle());
+            sum_distance += distance;
+            stateManager.putRouteState(route, distance_id, sum_distance);
+        }
     }
 
-    /**
-     * @return total capacity violation for specified solution
-     */
-    public Capacity getCapacityViolation() {
-        return cap_violation;
-    }
+    private static class SkillUpdater implements StateUpdater, ActivityVisitor {
 
-    /**
-     * @return total service time for specified solution
-     */
-    public Double getServiceTime() {
-        return service_time;
-    }
+        private StateManager stateManager;
 
-    /**
-     * @return total fixed costs for specified solution
-     */
-    public Double getFixedCosts() {
-        return fixed_costs;
-    }
+        private StateId skill_id;
 
-    /**
-     * @return total variable transport costs for specified solution
-     */
-    public Double getVariableTransportCosts() {
-        return variable_transport_costs;
-    }
+        private VehicleRoute route;
 
-    /**
-     * @return total costs defined by solutionCostCalculator
-     */
-    public Double getTotalCosts() {
-        return total_costs;
-    }
+        private boolean skillConstraintViolatedOnRoute;
 
-    /**
-     * @return true if at least one route in specified solution has shipment constraint violation
-     */
-    public Boolean hasShipmentConstraintViolation() {
-        return hasShipmentConstraintViolation;
-    }
+        private SkillUpdater(StateManager stateManager, StateId skill_id) {
+            this.stateManager = stateManager;
+            this.skill_id = skill_id;
+        }
 
-    /**
-     * @return true if at least one route in specified solution has backhaul constraint violation
-     */
-    public Boolean hasBackhaulConstraintViolation() {
-        return hasBackhaulConstraintViolation;
-    }
+        @Override
+        public void begin(VehicleRoute route) {
+            this.route = route;
+            skillConstraintViolatedOnRoute = false;
+        }
 
-    /**
-     * @return true if at least one route in specified solution has skill constraint violation
-     */
-    public Boolean hasSkillConstraintViolation() {
-        return hasSkillConstraintViolation;
+        @Override
+        public void visit(TourActivity activity) {
+            boolean violatedAtActivity = false;
+            if (activity instanceof TourActivity.JobActivity) {
+                Set<String> requiredForActivity = ((TourActivity.JobActivity) activity).getJob().getRequiredSkills().values();
+                for (String skill : requiredForActivity) {
+                    if (!route.getVehicle().getSkills().containsSkill(skill)) {
+                        violatedAtActivity = true;
+                        skillConstraintViolatedOnRoute = true;
+                    }
+                }
+            }
+            stateManager.putActivityState(activity, skill_id, violatedAtActivity);
+        }
+
+        @Override
+        public void finish() {
+            stateManager.putRouteState(route, skill_id, skillConstraintViolatedOnRoute);
+        }
     }
 
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/AbstractVehicle.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/AbstractVehicle.java
index 4f614e04c..72546c286 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/AbstractVehicle.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/AbstractVehicle.java
@@ -26,27 +26,15 @@
  */
 public abstract class AbstractVehicle implements Vehicle {
 
-    public abstract static class AbstractTypeKey implements HasIndex {
-
-        private int index;
-
-        @Override
-        public int getIndex() {
-            return index;
-        }
-
-        public void setIndex(int index) {
-            this.index = index;
-        }
-
-    }
-
     private int index;
-
     private VehicleTypeKey vehicleIdentifier;
-
     private Object userData;
 
+    @Override
+    public VehicleTypeKey getVehicleTypeIdentifier() {
+        return vehicleIdentifier;
+    }
+
     /**
      * @return User-specific domain data associated with the vehicle
      */
@@ -59,6 +47,10 @@ protected void setUserData(Object userData) {
         this.userData = userData;
     }
 
+    protected void setVehicleIdentifier(VehicleTypeKey vehicleTypeIdentifier) {
+        this.vehicleIdentifier = vehicleTypeIdentifier;
+    }
+
     @Override
     public int getIndex() {
         return index;
@@ -68,12 +60,20 @@ protected void setIndex(int index) {
         this.index = index;
     }
 
-    @Override
-    public VehicleTypeKey getVehicleTypeIdentifier() {
-        return vehicleIdentifier;
-    }
+    public abstract static class AbstractTypeKey implements HasIndex {
+
+        private int index;
+
+        @Override
+        public int getIndex() {
+            return index;
+        }
+
+        public void setIndex(int index) {
+            this.index = index;
+        }
 
-    protected void setVehicleIdentifier(VehicleTypeKey vehicleTypeIdentifier) {
-        this.vehicleIdentifier = vehicleTypeIdentifier;
     }
+
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Capacity.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Capacity.java
index 0017d21ab..46153c7e9 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Capacity.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Capacity.java
@@ -28,6 +28,29 @@
  */
 public class Capacity {
 
+    private int[] dimensions;
+
+    /**
+     * copy constructor
+     *
+     * @param capacity capacity to be copied
+     */
+    Capacity(Capacity capacity) {
+        this.dimensions = new int[capacity.getNuOfDimensions()];
+        for (int i = 0; i < capacity.getNuOfDimensions(); i++) {
+            this.dimensions[i] = capacity.get(i);
+        }
+    }
+
+    /**
+     * Returns the number of specified capacity dimensions.
+     *
+     * @return noDimensions
+     */
+    public int getNuOfDimensions() {
+        return dimensions.length;
+    }
+
     /**
      * Adds up two capacities, i.e. sums up each and every capacity dimension, and returns the resulting Capacity.
      * <p>
@@ -47,6 +70,23 @@ public static Capacity addup(Capacity cap1, Capacity cap2) {
         return capacityBuilder.build();
     }
 
+    /**
+     * Returns value of capacity-dimension with specified index.
+     * <p>
+     * <p>If capacity dimension does not exist, it returns 0 (rather than IndexOutOfBoundsException).
+     *
+     * @param index dimension index of the capacity value to be retrieved
+     * @return the according dimension value
+     */
+    public int get(int index) {
+        if (index < dimensions.length) return dimensions[index];
+        return 0;
+    }
+
+    Capacity(Builder builder) {
+        dimensions = builder.dimensions;
+    }
+
     /**
      * Subtracts cap2subtract from cap and returns the resulting Capacity.
      *
@@ -123,6 +163,87 @@ public static Capacity copyOf(Capacity capacity) {
         return new Capacity(capacity);
     }
 
+    /**
+     * Return the maximum, i.e. the maximum of each capacity dimension.
+     *
+     * @param cap1 first capacity to compare
+     * @param cap2 second capacity to compare
+     * @return capacity maximum of each capacity dimension
+     */
+    public static Capacity max(Capacity cap1, Capacity cap2) {
+        if (cap1 == null || cap2 == null) throw new IllegalArgumentException("arg must not be null");
+        Capacity.Builder toReturnBuilder = Capacity.Builder.newInstance();
+        for (int i = 0; i < Math.max(cap1.getNuOfDimensions(), cap2.getNuOfDimensions()); i++) {
+            toReturnBuilder.addDimension(i, Math.max(cap1.get(i), cap2.get(i)));
+        }
+        return toReturnBuilder.build();
+    }
+
+    public static Capacity min(Capacity cap1, Capacity cap2) {
+        if (cap1 == null || cap2 == null) throw new IllegalArgumentException("arg must not be null");
+        Capacity.Builder toReturnBuilder = Capacity.Builder.newInstance();
+        for (int i = 0; i < Math.max(cap1.getNuOfDimensions(), cap2.getNuOfDimensions()); i++) {
+            toReturnBuilder.addDimension(i, Math.min(cap1.get(i), cap2.get(i)));
+        }
+        return toReturnBuilder.build();
+    }
+
+    /**
+     * Returns true if this capacity is less or equal than the capacity toCompare, i.e. if none of the capacity dimensions > than the corresponding dimension in toCompare.
+     *
+     * @param toCompare the capacity to compare
+     * @return true if this capacity is less or equal than toCompare
+     * @throws NullPointerException if one of the args is null
+     */
+    public boolean isLessOrEqual(Capacity toCompare) {
+        if (toCompare == null) throw new NullPointerException();
+        for (int i = 0; i < this.getNuOfDimensions(); i++) {
+            if (this.get(i) > toCompare.get(i)) return false;
+        }
+        return true;
+    }
+
+    /**
+     * Returns true if this capacity is greater or equal than the capacity toCompare
+     *
+     * @param toCompare the capacity to compare
+     * @return true if this capacity is greater or equal than toCompare
+     * @throws NullPointerException if one of the args is null
+     */
+    public boolean isGreaterOrEqual(Capacity toCompare) {
+        if (toCompare == null) throw new NullPointerException();
+        for (int i = 0; i < Math.max(this.getNuOfDimensions(), toCompare.getNuOfDimensions()); i++) {
+            if (this.get(i) < toCompare.get(i)) return false;
+        }
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        return Arrays.hashCode(dimensions);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof Capacity)) return false;
+
+        Capacity capacity = (Capacity) o;
+
+        if (!Arrays.equals(dimensions, capacity.dimensions)) return false;
+
+        return true;
+    }
+
+    @Override
+    public String toString() {
+        String string = "[noDimensions=" + getNuOfDimensions() + "]";
+        for (int i = 0; i < getNuOfDimensions(); i++) {
+            string += "[[dimIndex=" + i + "][dimValue=" + dimensions[i] + "]]";
+        }
+        return string;
+    }
+
     /**
      * Builder that builds Capacity
      *
@@ -135,6 +256,9 @@ public static Capacity copyOf(Capacity capacity) {
          */
         private int[] dimensions = new int[1];
 
+        Builder() {
+        }
+
         /**
          * Returns a new instance of Capacity with one dimension and a value/size of 0
          *
@@ -144,9 +268,6 @@ public static Builder newInstance() {
             return new Builder();
         }
 
-        Builder() {
-        }
-
         /**
          * add capacity dimension
          * <p>
@@ -187,126 +308,4 @@ public Capacity build() {
 
 
     }
-
-    private int[] dimensions;
-
-    /**
-     * copy constructor
-     *
-     * @param capacity capacity to be copied
-     */
-    Capacity(Capacity capacity) {
-        this.dimensions = new int[capacity.getNuOfDimensions()];
-        for (int i = 0; i < capacity.getNuOfDimensions(); i++) {
-            this.dimensions[i] = capacity.get(i);
-        }
-    }
-
-    Capacity(Builder builder) {
-        dimensions = builder.dimensions;
-    }
-
-    /**
-     * Returns the number of specified capacity dimensions.
-     *
-     * @return noDimensions
-     */
-    public int getNuOfDimensions() {
-        return dimensions.length;
-    }
-
-
-    /**
-     * Returns value of capacity-dimension with specified index.
-     * <p>
-     * <p>If capacity dimension does not exist, it returns 0 (rather than IndexOutOfBoundsException).
-     *
-     * @param index dimension index of the capacity value to be retrieved
-     * @return the according dimension value
-     */
-    public int get(int index) {
-        if (index < dimensions.length) return dimensions[index];
-        return 0;
-    }
-
-    /**
-     * Returns true if this capacity is less or equal than the capacity toCompare, i.e. if none of the capacity dimensions > than the corresponding dimension in toCompare.
-     *
-     * @param toCompare the capacity to compare
-     * @return true if this capacity is less or equal than toCompare
-     * @throws NullPointerException if one of the args is null
-     */
-    public boolean isLessOrEqual(Capacity toCompare) {
-        if (toCompare == null) throw new NullPointerException();
-        for (int i = 0; i < this.getNuOfDimensions(); i++) {
-            if (this.get(i) > toCompare.get(i)) return false;
-        }
-        return true;
-    }
-
-    /**
-     * Returns true if this capacity is greater or equal than the capacity toCompare
-     *
-     * @param toCompare the capacity to compare
-     * @return true if this capacity is greater or equal than toCompare
-     * @throws NullPointerException if one of the args is null
-     */
-    public boolean isGreaterOrEqual(Capacity toCompare) {
-        if (toCompare == null) throw new NullPointerException();
-        for (int i = 0; i < Math.max(this.getNuOfDimensions(), toCompare.getNuOfDimensions()); i++) {
-            if (this.get(i) < toCompare.get(i)) return false;
-        }
-        return true;
-    }
-
-    @Override
-    public String toString() {
-        String string = "[noDimensions=" + getNuOfDimensions() + "]";
-        for (int i = 0; i < getNuOfDimensions(); i++) {
-            string += "[[dimIndex=" + i + "][dimValue=" + dimensions[i] + "]]";
-        }
-        return string;
-    }
-
-    /**
-     * Return the maximum, i.e. the maximum of each capacity dimension.
-     *
-     * @param cap1 first capacity to compare
-     * @param cap2 second capacity to compare
-     * @return capacity maximum of each capacity dimension
-     */
-    public static Capacity max(Capacity cap1, Capacity cap2) {
-        if (cap1 == null || cap2 == null) throw new IllegalArgumentException("arg must not be null");
-        Capacity.Builder toReturnBuilder = Capacity.Builder.newInstance();
-        for (int i = 0; i < Math.max(cap1.getNuOfDimensions(), cap2.getNuOfDimensions()); i++) {
-            toReturnBuilder.addDimension(i, Math.max(cap1.get(i), cap2.get(i)));
-        }
-        return toReturnBuilder.build();
-    }
-
-    public static Capacity min(Capacity cap1, Capacity cap2) {
-        if (cap1 == null || cap2 == null) throw new IllegalArgumentException("arg must not be null");
-        Capacity.Builder toReturnBuilder = Capacity.Builder.newInstance();
-        for (int i = 0; i < Math.max(cap1.getNuOfDimensions(), cap2.getNuOfDimensions()); i++) {
-            toReturnBuilder.addDimension(i, Math.min(cap1.get(i), cap2.get(i)));
-        }
-        return toReturnBuilder.build();
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (!(o instanceof Capacity)) return false;
-
-        Capacity capacity = (Capacity) o;
-
-        if (!Arrays.equals(dimensions, capacity.dimensions)) return false;
-
-        return true;
-    }
-
-    @Override
-    public int hashCode() {
-        return Arrays.hashCode(dimensions);
-    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Location.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Location.java
index 51c74612c..e9a9b8694 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Location.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Location.java
@@ -25,6 +25,21 @@
  */
 public final class Location implements HasIndex, HasId {
 
+    public final static int NO_INDEX = -1;
+    private final int index;
+    private final Coordinate coordinate;
+    private final String id;
+    private final String name;
+    private Object userData;
+
+    private Location(Builder builder) {
+        this.userData = builder.userData;
+        this.index = builder.index;
+        this.coordinate = builder.coordinate;
+        this.id = builder.id;
+        this.name = builder.name;
+    }
+
     /**
      * Factory method (and shortcut) for creating a location object just with x and y coordinates.
      *
@@ -56,6 +71,58 @@ public static Location newInstance(int index) {
         return Location.Builder.newInstance().setIndex(index).build();
     }
 
+    /**
+     * @return User-specific domain data associated by the job
+     */
+    public Object getUserData() {
+        return userData;
+    }
+
+    @Override
+    public String getId() {
+        return id;
+    }
+
+    @Override
+    public int getIndex() {
+        return index;
+    }
+
+    public Coordinate getCoordinate() {
+        return coordinate;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = index;
+        result = 31 * result + (coordinate != null ? coordinate.hashCode() : 0);
+        result = 31 * result + (id != null ? id.hashCode() : 0);
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof Location)) return false;
+
+        Location location = (Location) o;
+
+        if (index != location.index) return false;
+        if (coordinate != null ? !coordinate.equals(location.coordinate) : location.coordinate != null) return false;
+        if (id != null ? !id.equals(location.id) : location.id != null) return false;
+
+        return true;
+    }
+
+    @Override
+    public String toString() {
+        return "[id=" + id + "][index=" + index + "][coordinate=" + coordinate + "]";
+    }
+
     public static class Builder {
 
         private String id;
@@ -148,76 +215,4 @@ public Location build() {
         }
 
     }
-
-    public final static int NO_INDEX = -1;
-
-    private final int index;
-
-    private final Coordinate coordinate;
-
-    private final String id;
-
-    private final String name;
-
-    private Object userData;
-
-    private Location(Builder builder) {
-        this.userData = builder.userData;
-        this.index = builder.index;
-        this.coordinate = builder.coordinate;
-        this.id = builder.id;
-        this.name = builder.name;
-    }
-
-    /**
-     * @return User-specific domain data associated by the job
-     */
-    public Object getUserData() {
-        return userData;
-    }
-
-    @Override
-    public String getId() {
-        return id;
-    }
-
-    @Override
-    public int getIndex() {
-        return index;
-    }
-
-    public Coordinate getCoordinate() {
-        return coordinate;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (!(o instanceof Location)) return false;
-
-        Location location = (Location) o;
-
-        if (index != location.index) return false;
-        if (coordinate != null ? !coordinate.equals(location.coordinate) : location.coordinate != null) return false;
-        if (id != null ? !id.equals(location.id) : location.id != null) return false;
-
-        return true;
-    }
-
-    @Override
-    public int hashCode() {
-        int result = index;
-        result = 31 * result + (coordinate != null ? coordinate.hashCode() : 0);
-        result = 31 * result + (id != null ? id.hashCode() : 0);
-        return result;
-    }
-
-    @Override
-    public String toString() {
-        return "[id=" + id + "][index=" + index + "][coordinate=" + coordinate + "]";
-    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Skills.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Skills.java
index ddc7df8e0..38240fa2b 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Skills.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Skills.java
@@ -28,8 +28,65 @@
  */
 public class Skills {
 
+    private Set<String> skills = new HashSet<String>();
+
+    private Skills(Builder builder) {
+        skills.addAll(builder.skills);
+    }
+
+    /**
+     * Not case sensitive.
+     *
+     * @param skill which is checked whether it is in skill container or not
+     * @return true if skill is included, false otherwise
+     */
+    public boolean containsSkill(String skill) {
+        return skills.contains(skill.trim().toLowerCase());// trim to be consistent with addSkill()
+    }
+
+    @Override
+    public int hashCode() {
+        return skills != null ? skills.hashCode() : 0;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        Skills skills1 = (Skills) o;
+
+        if (skills != null ? !skills.equals(skills1.skills) : skills1.skills != null) return false;
+
+        return true;
+    }
+
+    public String toString() {
+        String s = "[";
+        boolean first = true;
+        for (String skill : values()) {
+            if (first) {
+                s += skill;
+                first = false;
+            } else s += ", " + skill;
+        }
+        s += "]";
+        return s;
+    }
+
+    /**
+     * Returns an unmodifiable set of skills. All skills are inLowerCase.
+     *
+     * @return set of skills in this containter
+     */
+    public Set<String> values() {
+        return Collections.unmodifiableSet(skills);
+    }
+
     public static class Builder {
 
+        private Set<String> skills = new HashSet<String>();
+
         /**
          * Returns new instance of skill-builder.
          *
@@ -39,27 +96,25 @@ public static Builder newInstance() {
             return new Builder();
         }
 
-        private Set<String> skills = new HashSet<String>();
-
         /**
-         * Adds skill. Skill is transformed into lowerCase.
+         * Adds a collection of skills.
          *
-         * @param skill skill to be added
+         * @param skills collection of skills to be added
          * @return builder
          */
-        public Builder addSkill(String skill) {
-            skills.add(skill.trim().toLowerCase());
+        public Builder addAllSkills(Collection<String> skills) {
+            for (String skill : skills) addSkill(skill);
             return this;
         }
 
         /**
-         * Adds a collection of skills.
+         * Adds skill. Skill is transformed into lowerCase.
          *
-         * @param skills collection of skills to be added
+         * @param skill skill to be added
          * @return builder
          */
-        public Builder addAllSkills(Collection<String> skills) {
-            for (String skill : skills) addSkill(skill);
+        public Builder addSkill(String skill) {
+            skills.add(skill.trim().toLowerCase());
             return this;
         }
 
@@ -73,59 +128,4 @@ public Skills build() {
         }
 
     }
-
-    private Set<String> skills = new HashSet<String>();
-
-    private Skills(Builder builder) {
-        skills.addAll(builder.skills);
-    }
-
-    /**
-     * Returns an unmodifiable set of skills. All skills are inLowerCase.
-     *
-     * @return set of skills in this containter
-     */
-    public Set<String> values() {
-        return Collections.unmodifiableSet(skills);
-    }
-
-    public String toString() {
-        String s = "[";
-        boolean first = true;
-        for (String skill : values()) {
-            if (first) {
-                s += skill;
-                first = false;
-            } else s += ", " + skill;
-        }
-        s += "]";
-        return s;
-    }
-
-    /**
-     * Not case sensitive.
-     *
-     * @param skill which is checked whether it is in skill container or not
-     * @return true if skill is included, false otherwise
-     */
-    public boolean containsSkill(String skill) {
-        return skills.contains(skill.trim().toLowerCase());// trim to be consistent with addSkill()
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-
-        Skills skills1 = (Skills) o;
-
-        if (skills != null ? !skills.equals(skills1.skills) : skills1.skills != null) return false;
-
-        return true;
-    }
-
-    @Override
-    public int hashCode() {
-        return skills != null ? skills.hashCode() : 0;
-    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
index 27574a3f8..dee0d52c6 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
@@ -41,7 +41,6 @@
 import java.util.*;
 
 
-
 /**
  * Contains and defines the vehicle routing problem.
  * <p>
@@ -56,6 +55,192 @@
  */
 public class VehicleRoutingProblem {
 
+    /**
+     * logger logging for this class
+     */
+    private final static Logger logger = LoggerFactory.getLogger(VehicleRoutingProblem.class);
+    /**
+     * contains transportation costs, i.e. the costs traveling from location A to B
+     */
+    private final VehicleRoutingTransportCosts transportCosts;
+    /**
+     * contains activity costs, i.e. the costs imposed by an activity
+     */
+    private final VehicleRoutingActivityCosts activityCosts;
+    /**
+     * map of jobs, stored by jobId
+     */
+    private final Map<String, Job> jobs;
+    private final Map<String, Job> allJobs;
+    /**
+     * Collection that contains available vehicles.
+     */
+    private final Collection<Vehicle> vehicles;
+    /**
+     * Collection that contains all available types.
+     */
+    private final Collection<VehicleType> vehicleTypes;
+    private final Collection<VehicleRoute> initialVehicleRoutes;
+    private final Collection<Location> allLocations;
+    /**
+     * An enum that indicates type of fleetSize. By default, it is INFINTE
+     */
+    private final FleetSize fleetSize;
+    private Map<Job, List<AbstractActivity>> activityMap;
+    private final JobActivityFactory jobActivityFactory = new JobActivityFactory() {
+
+        @Override
+        public List<AbstractActivity> createActivities(Job job) {
+            return copyAndGetActivities(job);
+        }
+
+    };
+    private int nuActivities;
+
+    private VehicleRoutingProblem(Builder builder) {
+        this.jobs = builder.jobs;
+        this.fleetSize = builder.fleetSize;
+        this.vehicles = builder.uniqueVehicles;
+        this.vehicleTypes = builder.vehicleTypes.values();
+        this.initialVehicleRoutes = builder.initialRoutes;
+        this.transportCosts = builder.transportCosts;
+        this.activityCosts = builder.activityCosts;
+        this.activityMap = builder.activityMap;
+        this.nuActivities = builder.activityIndexCounter;
+        this.allLocations = builder.allLocations;
+        this.allJobs = builder.tentativeJobs;
+        logger.info("setup problem: {}", this);
+    }
+
+    @Override
+    public String toString() {
+        return "[fleetSize=" + fleetSize + "][#jobs=" + jobs.size() + "][#vehicles=" + vehicles.size() + "][#vehicleTypes=" + vehicleTypes.size() + "][" +
+            "transportCost=" + transportCosts + "][activityCosts=" + activityCosts + "]";
+    }
+
+    /**
+     * Returns type of fleetSize, either INFINITE or FINITE.
+     * <p>
+     * <p>By default, it is INFINITE.
+     *
+     * @return either FleetSize.INFINITE or FleetSize.FINITE
+     */
+    public FleetSize getFleetSize() {
+        return fleetSize;
+    }
+
+    /**
+     * Returns the unmodifiable job map.
+     *
+     * @return unmodifiable jobMap
+     */
+    public Map<String, Job> getJobs() {
+        return Collections.unmodifiableMap(jobs);
+    }
+
+    public Map<String, Job> getJobsInclusiveInitialJobsInRoutes() {
+        return Collections.unmodifiableMap(allJobs);
+    }
+
+    /**
+     * Returns a copy of initial vehicle routes.
+     *
+     * @return copied collection of initial vehicle routes
+     */
+    public Collection<VehicleRoute> getInitialVehicleRoutes() {
+        Collection<VehicleRoute> copiedInitialRoutes = new ArrayList<VehicleRoute>();
+        for (VehicleRoute route : initialVehicleRoutes) {
+            copiedInitialRoutes.add(VehicleRoute.copyOf(route));
+        }
+        return copiedInitialRoutes;
+    }
+
+    /**
+     * Returns the entire, unmodifiable collection of types.
+     *
+     * @return unmodifiable collection of types
+     * @see com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl
+     */
+    public Collection<VehicleType> getTypes() {
+        return Collections.unmodifiableCollection(vehicleTypes);
+    }
+
+    /**
+     * Returns the entire, unmodifiable collection of vehicles.
+     *
+     * @return unmodifiable collection of vehicles
+     * @see Vehicle
+     */
+    public Collection<Vehicle> getVehicles() {
+        return Collections.unmodifiableCollection(vehicles);
+    }
+
+    /**
+     * Returns routing costs.
+     *
+     * @return routingCosts
+     * @see VehicleRoutingTransportCosts
+     */
+    public VehicleRoutingTransportCosts getTransportCosts() {
+        return transportCosts;
+    }
+
+    /**
+     * Returns activityCosts.
+     */
+    public VehicleRoutingActivityCosts getActivityCosts() {
+        return activityCosts;
+    }
+
+    public Collection<Location> getAllLocations() {
+        return allLocations;
+    }
+
+    /**
+     * @param job for which the corresponding activities needs to be returned
+     * @return associated activities
+     */
+    public List<AbstractActivity> getActivities(Job job) {
+        return Collections.unmodifiableList(activityMap.get(job));
+    }
+
+    /**
+     * @return total number of activities
+     */
+    public int getNuActivities() {
+        return nuActivities;
+    }
+
+    /**
+     * @return factory that creates the activities associated to a job
+     */
+    public JobActivityFactory getJobActivityFactory() {
+        return jobActivityFactory;
+    }
+
+//    public Map<Job,List<AbstractActivity>> getActivityMap() { return Collections.unmodifiableMap(activityMap); }
+
+    /**
+     * @param job for which the corresponding activities needs to be returned
+     * @return a copy of the activities that are associated to the specified job
+     */
+    public List<AbstractActivity> copyAndGetActivities(Job job) {
+        List<AbstractActivity> acts = new ArrayList<AbstractActivity>();
+        if (activityMap.containsKey(job)) {
+            for (AbstractActivity act : activityMap.get(job)) acts.add((AbstractActivity) act.duplicate());
+        }
+        return acts;
+    }
+
+    /**
+     * Enum that characterizes the fleet-size.
+     *
+     * @author sschroeder
+     */
+    public static enum FleetSize {
+        FINITE, INFINITE
+    }
+
     /**
      * Builder to build the routing-problem.
      *
@@ -64,48 +249,28 @@
     public static class Builder {
 
 
-        /**
-         * Returns a new instance of this builder.
-         *
-         * @return builder
-         */
-        public static Builder newInstance() {
-            return new Builder();
-        }
-
+        private final DefaultShipmentActivityFactory shipmentActivityFactory = new DefaultShipmentActivityFactory();
+        private final DefaultTourActivityFactory serviceActivityFactory = new DefaultTourActivityFactory();
         private VehicleRoutingTransportCosts transportCosts;
-
         private VehicleRoutingActivityCosts activityCosts = new WaitingTimeCosts();
-
         private Map<String, Job> jobs = new LinkedHashMap<String, Job>();
-
         private Map<String, Job> tentativeJobs = new LinkedHashMap<String, Job>();
-
         private Set<String> jobsInInitialRoutes = new HashSet<String>();
-
         private Map<String, Coordinate> tentative_coordinates = new HashMap<String, Coordinate>();
-
         private FleetSize fleetSize = FleetSize.INFINITE;
-
         private Map<String, VehicleType> vehicleTypes = new HashMap<>();
-
         private Collection<VehicleRoute> initialRoutes = new ArrayList<VehicleRoute>();
-
         private Set<Vehicle> uniqueVehicles = new LinkedHashSet<Vehicle>();
-
         private Set<String> addedVehicleIds = new LinkedHashSet<String>();
-
         private boolean hasBreaks = false;
-
         private JobActivityFactory jobActivityFactory = new JobActivityFactory() {
 
             @Override
             public List<AbstractActivity> createActivities(Job job) {
                 List<AbstractActivity> acts = new ArrayList<AbstractActivity>();
-                if( job instanceof Break){
+                if (job instanceof Break) {
                     acts.add(BreakActivity.newInstance((Break) job));
-                }
-                else if (job instanceof Service) {
+                } else if (job instanceof Service) {
                     acts.add(serviceActivityFactory.createActivity((Service) job));
                 } else if (job instanceof Shipment) {
                     acts.add(shipmentActivityFactory.createPickup((Shipment) job));
@@ -115,37 +280,23 @@ else if (job instanceof Service) {
             }
 
         };
-
         private int jobIndexCounter = 1;
-
         private int vehicleIndexCounter = 1;
-
         private int activityIndexCounter = 1;
-
         private int vehicleTypeIdIndexCounter = 1;
-
         private Map<VehicleTypeKey, Integer> typeKeyIndices = new HashMap<VehicleTypeKey, Integer>();
-
         private Map<Job, List<AbstractActivity>> activityMap = new HashMap<Job, List<AbstractActivity>>();
+        private Set<Location> allLocations = new HashSet<Location>();
 
-        private final DefaultShipmentActivityFactory shipmentActivityFactory = new DefaultShipmentActivityFactory();
-
-        private final DefaultTourActivityFactory serviceActivityFactory = new DefaultTourActivityFactory();
-
-        private void incJobIndexCounter() {
-            jobIndexCounter++;
-        }
-
-        private void incActivityIndexCounter() {
-            activityIndexCounter++;
-        }
-
-        private void incVehicleTypeIdIndexCounter() {
-            vehicleTypeIdIndexCounter++;
+        /**
+         * Returns a new instance of this builder.
+         *
+         * @return builder
+         */
+        public static Builder newInstance() {
+            return new Builder();
         }
 
-        private Set<Location> allLocations = new HashSet<Location>();
-
         /**
          * Returns the unmodifiable map of collected locations (mapped by their location-id).
          *
@@ -155,8 +306,6 @@ private void incVehicleTypeIdIndexCounter() {
             return Collections.unmodifiableMap(tentative_coordinates);
         }
 
-
-
         /**
          * Returns the locations collected SO FAR by this builder.
          * <p>
@@ -187,7 +336,6 @@ public Builder setRoutingCost(VehicleRoutingTransportCosts costs) {
             return this;
         }
 
-
         public Builder setJobActivityFactory(JobActivityFactory jobActivityFactory) {
             this.jobActivityFactory = jobActivityFactory;
             return this;
@@ -206,63 +354,6 @@ public Builder setFleetSize(FleetSize fleetSize) {
             return this;
         }
 
-        /**
-         * Adds a job which is either a service or a shipment.
-         * <p>
-         * <p>Note that job.getId() must be unique, i.e. no job (either it is a shipment or a service) is allowed to have an already allocated id.
-         *
-         * @param job job to be added
-         * @return this builder
-         * @throws IllegalStateException if job is neither a shipment nor a service, or jobId has already been added.
-         *
-         */
-        public Builder addJob(Job job) {
-            if (!(job instanceof AbstractJob)) throw new IllegalArgumentException("job must be of type AbstractJob");
-            return addJob((AbstractJob) job);
-        }
-
-        /**
-         * Adds a job which is either a service or a shipment.
-         * <p>
-         * <p>Note that job.getId() must be unique, i.e. no job (either it is a shipment or a service) is allowed to have an already allocated id.
-         *
-         * @param job job to be added
-         * @return this builder
-         * @throws IllegalStateException if job is neither a shipment nor a service, or jobId has already been added.
-         */
-        public Builder addJob(AbstractJob job) {
-            if (tentativeJobs.containsKey(job.getId()))
-                throw new IllegalArgumentException("The vehicle routing problem already contains a service or shipment with id " + job.getId() + ". Please make sure you use unique ids for all services and shipments.");
-            if (!(job instanceof Service || job instanceof Shipment))
-                throw new IllegalArgumentException("Job must be either a service or a shipment.");
-            job.setIndex(jobIndexCounter);
-            incJobIndexCounter();
-            tentativeJobs.put(job.getId(), job);
-            addLocationToTentativeLocations(job);
-            return this;
-        }
-
-        private void addLocationToTentativeLocations(Job job) {
-            if (job instanceof Service) {
-                Location location = ((Service) job).getLocation();
-//                tentative_coordinates.put(location.getId(), location.getCoordinate());
-                addLocationToTentativeLocations(location);
-            } else if (job instanceof Shipment) {
-                Shipment shipment = (Shipment) job;
-                Location pickupLocation = shipment.getPickupLocation();
-                addLocationToTentativeLocations(pickupLocation);
-//                tentative_coordinates.put(pickupLocation.getId(), pickupLocation.getCoordinate());
-                Location deliveryLocation = shipment.getDeliveryLocation();
-                addLocationToTentativeLocations(deliveryLocation);
-//                tentative_coordinates.put(deliveryLocation.getId(), deliveryLocation.getCoordinate());
-            }
-        }
-
-        private void addLocationToTentativeLocations(Location location) {
-            tentative_coordinates.put(location.getId(), location.getCoordinate());
-            allLocations.add(location);
-        }
-
         private void addJobToFinalJobMapAndCreateActivities(Job job) {
             if (job instanceof Service) {
                 Service service = (Service) job;
@@ -290,7 +381,7 @@ private boolean addBreaksToActivityMap() {
                     List<AbstractActivity> breakActivities = jobActivityFactory.createActivities(v.getBreak());
                     if (breakActivities.isEmpty())
                         throw new IllegalArgumentException("At least one activity for break needs to be created by activityFactory.");
-                    for(AbstractActivity act : breakActivities){
+                    for (AbstractActivity act : breakActivities) {
                         act.setIndex(activityIndexCounter);
                         incActivityIndexCounter();
                     }
@@ -300,6 +391,23 @@ private boolean addBreaksToActivityMap() {
             return hasBreaks;
         }
 
+        private void incActivityIndexCounter() {
+            activityIndexCounter++;
+        }
+
+        /**
+         * Adds a collection of initial vehicle routes.
+         *
+         * @param routes initial routes
+         * @return the builder
+         */
+        public Builder addInitialVehicleRoutes(Collection<VehicleRoute> routes) {
+            for (VehicleRoute r : routes) {
+                addInitialVehicleRoute(r);
+            }
+            return this;
+        }
+
         /**
          * Adds an initial vehicle route.
          *
@@ -307,7 +415,7 @@ private boolean addBreaksToActivityMap() {
          * @return the builder
          */
         public Builder addInitialVehicleRoute(VehicleRoute route) {
-            if(!addedVehicleIds.contains(route.getVehicle().getId())){
+            if (!addedVehicleIds.contains(route.getVehicle().getId())) {
                 addVehicle((AbstractVehicle) route.getVehicle());
                 addedVehicleIds.add(route.getVehicle().getId());
             }
@@ -326,52 +434,6 @@ public Builder addInitialVehicleRoute(VehicleRoute route) {
             return this;
         }
 
-
-
-        private void registerJobAndActivity(AbstractActivity abstractAct, Job job) {
-            if (activityMap.containsKey(job)) activityMap.get(job).add(abstractAct);
-            else {
-                List<AbstractActivity> actList = new ArrayList<AbstractActivity>();
-                actList.add(abstractAct);
-                activityMap.put(job, actList);
-            }
-        }
-
-        /**
-         * Adds a collection of initial vehicle routes.
-         *
-         * @param routes initial routes
-         * @return the builder
-         */
-        public Builder addInitialVehicleRoutes(Collection<VehicleRoute> routes) {
-            for (VehicleRoute r : routes) {
-                addInitialVehicleRoute(r);
-            }
-            return this;
-        }
-
-        private void addShipment(Shipment job) {
-            if (jobs.containsKey(job.getId())) {
-                logger.warn("The job " + job + " has already been added to the job list. This overrides the existing job.");
-            }
-            addLocationToTentativeLocations(job);
-//            tentative_coordinates.put(job.getPickupLocation().getId(), job.getPickupLocation().getCoordinate());
-//            tentative_coordinates.put(job.getDeliveryLocation().getId(), job.getDeliveryLocation().getCoordinate());
-            jobs.put(job.getId(), job);
-        }
-
-        /**
-         * Adds a vehicle.
-         *
-         * @param vehicle vehicle to be added
-         * @return this builder
-         * */
-        public Builder addVehicle(Vehicle vehicle) {
-            if (!(vehicle instanceof AbstractVehicle))
-                throw new IllegalArgumentException("A vehicle must be an AbstractVehicle.");
-            return addVehicle((AbstractVehicle) vehicle);
-        }
-
         /**
          * Adds a vehicle.
          *
@@ -379,10 +441,9 @@ public Builder addVehicle(Vehicle vehicle) {
          * @return this builder
          */
         public Builder addVehicle(AbstractVehicle vehicle) {
-            if(addedVehicleIds.contains(vehicle.getId())){
+            if (addedVehicleIds.contains(vehicle.getId())) {
                 throw new IllegalArgumentException("The vehicle routing problem already contains a vehicle with id " + vehicle.getId() + ". Please choose unique ids for each vehicle.");
-            }
-            else addedVehicleIds.add(vehicle.getId());
+            } else addedVehicleIds.add(vehicle.getId());
             if (!uniqueVehicles.contains(vehicle)) {
                 vehicle.setIndex(vehicleIndexCounter);
                 incVehicleIndexCounter();
@@ -413,10 +474,54 @@ public Builder addVehicle(AbstractVehicle vehicle) {
             return this;
         }
 
+        private void addLocationToTentativeLocations(Job job) {
+            if (job instanceof Service) {
+                Location location = ((Service) job).getLocation();
+//                tentative_coordinates.put(location.getId(), location.getCoordinate());
+                addLocationToTentativeLocations(location);
+            } else if (job instanceof Shipment) {
+                Shipment shipment = (Shipment) job;
+                Location pickupLocation = shipment.getPickupLocation();
+                addLocationToTentativeLocations(pickupLocation);
+//                tentative_coordinates.put(pickupLocation.getId(), pickupLocation.getCoordinate());
+                Location deliveryLocation = shipment.getDeliveryLocation();
+                addLocationToTentativeLocations(deliveryLocation);
+//                tentative_coordinates.put(deliveryLocation.getId(), deliveryLocation.getCoordinate());
+            }
+        }
+
+        private void registerJobAndActivity(AbstractActivity abstractAct, Job job) {
+            if (activityMap.containsKey(job)) activityMap.get(job).add(abstractAct);
+            else {
+                List<AbstractActivity> actList = new ArrayList<AbstractActivity>();
+                actList.add(abstractAct);
+                activityMap.put(job, actList);
+            }
+        }
+
         private void incVehicleIndexCounter() {
             vehicleIndexCounter++;
         }
 
+        private void incVehicleTypeIdIndexCounter() {
+            vehicleTypeIdIndexCounter++;
+        }
+
+        private void addLocationToTentativeLocations(Location location) {
+            tentative_coordinates.put(location.getId(), location.getCoordinate());
+            allLocations.add(location);
+        }
+
+        private void addShipment(Shipment job) {
+            if (jobs.containsKey(job.getId())) {
+                logger.warn("The job " + job + " has already been added to the job list. This overrides the existing job.");
+            }
+            addLocationToTentativeLocations(job);
+//            tentative_coordinates.put(job.getPickupLocation().getId(), job.getPickupLocation().getCoordinate());
+//            tentative_coordinates.put(job.getDeliveryLocation().getId(), job.getDeliveryLocation().getCoordinate());
+            jobs.put(job.getId(), job);
+        }
+
         /**
          * Sets the activity-costs.
          * <p>
@@ -471,6 +576,44 @@ public Builder addAllJobs(Collection<? extends Job> jobs) {
             return this;
         }
 
+        /**
+         * Adds a job which is either a service or a shipment.
+         * <p>
+         * <p>Note that job.getId() must be unique, i.e. no job (either it is a shipment or a service) is allowed to have an already allocated id.
+         *
+         * @param job job to be added
+         * @return this builder
+         * @throws IllegalStateException if job is neither a shipment nor a service, or jobId has already been added.
+         */
+        public Builder addJob(Job job) {
+            if (!(job instanceof AbstractJob)) throw new IllegalArgumentException("job must be of type AbstractJob");
+            return addJob((AbstractJob) job);
+        }
+
+        /**
+         * Adds a job which is either a service or a shipment.
+         * <p>
+         * <p>Note that job.getId() must be unique, i.e. no job (either it is a shipment or a service) is allowed to have an already allocated id.
+         *
+         * @param job job to be added
+         * @return this builder
+         * @throws IllegalStateException if job is neither a shipment nor a service, or jobId has already been added.
+         */
+        public Builder addJob(AbstractJob job) {
+            if (tentativeJobs.containsKey(job.getId()))
+                throw new IllegalArgumentException("The vehicle routing problem already contains a service or shipment with id " + job.getId() + ". Please make sure you use unique ids for all services and shipments.");
+            if (!(job instanceof Service || job instanceof Shipment))
+                throw new IllegalArgumentException("Job must be either a service or a shipment.");
+            job.setIndex(jobIndexCounter);
+            incJobIndexCounter();
+            tentativeJobs.put(job.getId(), job);
+            addLocationToTentativeLocations(job);
+            return this;
+        }
+
+        private void incJobIndexCounter() {
+            jobIndexCounter++;
+        }
 
         /**
          * Adds a collection of vehicles.
@@ -485,6 +628,18 @@ public Builder addAllVehicles(Collection<? extends Vehicle> vehicles) {
             return this;
         }
 
+        /**
+         * Adds a vehicle.
+         *
+         * @param vehicle vehicle to be added
+         * @return this builder
+         */
+        public Builder addVehicle(Vehicle vehicle) {
+            if (!(vehicle instanceof AbstractVehicle))
+                throw new IllegalArgumentException("A vehicle must be an AbstractVehicle.");
+            return addVehicle((AbstractVehicle) vehicle);
+        }
+
         /**
          * Gets an unmodifiable collection of already added vehicles.
          *
@@ -525,202 +680,4 @@ private Builder addService(Service service) {
 
     }
 
-    /**
-     * Enum that characterizes the fleet-size.
-     *
-     * @author sschroeder
-     */
-    public static enum FleetSize {
-        FINITE, INFINITE
-    }
-
-    /**
-     * logger logging for this class
-     */
-    private final static Logger logger = LoggerFactory.getLogger(VehicleRoutingProblem.class);
-
-    /**
-     * contains transportation costs, i.e. the costs traveling from location A to B
-     */
-    private final VehicleRoutingTransportCosts transportCosts;
-
-    /**
-     * contains activity costs, i.e. the costs imposed by an activity
-     */
-    private final VehicleRoutingActivityCosts activityCosts;
-
-    /**
-     * map of jobs, stored by jobId
-     */
-    private final Map<String, Job> jobs;
-
-    private final Map<String, Job> allJobs;
-    /**
-     * Collection that contains available vehicles.
-     */
-    private final Collection<Vehicle> vehicles;
-
-    /**
-     * Collection that contains all available types.
-     */
-    private final Collection<VehicleType> vehicleTypes;
-
-
-    private final Collection<VehicleRoute> initialVehicleRoutes;
-
-    private final Collection<Location> allLocations;
-
-    /**
-     * An enum that indicates type of fleetSize. By default, it is INFINTE
-     */
-    private final FleetSize fleetSize;
-
-    private Map<Job, List<AbstractActivity>> activityMap;
-
-    private int nuActivities;
-
-    private final JobActivityFactory jobActivityFactory = new JobActivityFactory() {
-
-        @Override
-        public List<AbstractActivity> createActivities(Job job) {
-            return copyAndGetActivities(job);
-        }
-
-    };
-
-    private VehicleRoutingProblem(Builder builder) {
-        this.jobs = builder.jobs;
-        this.fleetSize = builder.fleetSize;
-        this.vehicles = builder.uniqueVehicles;
-        this.vehicleTypes = builder.vehicleTypes.values();
-        this.initialVehicleRoutes = builder.initialRoutes;
-        this.transportCosts = builder.transportCosts;
-        this.activityCosts = builder.activityCosts;
-        this.activityMap = builder.activityMap;
-        this.nuActivities = builder.activityIndexCounter;
-        this.allLocations = builder.allLocations;
-        this.allJobs = builder.tentativeJobs;
-        logger.info("setup problem: {}", this);
-    }
-
-
-    @Override
-    public String toString() {
-        return "[fleetSize=" + fleetSize + "][#jobs=" + jobs.size() + "][#vehicles=" + vehicles.size() + "][#vehicleTypes=" + vehicleTypes.size() + "][" +
-            "transportCost=" + transportCosts + "][activityCosts=" + activityCosts + "]";
-    }
-
-    /**
-     * Returns type of fleetSize, either INFINITE or FINITE.
-     * <p>
-     * <p>By default, it is INFINITE.
-     *
-     * @return either FleetSize.INFINITE or FleetSize.FINITE
-     */
-    public FleetSize getFleetSize() {
-        return fleetSize;
-    }
-
-    /**
-     * Returns the unmodifiable job map.
-     *
-     * @return unmodifiable jobMap
-     */
-    public Map<String, Job> getJobs() {
-        return Collections.unmodifiableMap(jobs);
-    }
-
-    public Map<String, Job> getJobsInclusiveInitialJobsInRoutes(){
-        return Collections.unmodifiableMap(allJobs);
-    }
-    /**
-     * Returns a copy of initial vehicle routes.
-     *
-     * @return copied collection of initial vehicle routes
-     */
-    public Collection<VehicleRoute> getInitialVehicleRoutes() {
-        Collection<VehicleRoute> copiedInitialRoutes = new ArrayList<VehicleRoute>();
-        for (VehicleRoute route : initialVehicleRoutes) {
-            copiedInitialRoutes.add(VehicleRoute.copyOf(route));
-        }
-        return copiedInitialRoutes;
-    }
-
-    /**
-     * Returns the entire, unmodifiable collection of types.
-     *
-     * @return unmodifiable collection of types
-     * @see com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl
-     */
-    public Collection<VehicleType> getTypes() {
-        return Collections.unmodifiableCollection(vehicleTypes);
-    }
-
-
-    /**
-     * Returns the entire, unmodifiable collection of vehicles.
-     *
-     * @return unmodifiable collection of vehicles
-     * @see Vehicle
-     */
-    public Collection<Vehicle> getVehicles() {
-        return Collections.unmodifiableCollection(vehicles);
-    }
-
-    /**
-     * Returns routing costs.
-     *
-     * @return routingCosts
-     * @see VehicleRoutingTransportCosts
-     */
-    public VehicleRoutingTransportCosts getTransportCosts() {
-        return transportCosts;
-    }
-
-    /**
-     * Returns activityCosts.
-     */
-    public VehicleRoutingActivityCosts getActivityCosts() {
-        return activityCosts;
-    }
-
-    public Collection<Location> getAllLocations(){
-        return allLocations;
-    }
-    /**
-     * @param job for which the corresponding activities needs to be returned
-     * @return associated activities
-     */
-    public List<AbstractActivity> getActivities(Job job) {
-        return Collections.unmodifiableList(activityMap.get(job));
-    }
-
-//    public Map<Job,List<AbstractActivity>> getActivityMap() { return Collections.unmodifiableMap(activityMap); }
-
-    /**
-     * @return total number of activities
-     */
-    public int getNuActivities() {
-        return nuActivities;
-    }
-
-    /**
-     * @return factory that creates the activities associated to a job
-     */
-    public JobActivityFactory getJobActivityFactory() {
-        return jobActivityFactory;
-    }
-
-    /**
-     * @param job for which the corresponding activities needs to be returned
-     * @return a copy of the activities that are associated to the specified job
-     */
-    public List<AbstractActivity> copyAndGetActivities(Job job) {
-        List<AbstractActivity> acts = new ArrayList<AbstractActivity>();
-        if (activityMap.containsKey(job)) {
-            for (AbstractActivity act : activityMap.get(job)) acts.add((AbstractActivity) act.duplicate());
-        }
-        return acts;
-    }
-
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/AdditionalTransportationCosts.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/AdditionalTransportationCosts.java
index ac8fef6da..f97815e56 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/AdditionalTransportationCosts.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/AdditionalTransportationCosts.java
@@ -61,7 +61,7 @@ public double getCosts(JobInsertionContext iFacts, TourActivity prevAct, TourAct
         double tp_time_prevAct_newAct = routingCosts.getTransportTime(prevAct.getLocation(), newAct.getLocation(), depTimeAtPrevAct, iFacts.getNewDriver(), iFacts.getNewVehicle());
 
         double newAct_arrTime = depTimeAtPrevAct + tp_time_prevAct_newAct;
-        double newAct_endTime = Math.max(newAct_arrTime, newAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(newAct,newAct_arrTime,iFacts.getNewDriver(),iFacts.getNewVehicle());
+        double newAct_endTime = Math.max(newAct_arrTime, newAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(newAct, newAct_arrTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
 
         //open routes
         if (nextAct instanceof End) {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ConstraintManager.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ConstraintManager.java
index 1275f8251..7bd279578 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ConstraintManager.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ConstraintManager.java
@@ -38,12 +38,8 @@
 public class ConstraintManager implements HardActivityConstraint, HardRouteConstraint, SoftActivityConstraint, SoftRouteConstraint {
 
 
-    public static enum Priority {
-        CRITICAL, HIGH, LOW
-    }
-
     private static Logger log = LoggerFactory.getLogger(ConstraintManager.class);
-
+    private final DependencyType[] dependencyTypes;
     private HardActivityLevelConstraintManager actLevelConstraintManager = new HardActivityLevelConstraintManager();
 
     private HardRouteLevelConstraintManager hardRouteConstraintManager = new HardRouteLevelConstraintManager();
@@ -62,8 +58,6 @@
 
     private boolean skillconstraintSet = false;
 
-    private final DependencyType[] dependencyTypes;
-
     public ConstraintManager(VehicleRoutingProblem vrp, RouteAndActivityStateGetter stateManager) {
         this.vrp = vrp;
         this.stateManager = stateManager;
@@ -77,6 +71,32 @@ public ConstraintManager(VehicleRoutingProblem vrp, RouteAndActivityStateGetter
         resolveConstraints(constraints);
     }
 
+    private void resolveConstraints(Collection<Constraint> constraints) {
+        for (Constraint c : constraints) {
+            boolean constraintTypeKnown = false;
+            if (c instanceof HardActivityConstraint) {
+                actLevelConstraintManager.addConstraint((HardActivityConstraint) c, Priority.HIGH);
+                constraintTypeKnown = true;
+            }
+            if (c instanceof HardRouteConstraint) {
+                hardRouteConstraintManager.addConstraint((HardRouteConstraint) c);
+                constraintTypeKnown = true;
+            }
+            if (c instanceof SoftRouteConstraint) {
+                softRouteConstraintManager.addConstraint((SoftRouteConstraint) c);
+                constraintTypeKnown = true;
+            }
+            if (c instanceof SoftActivityConstraint) {
+                softActivityConstraintManager.addConstraint((SoftActivityConstraint) c);
+                constraintTypeKnown = true;
+            }
+            if (!constraintTypeKnown) {
+                log.warn("constraint " + c + " unknown thus ignores the constraint. currently, a constraint must implement either HardActivityStateLevelConstraint or HardRouteStateLevelConstraint");
+            }
+        }
+
+    }
+
     public Collection<HardRouteConstraint> getHardRouteConstraints() {
         return hardRouteConstraintManager.getConstraints();
     }
@@ -100,47 +120,21 @@ public ConstraintManager(VehicleRoutingProblem vrp, RouteAndActivityStateGetter
         return dependencyTypes;
     }
 
-    public void setDependencyType(String jobId, DependencyType dependencyType){
+    public void setDependencyType(String jobId, DependencyType dependencyType) {
         Job job = vrp.getJobs().get(jobId);
-        if(job != null) {
+        if (job != null) {
             dependencyTypes[job.getIndex()] = dependencyType;
         }
     }
 
-    public DependencyType getDependencyType(String jobId){
+    public DependencyType getDependencyType(String jobId) {
         Job job = vrp.getJobs().get(jobId);
-        if(job != null){
+        if (job != null) {
             return dependencyTypes[job.getIndex()];
         }
         return DependencyType.NO_TYPE;
     }
 
-    private void resolveConstraints(Collection<Constraint> constraints) {
-        for (Constraint c : constraints) {
-            boolean constraintTypeKnown = false;
-            if (c instanceof HardActivityConstraint) {
-                actLevelConstraintManager.addConstraint((HardActivityConstraint) c, Priority.HIGH);
-                constraintTypeKnown = true;
-            }
-            if (c instanceof HardRouteConstraint) {
-                hardRouteConstraintManager.addConstraint((HardRouteConstraint) c);
-                constraintTypeKnown = true;
-            }
-            if (c instanceof SoftRouteConstraint) {
-                softRouteConstraintManager.addConstraint((SoftRouteConstraint) c);
-                constraintTypeKnown = true;
-            }
-            if (c instanceof SoftActivityConstraint) {
-                softActivityConstraintManager.addConstraint((SoftActivityConstraint) c);
-                constraintTypeKnown = true;
-            }
-            if (!constraintTypeKnown) {
-                log.warn("constraint " + c + " unknown thus ignores the constraint. currently, a constraint must implement either HardActivityStateLevelConstraint or HardRouteStateLevelConstraint");
-            }
-        }
-
-    }
-
     public void addTimeWindowConstraint() {
         if (!timeWindowConstraintsSet) {
             addConstraint(new VehicleDependentTimeWindowConstraints(stateManager, vrp.getTransportCosts(), vrp.getActivityCosts()), Priority.HIGH);
@@ -148,6 +142,9 @@ public void addTimeWindowConstraint() {
         }
     }
 
+    public void addConstraint(HardActivityConstraint actLevelConstraint, Priority priority) {
+        actLevelConstraintManager.addConstraint(actLevelConstraint, priority);
+    }
 
     public void addLoadConstraint() {
         if (!loadConstraintsSet) {
@@ -158,6 +155,12 @@ public void addLoadConstraint() {
         }
     }
 
+    public void addConstraint(HardRouteConstraint routeLevelConstraint) {
+        hardRouteConstraintManager.addConstraint(routeLevelConstraint);
+    }
+
+//	public void add
+
     public void addSkillsConstraint() {
         if (!skillconstraintSet) {
             addConstraint(new HardSkillConstraint(stateManager));
@@ -165,16 +168,6 @@ public void addSkillsConstraint() {
         }
     }
 
-//	public void add
-
-    public void addConstraint(HardActivityConstraint actLevelConstraint, Priority priority) {
-        actLevelConstraintManager.addConstraint(actLevelConstraint, priority);
-    }
-
-    public void addConstraint(HardRouteConstraint routeLevelConstraint) {
-        hardRouteConstraintManager.addConstraint(routeLevelConstraint);
-    }
-
     public void addConstraint(SoftActivityConstraint softActivityConstraint) {
         softActivityConstraintManager.addConstraint(softActivityConstraint);
     }
@@ -212,5 +205,9 @@ public double getCosts(JobInsertionContext iFacts, TourActivity prevAct, TourAct
         return softActivityConstraintManager.getCosts(iFacts, prevAct, newAct, nextAct, prevActDepTime);
     }
 
+    public static enum Priority {
+        CRITICAL, HIGH, LOW
+    }
+
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/HardActivityConstraint.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/HardActivityConstraint.java
index dde2a8002..af883ed33 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/HardActivityConstraint.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/HardActivityConstraint.java
@@ -25,15 +25,6 @@
  */
 public interface HardActivityConstraint extends HardConstraint {
 
-    /**
-     * Indicates whether a hard activity constraint is fulfilled or not
-     */
-    static enum ConstraintsStatus {
-
-        NOT_FULFILLED_BREAK, NOT_FULFILLED, FULFILLED
-
-    }
-
     /**
      * Returns whether newAct can be inserted in between prevAct and nextAct.
      * <p>
@@ -80,4 +71,13 @@
      */
     public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime);
 
+    /**
+     * Indicates whether a hard activity constraint is fulfilled or not
+     */
+    static enum ConstraintsStatus {
+
+        NOT_FULFILLED_BREAK, NOT_FULFILLED, FULFILLED
+
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraint.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraint.java
index 35945791e..746a7df18 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraint.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraint.java
@@ -70,32 +70,30 @@ public ConstraintsStatus fulfilled(final JobInsertionContext iFacts, TourActivit
         2. check whether insertion of new shipment satisfies all other max-in-vehicle-constraints
          */
         //************ 1. check whether insertion of new shipment satisfies own max-in-vehicle-constraint
-        double newActArrival = prevActDepTime + transportTime.getTransportTime(prevAct.getLocation(),newAct.getLocation(),prevActDepTime,iFacts.getNewDriver(),iFacts.getNewVehicle());
+        double newActArrival = prevActDepTime + transportTime.getTransportTime(prevAct.getLocation(), newAct.getLocation(), prevActDepTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
         double newActStart = Math.max(newActArrival, newAct.getTheoreticalEarliestOperationStartTime());
         double newActDeparture = newActStart + activityCosts.getActivityDuration(newAct, newActArrival, iFacts.getNewDriver(), iFacts.getNewVehicle());
-        double nextActArrival = newActDeparture + transportTime.getTransportTime(newAct.getLocation(),nextAct.getLocation(),newActDeparture,iFacts.getNewDriver(),iFacts.getNewVehicle());
-        double nextActStart = Math.max(nextActArrival,nextAct.getTheoreticalEarliestOperationStartTime());
-        if(newAct instanceof DeliveryActivity){
+        double nextActArrival = newActDeparture + transportTime.getTransportTime(newAct.getLocation(), nextAct.getLocation(), newActDeparture, iFacts.getNewDriver(), iFacts.getNewVehicle());
+        double nextActStart = Math.max(nextActArrival, nextAct.getTheoreticalEarliestOperationStartTime());
+        if (newAct instanceof DeliveryActivity) {
             double pickupEnd;
-            if(iFacts.getAssociatedActivities().size() == 1){
+            if (iFacts.getAssociatedActivities().size() == 1) {
                 pickupEnd = iFacts.getNewDepTime();
-            }
-            else {
+            } else {
                 pickupEnd = iFacts.getRelatedActivityContext().getEndTime();
             }
             double timeInVehicle = newActStart - pickupEnd;
-            double maxTimeInVehicle = ((TourActivity.JobActivity)newAct).getJob().getMaxTimeInVehicle();
-            if(timeInVehicle > maxTimeInVehicle) return ConstraintsStatus.NOT_FULFILLED;
+            double maxTimeInVehicle = ((TourActivity.JobActivity) newAct).getJob().getMaxTimeInVehicle();
+            if (timeInVehicle > maxTimeInVehicle) return ConstraintsStatus.NOT_FULFILLED;
 
-        }
-        else if(newActIsPickup){
-            if(iFacts.getAssociatedActivities().size() == 1){
-                double maxTimeInVehicle = ((TourActivity.JobActivity)newAct).getJob().getMaxTimeInVehicle();
+        } else if (newActIsPickup) {
+            if (iFacts.getAssociatedActivities().size() == 1) {
+                double maxTimeInVehicle = ((TourActivity.JobActivity) newAct).getJob().getMaxTimeInVehicle();
                 //ToDo - estimate in vehicle time of pickups here - This seems to trickier than I thought
                 double nextActDeparture = nextActStart + activityCosts.getActivityDuration(nextAct, nextActArrival, iFacts.getNewDriver(), iFacts.getNewVehicle());
 //                if(!nextAct instanceof End)
                 double timeToEnd = 0; //newAct.end + tt(newAct,nextAct) + t@nextAct + t_to_end
-                if(timeToEnd > maxTimeInVehicle) return ConstraintsStatus.NOT_FULFILLED;
+                if (timeToEnd > maxTimeInVehicle) return ConstraintsStatus.NOT_FULFILLED;
             }
         }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTimeWindowConstraints.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTimeWindowConstraints.java
index 36fc4ce66..eb68d3939 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTimeWindowConstraints.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTimeWindowConstraints.java
@@ -65,13 +65,13 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
             nextActLocation = nextAct.getLocation();
         }
 
-			/*
-             * if latest arrival of vehicle (at its end) is smaller than earliest operation start times of activities,
-			 * then vehicle can never conduct activities.
-			 *
-			 *     |--- vehicle's operation time ---|
-			 *                        					|--- prevAct or newAct or nextAct ---|
-			 */
+        /*
+         * if latest arrival of vehicle (at its end) is smaller than earliest operation start times of activities,
+         * then vehicle can never conduct activities.
+         *
+         *     |--- vehicle's operation time ---|
+         *                        					|--- prevAct or newAct or nextAct ---|
+         */
         double newAct_theoreticalEarliestOperationStartTime = newAct.getTheoreticalEarliestOperationStartTime();
 
         if (latestVehicleArrival < prevAct.getTheoreticalEarliestOperationStartTime() ||
@@ -79,37 +79,37 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
             latestVehicleArrival < nextAct.getTheoreticalEarliestOperationStartTime()) {
             return ConstraintsStatus.NOT_FULFILLED_BREAK;
         }
-            /*
-             * if the latest operation start-time of new activity is smaller than the earliest start of prev. activity,
-			 * then
-			 *
-			 *                    |--- prevAct ---|
-			 *  |--- newAct ---|
-			 */
+        /*
+         * if the latest operation start-time of new activity is smaller than the earliest start of prev. activity,
+         * then
+         *
+         *                    |--- prevAct ---|
+         *  |--- newAct ---|
+         */
         if (newAct.getTheoreticalLatestOperationStartTime() < prevAct.getTheoreticalEarliestOperationStartTime()) {
             return ConstraintsStatus.NOT_FULFILLED_BREAK;
         }
 
-			/*
-             *  |--- prevAct ---|
-			 *                                          |- earliest arrival of vehicle
-			 *                       |--- nextAct ---|
-			 */
+        /*
+         *  |--- prevAct ---|
+         *                                          |- earliest arrival of vehicle
+         *                       |--- nextAct ---|
+         */
         double arrTimeAtNextOnDirectRouteWithNewVehicle = prevActDepTime + routingCosts.getTransportTime(prevAct.getLocation(), nextActLocation, prevActDepTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
         if (arrTimeAtNextOnDirectRouteWithNewVehicle > latestArrTimeAtNextAct) {
             return ConstraintsStatus.NOT_FULFILLED_BREAK;
         }
 
-			/*
-             *                     |--- newAct ---|
-			 *  |--- nextAct ---|
-			 */
+        /*
+         *                     |--- newAct ---|
+         *  |--- nextAct ---|
+         */
         if (newAct.getTheoreticalEarliestOperationStartTime() > nextAct.getTheoreticalLatestOperationStartTime()) {
             return ConstraintsStatus.NOT_FULFILLED;
         }
         //			log.info("check insertion of " + newAct + " between " + prevAct + " and " + nextAct + ". prevActDepTime=" + prevActDepTime);
         double arrTimeAtNewAct = prevActDepTime + routingCosts.getTransportTime(prevAct.getLocation(), newAct.getLocation(), prevActDepTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
-        double endTimeAtNewAct = Math.max(arrTimeAtNewAct, newAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(newAct, arrTimeAtNewAct,iFacts.getNewDriver(),iFacts.getNewVehicle());
+        double endTimeAtNewAct = Math.max(arrTimeAtNewAct, newAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(newAct, arrTimeAtNewAct, iFacts.getNewDriver(), iFacts.getNewVehicle());
         double latestArrTimeAtNewAct =
             Math.min(newAct.getTheoreticalLatestOperationStartTime(),
                 latestArrTimeAtNextAct -
@@ -117,11 +117,11 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
                     - activityCosts.getActivityDuration(newAct, arrTimeAtNewAct, iFacts.getNewDriver(), iFacts.getNewVehicle())
             );
 
-			/*
-             *  |--- prevAct ---|
-			 *                       		                 |--- vehicle's arrival @newAct
-			 *        latest arrival of vehicle @newAct ---|
-			 */
+        /*
+         *  |--- prevAct ---|
+         *                       		                 |--- vehicle's arrival @newAct
+         *        latest arrival of vehicle @newAct ---|
+         */
         if (arrTimeAtNewAct > latestArrTimeAtNewAct) {
             return ConstraintsStatus.NOT_FULFILLED;
         }
@@ -135,11 +135,11 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
 
         double arrTimeAtNextAct = endTimeAtNewAct + routingCosts.getTransportTime(newAct.getLocation(), nextActLocation, endTimeAtNewAct, iFacts.getNewDriver(), iFacts.getNewVehicle());
 
-			/*
-             *  |--- newAct ---|
-			 *                       		                 |--- vehicle's arrival @nextAct
-			 *        latest arrival of vehicle @nextAct ---|
-			 */
+        /*
+         *  |--- newAct ---|
+         *                       		                 |--- vehicle's arrival @nextAct
+         *        latest arrival of vehicle @nextAct ---|
+         */
         if (arrTimeAtNextAct > latestArrTimeAtNextAct) {
             return ConstraintsStatus.NOT_FULFILLED;
         }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/cost/AbstractForwardVehicleRoutingTransportCosts.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/cost/AbstractForwardVehicleRoutingTransportCosts.java
index c35cb1195..3119578d4 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/cost/AbstractForwardVehicleRoutingTransportCosts.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/cost/AbstractForwardVehicleRoutingTransportCosts.java
@@ -22,24 +22,24 @@
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 
 public abstract class AbstractForwardVehicleRoutingTransportCosts implements VehicleRoutingTransportCosts {
-    
-    @Override
-    public abstract double getDistance(Location from, Location to, double departureTime, Vehicle vehicle);
 
     @Override
-    public abstract double getTransportTime(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle);
-
-    @Override
-    public abstract double getTransportCost(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle);
+    public abstract double getDistance(Location from, Location to, double departureTime, Vehicle vehicle);
 
     @Override
     public double getBackwardTransportTime(Location from, Location to, double arrivalTime, Driver driver, Vehicle vehicle) {
         return getTransportTime(from, to, arrivalTime, driver, vehicle);
     }
 
+    @Override
+    public abstract double getTransportTime(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle);
+
     @Override
     public double getBackwardTransportCost(Location from, Location to, double arrivalTime, Driver driver, Vehicle vehicle) {
         return getTransportCost(from, to, arrivalTime, driver, vehicle);
     }
 
+    @Override
+    public abstract double getTransportCost(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle);
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/cost/VehicleRoutingActivityCosts.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/cost/VehicleRoutingActivityCosts.java
index d91b15878..9246166f4 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/cost/VehicleRoutingActivityCosts.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/cost/VehicleRoutingActivityCosts.java
@@ -30,21 +30,6 @@
  */
 public interface VehicleRoutingActivityCosts {
 
-    public static class Time {
-
-        public static double TOUREND = -2.0;
-
-        public static double TOURSTART = -1.0;
-
-        public static double UNDEFINED = -3.0;
-    }
-
-    public static interface Parameter {
-
-        public double getPenaltyForMissedTimeWindow();
-
-    }
-
     /**
      * Calculates and returns the activity cost at tourAct.
      * <p>
@@ -61,4 +46,19 @@
 
     public double getActivityDuration(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle);
 
+    public static interface Parameter {
+
+        public double getPenaltyForMissedTimeWindow();
+
+    }
+
+    public static class Time {
+
+        public static double TOUREND = -2.0;
+
+        public static double TOURSTART = -1.0;
+
+        public static double UNDEFINED = -3.0;
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/cost/WaitingTimeCosts.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/cost/WaitingTimeCosts.java
index cd7540cc0..32d141073 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/cost/WaitingTimeCosts.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/cost/WaitingTimeCosts.java
@@ -31,7 +31,7 @@
     public double getActivityCost(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
         if (vehicle != null) {
             double waiting = vehicle.getType().getVehicleCostParams().perWaitingTimeUnit * Math.max(0., tourAct.getTheoreticalEarliestOperationStartTime() - arrivalTime);
-            double servicing = vehicle.getType().getVehicleCostParams().perServiceTimeUnit * getActivityDuration(tourAct,arrivalTime,driver,vehicle);
+            double servicing = vehicle.getType().getVehicleCostParams().perServiceTimeUnit * getActivityDuration(tourAct, arrivalTime, driver, vehicle);
             return waiting + servicing;
         }
         return 0;
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/driver/DriverImpl.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/driver/DriverImpl.java
index 23d407e84..a1ea8ede2 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/driver/DriverImpl.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/driver/DriverImpl.java
@@ -19,24 +19,9 @@
 
 public class DriverImpl implements Driver {
 
-    public static NoDriver noDriver() {
-        return new NoDriver();
-    }
-
-    public static class NoDriver extends DriverImpl {
-
-        public NoDriver() {
-            super("noDriver");
-        }
-
-    }
-
     private String id;
-
     private double earliestStart = 0.0;
-
     private double latestEnd = Double.MAX_VALUE;
-
     private String home;
 
     private DriverImpl(String id) {
@@ -44,6 +29,10 @@ private DriverImpl(String id) {
         this.id = id;
     }
 
+    public static NoDriver noDriver() {
+        return new NoDriver();
+    }
+
     public String getId() {
         return id;
     }
@@ -64,12 +53,20 @@ public void setLatestEnd(double latestEnd) {
         this.latestEnd = latestEnd;
     }
 
+    public String getHomeLocation() {
+        return this.home;
+    }
+
     public void setHomeLocation(String locationId) {
         this.home = locationId;
     }
 
-    public String getHomeLocation() {
-        return this.home;
+    public static class NoDriver extends DriverImpl {
+
+        public NoDriver() {
+            super("noDriver");
+        }
+
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Break.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Break.java
index 0a73b3986..09741b356 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Break.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Break.java
@@ -28,8 +28,25 @@
  */
 public class Break extends Service {
 
+    private boolean variableLocation = true;
+
+    Break(Builder builder) {
+        super(builder);
+        this.variableLocation = builder.variableLocation;
+    }
+
+    public boolean hasVariableLocation() {
+        return variableLocation;
+    }
+
     public static class Builder extends Service.Builder<Break> {
 
+        private boolean variableLocation = true;
+
+        Builder(String id) {
+            super(id);
+        }
+
         /**
          * Returns a new instance of builder that builds a pickup.
          *
@@ -40,12 +57,6 @@ public static Builder newInstance(String id) {
             return new Builder(id);
         }
 
-        private boolean variableLocation = true;
-
-        Builder(String id) {
-            super(id);
-        }
-
         /**
          * Builds Pickup.
          * <p>
@@ -66,15 +77,4 @@ public Break build() {
 
     }
 
-    private boolean variableLocation = true;
-
-    Break(Builder builder) {
-        super(builder);
-        this.variableLocation = builder.variableLocation;
-    }
-
-    public boolean hasVariableLocation() {
-        return variableLocation;
-    }
-
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Delivery.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Delivery.java
index f31b25ef2..d061d85d3 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Delivery.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Delivery.java
@@ -25,8 +25,17 @@
  */
 public class Delivery extends Service {
 
+    Delivery(Builder builder) {
+        super(builder);
+
+    }
+
     public static class Builder extends Service.Builder<Delivery> {
 
+        Builder(String id) {
+            super(id);
+        }
+
         /**
          * Returns a new instance of builder that builds a delivery.
          *
@@ -37,17 +46,6 @@ public static Builder newInstance(String id) {
             return new Builder(id);
         }
 
-        Builder(String id) {
-            super(id);
-        }
-
-
-        public Builder setMaxTimeInVehicle(double maxTimeInVehicle){
-            if(maxTimeInVehicle < 0) throw new IllegalArgumentException("maxTimeInVehicle should be positive");
-            this.maxTimeInVehicle = maxTimeInVehicle;
-            return this;
-        }
-
         /**
          * Builds Delivery.
          *
@@ -62,10 +60,11 @@ public Delivery build() {
             return new Delivery(this);
         }
 
-    }
-
-    Delivery(Builder builder) {
-        super(builder);
+        public Builder setMaxTimeInVehicle(double maxTimeInVehicle) {
+            if (maxTimeInVehicle < 0) throw new IllegalArgumentException("maxTimeInVehicle should be positive");
+            this.maxTimeInVehicle = maxTimeInVehicle;
+            return this;
+        }
 
     }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Pickup.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Pickup.java
index 2a893d5f0..44922e578 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Pickup.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Pickup.java
@@ -25,8 +25,16 @@
  */
 public class Pickup extends Service {
 
+    Pickup(Builder builder) {
+        super(builder);
+    }
+
     public static class Builder extends Service.Builder<Pickup> {
 
+        Builder(String id) {
+            super(id);
+        }
+
         /**
          * Returns a new instance of builder that builds a pickup.
          *
@@ -37,17 +45,6 @@ public static Builder newInstance(String id) {
             return new Builder(id);
         }
 
-        Builder(String id) {
-            super(id);
-        }
-
-        public Builder setMaxTimeInVehicle(double maxTimeInVehicle){
-            throw new UnsupportedOperationException("maxTimeInVehicle is not yet supported for Pickups and Services (only for Deliveries and Shipments)");
-//            if(maxTimeInVehicle < 0) throw new IllegalArgumentException("maxTimeInVehicle should be positive");
-//            this.maxTimeInVehicle = maxTimeInVehicle;
-//            return this;
-        }
-
         /**
          * Builds Pickup.
          * <p>
@@ -64,10 +61,13 @@ public Pickup build() {
             return new Pickup(this);
         }
 
-    }
+        public Builder setMaxTimeInVehicle(double maxTimeInVehicle) {
+            throw new UnsupportedOperationException("maxTimeInVehicle is not yet supported for Pickups and Services (only for Deliveries and Shipments)");
+//            if(maxTimeInVehicle < 0) throw new IllegalArgumentException("maxTimeInVehicle should be positive");
+//            this.maxTimeInVehicle = maxTimeInVehicle;
+//            return this;
+        }
 
-    Pickup(Builder builder) {
-        super(builder);
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
index 99608c233..58d75ed3e 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
@@ -41,75 +41,186 @@
 public class Service extends AbstractJob {
 
 
+    private final String id;
+    private final String type;
+    private final double serviceTime;
+    private final Capacity size;
+    private final Skills skills;
+    private final String name;
+    private final Location location;
+    private final TimeWindows timeWindows;
+    private final int priority;
+    private final double maxTimeInVehicle;
+
+    Service(Builder<?> builder) {
+        setUserData(builder.userData);
+        id = builder.id;
+        serviceTime = builder.serviceTime;
+        type = builder.type;
+        size = builder.capacity;
+        skills = builder.skills;
+        name = builder.name;
+        location = builder.location;
+        timeWindows = builder.timeWindows;
+        priority = builder.priority;
+        maxTimeInVehicle = builder.maxTimeInVehicle;
+    }
+
+    public Collection<TimeWindow> getTimeWindows() {
+        return timeWindows.getTimeWindows();
+    }
+
+    @Override
+    public String getId() {
+        return id;
+    }
+
+    @Override
+    public Capacity getSize() {
+        return size;
+    }
+
+    @Override
+    public Skills getRequiredSkills() {
+        return skills;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
 
     /**
-     * Builder that builds a service.
+     * Get priority of service. Only 1 = high priority, 2 = medium and 3 = low are allowed.
+     * <p>
+     * Default is 2 = medium.
      *
-     * @author schroeder
+     * @return priority
      */
-    public static class Builder<T extends Service> {
+    @Override
+    public int getPriority() {
+        return priority;
+    }
 
+    @Override
+    public double getMaxTimeInVehicle() {
+        return this.maxTimeInVehicle;
+    }
 
+    /**
+     * Returns location.
+     *
+     * @return location
+     */
+    public Location getLocation() {
+        return location;
+    }
 
+    /**
+     * Returns the service-time/duration a service takes at service-location.
+     *
+     * @return service duration
+     */
+    public double getServiceDuration() {
+        return serviceTime;
+    }
 
-        /**
-         * Returns a new instance of builder that builds a service.
-         *
-         * @param id the id of the service
-         * @return the builder
-         */
-        public static Builder newInstance(String id) {
-            return new Builder(id);
-        }
+    /**
+     * Returns the time-window a service(-operation) is allowed to start.
+     * It is recommended to use getTimeWindows() instead. If you still use this, it returns the first time window of getTimeWindows() collection.
+     *
+     * @return time window
+     */
+    public TimeWindow getTimeWindow() {
+        return timeWindows.getTimeWindows().iterator().next();
+    }
 
-        private String id;
+    /**
+     * @return the name
+     */
+    public String getType() {
+        return type;
+    }
 
-        protected String locationId;
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((id == null) ? 0 : id.hashCode());
+        return result;
+    }
 
-        private String type = "service";
+    /**
+     * Two services are equal if they have the same id.
+     */
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        Service other = (Service) obj;
+        if (id == null) {
+            if (other.id != null)
+                return false;
+        } else if (!id.equals(other.id))
+            return false;
+        return true;
+    }
 
-        protected Coordinate coord;
+    /**
+     * Returns a string with the service's attributes.
+     * <p>
+     * <p>String is built as follows: [attr1=val1][attr2=val2]...
+     */
+    @Override
+    public String toString() {
+        return "[id=" + id + "][name=" + name + "][type=" + type + "][location=" + location
+            + "][capacity=" + size + "][serviceTime=" + serviceTime + "][timeWindows="
+            + timeWindows + "]";
+    }
 
-        protected double serviceTime;
+    /**
+     * Builder that builds a service.
+     *
+     * @author schroeder
+     */
+    public static class Builder<T extends Service> {
 
-        protected Capacity.Builder capacityBuilder = Capacity.Builder.newInstance();
 
+        protected String locationId;
+        protected Coordinate coord;
+        protected double serviceTime;
+        protected Capacity.Builder capacityBuilder = Capacity.Builder.newInstance();
         protected Capacity capacity;
-
         protected Skills.Builder skillBuilder = Skills.Builder.newInstance();
-
         protected Skills skills;
-
-        private String name = "no-name";
-
         protected Location location;
-
         protected TimeWindowsImpl timeWindows;
-
+        protected Object userData;
+        protected double maxTimeInVehicle = Double.MAX_VALUE;
+        private String id;
+        private String type = "service";
+        private String name = "no-name";
         private boolean twAdded = false;
-
         private int priority = 2;
-        protected Object userData;
 
-		protected double maxTimeInVehicle = Double.MAX_VALUE;
-
-		Builder(String id){
-			this.id = id;
-			timeWindows = new TimeWindowsImpl();
-			timeWindows.add(TimeWindow.newInstance(0.0, Double.MAX_VALUE));
-		}
+        Builder(String id) {
+            this.id = id;
+            timeWindows = new TimeWindowsImpl();
+            timeWindows.add(TimeWindow.newInstance(0.0, Double.MAX_VALUE));
+        }
 
         /**
-         * Protected method to set the type-name of the service.
-         * <p>
-         * <p>Currently there are {@link Service}, {@link Pickup} and {@link Delivery}.
+         * Returns a new instance of builder that builds a service.
          *
-         * @param name the name of service
+         * @param id the id of the service
          * @return the builder
          */
-        protected Builder<T> setType(String name) {
-            this.type = name;
-            return this;
+        public static Builder newInstance(String id) {
+            return new Builder(id);
         }
 
         /**
@@ -142,15 +253,14 @@ public static Builder newInstance(String id) {
 
         /**
          * Sets user specific domain data associated with the object.
-         *
+         * <p>
          * <p>
          * The user data is a black box for the framework, it only stores it,
          * but never interacts with it in any way.
          * </p>
          *
-         * @param userData
-         *            any object holding the domain specific user data
-         *            associated with the object.
+         * @param userData any object holding the domain specific user data
+         *                 associated with the object.
          * @return builder
          */
         public Builder<T> setUserData(Object userData) {
@@ -158,30 +268,20 @@ public static Builder newInstance(String id) {
             return this;
         }
 
-        /**
-         * Adds capacity dimension.
-         *
-         * @param dimensionIndex the dimension index of the capacity value
-         * @param dimensionValue the capacity value
-         * @return the builder
-         * @throws IllegalArgumentException if dimensionValue < 0
-         */
-        public Builder<T> addSizeDimension(int dimensionIndex, int dimensionValue) {
-            if (dimensionValue < 0) throw new IllegalArgumentException("The capacity value must not be negative.");
-            capacityBuilder.addDimension(dimensionIndex, dimensionValue);
-            return this;
-        }
-
-        public Builder<T> setTimeWindow(TimeWindow tw){
+        public Builder<T> setTimeWindow(TimeWindow tw) {
             if (tw == null) throw new IllegalArgumentException("The time window must not be null.");
             this.timeWindows = new TimeWindowsImpl();
             timeWindows.add(tw);
             return this;
         }
 
+        public Builder<T> addTimeWindow(double earliest, double latest) {
+            return addTimeWindow(TimeWindow.newInstance(earliest, latest));
+        }
+
         public Builder<T> addTimeWindow(TimeWindow timeWindow) {
             if (timeWindow == null) throw new IllegalArgumentException("The time window must not be null.");
-            if(!twAdded){
+            if (!twAdded) {
                 timeWindows = new TimeWindowsImpl();
                 twAdded = true;
             }
@@ -189,10 +289,6 @@ public static Builder newInstance(String id) {
             return this;
         }
 
-        public Builder<T> addTimeWindow(double earliest, double latest) {
-            return addTimeWindow(TimeWindow.newInstance(earliest, latest));
-        }
-
         public Builder<T> addAllTimeWindows(Collection<TimeWindow> timeWindows) {
             for (TimeWindow tw : timeWindows) addTimeWindow(tw);
             return this;
@@ -212,6 +308,19 @@ public T build() {
             return (T) new Service(this);
         }
 
+        /**
+         * Protected method to set the type-name of the service.
+         * <p>
+         * <p>Currently there are {@link Service}, {@link Pickup} and {@link Delivery}.
+         *
+         * @param name the name of service
+         * @return the builder
+         */
+        protected Builder<T> setType(String name) {
+            this.type = name;
+            return this;
+        }
+
         public Builder<T> addRequiredSkill(String skill) {
             skillBuilder.addSkill(skill);
             return this;
@@ -227,18 +336,32 @@ public T build() {
             return this;
         }
 
-        public Builder<T> addAllRequiredSkills(Skills skills){
+        public Builder<T> addAllRequiredSkills(Skills skills) {
             skillBuilder.addAllSkills(skills.values());
             return this;
         }
 
-        public Builder<T> addAllSizeDimensions(Capacity size){
-            for(int i=0;i<size.getNuOfDimensions();i++){
+        public Builder<T> addAllSizeDimensions(Capacity size) {
+            for (int i = 0; i < size.getNuOfDimensions(); i++) {
                 addSizeDimension(i, size.get(i));
             }
             return this;
         }
 
+        /**
+         * Adds capacity dimension.
+         *
+         * @param dimensionIndex the dimension index of the capacity value
+         * @param dimensionValue the capacity value
+         * @return the builder
+         * @throws IllegalArgumentException if dimensionValue < 0
+         */
+        public Builder<T> addSizeDimension(int dimensionIndex, int dimensionValue) {
+            if (dimensionValue < 0) throw new IllegalArgumentException("The capacity value must not be negative.");
+            capacityBuilder.addDimension(dimensionIndex, dimensionValue);
+            return this;
+        }
+
         /**
          * Set priority to service. Only 1 (very high) to 10 (very low) are allowed.
          * <p>
@@ -254,7 +377,7 @@ public T build() {
             return this;
         }
 
-        public Builder<T> setMaxTimeInVehicle(double maxTimeInVehicle){
+        public Builder<T> setMaxTimeInVehicle(double maxTimeInVehicle) {
             throw new UnsupportedOperationException("The maximum time in vehicle is not yet supported for Pickups and Services (only for Deliveries and Shipments).");
 //            if(maxTimeInVehicle < 0) throw new IllegalArgumentException("maxTimeInVehicle should be positive");
 //            this.maxTimeInVehicle = maxTimeInVehicle;
@@ -262,156 +385,4 @@ public T build() {
         }
     }
 
-    private final String id;
-
-    private final String type;
-
-    private final double serviceTime;
-
-    private final Capacity size;
-
-    private final Skills skills;
-
-    private final String name;
-
-    private final Location location;
-
-    private final TimeWindows timeWindows;
-
-    private final int priority;
-
-    private final double maxTimeInVehicle;
-
-    Service(Builder<?> builder) {
-        setUserData(builder.userData);
-        id = builder.id;
-        serviceTime = builder.serviceTime;
-        type = builder.type;
-        size = builder.capacity;
-        skills = builder.skills;
-        name = builder.name;
-        location = builder.location;
-        timeWindows = builder.timeWindows;
-        priority = builder.priority;
-	    maxTimeInVehicle = builder.maxTimeInVehicle;
-	}
-
-    public Collection<TimeWindow> getTimeWindows(){
-        return timeWindows.getTimeWindows();
-    }
-
-    @Override
-    public String getId() {
-        return id;
-    }
-
-    /**
-     * Returns location.
-     *
-     * @return location
-     */
-    public Location getLocation() {
-        return location;
-    }
-
-
-    /**
-     * Returns the service-time/duration a service takes at service-location.
-     *
-     * @return service duration
-     */
-    public double getServiceDuration() {
-        return serviceTime;
-    }
-
-    /**
-     * Returns the time-window a service(-operation) is allowed to start.
-     * It is recommended to use getTimeWindows() instead. If you still use this, it returns the first time window of getTimeWindows() collection.
-     *
-     * @return time window
-     *
-     */
-    public TimeWindow getTimeWindow() {
-        return timeWindows.getTimeWindows().iterator().next();
-    }
-
-    /**
-     * @return the name
-     */
-    public String getType() {
-        return type;
-    }
-
-    /**
-     * Returns a string with the service's attributes.
-     * <p>
-     * <p>String is built as follows: [attr1=val1][attr2=val2]...
-     */
-    @Override
-    public String toString() {
-        return "[id=" + id + "][name=" + name + "][type=" + type + "][location=" + location
-                + "][capacity=" + size + "][serviceTime=" + serviceTime + "][timeWindows="
-                + timeWindows + "]";
-    }
-
-    @Override
-    public int hashCode() {
-        final int prime = 31;
-        int result = 1;
-        result = prime * result + ((id == null) ? 0 : id.hashCode());
-        return result;
-    }
-
-    /**
-     * Two services are equal if they have the same id.
-     */
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj)
-            return true;
-        if (obj == null)
-            return false;
-        if (getClass() != obj.getClass())
-            return false;
-        Service other = (Service) obj;
-        if (id == null) {
-            if (other.id != null)
-                return false;
-        } else if (!id.equals(other.id))
-            return false;
-        return true;
-    }
-
-    @Override
-    public Capacity getSize() {
-        return size;
-    }
-
-    @Override
-    public Skills getRequiredSkills() {
-        return skills;
-    }
-
-    @Override
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Get priority of service. Only 1 = high priority, 2 = medium and 3 = low are allowed.
-     * <p>
-     * Default is 2 = medium.
-     *
-     * @return priority
-     */
-    @Override
-    public int getPriority() {
-        return priority;
-    }
-
-    @Override
-    public double getMaxTimeInVehicle() {
-        return this.maxTimeInVehicle;
-    }
-
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
index 8d356a020..0f03f03b5 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
@@ -46,7 +46,169 @@
 public class Shipment extends AbstractJob {
 
 
+    private final String id;
+    private final double pickupServiceTime;
+    private final double deliveryServiceTime;
+    private final Capacity capacity;
+    private final Skills skills;
+    private final String name;
+    private final Location pickupLocation_;
+    private final Location deliveryLocation_;
+    private final TimeWindowsImpl deliveryTimeWindows;
+    private final TimeWindowsImpl pickupTimeWindows;
+    private final int priority;
+    private final double maxTimeInVehicle;
+
+    Shipment(Builder builder) {
+        setUserData(builder.userData);
+        this.id = builder.id;
+        this.pickupServiceTime = builder.pickupServiceTime;
+        this.deliveryServiceTime = builder.deliveryServiceTime;
+        this.capacity = builder.capacity;
+        this.skills = builder.skills;
+        this.name = builder.name;
+        this.pickupLocation_ = builder.pickupLocation_;
+        this.deliveryLocation_ = builder.deliveryLocation_;
+        this.deliveryTimeWindows = builder.deliveryTimeWindows;
+        this.pickupTimeWindows = builder.pickupTimeWindows;
+        this.priority = builder.priority;
+        this.maxTimeInVehicle = builder.maxTimeInVehicle;
+    }
+
+    @Override
+    public String getId() {
+        return id;
+    }
+
+    @Override
+    public Capacity getSize() {
+        return capacity;
+    }
+
+    @Override
+    public Skills getRequiredSkills() {
+        return skills;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Get priority of shipment. Only 1 = high priority, 2 = medium and 3 = low are allowed.
+     * <p>
+     * Default is 2 = medium.
+     *
+     * @return priority
+     */
+    @Override
+    public int getPriority() {
+        return priority;
+    }
+
+    @Override
+    public double getMaxTimeInVehicle() {
+        return maxTimeInVehicle;
+    }
+
+    public Location getPickupLocation() {
+        return pickupLocation_;
+    }
+
+    /**
+     * Returns the pickup service-time.
+     * <p>
+     * <p>By default service-time is 0.0.
+     *
+     * @return service-time
+     */
+    public double getPickupServiceTime() {
+        return pickupServiceTime;
+    }
 
+    public Location getDeliveryLocation() {
+        return deliveryLocation_;
+    }
+
+    /**
+     * Returns service-time of delivery.
+     *
+     * @return service-time of delivery
+     */
+    public double getDeliveryServiceTime() {
+        return deliveryServiceTime;
+    }
+
+    /**
+     * Returns the time-window of delivery.
+     *
+     * @return time-window of delivery
+     */
+    public TimeWindow getDeliveryTimeWindow() {
+        return deliveryTimeWindows.getTimeWindows().iterator().next();
+    }
+
+    public Collection<TimeWindow> getDeliveryTimeWindows() {
+        return deliveryTimeWindows.getTimeWindows();
+    }
+
+    /**
+     * Returns the time-window of pickup.
+     *
+     * @return time-window of pickup
+     */
+    public TimeWindow getPickupTimeWindow() {
+        return pickupTimeWindows.getTimeWindows().iterator().next();
+    }
+
+    public Collection<TimeWindow> getPickupTimeWindows() {
+        return pickupTimeWindows.getTimeWindows();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((id == null) ? 0 : id.hashCode());
+        return result;
+    }
+
+    /**
+     * Two shipments are equal if they have the same id.
+     *
+     * @return true if shipments are equal (have the same id)
+     */
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        Shipment other = (Shipment) obj;
+        if (id == null) {
+            if (other.id != null)
+                return false;
+        } else if (!id.equals(other.id))
+            return false;
+        return true;
+    }
+
+    /**
+     * Returns a string with the shipment's attributes.
+     * <p>
+     * <p>String is built as follows: [attr1=val1][attr2=val2]...
+     */
+    @Override
+    public String toString() {
+        return "[id=" + id + "][name=" + name + "][pickupLocation=" + pickupLocation_
+            + "][deliveryLocation=" + deliveryLocation_ + "][capacity=" + capacity
+            + "][pickupServiceTime=" + pickupServiceTime + "][deliveryServiceTime="
+            + deliveryServiceTime + "][pickupTimeWindows=" + pickupTimeWindows
+            + "][deliveryTimeWindows=" + deliveryTimeWindows + "]";
+    }
 
     /**
      * Builder that builds the shipment.
@@ -55,39 +217,32 @@
      */
     public static class Builder {
 
+        public Object userData;
+        public double maxTimeInVehicle = Double.MAX_VALUE;
+        protected TimeWindowsImpl deliveryTimeWindows;
         private String id;
-
         private double pickupServiceTime = 0.0;
-
         private double deliveryServiceTime = 0.0;
-
         private Capacity.Builder capacityBuilder = Capacity.Builder.newInstance();
-
         private Capacity capacity;
-
         private Skills.Builder skillBuilder = Skills.Builder.newInstance();
-
         private Skills skills;
-
         private String name = "no-name";
-
         private Location pickupLocation_;
-
         private Location deliveryLocation_;
-
-        protected TimeWindowsImpl deliveryTimeWindows;
-
         private boolean deliveryTimeWindowAdded = false;
-
         private boolean pickupTimeWindowAdded = false;
-
         private TimeWindowsImpl pickupTimeWindows;
-
         private int priority = 2;
 
-        public Object userData;
-
-        public double maxTimeInVehicle = Double.MAX_VALUE;
+        Builder(String id) {
+            if (id == null) throw new IllegalArgumentException("id must not be null");
+            this.id = id;
+            pickupTimeWindows = new TimeWindowsImpl();
+            pickupTimeWindows.add(TimeWindow.newInstance(0.0, Double.MAX_VALUE));
+            deliveryTimeWindows = new TimeWindowsImpl();
+            deliveryTimeWindows.add(TimeWindow.newInstance(0.0, Double.MAX_VALUE));
+        }
 
         /**
          * Returns new instance of this builder.
@@ -99,26 +254,16 @@ public static Builder newInstance(String id) {
             return new Builder(id);
         }
 
-        Builder(String id) {
-            if (id == null) throw new IllegalArgumentException("id must not be null");
-            this.id = id;
-            pickupTimeWindows = new TimeWindowsImpl();
-            pickupTimeWindows.add(TimeWindow.newInstance(0.0, Double.MAX_VALUE));
-            deliveryTimeWindows = new TimeWindowsImpl();
-            deliveryTimeWindows.add(TimeWindow.newInstance(0.0, Double.MAX_VALUE));
-        }
-
         /**
          * Sets user specific domain data associated with the object.
-         *
+         * <p>
          * <p>
          * The user data is a black box for the framework, it only stores it,
          * but never interacts with it in any way.
          * </p>
          *
-         * @param userData
-         *            any object holding the domain specific user data
-         *            associated with the object.
+         * @param userData any object holding the domain specific user data
+         *                 associated with the object.
          * @return builder
          */
         public Builder setUserData(Object userData) {
@@ -129,8 +274,7 @@ public Builder setUserData(Object userData) {
         /**
          * Sets pickup location.
          *
-         * @param pickupLocation
-         *            pickup location
+         * @param pickupLocation pickup location
          * @return builder
          */
         public Builder setPickupLocation(Location pickupLocation) {
@@ -172,7 +316,6 @@ public Builder setPickupTimeWindow(TimeWindow timeWindow) {
         }
 
 
-
         /**
          * Sets delivery location.
          *
@@ -217,6 +360,13 @@ public Builder setDeliveryTimeWindow(TimeWindow timeWindow) {
             return this;
         }
 
+        public Builder addAllSizeDimensions(Capacity size) {
+            for (int i = 0; i < size.getNuOfDimensions(); i++) {
+                addSizeDimension(i, size.get(i));
+            }
+            return this;
+        }
+
         /**
          * Adds capacity dimension.
          *
@@ -232,20 +382,12 @@ public Builder addSizeDimension(int dimensionIndex, int dimensionValue) {
             return this;
         }
 
-        public Builder addAllSizeDimensions(Capacity size) {
-            for (int i = 0; i < size.getNuOfDimensions(); i++) {
-                addSizeDimension(i, size.get(i));
-            }
-            return this;
-        }
-
-
         /**
          * Builds the shipment.
          *
          * @return shipment
          * @throws IllegalArgumentException if neither pickup-location nor pickup-coord is set or if neither delivery-location nor delivery-coord
-         *                               is set
+         *                                  is set
          */
         public Shipment build() {
             if (pickupLocation_ == null) throw new IllegalArgumentException("The pickup location is missing.");
@@ -261,13 +403,13 @@ public Builder addRequiredSkill(String skill) {
             return this;
         }
 
-        public Builder addAllRequiredSkills(Collection<String> skills) {
-            skillBuilder.addAllSkills(skills);
+        public Builder addAllRequiredSkills(Skills skills) {
+            addAllRequiredSkills(skills.values());
             return this;
         }
 
-        public Builder addAllRequiredSkills(Skills skills) {
-            addAllRequiredSkills(skills.values());
+        public Builder addAllRequiredSkills(Collection<String> skills) {
+            skillBuilder.addAllSkills(skills);
             return this;
         }
 
@@ -276,9 +418,14 @@ public Builder setName(String name) {
             return this;
         }
 
+        public Builder addDeliveryTimeWindow(double earliest, double latest) {
+            addDeliveryTimeWindow(TimeWindow.newInstance(earliest, latest));
+            return this;
+        }
+
         public Builder addDeliveryTimeWindow(TimeWindow timeWindow) {
             if (timeWindow == null) throw new IllegalArgumentException("The time window must not be null.");
-            if(!deliveryTimeWindowAdded){
+            if (!deliveryTimeWindowAdded) {
                 deliveryTimeWindows = new TimeWindowsImpl();
                 deliveryTimeWindowAdded = true;
             }
@@ -286,19 +433,18 @@ public Builder addDeliveryTimeWindow(TimeWindow timeWindow) {
             return this;
         }
 
-        public Builder addDeliveryTimeWindow(double earliest, double latest) {
-            addDeliveryTimeWindow(TimeWindow.newInstance(earliest, latest));
-            return this;
-        }
-
         public Builder addAllDeliveryTimeWindows(Collection<TimeWindow> timeWindow) {
             for (TimeWindow tw : timeWindow) addDeliveryTimeWindow(tw);
             return this;
         }
 
+        public Builder addPickupTimeWindow(double earliest, double latest) {
+            return addPickupTimeWindow(TimeWindow.newInstance(earliest, latest));
+        }
+
         public Builder addPickupTimeWindow(TimeWindow timeWindow) {
             if (timeWindow == null) throw new IllegalArgumentException("The time window must not be null.");
-            if(!pickupTimeWindowAdded){
+            if (!pickupTimeWindowAdded) {
                 pickupTimeWindows = new TimeWindowsImpl();
                 pickupTimeWindowAdded = true;
             }
@@ -306,10 +452,6 @@ public Builder addPickupTimeWindow(TimeWindow timeWindow) {
             return this;
         }
 
-        public Builder addPickupTimeWindow(double earliest, double latest) {
-            return addPickupTimeWindow(TimeWindow.newInstance(earliest, latest));
-        }
-
         public Builder addAllPickupTimeWindows(Collection<TimeWindow> timeWindow) {
             for (TimeWindow tw : timeWindow) addPickupTimeWindow(tw);
             return this;
@@ -336,188 +478,11 @@ public Builder setPriority(int priority) {
          * @param maxTimeInVehicle
          * @return
          */
-        public Builder setMaxTimeInVehicle(double maxTimeInVehicle){
+        public Builder setMaxTimeInVehicle(double maxTimeInVehicle) {
             if (maxTimeInVehicle < 0)
                 throw new IllegalArgumentException("The maximum time in vehicle must be positive.");
             this.maxTimeInVehicle = maxTimeInVehicle;
             return this;
         }
     }
-
-    private final String id;
-
-    private final double pickupServiceTime;
-
-    private final double deliveryServiceTime;
-
-    private final Capacity capacity;
-
-    private final Skills skills;
-
-    private final String name;
-
-    private final Location pickupLocation_;
-
-    private final Location deliveryLocation_;
-
-    private final TimeWindowsImpl deliveryTimeWindows;
-
-    private final TimeWindowsImpl pickupTimeWindows;
-
-    private final int priority;
-
-    private final double maxTimeInVehicle;
-
-    Shipment(Builder builder) {
-        setUserData(builder.userData);
-        this.id = builder.id;
-        this.pickupServiceTime = builder.pickupServiceTime;
-        this.deliveryServiceTime = builder.deliveryServiceTime;
-        this.capacity = builder.capacity;
-        this.skills = builder.skills;
-        this.name = builder.name;
-        this.pickupLocation_ = builder.pickupLocation_;
-        this.deliveryLocation_ = builder.deliveryLocation_;
-        this.deliveryTimeWindows = builder.deliveryTimeWindows;
-        this.pickupTimeWindows = builder.pickupTimeWindows;
-        this.priority = builder.priority;
-        this.maxTimeInVehicle = builder.maxTimeInVehicle;
-    }
-
-    @Override
-    public String getId() {
-        return id;
-    }
-
-    public Location getPickupLocation() {
-        return pickupLocation_;
-    }
-
-    /**
-     * Returns the pickup service-time.
-     * <p>
-     * <p>By default service-time is 0.0.
-     *
-     * @return service-time
-     */
-    public double getPickupServiceTime() {
-        return pickupServiceTime;
-    }
-
-    public Location getDeliveryLocation() {
-        return deliveryLocation_;
-    }
-
-    /**
-     * Returns service-time of delivery.
-     *
-     * @return service-time of delivery
-     */
-    public double getDeliveryServiceTime() {
-        return deliveryServiceTime;
-    }
-
-    /**
-     * Returns the time-window of delivery.
-     *
-     * @return time-window of delivery
-     */
-    public TimeWindow getDeliveryTimeWindow() {
-        return deliveryTimeWindows.getTimeWindows().iterator().next();
-    }
-
-    public Collection<TimeWindow> getDeliveryTimeWindows() {
-        return deliveryTimeWindows.getTimeWindows();
-    }
-
-    /**
-     * Returns the time-window of pickup.
-     *
-     * @return time-window of pickup
-     */
-    public TimeWindow getPickupTimeWindow() {
-        return pickupTimeWindows.getTimeWindows().iterator().next();
-    }
-
-    public Collection<TimeWindow> getPickupTimeWindows() {
-        return pickupTimeWindows.getTimeWindows();
-    }
-
-
-    /**
-     * Returns a string with the shipment's attributes.
-     * <p>
-     * <p>String is built as follows: [attr1=val1][attr2=val2]...
-     */
-    @Override
-    public String toString() {
-        return "[id=" + id + "][name=" + name + "][pickupLocation=" + pickupLocation_
-                + "][deliveryLocation=" + deliveryLocation_ + "][capacity=" + capacity
-                + "][pickupServiceTime=" + pickupServiceTime + "][deliveryServiceTime="
-                + deliveryServiceTime + "][pickupTimeWindows=" + pickupTimeWindows
-                + "][deliveryTimeWindows=" + deliveryTimeWindows + "]";
-    }
-
-
-    @Override
-    public int hashCode() {
-        final int prime = 31;
-        int result = 1;
-        result = prime * result + ((id == null) ? 0 : id.hashCode());
-        return result;
-    }
-
-    /**
-     * Two shipments are equal if they have the same id.
-     *
-     * @return true if shipments are equal (have the same id)
-     */
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj)
-            return true;
-        if (obj == null)
-            return false;
-        if (getClass() != obj.getClass())
-            return false;
-        Shipment other = (Shipment) obj;
-        if (id == null) {
-            if (other.id != null)
-                return false;
-        } else if (!id.equals(other.id))
-            return false;
-        return true;
-    }
-
-    @Override
-    public Capacity getSize() {
-        return capacity;
-    }
-
-    @Override
-    public Skills getRequiredSkills() {
-        return skills;
-    }
-
-    @Override
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Get priority of shipment. Only 1 = high priority, 2 = medium and 3 = low are allowed.
-     * <p>
-     * Default is 2 = medium.
-     *
-     * @return priority
-     */
-    @Override
-    public int getPriority() {
-        return priority;
-    }
-
-    @Override
-    public double getMaxTimeInVehicle() {
-        return maxTimeInVehicle;
-    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/misc/ActivityContext.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/misc/ActivityContext.java
index 06a3f4738..0d83bf80a 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/misc/ActivityContext.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/misc/ActivityContext.java
@@ -38,6 +38,15 @@ public double getArrivalTime() {
         return arrivalTime;
     }
 
+    /**
+     * Sets arrivalTime of associated vehicle at activity.
+     *
+     * @param arrivalTime arrival time of associated vehicle at activity
+     */
+    public void setArrivalTime(double arrivalTime) {
+        this.arrivalTime = arrivalTime;
+    }
+
     /**
      * Returns end time of associated activity.
      *
@@ -47,6 +56,15 @@ public double getEndTime() {
         return endTime;
     }
 
+    /**
+     * Sets end time of associated activity.
+     *
+     * @param endTime end time
+     */
+    public void setEndTime(double endTime) {
+        this.endTime = endTime;
+    }
+
     /**
      * Returns the insertion index of the associated vehicle.
      * <p>
@@ -66,24 +84,6 @@ public int getInsertionIndex() {
         return insertionIndex;
     }
 
-    /**
-     * Sets arrivalTime of associated vehicle at activity.
-     *
-     * @param arrivalTime arrival time of associated vehicle at activity
-     */
-    public void setArrivalTime(double arrivalTime) {
-        this.arrivalTime = arrivalTime;
-    }
-
-    /**
-     * Sets end time of associated activity.
-     *
-     * @param endTime end time
-     */
-    public void setEndTime(double endTime) {
-        this.endTime = endTime;
-    }
-
     /**
      * Sets insertion index of associated activity.
      *
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/misc/JobInsertionContext.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/misc/JobInsertionContext.java
index 0115e9c22..a06003c59 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/misc/JobInsertionContext.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/misc/JobInsertionContext.java
@@ -47,6 +47,24 @@
 
     private ActivityContext relatedActivityContext;
 
+    /**
+     * Constructs the context.
+     *
+     * @param route      the existing route where the job needs to be inserted in
+     * @param job        the job to be inserted
+     * @param newVehicle the new vehicle that should operate the new route
+     * @param newDriver  the new driver that should operate the new route
+     * @param newDepTime the new departure time at the new vehicle's start location
+     */
+    public JobInsertionContext(VehicleRoute route, Job job, Vehicle newVehicle, Driver newDriver, double newDepTime) {
+        super();
+        this.route = route;
+        this.job = job;
+        this.newVehicle = newVehicle;
+        this.newDriver = newDriver;
+        this.newDepTime = newDepTime;
+    }
+
     /**
      * Returns the existing route where the .getJob() needs to be inserted in.
      *
@@ -94,26 +112,17 @@ public double getNewDepTime() {
         return newDepTime;
     }
 
+    public List<TourActivity> getAssociatedActivities() {
+        return associatedActivities;
+    }
+
     /**
-     * Constructs the context.
+     * Returns pickup context. If no context available, returns null.
      *
-     * @param route      the existing route where the job needs to be inserted in
-     * @param job        the job to be inserted
-     * @param newVehicle the new vehicle that should operate the new route
-     * @param newDriver  the new driver that should operate the new route
-     * @param newDepTime the new departure time at the new vehicle's start location
+     * @return pickup context
      */
-    public JobInsertionContext(VehicleRoute route, Job job, Vehicle newVehicle, Driver newDriver, double newDepTime) {
-        super();
-        this.route = route;
-        this.job = job;
-        this.newVehicle = newVehicle;
-        this.newDriver = newDriver;
-        this.newDepTime = newDepTime;
-    }
-
-    public List<TourActivity> getAssociatedActivities() {
-        return associatedActivities;
+    public ActivityContext getRelatedActivityContext() {
+        return this.relatedActivityContext;
     }
 
     /**
@@ -125,20 +134,11 @@ public void setRelatedActivityContext(ActivityContext relatedActivityContext) {
         this.relatedActivityContext = relatedActivityContext;
     }
 
-    /**
-     * Returns pickup context. If no context available, returns null.
-     *
-     * @return pickup context
-     */
-    public ActivityContext getRelatedActivityContext() {
-        return this.relatedActivityContext;
+    public ActivityContext getActivityContext() {
+        return this.activityContext;
     }
 
-    public void setActivityContext(ActivityContext activityContext){
+    public void setActivityContext(ActivityContext activityContext) {
         this.activityContext = activityContext;
     }
-
-    public ActivityContext getActivityContext(){
-        return this.activityContext;
-    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolution.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolution.java
index ba374d1d6..ba15936a0 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolution.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolution.java
@@ -31,20 +31,8 @@
  */
 public class VehicleRoutingProblemSolution {
 
-    /**
-     * Makes a deep copy of the solution to be copied.
-     *
-     * @param solution2copy solution to be copied
-     * @return solution
-     */
-    public static VehicleRoutingProblemSolution copyOf(VehicleRoutingProblemSolution solution2copy) {
-        return new VehicleRoutingProblemSolution(solution2copy);
-    }
-
     private final Collection<VehicleRoute> routes;
-
     private Collection<Job> unassignedJobs = new ArrayList<Job>();
-
     private double cost;
 
     private VehicleRoutingProblemSolution(VehicleRoutingProblemSolution solution) {
@@ -57,32 +45,6 @@ private VehicleRoutingProblemSolution(VehicleRoutingProblemSolution solution) {
         unassignedJobs.addAll(solution.getUnassignedJobs());
     }
 
-    /**
-     * Constructs a solution with a number of {@link VehicleRoute}s and their corresponding aggregate cost value.
-     *
-     * @param routes routes being part of the solution
-     * @param cost   total costs of solution
-     */
-    public VehicleRoutingProblemSolution(Collection<VehicleRoute> routes, double cost) {
-        super();
-        this.routes = routes;
-        this.cost = cost;
-    }
-
-    /**
-     * Constructs a solution with a number of {@link VehicleRoute}s, bad jobs and their corresponding aggregate cost value.
-     *
-     * @param routes         routes being part of the solution
-     * @param unassignedJobs jobs that could not be assigned to any vehicle
-     * @param cost           total costs of solution
-     */
-    public VehicleRoutingProblemSolution(Collection<VehicleRoute> routes, Collection<Job> unassignedJobs, double cost) {
-        super();
-        this.routes = routes;
-        this.unassignedJobs = unassignedJobs;
-        this.cost = cost;
-    }
-
     /**
      * Returns a collection of vehicle-routes.
      *
@@ -119,6 +81,42 @@ public void setCost(double cost) {
         return unassignedJobs;
     }
 
+    /**
+     * Constructs a solution with a number of {@link VehicleRoute}s and their corresponding aggregate cost value.
+     *
+     * @param routes routes being part of the solution
+     * @param cost   total costs of solution
+     */
+    public VehicleRoutingProblemSolution(Collection<VehicleRoute> routes, double cost) {
+        super();
+        this.routes = routes;
+        this.cost = cost;
+    }
+
+    /**
+     * Constructs a solution with a number of {@link VehicleRoute}s, bad jobs and their corresponding aggregate cost value.
+     *
+     * @param routes         routes being part of the solution
+     * @param unassignedJobs jobs that could not be assigned to any vehicle
+     * @param cost           total costs of solution
+     */
+    public VehicleRoutingProblemSolution(Collection<VehicleRoute> routes, Collection<Job> unassignedJobs, double cost) {
+        super();
+        this.routes = routes;
+        this.unassignedJobs = unassignedJobs;
+        this.cost = cost;
+    }
+
+    /**
+     * Makes a deep copy of the solution to be copied.
+     *
+     * @param solution2copy solution to be copied
+     * @return solution
+     */
+    public static VehicleRoutingProblemSolution copyOf(VehicleRoutingProblemSolution solution2copy) {
+        return new VehicleRoutingProblemSolution(solution2copy);
+    }
+
     @Override
     public String toString() {
         return "[costs=" + cost + "][routes=" + routes.size() + "][unassigned=" + unassignedJobs.size() + "]";
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/ReverseRouteActivityVisitor.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/ReverseRouteActivityVisitor.java
index 8ea38eccd..7539635e8 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/ReverseRouteActivityVisitor.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/ReverseRouteActivityVisitor.java
@@ -42,9 +42,9 @@ public void visit(VehicleRoute route) {
         finish(route);
     }
 
-    private void finish(VehicleRoute route) {
+    private void begin(VehicleRoute route) {
         for (ReverseActivityVisitor visitor : visitors) {
-            visitor.finish();
+            visitor.begin(route);
         }
 
     }
@@ -55,9 +55,9 @@ private void visit(TourActivity act) {
         }
     }
 
-    private void begin(VehicleRoute route) {
+    private void finish(VehicleRoute route) {
         for (ReverseActivityVisitor visitor : visitors) {
-            visitor.begin(route);
+            visitor.finish();
         }
 
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/RouteActivityVisitor.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/RouteActivityVisitor.java
index f03aa9342..45d3ca26e 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/RouteActivityVisitor.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/RouteActivityVisitor.java
@@ -38,9 +38,9 @@ public void visit(VehicleRoute route) {
         end(route);
     }
 
-    private void end(VehicleRoute route) {
+    private void begin(VehicleRoute route) {
         for (ActivityVisitor visitor : visitors) {
-            visitor.finish();
+            visitor.begin(route);
         }
 
     }
@@ -51,9 +51,9 @@ private void visit(TourActivity act) {
         }
     }
 
-    private void begin(VehicleRoute route) {
+    private void end(VehicleRoute route) {
         for (ActivityVisitor visitor : visitors) {
-            visitor.begin(route);
+            visitor.finish();
         }
 
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRoute.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRoute.java
index 7dd0c17d4..c88001a77 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRoute.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRoute.java
@@ -36,6 +36,83 @@
  */
 public class VehicleRoute {
 
+    private TourActivities tourActivities;
+    private Vehicle vehicle;
+    private Driver driver;
+    private Start start;
+    private End end;
+
+    /**
+     * Copy constructor copying a route.
+     *
+     * @param route to copy
+     */
+    private VehicleRoute(VehicleRoute route) {
+        this.start = Start.copyOf(route.getStart());
+        this.end = End.copyOf(route.getEnd());
+        this.tourActivities = TourActivities.copyOf(route.getTourActivities());
+        this.vehicle = route.getVehicle();
+        this.driver = route.getDriver();
+    }
+
+    /**
+     * Returns start-activity of this route.
+     *
+     * @return start
+     */
+    public Start getStart() {
+        return start;
+    }
+
+    /**
+     * Returns end-activity of this route.
+     *
+     * @return end
+     */
+    public End getEnd() {
+        return end;
+    }
+
+    /**
+     * Returns TourActivities.
+     *
+     * @return {@link TourActivities}
+     */
+    public TourActivities getTourActivities() {
+        return tourActivities;
+    }
+
+    /**
+     * Returns the vehicle operating this route.
+     *
+     * @return Vehicle
+     */
+    public Vehicle getVehicle() {
+        return vehicle;
+    }
+
+    /**
+     * Returns the driver operating this route.
+     *
+     * @return Driver
+     */
+    public Driver getDriver() {
+        return driver;
+    }
+
+    /**
+     * Constructs route.
+     *
+     * @param builder used to build route
+     */
+    private VehicleRoute(Builder builder) {
+        this.tourActivities = builder.tourActivities;
+        this.vehicle = builder.vehicle;
+        this.driver = builder.driver;
+        this.start = builder.start;
+        this.end = builder.end;
+    }
+
     /**
      * Returns a deep copy of this vehicleRoute.
      *
@@ -59,6 +136,78 @@ public static VehicleRoute emptyRoute() {
         return Builder.newInstance(VehicleImpl.createNoVehicle(), DriverImpl.noDriver()).build();
     }
 
+    /**
+     * Returns an unmodifiable list of activities on this route (without start/end).
+     *
+     * @return list of tourActivities
+     */
+    public List<TourActivity> getActivities() {
+        return Collections.unmodifiableList(tourActivities.getActivities());
+    }
+
+    /**
+     * Sets the vehicle and its departureTime from <code>vehicle.getStartLocationId()</code>.
+     * <p>
+     * <p>This implies the following:<br>
+     * if start and end are null, new start and end activities are created.<br>
+     * <p>startActivity is initialized with the start-location of the specified vehicle (<code>vehicle.getStartLocationId()</code>). the time-window of this activity is initialized
+     * such that [<code>startActivity.getTheoreticalEarliestOperationStartTime()</code> = <code>vehicle.getEarliestDeparture()</code>][<code>startActivity.getTheoreticalLatestOperationStartTime()</code> = <code>vehicle.getLatestArrival()</code>]
+     * <p>endActivity is initialized with the end-location of the specified vehicle (<code>vehicle.getEndLocationId()</code>). The time-window of the
+     * endActivity is initialized such that [<code>endActivity.getTheoreticalEarliestOperationStartTime()</code> = <code>vehicle.getEarliestDeparture()</code>][<code>endActivity.getTheoreticalLatestOperationStartTime()</code> = <code>vehicle.getLatestArrival()</code>]
+     * <p>startActivity.endTime (<code>startActivity.getEndTime()</code>) is set to max{<code>vehicle.getEarliestDeparture()</code>, <code>vehicleDepTime</code>}.
+     * thus, <code>vehicle.getEarliestDeparture()</code> is a physical constraint that has to be met.
+     *
+     * @param vehicle        to be employed
+     * @param vehicleDepTime of employed vehicle
+     */
+    public void setVehicleAndDepartureTime(Vehicle vehicle, double vehicleDepTime) {
+        this.vehicle = vehicle;
+        setStartAndEnd(vehicle, vehicleDepTime);
+    }
+
+    private void setStartAndEnd(Vehicle vehicle, double vehicleDepTime) {
+        if (!(vehicle instanceof VehicleImpl.NoVehicle)) {
+            if (start == null && end == null) {
+                start = new Start(vehicle.getStartLocation(), vehicle.getEarliestDeparture(), vehicle.getLatestArrival());
+                end = new End(vehicle.getEndLocation(), vehicle.getEarliestDeparture(), vehicle.getLatestArrival());
+            }
+            start.setEndTime(Math.max(vehicleDepTime, vehicle.getEarliestDeparture()));
+            start.setTheoreticalEarliestOperationStartTime(vehicle.getEarliestDeparture());
+            start.setTheoreticalLatestOperationStartTime(vehicle.getLatestArrival());
+            start.setLocation(vehicle.getStartLocation());
+            end.setLocation(vehicle.getEndLocation());
+            end.setTheoreticalEarliestOperationStartTime(vehicle.getEarliestDeparture());
+            end.setTheoreticalLatestOperationStartTime(vehicle.getLatestArrival());
+        }
+
+    }
+
+    /**
+     * Returns the departureTime of this vehicle in this route.
+     *
+     * @return departureTime
+     * @throws IllegalArgumentException if start is null
+     */
+    public double getDepartureTime() {
+        if (start == null)
+            throw new IllegalArgumentException("cannot get departureTime without having a vehicle on this route. use setVehicle(vehicle,departureTime) instead.");
+        return start.getEndTime();
+    }
+
+    /**
+     * Returns tour if tour-activity-sequence is empty, i.e. to activity on the tour yet.
+     *
+     * @return true if route is empty
+     */
+    public boolean isEmpty() {
+        return tourActivities.isEmpty();
+    }
+
+    @Override
+    public String toString() {
+        return "[start=" + start + "][end=" + end + "][departureTime=" + start.getEndTime() + "][vehicle=" + vehicle + "][driver=" + driver + "][nuOfActs=" + tourActivities.getActivities().size() + "]";
+    }
+
     /**
      * Builder that builds the vehicle route.
      *
@@ -67,6 +216,40 @@ public static VehicleRoute emptyRoute() {
     public static class Builder {
 
         private Map<Shipment, TourActivity> openActivities = new HashMap<Shipment, TourActivity>();
+        private Vehicle vehicle;
+        private Driver driver;
+        private Start start;
+        private End end;
+        private TourActivities tourActivities = new TourActivities();
+        private TourActivityFactory serviceActivityFactory = new DefaultTourActivityFactory();
+        private TourShipmentActivityFactory shipmentActivityFactory = new DefaultShipmentActivityFactory();
+        private Set<Shipment> openShipments = new HashSet<Shipment>();
+        private JobActivityFactory jobActivityFactory = new JobActivityFactory() {
+
+            @Override
+            public List<AbstractActivity> createActivities(Job job) {
+                List<AbstractActivity> acts = new ArrayList<AbstractActivity>();
+                if (job instanceof Break) {
+                    acts.add(BreakActivity.newInstance((Break) job));
+                } else if (job instanceof Service) {
+                    acts.add(serviceActivityFactory.createActivity((Service) job));
+                } else if (job instanceof Shipment) {
+                    acts.add(shipmentActivityFactory.createPickup((Shipment) job));
+                    acts.add(shipmentActivityFactory.createDelivery((Shipment) job));
+                }
+                return acts;
+            }
+
+        };
+
+        private Builder(Vehicle vehicle, Driver driver) {
+            super();
+            this.vehicle = vehicle;
+            this.driver = driver;
+            start = new Start(vehicle.getStartLocation(), vehicle.getEarliestDeparture(), Double.MAX_VALUE);
+            start.setEndTime(vehicle.getEarliestDeparture());
+            end = new End(vehicle.getEndLocation(), 0.0, vehicle.getLatestArrival());
+        }
 
         /**
          * Returns new instance of this builder.
@@ -107,54 +290,11 @@ public static Builder newInstance(Vehicle vehicle) {
             return new Builder(vehicle, DriverImpl.noDriver());
         }
 
-        private Vehicle vehicle;
-
-        private Driver driver;
-
-        private Start start;
-
-        private End end;
-
-        private TourActivities tourActivities = new TourActivities();
-
-        private TourActivityFactory serviceActivityFactory = new DefaultTourActivityFactory();
-
-        private TourShipmentActivityFactory shipmentActivityFactory = new DefaultShipmentActivityFactory();
-
-        private Set<Shipment> openShipments = new HashSet<Shipment>();
-
-        private JobActivityFactory jobActivityFactory = new JobActivityFactory() {
-
-            @Override
-            public List<AbstractActivity> createActivities(Job job) {
-                List<AbstractActivity> acts = new ArrayList<AbstractActivity>();
-                if (job instanceof Break) {
-                    acts.add(BreakActivity.newInstance((Break) job));
-                } else if (job instanceof Service) {
-                    acts.add(serviceActivityFactory.createActivity((Service) job));
-                } else if (job instanceof Shipment) {
-                    acts.add(shipmentActivityFactory.createPickup((Shipment) job));
-                    acts.add(shipmentActivityFactory.createDelivery((Shipment) job));
-                }
-                return acts;
-            }
-
-        };
-
         public Builder setJobActivityFactory(JobActivityFactory jobActivityFactory) {
             this.jobActivityFactory = jobActivityFactory;
             return this;
         }
 
-        private Builder(Vehicle vehicle, Driver driver) {
-            super();
-            this.vehicle = vehicle;
-            this.driver = driver;
-            start = new Start(vehicle.getStartLocation(), vehicle.getEarliestDeparture(), Double.MAX_VALUE);
-            start.setEndTime(vehicle.getEarliestDeparture());
-            end = new End(vehicle.getEndLocation(), 0.0, vehicle.getLatestArrival());
-        }
-
         /**
          * Sets the departure-time of the route, i.e. which is the time the vehicle departs from start-location.
          * <p>
@@ -171,20 +311,16 @@ public Builder setDepartureTime(double departureTime) {
             return this;
         }
 
-        /**
-         * Adds a service to this route. Activity is initialized with .getTimeWindow(). If you want to explicitly set another time window
-         * use .addService(Service service, TimeWindow timeWindow)
-         * <p>
-         * <p>This implies that for this service a serviceActivity is created with {@link TourActivityFactory} and added to the sequence of tourActivities.
-         * <p>
-         * <p>The resulting activity occurs in the activity-sequence in the order adding/inserting.
-         *
-         * @param service to be added
-         * @return this builder
-         * @throws IllegalArgumentException if service is null
-         */
-        public Builder addService(Service service) {
-            return addService(service,service.getTimeWindow());
+        @Deprecated
+        public Builder addBreak(Break currentbreak) {
+            if (currentbreak == null) throw new IllegalArgumentException("break must not be null");
+            return addBreak(currentbreak, currentbreak.getTimeWindow());
+        }
+
+        @Deprecated
+        public Builder addBreak(Break currentbreak, TimeWindow timeWindow) {
+            if (currentbreak == null) throw new IllegalArgumentException("break must not be null");
+            return addService(currentbreak, timeWindow);
         }
 
         public Builder addService(Service service, TimeWindow timeWindow) {
@@ -197,18 +333,6 @@ public Builder addService(Service service, TimeWindow timeWindow) {
             return this;
         }
 
-        @Deprecated
-        public Builder addBreak(Break currentbreak) {
-            if (currentbreak == null) throw new IllegalArgumentException("break must not be null");
-            return addBreak(currentbreak, currentbreak.getTimeWindow());
-        }
-
-        @Deprecated
-        public Builder addBreak(Break currentbreak, TimeWindow timeWindow) {
-            if (currentbreak == null) throw new IllegalArgumentException("break must not be null");
-            return addService(currentbreak,timeWindow);
-        }
-
         public Builder addBreak(Break currentbreak, TimeWindow timeWindow, Location location) {
             if (currentbreak == null) throw new IllegalArgumentException("break must not be null");
             return addBreakInternally(currentbreak, timeWindow, location);
@@ -235,9 +359,25 @@ public Builder addPickup(Pickup pickup) {
             return addService(pickup);
         }
 
+        /**
+         * Adds a service to this route. Activity is initialized with .getTimeWindow(). If you want to explicitly set another time window
+         * use .addService(Service service, TimeWindow timeWindow)
+         * <p>
+         * <p>This implies that for this service a serviceActivity is created with {@link TourActivityFactory} and added to the sequence of tourActivities.
+         * <p>
+         * <p>The resulting activity occurs in the activity-sequence in the order adding/inserting.
+         *
+         * @param service to be added
+         * @return this builder
+         * @throws IllegalArgumentException if service is null
+         */
+        public Builder addService(Service service) {
+            return addService(service, service.getTimeWindow());
+        }
+
         public Builder addPickup(Pickup pickup, TimeWindow timeWindow) {
             if (pickup == null) throw new IllegalArgumentException("pickup must not be null");
-            return addService(pickup,timeWindow);
+            return addService(pickup, timeWindow);
         }
 
         /**
@@ -253,7 +393,7 @@ public Builder addDelivery(Delivery delivery) {
 
         public Builder addDelivery(Delivery delivery, TimeWindow timeWindow) {
             if (delivery == null) throw new IllegalArgumentException("delivery must not be null");
-            return addService(delivery,timeWindow);
+            return addService(delivery, timeWindow);
         }
 
         /**
@@ -288,7 +428,7 @@ public Builder addPickup(Shipment shipment, TimeWindow pickupTimeWindow) {
          * @throws IllegalArgumentException if specified shipment has not been picked up yet (i.e. method addPickup(shipment) has not been called yet).
          */
         public Builder addDelivery(Shipment shipment) {
-            return addDelivery(shipment,shipment.getDeliveryTimeWindow());
+            return addDelivery(shipment, shipment.getDeliveryTimeWindow());
         }
 
         public Builder addDelivery(Shipment shipment, TimeWindow deliveryTimeWindow) {
@@ -325,157 +465,4 @@ public VehicleRoute build() {
 
     }
 
-    private TourActivities tourActivities;
-
-    private Vehicle vehicle;
-
-    private Driver driver;
-
-    private Start start;
-
-    private End end;
-
-    /**
-     * Copy constructor copying a route.
-     *
-     * @param route to copy
-     */
-    private VehicleRoute(VehicleRoute route) {
-        this.start = Start.copyOf(route.getStart());
-        this.end = End.copyOf(route.getEnd());
-        this.tourActivities = TourActivities.copyOf(route.getTourActivities());
-        this.vehicle = route.getVehicle();
-        this.driver = route.getDriver();
-    }
-
-    /**
-     * Constructs route.
-     *
-     * @param builder used to build route
-     */
-    private VehicleRoute(Builder builder) {
-        this.tourActivities = builder.tourActivities;
-        this.vehicle = builder.vehicle;
-        this.driver = builder.driver;
-        this.start = builder.start;
-        this.end = builder.end;
-    }
-
-    /**
-     * Returns an unmodifiable list of activities on this route (without start/end).
-     *
-     * @return list of tourActivities
-     */
-    public List<TourActivity> getActivities() {
-        return Collections.unmodifiableList(tourActivities.getActivities());
-    }
-
-    /**
-     * Returns TourActivities.
-     *
-     * @return {@link TourActivities}
-     */
-    public TourActivities getTourActivities() {
-        return tourActivities;
-    }
-
-    /**
-     * Returns the vehicle operating this route.
-     *
-     * @return Vehicle
-     */
-    public Vehicle getVehicle() {
-        return vehicle;
-    }
-
-    /**
-     * Returns the driver operating this route.
-     *
-     * @return Driver
-     */
-    public Driver getDriver() {
-        return driver;
-    }
-
-    /**
-     * Sets the vehicle and its departureTime from <code>vehicle.getStartLocationId()</code>.
-     * <p>
-     * <p>This implies the following:<br>
-     * if start and end are null, new start and end activities are created.<br>
-     * <p>startActivity is initialized with the start-location of the specified vehicle (<code>vehicle.getStartLocationId()</code>). the time-window of this activity is initialized
-     * such that [<code>startActivity.getTheoreticalEarliestOperationStartTime()</code> = <code>vehicle.getEarliestDeparture()</code>][<code>startActivity.getTheoreticalLatestOperationStartTime()</code> = <code>vehicle.getLatestArrival()</code>]
-     * <p>endActivity is initialized with the end-location of the specified vehicle (<code>vehicle.getEndLocationId()</code>). The time-window of the
-     * endActivity is initialized such that [<code>endActivity.getTheoreticalEarliestOperationStartTime()</code> = <code>vehicle.getEarliestDeparture()</code>][<code>endActivity.getTheoreticalLatestOperationStartTime()</code> = <code>vehicle.getLatestArrival()</code>]
-     * <p>startActivity.endTime (<code>startActivity.getEndTime()</code>) is set to max{<code>vehicle.getEarliestDeparture()</code>, <code>vehicleDepTime</code>}.
-     * thus, <code>vehicle.getEarliestDeparture()</code> is a physical constraint that has to be met.
-     *
-     * @param vehicle        to be employed
-     * @param vehicleDepTime of employed vehicle
-     */
-    public void setVehicleAndDepartureTime(Vehicle vehicle, double vehicleDepTime) {
-        this.vehicle = vehicle;
-        setStartAndEnd(vehicle, vehicleDepTime);
-    }
-
-    private void setStartAndEnd(Vehicle vehicle, double vehicleDepTime) {
-        if (!(vehicle instanceof VehicleImpl.NoVehicle)) {
-            if (start == null && end == null) {
-                start = new Start(vehicle.getStartLocation(), vehicle.getEarliestDeparture(), vehicle.getLatestArrival());
-                end = new End(vehicle.getEndLocation(), vehicle.getEarliestDeparture(), vehicle.getLatestArrival());
-            }
-            start.setEndTime(Math.max(vehicleDepTime, vehicle.getEarliestDeparture()));
-            start.setTheoreticalEarliestOperationStartTime(vehicle.getEarliestDeparture());
-            start.setTheoreticalLatestOperationStartTime(vehicle.getLatestArrival());
-            start.setLocation(vehicle.getStartLocation());
-            end.setLocation(vehicle.getEndLocation());
-            end.setTheoreticalEarliestOperationStartTime(vehicle.getEarliestDeparture());
-            end.setTheoreticalLatestOperationStartTime(vehicle.getLatestArrival());
-        }
-
-    }
-
-    /**
-     * Returns the departureTime of this vehicle in this route.
-     *
-     * @return departureTime
-     * @throws IllegalArgumentException if start is null
-     */
-    public double getDepartureTime() {
-        if (start == null)
-            throw new IllegalArgumentException("cannot get departureTime without having a vehicle on this route. use setVehicle(vehicle,departureTime) instead.");
-        return start.getEndTime();
-    }
-
-    /**
-     * Returns tour if tour-activity-sequence is empty, i.e. to activity on the tour yet.
-     *
-     * @return true if route is empty
-     */
-    public boolean isEmpty() {
-        return tourActivities.isEmpty();
-    }
-
-    /**
-     * Returns start-activity of this route.
-     *
-     * @return start
-     */
-    public Start getStart() {
-        return start;
-    }
-
-    /**
-     * Returns end-activity of this route.
-     *
-     * @return end
-     */
-    public End getEnd() {
-        return end;
-    }
-
-    @Override
-    public String toString() {
-        return "[start=" + start + "][end=" + end + "][departureTime=" + start.getEndTime() + "][vehicle=" + vehicle + "][driver=" + driver + "][nuOfActs=" + tourActivities.getActivities().size() + "]";
-    }
-
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ActivityStartsAsSoonAsTimeWindowOpens.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ActivityStartsAsSoonAsTimeWindowOpens.java
index b54e6781c..b56a986ba 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ActivityStartsAsSoonAsTimeWindowOpens.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ActivityStartsAsSoonAsTimeWindowOpens.java
@@ -25,7 +25,7 @@
 
     @Override
     public double getActivityStartTime(TourActivity activity, double arrivalTime) {
-        return Math.max(activity.getTheoreticalEarliestOperationStartTime(),arrivalTime);
+        return Math.max(activity.getTheoreticalEarliestOperationStartTime(), arrivalTime);
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/BreakActivity.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/BreakActivity.java
index cb37c9fc8..7d71fb1b2 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/BreakActivity.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/BreakActivity.java
@@ -26,55 +26,12 @@
 public class BreakActivity extends AbstractActivity implements TourActivity.JobActivity {
 
     public static int counter = 0;
-
+    private final Break aBreak;
     public double arrTime;
-
     public double endTime;
-
     private Location location;
-
     private double duration;
-
-    /**
-     * @return the arrTime
-     */
-    public double getArrTime() {
-        return arrTime;
-    }
-
-    /**
-     * @param arrTime the arrTime to set
-     */
-    public void setArrTime(double arrTime) {
-        this.arrTime = arrTime;
-    }
-
-    /**
-     * @return the endTime
-     */
-    public double getEndTime() {
-        return endTime;
-    }
-
-    /**
-     * @param endTime the endTime to set
-     */
-    public void setEndTime(double endTime) {
-        this.endTime = endTime;
-    }
-
-    public static BreakActivity copyOf(BreakActivity breakActivity) {
-        return new BreakActivity(breakActivity);
-    }
-
-    public static BreakActivity newInstance(Break aBreak) {
-        return new BreakActivity(aBreak);
-    }
-
-    private final Break aBreak;
-
     private double earliest = 0;
-
     private double latest = Double.MAX_VALUE;
 
     protected BreakActivity(Break aBreak) {
@@ -95,6 +52,18 @@ protected BreakActivity(BreakActivity breakActivity) {
         this.duration = breakActivity.getOperationTime();
     }
 
+    public static BreakActivity copyOf(BreakActivity breakActivity) {
+        return new BreakActivity(breakActivity);
+    }
+
+    public static BreakActivity newInstance(Break aBreak) {
+        return new BreakActivity(aBreak);
+    }
+
+    @Override
+    public Service getJob() {
+        return aBreak;
+    }
 
     /* (non-Javadoc)
      * @see java.lang.Object#hashCode()
@@ -127,21 +96,17 @@ public boolean equals(Object obj) {
         return true;
     }
 
-    public double getTheoreticalEarliestOperationStartTime() {
-        return earliest;
-    }
-
-    public double getTheoreticalLatestOperationStartTime() {
-        return latest;
-    }
-
     @Override
-    public double getOperationTime() {
-        return duration;
+    public String toString() {
+        return "[type=" + getName() + "][location=" + getLocation()
+            + "][size=" + getSize().toString()
+            + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
+            + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
     }
 
-    public void setOperationTime(double duration){
-        this.duration = duration;
+    @Override
+    public String getName() {
+        return aBreak.getType();
     }
 
     @Override
@@ -149,37 +114,60 @@ public Location getLocation() {
         return location;
     }
 
-    public void setLocation(Location breakLocation) {
-        this.location = breakLocation;
+    public double getTheoreticalEarliestOperationStartTime() {
+        return earliest;
     }
 
     @Override
-    public Service getJob() {
-        return aBreak;
+    public void setTheoreticalEarliestOperationStartTime(double earliest) {
+        this.earliest = earliest;
     }
 
+    public double getTheoreticalLatestOperationStartTime() {
+        return latest;
+    }
 
     @Override
-    public String toString() {
-        return "[type=" + getName() + "][location=" + getLocation()
-            + "][size=" + getSize().toString()
-            + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
-            + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
+    public void setTheoreticalLatestOperationStartTime(double latest) {
+        this.latest = latest;
     }
 
     @Override
-    public void setTheoreticalEarliestOperationStartTime(double earliest) {
-        this.earliest = earliest;
+    public double getOperationTime() {
+        return duration;
     }
 
-    @Override
-    public void setTheoreticalLatestOperationStartTime(double latest) {
-        this.latest = latest;
+    /**
+     * @return the arrTime
+     */
+    public double getArrTime() {
+        return arrTime;
+    }
+
+    /**
+     * @param arrTime the arrTime to set
+     */
+    public void setArrTime(double arrTime) {
+        this.arrTime = arrTime;
+    }
+
+    /**
+     * @return the endTime
+     */
+    public double getEndTime() {
+        return endTime;
+    }
+
+    /**
+     * @param endTime the endTime to set
+     */
+    public void setEndTime(double endTime) {
+        this.endTime = endTime;
     }
 
     @Override
-    public String getName() {
-        return aBreak.getType();
+    public Capacity getSize() {
+        return aBreak.getSize();
     }
 
     @Override
@@ -187,9 +175,12 @@ public TourActivity duplicate() {
         return new BreakActivity(this);
     }
 
-    @Override
-    public Capacity getSize() {
-        return aBreak.getSize();
+    public void setOperationTime(double duration) {
+        this.duration = duration;
+    }
+
+    public void setLocation(Location breakLocation) {
+        this.location = breakLocation;
     }
 
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliverService.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliverService.java
index 9b06ec6cb..7c58744cb 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliverService.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliverService.java
@@ -52,6 +52,18 @@ private DeliverService(DeliverService deliveryActivity) {
         this.theoreticalLatest = deliveryActivity.getTheoreticalLatestOperationStartTime();
     }
 
+    @Override
+    public Delivery getJob() {
+        return delivery;
+    }
+
+    public String toString() {
+        return "[type=" + getName() + "][locationId=" + getLocation().getId()
+            + "][size=" + getSize().toString()
+            + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
+            + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
+    }
+
     @Override
     public String getName() {
         return delivery.getType();
@@ -63,24 +75,23 @@ public Location getLocation() {
     }
 
     @Override
-    public void setTheoreticalEarliestOperationStartTime(double earliest) {
-        theoreticalEarliest = earliest;
+    public double getTheoreticalEarliestOperationStartTime() {
+        return theoreticalEarliest;
     }
 
     @Override
-    public void setTheoreticalLatestOperationStartTime(double latest) {
-        theoreticalLatest = latest;
+    public void setTheoreticalEarliestOperationStartTime(double earliest) {
+        theoreticalEarliest = earliest;
     }
 
-
     @Override
-    public double getTheoreticalEarliestOperationStartTime() {
-        return theoreticalEarliest;
+    public double getTheoreticalLatestOperationStartTime() {
+        return theoreticalLatest;
     }
 
     @Override
-    public double getTheoreticalLatestOperationStartTime() {
-        return theoreticalLatest;
+    public void setTheoreticalLatestOperationStartTime(double latest) {
+        theoreticalLatest = latest;
     }
 
     @Override
@@ -93,40 +104,28 @@ public double getArrTime() {
         return arrTime;
     }
 
-    @Override
-    public double getEndTime() {
-        return endTime;
-    }
-
     @Override
     public void setArrTime(double arrTime) {
         this.arrTime = arrTime;
     }
 
     @Override
-    public void setEndTime(double endTime) {
-        this.endTime = endTime;
+    public double getEndTime() {
+        return endTime;
     }
 
     @Override
-    public TourActivity duplicate() {
-        return new DeliverService(this);
+    public void setEndTime(double endTime) {
+        this.endTime = endTime;
     }
 
     @Override
-    public Delivery getJob() {
-        return delivery;
-    }
-
-    public String toString() {
-        return "[type=" + getName() + "][locationId=" + getLocation().getId()
-            + "][size=" + getSize().toString()
-            + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
-            + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
+    public Capacity getSize() {
+        return capacity;
     }
 
     @Override
-    public Capacity getSize() {
-        return capacity;
+    public TourActivity duplicate() {
+        return new DeliverService(this);
     }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliverShipment.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliverShipment.java
index 297efae69..d00bb30e0 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliverShipment.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DeliverShipment.java
@@ -58,14 +58,11 @@ public Job getJob() {
         return shipment;
     }
 
-    @Override
-    public void setTheoreticalEarliestOperationStartTime(double earliest) {
-        this.earliest = earliest;
-    }
-
-    @Override
-    public void setTheoreticalLatestOperationStartTime(double latest) {
-        this.latest = latest;
+    public String toString() {
+        return "[type=" + getName() + "][locationId=" + getLocation().getId()
+            + "][size=" + getSize().toString()
+            + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
+            + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
     }
 
     @Override
@@ -83,11 +80,21 @@ public double getTheoreticalEarliestOperationStartTime() {
         return earliest;
     }
 
+    @Override
+    public void setTheoreticalEarliestOperationStartTime(double earliest) {
+        this.earliest = earliest;
+    }
+
     @Override
     public double getTheoreticalLatestOperationStartTime() {
         return latest;
     }
 
+    @Override
+    public void setTheoreticalLatestOperationStartTime(double latest) {
+        this.latest = latest;
+    }
+
     @Override
     public double getOperationTime() {
         return shipment.getDeliveryServiceTime();
@@ -99,13 +106,13 @@ public double getArrTime() {
     }
 
     @Override
-    public double getEndTime() {
-        return endTime;
+    public void setArrTime(double arrTime) {
+        this.arrTime = arrTime;
     }
 
     @Override
-    public void setArrTime(double arrTime) {
-        this.arrTime = arrTime;
+    public double getEndTime() {
+        return endTime;
     }
 
     @Override
@@ -114,19 +121,12 @@ public void setEndTime(double endTime) {
     }
 
     @Override
-    public TourActivity duplicate() {
-        return new DeliverShipment(this);
-    }
-
-    public String toString() {
-        return "[type=" + getName() + "][locationId=" + getLocation().getId()
-            + "][size=" + getSize().toString()
-            + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
-            + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
+    public Capacity getSize() {
+        return capacity;
     }
 
     @Override
-    public Capacity getSize() {
-        return capacity;
+    public TourActivity duplicate() {
+        return new DeliverShipment(this);
     }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/End.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/End.java
index 8c2ef5c07..2a34d3c19 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/End.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/End.java
@@ -23,36 +23,13 @@
 
 public final class End extends AbstractActivity implements TourActivity {
 
-    public static End newInstance(String locationId, double earliestArrival, double latestArrival) {
-        return new End(locationId, earliestArrival, latestArrival);
-    }
-
-    public static End copyOf(End end) {
-        return new End(end);
-    }
-
     private final static Capacity capacity = Capacity.Builder.newInstance().build();
-
-
     private double endTime = -1;
-
-
     private double theoretical_earliestOperationStartTime;
-
     private double theoretical_latestOperationStartTime;
-
     private double arrTime;
-
     private Location location;
 
-    public void setTheoreticalEarliestOperationStartTime(double theoreticalEarliestOperationStartTime) {
-        theoretical_earliestOperationStartTime = theoreticalEarliestOperationStartTime;
-    }
-
-    public void setTheoreticalLatestOperationStartTime(double theoreticalLatestOperationStartTime) {
-        theoretical_latestOperationStartTime = theoreticalLatestOperationStartTime;
-    }
-
     public End(Location location, double theoreticalStart, double theoreticalEnd) {
         super();
         this.location = location;
@@ -81,6 +58,31 @@ public End(End end) {
         setIndex(-2);
     }
 
+    public static End newInstance(String locationId, double earliestArrival, double latestArrival) {
+        return new End(locationId, earliestArrival, latestArrival);
+    }
+
+    public static End copyOf(End end) {
+        return new End(end);
+    }
+
+    public void setTheoreticalEarliestOperationStartTime(double theoreticalEarliestOperationStartTime) {
+        theoretical_earliestOperationStartTime = theoreticalEarliestOperationStartTime;
+    }
+
+    public void setTheoreticalLatestOperationStartTime(double theoreticalLatestOperationStartTime) {
+        theoretical_latestOperationStartTime = theoreticalLatestOperationStartTime;
+    }
+
+    @Override
+    public String toString() {
+        return "[type=" + getName() + "][location=" + location
+            + "][twStart=" + Activities.round(theoretical_earliestOperationStartTime)
+            + "][twEnd=" + Activities.round(theoretical_latestOperationStartTime) + "]";
+    }
+
+
+
     public double getTheoreticalEarliestOperationStartTime() {
         return theoretical_earliestOperationStartTime;
     }
@@ -112,13 +114,6 @@ public double getOperationTime() {
     }
 
 
-    @Override
-    public String toString() {
-        return "[type=" + getName() + "][location=" + location
-            + "][twStart=" + Activities.round(theoretical_earliestOperationStartTime)
-            + "][twEnd=" + Activities.round(theoretical_latestOperationStartTime) + "]";
-    }
-
     @Override
     public String getName() {
         return "end";
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupService.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupService.java
index 167f8677f..af52e66de 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupService.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupService.java
@@ -53,6 +53,18 @@ private PickupService(PickupService pickupActivity) {
         this.theoreticalLatest = pickupActivity.getTheoreticalLatestOperationStartTime();
     }
 
+    @Override
+    public Service getJob() {
+        return pickup;
+    }
+
+    public String toString() {
+        return "[type=" + getName() + "][locationId=" + getLocation().getId()
+            + "][size=" + getSize().toString()
+            + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
+            + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
+    }
+
     @Override
     public String getName() {
         return pickup.getType();
@@ -69,13 +81,13 @@ public double getTheoreticalEarliestOperationStartTime() {
     }
 
     @Override
-    public double getTheoreticalLatestOperationStartTime() {
-        return theoreticalLatest;
+    public void setTheoreticalEarliestOperationStartTime(double earliest) {
+        this.theoreticalEarliest = earliest;
     }
 
     @Override
-    public void setTheoreticalEarliestOperationStartTime(double earliest) {
-        this.theoreticalEarliest = earliest;
+    public double getTheoreticalLatestOperationStartTime() {
+        return theoreticalLatest;
     }
 
     @Override
@@ -93,41 +105,29 @@ public double getArrTime() {
         return arrTime;
     }
 
-    @Override
-    public double getEndTime() {
-        return depTime;
-    }
-
     @Override
     public void setArrTime(double arrTime) {
         this.arrTime = arrTime;
     }
 
     @Override
-    public void setEndTime(double endTime) {
-        this.depTime = endTime;
+    public double getEndTime() {
+        return depTime;
     }
 
     @Override
-    public TourActivity duplicate() {
-        return new PickupService(this);
+    public void setEndTime(double endTime) {
+        this.depTime = endTime;
     }
 
     @Override
-    public Service getJob() {
-        return pickup;
-    }
-
-    public String toString() {
-        return "[type=" + getName() + "][locationId=" + getLocation().getId()
-            + "][size=" + getSize().toString()
-            + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
-            + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
+    public Capacity getSize() {
+        return pickup.getSize();
     }
 
     @Override
-    public Capacity getSize() {
-        return pickup.getSize();
+    public TourActivity duplicate() {
+        return new PickupService(this);
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupShipment.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupShipment.java
index d1f32c3a2..80ab301b2 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupShipment.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/PickupShipment.java
@@ -23,7 +23,7 @@
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.job.Shipment;
 
-public final class PickupShipment extends AbstractActivity implements PickupActivity{
+public final class PickupShipment extends AbstractActivity implements PickupActivity {
 
     private Shipment shipment;
 
@@ -54,14 +54,11 @@ public Job getJob() {
         return shipment;
     }
 
-    @Override
-    public void setTheoreticalEarliestOperationStartTime(double earliest) {
-        this.earliest = earliest;
-    }
-
-    @Override
-    public void setTheoreticalLatestOperationStartTime(double latest) {
-        this.latest = latest;
+    public String toString() {
+        return "[type=" + getName() + "][locationId=" + getLocation().getId()
+            + "][size=" + getSize().toString()
+            + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
+            + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
     }
 
     @Override
@@ -79,11 +76,21 @@ public double getTheoreticalEarliestOperationStartTime() {
         return earliest;
     }
 
+    @Override
+    public void setTheoreticalEarliestOperationStartTime(double earliest) {
+        this.earliest = earliest;
+    }
+
     @Override
     public double getTheoreticalLatestOperationStartTime() {
         return latest;
     }
 
+    @Override
+    public void setTheoreticalLatestOperationStartTime(double latest) {
+        this.latest = latest;
+    }
+
     @Override
     public double getOperationTime() {
         return shipment.getPickupServiceTime();
@@ -95,13 +102,13 @@ public double getArrTime() {
     }
 
     @Override
-    public double getEndTime() {
-        return endTime;
+    public void setArrTime(double arrTime) {
+        this.arrTime = arrTime;
     }
 
     @Override
-    public void setArrTime(double arrTime) {
-        this.arrTime = arrTime;
+    public double getEndTime() {
+        return endTime;
     }
 
     @Override
@@ -110,20 +117,13 @@ public void setEndTime(double endTime) {
     }
 
     @Override
-    public TourActivity duplicate() {
-        return new PickupShipment(this);
-    }
-
-    public String toString() {
-        return "[type=" + getName() + "][locationId=" + getLocation().getId()
-            + "][size=" + getSize().toString()
-            + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
-            + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
+    public Capacity getSize() {
+        return shipment.getSize();
     }
 
     @Override
-    public Capacity getSize() {
-        return shipment.getSize();
+    public TourActivity duplicate() {
+        return new PickupShipment(this);
     }
 
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ServiceActivity.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ServiceActivity.java
index 76bc09cb0..5d71af5ac 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ServiceActivity.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/ServiceActivity.java
@@ -24,53 +24,12 @@
 
 public class ServiceActivity extends AbstractActivity implements TourActivity.JobActivity {
 
+    private final Service service;
     public double arrTime;
-
     public double endTime;
-
     private double theoreticalEarliest;
-
     private double theoreticalLatest;
 
-    /**
-     * @return the arrTime
-     */
-    public double getArrTime() {
-        return arrTime;
-    }
-
-    /**
-     * @param arrTime the arrTime to set
-     */
-    public void setArrTime(double arrTime) {
-        this.arrTime = arrTime;
-    }
-
-    /**
-     * @return the endTime
-     */
-    public double getEndTime() {
-        return endTime;
-    }
-
-    /**
-     * @param endTime the endTime to set
-     */
-    public void setEndTime(double endTime) {
-        this.endTime = endTime;
-    }
-
-    public static ServiceActivity copyOf(ServiceActivity serviceActivity) {
-        return new ServiceActivity(serviceActivity);
-    }
-
-    public static ServiceActivity newInstance(Service service) {
-        return new ServiceActivity(service);
-    }
-
-
-    private final Service service;
-
     protected ServiceActivity(Service service) {
         this.service = service;
     }
@@ -84,6 +43,18 @@ protected ServiceActivity(ServiceActivity serviceActivity) {
         this.theoreticalLatest = serviceActivity.getTheoreticalLatestOperationStartTime();
     }
 
+    public static ServiceActivity copyOf(ServiceActivity serviceActivity) {
+        return new ServiceActivity(serviceActivity);
+    }
+
+    public static ServiceActivity newInstance(Service service) {
+        return new ServiceActivity(service);
+    }
+
+    @Override
+    public Service getJob() {
+        return service;
+    }
 
     /* (non-Javadoc)
      * @see java.lang.Object#hashCode()
@@ -116,12 +87,26 @@ public boolean equals(Object obj) {
         return true;
     }
 
-    public double getTheoreticalEarliestOperationStartTime() {
-        return theoreticalEarliest;
+    @Override
+    public String toString() {
+        return "[type=" + getName() + "][locationId=" + getLocation().getId()
+            + "][size=" + getSize().toString()
+            + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
+            + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
     }
 
-    public double getTheoreticalLatestOperationStartTime() {
-        return theoreticalLatest;
+    @Override
+    public String getName() {
+        return service.getType();
+    }
+
+    @Override
+    public Location getLocation() {
+        return service.getLocation();
+    }
+
+    public double getTheoreticalEarliestOperationStartTime() {
+        return theoreticalEarliest;
     }
 
     @Override
@@ -129,6 +114,10 @@ public void setTheoreticalEarliestOperationStartTime(double earliest) {
         theoreticalEarliest = earliest;
     }
 
+    public double getTheoreticalLatestOperationStartTime() {
+        return theoreticalLatest;
+    }
+
     @Override
     public void setTheoreticalLatestOperationStartTime(double latest) {
         theoreticalLatest = latest;
@@ -139,29 +128,37 @@ public double getOperationTime() {
         return service.getServiceDuration();
     }
 
-    @Override
-    public Location getLocation() {
-        return service.getLocation();
+    /**
+     * @return the arrTime
+     */
+    public double getArrTime() {
+        return arrTime;
     }
 
-
-    @Override
-    public Service getJob() {
-        return service;
+    /**
+     * @param arrTime the arrTime to set
+     */
+    public void setArrTime(double arrTime) {
+        this.arrTime = arrTime;
     }
 
+    /**
+     * @return the endTime
+     */
+    public double getEndTime() {
+        return endTime;
+    }
 
-    @Override
-    public String toString() {
-        return "[type=" + getName() + "][locationId=" + getLocation().getId()
-            + "][size=" + getSize().toString()
-            + "][twStart=" + Activities.round(getTheoreticalEarliestOperationStartTime())
-            + "][twEnd=" + Activities.round(getTheoreticalLatestOperationStartTime()) + "]";
+    /**
+     * @param endTime the endTime to set
+     */
+    public void setEndTime(double endTime) {
+        this.endTime = endTime;
     }
 
     @Override
-    public String getName() {
-        return service.getType();
+    public Capacity getSize() {
+        return service.getSize();
     }
 
     @Override
@@ -169,10 +166,5 @@ public TourActivity duplicate() {
         return new ServiceActivity(this);
     }
 
-    @Override
-    public Capacity getSize() {
-        return service.getSize();
-    }
-
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/Start.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/Start.java
index 2b193ecf6..895710a47 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/Start.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/Start.java
@@ -27,25 +27,11 @@
     public final static String ACTIVITY_NAME = "start";
 
     private final static Capacity capacity = Capacity.Builder.newInstance().build();
-
-    public static Start newInstance(String locationId, double theoreticalStart, double theoreticalEnd) {
-        return new Start(locationId, theoreticalStart, theoreticalEnd);
-    }
-
-    public static Start copyOf(Start start) {
-        return new Start(start);
-    }
-
     private String locationId;
-
     private double theoretical_earliestOperationStartTime;
-
     private double theoretical_latestOperationStartTime;
-
     private double endTime;
-
     private double arrTime;
-
     private Location location;
 
     private Start(String locationId, double theoreticalStart, double theoreticalEnd) {
@@ -74,6 +60,21 @@ private Start(Start start) {
         setIndex(-1);
     }
 
+    public static Start newInstance(String locationId, double theoreticalStart, double theoreticalEnd) {
+        return new Start(locationId, theoreticalStart, theoreticalEnd);
+    }
+
+    public static Start copyOf(Start start) {
+        return new Start(start);
+    }
+
+    @Override
+    public String toString() {
+        return "[type=" + getName() + "][location=" + location
+            + "][twStart=" + Activities.round(theoretical_earliestOperationStartTime)
+            + "][twEnd=" + Activities.round(theoretical_latestOperationStartTime) + "]";
+    }
+
     public double getTheoreticalEarliestOperationStartTime() {
         return theoretical_earliestOperationStartTime;
     }
@@ -107,12 +108,6 @@ public double getOperationTime() {
         return 0.0;
     }
 
-    @Override
-    public String toString() {
-        return "[type=" + getName() + "][location=" + location
-            + "][twStart=" + Activities.round(theoretical_earliestOperationStartTime)
-            + "][twEnd=" + Activities.round(theoretical_latestOperationStartTime) + "]";
-    }
 
     @Override
     public String getName() {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindow.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindow.java
index 7ded1e0b3..8d9443877 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindow.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindow.java
@@ -25,21 +25,8 @@
 
 public class TimeWindow {
 
-    /**
-     * Returns new instance of TimeWindow.
-     *
-     * @param start
-     * @param end
-     * @return TimeWindow
-     * @throw IllegalArgumentException either if start or end < 0.0 or end < start
-     */
-    public static TimeWindow newInstance(double start, double end) {
-        return new TimeWindow(start, end);
-    }
-
     private final double start;
     private final double end;
-
     /**
      * Constructs the timeWindow
      *
@@ -57,6 +44,18 @@ public TimeWindow(double start, double end) {
         this.end = end;
     }
 
+    /**
+     * Returns new instance of TimeWindow.
+     *
+     * @param start
+     * @param end
+     * @return TimeWindow
+     * @throw IllegalArgumentException either if start or end < 0.0 or end < start
+     */
+    public static TimeWindow newInstance(double start, double end) {
+        return new TimeWindow(start, end);
+    }
+
     /**
      * Returns startTime of TimeWindow.
      *
@@ -75,11 +74,6 @@ public double getEnd() {
         return end;
     }
 
-    @Override
-    public String toString() {
-        return "[start=" + start + "][end=" + end + "]";
-    }
-
     @Override
     public int hashCode() {
         final int prime = 31;
@@ -112,5 +106,10 @@ public boolean equals(Object obj) {
         return true;
     }
 
+    @Override
+    public String toString() {
+        return "[start=" + start + "][end=" + end + "]";
+    }
+
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindowsImpl.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindowsImpl.java
index 84b8f37c9..64eb05788 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindowsImpl.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindowsImpl.java
@@ -29,15 +29,15 @@
 
     private Collection<TimeWindow> timeWindows = new ArrayList<TimeWindow>();
 
-    public void add(TimeWindow timeWindow){
-        for(TimeWindow tw : timeWindows){
-            if(timeWindow.getStart() > tw.getStart() && timeWindow.getStart() < tw.getEnd()){
+    public void add(TimeWindow timeWindow) {
+        for (TimeWindow tw : timeWindows) {
+            if (timeWindow.getStart() > tw.getStart() && timeWindow.getStart() < tw.getEnd()) {
                 throw new IllegalArgumentException("time-windows cannot overlap each other. overlap: " + tw + ", " + timeWindow);
             }
-            if(timeWindow.getEnd() > tw.getStart() && timeWindow.getEnd() < tw.getEnd()){
+            if (timeWindow.getEnd() > tw.getStart() && timeWindow.getEnd() < tw.getEnd()) {
                 throw new IllegalArgumentException("time-windows cannot overlap each other. overlap: " + tw + ", " + timeWindow);
             }
-            if(timeWindow.getStart() <= tw.getStart() && timeWindow.getEnd() >= tw.getEnd()){
+            if (timeWindow.getStart() <= tw.getStart() && timeWindow.getEnd() >= tw.getEnd()) {
                 throw new IllegalArgumentException("time-windows cannot overlap each other. overlap: " + tw + ", " + timeWindow);
             }
         }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TourActivities.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TourActivities.java
index 949e70fda..f86df482b 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TourActivities.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TourActivities.java
@@ -29,48 +29,8 @@
 
 public class TourActivities {
 
-    public static TourActivities copyOf(TourActivities tourActivities) {
-        return new TourActivities(tourActivities);
-    }
-
-    public static class ReverseActivityIterator implements Iterator<TourActivity> {
-
-        private List<TourActivity> acts;
-        private int currentIndex;
-
-        public ReverseActivityIterator(List<TourActivity> acts) {
-            super();
-            this.acts = acts;
-            currentIndex = acts.size() - 1;
-        }
-
-        @Override
-        public boolean hasNext() {
-            if (currentIndex >= 0) return true;
-            return false;
-        }
-
-        @Override
-        public TourActivity next() {
-            TourActivity act = acts.get(currentIndex);
-            currentIndex--;
-            return act;
-        }
-
-        public void reset() {
-            currentIndex = acts.size() - 1;
-        }
-
-        @Override
-        public void remove() {
-            throw new UnsupportedOperationException();
-        }
-    }
-
     private final ArrayList<TourActivity> tourActivities = new ArrayList<TourActivity>();
-
     private final Set<Job> jobs = new HashSet<Job>();
-
     private ReverseActivityIterator backward;
 
     private TourActivities(TourActivities tour2copy) {
@@ -81,12 +41,45 @@ private TourActivities(TourActivities tour2copy) {
         }
     }
 
+    public List<TourActivity> getActivities() {
+        return Collections.unmodifiableList(tourActivities);
+    }
+
     public TourActivities() {
 
     }
 
-    public List<TourActivity> getActivities() {
-        return Collections.unmodifiableList(tourActivities);
+    public static TourActivities copyOf(TourActivities tourActivities) {
+        return new TourActivities(tourActivities);
+    }
+
+    /**
+     * Inserts the specified activity add the specified insertionIndex. Shifts the element currently at that position (if any) and
+     * any subsequent elements to the right (adds one to their indices).
+     * <p>If specified activity instanceof JobActivity, it adds job to jobList.
+     * <p>If insertionIndex > tourActivitiies.size(), it just adds the specified act at the end.
+     *
+     * @param insertionIndex index where activity needs to be inserted
+     * @param act            activity to be inserted
+     * @throws IndexOutOfBoundsException if insertionIndex < 0;
+     */
+    public void addActivity(int insertionIndex, TourActivity act) {
+
+        assert insertionIndex >= 0 : "insertionIndex < 0, this cannot be";
+
+        /*
+         * if 1 --> between start and act(0) --> act(0)
+         * if 2 && 2 <= acts.size --> between act(0) and act(1) --> act(1)
+         * if 2 && 2 > acts.size --> at actEnd
+         * ...
+         *
+         */
+        if (insertionIndex < tourActivities.size()) {
+            tourActivities.add(insertionIndex, act);
+        } else if (insertionIndex >= tourActivities.size()) {
+            tourActivities.add(act);
+        }
+        addJob(act);
     }
 
     public Iterator<TourActivity> iterator() {
@@ -146,7 +139,6 @@ public boolean removeJob(Job job) {
     }
 
 
-
     /**
      * Removes activity from this activity sequence. Removes its corresponding job as well, if there are no other activities
      * related to this job.
@@ -180,34 +172,12 @@ public boolean removeActivity(TourActivity activity) {
         return actRemoved;
     }
 
-
-    /**
-     * Inserts the specified activity add the specified insertionIndex. Shifts the element currently at that position (if any) and
-     * any subsequent elements to the right (adds one to their indices).
-     * <p>If specified activity instanceof JobActivity, it adds job to jobList.
-     * <p>If insertionIndex > tourActivitiies.size(), it just adds the specified act at the end.
-     *
-     * @param insertionIndex index where activity needs to be inserted
-     * @param act            activity to be inserted
-     * @throws IndexOutOfBoundsException if insertionIndex < 0;
-     */
-    public void addActivity(int insertionIndex, TourActivity act) {
-
-        assert insertionIndex >= 0 : "insertionIndex < 0, this cannot be";
-
-		/*
-         * if 1 --> between start and act(0) --> act(0)
-		 * if 2 && 2 <= acts.size --> between act(0) and act(1) --> act(1)
-		 * if 2 && 2 > acts.size --> at actEnd
-		 * ...
-		 *
-		 */
-        if (insertionIndex < tourActivities.size()) {
-            tourActivities.add(insertionIndex, act);
-        } else if (insertionIndex >= tourActivities.size()) {
-            tourActivities.add(act);
+    private void addJob(TourActivity act) {
+        if (act instanceof JobActivity) {
+            Job job = ((JobActivity) act).getJob();
+//            if(job instanceof Service) assert !jobs.contains(job);
+            jobs.add(job);
         }
-        addJob(act);
     }
 
     /**
@@ -224,14 +194,6 @@ public void addActivity(TourActivity act) {
         addJob(act);
     }
 
-    private void addJob(TourActivity act) {
-        if (act instanceof JobActivity) {
-            Job job = ((JobActivity) act).getJob();
-//            if(job instanceof Service) assert !jobs.contains(job);
-            jobs.add(job);
-        }
-    }
-
     /**
      * Returns number of jobs assiciated to activities in this activity sequence.
      *
@@ -247,5 +209,39 @@ public int jobSize() {
         return backward;
     }
 
+    public static class ReverseActivityIterator implements Iterator<TourActivity> {
+
+        private List<TourActivity> acts;
+        private int currentIndex;
+
+        public ReverseActivityIterator(List<TourActivity> acts) {
+            super();
+            this.acts = acts;
+            currentIndex = acts.size() - 1;
+        }
+
+        @Override
+        public boolean hasNext() {
+            if (currentIndex >= 0) return true;
+            return false;
+        }
+
+        @Override
+        public TourActivity next() {
+            TourActivity act = acts.get(currentIndex);
+            currentIndex--;
+            return act;
+        }
+
+        @Override
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+
+        public void reset() {
+            currentIndex = acts.size() - 1;
+        }
+    }
+
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TourActivity.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TourActivity.java
index a6aa070fd..d2c159103 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TourActivity.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TourActivity.java
@@ -31,28 +31,6 @@
  */
 public interface TourActivity extends HasIndex {
 
-	public void setTheoreticalEarliestOperationStartTime(double earliest);
-
-	public void setTheoreticalLatestOperationStartTime(double latest);
-
-    /**
-     * Basic interface of job-activies.
-     * <p>
-     * <p>A job activity is related to a {@link Job}.
-     *
-     * @author schroeder
-     */
-    public interface JobActivity extends TourActivity {
-
-        /**
-         * Returns the job that is involved with this activity.
-         *
-         * @return job
-         */
-        public Job getJob();
-
-    }
-
     /**
      * Returns the name of this activity.
      *
@@ -75,6 +53,8 @@
      */
     public abstract double getTheoreticalEarliestOperationStartTime();
 
+    public void setTheoreticalEarliestOperationStartTime(double earliest);
+
     /**
      * Returns the theoretical latest operation start time, which is the time that is just allowed
      * (not later) to start this activity, that is for example <code>service.getTimeWindow().getEnd()</code>.
@@ -83,6 +63,8 @@
      */
     public abstract double getTheoreticalLatestOperationStartTime();
 
+    public void setTheoreticalLatestOperationStartTime(double latest);
+
     /**
      * Returns the operation-time this activity takes.
      * <p>
@@ -101,18 +83,18 @@
     public abstract double getArrTime();
 
     /**
-     * Returns end-time of this activity.
+     * Sets the arrival time of that activity.
      *
-     * @return end time
+     * @param arrTime
      */
-    public abstract double getEndTime();
+    public abstract void setArrTime(double arrTime);
 
     /**
-     * Sets the arrival time of that activity.
+     * Returns end-time of this activity.
      *
-     * @param arrTime
+     * @return end time
      */
-    public abstract void setArrTime(double arrTime);
+    public abstract double getEndTime();
 
     /**
      * Sets the end-time of this activity.
@@ -136,4 +118,22 @@
      */
     public abstract TourActivity duplicate();
 
+    /**
+     * Basic interface of job-activies.
+     * <p>
+     * <p>A job activity is related to a {@link Job}.
+     *
+     * @author schroeder
+     */
+    public interface JobActivity extends TourActivity {
+
+        /**
+         * Returns the job that is involved with this activity.
+         *
+         * @return job
+         */
+        public Job getJob();
+
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/InfiniteVehicles.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/InfiniteVehicles.java
index 5fbdb93c1..1fe6e91e0 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/InfiniteVehicles.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/InfiniteVehicles.java
@@ -18,8 +18,6 @@
 package com.graphhopper.jsprit.core.problem.vehicle;
 
 
-
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -29,7 +27,6 @@
 import java.util.Map;
 
 
-
 class InfiniteVehicles implements VehicleFleetManager {
 
     private static Logger logger = LoggerFactory.getLogger(InfiniteVehicles.class);
@@ -43,11 +40,6 @@ public InfiniteVehicles(Collection<Vehicle> vehicles) {
         logger.debug("initialise " + this);
     }
 
-    @Override
-    public String toString() {
-        return "[name=infiniteVehicle]";
-    }
-
     private void extractTypes(Collection<Vehicle> vehicles) {
         for (Vehicle v : vehicles) {
 //            VehicleTypeKey typeKey = new VehicleTypeKey(v.getType().getTypeId(), v.getStartLocation().getId(), v.getEndLocation().getId(), v.getEarliestDeparture(), v.getLatestArrival(), v.getSkills(), v.isReturnToDepot());
@@ -56,6 +48,10 @@ private void extractTypes(Collection<Vehicle> vehicles) {
         }
     }
 
+    @Override
+    public String toString() {
+        return "[name=infiniteVehicle]";
+    }
 
     @Override
     public void lock(Vehicle vehicle) {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleFleetManagerImpl.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleFleetManagerImpl.java
index 5741594aa..35b270836 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleFleetManagerImpl.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleFleetManagerImpl.java
@@ -28,58 +28,11 @@
 
 class VehicleFleetManagerImpl implements VehicleFleetManager {
 
-    public VehicleFleetManagerImpl newInstance(Collection<Vehicle> vehicles) {
-        return new VehicleFleetManagerImpl(vehicles);
-    }
-
-    static class TypeContainer {
-
-        private ArrayList<Vehicle> vehicleList;
-
-        private int index = 0;
-
-        TypeContainer() {
-            super();
-            vehicleList = new ArrayList<Vehicle>();
-        }
-
-        void add(Vehicle vehicle) {
-            if (vehicleList.contains(vehicle)) {
-                throw new IllegalStateException("cannot add vehicle twice " + vehicle.getId());
-            }
-            vehicleList.add(vehicle);
-        }
-
-        void remove(Vehicle vehicle) {
-            vehicleList.remove(vehicle);
-        }
-
-        Vehicle getVehicle() {
-            if(index >= vehicleList.size()) index = 0;
-            Vehicle vehicle = vehicleList.get(index);
-            return vehicle;
-        }
-
-        void incIndex(){
-            index++;
-        }
-
-        boolean isEmpty() {
-            return vehicleList.isEmpty();
-        }
-
-    }
-
     private static Logger logger = LoggerFactory.getLogger(VehicleFleetManagerImpl.class);
-
     private Collection<Vehicle> vehicles;
-
     private TypeContainer[] vehicleTypes;
-
     private boolean[] locked;
-
     private Vehicle[] vehicleArr;
-
     private Random random;
 
     VehicleFleetManagerImpl(Collection<Vehicle> vehicles) {
@@ -90,34 +43,33 @@ boolean isEmpty() {
         vehicleArr = new Vehicle[arrSize];
     }
 
+    public VehicleFleetManagerImpl newInstance(Collection<Vehicle> vehicles) {
+        return new VehicleFleetManagerImpl(vehicles);
+    }
+
     void setRandom(Random random) {
         this.random = random;
     }
 
-    void init(){
+    void init() {
         initializeVehicleTypes();
-        logger.debug("initialise {}",this);
-    }
-
-    @Override
-    public String toString() {
-        return "[name=finiteVehicles]";
+        logger.debug("initialise {}", this);
     }
 
     private void initializeVehicleTypes() {
         int maxTypeIndex = 0;
-        for(Vehicle v : vehicles){
-            if(v.getVehicleTypeIdentifier().getIndex() > maxTypeIndex){
+        for (Vehicle v : vehicles) {
+            if (v.getVehicleTypeIdentifier().getIndex() > maxTypeIndex) {
                 maxTypeIndex = v.getVehicleTypeIdentifier().getIndex();
             }
         }
-        vehicleTypes = new TypeContainer[maxTypeIndex+1];
-        for(int i=0;i< vehicleTypes.length;i++){
+        vehicleTypes = new TypeContainer[maxTypeIndex + 1];
+        for (int i = 0; i < vehicleTypes.length; i++) {
             TypeContainer typeContainer = new TypeContainer();
             vehicleTypes[i] = typeContainer;
         }
         for (Vehicle v : vehicles) {
-            vehicleArr[v.getIndex()]=v;
+            vehicleArr[v.getIndex()] = v;
             addVehicle(v);
         }
     }
@@ -129,46 +81,9 @@ private void addVehicle(Vehicle v) {
         vehicleTypes[v.getVehicleTypeIdentifier().getIndex()].add(v);
     }
 
-    private void removeVehicle(Vehicle v) {
-        vehicleTypes[v.getVehicleTypeIdentifier().getIndex()].remove(v);
-    }
-
-
-    /**
-     * Returns a collection of available vehicles.
-     * <p>
-     * <p>If there is no vehicle with a certain type and location anymore, it looks up whether a penalty vehicle has been specified with
-     * this type and location. If so, it returns this penalty vehicle. If not, no vehicle with this type and location is returned.
-     */
-    @Override
-    public Collection<Vehicle> getAvailableVehicles() {
-        List<Vehicle> vehicles = new ArrayList<Vehicle>();
-        for(int i=0;i< vehicleTypes.length;i++){
-            if(!vehicleTypes[i].isEmpty()){
-                vehicles.add(vehicleTypes[i].getVehicle());
-            }
-        }
-        return vehicles;
-    }
-
     @Override
-    public Collection<Vehicle> getAvailableVehicles(Vehicle withoutThisType) {
-        List<Vehicle> vehicles = new ArrayList<Vehicle>();
-        for(int i=0;i< vehicleTypes.length;i++){
-            if(!vehicleTypes[i].isEmpty() && i != withoutThisType.getVehicleTypeIdentifier().getIndex()){
-                vehicles.add(vehicleTypes[i].getVehicle());
-            }
-        }
-        return vehicles;
-    }
-
-
-    @Override
-    public Vehicle getAvailableVehicle(VehicleTypeKey vehicleTypeIdentifier) {
-        if(!vehicleTypes[vehicleTypeIdentifier.getIndex()].isEmpty()){
-            return vehicleTypes[vehicleTypeIdentifier.getIndex()].getVehicle();
-        }
-        return null;
+    public String toString() {
+        return "[name=finiteVehicles]";
     }
 
     /* (non-Javadoc)
@@ -179,15 +94,18 @@ public void lock(Vehicle vehicle) {
         if (vehicles.isEmpty() || vehicle instanceof VehicleImpl.NoVehicle) {
             return;
         }
-        if(locked[vehicle.getIndex()]){
+        if (locked[vehicle.getIndex()]) {
             throw new IllegalStateException("cannot lock vehicle twice " + vehicle.getId());
-        }
-        else{
+        } else {
             locked[vehicle.getIndex()] = true;
             removeVehicle(vehicle);
         }
     }
 
+    private void removeVehicle(Vehicle v) {
+        vehicleTypes[v.getVehicleTypeIdentifier().getIndex()].remove(v);
+    }
+
     /* (non-Javadoc)
      * @see org.matsim.contrib.freight.vrp.basics.VehicleFleetManager#unlock(org.matsim.contrib.freight.vrp.basics.Vehicle)
      */
@@ -213,14 +131,88 @@ public boolean isLocked(Vehicle vehicle) {
      */
     @Override
     public void unlockAll() {
-        for(int i=0;i<vehicleArr.length;i++){
-            if(locked[i]){
+        for (int i = 0; i < vehicleArr.length; i++) {
+            if (locked[i]) {
                 unlock(vehicleArr[i]);
             }
         }
-        for(int i=0;i<vehicleTypes.length;i++){
+        for (int i = 0; i < vehicleTypes.length; i++) {
             vehicleTypes[i].incIndex();
         }
     }
 
+    /**
+     * Returns a collection of available vehicles.
+     * <p>
+     * <p>If there is no vehicle with a certain type and location anymore, it looks up whether a penalty vehicle has been specified with
+     * this type and location. If so, it returns this penalty vehicle. If not, no vehicle with this type and location is returned.
+     */
+    @Override
+    public Collection<Vehicle> getAvailableVehicles() {
+        List<Vehicle> vehicles = new ArrayList<Vehicle>();
+        for (int i = 0; i < vehicleTypes.length; i++) {
+            if (!vehicleTypes[i].isEmpty()) {
+                vehicles.add(vehicleTypes[i].getVehicle());
+            }
+        }
+        return vehicles;
+    }
+
+    @Override
+    public Collection<Vehicle> getAvailableVehicles(Vehicle withoutThisType) {
+        List<Vehicle> vehicles = new ArrayList<Vehicle>();
+        for (int i = 0; i < vehicleTypes.length; i++) {
+            if (!vehicleTypes[i].isEmpty() && i != withoutThisType.getVehicleTypeIdentifier().getIndex()) {
+                vehicles.add(vehicleTypes[i].getVehicle());
+            }
+        }
+        return vehicles;
+    }
+
+    @Override
+    public Vehicle getAvailableVehicle(VehicleTypeKey vehicleTypeIdentifier) {
+        if (!vehicleTypes[vehicleTypeIdentifier.getIndex()].isEmpty()) {
+            return vehicleTypes[vehicleTypeIdentifier.getIndex()].getVehicle();
+        }
+        return null;
+    }
+
+    static class TypeContainer {
+
+        private ArrayList<Vehicle> vehicleList;
+
+        private int index = 0;
+
+        TypeContainer() {
+            super();
+            vehicleList = new ArrayList<Vehicle>();
+        }
+
+        void add(Vehicle vehicle) {
+            if (vehicleList.contains(vehicle)) {
+                throw new IllegalStateException("cannot add vehicle twice " + vehicle.getId());
+            }
+            vehicleList.add(vehicle);
+        }
+
+        void remove(Vehicle vehicle) {
+            vehicleList.remove(vehicle);
+        }
+
+        Vehicle getVehicle() {
+            if (index >= vehicleList.size()) index = 0;
+            Vehicle vehicle = vehicleList.get(index);
+            return vehicle;
+        }
+
+        void incIndex() {
+            index++;
+        }
+
+        boolean isEmpty() {
+            return vehicleList.isEmpty();
+        }
+
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleImpl.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleImpl.java
index 0731abf21..722a8ecba 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleImpl.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleImpl.java
@@ -36,6 +36,104 @@
 public class VehicleImpl extends AbstractVehicle {
 
 
+    private final String id;
+    private final VehicleType type;
+    private final double earliestDeparture;
+    private final double latestArrival;
+    private final boolean returnToDepot;
+    private final Skills skills;
+    private final Location endLocation;
+    private final Location startLocation;
+    private final Break aBreak;
+
+    private VehicleImpl(Builder builder) {
+        setUserData(builder.userData);
+        id = builder.id;
+        type = builder.type;
+        earliestDeparture = builder.earliestStart;
+        latestArrival = builder.latestArrival;
+        returnToDepot = builder.returnToDepot;
+        skills = builder.skills;
+        endLocation = builder.endLocation;
+        startLocation = builder.startLocation;
+        aBreak = builder.aBreak;
+        //        setVehicleIdentifier(new VehicleTypeKey(type.getTypeId(),startLocation.getId(),endLocation.getId(),earliestDeparture,latestArrival,skills));
+        setVehicleIdentifier(new VehicleTypeKey(type.getTypeId(), startLocation.getId(), endLocation.getId(), earliestDeparture, latestArrival, skills, returnToDepot));
+    }
+
+    /**
+     * Returns empty/noVehicle which is a vehicle having no capacity, no type and no reasonable id.
+     * <p>
+     * <p>NoVehicle has id="noVehicle" and extends {@link VehicleImpl}
+     *
+     * @return emptyVehicle
+     */
+    public static NoVehicle createNoVehicle() {
+        return new NoVehicle();
+    }
+
+    /* (non-Javadoc)
+     * @see java.lang.Object#hashCode()
+     */
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((id == null) ? 0 : id.hashCode());
+        result = prime * result + ((type == null) ? 0 : type.hashCode());
+        return result;
+    }
+
+    /**
+     * Two vehicles are equal if they have the same id and if their types are equal.
+     */
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        VehicleImpl other = (VehicleImpl) obj;
+        if (id == null) {
+            if (other.id != null)
+                return false;
+        } else if (!id.equals(other.id))
+            return false;
+        if (type == null) {
+            if (other.type != null)
+                return false;
+        } else if (!type.equals(other.type))
+            return false;
+        return true;
+    }
+
+    /**
+     * Returns String with attributes of this vehicle
+     * <p>
+     * <p>String has the following format [attr1=val1][attr2=val2]...[attrn=valn]
+     */
+    @Override
+    public String toString() {
+        return "[id=" + id + "]" +
+            "[type=" + type + "]" +
+            "[startLocation=" + startLocation + "]" +
+            "[endLocation=" + endLocation + "]" +
+            "[isReturnToDepot=" + isReturnToDepot() + "]" +
+            "[skills=" + skills + "]";
+    }
+
+    @Override
+    public double getEarliestDeparture() {
+        return earliestDeparture;
+    }
+
+    @Override
+    public double getLatestArrival() {
+        return latestArrival;
+    }
+
     /**
      * Extension of {@link VehicleImpl} representing an unspecified vehicle with the id 'noVehicle'
      * (to avoid null).
@@ -140,6 +238,16 @@ private Builder(String id) {
             if (id == null) throw new IllegalArgumentException("Vehicle id must not be null.");
         }
 
+        /**
+         * Returns new instance of vehicle builder.
+         *
+         * @param vehicleId the id of the vehicle which must be a unique identifier among all vehicles
+         * @return vehicle builder
+         */
+        public static Builder newInstance(String vehicleId) {
+            return new Builder(vehicleId);
+        }
+
         /**
          * Sets the {@link VehicleType}.<br>
          *
@@ -183,8 +291,7 @@ public Builder setUserData(Object userData) {
          * If returnToDepot is false, the end-location of the vehicle is
          * endogenous.
          *
-         * @param returnToDepot
-         *            true if vehicle need to return to depot, otherwise false
+         * @param returnToDepot true if vehicle need to return to depot, otherwise false
          * @return this builder
          */
         public Builder setReturnToDepot(boolean returnToDepot) {
@@ -262,7 +369,7 @@ public Builder addSkill(String skill) {
          *
          * @return vehicle
          * @throws IllegalArgumentException if both locationId and locationCoord is not set or (endLocationCoord!=null AND returnToDepot=false)
-         *                               or (endLocationId!=null AND returnToDepot=false)
+         *                                  or (endLocationId!=null AND returnToDepot=false)
          */
         public VehicleImpl build() {
             if (latestArrival < earliestStart)
@@ -281,16 +388,6 @@ public VehicleImpl build() {
             return new VehicleImpl(this);
         }
 
-        /**
-         * Returns new instance of vehicle builder.
-         *
-         * @param vehicleId the id of the vehicle which must be a unique identifier among all vehicles
-         * @return vehicle builder
-         */
-        public static Builder newInstance(String vehicleId) {
-            return new Builder(vehicleId);
-        }
-
         public Builder addSkills(Skills skills) {
             this.skillBuilder.addAllSkills(skills.values());
             return this;
@@ -302,76 +399,6 @@ public Builder setBreak(Break aBreak) {
         }
     }
 
-    /**
-     * Returns empty/noVehicle which is a vehicle having no capacity, no type and no reasonable id.
-     * <p>
-     * <p>NoVehicle has id="noVehicle" and extends {@link VehicleImpl}
-     *
-     * @return emptyVehicle
-     */
-    public static NoVehicle createNoVehicle() {
-        return new NoVehicle();
-    }
-
-    private final String id;
-
-    private final VehicleType type;
-
-    private final double earliestDeparture;
-
-    private final double latestArrival;
-
-    private final boolean returnToDepot;
-
-    private final Skills skills;
-
-    private final Location endLocation;
-
-    private final Location startLocation;
-
-    private final Break aBreak;
-
-    private VehicleImpl(Builder builder) {
-        setUserData(builder.userData);
-        id = builder.id;
-        type = builder.type;
-        earliestDeparture = builder.earliestStart;
-        latestArrival = builder.latestArrival;
-        returnToDepot = builder.returnToDepot;
-        skills = builder.skills;
-        endLocation = builder.endLocation;
-        startLocation = builder.startLocation;
-        aBreak = builder.aBreak;
-        //        setVehicleIdentifier(new VehicleTypeKey(type.getTypeId(),startLocation.getId(),endLocation.getId(),earliestDeparture,latestArrival,skills));
-        setVehicleIdentifier(new VehicleTypeKey(type.getTypeId(), startLocation.getId(), endLocation.getId(), earliestDeparture, latestArrival, skills, returnToDepot));
-    }
-
-    /**
-     * Returns String with attributes of this vehicle
-     * <p>
-     * <p>String has the following format [attr1=val1][attr2=val2]...[attrn=valn]
-     */
-    @Override
-    public String toString() {
-        return "[id=" + id + "]" +
-            "[type=" + type + "]" +
-            "[startLocation=" + startLocation + "]" +
-            "[endLocation=" + endLocation + "]" +
-            "[isReturnToDepot=" + isReturnToDepot() + "]" +
-            "[skills=" + skills + "]";
-    }
-
-
-    @Override
-    public double getEarliestDeparture() {
-        return earliestDeparture;
-    }
-
-    @Override
-    public double getLatestArrival() {
-        return latestArrival;
-    }
-
     @Override
     public VehicleType getType() {
         return type;
@@ -407,42 +434,6 @@ public Break getBreak() {
         return aBreak;
     }
 
-    /* (non-Javadoc)
-     * @see java.lang.Object#hashCode()
-     */
-    @Override
-    public int hashCode() {
-        final int prime = 31;
-        int result = 1;
-        result = prime * result + ((id == null) ? 0 : id.hashCode());
-        result = prime * result + ((type == null) ? 0 : type.hashCode());
-        return result;
-    }
-
-    /**
-     * Two vehicles are equal if they have the same id and if their types are equal.
-     */
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj)
-            return true;
-        if (obj == null)
-            return false;
-        if (getClass() != obj.getClass())
-            return false;
-        VehicleImpl other = (VehicleImpl) obj;
-        if (id == null) {
-            if (other.id != null)
-                return false;
-        } else if (!id.equals(other.id))
-            return false;
-        if (type == null) {
-            if (other.type != null)
-                return false;
-        } else if (!type.equals(other.type))
-            return false;
-        return true;
-    }
 
 }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeImpl.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeImpl.java
index 931d61870..1c98dd617 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeImpl.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeImpl.java
@@ -29,6 +29,96 @@
  */
 public class VehicleTypeImpl implements VehicleType {
 
+    private final String typeId;
+    private final int capacity;
+    private final String profile;
+    private final VehicleTypeImpl.VehicleCostParams vehicleCostParams;
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof VehicleTypeImpl)) return false;
+
+        VehicleTypeImpl that = (VehicleTypeImpl) o;
+
+        if (Double.compare(that.maxVelocity, maxVelocity) != 0) return false;
+        if (!typeId.equals(that.typeId)) return false;
+        if (profile != null ? !profile.equals(that.profile) : that.profile != null) return false;
+        if (!vehicleCostParams.equals(that.vehicleCostParams)) return false;
+        return capacityDimensions.equals(that.capacityDimensions);
+    }
+
+    private final Capacity capacityDimensions;
+    private final double maxVelocity;
+    private Object userData;
+
+    /**
+     * priv constructor constructing vehicle-type
+     *
+     * @param builder
+     */
+    private VehicleTypeImpl(VehicleTypeImpl.Builder builder) {
+        this.userData = builder.userData;
+        typeId = builder.id;
+        capacity = builder.capacity;
+        maxVelocity = builder.maxVelo;
+        vehicleCostParams = new VehicleCostParams(builder.fixedCost, builder.perTime, builder.perDistance, builder.perWaitingTime, builder.perServiceTime);
+        capacityDimensions = builder.capacityDimensions;
+        profile = builder.profile;
+    }
+
+    @Override
+    public int hashCode() {
+        int result;
+        long temp;
+        result = typeId.hashCode();
+        result = 31 * result + (profile != null ? profile.hashCode() : 0);
+        result = 31 * result + vehicleCostParams.hashCode();
+        result = 31 * result + capacityDimensions.hashCode();
+        temp = Double.doubleToLongBits(maxVelocity);
+        result = 31 * result + (int) (temp ^ (temp >>> 32));
+        return result;
+    }
+
+    /* (non-Javadoc)
+     * @see basics.route.VehicleType#getTypeId()
+     */
+    @Override
+    public String getTypeId() {
+        return typeId;
+    }
+
+    @Override
+    public Capacity getCapacityDimensions() {
+        return capacityDimensions;
+    }
+
+    @Override
+    public double getMaxVelocity() {
+        return maxVelocity;
+    }
+
+    /* (non-Javadoc)
+     * @see basics.route.VehicleType#getVehicleCostParams()
+     */
+    @Override
+    public VehicleTypeImpl.VehicleCostParams getVehicleCostParams() {
+        return vehicleCostParams;
+    }
+
+    @Override
+    public String getProfile() {
+        return profile;
+    }
+
+    /**
+     * @return User-specific domain data associated with the vehicle
+     */
+    @Override
+    public Object getUserData() {
+        return userData;
+    }
+
     /**
      * CostParameter consisting of fixed cost parameter, time-based cost parameter and distance-based cost parameter.
      *
@@ -37,10 +127,6 @@
     public static class VehicleCostParams {
 
 
-        public static VehicleTypeImpl.VehicleCostParams newInstance(double fix, double perTimeUnit, double perDistanceUnit) {
-            return new VehicleCostParams(fix, perTimeUnit, perDistanceUnit);
-        }
-
         public final double fix;
         @Deprecated
         public final double perTimeUnit;
@@ -48,7 +134,6 @@
         public final double perDistanceUnit;
         public final double perWaitingTimeUnit;
         public final double perServiceTimeUnit;
-
         private VehicleCostParams(double fix, double perTimeUnit, double perDistanceUnit) {
             super();
             this.fix = fix;
@@ -77,6 +162,27 @@ public VehicleCostParams(double fix, double perTimeUnit, double perDistanceUnit,
             this.perServiceTimeUnit = perServiceTimeUnit;
         }
 
+        public static VehicleTypeImpl.VehicleCostParams newInstance(double fix, double perTimeUnit, double perDistanceUnit) {
+            return new VehicleCostParams(fix, perTimeUnit, perDistanceUnit);
+        }
+
+        @Override
+        public int hashCode() {
+            int result;
+            long temp;
+            temp = Double.doubleToLongBits(fix);
+            result = (int) (temp ^ (temp >>> 32));
+            temp = Double.doubleToLongBits(perTransportTimeUnit);
+            result = 31 * result + (int) (temp ^ (temp >>> 32));
+            temp = Double.doubleToLongBits(perDistanceUnit);
+            result = 31 * result + (int) (temp ^ (temp >>> 32));
+            temp = Double.doubleToLongBits(perWaitingTimeUnit);
+            result = 31 * result + (int) (temp ^ (temp >>> 32));
+            temp = Double.doubleToLongBits(perServiceTimeUnit);
+            result = 31 * result + (int) (temp ^ (temp >>> 32));
+            return result;
+        }
+
         @Override
         public String toString() {
             return "[fixed=" + fix + "][perTime=" + perTransportTimeUnit + "][perDistance=" + perDistanceUnit + "][perWaitingTimeUnit=" + perWaitingTimeUnit + "]";
@@ -96,22 +202,7 @@ public boolean equals(Object o) {
             return Double.compare(that.perServiceTimeUnit, perServiceTimeUnit) == 0;
         }
 
-        @Override
-        public int hashCode() {
-            int result;
-            long temp;
-            temp = Double.doubleToLongBits(fix);
-            result = (int) (temp ^ (temp >>> 32));
-            temp = Double.doubleToLongBits(perTransportTimeUnit);
-            result = 31 * result + (int) (temp ^ (temp >>> 32));
-            temp = Double.doubleToLongBits(perDistanceUnit);
-            result = 31 * result + (int) (temp ^ (temp >>> 32));
-            temp = Double.doubleToLongBits(perWaitingTimeUnit);
-            result = 31 * result + (int) (temp ^ (temp >>> 32));
-            temp = Double.doubleToLongBits(perServiceTimeUnit);
-            result = 31 * result + (int) (temp ^ (temp >>> 32));
-            return result;
-        }
+
     }
 
     /**
@@ -122,11 +213,6 @@ public int hashCode() {
     public static class Builder {
 
 
-        public static VehicleTypeImpl.Builder newInstance(String id) {
-            if (id == null) throw new IllegalArgumentException();
-            return new Builder(id);
-        }
-
         private String id;
         private int capacity = 0;
         private double maxVelo = Double.MAX_VALUE;
@@ -138,33 +224,31 @@ public int hashCode() {
         private double perTime = 0.0;
         private double perWaitingTime = 0.0;
         private double perServiceTime = 0.0;
-
         private String profile = "car";
-
         private Capacity.Builder capacityBuilder = Capacity.Builder.newInstance();
-
         private Capacity capacityDimensions = null;
-
         private boolean dimensionAdded = false;
-
         private Object userData;
 
         private Builder(String id) {
             this.id = id;
         }
 
+        public static VehicleTypeImpl.Builder newInstance(String id) {
+            if (id == null) throw new IllegalArgumentException();
+            return new Builder(id);
+        }
 
         /**
          * Sets user specific domain data associated with the object.
-         *
+         * <p>
          * <p>
          * The user data is a black box for the framework, it only stores it,
          * but never interacts with it in any way.
          * </p>
          *
-         * @param userData
-         *            any object holding the domain specific user data
-         *            associated with the object.
+         * @param userData any object holding the domain specific user data
+         *                 associated with the object.
          * @return builder
          */
         public Builder setUserData(Object userData) {
@@ -178,8 +262,7 @@ public Builder setUserData(Object userData) {
          *
          * @param inMeterPerSeconds
          * @return this builder
-         * @throws IllegalArgumentException
-         *             if velocity is smaller than zero
+         * @throws IllegalArgumentException if velocity is smaller than zero
          */
         public VehicleTypeImpl.Builder setMaxVelocity(double inMeterPerSeconds) {
             if (inMeterPerSeconds < 0.0)
@@ -290,7 +373,7 @@ public VehicleTypeImpl build() {
          * @param dimVal
          * @return the builder
          * @throws IllegalArgumentException if dimVal < 0
-         * @throws IllegalArgumentException    if capacity dimension is already set
+         * @throws IllegalArgumentException if capacity dimension is already set
          */
         public Builder addCapacityDimension(int dimIndex, int dimVal) {
             if (dimVal < 0) throw new IllegalArgumentException("The capacity value must not be negative.");
@@ -329,86 +412,6 @@ public Builder setProfile(String profile) {
         }
     }
 
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (!(o instanceof VehicleTypeImpl)) return false;
-
-        VehicleTypeImpl that = (VehicleTypeImpl) o;
-
-        if (Double.compare(that.maxVelocity, maxVelocity) != 0) return false;
-        if (!typeId.equals(that.typeId)) return false;
-        if (profile != null ? !profile.equals(that.profile) : that.profile != null) return false;
-        if (!vehicleCostParams.equals(that.vehicleCostParams)) return false;
-        return capacityDimensions.equals(that.capacityDimensions);
-    }
-
-    @Override
-    public int hashCode() {
-        int result;
-        long temp;
-        result = typeId.hashCode();
-        result = 31 * result + (profile != null ? profile.hashCode() : 0);
-        result = 31 * result + vehicleCostParams.hashCode();
-        result = 31 * result + capacityDimensions.hashCode();
-        temp = Double.doubleToLongBits(maxVelocity);
-        result = 31 * result + (int) (temp ^ (temp >>> 32));
-        return result;
-    }
-
-    private final String typeId;
-
-    private final int capacity;
-
-    private final String profile;
-
-    private final VehicleTypeImpl.VehicleCostParams vehicleCostParams;
-
-    private final Capacity capacityDimensions;
-
-    private final double maxVelocity;
-
-    private Object userData;
-
-    /**
-     * priv constructor constructing vehicle-type
-     *
-     * @param builder
-     */
-    private VehicleTypeImpl(VehicleTypeImpl.Builder builder) {
-        this.userData = builder.userData;
-        typeId = builder.id;
-        capacity = builder.capacity;
-        maxVelocity = builder.maxVelo;
-        vehicleCostParams = new VehicleCostParams(builder.fixedCost, builder.perTime, builder.perDistance, builder.perWaitingTime, builder.perServiceTime);
-        capacityDimensions = builder.capacityDimensions;
-        profile = builder.profile;
-    }
-
-    /**
-     * @return User-specific domain data associated with the vehicle
-     */
-    @Override
-    public Object getUserData() {
-        return userData;
-    }
-
-    /* (non-Javadoc)
-     * @see basics.route.VehicleType#getTypeId()
-     */
-    @Override
-    public String getTypeId() {
-        return typeId;
-    }
-
-    /* (non-Javadoc)
-     * @see basics.route.VehicleType#getVehicleCostParams()
-     */
-    @Override
-    public VehicleTypeImpl.VehicleCostParams getVehicleCostParams() {
-        return vehicleCostParams;
-    }
-
     @Override
     public String toString() {
         return "[typeId=" + typeId + "]" +
@@ -416,19 +419,5 @@ public String toString() {
             "[costs=" + vehicleCostParams + "]";
     }
 
-    @Override
-    public double getMaxVelocity() {
-        return maxVelocity;
-    }
-
-    @Override
-    public Capacity getCapacityDimensions() {
-        return capacityDimensions;
-    }
-
-    @Override
-    public String getProfile() {
-        return profile;
-    }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeKey.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeKey.java
index 4f8bdc44b..cab1249a2 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeKey.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeKey.java
@@ -48,6 +48,22 @@ public VehicleTypeKey(String typeId, String startLocationId, String endLocationI
         this.returnToDepot = returnToDepot;
     }
 
+    @Override
+    public int hashCode() {
+        int result;
+        long temp;
+        result = type.hashCode();
+        result = 31 * result + startLocationId.hashCode();
+        result = 31 * result + endLocationId.hashCode();
+        temp = Double.doubleToLongBits(earliestStart);
+        result = 31 * result + (int) (temp ^ (temp >>> 32));
+        temp = Double.doubleToLongBits(latestEnd);
+        result = 31 * result + (int) (temp ^ (temp >>> 32));
+        result = 31 * result + skills.hashCode();
+        result = 31 * result + (returnToDepot ? 1 : 0);
+        return result;
+    }
+
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
@@ -66,22 +82,6 @@ public boolean equals(Object o) {
         return true;
     }
 
-    @Override
-    public int hashCode() {
-        int result;
-        long temp;
-        result = type.hashCode();
-        result = 31 * result + startLocationId.hashCode();
-        result = 31 * result + endLocationId.hashCode();
-        temp = Double.doubleToLongBits(earliestStart);
-        result = 31 * result + (int) (temp ^ (temp >>> 32));
-        temp = Double.doubleToLongBits(latestEnd);
-        result = 31 * result + (int) (temp ^ (temp >>> 32));
-        result = 31 * result + skills.hashCode();
-        result = 31 * result + (returnToDepot ? 1 : 0);
-        return result;
-    }
-
     @Override
     public String toString() {
         StringBuilder stringBuilder = new StringBuilder();
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
index 35878ade9..aaa2ed3d6 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
@@ -42,33 +42,6 @@
     // Wrapping System.out into a PrintWriter
     private static final PrintWriter SYSTEM_OUT_AS_PRINT_WRITER = new PrintWriter(System.out);
 
-    /**
-     * Enum to indicate verbose-level.
-     * <p>
-     * <p>
-     * Print.CONCISE and Print.VERBOSE are available.
-     *
-     * @author stefan schroeder
-     */
-    public enum Print {
-
-        CONCISE, VERBOSE
-    }
-
-    private static class Jobs {
-        int nServices;
-        int nShipments;
-        int nBreaks;
-
-        public Jobs(int nServices, int nShipments, int nBreaks) {
-            super();
-            this.nServices = nServices;
-            this.nShipments = nShipments;
-            this.nBreaks = nBreaks;
-        }
-    }
-
-
     /**
      * Prints costs and #vehicles to stdout (out.println).
      *
@@ -141,11 +114,33 @@ public static void print(PrintWriter out, VehicleRoutingProblem problem, Vehicle
         }
     }
 
+    private static Jobs getNuOfJobs(VehicleRoutingProblem problem) {
+        int nShipments = 0;
+        int nServices = 0;
+        int nBreaks = 0;
+        for (Job j : problem.getJobs().values()) {
+            if (j instanceof Shipment) {
+                nShipments++;
+            }
+            if (j instanceof Service) {
+                nServices++;
+            }
+            if (j instanceof Break) {
+                nBreaks++;
+            }
+        }
+        return new Jobs(nServices, nShipments, nBreaks);
+    }
+
     private static void printVerbose(VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution) {
         printVerbose(SYSTEM_OUT_AS_PRINT_WRITER, problem, solution);
         SYSTEM_OUT_AS_PRINT_WRITER.flush();
     }
 
+    private static String getVehicleString(VehicleRoute route) {
+        return route.getVehicle().getId();
+    }
+
     private static void printVerbose(PrintWriter out, VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution) {
         String leftAlgin = "| %-7s | %-20s | %-21s | %-15s | %-15s | %-15s | %-15s |%n";
         out.format("+--------------------------------------------------------------------------------------------------------------------------------+%n");
@@ -155,7 +150,7 @@ private static void printVerbose(PrintWriter out, VehicleRoutingProblem problem,
         int routeNu = 1;
 
         List<VehicleRoute> list = new ArrayList<VehicleRoute>(solution.getRoutes());
-        Collections.sort(list , new com.graphhopper.jsprit.core.util.VehicleIndexComparator());
+        Collections.sort(list, new com.graphhopper.jsprit.core.util.VehicleIndexComparator());
         for (VehicleRoute route : list) {
             out.format("+---------+----------------------+-----------------------+-----------------+-----------------+-----------------+-----------------+%n");
             double costs = 0;
@@ -198,26 +193,30 @@ private static void printVerbose(PrintWriter out, VehicleRoutingProblem problem,
         }
     }
 
-    private static String getVehicleString(VehicleRoute route) {
-        return route.getVehicle().getId();
+    /**
+     * Enum to indicate verbose-level.
+     * <p>
+     * <p>
+     * Print.CONCISE and Print.VERBOSE are available.
+     *
+     * @author stefan schroeder
+     */
+    public enum Print {
+
+        CONCISE, VERBOSE
     }
 
-    private static Jobs getNuOfJobs(VehicleRoutingProblem problem) {
-        int nShipments = 0;
-        int nServices = 0;
-        int nBreaks = 0;
-        for (Job j : problem.getJobs().values()) {
-            if (j instanceof Shipment) {
-                nShipments++;
-            }
-            if (j instanceof Service) {
-                nServices++;
-            }
-            if (j instanceof Break) {
-                nBreaks++;
-            }
+    private static class Jobs {
+        int nServices;
+        int nShipments;
+        int nBreaks;
+
+        public Jobs(int nServices, int nShipments, int nBreaks) {
+            super();
+            this.nServices = nServices;
+            this.nShipments = nShipments;
+            this.nBreaks = nBreaks;
         }
-        return new Jobs(nServices, nShipments, nBreaks);
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/ActivityTimeTracker.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/ActivityTimeTracker.java
index 4c7f20fc4..2e99343a7 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/ActivityTimeTracker.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/ActivityTimeTracker.java
@@ -25,28 +25,14 @@
 
 public class ActivityTimeTracker implements ActivityVisitor {
 
-    public static enum ActivityPolicy {
-
-        AS_SOON_AS_TIME_WINDOW_OPENS, AS_SOON_AS_ARRIVED
-
-    }
-
     private final ForwardTransportTime transportTime;
-
     private final VehicleRoutingActivityCosts activityCosts;
-
     private TourActivity prevAct = null;
-
     private double startAtPrevAct;
-
     private VehicleRoute route;
-
     private boolean beginFirst = false;
-
     private double actArrTime;
-
     private double actEndTime;
-
     private ActivityPolicy activityPolicy = ActivityPolicy.AS_SOON_AS_TIME_WINDOW_OPENS;
 
     public ActivityTimeTracker(ForwardTransportTime transportTime, VehicleRoutingActivityCosts activityCosts) {
@@ -94,7 +80,7 @@ public void visit(TourActivity activity) {
             operationStartTime = actArrTime;
         } else operationStartTime = actArrTime;
 
-        double operationEndTime = operationStartTime + activityCosts.getActivityDuration(activity,actArrTime,route.getDriver(),route.getVehicle());
+        double operationEndTime = operationStartTime + activityCosts.getActivityDuration(activity, actArrTime, route.getDriver(), route.getVehicle());
 
         actEndTime = operationEndTime;
 
@@ -114,5 +100,11 @@ public void finish() {
         beginFirst = false;
     }
 
+    public static enum ActivityPolicy {
+
+        AS_SOON_AS_TIME_WINDOW_OPENS, AS_SOON_AS_ARRIVED
+
+    }
+
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/BenchmarkResult.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/BenchmarkResult.java
index 5c04f7867..d66237dda 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/BenchmarkResult.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/BenchmarkResult.java
@@ -21,18 +21,15 @@
 
 
 public class BenchmarkResult {
+    public final BenchmarkInstance instance;
+    public final int runs;
     private double[] results;
     private double[] vehicles;
     private double[] times;
-
     private DescriptiveStatistics statsResults;
     private DescriptiveStatistics statsVehicles;
     private DescriptiveStatistics statsTimes;
 
-    public final BenchmarkInstance instance;
-
-    public final int runs;
-
     public BenchmarkResult(BenchmarkInstance instance, int runs, double[] results, double[] compTimes, double[] vehicles) {
         super();
         this.results = results;
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/CalculationUtils.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/CalculationUtils.java
index 9f0781bee..a621fbe44 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/CalculationUtils.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/CalculationUtils.java
@@ -33,7 +33,7 @@
      * @return
      */
     @Deprecated
-    public static double getActivityEndTime(double actArrTime, TourActivity act){
-		return Math.max(actArrTime, act.getTheoreticalEarliestOperationStartTime()) + act.getOperationTime();
+    public static double getActivityEndTime(double actArrTime, TourActivity act) {
+        return Math.max(actArrTime, act.getTheoreticalEarliestOperationStartTime()) + act.getOperationTime();
     }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/Coordinate.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/Coordinate.java
index 6c1c26c8a..88c8ea68f 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/Coordinate.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/Coordinate.java
@@ -19,12 +19,7 @@
 
 public class Coordinate {
 
-    public static Coordinate newInstance(double x, double y) {
-        return new Coordinate(x, y);
-    }
-
     private final double x;
-
     private final double y;
 
     public Coordinate(double x, double y) {
@@ -33,6 +28,10 @@ public Coordinate(double x, double y) {
         this.y = y;
     }
 
+    public static Coordinate newInstance(double x, double y) {
+        return new Coordinate(x, y);
+    }
+
     public double getX() {
         return x;
     }
@@ -41,11 +40,6 @@ public double getY() {
         return y;
     }
 
-    @Override
-    public String toString() {
-        return "[x=" + x + "][y=" + y + "]";
-    }
-
     @Override
     public int hashCode() {
         final int prime = 31;
@@ -74,4 +68,9 @@ public boolean equals(Object obj) {
         return true;
     }
 
+    @Override
+    public String toString() {
+        return "[x=" + x + "][y=" + y + "]";
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/EuclideanCosts.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/EuclideanCosts.java
index c17e63574..11678999b 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/EuclideanCosts.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/EuclideanCosts.java
@@ -40,6 +40,16 @@ public String toString() {
         return "[name=crowFlyCosts]";
     }
 
+    @Override
+    public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+        return calculateDistance(from, to);
+    }
+
+    @Override
+    public double getTransportTime(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
+        return calculateDistance(from, to) / speed;
+    }
+
     @Override
     public double getTransportCost(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
         double distance = calculateDistance(from, to);
@@ -60,14 +70,4 @@ public double getTransportCost(Location from, Location to, double time, Driver d
             throw new NullPointerException("cannot calculate euclidean distance. coordinates are missing. either add coordinates or use another transport-cost-calculator.");
         }
     }
-
-    @Override
-    public double getTransportTime(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
-        return calculateDistance(from, to) / speed;
-    }
-
-    @Override
-    public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-            return calculateDistance(from, to);
-    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/FastVehicleRoutingTransportCostsMatrix.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/FastVehicleRoutingTransportCostsMatrix.java
index abbf27c62..a7dce15c4 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/FastVehicleRoutingTransportCostsMatrix.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/FastVehicleRoutingTransportCostsMatrix.java
@@ -33,6 +33,74 @@
  */
 public class FastVehicleRoutingTransportCostsMatrix extends AbstractForwardVehicleRoutingTransportCosts {
 
+    private final boolean isSymmetric;
+    private final double[][][] matrix;
+    private int noLocations;
+
+    private FastVehicleRoutingTransportCostsMatrix(Builder builder) {
+        this.isSymmetric = builder.isSymmetric;
+        matrix = builder.matrix;
+        noLocations = builder.noLocations;
+    }
+
+    /**
+     * First dim is from, second to and third indicates whether it is a distance value (index=0) or time value (index=1).
+     *
+     * @return
+     */
+    public double[][][] getMatrix() {
+        return matrix;
+    }
+
+    @Override
+    public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+        return getDistance(from.getIndex(), to.getIndex());
+    }
+
+    @Override
+    public double getTransportTime(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
+        if (from.getIndex() < 0 || to.getIndex() < 0)
+            throw new IllegalArgumentException("index of from " + from + " to " + to + " < 0 ");
+        int timeIndex = 1;
+        return get(from.getIndex(), to.getIndex(), timeIndex);
+    }
+
+    @Override
+    public double getTransportCost(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
+        if (from.getIndex() < 0 || to.getIndex() < 0)
+            throw new IllegalArgumentException("index of from " + from + " to " + to + " < 0 ");
+        if (vehicle == null) return getDistance(from.getIndex(), to.getIndex());
+        VehicleTypeImpl.VehicleCostParams costParams = vehicle.getType().getVehicleCostParams();
+        return costParams.perDistanceUnit * getDistance(from.getIndex(), to.getIndex()) + costParams.perTransportTimeUnit * getTransportTime(from, to, departureTime, driver, vehicle);
+    }
+
+    /**
+     * Returns the distance from to to.
+     *
+     * @param fromIndex from location index
+     * @param toIndex   to location index
+     * @return the distance
+     */
+    public double getDistance(int fromIndex, int toIndex) {
+        int distanceIndex = 0;
+        return get(fromIndex, toIndex, distanceIndex);
+    }
+
+    private double get(int from, int to, int indicatorIndex) {
+        double value;
+        if (isSymmetric) {
+            if (from < to) value = matrix[from][to][indicatorIndex];
+            else value = matrix[to][from][indicatorIndex];
+        } else {
+            value = matrix[from][to][indicatorIndex];
+        }
+        return value;
+    }
+
+    public int getNoLocations() {
+        return noLocations;
+    }
+
     /**
      * Builder that builds the matrix.
      *
@@ -40,11 +108,15 @@
      */
     public static class Builder {
 
+        private final int noLocations;
         private boolean isSymmetric;
-
         private double[][][] matrix;
 
-        private final int noLocations;
+        private Builder(int noLocations, boolean isSymmetric) {
+            this.isSymmetric = isSymmetric;
+            matrix = new double[noLocations][noLocations][2];
+            this.noLocations = noLocations;
+        }
 
         /**
          * Creates a new builder returning the matrix-builder.
@@ -57,10 +129,23 @@ public static Builder newInstance(int noLocations, boolean isSymmetric) {
             return new Builder(noLocations, isSymmetric);
         }
 
-        private Builder(int noLocations, boolean isSymmetric) {
-            this.isSymmetric = isSymmetric;
-            matrix = new double[noLocations][noLocations][2];
-            this.noLocations = noLocations;
+        public Builder addTransportTimeAndDistance(int fromIndex, int toIndex, double time, double distance) {
+            addTransportTime(fromIndex, toIndex, time);
+            addTransportDistance(fromIndex, toIndex, distance);
+            return this;
+        }
+
+        /**
+         * Adds transport-time for a particular relation.
+         *
+         * @param fromIndex from location index
+         * @param toIndex   to location index
+         * @param time      the time to be added
+         * @return builder
+         */
+        public Builder addTransportTime(int fromIndex, int toIndex, double time) {
+            add(fromIndex, toIndex, 1, time);
+            return this;
         }
 
         /**
@@ -83,24 +168,6 @@ private void add(int fromIndex, int toIndex, int indicatorIndex, double value) {
             } else matrix[fromIndex][toIndex][indicatorIndex] = value;
         }
 
-        /**
-         * Adds transport-time for a particular relation.
-         *
-         * @param fromIndex from location index
-         * @param toIndex   to location index
-         * @param time      the time to be added
-         * @return builder
-         */
-        public Builder addTransportTime(int fromIndex, int toIndex, double time) {
-            add(fromIndex, toIndex, 1, time);
-            return this;
-        }
-
-        public Builder addTransportTimeAndDistance(int fromIndex, int toIndex, double time, double distance) {
-            addTransportTime(fromIndex, toIndex, time);
-            addTransportDistance(fromIndex, toIndex, distance);
-            return this;
-        }
         /**
          * Builds the matrix.
          *
@@ -113,75 +180,5 @@ public FastVehicleRoutingTransportCostsMatrix build() {
 
     }
 
-    private final boolean isSymmetric;
-
-    private final double[][][] matrix;
-
-    private int noLocations;
-
-    private FastVehicleRoutingTransportCostsMatrix(Builder builder) {
-        this.isSymmetric = builder.isSymmetric;
-        matrix = builder.matrix;
-        noLocations = builder.noLocations;
-    }
-
-    /**
-     * First dim is from, second to and third indicates whether it is a distance value (index=0) or time value (index=1).
-     *
-     * @return
-     */
-    public double[][][] getMatrix() {
-        return matrix;
-    }
-
-    @Override
-    public double getTransportTime(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-        if (from.getIndex() < 0 || to.getIndex() < 0)
-            throw new IllegalArgumentException("index of from " + from + " to " + to + " < 0 ");
-        int timeIndex = 1;
-        return get(from.getIndex(), to.getIndex(), timeIndex);
-    }
-
-    private double get(int from, int to, int indicatorIndex) {
-        double value;
-        if (isSymmetric) {
-            if (from < to) value = matrix[from][to][indicatorIndex];
-            else value = matrix[to][from][indicatorIndex];
-        } else {
-            value = matrix[from][to][indicatorIndex];
-        }
-        return value;
-    }
-
-    /**
-     * Returns the distance from to to.
-     *
-     * @param fromIndex from location index
-     * @param toIndex   to location index
-     * @return the distance
-     */
-    public double getDistance(int fromIndex, int toIndex) {
-        int distanceIndex = 0;
-        return get(fromIndex, toIndex, distanceIndex);
-    }
-
-    @Override
-    public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-        return getDistance(from.getIndex(), to.getIndex());
-    }
-
-    @Override
-    public double getTransportCost(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-        if (from.getIndex() < 0 || to.getIndex() < 0)
-            throw new IllegalArgumentException("index of from " + from + " to " + to + " < 0 ");
-        if (vehicle == null) return getDistance(from.getIndex(), to.getIndex());
-        VehicleTypeImpl.VehicleCostParams costParams = vehicle.getType().getVehicleCostParams();
-        return costParams.perDistanceUnit * getDistance(from.getIndex(), to.getIndex()) + costParams.perTransportTimeUnit * getTransportTime(from, to, departureTime, driver, vehicle);
-    }
-
-    public int getNoLocations() {
-        return noLocations;
-    }
-
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/GreatCircleCosts.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/GreatCircleCosts.java
index 0ecbc62da..b7b3ff194 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/GreatCircleCosts.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/GreatCircleCosts.java
@@ -32,6 +32,16 @@
     private double speed = 1.;
 
     private double detour = 1.;
+    private DistanceUnit distanceUnit = DistanceUnit.Kilometer;
+
+    public GreatCircleCosts() {
+        super();
+    }
+
+    public GreatCircleCosts(DistanceUnit distanceUnit) {
+        super();
+        this.distanceUnit = distanceUnit;
+    }
 
     public void setSpeed(double speed) {
         this.speed = speed;
@@ -49,18 +59,16 @@ public void setDetour(double detour) {
         this.detour = detour;
     }
 
-    private DistanceUnit distanceUnit = DistanceUnit.Kilometer;
-
-   public GreatCircleCosts() {
-        super();
+    @Override
+    public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+        return calculateDistance(from, to);
     }
 
-    public GreatCircleCosts(DistanceUnit distanceUnit) {
-        super();
-        this.distanceUnit = distanceUnit;
+    @Override
+    public double getTransportTime(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
+        return calculateDistance(from, to) / speed;
     }
 
-
     @Override
     public double getTransportCost(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
         double distance;
@@ -88,14 +96,4 @@ private double calculateDistance(Location fromLocation, Location toLocation) {
         if (from == null || to == null) throw new NullPointerException("either from or to location is null");
         return GreatCircleDistanceCalculator.calculateDistance(from, to, distanceUnit) * detour;
     }
-
-    @Override
-    public double getTransportTime(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
-        return calculateDistance(from, to) / speed;
-    }
-
-    @Override
-    public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-        return calculateDistance(from, to);
-    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/ManhattanCosts.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/ManhattanCosts.java
index 971821f89..faba12645 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/ManhattanCosts.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/ManhattanCosts.java
@@ -42,6 +42,16 @@ public ManhattanCosts() {
 
     }
 
+    @Override
+    public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+        return calculateDistance(from, to);
+    }
+
+    @Override
+    public double getTransportTime(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
+        return calculateDistance(from, to) / speed;
+    }
+
     @Override
     public double getTransportCost(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
         double distance;
@@ -59,11 +69,6 @@ public double getTransportCost(Location from, Location to, double time, Driver d
         return costs;
     }
 
-    @Override
-    public double getTransportTime(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
-        return calculateDistance(from, to) / speed;
-    }
-
     private double calculateDistance(Location fromLocation, Location toLocation) {
         Coordinate from = null;
         Coordinate to = null;
@@ -81,9 +86,4 @@ private double calculateDistance(Location fromLocation, Location toLocation) {
     private double calculateDistance(Coordinate from, Coordinate to) {
         return Math.abs(from.getX() - to.getX()) + Math.abs(from.getY() - to.getY());
     }
-
-    @Override
-    public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-        return calculateDistance(from, to);
-    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/RandomUtils.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/RandomUtils.java
index facc97981..8ef93da51 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/RandomUtils.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/RandomUtils.java
@@ -34,14 +34,6 @@ public static VehicleRoute nextRoute(Collection<VehicleRoute> routes, Random ran
         return nextItem(routes, random);
     }
 
-    public static Job nextJob(Collection<Job> jobs, Random random) {
-        return nextItem(jobs, random);
-    }
-
-    public static Job nextJob(List<Job> jobs, Random random) {
-        return nextItem(jobs, random);
-    }
-
     public static <T> T nextItem(Collection<T> items, Random random) {
         int randomIndex = random.nextInt(items.size());
         int count = 0;
@@ -52,6 +44,14 @@ public static Job nextJob(List<Job> jobs, Random random) {
         return null;
     }
 
+    public static Job nextJob(Collection<Job> jobs, Random random) {
+        return nextItem(jobs, random);
+    }
+
+    public static Job nextJob(List<Job> jobs, Random random) {
+        return nextItem(jobs, random);
+    }
+
     public static <T> T nextItem(List<T> items, Random random) {
         int randomIndex = random.nextInt(items.size());
         return items.get(randomIndex);
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/Resource.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/Resource.java
index 451f3a533..134f13545 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/Resource.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/Resource.java
@@ -18,8 +18,6 @@
 package com.graphhopper.jsprit.core.util;
 
 
-
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/StopWatch.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/StopWatch.java
index d500453af..d6b23a18d 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/StopWatch.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/StopWatch.java
@@ -24,10 +24,6 @@
 
     private double startTime;
 
-    public double getCompTimeInSeconds() {
-        return (ran) / 1000.0;
-    }
-
     public void stop() {
         ran += System.currentTimeMillis() - startTime;
     }
@@ -46,6 +42,10 @@ public String toString() {
         return getCompTimeInSeconds() + " sec";
     }
 
+    public double getCompTimeInSeconds() {
+        return (ran) / 1000.0;
+    }
+
     public double getCurrTimeInSeconds() {
         return (System.currentTimeMillis() - startTime) / 1000.0;
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/Time.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/Time.java
index 57d195cc3..ea5476726 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/Time.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/Time.java
@@ -78,16 +78,16 @@ public static double parseTimeToSeconds(String timeString) {
 
     }
 
-    private static double getSecondsInSeconds(String secString) {
-        return getDigit(secString);
+    private static double getHourInSeconds(String hourString) {
+        return getDigit(hourString) * 3600.;
     }
 
     private static double getMinInSeconds(String minString) {
         return getDigit(minString) * 60.;
     }
 
-    private static double getHourInSeconds(String hourString) {
-        return getDigit(hourString) * 3600.;
+    private static double getSecondsInSeconds(String secString) {
+        return getDigit(secString);
     }
 
     private static double getDigit(String digitString) {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/UnassignedJobReasonTracker.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/UnassignedJobReasonTracker.java
index 0ab34dec0..d2582f068 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/UnassignedJobReasonTracker.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/UnassignedJobReasonTracker.java
@@ -30,30 +30,9 @@
 public class UnassignedJobReasonTracker implements JobUnassignedListener {
 
     private final static String NO_REASON = "cannot determine a particular reason";
-
-    public static String getMostLikelyFailedConstraintName(Frequency failedConstraintNamesFrequency) {
-        if (failedConstraintNamesFrequency == null || failedConstraintNamesFrequency.getUniqueCount() == 0)
-            return NO_REASON;
-        Iterator<Map.Entry<Comparable<?>, Long>> entryIterator = failedConstraintNamesFrequency.entrySetIterator();
-        long maxCount = 0;
-        String mostLikely = null;
-        while (entryIterator.hasNext()) {
-            Map.Entry<Comparable<?>, Long> entry = entryIterator.next();
-            if (entry.getValue() > maxCount) {
-                Comparable<?> key = entry.getKey();
-                maxCount = entry.getValue();
-                mostLikely = key.toString();
-            }
-        }
-        return mostLikely;
-    }
-
     Map<String, Frequency> failedConstraintNamesFrequencyMapping = new HashMap<>();
-
     Map<Integer, String> codesToHumanReadableReason = new HashMap<>();
-
     Map<String, Integer> failedConstraintNamesToCode = new HashMap<>();
-
     Set<String> failedConstraintNamesToBeIgnored = new HashSet<>();
 
     public UnassignedJobReasonTracker() {
@@ -114,15 +93,6 @@ public void put(String simpleNameOfFailedConstraint, int code, String reason) {
         return Collections.unmodifiableMap(failedConstraintNamesFrequencyMapping);
     }
 
-    /**
-     * Returns an unmodifiable map of codes and reason pairs.
-     *
-     * @return
-     */
-    public Map<Integer, String> getCodesToReason() {
-        return Collections.unmodifiableMap(codesToHumanReadableReason);
-    }
-
     /**
      * Returns an unmodifiable map of constraint names (simple name of constraint) and reason code pairs.
      *
@@ -132,18 +102,44 @@ public void put(String simpleNameOfFailedConstraint, int code, String reason) {
         return Collections.unmodifiableMap(failedConstraintNamesToCode);
     }
 
-    public int getCode(String failedConstraintName) {
-        return toCode(failedConstraintName);
-    }
-
     public String getHumanReadableReason(int code) {
         return getCodesToReason().get(code);
     }
 
+    public static String getMostLikelyFailedConstraintName(Frequency failedConstraintNamesFrequency) {
+        if (failedConstraintNamesFrequency == null || failedConstraintNamesFrequency.getUniqueCount() == 0)
+            return NO_REASON;
+        Iterator<Map.Entry<Comparable<?>, Long>> entryIterator = failedConstraintNamesFrequency.entrySetIterator();
+        long maxCount = 0;
+        String mostLikely = null;
+        while (entryIterator.hasNext()) {
+            Map.Entry<Comparable<?>, Long> entry = entryIterator.next();
+            if (entry.getValue() > maxCount) {
+                Comparable<?> key = entry.getKey();
+                maxCount = entry.getValue();
+                mostLikely = key.toString();
+            }
+        }
+        return mostLikely;
+    }
+
     public String getHumanReadableReason(String failedConstraintName) {
         return getCodesToReason().get(getCode(failedConstraintName));
     }
 
+    /**
+     * Returns an unmodifiable map of codes and reason pairs.
+     *
+     * @return
+     */
+    public Map<Integer, String> getCodesToReason() {
+        return Collections.unmodifiableMap(codesToHumanReadableReason);
+    }
+
+    public int getCode(String failedConstraintName) {
+        return toCode(failedConstraintName);
+    }
+
     /**
      * Returns the most likely reason code i.e. the reason (failed constraint) being observed most often.
      * <p>
@@ -162,6 +158,12 @@ public int getMostLikelyReasonCode(String jobId) {
         return toCode(mostLikelyReason);
     }
 
+    private int toCode(String mostLikelyReason) {
+        if (failedConstraintNamesToCode.containsKey(mostLikelyReason))
+            return failedConstraintNamesToCode.get(mostLikelyReason);
+        else return -1;
+    }
+
     /**
      * Returns the most likely reason i.e. the reason (failed constraint) being observed most often.
      *
@@ -178,11 +180,5 @@ public String getMostLikelyReason(String jobId) {
         else return codesToHumanReadableReason.get(code);
     }
 
-    private int toCode(String mostLikelyReason) {
-        if (failedConstraintNamesToCode.containsKey(mostLikelyReason))
-            return failedConstraintNamesToCode.get(mostLikelyReason);
-        else return -1;
-    }
-
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/VehicleIndexComparator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/VehicleIndexComparator.java
index c3e60a73a..4e7a51d71 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/VehicleIndexComparator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/VehicleIndexComparator.java
@@ -18,12 +18,12 @@
 
 package com.graphhopper.jsprit.core.util;
 
-import java.util.Comparator;
-
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 
+import java.util.Comparator;
+
 public class VehicleIndexComparator implements Comparator<VehicleRoute> {
-        public int compare(VehicleRoute a, VehicleRoute b) {
-            return  a.getVehicle().getIndex() - b.getVehicle().getIndex();
-        }
+    public int compare(VehicleRoute a, VehicleRoute b) {
+        return a.getVehicle().getIndex() - b.getVehicle().getIndex();
+    }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/VehicleRoutingTransportCostsMatrix.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/VehicleRoutingTransportCostsMatrix.java
index 5052b2be4..6125a3766 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/VehicleRoutingTransportCostsMatrix.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/VehicleRoutingTransportCostsMatrix.java
@@ -41,21 +41,97 @@
  */
 public class VehicleRoutingTransportCostsMatrix extends AbstractForwardVehicleRoutingTransportCosts {
 
-    static class RelationKey {
+    private Map<RelationKey, Double> distances = new HashMap<RelationKey, Double>();
+    private Map<RelationKey, Double> times = new HashMap<RelationKey, Double>();
+    private boolean isSymmetric;
+    private boolean timesSet;
+    private boolean distancesSet;
 
-        static RelationKey newKey(String from, String to) {
-            return new RelationKey(from, to);
+    private VehicleRoutingTransportCostsMatrix(Builder builder) {
+        this.isSymmetric = builder.isSymmetric;
+        distances.putAll(builder.distances);
+        times.putAll(builder.times);
+        timesSet = builder.timesSet;
+        distancesSet = builder.distancesSet;
+    }
+
+    @Override
+    public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+        return getDistance(from.getId(), to.getId());
+    }
+
+    @Override
+    public double getTransportTime(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
+        return getTime(from.getId(), to.getId());
+    }
+
+    private double getTime(String fromId, String toId) {
+        if (fromId.equals(toId)) return 0.0;
+        if (!timesSet) return 0.0;
+        RelationKey key = RelationKey.newKey(fromId, toId);
+        if (!isSymmetric) {
+            if (times.containsKey(key)) return times.get(key);
+            else
+                throw new IllegalStateException("time value for relation from " + fromId + " to " + toId + " does not exist");
+        } else {
+            Double time = times.get(key);
+            if (time == null) {
+                time = times.get(RelationKey.newKey(toId, fromId));
+            }
+            if (time != null) return time;
+            else
+                throw new IllegalStateException("time value for relation from " + fromId + " to " + toId + " does not exist");
+        }
+    }
+
+    @Override
+    public double getTransportCost(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
+        if (vehicle == null) return getDistance(from.getId(), to.getId());
+        VehicleCostParams costParams = vehicle.getType().getVehicleCostParams();
+        return costParams.perDistanceUnit * getDistance(from.getId(), to.getId()) + costParams.perTransportTimeUnit * getTime(from.getId(), to.getId());
+    }
+
+    /**
+     * Returns the distance fromId to toId.
+     *
+     * @param fromId from locationId
+     * @param toId   to locationId
+     * @return the distance from fromId to toId
+     * @throws IllegalStateException if distance of fromId -> toId is not found
+     */
+    public double getDistance(String fromId, String toId) {
+        if (fromId.equals(toId)) return 0.0;
+        if (!distancesSet) return 0.0;
+        RelationKey key = RelationKey.newKey(fromId, toId);
+        if (!isSymmetric) {
+            if (distances.containsKey(key)) return distances.get(key);
+            else
+                throw new IllegalStateException("distance value for relation from " + fromId + " to " + toId + " does not exist");
+        } else {
+            Double time = distances.get(key);
+            if (time == null) {
+                time = distances.get(RelationKey.newKey(toId, fromId));
+            }
+            if (time != null) return time;
+            else
+                throw new IllegalStateException("distance value for relation from " + fromId + " to " + toId + " does not exist");
         }
+    }
+
+    static class RelationKey {
 
         final String from;
         final String to;
-
         public RelationKey(String from, String to) {
             super();
             this.from = from;
             this.to = to;
         }
 
+        static RelationKey newKey(String from, String to) {
+            return new RelationKey(from, to);
+        }
+
         /* (non-Javadoc)
          * @see java.lang.Object#hashCode()
          */
@@ -94,7 +170,6 @@ public boolean equals(Object obj) {
         }
     }
 
-
     /**
      * Builder that builds the matrix.
      *
@@ -113,6 +188,10 @@ public boolean equals(Object obj) {
 
         private boolean timesSet = false;
 
+        private Builder(boolean isSymmetric) {
+            this.isSymmetric = isSymmetric;
+        }
+
         /**
          * Creates a new builder returning the matrix-builder.
          * <p>If you want to consider symmetric matrices, set isSymmetric to true.
@@ -124,10 +203,6 @@ public static Builder newInstance(boolean isSymmetric) {
             return new Builder(isSymmetric);
         }
 
-        private Builder(boolean isSymmetric) {
-            this.isSymmetric = isSymmetric;
-        }
-
         /**
          * Adds a transport-distance for a particular relation.
          *
@@ -184,87 +259,4 @@ public VehicleRoutingTransportCostsMatrix build() {
 
     }
 
-    private Map<RelationKey, Double> distances = new HashMap<RelationKey, Double>();
-
-    private Map<RelationKey, Double> times = new HashMap<RelationKey, Double>();
-
-    private boolean isSymmetric;
-
-    private boolean timesSet;
-
-    private boolean distancesSet;
-
-    private VehicleRoutingTransportCostsMatrix(Builder builder) {
-        this.isSymmetric = builder.isSymmetric;
-        distances.putAll(builder.distances);
-        times.putAll(builder.times);
-        timesSet = builder.timesSet;
-        distancesSet = builder.distancesSet;
-    }
-
-
-    @Override
-    public double getTransportTime(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-        return getTime(from.getId(), to.getId());
-    }
-
-
-    private double getTime(String fromId, String toId) {
-        if (fromId.equals(toId)) return 0.0;
-        if (!timesSet) return 0.0;
-        RelationKey key = RelationKey.newKey(fromId, toId);
-        if (!isSymmetric) {
-            if (times.containsKey(key)) return times.get(key);
-            else
-                throw new IllegalStateException("time value for relation from " + fromId + " to " + toId + " does not exist");
-        } else {
-            Double time = times.get(key);
-            if (time == null) {
-                time = times.get(RelationKey.newKey(toId, fromId));
-            }
-            if (time != null) return time;
-            else
-                throw new IllegalStateException("time value for relation from " + fromId + " to " + toId + " does not exist");
-        }
-    }
-
-    /**
-     * Returns the distance fromId to toId.
-     *
-     * @param fromId from locationId
-     * @param toId   to locationId
-     * @return the distance from fromId to toId
-     * @throws IllegalStateException if distance of fromId -> toId is not found
-     */
-    public double getDistance(String fromId, String toId) {
-        if (fromId.equals(toId)) return 0.0;
-        if (!distancesSet) return 0.0;
-        RelationKey key = RelationKey.newKey(fromId, toId);
-        if (!isSymmetric) {
-            if (distances.containsKey(key)) return distances.get(key);
-            else
-                throw new IllegalStateException("distance value for relation from " + fromId + " to " + toId + " does not exist");
-        } else {
-            Double time = distances.get(key);
-            if (time == null) {
-                time = distances.get(RelationKey.newKey(toId, fromId));
-            }
-            if (time != null) return time;
-            else
-                throw new IllegalStateException("distance value for relation from " + fromId + " to " + toId + " does not exist");
-        }
-    }
-
-    @Override
-    public double getTransportCost(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-        if (vehicle == null) return getDistance(from.getId(), to.getId());
-        VehicleCostParams costParams = vehicle.getType().getVehicleCostParams();
-        return costParams.perDistanceUnit * getDistance(from.getId(), to.getId()) + costParams.perTransportTimeUnit * getTime(from.getId(), to.getId());
-    }
-
-    @Override
-    public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-        return getDistance(from.getId(), to.getId());
-    }
-
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/BuildCVRPAlgoFromScratch_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/BuildCVRPAlgoFromScratch_IT.java
index fff942ceb..d8c718e6d 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/BuildCVRPAlgoFromScratch_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/BuildCVRPAlgoFromScratch_IT.java
@@ -39,7 +39,6 @@
 import com.graphhopper.jsprit.core.util.Solutions;
 import org.junit.Before;
 import org.junit.Test;
-import org.junit.experimental.categories.Category;
 
 import java.util.Collection;
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithDeliveries_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithDeliveries_IT.java
index 8b3c4c28c..fdb15f12d 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithDeliveries_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithDeliveries_IT.java
@@ -24,7 +24,6 @@
 import com.graphhopper.jsprit.core.util.JobType;
 import com.graphhopper.jsprit.core.util.Solutions;
 import org.junit.Test;
-import org.junit.experimental.categories.Category;
 
 import java.util.Collection;
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithMatrix_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithMatrix_IT.java
index 343cba627..2aed05d4e 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithMatrix_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithMatrix_IT.java
@@ -29,7 +29,6 @@
 import com.graphhopper.jsprit.core.util.*;
 import org.junit.Assert;
 import org.junit.Test;
-import org.junit.experimental.categories.Category;
 
 import java.util.ArrayList;
 import java.util.Collection;
@@ -48,39 +47,12 @@ public void whenReturnToDepot_itShouldWorkWithMatrix() {
         new ChristofidesReader(vrpBuilder).setJobType(JobType.DELIVERY).read(getClass().getResourceAsStream("vrpnc1.txt"));
         VehicleRoutingProblem vrp_ = vrpBuilder.build();
         VehicleRoutingProblem vrp = createVrpWithLocationIndecesAndMatrix(vrp_, true);
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.FAST_REGRET,"true").buildAlgorithm();
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.FAST_REGRET, "true").buildAlgorithm();
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
         Assert.assertEquals(530.0, Solutions.bestOf(solutions).getCost(), 50.0);
         assertEquals(5, Solutions.bestOf(solutions).getRoutes().size());
     }
 
-    @Test
-    public void whenNotReturnToDepot_itShouldWorkWithMatrix() {
-        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new ChristofidesReader(vrpBuilder).setJobType(JobType.DELIVERY).read(getClass().getResourceAsStream("vrpnc1.txt"));
-        VehicleRoutingProblem vrp_ = vrpBuilder.build();
-        VehicleRoutingProblem vrp = createVrpWithLocationIndecesAndMatrix(vrp_, false);
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.FAST_REGRET,"true").buildAlgorithm();
-        try {
-            Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
-            assertTrue(true);
-        } catch (Exception e) {
-            assertFalse(true);
-        }
-    }
-
-    @Test
-    public void whenCalcTimeWithSolutionAnalyser_itShouldWork() {
-        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new ChristofidesReader(vrpBuilder).setJobType(JobType.DELIVERY).read(getClass().getResourceAsStream("vrpnc1.txt"));
-        VehicleRoutingProblem vrp_ = vrpBuilder.build();
-        final VehicleRoutingProblem vrp = createVrpWithLocationIndecesAndMatrix(vrp_, false);
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.FAST_REGRET,"true").buildAlgorithm();
-        Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
-        SolutionAnalyser sa = new SolutionAnalyser(vrp, Solutions.bestOf(solutions), vrp.getTransportCosts());
-    }
-
-
     private VehicleRoutingProblem createVrpWithLocationIndecesAndMatrix(VehicleRoutingProblem vrp_, boolean return_to_depot) {
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         List<Location> locations = new ArrayList<Location>();
@@ -116,10 +88,35 @@ private VehicleRoutingProblem createVrpWithLocationIndecesAndMatrix(VehicleRouti
         return vrpBuilder.build();
     }
 
-
     public int getIndex() {
         int i = index;
         index++;
         return i;
     }
+
+    @Test
+    public void whenNotReturnToDepot_itShouldWorkWithMatrix() {
+        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
+        new ChristofidesReader(vrpBuilder).setJobType(JobType.DELIVERY).read(getClass().getResourceAsStream("vrpnc1.txt"));
+        VehicleRoutingProblem vrp_ = vrpBuilder.build();
+        VehicleRoutingProblem vrp = createVrpWithLocationIndecesAndMatrix(vrp_, false);
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.FAST_REGRET, "true").buildAlgorithm();
+        try {
+            Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
+            assertTrue(true);
+        } catch (Exception e) {
+            assertFalse(true);
+        }
+    }
+
+    @Test
+    public void whenCalcTimeWithSolutionAnalyser_itShouldWork() {
+        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
+        new ChristofidesReader(vrpBuilder).setJobType(JobType.DELIVERY).read(getClass().getResourceAsStream("vrpnc1.txt"));
+        VehicleRoutingProblem vrp_ = vrpBuilder.build();
+        final VehicleRoutingProblem vrp = createVrpWithLocationIndecesAndMatrix(vrp_, false);
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.FAST_REGRET, "true").buildAlgorithm();
+        Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
+        SolutionAnalyser sa = new SolutionAnalyser(vrp, Solutions.bestOf(solutions), vrp.getTransportCosts());
+    }
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithPickups_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithPickups_IT.java
index eef86be33..1b011f531 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithPickups_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithPickups_IT.java
@@ -24,7 +24,6 @@
 import com.graphhopper.jsprit.core.util.JobType;
 import com.graphhopper.jsprit.core.util.Solutions;
 import org.junit.Test;
-import org.junit.experimental.categories.Category;
 
 import java.util.Collection;
 
@@ -37,7 +36,7 @@ public void whenSolvingVRPNC1WithPickups_solutionsMustNoBeWorseThan5PercentOfBes
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         new ChristofidesReader(vrpBuilder).setJobType(JobType.PICKUP).read(getClass().getResourceAsStream("vrpnc1.txt"));
         VehicleRoutingProblem vrp = vrpBuilder.build();
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.FAST_REGRET,"true").buildAlgorithm();
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.FAST_REGRET, "true").buildAlgorithm();
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
         assertEquals(530.0, Solutions.bestOf(solutions).getCost(), 50.0);
         assertEquals(5, Solutions.bestOf(solutions).getRoutes().size());
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CapacityConstraint_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CapacityConstraint_IT.java
index 58c994bb0..4d19c6ba0 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CapacityConstraint_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CapacityConstraint_IT.java
@@ -39,40 +39,40 @@
     public void capacityShouldNotBeExceeded() {
 
         VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("type1")
-            .addCapacityDimension(0,1)
-            .addCapacityDimension(1,0).addCapacityDimension(2,17).addCapacityDimension(3,18)
-            .addCapacityDimension(4,14).addCapacityDimension(5,18).addCapacityDimension(6,20).build();
+            .addCapacityDimension(0, 1)
+            .addCapacityDimension(1, 0).addCapacityDimension(2, 17).addCapacityDimension(3, 18)
+            .addCapacityDimension(4, 14).addCapacityDimension(5, 18).addCapacityDimension(6, 20).build();
         VehicleTypeImpl type2 = VehicleTypeImpl.Builder.newInstance("type2")
-            .addCapacityDimension(0,0)
-            .addCapacityDimension(1,0).addCapacityDimension(2,17).addCapacityDimension(3,18)
-            .addCapacityDimension(4,13).addCapacityDimension(5,18).addCapacityDimension(6,20).build();
+            .addCapacityDimension(0, 0)
+            .addCapacityDimension(1, 0).addCapacityDimension(2, 17).addCapacityDimension(3, 18)
+            .addCapacityDimension(4, 13).addCapacityDimension(5, 18).addCapacityDimension(6, 20).build();
         VehicleTypeImpl type3 = VehicleTypeImpl.Builder.newInstance("type3")
-            .addCapacityDimension(0,1)
-            .addCapacityDimension(1,0).addCapacityDimension(2,17).addCapacityDimension(3,18)
-            .addCapacityDimension(4,14).addCapacityDimension(5,18).addCapacityDimension(6,20).build();
+            .addCapacityDimension(0, 1)
+            .addCapacityDimension(1, 0).addCapacityDimension(2, 17).addCapacityDimension(3, 18)
+            .addCapacityDimension(4, 14).addCapacityDimension(5, 18).addCapacityDimension(6, 20).build();
         VehicleTypeImpl type4 = VehicleTypeImpl.Builder.newInstance("type4")
-            .addCapacityDimension(0,0)
-            .addCapacityDimension(1,0).addCapacityDimension(2,17).addCapacityDimension(3,18)
-            .addCapacityDimension(4,14).addCapacityDimension(5,17).addCapacityDimension(6,20).build();
+            .addCapacityDimension(0, 0)
+            .addCapacityDimension(1, 0).addCapacityDimension(2, 17).addCapacityDimension(3, 18)
+            .addCapacityDimension(4, 14).addCapacityDimension(5, 17).addCapacityDimension(6, 20).build();
         VehicleTypeImpl type5 = VehicleTypeImpl.Builder.newInstance("type5")
-            .addCapacityDimension(0,1)
-            .addCapacityDimension(1,0).addCapacityDimension(2,16).addCapacityDimension(3,17)
-            .addCapacityDimension(4,14).addCapacityDimension(5,18).addCapacityDimension(6,20).build();
+            .addCapacityDimension(0, 1)
+            .addCapacityDimension(1, 0).addCapacityDimension(2, 16).addCapacityDimension(3, 17)
+            .addCapacityDimension(4, 14).addCapacityDimension(5, 18).addCapacityDimension(6, 20).build();
 
-        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(Location.newInstance(0,0)).setType(type1).setReturnToDepot(true).build();
+        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(Location.newInstance(0, 0)).setType(type1).setReturnToDepot(true).build();
         VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(Location.newInstance(0, 0)).setType(type2).setReturnToDepot(true).build();
         VehicleImpl v3 = VehicleImpl.Builder.newInstance("v3").setStartLocation(Location.newInstance(0, 0)).setType(type3).setReturnToDepot(true).build();
         VehicleImpl v4 = VehicleImpl.Builder.newInstance("v4").setStartLocation(Location.newInstance(0, 0)).setType(type4).setReturnToDepot(true).build();
         VehicleImpl v5 = VehicleImpl.Builder.newInstance("v5").setStartLocation(Location.newInstance(0, 0)).setType(type5).setReturnToDepot(true).build();
 
-        Delivery d1 = Delivery.Builder.newInstance("d1").setLocation(Location.newInstance(0,10))
-            .addSizeDimension(2,1).build();
-        Delivery d2 = Delivery.Builder.newInstance("d2").setLocation(Location.newInstance(0,12))
-            .addSizeDimension(2,1).addSizeDimension(3,1).build();
-        Delivery d3 = Delivery.Builder.newInstance("d3").setLocation(Location.newInstance(0,15))
-            .addSizeDimension(0,1).addSizeDimension(4,1).build();
-        Delivery d4 = Delivery.Builder.newInstance("d4").setLocation(Location.newInstance(0,20))
-            .addSizeDimension(0,1).addSizeDimension(5,1).build();
+        Delivery d1 = Delivery.Builder.newInstance("d1").setLocation(Location.newInstance(0, 10))
+            .addSizeDimension(2, 1).build();
+        Delivery d2 = Delivery.Builder.newInstance("d2").setLocation(Location.newInstance(0, 12))
+            .addSizeDimension(2, 1).addSizeDimension(3, 1).build();
+        Delivery d3 = Delivery.Builder.newInstance("d3").setLocation(Location.newInstance(0, 15))
+            .addSizeDimension(0, 1).addSizeDimension(4, 1).build();
+        Delivery d4 = Delivery.Builder.newInstance("d4").setLocation(Location.newInstance(0, 20))
+            .addSizeDimension(0, 1).addSizeDimension(5, 1).build();
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.setFleetSize(VehicleRoutingProblem.FleetSize.FINITE)
@@ -91,13 +91,13 @@ public void capacityShouldNotBeExceeded() {
 
         SolutionAnalyser sa = new SolutionAnalyser(vrp, solution, vrp.getTransportCosts());
 
-        for(VehicleRoute r : solution.getRoutes()){
+        for (VehicleRoute r : solution.getRoutes()) {
             Capacity loadAtBeginning = sa.getLoadAtBeginning(r);
             Capacity capacityDimensions = r.getVehicle().getType().getCapacityDimensions();
 //            System.out.println(r.getVehicle().getId() + " load@beginning: "  + loadAtBeginning);
 //            System.out.println("cap: " + capacityDimensions);
             Assert.assertTrue("capacity has been exceeded",
-            loadAtBeginning.isLessOrEqual(capacityDimensions));
+                loadAtBeginning.isLessOrEqual(capacityDimensions));
         }
 //
         Assert.assertTrue(solution.getRoutes().size() != 1);
@@ -105,5 +105,4 @@ public void capacityShouldNotBeExceeded() {
     }
 
 
-
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/DeactivateTimeWindowsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/DeactivateTimeWindowsTest.java
index db1508940..1075eefe7 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/DeactivateTimeWindowsTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/DeactivateTimeWindowsTest.java
@@ -41,7 +41,7 @@
     VehicleRoutingProblem vrp;
 
     @Before
-    public void doBefore(){
+    public void doBefore() {
         Service service = Service.Builder.newInstance("s").setLocation(Location.newInstance(20, 0))
             .setTimeWindow(TimeWindow.newInstance(40, 50)).build();
         VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0, 0)).build();
@@ -67,7 +67,7 @@ public void whenActivatingViaStateManager_activityTimesShouldConsiderTimeWindows
         constraintManager.addTimeWindowConstraint();
 
         VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).addCoreStateAndConstraintStuff(true)
-            .setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
+            .setStateAndConstraintManager(stateManager, constraintManager).buildAlgorithm();
         vra.setMaxIterations(10);
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ExampleActivityCostFunction.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ExampleActivityCostFunction.java
index 7656bffa9..04181811d 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ExampleActivityCostFunction.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ExampleActivityCostFunction.java
@@ -25,14 +25,12 @@
 
 public class ExampleActivityCostFunction implements VehicleRoutingActivityCosts {
 
-    public ExampleActivityCostFunction() {
-        super();
-    }
-
     public double parameter_timeAtAct;
-
     public double parameter_penaltyTooLate;
 
+    public ExampleActivityCostFunction() {
+        super();
+    }
 
     @Override
     public double getActivityCost(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
@@ -40,7 +38,7 @@ public double getActivityCost(TourActivity tourAct, double arrivalTime, Driver d
             return 0.0;
         } else {
             //waiting + act-time
-            double endTime = Math.max(arrivalTime, tourAct.getTheoreticalEarliestOperationStartTime()) + getActivityDuration(tourAct,arrivalTime,driver,vehicle);
+            double endTime = Math.max(arrivalTime, tourAct.getTheoreticalEarliestOperationStartTime()) + getActivityDuration(tourAct, arrivalTime, driver, vehicle);
             double timeAtAct = endTime - arrivalTime;
 
             double totalCost = timeAtAct * parameter_timeAtAct;
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ExternalInitialSolutionIsInValidTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ExternalInitialSolutionIsInValidTest.java
index 65db2e423..f223fffec 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ExternalInitialSolutionIsInValidTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ExternalInitialSolutionIsInValidTest.java
@@ -25,12 +25,10 @@
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
-import com.graphhopper.jsprit.core.util.Solutions;
 import junit.framework.Assert;
 import org.junit.Test;
 
 import java.util.Arrays;
-import java.util.Collection;
 
 
 public class ExternalInitialSolutionIsInValidTest {
@@ -57,8 +55,7 @@ public void itShouldSolveProblemWithIniSolutionExternallyCreated() {
         try {
             vra.searchSolutions();
             Assert.assertTrue(true);
-        }
-        catch (Exception e){
+        } catch (Exception e) {
             Assert.assertFalse(true);
         }
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/IgnoreBreakTimeWindowTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/IgnoreBreakTimeWindowTest.java
index 12b50a96f..6e632c711 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/IgnoreBreakTimeWindowTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/IgnoreBreakTimeWindowTest.java
@@ -40,13 +40,13 @@
 public class IgnoreBreakTimeWindowTest {
 
     @Test
-    public void doNotIgnoreBreakTW(){
+    public void doNotIgnoreBreakTW() {
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType");
         VehicleType vehicleType = vehicleTypeBuilder.setCostPerWaitingTime(0.8).build();
 
-		/*
+        /*
          * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
-		 */
+         */
 
         VehicleImpl vehicle2;
         {
@@ -57,13 +57,13 @@ public void doNotIgnoreBreakTW(){
             vehicleBuilder.setBreak(Break.Builder.newInstance("lunch").setTimeWindow(TimeWindow.newInstance(14, 14)).setServiceTime(1.).build());
             vehicle2 = vehicleBuilder.build();
         }
-		/*
+        /*
          * build services at the required locations, each with a capacity-demand of 1.
-		 */
+         */
 
 
         Service service4 = Service.Builder.newInstance("2").setLocation(Location.newInstance(0, 0))
-            .setServiceTime(1.).setTimeWindow(TimeWindow.newInstance(17,17)).build();
+            .setServiceTime(1.).setTimeWindow(TimeWindow.newInstance(17, 17)).build();
 
         Service service5 = Service.Builder.newInstance("3").setLocation(Location.newInstance(0, 0))
             .setServiceTime(1.).setTimeWindow(TimeWindow.newInstance(18, 18)).build();
@@ -99,12 +99,12 @@ public void doNotIgnoreBreakTW(){
 
     private boolean breakShouldBeTime(VehicleRoutingProblemSolution solution) {
         boolean inTime = true;
-        for(TourActivity act : solution.getRoutes().iterator().next().getActivities()){
-            if(act instanceof BreakActivity){
-                if(act.getEndTime() < ((BreakActivity) act).getJob().getTimeWindow().getStart()){
+        for (TourActivity act : solution.getRoutes().iterator().next().getActivities()) {
+            if (act instanceof BreakActivity) {
+                if (act.getEndTime() < ((BreakActivity) act).getJob().getTimeWindow().getStart()) {
                     inTime = false;
                 }
-                if(act.getArrTime() > ((BreakActivity) act).getJob().getTimeWindow().getEnd()){
+                if (act.getArrTime() > ((BreakActivity) act).getJob().getTimeWindow().getEnd()) {
                     inTime = false;
                 }
             }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/InitialRoutesTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/InitialRoutesTest.java
index 42430d0b5..0ddac9494 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/InitialRoutesTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/InitialRoutesTest.java
@@ -57,11 +57,11 @@
     private VehicleRoute initialRoute;
 
     @Before
-    public void before(){
+    public void before() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-        VehicleImpl v = VehicleImpl.Builder.newInstance("veh1").setStartLocation(Location.newInstance(0,0)).setLatestArrival(48600).build();
-        Service s1 = Service.Builder.newInstance("s1").setLocation(Location.newInstance(1000,0)).build();
-        Service s2 = Service.Builder.newInstance("s2").setLocation(Location.newInstance(1000,1000)).build();
+        VehicleImpl v = VehicleImpl.Builder.newInstance("veh1").setStartLocation(Location.newInstance(0, 0)).setLatestArrival(48600).build();
+        Service s1 = Service.Builder.newInstance("s1").setLocation(Location.newInstance(1000, 0)).build();
+        Service s2 = Service.Builder.newInstance("s2").setLocation(Location.newInstance(1000, 1000)).build();
         builder.addVehicle(v).addJob(s1).addJob(s2);
         initialRoute = VehicleRoute.Builder.newInstance(v).addService(s1).build();
         builder.addInitialVehicleRoute(initialRoute);
@@ -103,18 +103,6 @@ private Job getInitialJob(String jobId, VehicleRoutingProblem vrp) {
         return null;
     }
 
-    private boolean hasActivityIn(Collection<VehicleRoute> routes, String jobId) {
-        boolean isInRoute = false;
-        for (VehicleRoute route : routes) {
-            for (TourActivity act : route.getActivities()) {
-                if (act instanceof TourActivity.JobActivity) {
-                    if (((TourActivity.JobActivity) act).getJob().getId().equals(jobId)) isInRoute = true;
-                }
-            }
-        }
-        return isInRoute;
-    }
-
     private boolean hasActivityIn(VehicleRoutingProblemSolution solution, String vehicleId, Job job) {
         for (VehicleRoute route : solution.getRoutes()) {
             String vehicleId_ = route.getVehicle().getId();
@@ -127,12 +115,13 @@ private boolean hasActivityIn(VehicleRoutingProblemSolution solution, String veh
         return false;
     }
 
-
-    private boolean hasActivityIn(VehicleRoute route, String jobId) {
+    private boolean hasActivityIn(Collection<VehicleRoute> routes, String jobId) {
         boolean isInRoute = false;
-        for (TourActivity act : route.getActivities()) {
-            if (act instanceof TourActivity.JobActivity) {
-                if (((TourActivity.JobActivity) act).getJob().getId().equals(jobId)) isInRoute = true;
+        for (VehicleRoute route : routes) {
+            for (TourActivity act : route.getActivities()) {
+                if (act instanceof TourActivity.JobActivity) {
+                    if (((TourActivity.JobActivity) act).getJob().getId().equals(jobId)) isInRoute = true;
+                }
             }
         }
         return isInRoute;
@@ -147,6 +136,16 @@ public void whenSolving_deliverService2_shouldBeInRoute() {
         assertTrue(hasActivityIn(solution.getRoutes().iterator().next(), "s2"));
     }
 
+    private boolean hasActivityIn(VehicleRoute route, String jobId) {
+        boolean isInRoute = false;
+        for (TourActivity act : route.getActivities()) {
+            if (act instanceof TourActivity.JobActivity) {
+                if (((TourActivity.JobActivity) act).getJob().getId().equals(jobId)) isInRoute = true;
+            }
+        }
+        return isInRoute;
+    }
+
     @Test
     public void maxCapacityShouldNotBeExceeded() {
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0, 100).build();
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MaxTimeInVehicle_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MaxTimeInVehicle_IT.java
index a592b9dab..e08ba9274 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MaxTimeInVehicle_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MaxTimeInVehicle_IT.java
@@ -39,16 +39,16 @@
 public class MaxTimeInVehicle_IT {
 
     @Test
-    public void test(){
+    public void test() {
 
-        Shipment s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(0,0)).setDeliveryLocation(Location.newInstance(100,0)).setDeliveryServiceTime(10)
+        Shipment s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(0, 0)).setDeliveryLocation(Location.newInstance(100, 0)).setDeliveryServiceTime(10)
             .setMaxTimeInVehicle(100d)
             .build();
-        Shipment s2 = Shipment.Builder.newInstance("s2").setPickupLocation(Location.newInstance(0,0)).setDeliveryLocation(Location.newInstance(100,0)).setDeliveryServiceTime(10)
+        Shipment s2 = Shipment.Builder.newInstance("s2").setPickupLocation(Location.newInstance(0, 0)).setDeliveryLocation(Location.newInstance(100, 0)).setDeliveryServiceTime(10)
             .setMaxTimeInVehicle(100d)
             .build();
 
-        VehicleImpl v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0,0)).build();
+        VehicleImpl v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0, 0)).build();
 
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addVehicle(v).addJob(s1).addJob(s2).build();
 
@@ -57,13 +57,13 @@ public void test(){
         StateId openJobsId = stateManager.createStateId("open-jobs-id");
         stateManager.addStateUpdater(new UpdateMaxTimeInVehicle(stateManager, id, vrp.getTransportCosts(), vrp.getActivityCosts(), openJobsId));
 
-        ConstraintManager constraintManager = new ConstraintManager(vrp,stateManager);
+        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
         constraintManager.addConstraint(new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), id, stateManager, vrp, openJobsId), ConstraintManager.Priority.CRITICAL);
 
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager, constraintManager).buildAlgorithm();
         VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
 
 //        Assert.assertEquals(400, solution.getCost(), 0.001);
-        SolutionPrinter.print(vrp,solution, SolutionPrinter.Print.VERBOSE);
+        SolutionPrinter.print(vrp, solution, SolutionPrinter.Print.VERBOSE);
     }
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MeetTimeWindowConstraint_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MeetTimeWindowConstraint_IT.java
index 84bf83512..1e76875d1 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MeetTimeWindowConstraint_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MeetTimeWindowConstraint_IT.java
@@ -53,17 +53,17 @@
     VehicleRoutingProblem vrp;
 
     @Before
-    public void doBefore(){
+    public void doBefore() {
         VehicleType type1 = VehicleTypeImpl.Builder.newInstance("5").build();
         VehicleType type2 = VehicleTypeImpl.Builder.newInstance("3.5").build();
-        VehicleImpl vehicle1 = VehicleImpl.Builder.newInstance("21").setStartLocation(Location.newInstance(0,0))
+        VehicleImpl vehicle1 = VehicleImpl.Builder.newInstance("21").setStartLocation(Location.newInstance(0, 0))
             .setEarliestStart(14400).setLatestArrival(46800).setType(type1).build();
-        VehicleImpl vehicle2 = VehicleImpl.Builder.newInstance("19").setStartLocation(Location.newInstance(0,0))
+        VehicleImpl vehicle2 = VehicleImpl.Builder.newInstance("19").setStartLocation(Location.newInstance(0, 0))
             .setEarliestStart(39600).setLatestArrival(64800).setType(type2).build();
         Service service1 = Service.Builder.newInstance("2").setLocation(Location.newInstance(2000, 0))
-            .setTimeWindow(TimeWindow.newInstance(54000,54000)).build();
+            .setTimeWindow(TimeWindow.newInstance(54000, 54000)).build();
         Service service2 = Service.Builder.newInstance("1").setLocation(Location.newInstance(1000, 1000))
-            .setTimeWindow(TimeWindow.newInstance(19800,21600)).build();
+            .setTimeWindow(TimeWindow.newInstance(19800, 21600)).build();
         vrp = VehicleRoutingProblem.Builder.newInstance().addVehicle(vehicle1).addVehicle(vehicle2)
             .addJob(service1).addJob(service2).setFleetSize(VehicleRoutingProblem.FleetSize.FINITE).build();
     }
@@ -154,18 +154,9 @@ public void whenEmployingVehicleWithDifferentWorkingShifts_job1ShouldBeAssignedC
         assertTrue(containsJob(vrp.getJobs().get("1"), getRoute("21", Solutions.bestOf(solutions))));
     }
 
-    @Test
-    public void whenEmployingVehicleWithDifferentWorkingShifts_job2ShouldBeAssignedCorrectly() {
-        VehicleRoutingAlgorithm vra = Jsprit.createAlgorithm(vrp);
-        vra.setMaxIterations(100);
-        Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
-        assertTrue(containsJob(vrp.getJobs().get("2"), getRoute("19", Solutions.bestOf(solutions))));
-    }
-
-
     @Test
     public void whenEmployingVehicleWithDifferentWorkingShifts_and_vehicleSwitchIsNotAllowed_nRoutesShouldBeCorrect() {
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.VEHICLE_SWITCH,"false").buildAlgorithm();
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.VEHICLE_SWITCH, "false").buildAlgorithm();
         vra.setMaxIterations(100);
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
 
@@ -174,7 +165,7 @@ public void whenEmployingVehicleWithDifferentWorkingShifts_and_vehicleSwitchIsNo
 
     @Test
     public void whenEmployingVehicleWithDifferentWorkingShifts_and_vehicleSwitchIsNotAllowed_certainJobsCanNeverBeAssignedToCertainVehicles() {
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.VEHICLE_SWITCH,"false").buildAlgorithm();
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.VEHICLE_SWITCH, "false").buildAlgorithm();
         vra.setMaxIterations(100);
         final List<Boolean> testFailed = new ArrayList<Boolean>();
         vra.addListener(new JobInsertedListener() {
@@ -200,9 +191,17 @@ public void informJobInserted(Job job2insert, VehicleRoute inRoute, double addit
         assertTrue(testFailed.isEmpty());
     }
 
+    @Test
+    public void whenEmployingVehicleWithDifferentWorkingShifts_job2ShouldBeAssignedCorrectly() {
+        VehicleRoutingAlgorithm vra = Jsprit.createAlgorithm(vrp);
+        vra.setMaxIterations(100);
+        Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
+        assertTrue(containsJob(vrp.getJobs().get("2"), getRoute("19", Solutions.bestOf(solutions))));
+    }
+
     @Test
     public void whenEmployingVehicleWithDifferentWorkingShifts_and_vehicleSwitchIsNotAllowed_certainVehiclesCanNeverBeAssignedToCertainRoutes() {
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.VEHICLE_SWITCH,"false").buildAlgorithm();
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.VEHICLE_SWITCH, "false").buildAlgorithm();
         vra.setMaxIterations(100);
         final List<Boolean> testFailed = new ArrayList<Boolean>();
         vra.addListener(new VehicleSwitchedListener() {
@@ -236,7 +235,7 @@ public void vehicleSwitched(VehicleRoute vehicleRoute, Vehicle oldVehicle, Vehic
 
     @Test
     public void whenEmployingVehicleWithDifferentWorkingShifts_and_vehicleSwitchIsNotAllowed_job2CanNeverBeInVehicle21() {
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.VEHICLE_SWITCH,"false").buildAlgorithm();
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.VEHICLE_SWITCH, "false").buildAlgorithm();
         vra.setMaxIterations(100);
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
 
@@ -245,7 +244,7 @@ public void whenEmployingVehicleWithDifferentWorkingShifts_and_vehicleSwitchIsNo
 
     @Test
     public void whenEmployingVehicleWithDifferentWorkingShifts_and_vehicleSwitchIsNotAllowed_job1ShouldBeAssignedCorrectly() {
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.VEHICLE_SWITCH,"false").buildAlgorithm();
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.VEHICLE_SWITCH, "false").buildAlgorithm();
         vra.setMaxIterations(100);
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
 
@@ -253,9 +252,28 @@ public void whenEmployingVehicleWithDifferentWorkingShifts_and_vehicleSwitchIsNo
         assertTrue(containsJob(vrp.getJobs().get("1"), getRoute("21", Solutions.bestOf(solutions))));
     }
 
+    private boolean containsJob(Job job, VehicleRoute route) {
+        if (route == null) return false;
+        for (Job j : route.getTourActivities().getJobs()) {
+            if (job == j) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private VehicleRoute getRoute(String vehicleId, VehicleRoutingProblemSolution vehicleRoutingProblemSolution) {
+        for (VehicleRoute r : vehicleRoutingProblemSolution.getRoutes()) {
+            if (r.getVehicle().getId().equals(vehicleId)) {
+                return r;
+            }
+        }
+        return null;
+    }
+
     @Test
     public void whenEmployingVehicleWithDifferentWorkingShifts_and_vehicleSwitchIsNotAllowed_job2ShouldBeAssignedCorrectly() {
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.VEHICLE_SWITCH,"false").buildAlgorithm();
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.VEHICLE_SWITCH, "false").buildAlgorithm();
         vra.setMaxIterations(100);
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
 
@@ -275,40 +293,8 @@ public void whenUsingJsprit_driverTimesShouldBeMet() throws IOException {
         }
     }
 
-    private FastVehicleRoutingTransportCostsMatrix createMatrix() throws IOException {
-        BufferedReader reader = new BufferedReader(new InputStreamReader(getClass().getResourceAsStream("matrix.txt")));
-        String line;
-        FastVehicleRoutingTransportCostsMatrix.Builder builder = FastVehicleRoutingTransportCostsMatrix.Builder.newInstance(11, false);
-        while ((line = reader.readLine()) != null) {
-            String[] split = line.split("\t");
-            builder.addTransportDistance(Integer.parseInt(split[0]), Integer.parseInt(split[1]), Double.parseDouble(split[2]));
-            builder.addTransportTime(Integer.parseInt(split[0]), Integer.parseInt(split[1]), Double.parseDouble(split[3]));
-        }
-        return builder.build();
-    }
-
-
-    private boolean containsJob(Job job, VehicleRoute route) {
-        if (route == null) return false;
-        for (Job j : route.getTourActivities().getJobs()) {
-            if (job == j) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private VehicleRoute getRoute(String vehicleId, VehicleRoutingProblemSolution vehicleRoutingProblemSolution) {
-        for (VehicleRoute r : vehicleRoutingProblemSolution.getRoutes()) {
-            if (r.getVehicle().getId().equals(vehicleId)) {
-                return r;
-            }
-        }
-        return null;
-    }
-
     private VehicleRoutingProblem createTWBugProblem() throws IOException {
-        VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0,20)
+        VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0, 20)
             .setCostPerTransportTime(1.).setCostPerDistance(0).build();
         VehicleImpl v0 = VehicleImpl.Builder.newInstance("vehicle0").setStartLocation(Location.newInstance(0))
             .setEarliestStart(60).setLatestArrival(18060).setType(type).build();
@@ -322,7 +308,7 @@ private VehicleRoutingProblem createTWBugProblem() throws IOException {
             .setEarliestStart(36000).setLatestArrival(54060).setType(type).build();
 
         Service s1 = Service.Builder.newInstance("1").setLocation(Location.Builder.newInstance().setIndex(1).setId("js0").build())
-            .setServiceTime(600).setTimeWindow(TimeWindow.newInstance(0,1800)).addSizeDimension(0,1).build();
+            .setServiceTime(600).setTimeWindow(TimeWindow.newInstance(0, 1800)).addSizeDimension(0, 1).build();
         Service s2 = Service.Builder.newInstance("2").setLocation(Location.Builder.newInstance().setIndex(2).setId("js2").build())
             .setServiceTime(600).setTimeWindow(TimeWindow.newInstance(5400, 7200)).addSizeDimension(0, 2).build();
         Service s3 = Service.Builder.newInstance("3").setLocation(Location.Builder.newInstance().setIndex(3).setId("js5").build())
@@ -332,7 +318,7 @@ private VehicleRoutingProblem createTWBugProblem() throws IOException {
         Service s5 = Service.Builder.newInstance("5").setLocation(Location.Builder.newInstance().setIndex(5).setId("js8").build())
             .setServiceTime(600).addSizeDimension(0, 4).build();
         Service s6 = Service.Builder.newInstance("6").setLocation(Location.Builder.newInstance().setIndex(6).setId("js10").build())
-            .setServiceTime(1500).setTimeWindow(TimeWindow.newInstance(29700,32400)).addSizeDimension(0, 10).build();
+            .setServiceTime(1500).setTimeWindow(TimeWindow.newInstance(29700, 32400)).addSizeDimension(0, 10).build();
         Service s7 = Service.Builder.newInstance("7").setLocation(Location.Builder.newInstance().setIndex(7).setId("jsp3").build())
             .setServiceTime(5594).build();
 
@@ -345,28 +331,28 @@ private VehicleRoutingProblem createTWBugProblem() throws IOException {
         Shipment shipment2 = Shipment.Builder.newInstance("shipment2")
             .setPickupLocation(Location.Builder.newInstance().setId("jsp4").setIndex(9).build())
             .setPickupServiceTime(1200)
-            .addPickupTimeWindow(21600,23400)
+            .addPickupTimeWindow(21600, 23400)
             .setDeliveryLocation(Location.Builder.newInstance().setId("jsd4").setIndex(8).build())
             .setDeliveryServiceTime(900)
-            .addDeliveryTimeWindow(25200,27000)
+            .addDeliveryTimeWindow(25200, 27000)
             .build();
 
         Shipment shipment3 = Shipment.Builder.newInstance("shipment3")
             .setPickupLocation(Location.Builder.newInstance().setId("jsp7").setIndex(9).build())
             .setPickupServiceTime(1200)
-            .addPickupTimeWindow(37800,41400)
+            .addPickupTimeWindow(37800, 41400)
             .setDeliveryLocation(Location.Builder.newInstance().setId("jsd7").setIndex(8).build())
             .setDeliveryServiceTime(1800)
-            .addDeliveryTimeWindow(43200,45900)
+            .addDeliveryTimeWindow(43200, 45900)
             .build();
 
         Shipment shipment4 = Shipment.Builder.newInstance("shipment4")
             .setPickupLocation(Location.Builder.newInstance().setId("jsp9").setIndex(10).build())
             .setPickupServiceTime(300)
-            .addPickupTimeWindow(45000,48600)
+            .addPickupTimeWindow(45000, 48600)
             .setDeliveryLocation(Location.Builder.newInstance().setId("jsd9").setIndex(8).build())
             .setDeliveryServiceTime(300)
-            .addDeliveryTimeWindow(50400,52200)
+            .addDeliveryTimeWindow(50400, 52200)
             .build();
 
         FastVehicleRoutingTransportCostsMatrix matrix = createMatrix();
@@ -378,4 +364,16 @@ private VehicleRoutingProblem createTWBugProblem() throws IOException {
 
     }
 
+    private FastVehicleRoutingTransportCostsMatrix createMatrix() throws IOException {
+        BufferedReader reader = new BufferedReader(new InputStreamReader(getClass().getResourceAsStream("matrix.txt")));
+        String line;
+        FastVehicleRoutingTransportCostsMatrix.Builder builder = FastVehicleRoutingTransportCostsMatrix.Builder.newInstance(11, false);
+        while ((line = reader.readLine()) != null) {
+            String[] split = line.split("\t");
+            builder.addTransportDistance(Integer.parseInt(split[0]), Integer.parseInt(split[1]), Double.parseDouble(split[2]));
+            builder.addTransportTime(Integer.parseInt(split[0]), Integer.parseInt(split[1]), Double.parseDouble(split[3]));
+        }
+        return builder.build();
+    }
+
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MultipleTimeWindowsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MultipleTimeWindowsTest.java
index 5ed0309d4..46e5923c1 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MultipleTimeWindowsTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MultipleTimeWindowsTest.java
@@ -34,64 +34,64 @@
 public class MultipleTimeWindowsTest {
 
     @Test
-    public void service2ShouldNotBeInserted(){
+    public void service2ShouldNotBeInserted() {
         Service s = Service.Builder.newInstance("s1").setLocation(Location.newInstance(10, 0)).build();
 
         Service s2 = Service.Builder.newInstance("s2")
-                .addTimeWindow(50.,60.)
-                .setLocation(Location.newInstance(20, 0)).build();
+            .addTimeWindow(50., 60.)
+            .setLocation(Location.newInstance(20, 0)).build();
 
-        VehicleImpl v = VehicleImpl.Builder.newInstance("v1").setStartLocation(Location.newInstance(0,0))
-                .setEarliestStart(0.).setLatestArrival(40).build();
+        VehicleImpl v = VehicleImpl.Builder.newInstance("v1").setStartLocation(Location.newInstance(0, 0))
+            .setEarliestStart(0.).setLatestArrival(40).build();
 
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(s).addJob(s2).addVehicle(v).build();
         VehicleRoutingAlgorithm algorithm = Jsprit.createAlgorithm(vrp);
         algorithm.setMaxIterations(100);
         VehicleRoutingProblemSolution solution = Solutions.bestOf(algorithm.searchSolutions());
 
-        Assert.assertEquals(1,solution.getUnassignedJobs().size());
+        Assert.assertEquals(1, solution.getUnassignedJobs().size());
     }
 
     @Test
-    public void service2ShouldBeInsertedIntoNewVehicle(){
-        Service s = Service.Builder.newInstance("s1").setLocation(Location.newInstance(10,0))
-                .addTimeWindow(5.,15.).build();
+    public void service2ShouldBeInsertedIntoNewVehicle() {
+        Service s = Service.Builder.newInstance("s1").setLocation(Location.newInstance(10, 0))
+            .addTimeWindow(5., 15.).build();
 
         Service s2 = Service.Builder.newInstance("s2")
-                .addTimeWindow(50.,60.)
-                .setLocation(Location.newInstance(20, 0)).build();
+            .addTimeWindow(50., 60.)
+            .setLocation(Location.newInstance(20, 0)).build();
 
-        VehicleImpl v = VehicleImpl.Builder.newInstance("v1").setStartLocation(Location.newInstance(0,0))
-                .setEarliestStart(0.).setLatestArrival(40).build();
+        VehicleImpl v = VehicleImpl.Builder.newInstance("v1").setStartLocation(Location.newInstance(0, 0))
+            .setEarliestStart(0.).setLatestArrival(40).build();
 
-        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(Location.newInstance(0,0))
-                .setEarliestStart(40.).setLatestArrival(80).build();
+        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(Location.newInstance(0, 0))
+            .setEarliestStart(40.).setLatestArrival(80).build();
 
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(s).addJob(s2).addVehicle(v).addVehicle(v2).build();
         VehicleRoutingAlgorithm algorithm = Jsprit.createAlgorithm(vrp);
         algorithm.setMaxIterations(100);
         VehicleRoutingProblemSolution solution = Solutions.bestOf(algorithm.searchSolutions());
 
-        Assert.assertEquals(0,solution.getUnassignedJobs().size());
+        Assert.assertEquals(0, solution.getUnassignedJobs().size());
         Assert.assertEquals(2, solution.getRoutes().size());
     }
 
     @Test
-    public void service2ShouldBeInserted(){
-        Service s = Service.Builder.newInstance("s1").setLocation(Location.newInstance(10,0)).build();
+    public void service2ShouldBeInserted() {
+        Service s = Service.Builder.newInstance("s1").setLocation(Location.newInstance(10, 0)).build();
 
         Service s2 = Service.Builder.newInstance("s2")
-                .addTimeWindow(50., 60.).addTimeWindow(15., 25)
-                .setLocation(Location.newInstance(20, 0)).build();
+            .addTimeWindow(50., 60.).addTimeWindow(15., 25)
+            .setLocation(Location.newInstance(20, 0)).build();
 
-        VehicleImpl v = VehicleImpl.Builder.newInstance("v1").setStartLocation(Location.newInstance(0,0))
-                .setEarliestStart(0.).setLatestArrival(40).build();
+        VehicleImpl v = VehicleImpl.Builder.newInstance("v1").setStartLocation(Location.newInstance(0, 0))
+            .setEarliestStart(0.).setLatestArrival(40).build();
 
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(s).addJob(s2).addVehicle(v).build();
         VehicleRoutingAlgorithm algorithm = Jsprit.createAlgorithm(vrp);
         algorithm.setMaxIterations(100);
         VehicleRoutingProblemSolution solution = Solutions.bestOf(algorithm.searchSolutions());
 
-        Assert.assertEquals(0,solution.getUnassignedJobs().size());
+        Assert.assertEquals(0, solution.getUnassignedJobs().size());
     }
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/PickupsAndDeliveries_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/PickupsAndDeliveries_IT.java
index ff8e4aedd..ca4e54359 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/PickupsAndDeliveries_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/PickupsAndDeliveries_IT.java
@@ -23,7 +23,6 @@
 import com.graphhopper.jsprit.core.util.LiLimReader;
 import com.graphhopper.jsprit.core.util.Solutions;
 import org.junit.Test;
-import org.junit.experimental.categories.Category;
 
 import java.util.Collection;
 
@@ -36,7 +35,7 @@ public void whenSolvingLR101InstanceOfLiLim_solutionsMustNoBeWorseThan5PercentOf
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         new LiLimReader(vrpBuilder).read(getClass().getResourceAsStream("lr101.txt"));
         VehicleRoutingProblem vrp = vrpBuilder.build();
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.FAST_REGRET,"true").buildAlgorithm();
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.FAST_REGRET, "true").buildAlgorithm();
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
         assertEquals(1650.8, Solutions.bestOf(solutions).getCost(), 80.);
         assertEquals(19, Solutions.bestOf(solutions).getRoutes().size(), 1);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/RefuseCollectionWithCostsHigherThanTimesAndFiniteFleet_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/RefuseCollectionWithCostsHigherThanTimesAndFiniteFleet_IT.java
index 6d88cef89..1057c3c01 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/RefuseCollectionWithCostsHigherThanTimesAndFiniteFleet_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/RefuseCollectionWithCostsHigherThanTimesAndFiniteFleet_IT.java
@@ -28,7 +28,6 @@
 import com.graphhopper.jsprit.core.util.Solutions;
 import com.graphhopper.jsprit.core.util.VehicleRoutingTransportCostsMatrix;
 import org.junit.Test;
-import org.junit.experimental.categories.Category;
 
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
@@ -45,9 +44,9 @@
     public void testAlgo() {
 
 
-		/*
+        /*
          * create vehicle-type and vehicle
-		 */
+         */
         VehicleTypeImpl.Builder typeBuilder = VehicleTypeImpl.Builder.newInstance("vehicle-type").addCapacityDimension(0, 23);
         typeBuilder.setCostPerDistance(1.0);
         VehicleTypeImpl bigType = typeBuilder.build();
@@ -58,20 +57,20 @@ public void testAlgo() {
         vehicleBuilder.setLatestArrival(220);
         Vehicle bigVehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * start building the problem
-		 */
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.setFleetSize(VehicleRoutingProblem.FleetSize.INFINITE);
         vrpBuilder.addVehicle(bigVehicle);
 
-		/*
+        /*
          * create cost-matrix
-		 */
+         */
         VehicleRoutingTransportCostsMatrix.Builder matrixBuilder = VehicleRoutingTransportCostsMatrix.Builder.newInstance(true);
         /*
          * read demand quantities
-		 */
+         */
         try {
             readDemandQuantities(vrpBuilder);
             readDistances(matrixBuilder);
@@ -104,12 +103,12 @@ private void readDemandQuantities(VehicleRoutingProblem.Builder vrpBuilder) thro
             String[] lineTokens = line.split(",");
             /*
              * build service
-			 */
+             */
             Service service = Service.Builder.newInstance(lineTokens[0]).addSizeDimension(0, Integer.parseInt(lineTokens[1]))
                 .setLocation(Location.newInstance(lineTokens[0])).build();
             /*
-			 * and add it to problem
-			 */
+             * and add it to problem
+             */
             vrpBuilder.addJob(service);
         }
         reader.close();
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/RefuseCollectionWithCostsHigherThanTimesAndFiniteFleet_withTimeAndDistanceCosts_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/RefuseCollectionWithCostsHigherThanTimesAndFiniteFleet_withTimeAndDistanceCosts_IT.java
index 59586e9ce..1b7045ecf 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/RefuseCollectionWithCostsHigherThanTimesAndFiniteFleet_withTimeAndDistanceCosts_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/RefuseCollectionWithCostsHigherThanTimesAndFiniteFleet_withTimeAndDistanceCosts_IT.java
@@ -16,6 +16,7 @@
  * limitations under the License.
  */
 package com.graphhopper.jsprit.core.algorithm;
+
 import com.graphhopper.jsprit.core.algorithm.box.GreedySchrimpfFactory;
 import com.graphhopper.jsprit.core.algorithm.termination.IterationWithoutImprovementTermination;
 import com.graphhopper.jsprit.core.problem.Location;
@@ -28,7 +29,6 @@
 import com.graphhopper.jsprit.core.util.Solutions;
 import com.graphhopper.jsprit.core.util.VehicleRoutingTransportCostsMatrix;
 import org.junit.Test;
-import org.junit.experimental.categories.Category;
 
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
@@ -45,9 +45,9 @@
     public void testAlgo() {
 
 
-		/*
+        /*
          * create vehicle-type and vehicle
-		 */
+         */
         VehicleTypeImpl.Builder typeBuilder = VehicleTypeImpl.Builder.newInstance("vehicle-type").addCapacityDimension(0, 23);
         typeBuilder.setCostPerDistance(1.0).setCostPerTime(1.);
         VehicleTypeImpl bigType = typeBuilder.build();
@@ -58,20 +58,20 @@ public void testAlgo() {
         vehicleBuilder.setLatestArrival(220);
         Vehicle bigVehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * start building the problem
-		 */
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.setFleetSize(VehicleRoutingProblem.FleetSize.INFINITE);
         vrpBuilder.addVehicle(bigVehicle);
 
-		/*
+        /*
          * create cost-matrix
-		 */
+         */
         VehicleRoutingTransportCostsMatrix.Builder matrixBuilder = VehicleRoutingTransportCostsMatrix.Builder.newInstance(true);
         /*
          * read demand quantities
-		 */
+         */
         try {
             readDemandQuantities(vrpBuilder);
             readDistances(matrixBuilder);
@@ -92,7 +92,7 @@ public void testAlgo() {
     }
 
 
-    private void readDemandQuantities(VehicleRoutingProblem.Builder vrpBuilder) throws  IOException {
+    private void readDemandQuantities(VehicleRoutingProblem.Builder vrpBuilder) throws IOException {
         BufferedReader reader = new BufferedReader(new InputStreamReader(getClass().getResourceAsStream("refuseCollectionExample_Quantities")));
         String line = null;
         boolean firstLine = true;
@@ -104,12 +104,12 @@ private void readDemandQuantities(VehicleRoutingProblem.Builder vrpBuilder) thro
             String[] lineTokens = line.split(",");
             /*
              * build service
-			 */
+             */
             Service service = Service.Builder.newInstance(lineTokens[0]).addSizeDimension(0, Integer.parseInt(lineTokens[1]))
                 .setLocation(Location.newInstance(lineTokens[0])).build();
             /*
-			 * and add it to problem
-			 */
+             * and add it to problem
+             */
             vrpBuilder.addJob(service);
         }
         reader.close();
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/RefuseCollection_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/RefuseCollection_IT.java
index fc4d5aabc..8c4f9cc9e 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/RefuseCollection_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/RefuseCollection_IT.java
@@ -29,12 +29,10 @@
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
-
 import com.graphhopper.jsprit.core.util.Solutions;
 import com.graphhopper.jsprit.core.util.VehicleRoutingTransportCostsMatrix;
 import org.junit.Assert;
 import org.junit.Test;
-import org.junit.experimental.categories.Category;
 
 import java.io.BufferedReader;
 import java.io.IOException;
@@ -49,9 +47,9 @@
     @Test
     public void whenReadingServices_itShouldCalculateCorrectly() {
 
-		/*
+        /*
          * create vehicle-type and vehicle
-		 */
+         */
         VehicleTypeImpl.Builder typeBuilder = VehicleTypeImpl.Builder.newInstance("vehicle-type").addCapacityDimension(0, 23);
         typeBuilder.setCostPerDistance(1.0);
         VehicleTypeImpl bigType = typeBuilder.build();
@@ -61,20 +59,20 @@ public void whenReadingServices_itShouldCalculateCorrectly() {
         vehicleBuilder.setType(bigType);
         VehicleImpl bigVehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * start building the problem
-		 */
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.setFleetSize(VehicleRoutingProblem.FleetSize.INFINITE);
         vrpBuilder.addVehicle(bigVehicle);
 
-		/*
+        /*
          * create cost-matrix
-		 */
+         */
         VehicleRoutingTransportCostsMatrix.Builder matrixBuilder = VehicleRoutingTransportCostsMatrix.Builder.newInstance(true);
         /*
          * read demand quantities
-		 */
+         */
         readDemandQuantitiesAsServices(vrpBuilder);
         readDistances(matrixBuilder);
 
@@ -88,12 +86,73 @@ public void whenReadingServices_itShouldCalculateCorrectly() {
         Assert.assertEquals(2, Solutions.bestOf(solutions).getRoutes().size());
     }
 
+    private void readDemandQuantitiesAsServices(VehicleRoutingProblem.Builder vrpBuilder) {
+        BufferedReader reader = getBufferedReader("refuseCollectionExample_Quantities");
+        String line;
+        boolean firstLine = true;
+        while ((line = readLine(reader)) != null) {
+            if (firstLine) {
+                firstLine = false;
+                continue;
+            }
+            String[] lineTokens = line.split(",");
+            /*
+             * build service
+             */
+            Service service = Service.Builder.newInstance(lineTokens[0]).addSizeDimension(0, Integer.parseInt(lineTokens[1]))
+                .setLocation(Location.newInstance(lineTokens[0])).build();
+            /*
+             * and add it to problem
+             */
+            vrpBuilder.addJob(service);
+        }
+        close(reader);
+    }
+
+    private void readDistances(VehicleRoutingTransportCostsMatrix.Builder matrixBuilder) {
+        BufferedReader reader = getBufferedReader("refuseCollectionExample_Distances");
+        String line;
+        boolean firstLine = true;
+        while ((line = readLine(reader)) != null) {
+            if (firstLine) {
+                firstLine = false;
+                continue;
+            }
+            String[] lineTokens = line.split(",");
+            matrixBuilder.addTransportDistance(lineTokens[0], lineTokens[1], Integer.parseInt(lineTokens[2]));
+            matrixBuilder.addTransportTime(lineTokens[0], lineTokens[1], Integer.parseInt(lineTokens[2]));
+        }
+        close(reader);
+    }
+
+    private BufferedReader getBufferedReader(String s) {
+        return new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(s)));
+    }
+
+    private static String readLine(BufferedReader reader) {
+        String line = null;
+        try {
+            line = reader.readLine();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return line;
+    }
+
+    private static void close(Reader reader) {
+        try {
+            reader.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
     @Test
     public void whenReadingServices_usingJsprit_itShouldCalculateCorrectly() {
 
-		/*
+        /*
          * create vehicle-type and vehicle
-		 */
+         */
         VehicleTypeImpl.Builder typeBuilder = VehicleTypeImpl.Builder.newInstance("vehicle-type").addCapacityDimension(0, 23);
         typeBuilder.setCostPerDistance(1.0);
         VehicleTypeImpl bigType = typeBuilder.build();
@@ -103,20 +162,20 @@ public void whenReadingServices_usingJsprit_itShouldCalculateCorrectly() {
         vehicleBuilder.setType(bigType);
         VehicleImpl bigVehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * start building the problem
-		 */
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.setFleetSize(VehicleRoutingProblem.FleetSize.INFINITE);
         vrpBuilder.addVehicle(bigVehicle);
 
-		/*
+        /*
          * create cost-matrix
-		 */
+         */
         VehicleRoutingTransportCostsMatrix.Builder matrixBuilder = VehicleRoutingTransportCostsMatrix.Builder.newInstance(true);
         /*
-		 * read demand quantities
-		 */
+         * read demand quantities
+         */
         readDemandQuantitiesAsServices(vrpBuilder);
         readDistances(matrixBuilder);
 
@@ -133,9 +192,9 @@ public void whenReadingServices_usingJsprit_itShouldCalculateCorrectly() {
     @Test
     public void whenReadingPickups_itShouldCalculateCorrectly() {
 
-		/*
-		 * create vehicle-type and vehicle
-		 */
+        /*
+         * create vehicle-type and vehicle
+         */
         VehicleTypeImpl.Builder typeBuilder = VehicleTypeImpl.Builder.newInstance("vehicle-type").addCapacityDimension(0, 23);
         typeBuilder.setCostPerDistance(1.0);
         VehicleTypeImpl bigType = typeBuilder.build();
@@ -145,20 +204,20 @@ public void whenReadingPickups_itShouldCalculateCorrectly() {
         vehicleBuilder.setType(bigType);
         VehicleImpl bigVehicle = vehicleBuilder.build();
 
-		/*
-		 * start building the problem
-		 */
+        /*
+         * start building the problem
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.setFleetSize(VehicleRoutingProblem.FleetSize.INFINITE);
         vrpBuilder.addVehicle(bigVehicle);
 
-		/*
-		 * create cost-matrix
-		 */
+        /*
+         * create cost-matrix
+         */
         VehicleRoutingTransportCostsMatrix.Builder matrixBuilder = VehicleRoutingTransportCostsMatrix.Builder.newInstance(true);
-		/*
-		 * read demand quantities
-		 */
+        /*
+         * read demand quantities
+         */
         readDemandQuantitiesAsPickups(vrpBuilder);
         readDistances(matrixBuilder);
 
@@ -172,12 +231,35 @@ public void whenReadingPickups_itShouldCalculateCorrectly() {
         Assert.assertEquals(2, Solutions.bestOf(solutions).getRoutes().size());
     }
 
+    private void readDemandQuantitiesAsPickups(VehicleRoutingProblem.Builder vrpBuilder) {
+        BufferedReader reader = getBufferedReader("refuseCollectionExample_Quantities");
+        String line;
+        boolean firstLine = true;
+        while ((line = readLine(reader)) != null) {
+            if (firstLine) {
+                firstLine = false;
+                continue;
+            }
+            String[] lineTokens = line.split(",");
+            /*
+             * build service
+             */
+            Pickup service = Pickup.Builder.newInstance(lineTokens[0]).addSizeDimension(0, Integer.parseInt(lineTokens[1]))
+                .setLocation(Location.newInstance(lineTokens[0])).build();
+            /*
+             * and add it to problem
+             */
+            vrpBuilder.addJob(service);
+        }
+        close(reader);
+    }
+
     @Test
     public void whenReadingDeliveries_itShouldCalculateCorrectly() {
 
-		/*
-		 * create vehicle-type and vehicle
-		 */
+        /*
+         * create vehicle-type and vehicle
+         */
         VehicleTypeImpl.Builder typeBuilder = VehicleTypeImpl.Builder.newInstance("vehicle-type").addCapacityDimension(0, 23);
         typeBuilder.setCostPerDistance(1.0);
         VehicleTypeImpl bigType = typeBuilder.build();
@@ -187,20 +269,20 @@ public void whenReadingDeliveries_itShouldCalculateCorrectly() {
         vehicleBuilder.setType(bigType);
         VehicleImpl bigVehicle = vehicleBuilder.build();
 
-		/*
-		 * start building the problem
-		 */
+        /*
+         * start building the problem
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.setFleetSize(VehicleRoutingProblem.FleetSize.INFINITE);
         vrpBuilder.addVehicle(bigVehicle);
 
-		/*
-		 * create cost-matrix
-		 */
+        /*
+         * create cost-matrix
+         */
         VehicleRoutingTransportCostsMatrix.Builder matrixBuilder = VehicleRoutingTransportCostsMatrix.Builder.newInstance(true);
-		/*
-		 * read demand quantities
-		 */
+        /*
+         * read demand quantities
+         */
         readDemandQuantitiesAsDeliveries(vrpBuilder);
         readDistances(matrixBuilder);
 
@@ -214,57 +296,6 @@ public void whenReadingDeliveries_itShouldCalculateCorrectly() {
         Assert.assertEquals(2, Solutions.bestOf(solutions).getRoutes().size());
     }
 
-
-    private void readDemandQuantitiesAsServices(VehicleRoutingProblem.Builder vrpBuilder) {
-        BufferedReader reader = getBufferedReader("refuseCollectionExample_Quantities");
-        String line;
-        boolean firstLine = true;
-        while ((line = readLine(reader)) != null) {
-            if (firstLine) {
-                firstLine = false;
-                continue;
-            }
-            String[] lineTokens = line.split(",");
-			/*
-			 * build service
-			 */
-            Service service = Service.Builder.newInstance(lineTokens[0]).addSizeDimension(0, Integer.parseInt(lineTokens[1]))
-                .setLocation(Location.newInstance(lineTokens[0])).build();
-			/*
-			 * and add it to problem
-			 */
-            vrpBuilder.addJob(service);
-        }
-        close(reader);
-    }
-
-    private BufferedReader getBufferedReader(String s) {
-        return new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(s)));
-    }
-
-    private void readDemandQuantitiesAsPickups(VehicleRoutingProblem.Builder vrpBuilder) {
-        BufferedReader reader = getBufferedReader("refuseCollectionExample_Quantities");
-        String line;
-        boolean firstLine = true;
-        while ((line = readLine(reader)) != null) {
-            if (firstLine) {
-                firstLine = false;
-                continue;
-            }
-            String[] lineTokens = line.split(",");
-			/*
-			 * build service
-			 */
-            Pickup service = Pickup.Builder.newInstance(lineTokens[0]).addSizeDimension(0, Integer.parseInt(lineTokens[1]))
-                .setLocation(Location.newInstance(lineTokens[0])).build();
-			/*
-			 * and add it to problem
-			 */
-            vrpBuilder.addJob(service);
-        }
-        close(reader);
-    }
-
     private void readDemandQuantitiesAsDeliveries(VehicleRoutingProblem.Builder vrpBuilder) {
         BufferedReader reader = getBufferedReader("refuseCollectionExample_Quantities");
         String line;
@@ -275,53 +306,18 @@ private void readDemandQuantitiesAsDeliveries(VehicleRoutingProblem.Builder vrpB
                 continue;
             }
             String[] lineTokens = line.split(",");
-			/*
-			 * build service
-			 */
+            /*
+             * build service
+             */
             Delivery service = (Delivery) Delivery.Builder.newInstance(lineTokens[0]).addSizeDimension(0, Integer.parseInt(lineTokens[1]))
                 .setLocation(Location.newInstance(lineTokens[0])).build();
-			/*
-			 * and add it to problem
-			 */
+            /*
+             * and add it to problem
+             */
             vrpBuilder.addJob(service);
         }
         close(reader);
     }
 
-    private static String readLine(BufferedReader reader) {
-        String line = null;
-        try {
-            line = reader.readLine();
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-        return line;
-    }
-
-    private static void close(Reader reader) {
-        try {
-            reader.close();
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-
-    private void readDistances(VehicleRoutingTransportCostsMatrix.Builder matrixBuilder) {
-        BufferedReader reader = getBufferedReader("refuseCollectionExample_Distances");
-        String line;
-        boolean firstLine = true;
-        while ((line = readLine(reader)) != null) {
-            if (firstLine) {
-                firstLine = false;
-                continue;
-            }
-            String[] lineTokens = line.split(",");
-            matrixBuilder.addTransportDistance(lineTokens[0], lineTokens[1], Integer.parseInt(lineTokens[2]));
-            matrixBuilder.addTransportTime(lineTokens[0], lineTokens[1], Integer.parseInt(lineTokens[2]));
-        }
-        close(reader);
-    }
-
 
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/SolomonSkills_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/SolomonSkills_IT.java
index 928ac039b..f39940ec5 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/SolomonSkills_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/SolomonSkills_IT.java
@@ -32,7 +32,6 @@
 import com.graphhopper.jsprit.core.util.Solutions;
 import com.graphhopper.jsprit.core.util.TestUtils;
 import org.junit.Test;
-import org.junit.experimental.categories.Category;
 
 import java.util.Collection;
 
@@ -77,7 +76,7 @@ public void itShouldMakeCorrectAssignmentAccordingToSkills() {
         skillProblemBuilder.setFleetSize(VehicleRoutingProblem.FleetSize.FINITE);
         VehicleRoutingProblem skillProblem = skillProblemBuilder.build();
 
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(skillProblem).setProperty(Jsprit.Parameter.FAST_REGRET,"true").buildAlgorithm();
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(skillProblem).setProperty(Jsprit.Parameter.FAST_REGRET, "true").buildAlgorithm();
 
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
         VehicleRoutingProblemSolution solution = Solutions.bestOf(solutions);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/Solomon_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/Solomon_IT.java
index 055696f9e..24c5880a7 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/Solomon_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/Solomon_IT.java
@@ -25,7 +25,6 @@
 import com.graphhopper.jsprit.core.util.Solutions;
 import org.junit.Assert;
 import org.junit.Test;
-import org.junit.experimental.categories.Category;
 
 import java.util.Collection;
 
@@ -40,7 +39,7 @@ public void itShouldFindTheBestKnownSolution() {
         new SolomonReader(vrpBuilder).read(getClass().getResourceAsStream("C101.txt"));
         VehicleRoutingProblem vrp = vrpBuilder.build();
 
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.FAST_REGRET,"true").buildAlgorithm();
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.FAST_REGRET, "true").buildAlgorithm();
         vra.setMaxIterations(2000);
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
         Assert.assertEquals(828.94, Solutions.bestOf(solutions).getCost(), 0.01);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/VariableDepartureAndWaitingTime_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/VariableDepartureAndWaitingTime_IT.java
index 3232ca4e7..82b6b3353 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/VariableDepartureAndWaitingTime_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/VariableDepartureAndWaitingTime_IT.java
@@ -39,19 +39,13 @@
 import junit.framework.Assert;
 import org.junit.Before;
 import org.junit.Test;
-import org.junit.experimental.categories.Category;
 
 /**
  * Created by schroeder on 22/07/15.
  */
 public class VariableDepartureAndWaitingTime_IT {
 
-    static interface AlgorithmFactory {
-        VehicleRoutingAlgorithm createAlgorithm(VehicleRoutingProblem vrp);
-    }
-
     VehicleRoutingActivityCosts activityCosts;
-
     AlgorithmFactory algorithmFactory;
 
     @Before
@@ -122,5 +116,9 @@ public void withTimeWindowsShouldWork() {
         Assert.assertEquals(40. + 1000., solution.getCost());
     }
 
+    static interface AlgorithmFactory {
+        VehicleRoutingAlgorithm createAlgorithm(VehicleRoutingProblem vrp);
+    }
+
 
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/VehicleRoutingAlgorithmTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/VehicleRoutingAlgorithmTest.java
index 1deed4ccb..02fa050c7 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/VehicleRoutingAlgorithmTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/VehicleRoutingAlgorithmTest.java
@@ -48,21 +48,6 @@ public void whenSettingIterationsWithMaxIterations_itIsSetCorrectly() {
         assertEquals(50, algorithm.getMaxIterations());
     }
 
-    private static class CountIterations implements IterationStartsListener {
-
-        private int countIterations = 0;
-
-        @Override
-        public void informIterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
-            countIterations++;
-        }
-
-        public int getCountIterations() {
-            return countIterations;
-        }
-
-    }
-
     @Test
     public void whenSettingIterationsWithMaxIterations_iterAreExecutedCorrectly() {
         SearchStrategyManager stratManager = mock(SearchStrategyManager.class);
@@ -182,4 +167,19 @@ public boolean isPrematureBreak(SearchStrategy.DiscoveredSolution discoveredSolu
         assertEquals(25, counter.getCountIterations());
     }
 
+    private static class CountIterations implements IterationStartsListener {
+
+        private int countIterations = 0;
+
+        @Override
+        public void informIterationStarts(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
+            countIterations++;
+        }
+
+        public int getCountIterations() {
+            return countIterations;
+        }
+
+    }
+
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/acceptor/SchrimpfAcceptanceTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/acceptor/SchrimpfAcceptanceTest.java
index 7ff3342be..ad1fad2f5 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/acceptor/SchrimpfAcceptanceTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/acceptor/SchrimpfAcceptanceTest.java
@@ -36,10 +36,6 @@
     protected SchrimpfAcceptance schrimpfAcceptance;
     protected Collection<VehicleRoutingProblemSolution> memory;
 
-    protected static VehicleRoutingProblemSolution createSolutionWithCost(double cost) {
-        return when(mock(VehicleRoutingProblemSolution.class).getCost()).thenReturn(cost).getMock();
-    }
-
     @SuppressWarnings("deprecation")
     @Before
     public void setup() {
@@ -52,6 +48,16 @@ public void setup() {
         assertTrue("Solution (initial cost = 2.0) should be accepted since the memory is empty", schrimpfAcceptance.acceptSolution(memory, createSolutionWithCost(2.0)));
     }
 
+    @Test
+    public void respectsTheNonZeroThreshold_usingWorstCostSolution() {
+        schrimpfAcceptance.setInitialThreshold(0.5);
+        /*
+         * it should be accepted since 2.1 < 2.0 + 0.5 (2.0 is the best solution found so far and 0.5 the ini threshold
+         * since the threshold of 0.5 allows new solutions to be <0.5 worse than the current best solution
+         */
+        assertTrue("Worst cost solution (2.1 > 2.0) should be accepted", schrimpfAcceptance.acceptSolution(memory, createSolutionWithCost(2.1)));
+    }
+
     @Test
     public void respectsTheZeroThreshold_usingWorstCostSolution() {
         assertFalse("Worst cost solution (2.1 > 2.0) should not be accepted", schrimpfAcceptance.acceptSolution(memory, createSolutionWithCost(2.1)));
@@ -67,14 +73,8 @@ public void respectsTheZeroThreshold_usingSameCostSolution() {
         assertFalse("Same cost solution (2.0 == 2.0) should not be accepted", schrimpfAcceptance.acceptSolution(memory, createSolutionWithCost(2.0)));
     }
 
-    @Test
-    public void respectsTheNonZeroThreshold_usingWorstCostSolution() {
-        schrimpfAcceptance.setInitialThreshold(0.5);
-        /*
-         * it should be accepted since 2.1 < 2.0 + 0.5 (2.0 is the best solution found so far and 0.5 the ini threshold
-		 * since the threshold of 0.5 allows new solutions to be <0.5 worse than the current best solution
-		 */
-        assertTrue("Worst cost solution (2.1 > 2.0) should be accepted", schrimpfAcceptance.acceptSolution(memory, createSolutionWithCost(2.1)));
+    protected static VehicleRoutingProblemSolution createSolutionWithCost(double cost) {
+        return when(mock(VehicleRoutingProblemSolution.class).getCost()).thenReturn(cost).getMock();
     }
 
     @Test
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionConsideringFixCostsCalculatorTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionConsideringFixCostsCalculatorTest.java
index e35273a8a..efa913bb1 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionConsideringFixCostsCalculatorTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionConsideringFixCostsCalculatorTest.java
@@ -358,11 +358,11 @@ public void whenOldVehicleIsNotNullAndCurrentLoadIs25AndSolutionIs50PercentCompl
         //(0.5*absFix + 0.5*relFix) * 0.5 * 0.= (0.5*(100-50)+0.5*(75-25))*0.5*0.5 = 12.5
         /*
          * (0.5*(100-50)+0.5*(
-		 * relFixNew - relFixOld = (75/100+100/400)/2.*100 - ((25/50+100/100)/2.*50.) =
-		 * )*0.5*0.5
-		 * = (0.5*(100-50)+0.5*((75/100+100/400)/2.*100 - ((25/50+100/100)/2.*50.)))*0.5*0.5
-		 * = (0.5*(100-50)+0.5*12.5)*0.5*0.5 = 7.8125
-		 */
+         * relFixNew - relFixOld = (75/100+100/400)/2.*100 - ((25/50+100/100)/2.*50.) =
+         * )*0.5*0.5
+         * = (0.5*(100-50)+0.5*((75/100+100/400)/2.*100 - ((25/50+100/100)/2.*50.)))*0.5*0.5
+         * = (0.5*(100-50)+0.5*12.5)*0.5*0.5 = 7.8125
+         */
         assertEquals(7.8125, absFixedCosts.getCosts(context) + relFixedCosts.getCosts(context), 0.01);
     }
 
@@ -388,11 +388,11 @@ public void whenOldVehicleIsMoreExpensive() {
         //(0.5*absFix + 0.5*relFix) * 0.5 * 0.= (0.5*(100-50)+0.5*(75-25))*0.5*0.5 = 12.5
         /*
          * (0.5*(100-50)+0.5*(
-		 * relFixNew - relFixOld = (75/100+100/400)/2.*100 - ((25/50+100/100)/2.*50.) =
-		 * )*0.5*0.5
-		 * = (0.5*(100-50)+0.5*((75/100+100/400)/2.*100 - ((25/50+100/100)/2.*50.)))*0.5*0.5
-		 * = (0.5*(100-50)+0.5*12.5)*0.5*0.5 = 7.8125
-		 */
+         * relFixNew - relFixOld = (75/100+100/400)/2.*100 - ((25/50+100/100)/2.*50.) =
+         * )*0.5*0.5
+         * = (0.5*(100-50)+0.5*((75/100+100/400)/2.*100 - ((25/50+100/100)/2.*50.)))*0.5*0.5
+         * = (0.5*(100-50)+0.5*12.5)*0.5*0.5 = 7.8125
+         */
 
         JobInsertionContext context = new JobInsertionContext(route, job, medium, null, 0d);
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionTest.java
index fbdf90082..600df0b93 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/RegretInsertionTest.java
@@ -66,6 +66,65 @@ public void noRoutesShouldBeCorrect() {
         Assert.assertEquals(1, routes.size());
     }
 
+    private JobInsertionCostsCalculator getCalculator(final VehicleRoutingProblem vrp) {
+        return new JobInsertionCostsCalculator() {
+
+            @Override
+            public InsertionData getInsertionData(VehicleRoute currentRoute, Job newJob, Vehicle newVehicle, double newVehicleDepartureTime, Driver newDriver, double bestKnownCosts) {
+                Service service = (Service) newJob;
+                Vehicle vehicle = vrp.getVehicles().iterator().next();
+                InsertionData iData;
+                if (currentRoute.isEmpty()) {
+                    double mc = getCost(service.getLocation(), vehicle.getStartLocation());
+                    iData = new InsertionData(2 * mc, -1, 0, vehicle, newDriver);
+                    iData.getEvents().add(new InsertActivity(currentRoute, vehicle, vrp.copyAndGetActivities(newJob).get(0), 0));
+                    iData.getEvents().add(new SwitchVehicle(currentRoute, vehicle, newVehicleDepartureTime));
+                } else {
+                    double best = Double.MAX_VALUE;
+                    int bestIndex = 0;
+                    int index = 0;
+                    TourActivity prevAct = currentRoute.getStart();
+                    for (TourActivity act : currentRoute.getActivities()) {
+                        double mc = getMarginalCost(service, prevAct, act);
+                        if (mc < best) {
+                            best = mc;
+                            bestIndex = index;
+                        }
+                        index++;
+                        prevAct = act;
+                    }
+                    double mc = getMarginalCost(service, prevAct, currentRoute.getEnd());
+                    if (mc < best) {
+                        best = mc;
+                        bestIndex = index;
+                    }
+                    iData = new InsertionData(best, -1, bestIndex, vehicle, newDriver);
+                    iData.getEvents().add(new InsertActivity(currentRoute, vehicle, vrp.copyAndGetActivities(newJob).get(0), bestIndex));
+                    iData.getEvents().add(new SwitchVehicle(currentRoute, vehicle, newVehicleDepartureTime));
+                }
+                return iData;
+            }
+
+            private double getCost(Location loc1, Location loc2) {
+                return vrp.getTransportCosts().getTransportCost(loc1, loc2, 0., null, null);
+            }
+
+            private double getMarginalCost(Service service, TourActivity prevAct, TourActivity act) {
+                double prev_new = getCost(prevAct.getLocation(), service.getLocation());
+                double new_act = getCost(service.getLocation(), act.getLocation());
+                double prev_act = getCost(prevAct.getLocation(), act.getLocation());
+                return prev_new + new_act - prev_act;
+            }
+        };
+
+//        LocalActivityInsertionCostsCalculator local = new LocalActivityInsertionCostsCalculator(vrp.getTransportCosts(),vrp.getActivityCosts());
+//        StateManager stateManager = new StateManager(vrp);
+//        ConstraintManager manager = new ConstraintManager(vrp,stateManager);
+//        ServiceInsertionCalculator calculator = new ServiceInsertionCalculator(vrp.getTransportCosts(), local, manager);
+//        calculator.setJobActivityFactory(vrp.getJobActivityFactory());
+//        return calculator;
+    }
+
     @Test
     public void noJobsInRouteShouldBeCorrect() {
         Service s1 = Service.Builder.newInstance("s1").setLocation(Location.newInstance(0, 10)).build();
@@ -113,11 +172,11 @@ public void solutionWithFastRegretMustBeCorrect() {
             .addVehicle(v1).addVehicle(v2).setFleetSize(VehicleRoutingProblem.FleetSize.FINITE).build();
 
         StateManager stateManager = new StateManager(vrp);
-        ConstraintManager constraintManager = new ConstraintManager(vrp,stateManager);
+        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
 
         VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp)
             .addCoreStateAndConstraintStuff(true)
-            .setProperty(Jsprit.Parameter.FAST_REGRET,"true")
+            .setProperty(Jsprit.Parameter.FAST_REGRET, "true")
             .setStateAndConstraintManager(stateManager, constraintManager).buildAlgorithm();
 
         VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
@@ -125,92 +184,14 @@ public void solutionWithFastRegretMustBeCorrect() {
         Assert.assertEquals(2, solution.getRoutes().size());
     }
 
-    static class JobInRouteUpdater implements StateUpdater, ActivityVisitor {
-
-        private StateManager stateManager;
-
-        private StateId job1AssignedId;
-
-        private StateId job2AssignedId;
-
-        private VehicleRoute route;
-
-        public JobInRouteUpdater(StateManager stateManager, StateId job1AssignedId, StateId job2AssignedId) {
-            this.stateManager = stateManager;
-            this.job1AssignedId = job1AssignedId;
-            this.job2AssignedId = job2AssignedId;
-        }
-
-        @Override
-        public void begin(VehicleRoute route) {
-            this.route = route;
-        }
-
-        @Override
-        public void visit(TourActivity activity) {
-            if(((TourActivity.JobActivity)activity).getJob().getId().equals("s1")){
-                stateManager.putProblemState(job1AssignedId,Boolean.class,true);
-            }
-            if(((TourActivity.JobActivity)activity).getJob().getId().equals("s2")){
-                stateManager.putProblemState(job2AssignedId,Boolean.class,true);
-            }
-
-        }
-
-        @Override
-        public void finish() {
-
-        }
-    }
-
-    static class RouteConstraint implements HardRouteConstraint{
-
-        private final StateId job1AssignedId;
-
-        private final StateId job2AssignedId;
-
-        private StateManager stateManager;
-
-        public RouteConstraint(StateId job1Assigned, StateId job2Assigned, StateManager stateManager) {
-            this.job1AssignedId = job1Assigned;
-            this.job2AssignedId = job2Assigned;
-            this.stateManager = stateManager;
-        }
-
-        @Override
-        public boolean fulfilled(JobInsertionContext insertionContext) {
-            if(insertionContext.getJob().getId().equals("s1")){
-                Boolean job2Assigned = stateManager.getProblemState(job2AssignedId,Boolean.class);
-                if(job2Assigned == null || job2Assigned == false) return true;
-                else {
-                    for(Job j : insertionContext.getRoute().getTourActivities().getJobs()){
-                        if(j.getId().equals("s2")) return true;
-                    }
-                }
-                return false;
-            }
-            if(insertionContext.getJob().getId().equals("s2")){
-                Boolean job1Assigned = stateManager.getProblemState(job1AssignedId,Boolean.class);
-                if(job1Assigned == null || job1Assigned == false) return true;
-                else {
-                    for(Job j : insertionContext.getRoute().getTourActivities().getJobs()){
-                        if(j.getId().equals("s1")) return true;
-                    }
-                }
-                return false;
-            }
-            return true;
-        }
-    }
-
     @Test
     public void solutionWithConstraintAndWithFastRegretMustBeCorrect() {
-        Service s1 = Service.Builder.newInstance("s1").addSizeDimension(0,1).setLocation(Location.newInstance(0, 10)).build();
-        Service s2 = Service.Builder.newInstance("s2").addSizeDimension(0,1).setLocation(Location.newInstance(0, -10)).build();
-        Service s3 = Service.Builder.newInstance("s3").addSizeDimension(0,1).setLocation(Location.newInstance(0, -11)).build();
-        Service s4 = Service.Builder.newInstance("s4").addSizeDimension(0,1).setLocation(Location.newInstance(0, 11)).build();
+        Service s1 = Service.Builder.newInstance("s1").addSizeDimension(0, 1).setLocation(Location.newInstance(0, 10)).build();
+        Service s2 = Service.Builder.newInstance("s2").addSizeDimension(0, 1).setLocation(Location.newInstance(0, -10)).build();
+        Service s3 = Service.Builder.newInstance("s3").addSizeDimension(0, 1).setLocation(Location.newInstance(0, -11)).build();
+        Service s4 = Service.Builder.newInstance("s4").addSizeDimension(0, 1).setLocation(Location.newInstance(0, 11)).build();
 
-        VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0,2).build();
+        VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0, 2).build();
         VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setType(type).setStartLocation(Location.newInstance(0, 10)).build();
         VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setType(type).setStartLocation(Location.newInstance(0, -10)).build();
         final VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(s1).addJob(s2).addJob(s3).addJob(s4)
@@ -219,9 +200,9 @@ public void solutionWithConstraintAndWithFastRegretMustBeCorrect() {
         final StateManager stateManager = new StateManager(vrp);
         StateId job1Assigned = stateManager.createStateId("job1-assigned");
         StateId job2Assigned = stateManager.createStateId("job2-assigned");
-        stateManager.addStateUpdater(new JobInRouteUpdater(stateManager,job1Assigned,job2Assigned));
-        ConstraintManager constraintManager = new ConstraintManager(vrp,stateManager);
-        constraintManager.addConstraint(new RouteConstraint(job1Assigned,job2Assigned,stateManager));
+        stateManager.addStateUpdater(new JobInRouteUpdater(stateManager, job1Assigned, job2Assigned));
+        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
+        constraintManager.addConstraint(new RouteConstraint(job1Assigned, job2Assigned, stateManager));
         constraintManager.setDependencyType("s1", DependencyType.INTRA_ROUTE);
         constraintManager.setDependencyType("s2", DependencyType.INTRA_ROUTE);
 
@@ -240,12 +221,11 @@ public void solutionWithConstraintAndWithFastRegretMustBeCorrect() {
             .buildAlgorithm();
 
         VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
-        for(VehicleRoute route : solution.getRoutes()){
-            if(route.getTourActivities().servesJob(s1)){
-                if(!route.getTourActivities().servesJob(s2)){
+        for (VehicleRoute route : solution.getRoutes()) {
+            if (route.getTourActivities().servesJob(s1)) {
+                if (!route.getTourActivities().servesJob(s2)) {
                     Assert.assertFalse(true);
-                }
-                else Assert.assertTrue(true);
+                } else Assert.assertTrue(true);
             }
         }
 //        Assert.assertEquals(1, solution.getRoutes().size());
@@ -253,12 +233,12 @@ public void solutionWithConstraintAndWithFastRegretMustBeCorrect() {
 
     @Test
     public void solutionWithConstraintAndWithFastRegretConcurrentMustBeCorrect() {
-        Service s1 = Service.Builder.newInstance("s1").addSizeDimension(0,1).setLocation(Location.newInstance(0, 10)).build();
-        Service s2 = Service.Builder.newInstance("s2").addSizeDimension(0,1).setLocation(Location.newInstance(0, -10)).build();
-        Service s3 = Service.Builder.newInstance("s3").addSizeDimension(0,1).setLocation(Location.newInstance(0, -11)).build();
-        Service s4 = Service.Builder.newInstance("s4").addSizeDimension(0,1).setLocation(Location.newInstance(0, 11)).build();
+        Service s1 = Service.Builder.newInstance("s1").addSizeDimension(0, 1).setLocation(Location.newInstance(0, 10)).build();
+        Service s2 = Service.Builder.newInstance("s2").addSizeDimension(0, 1).setLocation(Location.newInstance(0, -10)).build();
+        Service s3 = Service.Builder.newInstance("s3").addSizeDimension(0, 1).setLocation(Location.newInstance(0, -11)).build();
+        Service s4 = Service.Builder.newInstance("s4").addSizeDimension(0, 1).setLocation(Location.newInstance(0, 11)).build();
 
-        VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0,2).build();
+        VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0, 2).build();
         VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setType(type).setStartLocation(Location.newInstance(0, 10)).build();
         VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setType(type).setStartLocation(Location.newInstance(0, -10)).build();
         final VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(s1).addJob(s2).addJob(s3).addJob(s4)
@@ -267,26 +247,25 @@ public void solutionWithConstraintAndWithFastRegretConcurrentMustBeCorrect() {
         final StateManager stateManager = new StateManager(vrp);
         StateId job1Assigned = stateManager.createStateId("job1-assigned");
         StateId job2Assigned = stateManager.createStateId("job2-assigned");
-        stateManager.addStateUpdater(new JobInRouteUpdater(stateManager,job1Assigned,job2Assigned));
-        ConstraintManager constraintManager = new ConstraintManager(vrp,stateManager);
-        constraintManager.addConstraint(new RouteConstraint(job1Assigned,job2Assigned,stateManager));
+        stateManager.addStateUpdater(new JobInRouteUpdater(stateManager, job1Assigned, job2Assigned));
+        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
+        constraintManager.addConstraint(new RouteConstraint(job1Assigned, job2Assigned, stateManager));
         constraintManager.setDependencyType("s1", DependencyType.INTRA_ROUTE);
         constraintManager.setDependencyType("s2", DependencyType.INTRA_ROUTE);
 
         VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp)
             .addCoreStateAndConstraintStuff(true)
             .setProperty(Jsprit.Parameter.FAST_REGRET, "true")
-            .setProperty(Jsprit.Parameter.THREADS,"4")
+            .setProperty(Jsprit.Parameter.THREADS, "4")
             .setStateAndConstraintManager(stateManager, constraintManager)
             .buildAlgorithm();
 
         VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
-        for(VehicleRoute route : solution.getRoutes()){
-            if(route.getTourActivities().servesJob(s1)){
-                if(!route.getTourActivities().servesJob(s2)){
+        for (VehicleRoute route : solution.getRoutes()) {
+            if (route.getTourActivities().servesJob(s1)) {
+                if (!route.getTourActivities().servesJob(s2)) {
                     Assert.assertFalse(true);
-                }
-                else Assert.assertTrue(true);
+                } else Assert.assertTrue(true);
             }
         }
     }
@@ -332,6 +311,83 @@ public InsertionData getInsertionData(VehicleRoute currentRoute, Job newJob, Veh
         };
     }
 
+    static class JobInRouteUpdater implements StateUpdater, ActivityVisitor {
+
+        private StateManager stateManager;
+
+        private StateId job1AssignedId;
+
+        private StateId job2AssignedId;
+
+        private VehicleRoute route;
+
+        public JobInRouteUpdater(StateManager stateManager, StateId job1AssignedId, StateId job2AssignedId) {
+            this.stateManager = stateManager;
+            this.job1AssignedId = job1AssignedId;
+            this.job2AssignedId = job2AssignedId;
+        }
+
+        @Override
+        public void begin(VehicleRoute route) {
+            this.route = route;
+        }
+
+        @Override
+        public void visit(TourActivity activity) {
+            if (((TourActivity.JobActivity) activity).getJob().getId().equals("s1")) {
+                stateManager.putProblemState(job1AssignedId, Boolean.class, true);
+            }
+            if (((TourActivity.JobActivity) activity).getJob().getId().equals("s2")) {
+                stateManager.putProblemState(job2AssignedId, Boolean.class, true);
+            }
+
+        }
+
+        @Override
+        public void finish() {
+
+        }
+    }
+
+    static class RouteConstraint implements HardRouteConstraint {
+
+        private final StateId job1AssignedId;
+
+        private final StateId job2AssignedId;
+
+        private StateManager stateManager;
+
+        public RouteConstraint(StateId job1Assigned, StateId job2Assigned, StateManager stateManager) {
+            this.job1AssignedId = job1Assigned;
+            this.job2AssignedId = job2Assigned;
+            this.stateManager = stateManager;
+        }
+
+        @Override
+        public boolean fulfilled(JobInsertionContext insertionContext) {
+            if (insertionContext.getJob().getId().equals("s1")) {
+                Boolean job2Assigned = stateManager.getProblemState(job2AssignedId, Boolean.class);
+                if (job2Assigned == null || job2Assigned == false) return true;
+                else {
+                    for (Job j : insertionContext.getRoute().getTourActivities().getJobs()) {
+                        if (j.getId().equals("s2")) return true;
+                    }
+                }
+                return false;
+            }
+            if (insertionContext.getJob().getId().equals("s2")) {
+                Boolean job1Assigned = stateManager.getProblemState(job1AssignedId, Boolean.class);
+                if (job1Assigned == null || job1Assigned == false) return true;
+                else {
+                    for (Job j : insertionContext.getRoute().getTourActivities().getJobs()) {
+                        if (j.getId().equals("s1")) return true;
+                    }
+                }
+                return false;
+            }
+            return true;
+        }
+    }
 
     static class CkeckJobSequence implements BeforeJobInsertionListener {
 
@@ -361,63 +417,4 @@ public boolean isCorrect() {
         }
     }
 
-    private JobInsertionCostsCalculator getCalculator(final VehicleRoutingProblem vrp) {
-        return new JobInsertionCostsCalculator() {
-
-            @Override
-            public InsertionData getInsertionData(VehicleRoute currentRoute, Job newJob, Vehicle newVehicle, double newVehicleDepartureTime, Driver newDriver, double bestKnownCosts) {
-                Service service = (Service) newJob;
-                Vehicle vehicle = vrp.getVehicles().iterator().next();
-                InsertionData iData;
-                if (currentRoute.isEmpty()) {
-                    double mc = getCost(service.getLocation(), vehicle.getStartLocation());
-                    iData = new InsertionData(2 * mc, -1, 0, vehicle, newDriver);
-                    iData.getEvents().add(new InsertActivity(currentRoute, vehicle, vrp.copyAndGetActivities(newJob).get(0), 0));
-                    iData.getEvents().add(new SwitchVehicle(currentRoute, vehicle, newVehicleDepartureTime));
-                } else {
-                    double best = Double.MAX_VALUE;
-                    int bestIndex = 0;
-                    int index = 0;
-                    TourActivity prevAct = currentRoute.getStart();
-                    for (TourActivity act : currentRoute.getActivities()) {
-                        double mc = getMarginalCost(service, prevAct, act);
-                        if (mc < best) {
-                            best = mc;
-                            bestIndex = index;
-                        }
-                        index++;
-                        prevAct = act;
-                    }
-                    double mc = getMarginalCost(service, prevAct, currentRoute.getEnd());
-                    if (mc < best) {
-                        best = mc;
-                        bestIndex = index;
-                    }
-                    iData = new InsertionData(best, -1, bestIndex, vehicle, newDriver);
-                    iData.getEvents().add(new InsertActivity(currentRoute, vehicle, vrp.copyAndGetActivities(newJob).get(0), bestIndex));
-                    iData.getEvents().add(new SwitchVehicle(currentRoute, vehicle, newVehicleDepartureTime));
-                }
-                return iData;
-            }
-
-            private double getMarginalCost(Service service, TourActivity prevAct, TourActivity act) {
-                double prev_new = getCost(prevAct.getLocation(), service.getLocation());
-                double new_act = getCost(service.getLocation(), act.getLocation());
-                double prev_act = getCost(prevAct.getLocation(), act.getLocation());
-                return prev_new + new_act - prev_act;
-            }
-
-            private double getCost(Location loc1, Location loc2) {
-                return vrp.getTransportCosts().getTransportCost(loc1, loc2, 0., null, null);
-            }
-        };
-
-//        LocalActivityInsertionCostsCalculator local = new LocalActivityInsertionCostsCalculator(vrp.getTransportCosts(),vrp.getActivityCosts());
-//        StateManager stateManager = new StateManager(vrp);
-//        ConstraintManager manager = new ConstraintManager(vrp,stateManager);
-//        ServiceInsertionCalculator calculator = new ServiceInsertionCalculator(vrp.getTransportCosts(), local, manager);
-//        calculator.setJobActivityFactory(vrp.getJobActivityFactory());
-//        return calculator;
-    }
-
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertionOnRouteLevel.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertionOnRouteLevel.java
index 44ff6f868..9da310443 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertionOnRouteLevel.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertionOnRouteLevel.java
@@ -83,13 +83,13 @@ public void setup() {
 
         costs = new AbstractForwardVehicleRoutingTransportCosts() {
 
+            VehicleRoutingTransportCosts routingCosts = CostFactory.createManhattanCosts();
+
             @Override
             public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
                 return 0;
             }
 
-            VehicleRoutingTransportCosts routingCosts = CostFactory.createManhattanCosts();
-
             @Override
             public double getTransportTime(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
                 return 0;
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestComparator.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestComparator.java
index d3eec4dc9..df9e9d5e3 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestComparator.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestComparator.java
@@ -34,7 +34,7 @@
 public class TestComparator {
 
     @Test
-    public void test(){
+    public void test() {
         Service s = Service.Builder.newInstance("1").setLocation(Location.newInstance("loc"))
             .setPriority(1).build();
         Service s2 = Service.Builder.newInstance("2").setLocation(Location.newInstance("loc"))
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestLocalActivityInsertionCostsCalculator.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestLocalActivityInsertionCostsCalculator.java
index 55127bd54..592601575 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestLocalActivityInsertionCostsCalculator.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestLocalActivityInsertionCostsCalculator.java
@@ -436,59 +436,62 @@ public void whenAddingNewWithTWBetweenTwoActs2_itShouldCalcInsertionCostsCorrect
     }
 
     @Test
-    public void whenAddingNewWithTWBetweenTwoActs3_itShouldCalcInsertionCostsCorrectly() {
+    public void whenAddingNewWithTWBetweenTwoActs3WithVarStart_itShouldCalcInsertionCostsCorrectly() {
         VehicleTypeImpl type = VehicleTypeImpl.Builder.newInstance("t").setCostPerWaitingTime(1.).build();
 
         VehicleImpl v = VehicleImpl.Builder.newInstance("v").setType(type).setStartLocation(Location.newInstance(0, 0)).build();
 //		VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setHasVariableDepartureTime(true).setType(type).setStartLocation(Location.newInstance(0,0)).build();
 
         Service prevS = Service.Builder.newInstance("prev").setLocation(Location.newInstance(10, 0)).build();
-        Service newS = Service.Builder.newInstance("new").setServiceTime(10).setTimeWindow(TimeWindow.newInstance(100, 120)).setLocation(Location.newInstance(20, 0)).build();
-        Service nextS = Service.Builder.newInstance("next").setLocation(Location.newInstance(30, 0)).setTimeWindow(TimeWindow.newInstance(40, 500)).build();
+        Service newS = Service.Builder.newInstance("new").setServiceTime(10).setTimeWindow(TimeWindow.newInstance(50, 70)).setLocation(Location.newInstance(20, 0)).build();
+        Service nextS = Service.Builder.newInstance("next").setLocation(Location.newInstance(30, 0)).setTimeWindow(TimeWindow.newInstance(40, 70)).build();
 
-        Service afterNextS = Service.Builder.newInstance("afterNext").setLocation(Location.newInstance(40, 0)).setTimeWindow(TimeWindow.newInstance(80, 500)).build();
-        Service afterAfterNextS = Service.Builder.newInstance("afterAfterNext").setLocation(Location.newInstance(40, 0)).setTimeWindow(TimeWindow.newInstance(100, 500)).build();
+        Service afterNextS = Service.Builder.newInstance("afterNext").setLocation(Location.newInstance(40, 0)).setTimeWindow(TimeWindow.newInstance(50, 100)).build();
+        Service afterAfterNextS = Service.Builder.newInstance("afterAfterNext").setLocation(Location.newInstance(50, 0)).setTimeWindow(TimeWindow.newInstance(100, 500)).build();
 
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addVehicle(v).addJob(prevS).addJob(newS).addJob(nextS)
             .addJob(afterNextS).addJob(afterAfterNextS).build();
 
         TourActivity prevAct = vrp.getActivities(prevS).get(0);
+
         TourActivity newAct = vrp.getActivities(newS).get(0);
-        newAct.setTheoreticalEarliestOperationStartTime(100);
-        newAct.setTheoreticalLatestOperationStartTime(120);
+        newAct.setTheoreticalEarliestOperationStartTime(50);
+        newAct.setTheoreticalLatestOperationStartTime(70);
 
         TourActivity nextAct = vrp.getActivities(nextS).get(0);
         nextAct.setTheoreticalEarliestOperationStartTime(40);
-        nextAct.setTheoreticalLatestOperationStartTime(500);
+        nextAct.setTheoreticalLatestOperationStartTime(70);
 
         TourActivity afterNextAct = vrp.getActivities(afterNextS).get(0);
-        afterNextAct.setTheoreticalEarliestOperationStartTime(80);
-        afterNextAct.setTheoreticalLatestOperationStartTime(500);
+        afterNextAct.setTheoreticalEarliestOperationStartTime(50);
+        afterNextAct.setTheoreticalEarliestOperationStartTime(100);
 
         TourActivity afterAfterNextAct = vrp.getActivities(afterAfterNextS).get(0);
         afterAfterNextAct.setTheoreticalEarliestOperationStartTime(100);
-        afterAfterNextAct.setTheoreticalLatestOperationStartTime(500);
-
+        afterAfterNextAct.setTheoreticalEarliestOperationStartTime(500);
 
         VehicleRoute route = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory()).addService(prevS).addService(nextS).addService(afterNextS).addService(afterAfterNextS).build();
+        JobInsertionContext context = new JobInsertionContext(route, newS, v, null, 0.);
 
         StateManager stateManager = getStateManager(vrp, route);
+        stateManager.updateTimeWindowStates();
+        stateManager.informInsertionStarts(Arrays.asList(route), new ArrayList<Job>());
 
-        JobInsertionContext context = new JobInsertionContext(route, newS, v, null, 0.);
         LocalActivityInsertionCostsCalculator calc = new LocalActivityInsertionCostsCalculator(CostFactory.createEuclideanCosts(), new WaitingTimeCosts(), stateManager);
         calc.setSolutionCompletenessRatio(1.);
         double c = calc.getCosts(context, prevAct, nextAct, newAct, 10);
-        assertEquals(20., c, 0.01);
-        //start-delay = new - old = 120 - 40 = 80 > future waiting time savings = 30 + 20 + 10
-        //ref: 10 + 50 + 20 = 80
-        //new: 80 - 10 - 30 - 20 = 20
-        /*
-        w(new) + w(next) - w_old(next) - min{start_delay(next),future_waiting}
+        assertEquals(-10., c, 0.01);
+		/*
+		activity start time delay at next act = start-time-old - start-time-new is always bigger than subsequent waiting time savings
+		 */
+		/*
+		old = 10 + 40 = 50
+		new = 30 + 10 = 40
 		 */
     }
 
     @Test
-    public void whenAddingNewWithTWBetweenTwoActs4_itShouldCalcInsertionCostsCorrectly() {
+    public void whenAddingNewWithTWBetweenTwoActs3_itShouldCalcInsertionCostsCorrectly() {
         VehicleTypeImpl type = VehicleTypeImpl.Builder.newInstance("t").setCostPerWaitingTime(1.).build();
 
         VehicleImpl v = VehicleImpl.Builder.newInstance("v").setType(type).setStartLocation(Location.newInstance(0, 0)).build();
@@ -499,7 +502,7 @@ public void whenAddingNewWithTWBetweenTwoActs4_itShouldCalcInsertionCostsCorrect
         Service nextS = Service.Builder.newInstance("next").setLocation(Location.newInstance(30, 0)).setTimeWindow(TimeWindow.newInstance(40, 500)).build();
 
         Service afterNextS = Service.Builder.newInstance("afterNext").setLocation(Location.newInstance(40, 0)).setTimeWindow(TimeWindow.newInstance(80, 500)).build();
-        Service afterAfterNextS = Service.Builder.newInstance("afterAfterNext").setLocation(Location.newInstance(50, 0)).setTimeWindow(TimeWindow.newInstance(100, 500)).build();
+        Service afterAfterNextS = Service.Builder.newInstance("afterAfterNext").setLocation(Location.newInstance(40, 0)).setTimeWindow(TimeWindow.newInstance(100, 500)).build();
 
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addVehicle(v).addJob(prevS).addJob(newS).addJob(nextS)
             .addJob(afterNextS).addJob(afterAfterNextS).build();
@@ -521,29 +524,26 @@ public void whenAddingNewWithTWBetweenTwoActs4_itShouldCalcInsertionCostsCorrect
         afterAfterNextAct.setTheoreticalEarliestOperationStartTime(100);
         afterAfterNextAct.setTheoreticalLatestOperationStartTime(500);
 
+
         VehicleRoute route = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory()).addService(prevS).addService(nextS).addService(afterNextS).addService(afterAfterNextS).build();
-        JobInsertionContext context = new JobInsertionContext(route, newS, v, null, 0.);
 
         StateManager stateManager = getStateManager(vrp, route);
 
+        JobInsertionContext context = new JobInsertionContext(route, newS, v, null, 0.);
         LocalActivityInsertionCostsCalculator calc = new LocalActivityInsertionCostsCalculator(CostFactory.createEuclideanCosts(), new WaitingTimeCosts(), stateManager);
         calc.setSolutionCompletenessRatio(1.);
         double c = calc.getCosts(context, prevAct, nextAct, newAct, 10);
-        assertEquals(30., c, 0.01);
-        //ref: 10 + 30 + 10 = 50
-        //new: 50 - 50 = 0
-
-		/*
-        activity start time delay at next act = start-time-old - start-time-new is always bigger than subsequent waiting time savings
-		 */
+        assertEquals(20., c, 0.01);
+        //start-delay = new - old = 120 - 40 = 80 > future waiting time savings = 30 + 20 + 10
+        //ref: 10 + 50 + 20 = 80
+        //new: 80 - 10 - 30 - 20 = 20
         /*
-		old = 10 + 30 + 10 = 50
-		new = 80 + 0 - 10 - min{80,40} = 30
+        w(new) + w(next) - w_old(next) - min{start_delay(next),future_waiting}
 		 */
     }
 
     @Test
-    public void whenAddingNewWithTWBetweenTwoActs4WithVarStart_itShouldCalcInsertionCostsCorrectly() {
+    public void whenAddingNewWithTWBetweenTwoActs4_itShouldCalcInsertionCostsCorrectly() {
         VehicleTypeImpl type = VehicleTypeImpl.Builder.newInstance("t").setCostPerWaitingTime(1.).build();
 
         VehicleImpl v = VehicleImpl.Builder.newInstance("v").setType(type).setStartLocation(Location.newInstance(0, 0)).build();
@@ -576,7 +576,6 @@ public void whenAddingNewWithTWBetweenTwoActs4WithVarStart_itShouldCalcInsertion
         afterAfterNextAct.setTheoreticalEarliestOperationStartTime(100);
         afterAfterNextAct.setTheoreticalLatestOperationStartTime(500);
 
-
         VehicleRoute route = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory()).addService(prevS).addService(nextS).addService(afterNextS).addService(afterAfterNextS).build();
         JobInsertionContext context = new JobInsertionContext(route, newS, v, null, 0.);
 
@@ -586,73 +585,73 @@ public void whenAddingNewWithTWBetweenTwoActs4WithVarStart_itShouldCalcInsertion
         calc.setSolutionCompletenessRatio(1.);
         double c = calc.getCosts(context, prevAct, nextAct, newAct, 10);
         assertEquals(30., c, 0.01);
+        //ref: 10 + 30 + 10 = 50
+        //new: 50 - 50 = 0
+
 		/*
-		activity start time delay at next act = start-time-old - start-time-new is always bigger than subsequent waiting time savings
+        activity start time delay at next act = start-time-old - start-time-new is always bigger than subsequent waiting time savings
 		 */
-		/*
+        /*
 		old = 10 + 30 + 10 = 50
-		new = 80
-		new - old = 80 - 40 = 40
-
+		new = 80 + 0 - 10 - min{80,40} = 30
 		 */
     }
 
     @Test
-    public void whenAddingNewWithTWBetweenTwoActs3WithVarStart_itShouldCalcInsertionCostsCorrectly() {
+    public void whenAddingNewWithTWBetweenTwoActs4WithVarStart_itShouldCalcInsertionCostsCorrectly() {
         VehicleTypeImpl type = VehicleTypeImpl.Builder.newInstance("t").setCostPerWaitingTime(1.).build();
 
         VehicleImpl v = VehicleImpl.Builder.newInstance("v").setType(type).setStartLocation(Location.newInstance(0, 0)).build();
 //		VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setHasVariableDepartureTime(true).setType(type).setStartLocation(Location.newInstance(0,0)).build();
 
         Service prevS = Service.Builder.newInstance("prev").setLocation(Location.newInstance(10, 0)).build();
-        Service newS = Service.Builder.newInstance("new").setServiceTime(10).setTimeWindow(TimeWindow.newInstance(50, 70)).setLocation(Location.newInstance(20, 0)).build();
-        Service nextS = Service.Builder.newInstance("next").setLocation(Location.newInstance(30, 0)).setTimeWindow(TimeWindow.newInstance(40, 70)).build();
+        Service newS = Service.Builder.newInstance("new").setServiceTime(10).setTimeWindow(TimeWindow.newInstance(100, 120)).setLocation(Location.newInstance(20, 0)).build();
+        Service nextS = Service.Builder.newInstance("next").setLocation(Location.newInstance(30, 0)).setTimeWindow(TimeWindow.newInstance(40, 500)).build();
 
-        Service afterNextS = Service.Builder.newInstance("afterNext").setLocation(Location.newInstance(40, 0)).setTimeWindow(TimeWindow.newInstance(50, 100)).build();
+        Service afterNextS = Service.Builder.newInstance("afterNext").setLocation(Location.newInstance(40, 0)).setTimeWindow(TimeWindow.newInstance(80, 500)).build();
         Service afterAfterNextS = Service.Builder.newInstance("afterAfterNext").setLocation(Location.newInstance(50, 0)).setTimeWindow(TimeWindow.newInstance(100, 500)).build();
 
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addVehicle(v).addJob(prevS).addJob(newS).addJob(nextS)
             .addJob(afterNextS).addJob(afterAfterNextS).build();
 
         TourActivity prevAct = vrp.getActivities(prevS).get(0);
-
         TourActivity newAct = vrp.getActivities(newS).get(0);
-        newAct.setTheoreticalEarliestOperationStartTime(50);
-        newAct.setTheoreticalLatestOperationStartTime(70);
+        newAct.setTheoreticalEarliestOperationStartTime(100);
+        newAct.setTheoreticalLatestOperationStartTime(120);
 
         TourActivity nextAct = vrp.getActivities(nextS).get(0);
         nextAct.setTheoreticalEarliestOperationStartTime(40);
-        nextAct.setTheoreticalLatestOperationStartTime(70);
+        nextAct.setTheoreticalLatestOperationStartTime(500);
 
         TourActivity afterNextAct = vrp.getActivities(afterNextS).get(0);
-        afterNextAct.setTheoreticalEarliestOperationStartTime(50);
-        afterNextAct.setTheoreticalEarliestOperationStartTime(100);
+        afterNextAct.setTheoreticalEarliestOperationStartTime(80);
+        afterNextAct.setTheoreticalLatestOperationStartTime(500);
 
         TourActivity afterAfterNextAct = vrp.getActivities(afterAfterNextS).get(0);
         afterAfterNextAct.setTheoreticalEarliestOperationStartTime(100);
-        afterAfterNextAct.setTheoreticalEarliestOperationStartTime(500);
+        afterAfterNextAct.setTheoreticalLatestOperationStartTime(500);
+
 
         VehicleRoute route = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory()).addService(prevS).addService(nextS).addService(afterNextS).addService(afterAfterNextS).build();
         JobInsertionContext context = new JobInsertionContext(route, newS, v, null, 0.);
 
         StateManager stateManager = getStateManager(vrp, route);
-        stateManager.updateTimeWindowStates();
-        stateManager.informInsertionStarts(Arrays.asList(route),new ArrayList<Job>());
 
         LocalActivityInsertionCostsCalculator calc = new LocalActivityInsertionCostsCalculator(CostFactory.createEuclideanCosts(), new WaitingTimeCosts(), stateManager);
         calc.setSolutionCompletenessRatio(1.);
         double c = calc.getCosts(context, prevAct, nextAct, newAct, 10);
-        assertEquals(-10., c, 0.01);
+        assertEquals(30., c, 0.01);
 		/*
 		activity start time delay at next act = start-time-old - start-time-new is always bigger than subsequent waiting time savings
 		 */
 		/*
-		old = 10 + 40 = 50
-		new = 30 + 10 = 40
+		old = 10 + 30 + 10 = 50
+		new = 80
+		new - old = 80 - 40 = 40
+
 		 */
     }
 
-
     private StateManager getStateManager(VehicleRoutingProblem vrp, VehicleRoute route) {
         StateManager stateManager = new StateManager(vrp);
         stateManager.addStateUpdater(new UpdateActivityTimes(vrp.getTransportCosts(), vrp.getActivityCosts()));
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestMixedServiceAndShipmentsProblemOnRouteLevel.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestMixedServiceAndShipmentsProblemOnRouteLevel.java
index dbec53eb0..bcc1c0956 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestMixedServiceAndShipmentsProblemOnRouteLevel.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestMixedServiceAndShipmentsProblemOnRouteLevel.java
@@ -41,22 +41,22 @@ public void whenHavingShipmentsAndServicesInOneProblem_andInsertionShouldBeMadeO
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType").addCapacityDimension(0, 2);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
+        /*
          * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
-		 */
+         */
         VehicleImpl.Builder vehicleBuilder = VehicleImpl.Builder.newInstance("vehicle");
         vehicleBuilder.setStartLocation(Location.newInstance(10, 10));
         vehicleBuilder.setType(vehicleType);
         VehicleImpl vehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * build shipments at the required locations, each with a capacity-demand of 1.
-		 * 4 shipments
-		 * 1: (5,7)->(6,9)
-		 * 2: (5,13)->(6,11)
-		 * 3: (15,7)->(14,9)
-		 * 4: (15,13)->(14,11)
-		 */
+         * 4 shipments
+         * 1: (5,7)->(6,9)
+         * 2: (5,13)->(6,11)
+         * 3: (15,7)->(14,9)
+         * 4: (15,13)->(14,11)
+         */
 
         Shipment shipment1 = Shipment.Builder.newInstance("1").addSizeDimension(0, 1).setPickupLocation(TestUtils.loc(Coordinate.newInstance(5, 7))).setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(6, 9))).build();
         Shipment shipment2 = Shipment.Builder.newInstance("2").addSizeDimension(0, 1).setPickupLocation(TestUtils.loc(Coordinate.newInstance(5, 13))).setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(6, 11))).build();
@@ -64,13 +64,13 @@ public void whenHavingShipmentsAndServicesInOneProblem_andInsertionShouldBeMadeO
         Shipment shipment3 = Shipment.Builder.newInstance("3").addSizeDimension(0, 1).setPickupLocation(TestUtils.loc(Coordinate.newInstance(15, 7))).setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(14, 9))).build();
         Shipment shipment4 = Shipment.Builder.newInstance("4").addSizeDimension(0, 1).setPickupLocation(TestUtils.loc(Coordinate.newInstance(15, 13))).setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(14, 11))).build();
 
-		/*
+        /*
          * build deliveries, (implicitly picked up in the depot)
-		 * 1: (4,8)
-		 * 2: (4,12)
-		 * 3: (16,8)
-		 * 4: (16,12)
-		 */
+         * 1: (4,8)
+         * 2: (4,12)
+         * 3: (16,8)
+         * 4: (16,12)
+         */
         Delivery delivery1 = (Delivery) Delivery.Builder.newInstance("5").addSizeDimension(0, 1).setLocation(TestUtils.loc(Coordinate.newInstance(4, 8))).build();
         Delivery delivery2 = (Delivery) Delivery.Builder.newInstance("6").addSizeDimension(0, 1).setLocation(TestUtils.loc(Coordinate.newInstance(4, 12))).build();
         Delivery delivery3 = (Delivery) Delivery.Builder.newInstance("7").addSizeDimension(0, 1).setLocation(TestUtils.loc(Coordinate.newInstance(16, 8))).build();
@@ -106,22 +106,22 @@ public void whenHavingOnlyServicesInOneProblem_andInsertionShouldBeMadeOnRouteLe
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType").addCapacityDimension(0, 2);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
+        /*
          * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
-		 */
+         */
         VehicleImpl.Builder vehicleBuilder = VehicleImpl.Builder.newInstance("vehicle");
         vehicleBuilder.setStartLocation(Location.newInstance(10, 10));
         vehicleBuilder.setType(vehicleType);
         VehicleImpl vehicle = vehicleBuilder.build();
 
 
-		/*
+        /*
          * build deliveries, (implicitly picked up in the depot)
-		 * 1: (4,8)
-		 * 2: (4,12)
-		 * 3: (16,8)
-		 * 4: (16,12)
-		 */
+         * 1: (4,8)
+         * 2: (4,12)
+         * 3: (16,8)
+         * 4: (16,12)
+         */
         Delivery delivery1 = (Delivery) Delivery.Builder.newInstance("5").addSizeDimension(0, 1).setLocation(Location.newInstance(4, 8)).build();
         Delivery delivery2 = (Delivery) Delivery.Builder.newInstance("6").addSizeDimension(0, 1).setLocation(Location.newInstance(4, 12)).build();
         Delivery delivery3 = (Delivery) Delivery.Builder.newInstance("7").addSizeDimension(0, 1).setLocation(Location.newInstance(16, 8)).build();
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsOptimizedTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsOptimizedTest.java
index 82f471e9a..31760e405 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsOptimizedTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsOptimizedTest.java
@@ -68,7 +68,7 @@ public void doBefore() {
 
     @Test
     public void whenRequestingNeighborhoodOfTargetJob_nNeighborsShouldBeTwo() {
-        JobNeighborhoodsOptimized jn = new JobNeighborhoodsOptimized(vrp,jobDistance,2);
+        JobNeighborhoodsOptimized jn = new JobNeighborhoodsOptimized(vrp, jobDistance, 2);
         jn.initialise();
         Iterator<Job> iter = jn.getNearestNeighborsIterator(2, target);
         List<Service> services = new ArrayList<Service>();
@@ -80,7 +80,7 @@ public void whenRequestingNeighborhoodOfTargetJob_nNeighborsShouldBeTwo() {
 
     @Test
     public void whenRequestingNeighborhoodOfTargetJob_s2ShouldBeNeighbor() {
-        JobNeighborhoodsOptimized jn = new JobNeighborhoodsOptimized(vrp,jobDistance,2);
+        JobNeighborhoodsOptimized jn = new JobNeighborhoodsOptimized(vrp, jobDistance, 2);
         jn.initialise();
         Iterator<Job> iter = jn.getNearestNeighborsIterator(2, target);
         List<Service> services = new ArrayList<Service>();
@@ -92,7 +92,7 @@ public void whenRequestingNeighborhoodOfTargetJob_s2ShouldBeNeighbor() {
 
     @Test
     public void whenRequestingNeighborhoodOfTargetJob_s4ShouldBeNeighbor() {
-        JobNeighborhoodsOptimized jn = new JobNeighborhoodsOptimized(vrp,jobDistance,2);
+        JobNeighborhoodsOptimized jn = new JobNeighborhoodsOptimized(vrp, jobDistance, 2);
         jn.initialise();
         Iterator<Job> iter = jn.getNearestNeighborsIterator(2, target);
         List<Service> services = new ArrayList<Service>();
@@ -104,7 +104,7 @@ public void whenRequestingNeighborhoodOfTargetJob_s4ShouldBeNeighbor() {
 
     @Test
     public void whenRequestingNeighborhoodOfTargetJob_sizeShouldBe4() {
-        JobNeighborhoodsOptimized jn = new JobNeighborhoodsOptimized(vrp,jobDistance,4);
+        JobNeighborhoodsOptimized jn = new JobNeighborhoodsOptimized(vrp, jobDistance, 4);
         jn.initialise();
         Iterator<Job> iter = jn.getNearestNeighborsIterator(4, target);
         List<Service> services = new ArrayList<Service>();
@@ -116,22 +116,22 @@ public void whenRequestingNeighborhoodOfTargetJob_sizeShouldBe4() {
 
     @Test
     public void whenRequestingNeighborhoodOfTargetJob_neighborsShouldBeCorrect() {
-        JobNeighborhoodsOptimized jn = new JobNeighborhoodsOptimized(vrp,jobDistance,4);
+        JobNeighborhoodsOptimized jn = new JobNeighborhoodsOptimized(vrp, jobDistance, 4);
         jn.initialise();
         Iterator<Job> iter = jn.getNearestNeighborsIterator(4, s7);
         List<Service> services = new ArrayList<Service>();
         while (iter.hasNext()) {
             services.add((Service) iter.next());
         }
-        Assert.assertEquals(s6,services.get(0));
-        Assert.assertEquals(s5,services.get(1));
-        Assert.assertEquals(target,services.get(2));
-        Assert.assertEquals(s2,services.get(3));
+        Assert.assertEquals(s6, services.get(0));
+        Assert.assertEquals(s5, services.get(1));
+        Assert.assertEquals(target, services.get(2));
+        Assert.assertEquals(s2, services.get(3));
     }
 
     @Test
     public void whenRequestingMoreNeighborsThanExisting_itShouldReturnMaxNeighbors() {
-        JobNeighborhoodsOptimized jn = new JobNeighborhoodsOptimized(vrp,jobDistance,2);
+        JobNeighborhoodsOptimized jn = new JobNeighborhoodsOptimized(vrp, jobDistance, 2);
         jn.initialise();
         Iterator<Job> iter = jn.getNearestNeighborsIterator(100, target);
         List<Service> services = new ArrayList<Service>();
@@ -142,5 +142,4 @@ public void whenRequestingMoreNeighborsThanExisting_itShouldReturnMaxNeighbors()
     }
 
 
-
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/StateManagerTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/StateManagerTest.java
index 40c89edc5..9ffdacb6c 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/StateManagerTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/StateManagerTest.java
@@ -40,26 +40,10 @@
 
 public class StateManagerTest {
 
-    static class ActFac implements JobActivityFactory {
-
-        @Override
-        public List<AbstractActivity> createActivities(Job job) {
-            ServiceActivity act = mock(ServiceActivity.class);
-            when(act.getIndex()).thenReturn(1);
-            List<AbstractActivity> acts = new ArrayList<AbstractActivity>();
-            acts.add(act);
-            return acts;
-        }
-    }
-
-    private VehicleRoute getRoute(Vehicle vehicle) {
-        return VehicleRoute.Builder.newInstance(vehicle).setJobActivityFactory(new ActFac()).addService(Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).build()).build();
-    }
-
     private VehicleRoutingProblem vrpMock;
 
     @Before
-    public void doBefore(){
+    public void doBefore() {
         vrpMock = mock(VehicleRoutingProblem.class);
         when(vrpMock.getFleetSize()).thenReturn(VehicleRoutingProblem.FleetSize.INFINITE);
     }
@@ -73,6 +57,10 @@ public void whenInternalRouteStateIsSet_itMustBeSetCorrectly() {
         assertEquals(10., stateManager.getRouteState(route, id, Double.class), 0.01);
     }
 
+    private VehicleRoute getRoute(Vehicle vehicle) {
+        return VehicleRoute.Builder.newInstance(vehicle).setJobActivityFactory(new ActFac()).addService(Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).build()).build();
+    }
+
     @Test
     public void whenInternalRouteStateIsNotSet_itShouldReturnNull() {
         VehicleRoute route = getRoute(mock(Vehicle.class));
@@ -139,7 +127,6 @@ public void whenRouteStateIsSetWithGenericMethodAndCapacity_itMustBeSetCorrectly
         assertEquals(500, getCap.get(0));
     }
 
-
     @Test
     public void whenActivityStateIsSetWithGenericMethodAndBoolean_itMustBeSetCorrectly() {
         TourActivity activity = mock(TourActivity.class);
@@ -337,7 +324,7 @@ public void whenClearing_arrElementsShouldBeNull() {
     }
 
     @Test
-    public void arrayIniShouldWork(){
+    public void arrayIniShouldWork() {
         VehicleType type = VehicleTypeImpl.Builder.newInstance("t").setCostPerDistance(4.).build();
         VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("loc")).build();
         VehicleImpl vehicle2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(Location.newInstance("loc")).setType(type).build();
@@ -351,9 +338,21 @@ public void arrayIniShouldWork(){
 
         StateManager stateManager = new StateManager(vrp);
         StateId myState = null;
-        for(int i=0;i<10;i++){
-            myState = stateManager.createStateId("myState"+i);
+        for (int i = 0; i < 10; i++) {
+            myState = stateManager.createStateId("myState" + i);
+        }
+        stateManager.putTypedInternalRouteState(route, myState, 1.);
+    }
+
+    static class ActFac implements JobActivityFactory {
+
+        @Override
+        public List<AbstractActivity> createActivities(Job job) {
+            ServiceActivity act = mock(ServiceActivity.class);
+            when(act.getIndex()).thenReturn(1);
+            List<AbstractActivity> acts = new ArrayList<AbstractActivity>();
+            acts.add(act);
+            return acts;
         }
-        stateManager.putTypedInternalRouteState(route,myState,1.);
     }
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicleTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicleTest.java
index 75aaf1453..a11369c99 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicleTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicleTest.java
@@ -69,11 +69,11 @@ public void doBefore() {
         v = VehicleImpl.Builder.newInstance("v0").setStartLocation(Location.newInstance(0, 0))
             .setType(type).build();
 
-        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0,0))
-            .setEndLocation(Location.newInstance(0,50)).setType(type).build();
+        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0, 0))
+            .setEndLocation(Location.newInstance(0, 50)).setType(type).build();
 
-        vehicle2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(Location.newInstance(0,10))
-            .setEndLocation(Location.newInstance(0,40)).setType(type).build();
+        vehicle2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(Location.newInstance(0, 10))
+            .setEndLocation(Location.newInstance(0, 40)).setType(type).build();
 
         Pickup service = Pickup.Builder.newInstance("s").setLocation(Location.newInstance(0, 10)).build();
         Pickup service2 = Pickup.Builder.newInstance("s2").setLocation(Location.newInstance(0, 20)).build();
@@ -81,14 +81,14 @@ public void doBefore() {
         Pickup service3 = Pickup.Builder.newInstance("s3").setLocation(Location.newInstance(0, 30)).build();
         Pickup service4 = Pickup.Builder.newInstance("s4").setLocation(Location.newInstance(0, 40)).build();
 
-        Delivery d1 = Delivery.Builder.newInstance("d1").setLocation(Location.newInstance(10,0)).build();
+        Delivery d1 = Delivery.Builder.newInstance("d1").setLocation(Location.newInstance(10, 0)).build();
 
-        Shipment shipment = Shipment.Builder.newInstance("shipment").setPickupLocation(Location.newInstance(20,0))
-            .setDeliveryLocation(Location.newInstance(40,0))
+        Shipment shipment = Shipment.Builder.newInstance("shipment").setPickupLocation(Location.newInstance(20, 0))
+            .setDeliveryLocation(Location.newInstance(40, 0))
             .setMaxTimeInVehicle(20d)
             .build();
 
-        Delivery d2 = Delivery.Builder.newInstance("d2").setLocation(Location.newInstance(30,0)).setServiceTime(10).build();
+        Delivery d2 = Delivery.Builder.newInstance("d2").setLocation(Location.newInstance(30, 0)).setServiceTime(10).build();
 
 
         vrp = VehicleRoutingProblem.Builder.newInstance().addVehicle(v).addVehicle(vehicle).addVehicle(vehicle2).addJob(service)
@@ -103,7 +103,7 @@ public void doBefore() {
             .addDelivery(d1).addPickup(shipment).addDelivery(shipment).build();
 
         stateManager = new StateManager(vrp);
-        stateManager.addStateUpdater(new UpdateActivityTimes(vrp.getTransportCosts(),vrp.getActivityCosts()));
+        stateManager.addStateUpdater(new UpdateActivityTimes(vrp.getTransportCosts(), vrp.getActivityCosts()));
         stateManager.informInsertionStarts(Arrays.asList(route), null);
 
         minSlackId = stateManager.createStateId("min-slack-id");
@@ -116,7 +116,7 @@ public void doBefore() {
         maxTimeInVehicleConstraint.setVehiclesToUpdate(new UpdateVehicleDependentPracticalTimeWindows.VehiclesToUpdate() {
             @Override
             public Collection<Vehicle> get(VehicleRoute route) {
-                return Arrays.asList((Vehicle)vehicle,(Vehicle)vehicle2,v);
+                return Arrays.asList((Vehicle) vehicle, (Vehicle) vehicle2, v);
             }
         });
         stateManager.addStateUpdater(maxTimeInVehicleConstraint);
@@ -177,20 +177,19 @@ public void doBefore() {
 //    }
 
     @Test
-    public void testWithShipment(){
+    public void testWithShipment() {
         stateManager.informInsertionStarts(Arrays.asList(route2), null);
-        for(TourActivity act : route2.getActivities()){
-            String jobId = ((TourActivity.JobActivity)act).getJob().getId();
-            if(jobId.equals("d1")){
+        for (TourActivity act : route2.getActivities()) {
+            String jobId = ((TourActivity.JobActivity) act).getJob().getId();
+            if (jobId.equals("d1")) {
                 Double slackTime = stateManager.getActivityState(act, v, minSlackId, Double.class);
                 Assert.assertEquals(Double.MAX_VALUE, slackTime, 0.001);
             }
-            if(jobId.equals("shipment")){
-                if(act instanceof PickupActivity){
+            if (jobId.equals("shipment")) {
+                if (act instanceof PickupActivity) {
                     Double slackTime = stateManager.getActivityState(act, v, minSlackId, Double.class);
                     Assert.assertEquals(Double.MAX_VALUE, slackTime, 0.001);
-                }
-                else{
+                } else {
                     Double slackTime = stateManager.getActivityState(act, v, minSlackId, Double.class);
                     Assert.assertEquals(0, slackTime, 0.001);
                 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/UpdateVehicleDependentTimeWindowTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/UpdateVehicleDependentTimeWindowTest.java
index a07d61e57..66cd4cc27 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/UpdateVehicleDependentTimeWindowTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/UpdateVehicleDependentTimeWindowTest.java
@@ -206,22 +206,22 @@ public void stateManagerShouldHaveMemorizedCorrectLatestEndOfAct1WithVehicle3()
 
 
     @Test
-    public void twUpdateShouldWorkWithMultipleTWs(){
+    public void twUpdateShouldWorkWithMultipleTWs() {
         //
         VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("0,0")).setEarliestStart(0.).setLatestArrival(100.).build();
         Service service = Service.Builder.newInstance("s1").setLocation(Location.newInstance("10,0"))
-                .addTimeWindow(10,20).addTimeWindow(30,40).build();
+            .addTimeWindow(10, 20).addTimeWindow(30, 40).build();
         Service service2 = Service.Builder.newInstance("s2")
-                .addTimeWindow(20,30).addTimeWindow(40,60).addTimeWindow(70,80).setLocation(Location.newInstance("20,0")).build();
+            .addTimeWindow(20, 30).addTimeWindow(40, 60).addTimeWindow(70, 80).setLocation(Location.newInstance("20,0")).build();
 
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(service).addJob(service2).addVehicle(vehicle)
-                .setRoutingCost(routingCosts).build();
+            .setRoutingCost(routingCosts).build();
 
         VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle).setJobActivityFactory(vrp.getJobActivityFactory())
-                .addService(service).addService(service2, TimeWindow.newInstance(70, 80)).build();
+            .addService(service).addService(service2, TimeWindow.newInstance(70, 80)).build();
 
         StateManager stateManager = new StateManager(vrp);
-        UpdateVehicleDependentPracticalTimeWindows updater = new UpdateVehicleDependentPracticalTimeWindows(stateManager,routingCosts,activityCosts);
+        UpdateVehicleDependentPracticalTimeWindows updater = new UpdateVehicleDependentPracticalTimeWindows(stateManager, routingCosts, activityCosts);
         updater.setVehiclesToUpdate(new UpdateVehicleDependentPracticalTimeWindows.VehiclesToUpdate() {
 
             @Override
@@ -236,12 +236,12 @@ public void twUpdateShouldWorkWithMultipleTWs(){
         stateManager.addStateUpdater(updater);
         stateManager.informInsertionStarts(Arrays.asList(route), Collections.<Job>emptyList());
 
-        assertEquals(80.,stateManager.getActivityState(route.getActivities().get(1),vehicle,
-                InternalStates.LATEST_OPERATION_START_TIME, Double.class),0.01);
+        assertEquals(80., stateManager.getActivityState(route.getActivities().get(1), vehicle,
+            InternalStates.LATEST_OPERATION_START_TIME, Double.class), 0.01);
     }
 
     @Test
-    public void updateOfOpenRoutesShouldBeDoneCorrectly(){
+    public void updateOfOpenRoutesShouldBeDoneCorrectly() {
         VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v")
             .setReturnToDepot(false)
             .setStartLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(0, 0)).build())
@@ -263,7 +263,7 @@ public void updateOfOpenRoutesShouldBeDoneCorrectly(){
         stateManager.addStateUpdater(updater);
         stateManager.reCalculateStates(route);
 
-        Double activityState = stateManager.getActivityState(route.getActivities().get(0),route.getVehicle(), InternalStates.LATEST_OPERATION_START_TIME, Double.class);
+        Double activityState = stateManager.getActivityState(route.getActivities().get(0), route.getVehicle(), InternalStates.LATEST_OPERATION_START_TIME, Double.class);
         Assert.assertEquals(51d, activityState, 0.01);
 
     }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyserTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyserTest.java
index 3ce9bcfae..248818910 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyserTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyserTest.java
@@ -112,65 +112,6 @@ public void doBefore() {
         solution = new VehicleRoutingProblemSolution(Arrays.asList(route1, route2), 42);
     }
 
-
-    public void buildAnotherScenarioWithOnlyOneVehicleAndWithoutAnyConstraintsBefore() {
-        VehicleType type = VehicleTypeImpl.Builder.newInstance("type").setFixedCost(100.).setCostPerDistance(2.).addCapacityDimension(0, 15).build();
-
-        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v1").setType(type)
-            .setStartLocation(Location.newInstance(-5, 0))
-            .setLatestArrival(150.)
-            .build();
-
-        Pickup s1 = Pickup.Builder.newInstance("s1")
-            .setTimeWindow(TimeWindow.newInstance(10, 20))
-            .setLocation(Location.newInstance(-10, 1))
-            .addSizeDimension(0, 10)
-            .build();
-        Delivery s2 = Delivery.Builder.newInstance("s2")
-            .setLocation(Location.newInstance(-10, 10))
-            .setTimeWindow(TimeWindow.newInstance(10, 20))
-            .addSizeDimension(0, 20)
-            .build();
-        Shipment shipment1 = Shipment.Builder.newInstance("ship1").setPickupLocation(TestUtils.loc(Coordinate.newInstance(-15, 2)))
-            .setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(-16, 5)))
-            .addSizeDimension(0, 15)
-            .setPickupServiceTime(20.).setDeliveryServiceTime(20.)
-            .setPickupTimeWindow(TimeWindow.newInstance(10, 20)).setDeliveryTimeWindow(TimeWindow.newInstance(10, 20))
-            .build();
-
-        Pickup s3 = Pickup.Builder.newInstance("s3")
-            .setTimeWindow(TimeWindow.newInstance(10, 20))
-            .setLocation(TestUtils.loc(Coordinate.newInstance(10, 1)))
-            .addSizeDimension(0, 10)
-            .build();
-        Delivery s4 = Delivery.Builder.newInstance("s4").setLocation(Location.newInstance(10, 10))
-            .addSizeDimension(0, 20)
-            .setTimeWindow(TimeWindow.newInstance(10, 20))
-            .build();
-        Shipment shipment2 = Shipment.Builder.newInstance("ship2").setPickupLocation(TestUtils.loc(Coordinate.newInstance(15, 2)))
-            .setPickupServiceTime(20.).setDeliveryServiceTime(20.)
-            .setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(16, 5)))
-            .setPickupTimeWindow(TimeWindow.newInstance(10, 20)).setDeliveryTimeWindow(TimeWindow.newInstance(10, 20))
-            .addSizeDimension(0, 15).build();
-
-        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance().addVehicle(vehicle)
-            .addJob(s1)
-            .addJob(s2).addJob(shipment1).addJob(s3).addJob(s4).addJob(shipment2).setFleetSize(VehicleRoutingProblem.FleetSize.FINITE);
-        vrpBuilder.setRoutingCost(new ManhattanCosts(vrpBuilder.getLocations()));
-        vrp = vrpBuilder.build();
-
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle).setJobActivityFactory(vrp.getJobActivityFactory())
-            .addPickup(s3)
-            .addPickup(shipment2).addDelivery(shipment2)
-            .addDelivery(s4)
-            .addDelivery(s2)
-            .addPickup(shipment1).addDelivery(shipment1)
-            .addPickup(s1)
-            .build();
-
-        solution = new VehicleRoutingProblemSolution(Arrays.asList(route), 300);
-    }
-
     /**
      * Test the last transport costs at an activity are correct.
      */
@@ -179,38 +120,6 @@ public void lastTransportCostsOfRoute1ShouldWork() {
         testTransportCosts(TransportCostsTestType.LAST_COST);
     }
 
-    /**
-     * Test the last transport distance at an activity are correct.
-     */
-    @Test
-    public void lastTransportDistanceOfRoute1ShouldWork() {
-        testTransportCosts(TransportCostsTestType.LAST_DISTANCE);
-    }
-
-
-    /**
-     * Test the last transport time at an activity are correct.
-     */
-    @Test
-    public void lastTransportTimeOfRoute1ShouldWork() {
-        testTransportCosts(TransportCostsTestType.LAST_TIME);
-    }
-
-    /**
-     * Test the last transport time at an activity are correct.
-     */
-    @Test
-    public void transportTimeAtActivityOfRoute1ShouldWork() {
-        testTransportCosts(TransportCostsTestType.TRANSPORT_TIME_AT_ACTIVITY);
-    }
-
-    private enum TransportCostsTestType {
-        LAST_COST,
-        LAST_TIME,
-        LAST_DISTANCE,
-        TRANSPORT_TIME_AT_ACTIVITY,
-    }
-
     /**
      * Run multiple different tests for transport costs
      *
@@ -291,6 +200,31 @@ private double calc(Coordinate from, Coordinate to) {
         }
     }
 
+    /**
+     * Test the last transport distance at an activity are correct.
+     */
+    @Test
+    public void lastTransportDistanceOfRoute1ShouldWork() {
+        testTransportCosts(TransportCostsTestType.LAST_DISTANCE);
+    }
+
+
+    /**
+     * Test the last transport time at an activity are correct.
+     */
+    @Test
+    public void lastTransportTimeOfRoute1ShouldWork() {
+        testTransportCosts(TransportCostsTestType.LAST_TIME);
+    }
+
+    /**
+     * Test the last transport time at an activity are correct.
+     */
+    @Test
+    public void transportTimeAtActivityOfRoute1ShouldWork() {
+        testTransportCosts(TransportCostsTestType.TRANSPORT_TIME_AT_ACTIVITY);
+    }
+
     @Test
     public void constructionShouldWork() {
         SolutionAnalyser analyser = new SolutionAnalyser(vrp, solution, vrp.getTransportCosts());
@@ -444,6 +378,64 @@ public void pickupCount_OfRoute1OfAnotherSolutionShouldWork() {
         Assert.assertEquals(4, analyser.getNumberOfPickups(route), 0.01);
     }
 
+    public void buildAnotherScenarioWithOnlyOneVehicleAndWithoutAnyConstraintsBefore() {
+        VehicleType type = VehicleTypeImpl.Builder.newInstance("type").setFixedCost(100.).setCostPerDistance(2.).addCapacityDimension(0, 15).build();
+
+        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v1").setType(type)
+            .setStartLocation(Location.newInstance(-5, 0))
+            .setLatestArrival(150.)
+            .build();
+
+        Pickup s1 = Pickup.Builder.newInstance("s1")
+            .setTimeWindow(TimeWindow.newInstance(10, 20))
+            .setLocation(Location.newInstance(-10, 1))
+            .addSizeDimension(0, 10)
+            .build();
+        Delivery s2 = Delivery.Builder.newInstance("s2")
+            .setLocation(Location.newInstance(-10, 10))
+            .setTimeWindow(TimeWindow.newInstance(10, 20))
+            .addSizeDimension(0, 20)
+            .build();
+        Shipment shipment1 = Shipment.Builder.newInstance("ship1").setPickupLocation(TestUtils.loc(Coordinate.newInstance(-15, 2)))
+            .setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(-16, 5)))
+            .addSizeDimension(0, 15)
+            .setPickupServiceTime(20.).setDeliveryServiceTime(20.)
+            .setPickupTimeWindow(TimeWindow.newInstance(10, 20)).setDeliveryTimeWindow(TimeWindow.newInstance(10, 20))
+            .build();
+
+        Pickup s3 = Pickup.Builder.newInstance("s3")
+            .setTimeWindow(TimeWindow.newInstance(10, 20))
+            .setLocation(TestUtils.loc(Coordinate.newInstance(10, 1)))
+            .addSizeDimension(0, 10)
+            .build();
+        Delivery s4 = Delivery.Builder.newInstance("s4").setLocation(Location.newInstance(10, 10))
+            .addSizeDimension(0, 20)
+            .setTimeWindow(TimeWindow.newInstance(10, 20))
+            .build();
+        Shipment shipment2 = Shipment.Builder.newInstance("ship2").setPickupLocation(TestUtils.loc(Coordinate.newInstance(15, 2)))
+            .setPickupServiceTime(20.).setDeliveryServiceTime(20.)
+            .setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(16, 5)))
+            .setPickupTimeWindow(TimeWindow.newInstance(10, 20)).setDeliveryTimeWindow(TimeWindow.newInstance(10, 20))
+            .addSizeDimension(0, 15).build();
+
+        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance().addVehicle(vehicle)
+            .addJob(s1)
+            .addJob(s2).addJob(shipment1).addJob(s3).addJob(s4).addJob(shipment2).setFleetSize(VehicleRoutingProblem.FleetSize.FINITE);
+        vrpBuilder.setRoutingCost(new ManhattanCosts(vrpBuilder.getLocations()));
+        vrp = vrpBuilder.build();
+
+        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle).setJobActivityFactory(vrp.getJobActivityFactory())
+            .addPickup(s3)
+            .addPickup(shipment2).addDelivery(shipment2)
+            .addDelivery(s4)
+            .addDelivery(s2)
+            .addPickup(shipment1).addDelivery(shipment1)
+            .addPickup(s1)
+            .build();
+
+        solution = new VehicleRoutingProblemSolution(Arrays.asList(route), 300);
+    }
+
     @Test
     public void pickupCountAtBeginning_OfRoute1OfAnotherSolutionShouldWork() {
         buildAnotherScenarioWithOnlyOneVehicleAndWithoutAnyConstraintsBefore();
@@ -766,7 +758,6 @@ public void distance_ofEndActOfRoute1ShouldWork() {
         Assert.assertEquals(42., analyser.getDistanceAtActivity(route.getEnd(), route), 0.01);
     }
 
-
     @Test
     public void lateArrivalTimes_atStartActOfRoute1ShouldWork() {
         SolutionAnalyser analyser = new SolutionAnalyser(vrp, solution, vrp.getTransportCosts());
@@ -923,7 +914,6 @@ public void capacityViolationAfterStart_shouldWork() {
         }
     }
 
-
     @Test
     public void capacityViolationAtBeginning_shouldWorkWhenViolated() {
         buildAnotherScenarioWithOnlyOneVehicleAndWithoutAnyConstraintsBefore();
@@ -934,7 +924,6 @@ public void capacityViolationAtBeginning_shouldWorkWhenViolated() {
         assertEquals(25, cap.get(0));
     }
 
-
     @Test
     public void capacityViolationAfterStart_shouldWorkWhenViolated() {
         buildAnotherScenarioWithOnlyOneVehicleAndWithoutAnyConstraintsBefore();
@@ -1565,7 +1554,6 @@ public void skillViolationAtEnd_shouldWork() {
         assertFalse(violated);
     }
 
-
     @Test
     public void skillViolationOnRoute_shouldWorkWhenNotViolated() {
         SolutionAnalyser analyser = new SolutionAnalyser(vrp, solution, vrp.getTransportCosts());
@@ -1615,4 +1603,11 @@ public void skillViolationOnSolution_shouldWorkWhenNotViolated() {
         assertFalse(violated);
     }
 
+    private enum TransportCostsTestType {
+        LAST_COST,
+        LAST_TIME,
+        LAST_DISTANCE,
+        TRANSPORT_TIME_AT_ACTIVITY,
+    }
+
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/CapacityTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/CapacityTest.java
index f8e5f089f..cead92a22 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/CapacityTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/CapacityTest.java
@@ -371,16 +371,16 @@ public void whenDividingZeroCaps_itShouldReturnZero() {
     }
 
     @Test
-    public void shouldBeEqual(){
+    public void shouldBeEqual() {
         Capacity cap1 = Capacity.Builder.newInstance().build();
         Capacity cap2 = Capacity.Builder.newInstance().build();
         Assert.assertTrue(cap1.equals(cap2));
     }
 
     @Test
-    public void shouldBeEqual2(){
-        Capacity cap1 = Capacity.Builder.newInstance().addDimension(0,10).addDimension(1,100).addDimension(2,1000).build();
-        Capacity cap2 = Capacity.Builder.newInstance().addDimension(0,10).addDimension(2, 1000).addDimension(1,100).build();
+    public void shouldBeEqual2() {
+        Capacity cap1 = Capacity.Builder.newInstance().addDimension(0, 10).addDimension(1, 100).addDimension(2, 1000).build();
+        Capacity cap2 = Capacity.Builder.newInstance().addDimension(0, 10).addDimension(2, 1000).addDimension(1, 100).build();
         Assert.assertTrue(cap1.equals(cap2));
     }
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblemTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblemTest.java
index 046f19343..86f4efa3a 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblemTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblemTest.java
@@ -125,7 +125,7 @@ public void whenShipmentsAreAdded_vrpShouldContainThem() {
         assertEquals(2, vrp.getJobs().size());
         assertEquals(s, vrp.getJobs().get("s"));
         assertEquals(s2, vrp.getJobs().get("s2"));
-        assertEquals(2,vrp.getAllLocations().size());
+        assertEquals(2, vrp.getAllLocations().size());
     }
 
     @Test
@@ -145,7 +145,7 @@ public void whenServicesAreAdded_vrpShouldContainThem() {
         assertEquals(2, vrp.getJobs().size());
         assertEquals(s1, vrp.getJobs().get("s1"));
         assertEquals(s2, vrp.getJobs().get("s2"));
-        assertEquals(1,vrp.getAllLocations().size());
+        assertEquals(1, vrp.getAllLocations().size());
     }
 
 
@@ -307,7 +307,7 @@ private Location loc(String i) {
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void whenAddingVehiclesWithSameId_itShouldThrowException(){
+    public void whenAddingVehiclesWithSameId_itShouldThrowException() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").build();
         VehicleImpl vehicle1 = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("loc")).setType(type).build();
@@ -328,7 +328,7 @@ public void whenAddingVehicleTypesWithSameIdButDifferentCosts_itShouldThrowExcep
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void whenBuildingProblemWithSameBreakId_itShouldThrowException(){
+    public void whenBuildingProblemWithSameBreakId_itShouldThrowException() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").build();
         VehicleImpl vehicle1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(Location.newInstance("loc")).setType(type)
@@ -433,7 +433,7 @@ public void whenAddingInitialRoutes_theyShouldBeAddedCorrectly() {
 
         VehicleRoutingProblem vrp = vrpBuilder.build();
         assertEquals(2, vrp.getInitialVehicleRoutes().size());
-        assertEquals(2,vrp.getAllLocations().size());
+        assertEquals(2, vrp.getAllLocations().size());
     }
 
     @Test
@@ -447,8 +447,8 @@ public void whenAddingInitialRoute_locationOfVehicleMustBeMemorized() {
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.addInitialVehicleRoute(route);
         VehicleRoutingProblem vrp = vrpBuilder.build();
-        assertThat(vrp.getAllLocations(),hasItem(start));
-        assertThat(vrp.getAllLocations(),hasItem(end));
+        assertThat(vrp.getAllLocations(), hasItem(start));
+        assertThat(vrp.getAllLocations(), hasItem(end));
     }
 
     @Test
@@ -463,7 +463,7 @@ public void whenAddingJobAndInitialRouteWithThatJobAfterwards_thisJobShouldNotBe
         vrpBuilder.addInitialVehicleRoute(initialRoute);
         VehicleRoutingProblem vrp = vrpBuilder.build();
         assertFalse(vrp.getJobs().containsKey("myService"));
-        assertEquals(3,vrp.getAllLocations().size());
+        assertEquals(3, vrp.getAllLocations().size());
     }
 
     @Test
@@ -478,7 +478,7 @@ public void whenAddingTwoJobs_theyShouldHaveProperIndeces() {
 
         assertEquals(1, service.getIndex());
         assertEquals(2, shipment.getIndex());
-        assertEquals(3,vrp.getAllLocations().size());
+        assertEquals(3, vrp.getAllLocations().size());
 
     }
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraintTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraintTest.java
index 95def3f0d..33d8d8654 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraintTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraintTest.java
@@ -65,47 +65,20 @@
     VehicleRoutingProblem vrp;
 
     @Before
-    public void doBefore(){
+    public void doBefore() {
 
     }
 
-    private void ini(double maxTimeShipment, double maxTimeDelivery, double maxTimePickup) {
-        d1 = Delivery.Builder.newInstance("d1").setLocation(Location.newInstance(10,0)).build();
-
-        s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(20,0))
-            .setDeliveryLocation(Location.newInstance(40, 0)).setMaxTimeInVehicle(maxTimeShipment).build();
-
-        s2 = Shipment.Builder.newInstance("s2").setPickupLocation(Location.newInstance(20,0))
-            .setDeliveryLocation(Location.newInstance(40, 0)).setMaxTimeInVehicle(maxTimeShipment).build();
-
-        d2 = Delivery.Builder.newInstance("d2")
-            .setMaxTimeInVehicle(maxTimeDelivery)
-            .setLocation(Location.newInstance(30, 0)).setServiceTime(10).build();
-
-        p1 = Pickup.Builder.newInstance("p1").setLocation(Location.newInstance(10, 0)).build();
-        p2 = Pickup.Builder.newInstance("p2")
-//            .setMaxTimeInVehicle(maxTimePickup)
-            .setLocation(Location.newInstance(20, 0)).build();
-
-        v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0,0)).build();
-
-        vrp = VehicleRoutingProblem.Builder.newInstance().addJob(d1).addJob(s1).addJob(d2).addJob(p1).addJob(p2)
-            .addVehicle(v).build();
-
-        route = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory())
-            .addDelivery(d1).addPickup(s1).addDelivery(s1).build();
-    }
-
     @Test
-    public void shiftOfExistingShipmentsShouldWork(){
-        Vehicle v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0,0)).build();
+    public void shiftOfExistingShipmentsShouldWork() {
+        Vehicle v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0, 0)).build();
 
-        Shipment s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(20,0))
-            .setDeliveryLocation(Location.newInstance(40,0)).setMaxTimeInVehicle(20).build();
+        Shipment s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(20, 0))
+            .setDeliveryLocation(Location.newInstance(40, 0)).setMaxTimeInVehicle(20).build();
 
-        Shipment s2 = Shipment.Builder.newInstance("s2").setPickupLocation(Location.newInstance(20,0))
+        Shipment s2 = Shipment.Builder.newInstance("s2").setPickupLocation(Location.newInstance(20, 0))
             .setPickupServiceTime(10)
-            .setDeliveryLocation(Location.newInstance(40,0)).setMaxTimeInVehicle(20).build();
+            .setDeliveryLocation(Location.newInstance(40, 0)).setMaxTimeInVehicle(20).build();
 
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(s1).addJob(s2).addVehicle(v).build();
 
@@ -119,10 +92,10 @@ public void shiftOfExistingShipmentsShouldWork(){
         UpdateMaxTimeInVehicle updater = new UpdateMaxTimeInVehicle(stateManager, minSlackId, vrp.getTransportCosts(), vrp.getActivityCosts(), openJobsId);
         stateManager.addStateUpdater(updater);
         stateManager.addStateUpdater(new UpdateActivityTimes(vrp.getTransportCosts(), vrp.getActivityCosts()));
-        stateManager.informInsertionStarts(Arrays.asList(route),new ArrayList<Job>());
+        stateManager.informInsertionStarts(Arrays.asList(route), new ArrayList<Job>());
 
         MaxTimeInVehicleConstraint constraint = new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), minSlackId, stateManager, vrp, openJobsId);
-        JobInsertionContext c = new JobInsertionContext(route,s2,v,route.getDriver(),0.);
+        JobInsertionContext c = new JobInsertionContext(route, s2, v, route.getDriver(), 0.);
         List<AbstractActivity> acts = vrp.getActivities(s2);
 
         c.getAssociatedActivities().add(acts.get(0));
@@ -130,7 +103,7 @@ public void shiftOfExistingShipmentsShouldWork(){
 
         Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, route.getStart(), acts.get(0), route.getActivities().get(0), 0));
         Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED, constraint.fulfilled(c, act(route, 0), acts.get(0), act(route, 1), 20));
-        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, act(route,1), acts.get(0), route.getEnd(), 40));
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, act(route, 1), acts.get(0), route.getEnd(), 40));
 
         //insert pickup at 0
         c.setRelatedActivityContext(new ActivityContext());
@@ -138,16 +111,16 @@ public void shiftOfExistingShipmentsShouldWork(){
         c.getRelatedActivityContext().setEndTime(30);
         c.getRelatedActivityContext().setInsertionIndex(0);
 
-        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, acts.get(0), acts.get(1), act(route,0), 30));
-        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, act(route,0), acts.get(1), act(route,1), 30));
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, acts.get(0), acts.get(1), act(route, 0), 30));
+        Assert.assertEquals(HardActivityConstraint.ConstraintsStatus.FULFILLED, constraint.fulfilled(c, act(route, 0), acts.get(1), act(route, 1), 30));
     }
 
-    private TourActivity act(VehicleRoute route, int index){
+    private TourActivity act(VehicleRoute route, int index) {
         return route.getActivities().get(index);
     }
 
     @Test
-    public void insertingDeliveryAtAnyPositionShouldWork(){
+    public void insertingDeliveryAtAnyPositionShouldWork() {
         ini(30d, Double.MAX_VALUE, Double.MAX_VALUE);
         StateManager stateManager = new StateManager(vrp);
         StateId latestStartId = stateManager.createStateId("latest-start-id");
@@ -156,10 +129,10 @@ public void insertingDeliveryAtAnyPositionShouldWork(){
         UpdateMaxTimeInVehicle updater = new UpdateMaxTimeInVehicle(stateManager, latestStartId, vrp.getTransportCosts(), vrp.getActivityCosts(), openJobsId);
         stateManager.addStateUpdater(updater);
         stateManager.addStateUpdater(new UpdateActivityTimes(vrp.getTransportCosts(), vrp.getActivityCosts()));
-        stateManager.informInsertionStarts(Arrays.asList(route),new ArrayList<Job>());
+        stateManager.informInsertionStarts(Arrays.asList(route), new ArrayList<Job>());
 
         MaxTimeInVehicleConstraint constraint = new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), latestStartId, stateManager, vrp, openJobsId);
-        JobInsertionContext c = new JobInsertionContext(route,d2,v,route.getDriver(),0.);
+        JobInsertionContext c = new JobInsertionContext(route, d2, v, route.getDriver(), 0.);
         List<AbstractActivity> acts = vrp.getActivities(d2);
         c.getAssociatedActivities().add(acts.get(0));
 
@@ -170,6 +143,33 @@ public void insertingDeliveryAtAnyPositionShouldWork(){
 
     }
 
+    private void ini(double maxTimeShipment, double maxTimeDelivery, double maxTimePickup) {
+        d1 = Delivery.Builder.newInstance("d1").setLocation(Location.newInstance(10, 0)).build();
+
+        s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(20, 0))
+            .setDeliveryLocation(Location.newInstance(40, 0)).setMaxTimeInVehicle(maxTimeShipment).build();
+
+        s2 = Shipment.Builder.newInstance("s2").setPickupLocation(Location.newInstance(20, 0))
+            .setDeliveryLocation(Location.newInstance(40, 0)).setMaxTimeInVehicle(maxTimeShipment).build();
+
+        d2 = Delivery.Builder.newInstance("d2")
+            .setMaxTimeInVehicle(maxTimeDelivery)
+            .setLocation(Location.newInstance(30, 0)).setServiceTime(10).build();
+
+        p1 = Pickup.Builder.newInstance("p1").setLocation(Location.newInstance(10, 0)).build();
+        p2 = Pickup.Builder.newInstance("p2")
+//            .setMaxTimeInVehicle(maxTimePickup)
+            .setLocation(Location.newInstance(20, 0)).build();
+
+        v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0, 0)).build();
+
+        vrp = VehicleRoutingProblem.Builder.newInstance().addJob(d1).addJob(s1).addJob(d2).addJob(p1).addJob(p2)
+            .addVehicle(v).build();
+
+        route = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory())
+            .addDelivery(d1).addPickup(s1).addDelivery(s1).build();
+    }
+
     @Test
     public void insertingD2JustAfterStartShouldWork() {
         ini(20d, 30, Double.MAX_VALUE);
@@ -214,7 +214,7 @@ public void insertingD2AfterFirstDeliveryShouldWork() {
     }
 
     @Test
-    public void insertingDeliveryInBetweenShipmentShouldFail(){
+    public void insertingDeliveryInBetweenShipmentShouldFail() {
         ini(20d, 30, Double.MAX_VALUE);
 
         StateManager stateManager = new StateManager(vrp);
@@ -224,10 +224,10 @@ public void insertingDeliveryInBetweenShipmentShouldFail(){
         UpdateMaxTimeInVehicle updater = new UpdateMaxTimeInVehicle(stateManager, latestStartId, vrp.getTransportCosts(), vrp.getActivityCosts(), openJobsId);
         stateManager.addStateUpdater(updater);
         stateManager.addStateUpdater(new UpdateActivityTimes(vrp.getTransportCosts(), vrp.getActivityCosts()));
-        stateManager.informInsertionStarts(Arrays.asList(route),new ArrayList<Job>());
+        stateManager.informInsertionStarts(Arrays.asList(route), new ArrayList<Job>());
 
         MaxTimeInVehicleConstraint constraint = new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), latestStartId, stateManager, vrp, openJobsId);
-        JobInsertionContext c = new JobInsertionContext(route,d2,v,route.getDriver(),0.);
+        JobInsertionContext c = new JobInsertionContext(route, d2, v, route.getDriver(), 0.);
         List<AbstractActivity> acts = vrp.getActivities(d2);
         c.getAssociatedActivities().add(acts.get(0));
 
@@ -236,9 +236,8 @@ public void insertingDeliveryInBetweenShipmentShouldFail(){
     }
 
 
-
     @Test
-    public void insertingPickupShipmentAtAnyPositionShouldWork(){
+    public void insertingPickupShipmentAtAnyPositionShouldWork() {
         ini(25d, Double.MAX_VALUE, Double.MAX_VALUE);
         VehicleRoute r = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory())
             .addDelivery(d1).addDelivery(d2).build();
@@ -250,10 +249,10 @@ public void insertingPickupShipmentAtAnyPositionShouldWork(){
         UpdateMaxTimeInVehicle updater = new UpdateMaxTimeInVehicle(stateManager, latestStartId, vrp.getTransportCosts(), vrp.getActivityCosts(), openJobsId);
         stateManager.addStateUpdater(updater);
         stateManager.addStateUpdater(new UpdateActivityTimes(vrp.getTransportCosts(), vrp.getActivityCosts()));
-        stateManager.informInsertionStarts(Arrays.asList(r),new ArrayList<Job>());
+        stateManager.informInsertionStarts(Arrays.asList(r), new ArrayList<Job>());
 
         MaxTimeInVehicleConstraint constraint = new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), latestStartId, stateManager, vrp, openJobsId);
-        JobInsertionContext c = new JobInsertionContext(r, s1,v,r.getDriver(),0.);
+        JobInsertionContext c = new JobInsertionContext(r, s1, v, r.getDriver(), 0.);
         List<AbstractActivity> acts = vrp.getActivities(s1);
         c.getAssociatedActivities().add(acts.get(0));
         c.getAssociatedActivities().add(acts.get(1));
@@ -355,7 +354,7 @@ public void testOpenRoutes() {
 //    }
 
     @Test
-    public void whenPickupIsInsertedAt0_insertingDeliveryShipmentShouldFailWhereConstraintIsBroken(){
+    public void whenPickupIsInsertedAt0_insertingDeliveryShipmentShouldFailWhereConstraintIsBroken() {
         ini(25d, Double.MAX_VALUE, Double.MAX_VALUE);
         VehicleRoute r = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory())
             .addDelivery(d1).addDelivery(d2).build();
@@ -367,10 +366,10 @@ public void whenPickupIsInsertedAt0_insertingDeliveryShipmentShouldFailWhereCons
         UpdateMaxTimeInVehicle updater = new UpdateMaxTimeInVehicle(stateManager, latestStartId, vrp.getTransportCosts(), vrp.getActivityCosts(), openJobsId);
         stateManager.addStateUpdater(updater);
         stateManager.addStateUpdater(new UpdateActivityTimes(vrp.getTransportCosts(), vrp.getActivityCosts()));
-        stateManager.informInsertionStarts(Arrays.asList(r),new ArrayList<Job>());
+        stateManager.informInsertionStarts(Arrays.asList(r), new ArrayList<Job>());
 
         MaxTimeInVehicleConstraint constraint = new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), latestStartId, stateManager, vrp, openJobsId);
-        JobInsertionContext c = new JobInsertionContext(r, s1,v,r.getDriver(),0.);
+        JobInsertionContext c = new JobInsertionContext(r, s1, v, r.getDriver(), 0.);
         List<AbstractActivity> acts = vrp.getActivities(s1);
         c.getAssociatedActivities().add(acts.get(0));
         c.getAssociatedActivities().add(acts.get(1));
@@ -386,7 +385,7 @@ public void whenPickupIsInsertedAt0_insertingDeliveryShipmentShouldFailWhereCons
     }
 
     @Test
-    public void whenPickupIsInsertedAt1_insertingDeliveryShipmentShouldFailWhereConstraintIsBroken(){
+    public void whenPickupIsInsertedAt1_insertingDeliveryShipmentShouldFailWhereConstraintIsBroken() {
         ini(25d, Double.MAX_VALUE, Double.MAX_VALUE);
         VehicleRoute r = VehicleRoute.Builder.newInstance(v).setJobActivityFactory(vrp.getJobActivityFactory())
             .addDelivery(d1).addDelivery(d2).build();
@@ -395,15 +394,15 @@ public void whenPickupIsInsertedAt1_insertingDeliveryShipmentShouldFailWhereCons
         StateId latestStartId = stateManager.createStateId("latest-start-id");
         StateId openJobsId = stateManager.createStateId("open-jobs-id");
 
-        Map<String,Double> maxTimes = new HashMap<>();
-        maxTimes.put("s1",25d);
+        Map<String, Double> maxTimes = new HashMap<>();
+        maxTimes.put("s1", 25d);
         UpdateMaxTimeInVehicle updater = new UpdateMaxTimeInVehicle(stateManager, latestStartId, vrp.getTransportCosts(), vrp.getActivityCosts(), openJobsId);
         stateManager.addStateUpdater(updater);
         stateManager.addStateUpdater(new UpdateActivityTimes(vrp.getTransportCosts(), vrp.getActivityCosts()));
-        stateManager.informInsertionStarts(Arrays.asList(r),new ArrayList<Job>());
+        stateManager.informInsertionStarts(Arrays.asList(r), new ArrayList<Job>());
 
         MaxTimeInVehicleConstraint constraint = new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), latestStartId, stateManager, vrp, openJobsId);
-        JobInsertionContext c = new JobInsertionContext(r, s1,v,r.getDriver(),0.);
+        JobInsertionContext c = new JobInsertionContext(r, s1, v, r.getDriver(), 0.);
         List<AbstractActivity> acts = vrp.getActivities(s1);
         c.getAssociatedActivities().add(acts.get(0));
         c.getAssociatedActivities().add(acts.get(1));
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/ServiceLoadRouteLevelConstraintTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/ServiceLoadRouteLevelConstraintTest.java
index 39e2bdb22..d69404730 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/ServiceLoadRouteLevelConstraintTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/ServiceLoadRouteLevelConstraintTest.java
@@ -44,15 +44,11 @@
 
 public class ServiceLoadRouteLevelConstraintTest {
 
-    private Vehicle vehicle;
-
-    private VehicleRoute route;
-
     RouteAndActivityStateGetter stateGetter;
-
     ServiceLoadRouteLevelConstraint constraint;
-
     StateManager stateManager;
+    private Vehicle vehicle;
+    private VehicleRoute route;
 
     @Before
     public void doBefore() {
@@ -334,6 +330,10 @@ public void whenNewVehicleCapacityIsNotSufficiant1_returnFalse() {
         assertFalse(new ServiceLoadRouteLevelConstraint(stateManager).fulfilled(iContext));
     }
 
+    private Service createPickup(String string, int i) {
+        return Pickup.Builder.newInstance(string).addSizeDimension(0, i).setLocation(Location.newInstance("loc")).build();
+    }
+
     @Test
     public void whenNewVehicleCapacityIsNotSufficiant2_returnFalse() {
         Pickup service = (Pickup) createPickup("pick", 2);
@@ -349,9 +349,4 @@ public void whenNewVehicleCapacityIsNotSufficiant2_returnFalse() {
     }
 
 
-    private Service createPickup(String string, int i) {
-        return Pickup.Builder.newInstance(string).addSizeDimension(0, i).setLocation(Location.newInstance("loc")).build();
-    }
-
-
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTimeWindowWithStartTimeAndMaxOperationTimeTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTimeWindowWithStartTimeAndMaxOperationTimeTest.java
index 373b0edd2..fe6bca4e4 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTimeWindowWithStartTimeAndMaxOperationTimeTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTimeWindowWithStartTimeAndMaxOperationTimeTest.java
@@ -131,7 +131,7 @@ public void doBefore() {
 
         });
         stateManager.addStateUpdater(timeWindow_updater);
-        stateManager.addStateUpdater(new UpdateActivityTimes(routingCosts,activityCosts));
+        stateManager.addStateUpdater(new UpdateActivityTimes(routingCosts, activityCosts));
         stateManager.informInsertionStarts(Arrays.asList(route), Collections.<Job>emptyList());
     }
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
index 3dbfc8d5e..e8ebbadf6 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
@@ -144,6 +144,13 @@ public void insertNewInVehicleShouldFail() {
         Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(4), newAct(), route.getEnd(), 0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
     }
 
+    private TourActivity newAct() {
+        return vrp.getActivities(newDelivery).get(0);
+    }
+
+    private TourActivity act(int i) {
+        return route.getActivities().get(i);
+    }
 
     @Test
     public void insertNewInVehicle2ShouldBeCorrect() {
@@ -164,14 +171,6 @@ public void insertNewInVehicle2ShouldBeCorrect() {
         Assert.assertTrue(maxDistanceConstraint.fulfilled(context, act(4), newAct(), route.getEnd(), 0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
     }
 
-    private TourActivity act(int i) {
-        return route.getActivities().get(i);
-    }
-
-    private TourActivity newAct() {
-        return vrp.getActivities(newDelivery).get(0);
-    }
-
     @Test
     public void traveledDistanceShouldBeCorrect() {
         Assert.assertEquals(20d, stateManager.getActivityState(route.getActivities().get(0), vehicle, traveledDistanceId, Double.class), 0.01);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/DeliveryTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/DeliveryTest.java
index 3ee2dadc6..8af14de5f 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/DeliveryTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/DeliveryTest.java
@@ -93,32 +93,32 @@ public void nameShouldBeAssigned() {
     }
 
     @Test
-    public void whenSettingPriorities_itShouldBeSetCorrectly(){
+    public void whenSettingPriorities_itShouldBeSetCorrectly() {
         Delivery s = Delivery.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
             .setPriority(3).build();
         Assert.assertEquals(3, s.getPriority());
     }
 
     @Test
-    public void whenNotSettingPriorities_defaultShouldBe(){
+    public void whenNotSettingPriorities_defaultShouldBe() {
         Delivery s = Delivery.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
             .build();
         Assert.assertEquals(2, s.getPriority());
     }
 
     @Test
-    public void whenAddingMaxTimeInVehicle_itShouldBeSet(){
+    public void whenAddingMaxTimeInVehicle_itShouldBeSet() {
         Delivery s = Delivery.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
             .setMaxTimeInVehicle(10)
             .build();
-        Assert.assertEquals(10, s.getMaxTimeInVehicle(),0.001);
+        Assert.assertEquals(10, s.getMaxTimeInVehicle(), 0.001);
     }
 
     @Test
-    public void whenNotAddingMaxTimeInVehicle_itShouldBeDefault(){
+    public void whenNotAddingMaxTimeInVehicle_itShouldBeDefault() {
         Delivery s = Delivery.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
             .build();
-        Assert.assertEquals(Double.MAX_VALUE, s.getMaxTimeInVehicle(),0.001);
+        Assert.assertEquals(Double.MAX_VALUE, s.getMaxTimeInVehicle(), 0.001);
     }
 
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/PickupTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/PickupTest.java
index b480b5296..644fb6b15 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/PickupTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/PickupTest.java
@@ -95,14 +95,14 @@ public void nameShouldBeAssigned() {
 
 
     @Test
-    public void whenSettingPriorities_itShouldBeSetCorrectly(){
+    public void whenSettingPriorities_itShouldBeSetCorrectly() {
         Pickup s = Pickup.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
             .setPriority(3).build();
         Assert.assertEquals(3, s.getPriority());
     }
 
     @Test
-    public void whenNotSettingPriorities_defaultShouldBe(){
+    public void whenNotSettingPriorities_defaultShouldBe() {
         Pickup s = Pickup.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
             .build();
         Assert.assertEquals(2, s.getPriority());
@@ -121,17 +121,17 @@ public void whenSettingUserData_itIsAssociatedWithTheJob() {
     }
 
     @Test(expected = UnsupportedOperationException.class)
-    public void whenAddingMaxTimeInVehicle_itShouldThrowEx(){
+    public void whenAddingMaxTimeInVehicle_itShouldThrowEx() {
         Pickup s = Pickup.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
             .setMaxTimeInVehicle(10)
             .build();
     }
 
     @Test
-    public void whenNotAddingMaxTimeInVehicle_itShouldBeDefault(){
+    public void whenNotAddingMaxTimeInVehicle_itShouldBeDefault() {
         Pickup s = Pickup.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
             .build();
-        Assert.assertEquals(Double.MAX_VALUE, s.getMaxTimeInVehicle(),0.001);
+        Assert.assertEquals(Double.MAX_VALUE, s.getMaxTimeInVehicle(), 0.001);
     }
 
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ServiceTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ServiceTest.java
index 9ab100159..c1fbd988d 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ServiceTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ServiceTest.java
@@ -123,8 +123,8 @@ public void whenSettingLocationCoord_itShouldBeSetCorrectly() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance(1, 2)).build();
         assertEquals(1.0, s.getLocation().getCoordinate().getX(), 0.01);
         assertEquals(2.0, s.getLocation().getCoordinate().getY(), 0.01);
-        assertEquals(1.0,s.getLocation().getCoordinate().getX(),0.01);
-        assertEquals(2.0,s.getLocation().getCoordinate().getY(),0.01);
+        assertEquals(1.0, s.getLocation().getCoordinate().getX(), 0.01);
+        assertEquals(2.0, s.getLocation().getCoordinate().getY(), 0.01);
     }
 
     @Test(expected = IllegalArgumentException.class)
@@ -176,7 +176,7 @@ public void whenAddingSkillsCaseSens_theyShouldBeAddedCorrectly() {
     }
 
     @Test
-    public void whenAddingSeveralTimeWindows_itShouldBeSetCorrectly(){
+    public void whenAddingSeveralTimeWindows_itShouldBeSetCorrectly() {
         TimeWindow tw1 = TimeWindow.newInstance(1.0, 2.0);
         TimeWindow tw2 = TimeWindow.newInstance(3.0, 5.0);
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
@@ -184,12 +184,12 @@ public void whenAddingSeveralTimeWindows_itShouldBeSetCorrectly(){
             .addTimeWindow(tw2)
             .build();
         assertEquals(2, s.getTimeWindows().size());
-        assertThat(s.getTimeWindows(),hasItem(is(tw1)));
-        assertThat(s.getTimeWindows(),hasItem(is(tw2)));
+        assertThat(s.getTimeWindows(), hasItem(is(tw1)));
+        assertThat(s.getTimeWindows(), hasItem(is(tw2)));
     }
 
     @Test
-    public void whenAddingTimeWindow_itShouldBeSetCorrectly(){
+    public void whenAddingTimeWindow_itShouldBeSetCorrectly() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
             .addTimeWindow(TimeWindow.newInstance(1.0, 2.0)).build();
         assertEquals(1.0, s.getTimeWindow().getStart(), 0.01);
@@ -197,8 +197,6 @@ public void whenAddingTimeWindow_itShouldBeSetCorrectly(){
     }
 
 
-
-
     @Test
     public void whenAddingSkillsCaseSensV2_theyShouldBeAddedCorrectly() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
@@ -239,14 +237,14 @@ public void whenMultipleTWOverlap2_throwEx() {
     }
 
     @Test
-    public void whenSettingPriorities_itShouldBeSetCorrectly(){
+    public void whenSettingPriorities_itShouldBeSetCorrectly() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
             .setPriority(1).build();
         Assert.assertEquals(1, s.getPriority());
     }
 
     @Test
-    public void whenSettingPriorities_itShouldBeSetCorrectly2(){
+    public void whenSettingPriorities_itShouldBeSetCorrectly2() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
             .setPriority(3).build();
         Assert.assertEquals(3, s.getPriority());
@@ -260,38 +258,38 @@ public void whenSettingPriorities_itShouldBeSetCorrectly3() {
     }
 
     @Test
-    public void whenNotSettingPriorities_defaultShouldBe2(){
+    public void whenNotSettingPriorities_defaultShouldBe2() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
             .build();
         Assert.assertEquals(2, s.getPriority());
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void whenSettingIncorrectPriorities_itShouldThrowException(){
+    public void whenSettingIncorrectPriorities_itShouldThrowException() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
             .setPriority(30).build();
 
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void whenSettingIncorrectPriorities_itShouldThrowException2(){
+    public void whenSettingIncorrectPriorities_itShouldThrowException2() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
             .setPriority(0).build();
 
     }
 
     @Test(expected = UnsupportedOperationException.class)
-    public void whenAddingMaxTimeInVehicle_itShouldThrowEx(){
+    public void whenAddingMaxTimeInVehicle_itShouldThrowEx() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
             .setMaxTimeInVehicle(10)
             .build();
     }
 
     @Test
-    public void whenNotAddingMaxTimeInVehicle_itShouldBeDefault(){
+    public void whenNotAddingMaxTimeInVehicle_itShouldBeDefault() {
         Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
             .build();
-        Assert.assertEquals(Double.MAX_VALUE, s.getMaxTimeInVehicle(),0.001);
+        Assert.assertEquals(Double.MAX_VALUE, s.getMaxTimeInVehicle(), 0.001);
     }
 
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ShipmentTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ShipmentTest.java
index 7e271092e..cb2c7f8d2 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ShipmentTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ShipmentTest.java
@@ -248,25 +248,24 @@ public void whenUsingAddDeliveryTimeWindow2_itShouldBeDoneCorrectly() {
 
     @Test
     public void whenAddingMultipleDeliveryTimeWindows_itShouldBeDoneCorrectly() {
-        TimeWindow tw1 = TimeWindow.newInstance(1,2);
-        TimeWindow tw2 = TimeWindow.newInstance(4,5);
+        TimeWindow tw1 = TimeWindow.newInstance(1, 2);
+        TimeWindow tw2 = TimeWindow.newInstance(4, 5);
         Shipment s = Shipment.Builder.newInstance("s").addDeliveryTimeWindow(tw1).addDeliveryTimeWindow(tw2)
             .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
-        assertEquals(s.getDeliveryTimeWindows().size(),2);
-        assertThat(s.getDeliveryTimeWindows(),hasItem(is(tw1)));
-        assertThat(s.getDeliveryTimeWindows(),hasItem(is(tw2)));
+        assertEquals(s.getDeliveryTimeWindows().size(), 2);
+        assertThat(s.getDeliveryTimeWindows(), hasItem(is(tw1)));
+        assertThat(s.getDeliveryTimeWindows(), hasItem(is(tw2)));
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void whenAddingMultipleOverlappingDeliveryTimeWindows_itShouldThrowException() {
-        Shipment s = Shipment.Builder.newInstance("s").addDeliveryTimeWindow(1, 3).addDeliveryTimeWindow(2,5)
+        Shipment s = Shipment.Builder.newInstance("s").addDeliveryTimeWindow(1, 3).addDeliveryTimeWindow(2, 5)
             .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
         assertEquals(1.0, s.getDeliveryTimeWindow().getStart(), 0.01);
         assertEquals(2.0, s.getDeliveryTimeWindow().getEnd(), 0.01);
     }
 
 
-
     @Test
     public void whenUsingAddPickupTimeWindow_itShouldBeDoneCorrectly() {
         Shipment s = Shipment.Builder.newInstance("s").addPickupTimeWindow(TimeWindow.newInstance(1, 2))
@@ -285,25 +284,24 @@ public void whenUsingAddPickupTimeWindow2_itShouldBeDoneCorrectly() {
 
     @Test
     public void whenAddingMultiplePickupTimeWindows_itShouldBeDoneCorrectly() {
-        TimeWindow tw1 = TimeWindow.newInstance(1,2);
-        TimeWindow tw2 = TimeWindow.newInstance(4,5);
+        TimeWindow tw1 = TimeWindow.newInstance(1, 2);
+        TimeWindow tw2 = TimeWindow.newInstance(4, 5);
         Shipment s = Shipment.Builder.newInstance("s").addPickupTimeWindow(tw1).addPickupTimeWindow(tw2)
             .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
-        assertEquals(s.getPickupTimeWindows().size(),2);
+        assertEquals(s.getPickupTimeWindows().size(), 2);
         assertThat(s.getPickupTimeWindows(), hasItem(is(tw1)));
         assertThat(s.getPickupTimeWindows(), hasItem(is(tw2)));
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void whenAddingMultipleOverlappingPickupTimeWindows_itShouldThrowException() {
-        Shipment s = Shipment.Builder.newInstance("s").addPickupTimeWindow(1, 3).addPickupTimeWindow(2,5)
+        Shipment s = Shipment.Builder.newInstance("s").addPickupTimeWindow(1, 3).addPickupTimeWindow(2, 5)
             .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
         assertEquals(1.0, s.getPickupTimeWindow().getStart(), 0.01);
         assertEquals(2.0, s.getPickupTimeWindow().getEnd(), 0.01);
     }
 
 
-
     @Test(expected = IllegalArgumentException.class)
     public void whenShipmentHasNegativeCapacityVal_throwIllegalStateExpception() {
         @SuppressWarnings("unused")
@@ -389,7 +387,7 @@ public void whenSettingLocation_itShouldWork() {
     }
 
     @Test
-    public void whenSettingPriorities_itShouldBeSetCorrectly(){
+    public void whenSettingPriorities_itShouldBeSetCorrectly() {
         Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc"))
             .setDeliveryLocation(Location.newInstance("loc"))
             .setPriority(1).build();
@@ -397,7 +395,7 @@ public void whenSettingPriorities_itShouldBeSetCorrectly(){
     }
 
     @Test
-    public void whenSettingPriorities_itShouldBeSetCorrectly2(){
+    public void whenSettingPriorities_itShouldBeSetCorrectly2() {
         Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc"))
             .setDeliveryLocation(Location.newInstance("loc"))
             .setPriority(3).build();
@@ -413,7 +411,7 @@ public void whenSettingPriorities_itShouldBeSetCorrectly3() {
     }
 
     @Test
-    public void whenNotSettingPriorities_defaultShouldBe2(){
+    public void whenNotSettingPriorities_defaultShouldBe2() {
         Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc"))
             .setDeliveryLocation(Location.newInstance("loc"))
             .build();
@@ -421,7 +419,7 @@ public void whenNotSettingPriorities_defaultShouldBe2(){
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void whenSettingIncorrectPriorities_itShouldThrowException(){
+    public void whenSettingIncorrectPriorities_itShouldThrowException() {
         Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc"))
             .setDeliveryLocation(Location.newInstance("loc"))
             .setPriority(30).build();
@@ -429,7 +427,7 @@ public void whenSettingIncorrectPriorities_itShouldThrowException(){
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void whenSettingIncorrectPriorities_itShouldThrowException2(){
+    public void whenSettingIncorrectPriorities_itShouldThrowException2() {
         Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc"))
             .setDeliveryLocation(Location.newInstance("loc"))
             .setPriority(0).build();
@@ -449,19 +447,20 @@ public void whenSettingUserData_itIsAssociatedWithTheJob() {
         assertEquals(42, two.getUserData());
         assertNull(three.getUserData());
     }
+
     @Test
-    public void whenAddingMaxTimeInVehicle_itShouldBeSet(){
+    public void whenAddingMaxTimeInVehicle_itShouldBeSet() {
         Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc")).setDeliveryLocation(Location.newInstance("loc"))
             .setMaxTimeInVehicle(10)
             .build();
-        Assert.assertEquals(10, s.getMaxTimeInVehicle(),0.001);
+        Assert.assertEquals(10, s.getMaxTimeInVehicle(), 0.001);
     }
 
     @Test
-    public void whenNotAddingMaxTimeInVehicle_itShouldBeDefault(){
+    public void whenNotAddingMaxTimeInVehicle_itShouldBeDefault() {
         Shipment s = Shipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc")).setDeliveryLocation(Location.newInstance("loc"))
             .build();
-        Assert.assertEquals(Double.MAX_VALUE, s.getMaxTimeInVehicle(),0.001);
+        Assert.assertEquals(Double.MAX_VALUE, s.getMaxTimeInVehicle(), 0.001);
     }
 
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRouteBuilderTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRouteBuilderTest.java
index dbb71cccb..bfa059b8f 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRouteBuilderTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRouteBuilderTest.java
@@ -55,8 +55,8 @@ public void whenShipmentIsPickedDeliveredAndDeliveredAgain_throwsException() {
         Shipment s = mock(Shipment.class);
         Capacity capacity = Capacity.Builder.newInstance().build();
         when(s.getSize()).thenReturn(capacity);
-        when(s.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
-        when(s.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
+        when(s.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
+        when(s.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
         VehicleRoute.Builder builder = VehicleRoute.Builder.newInstance(mock(Vehicle.class), mock(Driver.class));
         builder.addPickup(s);
         builder.addDelivery(s);
@@ -70,10 +70,10 @@ public void whenShipmentIsPickedUpThoughButHasNotBeenDeliveredAndRouteIsBuilt_th
         Shipment s2 = mock(Shipment.class);
         when(s2.getSize()).thenReturn(capacity);
         when(s.getSize()).thenReturn(capacity);
-        when(s2.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
-        when(s2.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
-        when(s.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
-        when(s.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
+        when(s2.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
+        when(s2.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
+        when(s.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
+        when(s.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
         VehicleRoute.Builder builder = VehicleRoute.Builder.newInstance(mock(Vehicle.class), mock(Driver.class));
         builder.addPickup(s);
         builder.addPickup(s2);
@@ -88,10 +88,10 @@ public void whenTwoShipmentsHaveBeenAdded_nuOfActivitiesMustEqualFour() {
         Capacity capacity = Capacity.Builder.newInstance().build();
         when(s.getSize()).thenReturn(capacity);
         when(s2.getSize()).thenReturn(capacity);
-        when(s2.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
-        when(s2.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
-        when(s.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
-        when(s.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
+        when(s2.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
+        when(s2.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
+        when(s.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
+        when(s.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
         VehicleRoute.Builder builder = VehicleRoute.Builder.newInstance(mock(Vehicle.class), mock(Driver.class));
         builder.addPickup(s);
         builder.addPickup(s2);
@@ -108,10 +108,10 @@ public void whenBuildingClosedRoute_routeEndShouldHaveLocationOfVehicle() {
         Capacity capacity = Capacity.Builder.newInstance().build();
         when(s.getSize()).thenReturn(capacity);
         when(s2.getSize()).thenReturn(capacity);
-        when(s2.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
-        when(s2.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
-        when(s.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
-        when(s.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
+        when(s2.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
+        when(s2.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
+        when(s.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
+        when(s.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
         Vehicle vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("vehLoc")).setEndLocation(Location.newInstance("vehLoc"))
             .build();
 
@@ -132,10 +132,10 @@ public void whenBuildingOpenRoute_routeEndShouldHaveLocationOfLastActivity() {
         when(s.getSize()).thenReturn(capacity);
         when(s2.getSize()).thenReturn(capacity);
         when(s2.getDeliveryLocation()).thenReturn(loc("delLoc"));
-        when(s.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
-        when(s.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
-        when(s2.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
-        when(s2.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
+        when(s.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
+        when(s.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
+        when(s2.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
+        when(s2.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
         Vehicle vehicle = mock(Vehicle.class);
         when(vehicle.isReturnToDepot()).thenReturn(false);
         when(vehicle.getStartLocation()).thenReturn(loc("vehLoc"));
@@ -160,10 +160,10 @@ public void whenSettingDepartureTime() {
         when(s.getSize()).thenReturn(capacity);
         when(s2.getSize()).thenReturn(capacity);
         when(s2.getDeliveryLocation()).thenReturn(Location.Builder.newInstance().setId("delLoc").build());
-        when(s.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
-        when(s.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
+        when(s.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
+        when(s.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
         when(s2.getPickupTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
-        when(s2.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0.,10.));
+        when(s2.getDeliveryTimeWindow()).thenReturn(TimeWindow.newInstance(0., 10.));
         Vehicle vehicle = mock(Vehicle.class);
         when(vehicle.isReturnToDepot()).thenReturn(false);
         when(vehicle.getStartLocation()).thenReturn(Location.Builder.newInstance().setId("vehLoc").build());
@@ -179,5 +179,4 @@ public void whenSettingDepartureTime() {
     }
 
 
-
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindowsImplTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindowsImplTest.java
index 0780458bf..11e19ed32 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindowsImplTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindowsImplTest.java
@@ -26,21 +26,21 @@
 public class TimeWindowsImplTest {
 
     @Test(expected = IllegalArgumentException.class)
-    public void overlappingTW_shouldThrowException(){
+    public void overlappingTW_shouldThrowException() {
         TimeWindowsImpl tws = new TimeWindowsImpl();
         tws.add(TimeWindow.newInstance(50, 100));
-        tws.add(TimeWindow.newInstance(90,150));
+        tws.add(TimeWindow.newInstance(90, 150));
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void overlappingTW2_shouldThrowException(){
+    public void overlappingTW2_shouldThrowException() {
         TimeWindowsImpl tws = new TimeWindowsImpl();
         tws.add(TimeWindow.newInstance(50, 100));
-        tws.add(TimeWindow.newInstance(40,150));
+        tws.add(TimeWindow.newInstance(40, 150));
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void overlappingTW3_shouldThrowException(){
+    public void overlappingTW3_shouldThrowException() {
         TimeWindowsImpl tws = new TimeWindowsImpl();
         tws.add(TimeWindow.newInstance(50, 100));
         tws.add(TimeWindow.newInstance(50, 100));
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/vehicle/TestVehicleFleetManagerImpl.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/vehicle/TestVehicleFleetManagerImpl.java
index 6d233bd00..cf37ac87b 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/vehicle/TestVehicleFleetManagerImpl.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/vehicle/TestVehicleFleetManagerImpl.java
@@ -149,6 +149,13 @@ public void whenAddingTwoVehiclesWithDifferentType_getAvailableVehicleShouldRetu
         assertTrue(vehicleInCollection(v2, vehicles));
     }
 
+    private boolean vehicleInCollection(Vehicle v, Collection<Vehicle> vehicles) {
+        for (Vehicle veh : vehicles) {
+            if (veh == v) return true;
+        }
+        return false;
+    }
+
     @Test
     public void whenAddingTwoVehiclesWithDifferentStartLocation_getAvailableVehicleShouldReturnBoth() {
         VehicleTypeImpl type = VehicleTypeImpl.Builder.newInstance("standard").build();
@@ -209,12 +216,5 @@ public void whenAddingTwoVehiclesWithDifferentLatestArr_getAvailableVehicleShoul
         assertTrue(vehicleInCollection(v2, vehicles));
     }
 
-    private boolean vehicleInCollection(Vehicle v, Collection<Vehicle> vehicles) {
-        for (Vehicle veh : vehicles) {
-            if (veh == v) return true;
-        }
-        return false;
-    }
-
 
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/ChristofidesReader.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/ChristofidesReader.java
index 80ae0f86b..04f20d064 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/ChristofidesReader.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/ChristofidesReader.java
@@ -95,15 +95,13 @@ public void read(InputStream inputStream) {
                 Coordinate customerCoord = makeCoord(tokens[0].trim(), tokens[1].trim());
                 int demand = Integer.parseInt(tokens[2].trim());
                 String customer = Integer.valueOf(counter - 1).toString();
-                if(jobType.equals(JobType.SERVICE)) {
+                if (jobType.equals(JobType.SERVICE)) {
                     Service service = Service.Builder.newInstance(customer).addSizeDimension(0, demand).setServiceTime(serviceTime).setLocation(Location.newInstance(customerCoord.getX(), customerCoord.getY())).build();
                     vrpBuilder.addJob(service);
-                }
-                else if(jobType.equals(JobType.DELIVERY)){
+                } else if (jobType.equals(JobType.DELIVERY)) {
                     Delivery service = Delivery.Builder.newInstance(customer).addSizeDimension(0, demand).setServiceTime(serviceTime).setLocation(Location.newInstance(customerCoord.getX(), customerCoord.getY())).build();
                     vrpBuilder.addJob(service);
-                }
-                else if(jobType.equals(JobType.PICKUP)){
+                } else if (jobType.equals(JobType.PICKUP)) {
                     Pickup service = Pickup.Builder.newInstance(customer).addSizeDimension(0, demand).setServiceTime(serviceTime).setLocation(Location.newInstance(customerCoord.getX(), customerCoord.getY())).build();
                     vrpBuilder.addJob(service);
                 }
@@ -113,16 +111,8 @@ else if(jobType.equals(JobType.PICKUP)){
         close(reader);
     }
 
-    public void setCoordProjectionFactor(double coordProjectionFactor) {
-        this.coordProjectionFactor = coordProjectionFactor;
-    }
-
-    private void close(BufferedReader reader) {
-        try {
-            reader.close();
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
+    private BufferedReader getReader(InputStream inputStream) {
+        return new BufferedReader(new InputStreamReader(inputStream));
     }
 
     private String readLine(BufferedReader reader) {
@@ -139,8 +129,16 @@ private Coordinate makeCoord(String xString, String yString) {
         return new Coordinate(x * coordProjectionFactor, y * coordProjectionFactor);
     }
 
-    private BufferedReader getReader(InputStream inputStream) {
-        return new BufferedReader(new InputStreamReader(inputStream));
+    private void close(BufferedReader reader) {
+        try {
+            reader.close();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public void setCoordProjectionFactor(double coordProjectionFactor) {
+        this.coordProjectionFactor = coordProjectionFactor;
     }
 
     public ChristofidesReader setJobType(JobType jobType) {
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/FastVehicleRoutingTransportCostsMatrixTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/FastVehicleRoutingTransportCostsMatrixTest.java
index 4e1361eec..9634c3695 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/FastVehicleRoutingTransportCostsMatrixTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/FastVehicleRoutingTransportCostsMatrixTest.java
@@ -40,6 +40,9 @@ public void whenAddingDistanceToSymmetricMatrix_itShouldReturnCorrectValues() {
         assertEquals(2., matrix.getDistance(2, 1), 0.1);
     }
 
+    private Location loc(int index) {
+        return Location.Builder.newInstance().setIndex(index).build();
+    }
 
     @Test
     public void whenAddingDistanceToAsymmetricMatrix_itShouldReturnCorrectValues() {
@@ -49,11 +52,6 @@ public void whenAddingDistanceToAsymmetricMatrix_itShouldReturnCorrectValues() {
         assertEquals(2., matrix.getTransportCost(loc(1), loc(2), 0.0, null, null), 0.1);
     }
 
-    private Location loc(int index) {
-        return Location.Builder.newInstance().setIndex(index).build();
-    }
-
-
     @Test
     public void whenAddingTimeToSymmetricMatrix_itShouldReturnCorrectValues() {
         FastVehicleRoutingTransportCostsMatrix.Builder matrixBuilder = FastVehicleRoutingTransportCostsMatrix.Builder.newInstance(3, true);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/LiLimReader.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/LiLimReader.java
index 3b53bb674..a559630b3 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/LiLimReader.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/LiLimReader.java
@@ -48,51 +48,14 @@
 
 public class LiLimReader {
 
-    static class CustomerData {
-        public Coordinate coord;
-        public double start;
-        public double end;
-        public double serviceTime;
-
-        public CustomerData(Coordinate coord, double start, double end, double serviceTime) {
-            super();
-            this.coord = coord;
-            this.start = start;
-            this.end = end;
-            this.serviceTime = serviceTime;
-        }
-    }
-
-    static class Relation {
-        public String from;
-        public String to;
-        public int demand;
-
-        public Relation(String from, String to, int demand) {
-            super();
-            this.from = from;
-            this.to = to;
-            this.demand = demand;
-        }
-
-    }
-
     private static Logger logger = LoggerFactory.getLogger(LiLimReader.class);
-
     private Builder vrpBuilder;
-
     private int vehicleCapacity;
-
     private String depotId;
-
     private Map<String, CustomerData> customers;
-
     private Collection<Relation> relations;
-
     private double depotOpeningTime;
-
     private double depotClosingTime;
-
     private int fixCosts = 0;
 
     public LiLimReader(Builder vrpBuilder) {
@@ -119,27 +82,6 @@ public void read(InputStream inputStream) {
         vrpBuilder.addVehicle(vehicle);
     }
 
-    private void buildShipments() {
-        Integer counter = 0;
-        for (Relation rel : relations) {
-            counter++;
-            String from = rel.from;
-            String to = rel.to;
-            int demand = rel.demand;
-            Shipment s = Shipment.Builder.newInstance(counter.toString()).addSizeDimension(0, demand)
-                .setPickupLocation(Location.Builder.newInstance().setCoordinate(customers.get(from).coord).build()).setPickupServiceTime(customers.get(from).serviceTime)
-                .setPickupTimeWindow(TimeWindow.newInstance(customers.get(from).start, customers.get(from).end))
-                .setDeliveryLocation(Location.Builder.newInstance().setCoordinate(customers.get(to).coord).build()).setDeliveryServiceTime(customers.get(to).serviceTime)
-                .setDeliveryTimeWindow(TimeWindow.newInstance(customers.get(to).start, customers.get(to).end)).build();
-            vrpBuilder.addJob(s);
-        }
-
-    }
-
-    private BufferedReader getReader(InputStream inputStream) {
-        return new BufferedReader(new InputStreamReader(inputStream));
-    }
-
     private void readShipments(InputStream inputStream) {
         BufferedReader reader = getReader(inputStream);
         String line = null;
@@ -180,6 +122,31 @@ private void readShipments(InputStream inputStream) {
 
     }
 
+    private void buildShipments() {
+        Integer counter = 0;
+        for (Relation rel : relations) {
+            counter++;
+            String from = rel.from;
+            String to = rel.to;
+            int demand = rel.demand;
+            Shipment s = Shipment.Builder.newInstance(counter.toString()).addSizeDimension(0, demand)
+                .setPickupLocation(Location.Builder.newInstance().setCoordinate(customers.get(from).coord).build()).setPickupServiceTime(customers.get(from).serviceTime)
+                .setPickupTimeWindow(TimeWindow.newInstance(customers.get(from).start, customers.get(from).end))
+                .setDeliveryLocation(Location.Builder.newInstance().setCoordinate(customers.get(to).coord).build()).setDeliveryServiceTime(customers.get(to).serviceTime)
+                .setDeliveryTimeWindow(TimeWindow.newInstance(customers.get(to).start, customers.get(to).end)).build();
+            vrpBuilder.addJob(s);
+        }
+
+    }
+
+    private BufferedReader getReader(InputStream inputStream) {
+        return new BufferedReader(new InputStreamReader(inputStream));
+    }
+
+    private int getInt(String string) {
+        return Integer.parseInt(string);
+    }
+
     private Coordinate makeCoord(String xString, String yString) {
         double x = Double.parseDouble(xString);
         double y = Double.parseDouble(yString);
@@ -190,8 +157,33 @@ private double getDouble(String string) {
         return Double.parseDouble(string);
     }
 
-    private int getInt(String string) {
-        return Integer.parseInt(string);
+    static class CustomerData {
+        public Coordinate coord;
+        public double start;
+        public double end;
+        public double serviceTime;
+
+        public CustomerData(Coordinate coord, double start, double end, double serviceTime) {
+            super();
+            this.coord = coord;
+            this.start = start;
+            this.end = end;
+            this.serviceTime = serviceTime;
+        }
+    }
+
+    static class Relation {
+        public String from;
+        public String to;
+        public int demand;
+
+        public Relation(String from, String to, int demand) {
+            super();
+            this.from = from;
+            this.to = to;
+            this.demand = demand;
+        }
+
     }
 
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/SolomonReader.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/SolomonReader.java
index 75818a6c4..1f396472d 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/SolomonReader.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/SolomonReader.java
@@ -44,23 +44,11 @@
 
 public class SolomonReader {
 
-    /**
-     * @param costProjectionFactor the costProjectionFactor to set
-     */
-    public void setVariableCostProjectionFactor(double costProjectionFactor) {
-        this.variableCostProjectionFactor = costProjectionFactor;
-    }
-
     private static Logger logger = LoggerFactory.getLogger(SolomonReader.class);
-
     private final VehicleRoutingProblem.Builder vrpBuilder;
-
     private double coordProjectionFactor = 1;
-
     private double timeProjectionFactor = 1;
-
     private double variableCostProjectionFactor = 1;
-
     private double fixedCostPerVehicle = 0.0;
 
     public SolomonReader(VehicleRoutingProblem.Builder vrpBuilder) {
@@ -74,6 +62,13 @@ public SolomonReader(VehicleRoutingProblem.Builder vrpBuilder, double fixedCostP
         this.fixedCostPerVehicle = fixedCostPerVehicle;
     }
 
+    /**
+     * @param costProjectionFactor the costProjectionFactor to set
+     */
+    public void setVariableCostProjectionFactor(double costProjectionFactor) {
+        this.variableCostProjectionFactor = costProjectionFactor;
+    }
+
     public void read(InputStream inputStream) {
         vrpBuilder.setFleetSize(FleetSize.INFINITE);
         BufferedReader reader = getReader(inputStream);
@@ -119,16 +114,8 @@ public void read(InputStream inputStream) {
         close(reader);
     }
 
-    public void setCoordProjectionFactor(double coordProjectionFactor) {
-        this.coordProjectionFactor = coordProjectionFactor;
-    }
-
-    private void close(BufferedReader reader) {
-        try {
-            reader.close();
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
+    private BufferedReader getReader(InputStream inputStream) {
+        return new BufferedReader(new InputStreamReader(inputStream));
     }
 
     private String readLine(BufferedReader reader) {
@@ -145,8 +132,16 @@ private Coordinate makeCoord(String xString, String yString) {
         return new Coordinate(x * coordProjectionFactor, y * coordProjectionFactor);
     }
 
-    private BufferedReader getReader(InputStream inputStream) {
-        return new BufferedReader(new InputStreamReader(inputStream));
+    private void close(BufferedReader reader) {
+        try {
+            reader.close();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public void setCoordProjectionFactor(double coordProjectionFactor) {
+        this.coordProjectionFactor = coordProjectionFactor;
     }
 
     public void setTimeProjectionFactor(double timeProjection) {
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/VehicleRoutingTransportCostsMatrixTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/VehicleRoutingTransportCostsMatrixTest.java
index 6ec6d80c6..7eead9ae0 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/VehicleRoutingTransportCostsMatrixTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/VehicleRoutingTransportCostsMatrixTest.java
@@ -40,6 +40,10 @@ public void whenAddingDistanceToSymmetricMatrix_itShouldReturnCorrectValues() {
         assertEquals(2., matrix.getDistance("2", "1"), 0.1);
     }
 
+    private Location loc(String s) {
+        return Location.Builder.newInstance().setId(s).build();
+    }
+
     @Test
     public void whenAddingDistanceToSymmetricMatrixUsingStringAsKey_itShouldReturnCorrectValues() {
         VehicleRoutingTransportCostsMatrix.Builder matrixBuilder = VehicleRoutingTransportCostsMatrix.Builder.newInstance(true);
@@ -87,10 +91,6 @@ public void whenAddingDistanceToAsymmetricMatrix_itShouldReturnCorrectValues() {
         assertEquals(2., matrix.getTransportCost(loc("1"), loc("2"), 0.0, null, null), 0.1);
     }
 
-    private Location loc(String s) {
-        return Location.Builder.newInstance().setId(s).build();
-    }
-
     @Test(expected = IllegalStateException.class)
     public void whenRequestingRelationThatDoesNotExist_itShouldThrowException() {
         VehicleRoutingTransportCostsMatrix.Builder matrixBuilder = VehicleRoutingTransportCostsMatrix.Builder.newInstance(false);
diff --git a/jsprit-examples/input/algorithmConfig.xml b/jsprit-examples/input/algorithmConfig.xml
index d84c9d930..b59c41ad3 100755
--- a/jsprit-examples/input/algorithmConfig.xml
+++ b/jsprit-examples/input/algorithmConfig.xml
@@ -18,8 +18,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <iterations>2000</iterations>
diff --git a/jsprit-examples/input/algorithmConfigWithSchrimpfAcceptance.xml b/jsprit-examples/input/algorithmConfigWithSchrimpfAcceptance.xml
index ba1aad00c..da1287d6f 100755
--- a/jsprit-examples/input/algorithmConfigWithSchrimpfAcceptance.xml
+++ b/jsprit-examples/input/algorithmConfigWithSchrimpfAcceptance.xml
@@ -18,8 +18,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <maxIterations>2000</maxIterations>
diff --git a/jsprit-examples/input/algorithmConfig_considerFixedCosts.xml b/jsprit-examples/input/algorithmConfig_considerFixedCosts.xml
index 2dd7713f4..ba4895f93 100755
--- a/jsprit-examples/input/algorithmConfig_considerFixedCosts.xml
+++ b/jsprit-examples/input/algorithmConfig_considerFixedCosts.xml
@@ -18,8 +18,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <iterations>2000</iterations>
diff --git a/jsprit-examples/input/algorithmConfig_considerFixedCosts_routeLevel.xml b/jsprit-examples/input/algorithmConfig_considerFixedCosts_routeLevel.xml
index 8dafeadff..54ce753a3 100755
--- a/jsprit-examples/input/algorithmConfig_considerFixedCosts_routeLevel.xml
+++ b/jsprit-examples/input/algorithmConfig_considerFixedCosts_routeLevel.xml
@@ -18,8 +18,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <iterations>2000</iterations>
diff --git a/jsprit-examples/input/algorithmConfig_fix.xml b/jsprit-examples/input/algorithmConfig_fix.xml
index f0d300f2a..b9bf45db6 100755
--- a/jsprit-examples/input/algorithmConfig_fix.xml
+++ b/jsprit-examples/input/algorithmConfig_fix.xml
@@ -18,8 +18,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <iterations>2000</iterations>
diff --git a/jsprit-examples/input/algorithmConfig_fix_schrimpf.xml b/jsprit-examples/input/algorithmConfig_fix_schrimpf.xml
index b6698c4a3..9a1d6222d 100755
--- a/jsprit-examples/input/algorithmConfig_fix_schrimpf.xml
+++ b/jsprit-examples/input/algorithmConfig_fix_schrimpf.xml
@@ -18,8 +18,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <iterations>2000</iterations>
diff --git a/jsprit-examples/input/algorithmConfig_greedyWithRegret.xml b/jsprit-examples/input/algorithmConfig_greedyWithRegret.xml
index 082abc6bc..40ca36980 100755
--- a/jsprit-examples/input/algorithmConfig_greedyWithRegret.xml
+++ b/jsprit-examples/input/algorithmConfig_greedyWithRegret.xml
@@ -18,8 +18,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <iterations>2000</iterations>
diff --git a/jsprit-examples/input/algorithmConfig_noVehicleSwitch.xml b/jsprit-examples/input/algorithmConfig_noVehicleSwitch.xml
index e9a144fda..77e2bfb99 100755
--- a/jsprit-examples/input/algorithmConfig_noVehicleSwitch.xml
+++ b/jsprit-examples/input/algorithmConfig_noVehicleSwitch.xml
@@ -18,8 +18,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <iterations>2000</iterations>
diff --git a/jsprit-examples/input/algorithmConfig_open.xml b/jsprit-examples/input/algorithmConfig_open.xml
index dea72ad60..2294ba82f 100755
--- a/jsprit-examples/input/algorithmConfig_open.xml
+++ b/jsprit-examples/input/algorithmConfig_open.xml
@@ -18,8 +18,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <iterations>20000</iterations>
diff --git a/jsprit-examples/input/algorithmConfig_solomon.xml b/jsprit-examples/input/algorithmConfig_solomon.xml
index 6728a38a0..973e44aaf 100755
--- a/jsprit-examples/input/algorithmConfig_solomon.xml
+++ b/jsprit-examples/input/algorithmConfig_solomon.xml
@@ -18,8 +18,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <iterations>2000</iterations>
diff --git a/jsprit-examples/input/cordeau01.xml b/jsprit-examples/input/cordeau01.xml
index 9caa8f80d..b2944ae50 100644
--- a/jsprit-examples/input/cordeau01.xml
+++ b/jsprit-examples/input/cordeau01.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>FINITE</fleetSize>
diff --git a/jsprit-examples/input/cordeau_p01.xml b/jsprit-examples/input/cordeau_p01.xml
index 11b57320f..f26143e74 100644
--- a/jsprit-examples/input/cordeau_p01.xml
+++ b/jsprit-examples/input/cordeau_p01.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>INFINITE</fleetSize>
diff --git a/jsprit-examples/input/cordeau_p08.xml b/jsprit-examples/input/cordeau_p08.xml
index 87b77fcfa..a799f162f 100644
--- a/jsprit-examples/input/cordeau_p08.xml
+++ b/jsprit-examples/input/cordeau_p08.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>INFINITE</fleetSize>
diff --git a/jsprit-examples/input/deliveries_solomon_c101.xml b/jsprit-examples/input/deliveries_solomon_c101.xml
index fdfa85759..a85650a4a 100644
--- a/jsprit-examples/input/deliveries_solomon_c101.xml
+++ b/jsprit-examples/input/deliveries_solomon_c101.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>INFINITE</fleetSize>
diff --git a/jsprit-examples/input/deliveries_solomon_open_c101.xml b/jsprit-examples/input/deliveries_solomon_open_c101.xml
index 5f853cb22..1e8123800 100644
--- a/jsprit-examples/input/deliveries_solomon_open_c101.xml
+++ b/jsprit-examples/input/deliveries_solomon_open_c101.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>INFINITE</fleetSize>
diff --git a/jsprit-examples/input/deliveries_solomon_specifiedVehicleEndLocations_c101.xml b/jsprit-examples/input/deliveries_solomon_specifiedVehicleEndLocations_c101.xml
index 42f5e179c..85140d10e 100644
--- a/jsprit-examples/input/deliveries_solomon_specifiedVehicleEndLocations_c101.xml
+++ b/jsprit-examples/input/deliveries_solomon_specifiedVehicleEndLocations_c101.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>INFINITE</fleetSize>
diff --git a/jsprit-examples/input/fastAlgo.xml b/jsprit-examples/input/fastAlgo.xml
index 725b01188..ef7e8535c 100755
--- a/jsprit-examples/input/fastAlgo.xml
+++ b/jsprit-examples/input/fastAlgo.xml
@@ -18,8 +18,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <iterations>2000</iterations>
diff --git a/jsprit-examples/input/pd_christophides_vrpnc1_vcap50.xml b/jsprit-examples/input/pd_christophides_vrpnc1_vcap50.xml
index d2cb59822..07a451186 100644
--- a/jsprit-examples/input/pd_christophides_vrpnc1_vcap50.xml
+++ b/jsprit-examples/input/pd_christophides_vrpnc1_vcap50.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>INFINITE</fleetSize>
diff --git a/jsprit-examples/input/pickups_and_deliveries_solomon_c101.xml b/jsprit-examples/input/pickups_and_deliveries_solomon_c101.xml
index 7760613ad..7f93a9c90 100644
--- a/jsprit-examples/input/pickups_and_deliveries_solomon_c101.xml
+++ b/jsprit-examples/input/pickups_and_deliveries_solomon_c101.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>INFINITE</fleetSize>
diff --git a/jsprit-examples/input/pickups_and_deliveries_solomon_c101_withoutTWs.xml b/jsprit-examples/input/pickups_and_deliveries_solomon_c101_withoutTWs.xml
index b68edb761..e9fe9023b 100644
--- a/jsprit-examples/input/pickups_and_deliveries_solomon_c101_withoutTWs.xml
+++ b/jsprit-examples/input/pickups_and_deliveries_solomon_c101_withoutTWs.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>INFINITE</fleetSize>
diff --git a/jsprit-examples/input/pickups_and_deliveries_solomon_c101_withoutTWs_and_specifiedVehicleEndLocations.xml b/jsprit-examples/input/pickups_and_deliveries_solomon_c101_withoutTWs_and_specifiedVehicleEndLocations.xml
index 56bdfb28e..c32b011f9 100644
--- a/jsprit-examples/input/pickups_and_deliveries_solomon_c101_withoutTWs_and_specifiedVehicleEndLocations.xml
+++ b/jsprit-examples/input/pickups_and_deliveries_solomon_c101_withoutTWs_and_specifiedVehicleEndLocations.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>INFINITE</fleetSize>
diff --git a/jsprit-examples/input/pickups_and_deliveries_solomon_r101.xml b/jsprit-examples/input/pickups_and_deliveries_solomon_r101.xml
index 19987b7e9..8be9d6068 100644
--- a/jsprit-examples/input/pickups_and_deliveries_solomon_r101.xml
+++ b/jsprit-examples/input/pickups_and_deliveries_solomon_r101.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>INFINITE</fleetSize>
diff --git a/jsprit-examples/input/pickups_and_deliveries_solomon_r101_open.xml b/jsprit-examples/input/pickups_and_deliveries_solomon_r101_open.xml
index c09803114..2e2fd178e 100644
--- a/jsprit-examples/input/pickups_and_deliveries_solomon_r101_open.xml
+++ b/jsprit-examples/input/pickups_and_deliveries_solomon_r101_open.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>INFINITE</fleetSize>
diff --git a/jsprit-examples/input/pickups_and_deliveries_solomon_r101_withoutTWs.xml b/jsprit-examples/input/pickups_and_deliveries_solomon_r101_withoutTWs.xml
index 47cb1b1e4..9c301e57b 100644
--- a/jsprit-examples/input/pickups_and_deliveries_solomon_r101_withoutTWs.xml
+++ b/jsprit-examples/input/pickups_and_deliveries_solomon_r101_withoutTWs.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>INFINITE</fleetSize>
diff --git a/jsprit-examples/input/pickups_and_deliveries_solomon_r101_withoutTWs_open.xml b/jsprit-examples/input/pickups_and_deliveries_solomon_r101_withoutTWs_open.xml
index a5eb6d2cb..b75afcbe7 100644
--- a/jsprit-examples/input/pickups_and_deliveries_solomon_r101_withoutTWs_open.xml
+++ b/jsprit-examples/input/pickups_and_deliveries_solomon_r101_withoutTWs_open.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>INFINITE</fleetSize>
diff --git a/jsprit-examples/input/pickups_solomon_c101.xml b/jsprit-examples/input/pickups_solomon_c101.xml
index 4f47fcae1..c2a7c3dfb 100644
--- a/jsprit-examples/input/pickups_solomon_c101.xml
+++ b/jsprit-examples/input/pickups_solomon_c101.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>INFINITE</fleetSize>
diff --git a/jsprit-examples/input/vrp_cordeau_01.xml b/jsprit-examples/input/vrp_cordeau_01.xml
index 789eb7fd2..36a92a2a2 100644
--- a/jsprit-examples/input/vrp_cordeau_01.xml
+++ b/jsprit-examples/input/vrp_cordeau_01.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
 
     <services>
diff --git a/jsprit-examples/input/vrp_cordeau_08.xml b/jsprit-examples/input/vrp_cordeau_08.xml
index 2382b9f8a..42bd4cacf 100644
--- a/jsprit-examples/input/vrp_cordeau_08.xml
+++ b/jsprit-examples/input/vrp_cordeau_08.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
 
     <services>
diff --git a/jsprit-examples/input/vrpnc1-jsprit.xml b/jsprit-examples/input/vrpnc1-jsprit.xml
index 7070a4349..5293d2504 100644
--- a/jsprit-examples/input/vrpnc1-jsprit.xml
+++ b/jsprit-examples/input/vrpnc1-jsprit.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>INFINITE</fleetSize>
diff --git a/jsprit-examples/pom.xml b/jsprit-examples/pom.xml
index 11a1b637f..4eb9336f3 100644
--- a/jsprit-examples/pom.xml
+++ b/jsprit-examples/pom.xml
@@ -16,7 +16,8 @@
   ~ limitations under the License.
   -->
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>jsprit</artifactId>
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/AdditionalDistanceConstraintExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/AdditionalDistanceConstraintExample.java
index 1dcbfcda2..cdb940a7e 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/AdditionalDistanceConstraintExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/AdditionalDistanceConstraintExample.java
@@ -46,6 +46,51 @@
 
 public class AdditionalDistanceConstraintExample {
 
+    public static void main(String[] args) {
+
+        //route length 618
+        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
+        new VrpXMLReader(vrpBuilder).read("input/pickups_and_deliveries_solomon_r101_withoutTWs.xml");
+        //builds a matrix based on euclidean distances; t_ij = euclidean(i,j) / 2; d_ij = euclidean(i,j);
+        VehicleRoutingTransportCostsMatrix costMatrix = createMatrix(vrpBuilder);
+        vrpBuilder.setRoutingCost(costMatrix);
+        VehicleRoutingProblem vrp = vrpBuilder.build();
+
+
+        StateManager stateManager = new StateManager(vrp); //head of development - upcoming release (v1.4)
+
+        StateId distanceStateId = stateManager.createStateId("distance"); //head of development - upcoming release (v1.4)
+        stateManager.addStateUpdater(new DistanceUpdater(distanceStateId, stateManager, costMatrix));
+
+        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
+        constraintManager.addConstraint(new DistanceConstraint(120., distanceStateId, stateManager, costMatrix), ConstraintManager.Priority.CRITICAL);
+
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager, constraintManager)
+            .buildAlgorithm();
+//        vra.setMaxIterations(250); //v1.3.1
+        vra.setMaxIterations(250); //head of development - upcoming release (v1.4)
+
+        Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
+
+        SolutionPrinter.print(vrp, Solutions.bestOf(solutions), SolutionPrinter.Print.VERBOSE);
+
+        new Plotter(vrp, Solutions.bestOf(solutions)).plot("output/plot", "plot");
+    }
+
+    private static VehicleRoutingTransportCostsMatrix createMatrix(VehicleRoutingProblem.Builder vrpBuilder) {
+        VehicleRoutingTransportCostsMatrix.Builder matrixBuilder = VehicleRoutingTransportCostsMatrix.Builder.newInstance(true);
+        for (String from : vrpBuilder.getLocationMap().keySet()) {
+            for (String to : vrpBuilder.getLocationMap().keySet()) {
+                Coordinate fromCoord = vrpBuilder.getLocationMap().get(from);
+                Coordinate toCoord = vrpBuilder.getLocationMap().get(to);
+                double distance = EuclideanDistanceCalculator.calculateDistance(fromCoord, toCoord);
+                matrixBuilder.addTransportDistance(from, to, distance);
+                matrixBuilder.addTransportTime(from, to, (distance / 2.));
+            }
+        }
+        return matrixBuilder.build();
+    }
+
     static class DistanceUpdater implements StateUpdater, ActivityVisitor {
 
         private final StateManager stateManager;
@@ -129,50 +174,5 @@ public ConstraintsStatus fulfilled(JobInsertionContext context, TourActivity pre
 
     }
 
-    public static void main(String[] args) {
-
-        //route length 618
-        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpBuilder).read("input/pickups_and_deliveries_solomon_r101_withoutTWs.xml");
-        //builds a matrix based on euclidean distances; t_ij = euclidean(i,j) / 2; d_ij = euclidean(i,j);
-        VehicleRoutingTransportCostsMatrix costMatrix = createMatrix(vrpBuilder);
-        vrpBuilder.setRoutingCost(costMatrix);
-        VehicleRoutingProblem vrp = vrpBuilder.build();
-
-
-        StateManager stateManager = new StateManager(vrp); //head of development - upcoming release (v1.4)
-
-        StateId distanceStateId = stateManager.createStateId("distance"); //head of development - upcoming release (v1.4)
-        stateManager.addStateUpdater(new DistanceUpdater(distanceStateId, stateManager, costMatrix));
-
-        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
-        constraintManager.addConstraint(new DistanceConstraint(120., distanceStateId, stateManager, costMatrix), ConstraintManager.Priority.CRITICAL);
-
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager,constraintManager)
-            .buildAlgorithm();
-//        vra.setMaxIterations(250); //v1.3.1
-        vra.setMaxIterations(250); //head of development - upcoming release (v1.4)
-
-        Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
-
-        SolutionPrinter.print(vrp, Solutions.bestOf(solutions), SolutionPrinter.Print.VERBOSE);
-
-        new Plotter(vrp, Solutions.bestOf(solutions)).plot("output/plot", "plot");
-    }
-
-    private static VehicleRoutingTransportCostsMatrix createMatrix(VehicleRoutingProblem.Builder vrpBuilder) {
-        VehicleRoutingTransportCostsMatrix.Builder matrixBuilder = VehicleRoutingTransportCostsMatrix.Builder.newInstance(true);
-        for (String from : vrpBuilder.getLocationMap().keySet()) {
-            for (String to : vrpBuilder.getLocationMap().keySet()) {
-                Coordinate fromCoord = vrpBuilder.getLocationMap().get(from);
-                Coordinate toCoord = vrpBuilder.getLocationMap().get(to);
-                double distance = EuclideanDistanceCalculator.calculateDistance(fromCoord, toCoord);
-                matrixBuilder.addTransportDistance(from, to, distance);
-                matrixBuilder.addTransportTime(from, to, (distance / 2.));
-            }
-        }
-        return matrixBuilder.build();
-    }
-
 
 }
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BicycleMessenger.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BicycleMessenger.java
index 2f61d78aa..5ce1be6aa 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BicycleMessenger.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BicycleMessenger.java
@@ -82,6 +82,178 @@
  */
 public class BicycleMessenger {
 
+    /**
+     * @throws IOException
+     */
+    public static void main(String[] args) throws IOException {
+        Examples.createOutputFolder();
+
+		/*
+        build the problem
+		 */
+        VehicleRoutingProblem.Builder problemBuilder = VehicleRoutingProblem.Builder.newInstance();
+        problemBuilder.setFleetSize(FleetSize.FINITE);
+        readEnvelopes(problemBuilder);
+        readMessengers(problemBuilder);
+        //add constraints to problem
+        VehicleRoutingTransportCosts routingCosts = new CrowFlyCosts(problemBuilder.getLocations()); //which is the default VehicleRoutingTransportCosts in builder above
+        problemBuilder.setRoutingCost(routingCosts);
+        //finally build the problem
+//        problemBuilder.addPenaltyVehicles(20.0,50000);
+        VehicleRoutingProblem bicycleMessengerProblem = problemBuilder.build();
+
+        /*
+        define states and constraints
+         */
+        //map mapping nearest messengers, i.e. for each envelope the direct-delivery-time with the fastest messenger is stored here
+        Map<String, Double> nearestMessengers = getNearestMessengers(routingCosts, problemBuilder.getAddedJobs(), problemBuilder.getAddedVehicles());
+
+        //define stateManager to update the required activity-state: "latest-activity-start-time"
+        StateManager stateManager = new StateManager(bicycleMessengerProblem);
+        //create state
+        StateId latest_act_arrival_time_stateId = stateManager.createStateId("latest-act-arrival-time");
+        //and make sure you update the activity-state "latest-activity-start-time" the way it is defined above
+        stateManager.addStateUpdater(new UpdateLatestActivityStartTimes(latest_act_arrival_time_stateId, stateManager, routingCosts, nearestMessengers));
+        stateManager.updateLoadStates();
+
+        ConstraintManager constraintManager = new ConstraintManager(bicycleMessengerProblem, stateManager);
+        constraintManager.addLoadConstraint();
+        constraintManager.addConstraint(new ThreeTimesLessThanBestDirectRouteConstraint(latest_act_arrival_time_stateId, nearestMessengers, routingCosts, stateManager), ConstraintManager.Priority.CRITICAL);
+        constraintManager.addConstraint(new IgnoreMessengerThatCanNeverMeetTimeRequirements(nearestMessengers, routingCosts));
+
+        VehicleRoutingAlgorithm algorithm = Jsprit.Builder.newInstance(bicycleMessengerProblem)
+            .setStateAndConstraintManager(stateManager, constraintManager).buildAlgorithm();
+
+        algorithm.setMaxIterations(2000);
+
+//		VehicleRoutingAlgorithm algorithm = Jsprit.Builder.newInstance(bicycleMessengerProblem)
+//				.setStateAndConstraintManager(stateManager, constraintManager)
+//				.setProperty(Jsprit.Parameter.THREADS.toString(), "6")
+////				.setProperty(Jsprit.Strategy.RADIAL_BEST.toString(), "0.25")
+////				.setProperty(Jsprit.Strategy.WORST_BEST.toString(), "0.25")
+////				.setProperty(Jsprit.Strategy.CLUSTER_BEST.toString(), "0.25")
+////				.setProperty(Jsprit.Strategy.RANDOM_BEST.toString(), "0.")
+////				.setProperty(Jsprit.Strategy.RANDOM_REGRET.toString(), "1.")
+//				.setProperty(Jsprit.Parameter.INSERTION_NOISE_LEVEL.toString(),"0.01")
+//				.setProperty(Jsprit.Parameter.INSERTION_NOISE_PROB.toString(), "0.2")
+////				.setProperty(Jsprit.Parameter.THRESHOLD_ALPHA.toString(),"0.1")
+//				.buildAlgorithm();
+//		algorithm.setMaxIterations(5000);
+
+//        VariationCoefficientTermination prematureAlgorithmTermination = new VariationCoefficientTermination(200, 0.001);
+//        algorithm.setPrematureAlgorithmTermination(prematureAlgorithmTermination);
+//        algorithm.addListener(prematureAlgorithmTermination);
+        algorithm.addListener(new AlgorithmSearchProgressChartListener("output/progress.png"));
+
+        //search
+        Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
+
+        //this is just to ensure that solution meet the above constraints
+        validateSolution(Solutions.bestOf(solutions), bicycleMessengerProblem, nearestMessengers);
+
+        SolutionPrinter.print(bicycleMessengerProblem, Solutions.bestOf(solutions), SolutionPrinter.Print.VERBOSE);
+
+        //you may want to plot the problem
+        Plotter plotter = new Plotter(bicycleMessengerProblem);
+//		plotter.setBoundingBox(10000, 47500, 20000, 67500);
+        plotter.plotShipments(true);
+        plotter.plot("output/bicycleMessengerProblem.png", "bicycleMessenger");
+
+        //and the problem as well as the solution
+        Plotter plotter1 = new Plotter(bicycleMessengerProblem, Solutions.bestOf(solutions));
+        plotter1.setLabel(Plotter.Label.ID);
+        plotter1.plotShipments(false);
+//		plotter1.setBoundingBox(5000, 45500, 25000, 66500);
+        plotter1.plot("output/bicycleMessengerSolution.png", "bicycleMessenger");
+
+        //and write out your solution in xml
+//		new VrpXMLWriter(bicycleMessengerProblem, solutions).write("output/bicycleMessenger.xml");
+
+
+        new GraphStreamViewer(bicycleMessengerProblem).labelWith(Label.ID).setRenderShipments(true).setRenderDelay(150).display();
+//
+        new GraphStreamViewer(bicycleMessengerProblem, Solutions.bestOf(solutions)).setGraphStreamFrameScalingFactor(1.5).setCameraView(12500, 55000, 0.25).labelWith(Label.ACTIVITY).setRenderShipments(true).setRenderDelay(150).display();
+
+    }
+
+    private static void readEnvelopes(Builder problemBuilder) throws IOException {
+        BufferedReader reader = new BufferedReader(new FileReader(new File("input/bicycle_messenger_demand.txt")));
+        String line;
+        boolean firstLine = true;
+        while ((line = reader.readLine()) != null) {
+            if (firstLine) {
+                firstLine = false;
+                continue;
+            }
+            String[] tokens = line.split("\\s+");
+            //define your envelope which is basically a shipment from A to B
+            Shipment envelope = Shipment.Builder.newInstance(tokens[1]).addSizeDimension(0, 1)
+                .setPickupLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(Double.parseDouble(tokens[2]), Double.parseDouble(tokens[3]))).build())
+                .setDeliveryLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(Double.parseDouble(tokens[4]), Double.parseDouble(tokens[5]))).build()).build();
+            problemBuilder.addJob(envelope);
+        }
+        reader.close();
+    }
+
+    private static void readMessengers(Builder problemBuilder) throws IOException {
+        BufferedReader reader = new BufferedReader(new FileReader(new File("input/bicycle_messenger_supply.txt")));
+        String line;
+        boolean firstLine = true;
+        VehicleType messengerType = VehicleTypeImpl.Builder.newInstance("messengerType").addCapacityDimension(0, 15).setCostPerDistance(1).build();
+        /*
+         * the algo requires some time and space to search for a valid solution. if you ommit a penalty-type, it probably throws an Exception once it cannot insert an envelope anymore
+         * thus, give it space by defining a penalty/shadow vehicle with higher variable and fixed costs to up the pressure to find solutions without penalty type
+         *
+         * it is important to give it the same typeId as the type you want to shadow
+         */
+        while ((line = reader.readLine()) != null) {
+            if (firstLine) {
+                firstLine = false;
+                continue;
+            }
+            String[] tokens = line.split("\\s+");
+            //build your vehicle
+            VehicleImpl vehicle = VehicleImpl.Builder.newInstance(tokens[1])
+                .setStartLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(Double.parseDouble(tokens[2]), Double.parseDouble(tokens[3]))).build())
+                .setReturnToDepot(false).setType(messengerType).build();
+            problemBuilder.addVehicle(vehicle);
+        }
+        reader.close();
+    }
+
+    static Map<String, Double> getNearestMessengers(VehicleRoutingTransportCosts routingCosts, Collection<Job> envelopes, Collection<Vehicle> messengers) {
+        Map<String, Double> nearestMessengers = new HashMap<String, Double>();
+        for (Job envelope : envelopes) {
+            double minDirect = Double.MAX_VALUE;
+            for (Vehicle m : messengers) {
+                double direct = getTimeOfDirectRoute(envelope, m, routingCosts);
+                if (direct < minDirect) {
+                    minDirect = direct;
+                }
+            }
+            nearestMessengers.put(envelope.getId(), minDirect);
+        }
+        return nearestMessengers;
+    }
+
+    //if you wanne run this enable assertion by putting an '-ea' in your vmargument list - Run As --> Run Configurations --> (x)=Arguments --> VM arguments: -ea
+    private static void validateSolution(VehicleRoutingProblemSolution bestOf, VehicleRoutingProblem bicycleMessengerProblem, Map<String, Double> nearestMessengers) {
+        for (VehicleRoute route : bestOf.getRoutes()) {
+            for (TourActivity act : route.getActivities()) {
+                if (act.getArrTime() > 3 * nearestMessengers.get(((JobActivity) act).getJob().getId())) {
+                    SolutionPrinter.print(bicycleMessengerProblem, bestOf, SolutionPrinter.Print.VERBOSE);
+                    throw new IllegalStateException("three times less than ... constraint broken. this must not be. act.getArrTime(): " + act.getArrTime() + " allowed: " + 3 * nearestMessengers.get(((JobActivity) act).getJob().getId()));
+                }
+            }
+        }
+    }
+
+    static double getTimeOfDirectRoute(Job job, Vehicle v, VehicleRoutingTransportCosts routingCosts) {
+        Shipment envelope = (Shipment) job;
+        return routingCosts.getTransportTime(v.getStartLocation(), envelope.getPickupLocation(), 0.0, DriverImpl.noDriver(), v) +
+            routingCosts.getTransportTime(envelope.getPickupLocation(), envelope.getDeliveryLocation(), 0.0, DriverImpl.noDriver(), v);
+    }
+
     /**
      * Hard constraint: delivery of envelope must not take longer than 3*bestDirect (i.e. fastest messenger on direct delivery)
      *
@@ -186,15 +358,11 @@ public boolean fulfilled(JobInsertionContext insertionContext) {
         private final VehicleRoutingTransportCosts routingCosts;
 
         private final Map<String, Double> bestMessengers;
-
+        private final StateId latest_act_arrival_time_stateId;
         private VehicleRoute route;
-
         private TourActivity prevAct;
-
         private double latest_arrTime_at_prevAct;
 
-        private final StateId latest_act_arrival_time_stateId;
-
         public UpdateLatestActivityStartTimes(StateId latest_act_arrival_time, StateManager stateManager, VehicleRoutingTransportCosts routingCosts, Map<String, Double> bestMessengers) {
             super();
             this.stateManager = stateManager;
@@ -228,176 +396,4 @@ public void finish() {
 
     }
 
-    /**
-     * @throws IOException
-     */
-    public static void main(String[] args) throws IOException {
-        Examples.createOutputFolder();
-
-		/*
-        build the problem
-		 */
-        VehicleRoutingProblem.Builder problemBuilder = VehicleRoutingProblem.Builder.newInstance();
-        problemBuilder.setFleetSize(FleetSize.FINITE);
-        readEnvelopes(problemBuilder);
-        readMessengers(problemBuilder);
-        //add constraints to problem
-        VehicleRoutingTransportCosts routingCosts = new CrowFlyCosts(problemBuilder.getLocations()); //which is the default VehicleRoutingTransportCosts in builder above
-        problemBuilder.setRoutingCost(routingCosts);
-        //finally build the problem
-//        problemBuilder.addPenaltyVehicles(20.0,50000);
-        VehicleRoutingProblem bicycleMessengerProblem = problemBuilder.build();
-
-        /*
-        define states and constraints
-         */
-        //map mapping nearest messengers, i.e. for each envelope the direct-delivery-time with the fastest messenger is stored here
-        Map<String, Double> nearestMessengers = getNearestMessengers(routingCosts, problemBuilder.getAddedJobs(), problemBuilder.getAddedVehicles());
-
-        //define stateManager to update the required activity-state: "latest-activity-start-time"
-        StateManager stateManager = new StateManager(bicycleMessengerProblem);
-        //create state
-        StateId latest_act_arrival_time_stateId = stateManager.createStateId("latest-act-arrival-time");
-        //and make sure you update the activity-state "latest-activity-start-time" the way it is defined above
-        stateManager.addStateUpdater(new UpdateLatestActivityStartTimes(latest_act_arrival_time_stateId, stateManager, routingCosts, nearestMessengers));
-        stateManager.updateLoadStates();
-
-        ConstraintManager constraintManager = new ConstraintManager(bicycleMessengerProblem, stateManager);
-        constraintManager.addLoadConstraint();
-        constraintManager.addConstraint(new ThreeTimesLessThanBestDirectRouteConstraint(latest_act_arrival_time_stateId, nearestMessengers, routingCosts, stateManager), ConstraintManager.Priority.CRITICAL);
-        constraintManager.addConstraint(new IgnoreMessengerThatCanNeverMeetTimeRequirements(nearestMessengers, routingCosts));
-
-        VehicleRoutingAlgorithm algorithm = Jsprit.Builder.newInstance(bicycleMessengerProblem)
-            .setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
-
-        algorithm.setMaxIterations(2000);
-
-//		VehicleRoutingAlgorithm algorithm = Jsprit.Builder.newInstance(bicycleMessengerProblem)
-//				.setStateAndConstraintManager(stateManager, constraintManager)
-//				.setProperty(Jsprit.Parameter.THREADS.toString(), "6")
-////				.setProperty(Jsprit.Strategy.RADIAL_BEST.toString(), "0.25")
-////				.setProperty(Jsprit.Strategy.WORST_BEST.toString(), "0.25")
-////				.setProperty(Jsprit.Strategy.CLUSTER_BEST.toString(), "0.25")
-////				.setProperty(Jsprit.Strategy.RANDOM_BEST.toString(), "0.")
-////				.setProperty(Jsprit.Strategy.RANDOM_REGRET.toString(), "1.")
-//				.setProperty(Jsprit.Parameter.INSERTION_NOISE_LEVEL.toString(),"0.01")
-//				.setProperty(Jsprit.Parameter.INSERTION_NOISE_PROB.toString(), "0.2")
-////				.setProperty(Jsprit.Parameter.THRESHOLD_ALPHA.toString(),"0.1")
-//				.buildAlgorithm();
-//		algorithm.setMaxIterations(5000);
-
-//        VariationCoefficientTermination prematureAlgorithmTermination = new VariationCoefficientTermination(200, 0.001);
-//        algorithm.setPrematureAlgorithmTermination(prematureAlgorithmTermination);
-//        algorithm.addListener(prematureAlgorithmTermination);
-        algorithm.addListener(new AlgorithmSearchProgressChartListener("output/progress.png"));
-
-        //search
-        Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
-
-        //this is just to ensure that solution meet the above constraints
-        validateSolution(Solutions.bestOf(solutions), bicycleMessengerProblem, nearestMessengers);
-
-        SolutionPrinter.print(bicycleMessengerProblem, Solutions.bestOf(solutions), SolutionPrinter.Print.VERBOSE);
-
-        //you may want to plot the problem
-        Plotter plotter = new Plotter(bicycleMessengerProblem);
-//		plotter.setBoundingBox(10000, 47500, 20000, 67500);
-        plotter.plotShipments(true);
-        plotter.plot("output/bicycleMessengerProblem.png", "bicycleMessenger");
-
-        //and the problem as well as the solution
-        Plotter plotter1 = new Plotter(bicycleMessengerProblem, Solutions.bestOf(solutions));
-        plotter1.setLabel(Plotter.Label.ID);
-        plotter1.plotShipments(false);
-//		plotter1.setBoundingBox(5000, 45500, 25000, 66500);
-        plotter1.plot("output/bicycleMessengerSolution.png", "bicycleMessenger");
-
-        //and write out your solution in xml
-//		new VrpXMLWriter(bicycleMessengerProblem, solutions).write("output/bicycleMessenger.xml");
-
-
-        new GraphStreamViewer(bicycleMessengerProblem).labelWith(Label.ID).setRenderShipments(true).setRenderDelay(150).display();
-//
-        new GraphStreamViewer(bicycleMessengerProblem, Solutions.bestOf(solutions)).setGraphStreamFrameScalingFactor(1.5).setCameraView(12500, 55000, 0.25).labelWith(Label.ACTIVITY).setRenderShipments(true).setRenderDelay(150).display();
-
-    }
-
-    //if you wanne run this enable assertion by putting an '-ea' in your vmargument list - Run As --> Run Configurations --> (x)=Arguments --> VM arguments: -ea
-    private static void validateSolution(VehicleRoutingProblemSolution bestOf, VehicleRoutingProblem bicycleMessengerProblem, Map<String, Double> nearestMessengers) {
-        for (VehicleRoute route : bestOf.getRoutes()) {
-            for (TourActivity act : route.getActivities()) {
-                if (act.getArrTime() > 3 * nearestMessengers.get(((JobActivity) act).getJob().getId())) {
-                    SolutionPrinter.print(bicycleMessengerProblem, bestOf, SolutionPrinter.Print.VERBOSE);
-                    throw new IllegalStateException("three times less than ... constraint broken. this must not be. act.getArrTime(): " + act.getArrTime() + " allowed: " + 3 * nearestMessengers.get(((JobActivity) act).getJob().getId()));
-                }
-            }
-        }
-    }
-
-    static Map<String, Double> getNearestMessengers(VehicleRoutingTransportCosts routingCosts, Collection<Job> envelopes, Collection<Vehicle> messengers) {
-        Map<String, Double> nearestMessengers = new HashMap<String, Double>();
-        for (Job envelope : envelopes) {
-            double minDirect = Double.MAX_VALUE;
-            for (Vehicle m : messengers) {
-                double direct = getTimeOfDirectRoute(envelope, m, routingCosts);
-                if (direct < minDirect) {
-                    minDirect = direct;
-                }
-            }
-            nearestMessengers.put(envelope.getId(), minDirect);
-        }
-        return nearestMessengers;
-    }
-
-    static double getTimeOfDirectRoute(Job job, Vehicle v, VehicleRoutingTransportCosts routingCosts) {
-        Shipment envelope = (Shipment) job;
-        return routingCosts.getTransportTime(v.getStartLocation(), envelope.getPickupLocation(), 0.0, DriverImpl.noDriver(), v) +
-            routingCosts.getTransportTime(envelope.getPickupLocation(), envelope.getDeliveryLocation(), 0.0, DriverImpl.noDriver(), v);
-    }
-
-    private static void readEnvelopes(Builder problemBuilder) throws IOException {
-        BufferedReader reader = new BufferedReader(new FileReader(new File("input/bicycle_messenger_demand.txt")));
-        String line;
-        boolean firstLine = true;
-        while ((line = reader.readLine()) != null) {
-            if (firstLine) {
-                firstLine = false;
-                continue;
-            }
-            String[] tokens = line.split("\\s+");
-            //define your envelope which is basically a shipment from A to B
-            Shipment envelope = Shipment.Builder.newInstance(tokens[1]).addSizeDimension(0, 1)
-                .setPickupLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(Double.parseDouble(tokens[2]), Double.parseDouble(tokens[3]))).build())
-                .setDeliveryLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(Double.parseDouble(tokens[4]), Double.parseDouble(tokens[5]))).build()).build();
-            problemBuilder.addJob(envelope);
-        }
-        reader.close();
-    }
-
-    private static void readMessengers(Builder problemBuilder) throws IOException {
-        BufferedReader reader = new BufferedReader(new FileReader(new File("input/bicycle_messenger_supply.txt")));
-        String line;
-        boolean firstLine = true;
-        VehicleType messengerType = VehicleTypeImpl.Builder.newInstance("messengerType").addCapacityDimension(0, 15).setCostPerDistance(1).build();
-        /*
-         * the algo requires some time and space to search for a valid solution. if you ommit a penalty-type, it probably throws an Exception once it cannot insert an envelope anymore
-		 * thus, give it space by defining a penalty/shadow vehicle with higher variable and fixed costs to up the pressure to find solutions without penalty type
-		 *
-		 * it is important to give it the same typeId as the type you want to shadow
-		 */
-        while ((line = reader.readLine()) != null) {
-            if (firstLine) {
-                firstLine = false;
-                continue;
-            }
-            String[] tokens = line.split("\\s+");
-            //build your vehicle
-            VehicleImpl vehicle = VehicleImpl.Builder.newInstance(tokens[1])
-                .setStartLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(Double.parseDouble(tokens[2]), Double.parseDouble(tokens[3]))).build())
-                .setReturnToDepot(false).setType(messengerType).build();
-            problemBuilder.addVehicle(vehicle);
-        }
-        reader.close();
-    }
-
 }
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BreakExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BreakExample.java
index f635c9372..68baeeaf7 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BreakExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BreakExample.java
@@ -42,17 +42,17 @@
     public static void main(String[] args) {
 
 
-		/*
+        /*
          * get a vehicle type-builder and build a type with the typeId "vehicleType" and one capacity dimension, i.e. weight, and capacity dimension value of 2
-		 */
+         */
         final int WEIGHT_INDEX = 0;
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType")
             .addCapacityDimension(WEIGHT_INDEX, 2).setCostPerWaitingTime(1.0);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
-		 * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
-		 */
+        /*
+         * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
+         */
         Builder vehicleBuilder = Builder.newInstance("v1");
         vehicleBuilder.setStartLocation(Location.newInstance(10, 10));
         Break myFirstBreak = Break.Builder.newInstance("myFirstBreak")
@@ -64,9 +64,9 @@ public static void main(String[] args) {
 
         VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(Location.newInstance(0, 10)).setType(vehicleType)
             .setBreak((Break) Break.Builder.newInstance("mySecondBreak").setTimeWindow(TimeWindow.newInstance(5, 10)).setServiceTime(10).build()).build();
-		/*
-		 * build services at the required locations, each with a capacity-demand of 1.
-		 */
+        /*
+         * build services at the required locations, each with a capacity-demand of 1.
+         */
         Service service1 = Service.Builder.newInstance("1").addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(5, 7)).build();
         Service service2 = Service.Builder.newInstance("2").addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(5, 13)).build();
 
@@ -80,27 +80,27 @@ public static void main(String[] args) {
         vrpBuilder.setFleetSize(VehicleRoutingProblem.FleetSize.FINITE);
         VehicleRoutingProblem problem = vrpBuilder.build();
 
-		/*
-		 * get the algorithm out-of-the-box.
-		 */
+        /*
+         * get the algorithm out-of-the-box.
+         */
         VehicleRoutingAlgorithm algorithm = Jsprit.Builder.newInstance(problem)
             .setProperty(Jsprit.Strategy.CLUSTER_REGRET, "0.")
             .setProperty(Jsprit.Strategy.CLUSTER_BEST, "0.").buildAlgorithm();
-		/*
-		 * and search a solution
-		 */
+        /*
+         * and search a solution
+         */
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
 
-		/*
-		 * get the best
-		 */
+        /*
+         * get the best
+         */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
         SolutionPrinter.print(problem, bestSolution, SolutionPrinter.Print.VERBOSE);
 
-		/*
-		 * plot
-		 */
+        /*
+         * plot
+         */
         new Plotter(problem, bestSolution).plot("output/plot", "breaks");
 
 
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BuildAlgorithmFromScratch.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BuildAlgorithmFromScratch.java
index 4660597a6..da2517497 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BuildAlgorithmFromScratch.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BuildAlgorithmFromScratch.java
@@ -55,55 +55,6 @@
 public class BuildAlgorithmFromScratch {
 
 
-    public static class MyBestStrategy extends AbstractInsertionStrategy {
-
-        private JobInsertionCostsCalculatorLight insertionCalculator;
-
-
-        public MyBestStrategy(VehicleRoutingProblem vrp, VehicleFleetManager fleetManager, StateManager stateManager, ConstraintManager constraintManager) {
-            super(vrp);
-            insertionCalculator = JobInsertionCostsCalculatorLightFactory.createStandardCalculator(vrp, fleetManager, stateManager, constraintManager);
-        }
-
-        @Override
-        public Collection<Job> insertUnassignedJobs(Collection<VehicleRoute> vehicleRoutes, Collection<Job> unassignedJobs) {
-            List<Job> badJobs = new ArrayList<Job>();
-            List<Job> unassigned = new ArrayList<Job>(unassignedJobs);
-            Collections.shuffle(unassigned, random);
-
-            for (Job j : unassigned) {
-
-                InsertionData bestInsertionData = InsertionData.createEmptyInsertionData();
-                VehicleRoute bestRoute = null;
-                //look for inserting unassigned job into existing route
-                for (VehicleRoute r : vehicleRoutes) {
-                    InsertionData insertionData = insertionCalculator.getInsertionData(j, r, bestInsertionData.getInsertionCost());
-                    if (insertionData instanceof InsertionData.NoInsertionFound) continue;
-                    if (insertionData.getInsertionCost() < bestInsertionData.getInsertionCost()) {
-                        bestInsertionData = insertionData;
-                        bestRoute = r;
-                    }
-                }
-                //try whole new route
-                VehicleRoute empty = VehicleRoute.emptyRoute();
-                InsertionData insertionData = insertionCalculator.getInsertionData(j, empty, bestInsertionData.getInsertionCost());
-                if (!(insertionData instanceof InsertionData.NoInsertionFound)) {
-                    if (insertionData.getInsertionCost() < bestInsertionData.getInsertionCost()) {
-                        vehicleRoutes.add(empty);
-                        insertJob(j, insertionData, empty);
-                    }
-                } else {
-                    if (bestRoute != null) insertJob(j, bestInsertionData, bestRoute);
-                    else badJobs.add(j);
-                }
-            }
-            return badJobs;
-        }
-
-
-    }
-
-
     public static void main(String[] args) {
         Examples.createOutputFolder();
 
@@ -127,7 +78,6 @@ public static void main(String[] args) {
 
     }
 
-
     public static VehicleRoutingAlgorithm createAlgorithm(final VehicleRoutingProblem vrp) {
 
         VehicleFleetManager fleetManager = new FiniteFleetManagerFactory(vrp.getVehicles()).createFleetManager();
@@ -150,15 +100,15 @@ public static VehicleRoutingAlgorithm createAlgorithm(final VehicleRoutingProble
         scoringFunction.setTimeWindowParam(0.0);
         regret.setScoringFunction(scoringFunction);
 
-		/*
+        /*
          * ruin strategies
-		 */
+         */
         RuinStrategy randomRuin = new RandomRuinStrategyFactory(0.5).createStrategy(vrp);
         RuinStrategy radialRuin = new RadialRuinStrategyFactory(0.3, new AvgServiceAndShipmentDistance(vrp.getTransportCosts())).createStrategy(vrp);
 
-		/*
+        /*
          * objective function
-		 */
+         */
         SolutionCostCalculator objectiveFunction = getObjectiveFunction(vrp);
 
         SearchStrategy firstStrategy = new SearchStrategy("firstStrategy", new SelectBest(), new GreedyAcceptance(1), objectiveFunction);
@@ -211,5 +161,53 @@ public double getCosts(VehicleRoutingProblemSolution solution) {
         };
     }
 
+    public static class MyBestStrategy extends AbstractInsertionStrategy {
+
+        private JobInsertionCostsCalculatorLight insertionCalculator;
+
+
+        public MyBestStrategy(VehicleRoutingProblem vrp, VehicleFleetManager fleetManager, StateManager stateManager, ConstraintManager constraintManager) {
+            super(vrp);
+            insertionCalculator = JobInsertionCostsCalculatorLightFactory.createStandardCalculator(vrp, fleetManager, stateManager, constraintManager);
+        }
+
+        @Override
+        public Collection<Job> insertUnassignedJobs(Collection<VehicleRoute> vehicleRoutes, Collection<Job> unassignedJobs) {
+            List<Job> badJobs = new ArrayList<Job>();
+            List<Job> unassigned = new ArrayList<Job>(unassignedJobs);
+            Collections.shuffle(unassigned, random);
+
+            for (Job j : unassigned) {
+
+                InsertionData bestInsertionData = InsertionData.createEmptyInsertionData();
+                VehicleRoute bestRoute = null;
+                //look for inserting unassigned job into existing route
+                for (VehicleRoute r : vehicleRoutes) {
+                    InsertionData insertionData = insertionCalculator.getInsertionData(j, r, bestInsertionData.getInsertionCost());
+                    if (insertionData instanceof InsertionData.NoInsertionFound) continue;
+                    if (insertionData.getInsertionCost() < bestInsertionData.getInsertionCost()) {
+                        bestInsertionData = insertionData;
+                        bestRoute = r;
+                    }
+                }
+                //try whole new route
+                VehicleRoute empty = VehicleRoute.emptyRoute();
+                InsertionData insertionData = insertionCalculator.getInsertionData(j, empty, bestInsertionData.getInsertionCost());
+                if (!(insertionData instanceof InsertionData.NoInsertionFound)) {
+                    if (insertionData.getInsertionCost() < bestInsertionData.getInsertionCost()) {
+                        vehicleRoutes.add(empty);
+                        insertJob(j, insertionData, empty);
+                    }
+                } else {
+                    if (bestRoute != null) insertJob(j, bestInsertionData, bestRoute);
+                    else badJobs.add(j);
+                }
+            }
+            return badJobs;
+        }
+
+
+    }
+
 
 }
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/CircleExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/CircleExample.java
index 455ad9d21..59f254eab 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/CircleExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/CircleExample.java
@@ -41,16 +41,6 @@
  */
 public class CircleExample {
 
-    public static Collection<Coordinate> createCoordinates(double center_x, double center_y, double radius, double step) {
-        Collection<Coordinate> coords = new ArrayList<Coordinate>();
-        for (double theta = 0; theta < 2 * Math.PI; theta += step) {
-            double x = center_x + radius * Math.cos(theta);
-            double y = center_y - radius * Math.sin(theta);
-            coords.add(Coordinate.newInstance(x, y));
-        }
-        return coords;
-    }
-
     public static void main(String[] args) {
         File dir = new File("output");
         // if the directory does not exist, create it
@@ -98,4 +88,14 @@ public static void main(String[] args) {
 
     }
 
+    public static Collection<Coordinate> createCoordinates(double center_x, double center_y, double radius, double step) {
+        Collection<Coordinate> coords = new ArrayList<Coordinate>();
+        for (double theta = 0; theta < 2 * Math.PI; theta += step) {
+            double x = center_x + radius * Math.cos(theta);
+            double y = center_y - radius * Math.sin(theta);
+            coords.add(Coordinate.newInstance(x, y));
+        }
+        return coords;
+    }
+
 }
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/ConfigureAlgorithmInCodeInsteadOfPerXml.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/ConfigureAlgorithmInCodeInsteadOfPerXml.java
index e844c3c05..9517df79b 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/ConfigureAlgorithmInCodeInsteadOfPerXml.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/ConfigureAlgorithmInCodeInsteadOfPerXml.java
@@ -43,26 +43,26 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * get a vehicle type-builder and build a type with the typeId "vehicleType" and a capacity of 2
-		 */
+         */
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType").addCapacityDimension(0, 2);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
+        /*
          * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
-		 */
+         */
         Builder vehicleBuilder = VehicleImpl.Builder.newInstance("vehicle");
         vehicleBuilder.setStartLocation(Location.newInstance(10, 10));
         vehicleBuilder.setType(vehicleType);
         VehicleImpl vehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * build services at the required locations, each with a capacity-demand of 1.
-		 */
+         */
         Service service1 = Service.Builder.newInstance("1").addSizeDimension(0, 1).setLocation(Location.newInstance(5, 7)).build();
         Service service2 = Service.Builder.newInstance("2").addSizeDimension(0, 1).setLocation(Location.newInstance(5, 13)).build();
 
@@ -76,29 +76,29 @@ public static void main(String[] args) {
 
         VehicleRoutingProblem problem = vrpBuilder.build();
 
-		/*
+        /*
          * get the algorithm out-of-the-box.
-		 */
+         */
         AlgorithmConfig algorithmConfig = getAlgorithmConfig();
         VehicleRoutingAlgorithm algorithm = VehicleRoutingAlgorithms.createAlgorithm(problem, algorithmConfig);
 
-		/*
+        /*
          * and search a solution
-		 */
+         */
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
 
-		/*
+        /*
          * get the best
-		 */
+         */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
         new VrpXMLWriter(problem, solutions).write("output/problem-with-solution.xml");
 
         SolutionPrinter.print(bestSolution);
 
-		/*
+        /*
          * plot
-		 */
+         */
         new Plotter(problem, bestSolution).plot("output/solution.png", "solution");
     }
 
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/CostMatrixExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/CostMatrixExample.java
index 157c685da..bd4b335b8 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/CostMatrixExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/CostMatrixExample.java
@@ -47,7 +47,7 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0, 2).setCostPerDistance(1).setCostPerTime(2).build();
@@ -59,24 +59,24 @@ public static void main(String[] args) {
         Service s3 = Service.Builder.newInstance("3").addSizeDimension(0, 1).setLocation(Location.newInstance("3")).build();
 
 
-		/*
+        /*
          * Assume the following symmetric distance-matrix
-		 * from,to,distance
-		 * 0,1,10.0
-		 * 0,2,20.0
-		 * 0,3,5.0
-		 * 1,2,4.0
-		 * 1,3,1.0
-		 * 2,3,2.0
-		 *
-		 * and this time-matrix
-		 * 0,1,5.0
-		 * 0,2,10.0
-		 * 0,3,2.5
-		 * 1,2,2.0
-		 * 1,3,0.5
-		 * 2,3,1.0
-		 */
+         * from,to,distance
+         * 0,1,10.0
+         * 0,2,20.0
+         * 0,3,5.0
+         * 1,2,4.0
+         * 1,3,1.0
+         * 2,3,2.0
+         *
+         * and this time-matrix
+         * 0,1,5.0
+         * 0,2,10.0
+         * 0,3,2.5
+         * 1,2,2.0
+         * 1,3,0.5
+         * 2,3,1.0
+         */
         //define a matrix-builder building a symmetric matrix
         VehicleRoutingTransportCostsMatrix.Builder costMatrixBuilder = VehicleRoutingTransportCostsMatrix.Builder.newInstance(true);
         costMatrixBuilder.addTransportDistance("0", "1", 10.0);
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/EnRoutePickupAndDeliveryWithMultipleDepotsAndOpenRoutesExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/EnRoutePickupAndDeliveryWithMultipleDepotsAndOpenRoutesExample.java
index 902fb13b7..85728d014 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/EnRoutePickupAndDeliveryWithMultipleDepotsAndOpenRoutesExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/EnRoutePickupAndDeliveryWithMultipleDepotsAndOpenRoutesExample.java
@@ -46,21 +46,21 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * get a vehicle type-builder and build a type with the typeId "vehicleType" and a capacity of 2
-		 */
+         */
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType").addCapacityDimension(0, 2);
         vehicleTypeBuilder.setCostPerDistance(1.0);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
+        /*
          * define two vehicles and their start-locations
-		 *
-		 * the first two do need to return to depot
-		 */
+         *
+         * the first two do need to return to depot
+         */
         Builder vehicleBuilder1 = VehicleImpl.Builder.newInstance("vehicles@[10,10]");
         vehicleBuilder1.setStartLocation(loc(Coordinate.newInstance(10, 10))).setReturnToDepot(false);
         vehicleBuilder1.setType(vehicleType);
@@ -81,10 +81,10 @@ public static void main(String[] args) {
         vehicleBuilder4.setType(vehicleType);
         VehicleImpl vehicle4 = vehicleBuilder4.build();
 
-		/*
+        /*
          * build shipments at the required locations, each with a capacity-demand of 1.
 
-		 */
+         */
 
         Shipment shipment1 = Shipment.Builder.newInstance("1").addSizeDimension(0, 1).setPickupLocation(loc(Coordinate.newInstance(5, 7))).setDeliveryLocation(loc(Coordinate.newInstance(6, 9))).build();
         Shipment shipment2 = Shipment.Builder.newInstance("2").addSizeDimension(0, 1).setPickupLocation(loc(Coordinate.newInstance(5, 13))).setDeliveryLocation(loc(Coordinate.newInstance(6, 11))).build();
@@ -121,41 +121,41 @@ public static void main(String[] args) {
         vrpBuilder.setFleetSize(FleetSize.FINITE);
         VehicleRoutingProblem problem = vrpBuilder.build();
 
-		/*
+        /*
          * get the algorithm out-of-the-box.
-		 */
+         */
         VehicleRoutingAlgorithm algorithm = Jsprit.createAlgorithm(problem);
 //		algorithm.setMaxIterations(30000);
         /*
          * and search a solution
-		 */
+         */
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
 
-		/*
+        /*
          * get the best
-		 */
+         */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
-		/*
-		 * write out problem and solution to xml-file
-		 */
+        /*
+         * write out problem and solution to xml-file
+         */
         new VrpXMLWriter(problem, solutions).write("output/shipment-problem-with-solution.xml");
 
-		/*
-		 * print nRoutes and totalCosts of bestSolution
-		 */
+        /*
+         * print nRoutes and totalCosts of bestSolution
+         */
         SolutionPrinter.print(bestSolution);
 
-		/*
-		 * plot problem without solution
-		 */
+        /*
+         * plot problem without solution
+         */
         Plotter problemPlotter = new Plotter(problem);
         problemPlotter.plotShipments(true);
         problemPlotter.plot("output/enRoutePickupAndDeliveryWithMultipleLocationsExample_problem.png", "en-route pickup and delivery");
 
-		/*
-		 * plot problem with solution
-		 */
+        /*
+         * plot problem with solution
+         */
         Plotter solutionPlotter = new Plotter(problem, Arrays.asList(Solutions.bestOf(solutions).getRoutes().iterator().next()));
         solutionPlotter.plotShipments(true);
         solutionPlotter.plot("output/enRoutePickupAndDeliveryWithMultipleLocationsExample_solution.png", "en-route pickup and delivery");
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/JobAndActivityDependenciesExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/JobAndActivityDependenciesExample.java
index 8fe754613..99cc61509 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/JobAndActivityDependenciesExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/JobAndActivityDependenciesExample.java
@@ -51,6 +51,77 @@
  */
 public class JobAndActivityDependenciesExample {
 
+    public static void main(String[] args) {
+
+        VehicleImpl driver1 = VehicleImpl.Builder.newInstance("driver1")
+            .addSkill("driver1")
+            .setStartLocation(Location.newInstance(0, 0)).setReturnToDepot(false).build();
+
+        VehicleImpl driver3 = VehicleImpl.Builder.newInstance("driver3")
+            .addSkill("driver3")
+            .setStartLocation(Location.newInstance(-3, 5)).setReturnToDepot(true).build();
+
+        Service s1 = Service.Builder.newInstance("s1")
+            .addRequiredSkill("driver1")
+            .setName("install new device")
+            .setLocation(Location.newInstance(2, 2)).build();
+        Service s2 = Service.Builder.newInstance("s2")
+            .addRequiredSkill("driver3")
+            .setName("deliver key")
+            .setLocation(Location.newInstance(2, 4)).build();
+
+        Service s3 = Service.Builder.newInstance("s3")
+            .addRequiredSkill("driver1")
+            .setName("repair heater")
+            .setLocation(Location.newInstance(-2, 2)).build();
+
+        Service s4 = Service.Builder.newInstance("s4")
+            .addRequiredSkill("driver3")
+            .setName("get key")
+            .setLocation(Location.newInstance(-2.3, 4)).build();
+
+        Service s5 = Service.Builder.newInstance("s5")
+            .addRequiredSkill("driver1")
+            .setName("cleaning")
+            .setLocation(Location.newInstance(1, 5)).build();
+
+        Service s6 = Service.Builder.newInstance("s6")
+            .addRequiredSkill("driver3")
+            .setName("use key")
+            .setLocation(Location.newInstance(-2, 3)).build();
+
+        Service s7 = Service.Builder.newInstance("s7")
+            .addRequiredSkill("driver3")
+            .setName("maintenance")
+            .setLocation(Location.newInstance(-1.7, 3.5)).build();
+
+        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance().setFleetSize(VehicleRoutingProblem.FleetSize.FINITE)
+            .addJob(s1).addJob(s2).addJob(s3).addJob(s4).addJob(s5).addJob(s6).addJob(s7)
+            .addVehicle(driver1).addVehicle(driver3);
+
+        VehicleRoutingProblem vrp = vrpBuilder.build();
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId keyPicked = stateManager.createStateId("key-picked");
+        StateId keyUsed = stateManager.createStateId("key-used");
+        StateId keyDelivered = stateManager.createStateId("key-delivered");
+        stateManager.addStateUpdater(new KeyStatusUpdater(stateManager, keyPicked, keyUsed, keyDelivered));
+
+        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
+        constraintManager.addConstraint(new GetUseAndDeliverKeySimpleHardActivityConstraint(stateManager, keyPicked, keyUsed, keyDelivered), ConstraintManager.Priority.CRITICAL);
+        constraintManager.addConstraint(new GetUseAndDeliverHardRouteContraint(stateManager, keyPicked, keyUsed, keyDelivered));
+
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager, constraintManager).buildAlgorithm();
+        vra.setMaxIterations(100);
+
+        Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
+
+        SolutionPrinter.print(vrp, Solutions.bestOf(solutions), SolutionPrinter.Print.VERBOSE);
+
+        new GraphStreamViewer(vrp, Solutions.bestOf(solutions)).labelWith(GraphStreamViewer.Label.JOB_NAME).display();
+
+    }
+
     static class KeyStatusUpdater implements StateUpdater, ActivityVisitor {
 
         StateManager stateManager;
@@ -205,75 +276,4 @@ private boolean isDeliverKey(TourActivity act) {
 
     }
 
-    public static void main(String[] args) {
-
-        VehicleImpl driver1 = VehicleImpl.Builder.newInstance("driver1")
-            .addSkill("driver1")
-            .setStartLocation(Location.newInstance(0, 0)).setReturnToDepot(false).build();
-
-        VehicleImpl driver3 = VehicleImpl.Builder.newInstance("driver3")
-            .addSkill("driver3")
-            .setStartLocation(Location.newInstance(-3, 5)).setReturnToDepot(true).build();
-
-        Service s1 = Service.Builder.newInstance("s1")
-            .addRequiredSkill("driver1")
-            .setName("install new device")
-            .setLocation(Location.newInstance(2, 2)).build();
-        Service s2 = Service.Builder.newInstance("s2")
-            .addRequiredSkill("driver3")
-            .setName("deliver key")
-            .setLocation(Location.newInstance(2, 4)).build();
-
-        Service s3 = Service.Builder.newInstance("s3")
-            .addRequiredSkill("driver1")
-            .setName("repair heater")
-            .setLocation(Location.newInstance(-2, 2)).build();
-
-        Service s4 = Service.Builder.newInstance("s4")
-            .addRequiredSkill("driver3")
-            .setName("get key")
-            .setLocation(Location.newInstance(-2.3, 4)).build();
-
-        Service s5 = Service.Builder.newInstance("s5")
-            .addRequiredSkill("driver1")
-            .setName("cleaning")
-            .setLocation(Location.newInstance(1, 5)).build();
-
-        Service s6 = Service.Builder.newInstance("s6")
-            .addRequiredSkill("driver3")
-            .setName("use key")
-            .setLocation(Location.newInstance(-2, 3)).build();
-
-        Service s7 = Service.Builder.newInstance("s7")
-            .addRequiredSkill("driver3")
-            .setName("maintenance")
-            .setLocation(Location.newInstance(-1.7, 3.5)).build();
-
-        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance().setFleetSize(VehicleRoutingProblem.FleetSize.FINITE)
-            .addJob(s1).addJob(s2).addJob(s3).addJob(s4).addJob(s5).addJob(s6).addJob(s7)
-            .addVehicle(driver1).addVehicle(driver3);
-
-        VehicleRoutingProblem vrp = vrpBuilder.build();
-
-        StateManager stateManager = new StateManager(vrp);
-        StateId keyPicked = stateManager.createStateId("key-picked");
-        StateId keyUsed = stateManager.createStateId("key-used");
-        StateId keyDelivered = stateManager.createStateId("key-delivered");
-        stateManager.addStateUpdater(new KeyStatusUpdater(stateManager, keyPicked, keyUsed, keyDelivered));
-
-        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
-        constraintManager.addConstraint(new GetUseAndDeliverKeySimpleHardActivityConstraint(stateManager, keyPicked, keyUsed, keyDelivered), ConstraintManager.Priority.CRITICAL);
-        constraintManager.addConstraint(new GetUseAndDeliverHardRouteContraint(stateManager, keyPicked, keyUsed, keyDelivered));
-
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
-        vra.setMaxIterations(100);
-
-        Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
-
-        SolutionPrinter.print(vrp, Solutions.bestOf(solutions), SolutionPrinter.Print.VERBOSE);
-
-        new GraphStreamViewer(vrp, Solutions.bestOf(solutions)).labelWith(GraphStreamViewer.Label.JOB_NAME).display();
-
-    }
-
 }
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleDepotExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleDepotExample.java
index a1b4829e7..7fc7fb9d8 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleDepotExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleDepotExample.java
@@ -45,25 +45,25 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         /*
          * Read cordeau-instance p01, BUT only its services without any vehicles
-		 */
+         */
         new VrpXMLReader(vrpBuilder).read("input/vrp_cordeau_01.xml");
 
-		/*
+        /*
          * add vehicles with its depots
-		 * 4 depots:
-		 * (20,20)
-		 * (30,40)
-		 * (50,30)
-		 * (60,50)
-		 *
-		 * each with 4 vehicles each with a capacity of 80
-		 */
+         * 4 depots:
+         * (20,20)
+         * (30,40)
+         * (50,30)
+         * (60,50)
+         *
+         * each with 4 vehicles each with a capacity of 80
+         */
         int nuOfVehicles = 4;
         int capacity = 80;
         Coordinate firstDepotCoord = Coordinate.newInstance(20, 20);
@@ -81,24 +81,24 @@ public static void main(String[] args) {
             depotCounter++;
         }
 
-		/*
+        /*
          * define problem with finite fleet
-		 */
+         */
         vrpBuilder.setFleetSize(FleetSize.FINITE);
 
-		/*
+        /*
          * build the problem
-		 */
+         */
         VehicleRoutingProblem vrp = vrpBuilder.build();
 
-		/*
+        /*
          * plot to see how the problem looks like
-		 */
+         */
 //		SolutionPlotter.plotVrpAsPNG(vrp, "output/problem01.png", "p01");
 
-		/*
+        /*
          * solve the problem
-		 */
+         */
         VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.THREADS, "5").buildAlgorithm();
         vra.getAlgorithmListeners().addListener(new StopWatch(), Priority.HIGH);
         vra.getAlgorithmListeners().addListener(new AlgorithmSearchProgressChartListener("output/progress.png"));
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleDepotExample2.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleDepotExample2.java
index 1145f31fc..5268759b3 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleDepotExample2.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleDepotExample2.java
@@ -47,23 +47,23 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         /*
          * Read cordeau-instance p01, BUT only its services without any vehicles
-		 */
+         */
         new CordeauReader(vrpBuilder).read("input/p08");
 
-		/*
+        /*
          * add vehicles with its depots
-		 * 2 depots:
-		 * (-33,33)
-		 * (33,-33)
-		 *
-		 * each with 14 vehicles each with a capacity of 500 and a maximum duration of 310
-		 */
+         * 2 depots:
+         * (-33,33)
+         * (33,-33)
+         *
+         * each with 14 vehicles each with a capacity of 500 and a maximum duration of 310
+         */
         int nuOfVehicles = 13;
         int capacity = 500;
         double maxDuration = 310;
@@ -87,24 +87,24 @@ public static void main(String[] args) {
         }
 
 
-		/*
+        /*
          * define problem with finite fleet
-		 */
+         */
         vrpBuilder.setFleetSize(FleetSize.FINITE);
 
-		/*
+        /*
          * build the problem
-		 */
+         */
         VehicleRoutingProblem vrp = vrpBuilder.build();
 
-		/*
+        /*
          * plot to see how the problem looks like
-		 */
+         */
 //		SolutionPlotter.plotVrpAsPNG(vrp, "output/problem08.png", "p08");
 
-		/*
+        /*
          * solve the problem
-		 */
+         */
         VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp)
             .setProperty(Jsprit.Parameter.FAST_REGRET, "true")
             .setProperty(Jsprit.Parameter.THREADS, "5").buildAlgorithm();
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleDepotWithInitialRoutesExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleDepotWithInitialRoutesExample.java
index 61b5e6394..a47aec4e8 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleDepotWithInitialRoutesExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleDepotWithInitialRoutesExample.java
@@ -42,41 +42,41 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         /*
          * Read cordeau-instance p01
-		 */
+         */
         new VrpXMLReader(vrpBuilder).read("input/cordeau01.xml");
 
-		/*
+        /*
          * Add initial route with 1_4_vehicle and services 44, 26
-		 */
+         */
         VehicleRoute initialRoute = VehicleRoute.Builder.newInstance(getVehicle("1_4_vehicle", vrpBuilder)).addService(getService("44", vrpBuilder))
             .addService(getService("26", vrpBuilder)).build();
         vrpBuilder.addInitialVehicleRoute(initialRoute);
 
-		/*
+        /*
          * build the problem
-		 */
+         */
         VehicleRoutingProblem vrp = vrpBuilder.build();
         /*
          * since job (service) 26 and 44 are already planned in initial route and thus static AND sequence is fixed they
-		 * should not be in jobMap anymore (only variable jobs are in jobMap)
-		 */
+         * should not be in jobMap anymore (only variable jobs are in jobMap)
+         */
         assert !vrp.getJobs().containsKey("26") : "strange. service 26 should not be part of the problem";
         assert !vrp.getJobs().containsKey("44") : "strange. service 44 should not be part of the problem";
 
-		/*
+        /*
          * plot to see how the problem looks like
-		 */
+         */
         new Plotter(vrp).setLabel(Label.ID).plot("output/cordeau01_problem_withInitialRoute.png", "c");
 
-		/*
-		 * solve the problem
-		 */
+        /*
+         * solve the problem
+         */
 //		VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp)
 //				.setProperty(Jsprit.Parameter.ITERATIONS,"10000").buildAlgorithm();
 
@@ -90,6 +90,13 @@ public static void main(String[] args) {
 
     }
 
+    private static Vehicle getVehicle(String vehicleId, Builder vrpBuilder) {
+        for (Vehicle v : vrpBuilder.getAddedVehicles()) {
+            if (v.getId().equals(vehicleId)) return v;
+        }
+        return null;
+    }
+
     private static Service getService(String serviceId, Builder vrpBuilder) {
         for (Job j : vrpBuilder.getAddedJobs()) {
             if (j.getId().equals(serviceId)) {
@@ -99,11 +106,4 @@ private static Service getService(String serviceId, Builder vrpBuilder) {
         return null;
     }
 
-    private static Vehicle getVehicle(String vehicleId, Builder vrpBuilder) {
-        for (Vehicle v : vrpBuilder.getAddedVehicles()) {
-            if (v.getId().equals(vehicleId)) return v;
-        }
-        return null;
-    }
-
 }
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleProductsWithLoadConstraintExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleProductsWithLoadConstraintExample.java
index 2fc579beb..c99c1c513 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleProductsWithLoadConstraintExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleProductsWithLoadConstraintExample.java
@@ -62,6 +62,53 @@
 
     static final int APPLES_DIMENSION_INDEX = 1;
 
+    public static void main(String[] args) {
+
+
+        VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(BANANAS_DIMENSION_INDEX, 10)
+            .addCapacityDimension(APPLES_DIMENSION_INDEX, 20).build();
+        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("vehicle").setStartLocation(loc(Coordinate.newInstance(0, 0)))
+            .setType(type).build();
+
+        Shipment bananas = Shipment.Builder.newInstance("bananas_1").addSizeDimension(BANANAS_DIMENSION_INDEX, 1)
+            .setPickupLocation(loc(Coordinate.newInstance(1, 8))).setDeliveryLocation(loc(Coordinate.newInstance(10, 8))).build();
+
+        Shipment bananas_2 = Shipment.Builder.newInstance("bananas_2").addSizeDimension(BANANAS_DIMENSION_INDEX, 1)
+            .setPickupLocation(loc(Coordinate.newInstance(2, 8))).setDeliveryLocation(loc(Coordinate.newInstance(11, 8))).build();
+
+        Shipment bananas_3 = Shipment.Builder.newInstance("bananas_3").addSizeDimension(BANANAS_DIMENSION_INDEX, 1)
+            .setPickupLocation(loc(Coordinate.newInstance(3, 8))).setDeliveryLocation(loc(Coordinate.newInstance(12, 8))).build();
+
+        Shipment apples = Shipment.Builder.newInstance("apples_1").addSizeDimension(APPLES_DIMENSION_INDEX, 1)
+            .setPickupLocation(loc(Coordinate.newInstance(1, 6))).setDeliveryLocation(loc(Coordinate.newInstance(10, 12))).build();
+
+        Shipment apples_2 = Shipment.Builder.newInstance("apples_2").addSizeDimension(APPLES_DIMENSION_INDEX, 1)
+            .setPickupLocation(loc(Coordinate.newInstance(1, 5))).setDeliveryLocation(loc(Coordinate.newInstance(10, 11))).build();
+
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().setFleetSize(VehicleRoutingProblem.FleetSize.INFINITE)
+            .addVehicle(vehicle)
+            .addJob(bananas).addJob(apples).addJob(bananas_2).addJob(bananas_3).addJob(apples_2).build();
+
+        StateManager stateManager = new StateManager(vrp);
+        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
+        constraintManager.addConstraint(new NoBananasANDApplesConstraint(stateManager), ConstraintManager.Priority.CRITICAL);
+//        constraintManager.addConstraint(new BananasFirst(),ConstraintManager.Priority.CRITICAL);
+
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager, constraintManager)
+            .buildAlgorithm();
+
+        Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
+
+        SolutionPrinter.print(vrp, Solutions.bestOf(solutions), SolutionPrinter.Print.VERBOSE);
+
+        new GraphStreamViewer(vrp, Solutions.bestOf(solutions)).labelWith(GraphStreamViewer.Label.ID).setRenderShipments(true).display();
+
+    }
+
+    private static Location loc(Coordinate coordinate) {
+        return Location.Builder.newInstance().setCoordinate(coordinate).build();
+    }
+
     //    static class BananasFirst implements HardActivityStateLevelConstraint { //v1.3.1
     static class BananasFirst implements HardActivityConstraint {
 
@@ -73,13 +120,13 @@ public ConstraintsStatus fulfilled(JobInsertionContext jobInsertionContext, Tour
             return ConstraintsStatus.FULFILLED;
         }
 
-        private boolean isApplePickup(TourActivity act) {
-            return act.getSize().get(APPLES_DIMENSION_INDEX) > 0;
-        }
-
         private boolean isBananaPickup(TourActivity act) {
             return act.getSize().get(BANANAS_DIMENSION_INDEX) > 0;
         }
+
+        private boolean isApplePickup(TourActivity act) {
+            return act.getSize().get(APPLES_DIMENSION_INDEX) > 0;
+        }
     }
 
     //static class NoBananasANDApplesConstraint implements HardActivityStateLevelConstraint { //v1.3.1
@@ -156,52 +203,4 @@ private Capacity getLoadAtPreviousAct(TourActivity prevAct) {
             else return Capacity.Builder.newInstance().build();
         }
     }
-
-
-    public static void main(String[] args) {
-
-
-        VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(BANANAS_DIMENSION_INDEX, 10)
-            .addCapacityDimension(APPLES_DIMENSION_INDEX, 20).build();
-        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("vehicle").setStartLocation(loc(Coordinate.newInstance(0, 0)))
-            .setType(type).build();
-
-        Shipment bananas = Shipment.Builder.newInstance("bananas_1").addSizeDimension(BANANAS_DIMENSION_INDEX, 1)
-            .setPickupLocation(loc(Coordinate.newInstance(1, 8))).setDeliveryLocation(loc(Coordinate.newInstance(10, 8))).build();
-
-        Shipment bananas_2 = Shipment.Builder.newInstance("bananas_2").addSizeDimension(BANANAS_DIMENSION_INDEX, 1)
-            .setPickupLocation(loc(Coordinate.newInstance(2, 8))).setDeliveryLocation(loc(Coordinate.newInstance(11, 8))).build();
-
-        Shipment bananas_3 = Shipment.Builder.newInstance("bananas_3").addSizeDimension(BANANAS_DIMENSION_INDEX, 1)
-            .setPickupLocation(loc(Coordinate.newInstance(3, 8))).setDeliveryLocation(loc(Coordinate.newInstance(12, 8))).build();
-
-        Shipment apples = Shipment.Builder.newInstance("apples_1").addSizeDimension(APPLES_DIMENSION_INDEX, 1)
-            .setPickupLocation(loc(Coordinate.newInstance(1, 6))).setDeliveryLocation(loc(Coordinate.newInstance(10, 12))).build();
-
-        Shipment apples_2 = Shipment.Builder.newInstance("apples_2").addSizeDimension(APPLES_DIMENSION_INDEX, 1)
-            .setPickupLocation(loc(Coordinate.newInstance(1, 5))).setDeliveryLocation(loc(Coordinate.newInstance(10, 11))).build();
-
-        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().setFleetSize(VehicleRoutingProblem.FleetSize.INFINITE)
-            .addVehicle(vehicle)
-            .addJob(bananas).addJob(apples).addJob(bananas_2).addJob(bananas_3).addJob(apples_2).build();
-
-        StateManager stateManager = new StateManager(vrp);
-        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
-        constraintManager.addConstraint(new NoBananasANDApplesConstraint(stateManager), ConstraintManager.Priority.CRITICAL);
-//        constraintManager.addConstraint(new BananasFirst(),ConstraintManager.Priority.CRITICAL);
-
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager, constraintManager)
-            .buildAlgorithm();
-
-        Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
-
-        SolutionPrinter.print(vrp, Solutions.bestOf(solutions), SolutionPrinter.Print.VERBOSE);
-
-        new GraphStreamViewer(vrp, Solutions.bestOf(solutions)).labelWith(GraphStreamViewer.Label.ID).setRenderShipments(true).display();
-
-    }
-
-    private static Location loc(Coordinate coordinate) {
-        return Location.Builder.newInstance().setCoordinate(coordinate).build();
-    }
 }
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleTimeWindowExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleTimeWindowExample.java
index 0cd3e154c..6817f489a 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleTimeWindowExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleTimeWindowExample.java
@@ -39,28 +39,28 @@
 
     public static void main(String[] args) {
 
-		/*
+        /*
          * get a vehicle type-builder and build a type with the typeId "vehicleType" and one capacity dimension, i.e. weight, and capacity dimension value of 2
-		 */
+         */
         final int WEIGHT_INDEX = 0;
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType")
             .addCapacityDimension(WEIGHT_INDEX, 10).setCostPerWaitingTime(1.);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
+        /*
          * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
-		 */
+         */
         Builder vehicleBuilder = Builder.newInstance("vehicle");
         vehicleBuilder.setStartLocation(Location.newInstance(0, 0));
         vehicleBuilder.setType(vehicleType);
         VehicleImpl vehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * build services at the required locations, each with a capacity-demand of 1.
-		 */
+         */
         Service service1 = Service.Builder.newInstance("1")
-            .addTimeWindow(50,100)
-            .addTimeWindow(20,35)
+            .addTimeWindow(50, 100)
+            .addTimeWindow(20, 35)
             .addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(10, 0)).build();
 
         Service service2 = Service.Builder.newInstance("2")
@@ -80,9 +80,9 @@ public static void main(String[] args) {
             .addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(40, 0)).build();
 
         Service service5 = Service.Builder.newInstance("5")
-            .addTimeWindow(5,10)
+            .addTimeWindow(5, 10)
             .addTimeWindow(20, 40)
-            .addTimeWindow(60,100)
+            .addTimeWindow(60, 100)
             .addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(20, 0)).build();
 
 
@@ -97,28 +97,28 @@ public static void main(String[] args) {
         vrpBuilder.setRoutingCost(new ManhattanCosts());
         VehicleRoutingProblem problem = vrpBuilder.build();
 
-		/*
+        /*
          * get the algorithm out-of-the-box.
-		 */
+         */
         VehicleRoutingAlgorithm algorithm = Jsprit.createAlgorithm(problem);
 
-		/*
+        /*
          * and search a solution
-		 */
+         */
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
 
-		/*
+        /*
          * get the best
-		 */
+         */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
 //        new VrpXMLWriter(problem, solutions).write("output/problem-with-solution.xml");
 
         SolutionPrinter.print(problem, bestSolution, SolutionPrinter.Print.VERBOSE);
 
-		/*
+        /*
          * plot
-		 */
+         */
 //        new Plotter(problem,bestSolution).setLabel(Plotter.Label.ID).plot("output/plot", "mtw");
 
 //        new GraphStreamViewer(problem, bestSolution).labelWith(Label.ID).setRenderDelay(200).display();
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleTimeWindowExample2.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleTimeWindowExample2.java
index 7ea4d8d95..4f4147b0f 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleTimeWindowExample2.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleTimeWindowExample2.java
@@ -42,18 +42,17 @@
 
     public static void main(String[] args) {
 
-		/*
+        /*
          * get a vehicle type-builder and build a type with the typeId "vehicleType" and one capacity dimension, i.e. weight, and capacity dimension value of 2
-		 */
+         */
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType")
             .addCapacityDimension(0, 60)
-            .setCostPerWaitingTime(0.8)
-            ;
+            .setCostPerWaitingTime(0.8);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
+        /*
          * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
-		 */
+         */
         Builder vehicleBuilder = Builder.newInstance("vehicle");
         vehicleBuilder.setStartLocation(Location.newInstance(0, 0));
         vehicleBuilder.setType(vehicleType);
@@ -73,9 +72,9 @@ public static void main(String[] args) {
 //        vehicleBuilder3.setEarliestStart(380).setLatestArrival(600);
 //        VehicleImpl vehicle3 = vehicleBuilder3.build();
 
-		/*
+        /*
          * build services at the required locations, each with a capacity-demand of 1.
-		 */
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.addVehicle(vehicle);
 //            .addVehicle(vehicle2).addVehicle(vehicle3);
@@ -83,7 +82,7 @@ public static void main(String[] args) {
 
 
         Random random = RandomNumberGeneration.newInstance();
-        for(int i=0;i<40;i++){
+        for (int i = 0; i < 40; i++) {
             Service service = Service.Builder.newInstance("" + (i + 1))
                 .addTimeWindow(random.nextInt(50), 200)
                 .addTimeWindow(220 + random.nextInt(50), 350)
@@ -94,8 +93,8 @@ public static void main(String[] args) {
             vrpBuilder.addJob(service);
         }
 
-        for(int i=0;i<12;i++){
-            Service service = Service.Builder.newInstance(""+(i+51))
+        for (int i = 0; i < 12; i++) {
+            Service service = Service.Builder.newInstance("" + (i + 51))
 //                .addTimeWindow(0, 80)
 ////                .addTimeWindow(120, 200)
 //                .addTimeWindow(250,500)
@@ -115,24 +114,24 @@ public static void main(String[] args) {
 
         VehicleRoutingAlgorithm algorithm = Jsprit.Builder.newInstance(problem).buildAlgorithm();
 
-		/*
+        /*
          * and search a solution
-		 */
+         */
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
 
-		/*
+        /*
          * get the best
-		 */
+         */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
 //        new VrpXMLWriter(problem, solutions).write("output/problem-with-solution.xml");
 
         SolutionPrinter.print(problem, bestSolution, SolutionPrinter.Print.VERBOSE);
 
-		/*
+        /*
          * plot
-		 */
-        new Plotter(problem,bestSolution).setLabel(Plotter.Label.ID).plot("output/plot", "mtw");
+         */
+        new Plotter(problem, bestSolution).setLabel(Plotter.Label.ID).plot("output/plot", "mtw");
 
         SolutionAnalyser a = new SolutionAnalyser(problem, bestSolution, problem.getTransportCosts());
 
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/PickupAndDeliveryExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/PickupAndDeliveryExample.java
index 9b4dfedb5..fa8ec92a5 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/PickupAndDeliveryExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/PickupAndDeliveryExample.java
@@ -37,60 +37,60 @@
 
     public static void main(String[] args) {
 
-		/*
+        /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * Build the problem.
-		 *
-		 * But define a problem-builder first.
-		 */
+         *
+         * But define a problem-builder first.
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
 
-		/*
+        /*
          * A solomonReader reads solomon-instance files, and stores the required information in the builder.
-		 */
+         */
         new VrpXMLReader(vrpBuilder).read("input/pickups_and_deliveries_solomon_r101_withoutTWs.xml");
 
-		/*
+        /*
          * Finally, the problem can be built. By default, transportCosts are crowFlyDistances (as usually used for vrp-instances).
-		 */
+         */
 
         final VehicleRoutingProblem vrp = vrpBuilder.build();
 
         new Plotter(vrp).plot("output/pd_solomon_r101.png", "pd_r101");
 
 
-		/*
+        /*
          * Define the required vehicle-routing algorithms to solve the above problem.
-		 *
-		 * The algorithm can be defined and configured in an xml-file.
-		 */
+         *
+         * The algorithm can be defined and configured in an xml-file.
+         */
 //		VehicleRoutingAlgorithm vra = new SchrimpfFactory().createAlgorithm(vrp);
         VehicleRoutingAlgorithm vra = Jsprit.createAlgorithm(vrp);
         vra.getAlgorithmListeners().addListener(new AlgorithmSearchProgressChartListener("output/sol_progress.png"));
         /*
          * Solve the problem.
-		 *
-		 *
-		 */
+         *
+         *
+         */
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
 
-		/*
+        /*
          * Retrieve best solution.
-		 */
+         */
         VehicleRoutingProblemSolution solution = new SelectBest().selectSolution(solutions);
 
-		/*
-		 * print solution
-		 */
+        /*
+         * print solution
+         */
         SolutionPrinter.print(solution);
 
-		/*
-		 * Plot solution.
-		 */
+        /*
+         * Plot solution.
+         */
 //		SolutionPlotter.plotSolutionAsPNG(vrp, solution, "output/pd_solomon_r101_solution.png","pd_r101");
         Plotter plotter = new Plotter(vrp, solution);
         plotter.setLabel(Label.SIZE);
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/PickupAndDeliveryExample2.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/PickupAndDeliveryExample2.java
index 0921bcdce..931014042 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/PickupAndDeliveryExample2.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/PickupAndDeliveryExample2.java
@@ -37,60 +37,60 @@
 
     public static void main(String[] args) {
 
-		/*
+        /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * Build the problem.
-		 *
-		 * But define a problem-builder first.
-		 */
+         *
+         * But define a problem-builder first.
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
 
-		/*
+        /*
          * A solomonReader reads solomon-instance files, and stores the required information in the builder.
-		 */
+         */
         new VrpXMLReader(vrpBuilder).read("input/pd_christophides_vrpnc1_vcap50.xml");
 
-		/*
+        /*
          * Finally, the problem can be built. By default, transportCosts are crowFlyDistances (as usually used for vrp-instances).
-		 */
+         */
 
         VehicleRoutingProblem vrp = vrpBuilder.build();
 
         new Plotter(vrp).plot("output/pd_christophides_vrpnc1.png", "pd_vrpnc1");
 
 
-		/*
+        /*
          * Define the required vehicle-routing algorithms to solve the above problem.
-		 *
-		 * The algorithm can be defined and configured in an xml-file.
-		 */
+         *
+         * The algorithm can be defined and configured in an xml-file.
+         */
 
         VehicleRoutingAlgorithm vra = Jsprit.createAlgorithm(vrp);
         vra.getAlgorithmListeners().addListener(new AlgorithmSearchProgressChartListener("output/sol_progress.png"));
         /*
          * Solve the problem.
-		 *
-		 *
-		 */
+         *
+         *
+         */
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
 
-		/*
+        /*
          * Retrieve best solution.
-		 */
+         */
         VehicleRoutingProblemSolution solution = new SelectBest().selectSolution(solutions);
 
-		/*
+        /*
          * print solution
-		 */
+         */
         SolutionPrinter.print(solution);
 
-		/*
-		 * Plot solution.
-		 */
+        /*
+         * Plot solution.
+         */
 //		SolutionPlotter.plotSolutionAsPNG(vrp, solution, "output/pd_solomon_r101_solution.png","pd_r101");
         Plotter plotter = new Plotter(vrp, solution);
         plotter.setLabel(Label.SIZE);
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/PickupAndDeliveryOpenExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/PickupAndDeliveryOpenExample.java
index 1c622a6b1..ead5229c1 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/PickupAndDeliveryOpenExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/PickupAndDeliveryOpenExample.java
@@ -36,59 +36,59 @@
 
     public static void main(String[] args) {
 
-		/*
+        /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * Build the problem.
-		 *
-		 * But define a problem-builder first.
-		 */
+         *
+         * But define a problem-builder first.
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
 
-		/*
+        /*
          * A solomonReader reads solomon-instance files, and stores the required information in the builder.
-		 */
+         */
         new VrpXMLReader(vrpBuilder).read("input/pickups_and_deliveries_solomon_r101_withoutTWs_open.xml");
 
-		/*
+        /*
          * Finally, the problem can be built. By default, transportCosts are crowFlyDistances (as usually used for vrp-instances).
-		 */
+         */
 
         VehicleRoutingProblem vrp = vrpBuilder.build();
 
 //		SolutionPlotter.plotVrpAsPNG(vrp, "output/pd_solomon_r101_o.png", "pd_r101");
 
-		/*
+        /*
          * Define the required vehicle-routing algorithms to solve the above problem.
-		 *
-		 * The algorithm can be defined and configured in an xml-file.
-		 */
+         *
+         * The algorithm can be defined and configured in an xml-file.
+         */
 
         VehicleRoutingAlgorithm vra = Jsprit.createAlgorithm(vrp);
         vra.getAlgorithmListeners().addListener(new AlgorithmSearchProgressChartListener("output/sol_progress.png"));
         /*
          * Solve the problem.
-		 *
-		 *
-		 */
+         *
+         *
+         */
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
 
-		/*
+        /*
          * Retrieve best solution.
-		 */
+         */
         VehicleRoutingProblemSolution solution = new SelectBest().selectSolution(solutions);
 
-		/*
-		 * print solution
-		 */
+        /*
+         * print solution
+         */
         SolutionPrinter.print(solution);
 
-		/*
-		 * Plot solution.
-		 */
+        /*
+         * Plot solution.
+         */
 //		SolutionPlotter.plotSolutionAsPNG(vrp, solution, "output/pd_solomon_r101_solution.png","pd_r101");
         Plotter plotter = new Plotter(vrp, solution);
         plotter.setLabel(Label.SIZE);
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/RefuseCollectionExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/RefuseCollectionExample.java
index 8b5d60ee5..edfbdef2f 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/RefuseCollectionExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/RefuseCollectionExample.java
@@ -52,12 +52,12 @@
     public static void main(String[] args) throws IOException {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * create vehicle-type and vehicle
-		 */
+         */
         VehicleTypeImpl.Builder typeBuilder = VehicleTypeImpl.Builder.newInstance("vehicle-type").addCapacityDimension(0, 23);
         typeBuilder.setCostPerDistance(1.0);
         VehicleTypeImpl bigType = typeBuilder.build();
@@ -67,21 +67,21 @@ public static void main(String[] args) throws IOException {
         vehicleBuilder.setType(bigType);
         VehicleImpl bigVehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * start building the problem
-		 */
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.setFleetSize(FleetSize.INFINITE);
         vrpBuilder.addVehicle(bigVehicle);
 
-		/*
+        /*
          * read demand quantities
-		 */
+         */
         readDemandQuantities(vrpBuilder);
 
-		/*
+        /*
          * create cost-matrix
-		 */
+         */
         VehicleRoutingTransportCostsMatrix.Builder matrixBuilder = VehicleRoutingTransportCostsMatrix.Builder.newInstance(true);
         readDistances(matrixBuilder);
 
@@ -112,11 +112,11 @@ private static void readDemandQuantities(VehicleRoutingProblem.Builder vrpBuilde
             String[] lineTokens = line.split(",");
             /*
              * build service
-			 */
+             */
             Service service = Service.Builder.newInstance(lineTokens[0]).addSizeDimension(0, Integer.parseInt(lineTokens[1])).setLocation(Location.newInstance(lineTokens[0])).build();
             /*
-			 * and add it to problem
-			 */
+             * and add it to problem
+             */
             vrpBuilder.addJob(service);
         }
         reader.close();
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/RefuseCollectionWithFastMatrixExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/RefuseCollectionWithFastMatrixExample.java
index 5db863726..bc183b6f2 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/RefuseCollectionWithFastMatrixExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/RefuseCollectionWithFastMatrixExample.java
@@ -51,12 +51,12 @@
     public static void main(String[] args) throws IOException {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * create vehicle-type and vehicle
-		 */
+         */
         VehicleTypeImpl.Builder typeBuilder = VehicleTypeImpl.Builder.newInstance("vehicle-type").addCapacityDimension(0, 23);
         typeBuilder.setCostPerDistance(1.0);
         VehicleTypeImpl bigType = typeBuilder.build();
@@ -66,21 +66,21 @@ public static void main(String[] args) throws IOException {
         vehicleBuilder.setType(bigType);
         VehicleImpl bigVehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * start building the problem
-		 */
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.setFleetSize(FleetSize.INFINITE);
         vrpBuilder.addVehicle(bigVehicle);
 
-		/*
+        /*
          * read demand quantities
-		 */
+         */
         readDemandQuantities(vrpBuilder);
 
-		/*
+        /*
          * create cost-matrix
-		 */
+         */
         FastVehicleRoutingTransportCostsMatrix.Builder matrixBuilder = FastVehicleRoutingTransportCostsMatrix.Builder.newInstance(11, true);
         readDistances(matrixBuilder);
 
@@ -111,14 +111,14 @@ private static void readDemandQuantities(VehicleRoutingProblem.Builder vrpBuilde
             String[] lineTokens = line.split(",");
             /*
              * build service
-			 */
+             */
             Service service = Service.Builder.newInstance(lineTokens[0])
                 .addSizeDimension(0, Integer.parseInt(lineTokens[1]))
                 .setLocation(Location.Builder.newInstance().setIndex(Integer.parseInt(lineTokens[0])).build())
                 .build();
             /*
-			 * and add it to problem
-			 */
+             * and add it to problem
+             */
             vrpBuilder.addJob(service);
         }
         reader.close();
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/ServicePickupsWithMultipleDepotsExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/ServicePickupsWithMultipleDepotsExample.java
index 67dbde120..82fb74223 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/ServicePickupsWithMultipleDepotsExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/ServicePickupsWithMultipleDepotsExample.java
@@ -44,19 +44,19 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * get a vehicle type-builder and build a type with the typeId "vehicleType" and a capacity of 2
-		 */
+         */
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType").addCapacityDimension(0, 8);
         vehicleTypeBuilder.setCostPerDistance(1.0);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
+        /*
          * define two depots, i.e. two vehicle locations ([10,10],[50,50]) and equip them with an infinite number of vehicles of type 'vehicleType'
-		 */
+         */
         Builder vehicleBuilder1 = VehicleImpl.Builder.newInstance("vehicles@[10,10]");
         vehicleBuilder1.setStartLocation(Location.newInstance(10, 10));
         vehicleBuilder1.setType(vehicleType);
@@ -68,14 +68,14 @@ public static void main(String[] args) {
         VehicleImpl vehicle2 = vehicleBuilder2.build();
 
 
-		/*
+        /*
          * build shipments at the required locations, each with a capacity-demand of 1.
-		 * 4 shipments
-		 * 1: (5,7)->(6,9)
-		 * 2: (5,13)->(6,11)
-		 * 3: (15,7)->(14,9)
-		 * 4: (15,13)->(14,11)
-		 */
+         * 4 shipments
+         * 1: (5,7)->(6,9)
+         * 2: (5,13)->(6,11)
+         * 3: (15,7)->(14,9)
+         * 4: (15,13)->(14,11)
+         */
 
         Service shipment1 = Service.Builder.newInstance("1").addSizeDimension(0, 1).setLocation(Location.newInstance(5, 7)).build();
         Service shipment2 = Service.Builder.newInstance("2").addSizeDimension(0, 1).setLocation(Location.newInstance(5, 13)).build();
@@ -98,42 +98,42 @@ public static void main(String[] args) {
 //		vrpBuilder.setFleetSize(FleetSize.FINITE);
         VehicleRoutingProblem problem = vrpBuilder.build();
 
-		/*
+        /*
          * get the algorithm out-of-the-box.
-		 */
+         */
         VehicleRoutingAlgorithm algorithm = Jsprit.createAlgorithm(problem);
         algorithm.setMaxIterations(10);
 
-		/*
+        /*
          * and search a solution
-		 */
+         */
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
 
-		/*
+        /*
          * get the best
-		 */
+         */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
-		/*
+        /*
          * write out problem and solution to xml-file
-		 */
+         */
         new VrpXMLWriter(problem, solutions).write("output/shipment-problem-with-solution.xml");
 
-		/*
-		 * print nRoutes and totalCosts of bestSolution
-		 */
+        /*
+         * print nRoutes and totalCosts of bestSolution
+         */
         SolutionPrinter.print(bestSolution);
 
-		/*
-		 * plot problem without solution
-		 */
+        /*
+         * plot problem without solution
+         */
         Plotter problemPlotter = new Plotter(problem);
         problemPlotter.plotShipments(true);
         problemPlotter.plot("output/enRoutePickupAndDeliveryWithMultipleLocationsExample_problem.png", "en-route pickup and delivery");
 
-		/*
-		 * plot problem with solution
-		 */
+        /*
+         * plot problem with solution
+         */
         Plotter solutionPlotter = new Plotter(problem, Arrays.asList(Solutions.bestOf(solutions).getRoutes().iterator().next()));
         solutionPlotter.plotShipments(true);
         solutionPlotter.plot("output/enRoutePickupAndDeliveryWithMultipleLocationsExample_solution.png", "en-route pickup and delivery");
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleDepotBoundedPickupAndDeliveryExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleDepotBoundedPickupAndDeliveryExample.java
index 35f805ef8..3912c80ec 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleDepotBoundedPickupAndDeliveryExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleDepotBoundedPickupAndDeliveryExample.java
@@ -43,26 +43,26 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * get a vehicle type-builder and build a type with the typeId "vehicleType" and a capacity of 2
-		 */
+         */
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType").addCapacityDimension(0, 2);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
+        /*
          * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
-		 */
+         */
         Builder vehicleBuilder = VehicleImpl.Builder.newInstance("vehicle");
         vehicleBuilder.setStartLocation(Location.newInstance(10, 10));
         vehicleBuilder.setType(vehicleType);
         VehicleImpl vehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * build pickups and deliveries at the required locations, each with a capacity-demand of 1.
-		 */
+         */
 
         Pickup pickup1 = Pickup.Builder.newInstance("1").addSizeDimension(0, 1).setLocation(Location.newInstance(5, 7)).build();
         Delivery delivery1 = Delivery.Builder.newInstance("2").addSizeDimension(0, 1).setLocation(Location.newInstance(5, 13)).build();
@@ -78,28 +78,28 @@ public static void main(String[] args) {
 
         VehicleRoutingProblem problem = vrpBuilder.build();
 
-		/*
+        /*
          * get the algorithm out-of-the-box.
-		 */
+         */
         VehicleRoutingAlgorithm algorithm = new SchrimpfFactory().createAlgorithm(problem);
 
-		/*
+        /*
          * and search a solution
-		 */
+         */
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
 
-		/*
+        /*
          * get the best
-		 */
+         */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
         new VrpXMLWriter(problem, solutions).write("output/problem-with-solution.xml");
 
         SolutionPrinter.print(bestSolution);
 
-		/*
+        /*
          * plot
-		 */
+         */
         Plotter plotter = new Plotter(problem, bestSolution);
         plotter.setLabel(Label.SIZE);
         plotter.plot("output/solution.png", "solution");
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleEnRoutePickupAndDeliveryExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleEnRoutePickupAndDeliveryExample.java
index c23098abc..2857a0ae7 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleEnRoutePickupAndDeliveryExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleEnRoutePickupAndDeliveryExample.java
@@ -44,31 +44,31 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * get a vehicle type-builder and build a type with the typeId "vehicleType" and a capacity of 2
-		 */
+         */
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType").addCapacityDimension(0, 2);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
+        /*
          * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
-		 */
+         */
         Builder vehicleBuilder = VehicleImpl.Builder.newInstance("vehicle");
         vehicleBuilder.setStartLocation(loc(Coordinate.newInstance(10, 10)));
         vehicleBuilder.setType(vehicleType);
         VehicleImpl vehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * build shipments at the required locations, each with a capacity-demand of 1.
-		 * 4 shipments
-		 * 1: (5,7)->(6,9)
-		 * 2: (5,13)->(6,11)
-		 * 3: (15,7)->(14,9)
-		 * 4: (15,13)->(14,11)
-		 */
+         * 4 shipments
+         * 1: (5,7)->(6,9)
+         * 2: (5,13)->(6,11)
+         * 3: (15,7)->(14,9)
+         * 4: (15,13)->(14,11)
+         */
 
         Shipment shipment1 = Shipment.Builder.newInstance("1").addSizeDimension(0, 1).setPickupLocation(loc(Coordinate.newInstance(5, 7))).setDeliveryLocation(loc(Coordinate.newInstance(6, 9))).build();
         Shipment shipment2 = Shipment.Builder.newInstance("2").addSizeDimension(0, 1).setPickupLocation(loc(Coordinate.newInstance(5, 13))).setDeliveryLocation(loc(Coordinate.newInstance(6, 11))).build();
@@ -83,41 +83,41 @@ public static void main(String[] args) {
 
         VehicleRoutingProblem problem = vrpBuilder.build();
 
-		/*
+        /*
          * get the algorithm out-of-the-box.
-		 */
+         */
         VehicleRoutingAlgorithm algorithm = new SchrimpfFactory().createAlgorithm(problem);
 
-		/*
+        /*
          * and search a solution
-		 */
+         */
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
 
-		/*
+        /*
          * get the best
-		 */
+         */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
-		/*
+        /*
          * write out problem and solution to xml-file
-		 */
+         */
         new VrpXMLWriter(problem, solutions).write("output/shipment-problem-with-solution.xml");
 
-		/*
-		 * print nRoutes and totalCosts of bestSolution
-		 */
+        /*
+         * print nRoutes and totalCosts of bestSolution
+         */
         SolutionPrinter.print(bestSolution);
 
-		/*
-		 * plot problem without solution
-		 */
+        /*
+         * plot problem without solution
+         */
         Plotter problemPlotter = new Plotter(problem);
         problemPlotter.plotShipments(true);
         problemPlotter.plot("output/simpleEnRoutePickupAndDeliveryExample_problem.png", "en-route pickup and delivery");
 
-		/*
-		 * plot problem with solution
-		 */
+        /*
+         * plot problem with solution
+         */
         Plotter solutionPlotter = new Plotter(problem, Arrays.asList(Solutions.bestOf(solutions).getRoutes().iterator().next()));
         solutionPlotter.plotShipments(true);
         solutionPlotter.plot("output/simpleEnRoutePickupAndDeliveryExample_solution.png", "en-route pickup and delivery");
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleEnRoutePickupAndDeliveryOpenRoutesExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleEnRoutePickupAndDeliveryOpenRoutesExample.java
index b48b7177a..b87e886a3 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleEnRoutePickupAndDeliveryOpenRoutesExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleEnRoutePickupAndDeliveryOpenRoutesExample.java
@@ -43,32 +43,32 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * get a vehicle type-builder and build a type with the typeId "vehicleType" and a capacity of 2
-		 */
+         */
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType").addCapacityDimension(0, 2);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
+        /*
          * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
-		 */
+         */
         Builder vehicleBuilder = VehicleImpl.Builder.newInstance("vehicle");
         vehicleBuilder.setStartLocation(loc(Coordinate.newInstance(10, 10)));
         vehicleBuilder.setType(vehicleType);
         vehicleBuilder.setReturnToDepot(false);
         VehicleImpl vehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * build shipments at the required locations, each with a capacity-demand of 1.
-		 * 4 shipments
-		 * 1: (5,7)->(6,9)
-		 * 2: (5,13)->(6,11)
-		 * 3: (15,7)->(14,9)
-		 * 4: (15,13)->(14,11)
-		 */
+         * 4 shipments
+         * 1: (5,7)->(6,9)
+         * 2: (5,13)->(6,11)
+         * 3: (15,7)->(14,9)
+         * 4: (15,13)->(14,11)
+         */
 
         Shipment shipment1 = Shipment.Builder.newInstance("1").addSizeDimension(0, 1).setPickupLocation(loc(Coordinate.newInstance(5, 7))).setDeliveryLocation(loc(Coordinate.newInstance(6, 9))).build();
         Shipment shipment2 = Shipment.Builder.newInstance("2").addSizeDimension(0, 1).setPickupLocation(loc(Coordinate.newInstance(5, 13))).setDeliveryLocation(loc(Coordinate.newInstance(6, 11))).build();
@@ -83,41 +83,41 @@ public static void main(String[] args) {
 
         VehicleRoutingProblem problem = vrpBuilder.build();
 
-		/*
+        /*
          * get the algorithm out-of-the-box.
-		 */
+         */
         VehicleRoutingAlgorithm algorithm = new SchrimpfFactory().createAlgorithm(problem);
 
-		/*
+        /*
          * and search a solution
-		 */
+         */
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
 
-		/*
+        /*
          * get the best
-		 */
+         */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
-		/*
+        /*
          * write out problem and solution to xml-file
-		 */
+         */
         new VrpXMLWriter(problem, solutions).write("output/shipment-problem-with-solution.xml");
 
-		/*
-		 * print nRoutes and totalCosts of bestSolution
-		 */
+        /*
+         * print nRoutes and totalCosts of bestSolution
+         */
         SolutionPrinter.print(problem, bestSolution, SolutionPrinter.Print.VERBOSE);
 
-		/*
-		 * plot problem without solution
-		 */
+        /*
+         * plot problem without solution
+         */
         Plotter problemPlotter = new Plotter(problem);
         problemPlotter.plotShipments(true);
         problemPlotter.plot("output/simpleEnRoutePickupAndDeliveryExample_problem.png", "en-route pickup and delivery");
 
-		/*
-		 * plot problem with solution
-		 */
+        /*
+         * plot problem with solution
+         */
         Plotter solutionPlotter = new Plotter(problem, Solutions.bestOf(solutions).getRoutes());
         solutionPlotter.plotShipments(true);
         solutionPlotter.plot("output/simpleEnRoutePickupAndDeliveryExample_solution.png", "en-route pickup and delivery");
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleEnRoutePickupAndDeliveryWithDepotBoundedDeliveriesExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleEnRoutePickupAndDeliveryWithDepotBoundedDeliveriesExample.java
index dafa1f709..f4b7f8c99 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleEnRoutePickupAndDeliveryWithDepotBoundedDeliveriesExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleEnRoutePickupAndDeliveryWithDepotBoundedDeliveriesExample.java
@@ -46,31 +46,31 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * get a vehicle type-builder and build a type with the typeId "vehicleType" and a capacity of 2
-		 */
+         */
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType").addCapacityDimension(0, 2);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
+        /*
          * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
-		 */
+         */
         Builder vehicleBuilder = VehicleImpl.Builder.newInstance("vehicle");
         vehicleBuilder.setStartLocation(loc(Coordinate.newInstance(10, 10)));
         vehicleBuilder.setType(vehicleType);
         VehicleImpl vehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * build shipments at the required locations, each with a capacity-demand of 1.
-		 * 4 shipments
-		 * 1: (5,7)->(6,9)
-		 * 2: (5,13)->(6,11)
-		 * 3: (15,7)->(14,9)
-		 * 4: (15,13)->(14,11)
-		 */
+         * 4 shipments
+         * 1: (5,7)->(6,9)
+         * 2: (5,13)->(6,11)
+         * 3: (15,7)->(14,9)
+         * 4: (15,13)->(14,11)
+         */
 
         Shipment shipment1 = Shipment.Builder.newInstance("1").addSizeDimension(0, 1).setPickupLocation(loc(Coordinate.newInstance(5, 7))).setDeliveryLocation(loc(Coordinate.newInstance(6, 9))).build();
         Shipment shipment2 = Shipment.Builder.newInstance("2").addSizeDimension(0, 1).setPickupLocation(loc(Coordinate.newInstance(5, 13))).setDeliveryLocation(loc(Coordinate.newInstance(6, 11))).build();
@@ -80,11 +80,11 @@ public static void main(String[] args) {
 //
         /*
          * build deliveries, (implicitly picked up in the depot)
-		 * 1: (4,8)
-		 * 2: (4,12)
-		 * 3: (16,8)
-		 * 4: (16,12)
-		 */
+         * 1: (4,8)
+         * 2: (4,12)
+         * 3: (16,8)
+         * 4: (16,12)
+         */
         Delivery delivery1 = Delivery.Builder.newInstance("5").addSizeDimension(0, 1).setLocation(loc(Coordinate.newInstance(4, 8))).build();
         Delivery delivery2 = Delivery.Builder.newInstance("6").addSizeDimension(0, 1).setLocation(loc(Coordinate.newInstance(4, 12))).build();
         Delivery delivery3 = Delivery.Builder.newInstance("7").addSizeDimension(0, 1).setLocation(loc(Coordinate.newInstance(16, 8))).build();
@@ -97,33 +97,33 @@ public static void main(String[] args) {
 
         VehicleRoutingProblem problem = vrpBuilder.build();
 
-		/*
+        /*
          * build the algorithm
-		 */
+         */
 
         StateManager stateManager = new StateManager(problem);
         ConstraintManager constraintManager = new ConstraintManager(problem, stateManager);
         constraintManager.addConstraint(new ServiceDeliveriesFirstConstraint(), ConstraintManager.Priority.CRITICAL);
 
-        VehicleRoutingAlgorithm algorithm = Jsprit.Builder.newInstance(problem).setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
+        VehicleRoutingAlgorithm algorithm = Jsprit.Builder.newInstance(problem).setStateAndConstraintManager(stateManager, constraintManager).buildAlgorithm();
 
-		/*
+        /*
          * and search a solution
-		 */
+         */
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
 
-		/*
-		 * get the best
-		 */
+        /*
+         * get the best
+         */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
         new VrpXMLWriter(problem, solutions).write("output/mixed-shipments-services-problem-with-solution.xml");
 
         SolutionPrinter.print(bestSolution);
 
-		/*
-		 * plot
-		 */
+        /*
+         * plot
+         */
         Plotter problemPlotter = new Plotter(problem);
         problemPlotter.plotShipments(true);
         problemPlotter.plot("output/simpleMixedEnRoutePickupAndDeliveryExample_problem.png", "en-route pd and depot bounded deliveries");
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExample.java
index 8cf9f200f..3b658bbc2 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExample.java
@@ -22,7 +22,6 @@
 import com.graphhopper.jsprit.analysis.toolbox.Plotter;
 import com.graphhopper.jsprit.core.algorithm.VehicleRoutingAlgorithm;
 import com.graphhopper.jsprit.core.algorithm.box.Jsprit;
-import com.graphhopper.jsprit.core.algorithm.box.SchrimpfFactory;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.job.Service;
@@ -45,7 +44,7 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         File dir = new File("output");
         // if the directory does not exist, create it
         if (!dir.exists()) {
@@ -54,24 +53,24 @@ public static void main(String[] args) {
             if (result) System.out.println("./output created");
         }
 
-		/*
+        /*
          * get a vehicle type-builder and build a type with the typeId "vehicleType" and one capacity dimension, i.e. weight, and capacity dimension value of 2
-		 */
+         */
         final int WEIGHT_INDEX = 0;
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType").addCapacityDimension(WEIGHT_INDEX, 2);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
+        /*
          * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
-		 */
+         */
         Builder vehicleBuilder = VehicleImpl.Builder.newInstance("vehicle");
         vehicleBuilder.setStartLocation(Location.newInstance(10, 10));
         vehicleBuilder.setType(vehicleType);
         VehicleImpl vehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * build services at the required locations, each with a capacity-demand of 1.
-		 */
+         */
         Service service1 = Service.Builder.newInstance("1").addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(5, 7)).build();
         Service service2 = Service.Builder.newInstance("2").addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(5, 13)).build();
 
@@ -85,29 +84,29 @@ public static void main(String[] args) {
 
         VehicleRoutingProblem problem = vrpBuilder.build();
 
-		/*
+        /*
          * get the algorithm out-of-the-box.
-		 */
+         */
         VehicleRoutingAlgorithm algorithm = Jsprit.createAlgorithm(problem);
 
-		/*
+        /*
          * and search a solution
-		 */
+         */
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
 
-		/*
+        /*
          * get the best
-		 */
+         */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
         new VrpXMLWriter(problem, solutions).write("output/problem-with-solution.xml");
 
         SolutionPrinter.print(problem, bestSolution, SolutionPrinter.Print.VERBOSE);
 
-		/*
+        /*
          * plot
-		 */
-        new Plotter(problem,bestSolution).plot("output/plot.png","simple example");
+         */
+        new Plotter(problem, bestSolution).plot("output/plot.png", "simple example");
 
         /*
         render problem and solution with GraphStream
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExampleOpenRoutes.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExampleOpenRoutes.java
index 83705e434..37b919619 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExampleOpenRoutes.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExampleOpenRoutes.java
@@ -41,19 +41,19 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * get a vehicle type-builder and build a type with the typeId "vehicleType" and a capacity of 2
-		 */
+         */
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType").addCapacityDimension(0, 2);
         vehicleTypeBuilder.setFixedCost(100);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
+        /*
          * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
-		 */
+         */
         Builder vehicleBuilder = VehicleImpl.Builder.newInstance("vehicle");
         vehicleBuilder.setStartLocation(Location.newInstance(10, 10));
         vehicleBuilder.setType(vehicleType);
@@ -61,9 +61,9 @@ public static void main(String[] args) {
 
         VehicleImpl vehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * build services at the required locations, each with a capacity-demand of 1.
-		 */
+         */
         Service service1 = Service.Builder.newInstance("1").addSizeDimension(0, 1).setLocation(Location.newInstance(5, 7)).build();
         Service service2 = Service.Builder.newInstance("2").addSizeDimension(0, 1).setLocation(Location.newInstance(5, 13)).build();
 
@@ -77,28 +77,28 @@ public static void main(String[] args) {
 
         VehicleRoutingProblem problem = vrpBuilder.build();
 
-		/*
+        /*
          * get the algorithm out-of-the-box.
-		 */
+         */
         VehicleRoutingAlgorithm algorithm = Jsprit.createAlgorithm(problem);
 
-		/*
+        /*
          * and search a solution
-		 */
+         */
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
 
-		/*
+        /*
          * get the best
-		 */
+         */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
         new VrpXMLWriter(problem, solutions).write("output/problem-with-solution.xml");
 
         SolutionPrinter.print(bestSolution);
 
-		/*
+        /*
          * plot
-		 */
+         */
 
         new Plotter(problem, bestSolution).plot("output/solution.png", "solution");
 
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExampleWithPriorities.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExampleWithPriorities.java
index 6fc24f19d..f70f103f6 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExampleWithPriorities.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExampleWithPriorities.java
@@ -43,7 +43,7 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         File dir = new File("output");
         // if the directory does not exist, create it
         if (!dir.exists()) {
@@ -52,24 +52,24 @@ public static void main(String[] args) {
             if (result) System.out.println("./output created");
         }
 
-		/*
+        /*
          * get a vehicle type-builder and build a type with the typeId "vehicleType" and one capacity dimension, i.e. weight, and capacity dimension value of 2
-		 */
+         */
         final int WEIGHT_INDEX = 0;
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType").addCapacityDimension(WEIGHT_INDEX, 2);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
+        /*
          * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
-		 */
+         */
         Builder vehicleBuilder = Builder.newInstance("vehicle");
         vehicleBuilder.setStartLocation(Location.newInstance(10, 10));
         vehicleBuilder.setType(vehicleType);
         VehicleImpl vehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * build services at the required locations, each with a capacity-demand of 1.
-		 */
+         */
         Service service1 = Service.Builder.newInstance("1").setPriority(1).addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(5, 7)).build();
         Service service2 = Service.Builder.newInstance("2").addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(5, 13)).build();
 
@@ -83,28 +83,28 @@ public static void main(String[] args) {
 
         VehicleRoutingProblem problem = vrpBuilder.build();
 
-		/*
+        /*
          * get the algorithm out-of-the-box.
-		 */
+         */
         VehicleRoutingAlgorithm algorithm = Jsprit.createAlgorithm(problem);
 
-		/*
+        /*
          * and search a solution
-		 */
+         */
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
 
-		/*
+        /*
          * get the best
-		 */
+         */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
         new VrpXMLWriter(problem, solutions).write("output/problem-with-solution.xml");
 
         SolutionPrinter.print(problem, bestSolution, SolutionPrinter.Print.VERBOSE);
 
-		/*
+        /*
          * plot
-		 */
+         */
 //		SolutionPlotter.plotSolutionAsPNG(problem, bestSolution, "output/solution.png", "solution");
 
         new GraphStreamViewer(problem, bestSolution).labelWith(Label.ID).setRenderDelay(200).display();
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExampleWithSkills.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExampleWithSkills.java
index 01834da95..87a711941 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExampleWithSkills.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleExampleWithSkills.java
@@ -21,10 +21,8 @@
 import com.graphhopper.jsprit.analysis.toolbox.GraphStreamViewer.Label;
 import com.graphhopper.jsprit.core.algorithm.VehicleRoutingAlgorithm;
 import com.graphhopper.jsprit.core.algorithm.box.Jsprit;
-import com.graphhopper.jsprit.core.algorithm.state.StateManager;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
-import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
 import com.graphhopper.jsprit.core.problem.job.Service;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
@@ -45,7 +43,7 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         File dir = new File("output");
         // if the directory does not exist, create it
         if (!dir.exists()) {
@@ -54,16 +52,16 @@ public static void main(String[] args) {
             if (result) System.out.println("./output created");
         }
 
-		/*
+        /*
          * get a vehicle type-builder and build a type with the typeId "vehicleType" and one capacity dimension, i.e. weight, and capacity dimension value of 2
-		 */
+         */
         final int WEIGHT_INDEX = 0;
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType").addCapacityDimension(WEIGHT_INDEX, 2);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
+        /*
          * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
-		 */
+         */
         Builder vehicleBuilder = Builder.newInstance("vehicle");
         vehicleBuilder.setStartLocation(Location.newInstance(10, 10));
         vehicleBuilder.setType(vehicleType);
@@ -75,9 +73,9 @@ public static void main(String[] args) {
         vehicle2Builder.addSkill("drill");
         VehicleImpl vehicle2 = vehicle2Builder.build();
 
-		/*
+        /*
          * build services at the required locations, each with a capacity-demand of 1.
-		 */
+         */
         Service service1 = Service.Builder.newInstance("1").addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(5, 7)).build();
         Service service2 = Service.Builder.newInstance("2").addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(5, 13)).build();
 
@@ -92,29 +90,29 @@ public static void main(String[] args) {
 
         VehicleRoutingProblem problem = vrpBuilder.build();
 
-		/*
+        /*
          * get the algorithm out-of-the-box.
-		 */
+         */
 
         VehicleRoutingAlgorithm algorithm = Jsprit.createAlgorithm(problem);
 
-		/*
+        /*
          * and search a solution
-		 */
+         */
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
 
-		/*
+        /*
          * get the best
-		 */
+         */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
         new VrpXMLWriter(problem, solutions).write("output/problem-with-solution.xml");
 
         SolutionPrinter.print(problem, bestSolution, SolutionPrinter.Print.VERBOSE);
 
-		/*
+        /*
          * plot
-		 */
+         */
 //		SolutionPlotter.plotSolutionAsPNG(problem, bestSolution, "output/solution.png", "solution");
 
         new GraphStreamViewer(problem, bestSolution).labelWith(Label.ID).setRenderDelay(200).display();
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleVRPWithBackhaulsExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleVRPWithBackhaulsExample.java
index 2c0c3e76f..e3764fe79 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleVRPWithBackhaulsExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SimpleVRPWithBackhaulsExample.java
@@ -35,7 +35,6 @@
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
 import com.graphhopper.jsprit.core.reporting.SolutionPrinter;
 import com.graphhopper.jsprit.core.util.Solutions;
-
 import com.graphhopper.jsprit.io.problem.VrpXMLWriter;
 import com.graphhopper.jsprit.util.Examples;
 
@@ -47,26 +46,26 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * get a vehicle type-builder and build a type with the typeId "vehicleType" and a capacity of 2
-		 */
+         */
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType").addCapacityDimension(0, 2);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
+        /*
          * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
-		 */
+         */
         Builder vehicleBuilder = VehicleImpl.Builder.newInstance("vehicle");
         vehicleBuilder.setStartLocation(Location.newInstance(10, 10));
         vehicleBuilder.setType(vehicleType);
         VehicleImpl vehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * build pickups and deliveries at the required locations, each with a capacity-demand of 1.
-		 */
+         */
         Pickup pickup1 = Pickup.Builder.newInstance("1").addSizeDimension(0, 1).setLocation(Location.newInstance(5, 7)).build();
         Delivery delivery1 = Delivery.Builder.newInstance("2").addSizeDimension(0, 1).setLocation(Location.newInstance(5, 13)).build();
 
@@ -86,26 +85,26 @@ public static void main(String[] args) {
         ConstraintManager constraintManager = new ConstraintManager(problem, stateManager);
         constraintManager.addConstraint(new ServiceDeliveriesFirstConstraint(), ConstraintManager.Priority.CRITICAL);
 
-        VehicleRoutingAlgorithm algorithm = Jsprit.Builder.newInstance(problem).setStateAndConstraintManager(stateManager,constraintManager)
+        VehicleRoutingAlgorithm algorithm = Jsprit.Builder.newInstance(problem).setStateAndConstraintManager(stateManager, constraintManager)
             .buildAlgorithm();
 
-		/*
+        /*
          * and search a solution
-		 */
+         */
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
 
-		/*
+        /*
          * get the best
-		 */
+         */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
         new VrpXMLWriter(problem, solutions).write("output/problem-with-solution.xml");
 
         SolutionPrinter.print(bestSolution);
 
-		/*
+        /*
          * plot
-		 */
+         */
         Plotter plotter = new Plotter(problem, bestSolution);
         plotter.setLabel(Label.SIZE);
         plotter.plot("output/solution.png", "solution");
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonExample.java
index 9493eb0d0..97d5a0695 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonExample.java
@@ -37,57 +37,57 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * Build the problem.
-		 *
-		 * But define a problem-builder first.
-		 */
+         *
+         * But define a problem-builder first.
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
 
-		/*
+        /*
          * A solomonReader reads solomon-instance files, and stores the required information in the builder.
-		 */
+         */
         new SolomonReader(vrpBuilder).read("input/C101_solomon.txt");
 
 
-		/*
+        /*
          * Finally, the problem can be built. By default, transportCosts are crowFlyDistances (as usually used for vrp-instances).
-		 */
+         */
         VehicleRoutingProblem vrp = vrpBuilder.build();
 
         new Plotter(vrp).plot("output/solomon_C101.png", "C101");
 
-		/*
+        /*
          * Define the required vehicle-routing algorithms to solve the above problem.
-		 *
-		 * The algorithm can be defined and configured in an xml-file.
-		 */
+         *
+         * The algorithm can be defined and configured in an xml-file.
+         */
         VehicleRoutingAlgorithm vra = new SchrimpfFactory().createAlgorithm(vrp);
 
-		/*
+        /*
          * Solve the problem.
-		 *
-		 *
-		 */
+         *
+         *
+         */
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
 
-		/*
+        /*
          * Retrieve best solution.
-		 */
+         */
         VehicleRoutingProblemSolution solution = new SelectBest().selectSolution(solutions);
 
 
-		/*
+        /*
          * print solution
-		 */
+         */
         SolutionPrinter.print(vrp, solution, SolutionPrinter.Print.VERBOSE);
 
-		/*
-		 * Plot solution.
-		 */
+        /*
+         * Plot solution.
+         */
         Plotter plotter = new Plotter(vrp, solution);
 //		plotter.setBoundingBox(30, 0, 50, 20);
         plotter.plot("output/solomon_C101_solution.png", "C101");
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonExampleWithSpecifiedVehicleEndLocations.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonExampleWithSpecifiedVehicleEndLocations.java
index 8548783eb..78c96886c 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonExampleWithSpecifiedVehicleEndLocations.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonExampleWithSpecifiedVehicleEndLocations.java
@@ -38,7 +38,7 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         File dir = new File("output");
         // if the directory does not exist, create it
         if (!dir.exists()) {
@@ -47,31 +47,31 @@ public static void main(String[] args) {
             if (result) System.out.println("./output created");
         }
 
-		/*
+        /*
          * Build the problem.
-		 *
-		 * But define a problem-builder first.
-		 */
+         *
+         * But define a problem-builder first.
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
 
-		/*
+        /*
          * A solomonReader reads solomon-instance files, and stores the required information in the builder.
-		 */
+         */
         new VrpXMLReader(vrpBuilder).read("input/deliveries_solomon_specifiedVehicleEndLocations_c101.xml");
 
-		/*
+        /*
          * Finally, the problem can be built. By default, transportCosts are crowFlyDistances (as usually used for vrp-instances).
-		 */
+         */
         VehicleRoutingProblem vrp = vrpBuilder.build();
 
         Plotter pblmPlotter = new Plotter(vrp);
         pblmPlotter.plot("output/solomon_C101_specifiedVehicleEndLocations.png", "C101");
 
-		/*
+        /*
          * Define the required vehicle-routing algorithms to solve the above problem.
-		 *
-		 * The algorithm can be defined and configured in an xml-file.
-		 */
+         *
+         * The algorithm can be defined and configured in an xml-file.
+         */
 //		VehicleRoutingAlgorithm vra = new SchrimpfFactory().createAlgorithm(vrp);
         VehicleRoutingAlgorithm vra = Jsprit.createAlgorithm(vrp);
         vra.setMaxIterations(20000);
@@ -79,24 +79,24 @@ public static void main(String[] args) {
         vra.getAlgorithmListeners().addListener(new AlgorithmSearchProgressChartListener("output/sol_progress.png"));
         /*
          * Solve the problem.
-		 *
-		 *
-		 */
+         *
+         *
+         */
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
 
-		/*
+        /*
          * Retrieve best solution.
-		 */
+         */
         VehicleRoutingProblemSolution solution = new SelectBest().selectSolution(solutions);
 
-		/*
-		 * print solution
-		 */
+        /*
+         * print solution
+         */
         SolutionPrinter.print(solution);
 
-		/*
-		 * Plot solution.
-		 */
+        /*
+         * Plot solution.
+         */
 //		SolutionPlotter.plotSolutionAsPNG(vrp, solution, "output/solomon_C101_specifiedVehicleEndLocations_solution.png","C101");
         Plotter solPlotter = new Plotter(vrp, solution);
         solPlotter.plot("output/solomon_C101_specifiedVehicleEndLocations_solution.png", "C101");
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonExampleWithSpecifiedVehicleEndLocationsWithoutTWs.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonExampleWithSpecifiedVehicleEndLocationsWithoutTWs.java
index cedf88186..5d28b037b 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonExampleWithSpecifiedVehicleEndLocationsWithoutTWs.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonExampleWithSpecifiedVehicleEndLocationsWithoutTWs.java
@@ -37,7 +37,7 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         File dir = new File("output");
         // if the directory does not exist, create it
         if (!dir.exists()) {
@@ -46,32 +46,32 @@ public static void main(String[] args) {
             if (result) System.out.println("./output created");
         }
 
-		/*
+        /*
          * Build the problem.
-		 *
-		 * But define a problem-builder first.
-		 */
+         *
+         * But define a problem-builder first.
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
 
-		/*
+        /*
          * A solomonReader reads solomon-instance files, and stores the required information in the builder.
-		 */
+         */
         new VrpXMLReader(vrpBuilder).read("input/pickups_and_deliveries_solomon_c101_withoutTWs_and_specifiedVehicleEndLocations.xml");
 
-		/*
+        /*
          * Finally, the problem can be built. By default, transportCosts are crowFlyDistances (as usually used for vrp-instances).
-		 */
+         */
 //		vrpBuilder.addProblemConstraint(Constraint.DELIVERIES_FIRST);
         VehicleRoutingProblem vrp = vrpBuilder.build();
 
         Plotter pblmPlotter = new Plotter(vrp);
         pblmPlotter.plot("output/solomon_C101_specifiedVehicleEndLocations_withoutTWs.png", "C101");
 
-		/*
+        /*
          * Define the required vehicle-routing algorithms to solve the above problem.
-		 *
-		 * The algorithm can be defined and configured in an xml-file.
-		 */
+         *
+         * The algorithm can be defined and configured in an xml-file.
+         */
 //		VehicleRoutingAlgorithm vra = new SchrimpfFactory().createAlgorithm(vrp);
         VehicleRoutingAlgorithm vra = Jsprit.createAlgorithm(vrp);
         vra.setMaxIterations(20000);
@@ -79,24 +79,24 @@ public static void main(String[] args) {
 //		vra.getAlgorithmListeners().addListener(new AlgorithmSearchProgressChartListener("output/sol_progress.png"));
         /*
          * Solve the problem.
-		 *
-		 *
-		 */
+         *
+         *
+         */
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
 
-		/*
+        /*
          * Retrieve best solution.
-		 */
+         */
         VehicleRoutingProblemSolution solution = new SelectBest().selectSolution(solutions);
 
-		/*
-		 * print solution
-		 */
+        /*
+         * print solution
+         */
         SolutionPrinter.print(solution);
 
-		/*
-		 * Plot solution.
-		 */
+        /*
+         * Plot solution.
+         */
 //		SolutionPlotter.plotSolutionAsPNG(vrp, solution, "output/solomon_C101_specifiedVehicleEndLocations_solution.png","C101");
         Plotter solPlotter = new Plotter(vrp, solution);
         solPlotter.plot("output/solomon_C101_specifiedVehicleEndLocations_withoutTWs_solution.png", "C101");
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonOpenExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonOpenExample.java
index 64fb61628..89747c6de 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonOpenExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonOpenExample.java
@@ -36,24 +36,24 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * Build the problem.
-		 *
-		 * But define a problem-builder first.
-		 */
+         *
+         * But define a problem-builder first.
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
 
-		/*
+        /*
          * A solomonReader reads solomon-instance files, and stores the required information in the builder.
-		 */
+         */
         new VrpXMLReader(vrpBuilder).read("input/deliveries_solomon_open_c101.xml");
 
-		/*
+        /*
          * Finally, the problem can be built. By default, transportCosts are crowFlyDistances (as usually used for vrp-instances).
-		 */
+         */
         VehicleRoutingProblem vrp = vrpBuilder.build();
 
 //        new Plotter(vrp).plot("output/solomon_C101_open.png", "C101");
@@ -62,15 +62,15 @@ public static void main(String[] args) {
         AlgorithmEventsRecorder eventsRecorder = new AlgorithmEventsRecorder(vrp, "output/events.dgs.gz");
         eventsRecorder.setRecordingRange(0, 50);
 
-		/*
+        /*
          * Define the required vehicle-routing algorithms to solve the above problem.
-		 *
-		 * The algorithm can be defined and configured in an xml-file.
-		 */
+         *
+         * The algorithm can be defined and configured in an xml-file.
+         */
 //		VehicleRoutingAlgorithm vra = new SchrimpfFactory().createAlgorithm(vrp);
 //		VehicleRoutingAlgorithm vra = VehicleRoutingAlgorithms.readAndCreateAlgorithm(vrp, "input/algorithmConfig_fix.xml");
         VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setProperty(Jsprit.Parameter.THREADS, "4")
-        .setProperty(Jsprit.Parameter.FAST_REGRET, "true")
+            .setProperty(Jsprit.Parameter.FAST_REGRET, "true")
             .setProperty(Jsprit.Parameter.CONSTRUCTION, Jsprit.Construction.BEST_INSERTION.toString()).buildAlgorithm();
 //		vra.setPrematureBreak(100);
 //		vra.getAlgorithmListeners().addListener(new AlgorithmSearchProgressChartListener("output/sol_progress.png"));
@@ -78,24 +78,24 @@ public static void main(String[] args) {
         vra.setMaxIterations(200);
         /*
          * Solve the problem.
-		 *
-		 *
-		 */
+         *
+         *
+         */
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
 
-		/*
+        /*
          * Retrieve best solution.
-		 */
+         */
         VehicleRoutingProblemSolution solution = new SelectBest().selectSolution(solutions);
 
-		/*
-		 * print solution
-		 */
+        /*
+         * print solution
+         */
         SolutionPrinter.print(solution);
 
-		/*
-		 * Plot solution.
-		 */
+        /*
+         * Plot solution.
+         */
 //		SolutionPlotter.plotSolutionAsPNG(vrp, solution, "output/solomon_C101_open_solution.png","C101");
 
 
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonR101Example.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonR101Example.java
index 22740a740..80bc6ff7b 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonR101Example.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/SolomonR101Example.java
@@ -36,34 +36,34 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * Build the problem.
-		 *
-		 * But define a problem-builder first.
-		 */
+         *
+         * But define a problem-builder first.
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
 
-		/*
+        /*
          * A solomonReader reads solomon-instance files, and stores the required information in the builder.
-		 */
+         */
 //		new SolomonReader(vrpBuilder).read("/Users/schroeder/IdeaProjects/jsprit/jsprit-instances/instances/solomon/R211.txt");
         new VrpXMLReader(vrpBuilder).read("output/R211.xml");
         /*
          * Finally, the problem can be built. By default, transportCosts are crowFlyDistances (as usually used for vrp-instances).
-		 */
+         */
         VehicleRoutingProblem vrp = vrpBuilder.build();
 
 //        new VrpXMLWriter(vrp).write("output/R211.xml");
 //		new Plotter(vrp).plot("output/solomon_R101.png", "R101");
 
-		/*
+        /*
          * Define the required vehicle-routing algorithms to solve the above problem.
-		 *
-		 * The algorithm can be defined and configured in an xml-file.
-		 */
+         *
+         * The algorithm can be defined and configured in an xml-file.
+         */
 //		VehicleRoutingAlgorithm vra = new SchrimpfFactory().createAlgorithm(vrp);
         VehicleRoutingAlgorithm vra = Jsprit.createAlgorithm(vrp);
         vra.setMaxIterations(20000);
@@ -71,25 +71,25 @@ public static void main(String[] args) {
         vra.getAlgorithmListeners().addListener(new AlgorithmSearchProgressChartListener("output/sol_progress.png"));
         /*
          * Solve the problem.
-		 *
-		 *
-		 */
+         *
+         *
+         */
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
 
-		/*
-		 * Retrieve best solution.
-		 */
+        /*
+         * Retrieve best solution.
+         */
         VehicleRoutingProblemSolution solution = new SelectBest().selectSolution(solutions);
 
-		/*
-		 * print solution
-		 */
+        /*
+         * print solution
+         */
         SolutionPrinter.print(vrp, solution, SolutionPrinter.Print.VERBOSE);
 
         new GraphStreamViewer(vrp, solution).display();
-		/*
-		 * Plot solution.
-		 */
+        /*
+         * Plot solution.
+         */
 //		new Plotter(vrp,solution).plot( "output/solomon_R101_solution.png","R101");
 
     }
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/TransportOfDisabledPeople.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/TransportOfDisabledPeople.java
index b02f9beb9..6c68abdc2 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/TransportOfDisabledPeople.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/TransportOfDisabledPeople.java
@@ -52,12 +52,12 @@
     public static void main(String[] args) {
         /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * get a vehicle type-builder and build a type with the typeId "vehicleType" and a capacity of 2
-		 */
+         */
         VehicleTypeImpl.Builder wheelChairTypeBuilder = VehicleTypeImpl.Builder.newInstance("wheelChairBusType")
             .addCapacityDimension(WHEELCHAIRSPACE_INDEX, 2) //can transport two people with wheelchair
             .addCapacityDimension(PASSENGERSEATS_INDEX, 4); //and 4 without
@@ -67,14 +67,14 @@ public static void main(String[] args) {
             .addCapacityDimension(PASSENGERSEATS_INDEX, 6); //and 4 without
         VehicleType vehicleType_solelypassenger = soleyPassengerTypeBuilder.build();
 
-		/*
+        /*
          * define two vehicles and their locations.
-		 *
-		 * this example employs two vehicles. one that has to return to its start-location (vehicle1) and one that has a different
-		 * end-location.
-		 *
-		 * play with these location to see which impact they have on customer-sequences.
-		 */
+         *
+         * this example employs two vehicles. one that has to return to its start-location (vehicle1) and one that has a different
+         * end-location.
+         *
+         * play with these location to see which impact they have on customer-sequences.
+         */
         Builder vehicleBuilder1 = VehicleImpl.Builder.newInstance("wheelchair_bus");
         vehicleBuilder1.setStartLocation(loc(Coordinate.newInstance(10, 10)));
         vehicleBuilder1.setType(vehicleType_wheelchair);
@@ -96,10 +96,10 @@ public static void main(String[] args) {
         VehicleImpl vehicle2_2 = vehicleBuilder2_2.build();
 
 
-		/*
+        /*
          * build shipments at the required locations, each with a capacity-demand of 1.
-		 *
-		 */
+         *
+         */
         Shipment shipment1 = Shipment.Builder.newInstance("wheelchair_1").addSizeDimension(WHEELCHAIRSPACE_INDEX, 1).setPickupLocation(loc(Coordinate.newInstance(5, 7))).setDeliveryLocation(loc(Coordinate.newInstance(6, 9))).build();
         Shipment shipment2 = Shipment.Builder.newInstance("2").addSizeDimension(PASSENGERSEATS_INDEX, 1).setPickupLocation(loc(Coordinate.newInstance(5, 13))).setDeliveryLocation(loc(Coordinate.newInstance(6, 11))).build();
 
@@ -141,10 +141,10 @@ public static void main(String[] args) {
         //you only have two vehicles
         vrpBuilder.setFleetSize(FleetSize.FINITE);
 
-		/*
+        /*
          *
-		 * wheelchair-bus can only pickup passenger where x<15
-		 */
+         * wheelchair-bus can only pickup passenger where x<15
+         */
         HardRouteConstraint wheelchair_bus_passenger_pickup_constraint = new HardRouteConstraint() {
 
             @Override
@@ -170,32 +170,32 @@ public boolean fulfilled(JobInsertionContext insertionContext) {
         constraintManager.addConstraint(wheelchair_bus_passenger_pickup_constraint);
 
 
-        VehicleRoutingAlgorithm algorithm = Jsprit.Builder.newInstance(problem).setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
+        VehicleRoutingAlgorithm algorithm = Jsprit.Builder.newInstance(problem).setStateAndConstraintManager(stateManager, constraintManager).buildAlgorithm();
         algorithm.setPrematureAlgorithmTermination(new IterationWithoutImprovementTermination(100));
 
-		/*
+        /*
          * and search a solution
-		 */
+         */
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
 
-		/*
+        /*
          * get the best
-		 */
+         */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
-		/*
-		 * write out problem and solution to xml-file
-		 */
+        /*
+         * write out problem and solution to xml-file
+         */
 //		new VrpXMLWriter(problem, solutions).write("output/shipment-problem-with-solution.xml");
 
-		/*
-		 * print nRoutes and totalCosts of bestSolution
-		 */
+        /*
+         * print nRoutes and totalCosts of bestSolution
+         */
         SolutionPrinter.print(problem, bestSolution, SolutionPrinter.Print.VERBOSE);
 
-		/*
-		 * plot problem without solution
-		 */
+        /*
+         * plot problem without solution
+         */
         Plotter problemPlotter = new Plotter(problem);
         problemPlotter.plotShipments(true);
         problemPlotter.setLabel(Plotter.Label.SIZE);
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/VRPWithBackhaulsExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/VRPWithBackhaulsExample.java
index a55452887..731d36448 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/VRPWithBackhaulsExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/VRPWithBackhaulsExample.java
@@ -38,63 +38,63 @@
 
     public static void main(String[] args) {
 
-		/*
+        /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * Build the problem.
-		 *
-		 * But define a problem-builder first.
-		 */
+         *
+         * But define a problem-builder first.
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
 
-		/*
+        /*
          * A solomonReader reads solomon-instance files, and stores the required information in the builder.
-		 */
+         */
         new VrpXMLReader(vrpBuilder).read("input/pickups_and_deliveries_solomon_r101.xml");
 
-		/*
+        /*
          * Finally, the problem can be built. By default, transportCosts are crowFlyDistances (as usually used for vrp-instances).
-		 */
+         */
 //
         VehicleRoutingProblem vrp = vrpBuilder.build();
 
 //		SolutionPlotter.plotVrpAsPNG(vrp, "output/vrpwbh_solomon_r101.png", "pd_r101");
 
-		/*
+        /*
          * Define the required vehicle-routing algorithms to solve the above problem.
-		 *
-		 * The algorithm can be defined and configured in an xml-file.
-		 */
+         *
+         * The algorithm can be defined and configured in an xml-file.
+         */
 
         StateManager stateManager = new StateManager(vrp);
         ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
         constraintManager.addConstraint(new ServiceDeliveriesFirstConstraint(), ConstraintManager.Priority.CRITICAL);
 
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager, constraintManager).buildAlgorithm();
         vra.getAlgorithmListeners().addListener(new AlgorithmSearchProgressChartListener("output/sol_progress.png"));
         /*
          * Solve the problem.
-		 *
-		 *
-		 */
+         *
+         *
+         */
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
 
-		/*
+        /*
          * Retrieve best solution.
-		 */
+         */
         VehicleRoutingProblemSolution solution = new SelectBest().selectSolution(solutions);
 
-		/*
-		 * print solution
-		 */
+        /*
+         * print solution
+         */
         SolutionPrinter.print(vrp, solution, SolutionPrinter.Print.VERBOSE);
 
-		/*
-		 * Plot solution.
-		 */
+        /*
+         * Plot solution.
+         */
 //		Plotter plotter = new Plotter(vrp, solution);
 //		plotter.setLabel(Label.SIZE);
 //		plotter.setShowFirstActivity(true);
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/VRPWithBackhaulsExample2.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/VRPWithBackhaulsExample2.java
index 47494f1bb..d4e29da41 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/VRPWithBackhaulsExample2.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/VRPWithBackhaulsExample2.java
@@ -42,37 +42,37 @@
 
     public static void main(String[] args) {
 
-		/*
+        /*
          * some preparation - create output folder
-		 */
+         */
         Examples.createOutputFolder();
 
-		/*
+        /*
          * Build the problem.
-		 *
-		 * But define a problem-builder first.
-		 */
+         *
+         * But define a problem-builder first.
+         */
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
 
-		/*
+        /*
          * A solomonReader reads solomon-instance files, and stores the required information in the builder.
-		 */
+         */
         new VrpXMLReader(vrpBuilder).read("input/pd_christophides_vrpnc1_vcap50.xml");
 
 
-		/*
+        /*
          * Finally, the problem can be built. By default, transportCosts are crowFlyDistances (as usually used for vrp-instances).
-		 */
+         */
         final VehicleRoutingProblem vrp = vrpBuilder.build();
 
 //		new Plotter(vrp).plot("output/vrpwbh_christophides_vrpnc1.png", "pd_vrpnc1");
 
 
-		/*
+        /*
          * Define the required vehicle-routing algorithms to solve the above problem.
-		 *
-		 * The algorithm can be defined and configured in an xml-file.
-		 */
+         *
+         * The algorithm can be defined and configured in an xml-file.
+         */
 //		VehicleRoutingAlgorithm vra = VehicleRoutingAlgorithms.readAndCreateAlgorithm(vrp, "input/algorithmConfig_solomon.xml");
 
 //        VehicleRoutingAlgorithmBuilder vraBuilder = new VehicleRoutingAlgorithmBuilder(vrp,"input/algorithmConfig_solomon.xml");
@@ -97,26 +97,26 @@ public static void main(String[] args) {
 
 
 
-		/*
+        /*
          * Solve the problem.
-		 *
-		 *
-		 */
+         *
+         *
+         */
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
 
-		/*
+        /*
          * Retrieve best solution.
-		 */
+         */
         VehicleRoutingProblemSolution solution = new SelectBest().selectSolution(solutions);
 
-		/*
+        /*
          * print solution
-		 */
+         */
         SolutionPrinter.print(solution);
 
-		/*
-		 * Plot solution.
-		 */
+        /*
+         * Plot solution.
+         */
 //		SolutionPlotter.plotSolutionAsPNG(vrp, solution, "output/pd_solomon_r101_solution.png","pd_r101");
         Plotter plotter = new Plotter(vrp, solution);
 //		plotter.setLabel(Plotter.Label.SIZE);
diff --git a/jsprit-instances/pom.xml b/jsprit-instances/pom.xml
index 5f657739c..b5a1926cb 100644
--- a/jsprit-instances/pom.xml
+++ b/jsprit-instances/pom.xml
@@ -16,7 +16,8 @@
   ~ limitations under the License.
   -->
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>jsprit</artifactId>
diff --git a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/BelhaizaReader.java b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/BelhaizaReader.java
index 401f70fea..2f49328f7 100644
--- a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/BelhaizaReader.java
+++ b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/BelhaizaReader.java
@@ -36,141 +36,133 @@
 
 /**
  * Reader that reads the well-known solomon-instances.
- *
+ * <p>
  * <p>See: <a href="http://neo.lcc.uma.es/vrp/vrp-instances/capacitated-vrp-with-time-windows-instances/">neo.org</a>
  *
  * @author stefan
- *
  */
 
 public class BelhaizaReader {
 
+    private static Logger logger = LoggerFactory.getLogger(BelhaizaReader.class);
+    private final VehicleRoutingProblem.Builder vrpBuilder;
     private int fixedCosts;
+    private double coordProjectionFactor = 1;
+    private double timeProjectionFactor = 1;
+    private double variableCostProjectionFactor = 1;
+    private double fixedCostPerVehicle = 0.0;
+
+    public BelhaizaReader(VehicleRoutingProblem.Builder vrpBuilder) {
+        super();
+        this.vrpBuilder = vrpBuilder;
+    }
+
+    public BelhaizaReader(VehicleRoutingProblem.Builder vrpBuilder, double fixedCostPerVehicle) {
+        super();
+        this.vrpBuilder = vrpBuilder;
+        this.fixedCostPerVehicle = fixedCostPerVehicle;
+    }
 
     /**
-	 * @param costProjectionFactor the costProjectionFactor to set
-	 */
-	public void setVariableCostProjectionFactor(double costProjectionFactor) {
-		this.variableCostProjectionFactor = costProjectionFactor;
-	}
-
-	private static Logger logger = LoggerFactory.getLogger(BelhaizaReader.class);
-
-	private final VehicleRoutingProblem.Builder vrpBuilder;
-
-	private double coordProjectionFactor = 1;
-
-	private double timeProjectionFactor = 1;
-
-	private double variableCostProjectionFactor = 1;
-
-	private double fixedCostPerVehicle = 0.0;
-
-	public BelhaizaReader(VehicleRoutingProblem.Builder vrpBuilder) {
-		super();
-		this.vrpBuilder = vrpBuilder;
-	}
-
-	public BelhaizaReader(VehicleRoutingProblem.Builder vrpBuilder, double fixedCostPerVehicle) {
-		super();
-		this.vrpBuilder = vrpBuilder;
-		this.fixedCostPerVehicle=fixedCostPerVehicle;
-	}
-
-	public void read(String solomonFile){
-		vrpBuilder.setFleetSize(FleetSize.INFINITE);
-		BufferedReader reader = getReader(solomonFile);
-		int vehicleCapacity = 0;
-		int counter = 0;
-		String line;
-		while((line = readLine(reader)) != null){
-			String[] tokens = line.replace("\r", "").trim().split("\\s+");
-			counter++;
-			if(counter == 2){
-				vehicleCapacity = Integer.parseInt(tokens[1]);
-				continue;
-			}
-			if(counter > 2){
-				if(tokens.length < 7) continue;
-                Coordinate coord = makeCoord(tokens[1],tokens[2]);
-				String customerId = tokens[0];
-				int demand = Integer.parseInt(tokens[4]);
-				double serviceTime = Double.parseDouble(tokens[3])*timeProjectionFactor;
-				if(counter == 3){
-					VehicleTypeImpl.Builder typeBuilder = VehicleTypeImpl.Builder.newInstance("solomonType").addCapacityDimension(0, vehicleCapacity);
-					typeBuilder.setCostPerDistance(1.0*variableCostProjectionFactor).setFixedCost(fixedCostPerVehicle)
-                    .setCostPerWaitingTime(0.8);
+     * @param costProjectionFactor the costProjectionFactor to set
+     */
+    public void setVariableCostProjectionFactor(double costProjectionFactor) {
+        this.variableCostProjectionFactor = costProjectionFactor;
+    }
+
+    public void read(String solomonFile) {
+        vrpBuilder.setFleetSize(FleetSize.INFINITE);
+        BufferedReader reader = getReader(solomonFile);
+        int vehicleCapacity = 0;
+        int counter = 0;
+        String line;
+        while ((line = readLine(reader)) != null) {
+            String[] tokens = line.replace("\r", "").trim().split("\\s+");
+            counter++;
+            if (counter == 2) {
+                vehicleCapacity = Integer.parseInt(tokens[1]);
+                continue;
+            }
+            if (counter > 2) {
+                if (tokens.length < 7) continue;
+                Coordinate coord = makeCoord(tokens[1], tokens[2]);
+                String customerId = tokens[0];
+                int demand = Integer.parseInt(tokens[4]);
+                double serviceTime = Double.parseDouble(tokens[3]) * timeProjectionFactor;
+                if (counter == 3) {
+                    VehicleTypeImpl.Builder typeBuilder = VehicleTypeImpl.Builder.newInstance("solomonType").addCapacityDimension(0, vehicleCapacity);
+                    typeBuilder.setCostPerDistance(1.0 * variableCostProjectionFactor).setFixedCost(fixedCostPerVehicle)
+                        .setCostPerWaitingTime(0.8);
                     System.out.println("fix: " + fixedCostPerVehicle + "; perDistance: 1.0; perWaitingTime: 0.8");
                     VehicleTypeImpl vehicleType = typeBuilder.build();
-					double end = Double.parseDouble(tokens[8])*timeProjectionFactor;
-					VehicleImpl vehicle = VehicleImpl.Builder.newInstance("solomonVehicle").setEarliestStart(0.).setLatestArrival(end)
-							.setStartLocation(Location.Builder.newInstance().setId(customerId)
-										.setCoordinate(coord).build()).setType(vehicleType).build();
-					vrpBuilder.addVehicle(vehicle);
-				}
-				else{
-					Service.Builder serviceBuilder = Service.Builder.newInstance(customerId);
-					serviceBuilder.addSizeDimension(0, demand).setLocation(Location.Builder.newInstance().setCoordinate(coord).setId(customerId).build()).setServiceTime(serviceTime);
-					int noTimeWindows = Integer.parseInt(tokens[7]);
-					for(int i=0;i<noTimeWindows*2;i=i+2){
-						double earliest = Double.parseDouble(tokens[8+i]);
-						double latest = Double.parseDouble(tokens[8+i+1]);
-						serviceBuilder.addTimeWindow(earliest,latest);
-					}
-					vrpBuilder.addJob(serviceBuilder.build());
-				}
-			}
-		}
-		close(reader);
-	}
-
-	public void setCoordProjectionFactor(double coordProjectionFactor) {
-		this.coordProjectionFactor = coordProjectionFactor;
-	}
-
-	private void close(BufferedReader reader)  {
-		try {
-			reader.close();
-		} catch (IOException e) {
-			e.printStackTrace();
-			logger.error(e.toString());
-			System.exit(1);
-		}
-	}
-
-	private String readLine(BufferedReader reader) {
-		try {
-			return reader.readLine();
-		} catch (IOException e) {
-			e.printStackTrace();
-			logger.error(e.toString());
-			System.exit(1);
-			return null;
-		}
-	}
-
-	private Coordinate makeCoord(String xString, String yString) {
-		double x = Double.parseDouble(xString);
-		double y = Double.parseDouble(yString);
-		return new Coordinate(x*coordProjectionFactor,y*coordProjectionFactor);
-	}
-
-	private BufferedReader getReader(String solomonFile) {
-		BufferedReader reader = null;
-		try {
-			reader = new BufferedReader(new FileReader(solomonFile));
-		} catch (FileNotFoundException e1) {
-			e1.printStackTrace();
-			logger.error(e1.toString());
-			System.exit(1);
-		}
-		return reader;
-	}
-
-	public void setTimeProjectionFactor(double timeProjection) {
-		this.timeProjectionFactor=timeProjection;
-
-	}
+                    double end = Double.parseDouble(tokens[8]) * timeProjectionFactor;
+                    VehicleImpl vehicle = VehicleImpl.Builder.newInstance("solomonVehicle").setEarliestStart(0.).setLatestArrival(end)
+                        .setStartLocation(Location.Builder.newInstance().setId(customerId)
+                            .setCoordinate(coord).build()).setType(vehicleType).build();
+                    vrpBuilder.addVehicle(vehicle);
+                } else {
+                    Service.Builder serviceBuilder = Service.Builder.newInstance(customerId);
+                    serviceBuilder.addSizeDimension(0, demand).setLocation(Location.Builder.newInstance().setCoordinate(coord).setId(customerId).build()).setServiceTime(serviceTime);
+                    int noTimeWindows = Integer.parseInt(tokens[7]);
+                    for (int i = 0; i < noTimeWindows * 2; i = i + 2) {
+                        double earliest = Double.parseDouble(tokens[8 + i]);
+                        double latest = Double.parseDouble(tokens[8 + i + 1]);
+                        serviceBuilder.addTimeWindow(earliest, latest);
+                    }
+                    vrpBuilder.addJob(serviceBuilder.build());
+                }
+            }
+        }
+        close(reader);
+    }
+
+    private BufferedReader getReader(String solomonFile) {
+        BufferedReader reader = null;
+        try {
+            reader = new BufferedReader(new FileReader(solomonFile));
+        } catch (FileNotFoundException e1) {
+            e1.printStackTrace();
+            logger.error(e1.toString());
+            System.exit(1);
+        }
+        return reader;
+    }
+
+    private String readLine(BufferedReader reader) {
+        try {
+            return reader.readLine();
+        } catch (IOException e) {
+            e.printStackTrace();
+            logger.error(e.toString());
+            System.exit(1);
+            return null;
+        }
+    }
+
+    private Coordinate makeCoord(String xString, String yString) {
+        double x = Double.parseDouble(xString);
+        double y = Double.parseDouble(yString);
+        return new Coordinate(x * coordProjectionFactor, y * coordProjectionFactor);
+    }
+
+    private void close(BufferedReader reader) {
+        try {
+            reader.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+            logger.error(e.toString());
+            System.exit(1);
+        }
+    }
+
+    public void setCoordProjectionFactor(double coordProjectionFactor) {
+        this.coordProjectionFactor = coordProjectionFactor;
+    }
+
+    public void setTimeProjectionFactor(double timeProjection) {
+        this.timeProjectionFactor = timeProjection;
+
+    }
 
     public void setFixedCosts(int fixedCosts) {
         this.fixedCostPerVehicle = fixedCosts;
diff --git a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/ChristofidesReader.java b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/ChristofidesReader.java
index ab5204cfa..7d9878be8 100644
--- a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/ChristofidesReader.java
+++ b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/ChristofidesReader.java
@@ -100,16 +100,14 @@ public void read(String fileName) {
         close(reader);
     }
 
-    public void setCoordProjectionFactor(double coordProjectionFactor) {
-        this.coordProjectionFactor = coordProjectionFactor;
-    }
-
-    private void close(BufferedReader reader) {
+    private BufferedReader getReader(String solomonFile) {
+        BufferedReader reader = null;
         try {
-            reader.close();
-        } catch (IOException e) {
-            throw new RuntimeException(e);
+            reader = new BufferedReader(new FileReader(solomonFile));
+        } catch (FileNotFoundException e1) {
+            throw new RuntimeException(e1);
         }
+        return reader;
     }
 
     private String readLine(BufferedReader reader) {
@@ -126,13 +124,15 @@ private Coordinate makeCoord(String xString, String yString) {
         return new Coordinate(x * coordProjectionFactor, y * coordProjectionFactor);
     }
 
-    private BufferedReader getReader(String solomonFile) {
-        BufferedReader reader = null;
+    private void close(BufferedReader reader) {
         try {
-            reader = new BufferedReader(new FileReader(solomonFile));
-        } catch (FileNotFoundException e1) {
-            throw new RuntimeException(e1);
+            reader.close();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
         }
-        return reader;
+    }
+
+    public void setCoordProjectionFactor(double coordProjectionFactor) {
+        this.coordProjectionFactor = coordProjectionFactor;
     }
 }
diff --git a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/CordeauReader.java b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/CordeauReader.java
index 8240b696f..585d23e2a 100644
--- a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/CordeauReader.java
+++ b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/CordeauReader.java
@@ -123,16 +123,14 @@ public void read(String fileName) {
         close(reader);
     }
 
-    public void setCoordProjectionFactor(double coordProjectionFactor) {
-        this.coordProjectionFactor = coordProjectionFactor;
-    }
-
-    private void close(BufferedReader reader) {
+    private BufferedReader getReader(String solomonFile) {
+        BufferedReader reader = null;
         try {
-            reader.close();
-        } catch (IOException e) {
-            throw new RuntimeException(e);
+            reader = new BufferedReader(new FileReader(solomonFile));
+        } catch (FileNotFoundException e1) {
+            throw new RuntimeException(e1);
         }
+        return reader;
     }
 
     private String readLine(BufferedReader reader) {
@@ -149,13 +147,15 @@ private Coordinate makeCoord(String xString, String yString) {
         return new Coordinate(x * coordProjectionFactor, y * coordProjectionFactor);
     }
 
-    private BufferedReader getReader(String solomonFile) {
-        BufferedReader reader = null;
+    private void close(BufferedReader reader) {
         try {
-            reader = new BufferedReader(new FileReader(solomonFile));
-        } catch (FileNotFoundException e1) {
-            throw new RuntimeException(e1);
+            reader.close();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
         }
-        return reader;
+    }
+
+    public void setCoordProjectionFactor(double coordProjectionFactor) {
+        this.coordProjectionFactor = coordProjectionFactor;
     }
 }
diff --git a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/Figliozzi.java b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/Figliozzi.java
index fec93f9ce..2443ccbc6 100644
--- a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/Figliozzi.java
+++ b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/Figliozzi.java
@@ -34,19 +34,22 @@
 
     public static class TimeDependentTransportCostsFactory {
 
-        public static enum SpeedDistribution {
-
-            TD1a, TD1b, TD1c, TD2a, TD2b, TD2c, TD3a, TD3b, TD3c, TD1d, TD2d, TD3d, TD4, TD5, TD6, CLASSIC
-
-        }
-
-
         public static TDCosts createCosts(Locations locations, SpeedDistribution speedDistribution, double depotClosingTime) {
             List<Double> timeBins = createTimeBins(depotClosingTime);
             List<Double> speedValues = createSpeedValues(speedDistribution);
             return new TDCosts(locations, timeBins, speedValues);
         }
 
+        private static List<Double> createTimeBins(double depotClosingTime) {
+            List<Double> timeBins = new ArrayList<Double>();
+            timeBins.add(.2 * depotClosingTime);
+            timeBins.add(.4 * depotClosingTime);
+            timeBins.add(.6 * depotClosingTime);
+            timeBins.add(.8 * depotClosingTime);
+            timeBins.add(depotClosingTime);
+            return timeBins;
+        }
+
         static List<Double> createSpeedValues(SpeedDistribution speedDistribution) {
             List<Double> speedValues = Collections.emptyList();
             switch (speedDistribution) {
@@ -107,14 +110,10 @@ public static TDCosts createCosts(Locations locations, SpeedDistribution speedDi
             return speedValues;
         }
 
-        private static List<Double> createTimeBins(double depotClosingTime) {
-            List<Double> timeBins = new ArrayList<Double>();
-            timeBins.add(.2 * depotClosingTime);
-            timeBins.add(.4 * depotClosingTime);
-            timeBins.add(.6 * depotClosingTime);
-            timeBins.add(.8 * depotClosingTime);
-            timeBins.add(depotClosingTime);
-            return timeBins;
+        public static enum SpeedDistribution {
+
+            TD1a, TD1b, TD1c, TD2a, TD2b, TD2c, TD3a, TD3b, TD3c, TD1d, TD2d, TD3d, TD4, TD5, TD6, CLASSIC
+
         }
 
     }
@@ -153,13 +152,6 @@ public double getTransportCost(Location from, Location to, double departureTime,
                 transportTimeParameter * getTransportTime(from, to, departureTime, driver, vehicle);
         }
 
-        @Override
-        public double getBackwardTransportCost(Location from, Location to, double arrivalTime, Driver driver, Vehicle vehicle) {
-            return transportDistanceParameter * EuclideanDistanceCalculator.calculateDistance(locations.getCoord(from.getId()), locations.getCoord(to.getId())) +
-                transportTimeParameter * getBackwardTransportTime(from, to, arrivalTime, driver, vehicle);
-        }
-
-
         @Override
         public double getTransportTime(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
             if (from.equals(to)) {
@@ -185,6 +177,11 @@ public double getTransportTime(Location from, Location to, double departureTime,
             return Double.MAX_VALUE;
         }
 
+        @Override
+        public double getBackwardTransportCost(Location from, Location to, double arrivalTime, Driver driver, Vehicle vehicle) {
+            return transportDistanceParameter * EuclideanDistanceCalculator.calculateDistance(locations.getCoord(from.getId()), locations.getCoord(to.getId())) +
+                transportTimeParameter * getBackwardTransportTime(from, to, arrivalTime, driver, vehicle);
+        }
 
         @Override
         public double getBackwardTransportTime(Location from, Location to, double arrivalTime, Driver driver, Vehicle vehicle) {
diff --git a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/LiLimReader.java b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/LiLimReader.java
index 95bedb71c..50ca5bea9 100644
--- a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/LiLimReader.java
+++ b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/LiLimReader.java
@@ -50,51 +50,14 @@
 
 public class LiLimReader {
 
-    static class CustomerData {
-        public Coordinate coord;
-        public double start;
-        public double end;
-        public double serviceTime;
-
-        public CustomerData(Coordinate coord, double start, double end, double serviceTime) {
-            super();
-            this.coord = coord;
-            this.start = start;
-            this.end = end;
-            this.serviceTime = serviceTime;
-        }
-    }
-
-    static class Relation {
-        public String from;
-        public String to;
-        public int demand;
-
-        public Relation(String from, String to, int demand) {
-            super();
-            this.from = from;
-            this.to = to;
-            this.demand = demand;
-        }
-
-    }
-
     private static Logger logger = LoggerFactory.getLogger(LiLimReader.class);
-
     private VehicleRoutingProblem.Builder vrpBuilder;
-
     private int vehicleCapacity;
-
     private String depotId;
-
     private Map<String, CustomerData> customers;
-
     private Collection<Relation> relations;
-
     private double depotOpeningTime;
-
     private double depotClosingTime;
-
     private int fixCosts = 0;
 
     public LiLimReader(Builder vrpBuilder) {
@@ -121,33 +84,6 @@ public void read(String filename) {
         vrpBuilder.addVehicle(vehicle);
     }
 
-    private void buildShipments() {
-        Integer counter = 0;
-        for (Relation rel : relations) {
-            counter++;
-            String from = rel.from;
-            String to = rel.to;
-            int demand = rel.demand;
-            Shipment s = Shipment.Builder.newInstance(counter.toString()).addSizeDimension(0, demand)
-                .setPickupLocation(Location.Builder.newInstance().setCoordinate(customers.get(from).coord).build()).setPickupServiceTime(customers.get(from).serviceTime)
-                .setPickupTimeWindow(TimeWindow.newInstance(customers.get(from).start, customers.get(from).end))
-                .setDeliveryLocation(Location.Builder.newInstance().setCoordinate(customers.get(to).coord).build()).setDeliveryServiceTime(customers.get(to).serviceTime)
-                .setDeliveryTimeWindow(TimeWindow.newInstance(customers.get(to).start, customers.get(to).end)).build();
-            vrpBuilder.addJob(s);
-        }
-
-    }
-
-    private BufferedReader getReader(String file) {
-        BufferedReader reader = null;
-        try {
-            reader = new BufferedReader(new FileReader(file));
-        } catch (FileNotFoundException e1) {
-            throw new RuntimeException(e1);
-        }
-        return reader;
-    }
-
     private void readShipments(String file) {
         BufferedReader reader = getReader(file);
         String line = null;
@@ -188,6 +124,37 @@ private void readShipments(String file) {
 
     }
 
+    private void buildShipments() {
+        Integer counter = 0;
+        for (Relation rel : relations) {
+            counter++;
+            String from = rel.from;
+            String to = rel.to;
+            int demand = rel.demand;
+            Shipment s = Shipment.Builder.newInstance(counter.toString()).addSizeDimension(0, demand)
+                .setPickupLocation(Location.Builder.newInstance().setCoordinate(customers.get(from).coord).build()).setPickupServiceTime(customers.get(from).serviceTime)
+                .setPickupTimeWindow(TimeWindow.newInstance(customers.get(from).start, customers.get(from).end))
+                .setDeliveryLocation(Location.Builder.newInstance().setCoordinate(customers.get(to).coord).build()).setDeliveryServiceTime(customers.get(to).serviceTime)
+                .setDeliveryTimeWindow(TimeWindow.newInstance(customers.get(to).start, customers.get(to).end)).build();
+            vrpBuilder.addJob(s);
+        }
+
+    }
+
+    private BufferedReader getReader(String file) {
+        BufferedReader reader = null;
+        try {
+            reader = new BufferedReader(new FileReader(file));
+        } catch (FileNotFoundException e1) {
+            throw new RuntimeException(e1);
+        }
+        return reader;
+    }
+
+    private int getInt(String string) {
+        return Integer.parseInt(string);
+    }
+
     private Coordinate makeCoord(String xString, String yString) {
         double x = Double.parseDouble(xString);
         double y = Double.parseDouble(yString);
@@ -198,8 +165,33 @@ private double getDouble(String string) {
         return Double.parseDouble(string);
     }
 
-    private int getInt(String string) {
-        return Integer.parseInt(string);
+    static class CustomerData {
+        public Coordinate coord;
+        public double start;
+        public double end;
+        public double serviceTime;
+
+        public CustomerData(Coordinate coord, double start, double end, double serviceTime) {
+            super();
+            this.coord = coord;
+            this.start = start;
+            this.end = end;
+            this.serviceTime = serviceTime;
+        }
+    }
+
+    static class Relation {
+        public String from;
+        public String to;
+        public int demand;
+
+        public Relation(String from, String to, int demand) {
+            super();
+            this.from = from;
+            this.to = to;
+            this.demand = demand;
+        }
+
     }
 
 
diff --git a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/LopezIbanezBlumReader.java b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/LopezIbanezBlumReader.java
index 411b69ff0..e628904de 100644
--- a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/LopezIbanezBlumReader.java
+++ b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/LopezIbanezBlumReader.java
@@ -45,6 +45,19 @@ public LopezIbanezBlumReader(VehicleRoutingProblem.Builder builder) {
         this.builder = builder;
     }
 
+    public static void main(String[] args) {
+        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
+        new LopezIbanezBlumReader(builder).read("input/Dumas/n20w20.001.txt");
+        VehicleRoutingProblem vrp = builder.build();
+        System.out.println("0->1: " + vrp.getTransportCosts().getTransportCost(Location.newInstance(0), Location.newInstance(1), 0, null, null));
+        System.out.println("0->20: " + vrp.getTransportCosts().getTransportCost(Location.newInstance(0), Location.newInstance(20), 0, null, null));
+        System.out.println("4->18: " + vrp.getTransportCosts().getTransportCost(Location.newInstance(4), Location.newInstance(18), 0, null, null));
+        System.out.println("20->8: " + vrp.getTransportCosts().getTransportCost(Location.newInstance(20), Location.newInstance(8), 0, null, null));
+        System.out.println("18: " + ((Service) vrp.getJobs().get("" + 18)).getTimeWindow().getStart() + " " + ((Service) vrp.getJobs().get("" + 18)).getTimeWindow().getEnd());
+        System.out.println("20: " + ((Service) vrp.getJobs().get("" + 20)).getTimeWindow().getStart() + " " + ((Service) vrp.getJobs().get("" + 20)).getTimeWindow().getEnd());
+        System.out.println("1: " + ((Service) vrp.getJobs().get("" + 1)).getTimeWindow().getStart() + " " + ((Service) vrp.getJobs().get("" + 1)).getTimeWindow().getEnd());
+    }
+
     public void read(String instanceFile) {
         builder.setFleetSize(VehicleRoutingProblem.FleetSize.FINITE);
         BufferedReader reader = getReader(instanceFile);
@@ -87,25 +100,14 @@ public void read(String instanceFile) {
         close(reader);
     }
 
-    public static void main(String[] args) {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-        new LopezIbanezBlumReader(builder).read("input/Dumas/n20w20.001.txt");
-        VehicleRoutingProblem vrp = builder.build();
-        System.out.println("0->1: " + vrp.getTransportCosts().getTransportCost(Location.newInstance(0), Location.newInstance(1), 0, null, null));
-        System.out.println("0->20: " + vrp.getTransportCosts().getTransportCost(Location.newInstance(0), Location.newInstance(20), 0, null, null));
-        System.out.println("4->18: " + vrp.getTransportCosts().getTransportCost(Location.newInstance(4), Location.newInstance(18), 0, null, null));
-        System.out.println("20->8: " + vrp.getTransportCosts().getTransportCost(Location.newInstance(20), Location.newInstance(8), 0, null, null));
-        System.out.println("18: " + ((Service) vrp.getJobs().get("" + 18)).getTimeWindow().getStart() + " " + ((Service) vrp.getJobs().get("" + 18)).getTimeWindow().getEnd());
-        System.out.println("20: " + ((Service) vrp.getJobs().get("" + 20)).getTimeWindow().getStart() + " " + ((Service) vrp.getJobs().get("" + 20)).getTimeWindow().getEnd());
-        System.out.println("1: " + ((Service) vrp.getJobs().get("" + 1)).getTimeWindow().getStart() + " " + ((Service) vrp.getJobs().get("" + 1)).getTimeWindow().getEnd());
-    }
-
-    private void close(BufferedReader reader) {
+    private BufferedReader getReader(String solomonFile) {
+        BufferedReader reader = null;
         try {
-            reader.close();
-        } catch (IOException e) {
-            throw new RuntimeException(e);
+            reader = new BufferedReader(new FileReader(solomonFile));
+        } catch (FileNotFoundException e1) {
+            throw new RuntimeException(e1);
         }
+        return reader;
     }
 
     private String readLine(BufferedReader reader) {
@@ -116,13 +118,11 @@ private String readLine(BufferedReader reader) {
         }
     }
 
-    private BufferedReader getReader(String solomonFile) {
-        BufferedReader reader = null;
+    private void close(BufferedReader reader) {
         try {
-            reader = new BufferedReader(new FileReader(solomonFile));
-        } catch (FileNotFoundException e1) {
-            throw new RuntimeException(e1);
+            reader.close();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
         }
-        return reader;
     }
 }
diff --git a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/LuiShenReader.java b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/LuiShenReader.java
index b6ec812b7..717f7f409 100644
--- a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/LuiShenReader.java
+++ b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/LuiShenReader.java
@@ -96,6 +96,30 @@ public void read(String instanceFile, String vehicleFile, String costScenario) {
         close(reader);
     }
 
+    private BufferedReader getReader(String solomonFile) {
+        BufferedReader reader = null;
+        try {
+            reader = new BufferedReader(new FileReader(solomonFile));
+        } catch (FileNotFoundException e1) {
+            throw new RuntimeException(e1);
+        }
+        return reader;
+    }
+
+    private String readLine(BufferedReader reader) {
+        try {
+            return reader.readLine();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private Coordinate makeCoord(String xString, String yString) {
+        double x = Double.parseDouble(xString);
+        double y = Double.parseDouble(yString);
+        return new Coordinate(x * coordProjectionFactor, y * coordProjectionFactor);
+    }
+
     private void createVehicles(String vehicleFileName, String costScenario, String locationId, Coordinate coord, double start, double end) {
         BufferedReader reader = getReader(vehicleFileName);
 
@@ -131,6 +155,14 @@ private void createVehicles(String vehicleFileName, String costScenario, String
         close(reader);
     }
 
+    private void close(BufferedReader reader) {
+        try {
+            reader.close();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
     private int getCostScenarioColumn(String costScenario) {
         if (costScenario.equals("a")) {
             return 2;
@@ -145,36 +177,4 @@ private int getCostScenarioColumn(String costScenario) {
     public void setCoordProjectionFactor(double coordProjectionFactor) {
         this.coordProjectionFactor = coordProjectionFactor;
     }
-
-    private void close(BufferedReader reader) {
-        try {
-            reader.close();
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    private String readLine(BufferedReader reader) {
-        try {
-            return reader.readLine();
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    private Coordinate makeCoord(String xString, String yString) {
-        double x = Double.parseDouble(xString);
-        double y = Double.parseDouble(yString);
-        return new Coordinate(x * coordProjectionFactor, y * coordProjectionFactor);
-    }
-
-    private BufferedReader getReader(String solomonFile) {
-        BufferedReader reader = null;
-        try {
-            reader = new BufferedReader(new FileReader(solomonFile));
-        } catch (FileNotFoundException e1) {
-            throw new RuntimeException(e1);
-        }
-        return reader;
-    }
 }
diff --git a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/SolomonReader.java b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/SolomonReader.java
index 04f54de9f..29f93b98c 100644
--- a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/SolomonReader.java
+++ b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/SolomonReader.java
@@ -45,23 +45,11 @@
 
 public class SolomonReader {
 
-    /**
-     * @param costProjectionFactor the costProjectionFactor to set
-     */
-    public void setVariableCostProjectionFactor(double costProjectionFactor) {
-        this.variableCostProjectionFactor = costProjectionFactor;
-    }
-
     private static Logger logger = LoggerFactory.getLogger(SolomonReader.class);
-
     private final VehicleRoutingProblem.Builder vrpBuilder;
-
     private double coordProjectionFactor = 1;
-
     private double timeProjectionFactor = 1;
-
     private double variableCostProjectionFactor = 1;
-
     private double fixedCostPerVehicle = 0.0;
 
     public SolomonReader(VehicleRoutingProblem.Builder vrpBuilder) {
@@ -75,6 +63,13 @@ public SolomonReader(VehicleRoutingProblem.Builder vrpBuilder, double fixedCostP
         this.fixedCostPerVehicle = fixedCostPerVehicle;
     }
 
+    /**
+     * @param costProjectionFactor the costProjectionFactor to set
+     */
+    public void setVariableCostProjectionFactor(double costProjectionFactor) {
+        this.variableCostProjectionFactor = costProjectionFactor;
+    }
+
     public void read(String solomonFile) {
         vrpBuilder.setFleetSize(FleetSize.INFINITE);
         BufferedReader reader = getReader(solomonFile);
@@ -120,16 +115,14 @@ public void read(String solomonFile) {
         close(reader);
     }
 
-    public void setCoordProjectionFactor(double coordProjectionFactor) {
-        this.coordProjectionFactor = coordProjectionFactor;
-    }
-
-    private void close(BufferedReader reader) {
+    private BufferedReader getReader(String solomonFile) {
+        BufferedReader reader = null;
         try {
-            reader.close();
-        } catch (IOException e) {
-            throw new RuntimeException(e);
+            reader = new BufferedReader(new FileReader(solomonFile));
+        } catch (FileNotFoundException e1) {
+            throw new RuntimeException(e1);
         }
+        return reader;
     }
 
     private String readLine(BufferedReader reader) {
@@ -146,14 +139,16 @@ private Coordinate makeCoord(String xString, String yString) {
         return new Coordinate(x * coordProjectionFactor, y * coordProjectionFactor);
     }
 
-    private BufferedReader getReader(String solomonFile) {
-        BufferedReader reader = null;
+    private void close(BufferedReader reader) {
         try {
-            reader = new BufferedReader(new FileReader(solomonFile));
-        } catch (FileNotFoundException e1) {
-            throw new RuntimeException(e1);
+            reader.close();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
         }
-        return reader;
+    }
+
+    public void setCoordProjectionFactor(double coordProjectionFactor) {
+        this.coordProjectionFactor = coordProjectionFactor;
     }
 
     public void setTimeProjectionFactor(double timeProjection) {
diff --git a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/TSPLIB95CostMatrixReader.java b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/TSPLIB95CostMatrixReader.java
index 416951621..0111dbb35 100644
--- a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/TSPLIB95CostMatrixReader.java
+++ b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/TSPLIB95CostMatrixReader.java
@@ -60,12 +60,14 @@ public void read(String matrixFile) {
         close(reader);
     }
 
-    private void close(BufferedReader reader) {
+    private BufferedReader getBufferedReader(String filename) {
+        BufferedReader bufferedReader = null;
         try {
-            reader.close();
-        } catch (IOException e) {
+            bufferedReader = new BufferedReader(new FileReader(new File(filename)));
+        } catch (FileNotFoundException e) {
             e.printStackTrace();
         }
+        return bufferedReader;
     }
 
     private String getLine(BufferedReader reader) {
@@ -78,13 +80,11 @@ private String getLine(BufferedReader reader) {
         return s;
     }
 
-    private BufferedReader getBufferedReader(String filename) {
-        BufferedReader bufferedReader = null;
+    private void close(BufferedReader reader) {
         try {
-            bufferedReader = new BufferedReader(new FileReader(new File(filename)));
-        } catch (FileNotFoundException e) {
+            reader.close();
+        } catch (IOException e) {
             e.printStackTrace();
         }
-        return bufferedReader;
     }
 }
diff --git a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/TSPLIB95Reader.java b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/TSPLIB95Reader.java
index abeeea31a..6f1c23d68 100644
--- a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/TSPLIB95Reader.java
+++ b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/TSPLIB95Reader.java
@@ -42,14 +42,14 @@
 
     private boolean switchCoordinates = false;
 
-    public void setSwitchCoordinates(boolean switchCoordinates) {
-        this.switchCoordinates = switchCoordinates;
-    }
-
     public TSPLIB95Reader(VehicleRoutingProblem.Builder vrpBuilder) {
         this.vrpBuilder = vrpBuilder;
     }
 
+    public void setSwitchCoordinates(boolean switchCoordinates) {
+        this.switchCoordinates = switchCoordinates;
+    }
+
     public void read(String filename) {
         BufferedReader reader = getBufferedReader(filename);
         String line_;
@@ -263,6 +263,35 @@ public void read(String filename) {
 
     }
 
+    private BufferedReader getBufferedReader(String filename) {
+        BufferedReader bufferedReader = null;
+        try {
+            bufferedReader = new BufferedReader(new FileReader(new File(filename)));
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        }
+        return bufferedReader;
+    }
+
+    private String getLine(BufferedReader reader) {
+        String s = null;
+        try {
+            s = reader.readLine();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return s;
+    }
+
+    private void close(BufferedReader reader) {
+        try {
+            reader.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        ;
+    }
+
     private VehicleRoutingTransportCosts getGEOMatrix(List<Location> noLocations) {
         FastVehicleRoutingTransportCostsMatrix.Builder matrixBuilder = FastVehicleRoutingTransportCostsMatrix.Builder.newInstance(noLocations.size(), true);
         for (Location i : noLocations) {
@@ -285,45 +314,15 @@ private double getDistance(Location from, Location to) {
         return 6378.388 * Math.acos(.5 * ((1. + q1) * q2 - (1. - q1) * q3)) + 1.;
     }
 
-    private double getLatitude(Location loc) {
-        int deg = (int) loc.getCoordinate().getX();
-        double min = loc.getCoordinate().getX() - deg;
-        return Math.PI * (deg + 5. * min / 3.) / 180.;
-    }
-
     private double getLongitude(Location loc) {
         int deg = (int) loc.getCoordinate().getY();
         double min = loc.getCoordinate().getY() - deg;
         return Math.PI * (deg + 5. * min / 3.) / 180.;
     }
 
-
-    private void close(BufferedReader reader) {
-        try {
-            reader.close();
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-        ;
-    }
-
-    private String getLine(BufferedReader reader) {
-        String s = null;
-        try {
-            s = reader.readLine();
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-        return s;
-    }
-
-    private BufferedReader getBufferedReader(String filename) {
-        BufferedReader bufferedReader = null;
-        try {
-            bufferedReader = new BufferedReader(new FileReader(new File(filename)));
-        } catch (FileNotFoundException e) {
-            e.printStackTrace();
-        }
-        return bufferedReader;
+    private double getLatitude(Location loc) {
+        int deg = (int) loc.getCoordinate().getX();
+        double min = loc.getCoordinate().getX() - deg;
+        return Math.PI * (deg + 5. * min / 3.) / 180.;
     }
 }
diff --git a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/VrphGoldenReader.java b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/VrphGoldenReader.java
index 9a7d4697b..79d32b764 100644
--- a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/VrphGoldenReader.java
+++ b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/VrphGoldenReader.java
@@ -40,25 +40,7 @@
  */
 public class VrphGoldenReader {
 
-    /**
-     * <b>FSMD</b> - Fleet Size and Mix with Dependent costs
-     * <p><b>FSMF</b> - Fleet Size and Mix with Fixed costs
-     * <p><b>FSMFD</b> - Fleet Size and Mix with Fixed and Dependent costs
-     * <p><b>HVRPD</b> - Heterogeneous Vehicle Routing Problem with Dependent costs and finite (limited) fleet
-     * <p><b>HVRPFD</b> - Heterogeneous Vehicle Routing Problem with Fixed and Dependent costs and finite (limited) fleet
-     *
-     * @author schroeder
-     */
-    public enum VrphType {
-        FSMD,
-        HVRPD,
-        FSMF,
-        FSMFD,
-        HVRPFD
-    }
-
     private final VehicleRoutingProblem.Builder vrpBuilder;
-
     private final VrphType vrphType;
 
     public VrphGoldenReader(Builder vrpBuilder, VrphType vrphType) {
@@ -134,10 +116,12 @@ public void read(String filename) {
         closeReader(reader);
     }
 
-    private void closeReader(BufferedReader reader) {
+    private BufferedReader getReader(String filename) {
+        BufferedReader bufferedReader = null;
         try {
-            reader.close();
-        } catch (IOException e) {
+            bufferedReader = new BufferedReader(new FileReader(new File(filename)));
+            return bufferedReader;
+        } catch (FileNotFoundException e) {
             throw new RuntimeException(e);
         }
     }
@@ -152,16 +136,30 @@ private String readLine(BufferedReader reader) {
         return readLine;
     }
 
-    private BufferedReader getReader(String filename) {
-        BufferedReader bufferedReader = null;
+    private void closeReader(BufferedReader reader) {
         try {
-            bufferedReader = new BufferedReader(new FileReader(new File(filename)));
-            return bufferedReader;
-        } catch (FileNotFoundException e) {
+            reader.close();
+        } catch (IOException e) {
             throw new RuntimeException(e);
         }
     }
 
+    /**
+     * <b>FSMD</b> - Fleet Size and Mix with Dependent costs
+     * <p><b>FSMF</b> - Fleet Size and Mix with Fixed costs
+     * <p><b>FSMFD</b> - Fleet Size and Mix with Fixed and Dependent costs
+     * <p><b>HVRPD</b> - Heterogeneous Vehicle Routing Problem with Dependent costs and finite (limited) fleet
+     * <p><b>HVRPFD</b> - Heterogeneous Vehicle Routing Problem with Fixed and Dependent costs and finite (limited) fleet
+     *
+     * @author schroeder
+     */
+    public enum VrphType {
+        FSMD,
+        HVRPD,
+        FSMF,
+        FSMFD,
+        HVRPFD
+    }
 
 
 }
diff --git a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/util/Instances.java b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/util/Instances.java
index aaaf1d041..28c7c3d17 100644
--- a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/util/Instances.java
+++ b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/util/Instances.java
@@ -52,6 +52,10 @@
         return instances;
     }
 
+    private static String getInstanceNu(int i) {
+        if (i < 10) return "0" + i;
+        return "" + i;
+    }
 
     private static double getBestKnown(String file) {
         try {
@@ -68,11 +72,6 @@ private static double getBestKnown(String file) {
         return 0;
     }
 
-    private static String getInstanceNu(int i) {
-        if (i < 10) return "0" + i;
-        return "" + i;
-    }
-
     /**
      * Returns a collection of {@link BenchmarkInstance} which are Cordeau's pr instances.
      * <p>Note that this assumes that within the folder 'inputFolder' 10 p-instances are located with their original name, i.e. pr01,pr02,...,pr10.
diff --git a/jsprit-instances/src/test/java/com/graphhopper/jsprit/instance/reader/BelhaizaReaderTest.java b/jsprit-instances/src/test/java/com/graphhopper/jsprit/instance/reader/BelhaizaReaderTest.java
index 39ce8a17a..fa9a7c706 100644
--- a/jsprit-instances/src/test/java/com/graphhopper/jsprit/instance/reader/BelhaizaReaderTest.java
+++ b/jsprit-instances/src/test/java/com/graphhopper/jsprit/instance/reader/BelhaizaReaderTest.java
@@ -38,157 +38,157 @@
 
 public class BelhaizaReaderTest {
 
-	@Test
-	public void whenReadingBelhaizaInstance_nuOfCustomersIsCorrect(){
-		VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-		new BelhaizaReader(builder).read(getPath());
-		VehicleRoutingProblem vrp = builder.build();
-		assertEquals(100,vrp.getJobs().values().size());
-	}
-
-	private String getPath() {
-		URL resource = getClass().getClassLoader().getResource("cm101.txt");
-		if(resource == null) throw new IllegalStateException("file C101_solomon.txt does not exist");
-		return resource.getPath();
-	}
-
-	@Test
-	public void whenReadingBelhaizaInstance_fleetSizeIsInfinite(){
-		VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-		new BelhaizaReader(builder).read(getPath());
-		VehicleRoutingProblem vrp = builder.build();
-		assertEquals(FleetSize.INFINITE,vrp.getFleetSize());
-	}
-
-	@Test
-	public void whenReadingBelhaizaInstance_vehicleCapacitiesAreCorrect(){
-		VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-		new BelhaizaReader(builder).read(getPath());
-		VehicleRoutingProblem vrp = builder.build();
-		for(Vehicle v : vrp.getVehicles()){
-			assertEquals(200,v.getType().getCapacityDimensions().get(0));
-		}
-	}
-
-	@Test
-	public void whenReadingBelhaizaInstance_vehicleLocationsAreCorrect_and_correspondToDepotLocation(){
-		VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-		new BelhaizaReader(builder).read(getPath());
-		VehicleRoutingProblem vrp = builder.build();
-		for(Vehicle v : vrp.getVehicles()){
-			assertEquals(40.0,v.getStartLocation().getCoordinate().getX(),0.01);
-			assertEquals(50.0,v.getStartLocation().getCoordinate().getY(),0.01);
-		}
-	}
-
-	@Test
-	public void whenReadingBelhaizaInstance_demandOfCustomerOneIsCorrect(){
-		VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-		new BelhaizaReader(builder).read(getPath());
-		VehicleRoutingProblem vrp = builder.build();
-		assertEquals(10,vrp.getJobs().get("1").getSize().get(0));
-	}
-
-	@Test
-	public void whenReadingBelhaizaInstance_serviceDurationOfCustomerTwoIsCorrect(){
-		VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-		new BelhaizaReader(builder).read(getPath());
-		VehicleRoutingProblem vrp = builder.build();
-		assertEquals(90,((Service)vrp.getJobs().get("2")).getServiceDuration(),0.1);
-	}
-
-	@Test
-	public void noTimeWindowsShouldBeCorrect(){
-		VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-		new BelhaizaReader(builder).read(getPath());
-		VehicleRoutingProblem vrp = builder.build();
-		assertEquals(5,((Service)vrp.getJobs().get("1")).getTimeWindows().size());
-	}
-
-	@Test
-	public void noTimeWindowsShouldBeCorrect2(){
-		VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-		new BelhaizaReader(builder).read(getPath());
-		VehicleRoutingProblem vrp = builder.build();
-		assertEquals(10,((Service)vrp.getJobs().get("2")).getTimeWindows().size());
-	}
-
-	@Test
-	public void firstTimeWindowShouldBeCorrect(){
-		VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-		new BelhaizaReader(builder).read(getPath());
-		VehicleRoutingProblem vrp = builder.build();
-		assertEquals(20.,((Service)vrp.getJobs().get("1")).getTimeWindows().iterator().next().getStart(),0.1);
-		assertEquals(31.,((Service)vrp.getJobs().get("1")).getTimeWindows().iterator().next().getEnd(),0.1);
-	}
-
-	@Test
-	public void secondTimeWindowShouldBeCorrect(){
-		VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-		new BelhaizaReader(builder).read(getPath());
-		VehicleRoutingProblem vrp = builder.build();
-		List<TimeWindow> timeWindows = new ArrayList<TimeWindow>(((Service)vrp.getJobs().get("1")).getTimeWindows());
-		assertEquals(118.,timeWindows.get(1).getStart(),0.1);
-		assertEquals(148.,timeWindows.get(1).getEnd(),0.1);
-	}
-
-	@Test
-	public void thirdTimeWindowShouldBeCorrect(){
-		VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-		new BelhaizaReader(builder).read(getPath());
-		VehicleRoutingProblem vrp = builder.build();
-		List<TimeWindow> timeWindows = new ArrayList<TimeWindow>(((Service)vrp.getJobs().get("1")).getTimeWindows());
-		assertEquals(235.,timeWindows.get(2).getStart(),0.1);
-		assertEquals(258.,timeWindows.get(2).getEnd(),0.1);
-	}
-
-	@Test
-	public void fourthTimeWindowShouldBeCorrect(){
-		VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-		new BelhaizaReader(builder).read(getPath());
-		VehicleRoutingProblem vrp = builder.build();
-		List<TimeWindow> timeWindows = new ArrayList<TimeWindow>(((Service)vrp.getJobs().get("1")).getTimeWindows());
-		assertEquals(343.,timeWindows.get(3).getStart(),0.1);
-		assertEquals(355.,timeWindows.get(3).getEnd(),0.1);
-	}
-
-	@Test
-	public void fifthTimeWindowShouldBeCorrect(){
-		VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-		new BelhaizaReader(builder).read(getPath());
-		VehicleRoutingProblem vrp = builder.build();
-		List<TimeWindow> timeWindows = new ArrayList<TimeWindow>(((Service)vrp.getJobs().get("1")).getTimeWindows());
-		assertEquals(441.,timeWindows.get(4).getStart(),0.1);
-		assertEquals(457.,timeWindows.get(4).getEnd(),0.1);
-	}
-
-	@Test
-	public void testAlgo(){
-		VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-		new BelhaizaReader(builder).read(getPath());
-		builder.setFleetSize(FleetSize.FINITE);
-		VehicleRoutingProblem vrp = builder.build();
+    @Test
+    public void whenReadingBelhaizaInstance_nuOfCustomersIsCorrect() {
+        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
+        new BelhaizaReader(builder).read(getPath());
+        VehicleRoutingProblem vrp = builder.build();
+        assertEquals(100, vrp.getJobs().values().size());
+    }
+
+    private String getPath() {
+        URL resource = getClass().getClassLoader().getResource("cm101.txt");
+        if (resource == null) throw new IllegalStateException("file C101_solomon.txt does not exist");
+        return resource.getPath();
+    }
+
+    @Test
+    public void whenReadingBelhaizaInstance_fleetSizeIsInfinite() {
+        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
+        new BelhaizaReader(builder).read(getPath());
+        VehicleRoutingProblem vrp = builder.build();
+        assertEquals(FleetSize.INFINITE, vrp.getFleetSize());
+    }
+
+    @Test
+    public void whenReadingBelhaizaInstance_vehicleCapacitiesAreCorrect() {
+        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
+        new BelhaizaReader(builder).read(getPath());
+        VehicleRoutingProblem vrp = builder.build();
+        for (Vehicle v : vrp.getVehicles()) {
+            assertEquals(200, v.getType().getCapacityDimensions().get(0));
+        }
+    }
+
+    @Test
+    public void whenReadingBelhaizaInstance_vehicleLocationsAreCorrect_and_correspondToDepotLocation() {
+        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
+        new BelhaizaReader(builder).read(getPath());
+        VehicleRoutingProblem vrp = builder.build();
+        for (Vehicle v : vrp.getVehicles()) {
+            assertEquals(40.0, v.getStartLocation().getCoordinate().getX(), 0.01);
+            assertEquals(50.0, v.getStartLocation().getCoordinate().getY(), 0.01);
+        }
+    }
+
+    @Test
+    public void whenReadingBelhaizaInstance_demandOfCustomerOneIsCorrect() {
+        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
+        new BelhaizaReader(builder).read(getPath());
+        VehicleRoutingProblem vrp = builder.build();
+        assertEquals(10, vrp.getJobs().get("1").getSize().get(0));
+    }
+
+    @Test
+    public void whenReadingBelhaizaInstance_serviceDurationOfCustomerTwoIsCorrect() {
+        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
+        new BelhaizaReader(builder).read(getPath());
+        VehicleRoutingProblem vrp = builder.build();
+        assertEquals(90, ((Service) vrp.getJobs().get("2")).getServiceDuration(), 0.1);
+    }
+
+    @Test
+    public void noTimeWindowsShouldBeCorrect() {
+        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
+        new BelhaizaReader(builder).read(getPath());
+        VehicleRoutingProblem vrp = builder.build();
+        assertEquals(5, ((Service) vrp.getJobs().get("1")).getTimeWindows().size());
+    }
+
+    @Test
+    public void noTimeWindowsShouldBeCorrect2() {
+        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
+        new BelhaizaReader(builder).read(getPath());
+        VehicleRoutingProblem vrp = builder.build();
+        assertEquals(10, ((Service) vrp.getJobs().get("2")).getTimeWindows().size());
+    }
+
+    @Test
+    public void firstTimeWindowShouldBeCorrect() {
+        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
+        new BelhaizaReader(builder).read(getPath());
+        VehicleRoutingProblem vrp = builder.build();
+        assertEquals(20., ((Service) vrp.getJobs().get("1")).getTimeWindows().iterator().next().getStart(), 0.1);
+        assertEquals(31., ((Service) vrp.getJobs().get("1")).getTimeWindows().iterator().next().getEnd(), 0.1);
+    }
+
+    @Test
+    public void secondTimeWindowShouldBeCorrect() {
+        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
+        new BelhaizaReader(builder).read(getPath());
+        VehicleRoutingProblem vrp = builder.build();
+        List<TimeWindow> timeWindows = new ArrayList<TimeWindow>(((Service) vrp.getJobs().get("1")).getTimeWindows());
+        assertEquals(118., timeWindows.get(1).getStart(), 0.1);
+        assertEquals(148., timeWindows.get(1).getEnd(), 0.1);
+    }
+
+    @Test
+    public void thirdTimeWindowShouldBeCorrect() {
+        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
+        new BelhaizaReader(builder).read(getPath());
+        VehicleRoutingProblem vrp = builder.build();
+        List<TimeWindow> timeWindows = new ArrayList<TimeWindow>(((Service) vrp.getJobs().get("1")).getTimeWindows());
+        assertEquals(235., timeWindows.get(2).getStart(), 0.1);
+        assertEquals(258., timeWindows.get(2).getEnd(), 0.1);
+    }
+
+    @Test
+    public void fourthTimeWindowShouldBeCorrect() {
+        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
+        new BelhaizaReader(builder).read(getPath());
+        VehicleRoutingProblem vrp = builder.build();
+        List<TimeWindow> timeWindows = new ArrayList<TimeWindow>(((Service) vrp.getJobs().get("1")).getTimeWindows());
+        assertEquals(343., timeWindows.get(3).getStart(), 0.1);
+        assertEquals(355., timeWindows.get(3).getEnd(), 0.1);
+    }
+
+    @Test
+    public void fifthTimeWindowShouldBeCorrect() {
+        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
+        new BelhaizaReader(builder).read(getPath());
+        VehicleRoutingProblem vrp = builder.build();
+        List<TimeWindow> timeWindows = new ArrayList<TimeWindow>(((Service) vrp.getJobs().get("1")).getTimeWindows());
+        assertEquals(441., timeWindows.get(4).getStart(), 0.1);
+        assertEquals(457., timeWindows.get(4).getEnd(), 0.1);
+    }
+
+    @Test
+    public void testAlgo() {
+        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
+        new BelhaizaReader(builder).read(getPath());
+        builder.setFleetSize(FleetSize.FINITE);
+        VehicleRoutingProblem vrp = builder.build();
 
 //		VehicleRoutingAlgorithm vra = Jsprit.createAlgorithm(vrp);
 
 //		VehicleRoutingAlgorithm algorithm = new SchrimpfFactory().createAlgorithm(vrp);
 
-		Jsprit.Builder vraBuilder = Jsprit.Builder.newInstance(vrp);
-		vraBuilder.setProperty(Jsprit.Strategy.CLUSTER_REGRET, "0.25");
-		vraBuilder.setProperty(Jsprit.Strategy.RADIAL_REGRET, "0.25");
-		vraBuilder.setProperty(Jsprit.Strategy.RANDOM_REGRET, "0.");
-		vraBuilder.setProperty(Jsprit.Strategy.WORST_REGRET, "0.25");
-		vraBuilder.setProperty(Jsprit.Parameter.THRESHOLD_INI, "0.05");
-		VehicleRoutingAlgorithm algorithm = vraBuilder.buildAlgorithm();
-		algorithm.setMaxIterations(5000);
+        Jsprit.Builder vraBuilder = Jsprit.Builder.newInstance(vrp);
+        vraBuilder.setProperty(Jsprit.Strategy.CLUSTER_REGRET, "0.25");
+        vraBuilder.setProperty(Jsprit.Strategy.RADIAL_REGRET, "0.25");
+        vraBuilder.setProperty(Jsprit.Strategy.RANDOM_REGRET, "0.");
+        vraBuilder.setProperty(Jsprit.Strategy.WORST_REGRET, "0.25");
+        vraBuilder.setProperty(Jsprit.Parameter.THRESHOLD_INI, "0.05");
+        VehicleRoutingAlgorithm algorithm = vraBuilder.buildAlgorithm();
+        algorithm.setMaxIterations(5000);
 //		VariationCoefficientTermination variation_coefficient = new VariationCoefficientTermination(200, 0.005);
 //		algorithm.setPrematureAlgorithmTermination(variation_coefficient);
 //		algorithm.addListener(variation_coefficient);
 
 //		vra.setMaxIterations(5000);
-		VehicleRoutingProblemSolution solution = Solutions.bestOf(algorithm.searchSolutions());
+        VehicleRoutingProblemSolution solution = Solutions.bestOf(algorithm.searchSolutions());
 
-		SolutionPrinter.print(vrp,solution, SolutionPrinter.Print.VERBOSE);
-	}
+        SolutionPrinter.print(vrp, solution, SolutionPrinter.Print.VERBOSE);
+    }
 
 }
diff --git a/jsprit-instances/src/test/java/com/graphhopper/jsprit/instance/reader/GoldenReaderTest.java b/jsprit-instances/src/test/java/com/graphhopper/jsprit/instance/reader/GoldenReaderTest.java
index a78ec5331..574698f2b 100644
--- a/jsprit-instances/src/test/java/com/graphhopper/jsprit/instance/reader/GoldenReaderTest.java
+++ b/jsprit-instances/src/test/java/com/graphhopper/jsprit/instance/reader/GoldenReaderTest.java
@@ -254,6 +254,11 @@ public void whenReadingInstance_service1MustHaveCorrectDemand() {
         assertEquals(18, job.getSize().get(0));
     }
 
+    private Coordinate getCoord(String string, VehicleRoutingProblem vrp) {
+        Job j = getJob(string, vrp);
+        return ((Service) j).getLocation().getCoordinate();
+    }
+
     @Test
     public void whenReadingInstance_service1MustHaveCorrectCoordinate() {
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
@@ -265,6 +270,15 @@ public void whenReadingInstance_service1MustHaveCorrectCoordinate() {
         assertEquals(22.0, coord.getY(), 0.01);
     }
 
+    private Job getJob(String string, VehicleRoutingProblem vrp) {
+        for (Job j : vrp.getJobs().values()) {
+            if (j.getId().equals(string)) {
+                return j;
+            }
+        }
+        return null;
+    }
+
     @Test
     public void whenReadingInstance_service15MustHaveCorrectCoordinate() {
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
@@ -276,7 +290,6 @@ public void whenReadingInstance_service15MustHaveCorrectCoordinate() {
         assertEquals(24.0, coord.getY(), 0.01);
     }
 
-
     @Test
     public void whenReadingInstance_service50MustHaveCorrectCoordinate() {
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
@@ -288,11 +301,6 @@ public void whenReadingInstance_service50MustHaveCorrectCoordinate() {
         assertEquals(56.0, coord.getY(), 0.01);
     }
 
-    private Coordinate getCoord(String string, VehicleRoutingProblem vrp) {
-        Job j = getJob(string, vrp);
-        return ((Service) j).getLocation().getCoordinate();
-    }
-
     @Test
     public void whenReadingInstance_service4MustHaveCorrectDemand() {
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
@@ -313,14 +321,5 @@ public void whenReadingInstance_service50MustHaveCorrectDemand() {
         assertEquals(22, job.getSize().get(0));
     }
 
-    private Job getJob(String string, VehicleRoutingProblem vrp) {
-        for (Job j : vrp.getJobs().values()) {
-            if (j.getId().equals(string)) {
-                return j;
-            }
-        }
-        return null;
-    }
-
 
 }
diff --git a/jsprit-io/pom.xml b/jsprit-io/pom.xml
index 1886f762c..031738059 100644
--- a/jsprit-io/pom.xml
+++ b/jsprit-io/pom.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://maven.apache.org/POM/4.0.0"
          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <parent>
         <groupId>com.graphhopper</groupId>
diff --git a/jsprit-io/src/main/java/com/graphhopper/jsprit/io/algorithm/AlgorithmConfigXmlReader.java b/jsprit-io/src/main/java/com/graphhopper/jsprit/io/algorithm/AlgorithmConfigXmlReader.java
index 57b26fdc0..237455d93 100644
--- a/jsprit-io/src/main/java/com/graphhopper/jsprit/io/algorithm/AlgorithmConfigXmlReader.java
+++ b/jsprit-io/src/main/java/com/graphhopper/jsprit/io/algorithm/AlgorithmConfigXmlReader.java
@@ -38,6 +38,10 @@
 
     private boolean schemaValidation = true;
 
+    public AlgorithmConfigXmlReader(AlgorithmConfig algorithmConfig) {
+        this.algorithmConfig = algorithmConfig;
+    }
+
     /**
      * @param schemaValidation the schemaValidation to set
      */
@@ -46,8 +50,10 @@ public AlgorithmConfigXmlReader setSchemaValidation(boolean schemaValidation) {
         return this;
     }
 
-    public AlgorithmConfigXmlReader(AlgorithmConfig algorithmConfig) {
-        this.algorithmConfig = algorithmConfig;
+    public void read(String filename) {
+        log.debug("read algorithm-config from file " + filename);
+        URL url = Resource.getAsURL(filename);
+        read(url);
     }
 
     public void read(URL url) {
@@ -82,11 +88,4 @@ public InputSource resolveEntity(String publicId, String systemId) throws SAXExc
         }
     }
 
-
-    public void read(String filename) {
-        log.debug("read algorithm-config from file " + filename);
-        URL url = Resource.getAsURL(filename);
-        read(url);
-    }
-
 }
diff --git a/jsprit-io/src/main/java/com/graphhopper/jsprit/io/algorithm/VehicleRoutingAlgorithms.java b/jsprit-io/src/main/java/com/graphhopper/jsprit/io/algorithm/VehicleRoutingAlgorithms.java
index 07ebaa979..71b513000 100644
--- a/jsprit-io/src/main/java/com/graphhopper/jsprit/io/algorithm/VehicleRoutingAlgorithms.java
+++ b/jsprit-io/src/main/java/com/graphhopper/jsprit/io/algorithm/VehicleRoutingAlgorithms.java
@@ -26,12 +26,7 @@
 import com.graphhopper.jsprit.core.algorithm.module.RuinAndRecreateModule;
 import com.graphhopper.jsprit.core.algorithm.recreate.InsertionStrategy;
 import com.graphhopper.jsprit.core.algorithm.recreate.listener.InsertionListener;
-import com.graphhopper.jsprit.core.algorithm.ruin.ClusterRuinStrategyFactory;
-import com.graphhopper.jsprit.core.algorithm.ruin.JobNeighborhoods;
-import com.graphhopper.jsprit.core.algorithm.ruin.JobNeighborhoodsFactory;
-import com.graphhopper.jsprit.core.algorithm.ruin.RadialRuinStrategyFactory;
-import com.graphhopper.jsprit.core.algorithm.ruin.RandomRuinStrategyFactory;
-import com.graphhopper.jsprit.core.algorithm.ruin.RuinStrategy;
+import com.graphhopper.jsprit.core.algorithm.ruin.*;
 import com.graphhopper.jsprit.core.algorithm.ruin.distance.AvgServiceAndShipmentDistance;
 import com.graphhopper.jsprit.core.algorithm.ruin.distance.JobDistance;
 import com.graphhopper.jsprit.core.algorithm.selector.SelectBest;
@@ -68,307 +63,490 @@
 
 public class VehicleRoutingAlgorithms {
 
-    static class TypedMap {
-
-        static interface AbstractKey<K> {
-
-            Class<K> getType();
-        }
-
-        static class AcceptorKey implements AbstractKey<SolutionAcceptor> {
-
-            private ModKey modKey;
+    private static Logger log = LoggerFactory.getLogger(VehicleRoutingAlgorithms.class.getName());
 
-            public AcceptorKey(ModKey modKey) {
-                super();
-                this.modKey = modKey;
-            }
+    private VehicleRoutingAlgorithms() {
+    }
 
+    /**
+     * Creates a {@link com.graphhopper.jsprit.core.algorithm.VehicleRoutingAlgorithm} from a AlgorithConfig based on the input vrp.
+     *
+     * @param vrp             the routing problem
+     * @param algorithmConfig the algorithm config
+     * @return {@link com.graphhopper.jsprit.core.algorithm.VehicleRoutingAlgorithm}
+     */
+    public static VehicleRoutingAlgorithm createAlgorithm(final VehicleRoutingProblem vrp, final AlgorithmConfig algorithmConfig) {
+        return createAlgo(vrp, algorithmConfig.getXMLConfiguration(), 0, null);
+    }
 
-            @Override
-            public int hashCode() {
-                final int prime = 31;
-                int result = 1;
-                result = prime * result
-                    + ((modKey == null) ? 0 : modKey.hashCode());
-                return result;
-            }
+    public static VehicleRoutingAlgorithm createAlgorithm(final VehicleRoutingProblem vrp, int nThreads, final AlgorithmConfig algorithmConfig) {
+        return createAlgo(vrp, algorithmConfig.getXMLConfiguration(), nThreads, null);
+    }
 
+    private static VehicleRoutingAlgorithm createAlgo(final VehicleRoutingProblem vrp, XMLConfiguration config, int nuOfThreads, StateManager stateMan) {
+        //create state-manager
+        final StateManager stateManager;
+        if (stateMan != null) {
+            stateManager = stateMan;
+        } else {
+            stateManager = new StateManager(vrp);
+        }
+        stateManager.updateLoadStates();
+        stateManager.updateTimeWindowStates();
+        stateManager.updateSkillStates();
+        stateManager.addStateUpdater(new UpdateEndLocationIfRouteIsOpen());
+        stateManager.addStateUpdater(new OpenRouteStateVerifier());
+//		stateManager.addStateUpdater(new UpdateActivityTimes(vrp.getTransportCosts()));
+//		stateManager.addStateUpdater(new UpdateVariableCosts(vrp.getActivityCosts(), vrp.getTransportCosts(), stateManager));
 
-            @Override
-            public boolean equals(Object obj) {
-                if (this == obj)
-                    return true;
-                if (obj == null)
-                    return false;
-                if (!(obj instanceof AcceptorKey))
-                    return false;
-                AcceptorKey other = (AcceptorKey) obj;
-                if (modKey == null) {
-                    if (other.modKey != null)
-                        return false;
-                } else if (!modKey.equals(other.modKey))
-                    return false;
-                return true;
-            }
+        /*
+         * define constraints
+         */
+        //constraint manager
+        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
+        constraintManager.addTimeWindowConstraint();
+        constraintManager.addLoadConstraint();
+        constraintManager.addSkillsConstraint();
+        constraintManager.addConstraint(new SwitchNotFeasible(stateManager));
 
+        return readAndCreateAlgorithm(vrp, config, nuOfThreads, null, stateManager, constraintManager, true, true);
+    }
 
-            @Override
-            public Class<SolutionAcceptor> getType() {
-                return SolutionAcceptor.class;
-            }
+    private static VehicleFleetManager createFleetManager(final VehicleRoutingProblem vrp) {
+        if (vrp.getFleetSize().equals(FleetSize.INFINITE)) {
+            return new InfiniteFleetManagerFactory(vrp.getVehicles()).createFleetManager();
 
+        } else if (vrp.getFleetSize().equals(FleetSize.FINITE)) {
+            return new FiniteFleetManagerFactory(vrp.getVehicles()).createFleetManager();
         }
+        throw new IllegalStateException("fleet size can only be infinite or finite. " +
+            "makes sure your config file contains one of these options");
+    }
 
-        static class SelectorKey implements AbstractKey<SolutionSelector> {
+    private static VehicleRoutingAlgorithm readAndCreateAlgorithm(final VehicleRoutingProblem vrp, XMLConfiguration config,
+                                                                  int nuOfThreads, final SolutionCostCalculator solutionCostCalculator, final StateManager stateManager, ConstraintManager constraintManager, boolean addDefaultCostCalculators, boolean addCoreConstraints) {
+        // map to store constructed modules
+        TypedMap definedClasses = new TypedMap();
 
-            private ModKey modKey;
+        // algorithm listeners
+        Set<PrioritizedVRAListener> algorithmListeners = new HashSet<PrioritizedVRAListener>();
 
-            public SelectorKey(ModKey modKey) {
-                super();
-                this.modKey = modKey;
-            }
+        // insertion listeners
+        List<InsertionListener> insertionListeners = new ArrayList<InsertionListener>();
 
-            @Override
-            public int hashCode() {
-                final int prime = 31;
-                int result = 1;
-                result = prime * result
-                    + ((modKey == null) ? 0 : modKey.hashCode());
-                return result;
-            }
 
-            @Override
-            public boolean equals(Object obj) {
-                if (this == obj)
-                    return true;
-                if (obj == null)
-                    return false;
-                if (getClass() != obj.getClass())
-                    return false;
-                SelectorKey other = (SelectorKey) obj;
-                if (modKey == null) {
-                    if (other.modKey != null)
-                        return false;
-                } else if (!modKey.equals(other.modKey))
-                    return false;
-                return true;
-            }
+        //threading
+        final ExecutorService executorService;
+        if (nuOfThreads > 0) {
+            log.debug("setup executor-service with " + nuOfThreads + " threads");
+            executorService = Executors.newFixedThreadPool(nuOfThreads);
+            algorithmListeners.add(new PrioritizedVRAListener(Priority.LOW, new AlgorithmEndsListener() {
 
+                @Override
+                public void informAlgorithmEnds(VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
+                    log.debug("shutdown executor-service");
+                    executorService.shutdown();
+                }
+            }));
+            Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {
 
-            @Override
-            public Class<SolutionSelector> getType() {
-                return SolutionSelector.class;
-            }
+                @Override
+                public void uncaughtException(Thread arg0, Throwable arg1) {
+                    System.err.println(arg1.toString());
+                }
+            });
+            Runtime.getRuntime().addShutdownHook(new Thread() {
+                public void run() {
+                    if (!executorService.isShutdown()) {
+                        System.err.println("shutdowHook shuts down executorService");
+                        executorService.shutdown();
+                    }
+                }
+            });
+        } else executorService = null;
 
-        }
 
-        static class StrategyModuleKey implements AbstractKey<SearchStrategyModule> {
+        //create fleetmanager
+        final VehicleFleetManager vehicleFleetManager = createFleetManager(vrp);
 
-            private ModKey modKey;
+        String switchString = config.getString("construction.insertion.allowVehicleSwitch");
+        final boolean switchAllowed;
+        if (switchString != null) {
+            switchAllowed = Boolean.parseBoolean(switchString);
+        } else switchAllowed = true;
+        ActivityTimeTracker.ActivityPolicy activityPolicy;
+        if (stateManager.timeWindowUpdateIsActivated()) {
+            UpdateVehicleDependentPracticalTimeWindows timeWindowUpdater = new UpdateVehicleDependentPracticalTimeWindows(stateManager, vrp.getTransportCosts(), vrp.getActivityCosts());
+            timeWindowUpdater.setVehiclesToUpdate(new UpdateVehicleDependentPracticalTimeWindows.VehiclesToUpdate() {
+                Map<VehicleTypeKey, Vehicle> uniqueTypes = new HashMap<VehicleTypeKey, Vehicle>();
 
-            public StrategyModuleKey(ModKey modKey) {
-                super();
-                this.modKey = modKey;
-            }
+                @Override
+                public Collection<Vehicle> get(VehicleRoute vehicleRoute) {
+                    if (uniqueTypes.isEmpty()) {
+                        for (Vehicle v : vrp.getVehicles()) {
+                            if (!uniqueTypes.containsKey(v.getVehicleTypeIdentifier())) {
+                                uniqueTypes.put(v.getVehicleTypeIdentifier(), v);
+                            }
+                        }
+                    }
+                    Collection<Vehicle> vehicles = new ArrayList<Vehicle>();
+                    vehicles.addAll(uniqueTypes.values());
+                    return vehicles;
+                }
+            });
+            stateManager.addStateUpdater(timeWindowUpdater);
+            activityPolicy = ActivityTimeTracker.ActivityPolicy.AS_SOON_AS_TIME_WINDOW_OPENS;
+        } else {
+            activityPolicy = ActivityTimeTracker.ActivityPolicy.AS_SOON_AS_ARRIVED;
+        }
+        stateManager.addStateUpdater(new UpdateActivityTimes(vrp.getTransportCosts(), activityPolicy, vrp.getActivityCosts()));
+        stateManager.addStateUpdater(new UpdateVariableCosts(vrp.getActivityCosts(), vrp.getTransportCosts(), stateManager, activityPolicy));
 
-            @Override
-            public int hashCode() {
-                final int prime = 31;
-                int result = 1;
-                result = prime * result
-                    + ((modKey == null) ? 0 : modKey.hashCode());
-                return result;
-            }
+        final SolutionCostCalculator costCalculator;
+        if (solutionCostCalculator == null) costCalculator = getDefaultCostCalculator(stateManager);
+        else costCalculator = solutionCostCalculator;
 
-            @Override
-            public boolean equals(Object obj) {
-                if (this == obj)
-                    return true;
-                if (obj == null)
-                    return false;
-                if (getClass() != obj.getClass())
-                    return false;
-                StrategyModuleKey other = (StrategyModuleKey) obj;
-                if (modKey == null) {
-                    if (other.modKey != null)
-                        return false;
-                } else if (!modKey.equals(other.modKey))
-                    return false;
-                return true;
-            }
+        PrettyAlgorithmBuilder prettyAlgorithmBuilder = PrettyAlgorithmBuilder.newInstance(vrp, vehicleFleetManager, stateManager, constraintManager);
+        if (addCoreConstraints)
+            prettyAlgorithmBuilder.addCoreStateAndConstraintStuff();
+        //construct initial solution creator
+        final InsertionStrategy initialInsertionStrategy = createInitialSolution(config, vrp, vehicleFleetManager, stateManager, algorithmListeners, definedClasses, executorService, nuOfThreads, costCalculator, constraintManager, addDefaultCostCalculators);
+        if (initialInsertionStrategy != null)
+            prettyAlgorithmBuilder.constructInitialSolutionWith(initialInsertionStrategy, costCalculator);
 
+        //construct algorithm, i.e. search-strategies and its modules
+        int solutionMemory = config.getInt("strategy.memory");
+        List<HierarchicalConfiguration> strategyConfigs = config.configurationsAt("strategy.searchStrategies.searchStrategy");
+        for (HierarchicalConfiguration strategyConfig : strategyConfigs) {
+            String name = getName(strategyConfig);
+            SolutionAcceptor acceptor = getAcceptor(strategyConfig, vrp, algorithmListeners, definedClasses, solutionMemory);
+            SolutionSelector selector = getSelector(strategyConfig, vrp, algorithmListeners, definedClasses);
 
-            @Override
-            public Class<SearchStrategyModule> getType() {
-                return SearchStrategyModule.class;
+            SearchStrategy strategy = new SearchStrategy(name, selector, acceptor, costCalculator);
+            strategy.setName(name);
+            List<HierarchicalConfiguration> modulesConfig = strategyConfig.configurationsAt("modules.module");
+            for (HierarchicalConfiguration moduleConfig : modulesConfig) {
+                SearchStrategyModule module = buildModule(moduleConfig, vrp, vehicleFleetManager, stateManager, algorithmListeners, definedClasses, executorService, nuOfThreads, constraintManager, addDefaultCostCalculators);
+                strategy.addModule(module);
             }
-
+            prettyAlgorithmBuilder.withStrategy(strategy, strategyConfig.getDouble("probability"));
         }
 
-        static class RuinStrategyKey implements AbstractKey<RuinStrategy> {
+        //construct algorithm
+        VehicleRoutingAlgorithm metaAlgorithm = prettyAlgorithmBuilder.build();
+        int maxIterations = getMaxIterations(config);
+        if (maxIterations > -1) metaAlgorithm.setMaxIterations(maxIterations);
 
-            private ModKey modKey;
-
-            public RuinStrategyKey(ModKey modKey) {
-                super();
-                this.modKey = modKey;
-            }
-
-            @Override
-            public int hashCode() {
-                final int prime = 31;
-                int result = 1;
-                result = prime * result
-                    + ((modKey == null) ? 0 : modKey.hashCode());
-                return result;
+        //define prematureBreak
+        PrematureAlgorithmTermination prematureAlgorithmTermination = getPrematureTermination(config, algorithmListeners);
+        if (prematureAlgorithmTermination != null)
+            metaAlgorithm.setPrematureAlgorithmTermination(prematureAlgorithmTermination);
+        else {
+            List<HierarchicalConfiguration> terminationCriteria = config.configurationsAt("terminationCriteria.termination");
+            for (HierarchicalConfiguration terminationConfig : terminationCriteria) {
+                PrematureAlgorithmTermination termination = getTerminationCriterion(terminationConfig, algorithmListeners);
+                if (termination != null) metaAlgorithm.addTerminationCriterion(termination);
             }
+        }
+        for (PrioritizedVRAListener l : algorithmListeners) {
+            metaAlgorithm.getAlgorithmListeners().add(l);
+        }
+        return metaAlgorithm;
+    }
 
-            @Override
-            public boolean equals(Object obj) {
-                if (this == obj)
-                    return true;
-                if (obj == null)
-                    return false;
-                if (getClass() != obj.getClass())
-                    return false;
-                RuinStrategyKey other = (RuinStrategyKey) obj;
-                if (modKey == null) {
-                    if (other.modKey != null)
-                        return false;
-                } else if (!modKey.equals(other.modKey))
-                    return false;
-                return true;
-            }
+    private static InsertionStrategy createInitialSolution(XMLConfiguration config, final VehicleRoutingProblem vrp, VehicleFleetManager vehicleFleetManager, final StateManager routeStates, Set<PrioritizedVRAListener> algorithmListeners, TypedMap definedClasses, ExecutorService executorService, int nuOfThreads, final SolutionCostCalculator solutionCostCalculator, ConstraintManager constraintManager, boolean addDefaultCostCalculators) {
+        List<HierarchicalConfiguration> modConfigs = config.configurationsAt("construction.insertion");
+        if (modConfigs == null) return null;
+        if (modConfigs.isEmpty()) return null;
+        if (modConfigs.size() != 1) throw new IllegalStateException("#construction.modules != 1. 1 expected");
+        HierarchicalConfiguration modConfig = modConfigs.get(0);
+        String insertionName = modConfig.getString("[@name]");
+        if (insertionName == null) throw new IllegalStateException("insertion[@name] is missing.");
+        String insertionId = modConfig.getString("[@id]");
+        if (insertionId == null) insertionId = "noId";
+        ModKey modKey = makeKey(insertionName, insertionId);
+        InsertionStrategyKey insertionStrategyKey = new InsertionStrategyKey(modKey);
+        InsertionStrategy insertionStrategy = definedClasses.get(insertionStrategyKey);
+        if (insertionStrategy == null) {
+            List<PrioritizedVRAListener> prioListeners = new ArrayList<PrioritizedVRAListener>();
+            insertionStrategy = createInsertionStrategy(modConfig, vrp, vehicleFleetManager, routeStates, prioListeners, executorService, nuOfThreads, constraintManager, addDefaultCostCalculators);
+            algorithmListeners.addAll(prioListeners);
+            definedClasses.put(insertionStrategyKey, insertionStrategy);
+        }
+        return insertionStrategy;
+    }
 
+    private static SolutionCostCalculator getDefaultCostCalculator(final StateManager stateManager) {
+        return new VariablePlusFixedSolutionCostCalculatorFactory(stateManager).createCalculator();
+    }
 
-            @Override
-            public Class<RuinStrategy> getType() {
-                return RuinStrategy.class;
+    private static SolutionAcceptor getAcceptor(HierarchicalConfiguration strategyConfig, VehicleRoutingProblem vrp, Set<PrioritizedVRAListener> algorithmListeners, TypedMap typedMap, int solutionMemory) {
+        String acceptorName = strategyConfig.getString("acceptor[@name]");
+        if (acceptorName == null) throw new IllegalStateException("no solution acceptor is defined");
+        String acceptorId = strategyConfig.getString("acceptor[@id]");
+        if (acceptorId == null) acceptorId = "noId";
+        AcceptorKey acceptorKey = new AcceptorKey(makeKey(acceptorName, acceptorId));
+        SolutionAcceptor definedAcceptor = typedMap.get(acceptorKey);
+        if (definedAcceptor != null) return definedAcceptor;
+        if (acceptorName.equals("acceptNewRemoveWorst")) {
+            GreedyAcceptance acceptor = new GreedyAcceptance(solutionMemory);
+            typedMap.put(acceptorKey, acceptor);
+            return acceptor;
+        }
+        if (acceptorName.equals("acceptNewRemoveFirst")) {
+            AcceptNewRemoveFirst acceptor = new AcceptNewRemoveFirst(solutionMemory);
+            typedMap.put(acceptorKey, acceptor);
+            return acceptor;
+        }
+        if (acceptorName.equals("greedyAcceptance")) {
+            GreedyAcceptance acceptor = new GreedyAcceptance(solutionMemory);
+            typedMap.put(acceptorKey, acceptor);
+            return acceptor;
+        }
+        if (acceptorName.equals("schrimpfAcceptance")) {
+            String nuWarmupIterations = strategyConfig.getString("acceptor.warmup");
+            double alpha = strategyConfig.getDouble("acceptor.alpha");
+            SchrimpfAcceptance schrimpf = new SchrimpfAcceptance(solutionMemory, alpha);
+            if (nuWarmupIterations != null) {
+                SchrimpfInitialThresholdGenerator iniThresholdGenerator = new SchrimpfInitialThresholdGenerator(schrimpf, Integer.parseInt(nuWarmupIterations));
+                algorithmListeners.add(new PrioritizedVRAListener(Priority.LOW, iniThresholdGenerator));
+            } else {
+                double threshold = strategyConfig.getDouble("acceptor.initialThreshold");
+                schrimpf.setInitialThreshold(threshold);
             }
-
+            algorithmListeners.add(new PrioritizedVRAListener(Priority.LOW, schrimpf));
+            typedMap.put(acceptorKey, schrimpf);
+            return schrimpf;
         }
+        if (acceptorName.equals("experimentalSchrimpfAcceptance")) {
+            int iterOfSchrimpf = strategyConfig.getInt("acceptor.warmup");
+            double alpha = strategyConfig.getDouble("acceptor.alpha");
+            ExperimentalSchrimpfAcceptance schrimpf = new ExperimentalSchrimpfAcceptance(solutionMemory, alpha, iterOfSchrimpf);
+            algorithmListeners.add(new PrioritizedVRAListener(Priority.LOW, schrimpf));
+            typedMap.put(acceptorKey, schrimpf);
+            return schrimpf;
+        } else {
+            throw new IllegalStateException("solution acceptor " + acceptorName + " is not known");
+        }
+    }
 
-        static class InsertionStrategyKey implements AbstractKey<InsertionStrategy> {
-
-            private ModKey modKey;
-
-            public InsertionStrategyKey(ModKey modKey) {
-                super();
-                this.modKey = modKey;
-            }
+    private static String getName(HierarchicalConfiguration strategyConfig) {
+        if (strategyConfig.containsKey("[@name]")) {
+            return strategyConfig.getString("[@name]");
+        }
+        return "";
+    }
 
-            @Override
-            public int hashCode() {
-                final int prime = 31;
-                int result = 1;
-                result = prime * result
-                    + ((modKey == null) ? 0 : modKey.hashCode());
-                return result;
-            }
+    private static SolutionSelector getSelector(HierarchicalConfiguration strategyConfig, VehicleRoutingProblem vrp, Set<PrioritizedVRAListener> algorithmListeners, TypedMap definedSelectors) {
+        String selectorName = strategyConfig.getString("selector[@name]");
+        if (selectorName == null)
+            throw new IllegalStateException("no solutionSelector defined. define either \"selectRandomly\" or \"selectBest\"");
+        String selectorId = strategyConfig.getString("selector[@id]");
+        if (selectorId == null) selectorId = "noId";
+        ModKey modKey = makeKey(selectorName, selectorId);
+        SelectorKey selectorKey = new SelectorKey(modKey);
+        SolutionSelector definedSelector = definedSelectors.get(selectorKey);
+        if (definedSelector != null) {
+            return definedSelector;
+        }
+        if (selectorName.equals("selectRandomly")) {
+            SelectRandomly selector = SelectRandomly.getInstance();
+            definedSelectors.put(selectorKey, selector);
+            return selector;
+        }
+        if (selectorName.equals("selectBest")) {
+            SelectBest selector = SelectBest.getInstance();
+            definedSelectors.put(selectorKey, selector);
+            return selector;
+        }
+        throw new IllegalStateException("solutionSelector is not know. Currently, it only knows \"selectRandomly\" and \"selectBest\"");
+    }
 
-            @Override
-            public boolean equals(Object obj) {
-                if (this == obj)
-                    return true;
-                if (obj == null)
-                    return false;
-                if (getClass() != obj.getClass())
-                    return false;
-                InsertionStrategyKey other = (InsertionStrategyKey) obj;
-                if (modKey == null) {
-                    if (other.modKey != null)
-                        return false;
-                } else if (!modKey.equals(other.modKey))
-                    return false;
-                return true;
-            }
+    private static SearchStrategyModule buildModule(HierarchicalConfiguration moduleConfig, final VehicleRoutingProblem vrp, VehicleFleetManager vehicleFleetManager,
+                                                    final StateManager routeStates, Set<PrioritizedVRAListener> algorithmListeners, TypedMap definedClasses, ExecutorService executorService, int nuOfThreads, ConstraintManager constraintManager, boolean addDefaultCostCalculators) {
+        String moduleName = moduleConfig.getString("[@name]");
+        if (moduleName == null) throw new IllegalStateException("module(-name) is missing.");
+        String moduleId = moduleConfig.getString("[@id]");
+        if (moduleId == null) moduleId = "noId";
+        ModKey modKey = makeKey(moduleName, moduleId);
+        StrategyModuleKey strategyModuleKey = new StrategyModuleKey(modKey);
+        SearchStrategyModule definedModule = definedClasses.get(strategyModuleKey);
+        if (definedModule != null) return definedModule;
 
+        if (moduleName.equals("ruin_and_recreate")) {
+            String ruin_name = moduleConfig.getString("ruin[@name]");
+            if (ruin_name == null) throw new IllegalStateException("module.ruin[@name] is missing.");
+            String ruin_id = moduleConfig.getString("ruin[@id]");
+            if (ruin_id == null) ruin_id = "noId";
+            final RuinStrategy ruin;
+            ModKey ruinKey = makeKey(ruin_name, ruin_id);
+            if (ruin_name.equals("randomRuin")) {
+                String shareToRuinString = moduleConfig.getString("ruin.share");
+                if (shareToRuinString == null) throw new IllegalStateException("module.ruin.share is missing.");
+                double shareToRuin = Double.valueOf(shareToRuinString);
+                ruin = getRandomRuin(vrp, routeStates, definedClasses, ruinKey, shareToRuin);
+            } else if (ruin_name.equals("radialRuin")) {
+                String shareToRuinString = moduleConfig.getString("ruin.share");
+                if (shareToRuinString == null) throw new IllegalStateException("module.ruin.share is missing.");
+                double shareToRuin = Double.valueOf(shareToRuinString);
+                JobDistance jobDistance = new AvgServiceAndShipmentDistance(vrp.getTransportCosts());
+                ruin = getRadialRuin(vrp, routeStates, definedClasses, ruinKey, shareToRuin, jobDistance);
+            } else if (ruin_name.equals("clusterRuin")) {
+                String initialNumberJobsToRemoveString = moduleConfig.getString("ruin.initRemoveJobs");
+                if (initialNumberJobsToRemoveString == null)
+                    throw new IllegalStateException("module.ruin.initRemoveJobs is missing.");
+                int initialNumberJobsToRemove = Integer.valueOf(initialNumberJobsToRemoveString);
+                ruin = getClusterRuin(vrp, routeStates, definedClasses, ruinKey, initialNumberJobsToRemove);
+            } else
+                throw new IllegalStateException("ruin[@name] " + ruin_name + " is not known. Use either randomRuin or radialRuin.");
 
-            @Override
-            public Class<InsertionStrategy> getType() {
-                return InsertionStrategy.class;
+            String insertionName = moduleConfig.getString("insertion[@name]");
+            if (insertionName == null)
+                throw new IllegalStateException("module.insertion[@name] is missing. set it to \"regretInsertion\" or \"bestInsertion\"");
+            String insertionId = moduleConfig.getString("insertion[@id]");
+            if (insertionId == null) insertionId = "noId";
+            ModKey insertionKey = makeKey(insertionName, insertionId);
+            InsertionStrategyKey insertionStrategyKey = new InsertionStrategyKey(insertionKey);
+            InsertionStrategy insertion = definedClasses.get(insertionStrategyKey);
+            if (insertion == null) {
+                List<HierarchicalConfiguration> insertionConfigs = moduleConfig.configurationsAt("insertion");
+                if (insertionConfigs.size() != 1) throw new IllegalStateException("this should be 1");
+                List<PrioritizedVRAListener> prioListeners = new ArrayList<PrioritizedVRAListener>();
+                insertion = createInsertionStrategy(insertionConfigs.get(0), vrp, vehicleFleetManager, routeStates, prioListeners, executorService, nuOfThreads, constraintManager, addDefaultCostCalculators);
+                algorithmListeners.addAll(prioListeners);
             }
+            final InsertionStrategy final_insertion = insertion;
 
+            RuinAndRecreateModule rrModule = new RuinAndRecreateModule("ruin_and_recreate", final_insertion, ruin);
+            return rrModule;
         }
+        throw new NullPointerException("no module found with moduleName=" + moduleName +
+            "\n\tcheck config whether the correct names are used" +
+            "\n\tcurrently there are following modules available: " +
+            "\n\tbestInsertion" +
+            "\n\trandomRuin" +
+            "\n\tradialRuin" +
+            "\n\tclusterRuin");
+    }
 
-        private Map<AbstractKey<?>, Object> map = new HashMap<AbstractKey<?>, Object>();
+    private static int getMaxIterations(XMLConfiguration config) {
+        String maxIterationsString = config.getString("iterations");
+        if (maxIterationsString == null) maxIterationsString = config.getString("maxIterations");
+        if (maxIterationsString != null) return (Integer.parseInt(maxIterationsString));
+        return -1;
+    }
 
-        public <T> T get(AbstractKey<T> key) {
-            if (map.get(key) == null) return null;
-            return key.getType().cast(map.get(key));
+    private static PrematureAlgorithmTermination getPrematureTermination(XMLConfiguration config, Set<PrioritizedVRAListener> algorithmListeners) {
+        String basedOn = config.getString("prematureBreak[@basedOn]");
+        if (basedOn == null) {
+            log.debug("set default prematureBreak, i.e. no premature break at all.");
+            return null;
         }
-
-        public <T> T put(AbstractKey<T> key, T value) {
-            return key.getType().cast(map.put(key, key.getType().cast(value)));
+        if (basedOn.equals("iterations")) {
+            log.debug("set prematureBreak based on iterations");
+            String iter = config.getString("prematureBreak.iterations");
+            if (iter == null) throw new IllegalStateException("prematureBreak.iterations is missing");
+            int iterations = Integer.valueOf(iter);
+            return new IterationWithoutImprovementTermination(iterations);
         }
-
-        public Set<AbstractKey<?>> keySet() {
-            return map.keySet();
+        if (basedOn.equals("time")) {
+            log.debug("set prematureBreak based on time");
+            String timeString = config.getString("prematureBreak.time");
+            if (timeString == null) throw new IllegalStateException("prematureBreak.time is missing");
+            long time = Long.parseLong(timeString);
+            TimeTermination timeBreaker = new TimeTermination(time);
+            algorithmListeners.add(new PrioritizedVRAListener(Priority.LOW, timeBreaker));
+            return timeBreaker;
         }
+        if (basedOn.equals("variationCoefficient")) {
+            log.debug("set prematureBreak based on variation coefficient");
+            String thresholdString = config.getString("prematureBreak.threshold");
+            String iterationsString = config.getString("prematureBreak.iterations");
+            if (thresholdString == null) throw new IllegalStateException("prematureBreak.threshold is missing");
+            if (iterationsString == null) throw new IllegalStateException("prematureBreak.iterations is missing");
+            double threshold = Double.valueOf(thresholdString);
+            int iterations = Integer.valueOf(iterationsString);
+            VariationCoefficientTermination variationCoefficientBreaker = new VariationCoefficientTermination(iterations, threshold);
+            algorithmListeners.add(new PrioritizedVRAListener(Priority.LOW, variationCoefficientBreaker));
+            return variationCoefficientBreaker;
+        }
+        throw new IllegalStateException("prematureBreak basedOn " + basedOn + " is not defined");
     }
 
-    static class ModKey {
-        private String name;
-        private String id;
-
-        public ModKey(String name, String id) {
-            super();
-            this.name = name;
-            this.id = id;
+    private static PrematureAlgorithmTermination getTerminationCriterion(HierarchicalConfiguration config, Set<PrioritizedVRAListener> algorithmListeners) {
+        String basedOn = config.getString("[@basedOn]");
+        if (basedOn == null) {
+            log.debug("set default prematureBreak, i.e. no premature break at all.");
+            return null;
         }
-
-        @Override
-        public int hashCode() {
-            final int prime = 31;
-            int result = 1;
-            result = prime * result + ((id == null) ? 0 : id.hashCode());
-            result = prime * result + ((name == null) ? 0 : name.hashCode());
-            return result;
+        if (basedOn.equals("iterations")) {
+            log.debug("set prematureBreak based on iterations");
+            String iter = config.getString("iterations");
+            if (iter == null) throw new IllegalStateException("iterations is missing");
+            int iterations = Integer.valueOf(iter);
+            return new IterationWithoutImprovementTermination(iterations);
+        }
+        if (basedOn.equals("time")) {
+            log.debug("set prematureBreak based on time");
+            String timeString = config.getString("time");
+            if (timeString == null) throw new IllegalStateException("time is missing");
+            long time = Long.parseLong(timeString);
+            TimeTermination timeBreaker = new TimeTermination(time);
+            algorithmListeners.add(new PrioritizedVRAListener(Priority.LOW, timeBreaker));
+            return timeBreaker;
         }
-
-        @Override
-        public boolean equals(Object obj) {
-            if (this == obj)
-                return true;
-            if (obj == null)
-                return false;
-            if (getClass() != obj.getClass())
-                return false;
-            ModKey other = (ModKey) obj;
-            if (id == null) {
-                if (other.id != null)
-                    return false;
-            } else if (!id.equals(other.id))
-                return false;
-            if (name == null) {
-                if (other.name != null)
-                    return false;
-            } else if (!name.equals(other.name))
-                return false;
-            return true;
+        if (basedOn.equals("variationCoefficient")) {
+            log.debug("set prematureBreak based on variation coefficient");
+            String thresholdString = config.getString("threshold");
+            String iterationsString = config.getString("iterations");
+            if (thresholdString == null) throw new IllegalStateException("threshold is missing");
+            if (iterationsString == null) throw new IllegalStateException("iterations is missing");
+            double threshold = Double.valueOf(thresholdString);
+            int iterations = Integer.valueOf(iterationsString);
+            VariationCoefficientTermination variationCoefficientBreaker = new VariationCoefficientTermination(iterations, threshold);
+            algorithmListeners.add(new PrioritizedVRAListener(Priority.LOW, variationCoefficientBreaker));
+            return variationCoefficientBreaker;
         }
+        throw new IllegalStateException("prematureBreak basedOn " + basedOn + " is not defined");
+    }
 
+    private static ModKey makeKey(String name, String id) {
+        return new ModKey(name, id);
     }
 
-    private static Logger log = LoggerFactory.getLogger(VehicleRoutingAlgorithms.class.getName());
+    private static RuinStrategy getRandomRuin(final VehicleRoutingProblem vrp, final StateManager routeStates, TypedMap definedClasses, ModKey modKey, double shareToRuin) {
+        RuinStrategyKey stratKey = new RuinStrategyKey(modKey);
+        RuinStrategy ruin = definedClasses.get(stratKey);
+        if (ruin == null) {
+            ruin = new RandomRuinStrategyFactory(shareToRuin).createStrategy(vrp);
+            definedClasses.put(stratKey, ruin);
+        }
+        return ruin;
+    }
 
-    private VehicleRoutingAlgorithms() {
+    private static RuinStrategy getRadialRuin(final VehicleRoutingProblem vrp, final StateManager routeStates, TypedMap definedClasses, ModKey modKey, double shareToRuin, JobDistance jobDistance) {
+        RuinStrategyKey stratKey = new RuinStrategyKey(modKey);
+        RuinStrategy ruin = definedClasses.get(stratKey);
+        if (ruin == null) {
+            ruin = new RadialRuinStrategyFactory(shareToRuin, jobDistance).createStrategy(vrp);
+            definedClasses.put(stratKey, ruin);
+        }
+        return ruin;
     }
 
-    /**
-     * Creates a {@link com.graphhopper.jsprit.core.algorithm.VehicleRoutingAlgorithm} from a AlgorithConfig based on the input vrp.
-     *
-     * @param vrp             the routing problem
-     * @param algorithmConfig the algorithm config
-     * @return {@link com.graphhopper.jsprit.core.algorithm.VehicleRoutingAlgorithm}
-     */
-    public static VehicleRoutingAlgorithm createAlgorithm(final VehicleRoutingProblem vrp, final AlgorithmConfig algorithmConfig) {
-        return createAlgo(vrp, algorithmConfig.getXMLConfiguration(), 0, null);
+    private static RuinStrategy getClusterRuin(final VehicleRoutingProblem vrp, final StateManager routeStates, TypedMap definedClasses, ModKey modKey, int initialNumberJobsToRemove) {
+        JobNeighborhoods jobNeighborhoods = new JobNeighborhoodsFactory().createNeighborhoods(vrp, new AvgServiceAndShipmentDistance(vrp.getTransportCosts()));
+        RuinStrategyKey stratKey = new RuinStrategyKey(modKey);
+        RuinStrategy ruin = definedClasses.get(stratKey);
+        if (ruin == null) {
+            ruin = new ClusterRuinStrategyFactory(initialNumberJobsToRemove, jobNeighborhoods).createStrategy(vrp);
+            definedClasses.put(stratKey, ruin);
+        }
+        return ruin;
     }
 
-    public static VehicleRoutingAlgorithm createAlgorithm(final VehicleRoutingProblem vrp, int nThreads, final AlgorithmConfig algorithmConfig) {
-        return createAlgo(vrp, algorithmConfig.getXMLConfiguration(), nThreads, null);
+    private static InsertionStrategy createInsertionStrategy(HierarchicalConfiguration moduleConfig, VehicleRoutingProblem vrp, VehicleFleetManager vehicleFleetManager, StateManager routeStates, List<PrioritizedVRAListener> algorithmListeners, ExecutorService executorService, int nuOfThreads, ConstraintManager constraintManager, boolean addDefaultCostCalculators) {
+        return InsertionFactory.createInsertion(vrp, moduleConfig, vehicleFleetManager, routeStates, algorithmListeners, executorService, nuOfThreads, constraintManager, addDefaultCostCalculators);
     }
 
     /**
@@ -427,517 +605,334 @@ public static VehicleRoutingAlgorithm readAndCreateAlgorithm(VehicleRoutingProbl
         return createAlgo(vrp, algorithmConfig.getXMLConfiguration(), nThreads, null);
     }
 
-    private static class OpenRouteStateVerifier implements StateUpdater, ReverseActivityVisitor {
+    public static VehicleRoutingAlgorithm readAndCreateAlgorithm(final VehicleRoutingProblem vrp, AlgorithmConfig config,
+                                                                 int nuOfThreads, SolutionCostCalculator solutionCostCalculator, final StateManager stateManager, ConstraintManager constraintManager, boolean addDefaultCostCalculators) {
+        return readAndCreateAlgorithm(vrp, config.getXMLConfiguration(), nuOfThreads, solutionCostCalculator, stateManager, constraintManager, addDefaultCostCalculators);
+    }
 
-        private End end;
+    private static VehicleRoutingAlgorithm readAndCreateAlgorithm(final VehicleRoutingProblem vrp, XMLConfiguration config,
+                                                                  int nuOfThreads, final SolutionCostCalculator solutionCostCalculator, final StateManager stateManager, ConstraintManager constraintManager, boolean addDefaultCostCalculators) {
 
-        private boolean firstAct = true;
+        return readAndCreateAlgorithm(vrp, config, nuOfThreads, solutionCostCalculator, stateManager, constraintManager, addDefaultCostCalculators, true);
+    }
 
-        private Vehicle vehicle;
+    public static VehicleRoutingAlgorithm readAndCreateAlgorithm(final VehicleRoutingProblem vrp, AlgorithmConfig config,
+                                                                 int nuOfThreads, SolutionCostCalculator solutionCostCalculator, final StateManager stateManager, ConstraintManager constraintManager, boolean addDefaultCostCalculators, boolean addCoreConstraints) {
+        return readAndCreateAlgorithm(vrp, config.getXMLConfiguration(), nuOfThreads, solutionCostCalculator, stateManager, constraintManager, addDefaultCostCalculators, addCoreConstraints);
+    }
 
-        @Override
-        public void begin(VehicleRoute route) {
-            end = route.getEnd();
-            vehicle = route.getVehicle();
-        }
+    static class TypedMap {
 
-        @Override
-        public void visit(TourActivity activity) {
-            if (firstAct) {
-                firstAct = false;
-                if (!vehicle.isReturnToDepot()) {
-                    assert activity.getLocation().getId().equals(end.getLocation().getId()) : "route end and last activity are not equal even route is open. this should not be.";
-                }
-            }
+        private Map<AbstractKey<?>, Object> map = new HashMap<AbstractKey<?>, Object>();
 
+        public <T> T get(AbstractKey<T> key) {
+            if (map.get(key) == null) return null;
+            return key.getType().cast(map.get(key));
         }
 
-        @Override
-        public void finish() {
-            firstAct = true;
+        public <T> T put(AbstractKey<T> key, T value) {
+            return key.getType().cast(map.put(key, key.getType().cast(value)));
         }
 
-    }
-
-    private static VehicleRoutingAlgorithm createAlgo(final VehicleRoutingProblem vrp, XMLConfiguration config, int nuOfThreads, StateManager stateMan) {
-        //create state-manager
-        final StateManager stateManager;
-        if (stateMan != null) {
-            stateManager = stateMan;
-        } else {
-            stateManager = new StateManager(vrp);
+        public Set<AbstractKey<?>> keySet() {
+            return map.keySet();
         }
-        stateManager.updateLoadStates();
-        stateManager.updateTimeWindowStates();
-        stateManager.updateSkillStates();
-        stateManager.addStateUpdater(new UpdateEndLocationIfRouteIsOpen());
-        stateManager.addStateUpdater(new OpenRouteStateVerifier());
-//		stateManager.addStateUpdater(new UpdateActivityTimes(vrp.getTransportCosts()));
-//		stateManager.addStateUpdater(new UpdateVariableCosts(vrp.getActivityCosts(), vrp.getTransportCosts(), stateManager));
 
-		/*
-         * define constraints
-		 */
-        //constraint manager
-        ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
-        constraintManager.addTimeWindowConstraint();
-        constraintManager.addLoadConstraint();
-        constraintManager.addSkillsConstraint();
-        constraintManager.addConstraint(new SwitchNotFeasible(stateManager));
+        static interface AbstractKey<K> {
 
-        return readAndCreateAlgorithm(vrp, config, nuOfThreads, null, stateManager, constraintManager, true, true);
-    }
+            Class<K> getType();
+        }
 
-    public static VehicleRoutingAlgorithm readAndCreateAlgorithm(final VehicleRoutingProblem vrp, AlgorithmConfig config,
-                                                                 int nuOfThreads, SolutionCostCalculator solutionCostCalculator, final StateManager stateManager, ConstraintManager constraintManager, boolean addDefaultCostCalculators) {
-        return readAndCreateAlgorithm(vrp, config.getXMLConfiguration(), nuOfThreads, solutionCostCalculator, stateManager, constraintManager, addDefaultCostCalculators);
-    }
+        static class AcceptorKey implements AbstractKey<SolutionAcceptor> {
 
+            private ModKey modKey;
 
-    public static VehicleRoutingAlgorithm readAndCreateAlgorithm(final VehicleRoutingProblem vrp, AlgorithmConfig config,
-                                                                 int nuOfThreads, SolutionCostCalculator solutionCostCalculator, final StateManager stateManager, ConstraintManager constraintManager, boolean addDefaultCostCalculators, boolean addCoreConstraints) {
-        return readAndCreateAlgorithm(vrp, config.getXMLConfiguration(), nuOfThreads, solutionCostCalculator, stateManager, constraintManager, addDefaultCostCalculators, addCoreConstraints);
-    }
+            public AcceptorKey(ModKey modKey) {
+                super();
+                this.modKey = modKey;
+            }
 
-    private static VehicleRoutingAlgorithm readAndCreateAlgorithm(final VehicleRoutingProblem vrp, XMLConfiguration config,
-                                                                  int nuOfThreads, final SolutionCostCalculator solutionCostCalculator, final StateManager stateManager, ConstraintManager constraintManager, boolean addDefaultCostCalculators) {
 
-        return readAndCreateAlgorithm(vrp, config, nuOfThreads, solutionCostCalculator, stateManager, constraintManager, addDefaultCostCalculators, true);
-    }
+            @Override
+            public int hashCode() {
+                final int prime = 31;
+                int result = 1;
+                result = prime * result
+                    + ((modKey == null) ? 0 : modKey.hashCode());
+                return result;
+            }
 
-    private static VehicleRoutingAlgorithm readAndCreateAlgorithm(final VehicleRoutingProblem vrp, XMLConfiguration config,
-                                                                  int nuOfThreads, final SolutionCostCalculator solutionCostCalculator, final StateManager stateManager, ConstraintManager constraintManager, boolean addDefaultCostCalculators, boolean addCoreConstraints) {
-        // map to store constructed modules
-        TypedMap definedClasses = new TypedMap();
+            @Override
+            public Class<SolutionAcceptor> getType() {
+                return SolutionAcceptor.class;
+            }
 
-        // algorithm listeners
-        Set<PrioritizedVRAListener> algorithmListeners = new HashSet<PrioritizedVRAListener>();
+            @Override
+            public boolean equals(Object obj) {
+                if (this == obj)
+                    return true;
+                if (obj == null)
+                    return false;
+                if (!(obj instanceof AcceptorKey))
+                    return false;
+                AcceptorKey other = (AcceptorKey) obj;
+                if (modKey == null) {
+                    if (other.modKey != null)
+                        return false;
+                } else if (!modKey.equals(other.modKey))
+                    return false;
+                return true;
+            }
 
-        // insertion listeners
-        List<InsertionListener> insertionListeners = new ArrayList<InsertionListener>();
 
+        }
 
-        //threading
-        final ExecutorService executorService;
-        if (nuOfThreads > 0) {
-            log.debug("setup executor-service with " + nuOfThreads + " threads");
-            executorService = Executors.newFixedThreadPool(nuOfThreads);
-            algorithmListeners.add(new PrioritizedVRAListener(Priority.LOW, new AlgorithmEndsListener() {
+        static class SelectorKey implements AbstractKey<SolutionSelector> {
 
-                @Override
-                public void informAlgorithmEnds(VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
-                    log.debug("shutdown executor-service");
-                    executorService.shutdown();
-                }
-            }));
-            Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {
+            private ModKey modKey;
 
-                @Override
-                public void uncaughtException(Thread arg0, Throwable arg1) {
-                    System.err.println(arg1.toString());
-                }
-            });
-            Runtime.getRuntime().addShutdownHook(new Thread() {
-                public void run() {
-                    if (!executorService.isShutdown()) {
-                        System.err.println("shutdowHook shuts down executorService");
-                        executorService.shutdown();
-                    }
-                }
-            });
-        } else executorService = null;
+            public SelectorKey(ModKey modKey) {
+                super();
+                this.modKey = modKey;
+            }
+
+            @Override
+            public int hashCode() {
+                final int prime = 31;
+                int result = 1;
+                result = prime * result
+                    + ((modKey == null) ? 0 : modKey.hashCode());
+                return result;
+            }
 
+            @Override
+            public boolean equals(Object obj) {
+                if (this == obj)
+                    return true;
+                if (obj == null)
+                    return false;
+                if (getClass() != obj.getClass())
+                    return false;
+                SelectorKey other = (SelectorKey) obj;
+                if (modKey == null) {
+                    if (other.modKey != null)
+                        return false;
+                } else if (!modKey.equals(other.modKey))
+                    return false;
+                return true;
+            }
 
-        //create fleetmanager
-        final VehicleFleetManager vehicleFleetManager = createFleetManager(vrp);
 
-        String switchString = config.getString("construction.insertion.allowVehicleSwitch");
-        final boolean switchAllowed;
-        if (switchString != null) {
-            switchAllowed = Boolean.parseBoolean(switchString);
-        } else switchAllowed = true;
-        ActivityTimeTracker.ActivityPolicy activityPolicy;
-        if (stateManager.timeWindowUpdateIsActivated()) {
-            UpdateVehicleDependentPracticalTimeWindows timeWindowUpdater = new UpdateVehicleDependentPracticalTimeWindows(stateManager, vrp.getTransportCosts(), vrp.getActivityCosts());
-            timeWindowUpdater.setVehiclesToUpdate(new UpdateVehicleDependentPracticalTimeWindows.VehiclesToUpdate() {
-                Map<VehicleTypeKey, Vehicle> uniqueTypes = new HashMap<VehicleTypeKey, Vehicle>();
+            @Override
+            public Class<SolutionSelector> getType() {
+                return SolutionSelector.class;
+            }
 
-                @Override
-                public Collection<Vehicle> get(VehicleRoute vehicleRoute) {
-                    if (uniqueTypes.isEmpty()) {
-                        for (Vehicle v : vrp.getVehicles()) {
-                            if (!uniqueTypes.containsKey(v.getVehicleTypeIdentifier())) {
-                                uniqueTypes.put(v.getVehicleTypeIdentifier(), v);
-                            }
-                        }
-                    }
-                    Collection<Vehicle> vehicles = new ArrayList<Vehicle>();
-                    vehicles.addAll(uniqueTypes.values());
-                    return vehicles;
-                }
-            });
-            stateManager.addStateUpdater(timeWindowUpdater);
-            activityPolicy = ActivityTimeTracker.ActivityPolicy.AS_SOON_AS_TIME_WINDOW_OPENS;
-        } else {
-            activityPolicy = ActivityTimeTracker.ActivityPolicy.AS_SOON_AS_ARRIVED;
         }
-        stateManager.addStateUpdater(new UpdateActivityTimes(vrp.getTransportCosts(), activityPolicy, vrp.getActivityCosts()));
-        stateManager.addStateUpdater(new UpdateVariableCosts(vrp.getActivityCosts(), vrp.getTransportCosts(), stateManager, activityPolicy));
 
-        final SolutionCostCalculator costCalculator;
-        if (solutionCostCalculator == null) costCalculator = getDefaultCostCalculator(stateManager);
-        else costCalculator = solutionCostCalculator;
+        static class StrategyModuleKey implements AbstractKey<SearchStrategyModule> {
 
-        PrettyAlgorithmBuilder prettyAlgorithmBuilder = PrettyAlgorithmBuilder.newInstance(vrp, vehicleFleetManager, stateManager, constraintManager);
-        if(addCoreConstraints)
-            prettyAlgorithmBuilder.addCoreStateAndConstraintStuff();
-        //construct initial solution creator
-        final InsertionStrategy initialInsertionStrategy = createInitialSolution(config, vrp, vehicleFleetManager, stateManager, algorithmListeners, definedClasses, executorService, nuOfThreads, costCalculator, constraintManager, addDefaultCostCalculators);
-        if (initialInsertionStrategy != null)
-            prettyAlgorithmBuilder.constructInitialSolutionWith(initialInsertionStrategy, costCalculator);
+            private ModKey modKey;
 
-        //construct algorithm, i.e. search-strategies and its modules
-        int solutionMemory = config.getInt("strategy.memory");
-        List<HierarchicalConfiguration> strategyConfigs = config.configurationsAt("strategy.searchStrategies.searchStrategy");
-        for (HierarchicalConfiguration strategyConfig : strategyConfigs) {
-            String name = getName(strategyConfig);
-            SolutionAcceptor acceptor = getAcceptor(strategyConfig, vrp, algorithmListeners, definedClasses, solutionMemory);
-            SolutionSelector selector = getSelector(strategyConfig, vrp, algorithmListeners, definedClasses);
+            public StrategyModuleKey(ModKey modKey) {
+                super();
+                this.modKey = modKey;
+            }
 
-            SearchStrategy strategy = new SearchStrategy(name, selector, acceptor, costCalculator);
-            strategy.setName(name);
-            List<HierarchicalConfiguration> modulesConfig = strategyConfig.configurationsAt("modules.module");
-            for (HierarchicalConfiguration moduleConfig : modulesConfig) {
-                SearchStrategyModule module = buildModule(moduleConfig, vrp, vehicleFleetManager, stateManager, algorithmListeners, definedClasses, executorService, nuOfThreads, constraintManager, addDefaultCostCalculators);
-                strategy.addModule(module);
+            @Override
+            public int hashCode() {
+                final int prime = 31;
+                int result = 1;
+                result = prime * result
+                    + ((modKey == null) ? 0 : modKey.hashCode());
+                return result;
             }
-            prettyAlgorithmBuilder.withStrategy(strategy, strategyConfig.getDouble("probability"));
-        }
 
-        //construct algorithm
-        VehicleRoutingAlgorithm metaAlgorithm = prettyAlgorithmBuilder.build();
-        int maxIterations = getMaxIterations(config);
-        if (maxIterations > -1) metaAlgorithm.setMaxIterations(maxIterations);
+            @Override
+            public boolean equals(Object obj) {
+                if (this == obj)
+                    return true;
+                if (obj == null)
+                    return false;
+                if (getClass() != obj.getClass())
+                    return false;
+                StrategyModuleKey other = (StrategyModuleKey) obj;
+                if (modKey == null) {
+                    if (other.modKey != null)
+                        return false;
+                } else if (!modKey.equals(other.modKey))
+                    return false;
+                return true;
+            }
 
-        //define prematureBreak
-        PrematureAlgorithmTermination prematureAlgorithmTermination = getPrematureTermination(config, algorithmListeners);
-        if (prematureAlgorithmTermination != null)
-            metaAlgorithm.setPrematureAlgorithmTermination(prematureAlgorithmTermination);
-        else {
-            List<HierarchicalConfiguration> terminationCriteria = config.configurationsAt("terminationCriteria.termination");
-            for (HierarchicalConfiguration terminationConfig : terminationCriteria) {
-                PrematureAlgorithmTermination termination = getTerminationCriterion(terminationConfig, algorithmListeners);
-                if (termination != null) metaAlgorithm.addTerminationCriterion(termination);
+
+            @Override
+            public Class<SearchStrategyModule> getType() {
+                return SearchStrategyModule.class;
             }
+
         }
-        for (PrioritizedVRAListener l : algorithmListeners) {
-            metaAlgorithm.getAlgorithmListeners().add(l);
-        }
-        return metaAlgorithm;
-    }
 
-    private static int getMaxIterations(XMLConfiguration config) {
-        String maxIterationsString = config.getString("iterations");
-        if (maxIterationsString == null) maxIterationsString = config.getString("maxIterations");
-        if (maxIterationsString != null) return (Integer.parseInt(maxIterationsString));
-        return -1;
-    }
+        static class RuinStrategyKey implements AbstractKey<RuinStrategy> {
 
-    private static SolutionCostCalculator getDefaultCostCalculator(final StateManager stateManager) {
-        return new VariablePlusFixedSolutionCostCalculatorFactory(stateManager).createCalculator();
-    }
+            private ModKey modKey;
 
-    private static VehicleFleetManager createFleetManager(final VehicleRoutingProblem vrp) {
-        if (vrp.getFleetSize().equals(FleetSize.INFINITE)) {
-            return new InfiniteFleetManagerFactory(vrp.getVehicles()).createFleetManager();
+            public RuinStrategyKey(ModKey modKey) {
+                super();
+                this.modKey = modKey;
+            }
 
-        } else if (vrp.getFleetSize().equals(FleetSize.FINITE)) {
-            return new FiniteFleetManagerFactory(vrp.getVehicles()).createFleetManager();
-        }
-        throw new IllegalStateException("fleet size can only be infinite or finite. " +
-            "makes sure your config file contains one of these options");
-    }
+            @Override
+            public int hashCode() {
+                final int prime = 31;
+                int result = 1;
+                result = prime * result
+                    + ((modKey == null) ? 0 : modKey.hashCode());
+                return result;
+            }
 
-    private static PrematureAlgorithmTermination getTerminationCriterion(HierarchicalConfiguration config, Set<PrioritizedVRAListener> algorithmListeners) {
-        String basedOn = config.getString("[@basedOn]");
-        if (basedOn == null) {
-            log.debug("set default prematureBreak, i.e. no premature break at all.");
-            return null;
-        }
-        if (basedOn.equals("iterations")) {
-            log.debug("set prematureBreak based on iterations");
-            String iter = config.getString("iterations");
-            if (iter == null) throw new IllegalStateException("iterations is missing");
-            int iterations = Integer.valueOf(iter);
-            return new IterationWithoutImprovementTermination(iterations);
-        }
-        if (basedOn.equals("time")) {
-            log.debug("set prematureBreak based on time");
-            String timeString = config.getString("time");
-            if (timeString == null) throw new IllegalStateException("time is missing");
-            long time = Long.parseLong(timeString);
-            TimeTermination timeBreaker = new TimeTermination(time);
-            algorithmListeners.add(new PrioritizedVRAListener(Priority.LOW, timeBreaker));
-            return timeBreaker;
-        }
-        if (basedOn.equals("variationCoefficient")) {
-            log.debug("set prematureBreak based on variation coefficient");
-            String thresholdString = config.getString("threshold");
-            String iterationsString = config.getString("iterations");
-            if (thresholdString == null) throw new IllegalStateException("threshold is missing");
-            if (iterationsString == null) throw new IllegalStateException("iterations is missing");
-            double threshold = Double.valueOf(thresholdString);
-            int iterations = Integer.valueOf(iterationsString);
-            VariationCoefficientTermination variationCoefficientBreaker = new VariationCoefficientTermination(iterations, threshold);
-            algorithmListeners.add(new PrioritizedVRAListener(Priority.LOW, variationCoefficientBreaker));
-            return variationCoefficientBreaker;
-        }
-        throw new IllegalStateException("prematureBreak basedOn " + basedOn + " is not defined");
-    }
+            @Override
+            public boolean equals(Object obj) {
+                if (this == obj)
+                    return true;
+                if (obj == null)
+                    return false;
+                if (getClass() != obj.getClass())
+                    return false;
+                RuinStrategyKey other = (RuinStrategyKey) obj;
+                if (modKey == null) {
+                    if (other.modKey != null)
+                        return false;
+                } else if (!modKey.equals(other.modKey))
+                    return false;
+                return true;
+            }
+
+
+            @Override
+            public Class<RuinStrategy> getType() {
+                return RuinStrategy.class;
+            }
 
-    private static PrematureAlgorithmTermination getPrematureTermination(XMLConfiguration config, Set<PrioritizedVRAListener> algorithmListeners) {
-        String basedOn = config.getString("prematureBreak[@basedOn]");
-        if (basedOn == null) {
-            log.debug("set default prematureBreak, i.e. no premature break at all.");
-            return null;
-        }
-        if (basedOn.equals("iterations")) {
-            log.debug("set prematureBreak based on iterations");
-            String iter = config.getString("prematureBreak.iterations");
-            if (iter == null) throw new IllegalStateException("prematureBreak.iterations is missing");
-            int iterations = Integer.valueOf(iter);
-            return new IterationWithoutImprovementTermination(iterations);
-        }
-        if (basedOn.equals("time")) {
-            log.debug("set prematureBreak based on time");
-            String timeString = config.getString("prematureBreak.time");
-            if (timeString == null) throw new IllegalStateException("prematureBreak.time is missing");
-            long time = Long.parseLong(timeString);
-            TimeTermination timeBreaker = new TimeTermination(time);
-            algorithmListeners.add(new PrioritizedVRAListener(Priority.LOW, timeBreaker));
-            return timeBreaker;
-        }
-        if (basedOn.equals("variationCoefficient")) {
-            log.debug("set prematureBreak based on variation coefficient");
-            String thresholdString = config.getString("prematureBreak.threshold");
-            String iterationsString = config.getString("prematureBreak.iterations");
-            if (thresholdString == null) throw new IllegalStateException("prematureBreak.threshold is missing");
-            if (iterationsString == null) throw new IllegalStateException("prematureBreak.iterations is missing");
-            double threshold = Double.valueOf(thresholdString);
-            int iterations = Integer.valueOf(iterationsString);
-            VariationCoefficientTermination variationCoefficientBreaker = new VariationCoefficientTermination(iterations, threshold);
-            algorithmListeners.add(new PrioritizedVRAListener(Priority.LOW, variationCoefficientBreaker));
-            return variationCoefficientBreaker;
         }
-        throw new IllegalStateException("prematureBreak basedOn " + basedOn + " is not defined");
-    }
 
-    private static String getName(HierarchicalConfiguration strategyConfig) {
-        if (strategyConfig.containsKey("[@name]")) {
-            return strategyConfig.getString("[@name]");
-        }
-        return "";
-    }
+        static class InsertionStrategyKey implements AbstractKey<InsertionStrategy> {
+
+            private ModKey modKey;
+
+            public InsertionStrategyKey(ModKey modKey) {
+                super();
+                this.modKey = modKey;
+            }
+
+            @Override
+            public int hashCode() {
+                final int prime = 31;
+                int result = 1;
+                result = prime * result
+                    + ((modKey == null) ? 0 : modKey.hashCode());
+                return result;
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (this == obj)
+                    return true;
+                if (obj == null)
+                    return false;
+                if (getClass() != obj.getClass())
+                    return false;
+                InsertionStrategyKey other = (InsertionStrategyKey) obj;
+                if (modKey == null) {
+                    if (other.modKey != null)
+                        return false;
+                } else if (!modKey.equals(other.modKey))
+                    return false;
+                return true;
+            }
 
-    private static InsertionStrategy createInitialSolution(XMLConfiguration config, final VehicleRoutingProblem vrp, VehicleFleetManager vehicleFleetManager, final StateManager routeStates, Set<PrioritizedVRAListener> algorithmListeners, TypedMap definedClasses, ExecutorService executorService, int nuOfThreads, final SolutionCostCalculator solutionCostCalculator, ConstraintManager constraintManager, boolean addDefaultCostCalculators) {
-        List<HierarchicalConfiguration> modConfigs = config.configurationsAt("construction.insertion");
-        if (modConfigs == null) return null;
-        if (modConfigs.isEmpty()) return null;
-        if (modConfigs.size() != 1) throw new IllegalStateException("#construction.modules != 1. 1 expected");
-        HierarchicalConfiguration modConfig = modConfigs.get(0);
-        String insertionName = modConfig.getString("[@name]");
-        if (insertionName == null) throw new IllegalStateException("insertion[@name] is missing.");
-        String insertionId = modConfig.getString("[@id]");
-        if (insertionId == null) insertionId = "noId";
-        ModKey modKey = makeKey(insertionName, insertionId);
-        InsertionStrategyKey insertionStrategyKey = new InsertionStrategyKey(modKey);
-        InsertionStrategy insertionStrategy = definedClasses.get(insertionStrategyKey);
-        if (insertionStrategy == null) {
-            List<PrioritizedVRAListener> prioListeners = new ArrayList<PrioritizedVRAListener>();
-            insertionStrategy = createInsertionStrategy(modConfig, vrp, vehicleFleetManager, routeStates, prioListeners, executorService, nuOfThreads, constraintManager, addDefaultCostCalculators);
-            algorithmListeners.addAll(prioListeners);
-            definedClasses.put(insertionStrategyKey, insertionStrategy);
-        }
-        return insertionStrategy;
-    }
 
-    private static SolutionSelector getSelector(HierarchicalConfiguration strategyConfig, VehicleRoutingProblem vrp, Set<PrioritizedVRAListener> algorithmListeners, TypedMap definedSelectors) {
-        String selectorName = strategyConfig.getString("selector[@name]");
-        if (selectorName == null)
-            throw new IllegalStateException("no solutionSelector defined. define either \"selectRandomly\" or \"selectBest\"");
-        String selectorId = strategyConfig.getString("selector[@id]");
-        if (selectorId == null) selectorId = "noId";
-        ModKey modKey = makeKey(selectorName, selectorId);
-        SelectorKey selectorKey = new SelectorKey(modKey);
-        SolutionSelector definedSelector = definedSelectors.get(selectorKey);
-        if (definedSelector != null) {
-            return definedSelector;
-        }
-        if (selectorName.equals("selectRandomly")) {
-            SelectRandomly selector = SelectRandomly.getInstance();
-            definedSelectors.put(selectorKey, selector);
-            return selector;
-        }
-        if (selectorName.equals("selectBest")) {
-            SelectBest selector = SelectBest.getInstance();
-            definedSelectors.put(selectorKey, selector);
-            return selector;
+            @Override
+            public Class<InsertionStrategy> getType() {
+                return InsertionStrategy.class;
+            }
+
         }
-        throw new IllegalStateException("solutionSelector is not know. Currently, it only knows \"selectRandomly\" and \"selectBest\"");
     }
 
-    private static ModKey makeKey(String name, String id) {
-        return new ModKey(name, id);
-    }
+    static class ModKey {
+        private String name;
+        private String id;
 
-    private static SolutionAcceptor getAcceptor(HierarchicalConfiguration strategyConfig, VehicleRoutingProblem vrp, Set<PrioritizedVRAListener> algorithmListeners, TypedMap typedMap, int solutionMemory) {
-        String acceptorName = strategyConfig.getString("acceptor[@name]");
-        if (acceptorName == null) throw new IllegalStateException("no solution acceptor is defined");
-        String acceptorId = strategyConfig.getString("acceptor[@id]");
-        if (acceptorId == null) acceptorId = "noId";
-        AcceptorKey acceptorKey = new AcceptorKey(makeKey(acceptorName, acceptorId));
-        SolutionAcceptor definedAcceptor = typedMap.get(acceptorKey);
-        if (definedAcceptor != null) return definedAcceptor;
-        if (acceptorName.equals("acceptNewRemoveWorst")) {
-            GreedyAcceptance acceptor = new GreedyAcceptance(solutionMemory);
-            typedMap.put(acceptorKey, acceptor);
-            return acceptor;
-        }
-        if (acceptorName.equals("acceptNewRemoveFirst")) {
-            AcceptNewRemoveFirst acceptor = new AcceptNewRemoveFirst(solutionMemory);
-            typedMap.put(acceptorKey, acceptor);
-            return acceptor;
-        }
-        if (acceptorName.equals("greedyAcceptance")) {
-            GreedyAcceptance acceptor = new GreedyAcceptance(solutionMemory);
-            typedMap.put(acceptorKey, acceptor);
-            return acceptor;
+        public ModKey(String name, String id) {
+            super();
+            this.name = name;
+            this.id = id;
         }
-        if (acceptorName.equals("schrimpfAcceptance")) {
-            String nuWarmupIterations = strategyConfig.getString("acceptor.warmup");
-            double alpha = strategyConfig.getDouble("acceptor.alpha");
-            SchrimpfAcceptance schrimpf = new SchrimpfAcceptance(solutionMemory, alpha);
-            if (nuWarmupIterations != null) {
-                SchrimpfInitialThresholdGenerator iniThresholdGenerator = new SchrimpfInitialThresholdGenerator(schrimpf, Integer.parseInt(nuWarmupIterations));
-                algorithmListeners.add(new PrioritizedVRAListener(Priority.LOW, iniThresholdGenerator));
-            } else {
-                double threshold = strategyConfig.getDouble("acceptor.initialThreshold");
-                schrimpf.setInitialThreshold(threshold);
-            }
-            algorithmListeners.add(new PrioritizedVRAListener(Priority.LOW, schrimpf));
-            typedMap.put(acceptorKey, schrimpf);
-            return schrimpf;
+
+        @Override
+        public int hashCode() {
+            final int prime = 31;
+            int result = 1;
+            result = prime * result + ((id == null) ? 0 : id.hashCode());
+            result = prime * result + ((name == null) ? 0 : name.hashCode());
+            return result;
         }
-        if (acceptorName.equals("experimentalSchrimpfAcceptance")) {
-            int iterOfSchrimpf = strategyConfig.getInt("acceptor.warmup");
-            double alpha = strategyConfig.getDouble("acceptor.alpha");
-            ExperimentalSchrimpfAcceptance schrimpf = new ExperimentalSchrimpfAcceptance(solutionMemory, alpha, iterOfSchrimpf);
-            algorithmListeners.add(new PrioritizedVRAListener(Priority.LOW, schrimpf));
-            typedMap.put(acceptorKey, schrimpf);
-            return schrimpf;
-        } else {
-            throw new IllegalStateException("solution acceptor " + acceptorName + " is not known");
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj)
+                return true;
+            if (obj == null)
+                return false;
+            if (getClass() != obj.getClass())
+                return false;
+            ModKey other = (ModKey) obj;
+            if (id == null) {
+                if (other.id != null)
+                    return false;
+            } else if (!id.equals(other.id))
+                return false;
+            if (name == null) {
+                if (other.name != null)
+                    return false;
+            } else if (!name.equals(other.name))
+                return false;
+            return true;
         }
+
     }
 
-    private static SearchStrategyModule buildModule(HierarchicalConfiguration moduleConfig, final VehicleRoutingProblem vrp, VehicleFleetManager vehicleFleetManager,
-                                                    final StateManager routeStates, Set<PrioritizedVRAListener> algorithmListeners, TypedMap definedClasses, ExecutorService executorService, int nuOfThreads, ConstraintManager constraintManager, boolean addDefaultCostCalculators) {
-        String moduleName = moduleConfig.getString("[@name]");
-        if (moduleName == null) throw new IllegalStateException("module(-name) is missing.");
-        String moduleId = moduleConfig.getString("[@id]");
-        if (moduleId == null) moduleId = "noId";
-        ModKey modKey = makeKey(moduleName, moduleId);
-        StrategyModuleKey strategyModuleKey = new StrategyModuleKey(modKey);
-        SearchStrategyModule definedModule = definedClasses.get(strategyModuleKey);
-        if (definedModule != null) return definedModule;
+    private static class OpenRouteStateVerifier implements StateUpdater, ReverseActivityVisitor {
 
-        if (moduleName.equals("ruin_and_recreate")) {
-            String ruin_name = moduleConfig.getString("ruin[@name]");
-            if (ruin_name == null) throw new IllegalStateException("module.ruin[@name] is missing.");
-            String ruin_id = moduleConfig.getString("ruin[@id]");
-            if (ruin_id == null) ruin_id = "noId";
-            final RuinStrategy ruin;
-            ModKey ruinKey = makeKey(ruin_name, ruin_id);
-            if (ruin_name.equals("randomRuin")) {
-                String shareToRuinString = moduleConfig.getString("ruin.share");
-                if (shareToRuinString == null) throw new IllegalStateException("module.ruin.share is missing.");
-                double shareToRuin = Double.valueOf(shareToRuinString);
-                ruin = getRandomRuin(vrp, routeStates, definedClasses, ruinKey, shareToRuin);
-            } else if (ruin_name.equals("radialRuin")) {
-                String shareToRuinString = moduleConfig.getString("ruin.share");
-                if (shareToRuinString == null) throw new IllegalStateException("module.ruin.share is missing.");
-                double shareToRuin = Double.valueOf(shareToRuinString);
-                JobDistance jobDistance = new AvgServiceAndShipmentDistance(vrp.getTransportCosts());
-                ruin = getRadialRuin(vrp, routeStates, definedClasses, ruinKey, shareToRuin, jobDistance);
-            } else if (ruin_name.equals("clusterRuin")) {
-                String initialNumberJobsToRemoveString = moduleConfig.getString("ruin.initRemoveJobs");
-                if (initialNumberJobsToRemoveString == null) throw new IllegalStateException("module.ruin.initRemoveJobs is missing.");
-                int initialNumberJobsToRemove = Integer.valueOf(initialNumberJobsToRemoveString);
-            	ruin = getClusterRuin(vrp, routeStates, definedClasses, ruinKey, initialNumberJobsToRemove);
-            } else throw new IllegalStateException("ruin[@name] " + ruin_name + " is not known. Use either randomRuin or radialRuin.");
+        private End end;
 
-            String insertionName = moduleConfig.getString("insertion[@name]");
-            if (insertionName == null)
-                throw new IllegalStateException("module.insertion[@name] is missing. set it to \"regretInsertion\" or \"bestInsertion\"");
-            String insertionId = moduleConfig.getString("insertion[@id]");
-            if (insertionId == null) insertionId = "noId";
-            ModKey insertionKey = makeKey(insertionName, insertionId);
-            InsertionStrategyKey insertionStrategyKey = new InsertionStrategyKey(insertionKey);
-            InsertionStrategy insertion = definedClasses.get(insertionStrategyKey);
-            if (insertion == null) {
-                List<HierarchicalConfiguration> insertionConfigs = moduleConfig.configurationsAt("insertion");
-                if (insertionConfigs.size() != 1) throw new IllegalStateException("this should be 1");
-                List<PrioritizedVRAListener> prioListeners = new ArrayList<PrioritizedVRAListener>();
-                insertion = createInsertionStrategy(insertionConfigs.get(0), vrp, vehicleFleetManager, routeStates, prioListeners, executorService, nuOfThreads, constraintManager, addDefaultCostCalculators);
-                algorithmListeners.addAll(prioListeners);
-            }
-            final InsertionStrategy final_insertion = insertion;
+        private boolean firstAct = true;
 
-            RuinAndRecreateModule rrModule = new RuinAndRecreateModule("ruin_and_recreate", final_insertion, ruin);
-            return rrModule;
-        }
-        throw new NullPointerException("no module found with moduleName=" + moduleName +
-            "\n\tcheck config whether the correct names are used" +
-            "\n\tcurrently there are following modules available: " +
-            "\n\tbestInsertion" +
-            "\n\trandomRuin" +
-            "\n\tradialRuin" +
-            "\n\tclusterRuin");
-    }
+        private Vehicle vehicle;
 
-    private static RuinStrategy getRadialRuin(final VehicleRoutingProblem vrp, final StateManager routeStates, TypedMap definedClasses, ModKey modKey, double shareToRuin, JobDistance jobDistance) {
-        RuinStrategyKey stratKey = new RuinStrategyKey(modKey);
-        RuinStrategy ruin = definedClasses.get(stratKey);
-        if (ruin == null) {
-            ruin = new RadialRuinStrategyFactory(shareToRuin, jobDistance).createStrategy(vrp);
-            definedClasses.put(stratKey, ruin);
+        @Override
+        public void begin(VehicleRoute route) {
+            end = route.getEnd();
+            vehicle = route.getVehicle();
         }
-        return ruin;
-    }
 
-    private static RuinStrategy getClusterRuin(final VehicleRoutingProblem vrp, final StateManager routeStates, TypedMap definedClasses, ModKey modKey, int initialNumberJobsToRemove) {
-    	JobNeighborhoods jobNeighborhoods = new JobNeighborhoodsFactory().createNeighborhoods(vrp, new AvgServiceAndShipmentDistance(vrp.getTransportCosts()));
-    	RuinStrategyKey stratKey = new RuinStrategyKey(modKey);
-        RuinStrategy ruin = definedClasses.get(stratKey);
-        if (ruin == null) {
-        	ruin = new ClusterRuinStrategyFactory(initialNumberJobsToRemove, jobNeighborhoods).createStrategy(vrp);
-        	definedClasses.put(stratKey, ruin);
+        @Override
+        public void visit(TourActivity activity) {
+            if (firstAct) {
+                firstAct = false;
+                if (!vehicle.isReturnToDepot()) {
+                    assert activity.getLocation().getId().equals(end.getLocation().getId()) : "route end and last activity are not equal even route is open. this should not be.";
+                }
+            }
+
         }
-        return ruin;
-    }
 
-    private static RuinStrategy getRandomRuin(final VehicleRoutingProblem vrp, final StateManager routeStates, TypedMap definedClasses, ModKey modKey, double shareToRuin) {
-        RuinStrategyKey stratKey = new RuinStrategyKey(modKey);
-        RuinStrategy ruin = definedClasses.get(stratKey);
-        if (ruin == null) {
-            ruin = new RandomRuinStrategyFactory(shareToRuin).createStrategy(vrp);
-            definedClasses.put(stratKey, ruin);
+        @Override
+        public void finish() {
+            firstAct = true;
         }
-        return ruin;
-    }
 
-    private static InsertionStrategy createInsertionStrategy(HierarchicalConfiguration moduleConfig, VehicleRoutingProblem vrp, VehicleFleetManager vehicleFleetManager, StateManager routeStates, List<PrioritizedVRAListener> algorithmListeners, ExecutorService executorService, int nuOfThreads, ConstraintManager constraintManager, boolean addDefaultCostCalculators) {
-        return InsertionFactory.createInsertion(vrp, moduleConfig, vehicleFleetManager, routeStates, algorithmListeners, executorService, nuOfThreads, constraintManager, addDefaultCostCalculators);
     }
 
 
diff --git a/jsprit-io/src/main/java/com/graphhopper/jsprit/io/problem/Schema.java b/jsprit-io/src/main/java/com/graphhopper/jsprit/io/problem/Schema.java
index 1635841e1..70b074bd7 100644
--- a/jsprit-io/src/main/java/com/graphhopper/jsprit/io/problem/Schema.java
+++ b/jsprit-io/src/main/java/com/graphhopper/jsprit/io/problem/Schema.java
@@ -30,6 +30,14 @@
     public static final String TYPE = "type";
 
 
+    private Schema() {
+
+    }
+
+    public static PathBuilder builder() {
+        return new PathBuilder();
+    }
+
     public void dot() {
 
     }
@@ -55,12 +63,4 @@ public String build() {
         }
 
     }
-
-    public static PathBuilder builder() {
-        return new PathBuilder();
-    }
-
-    private Schema() {
-
-    }
 }
diff --git a/jsprit-io/src/main/java/com/graphhopper/jsprit/io/problem/VrpXMLReader.java b/jsprit-io/src/main/java/com/graphhopper/jsprit/io/problem/VrpXMLReader.java
index 504d39c44..a3fa26991 100644
--- a/jsprit-io/src/main/java/com/graphhopper/jsprit/io/problem/VrpXMLReader.java
+++ b/jsprit-io/src/main/java/com/graphhopper/jsprit/io/problem/VrpXMLReader.java
@@ -48,56 +48,16 @@
 
 public class VrpXMLReader {
 
-    public interface ServiceBuilderFactory {
-        Service.Builder createBuilder(String serviceType, String id, Integer size);
-    }
-
-    static class DefaultServiceBuilderFactory implements ServiceBuilderFactory {
-
-        @Override
-        public Service.Builder createBuilder(String serviceType, String id, Integer size) {
-            if (serviceType.equals("pickup")) {
-                if (size != null) return Pickup.Builder.newInstance(id).addSizeDimension(0, size);
-                else return Pickup.Builder.newInstance(id);
-            } else if (serviceType.equals("delivery")) {
-                if (size != null) return Delivery.Builder.newInstance(id).addSizeDimension(0, size);
-                else return Delivery.Builder.newInstance(id);
-            } else {
-                if (size != null) return Service.Builder.newInstance(id).addSizeDimension(0, size);
-                else return Service.Builder.newInstance(id);
-
-            }
-        }
-    }
-
     private static Logger logger = LoggerFactory.getLogger(VrpXMLReader.class);
-
     private VehicleRoutingProblem.Builder vrpBuilder;
-
     private Map<String, Vehicle> vehicleMap;
-
     private Map<String, Service> serviceMap;
-
     private Map<String, Shipment> shipmentMap;
-
     private Set<String> freezedJobIds = new HashSet<String>();
-
     private boolean schemaValidation = true;
-
     private Collection<VehicleRoutingProblemSolution> solutions;
-
     private ServiceBuilderFactory serviceBuilderFactory = new DefaultServiceBuilderFactory();
 
-
-
-    /**
-     * @param schemaValidation the schemaValidation to set
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public void setSchemaValidation(boolean schemaValidation) {
-        this.schemaValidation = schemaValidation;
-    }
-
     public VrpXMLReader(VehicleRoutingProblem.Builder vrpBuilder, Collection<VehicleRoutingProblemSolution> solutions) {
         this.vrpBuilder = vrpBuilder;
         this.vehicleMap = new LinkedHashMap<String, Vehicle>();
@@ -114,21 +74,21 @@ public VrpXMLReader(VehicleRoutingProblem.Builder vrpBuilder) {
         this.solutions = null;
     }
 
-    public void read(String filename) {
-        logger.debug("read vrp: {}", filename);
-        XMLConfiguration xmlConfig = createXMLConfiguration();
-        try {
-            xmlConfig.load(filename);
-        } catch (ConfigurationException e) {
-            throw new RuntimeException(e);
+    private static Coordinate getCoord(HierarchicalConfiguration serviceConfig, String prefix) {
+        Coordinate pickupCoord = null;
+        if (serviceConfig.getString(prefix + "coord[@x]") != null && serviceConfig.getString(prefix + "coord[@y]") != null) {
+            double x = Double.parseDouble(serviceConfig.getString(prefix + "coord[@x]"));
+            double y = Double.parseDouble(serviceConfig.getString(prefix + "coord[@y]"));
+            pickupCoord = Coordinate.newInstance(x, y);
         }
-        read(xmlConfig);
+        return pickupCoord;
     }
 
-    public void read(InputStream fileContents) {
+    public void read(String filename) {
+        logger.debug("read vrp: {}", filename);
         XMLConfiguration xmlConfig = createXMLConfiguration();
         try {
-            xmlConfig.load(fileContents);
+            xmlConfig.load(filename);
         } catch (ConfigurationException e) {
             throw new RuntimeException(e);
         }
@@ -175,171 +135,6 @@ private void read(XMLConfiguration xmlConfig) {
         addJobsAndTheirLocationsToVrp();
     }
 
-    private void addJobsAndTheirLocationsToVrp() {
-        for (Service service : serviceMap.values()) {
-            if (!freezedJobIds.contains(service.getId())) {
-                vrpBuilder.addJob(service);
-            }
-        }
-        for (Shipment shipment : shipmentMap.values()) {
-            if (!freezedJobIds.contains(shipment.getId())) {
-                vrpBuilder.addJob(shipment);
-            }
-        }
-    }
-
-    private void readInitialRoutes(XMLConfiguration xmlConfig) {
-        List<HierarchicalConfiguration> initialRouteConfigs = xmlConfig.configurationsAt("initialRoutes.route");
-        for (HierarchicalConfiguration routeConfig : initialRouteConfigs) {
-            Driver driver = DriverImpl.noDriver();
-            String vehicleId = routeConfig.getString("vehicleId");
-            Vehicle vehicle = getVehicle(vehicleId);
-            if (vehicle == null) throw new IllegalArgumentException("vehicle is missing.");
-            String start = routeConfig.getString("start");
-            if (start == null) throw new IllegalArgumentException("route start-time is missing.");
-            double departureTime = Double.parseDouble(start);
-
-            VehicleRoute.Builder routeBuilder = VehicleRoute.Builder.newInstance(vehicle, driver);
-            routeBuilder.setDepartureTime(departureTime);
-
-            List<HierarchicalConfiguration> actConfigs = routeConfig.configurationsAt("act");
-            for (HierarchicalConfiguration actConfig : actConfigs) {
-                String type = actConfig.getString("[@type]");
-                if (type == null) throw new IllegalArgumentException("act[@type] is missing.");
-                double arrTime = 0.;
-                double endTime = 0.;
-                String arrTimeS = actConfig.getString("arrTime");
-                if (arrTimeS != null) arrTime = Double.parseDouble(arrTimeS);
-                String endTimeS = actConfig.getString("endTime");
-                if (endTimeS != null) endTime = Double.parseDouble(endTimeS);
-
-                String serviceId = actConfig.getString("serviceId");
-                if(type.equals("break")) {
-                    Break currentbreak = getBreak(vehicleId);
-                    routeBuilder.addBreak(currentbreak);
-                }
-                else {
-                    if (serviceId != null) {
-                        Service service = getService(serviceId);
-                        if (service == null)
-                            throw new IllegalArgumentException("service to serviceId " + serviceId + " is missing (reference in one of your initial routes). make sure you define the service you refer to here in <services> </services>.");
-                        //!!!since job is part of initial route, it does not belong to jobs in problem, i.e. variable jobs that can be assigned/scheduled
-                        freezedJobIds.add(serviceId);
-                        routeBuilder.addService(service);
-                    } else {
-                        String shipmentId = actConfig.getString("shipmentId");
-                        if (shipmentId == null)
-                            throw new IllegalArgumentException("either serviceId or shipmentId is missing");
-                        Shipment shipment = getShipment(shipmentId);
-                        if (shipment == null)
-                            throw new IllegalArgumentException("shipment to shipmentId " + shipmentId + " is missing (reference in one of your initial routes). make sure you define the shipment you refer to here in <shipments> </shipments>.");
-                        freezedJobIds.add(shipmentId);
-                        if (type.equals("pickupShipment")) {
-                            routeBuilder.addPickup(shipment);
-                        } else if (type.equals("deliverShipment")) {
-                            routeBuilder.addDelivery(shipment);
-                        } else
-                            throw new IllegalArgumentException("type " + type + " is not supported. Use 'pickupShipment' or 'deliverShipment' here");
-                    }
-                }
-            }
-            VehicleRoute route = routeBuilder.build();
-            vrpBuilder.addInitialVehicleRoute(route);
-        }
-
-    }
-
-    private void readSolutions(XMLConfiguration vrpProblem) {
-        if (solutions == null) return;
-        List<HierarchicalConfiguration> solutionConfigs = vrpProblem.configurationsAt("solutions.solution");
-        for (HierarchicalConfiguration solutionConfig : solutionConfigs) {
-            String totalCost = solutionConfig.getString("cost");
-            double cost = -1;
-            if (totalCost != null) cost = Double.parseDouble(totalCost);
-            List<HierarchicalConfiguration> routeConfigs = solutionConfig.configurationsAt("routes.route");
-            List<VehicleRoute> routes = new ArrayList<VehicleRoute>();
-            for (HierarchicalConfiguration routeConfig : routeConfigs) {
-                //! here, driverId is set to noDriver, no matter whats in driverId.
-                Driver driver = DriverImpl.noDriver();
-                String vehicleId = routeConfig.getString("vehicleId");
-                Vehicle vehicle = getVehicle(vehicleId);
-                if (vehicle == null) throw new IllegalArgumentException("vehicle is missing.");
-                String start = routeConfig.getString("start");
-                if (start == null) throw new IllegalArgumentException("route start-time is missing.");
-                double departureTime = Double.parseDouble(start);
-
-                String end = routeConfig.getString("end");
-                if (end == null) throw new IllegalArgumentException("route end-time is missing.");
-
-                VehicleRoute.Builder routeBuilder = VehicleRoute.Builder.newInstance(vehicle, driver);
-                routeBuilder.setDepartureTime(departureTime);
-                List<HierarchicalConfiguration> actConfigs = routeConfig.configurationsAt("act");
-                for (HierarchicalConfiguration actConfig : actConfigs) {
-                    String type = actConfig.getString("[@type]");
-                    if (type == null) throw new IllegalArgumentException("act[@type] is missing.");
-                    double arrTime = 0.;
-                    double endTime = 0.;
-                    String arrTimeS = actConfig.getString("arrTime");
-                    if (arrTimeS != null) arrTime = Double.parseDouble(arrTimeS);
-                    String endTimeS = actConfig.getString("endTime");
-                    if (endTimeS != null) endTime = Double.parseDouble(endTimeS);
-                    if(type.equals("break")) {
-                        Break currentbreak = getBreak(vehicleId);
-                        routeBuilder.addBreak(currentbreak);
-                    }
-                    else {
-                        String serviceId = actConfig.getString("serviceId");
-                        if (serviceId != null) {
-                            Service service = getService(serviceId);
-                            routeBuilder.addService(service);
-                        } else {
-                            String shipmentId = actConfig.getString("shipmentId");
-                            if (shipmentId == null)
-                                throw new IllegalArgumentException("either serviceId or shipmentId is missing");
-                            Shipment shipment = getShipment(shipmentId);
-                            if (shipment == null)
-                                throw new IllegalArgumentException("shipment with id " + shipmentId + " does not exist.");
-                            if (type.equals("pickupShipment")) {
-                                routeBuilder.addPickup(shipment);
-                            } else if (type.equals("deliverShipment")) {
-                                routeBuilder.addDelivery(shipment);
-                            } else
-                                throw new IllegalArgumentException("type " + type + " is not supported. Use 'pickupShipment' or 'deliverShipment' here");
-                        }
-                    }
-                }
-                routes.add(routeBuilder.build());
-            }
-            VehicleRoutingProblemSolution solution = new VehicleRoutingProblemSolution(routes, cost);
-            List<HierarchicalConfiguration> unassignedJobConfigs = solutionConfig.configurationsAt("unassignedJobs.job");
-            for (HierarchicalConfiguration unassignedJobConfig : unassignedJobConfigs) {
-                String jobId = unassignedJobConfig.getString("[@id]");
-                Job job = getShipment(jobId);
-                if (job == null) job = getService(jobId);
-                if (job == null) throw new IllegalArgumentException("cannot find unassignedJob with id " + jobId);
-                solution.getUnassignedJobs().add(job);
-            }
-
-            solutions.add(solution);
-        }
-    }
-
-    private Shipment getShipment(String shipmentId) {
-        return shipmentMap.get(shipmentId);
-    }
-
-    private Service getService(String serviceId) {
-        return serviceMap.get(serviceId);
-    }
-
-    private Vehicle getVehicle(String vehicleId) {
-        return vehicleMap.get(vehicleId);
-    }
-
-    private Break getBreak(String vehicleId) {
-        return vehicleMap.get(vehicleId).getBreak();
-    }
-
     private void readProblemType(XMLConfiguration vrpProblem) {
         String fleetSize = vrpProblem.getString("problemType.fleetSize");
         if (fleetSize == null) vrpBuilder.setFleetSize(FleetSize.INFINITE);
@@ -348,6 +143,14 @@ else if (fleetSize.toUpperCase().equals(FleetSize.INFINITE.toString()))
         else vrpBuilder.setFleetSize(FleetSize.FINITE);
     }
 
+    /**
+     * @param schemaValidation the schemaValidation to set
+     */
+    @SuppressWarnings("UnusedDeclaration")
+    public void setSchemaValidation(boolean schemaValidation) {
+        this.schemaValidation = schemaValidation;
+    }
+
     private void readShipments(XMLConfiguration config) {
         List<HierarchicalConfiguration> shipmentConfigs = config.configurationsAt("shipments.shipment");
         for (HierarchicalConfiguration shipmentConfig : shipmentConfigs) {
@@ -462,16 +265,6 @@ private void readShipments(XMLConfiguration config) {
         }
     }
 
-    private static Coordinate getCoord(HierarchicalConfiguration serviceConfig, String prefix) {
-        Coordinate pickupCoord = null;
-        if (serviceConfig.getString(prefix + "coord[@x]") != null && serviceConfig.getString(prefix + "coord[@y]") != null) {
-            double x = Double.parseDouble(serviceConfig.getString(prefix + "coord[@x]"));
-            double y = Double.parseDouble(serviceConfig.getString(prefix + "coord[@y]"));
-            pickupCoord = Coordinate.newInstance(x, y);
-        }
-        return pickupCoord;
-    }
-
     private void readServices(XMLConfiguration vrpProblem) {
         List<HierarchicalConfiguration> serviceConfigs = vrpProblem.configurationsAt("services.service");
         for (HierarchicalConfiguration serviceConfig : serviceConfigs) {
@@ -584,12 +377,12 @@ private void readVehiclesAndTheirTypes(XMLConfiguration vrpProblem) {
             Double fix = typeConfig.getDouble("costs.fixed");
             Double timeC = typeConfig.getDouble("costs.time");
             Double distC = typeConfig.getDouble("costs.distance");
-            if(typeConfig.containsKey("costs.service")){
+            if (typeConfig.containsKey("costs.service")) {
                 Double serviceC = typeConfig.getDouble("costs.service");
                 if (serviceC != null) typeBuilder.setCostPerServiceTime(serviceC);
             }
 
-            if(typeConfig.containsKey("costs.wait")){
+            if (typeConfig.containsKey("costs.wait")) {
                 Double waitC = typeConfig.getDouble("costs.wait");
                 if (waitC != null) typeBuilder.setCostPerWaitingTime(waitC);
             }
@@ -705,7 +498,7 @@ private void readVehiclesAndTheirTypes(XMLConfiguration vrpProblem) {
                 Break.Builder current_break = Break.Builder.newInstance(id);
                 current_break.setServiceTime(Double.parseDouble(breakDurationString));
                 for (HierarchicalConfiguration twConfig : breakTWConfigs) {
-                	current_break.addTimeWindow(TimeWindow.newInstance(twConfig.getDouble("start"), twConfig.getDouble("end")));
+                    current_break.addTimeWindow(TimeWindow.newInstance(twConfig.getDouble("start"), twConfig.getDouble("end")));
                 }
                 builder.setBreak(current_break.build());
             }
@@ -719,5 +512,200 @@ private void readVehiclesAndTheirTypes(XMLConfiguration vrpProblem) {
 
     }
 
+    private void readInitialRoutes(XMLConfiguration xmlConfig) {
+        List<HierarchicalConfiguration> initialRouteConfigs = xmlConfig.configurationsAt("initialRoutes.route");
+        for (HierarchicalConfiguration routeConfig : initialRouteConfigs) {
+            Driver driver = DriverImpl.noDriver();
+            String vehicleId = routeConfig.getString("vehicleId");
+            Vehicle vehicle = getVehicle(vehicleId);
+            if (vehicle == null) throw new IllegalArgumentException("vehicle is missing.");
+            String start = routeConfig.getString("start");
+            if (start == null) throw new IllegalArgumentException("route start-time is missing.");
+            double departureTime = Double.parseDouble(start);
+
+            VehicleRoute.Builder routeBuilder = VehicleRoute.Builder.newInstance(vehicle, driver);
+            routeBuilder.setDepartureTime(departureTime);
+
+            List<HierarchicalConfiguration> actConfigs = routeConfig.configurationsAt("act");
+            for (HierarchicalConfiguration actConfig : actConfigs) {
+                String type = actConfig.getString("[@type]");
+                if (type == null) throw new IllegalArgumentException("act[@type] is missing.");
+                double arrTime = 0.;
+                double endTime = 0.;
+                String arrTimeS = actConfig.getString("arrTime");
+                if (arrTimeS != null) arrTime = Double.parseDouble(arrTimeS);
+                String endTimeS = actConfig.getString("endTime");
+                if (endTimeS != null) endTime = Double.parseDouble(endTimeS);
+
+                String serviceId = actConfig.getString("serviceId");
+                if (type.equals("break")) {
+                    Break currentbreak = getBreak(vehicleId);
+                    routeBuilder.addBreak(currentbreak);
+                } else {
+                    if (serviceId != null) {
+                        Service service = getService(serviceId);
+                        if (service == null)
+                            throw new IllegalArgumentException("service to serviceId " + serviceId + " is missing (reference in one of your initial routes). make sure you define the service you refer to here in <services> </services>.");
+                        //!!!since job is part of initial route, it does not belong to jobs in problem, i.e. variable jobs that can be assigned/scheduled
+                        freezedJobIds.add(serviceId);
+                        routeBuilder.addService(service);
+                    } else {
+                        String shipmentId = actConfig.getString("shipmentId");
+                        if (shipmentId == null)
+                            throw new IllegalArgumentException("either serviceId or shipmentId is missing");
+                        Shipment shipment = getShipment(shipmentId);
+                        if (shipment == null)
+                            throw new IllegalArgumentException("shipment to shipmentId " + shipmentId + " is missing (reference in one of your initial routes). make sure you define the shipment you refer to here in <shipments> </shipments>.");
+                        freezedJobIds.add(shipmentId);
+                        if (type.equals("pickupShipment")) {
+                            routeBuilder.addPickup(shipment);
+                        } else if (type.equals("deliverShipment")) {
+                            routeBuilder.addDelivery(shipment);
+                        } else
+                            throw new IllegalArgumentException("type " + type + " is not supported. Use 'pickupShipment' or 'deliverShipment' here");
+                    }
+                }
+            }
+            VehicleRoute route = routeBuilder.build();
+            vrpBuilder.addInitialVehicleRoute(route);
+        }
+
+    }
+
+    private Vehicle getVehicle(String vehicleId) {
+        return vehicleMap.get(vehicleId);
+    }
+
+    private Break getBreak(String vehicleId) {
+        return vehicleMap.get(vehicleId).getBreak();
+    }
+
+    private Service getService(String serviceId) {
+        return serviceMap.get(serviceId);
+    }
+
+    private Shipment getShipment(String shipmentId) {
+        return shipmentMap.get(shipmentId);
+    }
+
+    private void readSolutions(XMLConfiguration vrpProblem) {
+        if (solutions == null) return;
+        List<HierarchicalConfiguration> solutionConfigs = vrpProblem.configurationsAt("solutions.solution");
+        for (HierarchicalConfiguration solutionConfig : solutionConfigs) {
+            String totalCost = solutionConfig.getString("cost");
+            double cost = -1;
+            if (totalCost != null) cost = Double.parseDouble(totalCost);
+            List<HierarchicalConfiguration> routeConfigs = solutionConfig.configurationsAt("routes.route");
+            List<VehicleRoute> routes = new ArrayList<VehicleRoute>();
+            for (HierarchicalConfiguration routeConfig : routeConfigs) {
+                //! here, driverId is set to noDriver, no matter whats in driverId.
+                Driver driver = DriverImpl.noDriver();
+                String vehicleId = routeConfig.getString("vehicleId");
+                Vehicle vehicle = getVehicle(vehicleId);
+                if (vehicle == null) throw new IllegalArgumentException("vehicle is missing.");
+                String start = routeConfig.getString("start");
+                if (start == null) throw new IllegalArgumentException("route start-time is missing.");
+                double departureTime = Double.parseDouble(start);
+
+                String end = routeConfig.getString("end");
+                if (end == null) throw new IllegalArgumentException("route end-time is missing.");
+
+                VehicleRoute.Builder routeBuilder = VehicleRoute.Builder.newInstance(vehicle, driver);
+                routeBuilder.setDepartureTime(departureTime);
+                List<HierarchicalConfiguration> actConfigs = routeConfig.configurationsAt("act");
+                for (HierarchicalConfiguration actConfig : actConfigs) {
+                    String type = actConfig.getString("[@type]");
+                    if (type == null) throw new IllegalArgumentException("act[@type] is missing.");
+                    double arrTime = 0.;
+                    double endTime = 0.;
+                    String arrTimeS = actConfig.getString("arrTime");
+                    if (arrTimeS != null) arrTime = Double.parseDouble(arrTimeS);
+                    String endTimeS = actConfig.getString("endTime");
+                    if (endTimeS != null) endTime = Double.parseDouble(endTimeS);
+                    if (type.equals("break")) {
+                        Break currentbreak = getBreak(vehicleId);
+                        routeBuilder.addBreak(currentbreak);
+                    } else {
+                        String serviceId = actConfig.getString("serviceId");
+                        if (serviceId != null) {
+                            Service service = getService(serviceId);
+                            routeBuilder.addService(service);
+                        } else {
+                            String shipmentId = actConfig.getString("shipmentId");
+                            if (shipmentId == null)
+                                throw new IllegalArgumentException("either serviceId or shipmentId is missing");
+                            Shipment shipment = getShipment(shipmentId);
+                            if (shipment == null)
+                                throw new IllegalArgumentException("shipment with id " + shipmentId + " does not exist.");
+                            if (type.equals("pickupShipment")) {
+                                routeBuilder.addPickup(shipment);
+                            } else if (type.equals("deliverShipment")) {
+                                routeBuilder.addDelivery(shipment);
+                            } else
+                                throw new IllegalArgumentException("type " + type + " is not supported. Use 'pickupShipment' or 'deliverShipment' here");
+                        }
+                    }
+                }
+                routes.add(routeBuilder.build());
+            }
+            VehicleRoutingProblemSolution solution = new VehicleRoutingProblemSolution(routes, cost);
+            List<HierarchicalConfiguration> unassignedJobConfigs = solutionConfig.configurationsAt("unassignedJobs.job");
+            for (HierarchicalConfiguration unassignedJobConfig : unassignedJobConfigs) {
+                String jobId = unassignedJobConfig.getString("[@id]");
+                Job job = getShipment(jobId);
+                if (job == null) job = getService(jobId);
+                if (job == null) throw new IllegalArgumentException("cannot find unassignedJob with id " + jobId);
+                solution.getUnassignedJobs().add(job);
+            }
+
+            solutions.add(solution);
+        }
+    }
+
+    private void addJobsAndTheirLocationsToVrp() {
+        for (Service service : serviceMap.values()) {
+            if (!freezedJobIds.contains(service.getId())) {
+                vrpBuilder.addJob(service);
+            }
+        }
+        for (Shipment shipment : shipmentMap.values()) {
+            if (!freezedJobIds.contains(shipment.getId())) {
+                vrpBuilder.addJob(shipment);
+            }
+        }
+    }
+
+    public void read(InputStream fileContents) {
+        XMLConfiguration xmlConfig = createXMLConfiguration();
+        try {
+            xmlConfig.load(fileContents);
+        } catch (ConfigurationException e) {
+            throw new RuntimeException(e);
+        }
+        read(xmlConfig);
+    }
+
+    public interface ServiceBuilderFactory {
+        Service.Builder createBuilder(String serviceType, String id, Integer size);
+    }
+
+    static class DefaultServiceBuilderFactory implements ServiceBuilderFactory {
+
+        @Override
+        public Service.Builder createBuilder(String serviceType, String id, Integer size) {
+            if (serviceType.equals("pickup")) {
+                if (size != null) return Pickup.Builder.newInstance(id).addSizeDimension(0, size);
+                else return Pickup.Builder.newInstance(id);
+            } else if (serviceType.equals("delivery")) {
+                if (size != null) return Delivery.Builder.newInstance(id).addSizeDimension(0, size);
+                else return Delivery.Builder.newInstance(id);
+            } else {
+                if (size != null) return Service.Builder.newInstance(id).addSizeDimension(0, size);
+                else return Service.Builder.newInstance(id);
+
+            }
+        }
+    }
+
 
 }
diff --git a/jsprit-io/src/main/java/com/graphhopper/jsprit/io/problem/VrpXMLWriter.java b/jsprit-io/src/main/java/com/graphhopper/jsprit/io/problem/VrpXMLWriter.java
index 57ba77f2f..2ca71eb5d 100644
--- a/jsprit-io/src/main/java/com/graphhopper/jsprit/io/problem/VrpXMLWriter.java
+++ b/jsprit-io/src/main/java/com/graphhopper/jsprit/io/problem/VrpXMLWriter.java
@@ -50,19 +50,7 @@
 
 public class VrpXMLWriter {
 
-    static class XMLConf extends XMLConfiguration {
-
-
-        /**
-         *
-         */
-        private static final long serialVersionUID = 1L;
-
-        public Document createDoc() throws ConfigurationException {
-            return createDocument();
-        }
-    }
-
+    private static Logger logger = LoggerFactory.getLogger(VrpXMLWriter.class);
     private Logger log = LoggerFactory.getLogger(VrpXMLWriter.class);
 
     private VehicleRoutingProblem vrp;
@@ -87,8 +75,6 @@ public VrpXMLWriter(VehicleRoutingProblem vrp) {
         this.solutions = null;
     }
 
-    private static Logger logger = LoggerFactory.getLogger(VrpXMLWriter.class);
-
     public void write(String filename) {
         if (!filename.endsWith(".xml")) filename += ".xml";
         log.info("write vrp: " + filename);
@@ -140,7 +126,7 @@ private XMLConf createXMLConfiguration() {
         writeShipments(xmlConfig, jobs);
 
         writeInitialRoutes(xmlConfig);
-        if(onlyBestSolution && solutions != null) {
+        if (onlyBestSolution && solutions != null) {
             VehicleRoutingProblemSolution solution = Solutions.bestOf(solutions);
             solutions.clear();
             solutions.add(solution);
@@ -170,82 +156,73 @@ private OutputFormat createOutputFormat() {
         return format;
     }
 
-    private void writeInitialRoutes(XMLConf xmlConfig) {
-        if (vrp.getInitialVehicleRoutes().isEmpty()) return;
-        String path = "initialRoutes.route";
-        int routeCounter = 0;
-        for (VehicleRoute route : vrp.getInitialVehicleRoutes()) {
-            xmlConfig.setProperty(path + "(" + routeCounter + ").driverId", route.getDriver().getId());
-            xmlConfig.setProperty(path + "(" + routeCounter + ").vehicleId", route.getVehicle().getId());
-            xmlConfig.setProperty(path + "(" + routeCounter + ").start", route.getStart().getEndTime());
-            int actCounter = 0;
-            for (TourActivity act : route.getTourActivities().getActivities()) {
-                xmlConfig.setProperty(path + "(" + routeCounter + ").act(" + actCounter + ")[@type]", act.getName());
-                if (act instanceof TourActivity.JobActivity) {
-                    Job job = ((TourActivity.JobActivity) act).getJob();
-                    if (job instanceof Service) {
-                        xmlConfig.setProperty(path + "(" + routeCounter + ").act(" + actCounter + ").serviceId", job.getId());
-                    } else if (job instanceof Shipment) {
-                        xmlConfig.setProperty(path + "(" + routeCounter + ").act(" + actCounter + ").shipmentId", job.getId());
-                    } else if (job instanceof Break) {
-                    	xmlConfig.setProperty(path + "(" + routeCounter + ").act(" + actCounter + ").breakId", job.getId());
-                    } else {
-                        throw new IllegalStateException("cannot write solution correctly since job-type is not know. make sure you use either service or shipment, or another writer");
-                    }
-                }
-                xmlConfig.setProperty(path + "(" + routeCounter + ").act(" + actCounter + ").arrTime", act.getArrTime());
-                xmlConfig.setProperty(path + "(" + routeCounter + ").act(" + actCounter + ").endTime", act.getEndTime());
-                actCounter++;
+    private void writeVehiclesAndTheirTypes(XMLConfiguration xmlConfig) {
+
+        //vehicles
+        String vehiclePathString = Schema.VEHICLES + "." + Schema.VEHICLE;
+        int counter = 0;
+        for (Vehicle vehicle : vrp.getVehicles()) {
+            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").id", vehicle.getId());
+            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").typeId", vehicle.getType().getTypeId());
+            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").startLocation.id", vehicle.getStartLocation().getId());
+            if (vehicle.getStartLocation().getCoordinate() != null) {
+                xmlConfig.setProperty(vehiclePathString + "(" + counter + ").startLocation.coord[@x]", vehicle.getStartLocation().getCoordinate().getX());
+                xmlConfig.setProperty(vehiclePathString + "(" + counter + ").startLocation.coord[@y]", vehicle.getStartLocation().getCoordinate().getY());
+            }
+            if (vehicle.getStartLocation().getIndex() != Location.NO_INDEX) {
+                xmlConfig.setProperty(vehiclePathString + "(" + counter + ").startLocation.index", vehicle.getStartLocation().getIndex());
             }
-            xmlConfig.setProperty(path + "(" + routeCounter + ").end", route.getEnd().getArrTime());
-            routeCounter++;
-        }
 
-    }
+            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").endLocation.id", vehicle.getEndLocation().getId());
+            if (vehicle.getEndLocation().getCoordinate() != null) {
+                xmlConfig.setProperty(vehiclePathString + "(" + counter + ").endLocation.coord[@x]", vehicle.getEndLocation().getCoordinate().getX());
+                xmlConfig.setProperty(vehiclePathString + "(" + counter + ").endLocation.coord[@y]", vehicle.getEndLocation().getCoordinate().getY());
+            }
+            if (vehicle.getEndLocation().getIndex() != Location.NO_INDEX) {
+                xmlConfig.setProperty(vehiclePathString + "(" + counter + ").endLocation.index", vehicle.getEndLocation().getId());
+            }
+            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").timeSchedule.start", vehicle.getEarliestDeparture());
+            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").timeSchedule.end", vehicle.getLatestArrival());
 
-    private void writeSolutions(XMLConf xmlConfig) {
-        if (solutions == null) return;
-        String solutionPath = "solutions.solution";
-        int counter = 0;
-        for (VehicleRoutingProblemSolution solution : solutions) {
-            xmlConfig.setProperty(solutionPath + "(" + counter + ").cost", solution.getCost());
-            int routeCounter = 0;
-            List<VehicleRoute> list = new ArrayList<VehicleRoute>(solution.getRoutes());
-            Collections.sort(list , new VehicleIndexComparator());
-            for (VehicleRoute route : list) {
-//				xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").cost", route.getCost());
-                xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").driverId", route.getDriver().getId());
-                xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").vehicleId", route.getVehicle().getId());
-                xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").start", route.getStart().getEndTime());
-                int actCounter = 0;
-                for (TourActivity act : route.getTourActivities().getActivities()) {
-                    xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").act(" + actCounter + ")[@type]", act.getName());
-                    if (act instanceof TourActivity.JobActivity) {
-                        Job job = ((TourActivity.JobActivity) act).getJob();
-                        if (job instanceof Break) {
-                            xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").act(" + actCounter + ").breakId", job.getId());
-                        } else if (job instanceof Service) {
-                            xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").act(" + actCounter + ").serviceId", job.getId());
-                        } else if (job instanceof Shipment) {
-                            xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").act(" + actCounter + ").shipmentId", job.getId());
-                        } else {
-                            throw new IllegalStateException("cannot write solution correctly since job-type is not know. make sure you use either service or shipment, or another writer");
-                        }
-                    }
-                    xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").act(" + actCounter + ").arrTime", act.getArrTime());
-                    xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").act(" + actCounter + ").endTime", act.getEndTime());
-                    actCounter++;
+            if (vehicle.getBreak() != null) {
+                Collection<TimeWindow> tws = vehicle.getBreak().getTimeWindows();
+                int index = 0;
+                xmlConfig.setProperty(vehiclePathString + "(" + counter + ").breaks.duration", vehicle.getBreak().getServiceDuration());
+                for (TimeWindow tw : tws) {
+                    xmlConfig.setProperty(vehiclePathString + "(" + counter + ").breaks.timeWindows.timeWindow(" + index + ").start", tw.getStart());
+                    xmlConfig.setProperty(vehiclePathString + "(" + counter + ").breaks.timeWindows.timeWindow(" + index + ").end", tw.getEnd());
+                    ++index;
                 }
-                xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").end", route.getEnd().getArrTime());
-                routeCounter++;
-            }
-            int unassignedJobCounter = 0;
-            for (Job unassignedJob : solution.getUnassignedJobs()) {
-                xmlConfig.setProperty(solutionPath + "(" + counter + ").unassignedJobs.job(" + unassignedJobCounter + ")[@id]", unassignedJob.getId());
-                unassignedJobCounter++;
             }
+            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").returnToDepot", vehicle.isReturnToDepot());
+
+            //write skills
+            String skillString = getSkillString(vehicle);
+            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").skills", skillString);
+
             counter++;
         }
+
+        //types
+        String typePathString = Schema.builder().append(Schema.TYPES).dot(Schema.TYPE).build();
+        int typeCounter = 0;
+        for (VehicleType type : vrp.getTypes()) {
+            xmlConfig.setProperty(typePathString + "(" + typeCounter + ").id", type.getTypeId());
+
+            for (int i = 0; i < type.getCapacityDimensions().getNuOfDimensions(); i++) {
+                xmlConfig.setProperty(typePathString + "(" + typeCounter + ").capacity-dimensions.dimension(" + i + ")[@index]", i);
+                xmlConfig.setProperty(typePathString + "(" + typeCounter + ").capacity-dimensions.dimension(" + i + ")", type.getCapacityDimensions().get(i));
+            }
+
+            xmlConfig.setProperty(typePathString + "(" + typeCounter + ").costs.fixed", type.getVehicleCostParams().fix);
+            xmlConfig.setProperty(typePathString + "(" + typeCounter + ").costs.distance", type.getVehicleCostParams().perDistanceUnit);
+            xmlConfig.setProperty(typePathString + "(" + typeCounter + ").costs.time", type.getVehicleCostParams().perTransportTimeUnit);
+            xmlConfig.setProperty(typePathString + "(" + typeCounter + ").costs.service", type.getVehicleCostParams().perServiceTimeUnit);
+            xmlConfig.setProperty(typePathString + "(" + typeCounter + ").costs.wait", type.getVehicleCostParams().perWaitingTimeUnit);
+            typeCounter++;
+        }
+
+
     }
 
     private void writeServices(XMLConf xmlConfig, List<Job> jobs) {
@@ -273,10 +250,10 @@ private void writeServices(XMLConf xmlConfig, List<Job> jobs) {
             Collection<TimeWindow> tws = service.getTimeWindows();
             int index = 0;
             xmlConfig.setProperty(shipmentPathString + "(" + counter + ").duration", service.getServiceDuration());
-            for(TimeWindow tw : tws) {
-	            xmlConfig.setProperty(shipmentPathString + "(" + counter + ").timeWindows.timeWindow(" + index + ").start", tw.getStart());
-	            xmlConfig.setProperty(shipmentPathString + "(" + counter + ").timeWindows.timeWindow(" + index + ").end", tw.getEnd());
-	            ++index;
+            for (TimeWindow tw : tws) {
+                xmlConfig.setProperty(shipmentPathString + "(" + counter + ").timeWindows.timeWindow(" + index + ").start", tw.getStart());
+                xmlConfig.setProperty(shipmentPathString + "(" + counter + ").timeWindows.timeWindow(" + index + ").end", tw.getEnd());
+                ++index;
             }
 
             //skills
@@ -314,11 +291,11 @@ private void writeShipments(XMLConf xmlConfig, List<Job> jobs) {
             Collection<TimeWindow> pu_tws = shipment.getPickupTimeWindows();
             int index = 0;
             xmlConfig.setProperty(shipmentPathString + "(" + counter + ").pickup.duration", shipment.getPickupServiceTime());
-            for(TimeWindow tw : pu_tws) {
-	            xmlConfig.setProperty(shipmentPathString + "(" + counter + ").pickup.timeWindows.timeWindow(" + index + ").start", tw.getStart());
-	            xmlConfig.setProperty(shipmentPathString + "(" + counter + ").pickup.timeWindows.timeWindow(" + index + ").end", tw.getEnd());
-	            ++index;
-	        }
+            for (TimeWindow tw : pu_tws) {
+                xmlConfig.setProperty(shipmentPathString + "(" + counter + ").pickup.timeWindows.timeWindow(" + index + ").start", tw.getStart());
+                xmlConfig.setProperty(shipmentPathString + "(" + counter + ").pickup.timeWindows.timeWindow(" + index + ").end", tw.getEnd());
+                ++index;
+            }
 
             if (shipment.getDeliveryLocation().getId() != null)
                 xmlConfig.setProperty(shipmentPathString + "(" + counter + ").delivery.location.id", shipment.getDeliveryLocation().getId());
@@ -331,12 +308,12 @@ private void writeShipments(XMLConf xmlConfig, List<Job> jobs) {
             }
 
             Collection<TimeWindow> del_tws = shipment.getDeliveryTimeWindows();
-        	xmlConfig.setProperty(shipmentPathString + "(" + counter + ").delivery.duration", shipment.getDeliveryServiceTime());
-        	index = 0;
-            for(TimeWindow tw : del_tws) {
-            	xmlConfig.setProperty(shipmentPathString + "(" + counter + ").delivery.timeWindows.timeWindow(" + index + ").start", tw.getStart());
-            	xmlConfig.setProperty(shipmentPathString + "(" + counter + ").delivery.timeWindows.timeWindow(" + index + ").end", tw.getEnd());
-            	++index;
+            xmlConfig.setProperty(shipmentPathString + "(" + counter + ").delivery.duration", shipment.getDeliveryServiceTime());
+            index = 0;
+            for (TimeWindow tw : del_tws) {
+                xmlConfig.setProperty(shipmentPathString + "(" + counter + ").delivery.timeWindows.timeWindow(" + index + ").start", tw.getStart());
+                xmlConfig.setProperty(shipmentPathString + "(" + counter + ").delivery.timeWindows.timeWindow(" + index + ").end", tw.getEnd());
+                ++index;
             }
 
             for (int i = 0; i < shipment.getSize().getNuOfDimensions(); i++) {
@@ -358,77 +335,86 @@ private void writeShipments(XMLConf xmlConfig, List<Job> jobs) {
         }
     }
 
+    private void writeInitialRoutes(XMLConf xmlConfig) {
+        if (vrp.getInitialVehicleRoutes().isEmpty()) return;
+        String path = "initialRoutes.route";
+        int routeCounter = 0;
+        for (VehicleRoute route : vrp.getInitialVehicleRoutes()) {
+            xmlConfig.setProperty(path + "(" + routeCounter + ").driverId", route.getDriver().getId());
+            xmlConfig.setProperty(path + "(" + routeCounter + ").vehicleId", route.getVehicle().getId());
+            xmlConfig.setProperty(path + "(" + routeCounter + ").start", route.getStart().getEndTime());
+            int actCounter = 0;
+            for (TourActivity act : route.getTourActivities().getActivities()) {
+                xmlConfig.setProperty(path + "(" + routeCounter + ").act(" + actCounter + ")[@type]", act.getName());
+                if (act instanceof TourActivity.JobActivity) {
+                    Job job = ((TourActivity.JobActivity) act).getJob();
+                    if (job instanceof Service) {
+                        xmlConfig.setProperty(path + "(" + routeCounter + ").act(" + actCounter + ").serviceId", job.getId());
+                    } else if (job instanceof Shipment) {
+                        xmlConfig.setProperty(path + "(" + routeCounter + ").act(" + actCounter + ").shipmentId", job.getId());
+                    } else if (job instanceof Break) {
+                        xmlConfig.setProperty(path + "(" + routeCounter + ").act(" + actCounter + ").breakId", job.getId());
+                    } else {
+                        throw new IllegalStateException("cannot write solution correctly since job-type is not know. make sure you use either service or shipment, or another writer");
+                    }
+                }
+                xmlConfig.setProperty(path + "(" + routeCounter + ").act(" + actCounter + ").arrTime", act.getArrTime());
+                xmlConfig.setProperty(path + "(" + routeCounter + ").act(" + actCounter + ").endTime", act.getEndTime());
+                actCounter++;
+            }
+            xmlConfig.setProperty(path + "(" + routeCounter + ").end", route.getEnd().getArrTime());
+            routeCounter++;
+        }
+
+    }
+
     private void writeProblemType(XMLConfiguration xmlConfig) {
         xmlConfig.setProperty("problemType.fleetSize", vrp.getFleetSize());
     }
 
-    private void writeVehiclesAndTheirTypes(XMLConfiguration xmlConfig) {
-
-        //vehicles
-        String vehiclePathString = Schema.VEHICLES + "." + Schema.VEHICLE;
+    private void writeSolutions(XMLConf xmlConfig) {
+        if (solutions == null) return;
+        String solutionPath = "solutions.solution";
         int counter = 0;
-        for (Vehicle vehicle : vrp.getVehicles()) {
-            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").id", vehicle.getId());
-            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").typeId", vehicle.getType().getTypeId());
-            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").startLocation.id", vehicle.getStartLocation().getId());
-            if (vehicle.getStartLocation().getCoordinate() != null) {
-                xmlConfig.setProperty(vehiclePathString + "(" + counter + ").startLocation.coord[@x]", vehicle.getStartLocation().getCoordinate().getX());
-                xmlConfig.setProperty(vehiclePathString + "(" + counter + ").startLocation.coord[@y]", vehicle.getStartLocation().getCoordinate().getY());
-            }
-            if (vehicle.getStartLocation().getIndex() != Location.NO_INDEX) {
-                xmlConfig.setProperty(vehiclePathString + "(" + counter + ").startLocation.index", vehicle.getStartLocation().getIndex());
-            }
-
-            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").endLocation.id", vehicle.getEndLocation().getId());
-            if (vehicle.getEndLocation().getCoordinate() != null) {
-                xmlConfig.setProperty(vehiclePathString + "(" + counter + ").endLocation.coord[@x]", vehicle.getEndLocation().getCoordinate().getX());
-                xmlConfig.setProperty(vehiclePathString + "(" + counter + ").endLocation.coord[@y]", vehicle.getEndLocation().getCoordinate().getY());
+        for (VehicleRoutingProblemSolution solution : solutions) {
+            xmlConfig.setProperty(solutionPath + "(" + counter + ").cost", solution.getCost());
+            int routeCounter = 0;
+            List<VehicleRoute> list = new ArrayList<VehicleRoute>(solution.getRoutes());
+            Collections.sort(list, new VehicleIndexComparator());
+            for (VehicleRoute route : list) {
+//				xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").cost", route.getCost());
+                xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").driverId", route.getDriver().getId());
+                xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").vehicleId", route.getVehicle().getId());
+                xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").start", route.getStart().getEndTime());
+                int actCounter = 0;
+                for (TourActivity act : route.getTourActivities().getActivities()) {
+                    xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").act(" + actCounter + ")[@type]", act.getName());
+                    if (act instanceof TourActivity.JobActivity) {
+                        Job job = ((TourActivity.JobActivity) act).getJob();
+                        if (job instanceof Break) {
+                            xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").act(" + actCounter + ").breakId", job.getId());
+                        } else if (job instanceof Service) {
+                            xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").act(" + actCounter + ").serviceId", job.getId());
+                        } else if (job instanceof Shipment) {
+                            xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").act(" + actCounter + ").shipmentId", job.getId());
+                        } else {
+                            throw new IllegalStateException("cannot write solution correctly since job-type is not know. make sure you use either service or shipment, or another writer");
+                        }
+                    }
+                    xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").act(" + actCounter + ").arrTime", act.getArrTime());
+                    xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").act(" + actCounter + ").endTime", act.getEndTime());
+                    actCounter++;
+                }
+                xmlConfig.setProperty(solutionPath + "(" + counter + ").routes.route(" + routeCounter + ").end", route.getEnd().getArrTime());
+                routeCounter++;
             }
-            if (vehicle.getEndLocation().getIndex() != Location.NO_INDEX) {
-                xmlConfig.setProperty(vehiclePathString + "(" + counter + ").endLocation.index", vehicle.getEndLocation().getId());
+            int unassignedJobCounter = 0;
+            for (Job unassignedJob : solution.getUnassignedJobs()) {
+                xmlConfig.setProperty(solutionPath + "(" + counter + ").unassignedJobs.job(" + unassignedJobCounter + ")[@id]", unassignedJob.getId());
+                unassignedJobCounter++;
             }
-            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").timeSchedule.start", vehicle.getEarliestDeparture());
-            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").timeSchedule.end", vehicle.getLatestArrival());
-
-            if (vehicle.getBreak() != null) {
-                Collection<TimeWindow> tws = vehicle.getBreak().getTimeWindows();
-                int index = 0;
-	            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").breaks.duration", vehicle.getBreak().getServiceDuration());
-                for(TimeWindow tw : tws) {
-		            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").breaks.timeWindows.timeWindow(" + index + ").start", tw.getStart());
-		            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").breaks.timeWindows.timeWindow(" + index + ").end", tw.getEnd());
-		            ++index;
-                }
-	        }
-            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").returnToDepot", vehicle.isReturnToDepot());
-
-            //write skills
-            String skillString = getSkillString(vehicle);
-            xmlConfig.setProperty(vehiclePathString + "(" + counter + ").skills", skillString);
-
             counter++;
         }
-
-        //types
-        String typePathString = Schema.builder().append(Schema.TYPES).dot(Schema.TYPE).build();
-        int typeCounter = 0;
-        for (VehicleType type : vrp.getTypes()) {
-            xmlConfig.setProperty(typePathString + "(" + typeCounter + ").id", type.getTypeId());
-
-            for (int i = 0; i < type.getCapacityDimensions().getNuOfDimensions(); i++) {
-                xmlConfig.setProperty(typePathString + "(" + typeCounter + ").capacity-dimensions.dimension(" + i + ")[@index]", i);
-                xmlConfig.setProperty(typePathString + "(" + typeCounter + ").capacity-dimensions.dimension(" + i + ")", type.getCapacityDimensions().get(i));
-            }
-
-            xmlConfig.setProperty(typePathString + "(" + typeCounter + ").costs.fixed", type.getVehicleCostParams().fix);
-            xmlConfig.setProperty(typePathString + "(" + typeCounter + ").costs.distance", type.getVehicleCostParams().perDistanceUnit);
-            xmlConfig.setProperty(typePathString + "(" + typeCounter + ").costs.time", type.getVehicleCostParams().perTransportTimeUnit);
-            xmlConfig.setProperty(typePathString + "(" + typeCounter + ").costs.service", type.getVehicleCostParams().perServiceTimeUnit);
-            xmlConfig.setProperty(typePathString + "(" + typeCounter + ").costs.wait", type.getVehicleCostParams().perWaitingTimeUnit);
-            typeCounter++;
-        }
-
-
     }
 
     private String getSkillString(Vehicle vehicle) {
@@ -449,6 +435,19 @@ private String createSkillString(Skills skills) {
         return skillString;
     }
 
+    static class XMLConf extends XMLConfiguration {
+
+
+        /**
+         *
+         */
+        private static final long serialVersionUID = 1L;
+
+        public Document createDoc() throws ConfigurationException {
+            return createDocument();
+        }
+    }
+
 
 }
 
diff --git a/jsprit-io/src/main/resources/algorithm_schema.xsd b/jsprit-io/src/main/resources/algorithm_schema.xsd
index d8bd7ec27..94ba462ac 100644
--- a/jsprit-io/src/main/resources/algorithm_schema.xsd
+++ b/jsprit-io/src/main/resources/algorithm_schema.xsd
@@ -206,11 +206,11 @@
                 </xs:simpleType>
             </xs:element>
             <xs:element name="initRemoveJobs" minOccurs="0" maxOccurs="1">
-              <xs:simpleType>
-                <xs:restriction base="xs:integer">
-                  <xs:minInclusive value="1"/>
-                </xs:restriction>
-              </xs:simpleType>
+                <xs:simpleType>
+                    <xs:restriction base="xs:integer">
+                        <xs:minInclusive value="1"/>
+                    </xs:restriction>
+                </xs:simpleType>
             </xs:element>
             <xs:element name="distance" minOccurs="0" maxOccurs="1">
                 <xs:simpleType>
diff --git a/jsprit-io/src/main/resources/greedySchrimpf.xml b/jsprit-io/src/main/resources/greedySchrimpf.xml
index 773b031f3..794dc50b9 100755
--- a/jsprit-io/src/main/resources/greedySchrimpf.xml
+++ b/jsprit-io/src/main/resources/greedySchrimpf.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <iterations>2000</iterations>
diff --git a/jsprit-io/src/main/resources/randomWalk.xml b/jsprit-io/src/main/resources/randomWalk.xml
index bf3da3e39..2af01a2fa 100755
--- a/jsprit-io/src/main/resources/randomWalk.xml
+++ b/jsprit-io/src/main/resources/randomWalk.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <construction>
diff --git a/jsprit-io/src/main/resources/schrimpf.xml b/jsprit-io/src/main/resources/schrimpf.xml
index 46d2bf82e..eee0f6171 100755
--- a/jsprit-io/src/main/resources/schrimpf.xml
+++ b/jsprit-io/src/main/resources/schrimpf.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <iterations>2000</iterations>
diff --git a/jsprit-io/src/main/resources/vrp_xml_schema.xsd b/jsprit-io/src/main/resources/vrp_xml_schema.xsd
index 04a36b26d..723ea54de 100644
--- a/jsprit-io/src/main/resources/vrp_xml_schema.xsd
+++ b/jsprit-io/src/main/resources/vrp_xml_schema.xsd
@@ -388,12 +388,12 @@
         <xs:sequence>
             <xs:element name="timeWindows" minOccurs="0" maxOccurs="1">
                 <xs:complexType>
-	                <xs:sequence>
-	                  <xs:element name="timeWindow" type="timeWindowType" minOccurs="1"
-	                          maxOccurs="unbounded"/>
-	                </xs:sequence>
+                    <xs:sequence>
+                        <xs:element name="timeWindow" type="timeWindowType" minOccurs="1"
+                                    maxOccurs="unbounded"/>
+                    </xs:sequence>
                 </xs:complexType>
-              </xs:element>
+            </xs:element>
             <xs:element name="duration" type="xs:double" minOccurs="1" maxOccurs="1" default="0.0"/>
             <xs:element name="id" type="xs:string" minOccurs="1" maxOccurs="1"/>
         </xs:sequence>
diff --git a/jsprit-io/src/test/java/com/graphhopper/jsprit/io/algorithm/TestAlgorithmReader.java b/jsprit-io/src/test/java/com/graphhopper/jsprit/io/algorithm/TestAlgorithmReader.java
index 3c69ab6ed..a4977a1d6 100644
--- a/jsprit-io/src/test/java/com/graphhopper/jsprit/io/algorithm/TestAlgorithmReader.java
+++ b/jsprit-io/src/test/java/com/graphhopper/jsprit/io/algorithm/TestAlgorithmReader.java
@@ -74,17 +74,6 @@ public void itShouldReadMaxIterations() {
         Assert.assertEquals(2000, vra.getMaxIterations());
     }
 
-    static class IterationCounter implements IterationEndsListener {
-
-        int iterations = 0;
-
-        @Override
-        public void informIterationEnds(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
-            iterations = i;
-        }
-
-    }
-
     @Test
     public void whenSettingPrematureBreak_itShouldReadTermination() {
         VehicleRoutingAlgorithm vra = VehicleRoutingAlgorithms.readAndCreateAlgorithm(vrp, getClass().getResource("algorithmConfigForReaderTest2.xml"));
@@ -103,7 +92,6 @@ public void itShouldReadTermination() {
         Assert.assertEquals(25, iCounter.iterations);
     }
 
-
     @Test
     public void testTypedMap() {
         VehicleRoutingAlgorithms.TypedMap typedMap = new VehicleRoutingAlgorithms.TypedMap();
@@ -283,4 +271,15 @@ public void readerTest_whenReadingAlgoWithSchemaValidationWithoutIterations_itRe
 
     }
 
+    static class IterationCounter implements IterationEndsListener {
+
+        int iterations = 0;
+
+        @Override
+        public void informIterationEnds(int i, VehicleRoutingProblem problem, Collection<VehicleRoutingProblemSolution> solutions) {
+            iterations = i;
+        }
+
+    }
+
 }
diff --git a/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/InitialRoutesTest.java b/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/InitialRoutesTest.java
index 526bbc132..a976ed86b 100644
--- a/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/InitialRoutesTest.java
+++ b/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/InitialRoutesTest.java
@@ -45,6 +45,14 @@ public void whenReading_jobMapShouldOnlyContainJob2() {
         assertTrue(vrp.getJobs().containsKey("2"));
     }
 
+    private int getNuServices(VehicleRoutingProblem vrp) {
+        int nuServices = 0;
+        for (Job job : vrp.getJobs().values()) {
+            if (job instanceof Service) nuServices++;
+        }
+        return nuServices;
+    }
+
     @Test
     public void whenReadingProblem2_jobMapShouldContain_service2() {
 
@@ -75,14 +83,6 @@ private int getNuShipments(VehicleRoutingProblem vrp) {
         return nuShipments;
     }
 
-    private int getNuServices(VehicleRoutingProblem vrp) {
-        int nuServices = 0;
-        for (Job job : vrp.getJobs().values()) {
-            if (job instanceof Service) nuServices++;
-        }
-        return nuServices;
-    }
-
     @Test
     public void whenReading_thereShouldBeOnlyOneActAssociatedToJob2() {
 
diff --git a/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/VrpXMLReaderTest.java b/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/VrpXMLReaderTest.java
index ce322cbdb..19d4a0286 100644
--- a/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/VrpXMLReaderTest.java
+++ b/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/VrpXMLReaderTest.java
@@ -85,6 +85,14 @@ public void whenReadingVrp_vehiclesAreReadCorrectly() {
         assertTrue(idsInCollection(Arrays.asList("v1", "v2"), vrp.getVehicles()));
     }
 
+    private boolean idsInCollection(List<String> asList, Collection<Vehicle> vehicles) {
+        List<String> ids = new ArrayList<String>(asList);
+        for (Vehicle v : vehicles) {
+            if (ids.contains(v.getId())) ids.remove(v.getId());
+        }
+        return ids.isEmpty();
+    }
+
     @Test
     public void whenReadingVrp_vehiclesAreReadCorrectly2() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
@@ -102,6 +110,11 @@ public void whenReadingVrp_vehiclesAreReadCorrectly2() {
         assertEquals(1000.0, v1.getLatestArrival(), 0.01);
     }
 
+    private Vehicle getVehicle(String string, Collection<Vehicle> vehicles) {
+        for (Vehicle v : vehicles) if (string.equals(v.getId())) return v;
+        return null;
+    }
+
     @Test
     public void whenReadingVehicles_skill1ShouldBeAssigned() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
@@ -138,19 +151,6 @@ public void whenReadingVehicles_nuSkillsOfV2ShouldBeCorrect() {
         assertEquals(0, v.getSkills().values().size());
     }
 
-    private Vehicle getVehicle(String string, Collection<Vehicle> vehicles) {
-        for (Vehicle v : vehicles) if (string.equals(v.getId())) return v;
-        return null;
-    }
-
-    private boolean idsInCollection(List<String> asList, Collection<Vehicle> vehicles) {
-        List<String> ids = new ArrayList<String>(asList);
-        for (Vehicle v : vehicles) {
-            if (ids.contains(v.getId())) ids.remove(v.getId());
-        }
-        return ids.isEmpty();
-    }
-
     @Test
     public void whenReadingVrp_vehicleTypesAreReadCorrectly() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
diff --git a/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/VrpXMLWriterTest.java b/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/VrpXMLWriterTest.java
index 57f743261..1b003f379 100644
--- a/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/VrpXMLWriterTest.java
+++ b/jsprit-io/src/test/java/com/graphhopper/jsprit/io/problem/VrpXMLWriterTest.java
@@ -62,6 +62,28 @@ public void whenWritingServices_itWritesThemCorrectly() {
         assertEquals(2.0, s1_read.getServiceDuration(), 0.01);
     }
 
+    private VehicleRoutingProblem.Builder twoVehicleTypesAndImpls() {
+        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
+
+        VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
+        VehicleTypeImpl type2 = VehicleTypeImpl.Builder.newInstance("vehType2").addCapacityDimension(0, 200).build();
+        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(TestUtils.loc("loc")).setType(type1).build();
+        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(TestUtils.loc("loc")).setType(type2).build();
+
+        builder.addVehicle(v1);
+        builder.addVehicle(v2);
+        return builder;
+    }
+
+    private VehicleRoutingProblem writeAndRereadXml(VehicleRoutingProblem vrp) {
+        VrpXMLWriter vrpXMLWriter = new VrpXMLWriter(vrp, null);
+        ByteArrayOutputStream os = (ByteArrayOutputStream) vrpXMLWriter.write();
+        ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
+        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
+        new VrpXMLReader(vrpToReadBuilder, null).read(is);
+        return vrpToReadBuilder.build();
+    }
+
     @Test
     public void shouldWriteNameOfService() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
@@ -241,6 +263,13 @@ public void whenWritingVehicles_vehShouldHave3Skills() {
         assertTrue(veh1.getSkills().containsSkill("skill2"));
     }
 
+    private Vehicle getVehicle(String v1, VehicleRoutingProblem readVrp) {
+        for (Vehicle v : readVrp.getVehicles()) {
+            if (v.getId().equals(v1)) return v;
+        }
+        return null;
+    }
+
     @Test
     public void whenWritingVehicles_vehShouldHave0Skills() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
@@ -255,13 +284,6 @@ public void whenWritingVehicles_vehShouldHave0Skills() {
         assertEquals(0, veh.getSkills().values().size());
     }
 
-    private Vehicle getVehicle(String v1, VehicleRoutingProblem readVrp) {
-        for (Vehicle v : readVrp.getVehicles()) {
-            if (v.getId().equals(v1)) return v;
-        }
-        return null;
-    }
-
     @Test
     public void whenWritingShipments_shipmentShouldHaveCorrectNuSkills() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
@@ -354,17 +376,9 @@ public void whenWritingVehicleV1_itsStartLocationMustBeWrittenCorrectly() {
 
     }
 
-    private VehicleRoutingProblem.Builder twoVehicleTypesAndImpls() {
-        VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
-
-        VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("vehType").addCapacityDimension(0, 20).build();
-        VehicleTypeImpl type2 = VehicleTypeImpl.Builder.newInstance("vehType2").addCapacityDimension(0, 200).build();
-        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(TestUtils.loc("loc")).setType(type1).build();
-        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(TestUtils.loc("loc")).setType(type2).build();
-
-        builder.addVehicle(v1);
-        builder.addVehicle(v2);
-        return builder;
+    private Vehicle getVehicle(String string, Collection<Vehicle> vehicles) {
+        for (Vehicle v : vehicles) if (string.equals(v.getId())) return v;
+        return null;
     }
 
     @Test
@@ -384,7 +398,6 @@ public void whenWritingService_itShouldContain_bothSkills() {
         assertTrue(readVrp.getJobs().get("1").getRequiredSkills().containsSkill("skill2"));
     }
 
-
     @Test
     public void whenWritingVehicleV1_itDoesNotReturnToDepotMustBeWrittenCorrectly() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
@@ -484,7 +497,6 @@ public void whenWritingVehicleV2_readingItsLocationsAgainReturnsCorrectLocations
         assertEquals(5.0, v.getEndLocation().getCoordinate().getY(), 0.01);
     }
 
-
     @Test
     public void whenWritingVehicleWithSeveralCapacityDimensions_itShouldBeWrittenAndRereadCorrectly() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
@@ -534,11 +546,6 @@ public void whenWritingVehicleWithSeveralCapacityDimensions_itShouldBeWrittenAnd
         assertEquals(10000, v.getType().getCapacityDimensions().get(10));
     }
 
-    private Vehicle getVehicle(String string, Collection<Vehicle> vehicles) {
-        for (Vehicle v : vehicles) if (string.equals(v.getId())) return v;
-        return null;
-    }
-
     @Test
     public void solutionWithoutUnassignedJobsShouldBeWrittenCorrectly() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
@@ -566,6 +573,16 @@ public void solutionWithoutUnassignedJobsShouldBeWrittenCorrectly() {
         assertTrue(Solutions.bestOf(solutionsToRead).getUnassignedJobs().isEmpty());
     }
 
+    private List<VehicleRoutingProblemSolution> writeAndRereadXmlWithSolutions(VehicleRoutingProblem vrp, List<VehicleRoutingProblemSolution> solutions) {
+        VrpXMLWriter vrpXMLWriter = new VrpXMLWriter(vrp, solutions);
+        ByteArrayOutputStream os = (ByteArrayOutputStream) vrpXMLWriter.write();
+        ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
+        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
+        List<VehicleRoutingProblemSolution> solutionsToRead = new ArrayList<VehicleRoutingProblemSolution>();
+        new VrpXMLReader(vrpToReadBuilder, solutionsToRead).read(is);
+        return solutionsToRead;
+    }
+
     @Test
     public void solutionWithUnassignedJobsShouldBeWrittenCorrectly() {
         VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
@@ -610,23 +627,4 @@ public void outputStreamAndFileContentsAreEqual() throws IOException {
 
     }
 
-    private VehicleRoutingProblem writeAndRereadXml(VehicleRoutingProblem vrp) {
-        VrpXMLWriter vrpXMLWriter = new VrpXMLWriter(vrp, null);
-        ByteArrayOutputStream os = (ByteArrayOutputStream) vrpXMLWriter.write();
-        ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        new VrpXMLReader(vrpToReadBuilder, null).read(is);
-        return vrpToReadBuilder.build();
-    }
-
-    private List<VehicleRoutingProblemSolution> writeAndRereadXmlWithSolutions(VehicleRoutingProblem vrp, List<VehicleRoutingProblemSolution> solutions) {
-        VrpXMLWriter vrpXMLWriter = new VrpXMLWriter(vrp, solutions);
-        ByteArrayOutputStream os = (ByteArrayOutputStream) vrpXMLWriter.write();
-        ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
-        VehicleRoutingProblem.Builder vrpToReadBuilder = VehicleRoutingProblem.Builder.newInstance();
-        List<VehicleRoutingProblemSolution> solutionsToRead = new ArrayList<VehicleRoutingProblemSolution>();
-        new VrpXMLReader(vrpToReadBuilder, solutionsToRead).read(is);
-        return solutionsToRead;
-    }
-
 }
diff --git a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/algorithmConfig.xml b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/algorithmConfig.xml
index e04ea9d7f..76a7e012b 100755
--- a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/algorithmConfig.xml
+++ b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/algorithmConfig.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <iterations>2000</iterations>
diff --git a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/algorithmConfigForReaderTest.xml b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/algorithmConfigForReaderTest.xml
index 32dc119b5..e7165d85b 100755
--- a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/algorithmConfigForReaderTest.xml
+++ b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/algorithmConfigForReaderTest.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <maxIterations>2000</maxIterations>
diff --git a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/algorithmConfigForReaderTest2.xml b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/algorithmConfigForReaderTest2.xml
index 0a6d353de..671c57bfb 100755
--- a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/algorithmConfigForReaderTest2.xml
+++ b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/algorithmConfigForReaderTest2.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <maxIterations>2000</maxIterations>
diff --git a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/algorithmConfig_withoutIterations.xml b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/algorithmConfig_withoutIterations.xml
index bee7bafc1..04d2a8d6a 100755
--- a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/algorithmConfig_withoutIterations.xml
+++ b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/algorithmConfig_withoutIterations.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<algorithm xmlns="http://www.w3schools.com"
-           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<algorithm xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+           xmlns="http://www.w3schools.com"
            xsi:schemaLocation="http://www.w3schools.com algorithm_schema.xsd">
 
     <construction>
diff --git a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/finiteVrp.xml b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/finiteVrp.xml
index 3922801a8..75a826b02 100644
--- a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/finiteVrp.xml
+++ b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/algorithm/finiteVrp.xml
@@ -18,8 +18,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>FINITE</fleetSize>
diff --git a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/biggerProblem.xml b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/biggerProblem.xml
index df987d508..1b37c5c87 100644
--- a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/biggerProblem.xml
+++ b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/biggerProblem.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>FINITE</fleetSize>
diff --git a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/finiteVrpForReaderTest.xml b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/finiteVrpForReaderTest.xml
index dd028c412..29919c637 100644
--- a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/finiteVrpForReaderTest.xml
+++ b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/finiteVrpForReaderTest.xml
@@ -18,8 +18,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>FINITE</fleetSize>
diff --git a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/finiteVrpWithInitialSolutionForReaderTest.xml b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/finiteVrpWithInitialSolutionForReaderTest.xml
index 5fba42b89..ec040e3e0 100644
--- a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/finiteVrpWithInitialSolutionForReaderTest.xml
+++ b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/finiteVrpWithInitialSolutionForReaderTest.xml
@@ -18,8 +18,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>FINITE</fleetSize>
diff --git a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/finiteVrpWithShipmentsAndSolution.xml b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/finiteVrpWithShipmentsAndSolution.xml
index 7e342b012..83ed38760 100644
--- a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/finiteVrpWithShipmentsAndSolution.xml
+++ b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/finiteVrpWithShipmentsAndSolution.xml
@@ -18,8 +18,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>FINITE</fleetSize>
diff --git a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/lui-shen-solution.xml b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/lui-shen-solution.xml
index c9b5028a9..5d5bab1a1 100644
--- a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/lui-shen-solution.xml
+++ b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/lui-shen-solution.xml
@@ -18,8 +18,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>INFINITE</fleetSize>
diff --git a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/simpleProblem_inclShipments_iniRoutes.xml b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/simpleProblem_inclShipments_iniRoutes.xml
index 7241b0df9..f08f4b4b6 100644
--- a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/simpleProblem_inclShipments_iniRoutes.xml
+++ b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/simpleProblem_inclShipments_iniRoutes.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>FINITE</fleetSize>
diff --git a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/simpleProblem_iniRoutes.xml b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/simpleProblem_iniRoutes.xml
index 73afd47cb..25373c253 100644
--- a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/simpleProblem_iniRoutes.xml
+++ b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/simpleProblem_iniRoutes.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>FINITE</fleetSize>
diff --git a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/simpleProblem_iniRoutes_2.xml b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/simpleProblem_iniRoutes_2.xml
index 884be64c5..320c73391 100644
--- a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/simpleProblem_iniRoutes_2.xml
+++ b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/simpleProblem_iniRoutes_2.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>FINITE</fleetSize>
diff --git a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/simpleProblem_iniRoutes_3.xml b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/simpleProblem_iniRoutes_3.xml
index 187454e9d..20720ace8 100644
--- a/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/simpleProblem_iniRoutes_3.xml
+++ b/jsprit-io/src/test/resources/com/graphhopper/jsprit/io/problem/simpleProblem_iniRoutes_3.xml
@@ -17,8 +17,8 @@
   ~ limitations under the License.
   -->
 
-<problem xmlns="http://www.w3schools.com"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+<problem xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns="http://www.w3schools.com"
          xsi:schemaLocation="http://www.w3schools.com vrp_xml_schema.xsd">
     <problemType>
         <fleetSize>FINITE</fleetSize>
diff --git a/pom.xml b/pom.xml
index 3740641cd..dc6c8f073 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,4 +1,3 @@
-
 <!--
 ~ Licensed to GraphHopper GmbH under one or more contributor
 ~ license agreements. See the NOTICE file distributed with this work for
@@ -17,7 +16,8 @@
 ~ limitations under the License.
 -->
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
 
     <groupId>com.graphhopper</groupId>
