diff --git a/.travis.yml b/.travis.yml
index 2406cbd9d..ccb8fd913 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,6 +1,4 @@
 language: java
 jdk:
-  - openjdk7
-  - oraclejdk7
   - oraclejdk8
 
diff --git a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsRecorder.java b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsRecorder.java
index 46714ced9..764a7bf8c 100644
--- a/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsRecorder.java
+++ b/jsprit-analysis/src/main/java/com/graphhopper/jsprit/analysis/toolbox/AlgorithmEventsRecorder.java
@@ -25,6 +25,7 @@
 import java.util.List;
 import java.util.zip.GZIPOutputStream;
 
+import com.graphhopper.jsprit.core.algorithm.recreate.InsertActivity;
 import org.graphstream.graph.Edge;
 import org.graphstream.graph.Graph;
 import org.graphstream.graph.Node;
@@ -442,17 +443,19 @@ private void insertJob(Job job, InsertionData data, VehicleRoute route) {
     private void insertShipment(Job job, InsertionData data, VehicleRoute route) {
         String fromNodeId = getFromNodeId((Shipment) job);
         String toNodeId = getToNodeId((Shipment) job);
-        insertNode(toNodeId, data.getDeliveryInsertionIndex(), data, route);
+        int deliveryIndex = data.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex();
+        insertNode(toNodeId, deliveryIndex, data, route);
 
         List<JobActivity> del = vrp.getActivities(job);
         VehicleRoute copied = VehicleRoute.copyOf(route);
-        copied.getTourActivities().addActivity(data.getDeliveryInsertionIndex(), del.get(1));
+        copied.getTourActivities().addActivity(deliveryIndex, del.get(1));
 
-        insertNode(fromNodeId, data.getPickupInsertionIndex(), data, copied);
+        int pickupIndex = data.getUnmodifiableEventsByType(InsertActivity.class).get(1).getIndex();
+        insertNode(fromNodeId, pickupIndex, data, copied);
     }
 
     private void insertService(Job job, InsertionData data, VehicleRoute route) {
-        insertNode(job.getId(), data.getDeliveryInsertionIndex(), data, route);
+        insertNode(job.getId(), data.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex(), data, route);
     }
 
     private void insertNode(String nodeId, int insertionIndex, InsertionData data, VehicleRoute route) {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertActivity.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertActivity.java
index 7af91cbd5..326239d33 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertActivity.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertActivity.java
@@ -25,7 +25,7 @@
 /**
  * Created by schroeder on 19/05/15.
  */
-class InsertActivity implements Event {
+public class InsertActivity implements Event {
 
     private VehicleRoute vehicleRoute;
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertBreak.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertBreak.java
index fc4a03539..5eb33a0c9 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertBreak.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertBreak.java
@@ -25,7 +25,7 @@
 /**
  * Created by schroeder on 19/05/15.
  */
-class InsertBreak implements Event {
+public class InsertBreak implements Event {
 
     private VehicleRoute vehicleRoute;
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/Inserter.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/Inserter.java
deleted file mode 100644
index c5f2fadda..000000000
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/Inserter.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import java.util.List;
-
-import com.graphhopper.jsprit.core.algorithm.recreate.InsertionData.NoInsertionFound;
-import com.graphhopper.jsprit.core.algorithm.recreate.listener.InsertionListeners;
-import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
-import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.job.Service;
-import com.graphhopper.jsprit.core.problem.job.Shipment;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.DefaultTourActivityFactory;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-
-class Inserter {
-
-    private abstract class JobInsertionHandler {
-
-        private JobInsertionHandler delegator = null;
-
-        public abstract void handleJobInsertion(Job job, InsertionData iData, VehicleRoute route);
-
-        public JobInsertionHandler withNextHandler(JobInsertionHandler handler) {
-            delegator = handler;
-            return this;
-        }
-
-        protected void delegate(Job job, InsertionData iData, VehicleRoute route) {
-            if (delegator != null) {
-            delegator.handleJobInsertion(job, iData, route);
-        }
-    }
-    }
-
-    class JobExceptionHandler extends JobInsertionHandler {
-
-        @Override
-        public void handleJobInsertion(Job job, InsertionData iData, VehicleRoute route) {
-            throw new IllegalStateException("job insertion is not supported. Do not know job type.");
-        }
-
-    }
-
-
-    private class UnifiedInsertionHandler extends JobInsertionHandler {
-
-        public UnifiedInsertionHandler() {
-        }
-
-        @Override
-        public void handleJobInsertion(Job job, InsertionData iData, VehicleRoute route) {
-            route.setVehicleAndDepartureTime(iData.getSelectedVehicle(), iData.getVehicleDepartureTime());
-            if (!iData.getSelectedVehicle().isReturnToDepot()) {
-                if (iData.getDeliveryInsertionIndex() >= route.getActivities().size()) {
-                    route.getEnd().setLocation(job.getEndLocation());
-                }
-            }
-
-            List<JobActivity> acts = job.getActivityList().getAllDuplicated();
-            acts.forEach(act -> route.getTourActivities().addActivity(iData.getDeliveryInsertionIndex(), act));
-
-            // Handles all // delegator.handleJobInsertion(job, iData, route);
-        }
-    }
-
-    private class ServiceInsertionHandler extends JobInsertionHandler {
-
-        @Override
-        public void handleJobInsertion(Job job, InsertionData iData, VehicleRoute route) {
-            if (job instanceof Service) {
-                route.setVehicleAndDepartureTime(iData.getSelectedVehicle(),
-                                iData.getVehicleDepartureTime());
-                if (!iData.getSelectedVehicle().isReturnToDepot()) {
-                    if (iData.getDeliveryInsertionIndex() >= route.getTourActivities()
-                                    .getActivities().size()) {
-                        setEndLocation(route, (Service) job);
-                    }
-                }
-                TourActivity activity = job.getActivityList().getAllDuplicated().get(0);
-                route.getTourActivities().addActivity(iData.getDeliveryInsertionIndex(), activity);
-            } else {
-                delegate(job, iData, route);
-            }
-        }
-
-        private void setEndLocation(VehicleRoute route, Service service) {
-            route.getEnd().setLocation(service.getLocation());
-        }
-    }
-
-    private class ShipmentInsertionHandler extends JobInsertionHandler {
-
-        @Override
-        public void handleJobInsertion(Job job, InsertionData iData, VehicleRoute route) {
-            if (job instanceof Shipment) {
-                List<JobActivity> acts = job.getActivityList().getAllDuplicated(); // vehicleRoutingProblem.copyAndGetActivities(job);
-                TourActivity pickupShipment = acts.get(0);
-                TourActivity deliverShipment = acts.get(1);
-                route.setVehicleAndDepartureTime(iData.getSelectedVehicle(),
-                                iData.getVehicleDepartureTime());
-                if (!iData.getSelectedVehicle().isReturnToDepot()) {
-                    if (iData.getDeliveryInsertionIndex() >= route.getActivities().size()) {
-                        setEndLocation(route, (Shipment) job);
-                    }
-                }
-                route.getTourActivities().addActivity(iData.getDeliveryInsertionIndex(),
-                                deliverShipment);
-                route.getTourActivities().addActivity(iData.getPickupInsertionIndex(),
-                                pickupShipment);
-            } else {
-                delegate(job, iData, route);
-            }
-        }
-
-        private void setEndLocation(VehicleRoute route, Shipment shipment) {
-            route.getEnd().setLocation(shipment.getDeliveryLocation());
-        }
-    }
-
-    private InsertionListeners insertionListeners;
-
-    private JobInsertionHandler jobInsertionHandler;
-
-    private VehicleRoutingProblem vehicleRoutingProblem;
-
-    public Inserter(InsertionListeners insertionListeners, VehicleRoutingProblem vehicleRoutingProblem) {
-        this.insertionListeners = insertionListeners;
-        new DefaultTourActivityFactory();
-
-        // Balage1551 - The new, unified handler
-        // There is a problem: how to handle uniformly insertation indexes for
-        // multiple activities
-        // jobInsertionHandler = new UnifiedInsertionHandler();
-
-        //The old ones:
-        jobInsertionHandler = new ServiceInsertionHandler().withNextHandler(
-                        new ShipmentInsertionHandler().withNextHandler(new JobExceptionHandler()));
-    }
-
-    public void insertJob(Job job, InsertionData insertionData, VehicleRoute vehicleRoute) {
-        insertionListeners.informBeforeJobInsertion(job, insertionData, vehicleRoute);
-
-        if (insertionData == null || (insertionData instanceof NoInsertionFound)) {
-            throw new IllegalStateException("insertionData null. cannot insert job.");
-        }
-        if (job == null) {
-            throw new IllegalStateException("cannot insert null-job");
-        }
-        if (!(vehicleRoute.getVehicle().getId().equals(insertionData.getSelectedVehicle().getId()))) {
-            insertionListeners.informVehicleSwitched(vehicleRoute, vehicleRoute.getVehicle(), insertionData.getSelectedVehicle());
-            vehicleRoute.setVehicleAndDepartureTime(insertionData.getSelectedVehicle(), insertionData.getVehicleDepartureTime());
-        }
-        jobInsertionHandler.handleJobInsertion(job, insertionData, vehicleRoute);
-
-        insertionListeners.informJobInserted(job, vehicleRoute, insertionData.getInsertionCost(), insertionData.getAdditionalTime());
-    }
-}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionData.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionData.java
index ac4911c2a..d1c9fe0bb 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionData.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionData.java
@@ -18,8 +18,10 @@
 package com.graphhopper.jsprit.core.algorithm.recreate;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
+
 import com.graphhopper.jsprit.core.problem.driver.Driver;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 
@@ -57,9 +59,9 @@ public static InsertionData createEmptyInsertionData() {
 
     private final double insertionCost;
 
-    private final int pickupInsertionIndex;
+    private int pickupInsertionIndex;
 
-    private final int deliveryInsertionIndex;
+    private int deliveryInsertionIndex;
 
     private final Vehicle selectedVehicle;
 
@@ -69,12 +71,23 @@ public static InsertionData createEmptyInsertionData() {
 
     private double additionalTime;
 
-    private List<Event> events = new ArrayList<Event>();
+    private List<Event> events = new ArrayList<>();
 
     List<Event> getEvents() {
         return events;
     }
 
+    public List<Event> getUnmodifiableEvents() { return Collections.unmodifiableList(events); }
+
+    public <T extends Event> List<T> getUnmodifiableEventsByType(Class<T> eventType){
+        List<T> events = new ArrayList<>();
+        for(Event e : this.events){
+            if(e.getClass().equals(eventType)){
+                events.add(eventType.cast(e));
+            }
+        }
+        return events;
+    }
     /**
      * @return the additionalTime
      */
@@ -85,10 +98,12 @@ public double getAdditionalTime() {
     /**
      * @param additionalTime the additionalTime to set
      */
+    @Deprecated
     public void setAdditionalTime(double additionalTime) {
         this.additionalTime = additionalTime;
     }
 
+    @Deprecated
     public InsertionData(double insertionCost, int pickupInsertionIndex, int deliveryInsertionIndex, Vehicle vehicle, Driver driver) {
         this.insertionCost = insertionCost;
         this.pickupInsertionIndex = pickupInsertionIndex;
@@ -97,6 +112,13 @@ public InsertionData(double insertionCost, int pickupInsertionIndex, int deliver
         this.selectedDriver = driver;
     }
 
+    public InsertionData(double insertionCost, double vehicleDepartureTime, Vehicle selectedVehicle, Driver selectedDriver){
+        this.insertionCost = insertionCost;
+        this.selectedVehicle = selectedVehicle;
+        this.selectedDriver = selectedDriver;
+        this.departureTime = vehicleDepartureTime;
+    }
+
     @Override
     public String toString() {
         return "[iCost=" + insertionCost + "][pickupIndex=" + pickupInsertionIndex + "][deliveryIndex=" + deliveryInsertionIndex + "][depTime=" + departureTime + "][vehicle=" + selectedVehicle + "][driver=" + selectedDriver + "]";
@@ -107,6 +129,7 @@ public String toString() {
      *
      * @return
      */
+    @Deprecated
     public int getDeliveryInsertionIndex() {
         return deliveryInsertionIndex;
     }
@@ -116,6 +139,7 @@ public int getDeliveryInsertionIndex() {
      *
      * @return
      */
+    @Deprecated
     public int getPickupInsertionIndex() {
         return pickupInsertionIndex;
     }
@@ -157,6 +181,7 @@ public double getVehicleDepartureTime() {
     /**
      * @param departureTime the departureTime to set
      */
+    @Deprecated
     public void setVehicleDepartureTime(double departureTime) {
         this.departureTime = departureTime;
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionDataUpdater.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionDataUpdater.java
index bbbc1a3a3..72e368399 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionDataUpdater.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/InsertionDataUpdater.java
@@ -69,12 +69,9 @@ static VehicleRoute findRoute(Collection<VehicleRoute> routes, Job job) {
     }
 
     static Comparator<VersionedInsertionData> getComparator(){
-        return new Comparator<VersionedInsertionData>() {
-            @Override
-            public int compare(VersionedInsertionData o1, VersionedInsertionData o2) {
-                if(o1.getiData().getInsertionCost() < o2.getiData().getInsertionCost()) return -1;
-                return 1;
-            }
+        return (o1, o2) -> {
+            if(o1.getiData().getInsertionCost() < o2.getiData().getInsertionCost()) return -1;
+            return 1;
         };
     }
 
@@ -105,9 +102,7 @@ static ScoredJob getBest(boolean switchAllowed, Set<String> initialVehicleIds, V
                         Vehicle available = fleetManager.getAvailableVehicle(versionedIData.getiData().getSelectedVehicle().getVehicleTypeIdentifier());
                         if (available != null) {
                             InsertionData oldData = versionedIData.getiData();
-                            InsertionData newData = new InsertionData(oldData.getInsertionCost(), oldData.getPickupInsertionIndex(),
-                                oldData.getDeliveryInsertionIndex(), available, oldData.getSelectedDriver());
-                            newData.setVehicleDepartureTime(oldData.getVehicleDepartureTime());
+                            InsertionData newData = new InsertionData(oldData.getInsertionCost(),oldData.getVehicleDepartureTime(),available, oldData.getSelectedDriver());
                             for(Event e : oldData.getEvents()){
                                 if(e instanceof SwitchVehicle){
                                     newData.getEvents().add(new SwitchVehicle(versionedIData.getRoute(),available,oldData.getVehicleDepartureTime()));
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionConsideringFixCostsCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionConsideringFixCostsCalculator.java
index 99a3de89e..8943d1251 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionConsideringFixCostsCalculator.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionConsideringFixCostsCalculator.java
@@ -62,8 +62,7 @@ public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job
             return iData;
         }
         double totalInsertionCost = iData.getInsertionCost() + fixcost_contribution;
-        InsertionData insertionData = new InsertionData(totalInsertionCost, iData.getPickupInsertionIndex(), iData.getDeliveryInsertionIndex(), newVehicle, newDriver);
-        insertionData.setVehicleDepartureTime(newVehicleDepartureTime);
+        InsertionData insertionData = new InsertionData(totalInsertionCost, newVehicleDepartureTime, newVehicle, newDriver);
         insertionData.getEvents().addAll(iData.getEvents());
         return insertionData;
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java
index c02f41129..99e233659 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/JobInsertionCostsCalculatorBuilder.java
@@ -330,32 +330,7 @@ private CalculatorPlusListeners createCalculatorConsideringFixedCosts(VehicleRou
     }
 
     private CalculatorPlusListeners createStandardRoute(final VehicleRoutingProblem vrp, RouteAndActivityStateGetter activityStates2, int forwardLooking, int solutionMemory) {
-        ActivityInsertionCostsCalculator routeLevelCostEstimator;
-        if (activityInsertionCostCalculator == null && addDefaultCostCalc) {
-            RouteLevelActivityInsertionCostsEstimator routeLevelActivityInsertionCostsEstimator = new RouteLevelActivityInsertionCostsEstimator(vrp.getTransportCosts(), vrp.getActivityCosts(), activityStates2);
-            routeLevelActivityInsertionCostsEstimator.setForwardLooking(forwardLooking);
-            routeLevelCostEstimator = routeLevelActivityInsertionCostsEstimator;
-        } else if (activityInsertionCostCalculator == null && !addDefaultCostCalc) {
-            routeLevelCostEstimator = new ActivityInsertionCostsCalculator() {
-
-                final ActivityInsertionCosts noInsertionCosts = new ActivityInsertionCosts(0., 0.);
-
-                @Override
-                public double getCosts(JobInsertionContext iContext, TourActivity prevAct, TourActivity nextAct, TourActivity newAct,
-                        double depTimeAtPrevAct) {
-                    return 0.;
-                }
-
-            };
-        } else {
-            routeLevelCostEstimator = activityInsertionCostCalculator;
-        }
-        ServiceInsertionOnRouteLevelCalculator jobInsertionCalculator = new ServiceInsertionOnRouteLevelCalculator(vrp.getTransportCosts(), vrp.getActivityCosts(), routeLevelCostEstimator, constraintManager, constraintManager);
-        jobInsertionCalculator.setNuOfActsForwardLooking(forwardLooking);
-        jobInsertionCalculator.setMemorySize(solutionMemory);
-        jobInsertionCalculator.setStates(activityStates2);
-        jobInsertionCalculator.setJobActivityFactory(new CopyJobActivityFactory());
-        return new CalculatorPlusListeners(jobInsertionCalculator);
+        throw new UnsupportedOperationException("route level insertion calculation is not supported anymore");
     }
 
     private JobInsertionCostsCalculator createFinalInsertion(VehicleFleetManager fleetManager, JobInsertionCostsCalculator baseCalc, RouteAndActivityStateGetter activityStates2) {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RouteLevelActivityInsertionCostsEstimator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RouteLevelActivityInsertionCostsEstimator.java
deleted file mode 100644
index d6fc01b48..000000000
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/RouteLevelActivityInsertionCostsEstimator.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import com.graphhopper.jsprit.core.algorithm.state.InternalStates;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.Start;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.state.RouteAndActivityStateGetter;
-
-import java.util.ArrayList;
-import java.util.List;
-
-@Deprecated
-class RouteLevelActivityInsertionCostsEstimator implements ActivityInsertionCostsCalculator {
-
-    private VehicleRoutingActivityCosts activityCosts;
-
-    private AuxilliaryCostCalculator auxilliaryPathCostCalculator;
-
-    private RouteAndActivityStateGetter stateManager;
-
-    private int nuOfActivities2LookForward = 0;
-
-    public RouteLevelActivityInsertionCostsEstimator(VehicleRoutingTransportCosts routingCosts, VehicleRoutingActivityCosts actCosts, RouteAndActivityStateGetter stateManager) {
-        super();
-        this.activityCosts = actCosts;
-        this.stateManager = stateManager;
-        auxilliaryPathCostCalculator = new AuxilliaryCostCalculator(routingCosts, activityCosts);
-    }
-
-    @Override
-    public double getCosts(JobInsertionContext iFacts, TourActivity prevAct, TourActivity nextAct, TourActivity newAct, double depTimeAtPrevAct) {
-        List<TourActivity> path = new ArrayList<TourActivity>();
-        path.add(prevAct);
-        path.add(newAct);
-        path.add(nextAct);
-        int actIndex;
-        if (prevAct instanceof Start) actIndex = 0;
-        else actIndex = iFacts.getRoute().getTourActivities().getActivities().indexOf(nextAct);
-        if (nuOfActivities2LookForward > 0 && !(nextAct instanceof End)) {
-            path.addAll(getForwardLookingPath(iFacts.getRoute(), actIndex));
-        }
-
-		/*
-         * calculates the path costs with new vehicle, c(forwardPath,newVehicle).
-		 */
-        double forwardPathCost_newVehicle = auxilliaryPathCostCalculator.costOfPath(path, depTimeAtPrevAct, iFacts.getNewDriver(), iFacts.getNewVehicle());
-        return forwardPathCost_newVehicle - (actCostsOld(iFacts.getRoute(), path.get(path.size() - 1)) - actCostsOld(iFacts.getRoute(), prevAct));
-    }
-
-    private double actCostsOld(VehicleRoute vehicleRoute, TourActivity act) {
-        Double cost_at_act;
-        if (act instanceof End) {
-            cost_at_act = stateManager.getRouteState(vehicleRoute, InternalStates.COSTS, Double.class);
-        } else {
-            cost_at_act = stateManager.getActivityState(act, InternalStates.COSTS, Double.class);
-        }
-        if (cost_at_act == null) cost_at_act = 0.;
-        return cost_at_act;
-    }
-
-    private List<TourActivity> getForwardLookingPath(VehicleRoute route, int actIndex) {
-        List<TourActivity> forwardLookingPath = new ArrayList<TourActivity>();
-        int nuOfActsInPath = 0;
-        int index = actIndex + 1;
-        while (index < route.getTourActivities().getActivities().size() && nuOfActsInPath < nuOfActivities2LookForward) {
-            forwardLookingPath.add(route.getTourActivities().getActivities().get(index));
-            index++;
-            nuOfActsInPath++;
-        }
-        if (nuOfActsInPath < nuOfActivities2LookForward) {
-            forwardLookingPath.add(route.getEnd());
-        }
-        return forwardLookingPath;
-    }
-
-    public void setForwardLooking(int nActivities) {
-        this.nuOfActivities2LookForward = nActivities;
-    }
-}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionOnRouteLevelCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionOnRouteLevelCalculator.java
deleted file mode 100644
index f8ea375a0..000000000
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionOnRouteLevelCalculator.java
+++ /dev/null
@@ -1,333 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import java.util.ArrayList;
-import java.util.Comparator;
-import java.util.List;
-import java.util.PriorityQueue;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import com.graphhopper.jsprit.core.algorithm.state.InternalStates;
-import com.graphhopper.jsprit.core.problem.JobActivityFactory;
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.constraint.HardActivityConstraint;
-import com.graphhopper.jsprit.core.problem.constraint.HardActivityConstraint.ConstraintsStatus;
-import com.graphhopper.jsprit.core.problem.constraint.HardRouteConstraint;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.job.Service;
-import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.Start;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivities;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.state.RouteAndActivityStateGetter;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
-
-@Deprecated
-final class ServiceInsertionOnRouteLevelCalculator implements JobInsertionCostsCalculator {
-
-    private static final Logger logger = LoggerFactory.getLogger(ServiceInsertionOnRouteLevelCalculator.class);
-
-    private final VehicleRoutingTransportCosts transportCosts;
-
-    private final VehicleRoutingActivityCosts activityCosts;
-
-    private AuxilliaryCostCalculator auxilliaryPathCostCalculator;
-
-    private JobActivityFactory activityFactory;
-
-    private RouteAndActivityStateGetter stateManager;
-
-    private HardRouteConstraint hardRouteLevelConstraint;
-
-    private HardActivityConstraint hardActivityLevelConstraint;
-
-    private ActivityInsertionCostsCalculator activityInsertionCostsCalculator;
-
-    private int nuOfActsForwardLooking = 0;
-    //
-    private int memorySize = 2;
-
-    private Start start;
-
-    private End end;
-
-    public void setJobActivityFactory(JobActivityFactory jobActivityFactory) {
-        this.activityFactory = jobActivityFactory;
-    }
-
-    public void setMemorySize(int memorySize) {
-        this.memorySize = memorySize;
-        logger.debug("set [solutionMemory={}]", memorySize);
-    }
-
-    public ServiceInsertionOnRouteLevelCalculator(VehicleRoutingTransportCosts vehicleRoutingCosts, VehicleRoutingActivityCosts costFunc, ActivityInsertionCostsCalculator activityInsertionCostsCalculator, HardRouteConstraint hardRouteLevelConstraint, HardActivityConstraint hardActivityLevelConstraint) {
-        super();
-        this.transportCosts = vehicleRoutingCosts;
-        this.activityCosts = costFunc;
-        this.activityInsertionCostsCalculator = activityInsertionCostsCalculator;
-        this.hardRouteLevelConstraint = hardRouteLevelConstraint;
-        this.hardActivityLevelConstraint = hardActivityLevelConstraint;
-        auxilliaryPathCostCalculator = new AuxilliaryCostCalculator(transportCosts, activityCosts);
-        logger.debug("initialise {}", this);
-    }
-
-
-    public void setStates(RouteAndActivityStateGetter stateManager) {
-        this.stateManager = stateManager;
-    }
-
-    void setNuOfActsForwardLooking(int nOfActsForwardLooking) {
-        this.nuOfActsForwardLooking = nOfActsForwardLooking;
-        logger.debug("set [forwardLooking={}]", nOfActsForwardLooking);
-    }
-
-    @Override
-    public String toString() {
-        return "[name=calculatesServiceInsertionOnRouteLevel][solutionMemory=" + memorySize + "][forwardLooking=" + nuOfActsForwardLooking + "]";
-    }
-
-    /**
-     * Calculates the insertion costs of job i on route level (which is based on the assumption that inserting job i does not only
-     * have local effects but affects the entire route).
-     * Calculation is conducted by two steps. In the first step, promising insertion positions are identified by appromiximating their
-     * marginal insertion cost. In the second step, marginal cost of the best M positions are calculated exactly.
-     */
-    @Override
-    public InsertionData getInsertionData(final VehicleRoute currentRoute, final Job jobToInsert, final Vehicle newVehicle, double newVehicleDepartureTime, final Driver newDriver, final double best_known_insertion_costs) {
-        if (jobToInsert == null)
-            throw new IllegalStateException("job is null. cannot calculate the insertion of a null-job.");
-        if (newVehicle == null || newVehicle instanceof VehicleImpl.NoVehicle)
-            throw new IllegalStateException("no vehicle given. set para vehicle!");
-
-        JobInsertionContext insertionContext = new JobInsertionContext(currentRoute, jobToInsert, newVehicle, newDriver, newVehicleDepartureTime);
-        if (!hardRouteLevelConstraint.fulfilled(insertionContext)) {
-            return InsertionData.createEmptyInsertionData();
-        }
-
-        /**
-         * map that memorizes the costs with newVehicle, which is a cost-snapshot at tour-activities.
-         */
-//		Map<TourActivity,Double> activity2costWithNewVehicle = new HashMap<TourActivity,Double>();
-
-        /**
-         * priority queue that stores insertion-data by insertion-costs in ascending order.
-         */
-        PriorityQueue<InsertionData> bestInsertionsQueue = new PriorityQueue<InsertionData>(Math.max(2, currentRoute.getTourActivities().getActivities().size()), getComparator());
-
-        TourActivities tour = currentRoute.getTourActivities();
-        double best_insertion_costs = best_known_insertion_costs;
-        Service service = (Service) jobToInsert;
-
-
-        /**
-         * some inis
-         */
-        TourActivity serviceAct2Insert = activityFactory.createActivities(service).get(0);
-        int best_insertion_index = InsertionData.NO_INDEX;
-
-        initialiseStartAndEnd(newVehicle, newVehicleDepartureTime);
-
-        TourActivity prevAct = start;
-        int actIndex = 0;
-        double sumOf_prevCosts_newVehicle = 0.0;
-        double prevActDepTime_newVehicle = start.getEndTime();
-
-        boolean loopBroken = false;
-        /**
-         * inserting serviceAct2Insert in route r={0,1,...,i-1,i,j,j+1,...,n(r),n(r)+1}
-         * i=prevAct
-         * j=nextAct
-         * k=serviceAct2Insert
-         */
-        for (TourActivity nextAct : tour.getActivities()) {
-            ConstraintsStatus hardActivityConstraintsStatus = hardActivityLevelConstraint.fulfilled(insertionContext, prevAct, serviceAct2Insert, nextAct, prevActDepTime_newVehicle);
-            if (hardActivityConstraintsStatus.equals(ConstraintsStatus.FULFILLED)) {
-                /**
-                 * builds a path on this route forwardPath={i,k,j,j+1,j+2,...,j+nuOfActsForwardLooking}
-                 */
-                double actInsertionCosts = activityInsertionCostsCalculator.getCosts(insertionContext, prevAct, nextAct, serviceAct2Insert, prevActDepTime_newVehicle);
-
-                /**
-                 * insertion_cost_approximation = c({0,1,...,i},newVehicle) + c({i,k,j,j+1,j+2,...,j+nuOfActsForwardLooking},newVehicle) - c({0,1,...,i,j,j+1,...,j+nuOfActsForwardLooking},oldVehicle)
-                 */
-                double insertion_cost_approximation = sumOf_prevCosts_newVehicle - sumOf_prevCosts_oldVehicle(currentRoute, prevAct) + actInsertionCosts;
-
-                /**
-                 * memorize it in insertion-queue
-                 */
-                if (insertion_cost_approximation < best_known_insertion_costs) {
-                    bestInsertionsQueue.add(new InsertionData(insertion_cost_approximation, InsertionData.NO_INDEX, actIndex, newVehicle, newDriver));
-                }
-            } else if (hardActivityConstraintsStatus.equals(ConstraintsStatus.NOT_FULFILLED_BREAK)) {
-                loopBroken = true;
-                break;
-            }
-
-
-            /**
-             * calculate transport and activity costs with new vehicle (without inserting k)
-             */
-            double transportCost_prevAct_nextAct_newVehicle = transportCosts.getTransportCost(prevAct.getLocation(), nextAct.getLocation(), prevActDepTime_newVehicle, newDriver, newVehicle);
-            double transportTime_prevAct_nextAct_newVehicle = transportCosts.getTransportTime(prevAct.getLocation(), nextAct.getLocation(), prevActDepTime_newVehicle, newDriver, newVehicle);
-            double arrTime_nextAct_newVehicle = prevActDepTime_newVehicle + transportTime_prevAct_nextAct_newVehicle;
-            double activityCost_nextAct = activityCosts.getActivityCost(nextAct, arrTime_nextAct_newVehicle, newDriver, newVehicle);
-
-            /**
-             * memorize transport and activity costs with new vehicle without inserting k
-             */
-            sumOf_prevCosts_newVehicle += transportCost_prevAct_nextAct_newVehicle + activityCost_nextAct;
-//			activity2costWithNewVehicle.put(nextAct, sumOf_prevCosts_newVehicle);
-
-            /**
-             * departure time at nextAct with new vehicle
-             */
-            double depTime_nextAct_newVehicle = Math.max(arrTime_nextAct_newVehicle, nextAct.getTheoreticalEarliestOperationStartTime()) + activityCosts.getActivityDuration(nextAct, arrTime_nextAct_newVehicle,newDriver,newVehicle);
-
-            /**
-             * set previous to next
-             */
-            prevAct = nextAct;
-            prevActDepTime_newVehicle = depTime_nextAct_newVehicle;
-
-            actIndex++;
-        }
-        if (!loopBroken) {
-            End nextAct = end;
-            ConstraintsStatus hardActivityConstraintsStatus = hardActivityLevelConstraint.fulfilled(insertionContext, prevAct, serviceAct2Insert, nextAct, prevActDepTime_newVehicle);
-            if (hardActivityConstraintsStatus.equals(ConstraintsStatus.FULFILLED)) {
-                double actInsertionCosts = activityInsertionCostsCalculator.getCosts(insertionContext, prevAct, nextAct, serviceAct2Insert, prevActDepTime_newVehicle);
-
-                /**
-                 * insertion_cost_approximation = c({0,1,...,i},newVehicle) + c({i,k,j,j+1,j+2,...,j+nuOfActsForwardLooking},newVehicle) - c({0,1,...,i,j,j+1,...,j+nuOfActsForwardLooking},oldVehicle)
-                 */
-                double insertion_cost_approximation = sumOf_prevCosts_newVehicle - sumOf_prevCosts_oldVehicle(currentRoute, prevAct) + actInsertionCosts;
-
-                /**
-                 * memorize it in insertion-queue
-                 */
-                if (insertion_cost_approximation < best_known_insertion_costs) {
-                    bestInsertionsQueue.add(new InsertionData(insertion_cost_approximation, InsertionData.NO_INDEX, actIndex, newVehicle, newDriver));
-                }
-
-            }
-        }
-
-
-        /**
-         * the above calculations approximate insertion costs. now calculate the exact insertion costs for the most promising (according to the approximation)
-         * insertion positions.
-         *
-         */
-
-        if (memorySize == 0) { // return bestInsertion
-            InsertionData insertion = bestInsertionsQueue.poll();
-            if (insertion != null) {
-                best_insertion_index = insertion.getDeliveryInsertionIndex();
-                best_insertion_costs = insertion.getInsertionCost();
-            }
-        } else {
-
-            for (int i = 0; i < memorySize; i++) {
-                InsertionData data = bestInsertionsQueue.poll();
-                if (data == null) {
-                    continue;
-                }
-                /**
-                 * build tour with new activity.
-                 */
-                List<TourActivity> wholeTour = new ArrayList<TourActivity>();
-                wholeTour.add(start);
-                wholeTour.addAll(currentRoute.getTourActivities().getActivities());
-                wholeTour.add(end);
-                wholeTour.add(data.getDeliveryInsertionIndex() + 1, serviceAct2Insert);
-
-                /**
-                 * compute cost-diff of tour with and without new activity --> insertion_costs
-                 */
-                Double currentRouteCosts = stateManager.getRouteState(currentRoute, InternalStates.COSTS, Double.class);
-                if (currentRouteCosts == null) currentRouteCosts = 0.;
-                double insertion_costs = auxilliaryPathCostCalculator.costOfPath(wholeTour, start.getEndTime(), newDriver, newVehicle) - currentRouteCosts;
-
-                /**
-                 * if better than best known, make it the best known
-                 */
-                if (insertion_costs < best_insertion_costs) {
-                    best_insertion_index = data.getDeliveryInsertionIndex();
-                    best_insertion_costs = insertion_costs;
-                }
-            }
-        }
-        if (best_insertion_index == InsertionData.NO_INDEX) return InsertionData.createEmptyInsertionData();
-        InsertionData insertionData = new InsertionData(best_insertion_costs, InsertionData.NO_INDEX, best_insertion_index, newVehicle, newDriver);
-        insertionData.setVehicleDepartureTime(start.getEndTime());
-        return insertionData;
-    }
-
-    private void initialiseStartAndEnd(final Vehicle newVehicle, double newVehicleDepartureTime) {
-        if (start == null) {
-            start = new Start(newVehicle.getStartLocation(), newVehicle.getEarliestDeparture(), Double.MAX_VALUE);
-            start.setEndTime(newVehicleDepartureTime);
-        } else {
-            start.setLocation(Location.newInstance(newVehicle.getStartLocation().getId()));
-            start.setTheoreticalEarliestOperationStartTime(newVehicle.getEarliestDeparture());
-            start.setTheoreticalLatestOperationStartTime(Double.MAX_VALUE);
-            start.setEndTime(newVehicleDepartureTime);
-        }
-
-        if (end == null) {
-            end = new End(newVehicle.getEndLocation(), 0.0, newVehicle.getLatestArrival());
-        } else {
-            end.setLocation(Location.newInstance(newVehicle.getEndLocation().getId()));
-            end.setTheoreticalEarliestOperationStartTime(0.0);
-            end.setTheoreticalLatestOperationStartTime(newVehicle.getLatestArrival());
-        }
-    }
-
-    private double sumOf_prevCosts_oldVehicle(VehicleRoute vehicleRoute, TourActivity act) {
-        Double prevCost;
-        if (act instanceof End) {
-            prevCost = stateManager.getRouteState(vehicleRoute, InternalStates.COSTS, Double.class);
-        } else prevCost = stateManager.getActivityState(act, InternalStates.COSTS, Double.class);
-        if (prevCost == null) prevCost = 0.;
-        return prevCost;
-    }
-
-    private Comparator<InsertionData> getComparator() {
-        return new Comparator<InsertionData>() {
-
-            @Override
-            public int compare(InsertionData o1, InsertionData o2) {
-                if (o1.getInsertionCost() < o2.getInsertionCost()) {
-                    return -1;
-                } else {
-                    return 1;
-                }
-
-            }
-        };
-    }
-}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/SwitchVehicle.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/SwitchVehicle.java
index 99221d1de..30ba9e8f8 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/SwitchVehicle.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/recreate/SwitchVehicle.java
@@ -24,7 +24,7 @@
 /**
  * Created by schroeder on 19/05/15.
  */
-class SwitchVehicle implements Event {
+public class SwitchVehicle implements Event {
 
     private VehicleRoute route;
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractJob.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractJob.java
index 0d6f154da..7d3192ec4 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractJob.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractJob.java
@@ -18,11 +18,7 @@
 
 package com.graphhopper.jsprit.core.problem.job;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
+import java.util.*;
 
 import com.graphhopper.jsprit.core.problem.Capacity;
 import com.graphhopper.jsprit.core.problem.Location;
@@ -308,7 +304,7 @@ private void addLocation(Location location) {
 
     protected void prepareCaches() {
         allLocations = new ArrayList<>();
-        allTimeWindows = new HashSet<>();
+        allTimeWindows = new LinkedHashSet<>();
         activityList.getAll().stream().forEach(ja -> {
             addLocation(ja.getLocation());
             addTimeWindows(ja.getTimeWindows());
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Job.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Job.java
index 92b682102..da0998152 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Job.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Job.java
@@ -76,15 +76,6 @@
      */
     public List<Location> getAllLocations();
 
-    /**
-     * @return Start location
-     */
-    public Location getStartLocation();
-
-    /**
-     * @return End location
-     */
-    public Location getEndLocation();
 
     /**
      * @return All activities
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
index 7c9dd3bfe..4caccdfe0 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
@@ -298,16 +298,6 @@ public Capacity getSize() {
         return getServiceActivity().getSize();
     }
 
-    @Override
-    public Location getStartLocation() {
-        return getServiceActivity().getLocation();
-    }
-
-
-    @Override
-    public Location getEndLocation() {
-        return getServiceActivity().getLocation();
-    }
 
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
index 912b9df37..62bafb860 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
@@ -319,17 +319,6 @@ protected void createActivities(JobBuilder<?, ?> builder) {
         setActivities(list);
     }
 
-
-    @Override
-    public Location getStartLocation() {
-        return getPickupActivity().getLocation();
-    }
-
-    @Override
-    public Location getEndLocation() {
-        return getDeliveryActivity().getLocation();
-    }
-
     public PickupShipmentDEPRECATED getPickupActivity() {
         return (PickupShipmentDEPRECATED) getActivityList().findByType(PickupShipmentDEPRECATED.NAME)
                         .get();
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobExample.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobExample.java
new file mode 100644
index 000000000..c871b4225
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/FirstCustomJobExample.java
@@ -0,0 +1,126 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.graphhopper.jsprit.core.algorithm;
+
+import com.graphhopper.jsprit.core.algorithm.box.Jsprit;
+import com.graphhopper.jsprit.core.problem.Capacity;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.job.AbstractJob;
+import com.graphhopper.jsprit.core.problem.job.JobActivityList;
+import com.graphhopper.jsprit.core.problem.job.SequentialJobActivityList;
+import com.graphhopper.jsprit.core.problem.job.Shipment;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.*;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
+import com.graphhopper.jsprit.core.reporting.SolutionPrinter;
+import com.graphhopper.jsprit.core.util.Solutions;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Created by schroeder on 11/11/16.
+ */
+public class FirstCustomJobExample {
+
+    static class CustomJob extends AbstractJob {
+
+        public static abstract class BuilderBase<T extends CustomJob, B extends BuilderBase<T, B>>
+            extends JobBuilder<T, B> {
+
+            List<Location> locs = new ArrayList<>();
+
+            public BuilderBase(String id) {
+                super(id);
+            }
+
+            public BuilderBase<T,B> addPickup(Location location){
+                locs.add(location);
+                return this;
+            }
+
+            public List<Location> getLocs() {
+                return locs;
+            }
+
+            protected void validate(){
+
+            }
+        }
+
+        public static final class Builder extends BuilderBase<CustomJob, Builder> {
+
+            public static Builder newInstance(String id) {
+                return new Builder(id);
+            }
+
+            public Builder(String id) {
+                super(id);
+            }
+
+            @Override
+            protected CustomJob createInstance() {
+                return new CustomJob(this);
+            }
+
+        }
+        /**
+         * Builder based constructor.
+         *
+         * @param builder The builder instance.
+         * @see JobBuilder
+         */
+        protected CustomJob(JobBuilder<?, ?> builder) {
+            super(builder);
+
+        }
+
+        @Override
+        public Capacity getSize() {
+            return Capacity.EMPTY;
+        }
+
+        @Override
+        protected void createActivities(JobBuilder<? extends AbstractJob, ?> jobBuilder) {
+            Builder builder = (Builder) jobBuilder;
+            JobActivityList list = new SequentialJobActivityList(this);
+            for(Location loc : builder.getLocs()){
+                list.addActivity(new PickupActivityNEW(this,"pick",loc,0,Capacity.EMPTY,Collections.emptyList()));
+            }
+            setActivities(list);
+        }
+    }
+
+
+
+    @Test
+    public void test(){
+        CustomJob cj = CustomJob.Builder.newInstance("job").addPickup(Location.newInstance(10,0)).build();
+        Vehicle v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0,0)).build();
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
+            .addJob(cj).addVehicle(v).build();
+        VehicleRoutingAlgorithm vra = Jsprit.createAlgorithm(vrp);
+        VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
+        SolutionPrinter.print(vrp,solution, SolutionPrinter.Print.VERBOSE);
+    }
+}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionAndLoadConstraintsTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionAndLoadConstraintsTest.java
index 59a1532d0..fb9637f10 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionAndLoadConstraintsTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ServiceInsertionAndLoadConstraintsTest.java
@@ -21,6 +21,7 @@
 import static org.mockito.Mockito.mock;
 
 import java.util.Arrays;
+import java.util.List;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -124,8 +125,7 @@ public void whenInsertingServiceWhileNoCapIsAvailable_itMustReturnTheCorrectInse
         VehicleRoute route = VehicleRoute.emptyRoute();
         route.setVehicleAndDepartureTime(vehicle, 0.0);
 
-        Inserter inserter = new Inserter(new InsertionListeners(), vrp);
-        inserter.insertJob(delivery, new InsertionData(0, 0, 0, vehicle, null), route);
+        route.getTourActivities().addActivity(0,vrp.copyAndGetActivities(delivery).get(0));
 
         JobActivityFactory activityFactory = new CopyJobActivityFactory();
 
@@ -147,8 +147,8 @@ public void whenInsertingServiceWhileNoCapIsAvailable_itMustReturnTheCorrectInse
         switcher.put(Shipment.class, insertionCalculator);
 
         InsertionData iData = switcher.getInsertionData(route, pickup, vehicle, 0, DriverImpl.noDriver(), Double.MAX_VALUE);
-
-        assertEquals(1, iData.getDeliveryInsertionIndex());
+        List<InsertActivity> insertActivities = iData.getUnmodifiableEventsByType(InsertActivity.class);
+        assertEquals(1, insertActivities.get(0).getIndex());
     }
 
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculatorTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculatorTest.java
index edac630de..f229e2cb8 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculatorTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/ShipmentInsertionCalculatorTest.java
@@ -130,11 +130,12 @@ public void whenCalculatingInsertionIntoExistingRoute_itShouldReturnCorrectCosts
         Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
         Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
         VehicleRoute route = VehicleRoute.emptyRoute();
-        when(vehicleRoutingProblem.copyAndGetActivities(shipment)).thenReturn(getTourActivities(shipment));
-        new Inserter(new InsertionListeners(), vehicleRoutingProblem).insertJob(shipment, new InsertionData(0, 0, 0, vehicle, null), route);
+        List<JobActivity> tourActivities = getTourActivities(shipment);
+        route.setVehicleAndDepartureTime(vehicle,0);
+        add(tourActivities,route,0,0);
 
         JobActivityFactory activityFactory = mock(JobActivityFactory.class);
-        List<JobActivity> activities = new ArrayList<JobActivity>();
+        List<JobActivity> activities = new ArrayList<>();
         activities.add(new PickupShipmentDEPRECATED(shipment2));
         activities.add(new DeliverShipmentDEPRECATED(shipment2));
         when(activityFactory.createActivities(shipment2)).thenReturn(activities);
@@ -142,12 +143,12 @@ public void whenCalculatingInsertionIntoExistingRoute_itShouldReturnCorrectCosts
 
         InsertionData iData = insertionCalculator.getInsertionData(route, shipment2, vehicle, 0.0, null, Double.MAX_VALUE);
         assertEquals(0.0, iData.getInsertionCost(), 0.05);
-        assertEquals(1, iData.getPickupInsertionIndex());
-        assertEquals(2, iData.getDeliveryInsertionIndex());
+        assertEquals(1, iData.getUnmodifiableEventsByType(InsertActivity.class).get(1).getIndex());
+        assertEquals(2, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
     }
 
     private List<JobActivity> getTourActivities(Shipment shipment) {
-        List<JobActivity> acts = new ArrayList<JobActivity>();
+        List<JobActivity> acts = new ArrayList<>();
         PickupShipmentDEPRECATED pick = new PickupShipmentDEPRECATED(shipment);
         DeliverShipmentDEPRECATED del = new DeliverShipmentDEPRECATED(shipment);
         acts.add(pick);
@@ -160,16 +161,11 @@ public void whenInsertingShipmentInRouteWithNotEnoughCapacity_itShouldReturnNoIn
         Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
         Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
         VehicleRoute route = VehicleRoute.emptyRoute();
-        when(vehicleRoutingProblem.copyAndGetActivities(shipment)).thenReturn(getTourActivities(shipment));
-        new Inserter(new InsertionListeners(), vehicleRoutingProblem).insertJob(shipment, new InsertionData(0, 0, 0, vehicle, null), route);
-        createInsertionCalculator(new HardRouteConstraint() {
+        List<JobActivity> tourActivities = getTourActivities(shipment);
+        route.setVehicleAndDepartureTime(vehicle,0);
+        add(tourActivities,route,0,0);
 
-            @Override
-            public boolean fulfilled(JobInsertionContext insertionContext) {
-                return false;
-            }
-
-        });
+        createInsertionCalculator(insertionContext -> false);
 
         JobActivityFactory activityFactory = mock(JobActivityFactory.class);
         List<JobActivity> activities = new ArrayList<JobActivity>();
@@ -191,14 +187,15 @@ public void whenInsertingThirdShipment_itShouldCalcCorrectVal() {
         Shipment shipment3 = Shipment.Builder.newInstance("s3").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("9,10")).build();
 
         VehicleRoute route = VehicleRoute.emptyRoute();
-        when(vehicleRoutingProblem.copyAndGetActivities(shipment)).thenReturn(getTourActivities(shipment));
-        when(vehicleRoutingProblem.copyAndGetActivities(shipment2)).thenReturn(getTourActivities(shipment2));
-        Inserter inserter = new Inserter(new InsertionListeners(), vehicleRoutingProblem);
-        inserter.insertJob(shipment, new InsertionData(0, 0, 0, vehicle, null), route);
-        inserter.insertJob(shipment2, new InsertionData(0, 1, 2, vehicle, null), route);
+        List<JobActivity> shipmentActivities = getTourActivities(shipment);
+        List<JobActivity> shipment2Activities = getTourActivities(shipment2);
+
+        route.setVehicleAndDepartureTime(vehicle,0d);
+        add(shipmentActivities,route,0,0);
+        add(shipment2Activities,route,1,2);
 
         JobActivityFactory activityFactory = mock(JobActivityFactory.class);
-        List<JobActivity> activities = new ArrayList<JobActivity>();
+        List<JobActivity> activities = new ArrayList<>();
         activities.add(new PickupShipmentDEPRECATED(shipment3));
         activities.add(new DeliverShipmentDEPRECATED(shipment3));
         when(activityFactory.createActivities(shipment3)).thenReturn(activities);
@@ -206,8 +203,9 @@ public void whenInsertingThirdShipment_itShouldCalcCorrectVal() {
 
         InsertionData iData = insertionCalculator.getInsertionData(route, shipment3, vehicle, 0.0, null, Double.MAX_VALUE);
         assertEquals(0.0, iData.getInsertionCost(), 0.05);
-        assertEquals(0, iData.getPickupInsertionIndex());
-        assertEquals(1, iData.getDeliveryInsertionIndex());
+        List<InsertActivity> unmodifiableEventsByType = iData.getUnmodifiableEventsByType(InsertActivity.class);
+        assertEquals(1, unmodifiableEventsByType.get(0).getIndex());
+        assertEquals(0, unmodifiableEventsByType.get(1).getIndex());
     }
 
     @Test
@@ -215,15 +213,16 @@ public void whenInsertingThirdShipment_itShouldCalcCorrectVal2() {
         Shipment shipment = Shipment.Builder.newInstance("s").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,10").build()).setDeliveryLocation(Location.newInstance("10,0")).build();
         Shipment shipment2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("10,10").build()).setDeliveryLocation(Location.newInstance("0,0")).build();
         Shipment shipment3 = Shipment.Builder.newInstance("s3").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("9,9")).build();
-        when(vehicleRoutingProblem.copyAndGetActivities(shipment)).thenReturn(getTourActivities(shipment));
-        when(vehicleRoutingProblem.copyAndGetActivities(shipment2)).thenReturn(getTourActivities(shipment2));
+        List<JobActivity> shipmentActivities = getTourActivities(shipment);
+        List<JobActivity> shipment2Activities = getTourActivities(shipment2);
         VehicleRoute route = VehicleRoute.emptyRoute();
-        Inserter inserter = new Inserter(new InsertionListeners(), vehicleRoutingProblem);
-        inserter.insertJob(shipment, new InsertionData(0, 0, 0, vehicle, null), route);
-        inserter.insertJob(shipment2, new InsertionData(0, 1, 2, vehicle, null), route);
+
+        route.setVehicleAndDepartureTime(vehicle,0d);
+        add(shipmentActivities,route,0,0);
+        add(shipment2Activities,route,1,2);
 
         JobActivityFactory activityFactory = mock(JobActivityFactory.class);
-        List<JobActivity> activities = new ArrayList<JobActivity>();
+        List<JobActivity> activities = new ArrayList<>();
         activities.add(new PickupShipmentDEPRECATED(shipment3));
         activities.add(new DeliverShipmentDEPRECATED(shipment3));
         when(activityFactory.createActivities(shipment3)).thenReturn(activities);
@@ -232,8 +231,8 @@ public void whenInsertingThirdShipment_itShouldCalcCorrectVal2() {
 
         InsertionData iData = insertionCalculator.getInsertionData(route, shipment3, vehicle, 0.0, null, Double.MAX_VALUE);
         assertEquals(2.0, iData.getInsertionCost(), 0.05);
-        assertEquals(0, iData.getPickupInsertionIndex());
-        assertEquals(1, iData.getDeliveryInsertionIndex());
+        assertEquals(0, iData.getUnmodifiableEventsByType(InsertActivity.class).get(1).getIndex());
+        assertEquals(1, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
     }
 
     @Test
@@ -248,9 +247,8 @@ public void whenInstertingShipmentWithLoadConstraintWhereCapIsNotSufficient_capC
         VehicleRoute route = VehicleRoute.emptyRoute();
         route.setVehicleAndDepartureTime(vehicle, 0.0);
 
-        Inserter inserter = new Inserter(new InsertionListeners(), vrp);
-        inserter.insertJob(shipment, new InsertionData(0, 0, 0, vehicle, null), route);
-        inserter.insertJob(shipment2, new InsertionData(0, 1, 2, vehicle, null), route);
+        add(vrp,route,shipment,0,0);
+        add(vrp,route,shipment2,1,2);
 
         StateManager stateManager = new StateManager(vrp);
         stateManager.updateLoadStates();
@@ -280,10 +278,8 @@ public void whenInsertingServiceWhileNoCapIsAvailable_itMustReturnNoInsertionDat
         VehicleRoute route = VehicleRoute.emptyRoute();
         route.setVehicleAndDepartureTime(vehicle, 0.0);
 
-        Inserter inserter = new Inserter(new InsertionListeners(), vrp);
-
-        inserter.insertJob(shipment, new InsertionData(0, 0, 0, vehicle, null), route);
-        inserter.insertJob(shipment2, new InsertionData(0, 1, 2, vehicle, null), route);
+        add(vrp,route,shipment,0,0);
+        add(vrp,route,shipment2,1,2);
 
         StateManager stateManager = new StateManager(vrp);
         stateManager.updateLoadStates();
@@ -314,7 +310,18 @@ public void whenInsertingServiceWhileNoCapIsAvailable_itMustReturnNoInsertionDat
         InsertionData iData = switcher.getInsertionData(route, service, vehicle, 0, DriverImpl.noDriver(), Double.MAX_VALUE);
         //		routeActVisitor.visit(route);
 
-        assertEquals(3, iData.getDeliveryInsertionIndex());
+        assertEquals(3, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
+    }
+
+    private void add(VehicleRoutingProblem vrp, VehicleRoute route, Shipment shipment, int pickI, int delI) {
+        List<JobActivity> shipmentActivities = vrp.copyAndGetActivities(shipment);
+        route.getTourActivities().addActivity(delI, shipmentActivities.get(1));
+        route.getTourActivities().addActivity(pickI, shipmentActivities.get(0));
+    }
+
+    private void add(List<JobActivity> shipmentActivities, VehicleRoute route, int pickI, int delI) {
+        route.getTourActivities().addActivity(delI, shipmentActivities.get(1));
+        route.getTourActivities().addActivity(pickI, shipmentActivities.get(0));
     }
 
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertion.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertion.java
index b502d5980..517484d0f 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertion.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertion.java
@@ -150,7 +150,7 @@ public void whenInsertingTheFirstJobInAnEmptyTourWithVehicle_itCalculatesMargina
 
         InsertionData iData = serviceInsertion.getInsertionData(route, first, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
         assertEquals(20.0, iData.getInsertionCost(), 0.2);
-        assertEquals(0, iData.getDeliveryInsertionIndex());
+        assertEquals(0, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
     }
 
     @Test
@@ -160,7 +160,7 @@ public void whenInsertingTheSecondJobInAnNonEmptyTourWithVehicle_itCalculatesMar
 
         InsertionData iData = serviceInsertion.getInsertionData(route, third, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
         assertEquals(20.0, iData.getInsertionCost(), 0.2);
-        assertEquals(0, iData.getDeliveryInsertionIndex());
+        assertEquals(0, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
     }
 
     @Test
@@ -170,7 +170,7 @@ public void whenInsertingThirdJobWithVehicle_itCalculatesMarginalCostChanges() {
 
         InsertionData iData = serviceInsertion.getInsertionData(route, second, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
         assertEquals(0.0, iData.getInsertionCost(), 0.2);
-        assertEquals(1, iData.getDeliveryInsertionIndex());
+        assertEquals(1, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
     }
 
     @Test
@@ -180,7 +180,7 @@ public void whenInsertingThirdJobWithNewVehicle_itCalculatesMarginalCostChanges(
 
         InsertionData iData = serviceInsertion.getInsertionData(route, second, newVehicle, newVehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
         assertEquals(40.0, iData.getInsertionCost(), 0.2);
-        assertEquals(1, iData.getDeliveryInsertionIndex());
+        assertEquals(1, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
     }
 
     @Test
@@ -190,7 +190,7 @@ public void whenInsertingASecondJobWithAVehicle_itCalculatesLocalMarginalCostCha
 
         InsertionData iData = serviceInsertion.getInsertionData(route, third, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
         assertEquals(0.0, iData.getInsertionCost(), 0.2);
-        assertEquals(2, iData.getDeliveryInsertionIndex());
+        assertEquals(2, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
     }
 
     @Test
@@ -202,7 +202,7 @@ public void whenInsertingASecondJobWithANewVehicle_itCalculatesLocalMarginalCost
 
         InsertionData iData = serviceInsertion.getInsertionData(route, third, newVehicle, newVehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
         assertEquals(50.0, iData.getInsertionCost(), 0.2);
-        assertEquals(2, iData.getDeliveryInsertionIndex());
+        assertEquals(2, iData.getUnmodifiableEventsByType(InsertActivity.class).get(0).getIndex());
     }
 
     @Test
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertionOnRouteLevel.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertionOnRouteLevel.java
deleted file mode 100644
index a2ec717e9..000000000
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertionOnRouteLevel.java
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import com.graphhopper.jsprit.core.algorithm.ExampleActivityCostFunction;
-import com.graphhopper.jsprit.core.algorithm.state.StateManager;
-import com.graphhopper.jsprit.core.algorithm.state.UpdateVariableCosts;
-import com.graphhopper.jsprit.core.problem.AbstractVehicle;
-import com.graphhopper.jsprit.core.problem.CopyJobActivityFactory;
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
-import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
-import com.graphhopper.jsprit.core.problem.cost.AbstractForwardVehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.driver.DriverImpl;
-import com.graphhopper.jsprit.core.problem.driver.DriverImpl.NoDriver;
-import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.job.Service;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
-import com.graphhopper.jsprit.core.util.CostFactory;
-
-
-public class TestCalculatesServiceInsertionOnRouteLevel {
-
-    ServiceInsertionOnRouteLevelCalculator serviceInsertion;
-
-    VehicleRoutingTransportCosts costs;
-
-    AbstractVehicle vehicle;
-
-    AbstractVehicle newVehicle;
-
-    private Service first;
-
-    private Service second;
-
-    private Service third;
-
-    private StateManager states;
-
-    private NoDriver driver;
-
-    private VehicleRoutingProblem vrp;
-
-    @Before
-    public void setup() {
-
-
-        costs = mock(VehicleRoutingTransportCosts.class);
-
-        VehicleType type = VehicleTypeImpl.Builder.newInstance("t").addCapacityDimension(0, 1000).build();
-        vehicle = VehicleImpl.Builder.newInstance("v1").setType(type).setStartLocation(Location.newInstance("0,0")).setLatestArrival(100.).build();
-        newVehicle = VehicleImpl.Builder.newInstance("v2").setType(type).setStartLocation(Location.newInstance("0,0")).setLatestArrival(100.).build();
-        driver = DriverImpl.noDriver();
-
-        costs = new AbstractForwardVehicleRoutingTransportCosts() {
-
-            VehicleRoutingTransportCosts routingCosts = CostFactory.createManhattanCosts();
-
-            @Override
-            public double getTransportTime(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-                return 0;
-            }
-
-            @Override
-            public double getTransportCost(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-                double tpCosts = routingCosts.getTransportCost(from, to, departureTime, driver, vehicle);
-                if (vehicle.getId().equals("v1")) {
-                    return tpCosts;
-                }
-                return 2. * tpCosts;
-            }
-
-        };
-
-        first = new Service.Builder("1").setLocation(Location.newInstance("0,10")).setTimeWindow(TimeWindow.newInstance(0.0, 100.0)).build();
-        second = new Service.Builder("3").setLocation(Location.newInstance("10,0")).setTimeWindow(TimeWindow.newInstance(0.0, 100.0)).build();
-        third = new Service.Builder("2").setLocation(Location.newInstance("10,10")).setTimeWindow(TimeWindow.newInstance(0.0, 100.0)).build();
-        Collection<Job> jobs = new ArrayList<Job>();
-        jobs.add(first);
-        jobs.add(second);
-        jobs.add(third);
-
-        vrp = VehicleRoutingProblem.Builder.newInstance().addAllJobs(jobs).addVehicle(vehicle).addVehicle(newVehicle).setRoutingCost(costs).build();
-
-        states = new StateManager(vrp);
-        states.updateLoadStates();
-        states.updateTimeWindowStates();
-        states.addStateUpdater(new UpdateVariableCosts(vrp.getActivityCosts(), vrp.getTransportCosts(), states));
-
-        ConstraintManager cManager = new ConstraintManager(vrp, states);
-        cManager.addLoadConstraint();
-        cManager.addTimeWindowConstraint();
-
-
-        ExampleActivityCostFunction activityCosts = new ExampleActivityCostFunction();
-        ActivityInsertionCostsCalculator actInsertionCostCalculator = new RouteLevelActivityInsertionCostsEstimator(costs, activityCosts, states);
-        serviceInsertion = new ServiceInsertionOnRouteLevelCalculator(costs, activityCosts, actInsertionCostCalculator, cManager, cManager);
-        serviceInsertion.setNuOfActsForwardLooking(4);
-        serviceInsertion.setStates(states);
-        serviceInsertion.setJobActivityFactory(new CopyJobActivityFactory());
-
-    }
-
-
-    @Test
-    public void whenInsertingTheFirstJobInAnEmptyTourWithVehicle_itCalculatesMarginalCostChanges() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).build();
-        states.informInsertionStarts(Arrays.asList(route), null);
-
-        InsertionData iData = serviceInsertion.getInsertionData(route, first, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
-        assertEquals(20.0, iData.getInsertionCost(), 0.2);
-        assertEquals(0, iData.getDeliveryInsertionIndex());
-    }
-
-    @Test
-    public void whenInsertingThirdJobWithVehicle_itCalculatesMarginalCostChanges() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).addService(second).build();
-        states.informInsertionStarts(Arrays.asList(route), null);
-
-        InsertionData iData = serviceInsertion.getInsertionData(route, third, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
-        assertEquals(0.0, iData.getInsertionCost(), 0.2);
-        assertEquals(1, iData.getDeliveryInsertionIndex());
-    }
-
-    @Test
-    public void whenInsertingThirdJobWithNewVehicle_itCalculatesMarginalCostChanges() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).addService(second).build();
-        states.informInsertionStarts(Arrays.asList(route), null);
-
-        InsertionData iData = serviceInsertion.getInsertionData(route, third, newVehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
-        assertEquals(40.0, iData.getInsertionCost(), 0.2);
-        assertEquals(1, iData.getDeliveryInsertionIndex());
-    }
-
-    @Test
-    public void whenInsertingASecondJobWithAVehicle_itCalculatesLocalMarginalCostChanges() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).addService(third).build();
-        states.informInsertionStarts(Arrays.asList(route), null);
-
-        InsertionData iData = serviceInsertion.getInsertionData(route, second, vehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
-        assertEquals(0.0, iData.getInsertionCost(), 0.2);
-        assertEquals(2, iData.getDeliveryInsertionIndex());
-    }
-
-    @Test
-    public void whenInsertingASecondJobWithANewVehicle_itCalculatesLocalMarginalCostChanges() {
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, driver).setJobActivityFactory(vrp.getJobActivityFactory()).addService(first).addService(third).build();
-        states.informInsertionStarts(Arrays.asList(route), null);
-
-        InsertionData iData = serviceInsertion.getInsertionData(route, second, newVehicle, vehicle.getEarliestDeparture(), null, Double.MAX_VALUE);
-        assertEquals(40.0, iData.getInsertionCost(), 0.2);
-        assertEquals(2, iData.getDeliveryInsertionIndex());
-    }
-
-
-}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestInserter.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestInserter.java
deleted file mode 100644
index 8c51b285d..000000000
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestInserter.java
+++ /dev/null
@@ -1,281 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.junit.Test;
-
-import com.graphhopper.jsprit.core.algorithm.recreate.listener.InsertionListeners;
-import com.graphhopper.jsprit.core.algorithm.state.UpdateEndLocationIfRouteIsOpen;
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.job.Service;
-import com.graphhopper.jsprit.core.problem.job.Shipment;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliverShipmentDEPRECATED;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupServiceDEPRECATED;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupShipmentDEPRECATED;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
-
-public class TestInserter {
-
-    private Service.Builder createService(String name, Location loc) {
-        TimeWindow tw = TimeWindow.newInstance(0, 10);
-
-        return new Service.Builder(name)
-                .setTimeWindow(tw)
-                .setLocation(loc);
-    }
-
-
-    protected Shipment.Builder createStandardShipment(String name) {
-        Location loc = Location.Builder.newInstance().setId("delLoc").build();
-        TimeWindow tw = TimeWindow.newInstance(0, 10);
-        return Shipment.Builder.newInstance(name)
-                .addSizeDimension(0, 10)
-                .setPickupTimeWindow(tw)
-                .setDeliveryTimeWindow(tw)
-                .setPickupLocation(loc)
-                .setDeliveryLocation(loc);
-    }
-
-    @Test
-    public void whenInsertingServiceAndRouteIsClosed_itInsertsCorrectly() {
-//        Service service = mock(Service.class);
-//        when(service.getActivityList()).thenReturn(new SequentialJobActivityList(service));
-//        when(service.getTimeWindow()).thenReturn(mock(TimeWindow.class));
-
-        Location loc = Location.Builder.newInstance().setId("loc").build();
-        Service service = createService("s1", loc).build();
-
-        Vehicle vehicle = mock(Vehicle.class);
-        when(vehicle.getStartLocation()).thenReturn(loc("vehLoc"));
-        when(vehicle.getEndLocation()).thenReturn(loc("vehLoc"));
-        when(vehicle.isReturnToDepot()).thenReturn(true);
-        when(vehicle.getId()).thenReturn("vehId");
-
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, mock(Driver.class)).addService(service).build();
-        //start - pick(shipment) - del(shipment) - end
-        Service serviceToInsert = createService("toInsert", loc).build();
-
-        InsertionData iData = mock(InsertionData.class);
-        when(iData.getDeliveryInsertionIndex()).thenReturn(1);
-        when(iData.getSelectedVehicle()).thenReturn(vehicle);
-
-        VehicleRoutingProblem vehicleRoutingProblem = mock(VehicleRoutingProblem.class);
-        List<JobActivity> acts = new ArrayList<>();
-        PickupServiceDEPRECATED act = new PickupServiceDEPRECATED(serviceToInsert);
-        acts.add(act);
-        when(vehicleRoutingProblem.copyAndGetActivities(serviceToInsert)).thenReturn(acts);
-        Inserter inserter = new Inserter(mock(InsertionListeners.class), vehicleRoutingProblem);
-        inserter.insertJob(serviceToInsert, iData, route);
-
-        assertEquals(2, route.getTourActivities().getActivities().size());
-        assertEquals(route.getTourActivities().getActivities().get(1).getLocation().getId(), serviceToInsert.getLocation().getId());
-        assertEquals(route.getEnd().getLocation().getId(), vehicle.getEndLocation().getId());
-    }
-
-    private Location loc(String vehLoc) {
-        return Location.Builder.newInstance().setId(vehLoc).build();
-    }
-
-    @Test
-    public void whenInsertingServiceAndRouteIsOpen_itInsertsCorrectlyAndSwitchesEndLocation() {
-        Service service = createService("alma", Location.newInstance("loc")).build();
-        Vehicle vehicle = mock(Vehicle.class);
-        when(vehicle.getStartLocation()).thenReturn(Location.newInstance("vehLoc"));
-        when(vehicle.getEndLocation()).thenReturn(Location.newInstance("vehLoc"));
-        when(vehicle.isReturnToDepot()).thenReturn(false);
-        when(vehicle.getId()).thenReturn("vehId");
-
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, mock(Driver.class)).addService(service).build();
-        Service serviceToInsert = createService("alma", Location.newInstance("delLoc")).build();
-
-        InsertionData iData = mock(InsertionData.class);
-        when(iData.getDeliveryInsertionIndex()).thenReturn(1);
-        when(iData.getSelectedVehicle()).thenReturn(vehicle);
-
-        VehicleRoutingProblem vehicleRoutingProblem = mock(VehicleRoutingProblem.class);
-// REMARK - Balage1551 - This one is throwing a mockito exception, I don't understand why.
-        when(vehicleRoutingProblem.copyAndGetActivities(serviceToInsert)).thenReturn(getTourActivities(serviceToInsert));
-
-        Inserter inserter = new Inserter(mock(InsertionListeners.class), vehicleRoutingProblem);
-        inserter.insertJob(serviceToInsert, iData, route);
-
-        assertEquals(2, route.getTourActivities().getActivities().size());
-        assertEquals(route.getTourActivities().getActivities().get(1).getLocation().getId(), serviceToInsert.getLocation().getId());
-        assertEquals(route.getEnd().getLocation().getId(), serviceToInsert.getLocation().getId());
-    }
-
-    private List<JobActivity> getTourActivities(Service serviceToInsert) {
-        List<JobActivity> acts = new ArrayList<>();
-        acts.add(new PickupServiceDEPRECATED(serviceToInsert));
-        return acts;
-    }
-
-
-    @Test
-    public void whenInsertingShipmentAndRouteIsClosed_itInsertsCorrectly() {
-        Shipment shipment = createStandardShipment("s1").build();
-
-        Vehicle vehicle = mock(Vehicle.class);
-        when(vehicle.getStartLocation()).thenReturn(loc("vehLoc"));
-        when(vehicle.getEndLocation()).thenReturn(loc("vehLoc"));
-        when(vehicle.isReturnToDepot()).thenReturn(true);
-        when(vehicle.getId()).thenReturn("vehId");
-
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, mock(Driver.class)).addPickup(shipment).addDelivery(shipment).build();
-        //start - pick(shipment) - del(shipment) - end
-        Shipment shipmentToInsert = Shipment.Builder.newInstance("s").setDeliveryLocation(Location.newInstance("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
-
-        InsertionData iData = mock(InsertionData.class);
-        when(iData.getPickupInsertionIndex()).thenReturn(2);
-        when(iData.getDeliveryInsertionIndex()).thenReturn(2);
-        when(iData.getSelectedVehicle()).thenReturn(vehicle);
-
-        VehicleRoutingProblem vehicleRoutingProblem = mock(VehicleRoutingProblem.class);
-        when(vehicleRoutingProblem.copyAndGetActivities(shipmentToInsert)).thenReturn(getTourActivities(shipmentToInsert));
-        Inserter inserter = new Inserter(mock(InsertionListeners.class), vehicleRoutingProblem);
-        inserter.insertJob(shipmentToInsert, iData, route);
-
-        assertEquals(4, route.getTourActivities().getActivities().size());
-        assertEquals(route.getTourActivities().getActivities().get(2).getLocation().getId(), shipmentToInsert.getPickupLocation().getId());
-        assertEquals(route.getTourActivities().getActivities().get(3).getLocation().getId(), shipmentToInsert.getDeliveryLocation().getId());
-        assertEquals(route.getEnd().getLocation().getId(), vehicle.getEndLocation().getId());
-    }
-
-    private List<JobActivity> getTourActivities(Shipment shipmentToInsert) {
-        List<JobActivity> acts = new ArrayList<>();
-        acts.add(new PickupShipmentDEPRECATED(shipmentToInsert));
-        acts.add(new DeliverShipmentDEPRECATED(shipmentToInsert));
-        return acts;
-    }
-
-    @Test
-    public void whenInsertingShipmentAndRouteIsOpen_itInsertsCorrectlyAndSwitchesEndLocation() {
-        Shipment shipment = createStandardShipment("s1").build();
-
-        Vehicle vehicle = mock(Vehicle.class);
-        when(vehicle.isReturnToDepot()).thenReturn(false);
-        when(vehicle.getId()).thenReturn("vehId");
-
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, mock(Driver.class)).addPickup(shipment).addDelivery(shipment).build();
-        //start - pick(shipment) - del(shipment) - end
-        Shipment shipmentToInsert = Shipment.Builder.newInstance("s").setDeliveryLocation(Location.newInstance("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
-        InsertionData iData = mock(InsertionData.class);
-        when(iData.getPickupInsertionIndex()).thenReturn(2);
-        when(iData.getDeliveryInsertionIndex()).thenReturn(2);
-        when(iData.getSelectedVehicle()).thenReturn(vehicle);
-
-        VehicleRoutingProblem vehicleRoutingProblem = mock(VehicleRoutingProblem.class);
-        when(vehicleRoutingProblem.copyAndGetActivities(shipmentToInsert)).thenReturn(getTourActivities(shipmentToInsert));
-        Inserter inserter = new Inserter(mock(InsertionListeners.class), vehicleRoutingProblem);
-        inserter.insertJob(shipmentToInsert, iData, route);
-
-        assertEquals(4, route.getTourActivities().getActivities().size());
-        assertEquals(route.getTourActivities().getActivities().get(2).getLocation().getId(), shipmentToInsert.getPickupLocation().getId());
-        assertEquals(route.getTourActivities().getActivities().get(3).getLocation().getId(), shipmentToInsert.getDeliveryLocation().getId());
-        assertEquals(route.getEnd().getLocation().getId(), shipmentToInsert.getDeliveryLocation().getId());
-    }
-
-    @Test
-    public void whenSwitchingVehicleAndRouteIsClosed_newStartAndEndShouldBeTheLocationOfNewVehicle() {
-        Shipment shipment = createStandardShipment("s1").build();
-        Vehicle vehicle = VehicleImpl.Builder.newInstance("vehId").setStartLocation(Location.newInstance("vehLoc")).setType(mock(VehicleType.class)).build();
-        Vehicle newVehicle = VehicleImpl.Builder.newInstance("newVehId").setStartLocation(Location.newInstance("newVehLoc")).setType(mock(VehicleType.class)).build();
-
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, mock(Driver.class)).addPickup(shipment).addDelivery(shipment).build();
-        //start - pick(shipment) - del(shipment) - end
-        Shipment shipmentToInsert = Shipment.Builder.newInstance("s").setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).setDeliveryLocation(Location.newInstance("delLoc")).build();
-
-        InsertionData iData = mock(InsertionData.class);
-        when(iData.getPickupInsertionIndex()).thenReturn(2);
-        when(iData.getDeliveryInsertionIndex()).thenReturn(2);
-        when(iData.getSelectedVehicle()).thenReturn(newVehicle);
-
-        VehicleRoutingProblem vehicleRoutingProblem = mock(VehicleRoutingProblem.class);
-        when(vehicleRoutingProblem.copyAndGetActivities(shipmentToInsert)).thenReturn(getTourActivities(shipmentToInsert));
-        Inserter inserter = new Inserter(mock(InsertionListeners.class), vehicleRoutingProblem);
-        inserter.insertJob(shipmentToInsert, iData, route);
-
-        assertEquals(route.getEnd().getLocation().getId(), newVehicle.getEndLocation().getId());
-    }
-
-    @Test
-    public void whenSwitchingVehicleAndRouteIsOpen_endLocationShouldBeTheLocationOfTheLastActivity() {
-        Shipment shipment = createStandardShipment("s1").build();
-        Vehicle vehicle = VehicleImpl.Builder.newInstance("vehId").setReturnToDepot(false).setStartLocation(Location.newInstance("vehLoc")).setType(mock(VehicleType.class)).build();
-        Vehicle newVehicle = VehicleImpl.Builder.newInstance("newVehId").setReturnToDepot(false).setStartLocation(Location.newInstance("newVehLoc")).setType(mock(VehicleType.class)).build();
-
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, mock(Driver.class)).addPickup(shipment).addDelivery(shipment).build();
-        //start - pick(shipment) - del(shipment) - end
-        Shipment shipmentToInsert = Shipment.Builder.newInstance("s").setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).setDeliveryLocation(Location.newInstance("delLoc")).build();
-
-        InsertionData iData = mock(InsertionData.class);
-        when(iData.getPickupInsertionIndex()).thenReturn(2);
-        when(iData.getDeliveryInsertionIndex()).thenReturn(2);
-        when(iData.getSelectedVehicle()).thenReturn(newVehicle);
-
-        VehicleRoutingProblem vehicleRoutingProblem = mock(VehicleRoutingProblem.class);
-        when(vehicleRoutingProblem.copyAndGetActivities(shipmentToInsert)).thenReturn(getTourActivities(shipmentToInsert));
-        Inserter inserter = new Inserter(mock(InsertionListeners.class), vehicleRoutingProblem);
-        inserter.insertJob(shipmentToInsert, iData, route);
-
-        assertEquals("delLoc", route.getEnd().getLocation().getId());
-    }
-
-    @Test
-    public void whenInsertingShipmentAtBeginningAndSwitchingVehicleAndRouteIsOpen_endLocationShouldBeTheLocationOfTheLastActivity() {
-        Shipment shipment = createStandardShipment("s1")
-                .setDeliveryLocation(Location.newInstance("oldShipmentDelLoc"))
-                .build();
-        Vehicle vehicle = VehicleImpl.Builder.newInstance("vehId").setReturnToDepot(false).setStartLocation(Location.Builder.newInstance().setId("vehLoc").build()).setType(mock(VehicleType.class)).build();
-        Vehicle newVehicle = VehicleImpl.Builder.newInstance("newVehId").setReturnToDepot(false).setStartLocation(Location.Builder.newInstance().setId("newVehLoc").build()).setType(mock(VehicleType.class)).build();
-
-        VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle, mock(Driver.class)).addPickup(shipment).addDelivery(shipment).build();
-        //start - pick(shipment) - del(shipment) - end
-        Shipment shipmentToInsert = Shipment.Builder.newInstance("s").setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).setDeliveryLocation(Location.newInstance("delLoc")).build();
-
-        InsertionData iData = mock(InsertionData.class);
-        when(iData.getPickupInsertionIndex()).thenReturn(0);
-        when(iData.getDeliveryInsertionIndex()).thenReturn(0);
-        when(iData.getSelectedVehicle()).thenReturn(newVehicle);
-
-        VehicleRoutingProblem vehicleRoutingProblem = mock(VehicleRoutingProblem.class);
-        when(vehicleRoutingProblem.copyAndGetActivities(shipmentToInsert)).thenReturn(getTourActivities(shipmentToInsert));
-        Inserter inserter = new Inserter(mock(InsertionListeners.class), vehicleRoutingProblem);
-        inserter.insertJob(shipmentToInsert, iData, route);
-
-        UpdateEndLocationIfRouteIsOpen updateEnd = new UpdateEndLocationIfRouteIsOpen();
-        updateEnd.visit(route);
-
-        assertEquals("oldShipmentDelLoc", route.getEnd().getLocation().getId());
-    }
-
-}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestMixedServiceAndShipmentsProblemOnRouteLevel.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestMixedServiceAndShipmentsProblemOnRouteLevel.java
index 7bcb244b3..7cad5e030 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestMixedServiceAndShipmentsProblemOnRouteLevel.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestMixedServiceAndShipmentsProblemOnRouteLevel.java
@@ -104,7 +104,7 @@ public void whenHavingShipmentsAndServicesInOneProblem_andInsertionShouldBeMadeO
 
     }
 
-    @Test
+    @Test(expected = UnsupportedOperationException.class)
     public void whenHavingOnlyServicesInOneProblem_andInsertionShouldBeMadeOnRouteLevel_itShouldAssertTrue() {
         /* get a vehicle type-builder and build a type with the typeId "vehicleType" and a capacity of 2
          */
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestRouteLevelActivityInsertionCostEstimator.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestRouteLevelActivityInsertionCostEstimator.java
deleted file mode 100644
index 9bd1c443e..000000000
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestRouteLevelActivityInsertionCostEstimator.java
+++ /dev/null
@@ -1,203 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import static org.junit.Assert.assertEquals;
-
-import java.util.Arrays;
-import java.util.Collections;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import com.graphhopper.jsprit.core.algorithm.state.StateManager;
-import com.graphhopper.jsprit.core.algorithm.state.UpdateVariableCosts;
-import com.graphhopper.jsprit.core.problem.CopyJobActivityFactory;
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.job.Service;
-import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivityNEW;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupServiceDEPRECATED;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
-import com.graphhopper.jsprit.core.util.CostFactory;
-
-/**
- * unit tests to test route level insertion
- */
-public class TestRouteLevelActivityInsertionCostEstimator {
-
-    private VehicleRoute route;
-
-    private VehicleRoutingTransportCosts routingCosts;
-
-    private VehicleRoutingActivityCosts activityCosts;
-
-    private StateManager stateManager;
-
-    @Before
-    public void doBefore() {
-        routingCosts = CostFactory.createEuclideanCosts();
-
-        activityCosts = new VehicleRoutingActivityCosts() {
-
-            @Override
-            public double getActivityCost(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
-                return Math.max(0., arrivalTime - tourAct.getTheoreticalLatestOperationStartTime());
-            }
-
-            @Override
-            public double getActivityDuration(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
-                return tourAct.getOperationTime();
-            }
-
-        };
-        Service s1 = new Service.Builder("s1").setLocation(Location.newInstance("10,0")).setTimeWindow(TimeWindow.newInstance(10., 10.)).build();
-        Service s2 = new Service.Builder("s2").setLocation(Location.newInstance("20,0")).setTimeWindow(TimeWindow.newInstance(20., 20.)).build();
-        Service s3 = new Service.Builder("s3").setLocation(Location.newInstance("30,0")).setTimeWindow(TimeWindow.newInstance(30., 30.)).build();
-
-        VehicleType type = VehicleTypeImpl.Builder.newInstance("type").build();
-        Vehicle vehicle = VehicleImpl.Builder.newInstance("vehicle").setStartLocation(Location.newInstance("0,0")).setType(type).build();
-
-        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
-        final VehicleRoutingProblem vrp = vrpBuilder.addJob(s1).addJob(s2).addJob(s3).build();
-
-        vrp.getActivities(s1).get(0).setTheoreticalEarliestOperationStartTime(10);
-        vrp.getActivities(s1).get(0).setTheoreticalLatestOperationStartTime(10);
-
-        vrp.getActivities(s2).get(0).setTheoreticalEarliestOperationStartTime(20);
-        vrp.getActivities(s2).get(0).setTheoreticalLatestOperationStartTime(20);
-
-        vrp.getActivities(s3).get(0).setTheoreticalEarliestOperationStartTime(30);
-        vrp.getActivities(s3).get(0).setTheoreticalLatestOperationStartTime(30);
-
-        route = VehicleRoute.Builder.newInstance(vehicle).setJobActivityFactory(new CopyJobActivityFactory())
-                .addService(s1).addService(s2).addService(s3)
-                .build();
-
-        stateManager = new StateManager(vrp);
-        stateManager.addStateUpdater(new UpdateVariableCosts(activityCosts, routingCosts, stateManager));
-        stateManager.informInsertionStarts(Arrays.asList(route), Collections.<Job>emptyList());
-    }
-
-    @Test
-    public void whenNewActInBetweenFirstAndSecond_and_forwardLookingIs0_itShouldReturnCorrectCosts() {
-        Service s4 = new Service.Builder("s4").setLocation(Location.newInstance("5,0")).build();
-        PickupActivityNEW pickupService = new PickupServiceDEPRECATED(s4);
-        JobInsertionContext context = new JobInsertionContext(route, s4, route.getVehicle(), route.getDriver(), 0.);
-        RouteLevelActivityInsertionCostsEstimator estimator = new RouteLevelActivityInsertionCostsEstimator(routingCosts, activityCosts, stateManager);
-        estimator.setForwardLooking(0);
-        double iCosts = estimator.getCosts(context, route.getStart(), route.getActivities().get(0), pickupService, 0.);
-        assertEquals(0., iCosts, 0.01);
-    }
-
-    @Test
-    public void whenNewActWithTWInBetweenFirstAndSecond_and_forwardLookingIs0_itShouldReturnCorrectCosts() {
-        Service s4 = new Service.Builder("s4").setLocation(Location.newInstance("5,0")).setTimeWindow(TimeWindow.newInstance(5., 5.)).build();
-        PickupActivityNEW pickupService = new PickupServiceDEPRECATED(s4);
-        JobInsertionContext context = new JobInsertionContext(route, s4, route.getVehicle(), route.getDriver(), 0.);
-        RouteLevelActivityInsertionCostsEstimator estimator = new RouteLevelActivityInsertionCostsEstimator(routingCosts, activityCosts, stateManager);
-        estimator.setForwardLooking(0);
-        double iCosts = estimator.getCosts(context, route.getStart(), route.getActivities().get(0), pickupService, 0.);
-        assertEquals(0., iCosts, 0.01);
-    }
-
-    @Test
-    public void whenNewActWithTWAndServiceTimeInBetweenFirstAndSecond_and_forwardLookingIs0_itShouldReturnCorrectCosts() {
-        Service s4 = new Service.Builder("s4").setLocation(Location.newInstance("5,0")).setServiceTime(10.).setTimeWindow(TimeWindow.newInstance(5., 5.)).build();
-        PickupActivityNEW pickupService = new PickupServiceDEPRECATED(s4);
-        pickupService.setTheoreticalEarliestOperationStartTime(5);
-        pickupService.setTheoreticalLatestOperationStartTime(5);
-
-        JobInsertionContext context = new JobInsertionContext(route, s4, route.getVehicle(), route.getDriver(), 0.);
-        RouteLevelActivityInsertionCostsEstimator estimator = new RouteLevelActivityInsertionCostsEstimator(routingCosts, activityCosts, stateManager);
-        estimator.setForwardLooking(0);
-        double iCosts = estimator.getCosts(context, route.getStart(), route.getActivities().get(0), pickupService, 0.);
-        double expectedTransportCosts = 0.;
-        double expectedActivityCosts = 10.;
-        assertEquals(expectedActivityCosts + expectedTransportCosts, iCosts, 0.01);
-    }
-
-    @Test
-    public void whenNewActWithTWAndServiceTimeInBetweenFirstAndSecond_and_forwardLookingIs3_itShouldReturnCorrectCosts() {
-        Service s4 = new Service.Builder("s4").setLocation(Location.newInstance("5,0")).setServiceTime(10.).setTimeWindow(TimeWindow.newInstance(5., 5.)).build();
-        PickupActivityNEW pickupService = new PickupServiceDEPRECATED(s4);
-        JobInsertionContext context = new JobInsertionContext(route, s4, route.getVehicle(), route.getDriver(), 0.);
-        RouteLevelActivityInsertionCostsEstimator estimator = new RouteLevelActivityInsertionCostsEstimator(routingCosts, activityCosts, stateManager);
-        estimator.setForwardLooking(3);
-        double iCosts = estimator.getCosts(context, route.getStart(), route.getActivities().get(0), pickupService, 0.);
-        double expectedTransportCosts = 0.;
-        double expectedActivityCosts = 30.;
-        assertEquals(expectedActivityCosts + expectedTransportCosts, iCosts, 0.01);
-    }
-
-    @Test
-    public void whenNewActInBetweenSecondAndThird_and_forwardLookingIs0_itShouldReturnCorrectCosts() {
-        Service s4 = new Service.Builder("s4").setLocation(Location.newInstance("5,0")).build();
-        PickupActivityNEW pickupService = new PickupServiceDEPRECATED(s4);
-        JobInsertionContext context = new JobInsertionContext(route, s4, route.getVehicle(), route.getDriver(), 0.);
-        RouteLevelActivityInsertionCostsEstimator estimator = new RouteLevelActivityInsertionCostsEstimator(routingCosts, activityCosts, stateManager);
-        estimator.setForwardLooking(0);
-        double iCosts =
-                estimator.getCosts(context, route.getActivities().get(0), route.getActivities().get(1), pickupService, 10.);
-        double expectedTransportCosts = 10.;
-        double expectedActivityCosts = 10.;
-        assertEquals(expectedTransportCosts + expectedActivityCosts, iCosts, 0.01);
-    }
-
-    @Test
-    public void whenNewActInBetweenSecondAndThird_and_forwardLookingIs3_itShouldReturnCorrectCosts() {
-        Service s4 = new Service.Builder("s4").setLocation(Location.newInstance("5,0")).build();
-        PickupActivityNEW pickupService = new PickupServiceDEPRECATED(s4);
-        JobInsertionContext context = new JobInsertionContext(route, s4, route.getVehicle(), route.getDriver(), 0.);
-        RouteLevelActivityInsertionCostsEstimator estimator = new RouteLevelActivityInsertionCostsEstimator(routingCosts, activityCosts, stateManager);
-        estimator.setForwardLooking(3);
-        double iCosts =
-                estimator.getCosts(context, route.getActivities().get(0), route.getActivities().get(1), pickupService, 10.);
-        double expectedTransportCosts = 10.;
-        double expectedActivityCosts = 10. + 10.;
-        assertEquals(expectedTransportCosts + expectedActivityCosts, iCosts, 0.01);
-    }
-
-    @Test
-    public void whenNewActWithTWInBetweenSecondAndThird_and_forwardLookingIs3_itShouldReturnCorrectCosts() {
-        Service s4 = new Service.Builder("s4").setLocation(Location.newInstance("5,0")).setTimeWindow(TimeWindow.newInstance(5., 5.)).build();
-        PickupActivityNEW pickupService = new PickupServiceDEPRECATED(s4);
-        pickupService.setTheoreticalEarliestOperationStartTime(5);
-        pickupService.setTheoreticalLatestOperationStartTime(5);
-        JobInsertionContext context = new JobInsertionContext(route, s4, route.getVehicle(), route.getDriver(), 0.);
-        RouteLevelActivityInsertionCostsEstimator estimator = new RouteLevelActivityInsertionCostsEstimator(routingCosts, activityCosts, stateManager);
-        estimator.setForwardLooking(3);
-        double iCosts =
-                estimator.getCosts(context, route.getActivities().get(0), route.getActivities().get(1), pickupService, 10.);
-        double expectedTransportCosts = 10.;
-        double expectedActivityCosts = 10. + 10. + 10.;
-        assertEquals(expectedTransportCosts + expectedActivityCosts, iCosts, 0.01);
-    }
-
-}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestRouteLevelServiceInsertionCostEstimator.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestRouteLevelServiceInsertionCostEstimator.java
deleted file mode 100644
index 83699621d..000000000
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestRouteLevelServiceInsertionCostEstimator.java
+++ /dev/null
@@ -1,238 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.algorithm.recreate;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import com.graphhopper.jsprit.core.algorithm.state.StateManager;
-import com.graphhopper.jsprit.core.algorithm.state.UpdateVariableCosts;
-import com.graphhopper.jsprit.core.problem.CopyJobActivityFactory;
-import com.graphhopper.jsprit.core.problem.JobActivityFactory;
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.SimpleJobActivityFactory;
-import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
-import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
-import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.job.Service;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupServiceDEPRECATED;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
-import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
-import com.graphhopper.jsprit.core.util.CostFactory;
-
-/**
- * Created by schroeder on 02.07.14.
- */
-public class TestRouteLevelServiceInsertionCostEstimator {
-
-    private VehicleRoute route;
-
-    private VehicleRoutingTransportCosts routingCosts;
-
-    private VehicleRoutingActivityCosts activityCosts;
-
-    private StateManager stateManager;
-
-    private ConstraintManager constraintManager;
-
-    private VehicleRoutingProblem vrp;
-
-    private JobActivityFactory activityFactory;
-
-    @Before
-    public void doBefore() {
-        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
-
-        routingCosts = CostFactory.createEuclideanCosts();
-        vrpBuilder.setRoutingCost(routingCosts);
-
-        activityCosts = new VehicleRoutingActivityCosts() {
-
-            @Override
-            public double getActivityCost(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
-                return Math.max(0., arrivalTime - tourAct.getTheoreticalLatestOperationStartTime());
-            }
-
-            @Override
-            public double getActivityDuration(TourActivity tourAct, double arrivalTime, Driver driver, Vehicle vehicle) {
-                return tourAct.getOperationTime();
-            }
-
-        };
-        vrpBuilder.setActivityCosts(activityCosts);
-
-        Service s1 = new Service.Builder("s1").setLocation(Location.newInstance("10,0")).setTimeWindow(TimeWindow.newInstance(10., 10.)).build();
-        Service s2 = new Service.Builder("s2").setLocation(Location.newInstance("20,0")).setTimeWindow(TimeWindow.newInstance(20., 20.)).build();
-        Service s3 = new Service.Builder("s3").setLocation(Location.newInstance("30,0")).setTimeWindow(TimeWindow.newInstance(30., 30.)).build();
-        vrpBuilder.addJob(s1).addJob(s2).addJob(s3);
-
-        VehicleType type = VehicleTypeImpl.Builder.newInstance("type").build();
-        VehicleImpl vehicle = VehicleImpl.Builder.newInstance("vehicle").setStartLocation(Location.newInstance("0,0")).setType(type).build();
-        vrpBuilder.addVehicle(vehicle);
-        vrp = vrpBuilder.build();
-
-        vrp.getActivities(s1).get(0).setTheoreticalEarliestOperationStartTime(10);
-        vrp.getActivities(s1).get(0).setTheoreticalLatestOperationStartTime(10);
-
-        vrp.getActivities(s2).get(0).setTheoreticalEarliestOperationStartTime(20);
-        vrp.getActivities(s2).get(0).setTheoreticalLatestOperationStartTime(20);
-
-        vrp.getActivities(s3).get(0).setTheoreticalEarliestOperationStartTime(30);
-        vrp.getActivities(s3).get(0).setTheoreticalLatestOperationStartTime(30);
-
-        activityFactory = new CopyJobActivityFactory();
-        route = VehicleRoute.Builder.newInstance(vehicle).setJobActivityFactory(activityFactory).addService(s1).addService(s2).addService(s3).build();
-
-        VehicleRoutingProblem vrpMock = mock(VehicleRoutingProblem.class);
-        when(vrpMock.getFleetSize()).thenReturn(VehicleRoutingProblem.FleetSize.INFINITE);
-        stateManager = new StateManager(vrpMock);
-        stateManager.addStateUpdater(new UpdateVariableCosts(activityCosts, routingCosts, stateManager));
-        stateManager.informInsertionStarts(Arrays.asList(route), Collections.<Job>emptyList());
-        constraintManager = new ConstraintManager(vrp, stateManager);
-    }
-
-    @Test
-    public void whenNewServiceNeedToBeInserted_itShouldReturnCorrectInsertionCosts() {
-        final Service s4 = new Service.Builder("s4").setLocation(Location.newInstance("5,0")).setTimeWindow(TimeWindow.newInstance(5., 5.)).build();
-        RouteLevelActivityInsertionCostsEstimator estimator = new RouteLevelActivityInsertionCostsEstimator(routingCosts, activityCosts, stateManager);
-        estimator.setForwardLooking(0);
-        ServiceInsertionOnRouteLevelCalculator routeInserter = new ServiceInsertionOnRouteLevelCalculator(routingCosts,
-                activityCosts, estimator, constraintManager, constraintManager);
-        routeInserter.setStates(stateManager);
-        routeInserter.setJobActivityFactory(new SimpleJobActivityFactory());
-        InsertionData iData = routeInserter.getInsertionData(route, s4, route.getVehicle(), route.getDepartureTime(), route.getDriver(), Double.MAX_VALUE);
-        assertEquals(0., iData.getInsertionCost(), 0.01);
-    }
-
-    @Test
-    public void whenNewServiceNeedToBeInserted_itShouldReturnCorrectInsertionIndex() {
-        final Service s4 = new Service.Builder("s4").setLocation(Location.newInstance("5,0")).setTimeWindow(TimeWindow.newInstance(5., 5.)).build();
-        RouteLevelActivityInsertionCostsEstimator estimator = new RouteLevelActivityInsertionCostsEstimator(routingCosts, activityCosts, stateManager);
-        estimator.setForwardLooking(0);
-        final ServiceInsertionOnRouteLevelCalculator routeInserter = new ServiceInsertionOnRouteLevelCalculator(routingCosts,
-                activityCosts, estimator, constraintManager, constraintManager);
-        routeInserter.setStates(stateManager);
-        routeInserter.setJobActivityFactory(new SimpleJobActivityFactory());
-        InsertionData iData = routeInserter.getInsertionData(route, s4, route.getVehicle(), route.getDepartureTime(), route.getDriver(), Double.MAX_VALUE);
-        assertEquals(0, iData.getDeliveryInsertionIndex(), 0.01);
-    }
-
-    @Test
-    public void whenNewServiceWithServiceTimeNeedToBeInserted_itShouldReturnCorrectInsertionData() {
-        final Service s4 = new Service.Builder("s4").setServiceTime(10.).setLocation(Location.newInstance("5,0")).setTimeWindow(TimeWindow.newInstance(5., 5.)).build();
-        RouteLevelActivityInsertionCostsEstimator estimator = new RouteLevelActivityInsertionCostsEstimator(routingCosts, activityCosts, stateManager);
-        estimator.setForwardLooking(0);
-        ServiceInsertionOnRouteLevelCalculator routeInserter = new ServiceInsertionOnRouteLevelCalculator(routingCosts,
-                activityCosts, estimator, constraintManager, constraintManager);
-        routeInserter.setStates(stateManager);
-        routeInserter.setJobActivityFactory(new JobActivityFactory() {
-            @Override
-            public List<JobActivity> createActivities(Job job) {
-                List<JobActivity> acts = activityFactory.createActivities(job);
-                if (acts.isEmpty()) {
-                    // TODO - Balage1551
-                    PickupServiceDEPRECATED pickupService = new PickupServiceDEPRECATED(s4);
-                    pickupService.setTheoreticalEarliestOperationStartTime(5);
-                    pickupService.setTheoreticalLatestOperationStartTime(5);
-                    acts.add(pickupService);
-                }
-                return acts;
-            }
-        });
-        InsertionData iData = routeInserter.getInsertionData(route, s4, route.getVehicle(), route.getDepartureTime(), route.getDriver(), Double.MAX_VALUE);
-        assertEquals(0, iData.getDeliveryInsertionIndex(), 0.01);
-        assertEquals(30., iData.getInsertionCost(), 0.01);
-    }
-
-
-    @Test
-    public void whenNewServiceWithServiceTimeNeedToBeInsertedAndRouteIsEmpty_itShouldReturnCorrectInsertionData() {
-        final Service s4 = new Service.Builder("s4").setServiceTime(10.).setLocation(Location.newInstance("5,0")).setTimeWindow(TimeWindow.newInstance(5., 5.)).build();
-//        PickupActivity pickupService = new PickupServiceDEPRECATED(s4);
-        VehicleRoute emptyroute = VehicleRoute.emptyRoute();
-        RouteLevelActivityInsertionCostsEstimator estimator = new RouteLevelActivityInsertionCostsEstimator(routingCosts, activityCosts, stateManager);
-        estimator.setForwardLooking(0);
-        ServiceInsertionOnRouteLevelCalculator routeInserter = new ServiceInsertionOnRouteLevelCalculator(routingCosts,
-                activityCosts, estimator, constraintManager, constraintManager);
-        routeInserter.setStates(stateManager);
-        routeInserter.setJobActivityFactory(new JobActivityFactory() {
-            @Override
-            public List<JobActivity> createActivities(Job job) {
-                // TODO - Balage1551
-                List<JobActivity> acts = activityFactory.createActivities(job);
-                if (acts.isEmpty()) {
-                    PickupServiceDEPRECATED pickupService = new PickupServiceDEPRECATED(s4);
-                    pickupService.setTheoreticalEarliestOperationStartTime(5);
-                    pickupService.setTheoreticalLatestOperationStartTime(5);
-                    acts.add(pickupService);
-                }
-                return acts;
-            }
-        });
-        InsertionData iData = routeInserter.getInsertionData(emptyroute, s4, route.getVehicle(), route.getDepartureTime(), route.getDriver(), Double.MAX_VALUE);
-        assertEquals(0, iData.getDeliveryInsertionIndex(), 0.01);
-        assertEquals(10., iData.getInsertionCost(), 0.01);
-    }
-
-    @Test
-    public void whenNewServiceWithServiceTimeAndTWNeedToBeInsertedAndRouteIsEmpty_itShouldReturnCorrectInsertionData() {
-        final Service s4 = new Service.Builder("s4").setServiceTime(10.).setLocation(Location.newInstance("5,0")).setTimeWindow(TimeWindow.newInstance(3., 3.)).build();
-//        PickupActivity pickupService = new PickupServiceDEPRECATED(s4);
-        VehicleRoute emptyroute = VehicleRoute.emptyRoute();
-        RouteLevelActivityInsertionCostsEstimator estimator = new RouteLevelActivityInsertionCostsEstimator(routingCosts, activityCosts, stateManager);
-        estimator.setForwardLooking(0);
-        ServiceInsertionOnRouteLevelCalculator routeInserter = new ServiceInsertionOnRouteLevelCalculator(routingCosts,
-                activityCosts, estimator, constraintManager, constraintManager);
-        routeInserter.setStates(stateManager);
-        routeInserter.setJobActivityFactory(new JobActivityFactory() {
-            @Override
-            public List<JobActivity> createActivities(Job job) {
-                // TODO - Balage1551
-                List<JobActivity> acts = activityFactory.createActivities(job);
-                if (acts.isEmpty()) {
-                    PickupServiceDEPRECATED pickupService = new PickupServiceDEPRECATED(s4);
-                    pickupService.setTheoreticalEarliestOperationStartTime(3);
-                    pickupService.setTheoreticalLatestOperationStartTime(3);
-                    acts.add(pickupService);
-                }
-                return acts;
-            }
-        });
-        InsertionData iData = routeInserter.getInsertionData(emptyroute, s4, route.getVehicle(), route.getDepartureTime(), route.getDriver(), Double.MAX_VALUE);
-        assertEquals(0, iData.getDeliveryInsertionIndex(), 0.01);
-        assertEquals(10. + 2., iData.getInsertionCost(), 0.01);
-    }
-
-}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DefaultShipmentActivityFactoryTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DefaultShipmentActivityFactoryTest.java
index 7d5539519..5f606cf8d 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DefaultShipmentActivityFactoryTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DefaultShipmentActivityFactoryTest.java
@@ -29,7 +29,6 @@
 public class DefaultShipmentActivityFactoryTest {
 
     @Test
-    @Ignore
     public void whenCreatingPickupActivityWithShipment_itShouldReturnPickupShipment() {
         DefaultShipmentActivityFactory factory = new DefaultShipmentActivityFactory();
         Shipment shipment = Shipment.Builder.newInstance("s")
@@ -40,7 +39,6 @@ public void whenCreatingPickupActivityWithShipment_itShouldReturnPickupShipment(
     }
 
     @Test
-    @Ignore
     public void whenCreatingDeliverActivityWithShipment_itShouldReturnDeliverShipment() {
         DefaultShipmentActivityFactory factory = new DefaultShipmentActivityFactory();
         Shipment shipment = Shipment.Builder.newInstance("s")
diff --git a/jsprit-instances/src/test/java/com/graphhopper/jsprit/instance/reader/BelhaizaReaderTest.java b/jsprit-instances/src/test/java/com/graphhopper/jsprit/instance/reader/BelhaizaReaderTest.java
index 39ce8a17a..c132fca4e 100644
--- a/jsprit-instances/src/test/java/com/graphhopper/jsprit/instance/reader/BelhaizaReaderTest.java
+++ b/jsprit-instances/src/test/java/com/graphhopper/jsprit/instance/reader/BelhaizaReaderTest.java
@@ -118,8 +118,8 @@ public void firstTimeWindowShouldBeCorrect(){
 		VehicleRoutingProblem.Builder builder = VehicleRoutingProblem.Builder.newInstance();
 		new BelhaizaReader(builder).read(getPath());
 		VehicleRoutingProblem vrp = builder.build();
-		assertEquals(20.,((Service)vrp.getJobs().get("1")).getTimeWindows().iterator().next().getStart(),0.1);
-		assertEquals(31.,((Service)vrp.getJobs().get("1")).getTimeWindows().iterator().next().getEnd(),0.1);
+		assertEquals(20.,vrp.getJobs().get("1").getTimeWindows().iterator().next().getStart(),0.1);
+		assertEquals(31.,vrp.getJobs().get("1").getTimeWindows().iterator().next().getEnd(),0.1);
 	}
 
 	@Test
diff --git a/pom.xml b/pom.xml
index da7ba9ec9..5307aa671 100644
--- a/pom.xml
+++ b/pom.xml
@@ -70,7 +70,7 @@
     </modules>
 
     <properties>
-        <jdkVersion>1.7</jdkVersion>
+        <jdkVersion>1.8</jdkVersion>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
         <junit.version>4.12</junit.version>
         <mockito.version>1.9.5</mockito.version>
