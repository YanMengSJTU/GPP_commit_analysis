diff --git a/jsprit-core/pom.xml b/jsprit-core/pom.xml
index d925760b1..edb19ad32 100644
--- a/jsprit-core/pom.xml
+++ b/jsprit-core/pom.xml
@@ -42,6 +42,12 @@
             <version>${logger.version}</version>
         </dependency>
 
+        <dependency>
+            <groupId>redis.clients</groupId>
+            <artifactId>jedis</artifactId>
+            <version>2.9.0</version>
+        </dependency>
+
     </dependencies>
 
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/GoogleMapsCosts.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/GoogleMapsCosts.java
new file mode 100644
index 000000000..53c78a6fe
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/GoogleMapsCosts.java
@@ -0,0 +1,100 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ *
+ */
+package com.graphhopper.jsprit.core.util;
+
+import com.graphhopper.jsprit.core.algorithm.VehicleRoutingAlgorithm;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.cost.AbstractForwardVehicleRoutingTransportCosts;
+import com.graphhopper.jsprit.core.problem.driver.Driver;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import redis.clients.jedis.Jedis;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+
+/**
+ * @author stefan schroeder
+ */
+public class GoogleMapsCosts extends AbstractForwardVehicleRoutingTransportCosts {
+
+    public int speed = 1;
+
+    public double detourFactor = 1.0;
+
+    private AtomicInteger c = new AtomicInteger(0);
+    private Locations locations;
+    private final static Logger logger = LoggerFactory.getLogger(GoogleMapsCosts.class);
+
+    private String redisURI = "redis://localhost:6379";
+    private Jedis jedis;
+
+    public GoogleMapsCosts(Locations locations, String redisURI) {
+        super();
+        this.locations = locations;
+        this.redisURI = redisURI;
+        this.jedis = new Jedis(this.redisURI);
+    }
+
+    @Override
+    public String toString() {
+        return "[name=googleMapsCosts]";
+    }
+
+    @Override
+    public double getTransportCost(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
+        String cachedResponse = jedis.get("distances/" + from.getCoordinate().toString() + ":" + to.getCoordinate().toString());
+        if (cachedResponse == null) {
+            double distance = calculateDistance(from, to);
+            if (vehicle != null && vehicle.getType() != null) {
+                return distance * vehicle.getType().getVehicleCostParams().perDistanceUnit;
+            }
+            logger.info("calculate cost [{}] from {} to {}: {}", c.incrementAndGet(), from.getCoordinate().toString(), to.getCoordinate().toString(), distance);
+            jedis.set("distances/" + from.getCoordinate().toString() + ":" + to.getCoordinate().toString(), Double.toString(distance));
+            jedis.expire("distances/" + from.getCoordinate().toString() + ":" + to.getCoordinate().toString(), 900);
+            return distance;
+        }
+        return Double.parseDouble(cachedResponse);
+    }
+
+    double calculateDistance(Location fromLocation, Location toLocation) {
+        return calculateDistance(fromLocation.getCoordinate(), toLocation.getCoordinate());
+    }
+
+    double calculateDistance(Coordinate from, Coordinate to) {
+        try {
+            return GoogleMapsDistanceCalculator.calculateDistance(from, to) * detourFactor;
+        } catch (NullPointerException e) {
+            throw new NullPointerException("cannot calculate euclidean distance. coordinates are missing. either add coordinates or use another transport-cost-calculator.");
+        }
+    }
+
+    @Override
+    public double getTransportTime(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
+        return calculateDistance(from, to) / speed;
+    }
+
+    @Override
+    public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+            return calculateDistance(from, to);
+    }
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/GoogleMapsDistanceCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/GoogleMapsDistanceCalculator.java
new file mode 100644
index 000000000..eef9b4cbc
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/GoogleMapsDistanceCalculator.java
@@ -0,0 +1,29 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.jsprit.core.util;
+
+
+public class GoogleMapsDistanceCalculator {
+
+    public static double calculateDistance(Coordinate coord1, Coordinate coord2) {
+        double xDiff = coord1.getX() - coord2.getX();
+        double yDiff = coord1.getY() - coord2.getY();
+        return Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));
+    }
+
+}
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/GoogleMapsExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/GoogleMapsExample.java
new file mode 100644
index 000000000..d39fa1b35
--- /dev/null
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/GoogleMapsExample.java
@@ -0,0 +1,108 @@
+package com.graphhopper.jsprit.examples;
+
+import com.graphhopper.jsprit.analysis.toolbox.GraphStreamViewer;
+import com.graphhopper.jsprit.analysis.toolbox.GraphStreamViewer.Label;
+import com.graphhopper.jsprit.analysis.toolbox.Plotter;
+import com.graphhopper.jsprit.core.algorithm.VehicleRoutingAlgorithm;
+import com.graphhopper.jsprit.core.algorithm.box.Jsprit;
+import com.graphhopper.jsprit.core.algorithm.box.SchrimpfFactory;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
+import com.graphhopper.jsprit.core.problem.job.Service;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl.Builder;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
+import com.graphhopper.jsprit.core.reporting.SolutionPrinter;
+import com.graphhopper.jsprit.core.util.GoogleMapsCosts;
+import com.graphhopper.jsprit.core.util.Solutions;
+import com.graphhopper.jsprit.io.problem.VrpXMLWriter;
+
+import java.io.File;
+import java.util.Collection;
+
+public class GoogleMapsExample {
+    public static void main(String[] args) {
+        /*
+         * some preparation - create output folder
+         */
+        File dir = new File("output");
+        // if the directory does not exist, create it
+        if (!dir.exists()) {
+            System.out.println("creating directory ./output");
+            boolean result = dir.mkdir();
+            if (result) System.out.println("./output created");
+        }
+
+        /*
+         * get a vehicle type-builder and build a type with the typeId "vehicleType" and one capacity dimension, i.e. weight, and capacity dimension value of 2
+         */
+        final int WEIGHT_INDEX = 0;
+        VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType").addCapacityDimension(WEIGHT_INDEX, 2);
+        VehicleType vehicleType = vehicleTypeBuilder.build();
+
+        /*
+         * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
+         */
+        Builder vehicleBuilder = VehicleImpl.Builder.newInstance("vehicle");
+        vehicleBuilder.setStartLocation(Location.newInstance(14.062918, 100.607133));
+        vehicleBuilder.setType(vehicleType);
+        VehicleImpl vehicle = vehicleBuilder.build();
+
+        /*
+         * build services at the required locations, each with a capacity-demand of 1.
+         */
+        Service service1 = Service.Builder.newInstance("1").addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(13.726021, 100.525798)).build();
+        Service service2 = Service.Builder.newInstance("2").addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(13.722493, 100.529473)).build();
+
+        Service service3 = Service.Builder.newInstance("3").addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(13.759156, 100.497299)).build();
+        Service service4 = Service.Builder.newInstance("4").addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(13.741576, 100.508628)).build();
+
+
+        VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
+        vrpBuilder.setFleetSize(VehicleRoutingProblem.FleetSize.INFINITE);
+
+        vrpBuilder.addVehicle(vehicle);
+        vrpBuilder.addJob(service1).addJob(service2).addJob(service3).addJob(service4);
+
+        VehicleRoutingTransportCosts routingCosts = new GoogleMapsCosts(vrpBuilder.getLocations(), "redis://localhost:6379");
+        vrpBuilder.setRoutingCost(routingCosts);
+        VehicleRoutingProblem problem = vrpBuilder.build();
+
+        /*
+         * get the algorithm out-of-the-box.
+         */
+        VehicleRoutingAlgorithm algorithm  = Jsprit.Builder.newInstance(problem)
+            .setProperty(Jsprit.Parameter.FAST_REGRET, "true")
+            .setProperty(Jsprit.Parameter.THREADS, "1")
+            .setProperty(Jsprit.Parameter.FIXED_COST_PARAM, "1.") //Increase weight of the fixed cost to enable the force all vehicle workaround
+            .buildAlgorithm();
+
+        /*
+         * and search a solution
+         */
+        Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
+
+        /*
+         * get the best
+         */
+        VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
+
+        new VrpXMLWriter(problem, solutions).write("output/problem-with-solution.xml");
+
+        SolutionPrinter.print(problem, bestSolution, SolutionPrinter.Print.VERBOSE);
+
+        /*
+         * plot
+         */
+        new Plotter(problem,bestSolution).plot("output/plot.png","simple example");
+
+        /*
+        render problem and solution with GraphStream
+         */
+        new GraphStreamViewer(problem, bestSolution).labelWith(Label.ID).setRenderDelay(200).display();
+    }
+
+}
