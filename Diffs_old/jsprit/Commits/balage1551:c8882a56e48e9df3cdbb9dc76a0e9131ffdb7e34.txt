diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
index 06009522e..1f1f9b2aa 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
@@ -32,6 +32,12 @@
 import com.graphhopper.jsprit.core.algorithm.listener.AlgorithmEndsListener;
 import com.graphhopper.jsprit.core.algorithm.listener.IterationStartsListener;
 import com.graphhopper.jsprit.core.algorithm.module.RuinAndRecreateModule;
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.ActivityCost;
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.FixCostPerVehicle;
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.MissedBreak;
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.ModularSolutionCostCalculator;
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.TransportCost;
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.UnassignedJobs;
 import com.graphhopper.jsprit.core.algorithm.recreate.AbstractInsertionStrategy;
 import com.graphhopper.jsprit.core.algorithm.recreate.ActivityInsertionCostsCalculator;
 import com.graphhopper.jsprit.core.algorithm.recreate.BestInsertion;
@@ -56,12 +62,8 @@
 import com.graphhopper.jsprit.core.algorithm.state.StateManager;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
-import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.solution.SolutionCostCalculator;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.BreakActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.vehicle.FiniteFleetManagerFactory;
 import com.graphhopper.jsprit.core.problem.vehicle.InfiniteFleetManagerFactory;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleFleetManager;
@@ -714,42 +716,18 @@ private SolutionCostCalculator getObjectiveFunction(final VehicleRoutingProblem
             return objectiveFunction;
         }
 
-        SolutionCostCalculator solutionCostCalculator = new SolutionCostCalculator() {
-            @Override
-            public double getCosts(VehicleRoutingProblemSolution solution) {
-                double costs = 0.;
-
-                for (VehicleRoute route : solution.getRoutes()) {
-                    costs += route.getVehicle().getType().getVehicleCostParams().fix;
-                    boolean hasBreak = false;
-                    TourActivity prevAct = route.getStart();
-                    for (TourActivity act : route.getActivities()) {
-                        if (act instanceof BreakActivity) {
-                            hasBreak = true;
-                        }
-                        costs += vrp.getTransportCosts().getTransportCost(prevAct.getLocation(), act.getLocation(), prevAct.getEndTime(), route.getDriver(), route.getVehicle());
-                        costs += vrp.getActivityCosts().getActivityCost(act, act.getArrTime(), route.getDriver(), route.getVehicle());
-                        prevAct = act;
-                    }
-                    costs += vrp.getTransportCosts().getTransportCost(prevAct.getLocation(), route.getEnd().getLocation(), prevAct.getEndTime(), route.getDriver(), route.getVehicle());
-                    if (route.getVehicle().getBreak() != null) {
-                        if (!hasBreak) {
-                            //break defined and required but not assigned penalty
-                            if (route.getEnd().getArrTime() > route.getVehicle().getBreak().getActivity().getSingleTimeWindow()
-                                            .getEnd()) {
-                                costs += 4 * (maxCosts * 2 + route.getVehicle().getBreak().getActivity().getOperationTime()
-                                                * route.getVehicle().getType().getVehicleCostParams().perServiceTimeUnit);
-                            }
-                        }
-                    }
-                }
-                for(Job j : solution.getUnassignedJobs()){
-                    costs += maxCosts * 2 * (4 - j.getPriority());
-                }
-                return costs;
-            }
-        };
-        return solutionCostCalculator;
+        ModularSolutionCostCalculator modCalc = new ModularSolutionCostCalculator(vrp, maxCosts);
+        modCalc.addComponent(new FixCostPerVehicle())
+        .addComponent(new MissedBreak())
+        .addComponent(new TransportCost())
+        .addComponent(new ActivityCost())
+        .addComponent(new UnassignedJobs());
+
+        // TODO: not to do here!
+        modCalc.beforeRun();
+        modCalc.beforeSolution();
+
+        return modCalc;
     }
 
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ActivityCost.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ActivityCost.java
new file mode 100644
index 000000000..d14543306
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ActivityCost.java
@@ -0,0 +1,24 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+
+public class ActivityCost extends RouteLevelSolutionCostComponent {
+
+    public static final String COMPONENT_ID = "Activity";
+
+    public ActivityCost() {
+        super(COMPONENT_ID);
+    }
+
+    @Override
+    protected double calculateRouteLevelCost(VehicleRoutingProblem problem, VehicleRoute route) {
+        double costs = 0;
+        for (TourActivity act : route.getActivities()) {
+            costs += problem.getActivityCosts().getActivityCost(act, act.getArrTime(), route.getDriver(), route.getVehicle());
+        }
+        return costs;
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ComponentValue.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ComponentValue.java
new file mode 100644
index 000000000..d52d214f0
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ComponentValue.java
@@ -0,0 +1,43 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+public class ComponentValue {
+    private String key;
+    private double value = 0d;
+    private double weight = 1d;
+
+    public ComponentValue(String key) {
+        super();
+        this.key = key;
+    }
+
+    public ComponentValue(String key, double value) {
+        this(key);
+        this.value = value;
+    }
+
+    final ComponentValue withWeight(double weight) {
+        this.weight = weight;
+        return this;
+    }
+
+    public String getKey() {
+        return key;
+    }
+
+    public double getValue() {
+        return value;
+    }
+
+    public double getWeight() {
+        return weight;
+    }
+
+    public double getWeightedValue() {
+        return weight * value;
+    }
+
+    protected void addToValue(double valueToAdd) {
+        value += valueToAdd;
+    }
+
+}
\ No newline at end of file
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/FixCostPerVehicle.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/FixCostPerVehicle.java
new file mode 100644
index 000000000..9d11987d6
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/FixCostPerVehicle.java
@@ -0,0 +1,19 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+
+public class FixCostPerVehicle extends RouteLevelSolutionCostComponent {
+
+    public static final String COMPONENT_ID = "VehicleFix";
+
+    public FixCostPerVehicle() {
+        super(COMPONENT_ID);
+    }
+
+    @Override
+    protected double calculateRouteLevelCost(VehicleRoutingProblem problem, VehicleRoute route) {
+        return route.getVehicle().getType().getVehicleCostParams().fix;
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/MissedBreak.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/MissedBreak.java
new file mode 100644
index 000000000..30e5dd240
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/MissedBreak.java
@@ -0,0 +1,34 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.BreakActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+
+public class MissedBreak extends RouteLevelSolutionCostComponent {
+
+    public static final String COMPONENT_ID = "MissedBreak";
+
+    public MissedBreak() {
+        super(COMPONENT_ID);
+    }
+
+    @Override
+    protected double calculateRouteLevelCost(VehicleRoutingProblem problem, VehicleRoute route) {
+        for (TourActivity act : route.getActivities()) {
+            if (act instanceof BreakActivity) {
+                return 0d;
+            }
+        }
+        if (route.getVehicle().getBreak() != null) {
+            if (route.getEnd().getArrTime() > route.getVehicle().getBreak().getActivity().getSingleTimeWindow()
+                            .getEnd()) {
+                return 4 * (getMaxCosts() * 2 + route.getVehicle().getBreak().getActivity().getOperationTime()
+                                * route.getVehicle().getType().getVehicleCostParams().perServiceTimeUnit);
+
+            }
+        }
+        return 0d;
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java
new file mode 100644
index 000000000..f36d006aa
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/ModularSolutionCostCalculator.java
@@ -0,0 +1,66 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.solution.SolutionCostCalculator;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+
+public class ModularSolutionCostCalculator implements SolutionCostCalculator {
+
+    private VehicleRoutingProblem problem;
+    private Map<SolutionCostComponent, Double> components = new HashMap<>();
+    private double maxCosts;
+
+    public ModularSolutionCostCalculator(VehicleRoutingProblem problem, double maxCosts) {
+        super();
+        this.problem = problem;
+        this.maxCosts = maxCosts;
+    }
+
+    public ModularSolutionCostCalculator addComponent(SolutionCostComponent component) {
+        return addComponent(component, 1d);
+    }
+
+    public ModularSolutionCostCalculator addComponents(SolutionCostComponent component, SolutionCostComponent... components) {
+        addComponent(component);
+        for (SolutionCostComponent c : components) {
+            addComponent(c);
+        }
+        return this;
+    }
+
+    public ModularSolutionCostCalculator addComponent(SolutionCostComponent component, double weight) {
+        if (components.containsKey(component.getId())) {
+            throw new IllegalArgumentException("Cost component '" + component.getId() + "' is duplicated.");
+        }
+        components.put(component, weight);
+        return this;
+    }
+
+    public List<ComponentValue> calculate(VehicleRoutingProblemSolution solution) {
+        return components.entrySet().stream()
+                        .map(en -> en.getKey().calculateCost(problem, solution).withWeight(en.getValue()))
+                        .collect(Collectors.toList());}
+
+
+    @Override
+    public double getCosts(VehicleRoutingProblemSolution solution) {
+        return calculate(solution).stream()
+                        .mapToDouble(cv -> cv.getWeightedValue())
+                        .sum();
+    }
+
+    public void beforeRun() {
+        components.keySet().forEach(c -> c.beforeRun(problem, maxCosts));
+    }
+
+    // TODO: Is it needed and can be easily integrated?
+    public void beforeSolution() {
+        components.keySet().forEach(c -> c.beforeSolution(problem));
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelComponentValue.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelComponentValue.java
new file mode 100644
index 000000000..7c9ddcfbf
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelComponentValue.java
@@ -0,0 +1,28 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+
+public class RouteLevelComponentValue extends ComponentValue {
+
+    private Map<Integer, Double> routeLevelValue = new HashMap<>();
+
+    public RouteLevelComponentValue(String key) {
+        super(key);
+    }
+
+    public void setRouteValue(int routeId, double value) {
+        routeLevelValue.put(routeId, value);
+        addToValue(value);
+    }
+
+    public Optional<Double> getRouteValue(int routeId) {
+        if (routeLevelValue.containsKey(routeId)) {
+            return Optional.ofNullable(routeLevelValue.get(routeId));
+        } else {
+            return Optional.empty();
+        }
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelSolutionCostComponent.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelSolutionCostComponent.java
new file mode 100644
index 000000000..8c7de45a2
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/RouteLevelSolutionCostComponent.java
@@ -0,0 +1,24 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+
+public abstract class RouteLevelSolutionCostComponent extends SolutionCostComponent {
+
+    public RouteLevelSolutionCostComponent(String id) {
+        super(id);
+    }
+
+    @Override
+    public RouteLevelComponentValue calculateCost(VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution) {
+        RouteLevelComponentValue cv = new RouteLevelComponentValue(getId());
+        for (VehicleRoute route : solution.getRoutes()) {
+            double val = calculateRouteLevelCost(problem, route);
+            cv.setRouteValue(route.getId(), val);
+        }
+        return cv;
+    }
+
+    protected abstract double calculateRouteLevelCost(VehicleRoutingProblem problem, VehicleRoute route);
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/SolutionCostComponent.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/SolutionCostComponent.java
new file mode 100644
index 000000000..4e7c10650
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/SolutionCostComponent.java
@@ -0,0 +1,65 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+
+public abstract class SolutionCostComponent {
+
+    private String id;
+
+    private double maxCosts;
+
+    public SolutionCostComponent(String id) {
+        super();
+        this.id = id;
+    }
+
+    public void beforeRun(VehicleRoutingProblem problem, double maxCosts) {
+        this.maxCosts = maxCosts;
+    }
+
+    public void beforeSolution(VehicleRoutingProblem problem) {
+    }
+
+    public abstract ComponentValue calculateCost(VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution);
+
+
+    public String getId() {
+        return id;
+    }
+
+    public double getMaxCosts() {
+        return maxCosts;
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((id == null) ? 0 : id.hashCode());
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        SolutionCostComponent other = (SolutionCostComponent) obj;
+        if (id == null) {
+            if (other.getId() != null) {
+                return false;
+            }
+        } else if (!getId().equals(other.getId())) {
+            return false;
+        }
+        return true;
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/TransportCost.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/TransportCost.java
new file mode 100644
index 000000000..7a77343ad
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/TransportCost.java
@@ -0,0 +1,29 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+
+public class TransportCost extends RouteLevelSolutionCostComponent {
+
+    public static final String COMPONENT_ID = "Transport";
+
+    public TransportCost() {
+        super(COMPONENT_ID);
+    }
+
+    @Override
+    protected double calculateRouteLevelCost(VehicleRoutingProblem problem, VehicleRoute route) {
+        double costs = 0;
+        TourActivity prevAct = route.getStart();
+        for (TourActivity act : route.getActivities()) {
+            costs += problem.getTransportCosts().getTransportCost(prevAct.getLocation(), act.getLocation(), prevAct.getEndTime(),
+                            route.getDriver(), route.getVehicle());
+            prevAct = act;
+        }
+        costs += problem.getTransportCosts().getTransportCost(prevAct.getLocation(), route.getEnd().getLocation(),
+                        prevAct.getEndTime(), route.getDriver(), route.getVehicle());
+        return costs;
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/UnassignedJobs.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/UnassignedJobs.java
new file mode 100644
index 000000000..b28aa02de
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/objectivefunction/UnassignedJobs.java
@@ -0,0 +1,26 @@
+package com.graphhopper.jsprit.core.algorithm.objectivefunction;
+
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.job.Job;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+
+public class UnassignedJobs extends SolutionCostComponent {
+
+    public static final String COMPONENT_ID = "Unassigned";
+
+    public UnassignedJobs() {
+        super(COMPONENT_ID);
+    }
+
+
+    @Override
+    public ComponentValue calculateCost(VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution) {
+        double costs = 0d;
+        for (Job j : solution.getUnassignedJobs()) {
+            costs += getMaxCosts() * 2 * (4 - j.getPriority());
+        }
+        return new ComponentValue(COMPONENT_ID, costs);
+    }
+
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolution.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolution.java
index ba374d1d6..62cc365de 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolution.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/VehicleRoutingProblemSolution.java
@@ -17,11 +17,13 @@
  */
 package com.graphhopper.jsprit.core.problem.solution;
 
-import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+import com.graphhopper.jsprit.core.problem.job.Job;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 
 
 /**
@@ -41,19 +43,20 @@ public static VehicleRoutingProblemSolution copyOf(VehicleRoutingProblemSolution
         return new VehicleRoutingProblemSolution(solution2copy);
     }
 
-    private final Collection<VehicleRoute> routes;
+    private List<VehicleRoute> routes;
 
-    private Collection<Job> unassignedJobs = new ArrayList<Job>();
+    private Collection<Job> unassignedJobs = new ArrayList<>();
 
     private double cost;
 
     private VehicleRoutingProblemSolution(VehicleRoutingProblemSolution solution) {
-        routes = new ArrayList<VehicleRoute>();
+        List<VehicleRoute> tmpRoutes = new ArrayList<>();
         for (VehicleRoute r : solution.getRoutes()) {
             VehicleRoute route = VehicleRoute.copyOf(r);
-            routes.add(route);
+            tmpRoutes.add(route);
         }
-        this.cost = solution.getCost();
+        setRoutes(tmpRoutes);
+        cost = solution.getCost();
         unassignedJobs.addAll(solution.getUnassignedJobs());
     }
 
@@ -65,7 +68,7 @@ private VehicleRoutingProblemSolution(VehicleRoutingProblemSolution solution) {
      */
     public VehicleRoutingProblemSolution(Collection<VehicleRoute> routes, double cost) {
         super();
-        this.routes = routes;
+        setRoutes(routes);
         this.cost = cost;
     }
 
@@ -78,17 +81,28 @@ public VehicleRoutingProblemSolution(Collection<VehicleRoute> routes, double cos
      */
     public VehicleRoutingProblemSolution(Collection<VehicleRoute> routes, Collection<Job> unassignedJobs, double cost) {
         super();
-        this.routes = routes;
+        setRoutes(routes);
         this.unassignedJobs = unassignedJobs;
         this.cost = cost;
     }
 
+
+    private void setRoutes(Collection<VehicleRoute> routes) {
+        this.routes = routes instanceof List ? (List<VehicleRoute>) routes : new ArrayList<>(routes);
+        Collections.sort(this.routes, new com.graphhopper.jsprit.core.util.VehicleIndexComparator());
+
+        int counter = 1;
+        for (VehicleRoute r : routes) {
+            r.setId(counter++);
+        }
+    }
+
     /**
      * Returns a collection of vehicle-routes.
      *
      * @return collection of vehicle-routes
      */
-    public Collection<VehicleRoute> getRoutes() {
+    public List<VehicleRoute> getRoutes() {
         return routes;
     }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRoute.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRoute.java
index 0b221af94..70151c967 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRoute.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRoute.java
@@ -43,7 +43,8 @@
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
 
 /**
- * Contains the tour, i.e. a number of activities, a vehicle servicing the tour and a driver.
+ * Contains the tour, i.e. a number of activities, a vehicle servicing the tour
+ * and a driver.
  *
  * @author stefan
  */
@@ -52,9 +53,11 @@
     /**
      * Returns a deep copy of this vehicleRoute.
      *
-     * @param route route to copy
+     * @param route
+     *            route to copy
      * @return copied route
-     * @throws IllegalArgumentException if route is null
+     * @throws IllegalArgumentException
+     *             if route is null
      */
     public static VehicleRoute copyOf(VehicleRoute route) {
         if (route == null) {
@@ -66,7 +69,9 @@ public static VehicleRoute copyOf(VehicleRoute route) {
     /**
      * Returns an empty route.
      * <p>
-     * <p>An empty route has an empty list of tour-activities, no driver (DriverImpl.noDriver()) and no vehicle (VehicleImpl.createNoVehicle()).
+     * <p>
+     * An empty route has an empty list of tour-activities, no driver
+     * (DriverImpl.noDriver()) and no vehicle (VehicleImpl.createNoVehicle()).
      *
      * @return empty route
      */
@@ -81,25 +86,34 @@ public static VehicleRoute emptyRoute() {
      */
     public static class Builder {
 
-        private Map<Shipment, TourActivity> openActivities = new HashMap<Shipment, TourActivity>();
+        private Map<Shipment, TourActivity> openActivities = new HashMap<>();
 
         /**
          * Returns new instance of this builder.
          * <p>
-         * <p><b>Construction-settings of vehicleRoute:</b>
-         * <p>startLocation == vehicle.getStartLocationId()
-         * <p>endLocation == vehicle.getEndLocationId()
-         * <p>departureTime == vehicle.getEarliestDepartureTime()
-         * <p>latestStart == Double.MAX_VALUE
-         * <p>earliestEnd == 0.0
+         * <p>
+         * <b>Construction-settings of vehicleRoute:</b>
+         * <p>
+         * startLocation == vehicle.getStartLocationId()
+         * <p>
+         * endLocation == vehicle.getEndLocationId()
+         * <p>
+         * departureTime == vehicle.getEarliestDepartureTime()
+         * <p>
+         * latestStart == Double.MAX_VALUE
+         * <p>
+         * earliestEnd == 0.0
          *
-         * @param vehicle employed vehicle
-         * @param driver  employed driver
+         * @param vehicle
+         *            employed vehicle
+         * @param driver
+         *            employed driver
          * @return this builder
          */
         public static Builder newInstance(Vehicle vehicle, Driver driver) {
             if (vehicle == null || driver == null) {
-                throw new IllegalArgumentException("null arguments not accepted. ini emptyRoute with VehicleImpl.createNoVehicle() and DriverImpl.noDriver()");
+                throw new IllegalArgumentException(
+                                "null arguments not accepted. ini emptyRoute with VehicleImpl.createNoVehicle() and DriverImpl.noDriver()");
             }
             return new Builder(vehicle, driver);
         }
@@ -107,19 +121,27 @@ public static Builder newInstance(Vehicle vehicle, Driver driver) {
         /**
          * Returns new instance of this builder.
          * <p>
-         * <p><b>Construction-settings of vehicleRoute:</b>
-         * <p>startLocation == vehicle.getStartLocationId()
-         * <p>endLocation == vehicle.getEndLocationId()
-         * <p>departureTime == vehicle.getEarliestDepartureTime()
-         * <p>latestStart == Double.MAX_VALUE
-         * <p>earliestEnd == 0.0
+         * <p>
+         * <b>Construction-settings of vehicleRoute:</b>
+         * <p>
+         * startLocation == vehicle.getStartLocationId()
+         * <p>
+         * endLocation == vehicle.getEndLocationId()
+         * <p>
+         * departureTime == vehicle.getEarliestDepartureTime()
+         * <p>
+         * latestStart == Double.MAX_VALUE
+         * <p>
+         * earliestEnd == 0.0
          *
-         * @param vehicle employed vehicle
+         * @param vehicle
+         *            employed vehicle
          * @return this builder
          */
         public static Builder newInstance(Vehicle vehicle) {
             if (vehicle == null) {
-                throw new IllegalArgumentException("null arguments not accepted. ini emptyRoute with VehicleImpl.createNoVehicle() and DriverImpl.noDriver()");
+                throw new IllegalArgumentException(
+                                "null arguments not accepted. ini emptyRoute with VehicleImpl.createNoVehicle() and DriverImpl.noDriver()");
             }
             return new Builder(vehicle, DriverImpl.noDriver());
         }
@@ -140,7 +162,7 @@ public static Builder newInstance(Vehicle vehicle) {
         // private TourShipmentActivityFactory shipmentActivityFactory = new
         // DefaultShipmentActivityFactory();
 
-        private Set<Shipment> openShipments = new HashSet<Shipment>();
+        private Set<Shipment> openShipments = new HashSet<>();
 
         private JobActivityFactory jobActivityFactory = new SimpleJobActivityFactory();
 
@@ -159,13 +181,18 @@ private Builder(Vehicle vehicle, Driver driver) {
         }
 
         /**
-         * Sets the departure-time of the route, i.e. which is the time the vehicle departs from start-location.
+         * Sets the departure-time of the route, i.e. which is the time the
+         * vehicle departs from start-location.
+         * <p>
          * <p>
-         * <p><b>Note</b> that departureTime cannot be lower than earliestDepartureTime of vehicle.
+         * <b>Note</b> that departureTime cannot be lower than
+         * earliestDepartureTime of vehicle.
          *
-         * @param departureTime departure time of vehicle being employed for this route
+         * @param departureTime
+         *            departure time of vehicle being employed for this route
          * @return builder
-         * @throws IllegalArgumentException if departureTime < vehicle.getEarliestDeparture()
+         * @throws IllegalArgumentException
+         *             if departureTime < vehicle.getEarliestDeparture()
          */
         public Builder setDepartureTime(double departureTime) {
             if (departureTime < start.getEndTime()) {
@@ -220,7 +247,6 @@ private Builder addSingleActivityJob(AbstractSingleActivityJob<?> service) {
             return addSingleActivityJob(service, service.getActivity().getSingleTimeWindow());
         }
 
-
         private Builder addSingleActivityJob(AbstractSingleActivityJob<?> service,
                         TimeWindow timeWindow) {
             if (service == null) {
@@ -234,7 +260,6 @@ private Builder addSingleActivityJob(AbstractSingleActivityJob<?> service,
             return this;
         }
 
-
         public Builder addBreak(Break currentbreak) {
             if (currentbreak == null) {
                 throw new IllegalArgumentException("break must not be null");
@@ -364,17 +389,19 @@ public Builder addDelivery(Shipment shipment, TimeWindow deliveryTimeWindow) {
                 tourActivities.addActivity(act);
                 openShipments.remove(shipment);
             } else {
-                throw new IllegalArgumentException("cannot deliver shipment. shipment " + shipment + " needs to be picked up first.");
+                throw new IllegalArgumentException(
+                                "cannot deliver shipment. shipment " + shipment + " needs to be picked up first.");
             }
             return this;
         }
 
-
         /**
          * Builds the route.
          *
          * @return {@link VehicleRoute}
-         * @throws IllegalArgumentException if there are still shipments that have been picked up though but not delivery.
+         * @throws IllegalArgumentException
+         *             if there are still shipments that have been picked up
+         *             though but not delivery.
          */
         public VehicleRoute build() {
             if (!openShipments.isEmpty()) {
@@ -400,10 +427,13 @@ public VehicleRoute build() {
 
     private End end;
 
+    private int id = 0;
+
     /**
      * Copy constructor copying a route.
      *
-     * @param route to copy
+     * @param route
+     *            to copy
      */
     private VehicleRoute(VehicleRoute route) {
         start = Start.copyOf(route.getStart());
@@ -416,7 +446,8 @@ private VehicleRoute(VehicleRoute route) {
     /**
      * Constructs route.
      *
-     * @param builder used to build route
+     * @param builder
+     *            used to build route
      */
     private VehicleRoute(Builder builder) {
         tourActivities = builder.tourActivities;
@@ -427,7 +458,8 @@ private VehicleRoute(Builder builder) {
     }
 
     /**
-     * Returns an unmodifiable list of activities on this route (without start/end).
+     * Returns an unmodifiable list of activities on this route (without
+     * start/end).
      *
      * @return list of tourActivities
      */
@@ -463,19 +495,37 @@ public Driver getDriver() {
     }
 
     /**
-     * Sets the vehicle and its departureTime from <code>vehicle.getStartLocationId()</code>.
+     * Sets the vehicle and its departureTime from
+     * <code>vehicle.getStartLocationId()</code>.
+     * <p>
      * <p>
-     * <p>This implies the following:<br>
+     * This implies the following:<br>
      * if start and end are null, new start and end activities are created.<br>
-     * <p>startActivity is initialized with the start-location of the specified vehicle (<code>vehicle.getStartLocationId()</code>). the time-window of this activity is initialized
-     * such that [<code>startActivity.getTheoreticalEarliestOperationStartTime()</code> = <code>vehicle.getEarliestDeparture()</code>][<code>startActivity.getTheoreticalLatestOperationStartTime()</code> = <code>vehicle.getLatestArrival()</code>]
-     * <p>endActivity is initialized with the end-location of the specified vehicle (<code>vehicle.getEndLocationId()</code>). The time-window of the
-     * endActivity is initialized such that [<code>endActivity.getTheoreticalEarliestOperationStartTime()</code> = <code>vehicle.getEarliestDeparture()</code>][<code>endActivity.getTheoreticalLatestOperationStartTime()</code> = <code>vehicle.getLatestArrival()</code>]
-     * <p>startActivity.endTime (<code>startActivity.getEndTime()</code>) is set to max{<code>vehicle.getEarliestDeparture()</code>, <code>vehicleDepTime</code>}.
-     * thus, <code>vehicle.getEarliestDeparture()</code> is a physical constraint that has to be met.
+     * <p>
+     * startActivity is initialized with the start-location of the specified
+     * vehicle (<code>vehicle.getStartLocationId()</code>). the time-window of
+     * this activity is initialized such that
+     * [<code>startActivity.getTheoreticalEarliestOperationStartTime()</code> =
+     * <code>vehicle.getEarliestDeparture()</code>][<code>startActivity.getTheoreticalLatestOperationStartTime()</code>
+     * = <code>vehicle.getLatestArrival()</code>]
+     * <p>
+     * endActivity is initialized with the end-location of the specified vehicle
+     * (<code>vehicle.getEndLocationId()</code>). The time-window of the
+     * endActivity is initialized such that
+     * [<code>endActivity.getTheoreticalEarliestOperationStartTime()</code> =
+     * <code>vehicle.getEarliestDeparture()</code>][<code>endActivity.getTheoreticalLatestOperationStartTime()</code>
+     * = <code>vehicle.getLatestArrival()</code>]
+     * <p>
+     * startActivity.endTime (<code>startActivity.getEndTime()</code>) is set to
+     * max{<code>vehicle.getEarliestDeparture()</code>,
+     * <code>vehicleDepTime</code>}. thus,
+     * <code>vehicle.getEarliestDeparture()</code> is a physical constraint that
+     * has to be met.
      *
-     * @param vehicle        to be employed
-     * @param vehicleDepTime of employed vehicle
+     * @param vehicle
+     *            to be employed
+     * @param vehicleDepTime
+     *            of employed vehicle
      */
     public void setVehicleAndDepartureTime(Vehicle vehicle, double vehicleDepTime) {
         this.vehicle = vehicle;
@@ -503,17 +553,20 @@ private void setStartAndEnd(Vehicle vehicle, double vehicleDepTime) {
      * Returns the departureTime of this vehicle in this route.
      *
      * @return departureTime
-     * @throws IllegalArgumentException if start is null
+     * @throws IllegalArgumentException
+     *             if start is null
      */
     public double getDepartureTime() {
         if (start == null) {
-            throw new IllegalArgumentException("cannot get departureTime without having a vehicle on this route. use setVehicle(vehicle,departureTime) instead.");
+            throw new IllegalArgumentException(
+                            "cannot get departureTime without having a vehicle on this route. use setVehicle(vehicle,departureTime) instead.");
         }
         return start.getEndTime();
     }
 
     /**
-     * Returns tour if tour-activity-sequence is empty, i.e. to activity on the tour yet.
+     * Returns tour if tour-activity-sequence is empty, i.e. to activity on the
+     * tour yet.
      *
      * @return true if route is empty
      */
@@ -541,7 +594,17 @@ public End getEnd() {
 
     @Override
     public String toString() {
-        return "[start=" + start + "][end=" + end + "][departureTime=" + start.getEndTime() + "][vehicle=" + vehicle + "][driver=" + driver + "][nuOfActs=" + tourActivities.getActivities().size() + "]";
+        return "[id=" + id + "][start=" + start + "][end=" + end + "][departureTime=" + start.getEndTime() + "][vehicle=" + vehicle
+                        + "][driver="
+                        + driver + "][nuOfActs=" + tourActivities.getActivities().size() + "]";
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public int getId() {
+        return id;
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
index 8acb5f486..97108a785 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
@@ -19,7 +19,6 @@
 
 import java.io.PrintWriter;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -217,7 +216,7 @@ public static void printSummary(PrintWriter out, VehicleRoutingProblem problem,
         DynamicTablePrinter problemTablePrinter = new DynamicTablePrinter(problemTableDef);
         problemTablePrinter.addRow().add("fleetsize").add(problem.getFleetSize());
         problemTablePrinter.addRow().add("maxNoVehicles")
-                        .add(problem.getFleetSize() == FleetSize.FINITE ? problem.getVehicles().size() : "unlimited");
+        .add(problem.getFleetSize() == FleetSize.FINITE ? problem.getVehicles().size() : "unlimited");
         problemTablePrinter.addSeparator();
         problemTablePrinter.addRow().add("noJobs").add(problem.getJobs().values().size());
         for (Entry<Class<? extends Job>, Long> jc : getNuOfJobs(problem).entrySet()) {
@@ -273,16 +272,14 @@ public static void printRouteDetails(PrintWriter out, VehicleRoutingProblem prob
     protected static ConfigurableTablePrinter<RoutePrinterContext> buildRouteDetailsTable(VehicleRoutingProblem problem,
                     VehicleRoutingProblemSolution solution, PrinterColumnList<RoutePrinterContext> columns) {
         ConfigurableTablePrinter<RoutePrinterContext> tablePrinter = new ConfigurableTablePrinter<>(columns);
-        int routeNu = 1;
 
         List<VehicleRoute> list = new ArrayList<>(solution.getRoutes());
-        Collections.sort(list, new com.graphhopper.jsprit.core.util.VehicleIndexComparator());
         for (VehicleRoute route : list) {
-            if (routeNu != 1) {
+            if (route.getId() != 1) {
                 tablePrinter.addSeparator();
             }
 
-            RoutePrinterContext context = new RoutePrinterContext(routeNu, route, route.getStart(), problem);
+            RoutePrinterContext context = new RoutePrinterContext(route, route.getStart(), problem);
             tablePrinter.addRow(context);
 
             for (TourActivity act : route.getActivities()) {
@@ -292,8 +289,6 @@ public static void printRouteDetails(PrintWriter out, VehicleRoutingProblem prob
 
             context.setActivity(route.getEnd());
             tablePrinter.addRow(context);
-
-            routeNu++;
         }
         return tablePrinter;
     }
@@ -329,11 +324,9 @@ public static String exportVehicleSummary(VehicleRoutingProblem problem, Vehicle
                     VehicleRoutingProblemSolution solution, PrinterColumnList<VehicleSummaryContext> columns) {
         ConfigurableTablePrinter<VehicleSummaryContext> vehicleTablePrinter = new ConfigurableTablePrinter<>(columns);
 
-        List<VehicleRoute> list = new ArrayList<>(solution.getRoutes());
-        Collections.sort(list, new com.graphhopper.jsprit.core.util.VehicleIndexComparator());
-        int rn = 1;
+        List<VehicleRoute> list = solution.getRoutes();
         for (VehicleRoute route : list) {
-            vehicleTablePrinter.addRow(new VehicleSummaryContext(rn++, route, problem));
+            vehicleTablePrinter.addRow(new VehicleSummaryContext(route, problem));
         }
         return vehicleTablePrinter;
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/RouteNumberPrinterColumn.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/RouteNumberPrinterColumn.java
index d9a4dc4f1..d15cbeede 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/RouteNumberPrinterColumn.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/RouteNumberPrinterColumn.java
@@ -43,7 +43,7 @@ protected String getDefaultTitle() {
 
     @Override
     public Integer getData(RoutePrinterContext context) {
-        return context.getRouteNr();
+        return context.getRoute().getId();
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/RoutePrinterContext.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/RoutePrinterContext.java
index 28c74ba4a..d868070bd 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/RoutePrinterContext.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/RoutePrinterContext.java
@@ -20,8 +20,6 @@
  */
 public class RoutePrinterContext implements JobPrinterContext {
 
-    // The route id
-    private int routeNr;
     // The route itself
     private VehicleRoute route;
     // The current activity
@@ -41,21 +39,13 @@
      * @param problem
      *            problem
      */
-    public RoutePrinterContext(int routeNr, VehicleRoute route, TourActivity activity, VehicleRoutingProblem problem) {
+    public RoutePrinterContext(VehicleRoute route, TourActivity activity, VehicleRoutingProblem problem) {
         super();
-        this.routeNr = routeNr;
         this.route = route;
         this.activity = activity;
         this.problem = problem;
     }
 
-    /**
-     * @return The route id.
-     */
-    public int getRouteNr() {
-        return routeNr;
-    }
-
     /**
      * @return The route itself.
      */
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/vehicle/VehicleSummaryContext.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/vehicle/VehicleSummaryContext.java
index 4b3505172..c658c1d97 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/vehicle/VehicleSummaryContext.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/vehicle/VehicleSummaryContext.java
@@ -25,8 +25,8 @@
     private long breakDuration;
     private long travelDistance;
 
-    public VehicleSummaryContext(int routeNr, VehicleRoute route, VehicleRoutingProblem problem) {
-        this.routeNr = routeNr;
+    public VehicleSummaryContext(VehicleRoute route, VehicleRoutingProblem problem) {
+        routeNr = route.getId();
         vehicle = route.getVehicle();
         driver = route.getDriver();
         start = (long) route.getStart().getEndTime();
