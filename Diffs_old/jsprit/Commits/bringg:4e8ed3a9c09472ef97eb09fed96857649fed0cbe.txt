diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/StateManager.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/StateManager.java
index 3dfaeb3f4..05eaa321c 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/StateManager.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/StateManager.java
@@ -252,7 +252,7 @@ private void fill_twoDimArr(Object[][] states, Object o) {
      */
     public boolean hasActivityState(TourActivity act, Vehicle vehicle, StateId stateId) {
         if (act.getIndex() == 0) throw new IllegalStateException("activity index is 0. this should not be.");
-        return vehicleDependentActivityStates[act.getIndex()][vehicle.getIndex()][stateId.getIndex()] != null;
+        return vehicleDependentActivityStates[act.getIndex()][vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()] != null;
     }
 
     /**
@@ -275,9 +275,9 @@ public boolean hasActivityState(TourActivity act, Vehicle vehicle, StateId state
         if (act.getIndex() < 0) return null; //act.getIndex() < 0 indicates that act is either Start (-1) or End (-2)
         T state;
         try {
-            state = type.cast(vehicleDependentActivityStates[act.getIndex()][vehicle.getIndex()][stateId.getIndex()]);
+            state = type.cast(vehicleDependentActivityStates[act.getIndex()][vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()]);
         } catch (ClassCastException e) {
-            Object state_class = vehicleDependentActivityStates[act.getIndex()][vehicle.getIndex()][stateId.getIndex()];
+            Object state_class = vehicleDependentActivityStates[act.getIndex()][vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()];
             throw getClassCastException(e, stateId, type.toString(), state_class.getClass().toString());
         }
         return state;
@@ -333,8 +333,8 @@ private ClassCastException getClassCastException(ClassCastException e, StateId s
     @SuppressWarnings("UnusedDeclaration")
     public boolean hasRouteState(VehicleRoute route, Vehicle vehicle, StateId stateId) {
         if (!vehicleDependentRouteStateMap.containsKey(route)) return false;
-        return vehicleDependentRouteStateMap.get(route)[vehicle.getIndex()][stateId.getIndex()] != null;
-//        return vehicle_dependent_route_states[route.getActivities().get(0).getIndex()][vehicle.getIndex()][stateId.getIndex()] != null;
+        return vehicleDependentRouteStateMap.get(route)[vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()] != null;
+//        return vehicle_dependent_route_states[route.getActivities().get(0).getIndex()][vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()] != null;
     }
 
     /**
@@ -355,18 +355,18 @@ public boolean hasRouteState(VehicleRoute route, Vehicle vehicle, StateId stateI
         T state = null;
         if(isIndexedBased){
             try {
-                state = type.cast(vehicleDependentRouteStatesArr[route.getVehicle().getIndex()][vehicle.getIndex()][stateId.getIndex()]);
+                state = type.cast(vehicleDependentRouteStatesArr[route.getVehicle().getIndex()][vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()]);
             } catch (ClassCastException e) {
-                throw getClassCastException(e, stateId, type.toString(), vehicleDependentRouteStatesArr[route.getVehicle().getIndex()][vehicle.getIndex()][stateId.getIndex()].getClass().toString());
+                throw getClassCastException(e, stateId, type.toString(), vehicleDependentRouteStatesArr[route.getVehicle().getIndex()][vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()].getClass().toString());
             }
         }
         else {
             try {
                 if (vehicleDependentRouteStateMap.containsKey(route)) {
-                    state = type.cast(vehicleDependentRouteStateMap.get(route)[vehicle.getIndex()][stateId.getIndex()]);
+                    state = type.cast(vehicleDependentRouteStateMap.get(route)[vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()]);
                 }
             } catch (ClassCastException e) {
-                throw getClassCastException(e, stateId, type.toString(), vehicleDependentRouteStateMap.get(route)[vehicle.getIndex()][stateId.getIndex()].getClass().toString());
+                throw getClassCastException(e, stateId, type.toString(), vehicleDependentRouteStateMap.get(route)[vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()].getClass().toString());
             }
         }
         return state;
@@ -422,7 +422,7 @@ public boolean hasRouteState(VehicleRoute route, Vehicle vehicle, StateId stateI
     }
 
     <T> void putInternalTypedActivityState(TourActivity act, Vehicle vehicle, StateId stateId, T state) {
-        vehicleDependentActivityStates[act.getIndex()][vehicle.getIndex()][stateId.getIndex()] = state;
+        vehicleDependentActivityStates[act.getIndex()][vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()] = state;
     }
 
     /**
@@ -449,10 +449,10 @@ public boolean hasRouteState(VehicleRoute route, Vehicle vehicle, StateId stateI
      * @param stateId the stateId which is the associated key to the activity state
      * @param state   the state that is associated to the activity and stateId
      * @param <T>     the type of the state
-     * @throws java.lang.IllegalStateException if <code>vehicle.getIndex() == 0</code> || <code>stateId.getIndex() < noInternalStates</code>
+     * @throws java.lang.IllegalStateException if <code>vehicle.getVehicleTypeIdentifier().getIndex() == 0</code> || <code>stateId.getIndex() < noInternalStates</code>
      */
     public <T> void putRouteState(VehicleRoute route, Vehicle vehicle, StateId stateId, T state) {
-        if (vehicle.getIndex() == 0) throw new IllegalStateException("vehicle index is 0. this should not be.");
+        if (vehicle.getVehicleTypeIdentifier().getIndex() == 0) throw new IllegalStateException("vehicle index is 0. this should not be.");
         if (stateId.getIndex() < initialNoStates) StateFactory.throwReservedIdException(stateId.toString());
         putTypedInternalRouteState(route, vehicle, stateId, state);
     }
@@ -473,13 +473,13 @@ public boolean hasRouteState(VehicleRoute route, Vehicle vehicle, StateId stateI
     <T> void putTypedInternalRouteState(VehicleRoute route, Vehicle vehicle, StateId stateId, T state) {
         if (route.isEmpty()) return;
         if(isIndexedBased){
-            vehicleDependentRouteStatesArr[route.getVehicle().getIndex()][vehicle.getIndex()][stateId.getIndex()] = state;
+            vehicleDependentRouteStatesArr[route.getVehicle().getIndex()][vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()] = state;
         }
         else {
             if (!vehicleDependentRouteStateMap.containsKey(route)) {
                 vehicleDependentRouteStateMap.put(route, new Object[nuVehicleTypeKeys][stateIndexCounter]);
             }
-            vehicleDependentRouteStateMap.get(route)[vehicle.getIndex()][stateId.getIndex()] = state;
+            vehicleDependentRouteStateMap.get(route)[vehicle.getVehicleTypeIdentifier().getIndex()][stateId.getIndex()] = state;
         }
 
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicle.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicle.java
index a5659c14e..9ae37d368 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicle.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/UpdateMaxTimeInVehicle.java
@@ -93,7 +93,7 @@ public void begin(VehicleRoute route) {
         vehicles = vehiclesToUpdate.get(route);
         this.route = route;
         for(Vehicle v : vehicles){
-            int vehicleIndex = v.getIndex();
+            int vehicleIndex = v.getVehicleTypeIdentifier().getIndex();
             openPickupEndTimesPerVehicle.put(vehicleIndex, new HashMap<Job, Double>());
             slackTimesPerVehicle.put(vehicleIndex, new HashMap<TourActivity, Double>());
             actStartTimesPerVehicle.put(vehicleIndex, new HashMap<TourActivity, Double>());
@@ -108,10 +108,10 @@ public void visit(TourActivity activity) {
         double maxTime = getMaxTimeInVehicle(activity);
 
         for(Vehicle v : vehicles) {
-            int vehicleIndex = v.getIndex();
+            int vehicleIndex = v.getVehicleTypeIdentifier().getIndex();
             Location prevActLocation = prevActLocations[vehicleIndex];
-            double prevActEndTime = prevActEndTimes[v.getIndex()];
-            double activityArrival = prevActEndTimes[v.getIndex()] + transportTime.getTransportTime(prevActLocation,activity.getLocation(),prevActEndTime,route.getDriver(),v);
+            double prevActEndTime = prevActEndTimes[v.getVehicleTypeIdentifier().getIndex()];
+            double activityArrival = prevActEndTimes[v.getVehicleTypeIdentifier().getIndex()] + transportTime.getTransportTime(prevActLocation,activity.getLocation(),prevActEndTime,route.getDriver(),v);
             double activityStart = Math.max(activityArrival,activity.getTheoreticalEarliestOperationStartTime());
             memorizeActStart(activity,v,activityStart);
             double activityEnd = activityStart + activityCosts.getActivityDuration(prevTourActivity, activity, activityArrival, route.getDriver(), v);
@@ -145,13 +145,13 @@ private double getMaxTimeInVehicle(TourActivity activity) {
     }
 
     private void memorizeActStart(TourActivity activity, Vehicle v, double activityStart) {
-        actStartTimesPerVehicle.get(v.getIndex()).put(activity, activityStart);
+        actStartTimesPerVehicle.get(v.getVehicleTypeIdentifier().getIndex()).put(activity, activityStart);
     }
 
     @Override
     public void finish() {
         for(Vehicle v : vehicles) {
-            int vehicleIndex = v.getIndex();
+            int vehicleIndex = v.getVehicleTypeIdentifier().getIndex();
 
             //!!! open routes !!!
             double routeEnd;
@@ -194,7 +194,7 @@ public void finish() {
 
     public void finish(List<TourActivity> activities, Job ignore) {
         for (Vehicle v : vehicles) {
-            int vehicleIndex = v.getIndex();
+            int vehicleIndex = v.getVehicleTypeIdentifier().getIndex();
 
             //!!! open routes !!!
             double routeEnd;
@@ -236,7 +236,7 @@ public void finish(List<TourActivity> activities, Job ignore) {
     }
 
     private double actStart(TourActivity act, Vehicle v) {
-        return actStartTimesPerVehicle.get(v.getIndex()).get(act);
+        return actStartTimesPerVehicle.get(v.getVehicleTypeIdentifier().getIndex()).get(act);
     }
 
     private double minSlackTime(Map<Job, Double> openDeliveries) {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraint.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraint.java
index e1f689e35..131656363 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraint.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxTimeInVehicleConstraint.java
@@ -103,7 +103,11 @@ else if(newActIsPickup){
 
         double minSlack = Double.MAX_VALUE;
         if (!(nextAct instanceof End)) {
-            minSlack = stateManager.getActivityState(nextAct, iFacts.getNewVehicle(), minSlackId, Double.class);
+            try {
+                minSlack = stateManager.getActivityState(nextAct, iFacts.getNewVehicle(), minSlackId, Double.class);
+            } catch (NullPointerException npe) {
+
+            }
         }
         double directArrTimeNextAct = prevActDepTime + transportTime.getTransportTime(prevAct.getLocation(), nextAct.getLocation(), prevActDepTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
         double directNextActStart = Math.max(directArrTimeNextAct, nextAct.getTheoreticalEarliestOperationStartTime());
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MaxTimeInVehicleTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MaxTimeInVehicleTest.java
new file mode 100644
index 000000000..89955ce4e
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/MaxTimeInVehicleTest.java
@@ -0,0 +1,340 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.graphhopper.jsprit.core.algorithm;
+import com.graphhopper.jsprit.core.algorithm.box.Jsprit;
+import com.graphhopper.jsprit.core.algorithm.state.StateId;
+import com.graphhopper.jsprit.core.algorithm.state.StateManager;
+import com.graphhopper.jsprit.core.algorithm.state.UpdateMaxTimeInVehicle;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
+import com.graphhopper.jsprit.core.problem.constraint.MaxTimeInVehicleConstraint;
+import com.graphhopper.jsprit.core.problem.job.Delivery;
+import com.graphhopper.jsprit.core.problem.job.Shipment;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
+import com.graphhopper.jsprit.core.reporting.SolutionPrinter;
+import com.graphhopper.jsprit.core.util.Solutions;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class MaxTimeInVehicleTest {
+
+    @Test
+    public void testShipment(){
+        Shipment s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(34.773586,32.079754)).setDeliveryLocation(Location.newInstance(34.781247,38.294571))
+                .setDeliveryServiceTime(10)
+                .setMaxTimeInVehicle(20)
+                .build();
+
+        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(Location.newInstance(34.771200,32.067646)).setEndLocation(Location.newInstance(34.768404,32.081525)).build();
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addVehicle(v1).addJob(s1).build();
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId id = stateManager.createStateId("max-time");
+        StateId openJobsId = stateManager.createStateId("open-jobs-id");
+        stateManager.addStateUpdater(new UpdateMaxTimeInVehicle(stateManager, id, vrp.getTransportCosts(), vrp.getActivityCosts(), openJobsId));
+
+        ConstraintManager constraintManager = new ConstraintManager(vrp,stateManager);
+        constraintManager.addConstraint(new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), id, stateManager, vrp, openJobsId), ConstraintManager.Priority.CRITICAL);
+
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
+        VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
+        SolutionPrinter.print(vrp,solution, SolutionPrinter.Print.VERBOSE);
+        assertEquals(0,solution.getUnassignedJobs().size());
+        assertEquals(1,solution.getRoutes().size());
+
+
+
+    }
+
+    @Test
+    public void testShipmentUnassigned(){
+        Shipment s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(34.773586,32.079754)).setDeliveryLocation(Location.newInstance(34.781247,38.294571))
+                .setDeliveryServiceTime(10)
+                .setMaxTimeInVehicle(4)
+                .build();
+
+        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(Location.newInstance(34.771200,32.067646)).setEndLocation(Location.newInstance(34.768404,32.081525)).build();
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addVehicle(v1).addJob(s1).build();
+
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId id = stateManager.createStateId("max-time");
+        StateId openJobsId = stateManager.createStateId("open-jobs-id");
+        stateManager.addStateUpdater(new UpdateMaxTimeInVehicle(stateManager, id, vrp.getTransportCosts(), vrp.getActivityCosts(), openJobsId));
+
+        ConstraintManager constraintManager = new ConstraintManager(vrp,stateManager);
+        constraintManager.addConstraint(new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), id, stateManager, vrp, openJobsId), ConstraintManager.Priority.CRITICAL);
+
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
+        VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
+        SolutionPrinter.print(vrp,solution, SolutionPrinter.Print.VERBOSE);
+
+        assertEquals(1,solution.getUnassignedJobs().size());
+        assertEquals(0,solution.getRoutes().size());
+
+    }
+
+    @Test
+    public void testDelivery(){
+
+        Delivery d2 = Delivery.Builder.newInstance("d2")
+                .setMaxTimeInVehicle(10)
+                .setLocation(Location.newInstance(10, 5)).setServiceTime(2).build();
+
+        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(Location.newInstance(2,3)).setEndLocation(Location.newInstance(0,0)).build();
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addVehicle(v1).addJob(d2).build();
+
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId id = stateManager.createStateId("max-time");
+        StateId openJobsId = stateManager.createStateId("open-jobs-id");
+        stateManager.addStateUpdater(new UpdateMaxTimeInVehicle(stateManager, id, vrp.getTransportCosts(), vrp.getActivityCosts(), openJobsId));
+
+        ConstraintManager constraintManager = new ConstraintManager(vrp,stateManager);
+        constraintManager.addConstraint(new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), id, stateManager, vrp, openJobsId), ConstraintManager.Priority.CRITICAL);
+
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
+        VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
+        SolutionPrinter.print(vrp,solution, SolutionPrinter.Print.VERBOSE);
+
+        assertEquals(0,solution.getUnassignedJobs().size());
+        assertEquals(1,solution.getRoutes().size());
+
+    }
+
+    @Test
+    public void testDeliveryUnassigned(){
+        Delivery d2 = Delivery.Builder.newInstance("d2")
+                .setMaxTimeInVehicle(4)
+                .setLocation(Location.newInstance(10, 5)).setServiceTime(2).build();
+
+        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(Location.newInstance(2,3)).setEndLocation(Location.newInstance(0,0)).build();
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addVehicle(v1).addJob(d2).build();
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId id = stateManager.createStateId("max-time");
+        StateId openJobsId = stateManager.createStateId("open-jobs-id");
+        stateManager.addStateUpdater(new UpdateMaxTimeInVehicle(stateManager, id, vrp.getTransportCosts(), vrp.getActivityCosts(), openJobsId));
+
+        ConstraintManager constraintManager = new ConstraintManager(vrp,stateManager);
+        constraintManager.addConstraint(new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), id, stateManager, vrp, openJobsId), ConstraintManager.Priority.CRITICAL);
+
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
+        VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
+        SolutionPrinter.print(vrp,solution, SolutionPrinter.Print.VERBOSE);
+
+        assertEquals(1,solution.getUnassignedJobs().size());
+        assertEquals(0,solution.getRoutes().size());
+
+    }
+
+    @Test
+    public void testPickUpDropOffTwoDriversSameLocation(){
+        Shipment s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(34.773586,32.079754))
+                .setDeliveryLocation(Location.newInstance(34.781247,38.294571))
+                .setDeliveryServiceTime(10)
+                .setMaxTimeInVehicle(10)
+                .build();
+
+        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1")
+                .setStartLocation(Location.newInstance(34.771200,32.067646))
+                .setEndLocation(Location.newInstance(34.768404,32.081525)).build();
+
+        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2")
+                .setStartLocation(Location.newInstance(34.771200,32.067646))
+                .setEndLocation(Location.newInstance(34.768404,32.081525)).build();
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addVehicle(v1).addVehicle(v2).addJob(s1).build();
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId id = stateManager.createStateId("max-time");
+        StateId openJobsId = stateManager.createStateId("open-jobs-id");
+        stateManager.addStateUpdater(new UpdateMaxTimeInVehicle(stateManager, id, vrp.getTransportCosts(), vrp.getActivityCosts(), openJobsId));
+
+        ConstraintManager constraintManager = new ConstraintManager(vrp,stateManager);
+        constraintManager.addConstraint(new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), id, stateManager, vrp, openJobsId), ConstraintManager.Priority.CRITICAL);
+
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
+        VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
+        SolutionPrinter.print(vrp,solution, SolutionPrinter.Print.VERBOSE);
+        assertEquals(0,solution.getUnassignedJobs().size());
+
+    }
+
+    @Test
+    public void testPickUpDropOffTwoDriversDiffrentLocation(){
+        Shipment s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(34.773586,32.079754))
+                .setDeliveryLocation(Location.newInstance(34.781247,38.294571))
+                .setDeliveryServiceTime(10)
+                .setMaxTimeInVehicle(10)
+                .build();
+
+        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1")
+                .setStartLocation(Location.newInstance(34.771200,32.067646))
+                .setEndLocation(Location.newInstance(34.768404,32.081525)).build();
+
+        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2")
+                .setStartLocation(Location.newInstance(34.771200,32.067646))
+                .setEndLocation(Location.newInstance(34.5555,32.081324)).build();
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addVehicle(v1).addVehicle(v2).addJob(s1).build();
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId id = stateManager.createStateId("max-time");
+        StateId openJobsId = stateManager.createStateId("open-jobs-id");
+        stateManager.addStateUpdater(new UpdateMaxTimeInVehicle(stateManager, id, vrp.getTransportCosts(), vrp.getActivityCosts(), openJobsId));
+
+        ConstraintManager constraintManager = new ConstraintManager(vrp,stateManager);
+        constraintManager.addConstraint(new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), id, stateManager, vrp, openJobsId), ConstraintManager.Priority.CRITICAL);
+
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
+        VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
+        SolutionPrinter.print(vrp,solution, SolutionPrinter.Print.VERBOSE);
+
+        assertEquals(0,solution.getUnassignedJobs().size());
+    }
+
+    @Test
+    public void testRouteTwoDriversDiffrentLocationOneRoute(){
+        Shipment s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(8,0))
+            .setDeliveryLocation(Location.newInstance(10,0))
+            .setDeliveryServiceTime(2)
+            .setMaxTimeInVehicle(10)
+            .build();
+
+        Delivery d2 = Delivery.Builder.newInstance("d2")
+            .setMaxTimeInVehicle(15)
+            .setLocation(Location.newInstance(10, 5)).setServiceTime(2).build();
+
+        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1")
+            .setStartLocation(Location.newInstance(8,5)).setReturnToDepot(true).build();
+
+        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2")
+            .setStartLocation(Location.newInstance(5,0)).setReturnToDepot(true).build();
+
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
+            .addVehicle(v1)
+            .addVehicle(v2)
+            .addJob(s1)
+            .addJob(d2)
+            .build();
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId id = stateManager.createStateId("max-time");
+        StateId openJobsId = stateManager.createStateId("open-jobs-id");
+        stateManager.addStateUpdater(new UpdateMaxTimeInVehicle(stateManager, id, vrp.getTransportCosts(), vrp.getActivityCosts(), openJobsId));
+
+        ConstraintManager constraintManager = new ConstraintManager(vrp,stateManager);
+        constraintManager.addConstraint(new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), id, stateManager, vrp, openJobsId), ConstraintManager.Priority.CRITICAL);
+
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
+        VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
+        SolutionPrinter.print(vrp,solution, SolutionPrinter.Print.VERBOSE);
+        assertEquals(1,solution.getRoutes().size());
+        assertEquals(0,solution.getUnassignedJobs().size());
+
+    }
+
+
+
+    @Test
+    public void testRouteTwoDriversTwoRouts(){
+        Shipment s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(8,0))
+                .setDeliveryLocation(Location.newInstance(10,0))
+                .setDeliveryServiceTime(9)
+                .setMaxTimeInVehicle(10)
+                .build();
+
+        Delivery d2 = Delivery.Builder.newInstance("d2")
+                .setMaxTimeInVehicle(3)
+                .setLocation(Location.newInstance(10, 5)).setServiceTime(10).build();
+
+        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1")
+                .setStartLocation(Location.newInstance(8,5)).setReturnToDepot(true).build();
+
+        VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2")
+                .setStartLocation(Location.newInstance(5,0)).setReturnToDepot(true).build();
+
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
+                .addVehicle(v1)
+                .addVehicle(v2)
+                .addJob(s1)
+                .addJob(d2)
+                .build();
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId id = stateManager.createStateId("max-time");
+        StateId openJobsId = stateManager.createStateId("open-jobs-id");
+        stateManager.addStateUpdater(new UpdateMaxTimeInVehicle(stateManager, id, vrp.getTransportCosts(), vrp.getActivityCosts(), openJobsId));
+
+        ConstraintManager constraintManager = new ConstraintManager(vrp,stateManager);
+        constraintManager.addConstraint(new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), id, stateManager, vrp, openJobsId), ConstraintManager.Priority.CRITICAL);
+
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
+        VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
+        SolutionPrinter.print(vrp,solution, SolutionPrinter.Print.VERBOSE);
+        assertEquals(2,solution.getRoutes().size());
+        assertEquals(0,solution.getUnassignedJobs().size());
+    }
+
+    @Test
+    public void testRoute(){
+        Shipment s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(5,0))
+                .setDeliveryLocation(Location.newInstance(10,0))
+                .setMaxTimeInVehicle(5)
+                .build();
+
+        Shipment s2 = Shipment.Builder.newInstance("s2").setPickupLocation(Location.newInstance(6,5))
+                .setDeliveryLocation(Location.newInstance(12,0))
+                .setMaxTimeInVehicle(10)
+                .build();
+
+        Shipment s3 = Shipment.Builder.newInstance("s3").setPickupLocation(Location.newInstance(3,2))
+                .setDeliveryLocation(Location.newInstance(3,5))
+                .setMaxTimeInVehicle(10)
+                .build();
+
+
+        VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1")
+                .setStartLocation(Location.newInstance(0,0)).setReturnToDepot(true).build();
+
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
+                .addVehicle(v1)
+                .addJob(s1)
+                .addJob(s2)
+                .addJob(s3)
+                .build();
+
+        StateManager stateManager = new StateManager(vrp);
+        StateId id = stateManager.createStateId("max-time");
+        StateId openJobsId = stateManager.createStateId("open-jobs-id");
+        stateManager.addStateUpdater(new UpdateMaxTimeInVehicle(stateManager, id, vrp.getTransportCosts(), vrp.getActivityCosts(), openJobsId));
+
+        ConstraintManager constraintManager = new ConstraintManager(vrp,stateManager);
+        constraintManager.addConstraint(new MaxTimeInVehicleConstraint(vrp.getTransportCosts(), vrp.getActivityCosts(), id, stateManager, vrp, openJobsId), ConstraintManager.Priority.CRITICAL);
+
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
+        VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
+        SolutionPrinter.print(vrp,solution, SolutionPrinter.Print.VERBOSE);
+
+        assertEquals(1,solution.getRoutes().size());
+        assertEquals(0,solution.getUnassignedJobs().size());
+    }
+}
