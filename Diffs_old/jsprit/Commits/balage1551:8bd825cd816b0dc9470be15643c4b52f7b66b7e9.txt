diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/VehicleDependentTraveledDistance.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/VehicleDependentTraveledDistance.java
new file mode 100644
index 000000000..bde4058b8
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/state/VehicleDependentTraveledDistance.java
@@ -0,0 +1,120 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.graphhopper.jsprit.core.algorithm.state;
+
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.cost.TransportDistance;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.ActivityVisitor;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeKey;
+
+import java.util.*;
+
+/**
+ * Created by schroeder on 17/05/16.
+ */
+public class VehicleDependentTraveledDistance implements StateUpdater, ActivityVisitor {
+
+    static class State {
+
+        Location prevLocation;
+
+        double distance;
+
+        public State(Location prevLocation, double distance) {
+            this.prevLocation = prevLocation;
+            this.distance = distance;
+        }
+
+        public Location getPrevLocation() {
+            return prevLocation;
+        }
+
+        public double getDistance() {
+            return distance;
+        }
+    }
+
+    private final TransportDistance transportDistance;
+
+    private final StateManager stateManager;
+
+    private final StateId traveledDistanceId;
+
+    private VehicleRoute route;
+
+    private List<Vehicle> uniqueVehicles;
+
+    private Map<VehicleTypeKey,State> states;
+
+    public VehicleDependentTraveledDistance(TransportDistance transportCostMatrices, StateManager stateManager, StateId distanceInRouteId, Collection<Vehicle> vehicles) {
+        this.transportDistance = transportCostMatrices;
+        this.stateManager = stateManager;
+        this.traveledDistanceId = distanceInRouteId;
+        uniqueVehicles = getUniqueVehicles(vehicles);
+    }
+
+    private List<Vehicle> getUniqueVehicles(Collection<Vehicle> vehicles) {
+        Set<VehicleTypeKey> types = new HashSet<>();
+        List<Vehicle> uniqueVehicles = new ArrayList<>();
+        for(Vehicle v : vehicles){
+            if(!types.contains(v.getVehicleTypeIdentifier())){
+                types.add(v.getVehicleTypeIdentifier());
+                uniqueVehicles.add(v);
+            }
+        }
+        return uniqueVehicles;
+    }
+
+    @Override
+    public void begin(VehicleRoute route) {
+        this.route = route;
+        states = new HashMap<>();
+        for(Vehicle v : uniqueVehicles){
+            State state = new State(v.getStartLocation(),0);
+            states.put(v.getVehicleTypeIdentifier(),state);
+        }
+    }
+
+    @Override
+    public void visit(TourActivity activity) {
+        for(Vehicle v : uniqueVehicles){
+            State old = states.get(v.getVehicleTypeIdentifier());
+            double distance = old.getDistance();
+            distance += transportDistance.getDistance(old.getPrevLocation(),activity.getLocation(),0,v);
+            stateManager.putActivityState(activity,v,traveledDistanceId,distance);
+            states.put(v.getVehicleTypeIdentifier(),new State(activity.getLocation(),distance));
+        }
+    }
+
+    @Override
+    public void finish() {
+        for(Vehicle v : uniqueVehicles){
+            State old = states.get(v.getVehicleTypeIdentifier());
+            double distance = old.getDistance();
+            if(v.isReturnToDepot()) {
+                distance += transportDistance.getDistance(old.getPrevLocation(), v.getEndLocation(), 0, v);
+            }
+            stateManager.putRouteState(route,v,traveledDistanceId, distance);
+        }
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
index 20d15234f..2c4a93169 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
@@ -616,7 +616,7 @@ private VehicleRoutingProblem(Builder builder) {
     @Override
     public String toString() {
         return "[fleetSize=" + fleetSize + "][#jobs=" + jobs.size() + "][#vehicles=" + vehicles.size() + "][#vehicleTypes=" + vehicleTypes.size() + "][" +
-                "transportCost=" + transportCosts + "][activityCosts=" + activityCosts + "]";
+            "transportCost=" + transportCosts + "][activityCosts=" + activityCosts + "]";
     }
 
     /**
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
new file mode 100644
index 000000000..96c752a5c
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
@@ -0,0 +1,133 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.graphhopper.jsprit.core.problem.constraint;
+
+import com.graphhopper.jsprit.core.algorithm.state.StateId;
+import com.graphhopper.jsprit.core.algorithm.state.StateManager;
+import com.graphhopper.jsprit.core.problem.cost.TransportDistance;
+import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliverShipment;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+
+import java.util.Collection;
+import java.util.Map;
+
+/**
+ * Created by schroeder on 11/10/16.
+ */
+public class MaxDistanceConstraint implements HardActivityConstraint{
+
+    private StateManager stateManager;
+
+    private StateId distanceId;
+
+    private TransportDistance distanceCalculator;
+
+    private Double[] maxDistances;
+
+    public MaxDistanceConstraint(StateManager stateManager, StateId distanceId, TransportDistance distanceCalculator, Map<Vehicle,Double> maxDistancePerVehicleMap) {
+        this.stateManager = stateManager;
+        this.distanceId = distanceId;
+        this.distanceCalculator = distanceCalculator;
+        makeArray(maxDistancePerVehicleMap);
+    }
+
+    private void makeArray(Map<Vehicle, Double> maxDistances) {
+        int maxIndex = getMaxIndex(maxDistances.keySet());
+        this.maxDistances = new Double[maxIndex+1];
+        for(Vehicle v : maxDistances.keySet()){
+            this.maxDistances[v.getIndex()]=maxDistances.get(v);
+        }
+    }
+
+    private int getMaxIndex(Collection<Vehicle> vehicles) {
+        int index = 0;
+        for(Vehicle v : vehicles){
+            if(v.getIndex() > index) index = v.getIndex();
+        }
+        return index;
+    }
+
+    @Override
+    public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime) {
+        if(!hasMaxDistance(iFacts.getNewVehicle())) return ConstraintsStatus.FULFILLED;
+        Double currentDistance = 0d;
+        if(!iFacts.getRoute().isEmpty()){
+            currentDistance = stateManager.getRouteState(iFacts.getRoute(),iFacts.getNewVehicle(), distanceId,Double.class);
+        }
+        double maxDistance = getMaxDistance(iFacts.getNewVehicle());
+
+        double distancePrevAct2NewAct = distanceCalculator.getDistance(prevAct.getLocation(), newAct.getLocation(), iFacts.getNewDepTime(), iFacts.getNewVehicle());
+        double distanceNewAct2nextAct = distanceCalculator.getDistance(newAct.getLocation(), nextAct.getLocation(), iFacts.getNewDepTime(), iFacts.getNewVehicle());
+        double distancePrevAct2NextAct = distanceCalculator.getDistance(prevAct.getLocation(), nextAct.getLocation(), prevActDepTime, iFacts.getRoute().getVehicle());
+        if(nextAct instanceof End && !iFacts.getNewVehicle().isReturnToDepot()){
+            distanceNewAct2nextAct = 0;
+            distancePrevAct2NextAct = 0;
+        }
+
+        double additionalDistanceOfPickup = 0;
+        if(newAct instanceof DeliverShipment){
+            int iIndexOfPickup = iFacts.getRelatedActivityContext().getInsertionIndex();
+            TourActivity pickup = iFacts.getAssociatedActivities().get(0);
+            TourActivity actBeforePickup;
+            if(iIndexOfPickup > 0) actBeforePickup = iFacts.getRoute().getActivities().get(iIndexOfPickup-1);
+            else actBeforePickup = iFacts.getRoute().getStart();
+
+            TourActivity actAfterPickup;
+            boolean associatedPickAndDeliveryAreDirectNeighbors = prevAct.getIndex() == pickup.getIndex();
+            if(associatedPickAndDeliveryAreDirectNeighbors){
+                actAfterPickup = newAct;
+                distancePrevAct2NextAct = distanceCalculator.getDistance(prevAct.getLocation(), nextAct.getLocation(), iFacts.getRelatedActivityContext().getEndTime(), iFacts.getNewVehicle());
+            }
+            else actAfterPickup = iFacts.getRoute().getActivities().get(iIndexOfPickup);
+            double distanceActBeforePickup2Pickup = distanceCalculator.getDistance(actBeforePickup.getLocation(), pickup.getLocation(), actBeforePickup.getEndTime(), iFacts.getNewVehicle());
+            double distancePickup2ActAfterPickup = distanceCalculator.getDistance(pickup.getLocation(), actAfterPickup.getLocation(), iFacts.getRelatedActivityContext().getEndTime(), iFacts.getNewVehicle());
+
+            double distanceBeforePickup2AfterPickup;
+            if(associatedPickAndDeliveryAreDirectNeighbors){
+                distanceBeforePickup2AfterPickup = distanceCalculator.getDistance(actBeforePickup.getLocation(), actAfterPickup.getLocation(), actBeforePickup.getEndTime(), iFacts.getNewVehicle());
+            }
+            else{
+                distanceBeforePickup2AfterPickup = distanceCalculator.getDistance(actBeforePickup.getLocation(), actAfterPickup.getLocation(), actBeforePickup.getEndTime(), iFacts.getRoute().getVehicle());
+            }
+            additionalDistanceOfPickup = distanceActBeforePickup2Pickup  + distancePickup2ActAfterPickup - distanceBeforePickup2AfterPickup;
+        }
+
+        double additionalDistance = distancePrevAct2NewAct + distanceNewAct2nextAct - distancePrevAct2NextAct;
+        if(currentDistance + additionalDistance > maxDistance) return ConstraintsStatus.NOT_FULFILLED;
+
+        if(currentDistance + additionalDistance + additionalDistanceOfPickup > maxDistance){
+            return ConstraintsStatus.NOT_FULFILLED;
+        }
+
+        return ConstraintsStatus.FULFILLED;
+    }
+
+    private boolean hasMaxDistance(Vehicle newVehicle){
+        return this.maxDistances[newVehicle.getIndex()] != null;
+    }
+
+    private double getMaxDistance(Vehicle newVehicle) {
+        Double maxDistance = this.maxDistances[newVehicle.getIndex()];
+        if(maxDistance == null) return Double.MAX_VALUE;
+        return maxDistance;
+    }
+}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
new file mode 100644
index 000000000..5a9216250
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
@@ -0,0 +1,238 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.graphhopper.jsprit.core.problem.constraint;
+
+
+import com.graphhopper.jsprit.core.algorithm.state.StateId;
+import com.graphhopper.jsprit.core.algorithm.state.StateManager;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.cost.TransportDistance;
+import com.graphhopper.jsprit.core.problem.job.Delivery;
+import com.graphhopper.jsprit.core.problem.job.Job;
+import com.graphhopper.jsprit.core.problem.job.Pickup;
+import com.graphhopper.jsprit.core.problem.job.Shipment;
+import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
+import com.graphhopper.jsprit.core.util.ManhattanCosts;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.*;
+
+import static org.mockito.Mockito.mock;
+
+/**
+ * Created by schroeder on 18/05/16.
+ */
+public class VehicleDependentTraveledDistanceTest {
+
+    StateManager stateManager;
+
+    VehicleRoute route;
+
+    StateId traveledDistanceId;
+
+    Vehicle vehicle;
+
+    Vehicle vehicle2;
+
+    VehicleRoutingProblem vrp;
+
+    Delivery d1,d2,newDelivery;
+
+    Pickup pickup;
+
+    Shipment s1;
+
+    Map<Vehicle,Double> maxDistanceMap;
+
+
+    @Before
+    public void doBefore(){
+        vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0,0)).build();
+        vehicle2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(Location.newInstance(10,10)).build();
+
+        maxDistanceMap = new HashMap<>();
+        maxDistanceMap.put(vehicle,200d);
+        maxDistanceMap.put(vehicle2,200d);
+
+        d1 = Delivery.Builder.newInstance("d1").setLocation(Location.newInstance(10,10)).build();
+        d2 = Delivery.Builder.newInstance("d2").setLocation(Location.newInstance(20,15)).build();
+        pickup = Pickup.Builder.newInstance("pickup").setLocation(Location.newInstance(50,50)).build();
+        s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(35,30))
+            .setDeliveryLocation(Location.newInstance(20,25)).build();
+
+        newDelivery = Delivery.Builder.newInstance("new").setLocation(Location.newInstance(-10,10)).build();
+
+        vrp = VehicleRoutingProblem.Builder.newInstance()
+            .setRoutingCost(new ManhattanCosts()).addVehicle(vehicle).addVehicle(vehicle2)
+            .addJob(d1).addJob(d2).addJob(s1).addJob(pickup).addJob(newDelivery).build();
+
+        route = VehicleRoute.Builder.newInstance(vehicle).setJobActivityFactory(vrp.getJobActivityFactory())
+            .addDelivery(d1).addDelivery(d2).addPickup(s1).addPickup(pickup).addDelivery(s1).build();
+
+        stateManager = new StateManager(vrp);
+
+        traveledDistanceId = stateManager.createStateId("traveledDistance");
+
+        com.graphhopper.jsprit.core.algorithm.state.VehicleDependentTraveledDistance traveledDistance =
+            new com.graphhopper.jsprit.core.algorithm.state.VehicleDependentTraveledDistance(new TransportDistance() {
+                @Override
+                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                    return new ManhattanCosts().getDistance(from,to,departureTime,vehicle);
+                }
+        },stateManager,traveledDistanceId,Arrays.asList(vehicle,vehicle2));
+
+        stateManager.addStateUpdater(traveledDistance);
+        stateManager.informInsertionStarts(Arrays.asList(route), Collections.<Job>emptyList());
+    }
+
+    /*
+    vehicle: 200.0
+vehicle (max distance): 200.0
+vehicle2: 160.0
+vehicle2 (max distance): 180.0
+     */
+    @Test
+    public void insertNewInVehicleShouldFail(){
+        MaxDistanceConstraint maxDistanceConstraint =
+            new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
+                @Override
+                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                }
+            },maxDistanceMap);
+        JobInsertionContext context = new JobInsertionContext(route,newDelivery,vehicle,null,0);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,route.getStart(),newAct(),act(0),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(0),newAct(),act(1),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(1),newAct(),act(2),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(2),newAct(),act(3),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(3),newAct(),act(4),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(4),newAct(),route.getEnd(),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+    }
+
+
+    @Test
+    public void insertNewInVehicle2ShouldBeCorrect(){
+        //current distance vehicle2: 160 allowed: 200
+        MaxDistanceConstraint maxDistanceConstraint =
+            new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
+                @Override
+                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                }
+            },maxDistanceMap);
+        JobInsertionContext context = new JobInsertionContext(route,newDelivery,vehicle2,null,0);
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,route.getStart(),newAct(),act(0),0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+        //additional distance: 20+35-15=40
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(0),newAct(),act(1),0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+        //additional distance: 35+65-30=70
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(1),newAct(),act(2),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        //additional distance: 65+100-35
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(2),newAct(),act(3),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        //additional distance: 100+45-55
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(3),newAct(),act(4),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
+        //additional distance: 45+20-25
+        Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(4),newAct(),route.getEnd(),0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
+    }
+
+    private TourActivity act(int i) {
+        return route.getActivities().get(i);
+    }
+
+    private TourActivity newAct(){
+        return vrp.getActivities(newDelivery).get(0);
+    }
+
+    @Test
+    public void traveledDistanceShouldBeCorrect(){
+        Assert.assertEquals(20d,stateManager.getActivityState(route.getActivities().get(0),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(35d,stateManager.getActivityState(route.getActivities().get(1),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(65d,stateManager.getActivityState(route.getActivities().get(2),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(100d,stateManager.getActivityState(route.getActivities().get(3),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(155d,stateManager.getActivityState(route.getActivities().get(4),vehicle,traveledDistanceId,Double.class),0.01);
+
+    }
+
+    @Test
+    public void traveledDistanceWithVehicle2ShouldBeCorrect(){
+        Assert.assertEquals(0d,stateManager.getActivityState(route.getActivities().get(0),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(15d,stateManager.getActivityState(route.getActivities().get(1),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(45d,stateManager.getActivityState(route.getActivities().get(2),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(80d,stateManager.getActivityState(route.getActivities().get(3),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(135d,stateManager.getActivityState(route.getActivities().get(4),vehicle2,traveledDistanceId,Double.class),0.01);
+
+    }
+
+    @Test
+    public void distanceOfShipmentInRoute(){
+        double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(2), vehicle,traveledDistanceId, Double.class);
+        double traveledDistanceBeforeDelivery = stateManager.getActivityState(route.getActivities().get(4), vehicle,traveledDistanceId, Double.class);
+        Assert.assertEquals(90d,traveledDistanceBeforeDelivery-traveledDistanceBeforePickup,0.01);
+    }
+
+    @Test
+    public void distanceOfShipmentInRouteVehicle2(){
+        double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(2), vehicle2,traveledDistanceId, Double.class);
+        double traveledDistanceBeforeDelivery = stateManager.getActivityState(route.getActivities().get(4), vehicle2,traveledDistanceId, Double.class);
+        Assert.assertEquals(90d,traveledDistanceBeforeDelivery-traveledDistanceBeforePickup,0.01);
+    }
+
+    @Test
+    public void distanceOfPickupInRoute(){
+        double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(3),vehicle, traveledDistanceId, Double.class);
+        double total = stateManager.getRouteState(route, vehicle,traveledDistanceId, Double.class);
+        Assert.assertEquals(100d,total-traveledDistanceBeforePickup,0.01);
+    }
+
+    @Test
+    public void distanceOfPickupInRouteVehicle2(){
+        double traveledDistanceBeforePickup = stateManager.getActivityState(route.getActivities().get(3),vehicle2, traveledDistanceId, Double.class);
+        double total = stateManager.getRouteState(route, vehicle2,traveledDistanceId, Double.class);
+        Assert.assertEquals(80d,total-traveledDistanceBeforePickup,0.01);
+    }
+
+    @Test
+    public void distanceToTravelShouldBeCorrect(){
+        double total = stateManager.getRouteState(route,vehicle,traveledDistanceId,Double.class);
+        Assert.assertEquals(180d,total - stateManager.getActivityState(route.getActivities().get(0),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(165d,total - stateManager.getActivityState(route.getActivities().get(1),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(135d,total - stateManager.getActivityState(route.getActivities().get(2),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(100d,total - stateManager.getActivityState(route.getActivities().get(3),vehicle,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(45d,total - stateManager.getActivityState(route.getActivities().get(4),vehicle,traveledDistanceId,Double.class),0.01);
+
+    }
+
+    @Test
+    public void distanceToTravelShouldBeCorrectVehicle2(){
+        double total = stateManager.getRouteState(route,vehicle2,traveledDistanceId,Double.class);
+        Assert.assertEquals(160d,total - stateManager.getActivityState(route.getActivities().get(0),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(145d,total - stateManager.getActivityState(route.getActivities().get(1),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(115d,total - stateManager.getActivityState(route.getActivities().get(2),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(80d,total - stateManager.getActivityState(route.getActivities().get(3),vehicle2,traveledDistanceId,Double.class),0.01);
+        Assert.assertEquals(25d,total - stateManager.getActivityState(route.getActivities().get(4),vehicle2,traveledDistanceId,Double.class),0.01);
+
+    }
+}
