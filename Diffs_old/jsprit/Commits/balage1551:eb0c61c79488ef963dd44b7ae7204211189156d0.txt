diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/HumanReadableDurationFormatter.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/HumanReadableDurationFormatter.java
new file mode 100644
index 000000000..7b99ac46f
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/HumanReadableDurationFormatter.java
@@ -0,0 +1,142 @@
+package com.graphhopper.jsprit.core.reporting;
+
+import java.time.format.DateTimeFormatter;
+import java.time.temporal.ChronoUnit;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+import hu.vissy.texttable.dataconverter.DataConverter;
+
+/**
+ * Duration formatter for human readable format.
+ * <p>
+ * The formatter uses the {@linkplain DateTimeFormatter} for time value to
+ * string formatting. The default format is the standard ISO time format (
+ * <code>"HH:mm:ss"</code>). If the input long value is X, the time value is
+ * calculated by adding X of the units to a predefined origin. The default unit
+ * is {@linkplain ChronoUnit#SECONDS}.
+ * </p>
+ *
+ * @author balage
+ *
+ */
+public class HumanReadableDurationFormatter implements DataConverter<Long> {
+
+    private static class UnitInfo {
+        private ChronoUnit unit;
+        private int exchange;
+        private String format;
+        private String prefix;
+        private String postfix;
+
+        public UnitInfo(ChronoUnit unit, int exchange, String format, String prefix,
+                String postfix) {
+            super();
+            this.unit = unit;
+            this.exchange = exchange;
+            this.format = format;
+            this.prefix = prefix;
+            this.postfix = postfix;
+        }
+        public ChronoUnit getUnit() {
+            return unit;
+        }
+        public int getExchange() {
+            return exchange;
+        }
+        public String getFormat() {
+            return format;
+        }
+
+        public String getPrefix() {
+            return prefix;
+        }
+
+        public String getPostfix() {
+            return postfix;
+        }
+
+    }
+
+    private static final List<UnitInfo> UNIT_INFO;
+    private static final Set<ChronoUnit> VALID_UNITS;
+
+
+    static {
+        UNIT_INFO = new ArrayList<>();
+        UNIT_INFO.add(new UnitInfo(ChronoUnit.SECONDS, 60, "%02d", ":", ""));
+        UNIT_INFO.add(new UnitInfo(ChronoUnit.MINUTES, 60, "%02d", ":", ""));
+        UNIT_INFO.add(new UnitInfo(ChronoUnit.HOURS, 24, "%02d", " ", ""));
+        UNIT_INFO.add(new UnitInfo(ChronoUnit.DAYS, Integer.MAX_VALUE, "%d", "", " d"));
+
+        VALID_UNITS = UNIT_INFO.stream().map(ui -> ui.getUnit()).collect(Collectors.toSet());
+    }
+
+    // The time unit
+    private ChronoUnit lowUnit = ChronoUnit.SECONDS;
+    // The highest unit
+    private ChronoUnit highUnit = ChronoUnit.DAYS;
+
+    /**
+     * Constructor with default settings. See
+     * {@linkplain HumanReadableTimeFormatter} for default values.
+     */
+    public HumanReadableDurationFormatter() {
+    }
+
+
+    public HumanReadableDurationFormatter(ChronoUnit lowUnit, ChronoUnit highUnit) {
+        if (!VALID_UNITS.contains(lowUnit))
+            throw new IllegalArgumentException(
+                    lowUnit + " is not allowed. Only: " + VALID_UNITS + " units allowed.");
+        if (!VALID_UNITS.contains(highUnit))
+            throw new IllegalArgumentException(
+                    highUnit + " is not allowed. Only: " + VALID_UNITS + " units allowed.");
+        if (indexOf(lowUnit) > indexOf(highUnit))
+            throw new IllegalArgumentException(
+                    lowUnit + " should be not higher than " + highUnit + ".");
+        this.lowUnit = lowUnit;
+        this.highUnit = highUnit;
+    }
+
+    private int indexOf(ChronoUnit unit) {
+        for (int i = 0; i < UNIT_INFO.size(); i++)
+            if (UNIT_INFO.get(i).getUnit().equals(unit))
+                return i;
+        throw new IllegalArgumentException("Unit " + unit + " is not valid");
+    }
+
+    @Override
+    public String convert(Long data) {
+        if (data == null)
+            return "";
+        else {
+            long val = data;
+            String res = "";
+            int i = indexOf(lowUnit);
+            int highIndex = indexOf(highUnit);
+            while (i <= highIndex) {
+                String s = "";
+                UnitInfo unitInfo = UNIT_INFO.get(i);
+                if (val >= unitInfo.getExchange() && i == highIndex) {
+                    s = String.format("%d", val);
+                } else {
+                    s = String.format(unitInfo.getFormat(), val % unitInfo.exchange);
+                }
+                s = s + unitInfo.getPostfix();
+
+                if (i != highIndex) {
+                    s = unitInfo.getPrefix() + s;
+                }
+                res = s + res;
+                val = val / unitInfo.exchange;
+                i++;
+            }
+
+            return res;
+        }
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/HumanReadableTimeFormatter.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/HumanReadableTimeFormatter.java
new file mode 100644
index 000000000..ec552e5b5
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/HumanReadableTimeFormatter.java
@@ -0,0 +1,102 @@
+package com.graphhopper.jsprit.core.reporting;
+
+import java.time.LocalDate;
+import java.time.LocalDateTime;
+import java.time.LocalTime;
+import java.time.format.DateTimeFormatter;
+import java.time.temporal.ChronoUnit;
+
+/**
+ * Time value or duration formatter for human readable format.
+ * <p>
+ * The formatter uses the {@linkplain DateTimeFormatter} for time value to
+ * string formatting. The default format is the standard ISO time format (
+ * <code>"HH:mm:ss"</code>). If the input long value is X, the time value is
+ * calculated by adding X of the units to the origin. The default value for
+ * origin is midnight (00:00) of the current day (note, that the default
+ * formatting ignores the date value), the default unit is
+ * {@linkplain ChronoUnit#SECONDS}.
+ * </p>
+ *
+ * @author balage
+ *
+ */
+public class HumanReadableTimeFormatter {
+
+    // Default origin
+    public static final LocalDateTime DEFAULT_ORIGIN = LocalDateTime.of(LocalDate.now(), LocalTime.MIDNIGHT);
+
+    // The formatter
+    private DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("HH:mm:ss");
+    // The origin
+    private LocalDateTime origin = DEFAULT_ORIGIN;
+    // The time unit
+    private ChronoUnit unit = ChronoUnit.SECONDS;
+
+    /**
+     * Constructor with default settings. See
+     * {@linkplain HumanReadableTimeFormatter} for default values.
+     */
+    public HumanReadableTimeFormatter() {
+    }
+
+    /**
+     * Constructor with time mapping values, but with default formatting.
+     *
+     * @param origin
+     *            The origin data and time of the time mapping. (Note that with
+     *            default formatter, the date part is ignored.)
+     * @param unit
+     *            The unit used to map the numerical value to the time value.
+     */
+    public HumanReadableTimeFormatter(LocalDateTime origin, ChronoUnit unit) {
+        this.origin = origin;
+        this.unit = unit;
+    }
+
+    /**
+     * Constructor with user-defined formatting.
+     *
+     * @param dateFormatter
+     *            The date formatter.
+     */
+    public HumanReadableTimeFormatter(DateTimeFormatter dateFormatter) {
+        this.dateFormatter = dateFormatter;
+    }
+
+    /**
+     * Constructor with both time mapping values and user-defined formatting.
+     *
+     * @param dateFormatter
+     *            The date formatter.
+     * @param origin
+     *            The origin data and time of the time mapping.
+     * @param unit
+     *            The unit used to map the numerical value to the time value.
+     */
+    public HumanReadableTimeFormatter(DateTimeFormatter dateFormatter, LocalDateTime origin, ChronoUnit unit) {
+        this.dateFormatter = dateFormatter;
+        this.origin = origin;
+        this.unit = unit;
+    }
+
+    /**
+     * Formats a numerical value into a human readable time value.
+     * <p>
+     * First a time value is calculated by adding <code>timeValue</code> of the
+     * units to the origin. Then the time value is formatted by the formatter.
+     * </p>
+     *
+     * @param timeValue
+     *            The value to convert.
+     * @return The converted value.
+     */
+    public String format(Long timeValue) {
+        if (timeValue == null) {
+            return null;
+        } else {
+            LocalDateTime dt = origin.plus(timeValue, unit);
+            return dateFormatter.format(dt);
+        }
+    }
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/RouteDeatailsRecord.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/RouteDeatailsRecord.java
new file mode 100644
index 000000000..d43a10f42
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/RouteDeatailsRecord.java
@@ -0,0 +1,122 @@
+package com.graphhopper.jsprit.core.reporting;
+
+import com.graphhopper.jsprit.core.problem.SizeDimension;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.job.AbstractJob;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+
+/**
+ * The context of the detailed route printer columns.
+ *
+ * <p>
+ * This is a imutable class.
+ * </p>
+ *
+ * @author balage
+ *
+ */
+public class RouteDeatailsRecord {
+
+    // The route itself
+    private VehicleRoute route;
+    // The current activity
+    private TourActivity activity;
+    // The problem
+    private VehicleRoutingProblem problem;
+
+    /**
+     * Constructor.
+     *
+     * @param routeNr
+     *            route id
+     * @param route
+     *            the route
+     * @param activity
+     *            current activity
+     * @param problem
+     *            problem
+     */
+    public RouteDeatailsRecord(VehicleRoute route, TourActivity activity,
+            VehicleRoutingProblem problem) {
+        super();
+        this.route = route;
+        this.activity = activity;
+        this.problem = problem;
+    }
+
+    /**
+     * @return The route itself.
+     */
+    public VehicleRoute getRoute() {
+        return route;
+    }
+
+    /**
+     * @return The current activity.
+     */
+    public TourActivity getActivity() {
+        return activity;
+    }
+
+    /**
+     * @return The problem.
+     */
+    public VehicleRoutingProblem getProblem() {
+        return problem;
+    }
+
+    public AbstractJob getJob() {
+        return (getActivity() instanceof JobActivity) ? ((JobActivity) getActivity()).getJob() : null;
+    }
+
+    public SizeDimension calculateInitialLoad() {
+        SizeDimension sd = SizeDimension.EMPTY;
+        for (TourActivity a : getRoute().getActivities()) {
+            sd = sd.add(a.getLoadChange());
+        }
+        sd = sd.getNegativeDimensions().abs();
+        return sd;
+    }
+
+    /**
+     * Returns the activity cost extracted from the context.
+     *
+     * @param context
+     *            The context.
+     * @return The activity cost.
+     */
+    double getActivityCost() {
+        return getProblem().getActivityCosts().getActivityCost(getActivity(),
+                getActivity().getArrTime(), getRoute().getDriver(), getRoute().getVehicle());
+    }
+
+    /**
+     * Returns the transport cost extracted from the
+     *
+     * @param context
+     *            The
+     * @return The transport cost.
+     */
+    double getTransportCost(TourActivity prevAct) {
+        return prevAct == null ? 0d
+                : getProblem().getTransportCosts().getTransportCost(prevAct.getLocation(),
+                        getActivity().getLocation(), getActivity().getArrTime(),
+                        getRoute().getDriver(), getRoute().getVehicle());
+    }
+
+    /**
+     * Returns the transport time extracted from the
+     *
+     * @param context
+     *            The
+     * @return The transpoert time.
+     */
+    double getTransportTime(TourActivity prevAct) {
+        return prevAct == null ? 0d
+                : getProblem().getTransportCosts().getTransportTime(prevAct.getLocation(),
+                        getActivity().getLocation(), getActivity().getArrTime(),
+                        getRoute().getDriver(), getRoute().getVehicle());
+    }
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/RouteDetailsConfig.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/RouteDetailsConfig.java
new file mode 100644
index 000000000..35b35bc98
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/RouteDetailsConfig.java
@@ -0,0 +1,521 @@
+package com.graphhopper.jsprit.core.reporting;
+
+import java.time.LocalDate;
+import java.time.LocalDateTime;
+import java.time.LocalTime;
+import java.time.temporal.ChronoUnit;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.SizeDimension;
+import com.graphhopper.jsprit.core.problem.job.AbstractJob;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.AbstractActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.Start;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+
+import hu.vissy.texttable.column.ColumnDefinition;
+import hu.vissy.texttable.contentformatter.CellContentFormatter;
+import hu.vissy.texttable.dataconverter.DataConverter;
+import hu.vissy.texttable.dataconverter.NumberDataConverter;
+import hu.vissy.texttable.dataextractor.StatefulDataExtractor;
+
+
+public class RouteDetailsConfig {
+
+    private static final String[] PRIORITY_NAMES = new String[] { "", /* 1 */ "highest",
+            /* 2 */ "very high", /* 3 */ "high", /* 4 */ "above medium", /* 5 */ "medium",
+            /* 6 */ "below medium", /* 7 */ "low", /* 8 */ "very low", /* 9 */ "extreme low",
+            /* 10 */ "lowest", };
+
+    private static class SizeDimensionAggregator {
+        SizeDimension size;
+    }
+
+    private static class PrevActivityHolder {
+        TourActivity prevAct;
+    }
+
+    private static final DataConverter<SizeDimension> SIZE_DIMENSION_CONVERTER = sd -> {
+        if (sd != null)
+            return IntStream.range(0, sd.getNuOfDimensions()).mapToObj(i -> "" + sd.get(i))
+                    .collect(Collectors.joining(", ", "[", "]"));
+        else
+            return null;
+    };
+
+
+    public enum DisplayMode {
+        NUMERIC {
+            @Override
+            List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> pickColumns(
+                    ColumnDefinition<RouteDeatailsRecord, ?, ?> numeric,
+                    ColumnDefinition<RouteDeatailsRecord, ?, ?> human) {
+                return Collections.singletonList(numeric);
+            }
+        },
+        HUMAN {
+            @Override
+            List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> pickColumns(
+                    ColumnDefinition<RouteDeatailsRecord, ?, ?> numeric,
+                    ColumnDefinition<RouteDeatailsRecord, ?, ?> human) {
+                return Collections.singletonList(human);
+            }
+        },
+        BOTH {
+            @Override
+            List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> pickColumns(
+                    ColumnDefinition<RouteDeatailsRecord, ?, ?> numeric,
+                    ColumnDefinition<RouteDeatailsRecord, ?, ?> human) {
+                List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> res = new ArrayList<>();
+                res.add(numeric);
+                res.add(human);
+                return res;
+            }
+        };
+
+        abstract List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> pickColumns(
+                ColumnDefinition<RouteDeatailsRecord, ?, ?> numeric,
+                ColumnDefinition<RouteDeatailsRecord, ?, ?> human);
+    }
+
+    public enum Column {
+        ROUTE_NUMBER {
+
+            @Override
+            public List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> createColumns(
+                    RouteDetailsConfig routeDetailsConfig) {
+                return Collections.singletonList(
+                        new ColumnDefinition.StatelessBuilder<RouteDeatailsRecord, Integer>()
+                        .withTitle("route")
+                        .withDataExtractor(r -> r.getRoute().getId())
+                        .withCellContentFormatter(CellContentFormatter.rightAlignedCell())
+                        .withDataConverter(NumberDataConverter.defaultIntegerFormatter())
+                        .build());
+            }
+
+        },
+        VEHICLE_NAME {
+
+            @Override
+            public List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> createColumns(
+                    RouteDetailsConfig routeDetailsConfig) {
+                return Collections.singletonList(
+                        new ColumnDefinition.StatelessBuilder<RouteDeatailsRecord, String>()
+                        .withTitle("vehicle")
+                        .withDataExtractor(r -> r.getRoute().getVehicle().getId()).build());
+            }
+
+        },
+        ACTIVITY_TYPE {
+
+            @Override
+            public List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> createColumns(
+                    RouteDetailsConfig routeDetailsConfig) {
+                return Collections.singletonList(
+                        new ColumnDefinition.StatelessBuilder<RouteDeatailsRecord, String>()
+                        .withTitle("activity")
+                        .withDataExtractor(
+                                r -> ((AbstractActivity) r.getActivity()).getType())
+                        .build());
+            }
+
+        },
+        JOB_NAME {
+
+            @Override
+            public List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> createColumns(
+                    RouteDetailsConfig routeDetailsConfig) {
+                return Collections.singletonList(
+                        new ColumnDefinition.StatelessBuilder<RouteDeatailsRecord, String>()
+                        .withTitle("job name").withDataExtractor(r -> {
+                            AbstractJob job = r.getJob();
+                            return job == null ? null : job.getId();
+                        })
+                        .build());
+            }
+
+        },
+        JOB_TYPE {
+
+            @Override
+            public List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> createColumns(
+                    RouteDetailsConfig routeDetailsConfig) {
+                return Collections.singletonList(
+                        new ColumnDefinition.StatelessBuilder<RouteDeatailsRecord, String>()
+                        .withTitle("job type").withDataExtractor(r -> {
+                            AbstractJob job = r.getJob();
+                            return job == null ? null : job.getClass().getSimpleName();
+                        }).build());
+            }
+
+        },
+        JOB_PRIORITY {
+
+            @Override
+            public List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> createColumns(
+                    RouteDetailsConfig routeDetailsConfig) {
+                return routeDetailsConfig.displayMode.pickColumns(
+                        new ColumnDefinition.StatelessBuilder<RouteDeatailsRecord, Integer>()
+                        .withTitle("priority")
+                        .withCellContentFormatter(CellContentFormatter.centeredCell())
+                        .withDataExtractor(r -> {
+                            AbstractJob job = r.getJob();
+                            return job == null ? null : job.getPriority();
+                        })
+                        .build(),
+                        new ColumnDefinition.StatelessBuilder<RouteDeatailsRecord, String>()
+                        .withTitle("priority (HR)")
+                        .withCellContentFormatter(CellContentFormatter.centeredCell())
+                        .withDataExtractor(r -> {
+                            AbstractJob job = r.getJob();
+                            return job == null ? null
+                                    : PRIORITY_NAMES[job.getPriority()] + "("
+                                    + job.getPriority() + ")";
+                        })
+                        .build()
+                        );
+            }
+        },
+
+        LOCATION {
+
+            @Override
+            public List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> createColumns(
+                    RouteDetailsConfig routeDetailsConfig) {
+                return Collections.singletonList(
+                        new ColumnDefinition.StatelessBuilder<RouteDeatailsRecord, String>()
+                        .withTitle("location").withDataExtractor(r -> {
+                            TourActivity act = r.getActivity();
+                            Location loc = act.getLocation();
+                            return loc == null ? null : loc.getId();
+                        }).build());
+            }
+
+        },
+        LOAD_CHANGE {
+
+            @Override
+            public List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> createColumns(
+                    RouteDetailsConfig routeDetailsConfig) {
+                return Collections.singletonList(
+                        new ColumnDefinition.StatelessBuilder<RouteDeatailsRecord,SizeDimension>()
+                        .withTitle("load change")
+                        .withDataConverter(SIZE_DIMENSION_CONVERTER)
+                        .withDataExtractor(r -> {
+                            TourActivity act = r.getActivity();
+                            if (act instanceof Start)
+                                return r.calculateInitialLoad();
+                            else
+                                return act.getLoadChange();
+                        }).build());
+            }
+
+        },
+        ROUTE_LOAD {
+
+            @Override
+            public List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> createColumns(
+                    RouteDetailsConfig routeDetailsConfig) {
+                return Collections.singletonList(
+                        new ColumnDefinition.StatefulBuilder<RouteDeatailsRecord, SizeDimensionAggregator, SizeDimension>()
+                        .withTitle("load").withDataConverter(SIZE_DIMENSION_CONVERTER)
+                        .withDataExtractor(new StatefulDataExtractor<>((r, s) -> {
+                            TourActivity act = r.getActivity();
+                            if (act instanceof Start) {
+                                s.size = r.calculateInitialLoad();
+                            } else {
+                                s.size = s.size.add(act.getLoadChange());
+                            }
+                            return s.size;
+                        }, SizeDimensionAggregator::new, (s) -> null)).build());
+            }
+
+        },
+
+        TIME_WINDOWS {
+
+            @Override
+            public List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> createColumns(
+                    RouteDetailsConfig routeDetailsConfig) {
+                return routeDetailsConfig.displayMode.pickColumns(
+                        new ColumnDefinition.StatelessBuilder<RouteDeatailsRecord, Collection<TimeWindow>>()
+                        .withTitle("time windows").withDataConverter(
+                                tws -> routeDetailsConfig.formatTimeWindowsNumeric(tws))
+                        .withDataExtractor(r -> {
+                            TourActivity act = r.getActivity();
+                            if (act instanceof JobActivity)
+                                return ((JobActivity) act).getTimeWindows();
+                            else
+                                return null;
+                        }).build(),
+                        new ColumnDefinition.StatelessBuilder<RouteDeatailsRecord, Collection<TimeWindow>>()
+                        .withTitle("time windows (HR)").withDataConverter(
+                                tws -> routeDetailsConfig.formatTimeWindowsHuman(tws))
+                        .withDataExtractor(r -> {
+                            TourActivity act = r.getActivity();
+                            if (act instanceof JobActivity)
+                                return ((JobActivity) act).getTimeWindows();
+                            else
+                                return null;
+                        }).build()
+                        );
+            }
+
+        },
+
+        OPERATION_DURATION {
+            @Override
+            public List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> createColumns(
+                    RouteDetailsConfig routeDetailsConfig) {
+                return createDurationColumns(routeDetailsConfig, "opTime", r -> {
+                    TourActivity act = r.getActivity();
+                    return (long) act.getOperationTime();
+                });
+            }
+        },
+
+        TRAVEL_DURATION {
+            @Override
+            public List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> createColumns(
+                    RouteDetailsConfig routeDetailsConfig) {
+                return createStatefulDurationColumns(routeDetailsConfig, "travel",
+                        new StatefulDataExtractor<RouteDeatailsRecord, PrevActivityHolder, Long>(
+                                (r, s) -> {
+                                    TourActivity act = r.getActivity();
+                                    if (act instanceof Start) {
+                                        s.prevAct = null;
+                                    }
+                                    long val = (long) (r
+                                            .getTransportTime(s.prevAct));
+                                    s.prevAct = act;
+                                    return val;
+                                }, PrevActivityHolder::new, (s) -> null));
+            }
+        },
+
+        WAITING {
+            @Override
+            public List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> createColumns(
+                    RouteDetailsConfig routeDetailsConfig) {
+                return createDurationColumns(routeDetailsConfig, "waitng", (r) -> {
+                    TourActivity act = r.getActivity();
+                    if (act instanceof Start || act instanceof End)
+                        return null;
+                    else
+                        return (long) (act.getEndTime() - act.getOperationTime()
+                                - act.getArrTime());
+                });
+            }
+        },
+
+        ACTIVITY_DURATION {
+            @Override
+            public List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> createColumns(
+                    RouteDetailsConfig routeDetailsConfig) {
+                return createStatefulDurationColumns(routeDetailsConfig, "duration",
+                        new StatefulDataExtractor<RouteDeatailsRecord, PrevActivityHolder, Long>(
+                                (r, s) -> {
+                                    TourActivity act = r.getActivity();
+                                    if (act instanceof Start) {
+                                        s.prevAct = null;
+                                    }
+                                    long val = (long) (r.getTransportTime(s.prevAct)
+                                            + act.getOperationTime());
+                                    s.prevAct = act;
+                                    return val;
+                                }, PrevActivityHolder::new, (s) -> null));
+            }
+        },
+        ;
+
+        public abstract List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> createColumns(
+                RouteDetailsConfig routeDetailsConfig);
+
+        private static List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> createDurationColumns(
+                RouteDetailsConfig routeDetailsConfig, String title,
+                Function<RouteDeatailsRecord, Long> getter) {
+            return routeDetailsConfig.displayMode.pickColumns(
+                    new ColumnDefinition.StatelessBuilder<RouteDeatailsRecord, Long>()
+                            .withTitle(title).withDataExtractor(getter)
+                            .withCellContentFormatter(CellContentFormatter.rightAlignedCell())
+                            .build(),
+                    new ColumnDefinition.StatelessBuilder<RouteDeatailsRecord, Long>()
+                    .withTitle(title + " (HR)")
+                            .withCellContentFormatter(CellContentFormatter.rightAlignedCell())
+                    .withDataConverter(dur -> routeDetailsConfig.formatDurationHuman(dur))
+                    .withDataExtractor(getter).build());
+        }
+
+        private static List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> createStatefulDurationColumns(
+                RouteDetailsConfig routeDetailsConfig, String title,
+                StatefulDataExtractor<RouteDeatailsRecord, PrevActivityHolder, Long> getter) {
+            return routeDetailsConfig.displayMode.pickColumns(
+                    new ColumnDefinition.StatefulBuilder<RouteDeatailsRecord, PrevActivityHolder, Long>()
+                    .withTitle(title)
+                            .withCellContentFormatter(CellContentFormatter.rightAlignedCell())
+                    .withDataExtractor(getter)
+                    .build(),
+                    new ColumnDefinition.StatefulBuilder<RouteDeatailsRecord, PrevActivityHolder, Long>()
+                    .withTitle(title+" (HR)")
+                            .withCellContentFormatter(CellContentFormatter.rightAlignedCell())
+                    .withDataConverter(dur -> routeDetailsConfig.formatDurationHuman(dur))
+                    .withDataExtractor(getter)
+                    .build());
+        }
+    }
+
+    public static class Builder {
+        private LocalDateTime humanReadableOrigin = LocalDateTime.of(LocalDate.now(),
+                LocalTime.MIDNIGHT);
+        private DisplayMode displayMode = DisplayMode.NUMERIC;
+        private List<Column> columns;
+        private ChronoUnit lowUnit = ChronoUnit.SECONDS;
+        private ChronoUnit highUnit = ChronoUnit.HOURS;
+
+        public Builder() {
+            this.columns = new ArrayList<>();
+
+        }
+
+        public Builder withHumanReadableOrigin(LocalDateTime humanReadableOrigin) {
+            this.humanReadableOrigin = humanReadableOrigin;
+            return this;
+        }
+
+        public Builder withTimeDisplayMode(DisplayMode displayMode) {
+            this.displayMode = displayMode;
+            return this;
+        }
+
+        public Builder withLowUnit(ChronoUnit lowUnit) {
+            this.lowUnit = lowUnit;
+            return this;
+        }
+
+        public Builder withHighUnit(ChronoUnit highUnit) {
+            this.highUnit = highUnit;
+            return this;
+        }
+
+        public Builder withColumn(Column columns) {
+            this.columns.add(columns);
+            return this;
+        }
+
+        public Builder withColumns(Column... columns) {
+            for (Column c : columns) {
+                withColumn(c);
+            }
+            return this;
+        }
+
+
+        public RouteDetailsConfig build() {
+            return new RouteDetailsConfig(this);
+        }
+    }
+
+    private DisplayMode displayMode;
+    private LocalDateTime humanReadableOrigin;
+    private ChronoUnit lowUnit;
+    private ChronoUnit highUnit;
+    private List<Column> columns;
+
+    private HumanReadableTimeFormatter timeFormatter;
+    private HumanReadableDurationFormatter durationFormatter;
+
+    private RouteDetailsConfig(Builder builder) {
+        this.humanReadableOrigin = builder.humanReadableOrigin;
+        this.displayMode = builder.displayMode;
+        this.columns = builder.columns;
+        this.lowUnit = builder.lowUnit;
+        this.highUnit = builder.highUnit;
+        timeFormatter = new HumanReadableTimeFormatter(humanReadableOrigin, lowUnit);
+        durationFormatter = new HumanReadableDurationFormatter(lowUnit, highUnit);
+    }
+
+
+
+
+    public DisplayMode getDisplayMode() {
+        return displayMode;
+    }
+
+    public LocalDateTime getHumanReadableOrigin() {
+        return humanReadableOrigin;
+    }
+
+    public ChronoUnit getLowUnit() {
+        return lowUnit;
+    }
+
+    public ChronoUnit getHighUnit() {
+        return highUnit;
+    }
+
+    public HumanReadableTimeFormatter getTimeFormatter() {
+        return timeFormatter;
+    }
+
+    public HumanReadableDurationFormatter getDurationFormatter() {
+        return durationFormatter;
+    }
+
+    public List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> getColumns() {
+        List<ColumnDefinition<RouteDeatailsRecord, ?, ?>> columns = new ArrayList<>();
+        this.columns.forEach(c -> columns.addAll(c.createColumns(this)));
+        return columns;
+    }
+
+    protected String formatTimeWindowsNumeric(Collection<TimeWindow> timeWindows) {
+        if (timeWindows == null || timeWindows.isEmpty())
+            return "";
+        return timeWindows.stream().map(tw -> formatTimeWindowNumeric(tw))
+                .collect(Collectors.joining());
+    }
+
+    protected String formatTimeWindowsHuman(Collection<TimeWindow> timeWindows) {
+        if (timeWindows == null || timeWindows.isEmpty())
+            return "";
+        return timeWindows.stream().map(tw -> formatTimeWindowHuman(tw))
+                .collect(Collectors.joining());
+    }
+
+    private String formatTimeWindowNumeric(TimeWindow tw) {
+        String res = "";
+        res = "[" + (long) tw.getStart() + "-";
+        if (tw.getEnd() == Double.MAX_VALUE) {
+            res += "";
+        } else {
+            res += (long) tw.getEnd();
+        }
+        res += "]";
+        return res;
+    }
+
+    private String formatTimeWindowHuman(TimeWindow tw) {
+        String res = "";
+        res = "[" + timeFormatter.format((long) tw.getStart()) + "-";
+        if (tw.getEnd() == Double.MAX_VALUE) {
+            res += "";
+        } else {
+            res += timeFormatter.format((long) tw.getEnd());
+        }
+        res += "]";
+        return res;
+    }
+
+    protected String formatDurationHuman(Long data) {
+        return durationFormatter.convert(data);
+    }
+
+}
\ No newline at end of file
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
index d76ee5006..8a0c0d986 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
@@ -117,6 +117,7 @@ public static void print(PrintWriter out, VehicleRoutingProblem problem, Vehicle
         print(out, problem, solution, Print.VERBOSE, verbosePrintColumns);
     }
 
+
     /**
      * Prints costs and #vehicles to the given writer
      *
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter2.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter2.java
new file mode 100644
index 000000000..8f48ac90c
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter2.java
@@ -0,0 +1,225 @@
+package com.graphhopper.jsprit.core.reporting;
+
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.ComponentValue;
+import com.graphhopper.jsprit.core.algorithm.objectivefunction.RouteLevelComponentValue;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem.FleetSize;
+import com.graphhopper.jsprit.core.problem.job.Job;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
+import com.graphhopper.jsprit.core.reporting.RouteDetailsConfig.Column;
+import com.graphhopper.jsprit.core.reporting.RouteDetailsConfig.DisplayMode;
+
+import hu.vissy.texttable.BorderFormatter;
+import hu.vissy.texttable.BorderFormatter.DefaultFormatters;
+import hu.vissy.texttable.TableFormatter;
+import hu.vissy.texttable.TableFormatter.Builder;
+import hu.vissy.texttable.column.ColumnDefinition;
+import hu.vissy.texttable.contentformatter.CellContentFormatter;
+import hu.vissy.texttable.dataconverter.NumberDataConverter;
+import hu.vissy.texttable.dataextractor.StatefulDataExtractor;
+
+
+public class SolutionPrinter2 {
+
+    private static class Entry {
+        String key;
+        String value;
+
+        public Entry(String key, Object value) {
+            super();
+            this.key = key;
+            this.value = "" + value;
+        }
+
+        public String getKey() {
+            return key;
+        }
+
+        public String getValue() {
+            return value;
+        }
+    }
+
+    private static class Aggregator {
+        double sum;
+    }
+
+    // Wrapping System.out into a PrintWriter
+    private static final PrintWriter SYSTEM_OUT_AS_PRINT_WRITER = new PrintWriter(System.out);
+
+    public static void print(VehicleRoutingProblem problem,
+            VehicleRoutingProblemSolution solution) {
+        print(SYSTEM_OUT_AS_PRINT_WRITER, problem, solution);
+    }
+
+    public static void print(PrintWriter out, VehicleRoutingProblem problem,
+            VehicleRoutingProblemSolution solution) {
+        printProblemTable(out, problem);
+        printSolutionSummary(out, solution);
+        printCostDetails(out, solution);
+        printRouteDetails(out, problem, solution);
+        out.flush();
+    }
+
+
+
+    private static void printProblemTable(PrintWriter out, VehicleRoutingProblem problem) {
+        TableFormatter<Entry> problemTableDef = createKeyValueTable("Problem");
+
+        List<Entry> data = new ArrayList<>();
+        data.add(new Entry("fleetsize", problem.getFleetSize()));
+        data.add(new Entry("maxNoVehicles", problem.getFleetSize() == FleetSize.FINITE
+                ? problem.getVehicles().size() : "unlimited"));
+        data.add(null);
+        data.add(new Entry("noJobs", problem.getJobs().values().size()));
+        for (Map.Entry<Class<? extends Job>, Long> jc : getNuOfJobs(problem).entrySet()) {
+            data.add(new Entry("   " + jc.getKey().getSimpleName(), jc.getValue()));
+        }
+
+        out.println(problemTableDef.apply(data));
+    }
+
+    private static void printSolutionSummary(PrintWriter out,
+            VehicleRoutingProblemSolution solution) {
+        TableFormatter<Entry> problemTableDef = createKeyValueTable("Solution");
+
+        List<Entry> data = new ArrayList<>();
+        data.add(new Entry("costs", String.format("%6.2f", solution.getCost()).trim()));
+        data.add(new Entry("noVehicles", solution.getRoutes().size()));
+        data.add(new Entry("unassignedJobs", solution.getUnassignedJobs().size()));
+
+        out.println(problemTableDef.apply(data));
+    }
+
+
+    private static void printCostDetails(PrintWriter out, VehicleRoutingProblemSolution solution) {
+        printCostComponents(out, solution);
+        printPerRouteCosts(out, solution);
+    }
+
+    private static void printCostComponents(PrintWriter out,
+            VehicleRoutingProblemSolution solution) {
+        TableFormatter<ComponentValue> tableDef = new TableFormatter.Builder<ComponentValue>()
+                .withBorderFormatter(new BorderFormatter.Builder(
+                        DefaultFormatters.ASCII_LINEDRAW).build())
+                .withHeading("Cost components")
+                .withColumn(ColumnDefinition.<ComponentValue, String>createSimpleStateless(
+                        "component id", c -> c.getKey()))
+                .withColumn(ColumnDefinition.<ComponentValue, Double>createSimpleStateless(
+                        "value", c -> c.getValue()))
+                .withColumn(ColumnDefinition.<ComponentValue, Double>createSimpleStateless(
+                        "weight", c -> c.getWeight()))
+                .withColumn(ColumnDefinition.<ComponentValue, Double>createSimpleStateless(
+                        "weighted value", c -> c.getWeightedValue()))
+                .build();
+
+        out.println(tableDef.apply(solution.getDetailedCost()));
+    }
+
+    private static void printPerRouteCosts(PrintWriter out,
+            VehicleRoutingProblemSolution solution) {
+
+        Builder<ComponentValue> builder = new TableFormatter.Builder<ComponentValue>()
+                .withBorderFormatter(new BorderFormatter.Builder(
+                        DefaultFormatters.ASCII_LINEDRAW).build())
+                .withHeading("Route level costs (weighted)")
+                .withShowAggregation(true)
+                .withColumn(new ColumnDefinition.StatelessBuilder<ComponentValue, String>()
+                        .withTitle("component id").withDataExtractor(c -> c.getKey())
+                        .withAggregateRowConstant("Total").build());
+
+        for (VehicleRoute r : solution.getRoutes()) {
+            builder.withColumn(
+                    new ColumnDefinition.StatefulBuilder<ComponentValue, Aggregator, Double>()
+                    .withTitle("Route " + r.getId())
+                    .withCellContentFormatter(CellContentFormatter.rightAlignedCell())
+                    .withDataConverter(NumberDataConverter.defaultDoubleFormatter())
+                    .withDataExtractor(new StatefulDataExtractor<>((cv, agg) -> {
+                        Double val = ((RouteLevelComponentValue) cv)
+                                .getRouteValue(r.getId()).orElse(null);
+                        if (val != null) {
+                            agg.sum += val;
+                        }
+                        return val;
+                    }, Aggregator::new, (agg) -> agg.sum))
+                    .build());
+        }
+
+
+        TableFormatter<ComponentValue> tableDef = builder.build();
+
+        out.println(tableDef.apply(solution.getDetailedCost().stream()
+                .filter(cv -> cv instanceof RouteLevelComponentValue)
+                .collect(Collectors.toList())));
+
+    }
+
+    private static TableFormatter<Entry> createKeyValueTable(String heading) {
+        TableFormatter<Entry> problemTableDef = new TableFormatter.Builder<Entry>()
+                .withBorderFormatter(new BorderFormatter.Builder(
+                        DefaultFormatters.ASCII_LINEDRAW).build())
+                .withHeading(heading)
+                .withColumn(ColumnDefinition.<Entry, String>createSimpleStateless("key",
+                        en -> en.getKey()))
+                .withColumn(ColumnDefinition.<Entry, String>createSimpleStateless("value",
+                        en -> en.getValue()))
+                .build();
+        return problemTableDef;
+    }
+
+    private static Map<Class<? extends Job>, Long> getNuOfJobs(VehicleRoutingProblem problem) {
+        return problem.getJobs().values().stream().map(j -> (Class<? extends Job>) j.getClass())
+                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
+    }
+
+    private static void printRouteDetails(PrintWriter out, VehicleRoutingProblem problem,
+            VehicleRoutingProblemSolution solution) {
+        printUnassignedJobs(out, solution);
+        printRouteData(out, problem, solution);
+    }
+
+    private static void printUnassignedJobs(PrintWriter out,
+            VehicleRoutingProblemSolution solution) {
+        if (solution.getUnassignedJobs().isEmpty())
+            return;
+    }
+
+    private static void printRouteData(PrintWriter out, VehicleRoutingProblem problem,
+            VehicleRoutingProblemSolution solution) {
+        Builder<RouteDeatailsRecord> builder = new TableFormatter.Builder<RouteDeatailsRecord>()
+                .withBorderFormatter(
+                        new BorderFormatter.Builder(DefaultFormatters.ASCII_LINEDRAW).build())
+                .withHeading("Route details");
+
+        new RouteDetailsConfig.Builder().withTimeDisplayMode(DisplayMode.BOTH)
+        .withColumns(Column.values()).build().getColumns()
+        .forEach(c -> builder.withColumn(c));
+
+        TableFormatter<RouteDeatailsRecord> tableDef = builder.build();
+
+        List<RouteDeatailsRecord> data = new ArrayList<>();
+        for (VehicleRoute route : new ArrayList<>(solution.getRoutes())) {
+            if (!data.isEmpty()) {
+                data.add(null);
+            }
+            data.add(new RouteDeatailsRecord(route, route.getStart(), problem));
+
+            for (TourActivity act : route.getActivities()) {
+                data.add(new RouteDeatailsRecord(route, act, problem));
+            }
+            data.add(new RouteDeatailsRecord(route, route.getEnd(), problem));
+        }
+
+        out.println(tableDef.apply(data));
+    }
+}
+
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/columndefinition/SolutionPrintColumnLists.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/columndefinition/SolutionPrintColumnLists.java
index 133768628..0634f6b65 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/columndefinition/SolutionPrintColumnLists.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/columndefinition/SolutionPrintColumnLists.java
@@ -153,7 +153,7 @@
      * @return The column list containing the predefined columns.
      */
     public static PrinterColumnList<RoutePrinterContext> getHumanReadable(PredefinedList listType,
-                    HumanReadableTimeFormatter timeFormatter) {
+            HumanReadableTimeFormatter timeFormatter) {
         return getList(listType, true, timeFormatter);
     }
 
@@ -169,7 +169,7 @@
      * @return The generated column list.
      */
     private static PrinterColumnList<RoutePrinterContext> getList(PredefinedList listType, boolean humanReadable,
-                    HumanReadableTimeFormatter timeFormatter) {
+            HumanReadableTimeFormatter timeFormatter) {
         PrinterColumnList<RoutePrinterContext> res = new PrinterColumnList<>();
 
         for (Class<? extends AbstractPrinterColumn<RoutePrinterContext, ?, ?>> c : COLUMNS.get(listType)) {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/.gitignore b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/.gitignore
new file mode 100644
index 000000000..b5a5a4c42
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/route/.gitignore
@@ -0,0 +1 @@
+/copy/
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithDeliveries_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithDeliveries_IT.java
index 4850b7bd1..1405a9de3 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithDeliveries_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithDeliveries_IT.java
@@ -26,6 +26,10 @@
 import com.graphhopper.jsprit.core.algorithm.box.Jsprit;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+import com.graphhopper.jsprit.core.reporting.SolutionPrinter;
+import com.graphhopper.jsprit.core.reporting.SolutionPrinter2;
+import com.graphhopper.jsprit.core.reporting.columndefinition.SolutionPrintColumnLists;
+import com.graphhopper.jsprit.core.reporting.columndefinition.SolutionPrintColumnLists.PredefinedList;
 import com.graphhopper.jsprit.core.util.ChristofidesReader;
 import com.graphhopper.jsprit.core.util.JobType;
 import com.graphhopper.jsprit.core.util.Solutions;
@@ -39,8 +43,18 @@ public void whenSolvingVRPNC1withDeliveriesWithJsprit_solutionsMustNoBeWorseThan
         VehicleRoutingProblem vrp = vrpBuilder.build();
         VehicleRoutingAlgorithm vra = Jsprit.createAlgorithm(vrp);
         Collection<VehicleRoutingProblemSolution> solutions = vra.searchSolutions();
-        assertEquals(530.0, Solutions.bestOf(solutions).getCost(), 50.0);
-        assertEquals(5, Solutions.bestOf(solutions).getRoutes().size());
+        VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
+        assertEquals(530.0, bestSolution.getCost(), 50.0);
+        assertEquals(5, bestSolution.getRoutes().size());
+        SolutionPrinter.print(vrp, bestSolution,
+                        SolutionPrintColumnLists.getHumanReadable(PredefinedList.VERBOSE));
+        SolutionPrinter.printCostDetails(vrp, bestSolution);
+        try {
+            SolutionPrinter2.print(vrp, bestSolution);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
     }
 
 }
+
diff --git a/pom.xml b/pom.xml
index 5a4e63b37..21e142ec4 100644
--- a/pom.xml
+++ b/pom.xml
@@ -78,6 +78,7 @@
         <logger.version>1.7.21</logger.version>
         <maven.javadoc.failOnError>false</maven.javadoc.failOnError>
         <maven.version>3.3.0</maven.version>
+        <ptt.version>[1,2)</ptt.version>
     </properties>
 
     <build>
@@ -176,6 +177,13 @@
             <version>${mockito.version}</version>
             <scope>test</scope>
         </dependency>
+        
+        <dependency>
+ 			<groupId>hu.vissy.plain-text-table</groupId>
+ 			<artifactId>ptt-core</artifactId>
+ 			<version>${ptt.version}</version>
+		</dependency>
+        
 
     </dependencies>
 
