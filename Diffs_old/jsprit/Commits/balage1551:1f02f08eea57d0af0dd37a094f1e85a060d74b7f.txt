diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/SizeDimension.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/SizeDimension.java
index 4ad2bceec..2bb5ff78e 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/SizeDimension.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/SizeDimension.java
@@ -72,6 +72,19 @@ public static SizeDimension copyOf(SizeDimension sizeDimension) {
         return new SizeDimension(sizeDimension);
     }
 
+    public static SizeDimension of(int value) {
+        return Builder.newInstance().addDimension(0, value).build();
+    }
+
+    public static SizeDimension of(int value, int value2) {
+        return Builder.newInstance().addDimension(0, value).addDimension(1, value2).build();
+    }
+
+    public static SizeDimension of(int value, int value2, int value3) {
+        return Builder.newInstance().addDimension(0, value).addDimension(1, value2)
+                        .addDimension(2, value3).build();
+    }
+
     /**
      * Builder that builds SizeDimension
      *
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/ReturnedShipment.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/ReturnedShipment.java
index f7cd1b81b..6dd23cdd4 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/ReturnedShipment.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/ReturnedShipment.java
@@ -17,9 +17,13 @@
  */
 package com.graphhopper.jsprit.core.problem.job;
 
-import com.graphhopper.jsprit.core.problem.SizeDimension;
 import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.*;
+import com.graphhopper.jsprit.core.problem.SizeDimension;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.ExchangeActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindowsImpl;
 
 
 /**
@@ -30,9 +34,7 @@
  */
 public final class ReturnedShipment extends Shipment {
 
-    public static final String ACTIVITY_NAME_PICKUP = "pickup";
-    public static final String ACTIVITY_NAME_DELIVERY = "delivery";
-    public static final String ACTIVITY_NAME_BACKHAUL = "backhaul";
+    public static final String BACKHAUL_ACTIVITY_NAME = "backhaul";
 
     /**
      * Builder that builds the shipment.
@@ -201,43 +203,41 @@ protected ReturnedShipment createInstance() {
     protected void createActivities(JobBuilder<?, ?> builder) {
         Builder shipmentBuilder = (Builder) builder;
         JobActivityList list = new SequentialJobActivityList(this);
-        list.addActivity(new PickupActivity(this, ACTIVITY_NAME_PICKUP,
-            shipmentBuilder.getPickupLocation(),
-            shipmentBuilder.getPickupServiceTime(), shipmentBuilder.getCapacity(),
-            shipmentBuilder.getPickupTimeWindows().getTimeWindows()));
-        list.addActivity(new ExchangeActivity(this, ACTIVITY_NAME_DELIVERY,
-            shipmentBuilder.getDeliveryLocation(),
-            shipmentBuilder.getDeliveryServiceTime(),
-            shipmentBuilder.getBackhaulCapacity()
-                .subtract(shipmentBuilder.getCapacity()),
-            shipmentBuilder.getDeliveryTimeWindows().getTimeWindows()));
-        list.addActivity(new DeliveryActivity(this, ACTIVITY_NAME_BACKHAUL,
-            shipmentBuilder.getBackhaulLocation(),
-            shipmentBuilder.getBackhaulServiceTime(),
-            shipmentBuilder.getBackhaulCapacity(),
-            shipmentBuilder.getBackhaulTimeWindows().getTimeWindows()));
+        list.addActivity(new PickupActivity(this, PICKUP_ACTIVITY_NAME,
+                        shipmentBuilder.getPickupLocation(),
+                        shipmentBuilder.getPickupServiceTime(), shipmentBuilder.getCapacity(),
+                        shipmentBuilder.getPickupTimeWindows().getTimeWindows()));
+        list.addActivity(new ExchangeActivity(this, DELIVERY_ACTIVITY_NAME,
+                        shipmentBuilder.getDeliveryLocation(),
+                        shipmentBuilder.getDeliveryServiceTime(),
+                        shipmentBuilder.getBackhaulCapacity()
+                        .subtract(shipmentBuilder.getCapacity()),
+                        shipmentBuilder.getDeliveryTimeWindows().getTimeWindows()));
+        list.addActivity(new DeliveryActivity(this, BACKHAUL_ACTIVITY_NAME,
+                        shipmentBuilder.getBackhaulLocation(),
+                        shipmentBuilder.getBackhaulServiceTime(),
+                        shipmentBuilder.getBackhaulCapacity(),
+                        shipmentBuilder.getBackhaulTimeWindows().getTimeWindows()));
         setActivities(list);
     }
 
-    // TODO: RENAME WHEN SHIPMENT IS RETURNING THE SAME TYPE OF ACTIVIT
-    public PickupActivity getPickupActivityTO_BE_RENAMED_LATER() {
+    @Override
+    public PickupActivity getPickupActivity() {
         return (PickupActivity) getActivityList()
-            .findByType(ACTIVITY_NAME_PICKUP)
-            .get();
+                        .findByType(PICKUP_ACTIVITY_NAME)
+                        .get();
     }
 
-    // TODO: RENAME WHEN SHIPMENT IS RETURNING THE SAME TYPE OF ACTIVIT
-    public ExchangeActivity getDeliveryActivityTO_BE_RENAMED_LATER() {
+    public ExchangeActivity getExchangeActivity() {
         return (ExchangeActivity) getActivityList()
-            .findByType(ACTIVITY_NAME_DELIVERY)
-            .get();
+                        .findByType(DELIVERY_ACTIVITY_NAME)
+                        .get();
     }
 
-    public DeliveryActivity getBackhaulActivityTO_BE_RENAMED_LATER() {
+    public DeliveryActivity getBackhaulActivity() {
         return (DeliveryActivity) getActivityList()
-            .findByType(ACTIVITY_NAME_BACKHAUL)
-            .get();
+                        .findByType(BACKHAUL_ACTIVITY_NAME)
+                        .get();
     }
 
-
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
index 42790b724..cfb07e966 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
@@ -52,6 +52,9 @@
  */
 public class Shipment extends AbstractJob {
 
+    public static final String DELIVERY_ACTIVITY_NAME = "deliverShipment";
+    public static final String PICKUP_ACTIVITY_NAME = "pickupShipment";
+
     /**
      * Builder that builds the shipment.
      *
@@ -297,11 +300,11 @@ protected Shipment createInstance() {
     protected void createActivities(JobBuilder<?, ?> builder) {
         Builder shipmentBuilder = (Builder) builder;
         JobActivityList list = new SequentialJobActivityList(this);
-        list.addActivity(new PickupActivity(this, "pickupShipment",
+        list.addActivity(new PickupActivity(this, PICKUP_ACTIVITY_NAME,
                         shipmentBuilder.getPickupLocation(),
                         shipmentBuilder.getPickupServiceTime(), shipmentBuilder.getCapacity(),
                         shipmentBuilder.getPickupTimeWindows().getTimeWindows()));
-        list.addActivity(new DeliveryActivity(this, "deliverShipment",
+        list.addActivity(new DeliveryActivity(this, DELIVERY_ACTIVITY_NAME,
                         shipmentBuilder.getDeliveryLocation(),
                         shipmentBuilder.getDeliveryServiceTime(),
                         shipmentBuilder.getCapacity().invert(),
@@ -311,11 +314,11 @@ protected void createActivities(JobBuilder<?, ?> builder) {
     }
 
     public PickupActivity getPickupActivity() {
-        return (PickupActivity) getActivityList().findByType("pickupShipment").get();
+        return (PickupActivity) getActivityList().findByType(PICKUP_ACTIVITY_NAME).get();
     }
 
     public DeliveryActivity getDeliveryActivity() {
-        return (DeliveryActivity) getActivityList().findByType("deliverShipment").get();
+        return (DeliveryActivity) getActivityList().findByType(DELIVERY_ACTIVITY_NAME).get();
     }
 
     // =================== DEPRECATED GETTERS
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/DynamicTableDefinition.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/DynamicTableDefinition.java
new file mode 100644
index 000000000..9bd5b2716
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/DynamicTableDefinition.java
@@ -0,0 +1,387 @@
+package com.graphhopper.jsprit.core.reporting;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * @author balage
+ */
+public class DynamicTableDefinition {
+
+    public static interface ColumnType<T> {
+        public String convert(Object data);
+
+        public boolean accepts(Object data);
+    }
+
+    public static abstract class AbstractColumnType<T> implements ColumnType<T> {
+
+        private String nullValue = "";
+
+
+        public AbstractColumnType() {
+            super();
+        }
+
+        public AbstractColumnType(String nullValue) {
+            super();
+            this.nullValue = nullValue;
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public String convert(Object data) {
+            if (data == null) {
+                return nullValue;
+            } else {
+                if (accepts(data)) {
+                    return convertNotNull((T) data);
+                } else {
+                    throw new ClassCastException();
+                }
+            }
+        }
+
+        protected abstract String convertNotNull(T data);
+    }
+
+    public static class StringColumnType extends AbstractColumnType<Object> {
+
+        public StringColumnType() {
+            super();
+        }
+
+        public StringColumnType(String nullValue) {
+            super(nullValue);
+        }
+
+        @Override
+        protected String convertNotNull(Object data) {
+            return data.toString();
+        }
+
+        @Override
+        public boolean accepts(Object data) {
+            return true;
+        }
+
+    }
+
+    public static class IntColumnType extends AbstractColumnType<Integer> {
+
+        public IntColumnType() {
+            super();
+        }
+
+        public IntColumnType(String nullValue) {
+            super(nullValue);
+        }
+
+        @Override
+        protected String convertNotNull(Integer data) {
+            return data.toString();
+        }
+
+        @Override
+        public boolean accepts(Object data) {
+            return data instanceof Integer;
+        }
+
+    }
+
+    public static class LongColumnType extends AbstractColumnType<Long> {
+
+        public LongColumnType() {
+            super();
+        }
+
+        public LongColumnType(String nullValue) {
+            super(nullValue);
+        }
+
+        @Override
+        protected String convertNotNull(Long data) {
+            return data.toString();
+        }
+
+        @Override
+        public boolean accepts(Object data) {
+            return data instanceof Long;
+        }
+
+
+    }
+
+    public static class DoubleColumnType extends AbstractColumnType<Double> {
+
+        private int decimals = 2;
+
+        public DoubleColumnType() {
+            super();
+        }
+
+        public DoubleColumnType(String nullValue) {
+            super(nullValue);
+        }
+
+        public DoubleColumnType(int decimals) {
+            super();
+            this.decimals = decimals;
+        }
+
+        public DoubleColumnType(String nullValue, int decimals) {
+            super(nullValue);
+            this.decimals = decimals;
+        }
+
+        @Override
+        protected String convertNotNull(Double data) {
+            return String.format("%50." + decimals + "f", data).trim();
+        }
+
+        @Override
+        public boolean accepts(Object data) {
+            return data instanceof Double;
+        }
+
+
+    }
+
+
+    public static class BooleanColumnType extends AbstractColumnType<Boolean> {
+        private String trueValue = "true";
+        private String falseValue = "false";
+
+        public BooleanColumnType() {
+            super();
+        }
+
+        public BooleanColumnType(String nullValue) {
+            super(nullValue);
+        }
+
+        public BooleanColumnType(String trueValue, String falseValue) {
+            super();
+            this.trueValue = trueValue;
+            this.falseValue = falseValue;
+        }
+
+        public BooleanColumnType(String trueValue, String falseValue, String nullValue) {
+            super(nullValue);
+            this.trueValue = trueValue;
+            this.falseValue = falseValue;
+        }
+
+        @Override
+        protected String convertNotNull(Boolean data) {
+            return data ? trueValue : falseValue;
+        }
+
+        @Override
+        public boolean accepts(Object data) {
+            return data instanceof Boolean;
+        }
+    }
+
+    public enum Alignment {
+        LEFT {
+
+            @Override
+            public String align(String data, int width) {
+                if (data.length() > width) {
+                    return data.substring(0, width);
+                }
+                return String.format("%1$-" + width + "s", data);
+            }
+
+        }, RIGHT {
+
+            @Override
+            public String align(String data, int width) {
+                if (data.length() > width) {
+                    return data.substring(0, width);
+                }
+                return String.format("%1$" + width + "s", data);
+            }
+
+        }, CENTER {
+            @Override
+            public String align(String data, int width) {
+                if (data.length() > width) {
+                    return data.substring(0, width);
+                }
+                int leftPad = (width - data.length())/2;
+                return LEFT.align(RIGHT.align(data, width-leftPad), width);
+            }
+        };
+
+        public abstract String align(String data, int width);
+    }
+
+    public static class ColumnDefinition {
+
+        public static class Builder {
+            private ColumnType<?> type;
+            private String title;
+            private int minWidth = 0;
+            private int maxWidth = Integer.MAX_VALUE;
+            private Alignment alignment = Alignment.LEFT;
+
+            public Builder(ColumnType<?> type, String title) {
+                super();
+                this.type = type;
+                this.title = title;
+            }
+
+            public Builder withMinWidth(int minWidth) {
+                this.minWidth = minWidth;
+                return this;
+            }
+
+            public Builder withMaxWidth(int maxWidth) {
+                this.maxWidth = maxWidth;
+                return this;
+            }
+
+            public Builder withAlignment(Alignment alignment) {
+                this.alignment = alignment;
+                return this;
+            }
+
+            public ColumnDefinition build() {
+                return new ColumnDefinition(this);
+            }
+
+        }
+
+        private ColumnType<?> type;
+        private String title;
+        private int minWidth = 0;
+        private int maxWidth = Integer.MAX_VALUE;
+        private Alignment alignment = Alignment.LEFT;
+
+        private ColumnDefinition(Builder builder) {
+            type = builder.type;
+            title = builder.title;
+            minWidth = builder.minWidth;
+            maxWidth = builder.maxWidth;
+            alignment = builder.alignment;
+        }
+
+        public ColumnType<?> getType() {
+            return type;
+        }
+
+        public String getTitle() {
+            return title;
+        }
+
+        public int getMinWidth() {
+            return minWidth;
+        }
+
+        public int getMaxWidth() {
+            return maxWidth;
+        }
+
+        public Alignment getAlignment() {
+            return alignment;
+        }
+
+    }
+
+
+    public static class Builder {
+        private char corner = '+';
+        private char vertical = '|';
+        private char horizontal = '-';
+
+        private String heading = null;
+        private List<ColumnDefinition> columns = new ArrayList<>();
+
+        private int padding = 1;
+
+        public Builder withCorner(char corner) {
+            this.corner = corner;
+            return this;
+        }
+
+        public Builder withVertical(char vertical) {
+            this.vertical = vertical;
+            return this;
+        }
+
+        public Builder withHorizontal(char horizontal) {
+            this.horizontal = horizontal;
+            return this;
+        }
+
+        public Builder withHeading(String heading) {
+            this.heading = heading;
+            return this;
+        }
+
+        public Builder addColumn(ColumnDefinition column) {
+            columns.add(column);
+            return this;
+        }
+
+        public Builder withPadding(int padding) {
+            this.padding = Math.max(0, padding);
+            return this;
+        }
+
+        public DynamicTableDefinition build() {
+            return new DynamicTableDefinition(this);
+        }
+    }
+
+
+    private char corner = '+';
+    private char vertical = '|';
+    private char horizontal = '-';
+
+    private String heading = null;
+    private List<ColumnDefinition> columns = new ArrayList<>();
+
+    private int padding = 1;
+
+    private DynamicTableDefinition(Builder builder) {
+        corner = builder.corner;
+        vertical = builder.vertical;
+        horizontal = builder.horizontal;
+        heading = builder.heading;
+        columns = Collections.unmodifiableList(builder.columns);
+        padding = builder.padding;
+    }
+
+    public char getCorner() {
+        return corner;
+    }
+
+    public char getVertical() {
+        return vertical;
+    }
+
+    public char getHorizontal() {
+        return horizontal;
+    }
+
+    public String getHeading() {
+        return heading;
+    }
+
+    public List<ColumnDefinition> getColumns() {
+        return columns;
+    }
+
+    public int getPadding() {
+        return padding;
+    }
+
+    public int size() {
+        return columns.size();
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/DynamicTablePrinter.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/DynamicTablePrinter.java
new file mode 100644
index 000000000..59abfdfb1
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/DynamicTablePrinter.java
@@ -0,0 +1,210 @@
+package com.graphhopper.jsprit.core.reporting;
+
+import java.nio.CharBuffer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.IntStream;
+
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.Alignment;
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.ColumnDefinition;
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.DoubleColumnType;
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.StringColumnType;
+
+/**
+ * @author balage
+ */
+public class DynamicTablePrinter {
+
+    public class TableRow {
+        private String row[] = new String[tableDef.size()];
+        private int lastIndex = 0;
+
+        public TableRow() {
+            super();
+            Arrays.fill(row, "");
+        }
+
+        public TableRow set(int index, Object data) {
+            if (index < 0 || index >= row.length) {
+                throw new IndexOutOfBoundsException("Invalid index: " + index);
+            }
+            if (data != null) {
+                if (!tableDef.getColumns().get(index).getType().accepts(data)) {
+                    throw new ClassCastException("Cannot assign " + data.getClass().getSimpleName()
+                                    + " to " + tableDef.getColumns().get(index).getType().getClass()
+                                    .getSimpleName()
+                                    + "( index: " + index + ")");
+                }
+            }
+            String val = tableDef.getColumns().get(index).getType().convert(data);
+
+            row[index] = val;
+            return this;
+        }
+
+        public TableRow add(Object data) {
+            return set(lastIndex++, data);
+        }
+
+        public TableRow add(int data) {
+            return add(new Integer(data));
+        }
+
+        public TableRow add(long data) {
+            return add(new Long(data));
+        }
+
+        public TableRow add(double data) {
+            return add(new Double(data));
+        }
+
+        public TableRow add(boolean data) {
+            return add(Boolean.valueOf(data));
+        }
+
+        public String get(int index) {
+            if (index < 0 || index >= row.length) {
+                throw new IndexOutOfBoundsException("Invalid index: " + index);
+            }
+            return row[index];
+        }
+    }
+
+    private class Separator extends TableRow {
+    }
+
+    DynamicTableDefinition tableDef;
+
+    List<TableRow> rows = new ArrayList<>();
+
+    public DynamicTablePrinter(DynamicTableDefinition tableDef) {
+        this.tableDef = tableDef;
+    }
+
+    public TableRow addRow() {
+        TableRow row = new TableRow();
+        rows.add(row);
+        return row;
+    }
+
+    public void addSeparator() {
+        rows.add(new Separator());
+    }
+
+
+    private String repeat(char c, int w) {
+        return CharBuffer.allocate(w).toString().replace('\0', c);
+    }
+
+    public String print() {
+        StringBuilder sb = new StringBuilder();
+        int[] colWidth = calculateWidthInfo();
+        int totalWidth = colWidth.length * (tableDef.getPadding() * 2 + 1) + 1;
+        for (int w : colWidth) {
+            totalWidth += w;
+        }
+
+        char corner = tableDef.getCorner();
+        char horizontal = tableDef.getHorizontal();
+        char vertical = tableDef.getVertical();
+        int padding = tableDef.getPadding();
+
+        String paddingChars = repeat(' ', padding);
+
+        StringBuilder sbSep = new StringBuilder();
+        sbSep.append(corner);
+        for (int w : colWidth) {
+            sbSep.append(repeat(horizontal, w + 2 * padding)).append(corner);
+        }
+        sbSep.append("\n");
+        String separatorLine = sbSep.toString();
+
+        if (tableDef.getHeading() != null) {
+            sb.append(corner).append(repeat(horizontal, totalWidth - 2)).append(corner)
+            .append("\n");
+            sb.append(vertical).append(paddingChars)
+            .append(Alignment.LEFT.align(tableDef.getHeading(),
+                            totalWidth - 2 * padding - 2))
+            .append(paddingChars)
+            .append(vertical)
+            .append("\n");
+        }
+
+        sb.append(separatorLine);
+        sb.append(vertical);
+        for (int i = 0; i < tableDef.size(); i++) {
+            ColumnDefinition cd = tableDef.getColumns().get(i);
+            sb.append(paddingChars).append(Alignment.LEFT.align(cd.getTitle(), colWidth[i]))
+            .append(paddingChars).append(vertical);
+        }
+        sb.append("\n");
+        sb.append(separatorLine);
+
+        for(TableRow row : rows) {
+            if (row instanceof Separator) {
+                sb.append(separatorLine);
+            } else {
+                sb.append(vertical);
+                for (int i = 0; i < tableDef.size(); i++) {
+                    ColumnDefinition cd = tableDef.getColumns().get(i);
+                    sb.append(paddingChars).append(cd.getAlignment().align(row.get(i), colWidth[i]))
+                    .append(paddingChars).append(vertical);
+                }
+                sb.append("\n");
+            }
+        }
+        sb.append(separatorLine);
+
+        return sb.toString();
+    }
+
+    private int[] calculateWidthInfo() {
+        int colWidth[] = new int[tableDef.size()];
+        IntStream.range(0, tableDef.size()).forEach(i -> {
+            int max = rows.stream()
+                            .filter(r -> r instanceof TableRow)
+                            .map(r -> r.get(i))
+                            .filter(d -> d != null)
+                            .mapToInt(d -> d.length())
+                            .max().orElse(0);
+            ColumnDefinition colDef = tableDef.getColumns().get(i);
+            colWidth[i] = Math.max(colDef.getTitle().length(),
+                            Math.max(colDef.getMinWidth(), Math.min(colDef.getMaxWidth(), max)));
+        });
+        return colWidth;
+    }
+
+    public static void main(String[] args) {
+        DynamicTableDefinition td = new DynamicTableDefinition.Builder()
+                        // .withHeading("Test")
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "string")
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(),
+                                        "right-string")
+                                        .withAlignment(Alignment.CENTER).build())
+                        .addColumn(new ColumnDefinition.Builder(new DoubleColumnType(),
+                                        "double")
+                                        .withMinWidth(10)
+                                        .withAlignment(Alignment.RIGHT).build())
+                        .build();
+
+        DynamicTablePrinter p = new DynamicTablePrinter(td);
+
+        TableRow r;
+        r = p.addRow();
+        r.add("apple");
+        r.add("one");
+        r.add(Math.PI);
+        r = p.addRow();
+        r.add("banana");
+        r.add("two");
+        r.add(2d);
+        p.addSeparator();
+        r = p.addRow();
+        r.add("cherry");
+        r.add("four");
+
+        System.out.println(p.print());
+    }
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
index 52088d94b..35669a99c 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
@@ -17,6 +17,16 @@
  */
 package com.graphhopper.jsprit.core.reporting;
 
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.SizeDimension;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.job.Job;
@@ -25,13 +35,11 @@
 import com.graphhopper.jsprit.core.problem.solution.route.activity.AbstractActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-
-import java.io.PrintWriter;
-import java.nio.CharBuffer;
-import java.util.*;
-import java.util.function.Function;
-import java.util.regex.Pattern;
-import java.util.stream.Collectors;
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.Alignment;
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.ColumnDefinition;
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.IntColumnType;
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.LongColumnType;
+import com.graphhopper.jsprit.core.reporting.DynamicTableDefinition.StringColumnType;
 
 
 /**
@@ -90,29 +98,6 @@ public static void print(VehicleRoutingProblem problem, VehicleRoutingProblemSol
         SYSTEM_OUT_AS_PRINT_WRITER.flush();
     }
 
-    protected static String drawLineBase(String pattern, int count) {
-        Object[] par = new Object[count];
-        Arrays.fill(par, "");
-        String text = String.format(pattern, par);
-        return text;
-    }
-
-    protected static String drawLine(String pattern, int count) {
-        String text = drawLineBase(pattern, count);
-        return text.replaceAll(" ", "-").replaceAll(Pattern.quote("|"), "+");
-    }
-
-
-    protected static String drawHeading(String pattern, int count, String text) {
-        String base = drawLineBase(pattern, count).trim();
-        int internalWidth = base.lastIndexOf('|') - base.indexOf('|') - 1;
-        if (text == null) {
-            return "+" + CharBuffer.allocate(internalWidth).toString().replace('\0', '-') + "+\n";
-        } else {
-            return "| " + String.format("%-" + (internalWidth - 2) + "s", text) + " |\n";
-        }
-    }
-
     /**
      * Prints costs and #vehicles to the given writer
      *
@@ -120,30 +105,39 @@ protected static String drawHeading(String pattern, int count, String text) {
      * @param solution the solution to be printed
      */
     public static void print(PrintWriter out, VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution, Print print) {
-        String leftAlign = "| %-30s | %-8s |%n";
-
-        out.printf(drawHeading(leftAlign, 2, null));
-        out.printf(drawHeading(leftAlign, 2, "problem"));
-        out.printf(drawLine(leftAlign, 2));
-        out.format(leftAlign, "indicator", "value");
-        out.printf(drawLine(leftAlign, 2));
-
-        out.format(leftAlign, "noJobs", problem.getJobs().values().size());
-        getNuOfJobs(problem).entrySet().forEach(en -> out.format(leftAlign, "   " + en.getKey().getSimpleName(), en.getValue()));
-        out.format(leftAlign, "fleetsize", problem.getFleetSize().toString());
-        out.printf(drawLine(leftAlign, 2));
-
-
-        String leftAlignSolution = "| %-13s | %-40s |%n";
-        out.printf(drawHeading(leftAlignSolution, 2, null));
-        out.printf(drawHeading(leftAlignSolution, 2, "solution"));
-        out.printf(drawLine(leftAlignSolution, 2));
-        out.format(leftAlignSolution, "indicator", "value");
-        out.printf(drawLine(leftAlignSolution, 2));
-        out.format(leftAlignSolution, "costs", solution.getCost());
-        out.format(leftAlignSolution, "noVehicles", solution.getRoutes().size());
-        out.format(leftAlignSolution, "unassgndJobs", solution.getUnassignedJobs().size());
-        out.printf(drawLine(leftAlignSolution, 2));
+
+        DynamicTableDefinition problemTableDef = new DynamicTableDefinition.Builder()
+                        .withHeading("Problem")
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "indicator")
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "value")
+                                        .build())
+                        .build();
+
+        DynamicTablePrinter problemTablePrinter = new DynamicTablePrinter(problemTableDef);
+        problemTablePrinter.addRow().add("fleetsize").add(problem.getFleetSize());
+        problemTablePrinter.addSeparator();
+        problemTablePrinter.addRow().add("noJobs").add(problem.getJobs().values().size());
+        for (Entry<Class<? extends Job>, Long> jc : getNuOfJobs(problem).entrySet()) {
+            problemTablePrinter.addRow().add("   " + jc.getKey().getSimpleName())
+            .add(jc.getValue());
+        }
+        out.println(problemTablePrinter.print());
+
+        DynamicTableDefinition solutionTableDef = new DynamicTableDefinition.Builder()
+                        .withHeading("Solution")
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "indicator")
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "value")
+                                        .build())
+                        .build();
+
+        DynamicTablePrinter solutionTablePrinter = new DynamicTablePrinter(solutionTableDef);
+        solutionTablePrinter.addRow().add("costs")
+        .add(String.format("%6.2f", solution.getCost()).trim());
+        solutionTablePrinter.addRow().add("noVehicles").add(solution.getRoutes().size());
+        solutionTablePrinter.addRow().add("unassgndJobs").add(solution.getUnassignedJobs().size());
+        out.println(solutionTablePrinter.print());
 
         if (print.equals(Print.VERBOSE)) {
             printVerbose(out, problem, solution);
@@ -157,20 +151,51 @@ private static void printVerbose(VehicleRoutingProblem problem, VehicleRoutingPr
     }
 
     private static void printVerbose(PrintWriter out, VehicleRoutingProblem problem, VehicleRoutingProblemSolution solution) {
-        String leftAlgin = "| %-7s | %-20s | %-21s | %-15s | %-15s | %-15s | %-15s | %-15s |%n";
-        out.format("+--------------------------------------------------------------------------------------------------------------------------------------------------+%n");
-        out.printf("| detailed solution                                                                                                                                |%n");
-        out.format("+---------+----------------------+-----------------------+-----------------+-----------------+-----------------+-----------------+-----------------+%n");
-        out.printf("| route   | vehicle              | activity              | job             | load            | arrTime         | endTime         | costs           |%n");
+
+        DynamicTableDefinition tableDef = new DynamicTableDefinition.Builder()
+                        .withHeading("Detailed solution")
+                        .addColumn(new ColumnDefinition.Builder(new IntColumnType(), "route")
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "vehicle")
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "activity")
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType("-"), "job")
+                                        .withMinWidth(10)
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "load")
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new StringColumnType(), "location")
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new LongColumnType("-"), "arrTime")
+                                        .withAlignment(Alignment.RIGHT)
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new LongColumnType("-"), "endTime")
+                                        .withAlignment(Alignment.RIGHT)
+                                        .build())
+                        .addColumn(new ColumnDefinition.Builder(new LongColumnType(), "cost")
+                                        .withAlignment(Alignment.RIGHT)
+                                        .build())
+                        .build();
+
+        DynamicTablePrinter tablePrinter = new DynamicTablePrinter(tableDef);
         int routeNu = 1;
 
         List<VehicleRoute> list = new ArrayList<VehicleRoute>(solution.getRoutes());
         Collections.sort(list, new com.graphhopper.jsprit.core.util.VehicleIndexComparator());
         for (VehicleRoute route : list) {
-            out.format("+---------+----------------------+-----------------------+-----------------+-----------------+-----------------+-----------------+-----------------+%n");
+            if (routeNu != 1) {
+                tablePrinter.addSeparator();
+            }
+
             double costs = 0;
             SizeDimension load = getInitialLoad(route);
-            out.format(leftAlgin, routeNu, getVehicleString(route), route.getStart().getName(), "-", getString(load), "undef", Math.round(route.getStart().getEndTime()), Math.round(costs));
+            tablePrinter.addRow().add(routeNu).add(getVehicleString(route)).add(route.getStart().getName()).add(null)
+            .add(getString(load))
+            .add(getLocationString(route.getStart().getLocation()))
+            .add(null)
+            .add(Math.round(route.getStart().getEndTime())).add(Math.round(costs));
+
             TourActivity prevAct = route.getStart();
             for (TourActivity act : route.getActivities()) {
                 String jobId;
@@ -180,43 +205,72 @@ private static void printVerbose(PrintWriter out, VehicleRoutingProblem problem,
                     jobId = "-";
                 }
                 String type = (act instanceof AbstractActivity)
-                    ? ((AbstractActivity) act).getType() : act.getName();
-                double c = problem.getTransportCosts().getTransportCost(prevAct.getLocation(), act.getLocation(), prevAct.getEndTime(), route.getDriver(),
-                    route.getVehicle());
-                c += problem.getActivityCosts().getActivityCost(act, act.getArrTime(), route.getDriver(), route.getVehicle());
-                costs += c;
-                load = load.add(act.getLoadChange());
-                out.format(leftAlgin, routeNu, getVehicleString(route), type, jobId, getString(load),
-                    Math.round(act.getArrTime()),
-                    Math.round(act.getEndTime()), Math.round(costs));
-                prevAct = act;
+                                ? ((AbstractActivity) act).getType() : act.getName();
+                                double c = problem.getTransportCosts().getTransportCost(prevAct.getLocation(), act.getLocation(), prevAct.getEndTime(), route.getDriver(),
+                                                route.getVehicle());
+                                c += problem.getActivityCosts().getActivityCost(act, act.getArrTime(), route.getDriver(), route.getVehicle());
+                                costs += c;
+                                load = load.add(act.getLoadChange());
+
+                                tablePrinter.addRow().add(routeNu).add(getVehicleString(route)).add(type).add(jobId)
+                                .add(getString(load)).add(getLocationString(act.getLocation()))
+                                .add(Math.round(act.getArrTime()))
+                                .add(Math.round(act.getEndTime())).add(Math.round(costs));
+                                prevAct = act;
             }
             double c = problem.getTransportCosts().getTransportCost(prevAct.getLocation(), route.getEnd().getLocation(), prevAct.getEndTime(),
-                route.getDriver(), route.getVehicle());
+                            route.getDriver(), route.getVehicle());
             c += problem.getActivityCosts().getActivityCost(route.getEnd(), route.getEnd().getArrTime(), route.getDriver(), route.getVehicle());
             costs += c;
-            out.format(leftAlgin, routeNu, getVehicleString(route), route.getEnd().getName(), "-", getString(load), Math.round(route.getEnd().getArrTime()), "undef",
-                Math.round(costs));
+
+            tablePrinter.addRow().add(routeNu).add(getVehicleString(route))
+            .add(route.getEnd().getName()).add(null)
+            .add(getString(load))
+            .add(getLocationString(route.getEnd().getLocation()))
+            .add(null).add(Math.round(route.getEnd().getEndTime()))
+            .add(Math.round(costs));
+
             routeNu++;
         }
-        out.format("+--------------------------------------------------------------------------------------------------------------------------------------------------+%n");
+        out.println(tablePrinter.print());
+
+
         if (!solution.getUnassignedJobs().isEmpty()) {
-            out.format("+----------------+%n");
-            out.format("| unassignedJobs |%n");
-            out.format("+----------------+%n");
-            String unassignedJobAlgin = "| %-14s |%n";
+
+            DynamicTableDefinition unassignedTableDef = new DynamicTableDefinition.Builder()
+                            .withHeading("Unassigned jobs")
+                            .addColumn(new ColumnDefinition.Builder(new StringColumnType(),
+                                            "id")
+                                            .withMinWidth(10)
+                                            .build())
+                            .addColumn(new ColumnDefinition.Builder(new StringColumnType(),
+                                            "type")
+                                            .build())
+                            .build();
+
+            DynamicTablePrinter unassignedTablePrinter = new DynamicTablePrinter(unassignedTableDef);
+
             for (Job j : solution.getUnassignedJobs()) {
-                out.format(unassignedJobAlgin, j.getId());
+                unassignedTablePrinter.addRow().add(j.getId()).add(j.getClass().getSimpleName());
             }
-            out.format("+----------------+%n");
+            out.println(unassignedTablePrinter.print());
+        }
+    }
+
+    private static String getLocationString(Location l) {
+        if (l == null) {
+            return null;
+        } else {
+            return l.getId();
         }
     }
 
     private static String getString(SizeDimension load) {
         String l = "[";
         for (int i = 0; i < load.getNuOfDimensions(); i++) {
-            if (i > 0) l += ", " + load.get(i);
-            else {
+            if (i > 0) {
+                l += ", " + load.get(i);
+            } else {
                 l += load.get(i);
             }
         }
@@ -239,8 +293,8 @@ private static String getVehicleString(VehicleRoute route) {
 
     private static Map<Class<? extends Job>, Long> getNuOfJobs(VehicleRoutingProblem problem) {
         return problem.getJobs().values().stream()
-            .map(j -> (Class<? extends Job>) j.getClass())
-            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
+                        .map(j -> (Class<? extends Job>) j.getClass())
+                        .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
     }
 
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ReturnedShipmentTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ReturnedShipmentTest.java
new file mode 100644
index 000000000..13555281a
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/ReturnedShipmentTest.java
@@ -0,0 +1,550 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.jsprit.core.problem.job;
+
+import static org.hamcrest.core.Is.is;
+import static org.hamcrest.core.IsCollectionContaining.hasItem;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import com.graphhopper.jsprit.core.algorithm.VehicleRoutingAlgorithm;
+import com.graphhopper.jsprit.core.algorithm.box.Jsprit;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.SizeDimension;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
+import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem.FleetSize;
+import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
+import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
+import com.graphhopper.jsprit.core.reporting.SolutionPrinter;
+import com.graphhopper.jsprit.core.util.Coordinate;
+import com.graphhopper.jsprit.core.util.CustomJob;
+import com.graphhopper.jsprit.core.util.Solutions;
+import com.graphhopper.jsprit.core.util.TestUtils;
+
+public class ReturnedShipmentTest {
+
+    @Test
+    public void whenTwoReturnedShipmentsHaveTheSameId_theyReferencesShouldBeUnEqual() {
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, 10)
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").build()).
+                        setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
+        ReturnedShipment two = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, 10)
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").build()).
+                        setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
+
+        assertTrue(one != two);
+    }
+
+    @Test
+    public void sizeAtStartAndEndShouldBeCorrect() {
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, 10)
+                        .addSizeDimension(1, 5)
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").build()).
+                        setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
+        SizeDimension cap = SizeDimension.Builder.newInstance().addDimension(0, 0).addDimension(1, 0).build();
+        assertTrue(one.getSizeAtStart().equals(cap));
+        assertTrue(one.getSizeAtEnd().equals(cap));
+    }
+
+    @Test
+    public void whenTwoReturnedShipmentsHaveTheSameId_theyShouldBeEqual() {
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, 10)
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").build()).
+                        setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
+        ReturnedShipment two = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, 10)
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").build()).
+                        setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
+
+        assertTrue(one.equals(two));
+    }
+
+    @Test
+    public void whenReturnedShipmentIsInstantiatedWithASizeOf10_theSizeShouldBe10() {
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, 10)
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").build()).
+                        setDeliveryLocation(TestUtils.loc("foofoo")).setPickupServiceTime(10).setDeliveryServiceTime(20).build();
+        assertEquals(10, one.getSize().get(0));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenReturnedShipmentIsBuiltWithNegativeDemand_itShouldThrowException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, -10)
+        .setPickupLocation(Location.Builder.newInstance().setId("foo").build())
+        .setDeliveryLocation(TestUtils.loc("foofoo")).build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenReturnedShipmentIsBuiltWithNegativeDemand_itShouldThrowException_v2() {
+        @SuppressWarnings("unused")
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, -10)
+        .setPickupLocation(Location.Builder.newInstance().setId("foo").build())
+        .setDeliveryLocation(TestUtils.loc("foofoo")).build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenIdIsNull_itShouldThrowException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance(null).addSizeDimension(0, 10)
+        .setPickupLocation(Location.Builder.newInstance().setId("foo").build())
+        .setDeliveryLocation(TestUtils.loc("foofoo")).build();
+    }
+
+    @Test
+    public void whenCallingForANewBuilderInstance_itShouldReturnBuilderCorrectly() {
+        ReturnedShipment.Builder builder = ReturnedShipment.Builder.newInstance("s");
+        assertNotNull(builder);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenNeitherPickupLocationIdNorPickupCoord_itThrowsException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+        .setDeliveryLocation(TestUtils.loc("delLoc")).build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenNeitherDeliveryLocationIdNorDeliveryCoord_itThrowsException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+        .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
+        .build();
+    }
+
+    @Test
+    public void whenPickupLocationIdIsSet_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryLocation(TestUtils.loc("delLoc"))
+                        .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
+                        .build();
+        assertEquals("pickLoc", s.getPickupActivity().getLocation().getId());
+        assertEquals("pickLoc", s.getPickupActivity().getLocation().getId());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenPickupLocationIsNull_itThrowsException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment.Builder builder = ReturnedShipment.Builder.newInstance("s")
+        .setPickupLocation(Location.Builder.newInstance().setId(null).build());
+    }
+
+    @Test
+    public void whenPickupCoordIsSet_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").setCoordinate(Coordinate.newInstance(1, 2)).build()).build();
+        assertEquals(1.0, s.getPickupActivity().getLocation().getCoordinate().getX(), 0.01);
+        assertEquals(2.0, s.getPickupActivity().getLocation().getCoordinate().getY(), 0.01);
+        assertEquals(1.0, s.getPickupActivity().getLocation().getCoordinate().getX(), 0.01);
+        assertEquals(2.0, s.getPickupActivity().getLocation().getCoordinate().getY(), 0.01);
+    }
+
+
+    @Test
+    public void whenDeliveryLocationIdIsSet_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals("delLoc", s.getExchangeActivity().getLocation().getId());
+        assertEquals("delLoc", s.getExchangeActivity().getLocation().getId());
+    }
+
+
+    @Test
+    public void whenDeliveryCoordIsSet_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryLocation(TestUtils.loc("delLoc", Coordinate.newInstance(1, 2)))
+                        .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
+                        .build();
+        assertEquals(1.0, s.getExchangeActivity().getLocation().getCoordinate().getX(), 0.01);
+        assertEquals(2.0, s.getExchangeActivity().getLocation().getCoordinate().getY(), 0.01);
+        assertEquals(1.0, s.getExchangeActivity().getLocation().getCoordinate().getX(), 0.01);
+        assertEquals(2.0, s.getExchangeActivity().getLocation().getCoordinate().getY(), 0.01);
+    }
+
+    @Test
+    public void whenPickupServiceTimeIsNotSet_itShouldBeZero() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(0.0, s.getPickupActivity().getOperationTime(), 0.01);
+    }
+
+    @Test
+    public void whenDeliveryServiceTimeIsNotSet_itShouldBeZero() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(0.0, s.getExchangeActivity().getOperationTime(), 0.01);
+    }
+
+    @Test
+    public void whenPickupServiceTimeIsSet_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupServiceTime(2.0)
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(2.0, s.getPickupActivity().getOperationTime(), 0.01);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenPickupServiceIsSmallerThanZero_itShouldThrowException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").setPickupServiceTime(-2.0)
+        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+    }
+
+    @Test
+    public void whenDeliveryServiceTimeIsSet_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").setDeliveryServiceTime(2.0)
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(2.0, s.getExchangeActivity().getOperationTime(), 0.01);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenDeliveryServiceIsSmallerThanZero_itShouldThrowException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").setDeliveryServiceTime(-2.0)
+        .setDeliveryLocation(TestUtils.loc("delLoc"))
+        .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
+        .build();
+    }
+
+    @Test
+    public void whenPickupTimeWindowIsNotSet_itShouldBeTheDefaultOne() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryLocation(TestUtils.loc("delLoc"))
+                        .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
+                        .build();
+        assertEquals(0.0, s.getPickupActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(Double.MAX_VALUE,
+                        s.getPickupActivity().getSingleTimeWindow().getEnd(), 0.01);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenPickupTimeWindowIsNull_itShouldThrowException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").setPickupTimeWindow(null)
+        .setDeliveryLocation(TestUtils.loc("delLoc"))
+        .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
+        .build();
+    }
+
+    @Test
+    public void whenPickupTimeWindowIsSet_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupTimeWindow(TimeWindow.newInstance(1, 2))
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(1.0, s.getPickupActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(2.0, s.getPickupActivity().getSingleTimeWindow().getEnd(), 0.01);
+    }
+
+    @Test
+    public void whenDeliveryTimeWindowIsNotSet_itShouldBeTheDefaultOne() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryLocation(TestUtils.loc("delLoc"))
+                        .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
+                        .build();
+        assertEquals(0.0, s.getExchangeActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(Double.MAX_VALUE,
+                        s.getExchangeActivity().getSingleTimeWindow().getEnd(), 0.01);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenDeliveryTimeWindowIsNull_itShouldThrowException() {
+        @SuppressWarnings("unused")
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").setDeliveryTimeWindow(null)
+        .setDeliveryLocation(TestUtils.loc("delLoc"))
+        .setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build())
+        .build();
+    }
+
+    @Test
+    public void whenDeliveryTimeWindowIsSet_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setDeliveryTimeWindow(TimeWindow.newInstance(1, 2))
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(1.0, s.getExchangeActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(2.0, s.getExchangeActivity().getSingleTimeWindow().getEnd(),
+                        0.01);
+    }
+
+    @Test
+    public void whenUsingAddDeliveryTimeWindow_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .addDeliveryTimeWindow(TimeWindow.newInstance(1, 2))
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(1.0, s.getExchangeActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(2.0, s.getExchangeActivity().getSingleTimeWindow().getEnd(),
+                        0.01);
+    }
+
+    @Test
+    public void whenUsingAddDeliveryTimeWindow2_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").addDeliveryTimeWindow(1, 2)
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(1.0, s.getExchangeActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(2.0, s.getExchangeActivity().getSingleTimeWindow().getEnd(),
+                        0.01);
+    }
+
+    @Test
+    public void whenAddingMultipleDeliveryTimeWindows_itShouldBeDoneCorrectly() {
+        TimeWindow tw1 = TimeWindow.newInstance(1, 2);
+        TimeWindow tw2 = TimeWindow.newInstance(4, 5);
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").addDeliveryTimeWindow(tw1)
+                        .addDeliveryTimeWindow(tw2)
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(s.getExchangeActivity().getTimeWindows().size(), 2);
+        assertThat(s.getExchangeActivity().getTimeWindows(), hasItem(is(tw1)));
+        assertThat(s.getExchangeActivity().getTimeWindows(), hasItem(is(tw2)));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenAddingMultipleOverlappingDeliveryTimeWindows_itShouldThrowException() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").addDeliveryTimeWindow(1, 3)
+                        .addDeliveryTimeWindow(2, 5)
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(1.0, s.getExchangeActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(2.0, s.getExchangeActivity().getSingleTimeWindow().getEnd(),
+                        0.01);
+    }
+
+
+    @Test
+    public void whenUsingAddPickupTimeWindow_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .addPickupTimeWindow(TimeWindow.newInstance(1, 2))
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(1.0, s.getPickupActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(2.0, s.getPickupActivity().getSingleTimeWindow().getEnd(), 0.01);
+    }
+
+    @Test
+    public void whenUsingAddPickupTimeWindow2_itShouldBeDoneCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").addPickupTimeWindow(1, 2)
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(1.0, s.getPickupActivity().getSingleTimeWindow().getStart(),
+                        0.01);
+        assertEquals(2.0, s.getPickupActivity().getSingleTimeWindow().getEnd(), 0.01);
+    }
+
+    @Test
+    public void whenAddingMultiplePickupTimeWindows_itShouldBeDoneCorrectly() {
+        TimeWindow tw1 = TimeWindow.newInstance(1, 2);
+        TimeWindow tw2 = TimeWindow.newInstance(4, 5);
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").addPickupTimeWindow(tw1)
+                        .addPickupTimeWindow(tw2)
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(s.getPickupActivity().getTimeWindows().size(), 2);
+        assertThat(s.getPickupActivity().getTimeWindows(), hasItem(is(tw1)));
+        assertThat(s.getPickupActivity().getTimeWindows(), hasItem(is(tw2)));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenAddingMultipleOverlappingPickupTimeWindows_itShouldThrowException() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s").addPickupTimeWindow(1, 3)
+                        .addPickupTimeWindow(2, 5)
+                        .setDeliveryLocation(TestUtils.loc("delLoc")).setPickupLocation(Location.Builder.newInstance().setId("pickLoc").build()).build();
+        assertEquals(1.0, s.getPickupActivity().getSingleTimeWindow().getStart(), 0.01);
+        assertEquals(2.0, s.getPickupActivity().getSingleTimeWindow().getEnd(), 0.01);
+    }
+
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenReturnedShipmentHasNegativeCapacityVal_throwIllegalStateExpception() {
+        @SuppressWarnings("unused")
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s")
+        .setPickupLocation(Location.Builder.newInstance().setId("foo").build())
+        .setDeliveryLocation(TestUtils.loc("foofoo"))
+        .addSizeDimension(0, -2)
+        .build();
+    }
+
+    @Test
+    public void whenAddingTwoCapDimension_nuOfDimsShouldBeTwo() {
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").build())
+                        .setDeliveryLocation(TestUtils.loc("foofoo"))
+                        .addSizeDimension(0, 2)
+                        .addSizeDimension(1, 4)
+                        .addBackhaulSizeDimension(0, 3)
+                        .addBackhaulSizeDimension(1, 5)
+                        .build();
+        assertEquals(2, one.getSize().getNuOfDimensions());
+        assertEquals(2, one.getBackhaulActivity().getLoadChange().getNuOfDimensions());
+    }
+
+    @Test
+    public void whenReturnedShipmentIsBuiltWithoutSpecifyingCapacity_itShouldHvCapWithOneDimAndDimValOfZero() {
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").setCoordinate(Coordinate.newInstance(0, 0)).build())
+                        .setDeliveryLocation(TestUtils.loc("foofoo")).build();
+        assertEquals(1, one.getSize().getNuOfDimensions());
+        assertEquals(0, one.getSize().get(0));
+        assertEquals(1, one.getBackhaulActivity().getLoadChange().getNuOfDimensions());
+    }
+
+    @Test
+    public void whenReturnedShipmentIsBuiltWithConstructorWhereSizeIsSpecified_capacityShouldBeSetCorrectly() {
+        ReturnedShipment one = ReturnedShipment.Builder.newInstance("s").addSizeDimension(0, 1)
+                        .setPickupLocation(Location.Builder.newInstance().setId("foo").setCoordinate(Coordinate.newInstance(0, 0)).build())
+                        .setDeliveryLocation(TestUtils.loc("foofoo")).build();
+        assertEquals(1, one.getSize().getNuOfDimensions());
+        assertEquals(1, one.getSize().get(0));
+    }
+
+    @Test
+    public void whenAddingSkills_theyShouldBeAddedCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.Builder.newInstance().setId("loc").build())
+                        .setDeliveryLocation(TestUtils.loc("delLoc"))
+                        .addRequiredSkill("drill").addRequiredSkill("screwdriver").build();
+        assertTrue(s.getRequiredSkills().containsSkill("drill"));
+        assertTrue(s.getRequiredSkills().containsSkill("drill"));
+        assertTrue(s.getRequiredSkills().containsSkill("ScrewDriver"));
+    }
+
+    @Test
+    public void whenAddingSkillsCaseSens_theyShouldBeAddedCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.Builder.newInstance().setId("pick").build())
+                        .setDeliveryLocation(TestUtils.loc("del"))
+                        .addRequiredSkill("DriLl").addRequiredSkill("screwDriver").build();
+        assertTrue(s.getRequiredSkills().containsSkill("drill"));
+        assertTrue(s.getRequiredSkills().containsSkill("drilL"));
+    }
+
+    @Test
+    public void whenAddingSkillsCaseSensV2_theyShouldBeAddedCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.Builder.newInstance().setId("loc").build())
+                        .setDeliveryLocation(TestUtils.loc("del"))
+                        .addRequiredSkill("screwDriver").build();
+        assertFalse(s.getRequiredSkills().containsSkill("drill"));
+        assertFalse(s.getRequiredSkills().containsSkill("drilL"));
+    }
+
+    @Test
+    public void nameShouldBeAssigned() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.Builder.newInstance().setId("loc").build())
+                        .setDeliveryLocation(TestUtils.loc("del"))
+                        .setName("name").build();
+        assertEquals("name", s.getName());
+    }
+
+    @Test
+    public void whenSettingLocation_itShouldWork() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.Builder.newInstance().setId("loc").build())
+                        .setDeliveryLocation(Location.Builder.newInstance().setId("del").build())
+                        .setBackhaulLocation(Location.Builder.newInstance().setId("back").build())
+                        .build();
+        assertEquals("loc", s.getPickupActivity().getLocation().getId());
+        assertEquals("del", s.getExchangeActivity().getLocation().getId());
+        assertEquals("back", s.getBackhaulActivity().getLocation().getId());
+    }
+
+    @Test
+    public void whenSettingPriorities_itShouldBeSetCorrectly() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.newInstance("loc"))
+                        .setDeliveryLocation(Location.newInstance("loc"))
+                        .setPriority(1).build();
+        assertEquals(1, s.getPriority());
+    }
+
+    @Test
+    public void whenSettingPriorities_itShouldBeSetCorrectly2() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.newInstance("loc"))
+                        .setDeliveryLocation(Location.newInstance("loc"))
+                        .setPriority(3).build();
+        assertEquals(3, s.getPriority());
+    }
+
+    @Test
+    public void whenNotSettingPriorities_defaultShouldBe2() {
+        ReturnedShipment s = ReturnedShipment.Builder.newInstance("s")
+                        .setPickupLocation(Location.newInstance("loc"))
+                        .setDeliveryLocation(Location.newInstance("loc"))
+                        .build();
+        assertEquals(2, s.getPriority());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenSettingIncorrectPriorities_itShouldThrowException() {
+        ReturnedShipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc"))
+        .setDeliveryLocation(Location.newInstance("loc"))
+        .setPriority(30).build();
+
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenSettingIncorrectPriorities_itShouldThrowException2() {
+        ReturnedShipment.Builder.newInstance("s").setPickupLocation(Location.newInstance("loc"))
+        .setDeliveryLocation(Location.newInstance("loc"))
+        .setPriority(0).build();
+
+    }
+
+    @Test
+    public void firstTest() {
+        CustomJob cj = CustomJob.Builder.newInstance("job")
+                        .addPickup(Location.newInstance(10, 0), SizeDimension.of(1, 0))
+                        .addExchange(Location.newInstance(5, 0), SizeDimension.of(-3, 2))
+                        .addDelivery(Location.newInstance(20, 0), SizeDimension.of(1))
+                        .build();
+        CustomJob cj2 = CustomJob.Builder.newInstance("job2")
+                        .addPickup(Location.newInstance(20, 0), SizeDimension.of(1, 0))
+                        .addExchange(Location.newInstance(30, 0), SizeDimension.of(-3, 2))
+                        .addDelivery(Location.newInstance(20, 0), SizeDimension.of(1))
+                        .build();
+        CustomJob cj3 = CustomJob.Builder.newInstance("job3")
+                        .addPickup(Location.newInstance(20, 0), SizeDimension.of(1, 0))
+                        .addExchange(Location.newInstance(30, 0), SizeDimension.of(-3, 2))
+                        .addDelivery(Location.newInstance(20, 0), SizeDimension.of(1))
+                        .build();
+        VehicleType type = VehicleTypeImpl.Builder.newInstance("type").addCapacityDimension(0, 3)
+                        .addCapacityDimension(1, 2).build();
+        Vehicle v = VehicleImpl.Builder.newInstance("v").setType(type)
+                        .setStartLocation(Location.newInstance(0, 0)).build();
+        VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
+                        .setFleetSize(FleetSize.FINITE)
+                        .addJob(cj).addJob(cj2).addJob(cj3).addVehicle(v).build();
+        VehicleRoutingAlgorithm vra = Jsprit.createAlgorithm(vrp);
+        vra.setMaxIterations(10);
+        VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
+        SolutionPrinter.print(vrp, solution, SolutionPrinter.Print.VERBOSE);
+        Assert.assertTrue(solution.getUnassignedJobs().isEmpty());
+    }
+}
