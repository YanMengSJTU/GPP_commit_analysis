diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
index fd76954ea..2ea246b35 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/box/Jsprit.java
@@ -50,7 +50,7 @@
 import com.graphhopper.jsprit.core.algorithm.ruin.RuinRandom;
 import com.graphhopper.jsprit.core.algorithm.ruin.RuinShareFactory;
 import com.graphhopper.jsprit.core.algorithm.ruin.RuinWorst;
-import com.graphhopper.jsprit.core.algorithm.ruin.distance.AvgServiceAndShipmentDistance;
+import com.graphhopper.jsprit.core.algorithm.ruin.distance.DefaultJobDistance;
 import com.graphhopper.jsprit.core.algorithm.selector.SelectBest;
 import com.graphhopper.jsprit.core.algorithm.state.StateManager;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
@@ -387,7 +387,7 @@ private VehicleRoutingAlgorithm create(final VehicleRoutingProblem vrp) {
         double noiseLevel = toDouble(getProperty(Parameter.INSERTION_NOISE_LEVEL.toString()));
         double noiseProbability = toDouble(getProperty(Parameter.INSERTION_NOISE_PROB.toString()));
 
-        JobNeighborhoods jobNeighborhoods = new JobNeighborhoodsFactory().createNeighborhoods(vrp, new AvgServiceAndShipmentDistance(vrp.getTransportCosts()), (int) (vrp.getJobs().values().size() * 0.5));
+        JobNeighborhoods jobNeighborhoods = new JobNeighborhoodsFactory().createNeighborhoods(vrp, new DefaultJobDistance(vrp.getTransportCosts()), (int) (vrp.getJobs().values().size() * 0.5));
         jobNeighborhoods.initialise();
 
         final double maxCosts;
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/AvgServiceDistance.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/AvgServiceDistance.java
index 75fd62186..16edc0529 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/AvgServiceDistance.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/AvgServiceDistance.java
@@ -25,10 +25,14 @@
 /**
  * Calculator that calculates average distance between two jobs based on the input-transport costs.
  * <p>
- * <p>If the distance between two jobs cannot be calculated with input-transport costs, it tries the euclidean distance between these jobs.
+ * <p>
+ * If the distance between two jobs cannot be calculated with input-transport costs, it tries the euclidean distance
+ * between these jobs.
  *
  * @author stefan schroeder
+ * @deprecated Being a subset of the {@linkplain DefaultJobDistance} class. Use that instead.
  */
+@Deprecated
 public class AvgServiceDistance implements JobDistance {
 
     private VehicleRoutingTransportCosts costs;
@@ -46,6 +50,8 @@ public AvgServiceDistance(VehicleRoutingTransportCosts costs) {
      */
     @Override
     public double getDistance(Job i, Job j) {
+        System.out.println("Serv: ");
+
         double avgCost = 0.0;
         if (i instanceof Service && j instanceof Service) {
             if (i.equals(j)) {
@@ -57,7 +63,7 @@ public double getDistance(Job i, Job j) {
             }
         } else {
             throw new UnsupportedOperationException(
-                "currently, this class just works services.");
+                    "currently, this class just works services.");
         }
         return avgCost;
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/AvgServiceAndShipmentDistance.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/CoordinateJobDistance.java
similarity index 65%
rename from jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/AvgServiceAndShipmentDistance.java
rename to jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/CoordinateJobDistance.java
index cc97b2a8e..27ed94e11 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/AvgServiceAndShipmentDistance.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/CoordinateJobDistance.java
@@ -19,30 +19,28 @@
 
 import java.util.List;
 
+import com.graphhopper.jsprit.core.distance.EuclideanDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
 import com.graphhopper.jsprit.core.problem.job.Job;
-import com.graphhopper.jsprit.core.util.EuclideanDistanceCalculator;
 
 
 /**
- * Calculator that calculates average distance between two jobs based on the
- * input-transport costs.
+ * Calculator that calculates average distance between two jobs based on the input-transport costs.
  * <p>
  * <p>
- * If the distance between two jobs cannot be calculated with input-transport
- * costs, it tries the euclidean distance between these jobs.
+ * If the distance between two jobs cannot be calculated with input-transport costs, it tries the euclidean distance
+ * between these jobs.
  *
  * @author stefan schroeder
+ * @author balage
  */
-public class AvgServiceAndShipmentDistance implements JobDistance {
+public class CoordinateJobDistance implements JobDistance {
 
     private VehicleRoutingTransportCosts costs;
 
-    public AvgServiceAndShipmentDistance(VehicleRoutingTransportCosts costs) {
+    public CoordinateJobDistance() {
         super();
-        this.costs = costs;
-
     }
 
     /**
@@ -60,14 +58,6 @@ public double getDistance(Job i, Job j) {
             return 0.0;
         }
 
-        // TODO: Do we really need these checks after the refactor?
-//      if (!(i instanceof Service || i instanceofx Shipment || i instanceofx ShipmentWithBackhaul)) {
-//          throw new IllegalStateException("this supports only shipments or services");
-//      }
-//      if (!(j instanceof Service || j instanceofx Shipment || j instanceofx ShipmentWithBackhaul)) {
-//          throw new IllegalStateException("this supports only shipments or services");
-//      }
-
         return calcDist(i.getAllLocations(), j.getAllLocations());
     }
 
@@ -81,7 +71,7 @@ public double getDistance(Job i, Job j) {
      * @return The Average distance. (Returns 0 when any of the sides contains
      *         no distances.)
      */
-    private double calcDist(List<Location> leftLocations, List<Location> rightLocations) {
+    protected double calcDist(List<Location> leftLocations, List<Location> rightLocations) {
         if (leftLocations.isEmpty() || rightLocations.isEmpty()) {
             return 0d;
         }
@@ -94,12 +84,7 @@ private double calcDist(List<Location> leftLocations, List<Location> rightLocati
         return totalDistance / (leftLocations.size() * rightLocations.size());
     }
 
-    private double calcDist(Location location_i, Location location_j) {
-        try {
-            return costs.getTransportCost(location_i, location_j, 0.0, null, null);
-        } catch (IllegalStateException e) {
-            // now try the euclidean distance between these two services
-        }
-        return EuclideanDistanceCalculator.calculateDistance(location_i.getCoordinate(), location_j.getCoordinate());
+    protected double calcDist(Location location_i, Location location_j) {
+        return EuclideanDistanceCalculator.getInstance().calculateDistance(location_i.getCoordinate(), location_j.getCoordinate());
     }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/DefaultJobDistance.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/DefaultJobDistance.java
new file mode 100644
index 000000000..c6ea2031b
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/DefaultJobDistance.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.jsprit.core.algorithm.ruin.distance;
+
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
+
+
+/**
+ * Calculator that calculates average distance between two jobs based on the input-transport costs.
+ * <p>
+ * <p>
+ * If the distance between two jobs cannot be calculated with input-transport costs, it tries the euclidean distance
+ * between these jobs.
+ *
+ * @author stefan schroeder
+ * @author balage
+ */
+public class DefaultJobDistance extends CoordinateJobDistance {
+
+    private VehicleRoutingTransportCosts costs;
+
+    public DefaultJobDistance(VehicleRoutingTransportCosts costs) {
+        super();
+        this.costs = costs;
+    }
+
+    @Override
+    protected double calcDist(Location location_i, Location location_j) {
+        try {
+            return costs.getTransportCost(location_i, location_j, 0.0, null, null);
+        } catch (IllegalStateException e) {
+            // now try the euclidean distance between these two services
+        }
+        return super.calcDist(location_i, location_j);
+    }
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/EuclideanServiceDistance.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/EuclideanServiceDistance.java
index a0be5db17..6f5d24446 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/EuclideanServiceDistance.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/EuclideanServiceDistance.java
@@ -17,10 +17,11 @@
  */
 package com.graphhopper.jsprit.core.algorithm.ruin.distance;
 
+import com.graphhopper.jsprit.core.distance.EuclideanDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.job.Service;
-import com.graphhopper.jsprit.core.util.EuclideanDistanceCalculator;
 
+@Deprecated
 public class EuclideanServiceDistance implements JobDistance {
 
     public EuclideanServiceDistance() {
@@ -36,13 +37,14 @@ public double getDistance(Job i, Job j) {
             } else {
                 Service s_i = (Service) i;
                 Service s_j = (Service) j;
-                if (s_i.getLocation().getCoordinate() == null || s_j.getLocation().getCoordinate() == null)
+                if (s_i.getLocation().getCoordinate() == null || s_j.getLocation().getCoordinate() == null) {
                     throw new IllegalStateException("cannot calculate euclidean distance. since service coords are missing");
-                avgCost = EuclideanDistanceCalculator.calculateDistance(s_i.getLocation().getCoordinate(), s_j.getLocation().getCoordinate());
+                }
+                avgCost = EuclideanDistanceCalculator.getInstance().calculateDistance(s_i.getLocation().getCoordinate(), s_j.getLocation().getCoordinate());
             }
         } else {
             throw new UnsupportedOperationException(
-                "currently, this class just works with shipments and services.");
+                            "currently, this class just works with shipments and services.");
         }
         return avgCost;
     }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/distance/DistanceCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/distance/DistanceCalculator.java
new file mode 100644
index 000000000..060257ca2
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/distance/DistanceCalculator.java
@@ -0,0 +1,10 @@
+package com.graphhopper.jsprit.core.distance;
+
+import com.graphhopper.jsprit.core.util.Coordinate;
+
+public interface DistanceCalculator {
+
+    public double calculateDistance(Coordinate from, Coordinate to);
+
+    public String getName();
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/distance/EuclideanDistanceCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/distance/EuclideanDistanceCalculator.java
new file mode 100644
index 000000000..6e2a6d9be
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/distance/EuclideanDistanceCalculator.java
@@ -0,0 +1,28 @@
+package com.graphhopper.jsprit.core.distance;
+
+import com.graphhopper.jsprit.core.util.Coordinate;
+
+public class EuclideanDistanceCalculator implements DistanceCalculator {
+
+    private static EuclideanDistanceCalculator INSTANCE = new EuclideanDistanceCalculator();
+
+    public static EuclideanDistanceCalculator getInstance() {
+        return INSTANCE;
+    }
+
+    private EuclideanDistanceCalculator() {
+    }
+
+    @Override
+    public double calculateDistance(Coordinate from, Coordinate to) {
+        double xDiff = from.getX() - to.getX();
+        double yDiff = from.getY() - to.getY();
+        return Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));
+    }
+
+    @Override
+    public String getName() {
+        return "Euclidean";
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/distance/ManhattanDistanceCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/distance/ManhattanDistanceCalculator.java
new file mode 100644
index 000000000..108789832
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/distance/ManhattanDistanceCalculator.java
@@ -0,0 +1,27 @@
+package com.graphhopper.jsprit.core.distance;
+
+import com.graphhopper.jsprit.core.util.Coordinate;
+
+public class ManhattanDistanceCalculator implements DistanceCalculator {
+
+    private static ManhattanDistanceCalculator INSTANCE = new ManhattanDistanceCalculator();
+
+    public static ManhattanDistanceCalculator getInstance() {
+        return INSTANCE;
+    }
+
+    @Override
+    public double calculateDistance(Coordinate from, Coordinate to) {
+        double xDiff = from.getX() - to.getX();
+        double yDiff = from.getY() - to.getY();
+
+        return Math.abs(xDiff) + Math.abs(yDiff);
+    }
+
+    @Override
+    public String getName() {
+        return "Manhattan";
+    }
+
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/distance/SphericalDistanceCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/distance/SphericalDistanceCalculator.java
new file mode 100644
index 000000000..ef6aad66a
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/distance/SphericalDistanceCalculator.java
@@ -0,0 +1,41 @@
+package com.graphhopper.jsprit.core.distance;
+
+import com.graphhopper.jsprit.core.util.Coordinate;
+
+public class SphericalDistanceCalculator implements DistanceCalculator {
+
+    private static final double R = 6372.8; // km
+
+    private static SphericalDistanceCalculator INSTANCE = new SphericalDistanceCalculator();
+
+    public static SphericalDistanceCalculator getInstance() {
+        return INSTANCE;
+    }
+
+    @Override
+    public double calculateDistance(Coordinate from, Coordinate to) {
+        double lon1 = from.getX();
+        double lon2 = to.getX();
+        double lat1 = from.getY();
+        double lat2 = to.getY();
+
+        double deltaLat = Math.toRadians(lat2 - lat1);
+        double deltaLon = Math.toRadians(lon2 - lon1);
+        lat1 = Math.toRadians(lat1);
+        lat2 = Math.toRadians(lat2);
+
+        double deltaLatSin = Math.sin(deltaLat / 2);
+        double deltaLonSin = Math.sin(deltaLon / 2);
+        double a = deltaLatSin * deltaLatSin
+                        + deltaLonSin * deltaLonSin * Math.cos(lat1) * Math.cos(lat2);
+        double c = 2 * Math.asin(Math.sqrt(a));
+        double distance = R * c;
+        return distance;
+    }
+
+    @Override
+    public String getName() {
+        return "Spherical";
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Capacity.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Capacity.java
index 5fc6040d8..eaebc5417 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Capacity.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/Capacity.java
@@ -356,4 +356,13 @@ public static Capacity createNullCapacity(int numberOfDimensions) {
         return new Capacity(numberOfDimensions);
     }
 
+    public boolean isPositive() {
+        for (int i = 0; i < getNuOfDimensions(); i++) {
+            if (get(i) < 0) {
+                return false;
+            }
+        }
+        return true;
+    }
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
index dbe3b6863..1e27b6226 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/VehicleRoutingProblem.java
@@ -31,6 +31,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import com.graphhopper.jsprit.core.distance.EuclideanDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingActivityCosts;
 import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
 import com.graphhopper.jsprit.core.problem.cost.WaitingTimeCosts;
@@ -44,7 +45,7 @@
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeKey;
 import com.graphhopper.jsprit.core.util.Coordinate;
-import com.graphhopper.jsprit.core.util.CrowFlyCosts;
+import com.graphhopper.jsprit.core.util.DefaultCosts;
 import com.graphhopper.jsprit.core.util.Locations;
 
 
@@ -406,13 +407,17 @@ public Builder setActivityCosts(VehicleRoutingActivityCosts activityCosts) {
         /**
          * Builds the {@link VehicleRoutingProblem}.
          * <p>
-         * <p>If {@link VehicleRoutingTransportCosts} are not set, {@link CrowFlyCosts} is used.
+         * <p>
+         * If {@link VehicleRoutingTransportCosts} are not set,
+         * {@link DefaultCosts} is used with
+         * {@linkplain EuclideanDistanceCalculator}.
          *
          * @return {@link VehicleRoutingProblem}
          */
         public VehicleRoutingProblem build() {
             if (transportCosts == null) {
-                transportCosts = new CrowFlyCosts(getLocations());
+                transportCosts = new DefaultCosts(EuclideanDistanceCalculator.getInstance())
+                                .withCoordinateConverter(getLocations());
             }
             for (Job job : tentativeJobs.values()) {
                 if (!jobsInInitialRoutes.contains(job.getId())) {
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
index d3fd0b8c7..0e5c04559 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/MaxDistanceConstraint.java
@@ -27,6 +27,7 @@
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliverShipmentDEPRECATED;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.End;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.Start;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 
@@ -78,14 +79,22 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
             currentDistance = stateManager.getRouteState(iFacts.getRoute(),iFacts.getNewVehicle(), distanceId,Double.class);
         }
         double maxDistance = getMaxDistance(iFacts.getNewVehicle());
+        if(currentDistance > maxDistance) {
+            return ConstraintsStatus.NOT_FULFILLED_BREAK;
+        }
 
         double distancePrevAct2NewAct = distanceCalculator.getDistance(prevAct.getLocation(), newAct.getLocation(), iFacts.getNewDepTime(), iFacts.getNewVehicle());
         double distanceNewAct2nextAct = distanceCalculator.getDistance(newAct.getLocation(), nextAct.getLocation(), iFacts.getNewDepTime(), iFacts.getNewVehicle());
-        double distancePrevAct2NextAct = distanceCalculator.getDistance(prevAct.getLocation(), nextAct.getLocation(), prevActDepTime, iFacts.getRoute().getVehicle());
+        double distancePrevAct2NextAct = distanceCalculator.getDistance(prevAct.getLocation(), nextAct.getLocation(), prevActDepTime, iFacts.getNewVehicle());
         if(nextAct instanceof End && !iFacts.getNewVehicle().isReturnToDepot()){
             distanceNewAct2nextAct = 0;
             distancePrevAct2NextAct = 0;
         }
+        double additionalDistance = distancePrevAct2NewAct + distanceNewAct2nextAct - distancePrevAct2NextAct;
+        if(currentDistance + additionalDistance > maxDistance) {
+            return ConstraintsStatus.NOT_FULFILLED;
+        }
+
 
         double additionalDistanceOfPickup = 0;
         if (newAct instanceof DeliverShipmentDEPRECATED) {
@@ -95,34 +104,16 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
             if(iIndexOfPickup > 0) {
                 actBeforePickup = iFacts.getRoute().getActivities().get(iIndexOfPickup-1);
             } else {
-                actBeforePickup = iFacts.getRoute().getStart();
-            }
-
-            TourActivity actAfterPickup;
-            boolean associatedPickAndDeliveryAreDirectNeighbors = prevAct.getIndex() == pickup.getIndex();
-            if(associatedPickAndDeliveryAreDirectNeighbors){
-                actAfterPickup = newAct;
-                distancePrevAct2NextAct = distanceCalculator.getDistance(prevAct.getLocation(), nextAct.getLocation(), iFacts.getRelatedActivityContext().getEndTime(), iFacts.getNewVehicle());
-            } else {
-                actAfterPickup = iFacts.getRoute().getActivities().get(iIndexOfPickup);
+                actBeforePickup = new Start(iFacts.getNewVehicle().getStartLocation(),0,Double.MAX_VALUE);
             }
+            TourActivity actAfterPickup = iFacts.getRoute().getActivities().get(iIndexOfPickup);
+            //ToDo account here fore End and returnToDepot
             double distanceActBeforePickup2Pickup = distanceCalculator.getDistance(actBeforePickup.getLocation(), pickup.getLocation(), actBeforePickup.getEndTime(), iFacts.getNewVehicle());
             double distancePickup2ActAfterPickup = distanceCalculator.getDistance(pickup.getLocation(), actAfterPickup.getLocation(), iFacts.getRelatedActivityContext().getEndTime(), iFacts.getNewVehicle());
-
-            double distanceBeforePickup2AfterPickup;
-            if(associatedPickAndDeliveryAreDirectNeighbors){
-                distanceBeforePickup2AfterPickup = distanceCalculator.getDistance(actBeforePickup.getLocation(), actAfterPickup.getLocation(), actBeforePickup.getEndTime(), iFacts.getNewVehicle());
-            }
-            else{
-                distanceBeforePickup2AfterPickup = distanceCalculator.getDistance(actBeforePickup.getLocation(), actAfterPickup.getLocation(), actBeforePickup.getEndTime(), iFacts.getRoute().getVehicle());
-            }
+            double distanceBeforePickup2AfterPickup = distanceCalculator.getDistance(actBeforePickup.getLocation(), actAfterPickup.getLocation(), actBeforePickup.getEndTime(), iFacts.getNewVehicle());
             additionalDistanceOfPickup = distanceActBeforePickup2Pickup  + distancePickup2ActAfterPickup - distanceBeforePickup2AfterPickup;
         }
 
-        double additionalDistance = distancePrevAct2NewAct + distanceNewAct2nextAct - distancePrevAct2NextAct;
-        if(currentDistance + additionalDistance > maxDistance) {
-            return ConstraintsStatus.NOT_FULFILLED;
-        }
 
         if(currentDistance + additionalDistance + additionalDistanceOfPickup > maxDistance){
             return ConstraintsStatus.NOT_FULFILLED;
@@ -132,6 +123,9 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
     }
 
     private boolean hasMaxDistance(Vehicle newVehicle){
+        if(newVehicle.getIndex() >= maxDistances.length) {
+            return false;
+        }
         return maxDistances[newVehicle.getIndex()] != null;
     }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/PickupAndDeliverShipmentLoadActivityLevelConstraint.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/PickupAndDeliverShipmentLoadActivityLevelConstraint.java
index 7ef727062..006d02d53 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/PickupAndDeliverShipmentLoadActivityLevelConstraint.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/PickupAndDeliverShipmentLoadActivityLevelConstraint.java
@@ -19,9 +19,11 @@
 
 import com.graphhopper.jsprit.core.algorithm.state.InternalStates;
 import com.graphhopper.jsprit.core.problem.Capacity;
+import com.graphhopper.jsprit.core.problem.job.Shipment;
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliverShipmentDEPRECATED;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupShipmentDEPRECATED;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivityNEW;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivityNEW;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.Start;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.state.RouteAndActivityStateGetter;
@@ -83,9 +85,21 @@ public PickupAndDeliverShipmentLoadActivityLevelConstraint(RouteAndActivityState
      */
     @Override
     public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime) {
-        if (!(newAct instanceof PickupShipmentDEPRECATED) && !(newAct instanceof DeliverShipmentDEPRECATED)) {
+        // ----> REMARK - Balage - This replaces the following check? Do we
+        // still need it? It's fragile and uses an instantof so it probably
+        // wrong!
+        // if (!(newAct instanceof PickupShipmentDEPRECATED) && !(newAct
+        // instanceof DeliverShipmentDEPRECATED))
+        // return ConstraintsStatus.FULFILLED;
+        if (!(newAct instanceof JobActivity)) {
             return ConstraintsStatus.FULFILLED;
         }
+        JobActivity newJobAct = (JobActivity)newAct;
+        if (!(newJobAct.getJob() instanceof Shipment)) {
+            return ConstraintsStatus.FULFILLED;
+        }
+        // <--- Check ends here
+
         // System.out.println(visualize(iFacts, prevAct, newAct, nextAct));
         Capacity loadAtPrevAct;
         if (prevAct instanceof Start) {
@@ -99,20 +113,59 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
                 loadAtPrevAct = defaultValue;
             }
         }
-        if (newAct instanceof PickupShipmentDEPRECATED) {
+        Capacity vehicleCapacityDimensions = iFacts.getNewVehicle().getType().getCapacityDimensions();
+
+        if (newAct instanceof PickupActivityNEW) {
             Capacity newCapacity = Capacity.addup(loadAtPrevAct, newAct.getSize());
-            if (!newCapacity.isLessOrEqual(iFacts.getNewVehicle().getType().getCapacityDimensions())) {
+            if (!newCapacity.isLessOrEqual(vehicleCapacityDimensions)) {
                 return ConstraintsStatus.NOT_FULFILLED;
             }
         }
-        if (newAct instanceof DeliverShipmentDEPRECATED) {
+        if (newAct instanceof DeliveryActivityNEW) {
             Capacity newCapacity = Capacity.addup(loadAtPrevAct, Capacity.invert(newAct.getSize()));
-            if (!newCapacity.isLessOrEqual(iFacts.getNewVehicle().getType().getCapacityDimensions())) {
+            if (!newCapacity.isLessOrEqual(vehicleCapacityDimensions)) {
                 return ConstraintsStatus.NOT_FULFILLED_BREAK;
             }
         }
         return ConstraintsStatus.FULFILLED;
     }
 
+    // OLD BODY
+    // if (!(newAct instanceof PickupShipmentDEPRECATED) && !(newAct instanceof
+    // DeliverShipmentDEPRECATED)) {
+    // return ConstraintsStatus.FULFILLED;
+    // }
+    // // System.out.println(visualize(iFacts, prevAct, newAct, nextAct));
+    // Capacity loadAtPrevAct;
+    // if (prevAct instanceof Start) {
+    // loadAtPrevAct = stateManager.getRouteState(iFacts.getRoute(),
+    // InternalStates.LOAD_AT_BEGINNING, Capacity.class);
+    // if (loadAtPrevAct == null) {
+    // loadAtPrevAct = defaultValue;
+    // }
+    // } else {
+    // loadAtPrevAct = stateManager.getActivityState(prevAct,
+    // InternalStates.LOAD, Capacity.class);
+    // if (loadAtPrevAct == null) {
+    // loadAtPrevAct = defaultValue;
+    // }
+    // }
+    // Capacity vehicleCapacityDimensions =
+    // iFacts.getNewVehicle().getType().getCapacityDimensions();
+    //
+    // if (newAct instanceof PickupShipmentDEPRECATED) {
+    // Capacity newCapacity = Capacity.addup(loadAtPrevAct, newAct.getSize());
+    // if (!newCapacity.isLessOrEqual(vehicleCapacityDimensions)) {
+    // return ConstraintsStatus.NOT_FULFILLED;
+    // }
+    // }
+    // if (newAct instanceof DeliverShipmentDEPRECATED) {
+    // Capacity newCapacity = Capacity.addup(loadAtPrevAct,
+    // Capacity.invert(newAct.getSize()));
+    // if (!newCapacity.isLessOrEqual(vehicleCapacityDimensions)) {
+    // return ConstraintsStatus.NOT_FULFILLED_BREAK;
+    // }
+    // }
+    // return ConstraintsStatus.FULFILLED;
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ServiceDeliveriesFirstConstraint.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ServiceDeliveriesFirstConstraint.java
index 1ed7d4e0c..93f7adc12 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ServiceDeliveriesFirstConstraint.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ServiceDeliveriesFirstConstraint.java
@@ -17,45 +17,117 @@
  */
 package com.graphhopper.jsprit.core.problem.constraint;
 
+import com.graphhopper.jsprit.core.problem.job.Service;
+import com.graphhopper.jsprit.core.problem.job.Shipment;
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliverServiceDEPRECATED;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliverShipmentDEPRECATED;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupServiceDEPRECATED;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupShipmentDEPRECATED;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivityNEW;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivityNEW;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.ServiceActivityNEW;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 
+/**
+ * @author stefan schroeder
+ * @author balage (generic job refactor)
+ *
+ */
 public class ServiceDeliveriesFirstConstraint implements HardActivityConstraint {
 
     @Override
     public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime) {
-        if (newAct instanceof PickupServiceDEPRECATED && nextAct instanceof DeliverServiceDEPRECATED) {
-            return ConstraintsStatus.NOT_FULFILLED;
-        }
-        if (newAct instanceof ServiceActivityNEW && nextAct instanceof DeliverServiceDEPRECATED) {
-            return ConstraintsStatus.NOT_FULFILLED;
-        }
-        if (newAct instanceof DeliverServiceDEPRECATED && prevAct instanceof PickupServiceDEPRECATED) {
-            return ConstraintsStatus.NOT_FULFILLED_BREAK;
-        }
-        if (newAct instanceof DeliverServiceDEPRECATED && prevAct instanceof ServiceActivityNEW) {
-            return ConstraintsStatus.NOT_FULFILLED_BREAK;
-        }
+        // ConstraintsStatus oldRes = old(prevAct, newAct, nextAct);
+        ConstraintsStatus newRes = newMethod(prevAct, newAct, nextAct);
+        // if (oldRes != newRes) {
+        // newRes = newMethod(prevAct, newAct, nextAct);
+        // }
+        // System.out.format("%14s (%4s) > %14s (%4s) > %14s (%4s) ====> %20s :
+        // %20s (%4s)\n",
+        // prevAct.getName(), isShipment(prevAct),
+        // newAct.getName(), isShipment(newAct),
+        // nextAct.getName(), isShipment(nextAct),
+        // oldRes, newRes, (oldRes == newRes));
+        return newRes;
+    }
 
-        if (newAct instanceof DeliverServiceDEPRECATED && prevAct instanceof PickupShipmentDEPRECATED) {
-            return ConstraintsStatus.NOT_FULFILLED_BREAK;
-        }
-        if (newAct instanceof DeliverServiceDEPRECATED && prevAct instanceof DeliverShipmentDEPRECATED) {
-            return ConstraintsStatus.NOT_FULFILLED_BREAK;
-        }
-        if (newAct instanceof PickupShipmentDEPRECATED && nextAct instanceof DeliverServiceDEPRECATED) {
-            return ConstraintsStatus.NOT_FULFILLED;
-        }
-        if (newAct instanceof DeliverShipmentDEPRECATED && nextAct instanceof DeliverServiceDEPRECATED) {
-            return ConstraintsStatus.NOT_FULFILLED;
+    protected ConstraintsStatus newMethod(TourActivity prevAct, TourActivity newAct,
+                    TourActivity nextAct) {
+        if (isShipment(newAct)) {
+            // The new activity is a shipment
+            if (nextAct instanceof DeliveryActivityNEW && isService(nextAct)) {
+                // Next activity can't be a service delivery
+                return ConstraintsStatus.NOT_FULFILLED;
+            }
+        } else {
+            // The new activity is a service
+            if (newAct instanceof PickupActivityNEW || newAct instanceof ServiceActivityNEW) {
+                // The new activity is a pickup or a service
+                if (nextAct instanceof DeliveryActivityNEW && isService(nextAct)) {
+                    // Next activity can't be a service delivera
+                    return ConstraintsStatus.NOT_FULFILLED;
+                }
+            } else if (newAct instanceof DeliveryActivityNEW) {
+                // The new activity is a delivery
+                if (prevAct instanceof PickupActivityNEW || prevAct instanceof ServiceActivityNEW
+                                || (prevAct instanceof DeliveryActivityNEW
+                                                && isShipment(prevAct))) {
+                    // The previous activity can't be a pickup or service (of
+                    // any type of Job), nor a shipment delivery
+                    // (Only service delivery.)
+                    return ConstraintsStatus.NOT_FULFILLED_BREAK;
+                }
+            }
         }
 
         return ConstraintsStatus.FULFILLED;
     }
 
+    protected boolean isShipment(TourActivity newAct) {
+        return newAct instanceof JobActivity && ((JobActivity) newAct).getJob() instanceof Shipment;
+    }
+
+    protected boolean isService(TourActivity newAct) {
+        return newAct instanceof JobActivity && ((JobActivity) newAct).getJob() instanceof Service;
+    }
+
+    // protected ConstraintsStatus old(TourActivity prevAct, TourActivity
+    // newAct,
+    // TourActivity nextAct) {
+    // if (newAct instanceof PickupServiceDEPRECATED
+    // && nextAct instanceof DeliverServiceDEPRECATED) {
+    // return ConstraintsStatus.NOT_FULFILLED;
+    // }
+    // if (newAct instanceof ServiceActivityNEW && nextAct instanceof
+    // DeliverServiceDEPRECATED) {
+    // return ConstraintsStatus.NOT_FULFILLED;
+    // }
+    // if (newAct instanceof DeliverServiceDEPRECATED
+    // && prevAct instanceof PickupServiceDEPRECATED) {
+    // return ConstraintsStatus.NOT_FULFILLED_BREAK;
+    // }
+    // if (newAct instanceof DeliverServiceDEPRECATED && prevAct instanceof
+    // ServiceActivityNEW) {
+    // return ConstraintsStatus.NOT_FULFILLED_BREAK;
+    // }
+    //
+    // if (newAct instanceof DeliverServiceDEPRECATED
+    // && prevAct instanceof PickupShipmentDEPRECATED) {
+    // return ConstraintsStatus.NOT_FULFILLED_BREAK;
+    // }
+    // if (newAct instanceof DeliverServiceDEPRECATED
+    // && prevAct instanceof DeliverShipmentDEPRECATED) {
+    // return ConstraintsStatus.NOT_FULFILLED_BREAK;
+    // }
+    // if (newAct instanceof PickupShipmentDEPRECATED
+    // && nextAct instanceof DeliverServiceDEPRECATED) {
+    // return ConstraintsStatus.NOT_FULFILLED;
+    // }
+    // if (newAct instanceof DeliverShipmentDEPRECATED
+    // && nextAct instanceof DeliverServiceDEPRECATED) {
+    // return ConstraintsStatus.NOT_FULFILLED;
+    // }
+    //
+    // return ConstraintsStatus.FULFILLED;
+    // }
+
+
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ServiceLoadActivityLevelConstraint.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ServiceLoadActivityLevelConstraint.java
index a106a0e29..432a75c3d 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ServiceLoadActivityLevelConstraint.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/constraint/ServiceLoadActivityLevelConstraint.java
@@ -20,9 +20,6 @@
 import com.graphhopper.jsprit.core.algorithm.state.InternalStates;
 import com.graphhopper.jsprit.core.problem.Capacity;
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliverServiceDEPRECATED;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupServiceDEPRECATED;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.ServiceActivityNEW;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.Start;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.state.RouteAndActivityStateGetter;
@@ -71,12 +68,22 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
             }
 
         }
-        if (newAct instanceof PickupServiceDEPRECATED || newAct instanceof ServiceActivityNEW) {
+
+        if (newAct.getSize().isPositive()) {
             if (!Capacity.addup(newAct.getSize(), futureMaxLoad).isLessOrEqual(iFacts.getNewVehicle().getType().getCapacityDimensions())) {
                 return ConstraintsStatus.NOT_FULFILLED;
             }
         }
-        if (newAct instanceof DeliverServiceDEPRECATED) {
+
+        /*
+         * REMARK - Balage - This negating could be a bottleneck if called too
+         * many times. Has to be mesured. If rational, the activities could
+         * store their size as absolute value as well. (We could rename
+         * getSize() as getCargoChange(), and the absolute value as
+         * getCargoSize(). For positive or zero activities as Service and Pickup
+         * they could refer to the same object.)
+         */
+        if (!newAct.getSize().isPositive()) {
             if (!Capacity.addup(Capacity.invert(newAct.getSize()), prevMaxLoad).isLessOrEqual(iFacts.getNewVehicle().getType().getCapacityDimensions())) {
                 return ConstraintsStatus.NOT_FULFILLED_BREAK;
             }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/ReturnedShipment.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/ReturnedShipment.java
new file mode 100644
index 000000000..a7e6df7af
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/ReturnedShipment.java
@@ -0,0 +1,256 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.jsprit.core.problem.job;
+
+import com.graphhopper.jsprit.core.problem.Capacity;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivityNEW;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.ExchangeActivityNEW;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivityNEW;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindowsImpl;
+
+
+/**
+ * Shipment is an implementation of Job and consists of a backhaul and exchange
+ * and an delivery
+ *
+ * @author balage
+ */
+public final class ReturnedShipment extends Shipment {
+
+    public static final String ACTIVITY_NAME_PICKUP = "pickup";
+    public static final String ACTIVITY_NAME_DELIVERY = "delivery";
+    public static final String ACTIVITY_NAME_BACKHAUL = "backhaul";
+
+    /**
+     * Builder that builds the shipment.
+     *
+     * @author schroeder
+     */
+
+    public static final class Builder extends Shipment.BuilderBase<ReturnedShipment, Builder> {
+
+        private double backhaulServiceTime = 0.0;
+
+        private Location backhaulLocation;
+
+        protected TimeWindowsImpl backhaulTimeWindows = new TimeWindowsImpl();
+
+        protected Capacity.Builder backhaulCapacityBuilder = Capacity.Builder.newInstance();
+
+        /**
+         * Returns new instance of this builder.
+         *
+         * @param id
+         *            the id of the shipment which must be a unique identifier
+         *            among all jobs
+         * @return the builder
+         */
+
+        public Builder(String id) {
+            super(id);
+            backhaulTimeWindows = new TimeWindowsImpl();
+        }
+
+        /**
+         * Sets backhaul location.
+         *
+         * @param backhaulLocation
+         *            backhaul location
+         * @return builder
+         */
+
+        public Builder setBackhaulLocation(Location backhaulLocation) {
+            this.backhaulLocation = backhaulLocation;
+            return this;
+        }
+
+        /**
+         * Sets backhaulServiceTime.
+         * <p>
+         * <p>
+         * ServiceTime is intended to be the time the implied activity takes at
+         * the backhaul-location.
+         *
+         * @param serviceTime
+         *            the service time / duration the backhaul of the associated
+         *            shipment takes
+         * @return builder
+         * @throws IllegalArgumentException
+         *             if servicTime < 0.0
+         */
+
+        public Builder setBackhaulServiceTime(double serviceTime) {
+            if (serviceTime < 0.0) {
+                throw new IllegalArgumentException("serviceTime must not be < 0.0");
+            }
+            backhaulServiceTime = serviceTime;
+            return this;
+        }
+
+        /**
+         * Sets the timeWindow for the backhaul, i.e. the time-period in which a
+         * backhaul operation is allowed to START.
+         * <p>
+         * <p>
+         * By default timeWindow is [0.0, Double.MAX_VALUE}
+         *
+         * @param timeWindow
+         *            the time window within the backhaul operation/activity can
+         *            START
+         * @return builder
+         * @throws IllegalArgumentException
+         *             if timeWindow is null
+         */
+
+        public Builder setBackhaulTimeWindow(TimeWindow timeWindow) {
+            if (timeWindow == null) {
+                throw new IllegalArgumentException("backhaul time-window must not be null");
+            }
+            backhaulTimeWindows.clear();
+            backhaulTimeWindows.add(timeWindow);
+            return this;
+        }
+
+
+
+
+        public Builder addBackhaulTimeWindow(TimeWindow timeWindow) {
+            if (timeWindow == null) {
+                throw new IllegalArgumentException("time-window arg must not be null");
+            }
+            backhaulTimeWindows.add(timeWindow);
+            return this;
+        }
+
+
+        public Builder addBackhaulTimeWindow(double earliest, double latest) {
+            addBackhaulTimeWindow(TimeWindow.newInstance(earliest, latest));
+            return this;
+        }
+
+        public Builder addBackhaulSizeDimension(int dimensionIndex, int dimensionValue) {
+            if (dimensionValue < 0) {
+                throw new IllegalArgumentException("capacity value cannot be negative");
+            }
+            backhaulCapacityBuilder.addDimension(dimensionIndex, dimensionValue);
+            return this;
+        }
+
+        public Builder addAllBackhaulSizeDimensions(Capacity size) {
+            for (int i = 0; i < size.getNuOfDimensions(); i++) {
+                backhaulCapacityBuilder.addDimension(i, size.get(i));
+            }
+            return this;
+        }
+
+        @Override
+        protected void validate() {
+            super.validate();
+            if (backhaulLocation == null) {
+                backhaulLocation = getPickupLocation();
+            }
+            if (backhaulTimeWindows.isEmpty()) {
+                backhaulTimeWindows.add(TimeWindow.ETERNITY);
+            }
+        }
+
+        private double getBackhaulServiceTime() {
+            return backhaulServiceTime;
+        }
+
+        private Location getBackhaulLocation() {
+            return backhaulLocation;
+        }
+
+        private TimeWindowsImpl getBackhaulTimeWindows() {
+            return backhaulTimeWindows;
+        }
+
+        private Capacity getBackhaulCapacity() {
+            Capacity backhaulCapacity = backhaulCapacityBuilder.build();
+            // If no capacity is specified, the backhaul capacity will be the
+            // same as the picking one.
+            if (backhaulCapacity.getNuOfDimensions() == 0) {
+                backhaulCapacity = getCapacity();
+            }
+            return backhaulCapacity;
+        }
+
+        public static Builder newInstance(String id) {
+            return new Builder(id);
+        }
+
+        @Override
+        protected ReturnedShipment createInstance() {
+            return new ReturnedShipment(this);
+        }
+    }
+
+
+
+    ReturnedShipment(BuilderBase<? extends ReturnedShipment, ?> builder) {
+        super(builder);
+    }
+
+
+    @Override
+    protected void createActivities(JobBuilder<?, ?> builder) {
+        Builder shipmentBuilder = (Builder) builder;
+        JobActivityList list = new SequentialJobActivityList(this);
+        list.addActivity(new PickupActivityNEW(this, ACTIVITY_NAME_PICKUP,
+                        shipmentBuilder.getPickupLocation(),
+                        shipmentBuilder.getPickupServiceTime(), shipmentBuilder.getCapacity(),
+                        shipmentBuilder.getPickupTimeWindows().getTimeWindows()));
+        list.addActivity(new ExchangeActivityNEW(this, ACTIVITY_NAME_DELIVERY,
+                        shipmentBuilder.getDeliveryLocation(),
+                        shipmentBuilder.getDeliveryServiceTime(),
+                        Capacity.subtract(shipmentBuilder.getBackhaulCapacity(),
+                                        shipmentBuilder.getCapacity()),
+                        shipmentBuilder.getDeliveryTimeWindows().getTimeWindows()));
+        list.addActivity(new DeliveryActivityNEW(this, ACTIVITY_NAME_BACKHAUL,
+                        shipmentBuilder.getBackhaulLocation(),
+                        shipmentBuilder.getBackhaulServiceTime(),
+                        shipmentBuilder.getBackhaulCapacity(),
+                        shipmentBuilder.getBackhaulTimeWindows().getTimeWindows()));
+        setActivities(list);
+    }
+
+    // TODO: RENAME WHEN SHIPMENT IS RETURNING THE SAME TYPE OF ACTIVIT
+    public PickupActivityNEW getPickupActivityTO_BE_RENAMED_LATER() {
+        return (PickupActivityNEW) getActivityList()
+                        .findByType(ACTIVITY_NAME_PICKUP)
+                        .get();
+    }
+
+    // TODO: RENAME WHEN SHIPMENT IS RETURNING THE SAME TYPE OF ACTIVIT
+    public ExchangeActivityNEW getDeliveryActivityTO_BE_RENAMED_LATER() {
+        return (ExchangeActivityNEW) getActivityList()
+                        .findByType(ACTIVITY_NAME_DELIVERY)
+                        .get();
+    }
+
+    public DeliveryActivityNEW getBackhaulActivityTO_BE_RENAMED_LATER() {
+        return (DeliveryActivityNEW) getActivityList()
+                        .findByType(ACTIVITY_NAME_BACKHAUL)
+                        .get();
+    }
+
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
index 4caccdfe0..5f1086181 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Service.java
@@ -174,7 +174,7 @@ protected void validate() {
                 throw new IllegalArgumentException("location is missing");
             }
             if (timeWindows.isEmpty()) {
-                timeWindows.add(new TimeWindow(0, Double.MAX_VALUE));
+                timeWindows.add(TimeWindow.ETERNITY);
             }
         }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
index 62bafb860..049dfdc1c 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/Shipment.java
@@ -249,10 +249,10 @@ protected void validate() {
                 throw new IllegalArgumentException("delivery location is missing");
             }
             if (pickupTimeWindows.isEmpty()) {
-                pickupTimeWindows.add(new TimeWindow(0, Double.MAX_VALUE));
+                pickupTimeWindows.add(TimeWindow.ETERNITY);
             }
             if (deliveryTimeWindows.isEmpty()) {
-                deliveryTimeWindows.add(new TimeWindow(0, Double.MAX_VALUE));
+                deliveryTimeWindows.add(TimeWindow.ETERNITY);
             }
         }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRoute.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRoute.java
index c36d346fc..0f8334c86 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRoute.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/VehicleRoute.java
@@ -39,7 +39,6 @@
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivities;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivityFactory;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DefaultTourActivityFactory.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DefaultTourActivityFactory.java
deleted file mode 100644
index fae304948..000000000
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DefaultTourActivityFactory.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.problem.solution.route.activity;
-
-import com.graphhopper.jsprit.core.problem.job.Delivery;
-import com.graphhopper.jsprit.core.problem.job.Pickup;
-import com.graphhopper.jsprit.core.problem.job.Service;
-
-public class DefaultTourActivityFactory implements TourActivityFactory {
-
-    @Override
-    public AbstractActivityNEW createActivity(Service service) {
-        AbstractActivityNEW act;
-        if (service instanceof Pickup) {
-            act = new PickupServiceDEPRECATED(service);
-        } else if (service instanceof Delivery) {
-            act = new DeliverServiceDEPRECATED((Delivery) service);
-        } else {
-            act = new PickupServiceDEPRECATED(service);
-        }
-        return act;
-    }
-
-}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindow.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindow.java
index 7ded1e0b3..f0dc03e38 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindow.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindow.java
@@ -25,6 +25,11 @@
 
 public class TimeWindow {
 
+    /**
+     * A time window of eternity.
+     */
+    public static final TimeWindow ETERNITY = new TimeWindow(0, Double.MAX_VALUE);
+
     /**
      * Returns new instance of TimeWindow.
      *
@@ -49,10 +54,12 @@ public static TimeWindow newInstance(double start, double end) {
      */
     public TimeWindow(double start, double end) {
         super();
-        if (start < 0.0 || end < 0.0)
+        if (start < 0.0 || end < 0.0) {
             throw new IllegalArgumentException("neither time window start nor end must be < 0.0: " + "[start=" + start + "][end=" + end + "]");
-        if (end < start)
+        }
+        if (end < start) {
             throw new IllegalArgumentException("time window end cannot be smaller than its start: " + "[start=" + start + "][end=" + end + "]");
+        }
         this.start = start;
         this.end = end;
     }
@@ -97,18 +104,23 @@ public int hashCode() {
      */
     @Override
     public boolean equals(Object obj) {
-        if (this == obj)
+        if (this == obj) {
             return true;
-        if (obj == null)
+        }
+        if (obj == null) {
             return false;
-        if (getClass() != obj.getClass())
+        }
+        if (getClass() != obj.getClass()) {
             return false;
+        }
         TimeWindow other = (TimeWindow) obj;
-        if (Double.doubleToLongBits(end) != Double.doubleToLongBits(other.end))
+        if (Double.doubleToLongBits(end) != Double.doubleToLongBits(other.end)) {
             return false;
+        }
         if (Double.doubleToLongBits(start) != Double
-            .doubleToLongBits(other.start))
+                        .doubleToLongBits(other.start)) {
             return false;
+        }
         return true;
     }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindows.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindows.java
index 615100a92..0e49736f1 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindows.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindows.java
@@ -25,6 +25,11 @@
  */
 public interface TimeWindows {
 
-    public Collection<TimeWindow> getTimeWindows();
+    /**
+     * A TimeWindows implementation which contains a single time window of
+     * eternity.
+     */
+    public final TimeWindows ANY_TIME = TimeWindowsImpl.INTERNAL_ANY_TIME;
 
+    public Collection<TimeWindow> getTimeWindows();
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindowsImpl.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindowsImpl.java
index a407438ed..f83e83e1e 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindowsImpl.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TimeWindowsImpl.java
@@ -27,6 +27,27 @@
  */
 public class TimeWindowsImpl implements TimeWindows {
 
+    static {
+        INTERNAL_ANY_TIME = anyTime();
+    }
+
+    /**
+     * This is an unmodifiable constant containing an instant of
+     * {@linkplain #anyTime()}.
+     */
+    public static final TimeWindows INTERNAL_ANY_TIME;
+
+    /**
+     * Creates a new instance containing only an eternal time window.
+     *
+     * @return The time window implementation.
+     */
+    public static TimeWindowsImpl anyTime() {
+        TimeWindowsImpl impl = new TimeWindowsImpl();
+        impl.add(TimeWindow.ETERNITY);
+        return impl;
+    }
+
     private Collection<TimeWindow> timeWindows = new ArrayList<TimeWindow>();
 
     public void add(TimeWindow timeWindow){
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TourActivityFactory.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TourActivityFactory.java
deleted file mode 100644
index 49f4a56de..000000000
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/solution/route/activity/TourActivityFactory.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.problem.solution.route.activity;
-
-import com.graphhopper.jsprit.core.problem.job.Service;
-
-public interface TourActivityFactory {
-
-    public AbstractActivityNEW createActivity(Service service);
-
-}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleType.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleType.java
index 9847f4ba6..f2ff25d79 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleType.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleType.java
@@ -47,6 +47,13 @@
      */
     public double getMaxVelocity();
 
+    /**
+     * Returns the average speed of this vehicle-type.
+     *
+     * @return max velocity
+     */
+    public double getAvgVelocity();
+
     /**
      * Return the cost-parameter of this vehicle-type.
      *
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeImpl.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeImpl.java
index 864d978ce..108d8bc95 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeImpl.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/vehicle/VehicleTypeImpl.java
@@ -53,25 +53,25 @@ private VehicleCostParams(double fix, double perTimeUnit, double perDistanceUnit
             super();
             this.fix = fix;
             this.perTimeUnit = perTimeUnit;
-            this.perTransportTimeUnit = perTimeUnit;
+            perTransportTimeUnit = perTimeUnit;
             this.perDistanceUnit = perDistanceUnit;
-            this.perWaitingTimeUnit = 0.;
-            this.perServiceTimeUnit = 0.;
+            perWaitingTimeUnit = 0.;
+            perServiceTimeUnit = 0.;
         }
 
         public VehicleCostParams(double fix, double perTimeUnit, double perDistanceUnit, double perWaitingTimeUnit) {
             this.fix = fix;
             this.perTimeUnit = perTimeUnit;
-            this.perTransportTimeUnit = perTimeUnit;
+            perTransportTimeUnit = perTimeUnit;
             this.perDistanceUnit = perDistanceUnit;
             this.perWaitingTimeUnit = perWaitingTimeUnit;
-            this.perServiceTimeUnit = 0.;
+            perServiceTimeUnit = 0.;
         }
 
         public VehicleCostParams(double fix, double perTimeUnit, double perDistanceUnit, double perWaitingTimeUnit, double perServiceTimeUnit) {
             this.fix = fix;
             this.perTimeUnit = perTimeUnit;
-            this.perTransportTimeUnit = perTimeUnit;
+            perTransportTimeUnit = perTimeUnit;
             this.perDistanceUnit = perDistanceUnit;
             this.perWaitingTimeUnit = perWaitingTimeUnit;
             this.perServiceTimeUnit = perServiceTimeUnit;
@@ -92,13 +92,16 @@ public String toString() {
 
 
         public static VehicleTypeImpl.Builder newInstance(String id) {
-            if (id == null) throw new IllegalArgumentException();
+            if (id == null) {
+                throw new IllegalArgumentException();
+            }
             return new Builder(id);
         }
 
         private String id;
         private int capacity = 0;
         private double maxVelo = Double.MAX_VALUE;
+        private double avgVelocity = 1d;
         /**
          * default cost values for default vehicle type
          */
@@ -128,22 +131,45 @@ private Builder(String id) {
          * @throws IllegalArgumentException if velocity is smaller than zero
          */
         public VehicleTypeImpl.Builder setMaxVelocity(double inMeterPerSeconds) {
-            if (inMeterPerSeconds < 0.0) throw new IllegalArgumentException("velocity cannot be smaller than zero");
-            this.maxVelo = inMeterPerSeconds;
+            if (inMeterPerSeconds < 0.0) {
+                throw new IllegalArgumentException("velocity cannot be smaller than zero");
+            }
+            maxVelo = inMeterPerSeconds;
+            return this;
+        }
+
+        /**
+         * Sets the average velocity this vehicle-type can go [in meter per
+         * seconds]. Used for travel time calculation.
+         *
+         * @param inMeterPerSeconds
+         * @return this builder
+         * @throws IllegalArgumentException
+         *             if velocity is smaller than zero
+         */
+        public VehicleTypeImpl.Builder setAverageVelocity(double inMeterPerSeconds) {
+            if (inMeterPerSeconds < 0.0) {
+                throw new IllegalArgumentException("average speed cannot be smaller than zero");
+            }
+            avgVelocity = inMeterPerSeconds;
             return this;
         }
 
         /**
          * Sets the fixed costs of the vehicle-type.
          * <p>
-         * <p>by default it is 0.
+         * <p>
+         * by default it is 0.
          *
          * @param fixedCost
          * @return this builder
-         * @throws IllegalArgumentException if fixedCost is smaller than zero
+         * @throws IllegalArgumentException
+         *             if fixedCost is smaller than zero
          */
         public VehicleTypeImpl.Builder setFixedCost(double fixedCost) {
-            if (fixedCost < 0.0) throw new IllegalArgumentException("fixed costs cannot be smaller than zero");
+            if (fixedCost < 0.0) {
+                throw new IllegalArgumentException("fixed costs cannot be smaller than zero");
+            }
             this.fixedCost = fixedCost;
             return this;
         }
@@ -158,7 +184,9 @@ private Builder(String id) {
          * @throws IllegalArgumentException if perDistance is smaller than zero
          */
         public VehicleTypeImpl.Builder setCostPerDistance(double perDistance) {
-            if (perDistance < 0.0) throw new IllegalArgumentException("cost per distance must not be smaller than zero");
+            if (perDistance < 0.0) {
+                throw new IllegalArgumentException("cost per distance must not be smaller than zero");
+            }
             this.perDistance = perDistance;
             return this;
         }
@@ -175,7 +203,9 @@ private Builder(String id) {
          */
         @Deprecated
         public VehicleTypeImpl.Builder setCostPerTime(double perTime) {
-            if (perTime < 0.0) throw new IllegalArgumentException();
+            if (perTime < 0.0) {
+                throw new IllegalArgumentException();
+            }
             this.perTime = perTime;
             return this;
         }
@@ -190,7 +220,9 @@ private Builder(String id) {
          * @throws IllegalArgumentException if costPerTime is smaller than zero
          */
         public VehicleTypeImpl.Builder setCostPerTransportTime(double perTime) {
-            if (perTime < 0.0) throw new IllegalArgumentException();
+            if (perTime < 0.0) {
+                throw new IllegalArgumentException();
+            }
             this.perTime = perTime;
             return this;
         }
@@ -205,7 +237,9 @@ private Builder(String id) {
          * @throws IllegalArgumentException if costPerTime is smaller than zero
          */
         public VehicleTypeImpl.Builder setCostPerWaitingTime(double perWaitingTime) {
-            if (perWaitingTime < 0.0) throw new IllegalArgumentException();
+            if (perWaitingTime < 0.0) {
+                throw new IllegalArgumentException();
+            }
             this.perWaitingTime = perWaitingTime;
             return this;
         }
@@ -237,11 +271,14 @@ public VehicleTypeImpl build() {
          * @throws IllegalArgumentException    if capacity dimension is already set
          */
         public Builder addCapacityDimension(int dimIndex, int dimVal) {
-            if (dimVal < 0) throw new IllegalArgumentException("capacity value cannot be negative");
-            if (capacityDimensions != null)
+            if (dimVal < 0) {
+                throw new IllegalArgumentException("capacity value cannot be negative");
+            }
+            if (capacityDimensions != null) {
                 throw new IllegalArgumentException("either build your dimension with build your dimensions with " +
-                    "addCapacityDimension(int dimIndex, int dimVal) or set the already built dimensions with .setCapacityDimensions(Capacity capacity)." +
-                    "You used both methods.");
+                                "addCapacityDimension(int dimIndex, int dimVal) or set the already built dimensions with .setCapacityDimensions(Capacity capacity)." +
+                                "You used both methods.");
+            }
             dimensionAdded = true;
             capacityBuilder.addDimension(dimIndex, dimVal);
             return this;
@@ -259,11 +296,12 @@ public Builder addCapacityDimension(int dimIndex, int dimVal) {
          * @throws IllegalArgumentException if capacityDimension has already been added
          */
         public Builder setCapacityDimensions(Capacity capacity) {
-            if (dimensionAdded)
+            if (dimensionAdded) {
                 throw new IllegalArgumentException("either build your dimension with build your dimensions with " +
-                    "addCapacityDimension(int dimIndex, int dimVal) or set the already built dimensions with .setCapacityDimensions(Capacity capacity)." +
-                    "You used both methods.");
-            this.capacityDimensions = capacity;
+                                "addCapacityDimension(int dimIndex, int dimVal) or set the already built dimensions with .setCapacityDimensions(Capacity capacity)." +
+                                "You used both methods.");
+            }
+            capacityDimensions = capacity;
             return this;
         }
 
@@ -278,7 +316,7 @@ public int hashCode() {
         final int prime = 31;
         int result = 1;
         result = prime * result
-            + ((typeId == null) ? 0 : typeId.hashCode());
+                        + ((typeId == null) ? 0 : typeId.hashCode());
         return result;
     }
 
@@ -287,18 +325,23 @@ public int hashCode() {
      */
     @Override
     public boolean equals(Object obj) {
-        if (this == obj)
+        if (this == obj) {
             return true;
-        if (obj == null)
+        }
+        if (obj == null) {
             return false;
-        if (getClass() != obj.getClass())
+        }
+        if (getClass() != obj.getClass()) {
             return false;
+        }
         VehicleTypeImpl other = (VehicleTypeImpl) obj;
         if (typeId == null) {
-            if (other.typeId != null)
+            if (other.typeId != null) {
                 return false;
-        } else if (!typeId.equals(other.typeId))
+            }
+        } else if (!typeId.equals(other.typeId)) {
             return false;
+        }
         return true;
     }
 
@@ -314,6 +357,8 @@ public boolean equals(Object obj) {
 
     private final double maxVelocity;
 
+    private final double avgVelocity;
+
     /**
      * priv constructor constructing vehicle-type
      *
@@ -323,6 +368,7 @@ private VehicleTypeImpl(VehicleTypeImpl.Builder builder) {
         typeId = builder.id;
         capacity = builder.capacity;
         maxVelocity = builder.maxVelo;
+        avgVelocity = builder.avgVelocity;
         vehicleCostParams = new VehicleCostParams(builder.fixedCost, builder.perTime, builder.perDistance, builder.perWaitingTime, builder.perServiceTime);
         capacityDimensions = builder.capacityDimensions;
         profile = builder.profile;
@@ -347,8 +393,8 @@ public String getTypeId() {
     @Override
     public String toString() {
         return "[typeId=" + typeId + "]" +
-            "[capacity=" + capacityDimensions + "]" +
-            "[costs=" + vehicleCostParams + "]";
+                        "[capacity=" + capacityDimensions + "]" +
+                        "[costs=" + vehicleCostParams + "]";
     }
 
     @Override
@@ -356,6 +402,11 @@ public double getMaxVelocity() {
         return maxVelocity;
     }
 
+    @Override
+    public double getAvgVelocity() {
+        return avgVelocity;
+    }
+
     @Override
     public Capacity getCapacityDimensions() {
         return capacityDimensions;
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
index 4fe635405..ce6b7eb40 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/reporting/SolutionPrinter.java
@@ -32,6 +32,7 @@
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.solution.VehicleRoutingProblemSolution;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.AbstractActivityNEW;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 
@@ -172,7 +173,7 @@ private static void printVerbose(PrintWriter out, VehicleRoutingProblem problem,
             out.format("+---------+----------------------+-----------------------+-----------------+-----------------+-----------------+-----------------+%n");
             double costs = 0;
             out.format(leftAlgin, routeNu, getVehicleString(route), route.getStart().getName(), "-", "undef", Math.round(route.getStart().getEndTime()),
-                    Math.round(costs));
+                            Math.round(costs));
             TourActivity prevAct = route.getStart();
             for (TourActivity act : route.getActivities()) {
                 String jobId;
@@ -181,20 +182,23 @@ private static void printVerbose(PrintWriter out, VehicleRoutingProblem problem,
                 } else {
                     jobId = "-";
                 }
+                String type = (act instanceof AbstractActivityNEW)
+                                ? ((AbstractActivityNEW) act).getType() : act.getName();
                 double c = problem.getTransportCosts().getTransportCost(prevAct.getLocation(), act.getLocation(), prevAct.getEndTime(), route.getDriver(),
-                        route.getVehicle());
+                                route.getVehicle());
                 c += problem.getActivityCosts().getActivityCost(act, act.getArrTime(), route.getDriver(), route.getVehicle());
                 costs += c;
-                out.format(leftAlgin, routeNu, getVehicleString(route), act.getName(), jobId, Math.round(act.getArrTime()),
-                        Math.round(act.getEndTime()), Math.round(costs));
+                out.format(leftAlgin, routeNu, getVehicleString(route), type, jobId,
+                                Math.round(act.getArrTime()),
+                                Math.round(act.getEndTime()), Math.round(costs));
                 prevAct = act;
             }
             double c = problem.getTransportCosts().getTransportCost(prevAct.getLocation(), route.getEnd().getLocation(), prevAct.getEndTime(),
-                    route.getDriver(), route.getVehicle());
+                            route.getDriver(), route.getVehicle());
             c += problem.getActivityCosts().getActivityCost(route.getEnd(), route.getEnd().getArrTime(), route.getDriver(), route.getVehicle());
             costs += c;
             out.format(leftAlgin, routeNu, getVehicleString(route), route.getEnd().getName(), "-", Math.round(route.getEnd().getArrTime()), "undef",
-                    Math.round(costs));
+                            Math.round(costs));
             routeNu++;
         }
         out.format("+--------------------------------------------------------------------------------------------------------------------------------+%n");
@@ -216,8 +220,8 @@ private static String getVehicleString(VehicleRoute route) {
 
     private static Map<Class<? extends Job>, Long> getNuOfJobs(VehicleRoutingProblem problem) {
         return problem.getJobs().values().stream()
-                .map(j -> (Class<? extends Job>) j.getClass())
-                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
+                        .map(j -> (Class<? extends Job>) j.getClass())
+                        .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
     }
 
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/CrowFlyCosts.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/CrowFlyCosts.java
index 6d75ca7c9..39921a99f 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/CrowFlyCosts.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/CrowFlyCosts.java
@@ -20,82 +20,19 @@
  */
 package com.graphhopper.jsprit.core.util;
 
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.cost.AbstractForwardVehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.cost.TransportDistance;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.distance.EuclideanDistanceCalculator;
 
 
 /**
  * @author stefan schroeder
+ *
+ * @deprecated Use instead new {@linkplain DefaultCosts} with
+ *             {@link EuclideanDistanceCalculator#getInstance()}
  */
-public class CrowFlyCosts extends AbstractForwardVehicleRoutingTransportCosts implements TransportDistance {
-
-    public int speed = 1;
-
-    public double detourFactor = 1.0;
-
-    private Locations locations;
-
-    public CrowFlyCosts(Locations locations) {
-        super();
-        this.locations = locations;
-    }
-
-    @Override
-    public String toString() {
-        return "[name=crowFlyCosts]";
-    }
-
-    @Override
-    public double getTransportCost(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
-        double distance;
-        try {
-            distance = calculateDistance(from, to);
-        } catch (NullPointerException e) {
-            throw new NullPointerException("cannot calculate euclidean distance. coordinates are missing. either add coordinates or use another transport-cost-calculator.");
-        }
-        double costs = distance;
-        if (vehicle != null) {
-            if (vehicle.getType() != null) {
-                costs = distance * vehicle.getType().getVehicleCostParams().perDistanceUnit;
-            }
-        }
-        return costs;
-    }
-
-    private double calculateDistance(Location fromLocation, Location toLocation) {
-        Coordinate from = null;
-        Coordinate to = null;
-        if (fromLocation.getCoordinate() != null & toLocation.getCoordinate() != null) {
-            from = fromLocation.getCoordinate();
-            to = toLocation.getCoordinate();
-        } else if (locations != null) {
-            from = locations.getCoord(fromLocation.getId());
-            to = locations.getCoord(toLocation.getId());
-        }
-        if (from == null || to == null) throw new NullPointerException();
-        return calculateDistance(from, to);
-    }
-
-    private double calculateDistance(Coordinate from, Coordinate to) {
-        return EuclideanDistanceCalculator.calculateDistance(from, to) * detourFactor;
-    }
-
-    @Override
-    public double getTransportTime(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
-        double distance;
-        try {
-            distance = calculateDistance(from, to);
-        } catch (NullPointerException e) {
-            throw new NullPointerException("cannot calculate euclidean distance. coordinates are missing. either add coordinates or use another transport-cost-calculator.");
-        }
-        return distance / speed;
-    }
+@Deprecated
+public class CrowFlyCosts extends DefaultCosts {
 
-    @Override
-    public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-        return calculateDistance(from, to);
+    public CrowFlyCosts() {
+        super(EuclideanDistanceCalculator.getInstance());
     }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/DefaultCosts.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/DefaultCosts.java
new file mode 100644
index 000000000..52366feff
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/DefaultCosts.java
@@ -0,0 +1,120 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ *
+ */
+package com.graphhopper.jsprit.core.util;
+
+import com.graphhopper.jsprit.core.distance.DistanceCalculator;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.cost.AbstractForwardVehicleRoutingTransportCosts;
+import com.graphhopper.jsprit.core.problem.cost.TransportDistance;
+import com.graphhopper.jsprit.core.problem.driver.Driver;
+import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+
+
+/**
+ * @author stefan schroeder
+ */
+public class DefaultCosts extends AbstractForwardVehicleRoutingTransportCosts implements TransportDistance {
+
+    private double detourFactor = 1.0;
+
+    private DistanceCalculator distanceCalculator;
+
+    private Locations coordinateConverter;
+
+    public DefaultCosts(DistanceCalculator distanceCalculator) {
+        super();
+        this.distanceCalculator = distanceCalculator;
+    }
+
+    public Locations getPredefinedLocations() {
+        return coordinateConverter;
+    }
+
+    public DefaultCosts withCoordinateConverter(Locations coordinateConverter) {
+        this.coordinateConverter = coordinateConverter;
+        return this;
+    }
+
+    public double getDetourFactor() {
+        return detourFactor;
+    }
+
+    public DefaultCosts withDetourFactor(double detourFactor) {
+        this.detourFactor = detourFactor;
+        return this;
+    }
+
+    @Override
+    public String toString() {
+        return "[name=" + distanceCalculator.getName() + "]";
+    }
+
+    @Override
+    public double getTransportCost(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
+        double distance;
+        try {
+            distance = calculateDistance(from, to);
+        } catch (NullPointerException e) {
+            throw new NullPointerException("cannot calculate euclidean distance. coordinates are missing. either add coordinates or use another transport-cost-calculator.");
+        }
+        double costs = distance;
+        if (vehicle != null) {
+            if (vehicle.getType() != null) {
+                costs = distance * vehicle.getType().getVehicleCostParams().perDistanceUnit;
+            }
+        }
+        return costs;
+    }
+
+    private double calculateDistance(Location fromLocation, Location toLocation) {
+        Coordinate from = getCoordinate(fromLocation);
+        Coordinate to = getCoordinate(toLocation);
+
+        return distanceCalculator.calculateDistance(from, to) * detourFactor;
+    }
+
+
+    protected Coordinate getCoordinate(Location location) {
+        if (location.getCoordinate() != null) {
+            return location.getCoordinate();
+        } else if (coordinateConverter != null) {
+            return coordinateConverter.getCoord(location.getId());
+        }
+        throw new NullPointerException("Coordinates are missing in " + location);
+    }
+
+    @Override
+    public double getTransportTime(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
+        double distance = calculateDistance(from, to);
+        if (vehicle != null) {
+            if (vehicle.getType() != null) {
+                distance = distance / vehicle.getType().getAvgVelocity();
+            }
+        }
+
+        return distance;
+    }
+
+    @Override
+    public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+        return calculateDistance(from, to);
+    }
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/EuclideanCosts.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/EuclideanCosts.java
index d8f981e70..3d9dadf14 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/EuclideanCosts.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/EuclideanCosts.java
@@ -20,72 +20,20 @@
  */
 package com.graphhopper.jsprit.core.util;
 
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.cost.AbstractForwardVehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.cost.TransportDistance;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.distance.EuclideanDistanceCalculator;
 
 
 /**
  * @author stefan schroeder
+ *
+ * @deprecated Use instead new {@linkplain DefaultCosts} with
+ *             {@link EuclideanDistanceCalculator#getInstance()}
  */
-public class EuclideanCosts extends AbstractForwardVehicleRoutingTransportCosts implements TransportDistance {
-
-    public int speed = 1;
-
-    public double detourFactor = 1.0;
-
-    @Override
-    public String toString() {
-        return "[name=crowFlyCosts]";
-    }
-
-    @Override
-    public double getTransportCost(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
-        double distance;
-        try {
-            distance = calculateDistance(from, to);
-        } catch (NullPointerException e) {
-            throw new NullPointerException("cannot calculate euclidean distance. coordinates are missing. either add coordinates or use another transport-cost-calculator.");
-        }
-        double costs = distance;
-        if (vehicle != null) {
-            if (vehicle.getType() != null) {
-                costs = distance * vehicle.getType().getVehicleCostParams().perDistanceUnit;
-            }
-        }
-        return costs;
-    }
-
-    private double calculateDistance(Location fromLocation, Location toLocation) {
-        Coordinate from = null;
-        Coordinate to = null;
-        if (fromLocation.getCoordinate() != null & toLocation.getCoordinate() != null) {
-            from = fromLocation.getCoordinate();
-            to = toLocation.getCoordinate();
-        }
-        if (from == null || to == null) throw new NullPointerException();
-        return calculateDistance(from, to);
-    }
 
-    private double calculateDistance(Coordinate from, Coordinate to) {
-        return EuclideanDistanceCalculator.calculateDistance(from, to) * detourFactor;
-    }
-
-    @Override
-    public double getTransportTime(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
-        double distance;
-        try {
-            distance = calculateDistance(from, to);
-        } catch (NullPointerException e) {
-            throw new NullPointerException("cannot calculate euclidean distance. coordinates are missing. either add coordinates or use another transport-cost-calculator.");
-        }
-        return distance / speed;
-    }
+@Deprecated
+public class EuclideanCosts extends DefaultCosts {
 
-    @Override
-    public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-        return calculateDistance(from, to);
+    public EuclideanCosts() {
+        super(EuclideanDistanceCalculator.getInstance());
     }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/EuclideanDistanceCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/EuclideanDistanceCalculator.java
deleted file mode 100644
index 4ee5c91d0..000000000
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/EuclideanDistanceCalculator.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.util;
-
-
-public class EuclideanDistanceCalculator {
-
-    public static double calculateDistance(Coordinate coord1, Coordinate coord2) {
-        double xDiff = coord1.getX() - coord2.getX();
-        double yDiff = coord1.getY() - coord2.getY();
-        return Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));
-    }
-
-}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/GreatCircleCosts.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/GreatCircleCosts.java
index 7d26d18af..b0687a198 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/GreatCircleCosts.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/GreatCircleCosts.java
@@ -18,85 +18,100 @@
 package com.graphhopper.jsprit.core.util;
 
 
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.cost.AbstractForwardVehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.cost.TransportDistance;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.distance.ManhattanDistanceCalculator;
+import com.graphhopper.jsprit.core.distance.SphericalDistanceCalculator;
 
 /**
  * @author stefan schroeder
+ *
+ * @deprecated Use instead new {@linkplain DefaultCosts} with
+ *             {@link ManhattanDistanceCalculator#getInstance()}
  */
+@Deprecated
+public class GreatCircleCosts extends DefaultCosts {
 
-public class GreatCircleCosts extends AbstractForwardVehicleRoutingTransportCosts implements TransportDistance {
-
-    private double speed = 1.;
-
-    private double detour = 1.;
-
-    public void setSpeed(double speed) {
-        this.speed = speed;
-    }
-
-    /**
-     * Sets the detour factor.
-     * <p>
-     * The distance is calculated by the great circle distance * detour factor.
-     * </p>
-     *
-     * @param detour
-     */
-    public void setDetour(double detour) {
-        this.detour = detour;
+    public GreatCircleCosts() {
+        super(SphericalDistanceCalculator.getInstance());
     }
 
-    private DistanceUnit distanceUnit = DistanceUnit.Kilometer;
-
-   public GreatCircleCosts() {
-        super();
-    }
-
-    public GreatCircleCosts(DistanceUnit distanceUnit) {
-        super();
-        this.distanceUnit = distanceUnit;
-    }
-
-
-    @Override
-    public double getTransportCost(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
-        double distance;
-        try {
-            distance = calculateDistance(from, to);
-        } catch (NullPointerException e) {
-            throw new NullPointerException("cannot calculate euclidean distance. coordinates are missing. either add coordinates or use another transport-cost-calculator.");
-        }
-        double costs = distance;
-        if (vehicle != null) {
-            if (vehicle.getType() != null) {
-                costs = distance * vehicle.getType().getVehicleCostParams().perDistanceUnit;
-            }
-        }
-        return costs;
-    }
-
-    private double calculateDistance(Location fromLocation, Location toLocation) {
-        Coordinate from = null;
-        Coordinate to = null;
-        if (fromLocation.getCoordinate() != null && toLocation.getCoordinate() != null) {
-            from = fromLocation.getCoordinate();
-            to = toLocation.getCoordinate();
-        }
-        if (from == null || to == null) throw new NullPointerException("either from or to location is null");
-        return GreatCircleDistanceCalculator.calculateDistance(from, to, distanceUnit) * detour;
-    }
-
-    @Override
-    public double getTransportTime(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
-        return calculateDistance(from, to) / speed;
-    }
-
-    @Override
-    public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-        return calculateDistance(from, to);
-    }
+    // private double speed = 1.;
+    //
+    // private double detour = 1.;
+    //
+    // public void setSpeed(double speed) {
+    // this.speed = speed;
+    // }
+    //
+    // /**
+    // * Sets the detour factor.
+    // * <p>
+    // * The distance is calculated by the great circle distance * detour
+    // factor.
+    // * </p>
+    // *
+    // * @param detour
+    // */
+    // public void setDetour(double detour) {
+    // this.detour = detour;
+    // }
+    //
+    // private DistanceUnit distanceUnit = DistanceUnit.Kilometer;
+    //
+    // public GreatCircleCosts() {
+    // super();
+    // }
+    //
+    // public GreatCircleCosts(DistanceUnit distanceUnit) {
+    // super();
+    // this.distanceUnit = distanceUnit;
+    // }
+    //
+    //
+    // @Override
+    // public double getTransportCost(Location from, Location to, double time,
+    // Driver driver, Vehicle vehicle) {
+    // double distance;
+    // try {
+    // distance = calculateDistance(from, to);
+    // } catch (NullPointerException e) {
+    // throw new NullPointerException("cannot calculate euclidean distance.
+    // coordinates are missing. either add coordinates or use another
+    // transport-cost-calculator.");
+    // }
+    // double costs = distance;
+    // if (vehicle != null) {
+    // if (vehicle.getType() != null) {
+    // costs = distance *
+    // vehicle.getType().getVehicleCostParams().perDistanceUnit;
+    // }
+    // }
+    // return costs;
+    // }
+    //
+    // private double calculateDistance(Location fromLocation, Location
+    // toLocation) {
+    // Coordinate from = null;
+    // Coordinate to = null;
+    // if (fromLocation.getCoordinate() != null && toLocation.getCoordinate() !=
+    // null) {
+    // from = fromLocation.getCoordinate();
+    // to = toLocation.getCoordinate();
+    // }
+    // if (from == null || to == null) throw new NullPointerException("either
+    // from or to location is null");
+    // return GreatCircleDistanceCalculator.calculateDistance(from, to,
+    // distanceUnit) * detour;
+    // }
+    //
+    // @Override
+    // public double getTransportTime(Location from, Location to, double time,
+    // Driver driver, Vehicle vehicle) {
+    // return calculateDistance(from, to) / speed;
+    // }
+    //
+    // @Override
+    // public double getDistance(Location from, Location to, double
+    // departureTime, Vehicle vehicle) {
+    // return calculateDistance(from, to);
+    // }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/GreatCircleDistanceCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/GreatCircleDistanceCalculator.java
deleted file mode 100644
index fbac56179..000000000
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/GreatCircleDistanceCalculator.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.graphhopper.jsprit.core.util;
-
-/**
- * Created by schroeder on 28.11.14.
- */
-public class GreatCircleDistanceCalculator {
-
-    private static final double R = 6372.8; // km
-
-    /**
-     * Harversine method.
-     * <p>
-     * double lon1 = coord1.getX();
-     * double lon2 = coord2.getX();
-     * double lat1 = coord1.getY();
-     * double lat2 = coord2.getY();
-     *
-     * @param coord1 - from coord
-     * @param coord2 - to coord
-     * @return great circle distance
-     */
-    public static double calculateDistance(Coordinate coord1, Coordinate coord2, DistanceUnit distanceUnit) {
-        double lon1 = coord1.getX();
-        double lon2 = coord2.getX();
-        double lat1 = coord1.getY();
-        double lat2 = coord2.getY();
-
-        double delta_Lat = Math.toRadians(lat2 - lat1);
-        double delta_Lon = Math.toRadians(lon2 - lon1);
-        lat1 = Math.toRadians(lat1);
-        lat2 = Math.toRadians(lat2);
-
-        double a = Math.sin(delta_Lat / 2) * Math.sin(delta_Lat / 2) + Math.sin(delta_Lon / 2) * Math.sin(delta_Lon / 2) * Math.cos(lat1) * Math.cos(lat2);
-        double c = 2 * Math.asin(Math.sqrt(a));
-        double distance = R * c;
-        if (distanceUnit.equals(DistanceUnit.Meter)) {
-            distance = distance * 1000.;
-        }
-        return distance;
-    }
-
-}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/ManhattanCosts.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/ManhattanCosts.java
index bbb50b182..c4ec63a29 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/ManhattanCosts.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/ManhattanCosts.java
@@ -18,73 +18,87 @@
 package com.graphhopper.jsprit.core.util;
 
 
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.cost.AbstractForwardVehicleRoutingTransportCosts;
-import com.graphhopper.jsprit.core.problem.cost.TransportDistance;
-import com.graphhopper.jsprit.core.problem.driver.Driver;
-import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
+import com.graphhopper.jsprit.core.distance.ManhattanDistanceCalculator;
 
 /**
  * @author stefan schroeder
+ *
+ * @deprecated Use instead new {@linkplain DefaultCosts} with
+ *             {@link ManhattanDistanceCalculator#getInstance()}
  */
-
-public class ManhattanCosts extends AbstractForwardVehicleRoutingTransportCosts implements TransportDistance {
-
-    public double speed = 1;
-
-    private Locations locations;
-
-    public ManhattanCosts(Locations locations) {
-        super();
-        this.locations = locations;
-    }
+@Deprecated
+public class ManhattanCosts extends DefaultCosts {
 
     public ManhattanCosts() {
-
-    }
-
-    @Override
-    public double getTransportCost(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
-        double distance;
-        try {
-            distance = calculateDistance(from, to);
-        } catch (NullPointerException e) {
-            throw new NullPointerException("cannot calculate euclidean distance. coordinates are missing. either add coordinates or use another transport-cost-calculator.");
-        }
-        double costs = distance;
-        if (vehicle != null) {
-            if (vehicle.getType() != null) {
-                costs = distance * vehicle.getType().getVehicleCostParams().perDistanceUnit;
-            }
-        }
-        return costs;
-    }
-
-    @Override
-    public double getTransportTime(Location from, Location to, double time, Driver driver, Vehicle vehicle) {
-        return calculateDistance(from, to) / speed;
-    }
-
-    private double calculateDistance(Location fromLocation, Location toLocation) {
-        Coordinate from = null;
-        Coordinate to = null;
-        if (fromLocation.getCoordinate() != null & toLocation.getCoordinate() != null) {
-            from = fromLocation.getCoordinate();
-            to = toLocation.getCoordinate();
-        } else if (locations != null) {
-            from = locations.getCoord(fromLocation.getId());
-            to = locations.getCoord(toLocation.getId());
-        }
-        if (from == null || to == null) throw new NullPointerException();
-        return calculateDistance(from, to);
-    }
-
-    private double calculateDistance(Coordinate from, Coordinate to) {
-        return Math.abs(from.getX() - to.getX()) + Math.abs(from.getY() - to.getY());
+        super(ManhattanDistanceCalculator.getInstance());
     }
 
-    @Override
-    public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-        return calculateDistance(from, to);
-    }
+    // public double speed = 1;
+    //
+    // private Locations locations;
+    //
+    // public ManhattanCosts(Locations locations) {
+    // super();
+    // this.locations = locations;
+    // }
+    //
+    // public ManhattanCosts() {
+    //
+    // }
+    //
+    // @Override
+    // public double getTransportCost(Location from, Location to, double time,
+    // Driver driver, Vehicle vehicle) {
+    // double distance;
+    // try {
+    // distance = calculateDistance(from, to);
+    // } catch (NullPointerException e) {
+    // throw new NullPointerException("cannot calculate euclidean distance.
+    // coordinates are missing. either add coordinates or use another
+    // transport-cost-calculator.");
+    // }
+    // double costs = distance;
+    // if (vehicle != null) {
+    // if (vehicle.getType() != null) {
+    // costs = distance *
+    // vehicle.getType().getVehicleCostParams().perDistanceUnit;
+    // }
+    // }
+    // return costs;
+    // }
+    //
+    // @Override
+    // public double getTransportTime(Location from, Location to, double time,
+    // Driver driver, Vehicle vehicle) {
+    // return calculateDistance(from, to) / speed;
+    // }
+    //
+    // private double calculateDistance(Location fromLocation, Location
+    // toLocation) {
+    // Coordinate from = null;
+    // Coordinate to = null;
+    // if (fromLocation.getCoordinate() != null & toLocation.getCoordinate() !=
+    // null) {
+    // from = fromLocation.getCoordinate();
+    // to = toLocation.getCoordinate();
+    // } else if (locations != null) {
+    // from = locations.getCoord(fromLocation.getId());
+    // to = locations.getCoord(toLocation.getId());
+    // }
+    // if (from == null || to == null) {
+    // throw new NullPointerException();
+    // }
+    // return calculateDistance(from, to);
+    // }
+    //
+    // private double calculateDistance(Coordinate from, Coordinate to) {
+    // return Math.abs(from.getX() - to.getX()) + Math.abs(from.getY() -
+    // to.getY());
+    // }
+    //
+    // @Override
+    // public double getDistance(Location from, Location to, double
+    // departureTime, Vehicle vehicle) {
+    // return calculateDistance(from, to);
+    // }
 }
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/ManhattanDistanceCalculator.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/ManhattanDistanceCalculator.java
deleted file mode 100644
index 522ff1f87..000000000
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/util/ManhattanDistanceCalculator.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.util;
-
-
-public class ManhattanDistanceCalculator {
-
-    public static double calculateDistance(Coordinate coord1, Coordinate coord2) {
-        return Math.abs(coord1.getX() - coord2.getX())
-            + Math.abs(coord1.getY() - coord2.getY());
-    }
-
-}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/BuildCVRPAlgoFromScratch_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/BuildCVRPAlgoFromScratch_IT.java
index 3e4d7024e..435d30f0a 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/BuildCVRPAlgoFromScratch_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/BuildCVRPAlgoFromScratch_IT.java
@@ -31,7 +31,7 @@
 import com.graphhopper.jsprit.core.algorithm.ruin.RadialRuinStrategyFactory;
 import com.graphhopper.jsprit.core.algorithm.ruin.RandomRuinStrategyFactory;
 import com.graphhopper.jsprit.core.algorithm.ruin.RuinStrategy;
-import com.graphhopper.jsprit.core.algorithm.ruin.distance.AvgServiceDistance;
+import com.graphhopper.jsprit.core.algorithm.ruin.distance.DefaultJobDistance;
 import com.graphhopper.jsprit.core.algorithm.selector.SelectBest;
 import com.graphhopper.jsprit.core.algorithm.state.InternalStates;
 import com.graphhopper.jsprit.core.algorithm.state.StateManager;
@@ -65,7 +65,7 @@ public void setup() {
 
         InsertionStrategy bestInsertion = new BestInsertionBuilder(vrp, fleetManager, stateManager, cManager).build();
 
-        RuinStrategy radial = new RadialRuinStrategyFactory(0.15, new AvgServiceDistance(vrp.getTransportCosts())).createStrategy(vrp);
+        RuinStrategy radial = new RadialRuinStrategyFactory(0.15, new DefaultJobDistance(vrp.getTransportCosts())).createStrategy(vrp);
         RuinStrategy random = new RandomRuinStrategyFactory(0.25).createStrategy(vrp);
 
         SolutionCostCalculator solutionCostCalculator = new SolutionCostCalculator() {
@@ -89,9 +89,9 @@ public double getCosts(VehicleRoutingProblemSolution solution) {
         radialStrategy.addModule(radialModule);
 
         vra = new PrettyAlgorithmBuilder(vrp, fleetManager, stateManager, cManager)
-            .withStrategy(randomStrategy, 0.5).withStrategy(radialStrategy, 0.5)
-            .addCoreStateAndConstraintStuff()
-            .constructInitialSolutionWith(bestInsertion, solutionCostCalculator).build();
+                .withStrategy(randomStrategy, 0.5).withStrategy(radialStrategy, 0.5)
+                .addCoreStateAndConstraintStuff()
+                .constructInitialSolutionWith(bestInsertion, solutionCostCalculator).build();
         vra.setMaxIterations(2000);
 
     }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithMatrix_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithMatrix_IT.java
index df6ad2242..605016715 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithMatrix_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CVRPwithMatrix_IT.java
@@ -30,6 +30,7 @@
 
 import com.graphhopper.jsprit.core.algorithm.box.Jsprit;
 import com.graphhopper.jsprit.core.analysis.SolutionAnalyser;
+import com.graphhopper.jsprit.core.distance.EuclideanDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.cost.TransportDistance;
@@ -39,7 +40,6 @@
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
 import com.graphhopper.jsprit.core.util.ChristofidesReader;
-import com.graphhopper.jsprit.core.util.EuclideanDistanceCalculator;
 import com.graphhopper.jsprit.core.util.FastVehicleRoutingTransportCostsMatrix;
 import com.graphhopper.jsprit.core.util.JobType;
 import com.graphhopper.jsprit.core.util.Solutions;
@@ -119,7 +119,7 @@ private VehicleRoutingProblem createVrpWithLocationIndecesAndMatrix(VehicleRouti
         FastVehicleRoutingTransportCostsMatrix.Builder matrixBuilder = FastVehicleRoutingTransportCostsMatrix.Builder.newInstance(locations.size(), true);
         for (Location from : locations) {
             for (Location to : locations) {
-                double distance = EuclideanDistanceCalculator.calculateDistance(from.getCoordinate(), to.getCoordinate());
+                double distance = EuclideanDistanceCalculator.getInstance().calculateDistance(from.getCoordinate(), to.getCoordinate());
                 matrixBuilder.addTransportDistance(from.getIndex(), to.getIndex(), distance);
                 matrixBuilder.addTransportTime(from.getIndex(), to.getIndex(), distance);
             }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CapacityConstraint_IT.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CapacityConstraint_IT.java
index 4669b4fb1..9ca17908f 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CapacityConstraint_IT.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/CapacityConstraint_IT.java
@@ -22,6 +22,7 @@
 
 import com.graphhopper.jsprit.core.algorithm.box.Jsprit;
 import com.graphhopper.jsprit.core.analysis.SolutionAnalyser;
+import com.graphhopper.jsprit.core.distance.ManhattanDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.Capacity;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
@@ -32,7 +33,7 @@
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
-import com.graphhopper.jsprit.core.util.ManhattanCosts;
+import com.graphhopper.jsprit.core.util.DefaultCosts;
 import com.graphhopper.jsprit.core.util.Solutions;
 
 
@@ -42,25 +43,25 @@
     public void capacityShouldNotBeExceeded() {
 
         VehicleTypeImpl type1 = VehicleTypeImpl.Builder.newInstance("type1")
-                .addCapacityDimension(0,1)
-                .addCapacityDimension(1,0).addCapacityDimension(2,17).addCapacityDimension(3,18)
-                .addCapacityDimension(4,14).addCapacityDimension(5,18).addCapacityDimension(6,20).build();
+                        .addCapacityDimension(0,1)
+                        .addCapacityDimension(1,0).addCapacityDimension(2,17).addCapacityDimension(3,18)
+                        .addCapacityDimension(4,14).addCapacityDimension(5,18).addCapacityDimension(6,20).build();
         VehicleTypeImpl type2 = VehicleTypeImpl.Builder.newInstance("type2")
-                .addCapacityDimension(0,0)
-                .addCapacityDimension(1,0).addCapacityDimension(2,17).addCapacityDimension(3,18)
-                .addCapacityDimension(4,13).addCapacityDimension(5,18).addCapacityDimension(6,20).build();
+                        .addCapacityDimension(0,0)
+                        .addCapacityDimension(1,0).addCapacityDimension(2,17).addCapacityDimension(3,18)
+                        .addCapacityDimension(4,13).addCapacityDimension(5,18).addCapacityDimension(6,20).build();
         VehicleTypeImpl type3 = VehicleTypeImpl.Builder.newInstance("type3")
-                .addCapacityDimension(0,1)
-                .addCapacityDimension(1,0).addCapacityDimension(2,17).addCapacityDimension(3,18)
-                .addCapacityDimension(4,14).addCapacityDimension(5,18).addCapacityDimension(6,20).build();
+                        .addCapacityDimension(0,1)
+                        .addCapacityDimension(1,0).addCapacityDimension(2,17).addCapacityDimension(3,18)
+                        .addCapacityDimension(4,14).addCapacityDimension(5,18).addCapacityDimension(6,20).build();
         VehicleTypeImpl type4 = VehicleTypeImpl.Builder.newInstance("type4")
-                .addCapacityDimension(0,0)
-                .addCapacityDimension(1,0).addCapacityDimension(2,17).addCapacityDimension(3,18)
-                .addCapacityDimension(4,14).addCapacityDimension(5,17).addCapacityDimension(6,20).build();
+                        .addCapacityDimension(0,0)
+                        .addCapacityDimension(1,0).addCapacityDimension(2,17).addCapacityDimension(3,18)
+                        .addCapacityDimension(4,14).addCapacityDimension(5,17).addCapacityDimension(6,20).build();
         VehicleTypeImpl type5 = VehicleTypeImpl.Builder.newInstance("type5")
-                .addCapacityDimension(0,1)
-                .addCapacityDimension(1,0).addCapacityDimension(2,16).addCapacityDimension(3,17)
-                .addCapacityDimension(4,14).addCapacityDimension(5,18).addCapacityDimension(6,20).build();
+                        .addCapacityDimension(0,1)
+                        .addCapacityDimension(1,0).addCapacityDimension(2,16).addCapacityDimension(3,17)
+                        .addCapacityDimension(4,14).addCapacityDimension(5,18).addCapacityDimension(6,20).build();
 
         VehicleImpl v1 = VehicleImpl.Builder.newInstance("v1").setStartLocation(Location.newInstance(0,0)).setType(type1).setReturnToDepot(true).build();
         VehicleImpl v2 = VehicleImpl.Builder.newInstance("v2").setStartLocation(Location.newInstance(0, 0)).setType(type2).setReturnToDepot(true).build();
@@ -69,13 +70,13 @@ public void capacityShouldNotBeExceeded() {
         VehicleImpl v5 = VehicleImpl.Builder.newInstance("v5").setStartLocation(Location.newInstance(0, 0)).setType(type5).setReturnToDepot(true).build();
 
         Delivery d1 = new Delivery.Builder("d1").setLocation(Location.newInstance(0, 10))
-                .addSizeDimension(2,1).build();
+                        .addSizeDimension(2,1).build();
         Delivery d2 = new Delivery.Builder("d2").setLocation(Location.newInstance(0,12))
-                .addSizeDimension(2,1).addSizeDimension(3,1).build();
+                        .addSizeDimension(2,1).addSizeDimension(3,1).build();
         Delivery d3 = new Delivery.Builder("d3").setLocation(Location.newInstance(0,15))
-                .addSizeDimension(0,1).addSizeDimension(4,1).build();
+                        .addSizeDimension(0,1).addSizeDimension(4,1).build();
         Delivery d4 = new Delivery.Builder("d4").setLocation(Location.newInstance(0,20))
-                .addSizeDimension(0,1).addSizeDimension(5,1).build();
+                        .addSizeDimension(0,1).addSizeDimension(5,1).build();
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.setFleetSize(VehicleRoutingProblem.FleetSize.FINITE)
@@ -83,31 +84,32 @@ public void capacityShouldNotBeExceeded() {
         .addVehicle(v1).addVehicle(v2)
         .addVehicle(v3)
         .addVehicle(v4).addVehicle(v5);
-        vrpBuilder.setRoutingCost(new ManhattanCosts());
+        vrpBuilder.setRoutingCost(new DefaultCosts(ManhattanDistanceCalculator.getInstance()));
 
         VehicleRoutingProblem vrp = vrpBuilder.build();
 
         VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp)
-                .setProperty(Jsprit.Parameter.VEHICLE_SWITCH, "true").buildAlgorithm();
+                        .setProperty(Jsprit.Parameter.VEHICLE_SWITCH, "true").buildAlgorithm();
         vra.setMaxIterations(2000);
         VehicleRoutingProblemSolution solution = Solutions.bestOf(vra.searchSolutions());
 
         SolutionAnalyser sa = new SolutionAnalyser(vrp, solution, new TransportDistance() {
             @Override
             public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-                return new ManhattanCosts().getDistance(from,to, 0d, null);
+                return new DefaultCosts(ManhattanDistanceCalculator.getInstance()).getDistance(from,
+                                to, 0d, null);
             }
         });
 
         for(VehicleRoute r : solution.getRoutes()){
             Capacity loadAtBeginning = sa.getLoadAtBeginning(r);
             Capacity capacityDimensions = r.getVehicle().getType().getCapacityDimensions();
-//            System.out.println(r.getVehicle().getId() + " load@beginning: "  + loadAtBeginning);
-//            System.out.println("cap: " + capacityDimensions);
+            //            System.out.println(r.getVehicle().getId() + " load@beginning: "  + loadAtBeginning);
+            //            System.out.println("cap: " + capacityDimensions);
             Assert.assertTrue("capacity has been exceeded",
-                    loadAtBeginning.isLessOrEqual(capacityDimensions));
+                            loadAtBeginning.isLessOrEqual(capacityDimensions));
         }
-//
+        //
         Assert.assertTrue(solution.getRoutes().size() != 1);
 
     }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/OpenRoutesTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/OpenRoutesTest.java
index d74cf6b27..5a6617bd6 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/OpenRoutesTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/OpenRoutesTest.java
@@ -27,6 +27,7 @@
 
 import com.graphhopper.jsprit.core.algorithm.box.SchrimpfFactory;
 import com.graphhopper.jsprit.core.algorithm.recreate.NoSolutionFoundException;
+import com.graphhopper.jsprit.core.distance.SphericalDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.job.Service;
@@ -36,7 +37,7 @@
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
 import com.graphhopper.jsprit.core.util.Coordinate;
-import com.graphhopper.jsprit.core.util.GreatCircleCosts;
+import com.graphhopper.jsprit.core.util.DefaultCosts;
 import com.graphhopper.jsprit.core.util.Solutions;
 import com.graphhopper.jsprit.core.util.TestUtils;
 
@@ -47,10 +48,10 @@ public void whenDealingWithOpenRouteAndShipments_insertionShouldNotRequireRouteT
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").build();
 
         VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setLatestArrival(11.)
-            .setType(type).setReturnToDepot(false).setStartLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(0, 0)).build()).build();
+                        .setType(type).setReturnToDepot(false).setStartLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(0, 0)).build()).build();
 
         Shipment shipment = Shipment.Builder.newInstance("s").setPickupLocation(TestUtils.loc(Coordinate.newInstance(5, 0)))
-            .setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(10, 0))).build();
+                        .setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(10, 0))).build();
 
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(shipment).addVehicle(vehicle).build();
 
@@ -71,13 +72,13 @@ public void whenDealingWithOpenRouteAndShipments_insertionShouldNotRequireRouteT
     public void whenDealingWithOpenRoute_insertionShouldNotRequireRouteToBeClosed() {
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").build();
         VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setLatestArrival(9.)
-            .setType(type).setReturnToDepot(false)
-            .setStartLocation(TestUtils.loc(Coordinate.newInstance(0, 0)))
-            .build();
+                        .setType(type).setReturnToDepot(false)
+                        .setStartLocation(TestUtils.loc(Coordinate.newInstance(0, 0)))
+                        .build();
 
         Service service = new Service.Builder("s")
-            .setLocation(TestUtils.loc(Coordinate.newInstance(5, 0)))
-            .build();
+                        .setLocation(TestUtils.loc(Coordinate.newInstance(5, 0)))
+                        .build();
 
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(service).addVehicle(vehicle).build();
 
@@ -100,13 +101,13 @@ public void whenDealingWithOpenRouteAndShipments_algorithmShouldCalculateCorrect
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").build();
 
         VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setLatestArrival(20.)
-            .setType(type).setReturnToDepot(false).setStartLocation(Location.Builder.newInstance()
-                .setCoordinate(Coordinate.newInstance(0, 0)).build()).build();
+                        .setType(type).setReturnToDepot(false).setStartLocation(Location.Builder.newInstance()
+                                        .setCoordinate(Coordinate.newInstance(0, 0)).build()).build();
 
         Shipment shipment = Shipment.Builder.newInstance("s")
-            .setPickupLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(5, 0)).build())
-            .setDeliveryLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(10, 0)).build())
-            .build();
+                        .setPickupLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(5, 0)).build())
+                        .setDeliveryLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(10, 0)).build())
+                        .build();
 
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(shipment).addVehicle(vehicle).build();
 
@@ -123,10 +124,10 @@ public void whenDealingWithOpenRouteAndShipments_algorithmShouldCalculateCorrect
     public void whenDealingWithOpenRoute_algorithmShouldCalculateCorrectCosts() {
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").build();
         VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v").setLatestArrival(10.)
-            .setType(type).setReturnToDepot(false).setStartLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(0, 0)).build()).build();
+                        .setType(type).setReturnToDepot(false).setStartLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(0, 0)).build()).build();
 
         Service service = new Service.Builder("s")
-            .setLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(5, 0)).build()).build();
+                        .setLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(5, 0)).build()).build();
 
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance().addJob(service).addVehicle(vehicle).build();
 
@@ -143,17 +144,17 @@ public void whenDealingWithOpenRoute_algorithmShouldCalculateCorrectCosts() {
     public void whenDealingWithOpenRouteAndGreatCircleCost_algorithmShouldRunWithoutException() {
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").build();
         VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v")
-            .setType(type).setReturnToDepot(false)
-            .setStartLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(0, 0)).build())
-            .build();
+                        .setType(type).setReturnToDepot(false)
+                        .setStartLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(0, 0)).build())
+                        .build();
 
         Service service = new Service.Builder("s")
-            .setLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(50, 0)).build()).build();
+                        .setLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(50, 0)).build()).build();
 
         VehicleRoutingProblem vrp = VehicleRoutingProblem.Builder.newInstance()
-            .addJob(service).addVehicle(vehicle)
-            .setRoutingCost(new GreatCircleCosts())
-            .build();
+                        .addJob(service).addVehicle(vehicle)
+                        .setRoutingCost(new DefaultCosts(SphericalDistanceCalculator.getInstance()))
+                        .build();
 
         VehicleRoutingAlgorithm vra = new SchrimpfFactory().createAlgorithm(vrp);
         vra.setMaxIterations(10);
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertion.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertion.java
index f3476aab5..517484d0f 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertion.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/recreate/TestCalculatesServiceInsertion.java
@@ -30,6 +30,8 @@
 import org.junit.Test;
 
 import com.graphhopper.jsprit.core.algorithm.state.StateManager;
+import com.graphhopper.jsprit.core.distance.EuclideanDistanceCalculator;
+import com.graphhopper.jsprit.core.distance.ManhattanDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.CopyJobActivityFactory;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
@@ -49,9 +51,7 @@
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
 import com.graphhopper.jsprit.core.util.Coordinate;
-import com.graphhopper.jsprit.core.util.EuclideanDistanceCalculator;
 import com.graphhopper.jsprit.core.util.Locations;
-import com.graphhopper.jsprit.core.util.ManhattanDistanceCalculator;
 
 
 public class TestCalculatesServiceInsertion {
@@ -94,7 +94,7 @@ public Coordinate getCoord(String id) {
                 //assume: locationId="x,y"
                 String[] splitted = id.split(",");
                 return Coordinate.newInstance(Double.parseDouble(splitted[0]),
-                        Double.parseDouble(splitted[1]));
+                                Double.parseDouble(splitted[1]));
             }
 
         };
@@ -102,12 +102,16 @@ public Coordinate getCoord(String id) {
 
             @Override
             public double getTransportTime(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-                return ManhattanDistanceCalculator.calculateDistance(locations.getCoord(from.getId()), locations.getCoord(to.getId()));
+                return ManhattanDistanceCalculator.getInstance().calculateDistance(
+                                locations.getCoord(from.getId()), locations.getCoord(to.getId()));
             }
 
             @Override
             public double getTransportCost(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-                return vehicle.getType().getVehicleCostParams().perDistanceUnit * ManhattanDistanceCalculator.calculateDistance(locations.getCoord(from.getId()), locations.getCoord(to.getId()));
+                return vehicle.getType().getVehicleCostParams().perDistanceUnit
+                                * ManhattanDistanceCalculator.getInstance().calculateDistance(
+                                                locations.getCoord(from.getId()),
+                                                locations.getCoord(to.getId()));
             }
         };
 
@@ -122,7 +126,7 @@ public double getTransportCost(Location from, Location to, double departureTime,
         jobs.add(second);
 
         vrp = VehicleRoutingProblem.Builder.newInstance().addAllJobs(jobs)
-                .addVehicle(vehicle).setRoutingCost(costs).build();
+                        .addVehicle(vehicle).setRoutingCost(costs).build();
 
         states = new StateManager(vrp);
         states.updateLoadStates();
@@ -213,8 +217,8 @@ public void whenInsertingJobAndCurrRouteIsEmpty_accessEggressCalcShouldReturnZer
     @Test
     public void whenInsertingJobAndCurrRouteAndVehicleHaveTheSameLocation_accessEggressCalcShouldReturnZero() {
         VehicleRoute route = VehicleRoute.Builder.newInstance(newVehicle, DriverImpl.noDriver())
-                .addService(first)
-                .build();
+                        .addService(first)
+                        .build();
 
         AdditionalAccessEgressCalculator accessEgressCalc = new AdditionalAccessEgressCalculator(costs);
         JobInsertionContext iContex = new JobInsertionContext(route, first, newVehicle, mock(Driver.class), 0.0);
@@ -237,14 +241,14 @@ public double getTransportTime(Location from, Location to, double departureTime,
 
             @Override
             public double getTransportCost(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-                return EuclideanDistanceCalculator.calculateDistance(coords.get(from.getId()), coords.get(to.getId()));
+                return EuclideanDistanceCalculator.getInstance().calculateDistance(coords.get(from.getId()), coords.get(to.getId()));
             }
         };
         Vehicle oldVehicle = VehicleImpl.Builder.newInstance("oldV").setStartLocation(Location.newInstance("oldV")).build();
 
         VehicleRoute route = VehicleRoute.Builder.newInstance(oldVehicle, DriverImpl.noDriver())
-                .addService(new Service.Builder("service").addSizeDimension(0, 0).setLocation(Location.newInstance("service")).build())
-                .build();
+                        .addService(new Service.Builder("service").addSizeDimension(0, 0).setLocation(Location.newInstance("service")).build())
+                        .build();
 
         Vehicle newVehicle = VehicleImpl.Builder.newInstance("newV").setStartLocation(Location.newInstance("newV")).build();
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/DBSCANClustererTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/DBSCANClustererTest.java
index d0756cb31..0c8709ae9 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/DBSCANClustererTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/DBSCANClustererTest.java
@@ -18,18 +18,20 @@
 
 package com.graphhopper.jsprit.core.algorithm.ruin;
 
+import static org.junit.Assert.assertEquals;
+
 import java.util.List;
 
 import org.junit.Test;
 
+import com.graphhopper.jsprit.core.distance.EuclideanDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.job.Job;
 import com.graphhopper.jsprit.core.problem.job.Service;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
-import com.graphhopper.jsprit.core.util.EuclideanCosts;
+import com.graphhopper.jsprit.core.util.DefaultCosts;
 
-import junit.framework.Assert;
 
 /**
  * Created by schroeder on 06/03/15.
@@ -45,11 +47,11 @@ public void itShouldReturnOneClusterOfSizeTwo() {
         VehicleImpl v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0, 0)).build();
         VehicleRoute r = VehicleRoute.Builder.newInstance(v).addService(s1).addService(s2).addService(s3).build();
 
-        DBSCANClusterer c = new DBSCANClusterer(new EuclideanCosts());
+        DBSCANClusterer c = new DBSCANClusterer(
+                        new DefaultCosts(EuclideanDistanceCalculator.getInstance()));
         c.setEpsDistance(3);
         List<Job> cluster = c.getRandomCluster(r);
-        Assert.assertEquals(2, cluster.size());
-
+        assertEquals(2, cluster.size());
     }
 
     @Test
@@ -61,10 +63,10 @@ public void itShouldReturnOneCluster() {
         VehicleImpl v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0, 0)).build();
         VehicleRoute r = VehicleRoute.Builder.newInstance(v).addService(s1).addService(s2).addService(s3).build();
 
-        DBSCANClusterer c = new DBSCANClusterer(new EuclideanCosts());
+        DBSCANClusterer c = new DBSCANClusterer(new DefaultCosts(EuclideanDistanceCalculator.getInstance()));
         c.setEpsDistance(3);
         List<List<Job>> cluster = c.getClusters(r);
-        Assert.assertEquals(1, cluster.size());
+        assertEquals(1, cluster.size());
 
     }
 
@@ -79,13 +81,14 @@ public void itShouldReturnTwoClusters() {
 
         VehicleImpl v = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance(0, 0)).build();
         VehicleRoute r = VehicleRoute.Builder.newInstance(v).addService(s1).addService(s2).addService(s3)
-            .addService(s0).addService(s4).addService(s5).build();
+                        .addService(s0).addService(s4).addService(s5).build();
 
-        DBSCANClusterer c = new DBSCANClusterer(new EuclideanCosts());
+        DBSCANClusterer c = new DBSCANClusterer(
+                        new DefaultCosts(EuclideanDistanceCalculator.getInstance()));
         c.setMinPts(1);
         c.setEpsDistance(2);
         List<List<Job>> cluster = c.getClusters(r);
-        Assert.assertEquals(3, cluster.size());
+        assertEquals(3, cluster.size());
 
     }
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsImplTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsImplTest.java
index 273e08089..5815322e8 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsImplTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsImplTest.java
@@ -27,7 +27,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import com.graphhopper.jsprit.core.algorithm.ruin.distance.EuclideanServiceDistance;
+import com.graphhopper.jsprit.core.algorithm.ruin.distance.CoordinateJobDistance;
 import com.graphhopper.jsprit.core.algorithm.ruin.distance.JobDistance;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
@@ -63,7 +63,7 @@ public void doBefore() {
 
         vrp = builder.addJob(target).addJob(s2).addJob(s3).addJob(s4).addJob(s5).addJob(s6).addJob(s7).build();
 
-        jobDistance = new EuclideanServiceDistance();
+        jobDistance = new CoordinateJobDistance();
     }
 
     @Test
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsOptimizedTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsOptimizedTest.java
index c4ca47bae..701978439 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsOptimizedTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsOptimizedTest.java
@@ -27,7 +27,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import com.graphhopper.jsprit.core.algorithm.ruin.distance.EuclideanServiceDistance;
+import com.graphhopper.jsprit.core.algorithm.ruin.distance.CoordinateJobDistance;
 import com.graphhopper.jsprit.core.algorithm.ruin.distance.JobDistance;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
@@ -65,7 +65,7 @@ public void doBefore() {
 
         vrp = builder.addJob(target).addJob(s2).addJob(s3).addJob(s4).addJob(s5).addJob(s6).addJob(s7).build();
 
-        jobDistance = new EuclideanServiceDistance();
+        jobDistance = new CoordinateJobDistance();
     }
 
     @Test
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsWithCapRestrictionImplTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsWithCapRestrictionImplTest.java
index 57dbf18e1..b4ca09632 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsWithCapRestrictionImplTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/JobNeighborhoodsWithCapRestrictionImplTest.java
@@ -27,7 +27,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import com.graphhopper.jsprit.core.algorithm.ruin.distance.EuclideanServiceDistance;
+import com.graphhopper.jsprit.core.algorithm.ruin.distance.CoordinateJobDistance;
 import com.graphhopper.jsprit.core.algorithm.ruin.distance.JobDistance;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
@@ -63,7 +63,7 @@ public void doBefore() {
 
         vrp = builder.addJob(target).addJob(s2).addJob(s3).addJob(s4).addJob(s5).addJob(s6).addJob(s7).build();
 
-        jobDistance = new EuclideanServiceDistance();
+        jobDistance = new CoordinateJobDistance();
     }
 
     @Test
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinClustersTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinClustersTest.java
index 4510d675d..be2dc8ae3 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinClustersTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/RuinClustersTest.java
@@ -24,7 +24,7 @@
 
 import org.junit.Test;
 
-import com.graphhopper.jsprit.core.algorithm.ruin.distance.AvgServiceAndShipmentDistance;
+import com.graphhopper.jsprit.core.algorithm.ruin.distance.DefaultJobDistance;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.job.Job;
@@ -60,7 +60,7 @@ public void itShouldRuinTwoObviousClusters() {
         VehicleRoute vr2 = VehicleRoute.Builder.newInstance(v)
             .addService(s6).addService(s7).addService(s4).addService(s5).setJobActivityFactory(vrp.getJobActivityFactory()).build();
 
-        JobNeighborhoods n = new JobNeighborhoodsFactory().createNeighborhoods(vrp, new AvgServiceAndShipmentDistance(vrp.getTransportCosts()));
+        JobNeighborhoods n = new JobNeighborhoodsFactory().createNeighborhoods(vrp, new DefaultJobDistance(vrp.getTransportCosts()));
         n.initialise();
         RuinClusters rc = new RuinClusters(vrp, 5, n);
         Random r = RandomNumberGeneration.newInstance();
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/AverageJobDistanceTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/AverageJobDistanceTest.java
index bd6ca96d9..d83dae570 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/AverageJobDistanceTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/AverageJobDistanceTest.java
@@ -23,18 +23,19 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import com.graphhopper.jsprit.core.distance.EuclideanDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.job.Service;
 import com.graphhopper.jsprit.core.problem.job.Shipment;
 import com.graphhopper.jsprit.core.util.Coordinate;
-import com.graphhopper.jsprit.core.util.CrowFlyCosts;
+import com.graphhopper.jsprit.core.util.DefaultCosts;
 import com.graphhopper.jsprit.core.util.Locations;
 
 
 public class AverageJobDistanceTest {
 
 
-    private CrowFlyCosts routingCosts;
+    private DefaultCosts routingCosts;
 
     @Before
     public void doBefore() {
@@ -45,11 +46,12 @@ public Coordinate getCoord(String id) {
                 //assume: locationId="x,y"
                 String[] splitted = id.split(",");
                 return Coordinate.newInstance(Double.parseDouble(splitted[0]),
-                    Double.parseDouble(splitted[1]));
+                                Double.parseDouble(splitted[1]));
             }
 
         };
-        routingCosts = new CrowFlyCosts(locations);
+        routingCosts = new DefaultCosts(EuclideanDistanceCalculator.getInstance())
+                        .withCoordinateConverter(locations);
 
     }
 
@@ -58,13 +60,13 @@ public void distanceOfTwoEqualShipmentsShouldBeSmallerThanAnyOtherDistance() {
         Shipment s1 = Shipment.Builder.newInstance("s1").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("10,10")).build();
         Shipment s2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("10,10")).build();
 
-        double dist = new AvgServiceAndShipmentDistance(routingCosts).getDistance(s1, s2);
+        double dist = new DefaultJobDistance(routingCosts).getDistance(s1, s2);
 
         for (int i = 0; i < 10; i++) {
             for (int j = 0; j < 10; j++) {
                 Shipment other1 = Shipment.Builder.newInstance("s1").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance(i + "," + j)).build();
                 Shipment other2 = Shipment.Builder.newInstance("s2").addSizeDimension(0, 1).setPickupLocation(Location.Builder.newInstance().setId("0,0").build()).setDeliveryLocation(Location.newInstance("10,10")).build();
-                double dist2 = new AvgServiceAndShipmentDistance(routingCosts).getDistance(other1, other2);
+                double dist2 = new DefaultJobDistance(routingCosts).getDistance(other1, other2);
                 assertTrue(dist <= dist2 + dist2 * 0.001);
             }
         }
@@ -76,7 +78,7 @@ public void whenServicesHaveSameLocation_distanceShouldBeZero() {
         Service s1 = new Service.Builder("s1").addSizeDimension(0, 1).setLocation(Location.newInstance("10,0")).build();
         Service s2 = new Service.Builder("s2").addSizeDimension(0, 1).setLocation(Location.newInstance("10,0")).build();
 
-        double dist = new AvgServiceAndShipmentDistance(routingCosts).getDistance(s1, s2);
+        double dist = new DefaultJobDistance(routingCosts).getDistance(s1, s2);
         assertEquals(0.0, dist, 0.01);
     }
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/TestJobDistanceAvgCosts.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/TestJobDistanceAvgCosts.java
index 5c81a3f59..16368a079 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/TestJobDistanceAvgCosts.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/ruin/distance/TestJobDistanceAvgCosts.java
@@ -28,39 +28,6 @@
 
 public class TestJobDistanceAvgCosts {
 
-    public static void main(String[] args) {
-        VehicleRoutingTransportCosts costs = new VehicleRoutingTransportCosts() {
-
-            @Override
-            public double getBackwardTransportTime(Location from, Location to, double arrivalTime, Driver driver, Vehicle vehicle) {
-
-                return 0;
-            }
-
-            @Override
-            public double getBackwardTransportCost(Location from, Location to,
-                                                   double arrivalTime, Driver driver, Vehicle vehicle) {
-                return 0;
-            }
-
-            @Override
-            public double getTransportCost(Location from, Location to,
-                                           double departureTime, Driver driver, Vehicle vehicle) {
-                @SuppressWarnings("unused")
-                String vehicleId = vehicle.getId();
-                return 0;
-            }
-
-            @Override
-            public double getTransportTime(Location from, Location to,
-                                           double departureTime, Driver driver, Vehicle vehicle) {
-                return 0;
-            }
-        };
-        AvgServiceDistance c = new AvgServiceDistance(costs);
-        c.getDistance(new Service.Builder("1").addSizeDimension(0, 1).setLocation(Location.newInstance("foo")).build(), new Service.Builder("2").addSizeDimension(0, 2).setLocation(Location.newInstance("foo")).build());
-    }
-
     @Test(expected = NullPointerException.class)
     public void whenVehicleAndDriverIsNull_And_CostsDoesNotProvideAMethodForThis_throwException() {
 //		(expected=NullPointerException.class)
@@ -74,13 +41,13 @@ public double getBackwardTransportTime(Location from, Location to, double arriva
 
             @Override
             public double getBackwardTransportCost(Location from, Location to,
-                                                   double arrivalTime, Driver driver, Vehicle vehicle) {
+                    double arrivalTime, Driver driver, Vehicle vehicle) {
                 return 0;
             }
 
             @Override
             public double getTransportCost(Location from, Location to,
-                                           double departureTime, Driver driver, Vehicle vehicle) {
+                    double departureTime, Driver driver, Vehicle vehicle) {
                 @SuppressWarnings("unused")
                 String vehicleId = vehicle.getId();
                 return 0;
@@ -88,12 +55,14 @@ public double getTransportCost(Location from, Location to,
 
             @Override
             public double getTransportTime(Location from, Location to,
-                                           double departureTime, Driver driver, Vehicle vehicle) {
+                    double departureTime, Driver driver, Vehicle vehicle) {
                 return 0;
             }
         };
-        AvgServiceDistance c = new AvgServiceDistance(costs);
-        c.getDistance(new Service.Builder("1").addSizeDimension(0, 1).setLocation(Location.newInstance("loc")).build(), new Service.Builder("2").addSizeDimension(0, 2).setLocation(Location.newInstance("loc")).build());
+        DefaultJobDistance c = new DefaultJobDistance(costs);
+        Service s1 = new Service.Builder("1").addSizeDimension(0, 1).setLocation(Location.newInstance("loc")).build();
+        Service s2 = new Service.Builder("2").addSizeDimension(0, 2).setLocation(Location.newInstance("loc")).build();
+        c.getDistance(s1, s2);
     }
 
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/UpdatePracticalTimeWindowTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/UpdatePracticalTimeWindowTest.java
index 105e1493c..359e7a925 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/UpdatePracticalTimeWindowTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/algorithm/state/UpdatePracticalTimeWindowTest.java
@@ -70,13 +70,15 @@ public void doBefore() {
         Delivery delivery = new Delivery.Builder("del").setLocation(Location.newInstance("20,20")).setTimeWindow(TimeWindow.newInstance(10, 40)).build();
         Pickup pickup2 = new Pickup.Builder("pick2").setLocation(Location.newInstance("20,0")).setTimeWindow(TimeWindow.newInstance(20, 50)).build();
 
-        Vehicle vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("0,0")).setType(mock(VehicleType.class)).build();
+        VehicleType vt = mock(VehicleType.class);
+        when(vt.getAvgVelocity()).thenReturn(1d);
+        Vehicle vehicle = VehicleImpl.Builder.newInstance("v").setStartLocation(Location.newInstance("0,0")).setType(vt).build();
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         final VehicleRoutingProblem vrp = vrpBuilder.addJob(pickup).addJob(pickup2).addJob(delivery).build();
 
         route = VehicleRoute.Builder.newInstance(vehicle, mock(Driver.class)).setJobActivityFactory(new CopyJobActivityFactory())
-                .addService(pickup).addService(delivery).addService(pickup2).build();
+                        .addService(pickup).addService(delivery).addService(pickup2).build();
 
         reverseActivityVisitor.visit(route);
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyserTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyserTest.java
index 3cf9ee782..762ef63d8 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyserTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/analysis/SolutionAnalyserTest.java
@@ -30,6 +30,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import com.graphhopper.jsprit.core.distance.ManhattanDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.Capacity;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
@@ -47,7 +48,7 @@
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
 import com.graphhopper.jsprit.core.util.Coordinate;
-import com.graphhopper.jsprit.core.util.ManhattanCosts;
+import com.graphhopper.jsprit.core.util.DefaultCosts;
 import com.graphhopper.jsprit.core.util.TestUtils;
 
 import junit.framework.Assert;
@@ -65,54 +66,55 @@ public void doBefore() {
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").setFixedCost(100.).setCostPerDistance(2.).addCapacityDimension(0, 15).build();
 
         VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v1").setType(type)
-            .setStartLocation(Location.newInstance(-5, 0))
-            .addSkill("skill1").addSkill("skill2")
-            .build();
+                        .setStartLocation(Location.newInstance(-5, 0))
+                        .addSkill("skill1").addSkill("skill2")
+                        .build();
 
         VehicleImpl vehicle2 = VehicleImpl.Builder.newInstance("v2").setType(type)
-            .setStartLocation(Location.newInstance(5, 0)).build();
+                        .setStartLocation(Location.newInstance(5, 0)).build();
 
         Service s1 = new Service.Builder("s1")
-            .setTimeWindow(TimeWindow.newInstance(10, 20))
-            .setLocation(Location.newInstance(-10, 1)).addSizeDimension(0, 2)
-            .addRequiredSkill("skill1")
-            .build();
+                        .setTimeWindow(TimeWindow.newInstance(10, 20))
+                        .setLocation(Location.newInstance(-10, 1)).addSizeDimension(0, 2)
+                        .addRequiredSkill("skill1")
+                        .build();
         Service s2 = new Service.Builder("s2")
-            .setLocation(Location.newInstance(-10, 10))
-            .addSizeDimension(0, 3)
-            .addRequiredSkill("skill2").addRequiredSkill("skill1")
-            .build();
+                        .setLocation(Location.newInstance(-10, 10))
+                        .addSizeDimension(0, 3)
+                        .addRequiredSkill("skill2").addRequiredSkill("skill1")
+                        .build();
         Shipment shipment1 = Shipment.Builder.newInstance("ship1")
-            .setPickupLocation(TestUtils.loc(Coordinate.newInstance(-15, 2)))
-            .setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(-16, 5)))
-            .addSizeDimension(0, 10)
-            .setPickupServiceTime(20.)
-            .setDeliveryServiceTime(20.)
-            .addRequiredSkill("skill3")
-            .build();
+                        .setPickupLocation(TestUtils.loc(Coordinate.newInstance(-15, 2)))
+                        .setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(-16, 5)))
+                        .addSizeDimension(0, 10)
+                        .setPickupServiceTime(20.)
+                        .setDeliveryServiceTime(20.)
+                        .addRequiredSkill("skill3")
+                        .build();
 
         Service s3 = new Service.Builder("s3")
-            .setTimeWindow(TimeWindow.newInstance(10, 20))
-            .setLocation(TestUtils.loc(Coordinate.newInstance(10, 1))).addSizeDimension(0, 2).build();
+                        .setTimeWindow(TimeWindow.newInstance(10, 20))
+                        .setLocation(TestUtils.loc(Coordinate.newInstance(10, 1))).addSizeDimension(0, 2).build();
 
         Service s4 = new Service.Builder("s4").setLocation(TestUtils.loc(Coordinate.newInstance(10, 10))).addSizeDimension(0, 3).build();
 
         Shipment shipment2 = Shipment.Builder.newInstance("ship2").setPickupLocation(TestUtils.loc(Coordinate.newInstance(15, 2)))
-            .setPickupServiceTime(20.).setDeliveryServiceTime(20.)
-            .setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(16, 5))).addSizeDimension(0, 10).build();
+                        .setPickupServiceTime(20.).setDeliveryServiceTime(20.)
+                        .setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(16, 5))).addSizeDimension(0, 10).build();
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance().addVehicle(vehicle)
-            .addVehicle(vehicle2)
-            .addJob(s1)
-            .addJob(s2).addJob(shipment1).addJob(s3).addJob(s4).addJob(shipment2).setFleetSize(VehicleRoutingProblem.FleetSize.INFINITE);
-        vrpBuilder.setRoutingCost(new ManhattanCosts(vrpBuilder.getLocations()));
+                        .addVehicle(vehicle2)
+                        .addJob(s1)
+                        .addJob(s2).addJob(shipment1).addJob(s3).addJob(s4).addJob(shipment2).setFleetSize(VehicleRoutingProblem.FleetSize.INFINITE);
+        vrpBuilder.setRoutingCost(new DefaultCosts(ManhattanDistanceCalculator.getInstance())
+                        .withCoordinateConverter(vrpBuilder.getLocations()));
         vrp = vrpBuilder.build();
 
         VehicleRoute route1 = VehicleRoute.Builder.newInstance(vehicle).setJobActivityFactory(vrp.getJobActivityFactory())
-            .addService(s1).addPickup(shipment1).addDelivery(shipment1).addService(s2).build();
+                        .addService(s1).addPickup(shipment1).addDelivery(shipment1).addService(s2).build();
 
         VehicleRoute route2 = VehicleRoute.Builder.newInstance(vehicle).setJobActivityFactory(vrp.getJobActivityFactory())
-            .addService(s3).addPickup(shipment2).addDelivery(shipment2).addService(s4).build();
+                        .addService(s3).addPickup(shipment2).addDelivery(shipment2).addService(s4).build();
 
         solution = new VehicleRoutingProblemSolution(Arrays.asList(route1, route2), 42);
     }
@@ -122,56 +124,57 @@ public void buildAnotherScenarioWithOnlyOneVehicleAndWithoutAnyConstraintsBefore
         VehicleType type = VehicleTypeImpl.Builder.newInstance("type").setFixedCost(100.).setCostPerDistance(2.).addCapacityDimension(0, 15).build();
 
         VehicleImpl vehicle = VehicleImpl.Builder.newInstance("v1").setType(type)
-            .setStartLocation(Location.newInstance(-5, 0))
-            .setLatestArrival(150.)
-            .build();
+                        .setStartLocation(Location.newInstance(-5, 0))
+                        .setLatestArrival(150.)
+                        .build();
 
         Pickup s1 = new Pickup.Builder("s1")
-            .setTimeWindow(TimeWindow.newInstance(10, 20))
-            .setLocation(Location.newInstance(-10, 1))
-            .addSizeDimension(0, 10)
-            .build();
+                        .setTimeWindow(TimeWindow.newInstance(10, 20))
+                        .setLocation(Location.newInstance(-10, 1))
+                        .addSizeDimension(0, 10)
+                        .build();
         Delivery s2 = new Delivery.Builder("s2")
-            .setLocation(Location.newInstance(-10, 10))
-            .setTimeWindow(TimeWindow.newInstance(10, 20))
-            .addSizeDimension(0, 20)
-            .build();
+                        .setLocation(Location.newInstance(-10, 10))
+                        .setTimeWindow(TimeWindow.newInstance(10, 20))
+                        .addSizeDimension(0, 20)
+                        .build();
         Shipment shipment1 = Shipment.Builder.newInstance("ship1").setPickupLocation(TestUtils.loc(Coordinate.newInstance(-15, 2)))
-            .setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(-16, 5)))
-            .addSizeDimension(0, 15)
-            .setPickupServiceTime(20.).setDeliveryServiceTime(20.)
-            .setPickupTimeWindow(TimeWindow.newInstance(10, 20)).setDeliveryTimeWindow(TimeWindow.newInstance(10, 20))
-            .build();
+                        .setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(-16, 5)))
+                        .addSizeDimension(0, 15)
+                        .setPickupServiceTime(20.).setDeliveryServiceTime(20.)
+                        .setPickupTimeWindow(TimeWindow.newInstance(10, 20)).setDeliveryTimeWindow(TimeWindow.newInstance(10, 20))
+                        .build();
 
         Pickup s3 = new Pickup.Builder("s3")
-            .setTimeWindow(TimeWindow.newInstance(10, 20))
-            .setLocation(TestUtils.loc(Coordinate.newInstance(10, 1)))
-            .addSizeDimension(0, 10)
-            .build();
+                        .setTimeWindow(TimeWindow.newInstance(10, 20))
+                        .setLocation(TestUtils.loc(Coordinate.newInstance(10, 1)))
+                        .addSizeDimension(0, 10)
+                        .build();
         Delivery s4 = new Delivery.Builder("s4").setLocation(Location.newInstance(10, 10))
-            .addSizeDimension(0, 20)
-            .setTimeWindow(TimeWindow.newInstance(10, 20))
-            .build();
+                        .addSizeDimension(0, 20)
+                        .setTimeWindow(TimeWindow.newInstance(10, 20))
+                        .build();
         Shipment shipment2 = Shipment.Builder.newInstance("ship2").setPickupLocation(TestUtils.loc(Coordinate.newInstance(15, 2)))
-            .setPickupServiceTime(20.).setDeliveryServiceTime(20.)
-            .setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(16, 5)))
-            .setPickupTimeWindow(TimeWindow.newInstance(10, 20)).setDeliveryTimeWindow(TimeWindow.newInstance(10, 20))
-            .addSizeDimension(0, 15).build();
+                        .setPickupServiceTime(20.).setDeliveryServiceTime(20.)
+                        .setDeliveryLocation(TestUtils.loc(Coordinate.newInstance(16, 5)))
+                        .setPickupTimeWindow(TimeWindow.newInstance(10, 20)).setDeliveryTimeWindow(TimeWindow.newInstance(10, 20))
+                        .addSizeDimension(0, 15).build();
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance().addVehicle(vehicle)
-            .addJob(s1)
-            .addJob(s2).addJob(shipment1).addJob(s3).addJob(s4).addJob(shipment2).setFleetSize(VehicleRoutingProblem.FleetSize.FINITE);
-        vrpBuilder.setRoutingCost(new ManhattanCosts(vrpBuilder.getLocations()));
+                        .addJob(s1)
+                        .addJob(s2).addJob(shipment1).addJob(s3).addJob(s4).addJob(shipment2).setFleetSize(VehicleRoutingProblem.FleetSize.FINITE);
+        vrpBuilder.setRoutingCost(new DefaultCosts(ManhattanDistanceCalculator.getInstance())
+                        .withCoordinateConverter(vrpBuilder.getLocations()));
         vrp = vrpBuilder.build();
 
         VehicleRoute route = VehicleRoute.Builder.newInstance(vehicle).setJobActivityFactory(vrp.getJobActivityFactory())
-            .addPickup(s3)
-            .addPickup(shipment2).addDelivery(shipment2)
-            .addDelivery(s4)
-            .addDelivery(s2)
-            .addPickup(shipment1).addDelivery(shipment1)
-            .addPickup(s1)
-            .build();
+                        .addPickup(s3)
+                        .addPickup(shipment2).addDelivery(shipment2)
+                        .addDelivery(s4)
+                        .addDelivery(s2)
+                        .addPickup(shipment1).addDelivery(shipment1)
+                        .addPickup(s1)
+                        .build();
 
         solution = new VehicleRoutingProblemSolution(Arrays.asList(route), 300);
     }
@@ -231,12 +234,12 @@ public double getDistance(Location fromLocationId, Location toLocationId, double
 
         // this should be the path taken by route 1 including depots
         Coordinate[] route1Path = new Coordinate[]{
-            Coordinate.newInstance(-5, 0),
-            Coordinate.newInstance(-10, 1),
-            Coordinate.newInstance(-15, 2),
-            Coordinate.newInstance(-16, 5),
-            Coordinate.newInstance(-10, 10),
-            Coordinate.newInstance(-5, 0)
+                        Coordinate.newInstance(-5, 0),
+                        Coordinate.newInstance(-10, 1),
+                        Coordinate.newInstance(-15, 2),
+                        Coordinate.newInstance(-16, 5),
+                        Coordinate.newInstance(-10, 10),
+                        Coordinate.newInstance(-5, 0)
 
         };
 
@@ -244,13 +247,13 @@ public double getDistance(Location fromLocationId, Location toLocationId, double
 
         // get route 1 activities
         List<TourActivity> activities = route1.getActivities();
-        Assert.assertEquals(activities.size(), 4);
+        assertEquals(activities.size(), 4);
 
         // utility class to calculate manhattan distance
         class ManhattanDistance {
             private double calc(Coordinate from, Coordinate to) {
                 return Math.abs(from.getX() - to.getX())
-                    + Math.abs(from.getY() - to.getY());
+                                + Math.abs(from.getY() - to.getY());
             }
         }
         ManhattanDistance md = new ManhattanDistance();
@@ -269,13 +272,13 @@ private double calc(Coordinate from, Coordinate to) {
             // test last distance
             if (type == TransportCostsTestType.LAST_DISTANCE) {
                 double savedDist = analyser.getLastTransportDistanceAtActivity(activity, route1);
-                Assert.assertEquals(dist, savedDist, 1E-10);
+                assertEquals(dist, savedDist, 1E-10);
             }
 
             // test last time
             if (type == TransportCostsTestType.LAST_TIME) {
                 double savedTime = analyser.getLastTransportTimeAtActivity(activity, route1);
-                Assert.assertEquals(time, savedTime, 1E-10);
+                assertEquals(time, savedTime, 1E-10);
             }
 
             // test last cost
@@ -289,14 +292,14 @@ private double calc(Coordinate from, Coordinate to) {
                 }
                 double cost = dist * perDistanceUnit;
                 double savedCost = analyser.getLastTransportCostAtActivity(activity, route1);
-                Assert.assertEquals(cost, savedCost, 1E-10);
+                assertEquals(cost, savedCost, 1E-10);
             }
 
             // test total transport time at activity
             if (type == TransportCostsTestType.TRANSPORT_TIME_AT_ACTIVITY) {
                 totalTime += time;
                 double savedTransportTime = analyser.getTransportTimeAtActivity(activity, route1);
-                Assert.assertEquals(totalTime, savedTransportTime, 1E-10);
+                assertEquals(totalTime, savedTransportTime, 1E-10);
             }
         }
     }
@@ -321,7 +324,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0, analyser.getLoadAtBeginning(route).get(0));
+        assertEquals(0, analyser.getLoadAtBeginning(route).get(0));
     }
 
     @Test
@@ -336,7 +339,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
         iterator.next();
         VehicleRoute route = iterator.next();
 
-        Assert.assertEquals(0, analyser.getLoadAtBeginning(route).get(0));
+        assertEquals(0, analyser.getLoadAtBeginning(route).get(0));
     }
 
     @Test
@@ -348,7 +351,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(5, analyser.getLoadAtEnd(route).get(0));
+        assertEquals(5, analyser.getLoadAtEnd(route).get(0));
     }
 
     @Test
@@ -363,7 +366,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
         iterator.next();
         VehicleRoute route = iterator.next();
 
-        Assert.assertEquals(5, analyser.getLoadAtEnd(route).get(0));
+        assertEquals(5, analyser.getLoadAtEnd(route).get(0));
     }
 
     @Test
@@ -375,7 +378,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0, analyser.getLoadRightAfterActivity(route.getStart(), route).get(0));
+        assertEquals(0, analyser.getLoadRightAfterActivity(route.getStart(), route).get(0));
     }
 
     @Test
@@ -387,7 +390,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(2, analyser.getLoadRightAfterActivity(route.getActivities().get(0), route).get(0));
+        assertEquals(2, analyser.getLoadRightAfterActivity(route.getActivities().get(0), route)
+                        .get(0));
     }
 
     @Test
@@ -399,7 +403,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(12, analyser.getLoadRightAfterActivity(route.getActivities().get(1), route).get(0));
+        assertEquals(12, analyser.getLoadRightAfterActivity(route.getActivities().get(1), route)
+                        .get(0));
     }
 
     @Test
@@ -411,7 +416,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(2, analyser.getLoadRightAfterActivity(route.getActivities().get(2), route).get(0));
+        assertEquals(2, analyser.getLoadRightAfterActivity(route.getActivities().get(2), route)
+                        .get(0));
     }
 
     @Test
@@ -423,7 +429,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(5, analyser.getLoadRightAfterActivity(route.getActivities().get(3), route).get(0));
+        assertEquals(5, analyser.getLoadRightAfterActivity(route.getActivities().get(3), route)
+                        .get(0));
     }
 
     @Test
@@ -435,7 +442,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(5, analyser.getLoadRightAfterActivity(route.getEnd(), route).get(0));
+        assertEquals(5, analyser.getLoadRightAfterActivity(route.getEnd(), route).get(0));
     }
 
     @Test
@@ -447,7 +454,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0, analyser.getLoadJustBeforeActivity(route.getStart(), route).get(0));
+        assertEquals(0, analyser.getLoadJustBeforeActivity(route.getStart(), route).get(0));
     }
 
     @Test
@@ -459,7 +466,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0, analyser.getLoadJustBeforeActivity(route.getActivities().get(0), route).get(0));
+        assertEquals(0, analyser.getLoadJustBeforeActivity(route.getActivities().get(0), route)
+                        .get(0));
     }
 
     @Test
@@ -471,7 +479,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(2, analyser.getLoadJustBeforeActivity(route.getActivities().get(1), route).get(0));
+        assertEquals(2, analyser.getLoadJustBeforeActivity(route.getActivities().get(1), route)
+                        .get(0));
     }
 
     @Test
@@ -483,7 +492,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(12, analyser.getLoadJustBeforeActivity(route.getActivities().get(2), route).get(0));
+        assertEquals(12, analyser.getLoadJustBeforeActivity(route.getActivities().get(2), route)
+                        .get(0));
     }
 
     @Test
@@ -495,7 +505,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(2, analyser.getLoadJustBeforeActivity(route.getActivities().get(3), route).get(0));
+        assertEquals(2, analyser.getLoadJustBeforeActivity(route.getActivities().get(3), route)
+                        .get(0));
     }
 
     @Test
@@ -507,7 +518,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(5, analyser.getLoadJustBeforeActivity(route.getEnd(), route).get(0));
+        assertEquals(5, analyser.getLoadJustBeforeActivity(route.getEnd(), route).get(0));
     }
 
     @Test
@@ -519,7 +530,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(12, analyser.getMaxLoad(route).get(0));
+        assertEquals(12, analyser.getMaxLoad(route).get(0));
     }
 
     @Test
@@ -531,7 +542,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(3, analyser.getNumberOfPickups(route), 0.01);
+        assertEquals(3, analyser.getNumberOfPickups(route), 0.01);
     }
 
     @Test
@@ -543,7 +554,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0, analyser.getNumberOfPickupsAtBeginning(route), 0.01);
+        assertEquals(0, analyser.getNumberOfPickupsAtBeginning(route), 0.01);
     }
 
     @Test
@@ -556,7 +567,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(4, analyser.getNumberOfPickups(route), 0.01);
+        assertEquals(4, analyser.getNumberOfPickups(route), 0.01);
     }
 
     @Test
@@ -569,7 +580,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(2, analyser.getNumberOfPickupsAtBeginning(route), 0.01);
+        assertEquals(2, analyser.getNumberOfPickupsAtBeginning(route), 0.01);
     }
 
     @Test
@@ -580,7 +591,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
                 return vrp.getTransportCosts().getTransportCost(from, to, 0., null, null);
             }
         });
-        Assert.assertEquals(6, analyser.getNumberOfPickups(), 0.01);
+        assertEquals(6, analyser.getNumberOfPickups(), 0.01);
     }
 
     @Test
@@ -591,7 +602,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
                 return vrp.getTransportCosts().getTransportCost(from, to, 0., null, null);
             }
         });
-        Assert.assertEquals(0, analyser.getNumberOfPickupsAtBeginning(), 0.01);
+        assertEquals(0, analyser.getNumberOfPickupsAtBeginning(), 0.01);
     }
 
     @Test
@@ -603,7 +614,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
                 return vrp.getTransportCosts().getTransportCost(from, to, 0., null, null);
             }
         });
-        Assert.assertEquals(4, analyser.getNumberOfPickups(), 0.01);
+        assertEquals(4, analyser.getNumberOfPickups(), 0.01);
     }
 
     @Test
@@ -615,7 +626,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
                 return vrp.getTransportCosts().getTransportCost(from, to, 0., null, null);
             }
         });
-        Assert.assertEquals(2, analyser.getNumberOfPickupsAtBeginning(), 0.01);
+        assertEquals(2, analyser.getNumberOfPickupsAtBeginning(), 0.01);
     }
 
     @Test
@@ -627,7 +638,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(15, analyser.getLoadPickedUp(route).get(0), 0.01);
+        assertEquals(15, analyser.getLoadPickedUp(route).get(0), 0.01);
     }
 
     @Test
@@ -639,7 +650,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0, analyser.getLoadAtBeginning(route).get(0), 0.01);
+        assertEquals(0, analyser.getLoadAtBeginning(route).get(0), 0.01);
     }
 
     @Test
@@ -652,7 +663,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(50, analyser.getLoadPickedUp(route).get(0), 0.01);
+        assertEquals(50, analyser.getLoadPickedUp(route).get(0), 0.01);
     }
 
     @Test
@@ -665,7 +676,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(40, analyser.getLoadAtBeginning(route).get(0), 0.01);
+        assertEquals(40, analyser.getLoadAtBeginning(route).get(0), 0.01);
     }
 
     @Test
@@ -676,7 +687,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
                 return vrp.getTransportCosts().getTransportCost(from, to, 0., null, null);
             }
         });
-        Assert.assertEquals(30, analyser.getLoadPickedUp().get(0), 0.01);
+        assertEquals(30, analyser.getLoadPickedUp().get(0), 0.01);
     }
 
     @Test
@@ -687,7 +698,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
                 return vrp.getTransportCosts().getTransportCost(from, to, 0., null, null);
             }
         });
-        Assert.assertEquals(0, analyser.getLoadAtBeginning().get(0), 0.01);
+        assertEquals(0, analyser.getLoadAtBeginning().get(0), 0.01);
     }
 
     @Test
@@ -699,7 +710,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
                 return vrp.getTransportCosts().getTransportCost(from, to, 0., null, null);
             }
         });
-        Assert.assertEquals(50, analyser.getLoadPickedUp().get(0), 0.01);
+        assertEquals(50, analyser.getLoadPickedUp().get(0), 0.01);
     }
 
     @Test
@@ -711,7 +722,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
                 return vrp.getTransportCosts().getTransportCost(from, to, 0., null, null);
             }
         });
-        Assert.assertEquals(40, analyser.getLoadAtBeginning().get(0), 0.01);
+        assertEquals(40, analyser.getLoadAtBeginning().get(0), 0.01);
     }
 
     @Test
@@ -723,7 +734,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(1, analyser.getNumberOfDeliveries(route), 0.01);
+        assertEquals(1, analyser.getNumberOfDeliveries(route), 0.01);
     }
 
     @Test
@@ -735,7 +746,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(2, analyser.getNumberOfDeliveriesAtEnd(route), 0.01);
+        assertEquals(2, analyser.getNumberOfDeliveriesAtEnd(route), 0.01);
     }
 
     @Test
@@ -748,7 +759,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(4, analyser.getNumberOfDeliveries(route), 0.01);
+        assertEquals(4, analyser.getNumberOfDeliveries(route), 0.01);
     }
 
     @Test
@@ -761,7 +772,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(2, analyser.getNumberOfDeliveriesAtEnd(route), 0.01);
+        assertEquals(2, analyser.getNumberOfDeliveriesAtEnd(route), 0.01);
     }
 
     @Test
@@ -772,7 +783,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
                 return vrp.getTransportCosts().getTransportCost(from, to, 0., null, null);
             }
         });
-        Assert.assertEquals(2, analyser.getNumberOfDeliveries(), 0.01);
+        assertEquals(2, analyser.getNumberOfDeliveries(), 0.01);
     }
 
     @Test
@@ -783,7 +794,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
                 return vrp.getTransportCosts().getTransportCost(from, to, 0., null, null);
             }
         });
-        Assert.assertEquals(4, analyser.getNumberOfDeliveriesAtEnd(), 0.01);
+        assertEquals(4, analyser.getNumberOfDeliveriesAtEnd(), 0.01);
     }
 
     @Test
@@ -795,7 +806,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
                 return vrp.getTransportCosts().getTransportCost(from, to, 0., null, null);
             }
         });
-        Assert.assertEquals(4, analyser.getNumberOfDeliveries(), 0.01);
+        assertEquals(4, analyser.getNumberOfDeliveries(), 0.01);
     }
 
     @Test
@@ -807,7 +818,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
                 return vrp.getTransportCosts().getTransportCost(from, to, 0., null, null);
             }
         });
-        Assert.assertEquals(2, analyser.getNumberOfDeliveriesAtEnd(), 0.01);
+        assertEquals(2, analyser.getNumberOfDeliveriesAtEnd(), 0.01);
     }
 
     @Test
@@ -819,7 +830,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(10, analyser.getLoadDelivered(route).get(0), 0.01);
+        assertEquals(10, analyser.getLoadDelivered(route).get(0), 0.01);
     }
 
     @Test
@@ -831,7 +842,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(5, analyser.getLoadAtEnd(route).get(0), 0.01);
+        assertEquals(5, analyser.getLoadAtEnd(route).get(0), 0.01);
     }
 
     @Test
@@ -844,7 +855,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(70, analyser.getLoadDelivered(route).get(0), 0.01);
+        assertEquals(70, analyser.getLoadDelivered(route).get(0), 0.01);
     }
 
     @Test
@@ -857,7 +868,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(20, analyser.getLoadAtEnd(route).get(0), 0.01);
+        assertEquals(20, analyser.getLoadAtEnd(route).get(0), 0.01);
     }
 
     @Test
@@ -868,7 +879,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
                 return vrp.getTransportCosts().getTransportCost(from, to, 0., null, null);
             }
         });
-        Assert.assertEquals(20, analyser.getLoadDelivered().get(0), 0.01);
+        assertEquals(20, analyser.getLoadDelivered().get(0), 0.01);
     }
 
     @Test
@@ -879,7 +890,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
                 return vrp.getTransportCosts().getTransportCost(from, to, 0., null, null);
             }
         });
-        Assert.assertEquals(10, analyser.getLoadAtEnd().get(0), 0.01);
+        assertEquals(10, analyser.getLoadAtEnd().get(0), 0.01);
     }
 
     @Test
@@ -892,7 +903,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(70, analyser.getLoadDelivered().get(0), 0.01);
+        assertEquals(70, analyser.getLoadDelivered().get(0), 0.01);
     }
 
     @Test
@@ -904,7 +915,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
                 return vrp.getTransportCosts().getTransportCost(from, to, 0., null, null);
             }
         });
-        Assert.assertEquals(20, analyser.getLoadAtEnd().get(0), 0.01);
+        assertEquals(20, analyser.getLoadAtEnd().get(0), 0.01);
     }
 
     @Test
@@ -916,7 +927,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(46. + 40., analyser.getOperationTime(route), 0.01);
+        assertEquals(46. + 40., analyser.getOperationTime(route), 0.01);
     }
 
     @Test
@@ -928,7 +939,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(4., analyser.getWaitingTime(route), 0.01);
+        assertEquals(4., analyser.getWaitingTime(route), 0.01);
     }
 
     @Test
@@ -940,7 +951,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(42., analyser.getTransportTime(route), 0.01);
+        assertEquals(42., analyser.getTransportTime(route), 0.01);
     }
 
     @Test
@@ -952,7 +963,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(40., analyser.getServiceTime(route), 0.01);
+        assertEquals(40., analyser.getServiceTime(route), 0.01);
     }
 
     @Test
@@ -964,7 +975,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(42., analyser.getDistance(route), 0.01);
+        assertEquals(42., analyser.getDistance(route), 0.01);
     }
 
     @Test
@@ -976,7 +987,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0, analyser.getWaitingTimeAtActivity(route.getStart(), route), 0.01);
+        assertEquals(0, analyser.getWaitingTimeAtActivity(route.getStart(), route), 0.01);
     }
 
     @Test
@@ -988,7 +999,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(4., analyser.getWaitingTimeAtActivity(route.getActivities().get(0), route), 0.01);
+        assertEquals(4., analyser.getWaitingTimeAtActivity(route.getActivities().get(0), route),
+                        0.01);
     }
 
     @Test
@@ -1000,7 +1012,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0., analyser.getWaitingTimeAtActivity(route.getActivities().get(1), route), 0.01);
+        assertEquals(0., analyser.getWaitingTimeAtActivity(route.getActivities().get(1), route),
+                        0.01);
     }
 
     @Test
@@ -1012,7 +1025,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0., analyser.getWaitingTimeAtActivity(route.getActivities().get(2), route), 0.01);
+        assertEquals(0., analyser.getWaitingTimeAtActivity(route.getActivities().get(2), route),
+                        0.01);
     }
 
     @Test
@@ -1024,7 +1038,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0., analyser.getWaitingTimeAtActivity(route.getActivities().get(3), route), 0.01);
+        assertEquals(0., analyser.getWaitingTimeAtActivity(route.getActivities().get(3), route),
+                        0.01);
     }
 
     @Test
@@ -1036,7 +1051,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0., analyser.getWaitingTimeAtActivity(route.getEnd(), route), 0.01);
+        assertEquals(0., analyser.getWaitingTimeAtActivity(route.getEnd(), route), 0.01);
     }
 
     @Test
@@ -1048,7 +1063,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0, analyser.getDistanceAtActivity(route.getStart(), route), 0.01);
+        assertEquals(0, analyser.getDistanceAtActivity(route.getStart(), route), 0.01);
     }
 
     @Test
@@ -1060,7 +1075,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(6., analyser.getDistanceAtActivity(route.getActivities().get(0), route), 0.01);
+        assertEquals(6., analyser.getDistanceAtActivity(route.getActivities().get(0), route), 0.01);
     }
 
     @Test
@@ -1072,7 +1087,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(12., analyser.getDistanceAtActivity(route.getActivities().get(1), route), 0.01);
+        assertEquals(12., analyser.getDistanceAtActivity(route.getActivities().get(1), route),
+                        0.01);
     }
 
     @Test
@@ -1084,7 +1100,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(16., analyser.getDistanceAtActivity(route.getActivities().get(2), route), 0.01);
+        assertEquals(16., analyser.getDistanceAtActivity(route.getActivities().get(2), route),
+                        0.01);
     }
 
     @Test
@@ -1096,7 +1113,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(27., analyser.getDistanceAtActivity(route.getActivities().get(3), route), 0.01);
+        assertEquals(27., analyser.getDistanceAtActivity(route.getActivities().get(3), route),
+                        0.01);
     }
 
     @Test
@@ -1108,7 +1126,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(42., analyser.getDistanceAtActivity(route.getEnd(), route), 0.01);
+        assertEquals(42., analyser.getDistanceAtActivity(route.getEnd(), route), 0.01);
     }
 
 
@@ -1121,7 +1139,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0, analyser.getTimeWindowViolationAtActivity(route.getStart(), route), 0.01);
+        assertEquals(0, analyser.getTimeWindowViolationAtActivity(route.getStart(), route), 0.01);
     }
 
     @Test
@@ -1133,7 +1151,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0., analyser.getTimeWindowViolationAtActivity(route.getActivities().get(0), route), 0.01);
+        assertEquals(0., analyser.getTimeWindowViolationAtActivity(route.getActivities().get(0),
+                        route), 0.01);
     }
 
     @Test
@@ -1145,7 +1164,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0., analyser.getTimeWindowViolationAtActivity(route.getActivities().get(1), route), 0.01);
+        assertEquals(0., analyser.getTimeWindowViolationAtActivity(route.getActivities().get(1),
+                        route), 0.01);
     }
 
     @Test
@@ -1157,7 +1177,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0., analyser.getTimeWindowViolationAtActivity(route.getActivities().get(2), route), 0.01);
+        assertEquals(0., analyser.getTimeWindowViolationAtActivity(route.getActivities().get(2),
+                        route), 0.01);
     }
 
     @Test
@@ -1169,7 +1190,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0., analyser.getTimeWindowViolationAtActivity(route.getActivities().get(3), route), 0.01);
+        assertEquals(0., analyser.getTimeWindowViolationAtActivity(route.getActivities().get(3),
+                        route), 0.01);
     }
 
     @Test
@@ -1181,7 +1203,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0., analyser.getTimeWindowViolationAtActivity(route.getEnd(), route), 0.01);
+        assertEquals(0., analyser.getTimeWindowViolationAtActivity(route.getEnd(), route), 0.01);
     }
 
     @Test
@@ -1193,7 +1215,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0., analyser.getTimeWindowViolation(route), 0.01);
+        assertEquals(0., analyser.getTimeWindowViolation(route), 0.01);
     }
 
     @Test
@@ -1205,7 +1227,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(84., analyser.getVariableTransportCosts(route), 0.01);
+        assertEquals(84., analyser.getVariableTransportCosts(route), 0.01);
     }
 
     @Test
@@ -1217,7 +1239,7 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(100., analyser.getFixedCosts(route), 0.01);
+        assertEquals(100., analyser.getFixedCosts(route), 0.01);
     }
 
     @Test
@@ -1229,7 +1251,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(0, analyser.getVariableTransportCostsAtActivity(route.getStart(), route), 0.01);
+        assertEquals(0, analyser.getVariableTransportCostsAtActivity(route.getStart(), route),
+                        0.01);
     }
 
     @Test
@@ -1241,7 +1264,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(6. * 2., analyser.getVariableTransportCostsAtActivity(route.getActivities().get(0), route), 0.01);
+        assertEquals(6. * 2., analyser.getVariableTransportCostsAtActivity(
+                        route.getActivities().get(0), route), 0.01);
     }
 
     @Test
@@ -1253,7 +1277,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(12. * 2., analyser.getVariableTransportCostsAtActivity(route.getActivities().get(1), route), 0.01);
+        assertEquals(12. * 2., analyser.getVariableTransportCostsAtActivity(
+                        route.getActivities().get(1), route), 0.01);
     }
 
     @Test
@@ -1265,7 +1290,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(16. * 2., analyser.getVariableTransportCostsAtActivity(route.getActivities().get(2), route), 0.01);
+        assertEquals(16. * 2., analyser.getVariableTransportCostsAtActivity(
+                        route.getActivities().get(2), route), 0.01);
     }
 
     @Test
@@ -1277,7 +1303,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(27. * 2., analyser.getVariableTransportCostsAtActivity(route.getActivities().get(3), route), 0.01);
+        assertEquals(27. * 2., analyser.getVariableTransportCostsAtActivity(
+                        route.getActivities().get(3), route), 0.01);
     }
 
     @Test
@@ -1289,7 +1316,8 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
             }
         });
         VehicleRoute route = solution.getRoutes().iterator().next();
-        Assert.assertEquals(42. * 2., analyser.getVariableTransportCostsAtActivity(route.getEnd(), route), 0.01);
+        assertEquals(42. * 2., analyser.getVariableTransportCostsAtActivity(route.getEnd(), route),
+                        0.01);
     }
 
     @Test
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/LoadConstraintTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/LoadConstraintTest.java
index 54ea6e19a..794007606 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/LoadConstraintTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/LoadConstraintTest.java
@@ -42,11 +42,10 @@
 import com.graphhopper.jsprit.core.problem.job.Shipment;
 import com.graphhopper.jsprit.core.problem.misc.JobInsertionContext;
 import com.graphhopper.jsprit.core.problem.solution.route.VehicleRoute;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliverServiceDEPRECATED;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliverShipmentDEPRECATED;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupServiceDEPRECATED;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupShipmentDEPRECATED;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivityNEW;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupActivityNEW;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.ServiceActivityNEW;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindows;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
 
@@ -126,7 +125,7 @@ public void whenServiceRouteAndNewServiceFitsInBetweenStartAndAct1_itShouldRetur
         stateManager.informInsertionStarts(Arrays.asList(serviceRoute), Collections.<Job>emptyList());
         Service s = mock(Service.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 5).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
@@ -143,7 +142,7 @@ public void whenServiceRouteAndNewServiceFitsInBetweenAc1AndAct2_itShouldReturnF
         stateManager.informInsertionStarts(Arrays.asList(serviceRoute), Collections.<Job>emptyList());
         Service s = mock(Service.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 5).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
@@ -160,7 +159,7 @@ public void whenServiceRouteAndNewServiceFitsInBetweenAc2AndEnd_itShouldReturnFu
         stateManager.informInsertionStarts(Arrays.asList(serviceRoute), Collections.<Job>emptyList());
         Service s = mock(Service.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 5).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
@@ -180,7 +179,7 @@ public void whenServiceRouteAndNewServiceDoesNotFitInBetweenStartAndAct1_itShoul
         stateManager.informInsertionStarts(Arrays.asList(serviceRoute), Collections.<Job>emptyList());
         Service s = mock(Service.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 6).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
@@ -197,7 +196,7 @@ public void whenServiceRouteAndNewServiceDoesNotFitInBetweenAc1AndAct2_itShouldR
         stateManager.informInsertionStarts(Arrays.asList(serviceRoute), Collections.<Job>emptyList());
         Service s = mock(Service.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 6).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
@@ -214,7 +213,7 @@ public void whenServiceRouteAndNewServiceDoesNotFitInBetweenAc2AndEnd_itShouldRe
         stateManager.informInsertionStarts(Arrays.asList(serviceRoute), Collections.<Job>emptyList());
         Service s = mock(Service.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 6).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
@@ -295,11 +294,12 @@ public void whenPDRoute_newPickupShouldFitInBetweenStartAndAct1() {
         stateManager.informInsertionStarts(Arrays.asList(pickup_delivery_route), Collections.<Job>emptyList());
         Pickup s = mock(Pickup.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 5).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(pickup_delivery_route, s, pickup_delivery_route.getVehicle(), null, 0.);
-        PickupServiceDEPRECATED newAct = new PickupServiceDEPRECATED(s);
+        PickupActivityNEW newAct = new PickupActivityNEW(s, "pick", null, 0, newSize,
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickup_delivery_route.getStart(), newAct, pickup_delivery_route.getActivities().get(0), 0.);
 
@@ -311,11 +311,12 @@ public void whenPDRoute_newPickupShouldFitInBetweenAct1AndAct2() {
         stateManager.informInsertionStarts(Arrays.asList(pickup_delivery_route), Collections.<Job>emptyList());
         Pickup s = mock(Pickup.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 5).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(pickup_delivery_route, s, pickup_delivery_route.getVehicle(), null, 0.);
-        PickupServiceDEPRECATED newAct = new PickupServiceDEPRECATED(s);
+        PickupActivityNEW newAct = new PickupActivityNEW(s, "pick", null, 0, newSize,
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickup_delivery_route.getActivities().get(0), newAct, pickup_delivery_route.getActivities().get(1), 0.);
 
@@ -327,11 +328,12 @@ public void whenPDRoute_newPickupShouldFitInBetweenAct2AndEnd() {
         stateManager.informInsertionStarts(Arrays.asList(pickup_delivery_route), Collections.<Job>emptyList());
         Pickup s = mock(Pickup.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 10).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(pickup_delivery_route, s, pickup_delivery_route.getVehicle(), null, 0.);
-        PickupServiceDEPRECATED newAct = new PickupServiceDEPRECATED(s);
+        PickupActivityNEW newAct = new PickupActivityNEW(s, "pick", null, 0, newSize,
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickup_delivery_route.getActivities().get(1), newAct, pickup_delivery_route.getEnd(), 0.);
 
@@ -346,11 +348,12 @@ public void whenPDRoute_newPickupShouldNotFitInBetweenStartAndAct1() {
         stateManager.informInsertionStarts(Arrays.asList(pickup_delivery_route), Collections.<Job>emptyList());
         Pickup s = mock(Pickup.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 6).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(pickup_delivery_route, s, pickup_delivery_route.getVehicle(), null, 0.);
-        PickupServiceDEPRECATED newAct = new PickupServiceDEPRECATED(s);
+        PickupActivityNEW newAct = new PickupActivityNEW(s, "pick", null, 0, newSize,
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickup_delivery_route.getStart(), newAct, pickup_delivery_route.getActivities().get(0), 0.);
 
@@ -362,11 +365,12 @@ public void whenPDRoute_newPickupShouldNotFitInBetweenAct1AndAct2() {
         stateManager.informInsertionStarts(Arrays.asList(pickup_delivery_route), Collections.<Job>emptyList());
         Pickup s = mock(Pickup.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 6).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(pickup_delivery_route, s, pickup_delivery_route.getVehicle(), null, 0.);
-        PickupServiceDEPRECATED newAct = new PickupServiceDEPRECATED(s);
+        PickupActivityNEW newAct = new PickupActivityNEW(s, "pick", null, 0, newSize,
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickup_delivery_route.getActivities().get(0), newAct, pickup_delivery_route.getActivities().get(1), 0.);
 
@@ -378,11 +382,12 @@ public void whenPDRoute_newPickupShouldNotFitInBetweenAct2AndEnd() {
         stateManager.informInsertionStarts(Arrays.asList(pickup_delivery_route), Collections.<Job>emptyList());
         Pickup s = mock(Pickup.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 11).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(pickup_delivery_route, s, pickup_delivery_route.getVehicle(), null, 0.);
-        PickupServiceDEPRECATED newAct = new PickupServiceDEPRECATED(s);
+        PickupActivityNEW newAct = new PickupActivityNEW(s, "pick", null, 0, newSize,
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickup_delivery_route.getActivities().get(1), newAct, pickup_delivery_route.getEnd(), 0.);
 
@@ -398,11 +403,13 @@ public void whenPDRoute_newDeliveryShouldFitInBetweenStartAndAct1() {
         stateManager.informInsertionStarts(Arrays.asList(pickup_delivery_route), Collections.<Job>emptyList());
         Delivery s = mock(Delivery.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 15).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(pickup_delivery_route, s, pickup_delivery_route.getVehicle(), null, 0.);
-        DeliverServiceDEPRECATED newAct = new DeliverServiceDEPRECATED(s);
+        DeliveryActivityNEW newAct = new DeliveryActivityNEW(s, "del", null, 0,
+                        Capacity.invert(newSize),
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickup_delivery_route.getStart(), newAct, pickup_delivery_route.getActivities().get(0), 0.);
 
@@ -414,11 +421,13 @@ public void whenPDRoute_newDeliveryShouldNotFitInBetweenStartAndAct1() {
         stateManager.informInsertionStarts(Arrays.asList(pickup_delivery_route), Collections.<Job>emptyList());
         Delivery s = mock(Delivery.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 16).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(pickup_delivery_route, s, pickup_delivery_route.getVehicle(), null, 0.);
-        DeliverServiceDEPRECATED newAct = new DeliverServiceDEPRECATED(s);
+        DeliveryActivityNEW newAct = new DeliveryActivityNEW(s, "del", null, 0,
+                        Capacity.invert(newSize),
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickup_delivery_route.getStart(), newAct, pickup_delivery_route.getActivities().get(0), 0.);
 
@@ -430,11 +439,13 @@ public void whenPDRoute_newDeliveryShouldFitInBetweenAct1AndAct2() {
         stateManager.informInsertionStarts(Arrays.asList(pickup_delivery_route), Collections.<Job>emptyList());
         Delivery s = mock(Delivery.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 5).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(pickup_delivery_route, s, pickup_delivery_route.getVehicle(), null, 0.);
-        DeliverServiceDEPRECATED newAct = new DeliverServiceDEPRECATED(s);
+        DeliveryActivityNEW newAct = new DeliveryActivityNEW(s, "del", null, 0,
+                        Capacity.invert(newSize),
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickup_delivery_route.getActivities().get(0), newAct, pickup_delivery_route.getActivities().get(1), 0.);
 
@@ -446,11 +457,13 @@ public void whenPDRoute_newDeliveryNotShouldFitInBetweenAct1AndAct2() {
         stateManager.informInsertionStarts(Arrays.asList(pickup_delivery_route), Collections.<Job>emptyList());
         Delivery s = mock(Delivery.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 6).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(pickup_delivery_route, s, pickup_delivery_route.getVehicle(), null, 0.);
-        DeliverServiceDEPRECATED newAct = new DeliverServiceDEPRECATED(s);
+        DeliveryActivityNEW newAct = new DeliveryActivityNEW(s, "del", null, 0,
+                        Capacity.invert(newSize),
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickup_delivery_route.getActivities().get(0), newAct, pickup_delivery_route.getActivities().get(1), 0.);
 
@@ -462,11 +475,13 @@ public void whenPDRoute_newDeliveryShouldFitInBetweenAct2AndEnd() {
         stateManager.informInsertionStarts(Arrays.asList(pickup_delivery_route), Collections.<Job>emptyList());
         Delivery s = mock(Delivery.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 5).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(pickup_delivery_route, s, pickup_delivery_route.getVehicle(), null, 0.);
-        DeliverServiceDEPRECATED newAct = new DeliverServiceDEPRECATED(s);
+        DeliveryActivityNEW newAct = new DeliveryActivityNEW(s, "del", null, 0,
+                        Capacity.invert(newSize),
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickup_delivery_route.getActivities().get(1), newAct, pickup_delivery_route.getEnd(), 0.);
 
@@ -478,11 +493,13 @@ public void whenPDRoute_newDeliveryShouldNotFitInBetweenAct2AndEnd() {
         stateManager.informInsertionStarts(Arrays.asList(pickup_delivery_route), Collections.<Job>emptyList());
         Delivery s = mock(Delivery.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 6).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(pickup_delivery_route, s, pickup_delivery_route.getVehicle(), null, 0.);
-        DeliverServiceDEPRECATED newAct = new DeliverServiceDEPRECATED(s);
+        DeliveryActivityNEW newAct = new DeliveryActivityNEW(s, "del", null, 0,
+                        Capacity.invert(newSize),
+                        TimeWindows.ANY_TIME.getTimeWindows());
 
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, pickup_delivery_route.getActivities().get(1), newAct, pickup_delivery_route.getEnd(), 0.);
 
@@ -494,7 +511,7 @@ public void whenPDRouteAndNewServiceFitsInBetweenAc1AndAct2_itShouldReturnFulfil
         stateManager.informInsertionStarts(Arrays.asList(pickup_delivery_route), Collections.<Job>emptyList());
         Service s = mock(Service.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 5).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
@@ -511,7 +528,7 @@ public void whenPDRouteAndNewServiceFitsInBetweenAc2AndEnd_itShouldReturnFulfill
         stateManager.informInsertionStarts(Arrays.asList(pickup_delivery_route), Collections.<Job>emptyList());
         Service s = mock(Service.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 5).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
@@ -531,7 +548,7 @@ public void whenPDRouteAndNewServiceDoesNotFitInBetweenStartAndAct1_itShouldRetu
         stateManager.informInsertionStarts(Arrays.asList(serviceRoute), Collections.<Job>emptyList());
         Service s = mock(Service.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 6).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
@@ -548,7 +565,7 @@ public void whenPDRouteAndNewServiceDoesNotFitInBetweenAc1AndAct2_itShouldReturn
         stateManager.informInsertionStarts(Arrays.asList(pickup_delivery_route), Collections.<Job>emptyList());
         Service s = mock(Service.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 6).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
@@ -565,7 +582,7 @@ public void whenPDRouteAndNewServiceDoesNotFitInBetweenAc2AndEnd_itShouldReturnF
         stateManager.informInsertionStarts(Arrays.asList(serviceRoute), Collections.<Job>emptyList());
         Service s = mock(Service.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 6).build();
-        when(s.getSize()).thenReturn(newSize);
+
         ServiceLoadActivityLevelConstraint loadConstraint = new ServiceLoadActivityLevelConstraint(stateManager);
 
         JobInsertionContext context = new JobInsertionContext(serviceRoute, s, serviceRoute.getVehicle(), null, 0.);
@@ -602,11 +619,12 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldFitInBetweenStartAndAct
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 20).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        PickupShipmentDEPRECATED newAct = new PickupShipmentDEPRECATED(s);
+        PickupActivityNEW newAct = new PickupActivityNEW(s, "pick", null, 0, newSize,
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getStart(), newAct, shipment_route.getActivities().get(0), 0.);
 
@@ -619,11 +637,12 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldNotFitInBetweenStartAnd
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 21).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        PickupShipmentDEPRECATED newAct = new PickupShipmentDEPRECATED(s);
+        PickupActivityNEW newAct = new PickupActivityNEW(s, "pick", null, 0, newSize,
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getStart(), newAct, shipment_route.getActivities().get(0), 0.);
 
@@ -636,11 +655,12 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldFitInBetweenAct1AndAct2
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 10).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        PickupShipmentDEPRECATED newAct = new PickupShipmentDEPRECATED(s);
+        PickupActivityNEW newAct = new PickupActivityNEW(s, "pick", null, 0, newSize,
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getActivities().get(0), newAct, shipment_route.getActivities().get(1), 0.);
 
@@ -653,11 +673,12 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldNotFitInBetweenAct1AndA
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 11).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        PickupShipmentDEPRECATED newAct = new PickupShipmentDEPRECATED(s);
+        PickupActivityNEW newAct = new PickupActivityNEW(s, "pick", null, 0, newSize,
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getActivities().get(0), newAct, shipment_route.getActivities().get(1), 0.);
 
@@ -670,11 +691,12 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldFitInBetweenAct2AndAct3
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 5).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        PickupShipmentDEPRECATED newAct = new PickupShipmentDEPRECATED(s);
+        PickupActivityNEW newAct = new PickupActivityNEW(s, "pick", null, 0, newSize,
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getActivities().get(1), newAct, shipment_route.getActivities().get(2), 0.);
 
@@ -687,11 +709,12 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldNotFitInBetweenAct2AndA
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 6).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        PickupShipmentDEPRECATED newAct = new PickupShipmentDEPRECATED(s);
+        PickupActivityNEW newAct = new PickupActivityNEW(s, "pick", null, 0, newSize,
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getActivities().get(1), newAct, shipment_route.getActivities().get(2), 0.);
 
@@ -704,11 +727,12 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldFitInBetweenAct3AndAct4
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 10).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        PickupShipmentDEPRECATED newAct = new PickupShipmentDEPRECATED(s);
+        PickupActivityNEW newAct = new PickupActivityNEW(s, "pick", null, 0, newSize,
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getActivities().get(2), newAct, shipment_route.getActivities().get(3), 0.);
 
@@ -721,11 +745,12 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldNotFitInBetweenAct3AndA
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 11).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        PickupShipmentDEPRECATED newAct = new PickupShipmentDEPRECATED(s);
+        PickupActivityNEW newAct = new PickupActivityNEW(s, "pick", null, 0, newSize,
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getActivities().get(2), newAct, shipment_route.getActivities().get(3), 0.);
 
@@ -738,11 +763,12 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldFitInBetweenAct4AndEnd(
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 20).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        PickupShipmentDEPRECATED newAct = new PickupShipmentDEPRECATED(s);
+        PickupActivityNEW newAct = new PickupActivityNEW(s, "pick", null, 0, newSize,
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getActivities().get(3), newAct, shipment_route.getEnd(), 0.);
 
@@ -755,11 +781,12 @@ public void whenShipmentRouteAndPickupOfNewShipmentShouldNotFitInBetweenAct4AndE
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 21).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        PickupShipmentDEPRECATED newAct = new PickupShipmentDEPRECATED(s);
+        PickupActivityNEW newAct = new PickupActivityNEW(s, "pick", null, 0, newSize,
+                        TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getActivities().get(3), newAct, shipment_route.getEnd(), 0.);
 
@@ -776,11 +803,12 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldFitInBetweenStartAndA
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 20).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        DeliverShipmentDEPRECATED newAct = new DeliverShipmentDEPRECATED(s);
+        DeliveryActivityNEW newAct = new DeliveryActivityNEW(s, "pick", null, 0,
+                        Capacity.invert(newSize), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getStart(), newAct, shipment_route.getActivities().get(0), 0.);
 
@@ -793,11 +821,12 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldNotFitInBetweenStartA
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 21).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        DeliverShipmentDEPRECATED newAct = new DeliverShipmentDEPRECATED(s);
+        DeliveryActivityNEW newAct = new DeliveryActivityNEW(s, "pick", null, 0,
+                        Capacity.invert(newSize), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getStart(), newAct, shipment_route.getActivities().get(0), 0.);
 
@@ -810,11 +839,12 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldFitInBetweenAct1AndAc
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 10).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        DeliverShipmentDEPRECATED newAct = new DeliverShipmentDEPRECATED(s);
+        DeliveryActivityNEW newAct = new DeliveryActivityNEW(s, "pick", null, 0,
+                        Capacity.invert(newSize), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getActivities().get(0), newAct, shipment_route.getActivities().get(1), 0.);
 
@@ -827,11 +857,12 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldNotFitInBetweenAct1An
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 11).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        DeliverShipmentDEPRECATED newAct = new DeliverShipmentDEPRECATED(s);
+        DeliveryActivityNEW newAct = new DeliveryActivityNEW(s, "pick", null, 0,
+                        Capacity.invert(newSize), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getActivities().get(0), newAct, shipment_route.getActivities().get(1), 0.);
 
@@ -844,11 +875,12 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldFitInBetweenAct2AndAc
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 5).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        DeliverShipmentDEPRECATED newAct = new DeliverShipmentDEPRECATED(s);
+        DeliveryActivityNEW newAct = new DeliveryActivityNEW(s, "pick", null, 0,
+                        Capacity.invert(newSize), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getActivities().get(1), newAct, shipment_route.getActivities().get(2), 0.);
 
@@ -861,11 +893,12 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldNotFitInBetweenAct2An
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 6).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        DeliverShipmentDEPRECATED newAct = new DeliverShipmentDEPRECATED(s);
+        DeliveryActivityNEW newAct = new DeliveryActivityNEW(s, "pick", null, 0,
+                        Capacity.invert(newSize), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getActivities().get(1), newAct, shipment_route.getActivities().get(2), 0.);
 
@@ -878,11 +911,12 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldFitInBetweenAct3AndAc
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 10).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        DeliverShipmentDEPRECATED newAct = new DeliverShipmentDEPRECATED(s);
+        DeliveryActivityNEW newAct = new DeliveryActivityNEW(s, "pick", null, 0,
+                        Capacity.invert(newSize), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getActivities().get(2), newAct, shipment_route.getActivities().get(3), 0.);
 
@@ -895,11 +929,12 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldNotFitInBetweenAct3An
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 11).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        DeliverShipmentDEPRECATED newAct = new DeliverShipmentDEPRECATED(s);
+        DeliveryActivityNEW newAct = new DeliveryActivityNEW(s, "pick", null, 0,
+                        Capacity.invert(newSize), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getActivities().get(2), newAct, shipment_route.getActivities().get(3), 0.);
 
@@ -912,11 +947,12 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldFitInBetweenAct4AndEn
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 20).build();
-        when(s.getSize()).thenReturn(newSize);
+
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        DeliverShipmentDEPRECATED newAct = new DeliverShipmentDEPRECATED(s);
+        DeliveryActivityNEW newAct = new DeliveryActivityNEW(s, "pick", null, 0,
+                        Capacity.invert(newSize), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getActivities().get(3), newAct, shipment_route.getEnd(), 0.);
 
@@ -929,11 +965,11 @@ public void whenShipmentRouteAndDeliveryOfNewShipmentShouldNotFitInBetweenAct4An
         stateManager.informInsertionStarts(Arrays.asList(shipment_route), Collections.<Job>emptyList());
         Shipment s = mock(Shipment.class);
         Capacity newSize = Capacity.Builder.newInstance().addDimension(0, 21).build();
-        when(s.getSize()).thenReturn(newSize);
 
         JobInsertionContext context = new JobInsertionContext(shipment_route, s, shipment_route.getVehicle(), null, 0.);
 
-        DeliverShipmentDEPRECATED newAct = new DeliverShipmentDEPRECATED(s);
+        DeliveryActivityNEW newAct = new DeliveryActivityNEW(s, "pick", null, 0,
+                        Capacity.invert(newSize), TimeWindows.ANY_TIME.getTimeWindows());
         PickupAndDeliverShipmentLoadActivityLevelConstraint loadConstraint = new PickupAndDeliverShipmentLoadActivityLevelConstraint(stateManager);
         HardActivityConstraint.ConstraintsStatus status = loadConstraint.fulfilled(context, shipment_route.getActivities().get(3), newAct, shipment_route.getEnd(), 0.);
 
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
index 0db39ebb2..68eced2c8 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/constraint/VehicleDependentTraveledDistanceTest.java
@@ -30,6 +30,7 @@
 
 import com.graphhopper.jsprit.core.algorithm.state.StateId;
 import com.graphhopper.jsprit.core.algorithm.state.StateManager;
+import com.graphhopper.jsprit.core.distance.ManhattanDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.cost.TransportDistance;
@@ -42,7 +43,7 @@
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleImpl;
-import com.graphhopper.jsprit.core.util.ManhattanCosts;
+import com.graphhopper.jsprit.core.util.DefaultCosts;
 
 /**
  * Created by schroeder on 18/05/16.
@@ -83,28 +84,32 @@ public void doBefore(){
         d2 = Delivery.Builder.newInstance("d2").setLocation(Location.newInstance(20,15)).build();
         pickup = Pickup.Builder.newInstance("pickup").setLocation(Location.newInstance(50,50)).build();
         s1 = Shipment.Builder.newInstance("s1").setPickupLocation(Location.newInstance(35,30))
-            .setDeliveryLocation(Location.newInstance(20,25)).build();
+                        .setDeliveryLocation(Location.newInstance(20,25)).build();
 
         newDelivery = Delivery.Builder.newInstance("new").setLocation(Location.newInstance(-10,10)).build();
 
         vrp = VehicleRoutingProblem.Builder.newInstance()
-            .setRoutingCost(new ManhattanCosts()).addVehicle(vehicle).addVehicle(vehicle2)
-            .addJob(d1).addJob(d2).addJob(s1).addJob(pickup).addJob(newDelivery).build();
+                        .setRoutingCost(new DefaultCosts(ManhattanDistanceCalculator.getInstance()))
+                        .addVehicle(vehicle).addVehicle(vehicle2)
+                        .addJob(d1).addJob(d2).addJob(s1).addJob(pickup).addJob(newDelivery).build();
 
         route = VehicleRoute.Builder.newInstance(vehicle).setJobActivityFactory(vrp.getJobActivityFactory())
-            .addDelivery(d1).addDelivery(d2).addPickup(s1).addPickup(pickup).addDelivery(s1).build();
+                        .addDelivery(d1).addDelivery(d2).addPickup(s1).addPickup(pickup).addDelivery(s1).build();
 
         stateManager = new StateManager(vrp);
 
         traveledDistanceId = stateManager.createStateId("traveledDistance");
 
         com.graphhopper.jsprit.core.algorithm.state.VehicleDependentTraveledDistance traveledDistance =
-            new com.graphhopper.jsprit.core.algorithm.state.VehicleDependentTraveledDistance(new TransportDistance() {
-                @Override
-                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-                    return new ManhattanCosts().getDistance(from,to,departureTime,vehicle);
-                }
-        },stateManager,traveledDistanceId,Arrays.asList(vehicle,vehicle2));
+                        new com.graphhopper.jsprit.core.algorithm.state.VehicleDependentTraveledDistance(new TransportDistance() {
+                            @Override
+                            public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                                                return new DefaultCosts(ManhattanDistanceCalculator
+                                                                .getInstance()).getDistance(from,
+                                                                                to, departureTime,
+                                                                                vehicle);
+                            }
+                        },stateManager,traveledDistanceId,Arrays.asList(vehicle,vehicle2));
 
         stateManager.addStateUpdater(traveledDistance);
         stateManager.informInsertionStarts(Arrays.asList(route), Collections.<Job>emptyList());
@@ -119,12 +124,12 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
     @Test
     public void insertNewInVehicleShouldFail(){
         MaxDistanceConstraint maxDistanceConstraint =
-            new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
-                @Override
-                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
-                }
-            },maxDistanceMap);
+                        new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
+                            @Override
+                            public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                                return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                            }
+                        },maxDistanceMap);
         JobInsertionContext context = new JobInsertionContext(route,newDelivery,vehicle,null,0);
         Assert.assertTrue(maxDistanceConstraint.fulfilled(context,route.getStart(),newAct(),act(0),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
         Assert.assertTrue(maxDistanceConstraint.fulfilled(context,act(0),newAct(),act(1),0).equals(HardActivityConstraint.ConstraintsStatus.NOT_FULFILLED));
@@ -139,12 +144,12 @@ public double getDistance(Location from, Location to, double departureTime, Vehi
     public void insertNewInVehicle2ShouldBeCorrect(){
         //current distance vehicle2: 160 allowed: 200
         MaxDistanceConstraint maxDistanceConstraint =
-            new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
-                @Override
-                public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
-                    return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
-                }
-            },maxDistanceMap);
+                        new MaxDistanceConstraint(stateManager, traveledDistanceId, new TransportDistance() {
+                            @Override
+                            public double getDistance(Location from, Location to, double departureTime, Vehicle vehicle) {
+                                return vrp.getTransportCosts().getTransportTime(from,to,departureTime, null, vehicle);
+                            }
+                        },maxDistanceMap);
         JobInsertionContext context = new JobInsertionContext(route,newDelivery,vehicle2,null,0);
         Assert.assertTrue(maxDistanceConstraint.fulfilled(context,route.getStart(),newAct(),act(0),0).equals(HardActivityConstraint.ConstraintsStatus.FULFILLED));
         //additional distance: 20+35-15=40
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/TestVehicleRoute.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/TestVehicleRoute.java
index e81da743f..9fef1cb48 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/TestVehicleRoute.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/TestVehicleRoute.java
@@ -31,7 +31,7 @@
 import com.graphhopper.jsprit.core.problem.job.Delivery;
 import com.graphhopper.jsprit.core.problem.job.Pickup;
 import com.graphhopper.jsprit.core.problem.job.Service;
-import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliverServiceDEPRECATED;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.DeliveryActivityNEW;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.PickupServiceDEPRECATED;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.ServiceActivityNEW;
@@ -335,7 +335,7 @@ public void whenAddingDelivery_itShouldBeTreatedAsDelivery() {
 
         TourActivity act = route.getActivities().get(0);
         assertEquals("delivery.delivery", act.getName());
-        assertTrue(act instanceof DeliverServiceDEPRECATED);
+        assertTrue(act instanceof DeliveryActivityNEW);
         assertTrue(((JobActivity) act).getJob() instanceof Delivery);
 
     }
@@ -349,7 +349,7 @@ public void whenAddingDelivery_itShouldBeAdded() {
 
         TourActivity act = route.getActivities().get(0);
         assertEquals("delivery.delivery", act.getName());
-        assertTrue(act instanceof DeliverServiceDEPRECATED);
+        assertTrue(act instanceof DeliveryActivityNEW);
         assertTrue(((JobActivity) act).getJob() instanceof Delivery);
 
     }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DefaultTourActivityFactoryTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DefaultTourActivityFactoryTest.java
deleted file mode 100644
index 2a4be92d7..000000000
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/solution/route/activity/DefaultTourActivityFactoryTest.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Licensed to GraphHopper GmbH under one or more contributor
- * license agreements. See the NOTICE file distributed with this work for
- * additional information regarding copyright ownership.
- *
- * GraphHopper GmbH licenses this file to you under the Apache License,
- * Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.jsprit.core.problem.solution.route.activity;
-
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-
-import org.junit.Test;
-
-import com.graphhopper.jsprit.core.problem.Location;
-import com.graphhopper.jsprit.core.problem.job.Delivery;
-import com.graphhopper.jsprit.core.problem.job.Pickup;
-import com.graphhopper.jsprit.core.problem.job.Service;
-
-public class DefaultTourActivityFactoryTest {
-
-    @Test
-    public void whenCreatingActivityWithService_itShouldReturnPickupService() {
-        DefaultTourActivityFactory factory = new DefaultTourActivityFactory();
-        Service service = new Service.Builder("service").setLocation(Location.newInstance("loc")).build();
-        TourActivity act = factory.createActivity(service);
-        assertNotNull(act);
-        assertTrue(act instanceof PickupServiceDEPRECATED);
-    }
-
-    @Test
-    public void whenCreatingActivityWithPickup_itShouldReturnPickupService() {
-        DefaultTourActivityFactory factory = new DefaultTourActivityFactory();
-        Pickup service = new Pickup.Builder("service").setLocation(Location.newInstance("loc")).build();
-        TourActivity act = factory.createActivity(service);
-        assertNotNull(act);
-        assertTrue(act instanceof PickupServiceDEPRECATED);
-    }
-
-    @Test
-    public void whenCreatingActivityWithDelivery_itShouldReturnDeliverService() {
-        DefaultTourActivityFactory factory = new DefaultTourActivityFactory();
-        Delivery service = new Delivery.Builder("service").setLocation(Location.newInstance("loc")).build();
-        TourActivity act = factory.createActivity(service);
-        assertNotNull(act);
-        assertTrue(act instanceof DeliverServiceDEPRECATED);
-    }
-
-}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/CostFactory.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/CostFactory.java
index 86e76fcd9..7ea3891eb 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/CostFactory.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/CostFactory.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper.jsprit.core.util;
 
+import com.graphhopper.jsprit.core.distance.EuclideanDistanceCalculator;
+import com.graphhopper.jsprit.core.distance.ManhattanDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
 
 public class CostFactory {
@@ -37,11 +39,12 @@ public Coordinate getCoord(String id) {
                 //assume: locationId="x,y"
                 String[] splitted = id.split(",");
                 return Coordinate.newInstance(Double.parseDouble(splitted[0]),
-                    Double.parseDouble(splitted[1]));
+                                Double.parseDouble(splitted[1]));
             }
 
         };
-        return new ManhattanCosts(locations);
+        return new DefaultCosts(ManhattanDistanceCalculator.getInstance())
+                        .withCoordinateConverter(locations);
     }
 
     /**
@@ -60,10 +63,11 @@ public Coordinate getCoord(String id) {
                 //assume: locationId="x,y"
                 String[] splitted = id.split(",");
                 return Coordinate.newInstance(Double.parseDouble(splitted[0]),
-                    Double.parseDouble(splitted[1]));
+                                Double.parseDouble(splitted[1]));
             }
 
         };
-        return new CrowFlyCosts(locations);
+        return new DefaultCosts(EuclideanDistanceCalculator.getInstance())
+                        .withCoordinateConverter(locations);
     }
 }
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/GreatCircleDistanceCalculatorTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/GreatCircleDistanceCalculatorTest.java
index 3679713fd..1bd242732 100644
--- a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/GreatCircleDistanceCalculatorTest.java
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/util/GreatCircleDistanceCalculatorTest.java
@@ -18,9 +18,11 @@
 
 package com.graphhopper.jsprit.core.util;
 
+import static org.junit.Assert.assertEquals;
+
 import org.junit.Test;
 
-import junit.framework.Assert;
+import com.graphhopper.jsprit.core.distance.SphericalDistanceCalculator;
 
 /**
  * Created by schroeder on 28.11.14.
@@ -35,28 +37,12 @@ public void test() {
         double lon2 = 12.1333333;
         double lat2 = 54.0833333;
 
-        double greatCircle = GreatCircleDistanceCalculator.calculateDistance(
-            Coordinate.newInstance(lon1, lat1),
-            Coordinate.newInstance(lon2, lat2),
-            DistanceUnit.Kilometer
-        );
-        Assert.assertEquals(600, greatCircle, 30.);
+        double greatCircle = SphericalDistanceCalculator.getInstance().calculateDistance(
+                        Coordinate.newInstance(lon1, lat1),
+                        Coordinate.newInstance(lon2, lat2)
+                        );
+        assertEquals(600, greatCircle, 30.);
     }
 
-    @Test
-    public void testMeter() {
-        double lon1 = 8.3858333;
-        double lat1 = 49.0047222;
-
-        double lon2 = 12.1333333;
-        double lat2 = 54.0833333;
-
-        double greatCircle = GreatCircleDistanceCalculator.calculateDistance(
-            Coordinate.newInstance(lon1, lat1),
-            Coordinate.newInstance(lon2, lat2),
-            DistanceUnit.Meter
-        );
-        Assert.assertEquals(600000, greatCircle, 30000.);
-    }
 
 }
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/AdditionalDistanceConstraintExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/AdditionalDistanceConstraintExample.java
index 1dcbfcda2..ec520bbe4 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/AdditionalDistanceConstraintExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/AdditionalDistanceConstraintExample.java
@@ -19,12 +19,15 @@
 package com.graphhopper.jsprit.examples;
 
 
+import java.util.Collection;
+
 import com.graphhopper.jsprit.analysis.toolbox.Plotter;
 import com.graphhopper.jsprit.core.algorithm.VehicleRoutingAlgorithm;
 import com.graphhopper.jsprit.core.algorithm.box.Jsprit;
 import com.graphhopper.jsprit.core.algorithm.state.StateId;
 import com.graphhopper.jsprit.core.algorithm.state.StateManager;
 import com.graphhopper.jsprit.core.algorithm.state.StateUpdater;
+import com.graphhopper.jsprit.core.distance.EuclideanDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.constraint.ConstraintManager;
 import com.graphhopper.jsprit.core.problem.constraint.HardActivityConstraint;
@@ -35,13 +38,10 @@
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TourActivity;
 import com.graphhopper.jsprit.core.reporting.SolutionPrinter;
 import com.graphhopper.jsprit.core.util.Coordinate;
-import com.graphhopper.jsprit.core.util.EuclideanDistanceCalculator;
 import com.graphhopper.jsprit.core.util.Solutions;
 import com.graphhopper.jsprit.core.util.VehicleRoutingTransportCostsMatrix;
 import com.graphhopper.jsprit.io.problem.VrpXMLReader;
 
-import java.util.Collection;
-
 //import jsprit.core.problem.solution.route.state.StateFactory; //v1.3.1
 
 public class AdditionalDistanceConstraintExample {
@@ -63,7 +63,7 @@
 
         //        public DistanceUpdater(StateFactory.StateId distanceStateId, StateManager stateManager, VehicleRoutingTransportCostsMatrix costMatrix) { //v1.3.1
         public DistanceUpdater(StateId distanceStateId, StateManager stateManager, VehicleRoutingTransportCostsMatrix transportCosts) { //head of development - upcoming release (v1.4)
-            this.costMatrix = transportCosts;
+            costMatrix = transportCosts;
             this.stateManager = stateManager;
             this.distanceStateId = distanceStateId;
         }
@@ -106,7 +106,7 @@ public void finish() {
 
         //        DistanceConstraint(double maxDistance, StateFactory.StateId distanceStateId, StateManager stateManager, VehicleRoutingTransportCostsMatrix costsMatrix) { //v1.3.1
         DistanceConstraint(double maxDistance, StateId distanceStateId, StateManager stateManager, VehicleRoutingTransportCostsMatrix transportCosts) { //head of development - upcoming release (v1.4)
-            this.costsMatrix = transportCosts;
+            costsMatrix = transportCosts;
             this.maxDistance = maxDistance;
             this.stateManager = stateManager;
             this.distanceStateId = distanceStateId;
@@ -116,11 +116,15 @@ public void finish() {
         public ConstraintsStatus fulfilled(JobInsertionContext context, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double v) {
             double additionalDistance = getDistance(prevAct, newAct) + getDistance(newAct, nextAct) - getDistance(prevAct, nextAct);
             Double routeDistance = stateManager.getRouteState(context.getRoute(), distanceStateId, Double.class);
-            if (routeDistance == null) routeDistance = 0.;
+            if (routeDistance == null) {
+                routeDistance = 0.;
+            }
             double newRouteDistance = routeDistance + additionalDistance;
             if (newRouteDistance > maxDistance) {
                 return ConstraintsStatus.NOT_FULFILLED;
-            } else return ConstraintsStatus.FULFILLED;
+            } else {
+                return ConstraintsStatus.FULFILLED;
+            }
         }
 
         double getDistance(TourActivity from, TourActivity to) {
@@ -148,8 +152,8 @@ public static void main(String[] args) {
         ConstraintManager constraintManager = new ConstraintManager(vrp, stateManager);
         constraintManager.addConstraint(new DistanceConstraint(120., distanceStateId, stateManager, costMatrix), ConstraintManager.Priority.CRITICAL);
 
-        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager,constraintManager)
-            .buildAlgorithm();
+        VehicleRoutingAlgorithm vra = Jsprit.Builder.newInstance(vrp).setStateAndConstraintManager(stateManager, constraintManager)
+                .buildAlgorithm();
 //        vra.setMaxIterations(250); //v1.3.1
         vra.setMaxIterations(250); //head of development - upcoming release (v1.4)
 
@@ -166,7 +170,7 @@ private static VehicleRoutingTransportCostsMatrix createMatrix(VehicleRoutingPro
             for (String to : vrpBuilder.getLocationMap().keySet()) {
                 Coordinate fromCoord = vrpBuilder.getLocationMap().get(from);
                 Coordinate toCoord = vrpBuilder.getLocationMap().get(to);
-                double distance = EuclideanDistanceCalculator.calculateDistance(fromCoord, toCoord);
+                double distance = EuclideanDistanceCalculator.getInstance().calculateDistance(fromCoord, toCoord);
                 matrixBuilder.addTransportDistance(from, to, distance);
                 matrixBuilder.addTransportTime(from, to, (distance / 2.));
             }
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BicycleMessenger.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BicycleMessenger.java
index af7320370..1cbd09065 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BicycleMessenger.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BicycleMessenger.java
@@ -17,6 +17,14 @@
  */
 package com.graphhopper.jsprit.examples;
 
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
 import com.graphhopper.jsprit.analysis.toolbox.AlgorithmSearchProgressChartListener;
 import com.graphhopper.jsprit.analysis.toolbox.GraphStreamViewer;
 import com.graphhopper.jsprit.analysis.toolbox.GraphStreamViewer.Label;
@@ -26,6 +34,7 @@
 import com.graphhopper.jsprit.core.algorithm.state.StateId;
 import com.graphhopper.jsprit.core.algorithm.state.StateManager;
 import com.graphhopper.jsprit.core.algorithm.state.StateUpdater;
+import com.graphhopper.jsprit.core.distance.EuclideanDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem.Builder;
@@ -50,40 +59,34 @@
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
 import com.graphhopper.jsprit.core.reporting.SolutionPrinter;
 import com.graphhopper.jsprit.core.util.Coordinate;
-import com.graphhopper.jsprit.core.util.CrowFlyCosts;
+import com.graphhopper.jsprit.core.util.DefaultCosts;
 import com.graphhopper.jsprit.core.util.Solutions;
 import com.graphhopper.jsprit.util.Examples;
 
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileReader;
-import java.io.IOException;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-
 
 /**
  * This class provides the/a solution to the following problem:
  * <p>
- * Statement of the problem (see Stackoverflow: http://stackoverflow.com/questions/19080537/bicycle-messenger-tsppd-with-optaplanner/20412598#20412598):
+ * Statement of the problem (see Stackoverflow:
+ * http://stackoverflow.com/questions/19080537/bicycle-messenger-tsppd-with-optaplanner/20412598#20412598):
  * <p>
- * Optimize the routes for a bicycle messenger service!
- * Assume 5 messengers that have to pick up 30 envelopes distributed through the city. These 5 messengers are distributed through the city as well. Thus
- * there is no single depot and they do not need to go back to their original starting location.
+ * Optimize the routes for a bicycle messenger service! Assume 5 messengers that have to pick up 30 envelopes
+ * distributed through the city. These 5 messengers are distributed through the city as well. Thus there is no single
+ * depot and they do not need to go back to their original starting location.
  * <p>
- * Additional hard constraints:
- * 1) Every messenger can carry up to fifteen envelopes
- * 2) The way an evelopes travels should be less than three times the direct route (so delivery does not take too long)
+ * Additional hard constraints: 1) Every messenger can carry up to fifteen envelopes 2) The way an evelopes travels
+ * should be less than three times the direct route (so delivery does not take too long)
  * <p>
- * Thus this problem is basically a Capacitated VRP with Pickups and Deliveries, Multiple Depots, Open Routes and Time Windows/Restrictions.
+ * Thus this problem is basically a Capacitated VRP with Pickups and Deliveries, Multiple Depots, Open Routes and Time
+ * Windows/Restrictions.
  *
  * @author stefan schroeder
  */
 public class BicycleMessenger {
 
     /**
-     * Hard constraint: delivery of envelope must not take longer than 3*bestDirect (i.e. fastest messenger on direct delivery)
+     * Hard constraint: delivery of envelope must not take longer than 3*bestDirect (i.e. fastest messenger on direct
+     * delivery)
      *
      * @author stefan
      */
@@ -98,26 +101,30 @@
 
         private final StateId latest_act_arrival_time_stateId;
 
-        public ThreeTimesLessThanBestDirectRouteConstraint(StateId latest_act_arrival_time, Map<String, Double> nearestMessengers, VehicleRoutingTransportCosts routingCosts, RouteAndActivityStateGetter stateManager) {
-            this.bestMessengers = nearestMessengers;
+        public ThreeTimesLessThanBestDirectRouteConstraint(StateId latest_act_arrival_time, Map<String, Double> nearestMessengers,
+                VehicleRoutingTransportCosts routingCosts, RouteAndActivityStateGetter stateManager) {
+            bestMessengers = nearestMessengers;
             this.routingCosts = routingCosts;
             this.stateManager = stateManager;
-            this.latest_act_arrival_time_stateId = latest_act_arrival_time;
+            latest_act_arrival_time_stateId = latest_act_arrival_time;
         }
 
         @Override
         public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prevAct, TourActivity newAct, TourActivity nextAct, double prevActDepTime) {
             //make sure vehicle can manage direct path
-            double arrTime_at_nextAct_onDirectRoute = prevActDepTime + routingCosts.getTransportTime(prevAct.getLocation(), nextAct.getLocation(), prevActDepTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
+            double arrTime_at_nextAct_onDirectRoute = prevActDepTime + routingCosts.getTransportTime(prevAct.getLocation(), nextAct.getLocation(),
+                    prevActDepTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
             Double latest_arrTime_at_nextAct = stateManager.getActivityState(nextAct, latest_act_arrival_time_stateId, Double.class);
-            if (latest_arrTime_at_nextAct == null)
+            if (latest_arrTime_at_nextAct == null) {
                 latest_arrTime_at_nextAct = nextAct.getTheoreticalLatestOperationStartTime();
+            }
             if (arrTime_at_nextAct_onDirectRoute > latest_arrTime_at_nextAct) {
                 //constraint can never be fulfilled anymore, thus .NOT_FULFILLED_BREAK
                 return ConstraintsStatus.NOT_FULFILLED_BREAK;
             }
 
-            double arrTime_at_newAct = prevActDepTime + routingCosts.getTransportTime(prevAct.getLocation(), newAct.getLocation(), prevActDepTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
+            double arrTime_at_newAct = prevActDepTime
+                    + routingCosts.getTransportTime(prevAct.getLocation(), newAct.getLocation(), prevActDepTime, iFacts.getNewDriver(), iFacts.getNewVehicle());
             //local impact
             //no matter whether it is a pickupShipment or deliverShipment activities. both arrivalTimes must be < 3*best.
             double directTimeOfNearestMessenger = bestMessengers.get(((JobActivity) newAct).getJob().getId());
@@ -128,12 +135,14 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
 
             //impact on whole route, since insertion of newAct shifts all subsequent activities forward in time
             double departureTime_at_newAct = arrTime_at_newAct + newAct.getOperationTime();
-            double latest_arrTime_at_newAct = latest_arrTime_at_nextAct - routingCosts.getTransportTime(newAct.getLocation(), nextAct.getLocation(), departureTime_at_newAct, iFacts.getNewDriver(), iFacts.getNewVehicle());
+            double latest_arrTime_at_newAct = latest_arrTime_at_nextAct - routingCosts.getTransportTime(newAct.getLocation(), nextAct.getLocation(),
+                    departureTime_at_newAct, iFacts.getNewDriver(), iFacts.getNewVehicle());
             if (arrTime_at_newAct > latest_arrTime_at_newAct) {
                 return ConstraintsStatus.NOT_FULFILLED;
             }
 
-            double arrTime_at_nextAct = departureTime_at_newAct + routingCosts.getTransportTime(newAct.getLocation(), nextAct.getLocation(), departureTime_at_newAct, iFacts.getNewDriver(), iFacts.getNewVehicle());
+            double arrTime_at_nextAct = departureTime_at_newAct + routingCosts.getTransportTime(newAct.getLocation(), nextAct.getLocation(),
+                    departureTime_at_newAct, iFacts.getNewDriver(), iFacts.getNewVehicle());
             //here you need an activity state
             if (arrTime_at_nextAct > latest_arrTime_at_nextAct) {
                 return ConstraintsStatus.NOT_FULFILLED;
@@ -144,9 +153,12 @@ public ConstraintsStatus fulfilled(JobInsertionContext iFacts, TourActivity prev
     }
 
     /**
-     * When inserting the activities of an envelope which are pickup and deliver envelope, this constraint makes insertion procedure to ignore messengers that are too far away to meet the 3*directTime-Constraint.
+     * When inserting the activities of an envelope which are pickup and deliver envelope, this constraint makes
+     * insertion procedure to ignore messengers that are too far away to meet the 3*directTime-Constraint.
      * <p>
-     * <p>one does not need this constraint. but it is faster. the earlier the solution-space can be constraint the better/faster.
+     * <p>
+     * one does not need this constraint. but it is faster. the earlier the solution-space can be constraint the
+     * better/faster.
      *
      * @author schroeder
      */
@@ -172,10 +184,13 @@ public boolean fulfilled(JobInsertionContext insertionContext) {
     }
 
     /**
-     * updates the state "latest-activity-start-time" (required above) once route/activity states changed, i.e. when removing or inserting an envelope-activity
+     * updates the state "latest-activity-start-time" (required above) once route/activity states changed, i.e. when
+     * removing or inserting an envelope-activity
+     * <p>
      * <p>
-     * <p>thus once either the insertion-procedure starts or an envelope has been inserted, this visitor runs through the route in reverse order (i.e. starting with the end of the route) and
-     * calculates the latest-activity-start-time (or latest-activity-arrival-time) which is the time to just meet the constraints of subsequent activities.
+     * thus once either the insertion-procedure starts or an envelope has been inserted, this visitor runs through the
+     * route in reverse order (i.e. starting with the end of the route) and calculates the latest-activity-start-time
+     * (or latest-activity-arrival-time) which is the time to just meet the constraints of subsequent activities.
      *
      * @author schroeder
      */
@@ -195,12 +210,13 @@ public boolean fulfilled(JobInsertionContext insertionContext) {
 
         private final StateId latest_act_arrival_time_stateId;
 
-        public UpdateLatestActivityStartTimes(StateId latest_act_arrival_time, StateManager stateManager, VehicleRoutingTransportCosts routingCosts, Map<String, Double> bestMessengers) {
+        public UpdateLatestActivityStartTimes(StateId latest_act_arrival_time, StateManager stateManager, VehicleRoutingTransportCosts routingCosts,
+                Map<String, Double> bestMessengers) {
             super();
             this.stateManager = stateManager;
             this.routingCosts = routingCosts;
             this.bestMessengers = bestMessengers;
-            this.latest_act_arrival_time_stateId = latest_act_arrival_time;
+            latest_act_arrival_time_stateId = latest_act_arrival_time;
         }
 
         @Override
@@ -213,11 +229,12 @@ public void begin(VehicleRoute route) {
         @Override
         public void visit(TourActivity currAct) {
             double timeOfNearestMessenger = bestMessengers.get(((JobActivity) currAct).getJob().getId());
-            double potential_latest_arrTime_at_currAct =
-                latest_arrTime_at_prevAct - routingCosts.getBackwardTransportTime(currAct.getLocation(), prevAct.getLocation(), latest_arrTime_at_prevAct, route.getDriver(), route.getVehicle()) - currAct.getOperationTime();
+            double potential_latest_arrTime_at_currAct = latest_arrTime_at_prevAct - routingCosts.getBackwardTransportTime(currAct.getLocation(),
+                    prevAct.getLocation(), latest_arrTime_at_prevAct, route.getDriver(), route.getVehicle()) - currAct.getOperationTime();
             double latest_arrTime_at_currAct = Math.min(3 * timeOfNearestMessenger, potential_latest_arrTime_at_currAct);
             stateManager.putActivityState(currAct, latest_act_arrival_time_stateId, latest_arrTime_at_currAct);
-            assert currAct.getArrTime() <= latest_arrTime_at_currAct : "this must not be since it breaks condition; actArrTime: " + currAct.getArrTime() + " latestArrTime: " + latest_arrTime_at_currAct + " vehicle: " + route.getVehicle().getId();
+            assert currAct.getArrTime() <= latest_arrTime_at_currAct : "this must not be since it breaks condition; actArrTime: " + currAct.getArrTime()
+                    + " latestArrTime: " + latest_arrTime_at_currAct + " vehicle: " + route.getVehicle().getId();
             latest_arrTime_at_prevAct = latest_arrTime_at_currAct;
             prevAct = currAct;
         }
@@ -234,22 +251,23 @@ public void finish() {
     public static void main(String[] args) throws IOException {
         Examples.createOutputFolder();
 
-		/*
-        build the problem
-		 */
+        /*
+         * build the problem
+         */
         VehicleRoutingProblem.Builder problemBuilder = VehicleRoutingProblem.Builder.newInstance();
         problemBuilder.setFleetSize(FleetSize.FINITE);
         readEnvelopes(problemBuilder);
         readMessengers(problemBuilder);
         //add constraints to problem
-        VehicleRoutingTransportCosts routingCosts = new CrowFlyCosts(problemBuilder.getLocations()); //which is the default VehicleRoutingTransportCosts in builder above
+        VehicleRoutingTransportCosts routingCosts = new DefaultCosts(EuclideanDistanceCalculator.getInstance())
+                .withCoordinateConverter(problemBuilder.getLocations()); //which is the default VehicleRoutingTransportCosts in builder above
         problemBuilder.setRoutingCost(routingCosts);
         //finally build the problem
 //        problemBuilder.addPenaltyVehicles(20.0,50000);
         VehicleRoutingProblem bicycleMessengerProblem = problemBuilder.build();
 
         /*
-        define states and constraints
+         * define states and constraints
          */
         //map mapping nearest messengers, i.e. for each envelope the direct-delivery-time with the fastest messenger is stored here
         Map<String, Double> nearestMessengers = getNearestMessengers(routingCosts, problemBuilder.getAddedJobs(), problemBuilder.getAddedVehicles());
@@ -264,11 +282,13 @@ public static void main(String[] args) throws IOException {
 
         ConstraintManager constraintManager = new ConstraintManager(bicycleMessengerProblem, stateManager);
         constraintManager.addLoadConstraint();
-        constraintManager.addConstraint(new ThreeTimesLessThanBestDirectRouteConstraint(latest_act_arrival_time_stateId, nearestMessengers, routingCosts, stateManager), ConstraintManager.Priority.CRITICAL);
+        constraintManager.addConstraint(
+                new ThreeTimesLessThanBestDirectRouteConstraint(latest_act_arrival_time_stateId, nearestMessengers, routingCosts, stateManager),
+                ConstraintManager.Priority.CRITICAL);
         constraintManager.addConstraint(new IgnoreMessengerThatCanNeverMeetTimeRequirements(nearestMessengers, routingCosts));
 
         VehicleRoutingAlgorithm algorithm = Jsprit.Builder.newInstance(bicycleMessengerProblem)
-            .setStateAndConstraintManager(stateManager,constraintManager).buildAlgorithm();
+                .setStateAndConstraintManager(stateManager, constraintManager).buildAlgorithm();
 
         algorithm.setMaxIterations(2000);
 
@@ -318,17 +338,20 @@ public static void main(String[] args) throws IOException {
 
         new GraphStreamViewer(bicycleMessengerProblem).labelWith(Label.ID).setRenderShipments(true).setRenderDelay(150).display();
 //
-        new GraphStreamViewer(bicycleMessengerProblem, Solutions.bestOf(solutions)).setGraphStreamFrameScalingFactor(1.5).setCameraView(12500, 55000, 0.25).labelWith(Label.ACTIVITY).setRenderShipments(true).setRenderDelay(150).display();
+        new GraphStreamViewer(bicycleMessengerProblem, Solutions.bestOf(solutions)).setGraphStreamFrameScalingFactor(1.5).setCameraView(12500, 55000, 0.25)
+                .labelWith(Label.ACTIVITY).setRenderShipments(true).setRenderDelay(150).display();
 
     }
 
     //if you wanne run this enable assertion by putting an '-ea' in your vmargument list - Run As --> Run Configurations --> (x)=Arguments --> VM arguments: -ea
-    private static void validateSolution(VehicleRoutingProblemSolution bestOf, VehicleRoutingProblem bicycleMessengerProblem, Map<String, Double> nearestMessengers) {
+    private static void validateSolution(VehicleRoutingProblemSolution bestOf, VehicleRoutingProblem bicycleMessengerProblem,
+            Map<String, Double> nearestMessengers) {
         for (VehicleRoute route : bestOf.getRoutes()) {
             for (TourActivity act : route.getActivities()) {
                 if (act.getArrTime() > 3 * nearestMessengers.get(((JobActivity) act).getJob().getId())) {
                     SolutionPrinter.print(bicycleMessengerProblem, bestOf, SolutionPrinter.Print.VERBOSE);
-                    throw new IllegalStateException("three times less than ... constraint broken. this must not be. act.getArrTime(): " + act.getArrTime() + " allowed: " + 3 * nearestMessengers.get(((JobActivity) act).getJob().getId()));
+                    throw new IllegalStateException("three times less than ... constraint broken. this must not be. act.getArrTime(): " + act.getArrTime()
+                            + " allowed: " + 3 * nearestMessengers.get(((JobActivity) act).getJob().getId()));
                 }
             }
         }
@@ -352,7 +375,7 @@ private static void validateSolution(VehicleRoutingProblemSolution bestOf, Vehic
     static double getTimeOfDirectRoute(Job job, Vehicle v, VehicleRoutingTransportCosts routingCosts) {
         Shipment envelope = (Shipment) job;
         return routingCosts.getTransportTime(v.getStartLocation(), envelope.getPickupLocation(), 0.0, DriverImpl.noDriver(), v) +
-            routingCosts.getTransportTime(envelope.getPickupLocation(), envelope.getDeliveryLocation(), 0.0, DriverImpl.noDriver(), v);
+                routingCosts.getTransportTime(envelope.getPickupLocation(), envelope.getDeliveryLocation(), 0.0, DriverImpl.noDriver(), v);
     }
 
     private static void readEnvelopes(Builder problemBuilder) throws IOException {
@@ -367,8 +390,11 @@ private static void readEnvelopes(Builder problemBuilder) throws IOException {
             String[] tokens = line.split("\\s+");
             //define your envelope which is basically a shipment from A to B
             Shipment envelope = Shipment.Builder.newInstance(tokens[1]).addSizeDimension(0, 1)
-                .setPickupLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(Double.parseDouble(tokens[2]), Double.parseDouble(tokens[3]))).build())
-                .setDeliveryLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(Double.parseDouble(tokens[4]), Double.parseDouble(tokens[5]))).build()).build();
+                    .setPickupLocation(Location.Builder.newInstance()
+                            .setCoordinate(Coordinate.newInstance(Double.parseDouble(tokens[2]), Double.parseDouble(tokens[3]))).build())
+                    .setDeliveryLocation(Location.Builder.newInstance()
+                            .setCoordinate(Coordinate.newInstance(Double.parseDouble(tokens[4]), Double.parseDouble(tokens[5]))).build())
+                    .build();
             problemBuilder.addJob(envelope);
         }
         reader.close();
@@ -380,11 +406,13 @@ private static void readMessengers(Builder problemBuilder) throws IOException {
         boolean firstLine = true;
         VehicleType messengerType = VehicleTypeImpl.Builder.newInstance("messengerType").addCapacityDimension(0, 15).setCostPerDistance(1).build();
         /*
-         * the algo requires some time and space to search for a valid solution. if you ommit a penalty-type, it probably throws an Exception once it cannot insert an envelope anymore
-		 * thus, give it space by defining a penalty/shadow vehicle with higher variable and fixed costs to up the pressure to find solutions without penalty type
-		 *
-		 * it is important to give it the same typeId as the type you want to shadow
-		 */
+         * the algo requires some time and space to search for a valid solution. if you ommit a penalty-type, it
+         * probably throws an Exception once it cannot insert an envelope anymore thus, give it space by defining a
+         * penalty/shadow vehicle with higher variable and fixed costs to up the pressure to find solutions without
+         * penalty type
+         *
+         * it is important to give it the same typeId as the type you want to shadow
+         */
         while ((line = reader.readLine()) != null) {
             if (firstLine) {
                 firstLine = false;
@@ -393,8 +421,9 @@ private static void readMessengers(Builder problemBuilder) throws IOException {
             String[] tokens = line.split("\\s+");
             //build your vehicle
             VehicleImpl vehicle = VehicleImpl.Builder.newInstance(tokens[1])
-                .setStartLocation(Location.Builder.newInstance().setCoordinate(Coordinate.newInstance(Double.parseDouble(tokens[2]), Double.parseDouble(tokens[3]))).build())
-                .setReturnToDepot(false).setType(messengerType).build();
+                    .setStartLocation(Location.Builder.newInstance()
+                            .setCoordinate(Coordinate.newInstance(Double.parseDouble(tokens[2]), Double.parseDouble(tokens[3]))).build())
+                    .setReturnToDepot(false).setType(messengerType).build();
             problemBuilder.addVehicle(vehicle);
         }
         reader.close();
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BuildAlgorithmFromScratch.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BuildAlgorithmFromScratch.java
index df30c0ee7..f1974188a 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BuildAlgorithmFromScratch.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/BuildAlgorithmFromScratch.java
@@ -31,7 +31,7 @@
 import com.graphhopper.jsprit.core.algorithm.ruin.RadialRuinStrategyFactory;
 import com.graphhopper.jsprit.core.algorithm.ruin.RandomRuinStrategyFactory;
 import com.graphhopper.jsprit.core.algorithm.ruin.RuinStrategy;
-import com.graphhopper.jsprit.core.algorithm.ruin.distance.AvgServiceAndShipmentDistance;
+import com.graphhopper.jsprit.core.algorithm.ruin.distance.DefaultJobDistance;
 import com.graphhopper.jsprit.core.algorithm.selector.SelectBest;
 import com.graphhopper.jsprit.core.algorithm.state.StateManager;
 import com.graphhopper.jsprit.core.analysis.SolutionAnalyser;
@@ -156,7 +156,7 @@ public static VehicleRoutingAlgorithm createAlgorithm(final VehicleRoutingProble
          * ruin strategies
 		 */
         RuinStrategy randomRuin = new RandomRuinStrategyFactory(0.5).createStrategy(vrp);
-        RuinStrategy radialRuin = new RadialRuinStrategyFactory(0.3, new AvgServiceAndShipmentDistance(vrp.getTransportCosts())).createStrategy(vrp);
+        RuinStrategy radialRuin = new RadialRuinStrategyFactory(0.3, new DefaultJobDistance(vrp.getTransportCosts())).createStrategy(vrp);
 
 		/*
          * objective function
diff --git a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleTimeWindowExample.java b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleTimeWindowExample.java
index 765bc15a2..e9429b735 100644
--- a/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleTimeWindowExample.java
+++ b/jsprit-examples/src/main/java/com/graphhopper/jsprit/examples/MultipleTimeWindowExample.java
@@ -17,8 +17,11 @@
  */
 package com.graphhopper.jsprit.examples;
 
+import java.util.Collection;
+
 import com.graphhopper.jsprit.core.algorithm.VehicleRoutingAlgorithm;
 import com.graphhopper.jsprit.core.algorithm.box.Jsprit;
+import com.graphhopper.jsprit.core.distance.ManhattanDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.VehicleRoutingProblem;
 import com.graphhopper.jsprit.core.problem.job.Service;
@@ -28,97 +31,95 @@
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleType;
 import com.graphhopper.jsprit.core.problem.vehicle.VehicleTypeImpl;
 import com.graphhopper.jsprit.core.reporting.SolutionPrinter;
-import com.graphhopper.jsprit.core.util.ManhattanCosts;
+import com.graphhopper.jsprit.core.util.DefaultCosts;
 import com.graphhopper.jsprit.core.util.Solutions;
 
-import java.util.Collection;
-
 
 public class MultipleTimeWindowExample {
 
 
     public static void main(String[] args) {
 
-		/*
-         * get a vehicle type-builder and build a type with the typeId "vehicleType" and one capacity dimension, i.e. weight, and capacity dimension value of 2
-		 */
+        /*
+         * get a vehicle type-builder and build a type with the typeId "vehicleType" and one capacity dimension, i.e.
+         * weight, and capacity dimension value of 2
+         */
         final int WEIGHT_INDEX = 0;
         VehicleTypeImpl.Builder vehicleTypeBuilder = VehicleTypeImpl.Builder.newInstance("vehicleType")
-            .addCapacityDimension(WEIGHT_INDEX, 10).setCostPerWaitingTime(1.);
+                .addCapacityDimension(WEIGHT_INDEX, 10).setCostPerWaitingTime(1.);
         VehicleType vehicleType = vehicleTypeBuilder.build();
 
-		/*
+        /*
          * get a vehicle-builder and build a vehicle located at (10,10) with type "vehicleType"
-		 */
+         */
         Builder vehicleBuilder = Builder.newInstance("vehicle");
         vehicleBuilder.setStartLocation(Location.newInstance(0, 0));
         vehicleBuilder.setType(vehicleType);
         VehicleImpl vehicle = vehicleBuilder.build();
 
-		/*
+        /*
          * build services at the required locations, each with a capacity-demand of 1.
-		 */
+         */
         Service service1 = new Service.Builder("1")
-            .addTimeWindow(50,100)
-            .addTimeWindow(20,35)
-            .addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(10, 0)).build();
+                .addTimeWindow(50, 100)
+                .addTimeWindow(20, 35)
+                .addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(10, 0)).build();
 
         Service service2 = new Service.Builder("2")
-            .addSizeDimension(WEIGHT_INDEX, 1)
+                .addSizeDimension(WEIGHT_INDEX, 1)
 //            .setServiceTime(10)
-            .setLocation(Location.newInstance(20, 0)).setServiceTime(10).build();
+                .setLocation(Location.newInstance(20, 0)).setServiceTime(10).build();
 
         Service service3 = new Service.Builder("3")
-            .addTimeWindow(5, 10)
-            .addTimeWindow(35, 50)
-            .addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(30, 0)).build();
+                .addTimeWindow(5, 10)
+                .addTimeWindow(35, 50)
+                .addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(30, 0)).build();
 
         Service service4 = new Service.Builder("4")
 //            .addTimeWindow(5,10)
-            .addTimeWindow(20, 40)
-            .addTimeWindow(45, 80)
-            .addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(40, 0)).build();
+                .addTimeWindow(20, 40)
+                .addTimeWindow(45, 80)
+                .addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(40, 0)).build();
 
         Service service5 = new Service.Builder("5")
-            .addTimeWindow(5,10)
-            .addTimeWindow(20, 40)
-            .addTimeWindow(60,100)
-            .addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(20, 0)).build();
+                .addTimeWindow(5, 10)
+                .addTimeWindow(20, 40)
+                .addTimeWindow(60, 100)
+                .addSizeDimension(WEIGHT_INDEX, 1).setLocation(Location.newInstance(20, 0)).build();
 
 
         VehicleRoutingProblem.Builder vrpBuilder = VehicleRoutingProblem.Builder.newInstance();
         vrpBuilder.addVehicle(vehicle);
         vrpBuilder.addJob(service1).addJob(service2)
-            .addJob(service3)
-            .addJob(service4)
-            .addJob(service5)
-        ;
+                .addJob(service3)
+                .addJob(service4)
+                .addJob(service5);
         vrpBuilder.setFleetSize(VehicleRoutingProblem.FleetSize.FINITE);
-        vrpBuilder.setRoutingCost(new ManhattanCosts());
+        vrpBuilder.setRoutingCost(new DefaultCosts(ManhattanDistanceCalculator.getInstance()));
         VehicleRoutingProblem problem = vrpBuilder.build();
 
-		/*
+        /*
          * get the algorithm out-of-the-box.
-		 */
+         */
         VehicleRoutingAlgorithm algorithm = Jsprit.createAlgorithm(problem);
 
-		/*
+        /*
          * and search a solution
-		 */
+         */
         Collection<VehicleRoutingProblemSolution> solutions = algorithm.searchSolutions();
 
-		/*
+        /*
          * get the best
-		 */
+         */
         VehicleRoutingProblemSolution bestSolution = Solutions.bestOf(solutions);
 
 //        new VrpXMLWriter(problem, solutions).write("output/problem-with-solution.xml");
 
         SolutionPrinter.print(problem, bestSolution, SolutionPrinter.Print.VERBOSE);
 
-		/*
+        /*
          * plot
-		 */
+         */
 //        new Plotter(problem,bestSolution).setLabel(Plotter.Label.ID).plot("output/plot", "mtw");
 
 //        new GraphStreamViewer(problem, bestSolution).labelWith(Label.ID).setRenderDelay(200).display();
diff --git a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/Figliozzi.java b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/Figliozzi.java
index 12dcbc399..2adce86e2 100644
--- a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/Figliozzi.java
+++ b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/Figliozzi.java
@@ -17,18 +17,18 @@
  */
 package com.graphhopper.jsprit.instance.reader;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import com.graphhopper.jsprit.core.distance.EuclideanDistanceCalculator;
 import com.graphhopper.jsprit.core.problem.Location;
 import com.graphhopper.jsprit.core.problem.cost.VehicleRoutingTransportCosts;
 import com.graphhopper.jsprit.core.problem.driver.Driver;
 import com.graphhopper.jsprit.core.problem.vehicle.Vehicle;
-import com.graphhopper.jsprit.core.util.EuclideanDistanceCalculator;
 import com.graphhopper.jsprit.core.util.Locations;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
 
 public class Figliozzi {
 
@@ -50,59 +50,59 @@ public static TDCosts createCosts(Locations locations, SpeedDistribution speedDi
         static List<Double> createSpeedValues(SpeedDistribution speedDistribution) {
             List<Double> speedValues = Collections.emptyList();
             switch (speedDistribution) {
-                case TD1a:
-                    speedValues = Arrays.asList(1., 1.6, 1.05, 1.6, 1.);
-                    break;
-                case TD2a:
-                    speedValues = Arrays.asList(1., 2., 1.5, 2., 1.);
-                    break;
-                case TD3a:
-                    speedValues = Arrays.asList(1., 2.5, 1.75, 2.5, 1.);
-                    break;
-
-                case TD1b:
-                    speedValues = Arrays.asList(1.6, 1., 1.05, 1., 1.6);
-                    break;
-                case TD2b:
-                    speedValues = Arrays.asList(2., 1., 1.5, 1., 2.);
-                    break;
-                case TD3b:
-                    speedValues = Arrays.asList(2.5, 1., 1.75, 1., 2.5);
-                    break;
-
-                case TD1c:
-                    speedValues = Arrays.asList(1.6, 1.6, 1.05, 1., 1.);
-                    break;
-                case TD2c:
-                    speedValues = Arrays.asList(2., 2., 1.5, 1., 1.);
-                    break;
-                case TD3c:
-                    speedValues = Arrays.asList(2.5, 2.5, 1.75, 1., 1.);
-                    break;
-
-                case TD1d:
-                    speedValues = Arrays.asList(1., 1., 1.05, 1.6, 1.6);
-                    break;
-                case TD2d:
-                    speedValues = Arrays.asList(1., 1., 1.5, 2., 2.);
-                    break;
-                case TD3d:
-                    speedValues = Arrays.asList(1., 1., 1.75, 2.5, 2.5);
-                    break;
-
-                case TD4:
-                    speedValues = Arrays.asList(1.1, 0.85, 1.1, 0.85, 1.1);
-                    break;
-                case TD5:
-                    speedValues = Arrays.asList(1.2, 0.8, 1., 0.8, 1.2);
-                    break;
-                case TD6:
-                    speedValues = Arrays.asList(1.2, 0.7, 1.2, 0.7, 1.2);
-                    break;
-
-                case CLASSIC:
-                    speedValues = Arrays.asList(1., 1., 1., 1., 1.);
-                    break;
+            case TD1a:
+                speedValues = Arrays.asList(1., 1.6, 1.05, 1.6, 1.);
+                break;
+            case TD2a:
+                speedValues = Arrays.asList(1., 2., 1.5, 2., 1.);
+                break;
+            case TD3a:
+                speedValues = Arrays.asList(1., 2.5, 1.75, 2.5, 1.);
+                break;
+
+            case TD1b:
+                speedValues = Arrays.asList(1.6, 1., 1.05, 1., 1.6);
+                break;
+            case TD2b:
+                speedValues = Arrays.asList(2., 1., 1.5, 1., 2.);
+                break;
+            case TD3b:
+                speedValues = Arrays.asList(2.5, 1., 1.75, 1., 2.5);
+                break;
+
+            case TD1c:
+                speedValues = Arrays.asList(1.6, 1.6, 1.05, 1., 1.);
+                break;
+            case TD2c:
+                speedValues = Arrays.asList(2., 2., 1.5, 1., 1.);
+                break;
+            case TD3c:
+                speedValues = Arrays.asList(2.5, 2.5, 1.75, 1., 1.);
+                break;
+
+            case TD1d:
+                speedValues = Arrays.asList(1., 1., 1.05, 1.6, 1.6);
+                break;
+            case TD2d:
+                speedValues = Arrays.asList(1., 1., 1.5, 2., 2.);
+                break;
+            case TD3d:
+                speedValues = Arrays.asList(1., 1., 1.75, 2.5, 2.5);
+                break;
+
+            case TD4:
+                speedValues = Arrays.asList(1.1, 0.85, 1.1, 0.85, 1.1);
+                break;
+            case TD5:
+                speedValues = Arrays.asList(1.2, 0.8, 1., 0.8, 1.2);
+                break;
+            case TD6:
+                speedValues = Arrays.asList(1.2, 0.7, 1.2, 0.7, 1.2);
+                break;
+
+            case CLASSIC:
+                speedValues = Arrays.asList(1., 1., 1., 1., 1.);
+                break;
             }
             return speedValues;
         }
@@ -149,14 +149,16 @@ public void setTransportTimeParameter(double transportTimeParameter) {
 
         @Override
         public double getTransportCost(Location from, Location to, double departureTime, Driver driver, Vehicle vehicle) {
-            return transportDistanceParameter * EuclideanDistanceCalculator.calculateDistance(locations.getCoord(from.getId()), locations.getCoord(to.getId())) +
-                transportTimeParameter * getTransportTime(from, to, departureTime, driver, vehicle);
+            return transportDistanceParameter
+                    * EuclideanDistanceCalculator.getInstance().calculateDistance(locations.getCoord(from.getId()), locations.getCoord(to.getId())) +
+                    transportTimeParameter * getTransportTime(from, to, departureTime, driver, vehicle);
         }
 
         @Override
         public double getBackwardTransportCost(Location from, Location to, double arrivalTime, Driver driver, Vehicle vehicle) {
-            return transportDistanceParameter * EuclideanDistanceCalculator.calculateDistance(locations.getCoord(from.getId()), locations.getCoord(to.getId())) +
-                transportTimeParameter * getBackwardTransportTime(from, to, arrivalTime, driver, vehicle);
+            return transportDistanceParameter
+                    * EuclideanDistanceCalculator.getInstance().calculateDistance(locations.getCoord(from.getId()), locations.getCoord(to.getId())) +
+                    transportTimeParameter * getBackwardTransportTime(from, to, arrivalTime, driver, vehicle);
         }
 
 
@@ -166,7 +168,8 @@ public double getTransportTime(Location from, Location to, double departureTime,
                 return 0.0;
             }
             double totalTravelTime = 0.0;
-            double distanceToTravel = EuclideanDistanceCalculator.calculateDistance(locations.getCoord(from.getId()), locations.getCoord(to.getId()));
+            double distanceToTravel = EuclideanDistanceCalculator.getInstance().calculateDistance(locations.getCoord(from.getId()),
+                    locations.getCoord(to.getId()));
             double currentTime = departureTime;
             for (int i = 0; i < timeBins.size(); i++) {
                 double timeThreshold = timeBins.get(i);
@@ -192,7 +195,8 @@ public double getBackwardTransportTime(Location from, Location to, double arriva
                 return 0.0;
             }
             double totalTravelTime = 0.0;
-            double distanceToTravel = EuclideanDistanceCalculator.calculateDistance(locations.getCoord(from.getId()), locations.getCoord(to.getId()));
+            double distanceToTravel = EuclideanDistanceCalculator.getInstance().calculateDistance(locations.getCoord(from.getId()),
+                    locations.getCoord(to.getId()));
             double currentTime = arrivalTime;
             for (int i = timeBins.size() - 1; i >= 0; i--) {
                 double nextLowerTimeThreshold;
diff --git a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/Taillard.java b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/Taillard.java
index c1026c04f..3e396446d 100644
--- a/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/Taillard.java
+++ b/jsprit-instances/src/main/java/com/graphhopper/jsprit/instance/reader/Taillard.java
@@ -219,7 +219,7 @@
 //				else{
 //					variableCost = vehicle.getType().vehicleCostParams.perDistanceUnit;
 //				}
-//				return variableCost*EuclideanDistanceCalculator.calculateDistance(myLocations.getCoord(fromId), myLocations.getCoord(toId));
+//				return variableCost*EuclideanDistanceCalculator.getInstance().calculateDistance(myLocations.getCoord(fromId), myLocations.getCoord(toId));
 //			}
 //
 //			@Override
diff --git a/jsprit-io/src/main/java/com/graphhopper/jsprit/io/algorithm/VehicleRoutingAlgorithms.java b/jsprit-io/src/main/java/com/graphhopper/jsprit/io/algorithm/VehicleRoutingAlgorithms.java
index 07ebaa979..b831b8952 100644
--- a/jsprit-io/src/main/java/com/graphhopper/jsprit/io/algorithm/VehicleRoutingAlgorithms.java
+++ b/jsprit-io/src/main/java/com/graphhopper/jsprit/io/algorithm/VehicleRoutingAlgorithms.java
@@ -32,7 +32,7 @@
 import com.graphhopper.jsprit.core.algorithm.ruin.RadialRuinStrategyFactory;
 import com.graphhopper.jsprit.core.algorithm.ruin.RandomRuinStrategyFactory;
 import com.graphhopper.jsprit.core.algorithm.ruin.RuinStrategy;
-import com.graphhopper.jsprit.core.algorithm.ruin.distance.AvgServiceAndShipmentDistance;
+import com.graphhopper.jsprit.core.algorithm.ruin.distance.DefaultJobDistance;
 import com.graphhopper.jsprit.core.algorithm.ruin.distance.JobDistance;
 import com.graphhopper.jsprit.core.algorithm.selector.SelectBest;
 import com.graphhopper.jsprit.core.algorithm.selector.SelectRandomly;
@@ -867,7 +867,7 @@ private static SearchStrategyModule buildModule(HierarchicalConfiguration module
                 String shareToRuinString = moduleConfig.getString("ruin.share");
                 if (shareToRuinString == null) throw new IllegalStateException("module.ruin.share is missing.");
                 double shareToRuin = Double.valueOf(shareToRuinString);
-                JobDistance jobDistance = new AvgServiceAndShipmentDistance(vrp.getTransportCosts());
+                JobDistance jobDistance = new DefaultJobDistance(vrp.getTransportCosts());
                 ruin = getRadialRuin(vrp, routeStates, definedClasses, ruinKey, shareToRuin, jobDistance);
             } else if (ruin_name.equals("clusterRuin")) {
                 String initialNumberJobsToRemoveString = moduleConfig.getString("ruin.initRemoveJobs");
@@ -916,7 +916,7 @@ private static RuinStrategy getRadialRuin(final VehicleRoutingProblem vrp, final
     }
 
     private static RuinStrategy getClusterRuin(final VehicleRoutingProblem vrp, final StateManager routeStates, TypedMap definedClasses, ModKey modKey, int initialNumberJobsToRemove) {
-    	JobNeighborhoods jobNeighborhoods = new JobNeighborhoodsFactory().createNeighborhoods(vrp, new AvgServiceAndShipmentDistance(vrp.getTransportCosts()));
+    	JobNeighborhoods jobNeighborhoods = new JobNeighborhoodsFactory().createNeighborhoods(vrp, new DefaultJobDistance(vrp.getTransportCosts()));
     	RuinStrategyKey stratKey = new RuinStrategyKey(modKey);
         RuinStrategy ruin = definedClasses.get(stratKey);
         if (ruin == null) {
