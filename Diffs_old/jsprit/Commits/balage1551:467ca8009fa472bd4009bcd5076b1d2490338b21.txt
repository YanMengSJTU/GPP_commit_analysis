diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractJob.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractJob.java
index 72ff4670a..677988230 100644
--- a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractJob.java
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/AbstractJob.java
@@ -18,14 +18,18 @@
 
 package com.graphhopper.jsprit.core.problem.job;
 
-import com.graphhopper.jsprit.core.problem.SizeDimension;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+
 import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.SizeDimension;
 import com.graphhopper.jsprit.core.problem.Skills;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.JobActivity;
 import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
 
-import java.util.*;
-
 /**
  * Abstract base class for all Job implementations.
  * <p>
@@ -128,9 +132,8 @@
         protected int priority = 2;
 
         public JobBuilder(String id) {
-            if (id == null) {
+            if (id == null)
                 throw new IllegalArgumentException("id must not be null");
-            }
             this.id = id;
         }
 
@@ -144,9 +147,8 @@ public JobBuilder(String id) {
          */
         @SuppressWarnings("unchecked")
         public B addSizeDimension(int dimensionIndex, int dimensionValue) {
-            if (dimensionValue < 0) {
+            if (dimensionValue < 0)
                 throw new IllegalArgumentException("capacity value cannot be negative");
-            }
             capacityBuilder.addDimension(dimensionIndex, dimensionValue);
             return (B) this;
         }
@@ -180,20 +182,19 @@ public B addAllSizeDimensions(SizeDimension size) {
         }
 
         /**
-         * Set priority to service. Only 1 = high priority, 2 = medium and 3 =
-         * low are allowed.
+         * Set priority to service. Only 1 (very high) to 10 (very low) are
+         * allowed.
          * <p>
-         * Default is 2 = medium.
+         * Default is 2.
          *
          * @param priority
          * @return builder
          */
         @SuppressWarnings("unchecked")
         public B setPriority(int priority) {
-            if (priority < 1 || priority > 3) {
+            if (priority < 1 || priority > 10)
                 throw new IllegalArgumentException(
-                    "incorrect priority. only 1 = high, 2 = medium and 3 = low is allowed");
-            }
+                                "incorrect priority. only priority values from 1 to 10 are allowed where 1 = high and 10 is low");
             this.priority = priority;
             return (B) this;
         }
@@ -364,23 +365,18 @@ public int hashCode() {
      */
     @Override
     public boolean equals(Object obj) {
-        if (this == obj) {
+        if (this == obj)
             return true;
-        }
-        if (obj == null) {
+        if (obj == null)
             return false;
-        }
-        if (getClass() != obj.getClass()) {
+        if (getClass() != obj.getClass())
             return false;
-        }
         AbstractJob other = (AbstractJob) obj;
         if (id == null) {
-            if (other.id != null) {
+            if (other.id != null)
                 return false;
-            }
-        } else if (!id.equals(other.id)) {
+        } else if (!id.equals(other.id))
             return false;
-        }
         return true;
     }
 
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/legacy/AbstractJob.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/legacy/AbstractJob.java
new file mode 100644
index 000000000..2a15cbb13
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/legacy/AbstractJob.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.graphhopper.jsprit.core.problem.job.legacy;
+
+
+/**
+ * Created by schroeder on 14.07.14.
+ */
+public abstract class AbstractJob implements Job {
+
+    private int index;
+    private Object userData;
+
+    @Override
+    public int getIndex() {
+        return index;
+    }
+
+    protected void setIndex(int index) {
+        this.index = index;
+    }
+
+    /**
+     * @return User-specific domain data associated by the job
+     */
+    public Object getUserData() {
+        return userData;
+    }
+
+    protected void setUserData(Object userData) {
+        this.userData = userData;
+    }
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/legacy/Job.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/legacy/Job.java
new file mode 100644
index 000000000..c3a7449ca
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/legacy/Job.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.jsprit.core.problem.job.legacy;
+
+
+import com.graphhopper.jsprit.core.problem.Capacity;
+import com.graphhopper.jsprit.core.problem.HasId;
+import com.graphhopper.jsprit.core.problem.HasIndex;
+import com.graphhopper.jsprit.core.problem.Skills;
+
+/**
+ * Basic interface for all jobs.
+ *
+ * @author schroeder
+ */
+public interface Job extends HasId, HasIndex {
+
+    /**
+     * Returns the unique identifier (id) of a job.
+     *
+     * @return id
+     */
+    @Override
+    public String getId();
+
+    /**
+     * Returns size, i.e. capacity-demand, of this job which can consist of an arbitrary number of capacity dimensions.
+     *
+     * @return Capacity
+     */
+    public Capacity getSize();
+
+    public Skills getRequiredSkills();
+
+    /**
+     * Returns name.
+     *
+     * @return name
+     */
+    public String getName();
+
+    /**
+     * Get priority of job. Only 1 = high priority, 2 = medium and 3 = low are allowed.
+     * <p>
+     * Default is 2 = medium.
+     *
+     * @return priority
+     */
+    public int getPriority();
+
+}
diff --git a/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/legacy/Service.java b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/legacy/Service.java
new file mode 100644
index 000000000..0ea5a76d4
--- /dev/null
+++ b/jsprit-core/src/main/java/com/graphhopper/jsprit/core/problem/job/legacy/Service.java
@@ -0,0 +1,447 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.jsprit.core.problem.job.legacy;
+
+import java.util.Collection;
+
+import com.graphhopper.jsprit.core.problem.Capacity;
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.SizeDimension;
+import com.graphhopper.jsprit.core.problem.Skills;
+import com.graphhopper.jsprit.core.problem.job.CustomJob;
+import com.graphhopper.jsprit.core.problem.job.CustomJob.BuilderBase.ActivityType;
+import com.graphhopper.jsprit.core.problem.job.CustomJob.BuilderBase.BuilderActivityInfo;
+import com.graphhopper.jsprit.core.problem.job.Delivery;
+import com.graphhopper.jsprit.core.problem.job.Pickup;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.ServiceActivity;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindowsImpl;
+import com.graphhopper.jsprit.core.util.Coordinate;
+
+/**
+ * Service implementation of a job.
+ *
+ * @deprecated Use {@linkplain CustomJob} instead
+ *
+ *
+ *             <p>
+ *             <h1><em>Warning!</em></h1>
+ *             </p>
+ *
+ *             <p>
+ *             <strong>This class is deprecated and only available for backward
+ *             compatibility and for easier migration.</strong>
+ *             </p>
+ *             <p>
+ *             This class wraps a new CustomJob instance and delegates its
+ *             values and the values from its sole activity. It is strongly
+ *             recommended to switch to the {@linkplain CustomJob} and use one
+ *             of the following functions of its builder to add the service
+ *             activity:
+ *
+ *             <ul>
+ *             <li>{@linkplain CustomJob.Builder#addService(Location)}</li>
+ *             <li>
+ *             {@linkplain CustomJob.Builder#addService(Location, SizeDimension)}
+ *             </li>
+ *             <li>
+ *             {@linkplain CustomJob.Builder#addService(Location, SizeDimension, double)}
+ *             </li>
+ *             <li>
+ *             {@linkplain CustomJob.Builder#addService(Location, SizeDimension, double, TimeWindow)}
+ *             </li>
+ *             </ul>
+ *
+ *             or if you need more control on the activity, use the
+ *             {@linkplain CustomJob.Builder#addActivity(BuilderActivityInfo)}
+ *             function:
+ *
+ *             <pre>
+ *    BuilderActivityInfo activityInfo = new BuilderActivityInfo(ActivityType.SERVICE, <i>location</i>);
+
+        activityInfo.withName(<i>activity name</i>);
+        activityInfo.withOperationTime(<i>serviceTime</i>);
+        activityInfo.withSize((SizeDimension) <i>capacity</i>);
+        activityInfo.withTimeWindows(<i>timeWindows</i>);
+        activityInfo.withTimeWindow(<i>timeWindow</i>);
+
+        CustomJob.Builder customJobBuilder = new CustomJob.Builder(<i>id</i>);
+        customJobBuilder
+            .addActivity(activityInfo)
+            .addAllRequiredSkills(<i>skills<i>)
+            .setName(<i>job name</i>)
+            .setPriority(<i>priority</i>);
+
+        job = customJobBuilder.build();
+ *             </pre>
+ *
+ *             </p>
+ *
+ * @author schroeder
+ * @author Balage
+ *
+ * @see {@linkplain CustomJob}
+ * @see {@linkplain CustomJob.Builder}
+ * @see {@linkplain CustomJob.BuilderBase.BuilderActivityInfo}
+ */
+@Deprecated
+public class Service extends AbstractJob {
+
+    /**
+     * Builder that builds a service.
+     *
+     * @author schroeder
+     */
+    public static class Builder<T extends Service> {
+
+        /**
+         * Returns a new instance of builder that builds a service.
+         *
+         * @param id the id of the service
+         * @return the builder
+         */
+        public static Builder newInstance(String id) {
+            return new Builder(id);
+        }
+
+        private String id;
+
+        protected String locationId;
+
+        private String type = "service";
+
+        protected Coordinate coord;
+
+        protected double serviceTime;
+
+        protected TimeWindow timeWindow = TimeWindow.newInstance(0.0, Double.MAX_VALUE);
+
+        protected Capacity.Builder capacityBuilder = Capacity.Builder.newInstance();
+
+        protected Capacity capacity;
+
+        protected Skills.Builder skillBuilder = Skills.Builder.newInstance();
+
+        protected Skills skills;
+
+        private String name = "no-name";
+
+        protected Location location;
+
+        protected TimeWindowsImpl timeWindows;
+
+        private boolean twAdded = false;
+
+        private int priority = 2;
+        protected Object userData;
+
+        Builder(String id){
+            this.id = id;
+            timeWindows = new TimeWindowsImpl();
+            timeWindows.add(timeWindow);
+        }
+
+        /**
+         * Protected method to set the type-name of the service.
+         * <p>
+         * <p>Currently there are {@link Service}, {@link Pickup} and {@link Delivery}.
+         *
+         * @param name the name of service
+         * @return the builder
+         */
+        protected Builder<T> setType(String name) {
+            this.type = name;
+            return this;
+        }
+
+        /**
+         * Sets location
+         *
+         * @param location location
+         * @return builder
+         */
+        public Builder<T> setLocation(Location location) {
+            this.location = location;
+            return this;
+        }
+
+        /**
+         * Sets the serviceTime of this service.
+         * <p>
+         * <p>It is understood as time that a service or its implied activity takes at the service-location, for instance
+         * to unload goods.
+         *
+         * @param serviceTime the service time / duration of service to be set
+         * @return builder
+         * @throws IllegalArgumentException if serviceTime < 0
+         */
+        public Builder<T> setServiceTime(double serviceTime) {
+            if (serviceTime < 0)
+                throw new IllegalArgumentException("serviceTime must be greater than or equal to zero");
+            this.serviceTime = serviceTime;
+            return this;
+        }
+
+        /**
+         * Sets user specific domain data associated with the object.
+         *
+         * <p>
+         * The user data is a black box for the framework, it only stores it,
+         * but never interacts with it in any way.
+         * </p>
+         *
+         * @param userData
+         *            any object holding the domain specific user data
+         *            associated with the object.
+         * @return builder
+         */
+        public Builder<T> setUserData(Object userData) {
+            this.userData = userData;
+            return this;
+        }
+
+        /**
+         * Adds capacity dimension.
+         *
+         * @param dimensionIndex the dimension index of the capacity value
+         * @param dimensionValue the capacity value
+         * @return the builder
+         * @throws IllegalArgumentException if dimensionValue < 0
+         */
+        public Builder<T> addSizeDimension(int dimensionIndex, int dimensionValue) {
+            if (dimensionValue < 0) throw new IllegalArgumentException("capacity value cannot be negative");
+            capacityBuilder.addDimension(dimensionIndex, dimensionValue);
+            return this;
+        }
+
+        public Builder<T> setTimeWindow(TimeWindow tw){
+            if(tw == null) throw new IllegalArgumentException("time-window arg must not be null");
+            this.timeWindow = tw;
+            this.timeWindows = new TimeWindowsImpl();
+            timeWindows.add(tw);
+            return this;
+        }
+
+        public Builder<T> addTimeWindow(TimeWindow timeWindow) {
+            if(timeWindow == null) throw new IllegalArgumentException("time-window arg must not be null");
+            if(!twAdded){
+                timeWindows = new TimeWindowsImpl();
+                twAdded = true;
+            }
+            timeWindows.add(timeWindow);
+            return this;
+        }
+
+        public Builder<T> addTimeWindow(double earliest, double latest) {
+            return addTimeWindow(TimeWindow.newInstance(earliest, latest));
+        }
+
+        /**
+         * Builds the service.
+         *
+         * @return {@link Service}
+         * @throws IllegalArgumentException if neither locationId nor coordinate is set.
+         */
+        public T build() {
+            if (location == null) throw new IllegalArgumentException("location is missing");
+            this.setType("service");
+            capacity = capacityBuilder.build();
+            skills = skillBuilder.build();
+            return (T) new Service(this);
+        }
+
+        public Builder<T> addRequiredSkill(String skill) {
+            skillBuilder.addSkill(skill);
+            return this;
+        }
+
+        public Builder<T> setName(String name) {
+            this.name = name;
+            return this;
+        }
+
+        public Builder<T> addAllRequiredSkills(Skills skills){
+            for(String s : skills.values()){
+                skillBuilder.addSkill(s);
+            }
+            return this;
+        }
+
+        public Builder<T> addAllSizeDimensions(Capacity size){
+            for(int i=0;i<size.getNuOfDimensions();i++){
+                capacityBuilder.addDimension(i,size.get(i));
+            }
+            return this;
+        }
+
+        /**
+         * Set priority to service. Only 1 (very high) to 10 (very low) are allowed.
+         * <p>
+         * Default is 2.
+         *
+         * @param priority
+         * @return builder
+         */
+        public Builder<T> setPriority(int priority) {
+            if (priority < 1 || priority > 10)
+                throw new IllegalArgumentException("incorrect priority. only priority values from 1 to 10 are allowed where 1 = high and 10 is low");
+            this.priority = priority;
+            return this;
+        }
+    }
+
+
+    private CustomJob theRealJob;
+    private ServiceActivity theRealActivity;
+
+    Service(Builder<?> builder) {
+        setUserData(builder.userData);
+        BuilderActivityInfo activityInfo = new BuilderActivityInfo(ActivityType.SERVICE,
+                        builder.location);
+
+        activityInfo.withName(builder.name);
+        activityInfo.withOperationTime(builder.serviceTime);
+        // Safe cast because SizeDimension is the only implementation of
+        // Capacity
+        activityInfo.withSize((SizeDimension) builder.capacity);
+        activityInfo.withTimeWindows(builder.timeWindows.getTimeWindows());
+
+        com.graphhopper.jsprit.core.problem.job.CustomJob.Builder customJobBuilder = new CustomJob.Builder(
+                        builder.id);
+        customJobBuilder.addActivity(activityInfo).addAllRequiredSkills(builder.skills)
+        .setName(builder.name)
+        .setPriority(builder.priority);
+        theRealJob = customJobBuilder.build();
+        theRealActivity = (ServiceActivity) theRealJob.getActivityList().getAll().get(0);
+    }
+
+    public Collection<TimeWindow> getTimeWindows(){
+        return theRealJob.getTimeWindows();
+    }
+
+    @Override
+    public String getId() {
+        return theRealJob.getId();
+    }
+
+    /**
+     * Returns location.
+     *
+     * @return location
+     */
+    public Location getLocation() {
+        return theRealActivity.getLocation();
+    }
+
+
+    /**
+     * Returns the service-time/duration a service takes at service-location.
+     *
+     * @return service duration
+     */
+    public double getServiceDuration() {
+        return theRealActivity.getOperationTime();
+    }
+
+    /**
+     * Returns the time-window a service(-operation) is allowed to start.
+     * It is recommended to use getTimeWindows() instead. If you still use this, it returns the first time window of getTimeWindows() collection.
+     *
+     * @return time window
+     *
+     */
+    public TimeWindow getTimeWindow() {
+        return theRealActivity.getSingleTimeWindow();
+    }
+
+    /**
+     * @return the name
+     */
+    public String getType() {
+        return "service";
+    }
+
+    /**
+     * Returns a string with the service's attributes.
+     * <p>
+     * <p>String is built as follows: [attr1=val1][attr2=val2]...
+     */
+    @Override
+    public String toString() {
+        return "[id=" + getId() + "][name=" + getName() + "][type=" + getType() + "][location="
+                        + getLocation() + "][capacity=" + getSize() + "][serviceTime="
+                        + getServiceDuration() + "][timeWindow=" + getTimeWindow() + "]";
+    }
+
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((getId() == null) ? 0 : getId().hashCode());
+        return result;
+    }
+
+    /**
+     * Two services are equal if they have the same id.
+     */
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        Service other = (Service) obj;
+        if (getId() == null) {
+            if (other.getId() != null)
+                return false;
+        } else if (!getId().equals(other.getId()))
+            return false;
+        return true;
+    }
+
+    @Override
+    public Capacity getSize() {
+        return theRealActivity.getLoadSize();
+    }
+
+    @Override
+    public Skills getRequiredSkills() {
+        return theRealJob.getRequiredSkills();
+    }
+
+    @Override
+    public String getName() {
+        return theRealJob.getName();
+    }
+
+    /**
+     * Get priority of service. Only 1 = high priority, 2 = medium and 3 = low are allowed.
+     * <p>
+     * Default is 2 = medium.
+     *
+     * @return priority
+     */
+    @Override
+    public int getPriority() {
+        return theRealJob.getPriority();
+    }
+
+}
diff --git a/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/legacy/ServiceTest.java b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/legacy/ServiceTest.java
new file mode 100644
index 000000000..eb7c3ff09
--- /dev/null
+++ b/jsprit-core/src/test/java/com/graphhopper/jsprit/core/problem/job/legacy/ServiceTest.java
@@ -0,0 +1,296 @@
+/*
+ * Licensed to GraphHopper GmbH under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
+ *
+ * GraphHopper GmbH licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.jsprit.core.problem.job.legacy;
+
+import static org.hamcrest.core.Is.is;
+import static org.hamcrest.core.IsCollectionContaining.hasItem;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import com.graphhopper.jsprit.core.problem.Location;
+import com.graphhopper.jsprit.core.problem.solution.route.activity.TimeWindow;
+
+public class ServiceTest {
+
+    @Test
+    public void whenTwoServicesHaveTheSameId_theirReferencesShouldBeUnEqual() {
+        Service one = Service.Builder.newInstance("service").addSizeDimension(0, 10).setLocation(Location.newInstance("foo")).build();
+        Service two = Service.Builder.newInstance("service").addSizeDimension(0, 10).setLocation(Location.newInstance("fo")).build();
+
+        assertTrue(one != two);
+    }
+
+    @Test
+    public void whenTwoServicesHaveTheSameId_theyShouldBeEqual() {
+        Service one = Service.Builder.newInstance("service").addSizeDimension(0, 10).setLocation(Location.newInstance("foo")).build();
+        Service two = Service.Builder.newInstance("service").addSizeDimension(0, 10).setLocation(Location.newInstance("fo")).build();
+
+        assertTrue(one.equals(two));
+    }
+
+    @Test
+    public void noName() {
+        Set<Service> serviceSet = new HashSet<Service>();
+        Service one = Service.Builder.newInstance("service").addSizeDimension(0, 10).setLocation(Location.newInstance("foo")).build();
+        Service two = Service.Builder.newInstance("service").addSizeDimension(0, 10).setLocation(Location.newInstance("fo")).build();
+        serviceSet.add(one);
+        // assertTrue(serviceSet.contains(two));
+        serviceSet.remove(two);
+        assertTrue(serviceSet.isEmpty());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenCapacityDimValueIsNegative_throwIllegalStateExpception() {
+        @SuppressWarnings("unused")
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("foo")).addSizeDimension(0, -10).build();
+    }
+
+    @Test
+    public void whenAddingTwoCapDimension_nuOfDimsShouldBeTwo() {
+        Service one = Service.Builder.newInstance("s").setLocation(Location.newInstance("foofoo"))
+                        .addSizeDimension(0, 2).addSizeDimension(1, 4).build();
+        assertEquals(2, one.getSize().getNuOfDimensions());
+    }
+
+    @Test
+    public void whenShipmentIsBuiltWithoutSpecifyingCapacity_itShouldHvCapWithOneDimAndDimValOfZero() {
+        Service one = Service.Builder.newInstance("s").setLocation(Location.newInstance("foofoo"))
+                        .build();
+        assertEquals(1, one.getSize().getNuOfDimensions());
+        assertEquals(0, one.getSize().get(0));
+    }
+
+    @Test
+    public void whenShipmentIsBuiltWithConstructorWhereSizeIsSpecified_capacityShouldBeSetCorrectly() {
+        Service one = Service.Builder.newInstance("s").addSizeDimension(0, 1).setLocation(Location.newInstance("foofoo"))
+                        .build();
+        assertEquals(1, one.getSize().getNuOfDimensions());
+        assertEquals(1, one.getSize().get(0));
+    }
+
+    @Test
+    public void whenCallingForNewInstanceOfBuilder_itShouldReturnBuilderCorrectly() {
+        Service.Builder builder = Service.Builder.newInstance("s");
+        assertNotNull(builder);
+    }
+
+    @Test
+    public void whenSettingNoType_itShouldReturn_service() {
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).build();
+        assertEquals("service", s.getType());
+    }
+
+    @Test
+    public void whenSettingLocation_itShouldBeSetCorrectly() {
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).build();
+        assertEquals("loc", s.getLocation().getId());
+        assertEquals("loc", s.getLocation().getId());
+    }
+
+    @Test
+    public void whenSettingLocation_itShouldWork() {
+        Service s = Service.Builder.newInstance("s").setLocation(Location.Builder.newInstance().setId("loc").build()).build();
+        assertEquals("loc", s.getLocation().getId());
+        assertEquals("loc", s.getLocation().getId());
+    }
+
+
+    @Test
+    public void whenSettingLocationCoord_itShouldBeSetCorrectly(){
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance(1, 2)).build();
+        assertEquals(1.0,s.getLocation().getCoordinate().getX(),0.01);
+        assertEquals(2.0,s.getLocation().getCoordinate().getY(),0.01);
+        assertEquals(1.0,s.getLocation().getCoordinate().getX(),0.01);
+        assertEquals(2.0,s.getLocation().getCoordinate().getY(),0.01);
+    }
+
+    @Test(expected=IllegalArgumentException.class)
+    public void whenSettingNeitherLocationIdNorCoord_throwsException(){
+        @SuppressWarnings("unused")
+        Service s = Service.Builder.newInstance("s").build();
+    }
+
+    @Test(expected=IllegalArgumentException.class)
+    public void whenServiceTimeSmallerZero_throwIllegalStateException(){
+        @SuppressWarnings("unused")
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).setServiceTime(-1).build();
+    }
+
+    @Test
+    public void whenSettingServiceTime_itShouldBeSetCorrectly(){
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).setServiceTime(1).build();
+        assertEquals(1.0,s.getServiceDuration(),0.01);
+    }
+
+    @Test(expected=IllegalArgumentException.class)
+    public void whenTimeWindowIsNull_throwException(){
+        @SuppressWarnings("unused")
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).setTimeWindow(null).build();
+    }
+
+    @Test
+    public void whenSettingTimeWindow_itShouldBeSetCorrectly(){
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc")).setTimeWindow(TimeWindow.newInstance(1.0, 2.0)).build();
+        assertEquals(1.0,s.getTimeWindow().getStart(),0.01);
+        assertEquals(2.0,s.getTimeWindow().getEnd(),0.01);
+    }
+
+    @Test
+    public void whenAddingSkills_theyShouldBeAddedCorrectly(){
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+                        .addRequiredSkill("drill").addRequiredSkill("screwdriver").build();
+        assertTrue(s.getRequiredSkills().containsSkill("drill"));
+        assertTrue(s.getRequiredSkills().containsSkill("drill"));
+        assertTrue(s.getRequiredSkills().containsSkill("ScrewDriver"));
+    }
+
+    @Test
+    public void whenAddingSkillsCaseSens_theyShouldBeAddedCorrectly(){
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+                        .addRequiredSkill("DriLl").addRequiredSkill("screwDriver").build();
+        assertTrue(s.getRequiredSkills().containsSkill("drill"));
+        assertTrue(s.getRequiredSkills().containsSkill("drilL"));
+    }
+
+    @Test
+    public void whenAddingSeveralTimeWindows_itShouldBeSetCorrectly(){
+        TimeWindow tw1 = TimeWindow.newInstance(1.0, 2.0);
+        TimeWindow tw2 = TimeWindow.newInstance(3.0, 5.0);
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+                        .addTimeWindow(tw1).addTimeWindow(tw2).build();
+        assertEquals(2, s.getTimeWindows().size());
+        assertThat(s.getTimeWindows(),hasItem(is(tw1)));
+        assertThat(s.getTimeWindows(),hasItem(is(tw2)));
+    }
+
+    @Test
+    public void whenAddingTimeWindow_itShouldBeSetCorrectly(){
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+                        .addTimeWindow(TimeWindow.newInstance(1.0, 2.0)).build();
+        assertEquals(1.0, s.getTimeWindow().getStart(), 0.01);
+        assertEquals(2.0, s.getTimeWindow().getEnd(), 0.01);
+    }
+
+
+
+
+    @Test
+    public void whenAddingSkillsCaseSensV2_theyShouldBeAddedCorrectly() {
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+                        .addRequiredSkill("screwDriver").build();
+        assertFalse(s.getRequiredSkills().containsSkill("drill"));
+        assertFalse(s.getRequiredSkills().containsSkill("drilL"));
+    }
+
+    @Test
+    public void nameShouldBeAssigned() {
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+                        .setName("name").build();
+        assertEquals("name", s.getName());
+    }
+
+    @Test
+    public void shouldKnowMultipleTimeWindows(){
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+                        .addTimeWindow(TimeWindow.newInstance(0., 10.))
+                        .addTimeWindow(TimeWindow.newInstance(20., 30.)).setName("name").build();
+        assertEquals(2,s.getTimeWindows().size());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenMultipleTWOverlap_throwEx(){
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+                        .addTimeWindow(TimeWindow.newInstance(0., 10.))
+                        .addTimeWindow(TimeWindow.newInstance(5., 30.)).setName("name").build();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenMultipleTWOverlap2_throwEx(){
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+                        .addTimeWindow(TimeWindow.newInstance(20., 30.))
+                        .addTimeWindow(TimeWindow.newInstance(0., 25.)).setName("name").build();
+    }
+
+    @Test
+    public void whenSettingPriorities_itShouldBeSetCorrectly(){
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+                        .setPriority(1).build();
+        Assert.assertEquals(1, s.getPriority());
+    }
+
+    @Test
+    public void whenSettingPriorities_itShouldBeSetCorrectly2(){
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+                        .setPriority(3).build();
+        Assert.assertEquals(3, s.getPriority());
+    }
+
+    @Test
+    public void whenSettingPriorities_itShouldBeSetCorrectly3() {
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+                        .setPriority(10).build();
+        Assert.assertEquals(10, s.getPriority());
+    }
+
+    @Test
+    public void whenNotSettingPriorities_defaultShouldBe2(){
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+                        .build();
+        Assert.assertEquals(2, s.getPriority());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenSettingIncorrectPriorities_itShouldThrowException(){
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+                        .setPriority(30).build();
+
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void whenSettingIncorrectPriorities_itShouldThrowException2(){
+        Service s = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+                        .setPriority(0).build();
+
+    }
+
+
+    @Test
+    public void whenSettingUserData_itIsAssociatedWithTheJob() {
+        Service one = Service.Builder.newInstance("s").setLocation(Location.newInstance("loc"))
+                        .setUserData(new HashMap<String, Object>()).build();
+        Service two = Service.Builder.newInstance("s2").setLocation(Location.newInstance("loc")).setUserData(42)
+                        .build();
+        Service three = Service.Builder.newInstance("s3").setLocation(Location.newInstance("loc")).build();
+
+        assertTrue(one.getUserData() instanceof Map);
+        assertEquals(42, two.getUserData());
+        assertNull(three.getUserData());
+    }
+}
