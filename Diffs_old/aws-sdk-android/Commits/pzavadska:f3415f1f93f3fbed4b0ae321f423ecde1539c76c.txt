diff --git a/aws-android-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferDBUtil.java b/aws-android-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferDBUtil.java
index 15627e7a0e..9464006493 100644
--- a/aws-android-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferDBUtil.java
+++ b/aws-android-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferDBUtil.java
@@ -119,7 +119,8 @@ public Uri insertSingleTransferRecord(TransferType type, String bucket, String k
      */
     public Uri insertSingleTransferRecord(TransferType type, String bucket, String key, File file,
             ObjectMetadata metadata, CannedAccessControlList cannedAcl) {
-        final ContentValues values = generateContentValuesForSinglePartTransfer(type, bucket, key, file,
+        final ContentValues values = generateContentValuesForSinglePartTransfer(type, bucket, key,
+                file,
                 metadata, cannedAcl);
         return transferDBBase.insert(transferDBBase.getContentUri(), values);
     }
@@ -195,9 +196,9 @@ public int updateBytesTotalForDownload(int id, long bytes) {
      * Updates the state but do not notify TransferService to refresh its
      * transfer record list. Therefore, only TransferObserver knows the state
      * change of the transfer record. If the new state is STATE_FAILED, we need
-     * to check the original state, because "pause", "cancel" and
-     * "disconnect network" actions may also cause failure message of the
-     * threads, but these are not actual failure of transfers.
+     * to check the original state, because "pause", "cancel" and "disconnect
+     * network" actions may also cause failure message of the threads, but these
+     * are not actual failure of transfers.
      *
      * @param id The id of the transfer.
      * @param state The new state of the transfer.
@@ -209,12 +210,12 @@ public int updateState(int id, TransferState state) {
         if (TransferState.FAILED.equals(state)) {
             return transferDBBase.update(getRecordUri(id), values, TransferTable.COLUMN_STATE
                     + " not in (?,?,?,?,?) ", new String[] {
-                    TransferState.COMPLETED.toString(),
-                    TransferState.PENDING_NETWORK_DISCONNECT.toString(),
-                    TransferState.PAUSED.toString(),
-                    TransferState.CANCELED.toString(),
-                    TransferState.WAITING_FOR_NETWORK.toString()
-                    });
+                            TransferState.COMPLETED.toString(),
+                            TransferState.PENDING_NETWORK_DISCONNECT.toString(),
+                            TransferState.PAUSED.toString(),
+                            TransferState.CANCELED.toString(),
+                            TransferState.WAITING_FOR_NETWORK.toString()
+            });
         } else {
             return transferDBBase.update(getRecordUri(id), values, null, null);
         }
@@ -275,11 +276,12 @@ public int updateNetworkDisconnected() {
                 TransferState.PENDING_NETWORK_DISCONNECT.toString());
         return transferDBBase.update(transferDBBase.getContentUri(), values,
                 TransferTable.COLUMN_STATE
-                        + " in (?,?,?)", new String[] {
+                        + " in (?,?,?)",
+                new String[] {
                         TransferState.IN_PROGRESS.toString(),
                         TransferState.RESUMED_WAITING.toString(),
                         TransferState.WAITING.toString()
-                        });
+                });
     }
 
     /**
@@ -293,10 +295,11 @@ public int updateNetworkConnected() {
         values.put(TransferTable.COLUMN_STATE, TransferState.RESUMED_WAITING.toString());
         return transferDBBase.update(transferDBBase.getContentUri(), values,
                 TransferTable.COLUMN_STATE
-                        + " in (?,?)", new String[] {
+                        + " in (?,?)",
+                new String[] {
                         TransferState.PENDING_NETWORK_DISCONNECT.toString(),
                         TransferState.WAITING_FOR_NETWORK.toString()
-                        });
+                });
     }
 
     /**
@@ -318,7 +321,7 @@ public int setAllRunningRecordsToPausedBeforeShutdownService() {
                         TransferState.PENDING_PAUSE.toString(),
                         TransferState.RESUMED_WAITING.toString(),
                         TransferState.WAITING.toString()
-                    });
+                });
     }
 
     /**
@@ -403,7 +406,7 @@ public Cursor queryAllTransfersWithType(TransferType type) {
         } else {
             return transferDBBase.query(transferDBBase.getContentUri(), null,
                     TransferTable.COLUMN_TYPE + "=?", new String[] {
-                        type.toString()
+                            type.toString()
                     }, null);
         }
     }
@@ -423,7 +426,7 @@ public Cursor queryTransfersWithTypeAndState(TransferType type, TransferState st
         } else {
             return transferDBBase.query(getStateUri(state), null, TransferTable.COLUMN_TYPE + "=?",
                     new String[] {
-                        type.toString()
+                            type.toString()
                     }, null);
         }
     }
@@ -433,11 +436,13 @@ public Cursor queryTransfersWithTypeAndState(TransferType type, TransferState st
      *
      * @param projections The list of columns to be projected
      * @param type The type of Transfer
-     * @param String[] The list of Transfer States whose Transfer Records are required.
-     * @return A Cursor pointing to records in the database in any of the given states.
+     * @param String[] The list of Transfer States whose Transfer Records are
+     *            required.
+     * @return A Cursor pointing to records in the database in any of the given
+     *         states.
      */
     public Cursor queryTransfersWithTypeAndStates(TransferType type,
-                                                  TransferState[] states) {
+            TransferState[] states) {
         final String selection;
         final String[] selectionArgs;
         int index = 0;
@@ -488,7 +493,8 @@ public long queryBytesTransferredByMainUploadId(int mainUploadId) {
         try {
             c = transferDBBase.query(getPartUri(mainUploadId), null, null, null, null);
             while (c.moveToNext()) {
-                final String state = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_STATE));
+                final String state = c
+                        .getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_STATE));
                 if (TransferState.PART_COMPLETED.equals(TransferState.getState(state))) {
                     bytesTotal += c.getLong(c
                             .getColumnIndexOrThrow(TransferTable.COLUMN_BYTES_TOTAL));
@@ -565,7 +571,8 @@ public int deleteTransferRecords(int id) {
                         .withId(c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_ID)))
                         .withMainUploadId(
                                 c.getInt(c
-                                        .getColumnIndexOrThrow(TransferTable.COLUMN_MAIN_UPLOAD_ID)))
+                                        .getColumnIndexOrThrow(
+                                                TransferTable.COLUMN_MAIN_UPLOAD_ID)))
                         .withBucketName(
                                 c.getString(c
                                         .getColumnIndexOrThrow(TransferTable.COLUMN_BUCKET_NAME)))
@@ -574,11 +581,13 @@ public int deleteTransferRecords(int id) {
                         .withFile(new File(
                                 c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_FILE))))
                         .withFileOffset(
-                                c.getLong(c.getColumnIndexOrThrow(TransferTable.COLUMN_FILE_OFFSET)))
+                                c.getLong(
+                                        c.getColumnIndexOrThrow(TransferTable.COLUMN_FILE_OFFSET)))
                         .withPartNumber(
                                 c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_PART_NUM)))
                         .withPartSize(
-                                c.getLong(c.getColumnIndexOrThrow(TransferTable.COLUMN_BYTES_TOTAL)))
+                                c.getLong(
+                                        c.getColumnIndexOrThrow(TransferTable.COLUMN_BYTES_TOTAL)))
                         .withLastPart(1 == c.getInt(c
                                 .getColumnIndexOrThrow(TransferTable.COLUMN_IS_LAST_PART)));
                 list.add(putPartRequest);
@@ -592,8 +601,8 @@ public int deleteTransferRecords(int id) {
     }
 
     /**
-     * Queries waiting for network partUpload tasks of a multipart upload and returns
-     * true if one such partUpload tasks
+     * Queries waiting for network partUpload tasks of a multipart upload and
+     * returns true if one such partUpload tasks
      *
      * @param mainUploadId The mainUploadId of a multipart upload task
      * @return If a partUpload task waiting for network exist
@@ -603,7 +612,8 @@ public boolean checkWaitingForNetworkPartRequestsFromDB(int mainUploadId) {
         Cursor c = null;
 
         try {
-            c = transferDBBase.query(getPartUri(mainUploadId), null, TransferTable.COLUMN_STATE + "=?",
+            c = transferDBBase.query(getPartUri(mainUploadId), null,
+                    TransferTable.COLUMN_STATE + "=?",
                     new String[] {
                             TransferState.WAITING_FOR_NETWORK.toString()
                     }, null);
@@ -704,7 +714,8 @@ private ContentValues generateContentValuesForObjectMetadata(ObjectMetadata meta
                 metadata.getContentDisposition());
         values.put(TransferTable.COLUMN_SSE_ALGORITHM, metadata.getSSEAlgorithm());
         values.put(TransferTable.COLUMN_SSE_KMS_KEY, metadata.getSSEAwsKmsKeyId());
-        values.put(TransferTable.COLUMN_EXPIRATION_TIME_RULE_ID, metadata.getExpirationTimeRuleId());
+        values.put(TransferTable.COLUMN_EXPIRATION_TIME_RULE_ID,
+                metadata.getExpirationTimeRuleId());
         if (metadata.getHttpExpiresDate() != null) {
             values.put(TransferTable.COLUMN_HTTP_EXPIRES_DATE,
                     String.valueOf(metadata.getHttpExpiresDate().getTime()));
@@ -820,4 +831,3 @@ static TransferDBBase getTransferDBBase() {
         return transferDBBase;
     }
 }
-
diff --git a/aws-android-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferRecord.java b/aws-android-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferRecord.java
index e071efc64e..9191e06984 100644
--- a/aws-android-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferRecord.java
+++ b/aws-android-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferRecord.java
@@ -21,7 +21,6 @@
 import com.amazonaws.mobileconnectors.s3.transferutility.TransferService.NetworkInfoReceiver;
 import com.amazonaws.services.s3.AmazonS3;
 import com.amazonaws.services.s3.model.AbortMultipartUploadRequest;
-import com.amazonaws.services.s3.model.StorageClass;
 import com.amazonaws.util.json.JsonUtils;
 
 import org.apache.commons.logging.Log;
@@ -149,7 +148,8 @@ public void updateFromDB(Cursor c) {
         this.sseKMSKey = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_SSE_KMS_KEY));
         this.md5 = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_CONTENT_MD5));
         this.cannedAcl = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_CANNED_ACL));
-        this.headerStorageClass = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_HEADER_STORAGE_CLASS));
+        this.headerStorageClass = c
+                .getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_HEADER_STORAGE_CLASS));
     }
 
     /**
diff --git a/aws-android-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferTable.java b/aws-android-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferTable.java
index 166a78496e..2110fe09b7 100644
--- a/aws-android-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferTable.java
+++ b/aws-android-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferTable.java
@@ -152,7 +152,7 @@
      * User specified cache control
      */
     public static final String COLUMN_HEADER_CACHE_CONTROL = "header_cache_control";
-    
+
     /**
      * User specified storage class
      */
@@ -306,14 +306,17 @@ private static void addVersion3Columns(SQLiteDatabase database) {
     }
 
     /**
-     * Adds columns that were introduced in version 3 to the database
+     * Adds columns that were introduced in version 4 to the database
      */
     private static void addVersion4Columns(SQLiteDatabase database) {
         final String addCannedAcl = "ALTER TABLE " + TABLE_TRANSFER +
                 " ADD COLUMN " + COLUMN_CANNED_ACL + " text;";
         database.execSQL(addCannedAcl);
     }
-    
+
+    /**
+     * Adds columns that were introduced in version 5 to the database
+     */
     private static void addVersion5Columns(SQLiteDatabase database) {
         final String addCannedAcl = "ALTER TABLE " + TABLE_TRANSFER +
                 " ADD COLUMN " + COLUMN_HEADER_STORAGE_CLASS + " text;";
diff --git a/aws-android-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/UploadTask.java b/aws-android-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/UploadTask.java
index f5ae615279..c9ef5a5808 100644
--- a/aws-android-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/UploadTask.java
+++ b/aws-android-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/UploadTask.java
@@ -15,7 +15,6 @@
 
 package com.amazonaws.mobileconnectors.s3.transferutility;
 
-
 import com.amazonaws.AmazonClientException;
 import com.amazonaws.mobileconnectors.s3.transferutility.TransferService.NetworkInfoReceiver;
 import com.amazonaws.retry.RetryUtils;
@@ -122,14 +121,16 @@ private Boolean uploadMultipartAndWaitForCompletion() throws ExecutionException
         }
         updater.updateProgress(upload.id, bytesAlreadyTransferrd, upload.bytesTotal);
 
-        final List<UploadPartRequest> requestList = dbUtil.getNonCompletedPartRequestsFromDB(upload.id,
+        final List<UploadPartRequest> requestList = dbUtil.getNonCompletedPartRequestsFromDB(
+                upload.id,
                 upload.multipartId);
         LOGGER.debug("multipart upload " + upload.id + " in " + requestList.size() + " parts.");
         final ArrayList<Future<Boolean>> futures = new ArrayList<Future<Boolean>>();
         for (final UploadPartRequest request : requestList) {
             TransferUtility.appendMultipartTransferServiceUserAgentString(request);
             request.setGeneralProgressListener(updater.newProgressListener(upload.id));
-            futures.add(TransferThreadPool.submitTask(new UploadPartTask(request, s3, dbUtil, networkInfo)));
+            futures.add(TransferThreadPool
+                    .submitTask(new UploadPartTask(request, s3, dbUtil, networkInfo)));
         }
         try {
             boolean isSuccess = true;
@@ -161,10 +162,12 @@ private Boolean uploadMultipartAndWaitForCompletion() throws ExecutionException
             // handle pause, cancel, etc
             boolean isNetworkInterrupted = false;
             if (ee.getCause() != null && ee.getCause() instanceof Exception) {
-                // check for network interruption and pause the transfer instead of failing them
+                // check for network interruption and pause the transfer instead
+                // of failing them
                 isNetworkInterrupted = dbUtil.checkWaitingForNetworkPartRequestsFromDB(upload.id);
                 if (isNetworkInterrupted) {
-                    LOGGER.debug("Network Connection Interrupted: Transfer " + upload.id + " waits for network");
+                    LOGGER.debug("Network Connection Interrupted: Transfer " + upload.id
+                            + " waits for network");
                     updater.updateState(upload.id, TransferState.WAITING_FOR_NETWORK);
                     return false;
                 }
@@ -225,8 +228,10 @@ private Boolean uploadSinglePartAndWaitForCompletion() {
                 return false;
             } else if (e.getCause() != null && e.getCause() instanceof AmazonClientException
                     && !networkInfo.isNetworkConnected()) {
-                // check for network interruption and pause the transfer instead of failing them
-                LOGGER.debug("Network Connection Interrupted: Transfer " + upload.id + " waits for network");
+                // check for network interruption and pause the transfer instead
+                // of failing them
+                LOGGER.debug("Network Connection Interrupted: Transfer " + upload.id
+                        + " waits for network");
                 updater.updateState(upload.id, TransferState.WAITING_FOR_NETWORK);
                 return false;
             } else if (e.getCause() != null && e.getCause() instanceof IOException
@@ -245,7 +250,8 @@ private Boolean uploadSinglePartAndWaitForCompletion() {
     private void completeMultiPartUpload(int mainUploadId, String bucket,
             String key, String multipartId) {
         final List<PartETag> partETags = dbUtil.queryPartETagsOfUpload(mainUploadId);
-        final CompleteMultipartUploadRequest completeRequest = new CompleteMultipartUploadRequest(bucket,
+        final CompleteMultipartUploadRequest completeRequest = new CompleteMultipartUploadRequest(
+                bucket,
                 key, multipartId, partETags);
         TransferUtility.appendMultipartTransferServiceUserAgentString(completeRequest);
         s3.completeMultipartUpload(completeRequest);
@@ -261,13 +267,14 @@ private String initiateMultipartUpload(PutObjectRequest putObjectRequest) {
         InitiateMultipartUploadRequest initiateMultipartUploadRequest = null;
         initiateMultipartUploadRequest = new InitiateMultipartUploadRequest(
                 putObjectRequest.getBucketName(), putObjectRequest.getKey())
-                .withCannedACL(putObjectRequest.getCannedAcl())
-                .withObjectMetadata(putObjectRequest.getMetadata())
-                .withSSEAwsKeyManagementParams(
+                        .withCannedACL(putObjectRequest.getCannedAcl())
+                        .withObjectMetadata(putObjectRequest.getMetadata())
+                        .withSSEAwsKeyManagementParams(
                                 putObjectRequest.getSSEAwsKeyManagementParams());
         TransferUtility
                 .appendMultipartTransferServiceUserAgentString(initiateMultipartUploadRequest);
-        final String uploadId = s3.initiateMultipartUpload(initiateMultipartUploadRequest).getUploadId();
+        final String uploadId = s3.initiateMultipartUpload(initiateMultipartUploadRequest)
+                .getUploadId();
         return uploadId;
     }
 
diff --git a/aws-android-sdk-s3/src/main/java/com/amazonaws/services/s3/model/ObjectMetadata.java b/aws-android-sdk-s3/src/main/java/com/amazonaws/services/s3/model/ObjectMetadata.java
index 74bad7d6e7..82fc278c1c 100644
--- a/aws-android-sdk-s3/src/main/java/com/amazonaws/services/s3/model/ObjectMetadata.java
+++ b/aws-android-sdk-s3/src/main/java/com/amazonaws/services/s3/model/ObjectMetadata.java
@@ -37,8 +37,7 @@
  * Amazon S3 sends and receives (Content-Length, ETag, Content-MD5, etc.).
  */
 public class ObjectMetadata implements ServerSideEncryptionResult, S3RequesterChargedResult,
-        ObjectExpirationResult, ObjectRestoreResult, Cloneable, Serializable
-{
+        ObjectExpirationResult, ObjectRestoreResult, Cloneable, Serializable {
     /*
      * TODO: Might be nice to get as many of the internal use only methods out
      * of here so users never even see them. Example: we could set the ETag
@@ -50,16 +49,17 @@
      * Custom user metadata, represented in responses with the x-amz-meta-
      * header prefix
      */
-    private Map<String, String> userMetadata = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);
+    private Map<String, String> userMetadata = new TreeMap<String, String>(
+            String.CASE_INSENSITIVE_ORDER);
 
     /**
      * All other (non user custom) headers such as Content-Length, Content-Type,
      * etc.
      */
-    private Map<String, Object> metadata = new TreeMap<String, Object>(String.CASE_INSENSITIVE_ORDER);
+    private Map<String, Object> metadata = new TreeMap<String, Object>(
+            String.CASE_INSENSITIVE_ORDER);
 
-    public static final String AES_256_SERVER_SIDE_ENCRYPTION =
-            SSEAlgorithm.AES256.getAlgorithm();
+    public static final String AES_256_SERVER_SIDE_ENCRYPTION = SSEAlgorithm.AES256.getAlgorithm();
 
     public static final String KMS_SERVER_SIDE_ENCRYPTION = SSEAlgorithm.KMS.getAlgorithm();
 
@@ -94,16 +94,18 @@
      * accessed. Null if this object has not been restored from Glacier.
      */
     private Date restoreExpirationTime;
-    public ObjectMetadata() {}
+
+    public ObjectMetadata() {
+    }
 
     private ObjectMetadata(ObjectMetadata from) {
         this.userMetadata = from.userMetadata == null
-            ? null
-            : new TreeMap<String,String>(from.userMetadata);
+                ? null
+                : new TreeMap<String, String>(from.userMetadata);
         // shallow clone the metadata data
         this.metadata = from.metadata == null
-            ? null
-            : new TreeMap<String, Object>(from.metadata);
+                ? null
+                : new TreeMap<String, Object>(from.metadata);
         this.expirationTime = cloneDate(from.expirationTime);
         this.expirationTimeRuleId = from.expirationTimeRuleId;
         this.httpExpiresDate = cloneDate(from.httpExpiresDate);
@@ -136,7 +138,6 @@ private ObjectMetadata(ObjectMetadata from) {
      * </p>
      *
      * @return The custom user metadata for the associated object.
-     *
      * @see ObjectMetadata#setUserMetadata(Map)
      * @see ObjectMetadata#addUserMetadata(String, String)
      */
@@ -227,7 +228,7 @@ public void addUserMetadata(String key, String value) {
      * @return A map of the raw metadata/headers for the associated object.
      */
     public Map<String, Object> getRawMetadata() {
-        final Map<String,Object> copy = new TreeMap<String,Object>(String.CASE_INSENSITIVE_ORDER);
+        final Map<String, Object> copy = new TreeMap<String, Object>(String.CASE_INSENSITIVE_ORDER);
         copy.putAll(metadata);
         return Collections.unmodifiableMap(copy);
     }
@@ -277,8 +278,8 @@ public void setLastModified(Date lastModified) {
      * content length before sending the data to Amazon S3.
      * </p>
      * <p>
-     * For more information on the Content-Length HTTP header, see <a
-     * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13">
+     * For more information on the Content-Length HTTP header, see <a href=
+     * "http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13">
      * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13</a>
      * </p>
      *
@@ -326,8 +327,8 @@ public long getInstanceLength() {
      * content length before sending the data to Amazon S3.
      * </p>
      * <p>
-     * For more information on the Content-Length HTTP header, see <a
-     * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13">
+     * For more information on the Content-Length HTTP header, see <a href=
+     * "http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13">
      * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13</a>
      * </p>
      *
@@ -354,8 +355,8 @@ public void setContentLength(long contentLength) {
      * used.
      * </p>
      * <p>
-     * For more information on the Content-Type header, see <a
-     * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">
+     * For more information on the Content-Type header, see <a href=
+     * "http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">
      * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17</a>
      * </p>
      *
@@ -383,8 +384,8 @@ public String getContentType() {
      * used.
      * </p>
      * <p>
-     * For more information on the Content-Type header, see <a
-     * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">
+     * For more information on the Content-Type header, see <a href=
+     * "http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">
      * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17</a>
      * </p>
      *
@@ -398,40 +399,38 @@ public void setContentType(String contentType) {
 
     /**
      * <p>
-     * Gets the Content-Language HTTP header, which describes the natural language(s) of the
-     * intended audience for the enclosed entity.
+     * Gets the Content-Language HTTP header, which describes the natural
+     * language(s) of the intended audience for the enclosed entity.
      * </p>
      * <p>
-     * For more information on the Content-Type header, see <a
-     * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">
+     * For more information on the Content-Type header, see <a href=
+     * "http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">
      * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17</a>
      * </p>
      *
-     * @return The HTTP Content-Language header, which describes the natural language(s) of the
-     * intended audience for the enclosed entity. Returns <code>null</code>
-     *         if it hasn't been set.
-     *
+     * @return The HTTP Content-Language header, which describes the natural
+     *         language(s) of the intended audience for the enclosed entity.
+     *         Returns <code>null</code> if it hasn't been set.
      * @see ObjectMetadata#setContentLanguage(String)
      */
     public String getContentLanguage() {
-        return (String)metadata.get(Headers.CONTENT_LANGUAGE);
+        return (String) metadata.get(Headers.CONTENT_LANGUAGE);
     }
 
     /**
      * <p>
-     * Sets the Content-Language HTTP header which describes the natural language(s) of the
-     * intended audience for the enclosed entity.
+     * Sets the Content-Language HTTP header which describes the natural
+     * language(s) of the intended audience for the enclosed entity.
      * </p>
      * <p>
-     * For more information on the Content-Type header, see <a
-     * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">
+     * For more information on the Content-Type header, see <a href=
+     * "http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">
      * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17</a>
      * </p>
      *
-     * @param contentLanguage
-     *            The HTTP Content-Language header which describes the natural language(s) of the
-     * intended audience for the enclosed entity.
-     *
+     * @param contentLanguage The HTTP Content-Language header which describes
+     *            the natural language(s) of the intended audience for the
+     *            enclosed entity.
      * @see ObjectMetadata#getContentLanguage()
      */
     public void setContentLanguage(String contentLanguage) {
@@ -447,8 +446,8 @@ public void setContentLanguage(String contentLanguage) {
      * </p>
      * <p>
      * For more information on how the Content-Encoding HTTP header works, see
-     * <a
-     * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">
+     * <a href=
+     * "http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">
      * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11</a>
      * </p>
      *
@@ -469,14 +468,14 @@ public String getContentEncoding() {
      * </p>
      * <p>
      * For more information on how the Content-Encoding HTTP header works, see
-     * <a
-     * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">
+     * <a href=
+     * "http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">
      * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11</a>
      * </p>
      *
      * @param encoding The HTTP Content-Encoding header, as defined in RFC 2616.
-     * @see <a
-     *      href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11"
+     * @see <a href=
+     *      "http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11"
      *      >http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11</a>
      * @see ObjectMetadata#getContentType()
      */
@@ -491,8 +490,8 @@ public void setContentEncoding(String encoding) {
      * </p>
      * <p>
      * For more information on how the Cache-Control HTTP header affects HTTP
-     * requests and responses, see <a
-     * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">
+     * requests and responses, see
+     * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">
      * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9</a>
      * </p>
      *
@@ -511,8 +510,8 @@ public String getCacheControl() {
      * </p>
      * <p>
      * For more information on how the Cache-Control HTTP header affects HTTP
-     * requests and responses see <a
-     * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">
+     * requests and responses see
+     * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">
      * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9</a>
      * </p>
      *
@@ -590,8 +589,8 @@ public String getContentMD5() {
      * </p>
      * <p>
      * For more information on how the Content-Disposition header affects HTTP
-     * client behavior, see <a
-     * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1">
+     * client behavior, see <a href=
+     * "http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1">
      * http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1</a>
      * </p>
      *
@@ -610,16 +609,16 @@ public void setContentDisposition(String disposition) {
      * </p>
      * <p>
      * For more information on how the Content-Disposition header affects HTTP
-     * client behavior, see <a
-     * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1">
+     * client behavior, see <a href=
+     * "http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1">
      * http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1</a>
      * </p>
      *
      * @return The value of the Content-Disposition header. Returns
      *         <code>null</code> if the Content-Disposition header hasn't been
      *         set.
-     * @see <a
-     *      href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1"
+     * @see <a href=
+     *      "http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1"
      *      >http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1</a>
      * @see ObjectMetadata#setCacheControl(String)
      */
@@ -829,8 +828,8 @@ public Date getHttpExpiresDate() {
     }
 
     /**
-     * @return The storage class of the object. Returns null if the object is in STANDARD storage.
-     *         See {@link StorageClass} for possible values
+     * @return The storage class of the object. Returns null if the object is in
+     *         STANDARD storage. See {@link StorageClass} for possible values
      */
     public String getStorageClass() {
         final Object storageClass = metadata.get(Headers.STORAGE_CLASS);
@@ -839,10 +838,11 @@ public String getStorageClass() {
         }
         return storageClass.toString();
     }
-    
+
     /**
      * Sets the Amazon S3 storage class for the stored objects.
-     * @param storageClass The Amazon S3 storage class for the stored objects. 
+     * 
+     * @param storageClass The Amazon S3 storage class for the stored objects.
      */
     public void setStorageClass(StorageClass storageClass) {
         metadata.put(Headers.STORAGE_CLASS, storageClass);
@@ -892,13 +892,14 @@ public void setRequesterCharged(boolean isRequesterCharged) {
      * Returns the value of x-amz-mp-parts-count header.
      * </p>
      * <p>
-     * The x-amz-mp-parts-count header is returned in the response only when
-     * a valid partNumber is specified in the request and the object has more than 1 part.
+     * The x-amz-mp-parts-count header is returned in the response only when a
+     * valid partNumber is specified in the request and the object has more than
+     * 1 part.
      * </p>
      * <p>
-     * To find the part count of an object, set the partNumber to 1 in GetObjectRequest.
-     * If the object has more than 1 part then part count will be returned,
-     * otherwise null is returned.
+     * To find the part count of an object, set the partNumber to 1 in
+     * GetObjectRequest. If the object has more than 1 part then part count will
+     * be returned, otherwise null is returned.
      * </p>
      */
     public Integer getPartCount() {
@@ -907,15 +908,17 @@ public Integer getPartCount() {
 
     /**
      * <p>
-     * Returns the content range of the object if response contains the Content-Range header.
+     * Returns the content range of the object if response contains the
+     * Content-Range header.
      * </p>
      * <p>
-     * If the request specifies a range or part number, then response returns the Content-Range range header.
-     * Otherwise, the response does not return Content-Range header.
+     * If the request specifies a range or part number, then response returns
+     * the Content-Range range header. Otherwise, the response does not return
+     * Content-Range header.
      * </p>
-     * @return
-     * 		Returns content range if the object is requested with specific range or part number,
-     * 		null otherwise.
+     * 
+     * @return Returns content range if the object is requested with specific
+     *         range or part number, null otherwise.
      */
     public Long[] getContentRange() {
         final String contentRange = (String) metadata.get(Headers.CONTENT_RANGE);
@@ -923,10 +926,13 @@ public Integer getPartCount() {
         if (contentRange != null) {
             final String[] tokens = contentRange.split("[ -/]+");
             try {
-                range = new Long[] { Long.parseLong(tokens[1]), Long.parseLong(tokens[2]) };
+                range = new Long[] {
+                        Long.parseLong(tokens[1]), Long.parseLong(tokens[2])
+                };
             } catch (final NumberFormatException nfe) {
                 throw new AmazonClientException(
-                        "Unable to parse content range. Header 'Content-Range' has corrupted data" + nfe.getMessage(),
+                        "Unable to parse content range. Header 'Content-Range' has corrupted data"
+                                + nfe.getMessage(),
                         nfe);
             }
         }
@@ -935,7 +941,7 @@ public Integer getPartCount() {
 
     /**
      * @return The replication status of the object if it is from a bucket that
-     * is the source or destination in a cross-region replication.
+     *         is the source or destination in a cross-region replication.
      */
     public String getReplicationStatus() {
         return (String) metadata.get(Headers.OBJECT_REPLICATION_STATUS);
diff --git a/aws-android-sdk-s3/src/test/java/com/amazonaws/services/s3/model/ObjectMetadataTest.java b/aws-android-sdk-s3/src/test/java/com/amazonaws/services/s3/model/ObjectMetadataTest.java
index fecc0343dc..bbf22b21f6 100644
--- a/aws-android-sdk-s3/src/test/java/com/amazonaws/services/s3/model/ObjectMetadataTest.java
+++ b/aws-android-sdk-s3/src/test/java/com/amazonaws/services/s3/model/ObjectMetadataTest.java
@@ -1,3 +1,4 @@
+
 package com.amazonaws.services.s3.model;
 
 import static org.junit.Assert.assertEquals;
@@ -5,13 +6,13 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
-import java.util.Date;
-import java.util.HashMap;
-import java.util.Map;
+import com.amazonaws.services.s3.Headers;
 
 import org.junit.Test;
 
-import com.amazonaws.services.s3.Headers;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
 
 public class ObjectMetadataTest {
 
@@ -126,10 +127,10 @@ public void cloneNonEmpty() {
         assertTrue(9999 == to.getInstanceLength());
         assertEquals(lastModified, to.getLastModified());
         assertTrue(to.getOngoingRestore());
-        
+
         assertEquals(from.getRawMetadata(), to.getRawMetadata());
         assertNotSame(from.getRawMetadata(), to.getRawMetadata());
-        
+
         assertEquals(restoreExpirationTime, to.getRestoreExpirationTime());
         assertEquals("ssealgo", to.getSSEAlgorithm());
         assertEquals("SSECustomerAlgorithm", to.getSSECustomerAlgorithm());
@@ -137,7 +138,7 @@ public void cloneNonEmpty() {
 
         assertEquals(from.getUserMetadata(), to.getUserMetadata());
         assertNotSame(from.getUserMetadata(), to.getUserMetadata());
-        
+
         assertEquals("versionid", to.getVersionId());
         assertEquals(from.getStorageClass(), to.getStorageClass());
     }
