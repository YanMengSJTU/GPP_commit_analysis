diff --git a/.classpath b/.classpath
new file mode 100644
index 0000000000..e32cbfdaa3
--- /dev/null
+++ b/.classpath
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="aws-android-sdk-cognitoidentityprovider/src/main/java"/>
+	<classpathentry kind="src" path="aws-android-sdk-core/src/main/java"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/.project b/.project
new file mode 100644
index 0000000000..a649463cae
--- /dev/null
+++ b/.project
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>aws-sdk-android</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.ManifestBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.SchemaBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.pde.PluginNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/.settings/org.eclipse.jdt.core.prefs b/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000000..0c68a61dca
--- /dev/null
+++ b/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,7 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
+org.eclipse.jdt.core.compiler.compliance=1.8
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.8
diff --git a/META-INF/MANIFEST.MF b/META-INF/MANIFEST.MF
new file mode 100644
index 0000000000..a8bb1c2276
--- /dev/null
+++ b/META-INF/MANIFEST.MF
@@ -0,0 +1,32 @@
+Manifest-Version: 1.0
+Bundle-ManifestVersion: 2
+Bundle-Name: Aws-sdk-android
+Bundle-SymbolicName: aws-sdk-android
+Bundle-Version: 1.0.0.qualifier
+Bundle-RequiredExecutionEnvironment: JavaSE-1.8
+Import-Package: com.fasterxml.jackson.core;version="2.4.5",
+ com.google.gson.stream,
+ org.apache.commons.logging;version="1.1.1",
+ org.apache.http;version="4.3.3",
+ org.apache.http.auth;version="4.3.6",
+ org.apache.http.client;version="4.3.6",
+ org.apache.http.client.methods;version="4.3.6",
+ org.apache.http.client.params;version="4.3.6",
+ org.apache.http.conn;version="4.3.4",
+ org.apache.http.conn.params;version="4.3.4",
+ org.apache.http.conn.scheme;version="4.3.6",
+ org.apache.http.conn.ssl;version="4.3.6",
+ org.apache.http.entity;version="4.3.3",
+ org.apache.http.impl.client;version="4.3.6",
+ org.apache.http.impl.conn.tsccm;version="4.3.6",
+ org.apache.http.params;version="4.3.3",
+ org.apache.http.protocol;version="4.3.3",
+ org.eclipse.swt.widgets,
+ org.json
+Export-Package: com.amazonaws.adroid.utils,
+ com.amazonaws.mobileconnectors.cognitoidentityprovider,
+ com.amazonaws.mobileconnectors.cognitoidentityprovider.continuations,
+ com.amazonaws.mobileconnectors.cognitoidentityprovider.exceptions,
+ com.amazonaws.mobileconnectors.cognitoidentityprovider.handlers,
+ com.amazonaws.mobileconnectors.cognitoidentityprovider.tokens,
+ com.amazonaws.mobileconnectors.cognitoidentityprovider.util
diff --git a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/CognitoDevice.java b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/CognitoDevice.java
index 2eba7b386a..de55f349c7 100644
--- a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/CognitoDevice.java
+++ b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/CognitoDevice.java
@@ -17,9 +17,11 @@
 
 package com.amazonaws.mobileconnectors.cognitoidentityprovider;
 
-import android.content.Context;
-import android.os.Handler;
+import java.util.Date;
+
+import org.eclipse.swt.widgets.Display;
 
+import com.amazonaws.adroid.utils.Context;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.exceptions.CognitoInternalErrorException;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.exceptions.CognitoNotAuthorizedException;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.exceptions.CognitoParameterInvalidException;
@@ -31,12 +33,10 @@
 import com.amazonaws.services.cognitoidentityprovider.model.UpdateDeviceStatusRequest;
 import com.amazonaws.services.cognitoidentityprovider.model.UpdateDeviceStatusResult;
 
-import java.util.Date;
-
 /**
- * This class is an abstraction for a tracked device. A instance of this class represents one
- * tracked device and encapsulates all details for that device. This class provides methods to access
- * the device details. The device attributes are stored as an object of {@link CognitoUserAttributes}.
+ * This class is an abstraction for a tracked device. A instance of this class represents one tracked device and
+ * encapsulates all details for that device. This class provides methods to access the device details. The device
+ * attributes are stored as an object of {@link CognitoUserAttributes}.
  */
 public class CognitoDevice {
 
@@ -82,15 +82,23 @@
     /**
      * Constructs an object of type {@link CognitoDevice} with device details.
      *
-     * @param deviceKey                 REQUIRED: The device key.
-     * @param deviceAttributes          REQUIRED: All devices attributes, stored as a {@link CognitoUserAttributes} object.
-     * @param createDate                REQUIRED: The date when the device tracking last began.
-     * @param lastModifiedDate          REQUIRED: The date on which the device attributes were last modified.
-     * @param lastAccessedDate          REQUIRED: The date this device details were last read.
-     * @param user                      REQUIRED: The {@link CognitoUser} this device is linked to.
-     * @param context                   REQUIRED: App context.
+     * @param deviceKey
+     *            REQUIRED: The device key.
+     * @param deviceAttributes
+     *            REQUIRED: All devices attributes, stored as a {@link CognitoUserAttributes} object.
+     * @param createDate
+     *            REQUIRED: The date when the device tracking last began.
+     * @param lastModifiedDate
+     *            REQUIRED: The date on which the device attributes were last modified.
+     * @param lastAccessedDate
+     *            REQUIRED: The date this device details were last read.
+     * @param user
+     *            REQUIRED: The {@link CognitoUser} this device is linked to.
+     * @param context
+     *            REQUIRED: App context.
      */
-    public CognitoDevice(String deviceKey, CognitoUserAttributes deviceAttributes, Date createDate, Date lastModifiedDate, Date lastAccessedDate, CognitoUser user, Context context) {
+    public CognitoDevice(String deviceKey, CognitoUserAttributes deviceAttributes, Date createDate,
+                         Date lastModifiedDate, Date lastAccessedDate, CognitoUser user, Context context) {
         this.deviceKey = deviceKey;
         this.deviceAttributes = deviceAttributes;
         this.createDate = createDate;
@@ -103,9 +111,12 @@ public CognitoDevice(String deviceKey, CognitoUserAttributes deviceAttributes, D
     /**
      * Constructs a {@link CognitoDevice} object with {@link DeviceType} object.
      *
-     * @param device                    REQUIRED: A {@link DeviceType} object.
-     * @param user                      REQUIRED: The {@link CognitoUser} this device is linked to.
-     * @param context                   REQUIRED: App context.
+     * @param device
+     *            REQUIRED: A {@link DeviceType} object.
+     * @param user
+     *            REQUIRED: The {@link CognitoUser} this device is linked to.
+     * @param context
+     *            REQUIRED: App context.
      */
     public CognitoDevice(DeviceType device, CognitoUser user, Context context) {
         this.deviceKey = device.getDeviceKey();
@@ -123,7 +134,7 @@ public CognitoDevice(DeviceType device, CognitoUser user, Context context) {
      * @return device key.
      */
     public String getDeviceKey() {
-        return deviceKey;
+        return this.deviceKey;
     }
 
     /**
@@ -132,19 +143,21 @@ public String getDeviceKey() {
      * @return device attributes as an {@link CognitoUserAttributes} object.
      */
     public CognitoUserAttributes getDeviceAttributes() {
-        return deviceAttributes;
+        return this.deviceAttributes;
     }
 
     /**
-     * Returns the value assigned for a specific attribute for this device. The attribute name is
-     * passed as a string. Returns null if this attribute is not set for this device.
+     * Returns the value assigned for a specific attribute for this device. The attribute name is passed as a string.
+     * Returns null if this attribute is not set for this device.
      *
-     * @param attributeName             REQUIRED: The name of the attribute whose value is needed.
-     * @return value associated with the passed attribute name as a string, returns null if the attribute does not have any value set.
+     * @param attributeName
+     *            REQUIRED: The name of the attribute whose value is needed.
+     * @return value associated with the passed attribute name as a string, returns null if the attribute does not have
+     *         any value set.
      */
     public String getDeviceAttribute(String attributeName) {
         try {
-            return deviceAttributes.getAttributes().get(attributeName);
+            return this.deviceAttributes.getAttributes().get(attributeName);
         } catch (final Exception e) {
             return null;
         }
@@ -156,17 +169,17 @@ public String getDeviceAttribute(String attributeName) {
      * @return Name of the device.
      */
     public String getDeviceName() {
-        return getDeviceAttribute(DEVICE_NAME_ATTRIBUTE);
+        return getDeviceAttribute(this.DEVICE_NAME_ATTRIBUTE);
     }
 
     /**
-     * Returns the date this device was created in the Cognito User Pools, that is the date when the
-     * service started tracking this device.
+     * Returns the date this device was created in the Cognito User Pools, that is the date when the service started
+     * tracking this device.
      *
      * @return the date when the device tracking began.
      */
     public Date getCreateDate() {
-        return createDate;
+        return this.createDate;
     }
 
     /**
@@ -175,7 +188,7 @@ public Date getCreateDate() {
      * @return the date when the device attributes were last modified.
      */
     public Date getLastModifiedDate() {
-        return lastModifiedDate;
+        return this.lastModifiedDate;
     }
 
     /**
@@ -184,26 +197,26 @@ public Date getLastModifiedDate() {
      * @return the date when the device details were last read.
      */
     public Date getLastAccessedDate() {
-        return lastAccessedDate;
+        return this.lastAccessedDate;
     }
 
     /**
-     * Fetches device properties. Call this method to ensure the device properties are current.
-     * Reading device properties from this object can return null values.
+     * Fetches device properties. Call this method to ensure the device properties are current. Reading device
+     * properties from this object can return null values.
      *
-     * @param callback              REQUIRED: {@link GenericHandler} callback.
+     * @param callback
+     *            REQUIRED: {@link GenericHandler} callback.
      */
     public void getDeviceInBackground(final GenericHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
         new Thread(new Runnable() {
             @Override
             public void run() {
-                final Handler handler = new Handler(context.getMainLooper());
                 Runnable returnCallback;
                 try {
-                    final GetDeviceResult getDeviceResult = getDeviceInternal(user.getCachedSession());
+                    final GetDeviceResult getDeviceResult =
+                        getDeviceInternal(CognitoDevice.this.user.getCachedSession());
                     updateThis(getDeviceResult.getDevice());
                     returnCallback = new Runnable() {
                         @Override
@@ -219,7 +232,7 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -228,20 +241,20 @@ public void run() {
      * Fetches device properties, in the current thread. Call this method to ensure the device properties are current.
      * Reading device properties from this object can return null values.
      *
-     *  <p>
-     *     <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * <p>
+     * <b>Note:</b> This method will perform network operations. Calling this method in applications' main thread will
+     * cause Android to throw NetworkOnMainThreadException.
      * </p>
      *
-     * @param callback              REQUIRED: {@link GenericHandler} callback.
+     * @param callback
+     *            REQUIRED: {@link GenericHandler} callback.
      */
     public void getDevice(GenericHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
 
         try {
-            final GetDeviceResult getDeviceResult = getDeviceInternal(user.getCachedSession());
+            final GetDeviceResult getDeviceResult = getDeviceInternal(this.user.getCachedSession());
             updateThis(getDeviceResult.getDevice());
             callback.onSuccess();
         } catch (final Exception e) {
@@ -252,19 +265,18 @@ public void getDevice(GenericHandler callback) {
     /**
      * Stops tracking this device, runs in a background thread.
      *
-     * @param callback              REQUIRED: {@link GenericHandler} callback.
+     * @param callback
+     *            REQUIRED: {@link GenericHandler} callback.
      */
     public void forgetDeviceInBackground(final GenericHandler callback) {
-        if (callback == null) {
-            throw  new CognitoParameterInvalidException("callback is null");
-        }
+        if (callback == null)
+            throw new CognitoParameterInvalidException("callback is null");
         new Thread(new Runnable() {
             @Override
             public void run() {
-                final Handler handler = new Handler(context.getMainLooper());
                 Runnable returnCallback;
                 try {
-                    forgetDeviceInternal(user.getCachedSession());
+                    forgetDeviceInternal(CognitoDevice.this.user.getCachedSession());
                     returnCallback = new Runnable() {
                         @Override
                         public void run() {
@@ -279,7 +291,7 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -287,18 +299,18 @@ public void run() {
     /**
      * Stops tracking this device, runs in the current thread.
      * <p>
-     *     <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * <b>Note:</b> This method will perform network operations. Calling this method in applications' main thread will
+     * cause Android to throw NetworkOnMainThreadException.
      * </p>
      *
-     * @param callback              REQUIRED: {@link GenericHandler} callback.
+     * @param callback
+     *            REQUIRED: {@link GenericHandler} callback.
      */
     public void forgetDevice(GenericHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
         try {
-            forgetDeviceInternal(user.getCachedSession());
+            forgetDeviceInternal(this.user.getCachedSession());
             callback.onSuccess();
         } catch (final Exception e) {
             callback.onFailure(e);
@@ -308,19 +320,19 @@ public void forgetDevice(GenericHandler callback) {
     /**
      * Marks this device as trusted, runs in a background.
      *
-     * @param callback              REQUIRED: {@link GenericHandler} callback.
+     * @param callback
+     *            REQUIRED: {@link GenericHandler} callback.
      */
     public void rememberThisDeviceInBackground(final GenericHandler callback) {
-        if (callback == null) {
-            throw  new CognitoParameterInvalidException("callback is null");
-        }
+        if (callback == null)
+            throw new CognitoParameterInvalidException("callback is null");
         new Thread(new Runnable() {
             @Override
             public void run() {
-                final Handler handler = new Handler(context.getMainLooper());
                 Runnable returnCallback;
                 try {
-                    updateDeviceStatusInternal(user.getCachedSession(), DEVICE_TYPE_REMEMBERED);
+                    updateDeviceStatusInternal(CognitoDevice.this.user.getCachedSession(),
+                                               CognitoDevice.this.DEVICE_TYPE_REMEMBERED);
                     returnCallback = new Runnable() {
                         @Override
                         public void run() {
@@ -335,27 +347,27 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
 
     /**
      * Marks this device as trusted, runs in the current thread.
-     *  <p>
-     *     <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * <p>
+     * <b>Note:</b> This method will perform network operations. Calling this method in applications' main thread will
+     * cause Android to throw NetworkOnMainThreadException.
      * </p>
      *
-     * @param callback              REQUIRED: {@link GenericHandler} callback.
+     * @param callback
+     *            REQUIRED: {@link GenericHandler} callback.
      */
     public void rememberThisDevice(GenericHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
 
         try {
-            updateDeviceStatusInternal(user.getCachedSession(), DEVICE_TYPE_REMEMBERED);
+            updateDeviceStatusInternal(this.user.getCachedSession(), this.DEVICE_TYPE_REMEMBERED);
         } catch (final Exception e) {
             callback.onFailure(e);
         }
@@ -364,20 +376,20 @@ public void rememberThisDevice(GenericHandler callback) {
     /**
      * Marks this device as <b>not</b> trusted, runs in a background thread.
      *
-     * @param callback              REQUIRED: {@link GenericHandler} callback.
+     * @param callback
+     *            REQUIRED: {@link GenericHandler} callback.
      */
     public void doNotRememberThisDeviceInBackground(final GenericHandler callback) {
-        if (callback == null) {
-            throw  new CognitoParameterInvalidException("callback is null");
-        }
+        if (callback == null)
+            throw new CognitoParameterInvalidException("callback is null");
 
         new Thread(new Runnable() {
             @Override
             public void run() {
-                final Handler handler = new Handler(context.getMainLooper());
                 Runnable returnCallback;
                 try {
-                    updateDeviceStatusInternal(user.getCachedSession(), DEVICE_TYPE_NOT_REMEMBERED);
+                    updateDeviceStatusInternal(CognitoDevice.this.user.getCachedSession(),
+                                               CognitoDevice.this.DEVICE_TYPE_NOT_REMEMBERED);
                     returnCallback = new Runnable() {
                         @Override
                         public void run() {
@@ -392,7 +404,7 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -400,18 +412,18 @@ public void run() {
     /**
      * Marks this device as <b>not</b> trusted, runs in the current thread.
      * <p>
-     *     <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * <b>Note:</b> This method will perform network operations. Calling this method in applications' main thread will
+     * cause Android to throw NetworkOnMainThreadException.
      * </p>
      *
-     * @param callback              REQUIRED: {@link GenericHandler} callback.
+     * @param callback
+     *            REQUIRED: {@link GenericHandler} callback.
      */
     public void doNotRememberThisDevice(GenericHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
         try {
-            updateDeviceStatusInternal(user.getCachedSession(), DEVICE_TYPE_NOT_REMEMBERED);
+            updateDeviceStatusInternal(this.user.getCachedSession(), this.DEVICE_TYPE_NOT_REMEMBERED);
         } catch (final Exception e) {
             callback.onFailure(e);
         }
@@ -420,83 +432,80 @@ public void doNotRememberThisDevice(GenericHandler callback) {
     /**
      * Internal method to forget this device.
      *
-     * @param session              REQUIRED: A valid {@link CognitoUserSession}.
+     * @param session
+     *            REQUIRED: A valid {@link CognitoUserSession}.
      */
     private void forgetDeviceInternal(CognitoUserSession session) {
-        if (session != null && session.isValid()) {
+        if ((session != null) && session.isValid()) {
             if (this.deviceKey != null) {
-                final CognitoDevice currentDeviceKey = user.thisDevice();
+                final CognitoDevice currentDeviceKey = this.user.thisDevice();
                 if (this.deviceKey.equals(currentDeviceKey.getDeviceKey())) {
                     // CognitoDeviceHelper.clearCachedDevice(user.context);
                 }
                 final ForgetDeviceRequest forgetDeviceRequest = new ForgetDeviceRequest();
                 forgetDeviceRequest.setAccessToken(session.getAccessToken().getJWTToken());
                 forgetDeviceRequest.setDeviceKey(this.deviceKey);
-                user.getCognitoIdentityProviderClient().forgetDevice(forgetDeviceRequest);
-            } else {
+                this.user.getCognitoIdentityProviderClient().forgetDevice(forgetDeviceRequest);
+            } else
                 throw new CognitoParameterInvalidException("Device key is null");
-            }
-        } else {
+        } else
             throw new CognitoNotAuthorizedException("User is not authorized");
-        }
     }
 
     /**
      * Internal method to fetch device details.
      *
-     * @param session              REQUIRED: A valid {@link CognitoUserSession}.
+     * @param session
+     *            REQUIRED: A valid {@link CognitoUserSession}.
      * @return
      */
     private GetDeviceResult getDeviceInternal(CognitoUserSession session) {
-        if (session != null && session.isValid()) {
+        if ((session != null) && session.isValid()) {
             if (this.deviceKey != null) {
                 final GetDeviceRequest getDeviceRequest = new GetDeviceRequest();
                 getDeviceRequest.setAccessToken(session.getAccessToken().getJWTToken());
                 getDeviceRequest.setDeviceKey(this.deviceKey);
-                return user.getCognitoIdentityProviderClient().getDevice(getDeviceRequest);
-            } else {
+                return this.user.getCognitoIdentityProviderClient().getDevice(getDeviceRequest);
+            } else
                 throw new CognitoParameterInvalidException("Device key is null");
-            }
-        } else {
+        } else
             throw new CognitoNotAuthorizedException("User is not authorized");
-        }
     }
 
     /**
      * Internal method to set device status.
      *
-     * @param session              REQUIRED: A valid {@link CognitoUserSession}.
-     * @param deviceTrustState     REQUIRED: New status of the device.
+     * @param session
+     *            REQUIRED: A valid {@link CognitoUserSession}.
+     * @param deviceTrustState
+     *            REQUIRED: New status of the device.
      * @return
      */
     private UpdateDeviceStatusResult updateDeviceStatusInternal(CognitoUserSession session, String deviceTrustState) {
-        if (session != null && session.isValid()) {
+        if ((session != null) && session.isValid()) {
             if (this.deviceKey != null) {
                 final UpdateDeviceStatusRequest updateDeviceStatusRequest = new UpdateDeviceStatusRequest();
                 updateDeviceStatusRequest.setAccessToken(session.getAccessToken().getJWTToken());
                 updateDeviceStatusRequest.setDeviceKey(this.deviceKey);
                 updateDeviceStatusRequest.setDeviceRememberedStatus(deviceTrustState);
-                return user.getCognitoIdentityProviderClient().updateDeviceStatus(updateDeviceStatusRequest);
-            } else {
+                return this.user.getCognitoIdentityProviderClient().updateDeviceStatus(updateDeviceStatusRequest);
+            } else
                 throw new CognitoParameterInvalidException("Device key is invalid");
-            }
-        } else {
+        } else
             throw new CognitoNotAuthorizedException("User is not authorized");
-        }
     }
 
     /**
      * Internal method to update this object.
      *
-     * @param device                REQUIRED: {@link DeviceType} returned from the service.
+     * @param device
+     *            REQUIRED: {@link DeviceType} returned from the service.
      */
     private void updateThis(DeviceType device) {
-        if (device == null) {
+        if (device == null)
             throw new CognitoInternalErrorException("Service returned null object, this object was not updated");
-        }
-        if (!device.getDeviceKey().equals(this.deviceKey)) {
+        if (!device.getDeviceKey().equals(this.deviceKey))
             throw new CognitoInternalErrorException("Service error, this object was not updated");
-        }
         this.deviceAttributes = new CognitoUserAttributes(device.getDeviceAttributes());
         this.lastModifiedDate = device.getDeviceLastModifiedDate();
         this.lastAccessedDate = device.getDeviceLastModifiedDate();
diff --git a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/CognitoUser.java b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/CognitoUser.java
index 838ff5764c..58803d6242 100644
--- a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/CognitoUser.java
+++ b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/CognitoUser.java
@@ -17,12 +17,28 @@
 
 package com.amazonaws.mobileconnectors.cognitoidentityprovider;
 
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.os.Handler;
-import android.util.Log;
+import java.math.BigInteger;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.security.SecureRandom;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.SimpleTimeZone;
+
+import javax.crypto.Mac;
+import javax.crypto.spec.SecretKeySpec;
+
+import org.eclipse.swt.widgets.Display;
 
 import com.amazonaws.AmazonServiceException;
+import com.amazonaws.adroid.utils.Context;
+import com.amazonaws.adroid.utils.Log;
+import com.amazonaws.adroid.utils.SharedPreferences;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.continuations.AuthenticationContinuation;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.continuations.AuthenticationDetails;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.continuations.ChallengeContinuation;
@@ -53,12 +69,13 @@
 import com.amazonaws.services.cognitoidentityprovider.model.CodeDeliveryDetailsType;
 import com.amazonaws.services.cognitoidentityprovider.model.ConfirmDeviceRequest;
 import com.amazonaws.services.cognitoidentityprovider.model.ConfirmDeviceResult;
-import com.amazonaws.services.cognitoidentityprovider.model.ConfirmSignUpRequest;
 import com.amazonaws.services.cognitoidentityprovider.model.ConfirmForgotPasswordRequest;
+import com.amazonaws.services.cognitoidentityprovider.model.ConfirmSignUpRequest;
 import com.amazonaws.services.cognitoidentityprovider.model.DeleteUserAttributesRequest;
 import com.amazonaws.services.cognitoidentityprovider.model.DeleteUserRequest;
 import com.amazonaws.services.cognitoidentityprovider.model.DeviceSecretVerifierConfigType;
 import com.amazonaws.services.cognitoidentityprovider.model.DeviceType;
+import com.amazonaws.services.cognitoidentityprovider.model.ForgotPasswordRequest;
 import com.amazonaws.services.cognitoidentityprovider.model.ForgotPasswordResult;
 import com.amazonaws.services.cognitoidentityprovider.model.GetUserAttributeVerificationCodeRequest;
 import com.amazonaws.services.cognitoidentityprovider.model.GetUserAttributeVerificationCodeResult;
@@ -73,7 +90,6 @@
 import com.amazonaws.services.cognitoidentityprovider.model.NewDeviceMetadataType;
 import com.amazonaws.services.cognitoidentityprovider.model.NotAuthorizedException;
 import com.amazonaws.services.cognitoidentityprovider.model.ResendConfirmationCodeRequest;
-import com.amazonaws.services.cognitoidentityprovider.model.ForgotPasswordRequest;
 import com.amazonaws.services.cognitoidentityprovider.model.ResendConfirmationCodeResult;
 import com.amazonaws.services.cognitoidentityprovider.model.ResourceNotFoundException;
 import com.amazonaws.services.cognitoidentityprovider.model.RespondToAuthChallengeRequest;
@@ -87,29 +103,12 @@
 import com.amazonaws.util.Base64;
 import com.amazonaws.util.StringUtils;
 
-import java.io.IOException;
-import java.math.BigInteger;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.security.SecureRandom;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.SimpleTimeZone;
-
-import javax.crypto.Mac;
-import javax.crypto.spec.SecretKeySpec;
-
 /**
  * Represents a single Cognito User.
  * <p>
- *     This class encapsulates all operations possible on a user and all tokens belonging to the user.
- *     The user tokens, as {@link CognitoUserSession}, are stored in SharedPreferences. Only the tokens
- *     belonging to the last successfully authenticated user are stored.
+ * This class encapsulates all operations possible on a user and all tokens belonging to the user. The user tokens, as
+ * {@link CognitoUserSession}, are stored in SharedPreferences. Only the tokens belonging to the last successfully
+ * authenticated user are stored.
  * </p>
  */
 public class CognitoUser {
@@ -131,14 +130,14 @@
     private final String clientId;
 
     /**
-     * Client secret generated for this {@code clientId}, this may be {@code null} if a secret is not
-     * generated for the {@code clientId}.
+     * Client secret generated for this {@code clientId}, this may be {@code null} if a secret is not generated for the
+     * {@code clientId}.
      */
     private final String clientSecret;
-    
+
     /**
-     * userId for this user, this is mutable to allow the userId to be set during authentication.
-     * This can be the username (users' unique sign-in username) or an alias (if available, such as email or phone number).
+     * userId for this user, this is mutable to allow the userId to be set during authentication. This can be the
+     * username (users' unique sign-in username) or an alias (if available, such as email or phone number).
      */
     private String userId;
 
@@ -151,11 +150,11 @@
      * Device-key of this device, if available.
      */
     private String deviceKey;
-    
+
     /**
      * Reference to the {@link CognitoUserPool} to which this user belongs .
      */
-    private CognitoUserPool pool;
+    private final CognitoUserPool pool;
 
     /**
      * Secret-Hash for this user-pool, this is mutable because userId is mutable.
@@ -170,16 +169,22 @@
     /**
      * Constructs a new Cognito User from a Cognito user identity pool {@link CognitoUserPool} and userId.
      *
-     * @param pool              REQUIRED: Reference to {@link CognitoUserPool}, to which this user belongs.
-     * @param userId            REQUIRED: userId of this user.
-     * @param clientId			REQUIRED: Client-Id of the android app.
-     * @param clientSecret      REQUIRED: Client secret assigned for this Client-Id.
-     * @param secretHash		REQUIRED: Secret-Hash, calculated for this android app.
-     * @param client			REQUIRED: Low level android client.
-     * @param context			REQUIRED: Application context.
-     */
-    protected CognitoUser(CognitoUserPool pool, String userId,
-                          String clientId, String clientSecret, String secretHash,
+     * @param pool
+     *            REQUIRED: Reference to {@link CognitoUserPool}, to which this user belongs.
+     * @param userId
+     *            REQUIRED: userId of this user.
+     * @param clientId
+     *            REQUIRED: Client-Id of the android app.
+     * @param clientSecret
+     *            REQUIRED: Client secret assigned for this Client-Id.
+     * @param secretHash
+     *            REQUIRED: Secret-Hash, calculated for this android app.
+     * @param client
+     *            REQUIRED: Low level android client.
+     * @param context
+     *            REQUIRED: Application context.
+     */
+    protected CognitoUser(CognitoUserPool pool, String userId, String clientId, String clientSecret, String secretHash,
                           AmazonCognitoIdentityProvider client, Context context) {
         this.pool = pool;
         this.context = context;
@@ -189,7 +194,7 @@ protected CognitoUser(CognitoUserPool pool, String userId,
         this.clientSecret = clientSecret;
         this.secretHash = secretHash;
         this.deviceKey = null;
-        cipSession = null;
+        this.cipSession = null;
     }
 
     /**
@@ -198,7 +203,7 @@ protected CognitoUser(CognitoUserPool pool, String userId,
      * @return userId.
      */
     public String getUserId() {
-        return userId;
+        return this.userId;
     }
 
     /**
@@ -207,7 +212,7 @@ public String getUserId() {
      * @return pool Id.
      */
     public String getUserPoolId() {
-        return pool.getUserPoolId();
+        return this.pool.getUserPoolId();
     }
 
     /**
@@ -216,31 +221,31 @@ public String getUserPoolId() {
      * @return
      */
     protected AmazonCognitoIdentityProvider getCognitoIdentityProviderClient() {
-        return cognitoIdentityProviderClient;
+        return this.cognitoIdentityProviderClient;
     }
 
     /**
      * Confirms user registration in background.
      * <p>
-     *     Confirming a user is required to complete the user's registration. Any other operations on a user.
-     *     are possible only after registration confirmation.
+     * Confirming a user is required to complete the user's registration. Any other operations on a user. are possible
+     * only after registration confirmation.
      * </p>
      *
-     * @param confirmationCode      REQUIRED: Code sent to the phone-number or email used to register the user.
-     * @param forcedAliasCreation   REQUIRED: This flag indicates if the confirmation should go-through in case of
-     *                              parameter contentions.
-     * @param callback              REQUIRED: This is a reference to {@link GenericHandler} callback handler.
-     */
-    public void confirmSignUpInBackground(final String confirmationCode,
-                                          final boolean forcedAliasCreation,
+     * @param confirmationCode
+     *            REQUIRED: Code sent to the phone-number or email used to register the user.
+     * @param forcedAliasCreation
+     *            REQUIRED: This flag indicates if the confirmation should go-through in case of parameter contentions.
+     * @param callback
+     *            REQUIRED: This is a reference to {@link GenericHandler} callback handler.
+     */
+    public void confirmSignUpInBackground(final String confirmationCode, final boolean forcedAliasCreation,
                                           final GenericHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Handler handler = new Handler(context.getMainLooper());
+
                 Runnable returnCallback;
                 try {
                     confirmSignUpInternal(confirmationCode, forcedAliasCreation);
@@ -258,7 +263,7 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -266,23 +271,21 @@ public void run() {
     /**
      * Confirms user registration in current thread.
      * <p>
-     *     Confirming a user is required to complete the user's registration. Any other operations on a user
-     *     are possible only after registration confirmation.
-     *     <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * Confirming a user is required to complete the user's registration. Any other operations on a user are possible
+     * only after registration confirmation. <b>Note:</b> This method will perform network operations. Calling this
+     * method in applications' main thread will cause Android to throw NetworkOnMainThreadException.
      * </p>
      *
-     * @param confirmationCode      REQUIRED: Code sent to the phone-number or email used to register the user
-     * @param forcedAliasCreation   REQUIRED: This flag indicates if the confirmation should go-through in case of
-     *                              parameter contentions.
-     * @param callback              REQUIRED: This is a reference to {@link GenericHandler} callback handler
-     */
-    public void confirmSignUp(String confirmationCode,
-                              boolean forcedAliasCreation,
-                              GenericHandler callback) {
-        if (callback == null) {
+     * @param confirmationCode
+     *            REQUIRED: Code sent to the phone-number or email used to register the user
+     * @param forcedAliasCreation
+     *            REQUIRED: This flag indicates if the confirmation should go-through in case of parameter contentions.
+     * @param callback
+     *            REQUIRED: This is a reference to {@link GenericHandler} callback handler
+     */
+    public void confirmSignUp(String confirmationCode, boolean forcedAliasCreation, GenericHandler callback) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
         try {
             confirmSignUpInternal(confirmationCode, forcedAliasCreation);
             callback.onSuccess();
@@ -294,33 +297,35 @@ public void confirmSignUp(String confirmationCode,
     /**
      * Internal method to Confirm Registration.
      *
-     * @param confirmationCode      REQUIRED: Code to confirm this user.
-     * @param forcedAliasCreation   REQUIRED: If set over-rides parameter contentions
+     * @param confirmationCode
+     *            REQUIRED: Code to confirm this user.
+     * @param forcedAliasCreation
+     *            REQUIRED: If set over-rides parameter contentions
      */
     private void confirmSignUpInternal(String confirmationCode, boolean forcedAliasCreation) {
         ConfirmSignUpRequest confirmUserRegistrationRequest = new ConfirmSignUpRequest();
-        confirmUserRegistrationRequest.setClientId(clientId);
-        confirmUserRegistrationRequest.setSecretHash(secretHash);
-        confirmUserRegistrationRequest.setUsername(userId);
+        confirmUserRegistrationRequest.setClientId(this.clientId);
+        confirmUserRegistrationRequest.setSecretHash(this.secretHash);
+        confirmUserRegistrationRequest.setUsername(this.userId);
         confirmUserRegistrationRequest.setConfirmationCode(confirmationCode);
         confirmUserRegistrationRequest.setForceAliasCreation(forcedAliasCreation);
 
-        cognitoIdentityProviderClient.confirmSignUp(confirmUserRegistrationRequest);
+        this.cognitoIdentityProviderClient.confirmSignUp(confirmUserRegistrationRequest);
     }
 
     /**
      * Request to resend registration confirmation code for a user, in background.
      *
-     * @param callback          REQUIRED: {@link VerificationHandler} callback handler.
+     * @param callback
+     *            REQUIRED: {@link VerificationHandler} callback handler.
      */
     public void resendConfirmationCodeInBackground(final VerificationHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Handler handler = new Handler(context.getMainLooper());
+
                 Runnable returnCallback;
                 try {
                     final ResendConfirmationCodeResult resendConfirmationCodeResult = resendConfirmationCodeInternal();
@@ -338,24 +343,24 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
 
     /**
      * Request to resend registration confirmation code for a user, in current thread.
-     *<p>
-     *     <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
-     *</p>
+     * <p>
+     * <b>Note:</b> This method will perform network operations. Calling this method in applications' main thread will
+     * cause Android to throw NetworkOnMainThreadException.
+     * </p>
      *
-     * @param callback          REQUIRED: {@link VerificationHandler} callback handler.
+     * @param callback
+     *            REQUIRED: {@link VerificationHandler} callback handler.
      */
     public void resendConfirmationCode(final VerificationHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
         try {
             ResendConfirmationCodeResult resendConfirmationCodeResult = resendConfirmationCodeInternal();
             callback.onSuccess(new CognitoUserCodeDeliveryDetails(resendConfirmationCodeResult.getCodeDeliveryDetails()));
@@ -369,44 +374,45 @@ public void resendConfirmationCode(final VerificationHandler callback) {
      */
     private ResendConfirmationCodeResult resendConfirmationCodeInternal() {
         ResendConfirmationCodeRequest resendConfirmationCodeRequest = new ResendConfirmationCodeRequest();
-        resendConfirmationCodeRequest.setUsername(userId);
-        resendConfirmationCodeRequest.setClientId(clientId);
-        resendConfirmationCodeRequest.setSecretHash(secretHash);
+        resendConfirmationCodeRequest.setUsername(this.userId);
+        resendConfirmationCodeRequest.setClientId(this.clientId);
+        resendConfirmationCodeRequest.setSecretHash(this.secretHash);
 
-        return cognitoIdentityProviderClient.resendConfirmationCode(resendConfirmationCodeRequest);
+        return this.cognitoIdentityProviderClient.resendConfirmationCode(resendConfirmationCodeRequest);
     }
 
     /**
      * Starts the process to set a new password for forgotten password case, in background.
      * <p>
-     *     This will initiate the process to set a new password when the current password is forgotten.
-     *     The new password will be successfully set only after the verification code, sent to the
-     *     registered email or phone number of the user, successfully verified by Cognito Identity Provider service.
-     *     This method will pass a continuation object to the callback.
-     *     Use setters in the Continuation object {@link ForgotPasswordContinuation} to set the
-     *     new password and verification code and call continue on the continuation object,
-     *     {@code CognitoIdentityProviderContinuation.continueTask()}.
+     * This will initiate the process to set a new password when the current password is forgotten. The new password
+     * will be successfully set only after the verification code, sent to the registered email or phone number of the
+     * user, successfully verified by Cognito Identity Provider service. This method will pass a continuation object to
+     * the callback. Use setters in the Continuation object {@link ForgotPasswordContinuation} to set the new password
+     * and verification code and call continue on the continuation object,
+     * {@code CognitoIdentityProviderContinuation.continueTask()}.
      * </p>
      *
-     * @param callback      REQUIRED: {@link ForgotPasswordHandler} callback
+     * @param callback
+     *            REQUIRED: {@link ForgotPasswordHandler} callback
      */
     public void forgotPasswordInBackground(final ForgotPasswordHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
 
         final CognitoUser cognitoUser = this;
 
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Handler handler = new Handler(context.getMainLooper());
+
                 Runnable returnCallback;
                 try {
                     final ForgotPasswordResult forgotPasswordResult = forgotPasswordInternal();
-                    final ForgotPasswordContinuation continuation = new ForgotPasswordContinuation(cognitoUser,
-                            new CognitoUserCodeDeliveryDetails(forgotPasswordResult.getCodeDeliveryDetails()),
-                            ForgotPasswordContinuation.RUN_IN_BACKGROUND, callback);
+                    final ForgotPasswordContinuation continuation =
+                        new ForgotPasswordContinuation(cognitoUser,
+                                                       new CognitoUserCodeDeliveryDetails(forgotPasswordResult.getCodeDeliveryDetails()),
+                                                       ForgotPasswordContinuation.RUN_IN_BACKGROUND,
+                                                       callback);
                     returnCallback = new Runnable() {
                         @Override
                         public void run() {
@@ -421,7 +427,7 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -429,31 +435,32 @@ public void run() {
     /**
      * Starts the process to set a new new password for forgotten password case, in current thread.
      * <p>
-     *     This will initiate the process to set a new password when the current password is forgotten.
-     *     The new password will be successfully set only after the verification code, sent to the
-     *     registered email or phone number of the user, successfully verified by Cognito Identity Provider service.
-     *     This method will pass a continuation object to the callback.
-     *     Use setters in the Continuation object {@link ForgotPasswordContinuation} to set the
-     *     new password and verification code and call continue on the continuation object,
-     *     {@code CognitoIdentityProviderContinuation.continueTask()}.
-     *     <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * This will initiate the process to set a new password when the current password is forgotten. The new password
+     * will be successfully set only after the verification code, sent to the registered email or phone number of the
+     * user, successfully verified by Cognito Identity Provider service. This method will pass a continuation object to
+     * the callback. Use setters in the Continuation object {@link ForgotPasswordContinuation} to set the new password
+     * and verification code and call continue on the continuation object,
+     * {@code CognitoIdentityProviderContinuation.continueTask()}. <b>Note:</b> This method will perform network
+     * operations. Calling this method in applications' main thread will cause Android to throw
+     * NetworkOnMainThreadException.
      * </p>
      *
-     * @param callback      REQUIRED: {@link ForgotPasswordHandler} callback
+     * @param callback
+     *            REQUIRED: {@link ForgotPasswordHandler} callback
      */
     public void forgotPassword(ForgotPasswordHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
 
         final CognitoUser cognitoUser = this;
 
         try {
             ForgotPasswordResult forgotPasswordResult = forgotPasswordInternal();
-            ForgotPasswordContinuation continuation = new ForgotPasswordContinuation(cognitoUser,
-                    new CognitoUserCodeDeliveryDetails(forgotPasswordResult.getCodeDeliveryDetails()),
-                    ForgotPasswordContinuation.RUN_IN_CURRENT, callback);
+            ForgotPasswordContinuation continuation =
+                new ForgotPasswordContinuation(cognitoUser,
+                                               new CognitoUserCodeDeliveryDetails(forgotPasswordResult.getCodeDeliveryDetails()),
+                                               ForgotPasswordContinuation.RUN_IN_CURRENT,
+                                               callback);
             callback.getResetCode(continuation);
         } catch (AmazonServiceException e) {
             callback.onFailure(e);
@@ -465,33 +472,35 @@ public void forgotPassword(ForgotPasswordHandler callback) {
      */
     private ForgotPasswordResult forgotPasswordInternal() {
         ForgotPasswordRequest resetPasswordRequest = new ForgotPasswordRequest();
-        resetPasswordRequest.setClientId(clientId);
-        resetPasswordRequest.setSecretHash(secretHash);
-        resetPasswordRequest.setUsername(userId);
+        resetPasswordRequest.setClientId(this.clientId);
+        resetPasswordRequest.setSecretHash(this.secretHash);
+        resetPasswordRequest.setUsername(this.userId);
 
-        return cognitoIdentityProviderClient.forgotPassword(resetPasswordRequest);
+        return this.cognitoIdentityProviderClient.forgotPassword(resetPasswordRequest);
     }
 
     /**
      * Set new password and send verification code to Cognito Identity Provider service, in background.
      * <p>
-     *     This method will be called by {@link ForgotPasswordContinuation} continuation object.
+     * This method will be called by {@link ForgotPasswordContinuation} continuation object.
      * </p>
-     * @param verificationCode  REQUIRED: Code sent from Cognito Identity Provider Service.
-     * @param newPassword       REQUIRED: New password. On successful verification of {@code verificationCode},
-     *                          this will be the new password for this user.
-     * @param callback          REQUIRED: {@link ForgotPasswordHandler} callback.
-     */
-    public void confirmPasswordInBackground(final String verificationCode,
-                                            final String newPassword,
+     *
+     * @param verificationCode
+     *            REQUIRED: Code sent from Cognito Identity Provider Service.
+     * @param newPassword
+     *            REQUIRED: New password. On successful verification of {@code verificationCode}, this will be the new
+     *            password for this user.
+     * @param callback
+     *            REQUIRED: {@link ForgotPasswordHandler} callback.
+     */
+    public void confirmPasswordInBackground(final String verificationCode, final String newPassword,
                                             final ForgotPasswordHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Handler handler = new Handler(context.getMainLooper());
+
                 Runnable returnCallback;
                 try {
                     confirmPasswordInternal(verificationCode, newPassword);
@@ -509,7 +518,7 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -517,21 +526,23 @@ public void run() {
     /**
      * Sends the new password and the verification code to Cognito Identity Provider service, in background.
      * <p>
-     *     This method will be called by {@link ForgotPasswordContinuation} continuation object.
-     *     <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * This method will be called by {@link ForgotPasswordContinuation} continuation object. <b>Note:</b> This method
+     * will perform network operations. Calling this method in applications' main thread will cause Android to throw
+     * NetworkOnMainThreadException.
      * </p>
-     * @param verificationCode  REQUIRED: Code sent from Cognito Identity Provider Service.
-     * @param newPassword       REQUIRED: New password. On successful verification of {@code verificationCode},
-     *                          this will be the new password for this user.
-     * @param callback          REQUIRED: {@link ForgotPasswordHandler} callback.
-     */
-    public void confirmPassword(final String verificationCode,
-                                final String newPassword,
+     *
+     * @param verificationCode
+     *            REQUIRED: Code sent from Cognito Identity Provider Service.
+     * @param newPassword
+     *            REQUIRED: New password. On successful verification of {@code verificationCode}, this will be the new
+     *            password for this user.
+     * @param callback
+     *            REQUIRED: {@link ForgotPasswordHandler} callback.
+     */
+    public void confirmPassword(final String verificationCode, final String newPassword,
                                 final ForgotPasswordHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
         try {
             confirmPasswordInternal(verificationCode, newPassword);
             callback.onSuccess();
@@ -542,53 +553,57 @@ public void confirmPassword(final String verificationCode,
 
     /**
      * Internal method to set a new password.
-     * @param verificationCode  REQUIRED: Verification code sent to the user.
-     * @param newPassword       REQUIRED: New password for the user.
+     *
+     * @param verificationCode
+     *            REQUIRED: Verification code sent to the user.
+     * @param newPassword
+     *            REQUIRED: New password for the user.
      */
     private void confirmPasswordInternal(String verificationCode, String newPassword) {
         ConfirmForgotPasswordRequest confirmResetPasswordRequest = new ConfirmForgotPasswordRequest();
-        confirmResetPasswordRequest.setUsername(userId);
-        confirmResetPasswordRequest.setClientId(clientId);
-        confirmResetPasswordRequest.setSecretHash(secretHash);
+        confirmResetPasswordRequest.setUsername(this.userId);
+        confirmResetPasswordRequest.setClientId(this.clientId);
+        confirmResetPasswordRequest.setSecretHash(this.secretHash);
         confirmResetPasswordRequest.setConfirmationCode(verificationCode);
         confirmResetPasswordRequest.setPassword(newPassword);
 
-        cognitoIdentityProviderClient.confirmForgotPassword(confirmResetPasswordRequest);
+        this.cognitoIdentityProviderClient.confirmForgotPassword(confirmResetPasswordRequest);
     }
 
     /**
      * Returns a valid tokens for a user through the callback method. Runs in background.
      * {@link AuthenticationHandler#onSuccess(CognitoUserSession, CognitoDevice)}.
      * <p>
-     *     Tokens are passed as instance of {@link CognitoUserSession}.
-     *     Call this method to get valid tokens for a user. This method returns any valid cached
-     *     tokens for the user. If no valid cached tokens are available this method initiates the
-     *     process to authenticate the user and get tokens from Cognito Identity Provider service.
-     *     Implement the interface {@link AuthenticationHandler} and pass it as callback to this
-     *     method. This method uses the callback to interact with application at different
-     *     stages of the authentication process. Continuation objects are used when the authentication
-     *     process requires more data to continue. See {@link com.amazonaws.mobileconnectors.cognitoidentityprovider.continuations.CognitoIdentityProviderContinuation} for details on continuation objects.
+     * Tokens are passed as instance of {@link CognitoUserSession}. Call this method to get valid tokens for a user.
+     * This method returns any valid cached tokens for the user. If no valid cached tokens are available this method
+     * initiates the process to authenticate the user and get tokens from Cognito Identity Provider service. Implement
+     * the interface {@link AuthenticationHandler} and pass it as callback to this method. This method uses the callback
+     * to interact with application at different stages of the authentication process. Continuation objects are used
+     * when the authentication process requires more data to continue. See
+     * {@link com.amazonaws.mobileconnectors.cognitoidentityprovider.continuations.CognitoIdentityProviderContinuation}
+     * for details on continuation objects.
      * </p>
-     * @param callback      REQUIRED: {@link AuthenticationHandler} callback
+     *
+     * @param callback
+     *            REQUIRED: {@link AuthenticationHandler} callback
      */
     public void getSessionInBackground(final AuthenticationHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
 
         final CognitoUser cognitoUser = this;
 
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Handler handler = new Handler(context.getMainLooper());
+
                 Runnable returnCallback;
                 try {
                     getCachedSession();
                     returnCallback = new Runnable() {
                         @Override
                         public void run() {
-                            callback.onSuccess(cipSession, null);
+                            callback.onSuccess(CognitoUser.this.cipSession, null);
                         }
                     };
                 } catch (final CognitoNotAuthorizedException e) {
@@ -596,7 +611,10 @@ public void run() {
                         @Override
                         public void run() {
                             AuthenticationContinuation authenticationContinuation =
-                                    new AuthenticationContinuation(cognitoUser, context, AuthenticationContinuation.RUN_IN_BACKGROUND, callback);
+                                new AuthenticationContinuation(cognitoUser,
+                                                               CognitoUser.this.context,
+                                                               AuthenticationContinuation.RUN_IN_BACKGROUND,
+                                                               callback);
                             callback.getAuthenticationDetails(authenticationContinuation, cognitoUser.getUserId());
                         }
                     };
@@ -608,7 +626,7 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -617,33 +635,32 @@ public void run() {
      * Returns a valid tokens for a user through the callback method. Runs in background.
      * {@link AuthenticationHandler#onSuccess(CognitoUserSession, CognitoDevice)}.
      * <p>
-     *     Tokens are passed as instance of {@link CognitoUserSession}.
-     *     Call this method to get valid tokens for a user. This method returns any valid cached
-     *     tokens for the user. If no valid cached tokens are available this method initiates the
-     *     process to authenticate the user and get tokens from Cognito Identity Provider service.
-     *     Implement the interface {@link AuthenticationHandler} and pass it as callback to this
-     *     method. This method uses the callback to interact with application at different
-     *     stages of the authentication process. Continuation objects are used when the authentication
-     *     process requires more data to continue. See {@link com.amazonaws.mobileconnectors.cognitoidentityprovider.continuations.CognitoIdentityProviderContinuation}
-     *     for details on continuation objects.
-     *     <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * Tokens are passed as instance of {@link CognitoUserSession}. Call this method to get valid tokens for a user.
+     * This method returns any valid cached tokens for the user. If no valid cached tokens are available this method
+     * initiates the process to authenticate the user and get tokens from Cognito Identity Provider service. Implement
+     * the interface {@link AuthenticationHandler} and pass it as callback to this method. This method uses the callback
+     * to interact with application at different stages of the authentication process. Continuation objects are used
+     * when the authentication process requires more data to continue. See
+     * {@link com.amazonaws.mobileconnectors.cognitoidentityprovider.continuations.CognitoIdentityProviderContinuation}
+     * for details on continuation objects. <b>Note:</b> This method will perform network operations. Calling this
+     * method in applications' main thread will cause Android to throw NetworkOnMainThreadException.
      * </p>
-     * @param callback      REQUIRED: {@link AuthenticationHandler} callback
+     *
+     * @param callback
+     *            REQUIRED: {@link AuthenticationHandler} callback
      */
     public void getSession(final AuthenticationHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new InvalidParameterException("callback is null");
-        }
 
         try {
             getCachedSession();
-            callback.onSuccess(cipSession, null);
+            callback.onSuccess(this.cipSession, null);
         } catch (InvalidParameterException e) {
             callback.onFailure(e);
         } catch (CognitoNotAuthorizedException e) {
-           AuthenticationContinuation authenticationContinuation =
-                   new AuthenticationContinuation(this, context, AuthenticationContinuation.RUN_IN_CURRENT, callback);
+            AuthenticationContinuation authenticationContinuation =
+                new AuthenticationContinuation(this, this.context, AuthenticationContinuation.RUN_IN_CURRENT, callback);
             callback.getAuthenticationDetails(authenticationContinuation, getUserId());
         } catch (Exception e) {
             callback.onFailure(e);
@@ -655,42 +672,49 @@ public void getSession(final AuthenticationHandler callback) {
      * This is the first step in user authentication. The response to this step from the service will contain
      * information about the next step in the authentication process.
      *
-     * @param authenticationDetails         REQUIRED: Contains details about the user authentication.
-     * @param callback                      REQUIRED: {@link AuthenticationHandler} callback.
+     * @param authenticationDetails
+     *            REQUIRED: Contains details about the user authentication.
+     * @param callback
+     *            REQUIRED: {@link AuthenticationHandler} callback.
      * @return {@link Runnable} for the next step in user authentication.
      */
-    public Runnable initiateUserAuthentication(final AuthenticationDetails authenticationDetails, final AuthenticationHandler callback, final boolean runInBackground) {
-        if (CognitoServiceConstants.CHLG_TYPE_USER_PASSWORD_VERIFIER.equals(authenticationDetails.getAuthenticationType())) {
+    public Runnable initiateUserAuthentication(final AuthenticationDetails authenticationDetails,
+                                               final AuthenticationHandler callback, final boolean runInBackground) {
+        if (CognitoServiceConstants.CHLG_TYPE_USER_PASSWORD_VERIFIER.equals(authenticationDetails.getAuthenticationType()))
             return startWithUserSrpAuth(authenticationDetails, callback, runInBackground);
-        } else if (CognitoServiceConstants.CHLG_TYPE_CUSTOM_CHALLENGE.equals(authenticationDetails.getAuthenticationType())) {
+        else if (CognitoServiceConstants.CHLG_TYPE_CUSTOM_CHALLENGE.equals(authenticationDetails.getAuthenticationType()))
             return startWithCustomAuth(authenticationDetails, callback, runInBackground);
-        } else {
+        else
             return new Runnable() {
                 @Override
                 public void run() {
-                    callback.onFailure(new CognitoParameterInvalidException("Unsupported authentication type " + authenticationDetails.getAuthenticationType()));
+                    callback.onFailure(new CognitoParameterInvalidException("Unsupported authentication type "
+                                                                            + authenticationDetails.getAuthenticationType()));
                 }
             };
-        }
     }
 
     /**
-     * Responds to an MFA challenge. This method creates a response to the challenge and calls the
-     * internal method to respond to the authentication challenge.
+     * Responds to an MFA challenge. This method creates a response to the challenge and calls the internal method to
+     * respond to the authentication challenge.
      *
-     * @param mfaCode                   REQUIRED: The MFA code received by the user.
-     * @param challenge                 REQUIRED: Current challenge {@link RespondToAuthChallengeResult}.
-     * @param callback                  REQUIRED: {@link AuthenticationHandler} callback.
+     * @param mfaCode
+     *            REQUIRED: The MFA code received by the user.
+     * @param challenge
+     *            REQUIRED: Current challenge {@link RespondToAuthChallengeResult}.
+     * @param callback
+     *            REQUIRED: {@link AuthenticationHandler} callback.
      * @return {@link Runnable} for the next step in user authentication.
      */
-    public Runnable respondToMfaChallenge(final String mfaCode, final RespondToAuthChallengeResult challenge, final AuthenticationHandler callback, final boolean runInBackground) {
+    public Runnable respondToMfaChallenge(final String mfaCode, final RespondToAuthChallengeResult challenge,
+                                          final AuthenticationHandler callback, final boolean runInBackground) {
         final RespondToAuthChallengeRequest challengeResponse = new RespondToAuthChallengeRequest();
         Map<String, String> mfaParameters = new HashMap<String, String>();
         mfaParameters.put(CognitoServiceConstants.CHLG_RESP_SMS_MFA_CODE, mfaCode);
-        mfaParameters.put(CognitoServiceConstants.CHLG_RESP_USERNAME, usernameInternal);
-        mfaParameters.put(CognitoServiceConstants.CHLG_RESP_DEVICE_KEY, deviceKey);
-        mfaParameters.put(CognitoServiceConstants.CHLG_RESP_SECRET_HASH, secretHash);
-        challengeResponse.setClientId(clientId);
+        mfaParameters.put(CognitoServiceConstants.CHLG_RESP_USERNAME, this.usernameInternal);
+        mfaParameters.put(CognitoServiceConstants.CHLG_RESP_DEVICE_KEY, this.deviceKey);
+        mfaParameters.put(CognitoServiceConstants.CHLG_RESP_SECRET_HASH, this.secretHash);
+        challengeResponse.setClientId(this.clientId);
         challengeResponse.setSession(challenge.getSession());
         challengeResponse.setChallengeName(challenge.getChallengeName());
         challengeResponse.setChallengeResponses(mfaParameters);
@@ -703,62 +727,59 @@ public Runnable respondToMfaChallenge(final String mfaCode, final RespondToAuthC
      * @return Valid, cached tokens {@link CognitoUserSession}. {@code null} otherwise.
      */
     protected CognitoUserSession getCachedSession() {
-        if (userId == null) {
+        if (this.userId == null)
             throw new CognitoNotAuthorizedException("User-ID is null");
-        }
 
-        if (cipSession != null) {
-            if (cipSession.isValidForThreshold()) {
-                return cipSession;
-            }
-        }
+        if (this.cipSession != null)
+            if (this.cipSession.isValidForThreshold())
+                return this.cipSession;
 
         CognitoUserSession cachedTokens = readCachedTokens();
 
         if (cachedTokens.isValidForThreshold()) {
-            cipSession = cachedTokens;
-            return  cipSession;
+            this.cipSession = cachedTokens;
+            return this.cipSession;
         }
 
-        if (cachedTokens.getRefreshToken() != null) {
+        if (cachedTokens.getRefreshToken() != null)
             try {
-                cipSession = refreshSession(cachedTokens);
-                cacheTokens(cipSession);
-                return cipSession;
+                this.cipSession = refreshSession(cachedTokens);
+                cacheTokens(this.cipSession);
+                return this.cipSession;
             } catch (NotAuthorizedException nae) {
                 clearCachedTokens();
                 throw new CognitoNotAuthorizedException("User is not authenticated", nae);
             } catch (Exception e) {
                 throw new CognitoInternalErrorException("Failed to authenticate user", e);
             }
-        }
         throw new CognitoNotAuthorizedException("User is not authenticated");
     }
 
     /**
      * Request to change password for this user, in background.
      * <p>
-     *     This operation requires a valid accessToken {@link CognitoUserSession#accessToken}.
-     *     Un-authenticated users will have to be authenticated before calling this method.
+     * This operation requires a valid accessToken {@link CognitoUserSession#accessToken}. Un-authenticated users will
+     * have to be authenticated before calling this method.
      * </p>
      *
-     * @param oldUserPassword   REQUIRED: Current password of this user.
-     * @param newUserPassword   REQUIRED: New password for this user.
-     * @param callback          REQUIRED: {@link GenericHandler} callback handler.
-     */
-    public void changePasswordInBackground(final String oldUserPassword,
-                                           final String newUserPassword,
+     * @param oldUserPassword
+     *            REQUIRED: Current password of this user.
+     * @param newUserPassword
+     *            REQUIRED: New password for this user.
+     * @param callback
+     *            REQUIRED: {@link GenericHandler} callback handler.
+     */
+    public void changePasswordInBackground(final String oldUserPassword, final String newUserPassword,
                                            final GenericHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
 
         final CognitoUser user = this;
 
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Handler handler = new Handler(context.getMainLooper());
+
                 Runnable returnCallback;
                 try {
                     CognitoUserSession session = user.getCachedSession();
@@ -777,7 +798,7 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -785,22 +806,22 @@ public void run() {
     /**
      * Request to change password for this user, in current thread.
      * <p>
-     *     This operation requires a valid accessToken {@link CognitoUserSession#accessToken}.
-     *     Unauthenticated users will need to be authenticated before calling this method.
-     *     <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * This operation requires a valid accessToken {@link CognitoUserSession#accessToken}. Unauthenticated users will
+     * need to be authenticated before calling this method. <b>Note:</b> This method will perform network operations.
+     * Calling this method in applications' main thread will cause Android to throw NetworkOnMainThreadException.
      * </p>
      *
-     * @param oldUserPassword   REQUIRED: Current password of this user.
-     * @param newUserPassword   REQUIRED: New password for this user.
-     * @param callback          REQUIRED: {@link GenericHandler} callback handler.
-     */
-    public void changePassword(final String oldUserPassword,
-                               final String newUserPassword,
+     * @param oldUserPassword
+     *            REQUIRED: Current password of this user.
+     * @param newUserPassword
+     *            REQUIRED: New password for this user.
+     * @param callback
+     *            REQUIRED: {@link GenericHandler} callback handler.
+     */
+    public void changePassword(final String oldUserPassword, final String newUserPassword,
                                final GenericHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
         try {
             changePasswordInternal(oldUserPassword, newUserPassword, getCachedSession());
             callback.onSuccess();
@@ -812,45 +833,44 @@ public void changePassword(final String oldUserPassword,
     /**
      * Internal method to change a user password.
      *
-     * @param oldUserPassword REQUIRED: old password.
-     * @param newUserPassword REQUIRED: new password.
-     * @param session		  REQUIRED: {@link CognitoUserSession}.
-     */
-    private void changePasswordInternal(String oldUserPassword, String newUserPassword,
-                                        CognitoUserSession session) {
-        if (session != null && session.isValid()) {
+     * @param oldUserPassword
+     *            REQUIRED: old password.
+     * @param newUserPassword
+     *            REQUIRED: new password.
+     * @param session
+     *            REQUIRED: {@link CognitoUserSession}.
+     */
+    private void changePasswordInternal(String oldUserPassword, String newUserPassword, CognitoUserSession session) {
+        if ((session != null) && session.isValid()) {
             ChangePasswordRequest changePasswordRequest = new ChangePasswordRequest();
             changePasswordRequest.setPreviousPassword(oldUserPassword);
             changePasswordRequest.setProposedPassword(newUserPassword);
             changePasswordRequest.setAccessToken(session.getAccessToken().getJWTToken());
-            cognitoIdentityProviderClient.changePassword(changePasswordRequest);
-        }
-        else {
+            this.cognitoIdentityProviderClient.changePassword(changePasswordRequest);
+        } else
             throw new CognitoNotAuthorizedException("user is not authenticated");
-        }
     }
 
     /**
      * Retrieves the current user attributes. Runs in background.
      *
      * <p>
-     *     All attributes, which are set for this user, are fetched.
-     *     This method requires valid accessToken.
+     * All attributes, which are set for this user, are fetched. This method requires valid accessToken.
      * </p>
      *
-     * @param callback      REQUIRED: {@link GetDetailsHandler} callback
+     * @param callback
+     *            REQUIRED: {@link GetDetailsHandler} callback
      */
     public void getDetailsInBackground(final GetDetailsHandler callback) {
 
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
         final CognitoUser user = this;
 
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Handler handler = new Handler(context.getMainLooper());
+
                 Runnable returnCallback;
                 try {
                     CognitoUserSession session = user.getCachedSession();
@@ -869,7 +889,7 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -878,21 +898,20 @@ public void run() {
      * Retrieves the current user attributes. Runs on current thread.
      *
      * <p>
-     *     All attributes, which are set for this user, are fetched.
-     *     This method requires valid accessToken.
-     *     <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * All attributes, which are set for this user, are fetched. This method requires valid accessToken. <b>Note:</b>
+     * This method will perform network operations. Calling this method in applications' main thread will cause Android
+     * to throw NetworkOnMainThreadException.
      * </p>
      *
-     * @param callback      REQUIRED: {@link GetDetailsHandler} callback
+     * @param callback
+     *            REQUIRED: {@link GetDetailsHandler} callback
      */
     public void getDetails(final GetDetailsHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
 
         try {
-            CognitoUserDetails userDetails = getUserDetailsInternal(this.getCachedSession());
+            CognitoUserDetails userDetails = getUserDetailsInternal(getCachedSession());
             callback.onSuccess(userDetails);
         } catch (Exception e) {
             callback.onFailure(e);
@@ -902,54 +921,52 @@ public void getDetails(final GetDetailsHandler callback) {
     /**
      * Internal method to fetch user attributes.
      *
-     * @param session		REQUIRED: {@link CognitoUserSession}
+     * @param session
+     *            REQUIRED: {@link CognitoUserSession}
      * @return User attributes
      */
     private CognitoUserDetails getUserDetailsInternal(CognitoUserSession session) {
-        if (session != null && session.isValid()) {
+        if ((session != null) && session.isValid()) {
             GetUserRequest getUserRequest = new GetUserRequest();
             getUserRequest.setAccessToken(session.getAccessToken().getJWTToken());
-            GetUserResult userResult = cognitoIdentityProviderClient.getUser(getUserRequest);
+            GetUserResult userResult = this.cognitoIdentityProviderClient.getUser(getUserRequest);
 
             return new CognitoUserDetails(new CognitoUserAttributes(userResult.getUserAttributes()),
-                    new CognitoUserSettings(userResult.getMFAOptions()));
-        }
-        else {
+                                          new CognitoUserSettings(userResult.getMFAOptions()));
+        } else
             throw new CognitoNotAuthorizedException("user is not authenticated");
-        }
     }
 
     /**
      * Requests code to verify a user attribute, in background.
      * <p>
-     *     The user attributes that can be verified are those attributes that can be used to
-     *     communicate with the user, e.g. phone_number and email.
-     *     The verification code is sent to the medium that is represented by the attribute.
-     *     Attribute verification is required to enable the attribute to be used an attribute as alias
-     *     for the user.
-     *     Aliases attributes can be used in lieu of the userId to authenticate the user.
-     *     If an attribute was used in the confirm the user after sign-up, then that alias is
-     *     already verified and does not require re-verification.
+     * The user attributes that can be verified are those attributes that can be used to communicate with the user, e.g.
+     * phone_number and email. The verification code is sent to the medium that is represented by the attribute.
+     * Attribute verification is required to enable the attribute to be used an attribute as alias for the user. Aliases
+     * attributes can be used in lieu of the userId to authenticate the user. If an attribute was used in the confirm
+     * the user after sign-up, then that alias is already verified and does not require re-verification.
      * </p>
-     * @param attributeName         REQUIRED: Name of the attribute that requires verification.
-     * @param callback              REQUIRED: callback.
+     *
+     * @param attributeName
+     *            REQUIRED: Name of the attribute that requires verification.
+     * @param callback
+     *            REQUIRED: callback.
      */
     public void getAttributeVerificationCodeInBackground(final String attributeName,
                                                          final VerificationHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
         final CognitoUser user = this;
 
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Handler handler = new Handler(context.getMainLooper());
+
                 Runnable returnCallback;
                 try {
                     final CognitoUserSession session = user.getCachedSession();
                     final GetUserAttributeVerificationCodeResult getUserAttributeVerificationCodeResult =
-                            getAttributeVerificationCodeInternal(attributeName, session);
+                        getAttributeVerificationCodeInternal(attributeName, session);
                     returnCallback = new Runnable() {
                         @Override
                         public void run() {
@@ -964,7 +981,7 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -972,28 +989,27 @@ public void run() {
     /**
      * Requests code to verify a user attribute, in current thread.
      * <p>
-     *     The user attributes that can be verified are those attributes that can be used to
-     *     communicate with the user, e.g. phone_number and email.
-     *     The verification code is sent to the medium that is represented by the attribute.
-     *     Attribute verification is required to enable the attribute to be used an attribute as alias
-     *     for the user.
-     *     Aliases attributes can be used in lieu of the userId to authenticate the user.
-     *     If an attribute was used in the confirm the user after sign-up, then that alias is
-     *     already verified and does not require re-verification.
-     *     <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * The user attributes that can be verified are those attributes that can be used to communicate with the user, e.g.
+     * phone_number and email. The verification code is sent to the medium that is represented by the attribute.
+     * Attribute verification is required to enable the attribute to be used an attribute as alias for the user. Aliases
+     * attributes can be used in lieu of the userId to authenticate the user. If an attribute was used in the confirm
+     * the user after sign-up, then that alias is already verified and does not require re-verification. <b>Note:</b>
+     * This method will perform network operations. Calling this method in applications' main thread will cause Android
+     * to throw NetworkOnMainThreadException.
      * </p>
-     * @param attributeName         REQUIRED: Name of the attribute that requires verification.
-     * @param callback              REQUIRED: callback.
+     *
+     * @param attributeName
+     *            REQUIRED: Name of the attribute that requires verification.
+     * @param callback
+     *            REQUIRED: callback.
      */
     public void getAttributeVerificationCode(String attributeName, VerificationHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
 
         try {
             GetUserAttributeVerificationCodeResult getUserAttributeVerificationCodeResult =
-            getAttributeVerificationCodeInternal(attributeName, this.getCachedSession());
+                getAttributeVerificationCodeInternal(attributeName, getCachedSession());
             callback.onSuccess(new CognitoUserCodeDeliveryDetails(getUserAttributeVerificationCodeResult.getCodeDeliveryDetails()));
         } catch (Exception e) {
             callback.onFailure(e);
@@ -1003,47 +1019,48 @@ public void getAttributeVerificationCode(String attributeName, VerificationHandl
     /**
      * Internal method to request for attribute verification code.
      *
-     * @param attributeName         REQUIRED: Name of the attribute that requires verification.
-     * @param session               REQUIRED: A valid {@link CognitoUserSession}.
+     * @param attributeName
+     *            REQUIRED: Name of the attribute that requires verification.
+     * @param session
+     *            REQUIRED: A valid {@link CognitoUserSession}.
      */
     private GetUserAttributeVerificationCodeResult getAttributeVerificationCodeInternal(final String attributeName,
-                                                      final CognitoUserSession session) {
-        if(session != null && session.isValid()){
-            GetUserAttributeVerificationCodeRequest getUserAttributeVerificationCodeRequest
-                    = new GetUserAttributeVerificationCodeRequest();
+                                                                                        final CognitoUserSession session) {
+        if ((session != null) && session.isValid()) {
+            GetUserAttributeVerificationCodeRequest getUserAttributeVerificationCodeRequest =
+                new GetUserAttributeVerificationCodeRequest();
             getUserAttributeVerificationCodeRequest.setAccessToken(session.getAccessToken().getJWTToken());
             getUserAttributeVerificationCodeRequest.setAttributeName(attributeName);
 
-            return cognitoIdentityProviderClient.getUserAttributeVerificationCode(getUserAttributeVerificationCodeRequest);
-        }
-        else {
+            return this.cognitoIdentityProviderClient.getUserAttributeVerificationCode(getUserAttributeVerificationCodeRequest);
+        } else
             throw new CognitoNotAuthorizedException("user is not authenticated");
-        }
     }
 
     /**
      * Verify an attribute with the verification code, in background.
      * <p>
-     *     Call this method to verify an attribute with the "verification code".
-     *     To request for a "verification code" call the method
-     *     {@link CognitoUser#getAttributeVerificationCodeInBackground(String, VerificationHandler)}.
+     * Call this method to verify an attribute with the "verification code". To request for a "verification code" call
+     * the method {@link CognitoUser#getAttributeVerificationCodeInBackground(String, VerificationHandler)}.
      * </p>
-     * @param attributeName         REQUIRED: The attribute that is being verified.
-     * @param verificationCode      REQUIRED: The code for verification.
-     * @param callback              REQUIRED: Callback
-     */
-    public void verifyAttributeInBackground(final String attributeName,
-                                            final String verificationCode,
+     *
+     * @param attributeName
+     *            REQUIRED: The attribute that is being verified.
+     * @param verificationCode
+     *            REQUIRED: The code for verification.
+     * @param callback
+     *            REQUIRED: Callback
+     */
+    public void verifyAttributeInBackground(final String attributeName, final String verificationCode,
                                             final GenericHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
         final CognitoUser user = this;
 
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Handler handler = new Handler(context.getMainLooper());
+
                 Runnable returnCallback;
                 try {
                     CognitoUserSession session = user.getCachedSession();
@@ -1062,7 +1079,7 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -1070,26 +1087,26 @@ public void run() {
     /**
      * Verify an attribute with the verification code, in current thread.
      * <p>
-     *     Call this method to verify an attribute with the "verification code".
-     *     To request for a "verification code" call the method
-     *     {@link CognitoUser#getAttributeVerificationCodeInBackground(String, VerificationHandler)}.
-     *     <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * Call this method to verify an attribute with the "verification code". To request for a "verification code" call
+     * the method {@link CognitoUser#getAttributeVerificationCodeInBackground(String, VerificationHandler)}.
+     * <b>Note:</b> This method will perform network operations. Calling this method in applications' main thread will
+     * cause Android to throw NetworkOnMainThreadException.
      * </p>
-     * @param attributeName         REQUIRED: The attribute that is being verified.
-     * @param verificationCode      REQUIRED: The code for verification.
-     * @param callback              REQUIRED: Callback
-     */
-    public void verifyAttribute(String attributeName,
-                                String verificationCode,
-                                GenericHandler callback) {
-        if (callback == null) {
+     *
+     * @param attributeName
+     *            REQUIRED: The attribute that is being verified.
+     * @param verificationCode
+     *            REQUIRED: The code for verification.
+     * @param callback
+     *            REQUIRED: Callback
+     */
+    public void verifyAttribute(String attributeName, String verificationCode, GenericHandler callback) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
 
         try {
             VerifyUserAttributeResult verifyUserAttributeResult =
-                    verifyAttributeInternal(attributeName, verificationCode, this.getCachedSession());
+                verifyAttributeInternal(attributeName, verificationCode, getCachedSession());
         } catch (Exception e) {
             callback.onFailure(e);
         }
@@ -1097,60 +1114,60 @@ public void verifyAttribute(String attributeName,
 
     /**
      * Internal method to verify an attribute.
-     * @param attributeName         REQUIRED: The attribute that is being verified.
-     * @param verificationCode      REQUIRED: The code for verification.
-     * @param session               REQUIRED: A valid {@link CognitoUserSession}.
+     *
+     * @param attributeName
+     *            REQUIRED: The attribute that is being verified.
+     * @param verificationCode
+     *            REQUIRED: The code for verification.
+     * @param session
+     *            REQUIRED: A valid {@link CognitoUserSession}.
      * @return {@link VerifyUserAttributeResult}
      */
-    private VerifyUserAttributeResult verifyAttributeInternal(String attributeName,
-                                                              String verificationCode,
+    private VerifyUserAttributeResult verifyAttributeInternal(String attributeName, String verificationCode,
                                                               CognitoUserSession session) {
-        if(session != null && session.isValid()) {
+        if ((session != null) && session.isValid()) {
             VerifyUserAttributeRequest verifyUserAttributeRequest = new VerifyUserAttributeRequest();
             verifyUserAttributeRequest.setAttributeName(attributeName);
             verifyUserAttributeRequest.setAccessToken(session.getAccessToken().getJWTToken());
             verifyUserAttributeRequest.setCode(verificationCode);
 
-            return cognitoIdentityProviderClient.verifyUserAttribute(verifyUserAttributeRequest);
-        }
-        else {
+            return this.cognitoIdentityProviderClient.verifyUserAttribute(verifyUserAttributeRequest);
+        } else
             throw new CognitoNotAuthorizedException("user is not authenticated");
-        }
     }
 
     /**
      * Updates attributes for a user. Runs in background.
      * <p>
-     *     Requires valid accessToken.
+     * Requires valid accessToken.
      * </p>
      *
-     * @param attributes        REQUIRED: All attributes and values that need to be updated for this  user.
-     * @param callback          REQUIRED: {@link UpdateAttributesHandler} callback.
+     * @param attributes
+     *            REQUIRED: All attributes and values that need to be updated for this user.
+     * @param callback
+     *            REQUIRED: {@link UpdateAttributesHandler} callback.
      */
     public void updateAttributesInBackground(final CognitoUserAttributes attributes,
                                              final UpdateAttributesHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
         final CognitoUser user = this;
 
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Handler handler = new Handler(context.getMainLooper());
+
                 Runnable returnCallback;
                 try {
                     CognitoUserSession session = user.getCachedSession();
                     final UpdateUserAttributesResult updateUserAttributesResult =
-                            updateAttributesInternal(attributes, session);
+                        updateAttributesInternal(attributes, session);
 
                     final List<CognitoUserCodeDeliveryDetails> attributesVerificationList =
-                            new ArrayList<CognitoUserCodeDeliveryDetails>();
-                    if (updateUserAttributesResult.getCodeDeliveryDetailsList() != null) {
-                        for(CodeDeliveryDetailsType details: updateUserAttributesResult.getCodeDeliveryDetailsList()) {
+                        new ArrayList<CognitoUserCodeDeliveryDetails>();
+                    if (updateUserAttributesResult.getCodeDeliveryDetailsList() != null)
+                        for (CodeDeliveryDetailsType details : updateUserAttributesResult.getCodeDeliveryDetailsList())
                             attributesVerificationList.add(new CognitoUserCodeDeliveryDetails(details));
-                        }
-                    }
                     returnCallback = new Runnable() {
                         @Override
                         public void run() {
@@ -1166,7 +1183,7 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -1174,32 +1191,28 @@ public void run() {
     /**
      * Updates attributes for a user. Runs in background.
      * <p>
-     *     Requires valid accessToken.
-     *     <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * Requires valid accessToken. <b>Note:</b> This method will perform network operations. Calling this method in
+     * applications' main thread will cause Android to throw NetworkOnMainThreadException.
      * </p>
      *
-     * @param attributes        REQUIRED: All attributes and values that need to be updated for this  user.
-     * @param callback          REQUIRED: {@link UpdateAttributesHandler} callback.
+     * @param attributes
+     *            REQUIRED: All attributes and values that need to be updated for this user.
+     * @param callback
+     *            REQUIRED: {@link UpdateAttributesHandler} callback.
      */
-    public void updateAttributes(final CognitoUserAttributes attributes,
-                                 final UpdateAttributesHandler callback) {
-        if (callback == null) {
+    public void updateAttributes(final CognitoUserAttributes attributes, final UpdateAttributesHandler callback) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
 
         try {
-        	CognitoUserSession session = getCachedSession();
-            UpdateUserAttributesResult updateUserAttributesResult =
-                    updateAttributesInternal(attributes, session);
+            CognitoUserSession session = getCachedSession();
+            UpdateUserAttributesResult updateUserAttributesResult = updateAttributesInternal(attributes, session);
 
             List<CognitoUserCodeDeliveryDetails> attributesVerificationList =
-                    new ArrayList<CognitoUserCodeDeliveryDetails>();
-            if (updateUserAttributesResult.getCodeDeliveryDetailsList() != null) {
-                for(CodeDeliveryDetailsType details: updateUserAttributesResult.getCodeDeliveryDetailsList()) {
+                new ArrayList<CognitoUserCodeDeliveryDetails>();
+            if (updateUserAttributesResult.getCodeDeliveryDetailsList() != null)
+                for (CodeDeliveryDetailsType details : updateUserAttributesResult.getCodeDeliveryDetailsList())
                     attributesVerificationList.add(new CognitoUserCodeDeliveryDetails(details));
-                }
-            }
             callback.onSuccess(attributesVerificationList);
         } catch (Exception e) {
             callback.onFailure(e);
@@ -1209,39 +1222,40 @@ public void updateAttributes(final CognitoUserAttributes attributes,
     /**
      * Helper method to update user attributes.
      *
-     * @param attributes        REQUIRED: Attributes.
-     * @param session           REQUIRED: A valid {@link CognitoUserSession}.
+     * @param attributes
+     *            REQUIRED: Attributes.
+     * @param session
+     *            REQUIRED: A valid {@link CognitoUserSession}.
      */
     private UpdateUserAttributesResult updateAttributesInternal(final CognitoUserAttributes attributes,
-                                          final CognitoUserSession session) {
-        if (session != null && session.isValid()) {
+                                                                final CognitoUserSession session) {
+        if ((session != null) && session.isValid()) {
             UpdateUserAttributesRequest updateUserAttributesRequest = new UpdateUserAttributesRequest();
             updateUserAttributesRequest.setAccessToken(session.getAccessToken().getJWTToken());
             updateUserAttributesRequest.setUserAttributes(attributes.getAttributesList());
 
-            return cognitoIdentityProviderClient.updateUserAttributes(updateUserAttributesRequest);
-        } else {
+            return this.cognitoIdentityProviderClient.updateUserAttributes(updateUserAttributesRequest);
+        } else
             throw new CognitoNotAuthorizedException("user is not authenticated");
-        }
     }
 
     /**
      * Deletes user attributes, in background.
      *
-     * @param attributeNamesToDelete    REQUIRED: List of user attributes that have to be deleted.
-     * @param callback                  REQUIRED: {@link GenericHandler} callback
+     * @param attributeNamesToDelete
+     *            REQUIRED: List of user attributes that have to be deleted.
+     * @param callback
+     *            REQUIRED: {@link GenericHandler} callback
      */
-    public void deleteAttributesInBackground(final List<String> attributeNamesToDelete,
-                                             final GenericHandler callback) {
-        if (callback == null) {
+    public void deleteAttributesInBackground(final List<String> attributeNamesToDelete, final GenericHandler callback) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
         final CognitoUser user = this;
 
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Handler handler = new Handler(context.getMainLooper());
+
                 Runnable returnCallback;
                 try {
                     CognitoUserSession session = user.getCachedSession();
@@ -1260,7 +1274,7 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -1268,21 +1282,21 @@ public void run() {
     /**
      * Deletes user attributes, in current thread.
      * <p>
-     *     <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * <b>Note:</b> This method will perform network operations. Calling this method in applications' main thread will
+     * cause Android to throw NetworkOnMainThreadException.
      * </p>
      *
-     * @param attributeNamesToDelete    REQUIRED: List of user attributes that have to be deleted.
-     * @param callback                  REQUIRED: {@link GenericHandler} callback
+     * @param attributeNamesToDelete
+     *            REQUIRED: List of user attributes that have to be deleted.
+     * @param callback
+     *            REQUIRED: {@link GenericHandler} callback
      */
-    public void deleteAttributes(final List<String> attributeNamesToDelete,
-                                 final GenericHandler callback) {
-        if (callback == null) {
+    public void deleteAttributes(final List<String> attributeNamesToDelete, final GenericHandler callback) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
 
         try {
-            deleteAttributesInternal(attributeNamesToDelete, this.getCachedSession());
+            deleteAttributesInternal(attributeNamesToDelete, getCachedSession());
             callback.onSuccess();
         } catch (Exception e) {
             callback.onFailure(e);
@@ -1292,62 +1306,59 @@ public void deleteAttributes(final List<String> attributeNamesToDelete,
     /**
      * Internal method to delete user attributes.
      *
-     * @param attributeNamesToDelete        REQUIRED: Attribute that is being deleted.
-     * @param session                       REQUIRED: A valid {@link CognitoUserSession}.
+     * @param attributeNamesToDelete
+     *            REQUIRED: Attribute that is being deleted.
+     * @param session
+     *            REQUIRED: A valid {@link CognitoUserSession}.
      */
-    private void deleteAttributesInternal(final List<String> attributeNamesToDelete,
-                                          final CognitoUserSession session) {
+    private void deleteAttributesInternal(final List<String> attributeNamesToDelete, final CognitoUserSession session) {
 
         // Check if session is valid
-        if (session == null) {
+        if (session == null)
             throw new CognitoNotAuthorizedException("user is not authenticated");
-        }
 
-        if (!session.isValid()) {
+        if (!session.isValid())
             throw new CognitoNotAuthorizedException("user is not authenticated");
-        }
 
         // Validate the attributes to delete list
-        if (attributeNamesToDelete == null) {
+        if (attributeNamesToDelete == null)
             return;
-        }
 
-        if (attributeNamesToDelete.size() < 1) {
+        if (attributeNamesToDelete.size() < 1)
             return;
-        }
 
         // Translating to AttributeNameType list
         DeleteUserAttributesRequest deleteUserAttributesRequest = new DeleteUserAttributesRequest();
         deleteUserAttributesRequest.setAccessToken(session.getAccessToken().getJWTToken());
         deleteUserAttributesRequest.setUserAttributeNames(attributeNamesToDelete);
 
-        cognitoIdentityProviderClient.deleteUserAttributes(deleteUserAttributesRequest);
+        this.cognitoIdentityProviderClient.deleteUserAttributes(deleteUserAttributesRequest);
     }
 
     /**
      * Sign-Out this user by removing all cached tokens.
      */
     public void signOut() {
-        cipSession = null;
+        this.cipSession = null;
         clearCachedTokens();
     }
 
     /**
      * Sign-out from all devices associated with this user, in background.
      *
-     * @param callback          REQUIRED: {@link GenericHandler} callback.
+     * @param callback
+     *            REQUIRED: {@link GenericHandler} callback.
      */
     public void globalSignOutInBackground(final GenericHandler callback) {
 
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
         final CognitoUser user = this;
 
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Handler handler = new Handler(context.getMainLooper());
+
                 Runnable returnCallback;
                 try {
                     CognitoUserSession session = user.getCachedSession();
@@ -1367,7 +1378,7 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -1376,18 +1387,19 @@ public void run() {
      * Sign-out from all devices associated with this user, in current thread.
      *
      * <p>
-     *     <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * <b>Note:</b> This method will perform network operations. Calling this method in applications' main thread will
+     * cause Android to throw NetworkOnMainThreadException.
      * </p>
-     * @param callback          REQUIRED: {@link GenericHandler} callback.
+     *
+     * @param callback
+     *            REQUIRED: {@link GenericHandler} callback.
      */
-    public void globalSignOut (GenericHandler callback) {
-        if (callback == null) {
+    public void globalSignOut(GenericHandler callback) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
 
         try {
-            globalSignOutInternal(this.getCachedSession());
+            globalSignOutInternal(getCachedSession());
             signOut();
             callback.onSuccess();
         } catch (Exception e) {
@@ -1398,39 +1410,38 @@ public void globalSignOut (GenericHandler callback) {
     /**
      * Internal method to Sign-Out from all devices of this user.
      *
-     * @param session                  REQUIRED: {@link GenericHandler} callback.
+     * @param session
+     *            REQUIRED: {@link GenericHandler} callback.
      */
     private void globalSignOutInternal(CognitoUserSession session) {
         // Check if session is valid
-        if (session == null) {
+        if (session == null)
             throw new CognitoNotAuthorizedException("user is not authenticated");
-        }
 
-        if (!session.isValid()) {
+        if (!session.isValid())
             throw new CognitoNotAuthorizedException("user is not authenticated");
-        }
 
         GlobalSignOutRequest globalSignOutRequest = new GlobalSignOutRequest();
         globalSignOutRequest.setAccessToken(getCachedSession().getAccessToken().getJWTToken());
 
-        cognitoIdentityProviderClient.globalSignOut(globalSignOutRequest);
+        this.cognitoIdentityProviderClient.globalSignOut(globalSignOutRequest);
     }
 
     /**
      * Deletes this user, in background.
      *
-     * @param callback                      REQUIRED: @link GenericHandler} callback.
+     * @param callback
+     *            REQUIRED: @link GenericHandler} callback.
      */
     public void deleteUserInBackground(final GenericHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
         final CognitoUser user = this;
 
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Handler handler = new Handler(context.getMainLooper());
+
                 Runnable returnCallback;
                 try {
                     CognitoUserSession session = user.getCachedSession();
@@ -1449,7 +1460,7 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -1457,18 +1468,19 @@ public void run() {
     /**
      * Deletes this user, in current thread.
      * <p>
-     *     <b>Note:</b> This method will perform network operations. Calling this method in applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * <b>Note:</b> This method will perform network operations. Calling this method in applications' main thread will
+     * cause Android to throw NetworkOnMainThreadException.
      * </p>
      *
-     * @param callback                      REQUIRED: @link GenericHandler} callback.
+     * @param callback
+     *            REQUIRED: @link GenericHandler} callback.
      */
     public void deleteUser(GenericHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
 
         try {
-            deleteUserInternal(this.getCachedSession());
+            deleteUserInternal(getCachedSession());
         } catch (Exception e) {
             callback.onFailure(e);
         }
@@ -1477,42 +1489,42 @@ public void deleteUser(GenericHandler callback) {
     /**
      * Internal method to delete a user.
      *
-     * @param session                       REQUIRED: A valid {@link CognitoUserSession}
+     * @param session
+     *            REQUIRED: A valid {@link CognitoUserSession}
      */
     private void deleteUserInternal(final CognitoUserSession session) {
 
         // Check if session is valid
-        if (session == null) {
+        if (session == null)
             throw new CognitoNotAuthorizedException("user is not authenticated");
-        }
 
-        if (!session.isValid()) {
+        if (!session.isValid())
             throw new CognitoNotAuthorizedException("user is not authenticated");
-        }
 
         DeleteUserRequest deleteUserRequest = new DeleteUserRequest();
         deleteUserRequest.setAccessToken(session.getAccessToken().getJWTToken());
 
-        cognitoIdentityProviderClient.deleteUser(deleteUserRequest);
+        this.cognitoIdentityProviderClient.deleteUser(deleteUserRequest);
     }
 
     /**
      * Set's user settings, in background.
      *
-     * @param cognitoUserSettings           REQUIRED: User settings as {@link CognitoUserSettings}.
-     * @param callback                      REQUIRED: {@link GenericHandler} callback.
+     * @param cognitoUserSettings
+     *            REQUIRED: User settings as {@link CognitoUserSettings}.
+     * @param callback
+     *            REQUIRED: {@link GenericHandler} callback.
      */
     public void setUserSettingsInBackground(final CognitoUserSettings cognitoUserSettings,
                                             final GenericHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
-        final CognitoUserSession session = this.getCachedSession();
+        final CognitoUserSession session = getCachedSession();
 
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Handler handler = new Handler(context.getMainLooper());
+
                 Runnable returnCallback;
                 try {
                     setUserSettingsInternal(cognitoUserSettings, session);
@@ -1530,7 +1542,7 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -1538,21 +1550,21 @@ public void run() {
     /**
      * Set's user settings, in current thread.
      * <p>
-     *     <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * <b>Note:</b> This method will perform network operations. Calling this method in applications' main thread will
+     * cause Android to throw NetworkOnMainThreadException.
      * </p>
      *
-     * @param cognitoUserSettings           REQUIRED: User settings as {@link CognitoUserSettings}.
-     * @param callback                      REQUIRED: {@link GenericHandler} callback.
+     * @param cognitoUserSettings
+     *            REQUIRED: User settings as {@link CognitoUserSettings}.
+     * @param callback
+     *            REQUIRED: {@link GenericHandler} callback.
      */
-    public void setUserSettings(CognitoUserSettings cognitoUserSettings,
-                                GenericHandler callback) {
-        if (callback == null) {
+    public void setUserSettings(CognitoUserSettings cognitoUserSettings, GenericHandler callback) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
 
         try {
-            setUserSettingsInternal(cognitoUserSettings, this.getCachedSession());
+            setUserSettingsInternal(cognitoUserSettings, getCachedSession());
         } catch (Exception e) {
             callback.onFailure(e);
         }
@@ -1561,24 +1573,23 @@ public void setUserSettings(CognitoUserSettings cognitoUserSettings,
     /**
      * Internal method to set MFA delivery options.
      *
-     * @param cognitoUserSettings           REQUIRED: {@link CognitoUserAttributes}, with MFA delivery options.
-     * @param session                       REQUIRED: A valid {@link CognitoUserSession}.
-     */
-    private void setUserSettingsInternal(CognitoUserSettings cognitoUserSettings,
-                                          CognitoUserSession session) {
-        if (session != null && session.isValid()) {
-            if (cognitoUserSettings == null) {
+     * @param cognitoUserSettings
+     *            REQUIRED: {@link CognitoUserAttributes}, with MFA delivery options.
+     * @param session
+     *            REQUIRED: A valid {@link CognitoUserSession}.
+     */
+    private void setUserSettingsInternal(CognitoUserSettings cognitoUserSettings, CognitoUserSession session) {
+        if ((session != null) && session.isValid()) {
+            if (cognitoUserSettings == null)
                 throw new CognitoParameterInvalidException("user attributes is null");
-            }
             SetUserSettingsRequest setUserSettingsRequest = new SetUserSettingsRequest();
             setUserSettingsRequest.setAccessToken(session.getAccessToken().getJWTToken());
             setUserSettingsRequest.setMFAOptions(cognitoUserSettings.getSettingsList());
 
             SetUserSettingsResult setUserSettingsResult =
-                    cognitoIdentityProviderClient.setUserSettings(setUserSettingsRequest); }
-        else {
+                this.cognitoIdentityProviderClient.setUserSettings(setUserSettingsRequest);
+        } else
             throw new CognitoNotAuthorizedException("user is not authenticated");
-        }
     }
 
     /**
@@ -1587,12 +1598,15 @@ private void setUserSettingsInternal(CognitoUserSettings cognitoUserSettings,
     private void clearCachedTokens() {
         try {
             // Clear all cached tokens.
-            SharedPreferences csiCachedTokens =  context.getSharedPreferences("CognitoIdentityProviderCache", 0);
-        
+            SharedPreferences csiCachedTokens =
+                this.context.getSharedPreferences("CognitoIdentityProviderCache.CognitoIdentityProvider."
+                                                  + this.clientId,
+                                                  0);
+
             // Format "key" strings
-            String csiIdTokenKey      =  String.format("CognitoIdentityProvider.%s.%s.idToken", clientId, userId);
-            String csiAccessTokenKey  =  String.format("CognitoIdentityProvider.%s.%s.accessToken", clientId, userId);
-            String csiRefreshTokenKey =  String.format("CognitoIdentityProvider.%s.%s.refreshToken", clientId, userId);
+            String csiIdTokenKey = this.userId + ".idToken";
+            String csiAccessTokenKey = this.userId + ".accessToken";
+            String csiRefreshTokenKey = this.userId + ".refreshToken";
 
             SharedPreferences.Editor cacheEdit = csiCachedTokens.edit();
             cacheEdit.remove(csiIdTokenKey);
@@ -1600,7 +1614,7 @@ private void clearCachedTokens() {
             cacheEdit.remove(csiRefreshTokenKey).apply();
         } catch (Exception e) {
             // Logging exception, this is not a fatal error
-            Log.e(TAG, "Error while deleting from SharedPreferences");
+            Log.e(this.TAG, "Error while deleting from SharedPreferences");
         }
     }
 
@@ -1613,61 +1627,70 @@ private CognitoUserSession readCachedTokens() {
         CognitoUserSession userSession = new CognitoUserSession(null, null, null);
 
         try {
-            SharedPreferences csiCachedTokens = context.getSharedPreferences("CognitoIdentityProviderCache", 0);
+            SharedPreferences csiCachedTokens =
+                this.context.getSharedPreferences("CognitoIdentityProviderCache.CognitoIdentityProvider."
+                                                  + this.clientId,
+                                                  0);
 
             // Format "key" strings
-            String csiIdTokenKey        = "CognitoIdentityProvider." + clientId + "." + userId + ".idToken";
-            String csiAccessTokenKey    = "CognitoIdentityProvider." + clientId + "." + userId + ".accessToken";
-            String csiRefreshTokenKey   = "CognitoIdentityProvider." + clientId + "." + userId + ".refreshToken";
+            String csiIdTokenKey = this.userId + ".idToken";
+            String csiAccessTokenKey = this.userId + ".accessToken";
+            String csiRefreshTokenKey = this.userId + ".refreshToken";
 
             if (csiCachedTokens.contains(csiIdTokenKey)) {
                 CognitoIdToken csiCachedIdToken = new CognitoIdToken(csiCachedTokens.getString(csiIdTokenKey, null));
-                CognitoAccessToken csiCachedAccessToken = new CognitoAccessToken(csiCachedTokens.getString(csiAccessTokenKey, null));
-                CognitoRefreshToken csiCachedRefreshToken = new CognitoRefreshToken(csiCachedTokens.getString(csiRefreshTokenKey, null));
+                CognitoAccessToken csiCachedAccessToken =
+                    new CognitoAccessToken(csiCachedTokens.getString(csiAccessTokenKey, null));
+                CognitoRefreshToken csiCachedRefreshToken =
+                    new CognitoRefreshToken(csiCachedTokens.getString(csiRefreshTokenKey, null));
                 userSession = new CognitoUserSession(csiCachedIdToken, csiCachedAccessToken, csiCachedRefreshToken);
             }
         } catch (Exception e) {
             // Logging exception, this is not a fatal error
-            Log.e(TAG, "Error while reading SharedPreferences");
+            Log.e(this.TAG, "Error while reading SharedPreferences");
         }
-        return  userSession;
+        return userSession;
     }
 
     /**
      * Cache tokens locally.
      *
-     * @param session           REQUIRED: Tokens to be cached.
+     * @param session
+     *            REQUIRED: Tokens to be cached.
      */
     private void cacheTokens(CognitoUserSession session) {
         try {
-            SharedPreferences csiCachedTokens = context.getSharedPreferences("CognitoIdentityProviderCache", 0);
+            // Create keys to look for cached tokens
 
-            String csiUserPoolId = pool.getUserPoolId();
+            SharedPreferences csiCachedTokens =
+                this.context.getSharedPreferences("CognitoIdentityProviderCache.CognitoIdentityProvider."
+                                                  + this.clientId,
+                                                  0);
 
-            // Create keys to look for cached tokens
-            String csiIdTokenKey        = "CognitoIdentityProvider." + clientId + "." + userId + ".idToken";
-            String csiAccessTokenKey    = "CognitoIdentityProvider." + clientId + "." + userId + ".accessToken";
-            String csiRefreshTokenKey   = "CognitoIdentityProvider." + clientId + "." + userId + ".refreshToken";
-            String csiLastUserKey       = "CognitoIdentityProvider." + clientId + ".LastAuthUser";
+            // Format "key" strings
+            String csiIdTokenKey = this.userId + ".idToken";
+            String csiAccessTokenKey = this.userId + ".accessToken";
+            String csiRefreshTokenKey = this.userId + ".refreshToken";
+            String csiLastUserKey = "LastAuthUser";
 
             // Store the data in Shared Preferences
             SharedPreferences.Editor cacheEdit = csiCachedTokens.edit();
             cacheEdit.putString(csiIdTokenKey, session.getIdToken().getJWTToken());
             cacheEdit.putString(csiAccessTokenKey, session.getAccessToken().getJWTToken());
             cacheEdit.putString(csiRefreshTokenKey, session.getRefreshToken().getToken());
-            cacheEdit.putString(csiLastUserKey, userId).apply();
+            cacheEdit.putString(csiLastUserKey, this.userId).apply();
 
         } catch (Exception e) {
             // Logging exception, this is not a fatal error
-            Log.e(TAG, "Error while writing to SharedPreferences.");
+            Log.e(this.TAG, "Error while writing to SharedPreferences.");
         }
     }
 
     /**
      * Creates a user session with the tokens from authentication.
      *
-     * @param authResult                        REQUIRED: Authentication result which contains the
-     *                                          tokens.
+     * @param authResult
+     *            REQUIRED: Authentication result which contains the tokens.
      * @return {@link CognitoUserSession} with the latest tokens.
      */
     private CognitoUserSession getCognitoUserSession(AuthenticationResultType authResult) {
@@ -1675,13 +1698,12 @@ private CognitoUserSession getCognitoUserSession(AuthenticationResultType authRe
     }
 
     /**
-     * Creates a user session with the tokens from authentication and overrider the refresh token
-     * with the value passed.
+     * Creates a user session with the tokens from authentication and overrider the refresh token with the value passed.
      *
-     * @param authResult                        REQUIRED: Authentication result which contains the
-     *                                          tokens.
-     * @param refreshTokenOverride              REQUIRED: This will be used to create a new session
-     *                                          object if it is not null.
+     * @param authResult
+     *            REQUIRED: Authentication result which contains the tokens.
+     * @param refreshTokenOverride
+     *            REQUIRED: This will be used to create a new session object if it is not null.
      * @return {@link CognitoUserSession} with the latest tokens.
      */
     private CognitoUserSession getCognitoUserSession(AuthenticationResultType authResult,
@@ -1694,9 +1716,9 @@ private CognitoUserSession getCognitoUserSession(AuthenticationResultType authRe
 
         CognitoRefreshToken refreshToken;
 
-        if (refreshTokenOverride != null) {
+        if (refreshTokenOverride != null)
             refreshToken = refreshTokenOverride;
-        } else {
+        else {
             String reftoken = authResult.getRefreshToken();
             refreshToken = new CognitoRefreshToken(reftoken);
         }
@@ -1706,60 +1728,67 @@ private CognitoUserSession getCognitoUserSession(AuthenticationResultType authRe
     /**
      * Internal method to refresh current {@link CognitoUserSession}, is a refresh token is available.
      *
-     * @param currSession           REQUIRED: Current cached {@link CognitoUserSession}.
+     * @param currSession
+     *            REQUIRED: Current cached {@link CognitoUserSession}.
      * @return {@link CognitoUserSession} with new access and id tokens.
      */
     private CognitoUserSession refreshSession(CognitoUserSession currSession) {
         CognitoUserSession cognitoUserSession = null;
         InitiateAuthRequest initiateAuthRequest = initiateRefreshTokenAuthRequest(currSession);
-        InitiateAuthResult refreshSessionResult = cognitoIdentityProviderClient.initiateAuth(initiateAuthRequest);
-        if (refreshSessionResult.getAuthenticationResult() == null) {
+        InitiateAuthResult refreshSessionResult = this.cognitoIdentityProviderClient.initiateAuth(initiateAuthRequest);
+        if (refreshSessionResult.getAuthenticationResult() == null)
             throw new CognitoNotAuthorizedException("user is not authenticated");
-        }
-        cognitoUserSession = getCognitoUserSession(refreshSessionResult.getAuthenticationResult(), currSession.getRefreshToken());
+        cognitoUserSession =
+            getCognitoUserSession(refreshSessionResult.getAuthenticationResult(), currSession.getRefreshToken());
         return cognitoUserSession;
     }
 
     /**
-     * This method sends the challenge response to the Cognito IDP service. The call to the Cognito IDP
-     * service returns a new challenge and a different method is called to process the challenge.
-     * Restarts authentication if the service cannot find a device-key.
+     * This method sends the challenge response to the Cognito IDP service. The call to the Cognito IDP service returns
+     * a new challenge and a different method is called to process the challenge. Restarts authentication if the service
+     * cannot find a device-key.
      *
-     * @param challengeResponse             REQUIRED: {@link RespondToAuthChallengeRequest} contains
-     *                                      response for the current challenge.
-     * @param callback                      REQUIRED: {@link AuthenticationHandler} callback.
-     * @param runInBackground               REQUIRED: Boolean to indicate the current threading.
+     * @param challengeResponse
+     *            REQUIRED: {@link RespondToAuthChallengeRequest} contains response for the current challenge.
+     * @param callback
+     *            REQUIRED: {@link AuthenticationHandler} callback.
+     * @param runInBackground
+     *            REQUIRED: Boolean to indicate the current threading.
      * @return {@link Runnable} for the next step in user authentication.
      */
-    public Runnable respondToChallenge(final RespondToAuthChallengeRequest challengeResponse, final AuthenticationHandler callback, final boolean runInBackground) {
+    public Runnable respondToChallenge(final RespondToAuthChallengeRequest challengeResponse,
+                                       final AuthenticationHandler callback, final boolean runInBackground) {
         try {
-            if (challengeResponse != null && challengeResponse.getChallengeResponses() != null) {
+            if ((challengeResponse != null) && (challengeResponse.getChallengeResponses() != null)) {
                 Map<String, String> challengeResponses = challengeResponse.getChallengeResponses();
-                challengeResponses.put(CognitoServiceConstants.CHLG_RESP_DEVICE_KEY, deviceKey);
+                challengeResponses.put(CognitoServiceConstants.CHLG_RESP_DEVICE_KEY, this.deviceKey);
                 challengeResponse.setChallengeResponses(challengeResponses);
             }
-            RespondToAuthChallengeResult challenge = cognitoIdentityProviderClient.respondToAuthChallenge(challengeResponse);
+            RespondToAuthChallengeResult challenge =
+                this.cognitoIdentityProviderClient.respondToAuthChallenge(challengeResponse);
             return handleChallenge(challenge, callback, runInBackground);
         } catch (final ResourceNotFoundException rna) {
             final CognitoUser cognitoUser = this;
             if (rna.getMessage().contains("Device")) {
-                CognitoDeviceHelper.clearCachedDevice(usernameInternal, pool.getUserPoolId(), context);
+                CognitoDeviceHelper.clearCachedDevice(this.usernameInternal, this.pool.getUserPoolId(), this.context);
                 return new Runnable() {
                     @Override
                     public void run() {
                         AuthenticationContinuation authenticationContinuation =
-                                new AuthenticationContinuation(cognitoUser, context, runInBackground, callback);
+                            new AuthenticationContinuation(cognitoUser,
+                                                           CognitoUser.this.context,
+                                                           runInBackground,
+                                                           callback);
                         callback.getAuthenticationDetails(authenticationContinuation, cognitoUser.getUserId());
                     }
                 };
-            } else {
+            } else
                 return new Runnable() {
                     @Override
                     public void run() {
                         callback.onFailure(rna);
                     }
                 };
-            }
         } catch (final Exception e) {
             return new Runnable() {
                 @Override
@@ -1771,48 +1800,55 @@ public void run() {
     }
 
     /**
-     * This method starts the user authentication with user password verification.
-     * Restarts authentication if the service cannot find a device-key.
+     * This method starts the user authentication with user password verification. Restarts authentication if the
+     * service cannot find a device-key.
      *
-     * @param authenticationDetails         REQUIRED: {@link AuthenticationDetails} contains user details
-     *                                      for authentication.
-     * @param callback                      REQUIRED: {@link AuthenticationHandler} callback.
-     * @param runInBackground               REQUIRED: Boolean to indicate the current threading.
+     * @param authenticationDetails
+     *            REQUIRED: {@link AuthenticationDetails} contains user details for authentication.
+     * @param callback
+     *            REQUIRED: {@link AuthenticationHandler} callback.
+     * @param runInBackground
+     *            REQUIRED: Boolean to indicate the current threading.
      * @return {@link Runnable} for the next step in user authentication.
      */
-    private Runnable startWithUserSrpAuth(final AuthenticationDetails authenticationDetails, final AuthenticationHandler callback, final boolean runInBackground) {
-        AuthenticationHelper authenticationHelper = new AuthenticationHelper(pool.getUserPoolId());
-        InitiateAuthRequest initiateAuthRequest = initiateUserSrpAuthRequest(authenticationDetails, authenticationHelper);
+    private Runnable startWithUserSrpAuth(final AuthenticationDetails authenticationDetails,
+                                          final AuthenticationHandler callback, final boolean runInBackground) {
+        AuthenticationHelper authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolId());
+        InitiateAuthRequest initiateAuthRequest =
+            initiateUserSrpAuthRequest(authenticationDetails, authenticationHelper);
         try {
-            InitiateAuthResult initiateAuthResult = cognitoIdentityProviderClient.initiateAuth(initiateAuthRequest);
+            InitiateAuthResult initiateAuthResult =
+                this.cognitoIdentityProviderClient.initiateAuth(initiateAuthRequest);
             updateInternalUsername(initiateAuthResult.getChallengeParameters());
-            if (CognitoServiceConstants.CHLG_TYPE_USER_PASSWORD_VERIFIER.equals(initiateAuthResult.getChallengeName())) {
+            if (CognitoServiceConstants.CHLG_TYPE_USER_PASSWORD_VERIFIER.equals(initiateAuthResult.getChallengeName()))
                 if (authenticationDetails.getPassword() != null) {
-                    RespondToAuthChallengeRequest challengeRequest = userSrpAuthRequest(initiateAuthResult, authenticationDetails, authenticationHelper);
+                    RespondToAuthChallengeRequest challengeRequest =
+                        userSrpAuthRequest(initiateAuthResult, authenticationDetails, authenticationHelper);
                     return respondToChallenge(challengeRequest, callback, runInBackground);
                 }
-            }
             return handleChallenge(initiateAuthResult, callback, runInBackground);
         } catch (final ResourceNotFoundException rna) {
             final CognitoUser cognitoUser = this;
             if (rna.getMessage().contains("Device")) {
-                CognitoDeviceHelper.clearCachedDevice(usernameInternal, pool.getUserPoolId(), context);
+                CognitoDeviceHelper.clearCachedDevice(this.usernameInternal, this.pool.getUserPoolId(), this.context);
                 return new Runnable() {
                     @Override
                     public void run() {
                         AuthenticationContinuation authenticationContinuation =
-                                new AuthenticationContinuation(cognitoUser, context, runInBackground, callback);
+                            new AuthenticationContinuation(cognitoUser,
+                                                           CognitoUser.this.context,
+                                                           runInBackground,
+                                                           callback);
                         callback.getAuthenticationDetails(authenticationContinuation, cognitoUser.getUserId());
                     }
                 };
-            } else {
+            } else
                 return new Runnable() {
                     @Override
                     public void run() {
                         callback.onFailure(rna);
                     }
                 };
-            }
         } catch (final Exception e) {
             return new Runnable() {
                 @Override
@@ -1826,17 +1862,21 @@ public void run() {
     /**
      * This method starts the user authentication with a custom (developer defined) flow.
      *
-     * @param authenticationDetails         REQUIRED: {@link AuthenticationDetails} contains details
-     *                                      about the custom authentication flow.
-     * @param callback                      REQUIRED: {@link AuthenticationHandler} callback.
-     * @param runInBackground               REQUIRED: Boolean to indicate the current threading.
+     * @param authenticationDetails
+     *            REQUIRED: {@link AuthenticationDetails} contains details about the custom authentication flow.
+     * @param callback
+     *            REQUIRED: {@link AuthenticationHandler} callback.
+     * @param runInBackground
+     *            REQUIRED: Boolean to indicate the current threading.
      * @return {@link Runnable} for the next step in user authentication.
      */
-    private Runnable startWithCustomAuth(final AuthenticationDetails authenticationDetails, final AuthenticationHandler callback, final boolean runInBackground) {
+    private Runnable startWithCustomAuth(final AuthenticationDetails authenticationDetails,
+                                         final AuthenticationHandler callback, final boolean runInBackground) {
         InitiateAuthRequest initiateAuthRequest = initiateCustomAuthRequest(authenticationDetails);
         try {
-            InitiateAuthResult initiateAuthResult = cognitoIdentityProviderClient.initiateAuth(initiateAuthRequest);
-            return  handleChallenge(initiateAuthResult, callback, runInBackground);
+            InitiateAuthResult initiateAuthResult =
+                this.cognitoIdentityProviderClient.initiateAuth(initiateAuthRequest);
+            return handleChallenge(initiateAuthResult, callback, runInBackground);
         } catch (final Exception e) {
             return new Runnable() {
                 @Override
@@ -1848,23 +1888,25 @@ public void run() {
     }
 
     /**
-     * Find the next step from the challenge.
-     * This is an important step in the generic authentication flow. After the responding to a challenge,
-     * the results are analyzed here to determine the next step in the authentication process.
-     * Like all other methods in this SDK, this is designed to work with Continuation objects.
-     * This method returns a {@link Runnable} with the code to be executed, for the next step, to the invoking Continuation.
-     * The possible steps are
-     *  1) Authentication was successful and we have the tokens, in this case we call {@code onSuccess()} to return the tokens.
-     *  2) User password is required, an AuthenticationContinuation is created.
-     *  3) MFA validation is required, a MultiFactorAuthenticationContinuation object is created.
-     *  4) Other generic challenge, the challenge details are passed to the user.
+     * Find the next step from the challenge. This is an important step in the generic authentication flow. After the
+     * responding to a challenge, the results are analyzed here to determine the next step in the authentication
+     * process. Like all other methods in this SDK, this is designed to work with Continuation objects. This method
+     * returns a {@link Runnable} with the code to be executed, for the next step, to the invoking Continuation. The
+     * possible steps are 1) Authentication was successful and we have the tokens, in this case we call
+     * {@code onSuccess()} to return the tokens. 2) User password is required, an AuthenticationContinuation is created.
+     * 3) MFA validation is required, a MultiFactorAuthenticationContinuation object is created. 4) Other generic
+     * challenge, the challenge details are passed to the user.
      *
-     * @param challenge                 REQUIRED: Current challenge details, {@link RespondToAuthChallengeResult}.
-     * @param callback                  REQUIRED: {@link AuthenticationDetails} callback.
-     * @param runInBackground           REQUIRED: Boolean to indicate the current threading.
+     * @param challenge
+     *            REQUIRED: Current challenge details, {@link RespondToAuthChallengeResult}.
+     * @param callback
+     *            REQUIRED: {@link AuthenticationDetails} callback.
+     * @param runInBackground
+     *            REQUIRED: Boolean to indicate the current threading.
      * @return {@link Runnable} for the next step in user authentication.
      */
-    private Runnable handleChallenge(final RespondToAuthChallengeResult challenge, final AuthenticationHandler callback, final boolean runInBackground) {
+    private Runnable handleChallenge(final RespondToAuthChallengeResult challenge, final AuthenticationHandler callback,
+                                     final boolean runInBackground) {
         Runnable nextTask;
         final CognitoUser cognitoUser = this;
         nextTask = new Runnable() {
@@ -1874,9 +1916,8 @@ public void run() {
             }
         };
 
-        if (challenge == null) {
-            return  nextTask;
-        }
+        if (challenge == null)
+            return nextTask;
 
         updateInternalUsername(challenge.getChallengeParameters());
         String challengeName = challenge.getChallengeName();
@@ -1884,48 +1925,65 @@ public void run() {
             final CognitoUserSession cognitoUserSession = getCognitoUserSession(challenge.getAuthenticationResult());
             cacheTokens(cognitoUserSession);
             NewDeviceMetadataType newDeviceMetadata = challenge.getAuthenticationResult().getNewDeviceMetadata();
-            if (newDeviceMetadata == null) {
+            if (newDeviceMetadata == null)
                 nextTask = new Runnable() {
                     @Override
                     public void run() {
                         callback.onSuccess(cognitoUserSession, null);
                     }
                 };
-            } else {
+            else {
                 ConfirmDeviceResult confirmDeviceResult = confirmDevice(newDeviceMetadata);
-                if (confirmDeviceResult != null && confirmDeviceResult.isUserConfirmationNecessary()) {
-                    final CognitoDevice newDevice = new CognitoDevice(newDeviceMetadata.getDeviceKey(), null, null, null, null, cognitoUser, context);
+                if ((confirmDeviceResult != null) && confirmDeviceResult.isUserConfirmationNecessary()) {
+                    final CognitoDevice newDevice =
+                        new CognitoDevice(newDeviceMetadata.getDeviceKey(),
+                                          null,
+                                          null,
+                                          null,
+                                          null,
+                                          cognitoUser,
+                                          this.context);
                     nextTask = new Runnable() {
                         @Override
                         public void run() {
                             callback.onSuccess(cognitoUserSession, newDevice);
                         }
                     };
-                } else {
+                } else
                     nextTask = new Runnable() {
                         @Override
                         public void run() {
                             callback.onSuccess(cognitoUserSession, null);
                         }
                     };
-                }
             }
-        } else if (CognitoServiceConstants.CHLG_TYPE_USER_PASSWORD_VERIFIER.equals(challengeName)) {
+        } else if (CognitoServiceConstants.CHLG_TYPE_USER_PASSWORD_VERIFIER.equals(challengeName))
             return nextTask;
-        } else if (CognitoServiceConstants.CHLG_TYPE_SMS_MFA.equals(challengeName)) {
+        else if (CognitoServiceConstants.CHLG_TYPE_SMS_MFA.equals(challengeName)) {
             final MultiFactorAuthenticationContinuation multiFactorAuthenticationContinuation =
-                    new MultiFactorAuthenticationContinuation(cognitoUser, context, challenge, runInBackground, callback);
+                new MultiFactorAuthenticationContinuation(cognitoUser,
+                                                          this.context,
+                                                          challenge,
+                                                          runInBackground,
+                                                          callback);
             nextTask = new Runnable() {
                 @Override
                 public void run() {
                     callback.getMFACode(multiFactorAuthenticationContinuation);
                 }
             };
-        } else if (CognitoServiceConstants.CHLG_TYPE_DEVICE_SRP_AUTH.equals(challengeName)) {
+        } else if (CognitoServiceConstants.CHLG_TYPE_DEVICE_SRP_AUTH.equals(challengeName))
             nextTask = deviceSrpAuthentication(challenge, callback, runInBackground);
-        } else if (CognitoServiceConstants.CHLG_TYPE_NEW_PASSWORD_REQUIRED.equals(challengeName)) {
+        else if (CognitoServiceConstants.CHLG_TYPE_NEW_PASSWORD_REQUIRED.equals(challengeName)) {
             final NewPasswordContinuation newPasswordContinuation =
-                    new NewPasswordContinuation(cognitoUser, context, usernameInternal, clientId, secretHash, challenge, runInBackground, callback);
+                new NewPasswordContinuation(cognitoUser,
+                                            this.context,
+                                            this.usernameInternal,
+                                            this.clientId,
+                                            this.secretHash,
+                                            challenge,
+                                            runInBackground,
+                                            callback);
             nextTask = new Runnable() {
                 @Override
                 public void run() {
@@ -1934,7 +1992,14 @@ public void run() {
             };
         } else {
             final ChallengeContinuation challengeContinuation =
-                    new ChallengeContinuation(cognitoUser, context, usernameInternal, clientId, secretHash, challenge, runInBackground, callback);
+                new ChallengeContinuation(cognitoUser,
+                                          this.context,
+                                          this.usernameInternal,
+                                          this.clientId,
+                                          this.secretHash,
+                                          challenge,
+                                          runInBackground,
+                                          callback);
             nextTask = new Runnable() {
                 @Override
                 public void run() {
@@ -1946,16 +2011,20 @@ public void run() {
     }
 
     /**
-     * Determines the next step from the challenge.
-     * This takes an object of type {@link InitiateAuthResult} as parameter and creates an object of type
-     * {@link RespondToAuthChallengeResult} and calls {@code handleChallenge(RespondToAuthChallengeResult challenge, final AuthenticationHandler callback)} method.
+     * Determines the next step from the challenge. This takes an object of type {@link InitiateAuthResult} as parameter
+     * and creates an object of type {@link RespondToAuthChallengeResult} and calls
+     * {@code handleChallenge(RespondToAuthChallengeResult challenge, final AuthenticationHandler callback)} method.
      *
-     * @param authResult        REQUIRED: Result from the {@code initiateAuth(...)} method.
-     * @param callback          REQUIRED: Callback for type {@link AuthenticationHandler}
-     * @param runInBackground   REQUIRED: Boolean to indicate the current threading.
+     * @param authResult
+     *            REQUIRED: Result from the {@code initiateAuth(...)} method.
+     * @param callback
+     *            REQUIRED: Callback for type {@link AuthenticationHandler}
+     * @param runInBackground
+     *            REQUIRED: Boolean to indicate the current threading.
      * @return {@link Runnable} for the next step in user authentication.
      */
-    private Runnable handleChallenge(final InitiateAuthResult authResult, final AuthenticationHandler callback, final boolean runInBackground) {
+    private Runnable handleChallenge(final InitiateAuthResult authResult, final AuthenticationHandler callback,
+                                     final boolean runInBackground) {
         try {
             RespondToAuthChallengeResult challenge = new RespondToAuthChallengeResult();
             challenge.setChallengeName(authResult.getChallengeName());
@@ -1974,36 +2043,47 @@ public void run() {
     }
 
     /**
-     * Performs device SRP authentication to identify remembered devices. Restarts authentication if
-     * the device verification does not succeed.
+     * Performs device SRP authentication to identify remembered devices. Restarts authentication if the device
+     * verification does not succeed.
      *
-     * @param challenge         REQUIRED: {@link RespondToAuthChallengeResult}, contains the current challenge.
-     * @param callback          REQUIRED: {@link AuthenticationHandler} callback.
-     * @param runInBackground   REQUIRED: Boolean to indicate the current threading.
+     * @param challenge
+     *            REQUIRED: {@link RespondToAuthChallengeResult}, contains the current challenge.
+     * @param callback
+     *            REQUIRED: {@link AuthenticationHandler} callback.
+     * @param runInBackground
+     *            REQUIRED: Boolean to indicate the current threading.
      * @return {@link Runnable} for the next step in user authentication.
      */
-    private Runnable deviceSrpAuthentication(final RespondToAuthChallengeResult challenge, final AuthenticationHandler callback, final boolean runInBackground) {
-        String deviceSecret = CognitoDeviceHelper.getDeviceSecret(usernameInternal, pool.getUserPoolId(), context);
-        String deviceGroupKey = CognitoDeviceHelper.getDeviceGroupKey(usernameInternal, pool.getUserPoolId(), context);
+    private Runnable deviceSrpAuthentication(final RespondToAuthChallengeResult challenge,
+                                             final AuthenticationHandler callback, final boolean runInBackground) {
+        String deviceSecret =
+            CognitoDeviceHelper.getDeviceSecret(this.usernameInternal, this.pool.getUserPoolId(), this.context);
+        String deviceGroupKey =
+            CognitoDeviceHelper.getDeviceGroupKey(this.usernameInternal, this.pool.getUserPoolId(), this.context);
         AuthenticationHelper authenticationHelper = new AuthenticationHelper(deviceGroupKey);
         RespondToAuthChallengeRequest devicesAuthRequest = initiateDevicesAuthRequest(authenticationHelper);
         try {
-            RespondToAuthChallengeResult initiateDeviceAuthResult = cognitoIdentityProviderClient.respondToAuthChallenge(devicesAuthRequest);
+            RespondToAuthChallengeResult initiateDeviceAuthResult =
+                this.cognitoIdentityProviderClient.respondToAuthChallenge(devicesAuthRequest);
             if (CognitoServiceConstants.CHLG_TYPE_DEVICE_PASSWORD_VERIFIER.equals(initiateDeviceAuthResult.getChallengeName())) {
-                RespondToAuthChallengeRequest challengeResponse = deviceSrpAuthRequest(initiateDeviceAuthResult, deviceSecret, deviceGroupKey, authenticationHelper);
-                RespondToAuthChallengeResult deviceSRPAuthResult = cognitoIdentityProviderClient.respondToAuthChallenge(challengeResponse);
+                RespondToAuthChallengeRequest challengeResponse =
+                    deviceSrpAuthRequest(initiateDeviceAuthResult, deviceSecret, deviceGroupKey, authenticationHelper);
+                RespondToAuthChallengeResult deviceSRPAuthResult =
+                    this.cognitoIdentityProviderClient.respondToAuthChallenge(challengeResponse);
                 return handleChallenge(deviceSRPAuthResult, callback, runInBackground);
-            } else {
+            } else
                 return handleChallenge(initiateDeviceAuthResult, callback, runInBackground);
-            }
         } catch (final NotAuthorizedException na) {
             final CognitoUser cognitoUser = this;
-            CognitoDeviceHelper.clearCachedDevice(usernameInternal, pool.getUserPoolId(), context);
+            CognitoDeviceHelper.clearCachedDevice(this.usernameInternal, this.pool.getUserPoolId(), this.context);
             return new Runnable() {
                 @Override
                 public void run() {
                     AuthenticationContinuation authenticationContinuation =
-                            new AuthenticationContinuation(cognitoUser, context, runInBackground, callback);
+                        new AuthenticationContinuation(cognitoUser,
+                                                       CognitoUser.this.context,
+                                                       runInBackground,
+                                                       callback);
                     callback.getAuthenticationDetails(authenticationContinuation, cognitoUser.getUserId());
                 }
             };
@@ -2020,29 +2100,38 @@ public void run() {
     /**
      * Creates a authentication request to start authentication with user SRP verification.
      *
-     * @param authenticationDetails     REQUIRED: {@link AuthenticationDetails}, contains details for
-     *                                  user SRP authentication.
-     * @param authenticationHelper      REQUIRED: Internal helper class for SRP calculations.
+     * @param authenticationDetails
+     *            REQUIRED: {@link AuthenticationDetails}, contains details for user SRP authentication.
+     * @param authenticationHelper
+     *            REQUIRED: Internal helper class for SRP calculations.
      * @return {@link InitiateAuthRequest}, request to start with the user SRP authentication.
      */
-    private InitiateAuthRequest initiateUserSrpAuthRequest(AuthenticationDetails authenticationDetails, AuthenticationHelper authenticationHelper) {
-        userId = authenticationDetails.getUserId();
+    private InitiateAuthRequest initiateUserSrpAuthRequest(AuthenticationDetails authenticationDetails,
+                                                           AuthenticationHelper authenticationHelper) {
+        this.userId = authenticationDetails.getUserId();
         InitiateAuthRequest initiateAuthRequest = new InitiateAuthRequest();
         initiateAuthRequest.setAuthFlow(CognitoServiceConstants.AUTH_TYPE_INIT_USER_SRP);
-        initiateAuthRequest.setClientId(clientId);
-        initiateAuthRequest.addAuthParametersEntry(CognitoServiceConstants.AUTH_PARAM_SECRET_HASH, CognitoSecretHash.getSecretHash(userId, clientId, clientSecret));
-        initiateAuthRequest.addAuthParametersEntry(CognitoServiceConstants.AUTH_PARAM_USERNAME, authenticationDetails.getUserId());
-        initiateAuthRequest.addAuthParametersEntry(CognitoServiceConstants.AUTH_PARAM_SRP_A, authenticationHelper.getA().toString(16));
-        if (deviceKey == null) {
-            initiateAuthRequest.addAuthParametersEntry(CognitoServiceConstants.AUTH_PARAM_DEVICE_KEY, CognitoDeviceHelper.getDeviceKey(authenticationDetails.getUserId(), pool.getUserPoolId(), context));
-        } else {
-            initiateAuthRequest.addAuthParametersEntry(CognitoServiceConstants.AUTH_PARAM_DEVICE_KEY, deviceKey);
-        }
-        if (authenticationDetails.getValidationData() != null && authenticationDetails.getValidationData().size() > 0) {
+        initiateAuthRequest.setClientId(this.clientId);
+        initiateAuthRequest.addAuthParametersEntry(CognitoServiceConstants.AUTH_PARAM_SECRET_HASH,
+                                                   CognitoSecretHash.getSecretHash(this.userId,
+                                                                                   this.clientId,
+                                                                                   this.clientSecret));
+        initiateAuthRequest.addAuthParametersEntry(CognitoServiceConstants.AUTH_PARAM_USERNAME,
+                                                   authenticationDetails.getUserId());
+        initiateAuthRequest.addAuthParametersEntry(CognitoServiceConstants.AUTH_PARAM_SRP_A,
+                                                   authenticationHelper.getA().toString(16));
+        if (this.deviceKey == null)
+            initiateAuthRequest.addAuthParametersEntry(CognitoServiceConstants.AUTH_PARAM_DEVICE_KEY,
+                                                       CognitoDeviceHelper.getDeviceKey(authenticationDetails.getUserId(),
+                                                                                        this.pool.getUserPoolId(),
+                                                                                        this.context));
+        else
+            initiateAuthRequest.addAuthParametersEntry(CognitoServiceConstants.AUTH_PARAM_DEVICE_KEY, this.deviceKey);
+        if ((authenticationDetails.getValidationData() != null)
+            && (authenticationDetails.getValidationData().size() > 0)) {
             Map<String, String> userValidationData = new HashMap<String, String>();
-            for (AttributeType attribute : authenticationDetails.getValidationData()) {
+            for (AttributeType attribute : authenticationDetails.getValidationData())
                 userValidationData.put(attribute.getName(), attribute.getValue());
-            }
             initiateAuthRequest.setClientMetadata(userValidationData);
         }
         return initiateAuthRequest;
@@ -2051,20 +2140,21 @@ private InitiateAuthRequest initiateUserSrpAuthRequest(AuthenticationDetails aut
     /**
      * Creates a authentication request to start authentication with custom authentication.
      *
-     * @param authenticationDetails     REQUIRED: {@link AuthenticationDetails}, contains details
-     *                                  required to start a custom authentication flow.
+     * @param authenticationDetails
+     *            REQUIRED: {@link AuthenticationDetails}, contains details required to start a custom authentication
+     *            flow.
      * @return {@link InitiateAuthRequest}, request to start with the user SRP authentication.
      */
     private InitiateAuthRequest initiateCustomAuthRequest(AuthenticationDetails authenticationDetails) {
         InitiateAuthRequest authRequest = new InitiateAuthRequest();
         authRequest.setAuthFlow(CognitoServiceConstants.AUTH_TYPE_INIT_CUSTOM_AUTH);
-        authRequest.setClientId(clientId);
+        authRequest.setClientId(this.clientId);
         authRequest.setAuthParameters(authenticationDetails.getAuthenticationParameters());
-        if (authenticationDetails.getValidationData() != null && authenticationDetails.getValidationData().size() > 0) {
+        if ((authenticationDetails.getValidationData() != null)
+            && (authenticationDetails.getValidationData().size() > 0)) {
             Map<String, String> userValidationData = new HashMap<String, String>();
-            for (AttributeType attribute : authenticationDetails.getValidationData()) {
+            for (AttributeType attribute : authenticationDetails.getValidationData())
                 userValidationData.put(attribute.getName(), attribute.getValue());
-            }
             authRequest.setClientMetadata(userValidationData);
         }
         return authRequest;
@@ -2073,18 +2163,23 @@ private InitiateAuthRequest initiateCustomAuthRequest(AuthenticationDetails auth
     /**
      * Creates a request to initiate device authentication.
      *
-     * @param authenticationHelper      REQUIRED: {@link AuthenticationDetails}, contains details
-     *                                  required to start a custom authentication flow.
+     * @param authenticationHelper
+     *            REQUIRED: {@link AuthenticationDetails}, contains details required to start a custom authentication
+     *            flow.
      * @return {@link RespondToAuthChallengeRequest}, request to start device authentication.
      */
     private RespondToAuthChallengeRequest initiateDevicesAuthRequest(AuthenticationHelper authenticationHelper) {
         RespondToAuthChallengeRequest initiateDevicesAuthRequest = new RespondToAuthChallengeRequest();
-        initiateDevicesAuthRequest.setClientId(clientId);
+        initiateDevicesAuthRequest.setClientId(this.clientId);
         initiateDevicesAuthRequest.setChallengeName(CognitoServiceConstants.CHLG_TYPE_DEVICE_SRP_AUTH);
-        initiateDevicesAuthRequest.addChallengeResponsesEntry(CognitoServiceConstants.CHLG_RESP_USERNAME, usernameInternal);
-        initiateDevicesAuthRequest.addChallengeResponsesEntry(CognitoServiceConstants.CHLG_RESP_SRP_A, authenticationHelper.getA().toString(16));
-        initiateDevicesAuthRequest.addChallengeResponsesEntry(CognitoServiceConstants.CHLG_RESP_DEVICE_KEY, deviceKey);
-        initiateDevicesAuthRequest.addChallengeResponsesEntry(CognitoServiceConstants.CHLG_RESP_SECRET_HASH, secretHash);
+        initiateDevicesAuthRequest.addChallengeResponsesEntry(CognitoServiceConstants.CHLG_RESP_USERNAME,
+                                                              this.usernameInternal);
+        initiateDevicesAuthRequest.addChallengeResponsesEntry(CognitoServiceConstants.CHLG_RESP_SRP_A,
+                                                              authenticationHelper.getA().toString(16));
+        initiateDevicesAuthRequest.addChallengeResponsesEntry(CognitoServiceConstants.CHLG_RESP_DEVICE_KEY,
+                                                              this.deviceKey);
+        initiateDevicesAuthRequest.addChallengeResponsesEntry(CognitoServiceConstants.CHLG_RESP_SECRET_HASH,
+                                                              this.secretHash);
 
         return initiateDevicesAuthRequest;
     }
@@ -2092,22 +2187,23 @@ private RespondToAuthChallengeRequest initiateDevicesAuthRequest(AuthenticationH
     /**
      * Creates a request to refresh tokens.
      *
-     * @param currSession             REQUIRED: Refresh token.
-     * @return  {@link InitiateAuthRequest}, request to refresh tokens.
+     * @param currSession
+     *            REQUIRED: Refresh token.
+     * @return {@link InitiateAuthRequest}, request to refresh tokens.
      */
     private InitiateAuthRequest initiateRefreshTokenAuthRequest(CognitoUserSession currSession) {
         InitiateAuthRequest initiateAuthRequest = new InitiateAuthRequest();
-        initiateAuthRequest.addAuthParametersEntry(CognitoServiceConstants.AUTH_PARAM_REFRESH_TOKEN, currSession.getRefreshToken().getToken());
-        if (deviceKey == null) {
-            if (usernameInternal != null) {
-                deviceKey = CognitoDeviceHelper.getDeviceKey(usernameInternal, pool.getUserPoolId(), context);
-            } else {
-                deviceKey = CognitoDeviceHelper.getDeviceKey(userId, pool.getUserPoolId(), context);
-            }
-        }
-        initiateAuthRequest.addAuthParametersEntry(CognitoServiceConstants.AUTH_PARAM_DEVICE_KEY, deviceKey);
-        initiateAuthRequest.addAuthParametersEntry(CognitoServiceConstants.AUTH_PARAM_SECRET_HASH, clientSecret);
-        initiateAuthRequest.setClientId(clientId);
+        initiateAuthRequest.addAuthParametersEntry(CognitoServiceConstants.AUTH_PARAM_REFRESH_TOKEN,
+                                                   currSession.getRefreshToken().getToken());
+        if (this.deviceKey == null)
+            if (this.usernameInternal != null)
+                this.deviceKey =
+                    CognitoDeviceHelper.getDeviceKey(this.usernameInternal, this.pool.getUserPoolId(), this.context);
+            else
+                this.deviceKey = CognitoDeviceHelper.getDeviceKey(this.userId, this.pool.getUserPoolId(), this.context);
+        initiateAuthRequest.addAuthParametersEntry(CognitoServiceConstants.AUTH_PARAM_DEVICE_KEY, this.deviceKey);
+        initiateAuthRequest.addAuthParametersEntry(CognitoServiceConstants.AUTH_PARAM_SECRET_HASH, this.clientSecret);
+        initiateAuthRequest.setClientId(this.clientId);
         initiateAuthRequest.setAuthFlow(CognitoServiceConstants.AUTH_TYPE_REFRESH_TOKEN);
         return initiateAuthRequest;
     }
@@ -2115,26 +2211,34 @@ private InitiateAuthRequest initiateRefreshTokenAuthRequest(CognitoUserSession c
     /**
      * Creates response for the second step of the SRP authentication.
      *
-     * @param challenge                     REQUIRED: {@link InitiateAuthResult} contains next challenge.
-     * @param authenticationDetails         REQUIRED: {@link AuthenticationDetails} user authentication details.
-     * @param authenticationHelper          REQUIRED: Internal helper class for SRP calculations.
+     * @param challenge
+     *            REQUIRED: {@link InitiateAuthResult} contains next challenge.
+     * @param authenticationDetails
+     *            REQUIRED: {@link AuthenticationDetails} user authentication details.
+     * @param authenticationHelper
+     *            REQUIRED: Internal helper class for SRP calculations.
      * @return {@link RespondToAuthChallengeRequest}.
      */
     private RespondToAuthChallengeRequest userSrpAuthRequest(InitiateAuthResult challenge,
                                                              AuthenticationDetails authenticationDetails,
                                                              AuthenticationHelper authenticationHelper) {
-        String userIdForSRP = challenge.getChallengeParameters().get(CognitoServiceConstants.CHLG_PARAM_USER_ID_FOR_SRP);
+        String userIdForSRP =
+            challenge.getChallengeParameters().get(CognitoServiceConstants.CHLG_PARAM_USER_ID_FOR_SRP);
         this.usernameInternal = challenge.getChallengeParameters().get(CognitoServiceConstants.CHLG_PARAM_USERNAME);
-        this.deviceKey = CognitoDeviceHelper.getDeviceKey(usernameInternal, pool.getUserPoolId(), context);
-        secretHash = CognitoSecretHash.getSecretHash(usernameInternal, clientId, clientSecret);
+        this.deviceKey =
+            CognitoDeviceHelper.getDeviceKey(this.usernameInternal, this.pool.getUserPoolId(), this.context);
+        this.secretHash = CognitoSecretHash.getSecretHash(this.usernameInternal, this.clientId, this.clientSecret);
 
         BigInteger B = new BigInteger(challenge.getChallengeParameters().get("SRP_B"), 16);
-        if (B.mod(AuthenticationHelper.N).equals(BigInteger.ZERO)) {
+        if (B.mod(AuthenticationHelper.N).equals(BigInteger.ZERO))
             throw new CognitoInternalErrorException("SRP error, B cannot be zero");
-        }
 
         BigInteger salt = new BigInteger(challenge.getChallengeParameters().get("SALT"), 16);
-        byte[] key = authenticationHelper.getPasswordAuthenticationKey(userIdForSRP, authenticationDetails.getPassword(), B, salt);
+        byte[] key =
+            authenticationHelper.getPasswordAuthenticationKey(userIdForSRP,
+                                                              authenticationDetails.getPassword(),
+                                                              B,
+                                                              salt);
 
         Date timestamp = new Date();
         byte[] hmac;
@@ -2142,7 +2246,7 @@ private RespondToAuthChallengeRequest userSrpAuthRequest(InitiateAuthResult chal
             Mac mac = Mac.getInstance("HmacSHA256");
             SecretKeySpec keySpec = new SecretKeySpec(key, "HmacSHA256");
             mac.init(keySpec);
-            mac.update(pool.getUserPoolId().split("_", 2)[1].getBytes(StringUtils.UTF8));
+            mac.update(this.pool.getUserPoolId().split("_", 2)[1].getBytes(StringUtils.UTF8));
             mac.update(userIdForSRP.getBytes(StringUtils.UTF8));
             byte[] secretBlock = Base64.decode(challenge.getChallengeParameters().get("SECRET_BLOCK"));
             mac.update(secretBlock);
@@ -2159,16 +2263,18 @@ private RespondToAuthChallengeRequest userSrpAuthRequest(InitiateAuthResult chal
         formatTimestamp.setTimeZone(new SimpleTimeZone(SimpleTimeZone.UTC_TIME, "UTC"));
 
         Map<String, String> srpAuthResponses = new HashMap<String, String>();
-        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_PASSWORD_CLAIM_SECRET_BLOCK, challenge.getChallengeParameters().get(CognitoServiceConstants.CHLG_PARAM_SECRET_BLOCK));
-        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_PASSWORD_CLAIM_SIGNATURE, new String(Base64.encode(hmac), StringUtils.UTF8));
+        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_PASSWORD_CLAIM_SECRET_BLOCK,
+                             challenge.getChallengeParameters().get(CognitoServiceConstants.CHLG_PARAM_SECRET_BLOCK));
+        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_PASSWORD_CLAIM_SIGNATURE,
+                             new String(Base64.encode(hmac), StringUtils.UTF8));
         srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_TIMESTAMP, formatTimestamp.format(timestamp));
-        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_USERNAME, usernameInternal);
-        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_DEVICE_KEY, deviceKey);
-        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_SECRET_HASH, secretHash);
+        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_USERNAME, this.usernameInternal);
+        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_DEVICE_KEY, this.deviceKey);
+        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_SECRET_HASH, this.secretHash);
 
         RespondToAuthChallengeRequest authChallengeRequest = new RespondToAuthChallengeRequest();
         authChallengeRequest.setChallengeName(challenge.getChallengeName());
-        authChallengeRequest.setClientId(clientId);
+        authChallengeRequest.setClientId(this.clientId);
         authChallengeRequest.setSession(challenge.getSession());
         authChallengeRequest.setChallengeResponses(srpAuthResponses);
 
@@ -2178,24 +2284,25 @@ private RespondToAuthChallengeRequest userSrpAuthRequest(InitiateAuthResult chal
     /**
      * Creates request for device SRP verification.
      *
-     * @param challenge                     REQUIRED: {@link RespondToAuthChallengeResult} contains next challenge.
-     * @param deviceSecret                  REQUIRED: Device secret verifier.
-     * @param authenticationHelper          REQUIRED: Internal helper class for SRP calculations.
+     * @param challenge
+     *            REQUIRED: {@link RespondToAuthChallengeResult} contains next challenge.
+     * @param deviceSecret
+     *            REQUIRED: Device secret verifier.
+     * @param authenticationHelper
+     *            REQUIRED: Internal helper class for SRP calculations.
      * @return {@link RespondToAuthChallengeRequest}.
      */
     public RespondToAuthChallengeRequest deviceSrpAuthRequest(RespondToAuthChallengeResult challenge,
-                                                              String deviceSecret,
-                                                              String deviceGroupKey,
+                                                              String deviceSecret, String deviceGroupKey,
                                                               AuthenticationHelper authenticationHelper) {
         this.usernameInternal = challenge.getChallengeParameters().get(CognitoServiceConstants.CHLG_PARAM_USERNAME);
 
         BigInteger B = new BigInteger(challenge.getChallengeParameters().get("SRP_B"), 16);
-        if (B.mod(AuthenticationHelper.N).equals(BigInteger.ZERO)) {
+        if (B.mod(AuthenticationHelper.N).equals(BigInteger.ZERO))
             throw new CognitoInternalErrorException("SRP error, B cannot be zero");
-        }
 
         BigInteger salt = new BigInteger(challenge.getChallengeParameters().get("SALT"), 16);
-        byte[] key = authenticationHelper.getPasswordAuthenticationKey(deviceKey, deviceSecret, B, salt);
+        byte[] key = authenticationHelper.getPasswordAuthenticationKey(this.deviceKey, deviceSecret, B, salt);
 
         Date timestamp = new Date();
         byte[] hmac;
@@ -2204,8 +2311,9 @@ public RespondToAuthChallengeRequest deviceSrpAuthRequest(RespondToAuthChallenge
             SecretKeySpec keySpec = new SecretKeySpec(key, "HmacSHA256");
             mac.init(keySpec);
             mac.update(deviceGroupKey.getBytes(StringUtils.UTF8));
-            mac.update(deviceKey.getBytes(StringUtils.UTF8));
-            byte[] secretBlock = Base64.decode(challenge.getChallengeParameters().get(CognitoServiceConstants.CHLG_PARAM_SECRET_BLOCK));
+            mac.update(this.deviceKey.getBytes(StringUtils.UTF8));
+            byte[] secretBlock =
+                Base64.decode(challenge.getChallengeParameters().get(CognitoServiceConstants.CHLG_PARAM_SECRET_BLOCK));
             mac.update(secretBlock);
             SimpleDateFormat simpleDateFormat = new SimpleDateFormat("EEE MMM d HH:mm:ss z yyyy", Locale.US);
             simpleDateFormat.setTimeZone(new SimpleTimeZone(SimpleTimeZone.UTC_TIME, "UTC"));
@@ -2219,19 +2327,21 @@ public RespondToAuthChallengeRequest deviceSrpAuthRequest(RespondToAuthChallenge
         SimpleDateFormat formatTimestamp = new SimpleDateFormat("EEE MMM d HH:mm:ss z yyyy", Locale.US);
         formatTimestamp.setTimeZone(new SimpleTimeZone(SimpleTimeZone.UTC_TIME, "UTC"));
 
-        secretHash = CognitoSecretHash.getSecretHash(usernameInternal, clientId, clientSecret);
+        this.secretHash = CognitoSecretHash.getSecretHash(this.usernameInternal, this.clientId, this.clientSecret);
 
         Map<String, String> srpAuthResponses = new HashMap<String, String>();
-        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_PASSWORD_CLAIM_SECRET_BLOCK, challenge.getChallengeParameters().get(CognitoServiceConstants.CHLG_PARAM_SECRET_BLOCK));
-        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_PASSWORD_CLAIM_SIGNATURE, new String(Base64.encode(hmac), StringUtils.UTF8));
+        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_PASSWORD_CLAIM_SECRET_BLOCK,
+                             challenge.getChallengeParameters().get(CognitoServiceConstants.CHLG_PARAM_SECRET_BLOCK));
+        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_PASSWORD_CLAIM_SIGNATURE,
+                             new String(Base64.encode(hmac), StringUtils.UTF8));
         srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_TIMESTAMP, formatTimestamp.format(timestamp));
-        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_USERNAME, usernameInternal);
-        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_DEVICE_KEY, deviceKey);
-        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_SECRET_HASH, secretHash);
+        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_USERNAME, this.usernameInternal);
+        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_DEVICE_KEY, this.deviceKey);
+        srpAuthResponses.put(CognitoServiceConstants.CHLG_RESP_SECRET_HASH, this.secretHash);
 
         RespondToAuthChallengeRequest authChallengeRequest = new RespondToAuthChallengeRequest();
         authChallengeRequest.setChallengeName(challenge.getChallengeName());
-        authChallengeRequest.setClientId(clientId);
+        authChallengeRequest.setClientId(this.clientId);
         authChallengeRequest.setSession(challenge.getSession());
         authChallengeRequest.setChallengeResponses(srpAuthResponses);
 
@@ -2241,28 +2351,30 @@ public RespondToAuthChallengeRequest deviceSrpAuthRequest(RespondToAuthChallenge
     /**
      * Fetches the list of all remembered devices for this user.
      *
-     * @param limit                         REQUIRED: Maximum number of devices to be returned in this call, defaults to 10.
-     * @param paginationToken               REQUIRED: Token to continue an earlier search.
-     * @param callback                      REQUIRED: {@link DevicesHandler} callback.
+     * @param limit
+     *            REQUIRED: Maximum number of devices to be returned in this call, defaults to 10.
+     * @param paginationToken
+     *            REQUIRED: Token to continue an earlier search.
+     * @param callback
+     *            REQUIRED: {@link DevicesHandler} callback.
      */
     public void listDevicesInBackground(final int limit, final String paginationToken, final DevicesHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
 
         final CognitoUser user = this;
 
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Handler handler = new Handler(context.getMainLooper());
+
                 Runnable returnCallback;
                 try {
-                    ListDevicesResult listDevicesResult = listDevicesInternal(user.getCachedSession(), limit, paginationToken);
+                    ListDevicesResult listDevicesResult =
+                        listDevicesInternal(user.getCachedSession(), limit, paginationToken);
                     final List<CognitoDevice> devicesList = new ArrayList<CognitoDevice>();
-                    for (DeviceType device : listDevicesResult.getDevices()) {
-                        devicesList.add(new CognitoDevice(device, user, context));
-                    }
+                    for (DeviceType device : listDevicesResult.getDevices())
+                        devicesList.add(new CognitoDevice(device, user, CognitoUser.this.context));
                     returnCallback = new Runnable() {
                         @Override
                         public void run() {
@@ -2278,7 +2390,7 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -2286,21 +2398,22 @@ public void run() {
     /**
      * Fetches the list of all remembered devices for this user, runs in current thread.
      *
-     * @param limit                         REQUIRED: Maximum number of devices to be returned in this call, defaults to 10.
-     * @param paginationToken               REQUIRED: Token to continue an earlier search.
-     * @param callback                      REQUIRED: {@link DevicesHandler} callback.
+     * @param limit
+     *            REQUIRED: Maximum number of devices to be returned in this call, defaults to 10.
+     * @param paginationToken
+     *            REQUIRED: Token to continue an earlier search.
+     * @param callback
+     *            REQUIRED: {@link DevicesHandler} callback.
      */
     public void listDevices(int limit, String paginationToken, DevicesHandler callback) {
-        if (callback == null) {
+        if (callback == null)
             throw new CognitoParameterInvalidException("callback is null");
-        }
-        
+
         try {
             ListDevicesResult listDevicesResult = listDevicesInternal(getCachedSession(), limit, paginationToken);
             List<CognitoDevice> devicesList = new ArrayList<CognitoDevice>();
-            for (DeviceType device : listDevicesResult.getDevices()) {
-                devicesList.add(new CognitoDevice(device, this, context));
-            }
+            for (DeviceType device : listDevicesResult.getDevices())
+                devicesList.add(new CognitoDevice(device, this, this.context));
             callback.onSuccess(devicesList);
         } catch (Exception e) {
             callback.onFailure(e);
@@ -2313,82 +2426,104 @@ public void listDevices(int limit, String paginationToken, DevicesHandler callba
      * @return {@link CognitoDevice} if the device is available, null otherwise.
      */
     public CognitoDevice thisDevice() {
-        if (deviceKey == null) {
-            if (usernameInternal != null) {
-                deviceKey = CognitoDeviceHelper.getDeviceKey(usernameInternal, pool.getUserPoolId(), context);
-            } else if (userId != null) {
-                deviceKey = CognitoDeviceHelper.getDeviceKey(userId, pool.getUserPoolId(), context);
-            }
-        }
-        if (deviceKey != null) {
-            return new CognitoDevice(deviceKey, null, null, null, null, this, context);
-        } else {
-            return  null;
-        }
+        if (this.deviceKey == null)
+            if (this.usernameInternal != null)
+                this.deviceKey =
+                    CognitoDeviceHelper.getDeviceKey(this.usernameInternal, this.pool.getUserPoolId(), this.context);
+            else if (this.userId != null)
+                this.deviceKey = CognitoDeviceHelper.getDeviceKey(this.userId, this.pool.getUserPoolId(), this.context);
+        if (this.deviceKey != null)
+            return new CognitoDevice(this.deviceKey, null, null, null, null, this, this.context);
+        else
+            return null;
     }
 
     /**
-     * The method confirms a device. If this device can be remembered and if this is a new device,
-     * a new device key is generated at the end of a successful authentication. SRP verification is
-     * performed by the service, during the next authentication attempts, to identify this device.
-     * This method generates the necessary tokens to enable the device SRP verification.
+     * The method confirms a device. If this device can be remembered and if this is a new device, a new device key is
+     * generated at the end of a successful authentication. SRP verification is performed by the service, during the
+     * next authentication attempts, to identify this device. This method generates the necessary tokens to enable the
+     * device SRP verification.
      *
-     * @param deviceMetadata        REQUIRED: Metadata for the new device.
+     * @param deviceMetadata
+     *            REQUIRED: Metadata for the new device.
      */
     private ConfirmDeviceResult confirmDevice(final NewDeviceMetadataType deviceMetadata) {
-        Map<String, String> deviceSrpVerifiers = CognitoDeviceHelper.generateVerificationParameters(deviceMetadata.getDeviceKey(), deviceMetadata.getDeviceGroupKey());
+        Map<String, String> deviceSrpVerifiers =
+            CognitoDeviceHelper.generateVerificationParameters(deviceMetadata.getDeviceKey(),
+                                                               deviceMetadata.getDeviceGroupKey());
 
         ConfirmDeviceResult confirmDeviceResult = new ConfirmDeviceResult();
         confirmDeviceResult.setUserConfirmationNecessary(false);
         try {
-            confirmDeviceResult = confirmDeviceInternal(getCachedSession(), deviceMetadata.getDeviceKey(), deviceSrpVerifiers.get("verifier"), deviceSrpVerifiers.get("salt"), CognitoDeviceHelper.getDeviceName());
+            confirmDeviceResult =
+                confirmDeviceInternal(getCachedSession(),
+                                      deviceMetadata.getDeviceKey(),
+                                      deviceSrpVerifiers.get("verifier"),
+                                      deviceSrpVerifiers.get("salt"),
+                                      CognitoDeviceHelper.getDeviceName());
         } catch (Exception e) {
-            Log.e(TAG, "Device confirmation failed: " + e.getMessage());
+            Log.e(this.TAG, "Device confirmation failed: " + e.getMessage(), e);
             return null;
         }
-        CognitoDeviceHelper.cacheDeviceKey(usernameInternal, pool.getUserPoolId(), deviceMetadata.getDeviceKey(), context);
-        CognitoDeviceHelper.cacheDeviceVerifier(usernameInternal, pool.getUserPoolId(), deviceSrpVerifiers.get("secret"), context);
-        CognitoDeviceHelper.cacheDeviceGroupKey(usernameInternal, pool.getUserPoolId(), deviceMetadata.getDeviceGroupKey(), context);
+        CognitoDeviceHelper.cacheDeviceKey(this.usernameInternal,
+                                           this.pool.getUserPoolId(),
+                                           deviceMetadata.getDeviceKey(),
+                                           this.context);
+        CognitoDeviceHelper.cacheDeviceVerifier(this.usernameInternal,
+                                                this.pool.getUserPoolId(),
+                                                deviceSrpVerifiers.get("secret"),
+                                                this.context);
+        CognitoDeviceHelper.cacheDeviceGroupKey(this.usernameInternal,
+                                                this.pool.getUserPoolId(),
+                                                deviceMetadata.getDeviceGroupKey(),
+                                                this.context);
         return confirmDeviceResult;
     }
 
     /**
      * Internal method to fetch all devices trusted by this user.
      *
-     * @param session                           REQUIRED: A valid {@link CognitoUserSession}.
-     * @param limit                             REQUIRED: Maximum number of devices to fetch.
-     * @param paginationToken                   REQUIRED: Token to continue with the previous srearch.
+     * @param session
+     *            REQUIRED: A valid {@link CognitoUserSession}.
+     * @param limit
+     *            REQUIRED: Maximum number of devices to fetch.
+     * @param paginationToken
+     *            REQUIRED: Token to continue with the previous srearch.
      * @return {@link ListDevicesResult}, service response.
      */
     private ListDevicesResult listDevicesInternal(CognitoUserSession session, int limit, String paginationToken) {
-        if (session != null && session.isValid()) {
+        if ((session != null) && session.isValid()) {
             ListDevicesRequest listDevicesRequest = new ListDevicesRequest();
-            if (limit < 1) {
+            if (limit < 1)
                 listDevicesRequest.setLimit(CognitoDeviceHelper.DEFAULT_DEVICE_PAGINATION_LIMIT);
-            } else {
+            else
                 listDevicesRequest.setLimit(limit);
-            }
             listDevicesRequest.setPaginationToken(paginationToken);
             listDevicesRequest.setAccessToken(session.getAccessToken().getJWTToken());
-            return cognitoIdentityProviderClient.listDevices(listDevicesRequest);
-        } else {
+            return this.cognitoIdentityProviderClient.listDevices(listDevicesRequest);
+        } else
             throw new CognitoNotAuthorizedException("User is not authorized");
-        }
     }
 
     /**
      * Internal method to confirm a device.
      *
-     * @param session                           REQUIRED: A valid {@link CognitoUserSession}.
-     * @param deviceKey                         REQUIRED: This is the device-key assigned the new device.
-     * @param passwordVerifier                  REQUIRED: Random string generated by the SDK.
-     * @param salt                              REQUIRED: Generated by the SDK to set the device verifier.
-     * @param deviceName                        REQUIRED: A user identifiable string assigned to the device.
+     * @param session
+     *            REQUIRED: A valid {@link CognitoUserSession}.
+     * @param deviceKey
+     *            REQUIRED: This is the device-key assigned the new device.
+     * @param passwordVerifier
+     *            REQUIRED: Random string generated by the SDK.
+     * @param salt
+     *            REQUIRED: Generated by the SDK to set the device verifier.
+     * @param deviceName
+     *            REQUIRED: A user identifiable string assigned to the device.
      * @return {@link ConfirmDeviceResult}, service response.
      */
-    private ConfirmDeviceResult confirmDeviceInternal(CognitoUserSession session, String deviceKey, String passwordVerifier, String salt, String deviceName) {
-        if (session != null && session.isValid()) {
-            if (deviceKey != null && deviceName != null) {
+    private ConfirmDeviceResult confirmDeviceInternal(CognitoUserSession session, String deviceKey,
+                                                      String passwordVerifier, String salt, String deviceName) {
+        if ((session != null) && session.isValid()) {
+            if ((deviceKey != null) && (deviceName != null)) {
                 DeviceSecretVerifierConfigType deviceConfig = new DeviceSecretVerifierConfigType();
                 deviceConfig.setPasswordVerifier(passwordVerifier);
                 deviceConfig.setSalt(salt);
@@ -2397,34 +2532,32 @@ private ConfirmDeviceResult confirmDeviceInternal(CognitoUserSession session, St
                 confirmDeviceRequest.setDeviceKey(deviceKey);
                 confirmDeviceRequest.setDeviceName(deviceName);
                 confirmDeviceRequest.setDeviceSecretVerifierConfig(deviceConfig);
-                return cognitoIdentityProviderClient.confirmDevice(confirmDeviceRequest);
-            } else {
-                if (deviceKey == null) {
-                    throw new CognitoParameterInvalidException("Device key is null");
-                } else {
-                    throw new CognitoParameterInvalidException("Device name is null");
-                }
-            }
-        } else {
+                return this.cognitoIdentityProviderClient.confirmDevice(confirmDeviceRequest);
+            } else if (deviceKey == null)
+                throw new CognitoParameterInvalidException("Device key is null");
+            else
+                throw new CognitoParameterInvalidException("Device name is null");
+        } else
             throw new CognitoNotAuthorizedException("User is not authorized");
-        }
     }
 
     /**
      * Updates user's internal Username and device key from challenge parameters.
      *
-     * @param challengeParameters           REQUIRED: Challenge parameters.
+     * @param challengeParameters
+     *            REQUIRED: Challenge parameters.
      */
     private void updateInternalUsername(Map<String, String> challengeParameters) {
-        if (usernameInternal == null) {
-            if (challengeParameters != null && challengeParameters.containsKey(CognitoServiceConstants.CHLG_PARAM_USERNAME)) {
-                usernameInternal = challengeParameters.get(CognitoServiceConstants.CHLG_PARAM_USERNAME);
-                deviceKey = CognitoDeviceHelper.getDeviceKey(usernameInternal, pool.getUserPoolId(), context);
-                if (secretHash == null) {
-                    secretHash = CognitoSecretHash.getSecretHash(usernameInternal, clientId, clientSecret);
-                }
+        if (this.usernameInternal == null)
+            if ((challengeParameters != null)
+                && challengeParameters.containsKey(CognitoServiceConstants.CHLG_PARAM_USERNAME)) {
+                this.usernameInternal = challengeParameters.get(CognitoServiceConstants.CHLG_PARAM_USERNAME);
+                this.deviceKey =
+                    CognitoDeviceHelper.getDeviceKey(this.usernameInternal, this.pool.getUserPoolId(), this.context);
+                if (this.secretHash == null)
+                    this.secretHash =
+                        CognitoSecretHash.getSecretHash(this.usernameInternal, this.clientId, this.clientSecret);
             }
-        }
     }
 
     /**
@@ -2437,42 +2570,41 @@ private void updateInternalUsername(Map<String, String> challengeParameters) {
 
         public AuthenticationHelper(String userPoolName) {
             do {
-                a = new BigInteger(EPHEMERAL_KEY_LENGTH, SECURE_RANDOM).mod(N);
-                A = g.modPow(a, N);
-            } while (A.mod(N).equals(BigInteger.ZERO));
-
-            if (userPoolName.contains("_")) {
-                poolName = userPoolName.split("_", 2)[1];
-            } else {
-                poolName = userPoolName;
-            }
+                this.a = new BigInteger(EPHEMERAL_KEY_LENGTH, SECURE_RANDOM).mod(N);
+                this.A = g.modPow(this.a, N);
+            } while (this.A.mod(N).equals(BigInteger.ZERO));
+
+            if (userPoolName.contains("_"))
+                this.poolName = userPoolName.split("_", 2)[1];
+            else
+                this.poolName = userPoolName;
         }
 
         public BigInteger geta() {
-            return a;
+            return this.a;
         }
 
         public BigInteger getA() {
-            return A;
+            return this.A;
         }
 
         private static final String HEX_N =
-                "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
-                        + "29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
-                        + "EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
-                        + "E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
-                        + "EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
-                        + "C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
-                        + "83655D23DCA3AD961C62F356208552BB9ED529077096966D"
-                        + "670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"
-                        + "E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"
-                        + "DE2BCBF6955817183995497CEA956AE515D2261898FA0510"
-                        + "15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64"
-                        + "ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7"
-                        + "ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B"
-                        + "F12FFA06D98A0864D87602733EC86A64521F2B18177B200C"
-                        + "BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31"
-                        + "43DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF";
+            "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
+                                            + "29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
+                                            + "EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
+                                            + "E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
+                                            + "EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
+                                            + "C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
+                                            + "83655D23DCA3AD961C62F356208552BB9ED529077096966D"
+                                            + "670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"
+                                            + "E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"
+                                            + "DE2BCBF6955817183995497CEA956AE515D2261898FA0510"
+                                            + "15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64"
+                                            + "ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7"
+                                            + "ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B"
+                                            + "F12FFA06D98A0864D87602733EC86A64521F2B18177B200C"
+                                            + "BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31"
+                                            + "43DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF";
         private static final BigInteger N = new BigInteger(HEX_N, 16);
         private static final BigInteger g = BigInteger.valueOf(2);
         private static final BigInteger k;
@@ -2481,17 +2613,16 @@ public BigInteger getA() {
         private static final int DERIVED_KEY_SIZE = 16;
         private static final String DERIVED_KEY_INFO = "Caldera Derived Key";
 
-        private static final ThreadLocal<MessageDigest> THREAD_MESSAGE_DIGEST =
-                new ThreadLocal<MessageDigest>() {
-                    @Override
-                    protected MessageDigest initialValue() {
-                        try {
-                            return MessageDigest.getInstance("SHA-256");
-                        } catch (NoSuchAlgorithmException e) {
-                            throw new CognitoInternalErrorException("Exception in authentication", e);
-                        }
-                    }
-                };
+        private static final ThreadLocal<MessageDigest> THREAD_MESSAGE_DIGEST = new ThreadLocal<MessageDigest>() {
+            @Override
+            protected MessageDigest initialValue() {
+                try {
+                    return MessageDigest.getInstance("SHA-256");
+                } catch (NoSuchAlgorithmException e) {
+                    throw new CognitoInternalErrorException("Exception in authentication", e);
+                }
+            }
+        };
 
         private static final SecureRandom SECURE_RANDOM;
 
@@ -2509,31 +2640,27 @@ protected MessageDigest initialValue() {
             }
         }
 
-        public byte[] getPasswordAuthenticationKey(String userId,
-                                                   String userPassword,
-                                                   BigInteger B,
-                                                   BigInteger salt) {
+        public byte[] getPasswordAuthenticationKey(String userId, String userPassword, BigInteger B, BigInteger salt) {
             // Authenticate the password
             // u = H(A, B)
             MessageDigest messageDigest = THREAD_MESSAGE_DIGEST.get();
             messageDigest.reset();
-            messageDigest.update(A.toByteArray());
+            messageDigest.update(this.A.toByteArray());
             BigInteger u = new BigInteger(1, messageDigest.digest(B.toByteArray()));
-            if (u.equals(BigInteger.ZERO)) {
+            if (u.equals(BigInteger.ZERO))
                 throw new CognitoInternalErrorException("Hash of A and B cannot be zero");
-            }
 
             // x = H(salt | H(poolName | userId | ":" | password))
             messageDigest.reset();
-            messageDigest.update(poolName.getBytes(StringUtils.UTF8));
+            messageDigest.update(this.poolName.getBytes(StringUtils.UTF8));
             messageDigest.update(userId.getBytes(StringUtils.UTF8));
             messageDigest.update(":".getBytes(StringUtils.UTF8));
-            byte [] userIdHash = messageDigest.digest(userPassword.getBytes(StringUtils.UTF8));
+            byte[] userIdHash = messageDigest.digest(userPassword.getBytes(StringUtils.UTF8));
 
             messageDigest.reset();
             messageDigest.update(salt.toByteArray());
             BigInteger x = new BigInteger(1, messageDigest.digest(userIdHash));
-            BigInteger S = (B.subtract(k.multiply(g.modPow(x,N))).modPow(a.add(u.multiply(x)), N)).mod(N);
+            BigInteger S = (B.subtract(k.multiply(g.modPow(x, N))).modPow(this.a.add(u.multiply(x)), N)).mod(N);
 
             Hkdf hkdf = null;
             try {
diff --git a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/CognitoUserPool.java b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/CognitoUserPool.java
index 845feedb4b..3a877729cd 100644
--- a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/CognitoUserPool.java
+++ b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/CognitoUserPool.java
@@ -17,11 +17,15 @@
 
 package com.amazonaws.mobileconnectors.cognitoidentityprovider;
 
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.os.Handler;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+import org.eclipse.swt.widgets.Display;
 
 import com.amazonaws.ClientConfiguration;
+import com.amazonaws.adroid.utils.Context;
+import com.amazonaws.adroid.utils.SharedPreferences;
 import com.amazonaws.auth.AnonymousAWSCredentials;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.handlers.AuthenticationHandler;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.handlers.SignUpHandler;
@@ -33,28 +37,23 @@
 import com.amazonaws.services.cognitoidentityprovider.model.SignUpRequest;
 import com.amazonaws.services.cognitoidentityprovider.model.SignUpResult;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
 /**
- * This represents a user-pool in a Cognito identity provider account. The user-pools are called as
- * <b>Cognito User Identity Pool</b> or <b>User Identity Pool</b> or <b>User Pool</b>. All of these
- * terms represent the same entity, which is a pool of users in your account.
+ * This represents a user-pool in a Cognito identity provider account. The user-pools are called as <b>Cognito User
+ * Identity Pool</b> or <b>User Identity Pool</b> or <b>User Pool</b>. All of these terms represent the same entity,
+ * which is a pool of users in your account.
  * <p>
- *     A user-pool can have these:
+ * A user-pool can have these:
  *
- *     1) User pool ID, {@code userPoolId}. This is an unique identifier for your user pool. This is
- *     a required parameter to use the SDK.
+ * 1) User pool ID, {@code userPoolId}. This is an unique identifier for your user pool. This is a required parameter to
+ * use the SDK.
  *
- *     2) Client identifier, {@code clientId}. This is generated for a user pool and each user pool
- *     can have several of these. A client identifier will associated with one, and only one, user
- *     pool. This is required to use the SDK. A client identifier can have one or no client secrets.
+ * 2) Client identifier, {@code clientId}. This is generated for a user pool and each user pool can have several of
+ * these. A client identifier will associated with one, and only one, user pool. This is required to use the SDK. A
+ * client identifier can have one or no client secrets.
  *
- *     3) Client secret, {@code clientSecret}. This is generated for a Client identified. A client
- *     identifier may have a client secret, it is not necessary to generate a client secret for all
- *     client identifiers. However if a client identifier has a client secret then this client secret
- *     has to be used, along with the client identifier, in the SDK.
+ * 3) Client secret, {@code clientSecret}. This is generated for a Client identified. A client identifier may have a
+ * client secret, it is not necessary to generate a client secret for all client identifiers. However if a client
+ * identifier has a client secret then this client secret has to be used, along with the client identifier, in the SDK.
  * </p>
  *
  * On a user-pool new user's can sign-up and create new {@link CognitoUser}.
@@ -71,10 +70,10 @@
     private final String clientId;
 
     /**
-     * Client secret generated for this {@code clientId}, this may be {@code null} if a secret is not
-     * generated for the {@code clientId}.
+     * Client secret generated for this {@code clientId}, this may be {@code null} if a secret is not generated for the
+     * {@code clientId}.
      */
-    private String clientSecret;
+    private final String clientSecret;
 
     /**
      * Application context.
@@ -92,18 +91,22 @@
     private String secretHash;
 
     /**
-     * Constructs a user-pool with a developer specified {@link ClientConfiguration} and default AWS region {@link Regions}.
-     * Region defaults to US-EAST-1.
+     * Constructs a user-pool with a developer specified {@link ClientConfiguration} and default AWS region
+     * {@link Regions}. Region defaults to US-EAST-1.
      *
-     * @param context               REQUIRED: Android application context
-     * @param userPoolId            REQUIRED: User-pool-Id of the user-pool
-     * @param clientId              REQUIRED: Client-Id generated for this app and user-pool at the
-     *                              Cognito Identity Provider developer console
-     * @param clientSecret          REQUIRED: Client Secret generated for this app and user-pool at
-     *                              the Cognito Identity Provider developer console
-     * @param clientConfiguration   REQUIRED: The client configuration options controlling how this
-     *                              client connects to Cognito Identity Provider Service (e.g. proxy settings,
-     *                              retry counts, etc.).
+     * @param context
+     *            REQUIRED: Android application context
+     * @param userPoolId
+     *            REQUIRED: User-pool-Id of the user-pool
+     * @param clientId
+     *            REQUIRED: Client-Id generated for this app and user-pool at the Cognito Identity Provider developer
+     *            console
+     * @param clientSecret
+     *            REQUIRED: Client Secret generated for this app and user-pool at the Cognito Identity Provider
+     *            developer console
+     * @param clientConfiguration
+     *            REQUIRED: The client configuration options controlling how this client connects to Cognito Identity
+     *            Provider Service (e.g. proxy settings, retry counts, etc.).
      */
     public CognitoUserPool(Context context, String userPoolId, String clientId, String clientSecret,
                            ClientConfiguration clientConfiguration) {
@@ -111,15 +114,19 @@ public CognitoUserPool(Context context, String userPoolId, String clientId, Stri
     }
 
     /**
-     * Constructs a user-pool with default {@link ClientConfiguration} and default AWS region {@link Regions}.
-     * Region defaults to US-EAST-1.
+     * Constructs a user-pool with default {@link ClientConfiguration} and default AWS region {@link Regions}. Region
+     * defaults to US-EAST-1.
      *
-     * @param context               REQUIRED: Android application context.
-     * @param userPoolId            REQUIRED: User-pool-Id of the user-pool.
-     * @param clientId              REQUIRED: Client-Id generated for this app and user-pool at the
-     *                              Cognito Identity Provider developer console.
-     * @param clientSecret          REQUIRED: Client Secret generated for this app and user-pool at
-     *                              the Cognito Identity Provider developer console.
+     * @param context
+     *            REQUIRED: Android application context.
+     * @param userPoolId
+     *            REQUIRED: User-pool-Id of the user-pool.
+     * @param clientId
+     *            REQUIRED: Client-Id generated for this app and user-pool at the Cognito Identity Provider developer
+     *            console.
+     * @param clientSecret
+     *            REQUIRED: Client Secret generated for this app and user-pool at the Cognito Identity Provider
+     *            developer console.
      */
     public CognitoUserPool(Context context, String userPoolId, String clientId, String clientSecret) {
         this(context, userPoolId, clientId, clientSecret, new ClientConfiguration(), Regions.US_EAST_1);
@@ -128,13 +135,18 @@ public CognitoUserPool(Context context, String userPoolId, String clientId, Stri
     /**
      * Constructs a user-pool with default {@link ClientConfiguration}.
      *
-     * @param context               REQUIRED: Android application context.
-     * @param userPoolId            REQUIRED: User-pool-Id of the user-pool.
-     * @param clientId              REQUIRED: Client-Id generated for this app and user-pool at the
-     *                              Cognito Identity Provider developer console.
-     * @param clientSecret          REQUIRED: Client Secret generated for this app and user-pool at
-     *                              the Cognito Identity Provider developer console.
-     * @param region                REQUIRED: AWS region {@link Regions}.
+     * @param context
+     *            REQUIRED: Android application context.
+     * @param userPoolId
+     *            REQUIRED: User-pool-Id of the user-pool.
+     * @param clientId
+     *            REQUIRED: Client-Id generated for this app and user-pool at the Cognito Identity Provider developer
+     *            console.
+     * @param clientSecret
+     *            REQUIRED: Client Secret generated for this app and user-pool at the Cognito Identity Provider
+     *            developer console.
+     * @param region
+     *            REQUIRED: AWS region {@link Regions}.
      */
     public CognitoUserPool(Context context, String userPoolId, String clientId, String clientSecret, Regions region) {
         this(context, userPoolId, clientId, clientSecret, new ClientConfiguration(), region);
@@ -143,18 +155,24 @@ public CognitoUserPool(Context context, String userPoolId, String clientId, Stri
     /**
      * Constructs a user-pool.
      *
-     * @param context               REQUIRED: Android application context.
-     * @param userPoolId            REQUIRED: User-pool-Id of the user-pool.
-     * @param clientId              REQUIRED: Client-Id generated for this app and user-pool at the
-     *                              Cognito Identity Provider developer console.
-     * @param clientSecret          REQUIRED: Client Secret generated for this app and user-pool at
-     *                              the Cognito Identity Provider developer console.
-     * @param clientConfiguration   REQUIRED: The client configuration options controlling how this
-     *                              client connects to Cognito Identity Provider Service (e.g. proxy settings,
-     *                              retry counts, etc.).
-     * @param region                REQUIRED: AWS region {@link Regions}.
+     * @param context
+     *            REQUIRED: Android application context.
+     * @param userPoolId
+     *            REQUIRED: User-pool-Id of the user-pool.
+     * @param clientId
+     *            REQUIRED: Client-Id generated for this app and user-pool at the Cognito Identity Provider developer
+     *            console.
+     * @param clientSecret
+     *            REQUIRED: Client Secret generated for this app and user-pool at the Cognito Identity Provider
+     *            developer console.
+     * @param clientConfiguration
+     *            REQUIRED: The client configuration options controlling how this client connects to Cognito Identity
+     *            Provider Service (e.g. proxy settings, retry counts, etc.).
+     * @param region
+     *            REQUIRED: AWS region {@link Regions}.
      */
-    public CognitoUserPool(Context context, String userPoolId, String clientId, String clientSecret, ClientConfiguration clientConfiguration, Regions region) {
+    public CognitoUserPool(Context context, String userPoolId, String clientId, String clientSecret,
+                           ClientConfiguration clientConfiguration, Regions region) {
         this.context = context;
         this.userPoolId = userPoolId;
         this.clientId = clientId;
@@ -166,15 +184,21 @@ public CognitoUserPool(Context context, String userPoolId, String clientId, Stri
     /**
      * Constructs a user-pool with default {@link ClientConfiguration}.
      *
-     * @param context               REQUIRED: Android application context.
-     * @param userPoolId            REQUIRED: User-pool-Id of the user-pool.
-     * @param clientId              REQUIRED: Client-Id generated for this app and user-pool at the
-     *                              Cognito Identity Provider developer console.
-     * @param clientSecret          REQUIRED: Client Secret generated for this app and user-pool at
-     *                              the Cognito Identity Provider developer console.
-     * @param client                REQUIRED: AWS low-level Cognito Identity Provider Client.
+     * @param context
+     *            REQUIRED: Android application context.
+     * @param userPoolId
+     *            REQUIRED: User-pool-Id of the user-pool.
+     * @param clientId
+     *            REQUIRED: Client-Id generated for this app and user-pool at the Cognito Identity Provider developer
+     *            console.
+     * @param clientSecret
+     *            REQUIRED: Client Secret generated for this app and user-pool at the Cognito Identity Provider
+     *            developer console.
+     * @param client
+     *            REQUIRED: AWS low-level Cognito Identity Provider Client.
      */
-    public CognitoUserPool(Context context, String userPoolId, String clientId, String clientSecret, AmazonCognitoIdentityProvider client) {
+    public CognitoUserPool(Context context, String userPoolId, String clientId, String clientSecret,
+                           AmazonCognitoIdentityProvider client) {
         this.context = context;
         this.userPoolId = userPoolId;
         this.clientId = clientId;
@@ -188,7 +212,7 @@ public CognitoUserPool(Context context, String userPoolId, String clientId, Stri
      * @return Client ID.
      */
     public String getClientId() {
-    	return  clientId;
+        return this.clientId;
     }
 
     /**
@@ -197,39 +221,43 @@ public String getClientId() {
      * @return Your User Pool ID.
      */
     public String getUserPoolId() {
-        return userPoolId;
+        return this.userPoolId;
     }
 
     /**
      * Runs user registration in background.
      *
-     * @param userId            REQUIRED: userId for this user
-     * @param password          REQUIRED: Password for this user
-     * @param userAttributes    REQUIRED: Contains all attributes for this user
-     * @param validationData    REQUIRED: Parameters for lambda function for user registration
-     * @param callback          REQUIRED: callback, must not be null
+     * @param userId
+     *            REQUIRED: userId for this user
+     * @param password
+     *            REQUIRED: Password for this user
+     * @param userAttributes
+     *            REQUIRED: Contains all attributes for this user
+     * @param validationData
+     *            REQUIRED: Parameters for lambda function for user registration
+     * @param callback
+     *            REQUIRED: callback, must not be null
      */
     public void signUpInBackground(final String userId, final String password,
-                                         final CognitoUserAttributes userAttributes,
-                                         final Map<String, String> validationData,
-                                         final SignUpHandler callback) {
+                                   final CognitoUserAttributes userAttributes, final Map<String, String> validationData,
+                                   final SignUpHandler callback) {
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Handler handler = new Handler(context.getMainLooper());
+
                 Runnable returnCallback;
                 try {
-                    final SignUpResult signUpResult =
-                            signUpInternal(userId, password, userAttributes, validationData);
+                    final SignUpResult signUpResult = signUpInternal(userId, password, userAttributes, validationData);
                     final CognitoUser user = getUser(userId);
                     returnCallback = new Runnable() {
                         @Override
                         public void run() {
-                            callback.onSuccess(user, signUpResult.getUserConfirmed(),
-                                    new CognitoUserCodeDeliveryDetails(signUpResult.getCodeDeliveryDetails()));
+                            callback.onSuccess(user,
+                                               signUpResult.getUserConfirmed(),
+                                               new CognitoUserCodeDeliveryDetails(signUpResult.getCodeDeliveryDetails()));
                         }
                     };
-                } catch(final Exception e) {
+                } catch (final Exception e) {
                     returnCallback = new Runnable() {
                         @Override
                         public void run() {
@@ -237,7 +265,8 @@ public void run() {
                         }
                     };
                 }
-                handler.post(returnCallback);
+
+                Display.getDefault().asyncExec(returnCallback);
             }
         }).start();
     }
@@ -245,27 +274,30 @@ public void run() {
     /**
      * Runs user registration in current thread.
      * <p>
-     *      <b>Note:</b> This method will perform network operations. Calling this method in
-     *     applications' main thread will cause Android to throw NetworkOnMainThreadException.
+     * <b>Note:</b> This method will perform network operations. Calling this method in applications' main thread will
+     * cause Android to throw NetworkOnMainThreadException.
      * </p>
      *
-     * @param userId            REQUIRED: userId for this user
-     * @param password          REQUIRED: Password for this user
-     * @param userAttributes    REQUIRED: Contains all attributes for this user
-     * @param validationData    REQUIRED: Parameters for lambda function for user registration
-     * @param callback          REQUIRED: callback, must not be null
+     * @param userId
+     *            REQUIRED: userId for this user
+     * @param password
+     *            REQUIRED: Password for this user
+     * @param userAttributes
+     *            REQUIRED: Contains all attributes for this user
+     * @param validationData
+     *            REQUIRED: Parameters for lambda function for user registration
+     * @param callback
+     *            REQUIRED: callback, must not be null
      */
-    public void signUp(final String userId, final String password,
-                             final CognitoUserAttributes userAttributes,
-                             final Map<String, String> validationData,
-                             final SignUpHandler callback) {
+    public void signUp(final String userId, final String password, final CognitoUserAttributes userAttributes,
+                       final Map<String, String> validationData, final SignUpHandler callback) {
         try {
-            SignUpResult signUpResult =
-                    signUpInternal(userId, password, userAttributes, validationData);
+            SignUpResult signUpResult = signUpInternal(userId, password, userAttributes, validationData);
             CognitoUser user = getUser(userId);
-            callback.onSuccess(user, signUpResult.getUserConfirmed(),
-                    new CognitoUserCodeDeliveryDetails(signUpResult.getCodeDeliveryDetails()));
-        } catch(final Exception e) {
+            callback.onSuccess(user,
+                               signUpResult.getUserConfirmed(),
+                               new CognitoUserCodeDeliveryDetails(signUpResult.getCodeDeliveryDetails()));
+        } catch (final Exception e) {
             callback.onFailure(e);
         }
     }
@@ -273,21 +305,24 @@ public void signUp(final String userId, final String password,
     /**
      * Internal method to sign-up a new user in Cognito Identity Provider user pool.
      *
-     * @param userId            REQUIRED: The new user userId.
-     * @param password          REQUIRED: Password you want to associate to this use.
-     * @param userAttributes    REQUIRED: User attributes.
-     * @param validationData    REQUIRED: Validation key value pairs, these will be passed to pre
-     *                          and post registration lambda functions.
+     * @param userId
+     *            REQUIRED: The new user userId.
+     * @param password
+     *            REQUIRED: Password you want to associate to this use.
+     * @param userAttributes
+     *            REQUIRED: User attributes.
+     * @param validationData
+     *            REQUIRED: Validation key value pairs, these will be passed to pre and post registration lambda
+     *            functions.
      *
      * @return CognitoUser
      */
-    private SignUpResult signUpInternal(String userId, String password,
-                                              CognitoUserAttributes userAttributes,
-                                              Map<String, String> validationData) {
+    private SignUpResult signUpInternal(String userId, String password, CognitoUserAttributes userAttributes,
+                                        Map<String, String> validationData) {
 
         // Create a list of {@link AttributeType} from {@code userAttributes}
         List<AttributeType> validationDataList = null;
-        if(validationData != null) {
+        if (validationData != null) {
             validationDataList = new ArrayList<AttributeType>();
             for (Map.Entry<String, String> data : validationData.entrySet()) {
                 AttributeType validation = new AttributeType();
@@ -298,18 +333,18 @@ private SignUpResult signUpInternal(String userId, String password,
         }
 
         // Generate Client secret hash
-        secretHash = CognitoSecretHash.getSecretHash(userId, clientId, clientSecret);
+        this.secretHash = CognitoSecretHash.getSecretHash(userId, this.clientId, this.clientSecret);
 
         // Create User registration request
         SignUpRequest signUpUserRequest = new SignUpRequest();
         signUpUserRequest.setUsername(userId);
         signUpUserRequest.setPassword(password);
-        signUpUserRequest.setClientId(clientId);
-        signUpUserRequest.setSecretHash(secretHash);
+        signUpUserRequest.setClientId(this.clientId);
+        signUpUserRequest.setSecretHash(this.secretHash);
         signUpUserRequest.setUserAttributes(userAttributes.getAttributesList());
         signUpUserRequest.setValidationData(validationDataList);
 
-        return client.signUp(signUpUserRequest);
+        return this.client.signUp(signUpUserRequest);
     }
 
     /**
@@ -318,16 +353,14 @@ private SignUpResult signUpInternal(String userId, String password,
      * @return An instance of the {@link CognitoUser} for last authenticated, cached on this device
      */
     public CognitoUser getCurrentUser() {
-        SharedPreferences csiCachedTokens = context.getSharedPreferences("CognitoIdentityProviderCache", 0);
+        SharedPreferences csiCachedTokens = this.context.getSharedPreferences("CognitoIdentityProviderCache", 0);
 
-        String csiLastUserKey = "CognitoIdentityProvider." + clientId + ".LastAuthUser";
+        String csiLastUserKey = "CognitoIdentityProvider." + this.clientId + ".LastAuthUser";
 
-        if(csiCachedTokens.contains(csiLastUserKey)){
+        if (csiCachedTokens.contains(csiLastUserKey))
             return getUser(csiCachedTokens.getString(csiLastUserKey, null));
-        }
-        else {
+        else
             return getUser();
-        }
     }
 
     /**
@@ -336,31 +369,34 @@ public CognitoUser getCurrentUser() {
      * @return {@link CognitoUser}.
      */
     public CognitoUser getUser() {
-        return new CognitoUser(this, null, clientId, clientSecret, null, client, context);
+        return new CognitoUser(this, null, this.clientId, this.clientSecret, null, this.client, this.context);
     }
 
     /**
      * Returns a CognitoUser with userId {@code userId}
      * <p>
-     *     This CognitoUser is not authenticated. Call {@link CognitoUser#getSession(AuthenticationHandler)}
-     *     to get valid tokens {@link CognitoUserSession}
+     * This CognitoUser is not authenticated. Call {@link CognitoUser#getSession(AuthenticationHandler)} to get valid
+     * tokens {@link CognitoUserSession}
      * </p>
      *
-     * @param userId            Can be null
+     * @param userId
+     *            Can be null
      * @return a new CognitoUser instance with userId {@code userId}
      */
     public CognitoUser getUser(String userId) {
 
-        if (userId == null) {
+        if (userId == null)
             return getUser();
-        }
 
-        if(userId.isEmpty()) {
+        if (userId.isEmpty())
             return getUser();
-        }
 
-        return new CognitoUser(this, userId, clientId, clientSecret,
-                CognitoSecretHash.getSecretHash(userId, clientId, clientSecret),
-                client, context);
+        return new CognitoUser(this,
+                               userId,
+                               this.clientId,
+                               this.clientSecret,
+                               CognitoSecretHash.getSecretHash(userId, this.clientId, this.clientSecret),
+                               this.client,
+                               this.context);
     }
 }
diff --git a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/continuations/AuthenticationContinuation.java b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/continuations/AuthenticationContinuation.java
index d59700944f..a34b7216f8 100644
--- a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/continuations/AuthenticationContinuation.java
+++ b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/continuations/AuthenticationContinuation.java
@@ -17,16 +17,15 @@
 
 package com.amazonaws.mobileconnectors.cognitoidentityprovider.continuations;
 
-import android.content.Context;
-import android.os.Handler;
-import android.util.Log;
+import org.eclipse.swt.widgets.Display;
 
+import com.amazonaws.adroid.utils.Context;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.CognitoUser;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.handlers.AuthenticationHandler;
 
 /**
- * Defines Continuation for authentication. This Continuation is used when user log-in details
- * are required to continue to authenticate the user and get tokens.
+ * Defines Continuation for authentication. This Continuation is used when user log-in details are required to continue
+ * to authenticate the user and get tokens.
  */
 public class AuthenticationContinuation implements CognitoIdentityProviderContinuation<String> {
 
@@ -52,14 +51,16 @@
     /**
      * Constructs a new continuation in the authentication process.
      *
-     * @param user                  REQUIRED: Reference to the {@link CognitoUser} object.
-     * @param context               REQUIRED: Application context to manage threads.
-     * @param runInBackground       REQUIRED: Represents where this continuation has to run.
-     * @param callback              REQUIRED: Callback to interact with the app.
+     * @param user
+     *            REQUIRED: Reference to the {@link CognitoUser} object.
+     * @param context
+     *            REQUIRED: Application context to manage threads.
+     * @param runInBackground
+     *            REQUIRED: Represents where this continuation has to run.
+     * @param callback
+     *            REQUIRED: Callback to interact with the app.
      */
-    public AuthenticationContinuation(CognitoUser user,
-                                      Context context,
-                                      boolean runInBackground,
+    public AuthenticationContinuation(CognitoUser user, Context context, boolean runInBackground,
                                       AuthenticationHandler callback) {
         this.user = user;
         this.context = context;
@@ -72,45 +73,49 @@ public AuthenticationContinuation(CognitoUser user,
      *
      * @return
      */
-    public String getParameters(){
+    @Override
+    public String getParameters() {
         return "AuthenticationDetails";
     }
 
     /**
-     * Continues the authentications process by responding to the "PASSWORD_VERIFIER" challenge with
-     * username and password. Depending upon the initial call, the response call is name in the current
-     * or the background thread.
+     * Continues the authentications process by responding to the "PASSWORD_VERIFIER" challenge with username and
+     * password. Depending upon the initial call, the response call is name in the current or the background thread.
      *
      */
+    @Override
     public void continueTask() {
-        if (runInBackground) {
+        if (this.runInBackground)
             new Thread(new Runnable() {
                 @Override
                 public void run() {
-                    Handler handler = new Handler(context.getMainLooper());
                     Runnable nextStep;
                     try {
-                        nextStep = user.initiateUserAuthentication(authenticationDetails, callback, RUN_IN_BACKGROUND);
+                        nextStep =
+                            AuthenticationContinuation.this.user.initiateUserAuthentication(AuthenticationContinuation.this.authenticationDetails,
+                                                                                            AuthenticationContinuation.this.callback,
+                                                                                            RUN_IN_BACKGROUND);
                     } catch (final Exception e) {
                         nextStep = new Runnable() {
                             @Override
                             public void run() {
-                                callback.onFailure(e);
+                                AuthenticationContinuation.this.callback.onFailure(e);
                             }
                         };
                     }
-                    handler.post(nextStep);
+                    Display.getDefault().asyncExec(nextStep);
                 }
             }).start();
-        } else {
+        else {
             Runnable nextStep;
             try {
-                nextStep = user.initiateUserAuthentication(authenticationDetails, callback, RUN_IN_CURRENT);
+                nextStep =
+                    this.user.initiateUserAuthentication(this.authenticationDetails, this.callback, RUN_IN_CURRENT);
             } catch (final Exception e) {
                 nextStep = new Runnable() {
                     @Override
                     public void run() {
-                        callback.onFailure(e);
+                        AuthenticationContinuation.this.callback.onFailure(e);
                     }
                 };
             }
diff --git a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/continuations/ChallengeContinuation.java b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/continuations/ChallengeContinuation.java
index d7aff0d349..c3e748baa8 100644
--- a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/continuations/ChallengeContinuation.java
+++ b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/continuations/ChallengeContinuation.java
@@ -17,21 +17,20 @@
 
 package com.amazonaws.mobileconnectors.cognitoidentityprovider.continuations;
 
-import android.content.Context;
-import android.os.Handler;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.eclipse.swt.widgets.Display;
 
+import com.amazonaws.adroid.utils.Context;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.CognitoUser;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.handlers.AuthenticationHandler;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.util.CognitoServiceConstants;
 import com.amazonaws.services.cognitoidentityprovider.model.RespondToAuthChallengeRequest;
 import com.amazonaws.services.cognitoidentityprovider.model.RespondToAuthChallengeResult;
 
-import java.util.HashMap;
-import java.util.Map;
-
 /**
- * Defines a Continuation for a generic auth-challenge. This Continuation is used for all developer
- * driven challenges.
+ * Defines a Continuation for a generic auth-challenge. This Continuation is used for all developer driven challenges.
  */
 public class ChallengeContinuation implements CognitoIdentityProviderContinuation<Map<String, String>> {
 
@@ -47,15 +46,10 @@
     private final String username;
     private final AuthenticationHandler callback;
     protected Map<String, String> challengeResponses;
-    private boolean runInBackground;
+    private final boolean runInBackground;
 
-    public ChallengeContinuation(CognitoUser user,
-                                 Context context,
-                                 String username,
-                                 String clientId,
-                                 String secretHash,
-                                 RespondToAuthChallengeResult challengeResult,
-                                 boolean runInBackground,
+    public ChallengeContinuation(CognitoUser user, Context context, String username, String clientId, String secretHash,
+                                 RespondToAuthChallengeResult challengeResult, boolean runInBackground,
                                  AuthenticationHandler callback) {
         this.challengeResult = challengeResult;
         this.context = context;
@@ -65,89 +59,90 @@ public ChallengeContinuation(CognitoUser user,
         this.username = username;
         this.callback = callback;
         this.runInBackground = runInBackground;
-        challengeResponses = new HashMap<String, String>();
+        this.challengeResponses = new HashMap<String, String>();
     }
 
     /**
-     * Returns the challenges parameters for a generic challenge (developer defined) challenge.
-     * The keys in this map are usually determined by the developer. They should contain all the
-     * information and resources required by the app, to determine the type of challenge and to
-     * present the challenge to the user. This opens up the authentication process to the developers
-     * to bring their custom steps to authenticate to Cognito User Pools.
+     * Returns the challenges parameters for a generic challenge (developer defined) challenge. The keys in this map are
+     * usually determined by the developer. They should contain all the information and resources required by the app,
+     * to determine the type of challenge and to present the challenge to the user. This opens up the authentication
+     * process to the developers to bring their custom steps to authenticate to Cognito User Pools.
      *
      * @return A {@link Map<String, String>} containing parameters for this auth challenge process.
      */
+    @Override
     public Map<String, String> getParameters() {
-        return challengeResult.getChallengeParameters();
+        return this.challengeResult.getChallengeParameters();
     }
 
     /**
-     * Returns the name of the challenge. Use the challenge name and the challenge parameters to
-     * identity the challenge and correctly present to the user.
+     * Returns the name of the challenge. Use the challenge name and the challenge parameters to identity the challenge
+     * and correctly present to the user.
      *
      * @return the challenge name as a {@link String}.
      */
     public String getChallengeName() {
-        return challengeResult.getChallengeName();
+        return this.challengeResult.getChallengeName();
     }
 
     /**
-     * Add responses to the authentication challenge. The responses are added as key-value pairs. The
-     * keys are usually unique to the challenge and are often determined by the developers who have
-     * set this challenge.  <b>Note:</b> Overrides an earlier value set for an attribute
-     * which was already added to this object.
+     * Add responses to the authentication challenge. The responses are added as key-value pairs. The keys are usually
+     * unique to the challenge and are often determined by the developers who have set this challenge. <b>Note:</b>
+     * Overrides an earlier value set for an attribute which was already added to this object.
      *
      * @param responseKey
      * @param responseValue
      */
     public void setChallengeResponse(String responseKey, String responseValue) {
-        challengeResponses.put(responseKey, responseValue);
+        this.challengeResponses.put(responseKey, responseValue);
     }
 
     /**
-     * Continues the authentication process by responding to the generic challenge posed by the system.
-     * This invokes the method to respond to the generic authentication challenge in the current or on
-     * a background thread depending up on how the authentication process with initiated.
-     * This method gets a {@link Runnable} which is is always executed in the applications thread.
-     * The mechanism to identify the current thread and to run the returned {@link Runnable} in the apps
-     * thread is implemented in this method.
+     * Continues the authentication process by responding to the generic challenge posed by the system. This invokes the
+     * method to respond to the generic authentication challenge in the current or on a background thread depending up
+     * on how the authentication process with initiated. This method gets a {@link Runnable} which is is always executed
+     * in the applications thread. The mechanism to identify the current thread and to run the returned {@link Runnable}
+     * in the apps thread is implemented in this method.
      */
+    @Override
     public void continueTask() {
         final RespondToAuthChallengeRequest respondToAuthChallengeRequest = new RespondToAuthChallengeRequest();
-        challengeResponses.put(CognitoServiceConstants.CHLG_RESP_USERNAME, username);
-        challengeResponses.put(CognitoServiceConstants.CHLG_RESP_SECRET_HASH, secretHash);
-        respondToAuthChallengeRequest.setChallengeName(challengeResult.getChallengeName());
-        respondToAuthChallengeRequest.setSession(challengeResult.getSession());
-        respondToAuthChallengeRequest.setClientId(clientId);
-        respondToAuthChallengeRequest.setChallengeResponses(challengeResponses);
-        if (runInBackground) {
+        this.challengeResponses.put(CognitoServiceConstants.CHLG_RESP_USERNAME, this.username);
+        this.challengeResponses.put(CognitoServiceConstants.CHLG_RESP_SECRET_HASH, this.secretHash);
+        respondToAuthChallengeRequest.setChallengeName(this.challengeResult.getChallengeName());
+        respondToAuthChallengeRequest.setSession(this.challengeResult.getSession());
+        respondToAuthChallengeRequest.setClientId(this.clientId);
+        respondToAuthChallengeRequest.setChallengeResponses(this.challengeResponses);
+        if (this.runInBackground)
             new Thread(new Runnable() {
                 @Override
                 public void run() {
-                    Handler handler = new Handler(context.getMainLooper());
                     Runnable nextStep;
                     try {
-                        nextStep = user.respondToChallenge(respondToAuthChallengeRequest, callback, RUN_IN_BACKGROUND);
+                        nextStep =
+                            ChallengeContinuation.this.user.respondToChallenge(respondToAuthChallengeRequest,
+                                                                               ChallengeContinuation.this.callback,
+                                                                               RUN_IN_BACKGROUND);
                     } catch (final Exception e) {
                         nextStep = new Runnable() {
                             @Override
                             public void run() {
-                                callback.onFailure(e);
+                                ChallengeContinuation.this.callback.onFailure(e);
                             }
                         };
                     }
-                    handler.post(nextStep);
+                    Display.getDefault().asyncExec(nextStep);
                 }
             }).start();
-        } else {
+        else {
             Runnable nextStep;
             try {
-                nextStep = user.respondToChallenge(respondToAuthChallengeRequest, callback, RUN_IN_CURRENT);
+                nextStep = this.user.respondToChallenge(respondToAuthChallengeRequest, this.callback, RUN_IN_CURRENT);
             } catch (final Exception e) {
                 nextStep = new Runnable() {
                     @Override
                     public void run() {
-                        callback.onFailure(e);
+                        ChallengeContinuation.this.callback.onFailure(e);
                     }
                 };
             }
diff --git a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/continuations/MultiFactorAuthenticationContinuation.java b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/continuations/MultiFactorAuthenticationContinuation.java
index 3cf30eaf74..845618949d 100644
--- a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/continuations/MultiFactorAuthenticationContinuation.java
+++ b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/continuations/MultiFactorAuthenticationContinuation.java
@@ -17,19 +17,19 @@
 
 package com.amazonaws.mobileconnectors.cognitoidentityprovider.continuations;
 
-import android.content.Context;
-import android.os.Handler;
+import org.eclipse.swt.widgets.Display;
 
+import com.amazonaws.adroid.utils.Context;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.CognitoUser;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.CognitoUserCodeDeliveryDetails;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.handlers.AuthenticationHandler;
-import com.amazonaws.services.cognitoidentityprovider.model.RespondToAuthChallengeRequest;
 import com.amazonaws.services.cognitoidentityprovider.model.RespondToAuthChallengeResult;
 
 /**
  * This is a Continuation for multi-factor authentication.
  */
-public class MultiFactorAuthenticationContinuation implements CognitoIdentityProviderContinuation<CognitoUserCodeDeliveryDetails> {
+public class MultiFactorAuthenticationContinuation
+    implements CognitoIdentityProviderContinuation<CognitoUserCodeDeliveryDetails> {
 
     // Boolean constants used to indicate where this continuation will run.
     final public static boolean RUN_IN_BACKGROUND = true;
@@ -45,15 +45,17 @@
     /**
      * Constructs a multi-factor authentication continuation.
      *
-     * @param user                  REQUIRED: Reference to the {@link CognitoUser} object.
-     * @param challenge             REQUIRED: Contains the MFA Challenge.
-     * @param runInBackground       REQUIRED: Represents where this continuation has to run.
-     * @param callback              REQUIRED: Callback to interact with the app.
+     * @param user
+     *            REQUIRED: Reference to the {@link CognitoUser} object.
+     * @param challenge
+     *            REQUIRED: Contains the MFA Challenge.
+     * @param runInBackground
+     *            REQUIRED: Represents where this continuation has to run.
+     * @param callback
+     *            REQUIRED: Callback to interact with the app.
      */
-    public MultiFactorAuthenticationContinuation(CognitoUser user,
-                                                 Context context,
-                                                 RespondToAuthChallengeResult challenge,
-                                                 boolean runInBackground,
+    public MultiFactorAuthenticationContinuation(CognitoUser user, Context context,
+                                                 RespondToAuthChallengeResult challenge, boolean runInBackground,
                                                  AuthenticationHandler callback) {
         this.user = user;
         this.context = context;
@@ -67,45 +69,52 @@ public MultiFactorAuthenticationContinuation(CognitoUser user,
      *
      * @return medium where the code was sent (e.g. email, sms).
      */
-    public CognitoUserCodeDeliveryDetails getParameters(){
-        return new CognitoUserCodeDeliveryDetails(challenge.getChallengeParameters().get("CODE_DELIVERY_DESTINATION"),
-                challenge.getChallengeParameters().get("CODE_DELIVERY_DELIVERY_MEDIUM"),
-                null);
+    @Override
+    public CognitoUserCodeDeliveryDetails getParameters() {
+        return new CognitoUserCodeDeliveryDetails(this.challenge.getChallengeParameters()
+                                                                .get("CODE_DELIVERY_DESTINATION"),
+                                                  this.challenge.getChallengeParameters()
+                                                                .get("CODE_DELIVERY_DELIVERY_MEDIUM"),
+                                                  null);
     }
 
     /**
      * Call this to continue with the authentication process.
      */
-    public void continueTask(){
-        if (runInBackground) {
+    @Override
+    public void continueTask() {
+        if (this.runInBackground)
             new Thread(new Runnable() {
                 @Override
                 public void run() {
-                    Handler handler = new Handler(context.getMainLooper());
                     Runnable nextStep;
                     try {
 
-                        nextStep = user.respondToMfaChallenge(mfaCode, challenge, callback, RUN_IN_BACKGROUND);
+                        nextStep =
+                            MultiFactorAuthenticationContinuation.this.user.respondToMfaChallenge(MultiFactorAuthenticationContinuation.this.mfaCode,
+                                                                                                  MultiFactorAuthenticationContinuation.this.challenge,
+                                                                                                  MultiFactorAuthenticationContinuation.this.callback,
+                                                                                                  RUN_IN_BACKGROUND);
                     } catch (final Exception e) {
                         nextStep = new Runnable() {
                             @Override
                             public void run() {
-                                callback.onFailure(e);
+                                MultiFactorAuthenticationContinuation.this.callback.onFailure(e);
                             }
                         };
                     }
-                    handler.post(nextStep);
+                    Display.getDefault().asyncExec(nextStep);
                 }
             }).start();
-        } else {
+        else {
             Runnable nextStep;
             try {
-                nextStep = user.respondToMfaChallenge(mfaCode, challenge, callback, RUN_IN_CURRENT);
+                nextStep = this.user.respondToMfaChallenge(this.mfaCode, this.challenge, this.callback, RUN_IN_CURRENT);
             } catch (final Exception e) {
                 nextStep = new Runnable() {
                     @Override
                     public void run() {
-                        callback.onFailure(e);
+                        MultiFactorAuthenticationContinuation.this.callback.onFailure(e);
                     }
                 };
             }
diff --git a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/continuations/NewPasswordContinuation.java b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/continuations/NewPasswordContinuation.java
index f401409811..375545a9da 100644
--- a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/continuations/NewPasswordContinuation.java
+++ b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/continuations/NewPasswordContinuation.java
@@ -17,29 +17,27 @@
 
 package com.amazonaws.mobileconnectors.cognitoidentityprovider.continuations;
 
-import android.content.Context;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
 
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+import com.amazonaws.adroid.utils.Context;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.CognitoUser;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.exceptions.CognitoParameterInvalidException;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.handlers.AuthenticationHandler;
 import com.amazonaws.mobileconnectors.cognitoidentityprovider.util.CognitoServiceConstants;
 import com.amazonaws.services.cognitoidentityprovider.model.RespondToAuthChallengeResult;
 
-import org.json.JSONArray;
-import org.json.JSONObject;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
 /**
- * Defines continuation for new user set-up. This is used to set the password and user attributes
- * after first sign-in after admin created this user. Depending the attributes, for the user,
- * set by the admin, user will have the set the other required attributes during the first sign-in.
- * During the first sign-in, the user will also be able to change some of the attributes which were
- * set by the admin.
+ * Defines continuation for new user set-up. This is used to set the password and user attributes after first sign-in
+ * after admin created this user. Depending the attributes, for the user, set by the admin, user will have the set the
+ * other required attributes during the first sign-in. During the first sign-in, the user will also be able to change
+ * some of the attributes which were set by the admin.
  */
 public class NewPasswordContinuation extends ChallengeContinuation {
     /**
@@ -60,14 +58,9 @@
     /**
      * Constructs a new continuation for new user sign-in.
      */
-    public NewPasswordContinuation (CognitoUser user,
-                                    Context context,
-                                    String username,
-                                    String clientId,
-                                    String secretHash,
-                                    RespondToAuthChallengeResult challengeResult,
-                                    boolean runInBackground,
-                                    AuthenticationHandler callback) {
+    public NewPasswordContinuation(CognitoUser user, Context context, String username, String clientId,
+                                   String secretHash, RespondToAuthChallengeResult challengeResult,
+                                   boolean runInBackground, AuthenticationHandler callback) {
         super(user, context, username, clientId, secretHash, challengeResult, runInBackground, callback);
         this.callback = callback;
 
@@ -77,30 +70,31 @@ public NewPasswordContinuation (CognitoUser user,
     }
 
     /**
-     * Returns all required attributes to complete user sign-up. All these user attributes have to be
-     * set to complete the user sign-up.
+     * Returns all required attributes to complete user sign-up. All these user attributes have to be set to complete
+     * the user sign-up.
      *
      * @return A {@code List<String>} of all required user attributes.
      */
     public List<String> getRequiredAttributes() {
-        return requiredAttributes;
+        return this.requiredAttributes;
     }
 
     /**
-     * Returns all current user attributes. These attributes are set by the Admin when creating a new
-     * user.
+     * Returns all current user attributes. These attributes are set by the Admin when creating a new user.
      *
      * @return A {@code Map<String, String>} containing all current values of user attributes.
      */
     public Map<String, String> getCurrentUserAttributes() {
-        return currentUserAttributes;
+        return this.currentUserAttributes;
     }
 
     /**
      * Add a user attribute, will override current value.
      *
-     * @param attributeName     REQUIRED: The attribute name.
-     * @param attributeValue    REQUIRED: The attribute value.
+     * @param attributeName
+     *            REQUIRED: The attribute name.
+     * @param attributeValue
+     *            REQUIRED: The attribute value.
      */
     public void setUserAttribute(String attributeName, String attributeValue) {
         setChallengeResponse(CognitoServiceConstants.CHLG_PARAM_USER_ATTRIBUTE_PREFIX + attributeName, attributeValue);
@@ -109,12 +103,12 @@ public void setUserAttribute(String attributeName, String attributeValue) {
     /**
      * Set new user password, must not be {@code null}. This is required to complete the user sign-up.
      *
-     * @param userPassword      REQUIRED: New user password.
+     * @param userPassword
+     *            REQUIRED: New user password.
      */
     public void setPassword(String userPassword) {
-        if (userPassword != null) {
+        if (userPassword != null)
             setChallengeResponse(CognitoServiceConstants.CHLG_RESP_NEW_PASSWORD, userPassword);
-        }
     }
 
     /**
@@ -122,62 +116,61 @@ public void setPassword(String userPassword) {
      */
     @Override
     public void continueTask() {
-        if (requiredAttributes != null && requiredAttributes.size() > 1) {
-            for (final String requiredAttribute: requiredAttributes) {
-                final String requiredAttrKey = CognitoServiceConstants.CHLG_PARAM_USER_ATTRIBUTE_PREFIX + requiredAttribute;
-                if (!challengeResponses.containsKey(requiredAttrKey)) {
-                    throw new CognitoParameterInvalidException(
-                            String.format("Missing required attribute: %s", requiredAttribute));
-                }
+        if ((this.requiredAttributes != null) && (this.requiredAttributes.size() > 1))
+            for (final String requiredAttribute : this.requiredAttributes) {
+                final String requiredAttrKey =
+                    CognitoServiceConstants.CHLG_PARAM_USER_ATTRIBUTE_PREFIX + requiredAttribute;
+                if (!this.challengeResponses.containsKey(requiredAttrKey))
+                    throw new CognitoParameterInvalidException(String.format("Missing required attribute: %s",
+                                                                             requiredAttribute));
             }
-        }
 
-        if (challengeResponses.containsKey(CognitoServiceConstants.CHLG_RESP_NEW_PASSWORD) &&
-                (challengeResponses.get(CognitoServiceConstants.CHLG_RESP_NEW_PASSWORD) != null)) {
+        if (this.challengeResponses.containsKey(CognitoServiceConstants.CHLG_RESP_NEW_PASSWORD)
+            && (this.challengeResponses.get(CognitoServiceConstants.CHLG_RESP_NEW_PASSWORD) != null))
             super.continueTask();
-        } else {
+        else
             throw new CognitoParameterInvalidException("New password was not set");
-        }
     }
 
     /**
      * Parses user attributes.
      *
-     * @param userAttributesJsonString      REQUIRED: User attributes as a Json String.
+     * @param userAttributesJsonString
+     *            REQUIRED: User attributes as a Json String.
      */
     private void parseUserAttributes(String userAttributesJsonString) {
-        currentUserAttributes = new HashMap<String, String>();
-        if (userAttributesJsonString != null) {
+        this.currentUserAttributes = new HashMap<String, String>();
+        if (userAttributesJsonString != null)
             try {
                 final JSONObject userAttributesJson = new JSONObject(userAttributesJsonString);
                 final Iterator<?> userAttribute = userAttributesJson.keys();
                 while (userAttribute.hasNext()) {
                     final String attributeName = (String) userAttribute.next();
                     final String attributeValue = userAttributesJson.getString(attributeName);
-                    currentUserAttributes.put(attributeName, attributeValue);
+                    this.currentUserAttributes.put(attributeName, attributeValue);
                 }
             } catch (final Exception e) {
-                callback.onFailure(e);
+                this.callback.onFailure(e);
             }
-        }
     }
 
     /**
      * Parse required attributes.
      *
-     * @param requiredAttributesJsonString      REQUIRED: Required user attributes as a Json array.
+     * @param requiredAttributesJsonString
+     *            REQUIRED: Required user attributes as a Json array.
      */
     private void parseRequiredAttributes(String requiredAttributesJsonString) {
-        requiredAttributes = new ArrayList<String>();
-        if (requiredAttributesJsonString != null) {
+        this.requiredAttributes = new ArrayList<String>();
+        if (requiredAttributesJsonString != null)
             try {
                 final JSONArray requiredAttributesJson = new JSONArray(requiredAttributesJsonString);
-                for (int i = 0; i < requiredAttributesJson.length(); i++) {
-                    requiredAttributes.add(requiredAttributesJson.getString(i).split(CognitoServiceConstants.CHLG_PARAM_USER_ATTRIBUTE_PREFIX, 2)[1]);
-                }
+                for (int i = 0; i < requiredAttributesJson.length(); i++)
+                    this.requiredAttributes.add(requiredAttributesJson.getString(i).split(
+                                                                                          CognitoServiceConstants.CHLG_PARAM_USER_ATTRIBUTE_PREFIX,
+                                                                                          2)[1]);
             } catch (final Exception e) {
-                callback.onFailure(e);
+                this.callback.onFailure(e);
             }
-        }
     }
 }
diff --git a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/util/CognitoDeviceHelper.java b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/util/CognitoDeviceHelper.java
index c5bcafaae2..e9f6652c7a 100644
--- a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/util/CognitoDeviceHelper.java
+++ b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/util/CognitoDeviceHelper.java
@@ -17,14 +17,6 @@
 
 package com.amazonaws.mobileconnectors.cognitoidentityprovider.util;
 
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.os.Build;
-import android.util.Log;
-
-import com.amazonaws.util.Base64;
-import com.amazonaws.util.StringUtils;
-
 import java.math.BigInteger;
 import java.nio.ByteBuffer;
 import java.security.MessageDigest;
@@ -34,6 +26,12 @@
 import java.util.Map;
 import java.util.UUID;
 
+import com.amazonaws.adroid.utils.Context;
+import com.amazonaws.adroid.utils.Log;
+import com.amazonaws.adroid.utils.SharedPreferences;
+import com.amazonaws.util.Base64;
+import com.amazonaws.util.StringUtils;
+
 /**
  * A utility class for device operations.
  */
@@ -52,24 +50,27 @@
      * @return Device model name, which is also the name of the device.
      */
     public static String getDeviceName() {
-        return Build.MODEL;
+        return "Studio";
     }
 
     /**
-     * Returns the cached key for this device. Device keys are stored in SharedPreferences and are
-     * used to track devices. Returns null if no device key was cached.
+     * Returns the cached key for this device. Device keys are stored in SharedPreferences and are used to track
+     * devices. Returns null if no device key was cached.
      *
-     * @param username          REQUIRED: The current user.
-     * @param userPoolId        REQUIRED: Client ID of the application.
-     * @param context           REQUIRED: Application context.
+     * @param username
+     *            REQUIRED: The current user.
+     * @param userPoolId
+     *            REQUIRED: Client ID of the application.
+     * @param context
+     *            REQUIRED: Application context.
      * @return device key as String, null if the device-key is not available.
      */
     public static String getDeviceKey(String username, String userPoolId, Context context) {
         try {
-            SharedPreferences cipCachedDeviceDetails = context.getSharedPreferences(getDeviceDetailsCacheForUser(username, userPoolId), 0);
-            if (cipCachedDeviceDetails != null && cipCachedDeviceDetails.contains(COGNITO_DEVICE_KEY)) {
+            SharedPreferences cipCachedDeviceDetails =
+                context.getSharedPreferences(getDeviceDetailsCacheForUser(username, userPoolId), 0);
+            if ((cipCachedDeviceDetails != null) && cipCachedDeviceDetails.contains(COGNITO_DEVICE_KEY))
                 return cipCachedDeviceDetails.getString(COGNITO_DEVICE_KEY, null);
-            }
         } catch (Exception e) {
             Log.e(TAG, "Error accessing SharedPreferences" + e.getMessage());
         }
@@ -77,20 +78,23 @@ public static String getDeviceKey(String username, String userPoolId, Context co
     }
 
     /**
-     * Returns the cached device secret for this device. Device secret is generated when the device
-     * is confirmed and is used for device identification.
+     * Returns the cached device secret for this device. Device secret is generated when the device is confirmed and is
+     * used for device identification.
      *
-     * @param username          REQUIRED: The current user.
-     * @param userPoolId        REQUIRED: Client ID of the application.
-     * @param context           REQUIRED: Application context.
+     * @param username
+     *            REQUIRED: The current user.
+     * @param userPoolId
+     *            REQUIRED: Client ID of the application.
+     * @param context
+     *            REQUIRED: Application context.
      * @return device secret as String, null if the device-key is not available.
      */
     public static String getDeviceSecret(String username, String userPoolId, Context context) {
         try {
-            SharedPreferences cipCachedDeviceDetails = context.getSharedPreferences(getDeviceDetailsCacheForUser(username, userPoolId), 0);
-            if (cipCachedDeviceDetails != null && cipCachedDeviceDetails.contains(COGNITO_DEVICE_SECRET)) {
+            SharedPreferences cipCachedDeviceDetails =
+                context.getSharedPreferences(getDeviceDetailsCacheForUser(username, userPoolId), 0);
+            if ((cipCachedDeviceDetails != null) && cipCachedDeviceDetails.contains(COGNITO_DEVICE_SECRET))
                 return cipCachedDeviceDetails.getString(COGNITO_DEVICE_SECRET, null);
-            }
         } catch (Exception e) {
             Log.e(TAG, "Error accessing SharedPreferences" + e.getMessage());
         }
@@ -98,20 +102,23 @@ public static String getDeviceSecret(String username, String userPoolId, Context
     }
 
     /**
-     * Returns the cached device group key for this device. Device secret is generated when the device
-     * is confirmed and is used for device identification.
+     * Returns the cached device group key for this device. Device secret is generated when the device is confirmed and
+     * is used for device identification.
      *
-     * @param username          REQUIRED: The current user.
-     * @param userPoolId        REQUIRED: Client ID of the application.
-     * @param context           REQUIRED: Application context.
+     * @param username
+     *            REQUIRED: The current user.
+     * @param userPoolId
+     *            REQUIRED: Client ID of the application.
+     * @param context
+     *            REQUIRED: Application context.
      * @return device group key as String, null if the device-key is not available.
      */
     public static String getDeviceGroupKey(String username, String userPoolId, Context context) {
         try {
-            SharedPreferences cipCachedDeviceDetails = context.getSharedPreferences(getDeviceDetailsCacheForUser(username, userPoolId), 0);
-            if (cipCachedDeviceDetails != null && cipCachedDeviceDetails.contains(COGNITO_DEVICE_GROUP_KEY)) {
+            SharedPreferences cipCachedDeviceDetails =
+                context.getSharedPreferences(getDeviceDetailsCacheForUser(username, userPoolId), 0);
+            if ((cipCachedDeviceDetails != null) && cipCachedDeviceDetails.contains(COGNITO_DEVICE_GROUP_KEY))
                 return cipCachedDeviceDetails.getString(COGNITO_DEVICE_GROUP_KEY, null);
-            }
         } catch (Exception e) {
             Log.e(TAG, "Error accessing SharedPreferences" + e.getMessage());
         }
@@ -119,17 +126,22 @@ public static String getDeviceGroupKey(String username, String userPoolId, Conte
     }
 
     /**
-     * This method caches the device key. Device key is assigned by the Amazon Cognito service and is
-     * used as a device identifier.
+     * This method caches the device key. Device key is assigned by the Amazon Cognito service and is used as a device
+     * identifier.
      *
-     * @param username          REQUIRED: The current user.
-     * @param userPoolId        REQUIRED: Client ID of the device.
-     * @param deviceKey         REQUIRED: Cognito assigned device key.
-     * @param context           REQUIRED: App context, needed to access device datastore.
+     * @param username
+     *            REQUIRED: The current user.
+     * @param userPoolId
+     *            REQUIRED: Client ID of the device.
+     * @param deviceKey
+     *            REQUIRED: Cognito assigned device key.
+     * @param context
+     *            REQUIRED: App context, needed to access device datastore.
      */
     public static void cacheDeviceKey(String username, String userPoolId, String deviceKey, Context context) {
         try {
-            SharedPreferences cipCachedDeviceDetails = context.getSharedPreferences(getDeviceDetailsCacheForUser(username, userPoolId), 0);
+            SharedPreferences cipCachedDeviceDetails =
+                context.getSharedPreferences(getDeviceDetailsCacheForUser(username, userPoolId), 0);
             cipCachedDeviceDetails.edit().putString(COGNITO_DEVICE_KEY, deviceKey).apply();
         } catch (Exception e) {
             Log.e(TAG, "Error accessing SharedPreferences" + e.getMessage());
@@ -137,17 +149,22 @@ public static void cacheDeviceKey(String username, String userPoolId, String dev
     }
 
     /**
-     * This method caches the device verifier. Device verifier is generated locally by the SDK and
-     * it is used to authenticate the device through device SRP authentication.
+     * This method caches the device verifier. Device verifier is generated locally by the SDK and it is used to
+     * authenticate the device through device SRP authentication.
      *
-     * @param username          REQUIRED: The current user.
-     * @param userPoolId        REQUIRED: Client ID of the device.
-     * @param deviceSecret      REQUIRED: Cognito assigned device key.
-     * @param context           REQUIRED: App context, needed to access device datastore.
+     * @param username
+     *            REQUIRED: The current user.
+     * @param userPoolId
+     *            REQUIRED: Client ID of the device.
+     * @param deviceSecret
+     *            REQUIRED: Cognito assigned device key.
+     * @param context
+     *            REQUIRED: App context, needed to access device datastore.
      */
     public static void cacheDeviceVerifier(String username, String userPoolId, String deviceSecret, Context context) {
         try {
-            SharedPreferences cipCachedDeviceDetails = context.getSharedPreferences(getDeviceDetailsCacheForUser(username, userPoolId), 0);
+            SharedPreferences cipCachedDeviceDetails =
+                context.getSharedPreferences(getDeviceDetailsCacheForUser(username, userPoolId), 0);
             cipCachedDeviceDetails.edit().putString(COGNITO_DEVICE_SECRET, deviceSecret).apply();
         } catch (Exception e) {
             Log.e(TAG, "Error accessing SharedPreferences" + e.getMessage());
@@ -155,17 +172,22 @@ public static void cacheDeviceVerifier(String username, String userPoolId, Strin
     }
 
     /**
-     * This method caches the device group key. Device verifier is generated locally by the SDK and
-     * it is used to authenticate the device through device SRP authentication.
+     * This method caches the device group key. Device verifier is generated locally by the SDK and it is used to
+     * authenticate the device through device SRP authentication.
      *
-     * @param username          REQUIRED: The current user.
-     * @param userPoolId        REQUIRED: Client ID of the device.
-     * @param deviceGroupKey    REQUIRED: Cognito assigned device group key.
-     * @param context           REQUIRED: App context, needed to access device datastore.
+     * @param username
+     *            REQUIRED: The current user.
+     * @param userPoolId
+     *            REQUIRED: Client ID of the device.
+     * @param deviceGroupKey
+     *            REQUIRED: Cognito assigned device group key.
+     * @param context
+     *            REQUIRED: App context, needed to access device datastore.
      */
     public static void cacheDeviceGroupKey(String username, String userPoolId, String deviceGroupKey, Context context) {
         try {
-            SharedPreferences cipCachedDeviceDetails = context.getSharedPreferences(getDeviceDetailsCacheForUser(username, userPoolId), 0);
+            SharedPreferences cipCachedDeviceDetails =
+                context.getSharedPreferences(getDeviceDetailsCacheForUser(username, userPoolId), 0);
             cipCachedDeviceDetails.edit().putString(COGNITO_DEVICE_GROUP_KEY, deviceGroupKey).apply();
         } catch (Exception e) {
             Log.e(TAG, "Error accessing SharedPreferences" + e.getMessage());
@@ -175,13 +197,17 @@ public static void cacheDeviceGroupKey(String username, String userPoolId, Strin
     /**
      * Clears cached device details for this user.
      *
-     * @param username          REQUIRED: The current user.
-     * @param userPoolId        REQUIRED: Client ID of the device.
-     * @param context           REQUIRED: App context, needed to access device datastore.
+     * @param username
+     *            REQUIRED: The current user.
+     * @param userPoolId
+     *            REQUIRED: Client ID of the device.
+     * @param context
+     *            REQUIRED: App context, needed to access device datastore.
      */
     public static void clearCachedDevice(String username, String userPoolId, Context context) {
         try {
-            SharedPreferences cipCachedDeviceDetails = context.getSharedPreferences(getDeviceDetailsCacheForUser(username, userPoolId), 0);
+            SharedPreferences cipCachedDeviceDetails =
+                context.getSharedPreferences(getDeviceDetailsCacheForUser(username, userPoolId), 0);
             cipCachedDeviceDetails.edit().clear().apply();
         } catch (Exception e) {
             Log.e(TAG, "Error accessing SharedPreferences" + e.getMessage());
@@ -191,8 +217,10 @@ public static void clearCachedDevice(String username, String userPoolId, Context
     /**
      * Generates SRP verification parameters for device verification.
      *
-     * @param deviceKey          REQUIRED: Username this device belongs to.
-     * @param deviceGroup        REQUIRED: This is the device group id returned by the service.
+     * @param deviceKey
+     *            REQUIRED: Username this device belongs to.
+     * @param deviceGroup
+     *            REQUIRED: This is the device group id returned by the service.
      * @return srp verification details for this device, as a {@link Map}.
      */
     public static Map<String, String> generateVerificationParameters(String deviceKey, String deviceGroup) {
@@ -210,8 +238,10 @@ public static void clearCachedDevice(String username, String userPoolId, Context
     /**
      * Generates and returns the key to access device details from shared preferences.
      *
-     * @param username          REQUIRED: The current user.
-     * @param userPoolId        REQUIRED: Client ID of the device.
+     * @param username
+     *            REQUIRED: The current user.
+     * @param userPoolId
+     *            REQUIRED: Client ID of the device.
      * @return a string which is a key to access the device key from SharedPreferences.
      */
     private static String getDeviceDetailsCacheForUser(String username, String userPoolId) {
@@ -222,38 +252,38 @@ private static String getDeviceDetailsCacheForUser(String username, String userP
      * Static class for SRP related calculations for devices.
      */
     public static class deviceSRP {
-        private BigInteger salt;
-        private BigInteger verifier;
+        private final BigInteger salt;
+        private final BigInteger verifier;
         private static final String HASH_ALGORITHM = "SHA-256";
 
-        private static final ThreadLocal<MessageDigest> THREAD_MESSAGE_DIGEST =
-                new ThreadLocal<MessageDigest>() {
-                    @Override
-                    protected MessageDigest initialValue() {
-                        try {
-                            return MessageDigest.getInstance(HASH_ALGORITHM);
-                        } catch (NoSuchAlgorithmException e) {
-                            throw new ExceptionInInitializerError(e);
-                        }
-                    }
-                };
-
-        private static final String HEX_N = "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
-                + "29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
-                + "EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
-                + "E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
-                + "EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
-                + "C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
-                + "83655D23DCA3AD961C62F356208552BB9ED529077096966D"
-                + "670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"
-                + "E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"
-                + "DE2BCBF6955817183995497CEA956AE515D2261898FA0510"
-                + "15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64"
-                + "ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7"
-                + "ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B"
-                + "F12FFA06D98A0864D87602733EC86A64521F2B18177B200C"
-                + "BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31"
-                + "43DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF";
+        private static final ThreadLocal<MessageDigest> THREAD_MESSAGE_DIGEST = new ThreadLocal<MessageDigest>() {
+            @Override
+            protected MessageDigest initialValue() {
+                try {
+                    return MessageDigest.getInstance(HASH_ALGORITHM);
+                } catch (NoSuchAlgorithmException e) {
+                    throw new ExceptionInInitializerError(e);
+                }
+            }
+        };
+
+        private static final String HEX_N =
+            "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
+                                            + "29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
+                                            + "EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
+                                            + "E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
+                                            + "EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
+                                            + "C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
+                                            + "83655D23DCA3AD961C62F356208552BB9ED529077096966D"
+                                            + "670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"
+                                            + "E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"
+                                            + "DE2BCBF6955817183995497CEA956AE515D2261898FA0510"
+                                            + "15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64"
+                                            + "ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7"
+                                            + "ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B"
+                                            + "F12FFA06D98A0864D87602733EC86A64521F2B18177B200C"
+                                            + "BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31"
+                                            + "43DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF";
 
         private static final BigInteger N = new BigInteger(HEX_N, 16);
         private static final BigInteger g = BigInteger.valueOf(2);
@@ -271,18 +301,18 @@ protected MessageDigest initialValue() {
         private static final int SALT_LENGTH_BITS = 128;
 
         public BigInteger getSalt() {
-            return salt;
+            return this.salt;
         }
 
         public BigInteger getVerifier() {
-            return verifier;
+            return this.verifier;
         }
 
         public deviceSRP(String deviceGroupKey, String deviceKey, String password) {
             byte[] deviceKeyHash = getUserIdHash(deviceGroupKey, deviceKey, password);
 
-            salt = new BigInteger(SALT_LENGTH_BITS, SECURE_RANDOM);
-            verifier = calcVerifier(salt, deviceKeyHash);
+            this.salt = new BigInteger(SALT_LENGTH_BITS, SECURE_RANDOM);
+            this.verifier = calcVerifier(this.salt, deviceKeyHash);
         }
 
         private static BigInteger calcVerifier(BigInteger salt, byte[] userIdHash) {
@@ -313,48 +343,40 @@ public static void begin() {
 
         public static void update(String... strings) {
             MessageDigest md = THREAD_MESSAGE_DIGEST.get();
-            for (String s : strings) {
-                if (s != null) {
+            for (String s : strings)
+                if (s != null)
                     md.update(s.getBytes(StringUtils.UTF8));
-                }
-            }
         }
 
         public static void update(String s) {
             MessageDigest md = THREAD_MESSAGE_DIGEST.get();
-            if (s != null) {
+            if (s != null)
                 md.update(s.getBytes(StringUtils.UTF8));
-            }
         }
 
         public static void update(BigInteger... bigInts) {
             MessageDigest md = THREAD_MESSAGE_DIGEST.get();
-            for (BigInteger n : bigInts) {
-                if (n != null) {
+            for (BigInteger n : bigInts)
+                if (n != null)
                     md.update(n.toByteArray());
-                }
-            }
         }
 
         public static void update(BigInteger n) {
             MessageDigest md = THREAD_MESSAGE_DIGEST.get();
-            if (n != null) {
+            if (n != null)
                 md.update(n.toByteArray());
-            }
         }
 
         public static void update(ByteBuffer b) {
             MessageDigest md = THREAD_MESSAGE_DIGEST.get();
-            if (b != null) {
+            if (b != null)
                 md.update(b.array());
-            }
         }
 
         public static void update(byte[] b) {
             MessageDigest md = THREAD_MESSAGE_DIGEST.get();
-            if (b != null) {
+            if (b != null)
                 md.update(b);
-            }
         }
     }
 
diff --git a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/util/CognitoJWTParser.java b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/util/CognitoJWTParser.java
index 7751710874..2b93dc7a8a 100644
--- a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/util/CognitoJWTParser.java
+++ b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/mobileconnectors/cognitoidentityprovider/util/CognitoJWTParser.java
@@ -17,14 +17,13 @@
 
 package com.amazonaws.mobileconnectors.cognitoidentityprovider.util;
 
-import android.util.Base64;
-
-import com.amazonaws.mobileconnectors.cognitoidentityprovider.exceptions.CognitoParameterInvalidException;
+import java.io.UnsupportedEncodingException;
 
 import org.json.JSONException;
 import org.json.JSONObject;
 
-import java.io.UnsupportedEncodingException;
+import com.amazonaws.mobileconnectors.cognitoidentityprovider.exceptions.CognitoParameterInvalidException;
+import com.amazonaws.util.Base64;
 
 /**
  * Utility class for all operations on JWT.
@@ -37,13 +36,14 @@
     /**
      * Returns header for a JWT as a JSON object.
      *
-     * @param JWT       REQUIRED: valid JSON Web Token as String.
+     * @param JWT
+     *            REQUIRED: valid JSON Web Token as String.
      * @return header as a JSONObject.
      */
     public static JSONObject getHeader(String JWT) {
         try {
             validateJWT(JWT);
-            byte[] sectionDecoded = Base64.decode(JWT.split("\\.")[HEADER], Base64.URL_SAFE);
+            byte[] sectionDecoded = Base64.decode(JWT.split("\\.")[HEADER]);
             String jwtSection = new String(sectionDecoded, "UTF-8");
             return new JSONObject(jwtSection);
         } catch (UnsupportedEncodingException e) {
@@ -58,14 +58,15 @@ public static JSONObject getHeader(String JWT) {
     /**
      * Returns payload of a JWT as a JSON object.
      *
-     * @param JWT       REQUIRED: valid JSON Web Token as String.
+     * @param JWT
+     *            REQUIRED: valid JSON Web Token as String.
      * @return payload as a JSONObject.
      */
     public static JSONObject getPayload(String JWT) {
         try {
             validateJWT(JWT);
             String payload = JWT.split("\\.")[PAYLOAD];
-            byte[] sectionDecoded = Base64.decode(payload, Base64.URL_SAFE);
+            byte[] sectionDecoded = Base64.decode(payload);
             String jwtSection = new String(sectionDecoded, "UTF-8");
             return new JSONObject(jwtSection);
         } catch (UnsupportedEncodingException e) {
@@ -80,13 +81,14 @@ public static JSONObject getPayload(String JWT) {
     /**
      * Returns signature of a JWT as a String.
      *
-     * @param JWT       REQUIRED: valid JSON Web Token as String.
+     * @param JWT
+     *            REQUIRED: valid JSON Web Token as String.
      * @return signature as a String.
      */
     public static String getSignature(String JWT) {
         try {
             validateJWT(JWT);
-            byte[] sectionDecoded = Base64.decode(JWT.split("\\.")[SIGNATURE], Base64.URL_SAFE);
+            byte[] sectionDecoded = Base64.decode(JWT.split("\\.")[SIGNATURE]);
             return new String(sectionDecoded, "UTF-8");
         } catch (Exception e) {
             throw new CognitoParameterInvalidException("error in parsing JSON");
@@ -96,18 +98,19 @@ public static String getSignature(String JWT) {
     /**
      * Returns a claim, from the {@code JWT}s' payload, as a String.
      *
-     * @param JWT       REQUIRED: valid JSON Web Token as String.
-     * @param claim     REQUIRED: claim name as String.
-     * @return  claim from the JWT as a String.
+     * @param JWT
+     *            REQUIRED: valid JSON Web Token as String.
+     * @param claim
+     *            REQUIRED: claim name as String.
+     * @return claim from the JWT as a String.
      */
     public static String getClaim(String JWT, String claim) {
         try {
             JSONObject payload = getPayload(JWT);
             Object claimValue = payload.get(claim);
 
-            if (claimValue != null) {
+            if (claimValue != null)
                 return claimValue.toString();
-            }
 
         } catch (Exception e) {
             throw new CognitoParameterInvalidException("invalid token");
@@ -115,17 +118,15 @@ public static String getClaim(String JWT, String claim) {
         return null;
     }
 
-
     /**
-     *  Checks if {@code JWT} is a valid JSON Web Token.
+     * Checks if {@code JWT} is a valid JSON Web Token.
      *
      * @param JWT
      */
     public static void validateJWT(String JWT) {
         // Check if the the JWT has the three parts
         String[] jwtParts = JWT.split("\\.");
-        if(jwtParts.length != 3) {
+        if (jwtParts.length != 3)
             throw new CognitoParameterInvalidException("not a JSON Web Token");
-        }
     }
 }
diff --git a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/services/cognitoidentityprovider/AmazonCognitoIdentityProviderClient.java b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/services/cognitoidentityprovider/AmazonCognitoIdentityProviderClient.java
index aac4a8c355..db15105de7 100644
--- a/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/services/cognitoidentityprovider/AmazonCognitoIdentityProviderClient.java
+++ b/aws-android-sdk-cognitoidentityprovider/src/main/java/com/amazonaws/services/cognitoidentityprovider/AmazonCognitoIdentityProviderClient.java
@@ -18,13 +18,14 @@
 import java.util.*;
 
 import com.amazonaws.*;
+import com.amazonaws.adroid.utils.*;
 import com.amazonaws.auth.*;
 import com.amazonaws.handlers.*;
 import com.amazonaws.http.*;
 import com.amazonaws.internal.*;
 import com.amazonaws.metrics.*;
 import com.amazonaws.transform.*;
-import com.amazonaws.util.*;
+import com.amazonaws.util.AWSRequestMetrics;
 import com.amazonaws.util.AWSRequestMetrics.Field;
 
 import com.amazonaws.services.cognitoidentityprovider.model.*;
diff --git a/aws-android-sdk-core/src/main/java/com/amazonaws/auth/CognitoCachingCredentialsProvider.java b/aws-android-sdk-core/src/main/java/com/amazonaws/auth/CognitoCachingCredentialsProvider.java
index 29609199ca..3ab5387b5c 100644
--- a/aws-android-sdk-core/src/main/java/com/amazonaws/auth/CognitoCachingCredentialsProvider.java
+++ b/aws-android-sdk-core/src/main/java/com/amazonaws/auth/CognitoCachingCredentialsProvider.java
@@ -15,34 +15,29 @@
 
 package com.amazonaws.auth;
 
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.util.Log;
+import java.util.Date;
+import java.util.Map;
 
 import com.amazonaws.ClientConfiguration;
+import com.amazonaws.adroid.utils.Context;
+import com.amazonaws.adroid.utils.Log;
+import com.amazonaws.adroid.utils.SharedPreferences;
 import com.amazonaws.regions.Regions;
 import com.amazonaws.services.cognitoidentity.AmazonCognitoIdentityClient;
 import com.amazonaws.services.cognitoidentity.model.NotAuthorizedException;
 import com.amazonaws.services.securitytoken.AWSSecurityTokenService;
 import com.amazonaws.util.VersionInfoUtils;
 
-import java.util.Date;
-import java.util.Map;
-
 /**
- * This credentials provider is intended for Android applications. It offers the
- * ability to persist the Cognito identity id in {@link SharedPreferences}.
- * Furthermore, it caches session credentials so as to reduce the number of
- * network requests. This is the provider to use with a custom identity
- * provider, which should be an extension of AWSAbstractCognitoIdentityProvider.
- * This will consume an identity provider, as well. If one is passed in to a
- * constructor, then that one is the one that is consumed, but if not/a
- * constructor that doesn't take an identity provider is used, then the Cognito
- * identity provider is used by default.
+ * This credentials provider is intended for Android applications. It offers the ability to persist the Cognito identity
+ * id in {@link SharedPreferences}. Furthermore, it caches session credentials so as to reduce the number of network
+ * requests. This is the provider to use with a custom identity provider, which should be an extension of
+ * AWSAbstractCognitoIdentityProvider. This will consume an identity provider, as well. If one is passed in to a
+ * constructor, then that one is the one that is consumed, but if not/a constructor that doesn't take an identity
+ * provider is used, then the Cognito identity provider is used by default.
  * <p>
- * Note: if you haven't yet associated your IAM roles with your identity pool,
- * please do so via the Cognito console before using this constructor. You will
- * get an InvalidIdentityPoolConfigurationException if you use it and have not.
+ * Note: if you haven't yet associated your IAM roles with your identity pool, please do so via the Cognito console
+ * before using this constructor. You will get an InvalidIdentityPoolConfigurationException if you use it and have not.
  * </p>
  *
  * <pre>
@@ -73,12 +68,11 @@
  *         Regions.US_EAST_1);
  * </pre>
  */
-public class CognitoCachingCredentialsProvider
-        extends CognitoCredentialsProvider {
+public class CognitoCachingCredentialsProvider extends CognitoCredentialsProvider {
 
     private final String DEFAULT_SHAREDPREFERENCES_NAME = "com.amazonaws.android.auth";
-    private static final String USER_AGENT = CognitoCachingCredentialsProvider.class.getName()
-            + "/" + VersionInfoUtils.getVersion();
+    private static final String USER_AGENT =
+        CognitoCachingCredentialsProvider.class.getName() + "/" + VersionInfoUtils.getVersion();
     private final SharedPreferences prefs;
     private String identityId;
 
@@ -102,291 +96,279 @@ public void identityChanged(String oldIdentityId, String newIdentityId) {
     };
 
     /**
-     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
-     * use the specified Amazon Cognito identity pool to make a request, using
-     * the basic authentication flow, to the AWS Security Token Service (STS) to
-     * request short-lived session credentials, which will then be returned by
-     * this class's {@link #getCredentials()} method.
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will use the specified Amazon Cognito identity
+     * pool to make a request, using the basic authentication flow, to the AWS Security Token Service (STS) to request
+     * short-lived session credentials, which will then be returned by this class's {@link #getCredentials()} method.
      *
-     * @param context The Android context to be used for the caching
-     * @param accountId The AWS accountId for the account with Amazon Cognito
-     * @param identityPoolId The Amazon Cogntio identity pool to use
-     * @param unauthRoleArn The ARN of the IAM Role that will be assumed when
-     *            unauthenticated
-     * @param authRoleArn The ARN of the IAM Role that will be assumed when
-     *            authenticated
-     * @param region The region to use when contacting Cognito Identity
+     * @param context
+     *            The Android context to be used for the caching
+     * @param accountId
+     *            The AWS accountId for the account with Amazon Cognito
+     * @param identityPoolId
+     *            The Amazon Cogntio identity pool to use
+     * @param unauthRoleArn
+     *            The ARN of the IAM Role that will be assumed when unauthenticated
+     * @param authRoleArn
+     *            The ARN of the IAM Role that will be assumed when authenticated
+     * @param region
+     *            The region to use when contacting Cognito Identity
      */
-    public CognitoCachingCredentialsProvider(Context context, String accountId,
-            String identityPoolId, String unauthRoleArn, String authRoleArn, Regions region) {
+    public CognitoCachingCredentialsProvider(Context context, String accountId, String identityPoolId,
+                                             String unauthRoleArn, String authRoleArn, Regions region) {
         super(accountId, identityPoolId, unauthRoleArn, authRoleArn, region);
-        if (context == null) {
+        if (context == null)
             throw new IllegalArgumentException("context can't be null");
-        }
-        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
-                Context.MODE_PRIVATE);
+        this.prefs = context.getSharedPreferences(this.DEFAULT_SHAREDPREFERENCES_NAME, Context.MODE_PRIVATE);
         initialize();
     }
 
     /**
-     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
-     * use the specified Amazon Cognito identity pool to make a request, using
-     * the basic authentication flow, to the AWS Security Token Service (STS) to
-     * request short-lived session credentials, which will then be returned by
-     * this class's {@link #getCredentials()} method.
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will use the specified Amazon Cognito identity
+     * pool to make a request, using the basic authentication flow, to the AWS Security Token Service (STS) to request
+     * short-lived session credentials, which will then be returned by this class's {@link #getCredentials()} method.
      * <p>
-     * This version of the constructor allows you to specify a client
-     * configuration for the Amazon Cognito and STS clients.
+     * This version of the constructor allows you to specify a client configuration for the Amazon Cognito and STS
+     * clients.
      * </p>
      *
-     * @param context The Android context to be used for the caching
-     * @param accountId The AWS accountId for the account with Amazon Cognito
-     * @param identityPoolId The Amazon Cognito identity pool to use
-     * @param unauthRoleArn The ARN of the IAM Role that will be assumed when
-     *            unauthenticated
-     * @param authRoleArn The ARN of the IAM Role that will be assumed when
-     *            authenticated
-     * @param region The region to use when contacting Cognito Identity
-     * @param clientConfiguration Configuration to apply to service clients
-     *            created
+     * @param context
+     *            The Android context to be used for the caching
+     * @param accountId
+     *            The AWS accountId for the account with Amazon Cognito
+     * @param identityPoolId
+     *            The Amazon Cognito identity pool to use
+     * @param unauthRoleArn
+     *            The ARN of the IAM Role that will be assumed when unauthenticated
+     * @param authRoleArn
+     *            The ARN of the IAM Role that will be assumed when authenticated
+     * @param region
+     *            The region to use when contacting Cognito Identity
+     * @param clientConfiguration
+     *            Configuration to apply to service clients created
      */
-    public CognitoCachingCredentialsProvider(Context context, String accountId,
-            String identityPoolId, String unauthRoleArn, String authRoleArn, Regions region,
-            ClientConfiguration clientConfiguration) {
+    public CognitoCachingCredentialsProvider(Context context, String accountId, String identityPoolId,
+                                             String unauthRoleArn, String authRoleArn, Regions region,
+                                             ClientConfiguration clientConfiguration) {
         super(accountId, identityPoolId, unauthRoleArn, authRoleArn, region, clientConfiguration);
-        if (context == null) {
+        if (context == null)
             throw new IllegalArgumentException("context can't be null");
-        }
-        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
-                Context.MODE_PRIVATE);
+        this.prefs = context.getSharedPreferences(this.DEFAULT_SHAREDPREFERENCES_NAME, Context.MODE_PRIVATE);
         initialize();
     }
 
     /**
-     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
-     * use the specified Amazon Cognito identity pool to make a request to
-     * Cognito, using the enhanced flow, to get short lived session credentials,
-     * which will then be returned by this class's {@link #getCredentials()}
-     * method.
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will use the specified Amazon Cognito identity
+     * pool to make a request to Cognito, using the enhanced flow, to get short lived session credentials, which will
+     * then be returned by this class's {@link #getCredentials()} method.
      * <p>
-     * Note: if you haven't yet associated your IAM roles with your identity
-     * pool, please do so via the Cognito console before using this constructor.
-     * You will get an InvalidIdentityPoolConfigurationException if you use it
-     * and have not. The existing constructor (mirroring this one but with roles
-     * and an account id) will work without doing so, but will not use the
-     * enhanced flow.
+     * Note: if you haven't yet associated your IAM roles with your identity pool, please do so via the Cognito console
+     * before using this constructor. You will get an InvalidIdentityPoolConfigurationException if you use it and have
+     * not. The existing constructor (mirroring this one but with roles and an account id) will work without doing so,
+     * but will not use the enhanced flow.
      * </p>
      *
-     * @param context The Android context to be used for the caching
-     * @param identityPoolId The Amazon Cognito identity pool to use
-     * @param region The region to use when contacting Cognito Identity
+     * @param context
+     *            The Android context to be used for the caching
+     * @param identityPoolId
+     *            The Amazon Cognito identity pool to use
+     * @param region
+     *            The region to use when contacting Cognito Identity
      */
     public CognitoCachingCredentialsProvider(Context context, String identityPoolId, Regions region) {
         super(identityPoolId, region);
-        if (context == null) {
+        if (context == null)
             throw new IllegalArgumentException("context can't be null");
-        }
-        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
-                Context.MODE_PRIVATE);
+        this.prefs = context.getSharedPreferences(this.DEFAULT_SHAREDPREFERENCES_NAME, Context.MODE_PRIVATE);
         initialize();
     }
 
     /**
-     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
-     * use the specified Amazon Cognito identity pool to make a request to
-     * Cognito, using the enhanced flow, to get short lived session credentials,
-     * which will then be returned by this class's {@link #getCredentials()}
-     * method.
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will use the specified Amazon Cognito identity
+     * pool to make a request to Cognito, using the enhanced flow, to get short lived session credentials, which will
+     * then be returned by this class's {@link #getCredentials()} method.
      * <p>
-     * This version of the constructor allows you to specify a client
-     * configuration for the Amazon Cognito client.
+     * This version of the constructor allows you to specify a client configuration for the Amazon Cognito client.
      * </p>
      * <p>
-     * Note: if you haven't yet associated your IAM roles with your identity
-     * pool, please do so via the Cognito console before using this constructor.
-     * You will get an InvalidIdentityPoolConfigurationException if you use it
-     * and have not. The existing constructor (mirroring this one but with roles
-     * and an account id) will work without doing so, but will not use the
-     * enhanced flow.
+     * Note: if you haven't yet associated your IAM roles with your identity pool, please do so via the Cognito console
+     * before using this constructor. You will get an InvalidIdentityPoolConfigurationException if you use it and have
+     * not. The existing constructor (mirroring this one but with roles and an account id) will work without doing so,
+     * but will not use the enhanced flow.
      * </p>
      *
-     * @param context The Android context to be used for the caching
-     * @param identityPoolId The Amazon Cognito identity pool to use
-     * @param region The region to use when contacting Cognito Identity
-     * @param clientConfiguration Configuration to apply to service clients
-     *            created
+     * @param context
+     *            The Android context to be used for the caching
+     * @param identityPoolId
+     *            The Amazon Cognito identity pool to use
+     * @param region
+     *            The region to use when contacting Cognito Identity
+     * @param clientConfiguration
+     *            Configuration to apply to service clients created
      */
-    public CognitoCachingCredentialsProvider(Context context, String identityPoolId,
-            Regions region, ClientConfiguration clientConfiguration) {
+    public CognitoCachingCredentialsProvider(Context context, String identityPoolId, Regions region,
+                                             ClientConfiguration clientConfiguration) {
         super(identityPoolId, region, clientConfiguration);
-        if (context == null) {
+        if (context == null)
             throw new IllegalArgumentException("context can't be null");
-        }
-        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
-                Context.MODE_PRIVATE);
+        this.prefs = context.getSharedPreferences(this.DEFAULT_SHAREDPREFERENCES_NAME, Context.MODE_PRIVATE);
         initialize();
     }
 
     /**
-     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
-     * use the specified Amazon Cognito identity pool to make a request to the
-     * AWS Security Token Service (STS) to get short-lived session credentials,
-     * which will then be returned by this class's {@link #getCredentials()}
-     * method.
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will use the specified Amazon Cognito identity
+     * pool to make a request to the AWS Security Token Service (STS) to get short-lived session credentials, which will
+     * then be returned by this class's {@link #getCredentials()} method.
      * <p>
-     * This version of the constructor allows you to specify the Amazon Cognito
-     * and STS client to use.
+     * This version of the constructor allows you to specify the Amazon Cognito and STS client to use.
      * </p>
      * <p>
-     * Set the roles and stsClient to null to use the enhanced authentication
-     * flow, not contacting STS. Otherwise the basic flow will be used.
+     * Set the roles and stsClient to null to use the enhanced authentication flow, not contacting STS. Otherwise the
+     * basic flow will be used.
      * </p>
      *
-     * @param context The Android context to be used for the caching
-     * @param accountId The AWS accountId for the account with Amazon Cognito
-     * @param identityPoolId The Amazon Cogntio identity pool to use
-     * @param unauthRoleArn The ARN of the IAM Role that will be assumed when
-     *            unauthenticated
-     * @param authRoleArn The ARN of the IAM Role that will be assumed when
-     *            authenticated
-     * @param cibClient Preconfigured CognitoIdentity client to make requests
-     *            with
-     * @param stsClient Preconfigured STS client to make requests with
+     * @param context
+     *            The Android context to be used for the caching
+     * @param accountId
+     *            The AWS accountId for the account with Amazon Cognito
+     * @param identityPoolId
+     *            The Amazon Cogntio identity pool to use
+     * @param unauthRoleArn
+     *            The ARN of the IAM Role that will be assumed when unauthenticated
+     * @param authRoleArn
+     *            The ARN of the IAM Role that will be assumed when authenticated
+     * @param cibClient
+     *            Preconfigured CognitoIdentity client to make requests with
+     * @param stsClient
+     *            Preconfigured STS client to make requests with
      */
-    public CognitoCachingCredentialsProvider(Context context, String accountId,
-            String identityPoolId, String unauthArn, String authArn,
-            AmazonCognitoIdentityClient cibClient, AWSSecurityTokenService stsClient) {
+    public CognitoCachingCredentialsProvider(Context context, String accountId, String identityPoolId, String unauthArn,
+                                             String authArn, AmazonCognitoIdentityClient cibClient,
+                                             AWSSecurityTokenService stsClient) {
         super(accountId, identityPoolId, unauthArn, authArn, cibClient, stsClient);
-        if (context == null) {
+        if (context == null)
             throw new IllegalArgumentException("context can't be null");
-        }
-        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
-                Context.MODE_PRIVATE);
+        this.prefs = context.getSharedPreferences(this.DEFAULT_SHAREDPREFERENCES_NAME, Context.MODE_PRIVATE);
         initialize();
     }
 
     /**
-     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
-     * set up a link to the provider passed in using the basic authentication
-     * flow to get get short-lived credentials from STS, which can be retrieved
-     * from {@link #getCredentials()}
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will set up a link to the provider passed in
+     * using the basic authentication flow to get get short-lived credentials from STS, which can be retrieved from
+     * {@link #getCredentials()}
      * <p>
-     * This version of the constructor allows you to specify your own Identity
-     * Provider class.
+     * This version of the constructor allows you to specify your own Identity Provider class.
      * </p>
      *
-     * @param context The Android context to be used for the caching
-     * @param provider a reference to the provider in question, including what's
-     *            needed to interact with it to later connect with STS
-     * @param unauthArn the unauthArn, for use with the STS call
-     * @param authArn the authArn, for use with the STS call
+     * @param context
+     *            The Android context to be used for the caching
+     * @param provider
+     *            a reference to the provider in question, including what's needed to interact with it to later connect
+     *            with STS
+     * @param unauthArn
+     *            the unauthArn, for use with the STS call
+     * @param authArn
+     *            the authArn, for use with the STS call
      */
-    public CognitoCachingCredentialsProvider(Context context, AWSCognitoIdentityProvider provider,
-            String unauthArn, String authArn) {
+    public CognitoCachingCredentialsProvider(Context context, AWSCognitoIdentityProvider provider, String unauthArn,
+                                             String authArn) {
         super(provider, unauthArn, authArn);
-        if (context == null) {
+        if (context == null)
             throw new IllegalArgumentException("context can't be null");
-        }
-        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
-                Context.MODE_PRIVATE);
+        this.prefs = context.getSharedPreferences(this.DEFAULT_SHAREDPREFERENCES_NAME, Context.MODE_PRIVATE);
         initialize();
     }
 
     /**
-     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
-     * set up a link to the provider passed in to use the basic authentication
-     * flow to get short-lived credentials from STS, which can be retrieved from
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will set up a link to the provider passed in to
+     * use the basic authentication flow to get short-lived credentials from STS, which can be retrieved from
      * {@link #getCredentials()}
      * <p>
-     * This version of the constructor allows you to specify your own Identity
-     * Provider class, and the STS client to use.
+     * This version of the constructor allows you to specify your own Identity Provider class, and the STS client to
+     * use.
      * </p>
      *
-     * @param context The Android context to be used for the caching
-     * @param provider a reference to the provider in question, including what's
-     *            needed to interact with it to later connect with STS
-     * @param unauthArn the unauthArn, for use with the STS call
-     * @param authArn the authArn, for use with the STS call
-     * @param stsClient the sts endpoint to get session credentials from
+     * @param context
+     *            The Android context to be used for the caching
+     * @param provider
+     *            a reference to the provider in question, including what's needed to interact with it to later connect
+     *            with STS
+     * @param unauthArn
+     *            the unauthArn, for use with the STS call
+     * @param authArn
+     *            the authArn, for use with the STS call
+     * @param stsClient
+     *            the sts endpoint to get session credentials from
      */
-    public CognitoCachingCredentialsProvider(Context context, AWSCognitoIdentityProvider provider,
-            String unauthArn, String authArn, AWSSecurityTokenService stsClient) {
+    public CognitoCachingCredentialsProvider(Context context, AWSCognitoIdentityProvider provider, String unauthArn,
+                                             String authArn, AWSSecurityTokenService stsClient) {
         super(provider, unauthArn, authArn, stsClient);
-        if (context == null) {
+        if (context == null)
             throw new IllegalArgumentException("context can't be null");
-        }
-        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
-                Context.MODE_PRIVATE);
+        this.prefs = context.getSharedPreferences(this.DEFAULT_SHAREDPREFERENCES_NAME, Context.MODE_PRIVATE);
         initialize();
     }
 
     /**
-     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
-     * set up a link to the provider passed in using the enhanced authentication
-     * flow to get short-lived credentials from Amazon Cognito, which can be
-     * retrieved from {@link #getCredentials()}
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will set up a link to the provider passed in
+     * using the enhanced authentication flow to get short-lived credentials from Amazon Cognito, which can be retrieved
+     * from {@link #getCredentials()}
      * <p>
-     * This version of the constructor allows you to specify your own Identity
-     * Provider class.
+     * This version of the constructor allows you to specify your own Identity Provider class.
      * </p>
      * <p>
-     * Note: if you haven't yet associated your IAM roles with your identity
-     * pool, please do so via the Cognito console before using this constructor.
-     * You will get an InvalidIdentityPoolConfigurationException if you use it
-     * and have not. The existing constructor (mirroring this one but with
-     * roles) will work without doing so, but will not use the enhanced flow.
+     * Note: if you haven't yet associated your IAM roles with your identity pool, please do so via the Cognito console
+     * before using this constructor. You will get an InvalidIdentityPoolConfigurationException if you use it and have
+     * not. The existing constructor (mirroring this one but with roles) will work without doing so, but will not use
+     * the enhanced flow.
      * </p>
      *
-     * @param context The Android context to be used for the caching
-     * @param provider a reference to the provider in question, including what's
-     *            needed to interact with it to later connect with Amazon
-     *            Cognito
-     * @param region The region to use when contacting Cognito
+     * @param context
+     *            The Android context to be used for the caching
+     * @param provider
+     *            a reference to the provider in question, including what's needed to interact with it to later connect
+     *            with Amazon Cognito
+     * @param region
+     *            The region to use when contacting Cognito
      */
-    public CognitoCachingCredentialsProvider(Context context, AWSCognitoIdentityProvider provider,
-            Regions region) {
+    public CognitoCachingCredentialsProvider(Context context, AWSCognitoIdentityProvider provider, Regions region) {
         super(provider, region);
-        if (context == null) {
+        if (context == null)
             throw new IllegalArgumentException("context can't be null");
-        }
-        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
-                Context.MODE_PRIVATE);
+        this.prefs = context.getSharedPreferences(this.DEFAULT_SHAREDPREFERENCES_NAME, Context.MODE_PRIVATE);
         initialize();
     }
 
     /**
-     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will
-     * set up a link to the provider passed in using the enhanced authentication
-     * flow to get short-lived credentials from Amazon Cognito, which can be
-     * retrieved from {@link #getCredentials()}
+     * Constructs a new {@link CognitoCachingCredentialsProvider}, which will set up a link to the provider passed in
+     * using the enhanced authentication flow to get short-lived credentials from Amazon Cognito, which can be retrieved
+     * from {@link #getCredentials()}
      * <p>
-     * This version of the constructor allows you to specify your own Identity
-     * Provider class and the configuration for the Amazon Cognito client.
+     * This version of the constructor allows you to specify your own Identity Provider class and the configuration for
+     * the Amazon Cognito client.
      * </p>
      * <p>
-     * Note: if you haven't yet associated your IAM roles with your identity
-     * pool, please do so via the Cognito console before using this constructor.
-     * You will get an InvalidIdentityPoolConfigurationException if you use it
-     * and have not. The existing constructor (mirroring this one but with
-     * roles) will work without doing so, but will not use the enhanced flow.
+     * Note: if you haven't yet associated your IAM roles with your identity pool, please do so via the Cognito console
+     * before using this constructor. You will get an InvalidIdentityPoolConfigurationException if you use it and have
+     * not. The existing constructor (mirroring this one but with roles) will work without doing so, but will not use
+     * the enhanced flow.
      * </p>
      *
-     * @param context The Android context to be used for the caching
-     * @param provider a reference to the provider in question, including what's
-     *            needed to interact with it to later connect with Amazon
-     *            Cognito
-     * @param clientConfiguration Configuration to apply to service clients
-     *            created
-     * @param region The region to use when contacting Cognito Identity
+     * @param context
+     *            The Android context to be used for the caching
+     * @param provider
+     *            a reference to the provider in question, including what's needed to interact with it to later connect
+     *            with Amazon Cognito
+     * @param clientConfiguration
+     *            Configuration to apply to service clients created
+     * @param region
+     *            The region to use when contacting Cognito Identity
      */
-    public CognitoCachingCredentialsProvider(Context context, AWSCognitoIdentityProvider provider,
-            Regions region, ClientConfiguration clientConfiguration) {
+    public CognitoCachingCredentialsProvider(Context context, AWSCognitoIdentityProvider provider, Regions region,
+                                             ClientConfiguration clientConfiguration) {
         super(provider, region, clientConfiguration);
-        if (context == null) {
+        if (context == null)
             throw new IllegalArgumentException("context can't be null");
-        }
-        this.prefs = context.getSharedPreferences(DEFAULT_SHAREDPREFERENCES_NAME,
-                Context.MODE_PRIVATE);
+        this.prefs = context.getSharedPreferences(this.DEFAULT_SHAREDPREFERENCES_NAME, Context.MODE_PRIVATE);
         initialize();
     }
 
@@ -394,14 +376,13 @@ private void initialize() {
         checkUpgrade();
         this.identityId = getCachedIdentityId();
         loadCachedCredentials();
-        registerIdentityChangedListener(listener);
+        registerIdentityChangedListener(this.listener);
     }
 
     /**
-     * Gets the Cognito identity id of the user. The first time when this method
-     * is called, a network request will be made to retrieve a new identity id.
-     * After that it's saved in {@link SharedPreferences}. Please don't call it
-     * in the main thread.
+     * Gets the Cognito identity id of the user. The first time when this method is called, a network request will be
+     * made to retrieve a new identity id. After that it's saved in {@link SharedPreferences}. Please don't call it in
+     * the main thread.
      *
      * @return identity id of the user
      */
@@ -409,31 +390,29 @@ private void initialize() {
     public String getIdentityId() {
         // If a login has been added, this condition is met
         // and refresh is called to update the id
-        if (needIdentityRefresh) {
-            needIdentityRefresh = false;
+        if (this.needIdentityRefresh) {
+            this.needIdentityRefresh = false;
             refresh();
-            identityId = super.getIdentityId();
-            saveIdentityId(identityId);
+            this.identityId = super.getIdentityId();
+            saveIdentityId(this.identityId);
         }
 
         // try to get the ID from SharedPreferences
         this.identityId = getCachedIdentityId();
         if (this.identityId == null) {
-            identityId = super.getIdentityId();
-            saveIdentityId(identityId);
+            this.identityId = super.getIdentityId();
+            saveIdentityId(this.identityId);
         }
-        return identityId;
+        return this.identityId;
     }
 
     @Override
     synchronized public AWSSessionCredentials getCredentials() {
-        if (sessionCredentials == null) {
+        if (this.sessionCredentials == null)
             loadCachedCredentials();
-        }
         // return only if the credentials are valid
-        if (!needsNewSession()) {
-            return sessionCredentials;
-        }
+        if (!needsNewSession())
+            return this.sessionCredentials;
 
         try {
             // super will validate loaded credentials
@@ -446,62 +425,56 @@ synchronized public AWSSessionCredentials getCredentials() {
                 // match the current id, so clear them
                 super.setIdentityId(null);
                 super.getCredentials();
-            }
-            else {
+            } else
                 throw e;
-            }
         }
 
-        saveCredentials(sessionCredentials,
-                getSessionCredentitalsExpiration().getTime());
+        saveCredentials(this.sessionCredentials, getSessionCredentitalsExpiration().getTime());
 
-        return sessionCredentials;
+        return this.sessionCredentials;
     }
-    
+
     @Override
     public void refresh() {
         super.refresh();
-        saveCredentials(sessionCredentials,
-                getSessionCredentitalsExpiration().getTime());
+        saveCredentials(this.sessionCredentials, getSessionCredentitalsExpiration().getTime());
     }
 
     @Override
     public void setLogins(Map<String, String> logins) {
         super.setLogins(logins);
         // A new login has been added, so an identity refresh is necessary
-        needIdentityRefresh = true;
+        this.needIdentityRefresh = true;
         // clear cached credentials
         clearCredentials();
     }
 
     /*
      * (non-Javadoc)
-     * @see com.amazonaws.auth.CognitoCredentialsProvider#clear() Clears the AWS
-     * credentials and the identity id.
+     * @see com.amazonaws.auth.CognitoCredentialsProvider#clear() Clears the AWS credentials and the identity id.
      */
     @Override
     public void clear() {
         super.clear();
 
         // clear cached identity id and credentials
-        prefs.edit().clear().apply();
+        this.prefs.edit().clear().apply();
     }
 
     /*
      * (non-Javadoc)
-     * @see com.amazonaws.auth.CognitoCredentialsProvider#clearCredentials()
-     * Clears the AWS credentials
+     * @see com.amazonaws.auth.CognitoCredentialsProvider#clearCredentials() Clears the AWS credentials
      */
     @Override
     public void clearCredentials() {
         super.clearCredentials();
         Log.d(TAG, "Clearing credentials from SharedPreferences");
-        prefs.edit()
-                .remove(namespace(AK_KEY))
-                .remove(namespace(SK_KEY))
-                .remove(namespace(ST_KEY))
-                .remove(namespace(EXP_KEY))
-                .apply();
+        this.prefs.edit()
+                  .remove(namespace(AK_KEY))
+                  .remove(namespace(SK_KEY))
+                  .remove(namespace(ST_KEY))
+                  .remove(namespace(EXP_KEY))
+                  .apply();
     }
 
     /**
@@ -510,10 +483,9 @@ public void clearCredentials() {
      * @return cached identity id, null if it doesn't exist
      */
     public String getCachedIdentityId() {
-        String cachedIdentityId = prefs.getString(namespace(ID_KEY), null);
-        if (cachedIdentityId != null && identityId == null) {
+        String cachedIdentityId = this.prefs.getString(namespace(ID_KEY), null);
+        if ((cachedIdentityId != null) && (this.identityId == null))
             super.setIdentityId(cachedIdentityId);
-        }
         return cachedIdentityId;
     }
 
@@ -522,50 +494,45 @@ public String getCachedIdentityId() {
      */
     void loadCachedCredentials() {
         Log.d(TAG, "Loading credentials from SharedPreferences");
-        sessionCredentialsExpiration = new Date(prefs.getLong(namespace(EXP_KEY), 0));
+        this.sessionCredentialsExpiration = new Date(this.prefs.getLong(namespace(EXP_KEY), 0));
         // make sure we have valid data in prefs
-        boolean hasAK = prefs.contains(namespace(AK_KEY));
-        boolean hasSK = prefs.contains(namespace(SK_KEY));
-        boolean hasST = prefs.contains(namespace(ST_KEY));
+        boolean hasAK = this.prefs.contains(namespace(AK_KEY));
+        boolean hasSK = this.prefs.contains(namespace(SK_KEY));
+        boolean hasST = this.prefs.contains(namespace(ST_KEY));
         if (!hasAK || !hasSK || !hasST) {
             Log.d(TAG, "No valid credentials found in SharedPreferences");
-            sessionCredentialsExpiration = null;
+            this.sessionCredentialsExpiration = null;
             return;
         }
-        String AK = prefs.getString(namespace(AK_KEY), null);
-        String SK = prefs.getString(namespace(SK_KEY), null);
-        String ST = prefs.getString(namespace(ST_KEY), null);
+        String AK = this.prefs.getString(namespace(AK_KEY), null);
+        String SK = this.prefs.getString(namespace(SK_KEY), null);
+        String ST = this.prefs.getString(namespace(ST_KEY), null);
 
-        sessionCredentials = new BasicSessionCredentials(AK, SK, ST);
+        this.sessionCredentials = new BasicSessionCredentials(AK, SK, ST);
     }
 
     /**
      * Save the credentials to SharedPreferences
      */
-    private void saveCredentials(AWSSessionCredentials sessionCredentials,
-            long time) {
+    private void saveCredentials(AWSSessionCredentials sessionCredentials, long time) {
         Log.d(TAG, "Saving credentials to SharedPreferences");
-        if (sessionCredentials != null) {
-            prefs.edit()
-                    .putString(namespace(AK_KEY), sessionCredentials.getAWSAccessKeyId())
-                    .putString(namespace(SK_KEY), sessionCredentials.getAWSSecretKey())
-                    .putString(namespace(ST_KEY), sessionCredentials.getSessionToken())
-                    .putLong(namespace(EXP_KEY), time)
-                    .apply();
-        }
+        if (sessionCredentials != null)
+            this.prefs.edit()
+                      .putString(namespace(AK_KEY), sessionCredentials.getAWSAccessKeyId())
+                      .putString(namespace(SK_KEY), sessionCredentials.getAWSSecretKey())
+                      .putString(namespace(ST_KEY), sessionCredentials.getSessionToken())
+                      .putLong(namespace(EXP_KEY), time)
+                      .apply();
     }
 
     /**
-     * clear cached identity id and credentials Save the Amazon Cognito Identity
-     * Id to SharedPreferences
+     * clear cached identity id and credentials Save the Amazon Cognito Identity Id to SharedPreferences
      */
     private void saveIdentityId(String identityId) {
         Log.d(TAG, "Saving identity id to SharedPreferences");
         this.identityId = identityId;
 
-        prefs.edit()
-                .putString(namespace(ID_KEY), identityId)
-                .apply();
+        this.prefs.edit().putString(namespace(ID_KEY), identityId).apply();
     }
 
     @Override
@@ -580,14 +547,14 @@ protected String getUserAgent() {
     // namespace.
     private void checkUpgrade() {
         // check identity id without namespace
-        if (prefs.contains(ID_KEY)) {
-            Log.i(TAG,
-                    "Identity id without namespace is detected. It will be saved under new namespace.");
+        if (this.prefs.contains(ID_KEY)) {
+            Log.i(TAG, "Identity id without namespace is detected. It will be saved under new namespace.");
             // save identity id
-            String identityId = prefs.getString(ID_KEY, null);
-            prefs.edit().clear() // clear old data
-                    .putString(namespace(ID_KEY), identityId)
-                    .apply();
+            String identityId = this.prefs.getString(ID_KEY, null);
+            this.prefs.edit()
+                      .clear() // clear old data
+                      .putString(namespace(ID_KEY), identityId)
+                      .apply();
         }
     }
 
diff --git a/aws-android-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/AmazonCognitoIdentityClient.java b/aws-android-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/AmazonCognitoIdentityClient.java
index 3ee3c91a76..469024ff25 100644
--- a/aws-android-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/AmazonCognitoIdentityClient.java
+++ b/aws-android-sdk-core/src/main/java/com/amazonaws/services/cognitoidentity/AmazonCognitoIdentityClient.java
@@ -18,13 +18,14 @@
 import java.util.*;
 
 import com.amazonaws.*;
+import com.amazonaws.adroid.utils.*;
 import com.amazonaws.auth.*;
 import com.amazonaws.handlers.*;
 import com.amazonaws.http.*;
 import com.amazonaws.internal.*;
 import com.amazonaws.metrics.*;
 import com.amazonaws.transform.*;
-import com.amazonaws.util.*;
+import com.amazonaws.util.AWSRequestMetrics;
 import com.amazonaws.util.AWSRequestMetrics.Field;
 
 import com.amazonaws.services.cognitoidentity.model.*;
diff --git a/aws-android-sdk-core/src/main/java/com/amazonaws/services/securitytoken/AWSSecurityTokenServiceClient.java b/aws-android-sdk-core/src/main/java/com/amazonaws/services/securitytoken/AWSSecurityTokenServiceClient.java
index 00fd095e7a..5615fe1c6a 100644
--- a/aws-android-sdk-core/src/main/java/com/amazonaws/services/securitytoken/AWSSecurityTokenServiceClient.java
+++ b/aws-android-sdk-core/src/main/java/com/amazonaws/services/securitytoken/AWSSecurityTokenServiceClient.java
@@ -20,13 +20,14 @@
 import java.util.*;
 
 import com.amazonaws.*;
+import com.amazonaws.adroid.utils.*;
 import com.amazonaws.auth.*;
 import com.amazonaws.handlers.*;
 import com.amazonaws.http.*;
 import com.amazonaws.internal.*;
 import com.amazonaws.metrics.*;
 import com.amazonaws.transform.*;
-import com.amazonaws.util.*;
+import com.amazonaws.util.AWSRequestMetrics;
 import com.amazonaws.util.AWSRequestMetrics.Field;
 
 import com.amazonaws.services.securitytoken.model.*;
diff --git a/bin/.gitignore b/bin/.gitignore
new file mode 100644
index 0000000000..c2d9872a16
--- /dev/null
+++ b/bin/.gitignore
@@ -0,0 +1 @@
+/com/
diff --git a/build.properties b/build.properties
new file mode 100644
index 0000000000..f80cb31020
--- /dev/null
+++ b/build.properties
@@ -0,0 +1,7 @@
+source.. = src/
+output.. = bin/
+bin.includes = META-INF/,\
+               .
+src.includes = aws-android-sdk-core/src/main/java/,\
+               aws-android-sdk-cognitoidentityprovider/src/main/java/,\
+               src/
diff --git a/src/com/amazonaws/adroid/utils/Context.java b/src/com/amazonaws/adroid/utils/Context.java
new file mode 100644
index 0000000000..9dde0a0f6e
--- /dev/null
+++ b/src/com/amazonaws/adroid/utils/Context.java
@@ -0,0 +1,12 @@
+
+package com.amazonaws.adroid.utils;
+
+public class Context {
+
+    public static final int MODE_PRIVATE = 0;
+
+    public SharedPreferences getSharedPreferences(String node, int mode) {
+        return new SharedPreferencesImpl(node);
+    }
+
+}
diff --git a/src/com/amazonaws/adroid/utils/Editor.java b/src/com/amazonaws/adroid/utils/Editor.java
new file mode 100644
index 0000000000..3c2db18d95
--- /dev/null
+++ b/src/com/amazonaws/adroid/utils/Editor.java
@@ -0,0 +1,2 @@
+
+package com.amazonaws.adroid.utils;
diff --git a/src/com/amazonaws/adroid/utils/Log.java b/src/com/amazonaws/adroid/utils/Log.java
new file mode 100644
index 0000000000..c270ab851a
--- /dev/null
+++ b/src/com/amazonaws/adroid/utils/Log.java
@@ -0,0 +1,23 @@
+
+package com.amazonaws.adroid.utils;
+
+public class Log {
+
+    public static void e(String name, String message) {
+        System.err.println(name + " : " + message);
+    }
+
+    public static void d(String name, String message) {
+        System.out.println(name + " : " + message);
+    }
+
+    public static void e(String name, String message, Exception e) {
+        System.err.println(name + " : " + message);
+        e.printStackTrace();
+    }
+
+    public static void i(String name, String message) {
+        System.out.println(name + " : " + message);
+    }
+
+}
diff --git a/src/com/amazonaws/adroid/utils/SharedPreferences.java b/src/com/amazonaws/adroid/utils/SharedPreferences.java
new file mode 100644
index 0000000000..e3cef45773
--- /dev/null
+++ b/src/com/amazonaws/adroid/utils/SharedPreferences.java
@@ -0,0 +1,28 @@
+
+package com.amazonaws.adroid.utils;
+
+public interface SharedPreferences {
+
+    public boolean contains(String key);
+
+    public String getString(String key, String defaultValue);
+
+    public long getLong(String key, long defaultValue);
+
+    public Editor edit();
+
+    public interface Editor extends SharedPreferences {
+
+        Editor putString(String key, String value);
+
+        Editor putLong(String key, long value);
+
+        void apply();
+
+        Editor clear();
+
+        Editor remove(String key);
+
+    }
+
+}
diff --git a/src/com/amazonaws/adroid/utils/SharedPreferencesImpl.java b/src/com/amazonaws/adroid/utils/SharedPreferencesImpl.java
new file mode 100644
index 0000000000..27a139edb5
--- /dev/null
+++ b/src/com/amazonaws/adroid/utils/SharedPreferencesImpl.java
@@ -0,0 +1,78 @@
+
+package com.amazonaws.adroid.utils;
+
+import java.util.prefs.BackingStoreException;
+import java.util.prefs.Preferences;
+
+import com.amazonaws.adroid.utils.SharedPreferences.Editor;
+
+public class SharedPreferencesImpl implements Editor {
+
+    protected Preferences prefs;
+
+    public SharedPreferencesImpl(String nodePath) {
+        this.prefs = Preferences.userNodeForPackage(this.getClass());
+
+        String[] nodes = nodePath.split("[.]");
+        for (String node : nodes)
+            this.prefs = this.prefs.node(node);
+    }
+
+    @Override
+    public boolean contains(String key) {
+        return this.prefs.get(key, null) != null;
+    }
+
+    @Override
+    public String getString(String key, String defaultValue) {
+        return this.prefs.get(key, defaultValue);
+    }
+
+    @Override
+    public long getLong(String key, long defaultValue) {
+        return this.prefs.getLong(key, defaultValue);
+    }
+
+    @Override
+    public Editor putString(String key, String value) {
+        this.prefs.put(key, value);
+        return this;
+    }
+
+    @Override
+    public Editor putLong(String key, long value) {
+        this.prefs.putLong(key, value);
+        return this;
+    }
+
+    @Override
+    public void apply() {
+        try {
+            this.prefs.sync();
+        } catch (BackingStoreException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public Editor clear() {
+        try {
+            this.prefs.clear();
+        } catch (BackingStoreException e) {
+            e.printStackTrace();
+        }
+
+        return this;
+    }
+
+    @Override
+    public Editor remove(String key) {
+        this.prefs.remove(key);
+        return this;
+    }
+
+    @Override
+    public Editor edit() {
+        return this;
+    }
+}
