diff --git a/aws-java-sdk-s3/pom.xml b/aws-java-sdk-s3/pom.xml
index b28839a9ca..30dec25090 100644
--- a/aws-java-sdk-s3/pom.xml
+++ b/aws-java-sdk-s3/pom.xml
@@ -3,7 +3,7 @@
      xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
   <groupId>com.amazonaws</groupId>
-  <artifactId>aws-android-sdk-s3</artifactId>
+  <artifactId>aws-java-sdk-s3</artifactId>
   <packaging>jar</packaging>
   <name>AWS SDK for Java - Amazon S3</name>
   <description>The AWS Java SDK for Amazon S3 module holds the client classes that are used for communicating with Amazon Simple Storage Service</description>
@@ -18,15 +18,20 @@
   <dependencies>
     <dependency>
       <groupId>com.amazonaws</groupId>
-      <artifactId>aws-android-sdk-core</artifactId>
+      <artifactId>aws-java-sdk-core</artifactId>
       <optional>false</optional>
       <version>2.6.19</version>
     </dependency>
     <dependency>
       <groupId>com.amazonaws</groupId>
-      <artifactId>aws-android-sdk-kms</artifactId>
+      <artifactId>aws-java-sdk-kms</artifactId>
       <optional>false</optional>
-      <version>2.6.19</version>
+      <version>2.6.18</version>
+    </dependency>
+    <dependency>
+      <groupId>com.gluonhq</groupId>
+      <artifactId>charm-cloudlink-client</artifactId>
+      <version>4.4.7</version>
     </dependency>
     <dependency>
       <groupId>junit</groupId>
@@ -72,6 +77,12 @@
     </dependency>
   </dependencies>
 
+  <repositories>
+    <repository>
+      <id>GluonID</id>
+      <url>http://nexus.gluonhq.com/nexus/content/repositories/releases</url>
+    </repository>
+  </repositories>
   <build>
     <plugins>
       <plugin>
diff --git a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/DownloadTask.java b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/DownloadTask.java
index cbc5c384e9..d8e3afa4eb 100644
--- a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/DownloadTask.java
+++ b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/DownloadTask.java
@@ -72,18 +72,18 @@ public DownloadTask(TransferRecord download, AmazonS3 s3, TransferStatusUpdater
     @Override
     public Boolean call() throws Exception {
         if (!networkInfo.isNetworkConnected()) {
-            updater.updateState(download.id, TransferState.WAITING_FOR_NETWORK);
+            updater.updateState(download.getRecord().getId(), TransferState.WAITING_FOR_NETWORK);
             return false;
         }
-        updater.updateState(download.id, TransferState.IN_PROGRESS);
+        updater.updateState(download.getRecord().getId(), TransferState.IN_PROGRESS);
 
-        final GetObjectRequest getObjectRequest = new GetObjectRequest(download.bucketName,
-                download.key);
+        final GetObjectRequest getObjectRequest = new GetObjectRequest(download.getRecord().getBucketName(),
+                download.getRecord().getKey());
         TransferUtility.appendTransferServiceUserAgentString(getObjectRequest);
-        final File file = new File(download.file);
+        final File file = new File(download.getRecord().getFile());
         final long bytesCurrent = file.length();
         if (bytesCurrent > 0) {
-            LOGGER.debug(String.format("Resume transfer %d from %d bytes", download.id,
+            LOGGER.debug(String.format("Resume transfer %d from %d bytes", download.getRecord().getId(),
                     bytesCurrent));
             /*
              * Setting the last byte position to Ôºç1 means downloading the object
@@ -91,22 +91,22 @@ public Boolean call() throws Exception {
              */
             getObjectRequest.setRange(bytesCurrent, -1);
         }
-        getObjectRequest.setGeneralProgressListener(updater.newProgressListener(download.id));
+        getObjectRequest.setGeneralProgressListener(updater.newProgressListener(download.getRecord().getId()));
 
         try {
             final S3Object object = s3.getObject(getObjectRequest);
             if (object == null) {
-                updater.throwError(download.id, new IllegalStateException(
+                updater.throwError(download.getRecord().getId(), new IllegalStateException(
                         "AmazonS3.getObject returns null"));
-                updater.updateState(download.id, TransferState.FAILED);
+                updater.updateState(download.getRecord().getId(), TransferState.FAILED);
                 return false;
             }
 
             final long bytesTotal = object.getObjectMetadata().getInstanceLength();
-            updater.updateProgress(download.id, bytesCurrent, bytesTotal);
+            updater.updateProgress(download.getRecord().getId(), bytesCurrent, bytesTotal);
             saveToFile(object.getObjectContent(), file);
-            updater.updateProgress(download.id, bytesTotal, bytesTotal);
-            updater.updateState(download.id, TransferState.COMPLETED);
+            updater.updateProgress(download.getRecord().getId(), bytesTotal, bytesTotal);
+            updater.updateState(download.getRecord().getId(), TransferState.COMPLETED);
             return true;
         } catch (final Exception e) {
             if (RetryUtils.isInterrupted(e)) {
@@ -114,16 +114,16 @@ public Boolean call() throws Exception {
                  * thread is interrupted by user. don't update the state as it's
                  * set by caller who interrupted
                  */
-                LOGGER.debug("Transfer " + download.id + " is interrupted by user");
+                LOGGER.debug("Transfer " + download.getRecord().getId() + " is interrupted by user");
             } else if (e.getCause() != null &&
                     (e.getCause() instanceof IOException || e.getCause() instanceof AmazonClientException)
                     && !networkInfo.isNetworkConnected()) {
-                LOGGER.debug("Transfer " + download.id + " waits for network");
-                updater.updateState(download.id, TransferState.WAITING_FOR_NETWORK);
+                LOGGER.debug("Transfer " + download.getRecord().getId() + " waits for network");
+                updater.updateState(download.getRecord().getId(), TransferState.WAITING_FOR_NETWORK);
             } else {
-                LOGGER.debug("Failed to download: " + download.id + " due to " + e.getMessage());
-                updater.throwError(download.id, e);
-                updater.updateState(download.id, TransferState.FAILED);
+                LOGGER.debug("Failed to download: " + download.getRecord().getId() + " due to " + e.getMessage());
+                updater.throwError(download.getRecord().getId(), e);
+                updater.updateState(download.getRecord().getId(), TransferState.FAILED);
             }
         }
         return false;
diff --git a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/Record.java b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/Record.java
new file mode 100644
index 0000000000..9f7bc80c0e
--- /dev/null
+++ b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/Record.java
@@ -0,0 +1,324 @@
+package com.amazonaws.mobileconnectors.s3.transferutility;
+
+import java.util.Map;
+
+public class Record {
+    
+    private int id;
+    private int mainUploadId;
+    private int isRequesterPays;
+    private int isMultipart;
+    private int isLastPart;
+    private int isEncrypted;
+    private int partNumber;
+    private long bytesTotal;
+    private long bytesCurrent;
+    private long speed;
+    private long rangeStart;
+    private long rangeLast;
+    private long fileOffset;
+    private TransferType type;
+    private TransferState state;
+    private String bucketName;
+    private String key;
+    private String versionId;
+    private String file;
+    private String multipartId;
+    private String eTag;
+    private String headerContentType;
+    private String headerContentLanguage;
+    private String headerContentDisposition;
+    private String headerContentEncoding;
+    private String headerCacheControl;
+    private String headerExpire;
+
+    private Map<String, String> userMetadata;
+    private String expirationTimeRuleId;
+    // This is a long representing a date, however it may be null
+    private String httpExpires;
+    private String sseAlgorithm;
+    private String sseKMSKey;
+    private String md5;
+    private String cannedAcl;
+    
+    public Record() {
+    }
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public int getMainUploadId() {
+        return mainUploadId;
+    }
+
+    public void setMainUploadId(int mainUploadId) {
+        this.mainUploadId = mainUploadId;
+    }
+
+    public int getIsRequesterPays() {
+        return isRequesterPays;
+    }
+
+    public void setIsRequesterPays(int isRequesterPays) {
+        this.isRequesterPays = isRequesterPays;
+    }
+
+    public int getIsMultipart() {
+        return isMultipart;
+    }
+
+    public void setIsMultipart(int isMultipart) {
+        this.isMultipart = isMultipart;
+    }
+
+    public int getIsLastPart() {
+        return isLastPart;
+    }
+
+    public void setIsLastPart(int isLastPart) {
+        this.isLastPart = isLastPart;
+    }
+
+    public int getIsEncrypted() {
+        return isEncrypted;
+    }
+
+    public void setIsEncrypted(int isEncrypted) {
+        this.isEncrypted = isEncrypted;
+    }
+
+    public int getPartNumber() {
+        return partNumber;
+    }
+
+    public void setPartNumber(int partNumber) {
+        this.partNumber = partNumber;
+    }
+
+    public long getBytesTotal() {
+        return bytesTotal;
+    }
+
+    public void setBytesTotal(long bytesTotal) {
+        this.bytesTotal = bytesTotal;
+    }
+
+    public long getBytesCurrent() {
+        return bytesCurrent;
+    }
+
+    public void setBytesCurrent(long bytesCurrent) {
+        this.bytesCurrent = bytesCurrent;
+    }
+
+    public long getSpeed() {
+        return speed;
+    }
+
+    public void setSpeed(long speed) {
+        this.speed = speed;
+    }
+
+    public long getRangeStart() {
+        return rangeStart;
+    }
+
+    public void setRangeStart(long rangeStart) {
+        this.rangeStart = rangeStart;
+    }
+
+    public long getRangeLast() {
+        return rangeLast;
+    }
+
+    public void setRangeLast(long rangeLast) {
+        this.rangeLast = rangeLast;
+    }
+
+    public long getFileOffset() {
+        return fileOffset;
+    }
+
+    public void setFileOffset(long fileOffset) {
+        this.fileOffset = fileOffset;
+    }
+
+    public TransferType getType() {
+        return type;
+    }
+
+    public void setType(TransferType type) {
+        this.type = type;
+    }
+
+    public TransferState getState() {
+        return state;
+    }
+
+    public void setState(TransferState state) {
+        this.state = state;
+    }
+
+    public String getBucketName() {
+        return bucketName;
+    }
+
+    public void setBucketName(String bucketName) {
+        this.bucketName = bucketName;
+    }
+
+    public String getKey() {
+        return key;
+    }
+
+    public void setKey(String key) {
+        this.key = key;
+    }
+
+    public String getVersionId() {
+        return versionId;
+    }
+
+    public void setVersionId(String versionId) {
+        this.versionId = versionId;
+    }
+
+    public String getFile() {
+        return file;
+    }
+
+    public void setFile(String file) {
+        this.file = file;
+    }
+
+    public String getMultipartId() {
+        return multipartId;
+    }
+
+    public void setMultipartId(String multipartId) {
+        this.multipartId = multipartId;
+    }
+
+    public String geteTag() {
+        return eTag;
+    }
+
+    public void seteTag(String eTag) {
+        this.eTag = eTag;
+    }
+
+    public String getHeaderContentType() {
+        return headerContentType;
+    }
+
+    public void setHeaderContentType(String headerContentType) {
+        this.headerContentType = headerContentType;
+    }
+
+    public String getHeaderContentLanguage() {
+        return headerContentLanguage;
+    }
+
+    public void setHeaderContentLanguage(String headerContentLanguage) {
+        this.headerContentLanguage = headerContentLanguage;
+    }
+
+    public String getHeaderContentDisposition() {
+        return headerContentDisposition;
+    }
+
+    public void setHeaderContentDisposition(String headerContentDisposition) {
+        this.headerContentDisposition = headerContentDisposition;
+    }
+
+    public String getHeaderContentEncoding() {
+        return headerContentEncoding;
+    }
+
+    public void setHeaderContentEncoding(String headerContentEncoding) {
+        this.headerContentEncoding = headerContentEncoding;
+    }
+
+    public String getHeaderCacheControl() {
+        return headerCacheControl;
+    }
+
+    public void setHeaderCacheControl(String headerCacheControl) {
+        this.headerCacheControl = headerCacheControl;
+    }
+
+    public String getHeaderExpire() {
+        return headerExpire;
+    }
+
+    public void setHeaderExpire(String headerExpire) {
+        this.headerExpire = headerExpire;
+    }
+
+    public Map<String, String> getUserMetadata() {
+        return userMetadata;
+    }
+
+    public void setUserMetadata(Map<String, String> userMetadata) {
+        this.userMetadata = userMetadata;
+    }
+
+    public String getExpirationTimeRuleId() {
+        return expirationTimeRuleId;
+    }
+
+    public void setExpirationTimeRuleId(String expirationTimeRuleId) {
+        this.expirationTimeRuleId = expirationTimeRuleId;
+    }
+
+    public String getHttpExpires() {
+        return httpExpires;
+    }
+
+    public void setHttpExpires(String httpExpires) {
+        this.httpExpires = httpExpires;
+    }
+
+    public String getSseAlgorithm() {
+        return sseAlgorithm;
+    }
+
+    public void setSseAlgorithm(String sseAlgorithm) {
+        this.sseAlgorithm = sseAlgorithm;
+    }
+
+    public String getSseKMSKey() {
+        return sseKMSKey;
+    }
+
+    public void setSseKMSKey(String sseKMSKey) {
+        this.sseKMSKey = sseKMSKey;
+    }
+
+    public String getMd5() {
+        return md5;
+    }
+
+    public void setMd5(String md5) {
+        this.md5 = md5;
+    }
+
+    public String getCannedAcl() {
+        return cannedAcl;
+    }
+
+    public void setCannedAcl(String cannedAcl) {
+        this.cannedAcl = cannedAcl;
+    }
+
+    @Override
+    public String toString() {
+        return "Record{" + "id=" + id + ", mainUploadId=" + mainUploadId + ", isRequesterPays=" + isRequesterPays + ", isMultipart=" + isMultipart + ", isLastPart=" + isLastPart + ", isEncrypted=" + isEncrypted + ", partNumber=" + partNumber + ", bytesTotal=" + bytesTotal + ", bytesCurrent=" + bytesCurrent + ", speed=" + speed + ", rangeStart=" + rangeStart + ", rangeLast=" + rangeLast + ", fileOffset=" + fileOffset + ", type=" + type + ", state=" + state + ", bucketName=" + bucketName + ", key=" + key + ", versionId=" + versionId + ", file=" + file + ", multipartId=" + multipartId + ", eTag=" + eTag + ", headerContentType=" + headerContentType + ", headerContentLanguage=" + headerContentLanguage + ", headerContentDisposition=" + headerContentDisposition + ", headerContentEncoding=" + headerContentEncoding + ", headerCacheControl=" + headerCacheControl + ", headerExpire=" + headerExpire + ", userMetadata=" + userMetadata + ", expirationTimeRuleId=" + expirationTimeRuleId + ", httpExpires=" + httpExpires + ", sseAlgorithm=" + sseAlgorithm + ", sseKMSKey=" + sseKMSKey + ", md5=" + md5 + ", cannedAcl=" + cannedAcl + '}';
+    }
+
+}
diff --git a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/Service.java b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/Service.java
new file mode 100644
index 0000000000..3624e0e37e
--- /dev/null
+++ b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/Service.java
@@ -0,0 +1,96 @@
+package com.amazonaws.mobileconnectors.s3.transferutility;
+
+import com.gluonhq.cloudlink.client.data.DataClient;
+import com.gluonhq.cloudlink.client.data.DataClientBuilder;
+import com.gluonhq.cloudlink.client.data.OperationMode;
+import com.gluonhq.cloudlink.client.data.SyncFlag;
+import com.gluonhq.connect.ConnectState;
+import com.gluonhq.connect.GluonObservableList;
+import com.gluonhq.connect.provider.DataProvider;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javafx.beans.value.ChangeListener;
+import javafx.beans.value.ObservableValue;
+import javafx.collections.ObservableList;
+
+public class Service {
+
+    private static final Logger LOG = Logger.getLogger(Service.class.getName());
+    
+    private static final String DATABASE_NAME = "AWS_LOCAL_DATABASE";
+    
+    private final DataClient dataClient;
+
+    private GluonObservableList<Record> records;
+    
+    private static Service instance;
+    
+    public static Service getInstance() {
+        if (instance == null) {
+            instance = new Service();
+        }
+        return instance;
+    }
+    
+    private Service() {
+        dataClient = DataClientBuilder.create()
+                .operationMode(OperationMode.LOCAL_ONLY)
+                .build();
+        
+        retrieveRecords(DATABASE_NAME);
+    }
+    
+    private void retrieveRecords(String databaseName) {
+        records = DataProvider.retrieveList(dataClient.createListDataReader(databaseName, 
+                Record.class,
+                SyncFlag.LIST_WRITE_THROUGH, SyncFlag.OBJECT_WRITE_THROUGH));
+        records.exceptionProperty().addListener(new ChangeListener<Throwable>() {
+            @Override
+            public void changed(ObservableValue<? extends Throwable> observable, Throwable oldValue, Throwable newValue) {
+                LOG.log(Level.WARNING, "Exception dataClient", newValue);
+            }
+        });
+        records.stateProperty().addListener(new ChangeListener<ConnectState>() {
+            @Override
+            public void changed(ObservableValue<? extends ConnectState> observable, ConnectState oldValue, ConnectState newValue) {
+                LOG.log(Level.INFO, "State dataClient: " + newValue);
+            }
+        });
+        LOG.log(Level.INFO, "Initial state dataClient: " + records.getState());
+    }
+    
+    public ObservableList<Record> getRecords() {
+        return records;
+    }
+    
+    public Record getRecord(int id) {
+        for (Record record : records) {
+            if (record.getId() == id) {
+                return record;
+            }
+        }
+        return new Record();
+    }
+    
+    public void updateRecord(Record oldRecord, Record newRecord) {
+        Record r = getRecord(oldRecord.getId());
+        if (r.getId() == oldRecord.getId()) {
+            removeRecord(oldRecord);
+            addRecord(newRecord);
+            dataClient.push(records);
+        }
+    }
+    
+    public void addRecord(Record record) {
+        LOG.log(Level.INFO, "Adding record " + record);
+        records.add(record);
+        LOG.log(Level.INFO, "Push records");
+        dataClient.push(records);
+    }
+    
+    public void removeRecord(Record record) {
+        LOG.log(Level.INFO, "Removing record " + record);
+        records.remove(record);
+        dataClient.push(records);
+    }
+}
diff --git a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferDBBase.java b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferDBBase.java
deleted file mode 100644
index 597e860f30..0000000000
--- a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferDBBase.java
+++ /dev/null
@@ -1,283 +0,0 @@
-/**
- * Copyright 2015-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *  http://aws.amazon.com/apache2.0
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
-package com.amazonaws.mobileconnectors.s3.transferutility;
-
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.UriMatcher;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteQueryBuilder;
-import android.net.Uri;
-import android.text.TextUtils;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-/**
- * Provides methods to access database through which applications can interact
- * with transfer tasks.
- */
-class TransferDBBase {
-    private static final Log LOGGER = LogFactory.getLog(TransferDBBase.class);
-
-    private static final int TRANSFERS = 10;
-    private static final int TRANSFER_ID = 20;
-    private static final int TRANSFER_PART = 30;
-    private static final int TRANSFER_STATE = 40;
-    private static final String BASE_PATH = "transfers";
-    private final Context context;
-    private final Uri contentUri;
-    private final UriMatcher uriMatcher;
-    private final TransferDatabaseHelper databaseHelper;
-    private SQLiteDatabase database;
-
-    /**
-     * Constructs TransferdatabaseBase with the given Context.
-     *
-     * @param context A Context instance.
-     */
-    public TransferDBBase(Context context) {
-        this.context = context;
-        final String mAuthority = context.getApplicationContext().getPackageName();
-        databaseHelper = new TransferDatabaseHelper(this.context);
-        database = databaseHelper.getWritableDatabase();
-        contentUri = Uri.parse("content://" + mAuthority + "/" + BASE_PATH);
-        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
-
-        /*
-         * The Uri of TRANSFERS is for all records in the table.
-         */
-        uriMatcher.addURI(mAuthority, BASE_PATH, TRANSFERS);
-
-        /*
-         * The Uri of TRANSFER_ID is for a single transfer record.
-         */
-        uriMatcher.addURI(mAuthority, BASE_PATH + "/#", TRANSFER_ID);
-
-        /*
-         * The Uri of TRANSFER_PART is for part records of a multipart upload.
-         */
-        uriMatcher.addURI(mAuthority, BASE_PATH + "/part/#", TRANSFER_PART);
-
-        /*
-         * The Uri of TRANSFER_STATE is for records with a specific state.
-         */
-        uriMatcher.addURI(mAuthority, BASE_PATH + "/state/*", TRANSFER_STATE);
-    }
-
-
-    /* package private */ TransferDatabaseHelper getDatabaseHelper() {
-        return databaseHelper;
-    }
-
-    /**
-     * Closes the database helper.
-     */
-    public void closeDBHelper() {
-        databaseHelper.close();
-    }
-
-    /**
-     * Gets the Uri for the table.
-     *
-     * @return The Uri for the table.
-     */
-    public Uri getContentUri() {
-        return contentUri;
-    }
-
-    /**
-     * Inserts a record to the table.
-     *
-     * @param uri The Uri of a table.
-     * @param values The values of a record.
-     * @return The Uri of the inserted record.
-     */
-    public Uri insert(Uri uri, ContentValues values) {
-        final int uriType = uriMatcher.match(uri);
-        long id = 0;
-        ensureDatabaseOpen();
-
-        switch (uriType) {
-            case TRANSFERS:
-                id = database.insertOrThrow(TransferTable.TABLE_TRANSFER, null, values);
-                break;
-            default:
-                throw new IllegalArgumentException("Unknown URI: " + uri);
-        }
-        return Uri.parse(BASE_PATH + "/" + id);
-    }
-
-    /**
-     * Query records from the database.
-     *
-     * @param uri A Uri indicating which part of data to query.
-     * @param projection The projection of columns.
-     * @param selection The "where" clause of sql.
-     * @param selectionArgs Strings in the "where" clause.
-     * @param sortOrder Sorting order of the query.
-     * @param type Type of transfers to query.
-     * @return A Cursor pointing to records.
-     */
-    public Cursor query(Uri uri, String[] projection, String selection,
-            String[] selectionArgs,
-            String sortOrder) {
-        final SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();
-        // TODO: currently all methods calling this pass null to projection.
-        // In the future we want to update projection to be more specific for
-        // performance and must handle that here.
-        queryBuilder.setTables(TransferTable.TABLE_TRANSFER);
-        final int uriType = uriMatcher.match(uri);
-        switch (uriType) {
-            case TRANSFERS:
-                queryBuilder.appendWhere(TransferTable.COLUMN_PART_NUM + "=" + 0);
-                break;
-            case TRANSFER_ID:
-                queryBuilder.appendWhere(TransferTable.COLUMN_ID + "=" + uri.getLastPathSegment());
-                break;
-            case TRANSFER_PART:
-                queryBuilder.appendWhere(TransferTable.COLUMN_MAIN_UPLOAD_ID + "="
-                        + uri.getLastPathSegment());
-                break;
-            case TRANSFER_STATE:
-                queryBuilder.appendWhere(TransferTable.COLUMN_STATE + "=");
-                queryBuilder.appendWhereEscapeString(uri.getLastPathSegment());
-                break;
-            default:
-                throw new IllegalArgumentException("Unknown URI: " + uri);
-        }
-        ensureDatabaseOpen();
-        final Cursor cursor = queryBuilder.query(database, projection, selection, selectionArgs,
-                null, null,
-                sortOrder);
-        return cursor;
-    }
-
-    /**
-     * Updates records in the table synchronously.
-     *
-     * @param uri A Uri of the specific record.
-     * @param values The values to update.
-     * @param whereClause The "where" clause of sql.
-     * @param whereArgs Strings in the "where" clause.
-     * @return Number of rows updated.
-     */
-    public synchronized int update(Uri uri, ContentValues values, String whereClause,
-            String[] whereArgs) {
-        final int uriType = uriMatcher.match(uri);
-        int rowsUpdated = 0;
-        ensureDatabaseOpen();
-        switch (uriType) {
-            case TRANSFERS:
-                rowsUpdated = database.update(TransferTable.TABLE_TRANSFER, values, whereClause,
-                        whereArgs);
-                break;
-            case TRANSFER_ID:
-                final String id = uri.getLastPathSegment();
-                if (TextUtils.isEmpty(whereClause)) {
-                    rowsUpdated = database.update(TransferTable.TABLE_TRANSFER, values,
-                            TransferTable.COLUMN_ID + "=" + id, null);
-                } else {
-                    rowsUpdated = database
-                            .update(TransferTable.TABLE_TRANSFER, values, TransferTable.COLUMN_ID
-                                    + "=" + id + " and " + whereClause, whereArgs);
-                }
-                break;
-            default:
-                throw new IllegalArgumentException("Unknown URI: " + uri);
-        }
-        return rowsUpdated;
-    }
-
-    /**
-     * Deletes a record in the table.
-     *
-     * @param uri A Uri of the specific record.
-     * @param selection The "where" clause of sql.
-     * @param selectionArgs Strings in the "where" clause.
-     * @return Number of rows deleted.
-     */
-    public int delete(Uri uri, String selection, String[] selectionArgs) {
-        final int uriType = uriMatcher.match(uri);
-        int rowsDeleted = 0;
-        ensureDatabaseOpen();
-        switch (uriType) {
-            case TRANSFERS:
-                rowsDeleted = database.delete(TransferTable.TABLE_TRANSFER, selection,
-                        selectionArgs);
-                break;
-            case TRANSFER_ID:
-                final String id = uri.getLastPathSegment();
-                if (TextUtils.isEmpty(selection)) {
-                    rowsDeleted = database.delete(TransferTable.TABLE_TRANSFER,
-                            TransferTable.COLUMN_ID + "=" + id, null);
-                } else {
-                    rowsDeleted = database
-                            .delete(TransferTable.TABLE_TRANSFER, TransferTable.COLUMN_ID + "="
-                                    + id + " and " + selection, selectionArgs);
-                }
-                break;
-            default:
-                throw new IllegalArgumentException("Unknown URI: " + uri);
-        }
-        return rowsDeleted;
-    }
-
-    /**
-     * @param uri The Uri of a table.
-     * @param valuesArray A array of values to insert.
-     * @return The mainUploadId of the multipart transfer records
-     */
-    public int bulkInsert(Uri uri, ContentValues[] valuesArray) {
-        final int uriType = uriMatcher.match(uri);
-        int mainUploadId = 0;
-        ensureDatabaseOpen();
-        switch (uriType) {
-            case TRANSFERS:
-                try {
-                    database.beginTransaction();
-                    mainUploadId = (int) database.insertOrThrow(TransferTable.TABLE_TRANSFER, null,
-                            valuesArray[0]);
-                    for (int i = 1; i < valuesArray.length; i++) {
-                        valuesArray[i].put(TransferTable.COLUMN_MAIN_UPLOAD_ID, mainUploadId);
-                        database.insertOrThrow(TransferTable.TABLE_TRANSFER, null, valuesArray[i]);
-                    }
-                    database.setTransactionSuccessful();
-                } catch (final Exception e) {
-                    LOGGER.error("bulkInsert error : ", e);
-                } finally {
-                    database.endTransaction();
-                }
-                break;
-            default:
-                throw new IllegalArgumentException("Unknown URI: " + uri);
-        }
-        return mainUploadId;
-    }
-
-    private void ensureDatabaseOpen() {
-        // close and reopen database.
-        if (!database.isOpen()) {
-            database = databaseHelper.getWritableDatabase();
-        }
-    }
-
-    SQLiteDatabase getDatabase() {
-        return database;
-    }
-
-}
diff --git a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferDBUtil.java b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferDBUtil.java
index b875b0cd32..51f7c2ae61 100644
--- a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferDBUtil.java
+++ b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferDBUtil.java
@@ -15,11 +15,6 @@
 
 package com.amazonaws.mobileconnectors.s3.transferutility;
 
-import android.content.ContentValues;
-import android.content.Context;
-import android.database.Cursor;
-import android.net.Uri;
-
 import com.amazonaws.services.s3.model.CannedAccessControlList;
 import com.amazonaws.services.s3.model.ObjectMetadata;
 import com.amazonaws.services.s3.model.PartETag;
@@ -42,29 +37,12 @@
 
     private static final String QUERY_PLACE_HOLDER_STRING = ",?";
 
-    /**
-     * transferDBBase is a basic helper for accessing the database
-     */
-    private static TransferDBBase transferDBBase;
-
     /**
      * Constructs a TransferDBUtil with the given Context.
      *
      * @param context An instance of Context.
      */
-    public TransferDBUtil(Context context) {
-        if (transferDBBase == null) {
-            transferDBBase = new TransferDBBase(context);
-        }
-    }
-
-    /**
-     * Closes the DB Connection
-     */
-    public void closeDB() {
-        if (transferDBBase != null) {
-            transferDBBase.closeDBHelper();
-        }
+    public TransferDBUtil() {
     }
 
     /**
@@ -79,14 +57,14 @@ public void closeDB() {
      * @param uploadId The multipart upload id of the upload.
      * @param bytesTotal The Total bytes of the file.
      * @param isLastPart Whether this part is the last part of the upload.
-     * @return An Uri of the record inserted.
      */
-    public Uri insertMultipartUploadRecord(String bucket, String key, File file,
+    public int insertMultipartUploadRecord(String bucket, String key, File file,
             long fileOffset, int partNumber, String uploadId, long bytesTotal, int isLastPart) {
-        final ContentValues values = generateContentValuesForMultiPartUpload(bucket, key, file,
+        final Record record = generateRecordForMultiPartUpload(bucket, key, file,
                 fileOffset, partNumber, uploadId, bytesTotal, isLastPart, new ObjectMetadata(),
                 null);
-        return transferDBBase.insert(transferDBBase.getContentUri(), values);
+        Service.getInstance().addRecord(record);
+        return record.getId();
     }
 
     /**
@@ -98,9 +76,8 @@ public Uri insertMultipartUploadRecord(String bucket, String key, File file,
      *            object.
      * @param file The file to upload.
      * @param metadata The S3 Object metadata associated with this object
-     * @return An Uri of the record inserted.
      */
-    public Uri insertSingleTransferRecord(TransferType type, String bucket, String key, File file,
+    public int insertSingleTransferRecord(TransferType type, String bucket, String key, File file,
             ObjectMetadata metadata) {
         return insertSingleTransferRecord(type, bucket, key, file, metadata, null);
     }
@@ -117,11 +94,12 @@ public Uri insertSingleTransferRecord(TransferType type, String bucket, String k
      * @param cannedAcl The canned Acl of this S3 object
      * @return An Uri of the record inserted.
      */
-    public Uri insertSingleTransferRecord(TransferType type, String bucket, String key, File file,
+    public int insertSingleTransferRecord(TransferType type, String bucket, String key, File file,
             ObjectMetadata metadata, CannedAccessControlList cannedAcl) {
-        final ContentValues values = generateContentValuesForSinglePartTransfer(type, bucket, key, file,
+        final Record record = generateRecordForSinglePartTransfer(type, bucket, key, file,
                 metadata, cannedAcl);
-        return transferDBBase.insert(transferDBBase.getContentUri(), values);
+        Service.getInstance().addRecord(record);
+        return record.getId();
     }
 
     /**
@@ -132,21 +110,21 @@ public Uri insertSingleTransferRecord(TransferType type, String bucket, String k
      * @param key The key in the specified bucket by which to store the new
      *            object.
      * @param file The file to upload.
-     * @return An Uri of the record inserted.
      */
-    public Uri insertSingleTransferRecord(TransferType type, String bucket, String key, File file) {
-        return insertSingleTransferRecord(type, bucket, key, file,
-                new ObjectMetadata());
+    public int insertSingleTransferRecord(TransferType type, String bucket, String key, File file) {
+        return insertSingleTransferRecord(type, bucket, key, file, new ObjectMetadata());
     }
 
     /**
      * Inserts multiple records at a time.
      *
-     * @param valuesArray An array of values to insert.
-     * @return The mainUploadId of the multipart records
+     * @param recordsArray An array of values to insert.
      */
-    public int bulkInsertTransferRecords(ContentValues[] valuesArray) {
-        return transferDBBase.bulkInsert(transferDBBase.getContentUri(), valuesArray);
+    public int bulkInsertTransferRecords(Record[] recordsArray) {
+        for (Record record : recordsArray) {
+            Service.getInstance().addRecord(record);
+    }
+        return recordsArray.length;
     }
 
     /**
@@ -154,15 +132,15 @@ public int bulkInsertTransferRecords(ContentValues[] valuesArray) {
      * bytes and total bytes into database.
      *
      * @param transfer a TransferRecord object
-     * @return Number of rows updated.
      */
     public int updateTransferRecord(TransferRecord transfer) {
-        final ContentValues cv = new ContentValues();
-        cv.put(TransferTable.COLUMN_ID, transfer.id);
-        cv.put(TransferTable.COLUMN_STATE, transfer.state.toString());
-        cv.put(TransferTable.COLUMN_BYTES_TOTAL, transfer.bytesTotal);
-        cv.put(TransferTable.COLUMN_BYTES_CURRENT, transfer.bytesCurrent);
-        return transferDBBase.update(getRecordUri(transfer.id), cv, null, null);
+        final Record record = Service.getInstance().getRecord(transfer.getRecord().getId());
+        record.setId(transfer.getRecord().getId());
+        record.setState(transfer.getRecord().getState());
+        record.setBytesTotal(transfer.getRecord().getBytesTotal());
+        record.setBytesCurrent(transfer.getRecord().getBytesCurrent());
+        Service.getInstance().updateRecord(transfer.getRecord(), record);
+        return record.getId();
     }
 
     /**
@@ -170,12 +148,12 @@ public int updateTransferRecord(TransferRecord transfer) {
      *
      * @param id The id of the transfer
      * @param bytes The bytes currently transferred
-     * @return Number of rows updated.
      */
     public int updateBytesTransferred(int id, long bytes) {
-        final ContentValues values = new ContentValues();
-        values.put(TransferTable.COLUMN_BYTES_CURRENT, bytes);
-        return transferDBBase.update(getRecordUri(id), values, null, null);
+        final Record record = getRecord(id);
+        record.setBytesCurrent(bytes);
+        Service.getInstance().updateRecord(getRecord(id), record);
+        return record.getId();
     }
 
     /**
@@ -183,12 +161,12 @@ public int updateBytesTransferred(int id, long bytes) {
      *
      * @param id The id of the transfer
      * @param bytes The total bytes of the download.
-     * @return Number of rows updated.
      */
     public int updateBytesTotalForDownload(int id, long bytes) {
-        final ContentValues values = new ContentValues();
-        values.put(TransferTable.COLUMN_BYTES_TOTAL, bytes);
-        return transferDBBase.update(getRecordUri(id), values, null, null);
+        final Record record = getRecord(id);
+        record.setBytesTotal(bytes);
+        Service.getInstance().updateRecord(getRecord(id), record);
+        return record.getId();
     }
 
     /**
@@ -201,23 +179,12 @@ public int updateBytesTotalForDownload(int id, long bytes) {
      *
      * @param id The id of the transfer.
      * @param state The new state of the transfer.
-     * @return Number of rows updated.
      */
     public int updateState(int id, TransferState state) {
-        final ContentValues values = new ContentValues();
-        values.put(TransferTable.COLUMN_STATE, state.toString());
-        if (TransferState.FAILED.equals(state)) {
-            return transferDBBase.update(getRecordUri(id), values, TransferTable.COLUMN_STATE
-                    + " not in (?,?,?,?,?) ", new String[] {
-                    TransferState.COMPLETED.toString(),
-                    TransferState.PENDING_NETWORK_DISCONNECT.toString(),
-                    TransferState.PAUSED.toString(),
-                    TransferState.CANCELED.toString(),
-                    TransferState.WAITING_FOR_NETWORK.toString()
-                    });
-        } else {
-            return transferDBBase.update(getRecordUri(id), values, null, null);
-        }
+        final Record record = getRecord(id);
+        record.setState(state);
+        Service.getInstance().updateRecord(getRecord(id), record);
+        return record.getId();
     }
 
     /**
@@ -228,13 +195,12 @@ public int updateState(int id, TransferState state) {
      *
      * @param id The id of the transfer.
      * @param state The new state of the transfer.
-     * @return Number of rows updated.
      */
     public int updateStateAndNotifyUpdate(int id, TransferState state) {
-        final ContentValues values = new ContentValues();
-        values.put(TransferTable.COLUMN_STATE, state.toString());
-        return transferDBBase.update(transferDBBase.getContentUri(), values,
-                TransferTable.COLUMN_ID + "=" + id, null);
+        final Record record = getRecord(id);
+        record.setState(state);
+        Service.getInstance().updateRecord(getRecord(id), record);
+        return record.getId();
     }
 
     /**
@@ -242,12 +208,12 @@ public int updateStateAndNotifyUpdate(int id, TransferState state) {
      *
      * @param id The id of the transfer.
      * @param multipartId The multipart id of the transfer.
-     * @return Number of rows updated.
      */
     public int updateMultipartId(int id, String multipartId) {
-        final ContentValues values = new ContentValues();
-        values.put(TransferTable.COLUMN_MULTIPART_ID, multipartId);
-        return transferDBBase.update(getRecordUri(id), values, null, null);
+        final Record record = getRecord(id);
+        record.setMultipartId(multipartId);
+        Service.getInstance().updateRecord(getRecord(id), record);
+        return record.getId();
     }
 
     /**
@@ -255,48 +221,45 @@ public int updateMultipartId(int id, String multipartId) {
      *
      * @param id The id of the transfer.
      * @param etag The Etag of the transfer.
-     * @return Number of rows updated.
      */
     public int updateETag(int id, String etag) {
-        final ContentValues values = new ContentValues();
-        values.put(TransferTable.COLUMN_ETAG, etag);
-        return transferDBBase.update(getRecordUri(id), values, null, null);
+        final Record record = getRecord(id);
+        record.seteTag(etag);
+        Service.getInstance().updateRecord(getRecord(id), record);
+        return record.getId();
     }
 
     /**
      * Updates states of all transfer records which are "running" and "waiting"
      * to "network disconnect"
      *
-     * @return Number of rows updated.
      */
-    public int updateNetworkDisconnected() {
-        final ContentValues values = new ContentValues();
-        values.put(TransferTable.COLUMN_STATE,
-                TransferState.PENDING_NETWORK_DISCONNECT.toString());
-        return transferDBBase.update(transferDBBase.getContentUri(), values,
-                TransferTable.COLUMN_STATE
-                        + " in (?,?,?)", new String[] {
-                        TransferState.IN_PROGRESS.toString(),
-                        TransferState.RESUMED_WAITING.toString(),
-                        TransferState.WAITING.toString()
-                        });
+    public void updateNetworkDisconnected() {
+        for (Record record : Service.getInstance().getRecords()) {
+            if (record.getState().equals(TransferState.IN_PROGRESS) || 
+                    record.getState().equals(TransferState.RESUMED_WAITING) || 
+                    record.getState().equals(TransferState.WAITING)) {
+                Record newRecord = record;
+                newRecord.setState(TransferState.PENDING_NETWORK_DISCONNECT);
+                Service.getInstance().updateRecord(record, newRecord);
+            }
+        }
     }
 
     /**
      * Updates states of all transfer records which are "waiting for network" to
      * "waiting to resume"
      *
-     * @return Number of rows updated.
      */
-    public int updateNetworkConnected() {
-        final ContentValues values = new ContentValues();
-        values.put(TransferTable.COLUMN_STATE, TransferState.RESUMED_WAITING.toString());
-        return transferDBBase.update(transferDBBase.getContentUri(), values,
-                TransferTable.COLUMN_STATE
-                        + " in (?,?)", new String[] {
-                        TransferState.PENDING_NETWORK_DISCONNECT.toString(),
-                        TransferState.WAITING_FOR_NETWORK.toString()
-                        });
+    public void updateNetworkConnected() {
+        for (Record record : Service.getInstance().getRecords()) {
+            if (record.getState().equals(TransferState.PENDING_NETWORK_DISCONNECT) || 
+                    record.getState().equals(TransferState.WAITING_FOR_NETWORK)) {
+                Record newRecord = record;
+                newRecord.setState(TransferState.RESUMED_WAITING);
+                Service.getInstance().updateRecord(record, newRecord);
+            }
+        }
     }
 
     /**
@@ -305,175 +268,20 @@ public int updateNetworkConnected() {
      *
      * @return Number of rows updated.
      */
-    public int setAllRunningRecordsToPausedBeforeShutdownService() {
-        final ContentValues values = new ContentValues();
-        values.put(TransferTable.COLUMN_STATE, TransferState.PAUSED.toString());
-        return transferDBBase.update(
-                transferDBBase.getContentUri(),
-                values,
-                TransferTable.COLUMN_STATE
-                        + " in (?,?,?,?)",
-                new String[] {
-                        TransferState.IN_PROGRESS.toString(),
-                        TransferState.PENDING_PAUSE.toString(),
-                        TransferState.RESUMED_WAITING.toString(),
-                        TransferState.WAITING.toString()
-                    });
-    }
-
-    /**
-     * Updates states of all transfer records with the specified type which are
-     * "running" and "waiting" to "pending pause".
-     *
-     * @param TransferType The type of transfers to query for.
-     * @return Number of rows updated.
-     */
-    public int pauseAllWithType(TransferType type) {
-        final ContentValues values = new ContentValues();
-        values.put(TransferTable.COLUMN_STATE, TransferState.PENDING_PAUSE.toString());
-        String selection = null;
-        String[] selectionArgs = null;
-        if (type == TransferType.ANY) {
-            selection = TransferTable.COLUMN_STATE + " in (?,?,?)";
-            selectionArgs = new String[] {
-                    TransferState.IN_PROGRESS.toString(),
-                    TransferState.RESUMED_WAITING.toString(),
-                    TransferState.WAITING.toString()
-            };
-        } else {
-            selection = TransferTable.COLUMN_STATE + " in (?,?,?) and " + TransferTable.COLUMN_TYPE
-                    + "=?";
-            selectionArgs = new String[] {
-                    TransferState.IN_PROGRESS.toString(),
-                    TransferState.RESUMED_WAITING.toString(),
-                    TransferState.WAITING.toString(),
-                    type.toString()
-            };
-        }
-        return transferDBBase.update(transferDBBase.getContentUri(), values, selection,
-                selectionArgs);
-    }
-
-    /**
-     * Updates states of all transfer records with the specified which are
-     * "running" and "waiting" to "pending cancel"
-     *
-     * @param TransferType The type of transfers to cancel
-     * @return Number of rows updated.
-     */
-    public int cancelAllWithType(TransferType type) {
-        final ContentValues values = new ContentValues();
-        values.put(TransferTable.COLUMN_STATE, TransferState.PENDING_CANCEL.toString());
-        String selection = null;
-        String[] selectionArgs = null;
-        if (type == TransferType.ANY) {
-            selection = TransferTable.COLUMN_STATE + " in (?,?,?,?,?)";
-            selectionArgs = new String[] {
-                    TransferState.IN_PROGRESS.toString(),
-                    TransferState.RESUMED_WAITING.toString(),
-                    TransferState.WAITING.toString(),
-                    TransferState.PAUSED.toString(),
-                    TransferState.WAITING_FOR_NETWORK.toString()
-            };
-        } else {
-            selection = TransferTable.COLUMN_STATE + " in (?,?,?,?,?) and "
-                    + TransferTable.COLUMN_TYPE + "=?";
-            selectionArgs = new String[] {
-                    TransferState.IN_PROGRESS.toString(),
-                    TransferState.RESUMED_WAITING.toString(),
-                    TransferState.WAITING.toString(),
-                    TransferState.PAUSED.toString(),
-                    TransferState.WAITING_FOR_NETWORK.toString(),
-                    type.toString()
-            };
-        }
-        return transferDBBase.update(transferDBBase.getContentUri(), values, selection,
-                selectionArgs);
-    }
-
-    /**
-     * Queries all the records which have the given type.
-     *
-     * @param TransferType The type of transfers to query for.
-     * @return A Cursor pointing to records in the database with the given type.
-     */
-    public Cursor queryAllTransfersWithType(TransferType type) {
-        if (type == TransferType.ANY) {
-            return transferDBBase.query(transferDBBase.getContentUri(), null, null, null, null);
-        } else {
-            return transferDBBase.query(transferDBBase.getContentUri(), null,
-                    TransferTable.COLUMN_TYPE + "=?", new String[] {
-                        type.toString()
-                    }, null);
-        }
-    }
-
-    /**
-     * Queries all the records which have the given type and state.
-     *
-     * @param TransferType The type of transfers to query for.
-     * @param TransferState The state of the transfer.
-     * @return A Cursor pointing to records in the database with the given type
-     *         and state.
-     */
-    public Cursor queryTransfersWithTypeAndState(TransferType type, TransferState state) {
-        if (type == TransferType.ANY) {
-            return transferDBBase.query(getStateUri(state), null, null,
-                    null, null);
-        } else {
-            return transferDBBase.query(getStateUri(state), null, TransferTable.COLUMN_TYPE + "=?",
-                    new String[] {
-                        type.toString()
-                    }, null);
-        }
-    }
-
-    /**
-     * Queries all the records which have the given type and states.
-     *
-     * @param type   The type of Transfer
-     * @param states The list of Transfer States whose Transfer Records are required.
-     * @return A Cursor pointing to records in the database in any of the given states.
-     */
-    public Cursor queryTransfersWithTypeAndStates(TransferType type,
-                                                  TransferState[] states) {
-        final String selection;
-        final String[] selectionArgs;
-        int index = 0;
-        int numStates = states.length;
-        String placeholderString = createPlaceholders(numStates);
-
-        if (type == TransferType.ANY) {
-            selection = TransferTable.COLUMN_STATE +
-                    " in (" + placeholderString + ")";
-            selectionArgs = new String[numStates];
-            for (index = 0; index < numStates; index++) {
-                selectionArgs[index] = states[index].toString();
-            }
-        } else {
-            selection = TransferTable.COLUMN_STATE
-                    + " in (" + placeholderString + ") and "
-                    + TransferTable.COLUMN_TYPE + "=?";
-            selectionArgs = new String[numStates + 1];
-            for (index = 0; index < numStates; index++) {
-                selectionArgs[index] = states[index].toString();
+    public void setAllRunningRecordsToPausedBeforeShutdownService() {
+        for (Record record : Service.getInstance().getRecords()) {
+            if (record.getState().equals(TransferState.IN_PROGRESS) || 
+                    record.getState().equals(TransferState.PENDING_PAUSE) || 
+                    record.getState().equals(TransferState.RESUMED_WAITING) || 
+                    record.getState().equals(TransferState.WAITING)) {
+                Record newRecord = record;
+                newRecord.setState(TransferState.PAUSED);
+                Service.getInstance().updateRecord(record, newRecord);
             }
-            selectionArgs[index] = type.toString();
         }
-
-        return transferDBBase.query(transferDBBase.getContentUri(), null, selection,
-                selectionArgs, null);
     }
 
     /**
-     * Queries the transfer record specified by id.
-     *
-     * @param id The id of the transfer.
-     * @return The result Cursor of the query.
-     */
-    public Cursor queryTransferById(int id) {
-        return transferDBBase.query(getRecordUri(id), null, null, null, null);
-    }
 
     /**
      * Queries the transfer record specified by main upload id.
@@ -482,20 +290,11 @@ public Cursor queryTransferById(int id) {
      * @return The bytes already uploaded for this multipart upload task
      */
     public long queryBytesTransferredByMainUploadId(int mainUploadId) {
-        Cursor c = null;
         long bytesTotal = 0;
-        try {
-            c = transferDBBase.query(getPartUri(mainUploadId), null, null, null, null);
-            while (c.moveToNext()) {
-                final String state = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_STATE));
-                if (TransferState.PART_COMPLETED.equals(TransferState.getState(state))) {
-                    bytesTotal += c.getLong(c
-                            .getColumnIndexOrThrow(TransferTable.COLUMN_BYTES_TOTAL));
-                }
-            }
-        } finally {
-            if (c != null) {
-                c.close();
+        for (Record record : getPartRecord(mainUploadId)) {
+            final TransferState state = record.getState();
+            if (TransferState.PART_COMPLETED.equals(TransferState.getState(state.name()))) {
+                bytesTotal += record.getBytesTotal();
             }
         }
         return bytesTotal;
@@ -505,10 +304,10 @@ public long queryBytesTransferredByMainUploadId(int mainUploadId) {
      * Deletes the record with the given id.
      *
      * @param id The id of the transfer to be deleted.
-     * @return Number of rows deleted.
      */
     public int deleteTransferRecords(int id) {
-        return transferDBBase.delete(getRecordUri(id), null, null);
+        Service.getInstance().removeRecord(getRecord(id));
+        return id;
     }
 
     /**
@@ -522,21 +321,11 @@ public int deleteTransferRecords(int id) {
      */
     public List<PartETag> queryPartETagsOfUpload(int mainUploadId) {
         final List<PartETag> partETags = new ArrayList<PartETag>();
-        Cursor c = null;
-        int partNum = 0;
-        String eTag = null;
-        try {
-            c = transferDBBase.query(getPartUri(mainUploadId), null, null, null, null);
-            while (c.moveToNext()) {
-                partNum = c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_PART_NUM));
-                eTag = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_ETAG));
+        for (Record record : getPartRecord(mainUploadId)) {
+            int partNum = record.getPartNumber();
+            String eTag = record.geteTag();
                 partETags.add(new PartETag(partNum, eTag));
             }
-        } finally {
-            if (c != null) {
-                c.close();
-            }
-        }
         return partETags;
     }
 
@@ -552,40 +341,22 @@ public int deleteTransferRecords(int id) {
     public List<UploadPartRequest> getNonCompletedPartRequestsFromDB(int mainUploadId,
             String multipartId) {
         final ArrayList<UploadPartRequest> list = new ArrayList<UploadPartRequest>();
-        Cursor c = null;
-        try {
-            c = transferDBBase.query(getPartUri(mainUploadId), null, null, null, null);
-            while (c.moveToNext()) {
-                if (TransferState.PART_COMPLETED.equals(TransferState.getState(c.getString(c
-                        .getColumnIndexOrThrow(TransferTable.COLUMN_STATE))))) {
-                    continue;
-                }
+        for (Record record : getPartRecord(mainUploadId)) {
+            final TransferState state = record.getState();
+            if (! TransferState.PART_COMPLETED.equals(TransferState.getState(state.name()))) {
                 final UploadPartRequest putPartRequest = new UploadPartRequest()
-                        .withId(c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_ID)))
-                        .withMainUploadId(
-                                c.getInt(c
-                                        .getColumnIndexOrThrow(TransferTable.COLUMN_MAIN_UPLOAD_ID)))
-                        .withBucketName(
-                                c.getString(c
-                                        .getColumnIndexOrThrow(TransferTable.COLUMN_BUCKET_NAME)))
-                        .withKey(c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_KEY)))
+                        .withId(record.getId())
+                        .withMainUploadId(record.getMainUploadId())
+                        .withBucketName(record.getBucketName())
+                        .withKey(record.getKey())
                         .withUploadId(multipartId)
-                        .withFile(new File(
-                                c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_FILE))))
-                        .withFileOffset(
-                                c.getLong(c.getColumnIndexOrThrow(TransferTable.COLUMN_FILE_OFFSET)))
-                        .withPartNumber(
-                                c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_PART_NUM)))
-                        .withPartSize(
-                                c.getLong(c.getColumnIndexOrThrow(TransferTable.COLUMN_BYTES_TOTAL)))
-                        .withLastPart(1 == c.getInt(c
-                                .getColumnIndexOrThrow(TransferTable.COLUMN_IS_LAST_PART)));
+                        .withFile(new File(record.getFile()))
+                        .withFileOffset(record.getFileOffset())
+                        .withPartNumber(record.getPartNumber())
+                        .withPartSize(record.getBytesTotal())
+                        .withLastPart(1 == record.getIsLastPart());
                 list.add(putPartRequest);
             }
-        } finally {
-            if (c != null) {
-                c.close();
-            }
         }
         return list;
     }
@@ -599,23 +370,12 @@ public int deleteTransferRecords(int id) {
      */
     public boolean checkWaitingForNetworkPartRequestsFromDB(int mainUploadId) {
         boolean isNetworkInterrupted = false;
-        Cursor c = null;
-
-        try {
-            c = transferDBBase.query(getPartUri(mainUploadId), null, TransferTable.COLUMN_STATE + "=?",
-                    new String[] {
-                            TransferState.WAITING_FOR_NETWORK.toString()
-                    }, null);
-            while (c.moveToNext()) {
+        for (Record record : getPartRecord(mainUploadId)) {
+            if (record.getState().equals(TransferState.WAITING_FOR_NETWORK)) {
                 isNetworkInterrupted = true;
                 break;
             }
-        } finally {
-            if (c != null) {
-                c.close();
             }
-        }
-
         return isNetworkInterrupted;
     }
 
@@ -656,31 +416,31 @@ private String createPlaceholders(int numPlaceHolders) {
      * @param isLastPart Whether this part is the last part of the upload.
      * @param metadata The S3 ObjectMetadata to send along with the object
      * @param cannedAcl The canned ACL associated with the object
-     * @return The ContentValues object generated.
+     * @return The Record object generated.
      */
-    public ContentValues generateContentValuesForMultiPartUpload(String bucket,
+    public Record generateRecordForMultiPartUpload(String bucket,
             String key, File file, long fileOffset, int partNumber, String uploadId,
             long bytesTotal, int isLastPart, ObjectMetadata metadata,
             CannedAccessControlList cannedAcl) {
-        final ContentValues values = new ContentValues();
-        values.put(TransferTable.COLUMN_TYPE, TransferType.UPLOAD.toString());
-        values.put(TransferTable.COLUMN_STATE, TransferState.WAITING.toString());
-        values.put(TransferTable.COLUMN_BUCKET_NAME, bucket);
-        values.put(TransferTable.COLUMN_KEY, key);
-        values.put(TransferTable.COLUMN_FILE, file.getAbsolutePath());
-        values.put(TransferTable.COLUMN_BYTES_CURRENT, 0L);
-        values.put(TransferTable.COLUMN_BYTES_TOTAL, bytesTotal);
-        values.put(TransferTable.COLUMN_IS_MULTIPART, 1);
-        values.put(TransferTable.COLUMN_PART_NUM, partNumber);
-        values.put(TransferTable.COLUMN_FILE_OFFSET, fileOffset);
-        values.put(TransferTable.COLUMN_MULTIPART_ID, uploadId);
-        values.put(TransferTable.COLUMN_IS_LAST_PART, isLastPart);
-        values.put(TransferTable.COLUMN_IS_ENCRYPTED, 0);
-        values.putAll(generateContentValuesForObjectMetadata(metadata));
+        final Record record = new Record();
+        record.setType(TransferType.UPLOAD);
+        record.setState(TransferState.WAITING);
+        record.setBucketName(bucket);
+        record.setKey(key);
+        record.setFile(file.getAbsolutePath());
+        record.setBytesCurrent(0L);
+        record.setBytesTotal(bytesTotal);
+        record.setIsMultipart(1);
+        record.setPartNumber(partNumber);
+        record.setFileOffset(fileOffset);
+        record.setMultipartId(uploadId);
+        record.setIsLastPart(isLastPart);
+        record.setIsEncrypted(0);
+        setRecordForObjectMetadata(record, metadata);
         if (cannedAcl != null) {
-            values.put(TransferTable.COLUMN_CANNED_ACL, cannedAcl.toString());
+            record.setCannedAcl(cannedAcl.toString());
         }
-        return values;
+        return record;
     }
 
     /**
@@ -689,27 +449,20 @@ public ContentValues generateContentValuesForMultiPartUpload(String bucket,
      *
      * @param metadata The ObjectMetadata the content values should be filled
      *            with
-     * @return the ContentValues
      */
-    private ContentValues generateContentValuesForObjectMetadata(ObjectMetadata metadata) {
-        final ContentValues values = new ContentValues();
-        values.put(TransferTable.COLUMN_USER_METADATA,
-                JsonUtils.mapToString(metadata.getUserMetadata()));
-        values.put(TransferTable.COLUMN_HEADER_CONTENT_TYPE, metadata.getContentType());
-        values.put(TransferTable.COLUMN_HEADER_CONTENT_ENCODING, metadata.getContentEncoding());
-        values.put(TransferTable.COLUMN_HEADER_CACHE_CONTROL, metadata.getCacheControl());
-        values.put(TransferTable.COLUMN_CONTENT_MD5, metadata.getContentMD5());
-        values.put(TransferTable.COLUMN_HEADER_CONTENT_DISPOSITION,
-                metadata.getContentDisposition());
-        values.put(TransferTable.COLUMN_SSE_ALGORITHM, metadata.getSSEAlgorithm());
-        values.put(TransferTable.COLUMN_SSE_KMS_KEY, metadata.getSSEAwsKmsKeyId());
-        values.put(TransferTable.COLUMN_EXPIRATION_TIME_RULE_ID, metadata.getExpirationTimeRuleId());
+    private void setRecordForObjectMetadata(Record values, ObjectMetadata metadata) {
+        values.setUserMetadata(metadata.getUserMetadata());
+        values.setHeaderContentType(metadata.getContentType());
+        values.setHeaderContentEncoding(metadata.getContentEncoding());
+        values.setHeaderCacheControl(metadata.getCacheControl());
+        values.setMd5(metadata.getContentMD5());
+        values.setHeaderContentDisposition(metadata.getContentDisposition());
+        values.setSseAlgorithm(metadata.getSSEAlgorithm());
+        values.setSseKMSKey(metadata.getSSEAwsKmsKeyId());
+        values.setExpirationTimeRuleId(metadata.getExpirationTimeRuleId());
         if (metadata.getHttpExpiresDate() != null) {
-            values.put(TransferTable.COLUMN_HTTP_EXPIRES_DATE,
-                    String.valueOf(metadata.getHttpExpiresDate().getTime()));
+            values.setHttpExpires(String.valueOf(metadata.getHttpExpiresDate().getTime()));
         }
-
-        return values;
     }
 
     /**
@@ -723,48 +476,39 @@ private ContentValues generateContentValuesForObjectMetadata(ObjectMetadata meta
      * @param file The file to upload.
      * @param metadata The S3 ObjectMetadata to send along with the object
      * @param cannedAcl The canned ACL associated with the object
-     * @return The ContentValues object generated.
+     * @return The Record object generated.
      */
-    private ContentValues generateContentValuesForSinglePartTransfer(TransferType type,
+    private Record generateRecordForSinglePartTransfer(TransferType type,
             String bucket, String key, File file, ObjectMetadata metadata,
             CannedAccessControlList cannedAcl) {
-        final ContentValues values = new ContentValues();
-        values.put(TransferTable.COLUMN_TYPE, type.toString());
-        values.put(TransferTable.COLUMN_STATE, TransferState.WAITING.toString());
-        values.put(TransferTable.COLUMN_BUCKET_NAME, bucket);
-        values.put(TransferTable.COLUMN_KEY, key);
-        values.put(TransferTable.COLUMN_FILE, file.getAbsolutePath());
-        values.put(TransferTable.COLUMN_BYTES_CURRENT, 0L);
+        final Record record = new Record();
+        record.setType(type);
+        record.setState(TransferState.WAITING);
+        record.setBucketName(bucket);
+        record.setKey(key);
+        record.setFile(file.getAbsolutePath());
+        record.setBytesCurrent(0L);
         if (type.equals(TransferType.UPLOAD)) {
-            values.put(TransferTable.COLUMN_BYTES_TOTAL, file == null ? 0L : file.length());
+            record.setBytesTotal(file == null ? 0L : file.length());
         }
-        values.put(TransferTable.COLUMN_IS_MULTIPART, 0);
-        values.put(TransferTable.COLUMN_PART_NUM, 0);
-        values.put(TransferTable.COLUMN_IS_ENCRYPTED, 0);
-        values.putAll(generateContentValuesForObjectMetadata(metadata));
+        record.setIsMultipart(0);
+        record.setPartNumber(0);
+        record.setIsEncrypted(0);
+        setRecordForObjectMetadata(record, metadata);
         if (cannedAcl != null) {
-            values.put(TransferTable.COLUMN_CANNED_ACL, cannedAcl.toString());
+            record.setCannedAcl(cannedAcl.toString());
         }
-        return values;
-    }
-
-    /**
-     * Gets the Uri of the transfer record table.
-     *
-     * @return The Uri of a table.
-     */
-    public Uri getContentUri() {
-        return transferDBBase.getContentUri();
+        return record;
     }
 
     /**
-     * Gets the Uri of a record.
+     * Gets the record.
      *
      * @param id The id of the transfer.
-     * @return The Uri of the record specified by the id.
+     * @return The record specified by the id.
      */
-    public Uri getRecordUri(int id) {
-        return Uri.parse(transferDBBase.getContentUri() + "/" + id);
+    public Record getRecord(int id) {
+        return Service.getInstance().getRecord(id);
     }
 
     /**
@@ -774,19 +518,14 @@ public Uri getRecordUri(int id) {
      * @return The Uri of the part upload records that have the given
      *         mainUploadId value.
      */
-    public Uri getPartUri(int mainUploadId) {
-        return Uri.parse(transferDBBase.getContentUri() + "/part/" + mainUploadId);
-    }
-
-    /**
-     * Gets the Uri of the records that have the given state.
-     *
-     * @param state The state of transfers
-     * @return The Uri that is used to query transfer records with the given
-     *         state.
-     */
-    public Uri getStateUri(TransferState state) {
-        return Uri.parse(transferDBBase.getContentUri() + "/state/" + state.toString());
+    public List<Record> getPartRecord(int mainUploadId) {
+        List<Record> records = new ArrayList<Record>();
+        for (Record r : Service.getInstance().getRecords()) {
+            if (r.getMultipartId().equals(mainUploadId)) {
+                records.add(r);
+            }
+        }
+        return records;
     }
 
     /**
@@ -796,24 +535,10 @@ public Uri getStateUri(TransferState state) {
      * @return a TransferRecord if exists, null otherwise
      */
     TransferRecord getTransferById(int id) {
-        TransferRecord transfer = null;
-        Cursor c = null;
-        try {
-            c = queryTransferById(id);
-            if (c.moveToFirst()) {
-                transfer = new TransferRecord(id);
-                transfer.updateFromDB(c);
-            }
-        } finally {
-            if (c != null) {
-                c.close();
-            }
-        }
+        TransferRecord transfer = new TransferRecord();
+        transfer.updateFromDB(getRecord(id));
         return transfer;
     }
 
-    static TransferDBBase getTransferDBBase() {
-        return transferDBBase;
-    }
 }
 
diff --git a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferDatabaseHelper.java b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferDatabaseHelper.java
deleted file mode 100644
index a9725a9213..0000000000
--- a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferDatabaseHelper.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/**
- * Copyright 2015-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *  http://aws.amazon.com/apache2.0
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
-package com.amazonaws.mobileconnectors.s3.transferutility;
-
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-
-class TransferDatabaseHelper extends SQLiteOpenHelper {
-
-    private static final String DATABASE_NAME = "awss3transfertable.db";
-    private static final int DATABASE_VERSION = 4;
-
-    private int version;
-
-    public TransferDatabaseHelper(Context context) {
-        this(context, DATABASE_VERSION);
-    }
-
-    public TransferDatabaseHelper(Context context, int version) {
-        super(context, DATABASE_NAME, null, version);
-        this.version = version;
-    }
-
-    @Override
-    public void onCreate(SQLiteDatabase database) {
-        TransferTable.onCreate(database, version);
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase database, int oldVersion, int newVersion) {
-        TransferTable.onUpgrade(database, oldVersion, newVersion);
-    }
-
-}
diff --git a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferObserver.java b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferObserver.java
index 4421282cda..64a006ceb6 100644
--- a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferObserver.java
+++ b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferObserver.java
@@ -15,8 +15,6 @@
 
 package com.amazonaws.mobileconnectors.s3.transferutility;
 
-import android.database.Cursor;
-
 import java.io.File;
 
 /**
@@ -49,7 +47,6 @@
 public class TransferObserver {
 
     private final int id;
-    private final TransferDBUtil dbUtil;
 
     private String bucket;
     private String key;
@@ -71,9 +68,8 @@
      * @param key key of the S3 object
      * @param file a file associated with this transfer
      */
-    TransferObserver(int id, TransferDBUtil dbUtil, String bucket, String key, File file) {
+    TransferObserver(int id, String bucket, String key, File file) {
         this.id = id;
-        this.dbUtil = dbUtil;
         this.bucket = bucket;
         this.key = key;
         filePath = file.getAbsolutePath();
@@ -92,9 +88,9 @@
      * @param file a file associated with this transfer
      * @param listener the listener for the transfer
      */
-    TransferObserver(int id, TransferDBUtil dbUtil, String bucket, String key, File file,
+    TransferObserver(int id, String bucket, String key, File file,
             TransferListener listener) {
-        this(id, dbUtil, bucket, key, file);
+        this(id, bucket, key, file);
         this.setTransferListener(listener);
     }
 
@@ -105,9 +101,8 @@
      * @param id The transfer id of the transfer to be observed.
      * @param dbUtil an instance of database utility
      */
-    TransferObserver(int id, TransferDBUtil dbUtil) {
+    TransferObserver(int id) {
         this.id = id;
-        this.dbUtil = dbUtil;
     }
 
     /**
@@ -115,15 +110,10 @@
      * TransferListener is set, then there's no need to call this method.
      */
     public void refresh() {
-        Cursor c = null;
-        try {
-            c = dbUtil.queryTransferById(id);
-            if (c.moveToFirst()) {
-                updateFromDB(c);
-            }
-        } finally {
-            if (c != null) {
-                c.close();
+        for (Record record : Service.getInstance().getRecords()) {
+            if (record.getId() == id) {
+                updateFromDB(record);
+                break;
             }
         }
     }
@@ -131,17 +121,15 @@ public void refresh() {
     /**
      * Update transfer state from the given cursor.
      *
-     * @param c a cursor to read the state of the transfer from
+     * @param r a record to read the state of the transfer from
      */
-    protected void updateFromDB(Cursor c) {
-        bucket = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_BUCKET_NAME));
-        key = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_KEY));
-        bytesTotal = c.getLong(c.getColumnIndexOrThrow(TransferTable.COLUMN_BYTES_TOTAL));
-        bytesTransferred = c.getLong(c
-                .getColumnIndexOrThrow(TransferTable.COLUMN_BYTES_CURRENT));
-        transferState = TransferState.getState(c.getString(c
-                .getColumnIndexOrThrow(TransferTable.COLUMN_STATE)));
-        filePath = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_FILE));
+    protected void updateFromDB(Record r) {
+        bucket = r.getBucketName();
+        key = r.getKey();
+        bytesTotal = r.getBytesTotal();
+        bytesTransferred = r.getBytesCurrent();
+        transferState = r.getState();
+        filePath = r.getFile();
     }
 
     /**
diff --git a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferRecord.java b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferRecord.java
index b2534a0c46..cec3710bbb 100644
--- a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferRecord.java
+++ b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferRecord.java
@@ -15,23 +15,20 @@
 
 package com.amazonaws.mobileconnectors.s3.transferutility;
 
-import android.database.Cursor;
-
 import com.amazonaws.AmazonClientException;
 import com.amazonaws.mobileconnectors.s3.transferutility.TransferService.NetworkInfoReceiver;
 import com.amazonaws.services.s3.AmazonS3;
 import com.amazonaws.services.s3.model.AbortMultipartUploadRequest;
-import com.amazonaws.util.json.JsonUtils;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 import java.io.File;
-import java.util.Map;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
+import java.util.logging.Level;
 
 /**
  * TransferRecord is used to store all the information of a transfer and
@@ -41,45 +38,7 @@
 class TransferRecord {
     private static final Log LOGGER = LogFactory.getLog(TransferRecord.class);
 
-    public int id;
-    public int mainUploadId;
-    public int isRequesterPays;
-    public int isMultipart;
-    public int isLastPart;
-    public int isEncrypted;
-    public int partNumber;
-    public long bytesTotal;
-    public long bytesCurrent;
-    public long speed;
-    public long rangeStart;
-    public long rangeLast;
-    public long fileOffset;
-    public TransferType type;
-    public TransferState state;
-    public String bucketName;
-    public String key;
-    public String versionId;
-    public String file;
-    public String multipartId;
-    public String eTag;
-    public String headerContentType;
-    public String headerContentLanguage;
-    public String headerContentDisposition;
-    public String headerContentEncoding;
-    public String headerCacheControl;
-    public String headerExpire;
-
-    /**
-     * The following were added in 2.2.6 to support object metdata
-     */
-    public Map<String, String> userMetadata;
-    public String expirationTimeRuleId;
-    // This is a long representing a date, however it may be null
-    public String httpExpires;
-    public String sseAlgorithm;
-    public String sseKMSKey;
-    public String md5;
-    public String cannedAcl;
+    private Record record;
 
     private Future<?> submittedTask;
 
@@ -89,64 +48,16 @@
      *
      * @param id The id of a transfer.
      */
-    public TransferRecord(int id) {
-        this.id = id;
+    public TransferRecord() {
     }
 
     /**
      * Updates all the fields from database using the given Cursor.
      *
-     * @param c A Cursor pointing to a transfer record.
+     * @param record A Record pointing to a transfer record.
      */
-    public void updateFromDB(Cursor c) {
-        this.id = c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_ID));
-        this.mainUploadId = c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_MAIN_UPLOAD_ID));
-        this.type = TransferType.getType(c.getString(c
-                .getColumnIndexOrThrow(TransferTable.COLUMN_TYPE)));
-        this.state = TransferState.getState(c.getString(c
-                .getColumnIndexOrThrow(TransferTable.COLUMN_STATE)));
-        this.bucketName = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_BUCKET_NAME));
-        this.key = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_KEY));
-        this.versionId = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_VERSION_ID));
-        this.bytesTotal = c.getLong(c.getColumnIndexOrThrow(TransferTable.COLUMN_BYTES_TOTAL));
-        this.bytesCurrent = c.getLong(c.getColumnIndexOrThrow(TransferTable.COLUMN_BYTES_CURRENT));
-        this.speed = c.getLong(c.getColumnIndexOrThrow(TransferTable.COLUMN_SPEED));
-        this.isRequesterPays = c.getInt(c
-                .getColumnIndexOrThrow(TransferTable.COLUMN_IS_REQUESTER_PAYS));
-        this.isMultipart = c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_IS_MULTIPART));
-        this.isLastPart = c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_IS_LAST_PART));
-        this.isEncrypted = c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_IS_ENCRYPTED));
-        this.partNumber = c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_PART_NUM));
-        this.eTag = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_ETAG));
-        this.file = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_FILE));
-        this.multipartId = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_MULTIPART_ID));
-        this.rangeStart = c
-                .getLong(c.getColumnIndexOrThrow(TransferTable.COLUMN_DATA_RANGE_START));
-        this.rangeLast = c.getLong(c.getColumnIndexOrThrow(TransferTable.COLUMN_DATA_RANGE_LAST));
-        this.fileOffset = c.getLong(c.getColumnIndexOrThrow(TransferTable.COLUMN_FILE_OFFSET));
-        this.headerContentType = c.getString(c
-                .getColumnIndexOrThrow(TransferTable.COLUMN_HEADER_CONTENT_TYPE));
-        this.headerContentLanguage = c.getString(c
-                .getColumnIndexOrThrow(TransferTable.COLUMN_HEADER_CONTENT_LANGUAGE));
-        this.headerContentDisposition = c.getString(c
-                .getColumnIndexOrThrow(TransferTable.COLUMN_HEADER_CONTENT_DISPOSITION));
-        this.headerContentEncoding = c.getString(c
-                .getColumnIndexOrThrow(TransferTable.COLUMN_HEADER_CONTENT_ENCODING));
-        this.headerCacheControl = c.getString(c
-                .getColumnIndexOrThrow(TransferTable.COLUMN_HEADER_CACHE_CONTROL));
-        this.headerExpire = c.getString(c
-                .getColumnIndexOrThrow(TransferTable.COLUMN_HEADER_EXPIRE));
-        this.userMetadata = JsonUtils.jsonToMap(c.getString(c
-                .getColumnIndexOrThrow(TransferTable.COLUMN_USER_METADATA)));
-        this.expirationTimeRuleId = c.getString(c
-                .getColumnIndexOrThrow(TransferTable.COLUMN_EXPIRATION_TIME_RULE_ID));
-        this.httpExpires = c.getString(c
-                .getColumnIndexOrThrow(TransferTable.COLUMN_HTTP_EXPIRES_DATE));
-        this.sseAlgorithm = c
-                .getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_SSE_ALGORITHM));
-        this.sseKMSKey = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_SSE_KMS_KEY));
-        this.md5 = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_CONTENT_MD5));
-        this.cannedAcl = c.getString(c.getColumnIndexOrThrow(TransferTable.COLUMN_CANNED_ACL));
+    public void updateFromDB(Record record) {
+        this.record = record;
     }
 
     /**
@@ -162,10 +73,12 @@ public void updateFromDB(Cursor c) {
     public boolean start(AmazonS3 s3, TransferDBUtil dbUtil, TransferStatusUpdater updater,
             NetworkInfoReceiver networkInfo) {
         if (!isRunning() && checkIsReadyToRun()) {
-            if (type.equals(TransferType.DOWNLOAD)) {
+            if (TransferType.DOWNLOAD.equals(record.getType())) {
+                LOGGER.info("Task Download ");
                 submittedTask = TransferThreadPool
                         .submitTask(new DownloadTask(this, s3, updater, networkInfo));
             } else {
+                LOGGER.info("Task Upload ");
                 submittedTask = TransferThreadPool
                         .submitTask(new UploadTask(this, s3, dbUtil, updater, networkInfo));
             }
@@ -183,8 +96,8 @@ public boolean start(AmazonS3 s3, TransferDBUtil dbUtil, TransferStatusUpdater u
      *         otherwise
      */
     public boolean pause(AmazonS3 s3, TransferStatusUpdater updater) {
-        if (!isFinalState(state) && !TransferState.PAUSED.equals(state)) {
-            updater.updateState(id, TransferState.PAUSED);
+        if (!isFinalState(record.getState()) && !TransferState.PAUSED.equals(record.getState())) {
+            updater.updateState(record.getId(), TransferState.PAUSED);
             if (isRunning()) {
                 submittedTask.cancel(true);
             }
@@ -202,28 +115,28 @@ public boolean pause(AmazonS3 s3, TransferStatusUpdater updater) {
      *         false otherwise
      */
     public boolean cancel(final AmazonS3 s3, final TransferStatusUpdater updater) {
-        if (!isFinalState(state)) {
-            updater.updateState(id, TransferState.CANCELED);
+        if (!isFinalState(record.getState())) {
+            updater.updateState(record.getId(), TransferState.CANCELED);
             if (isRunning()) {
                 submittedTask.cancel(true);
             }
             // additional cleanups
-            if (isMultipart == 1) {
+            if (record.getIsMultipart() == 1) {
                 new Thread(new Runnable() {
                     @Override
                     public void run() {
                         try {
-                            s3.abortMultipartUpload(new AbortMultipartUploadRequest(bucketName,
-                                    key, multipartId));
-                            LOGGER.debug("Successfully clean up multipart upload: " + id);
+                            s3.abortMultipartUpload(new AbortMultipartUploadRequest(record.getBucketName(),
+                                    record.getKey(), record.getMultipartId()));
+                            LOGGER.debug("Successfully clean up multipart upload: " + record.getId());
                         } catch (final AmazonClientException e) {
-                            LOGGER.debug("Failed to abort multiplart upload: " + id, e);
+                            LOGGER.debug("Failed to abort multiplart upload: " + record.getId(), e);
                         }
                     }
                 }).start();
-            } else if (TransferType.DOWNLOAD.equals(type)) {
+            } else if (TransferType.DOWNLOAD.equals(record.getType())) {
                 // remove partially download file
-                new File(file).delete();
+                new File(record.getFile()).delete();
             }
             return true;
         }
@@ -265,29 +178,33 @@ private boolean isFinalState(TransferState state) {
     }
 
     private boolean checkIsReadyToRun() {
-        return partNumber == 0 && !TransferState.COMPLETED.equals(state);
+        return record.getPartNumber() == 0 && !TransferState.COMPLETED.equals(record.getState());
     }
 
+    public Record getRecord() {
+        return record;
+    }
+    
     @Override
     public String toString() {
         final StringBuilder sb = new StringBuilder();
         sb.append("[")
-                .append("id:").append(id).append(",")
-                .append("bucketName:").append(bucketName).append(",")
-                .append("key:").append(key).append(",")
-                .append("file:").append(file).append(",")
-                .append("type:").append(type).append(",")
-                .append("bytesTotal:").append(bytesTotal).append(",")
-                .append("bytesCurrent:").append(bytesCurrent).append(",")
-                .append("fileOffset:").append(fileOffset).append(",")
-                .append("state:").append(state).append(",")
-                .append("cannedAcl:").append(cannedAcl).append(",")
-                .append("mainUploadId:").append(mainUploadId).append(",")
-                .append("isMultipart:").append(isMultipart).append(",")
-                .append("isLastPart:").append(isLastPart).append(",")
-                .append("partNumber:").append(partNumber).append(",")
-                .append("multipartId:").append(multipartId).append(",")
-                .append("eTag:").append(eTag)
+                .append("id:").append(record.getId()).append(",")
+                .append("bucketName:").append(record.getBucketName()).append(",")
+                .append("key:").append(record.getKey()).append(",")
+                .append("file:").append(record.getFile()).append(",")
+                .append("type:").append(record.getType()).append(",")
+                .append("bytesTotal:").append(record.getBytesTotal()).append(",")
+                .append("bytesCurrent:").append(record.getBytesCurrent()).append(",")
+                .append("fileOffset:").append(record.getFileOffset()).append(",")
+                .append("state:").append(record.getState()).append(",")
+                .append("cannedAcl:").append(record.getCannedAcl()).append(",")
+                .append("mainUploadId:").append(record.getMainUploadId()).append(",")
+                .append("isMultipart:").append(record.getIsMultipart()).append(",")
+                .append("isLastPart:").append(record.getIsLastPart()).append(",")
+                .append("partNumber:").append(record.getPartNumber()).append(",")
+                .append("multipartId:").append(record.getMultipartId()).append(",")
+                .append("eTag:").append(record.geteTag())
                 .append("]");
         return sb.toString();
     }
diff --git a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferService.java b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferService.java
index 6eeea6aa43..e92fa693dd 100644
--- a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferService.java
+++ b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferService.java
@@ -15,21 +15,6 @@
 
 package com.amazonaws.mobileconnectors.s3.transferutility;
 
-import android.app.Service;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.pm.ApplicationInfo;
-import android.database.Cursor;
-import android.net.ConnectivityManager;
-import android.net.NetworkInfo;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.IBinder;
-import android.os.Looper;
-import android.os.Message;
-
 import com.amazonaws.services.s3.AmazonS3;
 
 import org.apache.commons.logging.Log;
@@ -47,10 +32,9 @@
  * the upload and download threads and limits the concurrent running threads.
  * When there are no active tasks, TransferService will stop itself.
  */
-public class TransferService extends Service {
+public class TransferService {
 
     private static final Log LOGGER = LogFactory.getLog(TransferService.class);
-    private static final String TAG = TransferService.class.getSimpleName();
 
     /*
      * Constants of message sent to update handler.
@@ -81,13 +65,6 @@
         TransferState.RESUMED_WAITING
     };
     
-    /*
-     * updateHandler manages update requests in a queue. It updates transfers
-     * from database and start/stop threads if needed.
-     */
-    private HandlerThread handlerThread;
-    private Handler updateHandler;
-
     /*
      * registers a BroadcastReceiver to receive network status change events. It
      * will update transfer records in database directly.
@@ -120,7 +97,7 @@
     /**
      * Reference to the transfer database utility.
      */
-    private TransferDBUtil dbUtil;
+    private final TransferDBUtil dbUtil;
     
     /**
      * The status updater that updates the state and the
@@ -129,6 +106,9 @@
      */
     TransferStatusUpdater updater;
     
+    private final UpdateHandler updateHandler;
+
+    
     /**
      * The time interval to wait before checking for the
      * unfinished transfers that are not tracked in memory
@@ -141,11 +121,6 @@
      */
     private long transferServiceCheckTimeInterval;
 
-    @Override
-    public IBinder onBind(Intent intent) {
-        throw new UnsupportedOperationException("Can't bind to TransferService");
-    }
-
     /**
      * <ul>
      * <li>The service starts upon intents from transfer utility.</li>
@@ -154,67 +129,62 @@ public IBinder onBind(Intent intent) {
      * transfers waiting.</li>
      * </ul>
      */
-    @Override
-    public void onCreate() {
-        super.onCreate();
-
+    public TransferService() {
         LOGGER.debug("Starting Transfer Service");
-        dbUtil = new TransferDBUtil(this);
+        dbUtil = new TransferDBUtil();
         updater = new TransferStatusUpdater(dbUtil);
-
-        handlerThread = new HandlerThread(TAG + "-AWSTransferUpdateHandlerThread");
-        handlerThread.start();
-        setHandlerLooper(handlerThread.getLooper());
+        updateHandler = new UpdateHandler();
+        networkInfoReceiver = new NetworkInfoReceiver();
     }
 
     /**
      * A Broadcast receiver to receive network connection change events.
      */
-    static class NetworkInfoReceiver extends BroadcastReceiver {
-        private final Handler handler;
-        private final ConnectivityManager connManager;
-
-        /**
-         * Constructs a NetworkInfoReceiver.
-         *
-         * @param handler a handle to send message to
-         */
-        public NetworkInfoReceiver(Context context, Handler handler) {
-            this.handler = handler;
-            connManager = (ConnectivityManager) context
-                    .getSystemService(Context.CONNECTIVITY_SERVICE);
-        }
-
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction())) {
-                final boolean networkConnected = isNetworkConnected();
-                LOGGER.debug("Network connected: " + networkConnected);
-                handler.sendEmptyMessage(networkConnected ? MSG_CONNECT : MSG_DISCONNECT);
-            }
-        }
-
-        /**
-         * Gets the status of network connectivity.
-         *
-         * @return true if network is connected, false otherwise.
-         */
+    static class NetworkInfoReceiver /*extends BroadcastReceiver */{
+//        private final Handler handler;
+//        private final ConnectivityManager connManager;
+//
+//        /**
+//         * Constructs a NetworkInfoReceiver.
+//         *
+//         * @param handler a handle to send message to
+//         */
+//        public NetworkInfoReceiver(Context context, Handler handler) {
+//            this.handler = handler;
+//            connManager = (ConnectivityManager) context
+//                    .getSystemService(Context.CONNECTIVITY_SERVICE);
+//        }
+//
+//        @Override
+//        public void onReceive(Context context, Intent intent) {
+//            if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction())) {
+//                final boolean networkConnected = isNetworkConnected();
+//                LOGGER.debug("Network connected: " + networkConnected);
+//                handler.sendEmptyMessage(networkConnected ? MSG_CONNECT : MSG_DISCONNECT);
+//            }
+//        }
+//
+//        /**
+//         * Gets the status of network connectivity.
+//         *
+//         * @return true if network is connected, false otherwise.
+//         */
         boolean isNetworkConnected() {
-            final NetworkInfo info = connManager.getActiveNetworkInfo();
-            return info != null && info.isConnected();
+            // TODO: Add ConnectivityService
+            return true;
+//            final NetworkInfo info = connManager.getActiveNetworkInfo();
+//            return info != null && info.isConnected();
         }
     }
 
-    @Override
-    @SuppressWarnings("checkstyle:hiddenfield")
-    public int onStartCommand(Intent intent, int flags, int startId) {
+    public int onStartCommand(String action, Integer id, TransferUtilityOptions options, int flags, int startId) {
         this.startId = startId;
 
         if (isReceiverNotRegistered) {
             try {
                 LOGGER.info("registering receiver");
-                this.registerReceiver(this.networkInfoReceiver,
-                    new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
+//                this.registerReceiver(this.networkInfoReceiver,
+//                    new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
             } catch (final IllegalArgumentException iae) {
                 LOGGER.warn("Ignoring the exception trying to register the receiver for connectivity change.");
             } catch (final IllegalStateException ise) {
@@ -224,44 +194,37 @@ public int onStartCommand(Intent intent, int flags, int startId) {
             }
         }
 
-        if (intent == null) {
-            return START_REDELIVER_INTENT;
-        }
-
-        final Integer id = intent.getIntExtra(INTENT_BUNDLE_TRANSFER_ID, -1);
         if (id < 0) {
             LOGGER.error("The intent sent by the TransferUtility doesn't have the id.");
-            return START_NOT_STICKY;
+            return -1;
         }
         
         final AmazonS3 s3 = S3ClientReference.get(id);
         if (s3 == null) {
             LOGGER.error("TransferService can't get s3 client and not acting on the id.");
-            return START_NOT_STICKY;
+            return -1;
         }
 
-        final TransferUtilityOptions tuOptions = (TransferUtilityOptions) 
-            intent.getSerializableExtra(INTENT_BUNDLE_TRANSFER_UTILITY_OPTIONS);
+        final TransferUtilityOptions tuOptions = options;
         
         TransferThreadPool.init(tuOptions.getTransferThreadPoolSize());
         transferServiceCheckTimeInterval = tuOptions.getTransferServiceCheckTimeInterval();
         LOGGER.debug("ThreadPoolSize: " + tuOptions.getTransferThreadPoolSize()
             + " transferServiceCheckTimeInterval: " + tuOptions.getTransferServiceCheckTimeInterval());
 
-        updateHandler.sendMessage(updateHandler.obtainMessage(MSG_EXEC, intent));
+        updateHandler.handleMessage(MSG_EXEC, action, id);
         
         /*
          * The service will not restart if it's killed by system.
          */
-        return START_NOT_STICKY;
+        return -1;
     }
 
-    @Override
     public void onDestroy() {
         try {
             if (networkInfoReceiver != null) {
                 LOGGER.info("unregistering receiver");
-                this.unregisterReceiver(this.networkInfoReceiver);
+//                this.unregisterReceiver(this.networkInfoReceiver);
                 isReceiverNotRegistered = true;
             }
         } catch (final IllegalArgumentException iae) {
@@ -273,38 +236,37 @@ public void onDestroy() {
         }
 
         pauseAll();
-        handlerThread.quit();
         TransferThreadPool.closeThreadPool();
         S3ClientReference.clear();
 
         LOGGER.info("Closing the database.");
-        dbUtil.closeDB();
-        super.onDestroy();
     }
 
-    class UpdateHandler extends Handler {
-        public UpdateHandler(Looper looper) {
-            super(looper);
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            if (msg.what == MSG_CHECK) {
-                // remove messages of the same type
-                updateHandler.removeMessages(MSG_CHECK);
-                checkTransfers();
-            } else if (msg.what == MSG_EXEC) {
-                execCommand((Intent) msg.obj);
-            } else if (msg.what == MSG_DISCONNECT) {
-                pauseAllForNetwork();
-            } else if (msg.what == MSG_CONNECT) {
-                checkTransfersOnNetworkReconnect();
-            } else {
-                LOGGER.error("Unknown command: " + msg.what);
+    class UpdateHandler {
+
+        public void handleMessage(int msgWhat, String intentAction, Integer id) {
+            LOGGER.info("Mesage " + msgWhat + ", action: " + intentAction + ", id: " + id);
+            switch (msgWhat) {
+                case MSG_CHECK:
+                    // remove messages of the same type
+                    checkTransfers();
+                    break;
+                case MSG_EXEC:
+                    execCommand(intentAction, id);
+                    break;
+                case MSG_DISCONNECT:
+                    pauseAllForNetwork();
+                    break;
+                case MSG_CONNECT:
+                    checkTransfersOnNetworkReconnect();
+                    break;
+                default:
+                    LOGGER.error("Unknown command: " + msgWhat);
+                    break;
             }
         }
     }
-
+//
     /**
      * Checks two things: whether they are active transfers and whether a
      * database scan is necessary.
@@ -321,14 +283,13 @@ void checkTransfers() {
             lastActiveTime = System.currentTimeMillis();
             
             // check after transferServiceCheckTimeInterval milliseconds.
-            updateHandler.sendEmptyMessageDelayed(MSG_CHECK, transferServiceCheckTimeInterval);
+//            updateHandler.sendEmptyMessageDelayed(MSG_CHECK, transferServiceCheckTimeInterval);
         } else {
             /*
              * Stop the service when it's been idled for more than the time interval supplied
              * through {@link TransferUtilityConfiguration}. The default is 1-minute.
              */
             LOGGER.debug("Stop self");
-            stopSelf(startId);
         }
     }
 
@@ -349,18 +310,13 @@ void checkTransfersOnNetworkReconnect() {
      *
      * @param intent received intent
      */
-    void execCommand(Intent intent) {
+    void execCommand(String intentAction, Integer id) {
         // update last active time
         lastActiveTime = System.currentTimeMillis();
 
-        final String action = intent.getAction();
-        final Integer id = intent.getIntExtra(INTENT_BUNDLE_TRANSFER_ID, 0);
+        final String action = intentAction;
         final AmazonS3 s3 = S3ClientReference.get(id);
 
-        if (!TransferDBUtil.getTransferDBBase().getDatabase().isOpen()) {
-            LOGGER.debug("Database is not open. Opening the database before proceeding.");
-            this.dbUtil = new TransferDBUtil(this);
-        }
 
         if (INTENT_ACTION_TRANSFER_ADD.equals(action)) {
             if (updater.getTransfer(id) != null) {
@@ -444,33 +400,23 @@ private boolean isActive() {
      */
     void loadAndResumeTransfersFromDB(final TransferState[] transferStates) {
         LOGGER.debug("Loading transfers from database...");
-        Cursor c = null;
         int count = 0;
 
         // Read the transfer ids from the cursor and store in this list.
         List<Integer> transferIds = new ArrayList<Integer>();
 
         // Query for the unfinished transfers and store them in a list
-        try {
-            c = dbUtil.queryTransfersWithTypeAndStates(TransferType.ANY,
-                                                       transferStates);
-            while (c.moveToNext()) {
-                final int id = c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_ID));
-                // If the transfer status updater doesn't track it, load the transfer record
-                // from the database and add it to the updater to track
-                if (updater.getTransfer(id) == null) {
-                    final TransferRecord transfer = new TransferRecord(id);
-                    transfer.updateFromDB(c);
-                    updater.addTransfer(transfer);
-                    count++;
-                }
-                transferIds.add(id);
-            }
-        } finally {
-            if (c != null) {
-                LOGGER.debug("Closing the cursor for loadAndResumeTransfersFromDB");
-                c.close();
+        for (Record record : Service.getInstance().getRecords()) {
+            final int id = record.getId();
+            // If the transfer status updater doesn't track it, load the transfer record
+            // from the database and add it to the updater to track
+            if (updater.getTransfer(id) == null) {
+                final TransferRecord transfer = new TransferRecord();
+                transfer.updateFromDB(record);
+                updater.addTransfer(transfer);
+                count++;
             }
+            transferIds.add(id);
         }
 
         // Iterate over each transfer id and resume them if it's not running.
@@ -491,48 +437,34 @@ void loadAndResumeTransfersFromDB(final TransferState[] transferStates) {
 
         LOGGER.debug(count + " transfers are loaded from database.");
     }
-    
+
     /**
      * Pause all running transfers and set the state to WAITING_FOR_NETWORK.
      */
     void pauseAll() {
         for (final TransferRecord transferRecord : updater.getTransfers().values()) {
-            final AmazonS3 s3 = S3ClientReference.get(transferRecord.id);
-            if (s3 != null && transferRecord != null) {
+            final AmazonS3 s3 = S3ClientReference.get(transferRecord.getRecord().getId());
+            if (s3 != null) {
                 transferRecord.pause(s3, updater);
             }
         }
     }
-    
+
     /**
      * Pause all running transfers and set the state to WAITING_FOR_NETWORK.
      */
     void pauseAllForNetwork() {
         for (final TransferRecord transferRecord : updater.getTransfers().values()) {
-            final AmazonS3 s3 = S3ClientReference.get(transferRecord.id);
-            if (s3 != null && transferRecord != null && transferRecord.pause(s3, updater)) {
-                updater.updateState(transferRecord.id, TransferState.WAITING_FOR_NETWORK);
+            final AmazonS3 s3 = S3ClientReference.get(transferRecord.getRecord().getId());
+            if (s3 != null && transferRecord.pause(s3, updater)) {
+                updater.updateState(transferRecord.getRecord().getId(), TransferState.WAITING_FOR_NETWORK);
             }
         }
         shouldScan = true;
     }
-
-    /**
-     * A helper method to swap a different looper for testing purpose.
-     *
-     * @param looper new looper
-     */
-    void setHandlerLooper(Looper looper) {
-        updateHandler = new UpdateHandler(looper);
-        networkInfoReceiver = new NetworkInfoReceiver(getApplicationContext(), updateHandler);
-    }
-
-    @Override
+    
     protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
         // only available when the application is debuggable
-        if ((getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
-            return;
-        }
 
         writer.printf("start id: %d\n", startId);
         writer.printf("network status: %s\n", networkInfoReceiver.isNetworkConnected());
@@ -540,9 +472,10 @@ protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
         final Map<Integer, TransferRecord> transfers = updater.getTransfers();
         writer.printf("# of active transfers: %d\n", transfers.size());
         for (final TransferRecord transfer : transfers.values()) {
+            Record r = transfer.getRecord();
             writer.printf("bucket: %s, key: %s, status: %s, total size: %d, current: %d\n",
-                    transfer.bucketName, transfer.key, transfer.state, transfer.bytesTotal,
-                    transfer.bytesCurrent);
+                    r.getBucketName(), r.getKey(), r.getState(), r.getBytesTotal(),
+                    r.getBytesCurrent());
         }
         writer.flush();
     }
diff --git a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferStatusUpdater.java b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferStatusUpdater.java
index d8983516b1..5d39a7eaf7 100644
--- a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferStatusUpdater.java
+++ b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferStatusUpdater.java
@@ -15,9 +15,6 @@
 
 package com.amazonaws.mobileconnectors.s3.transferutility;
 
-import android.os.Handler;
-import android.os.Looper;
-
 import com.amazonaws.event.ProgressEvent;
 import com.amazonaws.event.ProgressListener;
 
@@ -31,6 +28,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.CopyOnWriteArrayList;
+import javafx.application.Platform;
 
 /**
  * A class that tracks active transfers. It has a static map that holds weak
@@ -69,17 +67,11 @@
      * Database util to update transfer status.
      */
     private final TransferDBUtil dbUtil;
-    /**
-     * The handler of main thread that runs callbacks.
-     */
-    private final Handler mainHandler;
-
     /**
      * This class is instantiated by TransferService.
      */
     TransferStatusUpdater(TransferDBUtil dbUtil) {
         this.dbUtil = dbUtil;
-        mainHandler = new Handler(Looper.getMainLooper());
         transfers = new HashMap<Integer, TransferRecord>();
         lastUpdateTime = new HashMap<Integer, Long>();
     }
@@ -99,7 +91,7 @@
      * @param transfer a transfer object
      */
     void addTransfer(TransferRecord transfer) {
-        transfers.put(transfer.id, transfer);
+        transfers.put(transfer.getRecord().getId(), transfer);
     }
 
     /**
@@ -154,16 +146,12 @@ void updateState(final int id, final TransferState newState) {
         final TransferRecord transfer = transfers.get(id);
         if (transfer == null) {
             // still wants to save state
-            if (dbUtil.updateState(id, newState) == 0) {
-                LOGGER.warn("Failed to update the status of transfer " + id);
-            }
+            dbUtil.updateState(id, newState);
         } else {
-            shouldNotNotify |= newState.equals(transfer.state);
-            transfer.state = newState;
+            shouldNotNotify |= newState.equals(transfer.getRecord().getState());
+            transfer.getRecord().setState(newState);
             // save to database
-            if (dbUtil.updateTransferRecord(transfer) == 0) {
-                LOGGER.warn("Failed to update the status of transfer " + id);
-            }
+            dbUtil.updateTransferRecord(transfer);
         }
 
         if (shouldNotNotify) {
@@ -180,7 +168,7 @@ void updateState(final int id, final TransferState newState) {
         }
 
         // invoke on main thread
-        mainHandler.post(new Runnable() {
+        Platform.runLater(new Runnable() {
             @Override
             public void run() {
                 for (final TransferListener l : list) {
@@ -213,8 +201,8 @@ public void run() {
     void updateProgress(final int id, final long bytesCurrent, final long bytesTotal) {
         final TransferRecord transfer = transfers.get(id);
         if (transfer != null) {
-            transfer.bytesCurrent = bytesCurrent;
-            transfer.bytesTotal = bytesTotal;
+            transfer.getRecord().setBytesCurrent(bytesCurrent);
+            transfer.getRecord().setBytesTotal(bytesTotal);
         }
 
         // Don't fire off the update too frequently, but still fire when it
@@ -238,7 +226,7 @@ void updateProgress(final int id, final long bytesCurrent, final long bytesTotal
             lastUpdateTime.put(id, timeInMillis);
 
             // invoke on main thread
-            mainHandler.post(new Runnable() {
+            Platform.runLater(new Runnable() {
                 @Override
                 public void run() {
                     for (final TransferListener l : list) {
@@ -263,7 +251,7 @@ void throwError(final int id, final Exception e) {
             return;
         }
         // invoke on main thread
-        mainHandler.post(new Runnable() {
+        Platform.runLater(new Runnable() {
             @Override
             public void run() {
                 for (final TransferListener l : list) {
@@ -346,13 +334,13 @@ public synchronized void progressChanged(ProgressEvent progressEvent) {
             if (progressEvent.getEventCode() == ProgressEvent.RESET_EVENT_CODE) {
                 // Reset will discard what's been transferred, so subtract the
                 // bytes transferred in this task from the total progress.
-                transfer.bytesCurrent -= bytesCurrent;
+                transfer.getRecord().setBytesCurrent(transfer.getRecord().getBytesCurrent() - bytesCurrent);
                 bytesCurrent = 0;
             } else {
                 bytesCurrent += progressEvent.getBytesTransferred();
-                transfer.bytesCurrent += progressEvent.getBytesTransferred();
+                transfer.getRecord().setBytesCurrent(transfer.getRecord().getBytesCurrent() + progressEvent.getBytesTransferred());
             }
-            updateProgress(transfer.id, transfer.bytesCurrent, transfer.bytesTotal);
+            updateProgress(transfer.getRecord().getId(), transfer.getRecord().getBytesCurrent(), transfer.getRecord().getBytesTotal());
         }
     }
 
diff --git a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferTable.java b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferTable.java
deleted file mode 100644
index 56a5eae4a8..0000000000
--- a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferTable.java
+++ /dev/null
@@ -1,307 +0,0 @@
-/**
- * Copyright 2015-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License").
- * You may not use this file except in compliance with the License.
- * A copy of the License is located at
- *
- *  http://aws.amazon.com/apache2.0
- *
- * or in the "license" file accompanying this file. This file is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
- * express or implied. See the License for the specific language governing
- * permissions and limitations under the License.
- */
-
-package com.amazonaws.mobileconnectors.s3.transferutility;
-
-import android.database.sqlite.SQLiteDatabase;
-
-class TransferTable {
-
-    /**
-     * Database table name
-     */
-    public static final String TABLE_TRANSFER = "awstransfer";
-
-    /**
-     * A unique id of the transfer record
-     */
-    public static final String COLUMN_ID = "_id";
-
-    /**
-     * For upload part record only, the transfer id of the main record of the
-     * part record.
-     */
-    public static final String COLUMN_MAIN_UPLOAD_ID = "main_upload_id";
-
-    /**
-     * Transfer type, can be whether "upload" or "download"
-     */
-    public static final String COLUMN_TYPE = "type";
-
-    /**
-     * The current state of the transfer, values of all states are in
-     * <code>TransferConstants</code>.
-     */
-    public static final String COLUMN_STATE = "state";
-
-    /**
-     * The name of the bucket.
-     */
-    public static final String COLUMN_BUCKET_NAME = "bucket_name";
-
-    /**
-     * A key in the bucket.
-     */
-    public static final String COLUMN_KEY = "key";
-
-    /**
-     * The total bytes to transfer.
-     */
-    public static final String COLUMN_BYTES_TOTAL = "bytes_total";
-
-    /**
-     * The bytes currently transferred.
-     */
-    public static final String COLUMN_BYTES_CURRENT = "bytes_current";
-
-    /**
-     * The path of the file to transfer.
-     */
-    public static final String COLUMN_FILE = "file";
-
-    /**
-     * The bytes offset of the file.
-     */
-    public static final String COLUMN_FILE_OFFSET = "file_offset";
-
-    /**
-     * Whether the transfer is a multi-part transfer.
-     */
-    public static final String COLUMN_IS_MULTIPART = "is_multipart";
-
-    /**
-     * Whether the part is the last part of the file.
-     */
-    public static final String COLUMN_IS_LAST_PART = "is_last_part";
-
-    /**
-     * The number of the part in the transfer.
-     */
-    public static final String COLUMN_PART_NUM = "part_num";
-
-    /**
-     * The multipart upload id.
-     */
-    public static final String COLUMN_MULTIPART_ID = "multipart_id";
-
-    /**
-     * The Etag of the transfer
-     */
-    public static final String COLUMN_ETAG = "etag";
-
-    /**
-     * The range's start index in the file.
-     */
-    public static final String COLUMN_DATA_RANGE_START = "range_start";
-
-    /**
-     * The range's end index in the file.
-     */
-    public static final String COLUMN_DATA_RANGE_LAST = "range_last";
-
-    /**
-     * Whether the transfer is encrypted.
-     */
-    public static final String COLUMN_IS_ENCRYPTED = "is_encrypted";
-
-    /*
-     * the following columns are not used yet
-     */
-    public static final String COLUMN_SPEED = "speed";
-    public static final String COLUMN_VERSION_ID = "version_id";
-    public static final String COLUMN_HEADER_EXPIRE = "header_expire";
-
-    /**
-     * If the object requires the requester to pay
-     */
-    public static final String COLUMN_IS_REQUESTER_PAYS = "is_requester_pays";
-
-    /**
-     * User specified content Type
-     */
-    public static final String COLUMN_HEADER_CONTENT_TYPE = "header_content_type";
-
-    /**
-     * User specified content language
-     */
-    public static final String COLUMN_HEADER_CONTENT_LANGUAGE = "header_content_language";
-
-    /**
-     * User specified content disposition
-     */
-    public static final String COLUMN_HEADER_CONTENT_DISPOSITION = "header_content_disposition";
-
-    /**
-     * User specified content encoding
-     */
-    public static final String COLUMN_HEADER_CONTENT_ENCODING = "header_content_encoding";
-
-    /**
-     * User specified cache control
-     */
-    public static final String COLUMN_HEADER_CACHE_CONTROL = "header_cache_control";
-
-    /**
-     * ============ Below added in 2.2.6 for support for metadata ============
-     */
-
-    /**
-     * User specified lifecycle configuration expiration time rule id
-     */
-    public static final String COLUMN_EXPIRATION_TIME_RULE_ID = "expiration_time_rule_id";
-
-    /**
-     * User specified lifecycle configuration expiration time rule id
-     */
-    public static final String COLUMN_HTTP_EXPIRES_DATE = "http_expires_date";
-
-    /**
-     * User specified server side encryption algorithm
-     */
-    public static final String COLUMN_SSE_ALGORITHM = "sse_algorithm";
-
-    /**
-     * User specified content MD5
-     */
-    public static final String COLUMN_CONTENT_MD5 = "content_md5";
-
-    /**
-     * Json serialization of user metadata to store with the Object
-     */
-    public static final String COLUMN_USER_METADATA = "user_metadata";
-
-    /**
-     * ============ Below added in 2.2.11 for support for KMS ============
-     */
-
-    /**
-     * User specified KMS key for server side encryption
-     */
-    public static final String COLUMN_SSE_KMS_KEY = "kms_key";
-
-    /**
-     * Canned ACL of this upload.
-     */
-    public static final String COLUMN_CANNED_ACL = "canned_acl";
-
-    /*
-     * Database creation SQL statement
-     */
-    private static final String DATABASE_CREATE = "create table "
-            + TABLE_TRANSFER
-            + "("
-            + COLUMN_ID + " integer primary key autoincrement, "
-            + COLUMN_MAIN_UPLOAD_ID + " integer, "
-            + COLUMN_TYPE + " text not null, "
-            + COLUMN_STATE + " text not null, "
-            + COLUMN_BUCKET_NAME + " text not null, "
-            + COLUMN_KEY + " text not null, "
-            + COLUMN_VERSION_ID + " text, "
-            + COLUMN_BYTES_TOTAL + " bigint, "
-            + COLUMN_BYTES_CURRENT + " bigint, "
-            + COLUMN_SPEED + " bigint, "
-            + COLUMN_IS_REQUESTER_PAYS + " integer, "
-            + COLUMN_IS_ENCRYPTED + " integer, "
-            + COLUMN_FILE + " text not null, "
-            + COLUMN_FILE_OFFSET + " bigint, "
-            + COLUMN_IS_MULTIPART + " int, "
-            + COLUMN_PART_NUM + " int not null, "
-            + COLUMN_IS_LAST_PART + " integer, "
-            + COLUMN_MULTIPART_ID + " text, "
-            + COLUMN_ETAG + " text, "
-            + COLUMN_DATA_RANGE_START + " bigint, "
-            + COLUMN_DATA_RANGE_LAST + " bigint, "
-            + COLUMN_HEADER_CONTENT_TYPE + " text, "
-            + COLUMN_HEADER_CONTENT_LANGUAGE + " text, "
-            + COLUMN_HEADER_CONTENT_DISPOSITION + " text, "
-            + COLUMN_HEADER_CONTENT_ENCODING + " text, "
-            + COLUMN_HEADER_CACHE_CONTROL + " text, "
-            + COLUMN_HEADER_EXPIRE + " text"
-            + ");";
-
-    /**
-     * Creates the database.
-     *
-     * @param database An SQLiteDatabase instance.
-     */
-    public static void onCreate(SQLiteDatabase database, int version) {
-        database.execSQL(DATABASE_CREATE);
-        onUpgrade(database, 1, version);
-    }
-
-    private static final int TABLE_VERSION_2 = 2;
-    private static final int TABLE_VERSION_3 = 3;
-    private static final int TABLE_VERSION_4 = 4;
-
-    /**
-     * Upgrades the database.
-     *
-     * @param database An SQLiteDatabase instance.
-     * @param oldVersion The old version of the database.
-     * @param newVersion The new version of the database.
-     */
-    public static void onUpgrade(SQLiteDatabase database, int oldVersion,
-            int newVersion) {
-
-        if (oldVersion < TABLE_VERSION_2 && newVersion >= TABLE_VERSION_2) {
-            addVersion2Columns(database);
-        }
-        if (oldVersion < TABLE_VERSION_3 && newVersion >= TABLE_VERSION_3) {
-            addVersion3Columns(database);
-        }
-        if (oldVersion < TABLE_VERSION_4 && newVersion >= TABLE_VERSION_4) {
-            addVersion4Columns(database);
-        }
-    }
-
-    /**
-     * Adds columns that were introduced in version 2 to the database
-     */
-    private static void addVersion2Columns(SQLiteDatabase database) {
-        final String addUserMetadata = "ALTER TABLE " + TABLE_TRANSFER +
-                " ADD COLUMN " + COLUMN_USER_METADATA + " text;";
-        final String addExpirationTimeRuleId = "ALTER TABLE " + TABLE_TRANSFER +
-                " ADD COLUMN " + COLUMN_EXPIRATION_TIME_RULE_ID + " text;";
-        final String addHttpExpires = "ALTER TABLE " + TABLE_TRANSFER +
-                " ADD COLUMN " + COLUMN_HTTP_EXPIRES_DATE + " text;";
-        final String addSSEAlgorithm = "ALTER TABLE " + TABLE_TRANSFER +
-                " ADD COLUMN " + COLUMN_SSE_ALGORITHM + " text;";
-        final String addContentMD5 = "ALTER TABLE " + TABLE_TRANSFER +
-                " ADD COLUMN " + COLUMN_CONTENT_MD5 + " text;";
-        database.execSQL(addUserMetadata);
-        database.execSQL(addExpirationTimeRuleId);
-        database.execSQL(addHttpExpires);
-        database.execSQL(addSSEAlgorithm);
-        database.execSQL(addContentMD5);
-    }
-
-    /**
-     * Adds columns that were introduced in version 3 to the database
-     */
-    private static void addVersion3Columns(SQLiteDatabase database) {
-        final String addKMSKey = "ALTER TABLE " + TABLE_TRANSFER +
-                " ADD COLUMN " + COLUMN_SSE_KMS_KEY + " text;";
-        database.execSQL(addKMSKey);
-    }
-
-    /**
-     * Adds columns that were introduced in version 3 to the database
-     */
-    private static void addVersion4Columns(SQLiteDatabase database) {
-        final String addCannedAcl = "ALTER TABLE " + TABLE_TRANSFER +
-                " ADD COLUMN " + COLUMN_CANNED_ACL + " text;";
-        database.execSQL(addCannedAcl);
-    }
-}
diff --git a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferUtility.java b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferUtility.java
index fde4e308fa..6030886a1f 100644
--- a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferUtility.java
+++ b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/TransferUtility.java
@@ -18,11 +18,6 @@
 import static com.amazonaws.services.s3.internal.Constants.MAXIMUM_UPLOAD_PARTS;
 import static com.amazonaws.services.s3.internal.Constants.MB;
 
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.Intent;
-import android.database.Cursor;
-import android.net.Uri;
 import org.json.JSONObject;
 
 import com.amazonaws.AmazonWebServiceRequest;
@@ -33,12 +28,11 @@
 import com.amazonaws.services.s3.model.ObjectMetadata;
 import com.amazonaws.util.VersionInfoUtils;
 
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
 import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 /**
  * The transfer utility is a high-level class for applications to upload and
@@ -100,7 +94,7 @@
  */
 public class TransferUtility {
 
-    private static final Log LOGGER = LogFactory.getLog(TransferUtility.class);
+    private static final Logger LOGGER = Logger.getLogger(TransferUtility.class.getName());
 
     /**
      * Default minimum part size for upload parts. Anything below this will use
@@ -125,7 +119,6 @@ private static String getUserAgentFromConfig() {
     }
 
     private final AmazonS3 s3;
-    private final Context appContext;
     private final TransferDBUtil dbUtil;
     private final String defaultBucket;
     private final TransferUtilityOptions transferUtilityOptions;
@@ -135,7 +128,6 @@ private static String getUserAgentFromConfig() {
      */
     public static class Builder {
         private AmazonS3 s3;
-        private Context appContext;
         private String defaultBucket;
         private AWSConfiguration awsConfig;
         private TransferUtilityOptions transferUtilityOptions;
@@ -153,17 +145,6 @@ public Builder s3Client(final AmazonS3 s3Client) {
             return this;
         }
         
-        /**
-         * Sets the context used.
-         * 
-         * @param applicationContext The application context.
-         * @return builder
-         */
-        public Builder context(final Context applicationContext) {
-            this.appContext = applicationContext.getApplicationContext();
-            return this;
-        }
-        
         /**
          * Sets the default bucket used for uploads and downloads.
          * This allows you to use the corresponding methods that do not require the bucket name to be specified.
@@ -233,8 +214,6 @@ public Builder transferUtilityOptions(final TransferUtilityOptions tuOptions) {
         public TransferUtility build() {
             if (this.s3 == null) {
                 throw new IllegalArgumentException("AmazonS3 client is required please set using .s3Client(yourClient)");
-            } else if (this.appContext == null) {
-                throw new IllegalArgumentException("Context is required please set using .context(applicationContext)");
             }
             
             if (this.awsConfig != null) {
@@ -255,7 +234,6 @@ public TransferUtility build() {
             }
             
             return new TransferUtility(this.s3,
-                                    this.appContext,
                                     this.defaultBucket,
                                     this.transferUtilityOptions);
         }
@@ -275,17 +253,14 @@ public static Builder builder() {
      * Constructor.
      * 
      * @param s3 The client to use when making requests to Amazon S3
-     * @param context The current context
      * @param defaultBucket The name of the default S3 bucket
      * @param tuOptions The TransferUtility Options object
      */
     private TransferUtility(AmazonS3 s3,
-                            Context context,
                             String defaultBucket,
                             TransferUtilityOptions tuOptions) {
         this.s3 = s3;
-        this.appContext = context.getApplicationContext();
-        this.dbUtil = new TransferDBUtil(appContext);
+        this.dbUtil = new TransferDBUtil();
         this.defaultBucket = defaultBucket;
         this.transferUtilityOptions = tuOptions;
     }
@@ -296,15 +271,13 @@ private TransferUtility(AmazonS3 s3,
      * reference.
      *
      * @param s3 The client to use when making requests to Amazon S3
-     * @param context The current context
      * 
      * @deprecated Please use TransferUtility.builder().s3Client(s3).context(context).build()
      */
     @Deprecated
-    public TransferUtility(AmazonS3 s3, Context context) {
+    public TransferUtility(AmazonS3 s3) {
         this.s3 = s3;
-        this.appContext = context.getApplicationContext();
-        this.dbUtil = new TransferDBUtil(appContext);
+        this.dbUtil = new TransferDBUtil();
         this.defaultBucket = null;
         this.transferUtilityOptions = new TransferUtilityOptions();
     }
@@ -365,16 +338,14 @@ public TransferObserver download(String bucket, String key, File file,
         if (file == null || file.isDirectory()) {
             throw new IllegalArgumentException("Invalid file: " + file);
         }
-        final Uri uri = dbUtil.insertSingleTransferRecord(TransferType.DOWNLOAD,
-                bucket, key, file);
-        final int recordId = Integer.parseInt(uri.getLastPathSegment());
+        final int recordId = dbUtil.insertSingleTransferRecord(TransferType.DOWNLOAD, bucket, key, file);
         if (file.isFile()) {
-            LOGGER.warn("Overwrite existing file: " + file);
+            LOGGER.log(Level.WARNING, "Overwrite existing file: " + file);
             file.delete();
         }
 
         sendIntent(TransferService.INTENT_ACTION_TRANSFER_ADD, recordId);
-        return new TransferObserver(recordId, dbUtil, bucket, key, file, listener);
+        return new TransferObserver(recordId, bucket, key, file, listener);
     }
 
     /**
@@ -536,13 +507,12 @@ public TransferObserver upload(String bucket, String key, File file, ObjectMetad
             recordId = createMultipartUploadRecords(bucket, key, file, metadata, cannedAcl);
         } else {
 
-            final Uri uri = dbUtil.insertSingleTransferRecord(TransferType.UPLOAD,
+            recordId = dbUtil.insertSingleTransferRecord(TransferType.UPLOAD,
                     bucket, key, file, metadata, cannedAcl);
-            recordId = Integer.parseInt(uri.getLastPathSegment());
         }
 
         sendIntent(TransferService.INTENT_ACTION_TRANSFER_ADD, recordId);
-        return new TransferObserver(recordId, dbUtil, bucket, key, file, listener);
+        return new TransferObserver(recordId, bucket, key, file, listener);
     }
 
     /**
@@ -570,20 +540,13 @@ public TransferObserver upload(String key, File file, ObjectMetadata metadata,
      * @return The TransferObserver instance which is observing the record.
      */
     public TransferObserver getTransferById(int id) {
-        Cursor c = null;
-        try {
-            c = dbUtil.queryTransferById(id);
-            if (c.moveToNext()) {
-                final TransferObserver to = new TransferObserver(id, dbUtil);
-                to.updateFromDB(c);
+        for (Record r : Service.getInstance().getRecords()) {
+            if (r.getId() == id) {
+                final TransferObserver to = new TransferObserver(id);
+                to.updateFromDB(r);
                 return to;
             }
-        } finally {
-            if (c != null) {
-                c.close();
-            }
         }
-
         return null;
     }
 
@@ -596,20 +559,14 @@ public TransferObserver getTransferById(int id) {
      */
     public List<TransferObserver> getTransfersWithType(TransferType type) {
         final List<TransferObserver> transferObservers = new ArrayList<TransferObserver>();
-        Cursor c = null;
-        try {
-            c = dbUtil.queryAllTransfersWithType(type);
-            while (c.moveToNext()) {
-                final int id = c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_ID));
-                final TransferObserver to = new TransferObserver(id, dbUtil);
-                to.updateFromDB(c);
+        for (Record record : Service.getInstance().getRecords()) {
+            if (record.getType().equals(type)) {
+                final TransferObserver to = new TransferObserver(record.getId());
+                to.updateFromDB(record);
                 transferObservers.add(to);
             }
-        } finally {
-            if (c != null) {
-                c.close();
-            }
         }
+        
         return transferObservers;
     }
 
@@ -641,23 +598,17 @@ public TransferObserver getTransferById(int id) {
     public List<TransferObserver> getTransfersWithTypeAndStates(TransferType type,
                                                                 TransferState[] states) {
         final List<TransferObserver> transferObservers = new ArrayList<TransferObserver>();
-        Cursor c = null;
-        try {
-            c = dbUtil.queryTransfersWithTypeAndStates(type, states);
-            while (c.moveToNext()) {
-                final int partNum = c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_PART_NUM));
-                if (partNum != 0) {
+        for (Record record : Service.getInstance().getRecords()) {
                     // skip parts of a multipart upload
-                    continue;
-                }
-                final int id = c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_ID));
-                final TransferObserver to = new TransferObserver(id, dbUtil);
-                to.updateFromDB(c);
+            if (record.getType().equals(type) && ! record.getMultipartId().equals("0")) {
+                for (TransferState state : states) {
+                    if (record.getState().equals(state)) {
+                        final TransferObserver to = new TransferObserver(record.getId());
+                        to.updateFromDB(record);
                 transferObservers.add(to);
-            }
-        } finally {
-            if (c != null) {
-                c.close();
+                        break;
+                    }
+                }
             }
         }
         return transferObservers;
@@ -674,21 +625,17 @@ public TransferObserver getTransferById(int id) {
     private List<Integer> getTransferIdsWithTypeAndStates(TransferType type,
                                                           TransferState[] states) {
         List<Integer> transferIds = new ArrayList<Integer>();
-        Cursor c = null;
-        try {
-            c = dbUtil.queryTransfersWithTypeAndStates(type, states);
-            while (c.moveToNext()) {
-                final int partNum = c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_PART_NUM));
-                if (partNum != 0) {
+        for (Record record : Service.getInstance().getRecords()) {
                     // skip parts of a multipart upload
-                    continue;
+            if (record.getType().equals(type) && ! record.getMultipartId().equals("0")) {
+                for (TransferState state : states) {
+                    if (record.getState().equals(state)) {
+                        final TransferObserver to = new TransferObserver(record.getId());
+                        to.updateFromDB(record);
+                        transferIds.add(to.getId());
+                        break;
+                    }
                 }
-                final int id = c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_ID));
-                transferIds.add(id);
-            }
-        } finally {
-            if (c != null) {
-                c.close();
             }
         }
         return transferIds;
@@ -720,12 +667,12 @@ private int createMultipartUploadRecords(String bucket, String key, File file,
          * the size of valuesArray is partCount + 1, one for a multipart upload
          * summary, others are actual parts to be uploaded
          */
-        final ContentValues[] valuesArray = new ContentValues[partCount + 1];
-        valuesArray[0] = dbUtil.generateContentValuesForMultiPartUpload(bucket, key,
+        final Record[] valuesArray = new Record[partCount + 1];
+        valuesArray[0] = dbUtil.generateRecordForMultiPartUpload(bucket, key,
                 file, fileOffset, 0, "", file.length(), 0, metadata, cannedAcl);
         for (int i = 1; i < partCount + 1; i++) {
             final long bytesForPart = Math.min(optimalPartSize, remainingLenth);
-            valuesArray[i] = dbUtil.generateContentValuesForMultiPartUpload(bucket, key,
+            valuesArray[i] = dbUtil.generateRecordForMultiPartUpload(bucket, key,
                     file, fileOffset, partNumber, "", bytesForPart, remainingLenth
                             - optimalPartSize <= 0 ? 1 : 0,
                     metadata, cannedAcl);
@@ -753,16 +700,9 @@ public boolean pause(int id) {
      * @param type The type of transfers
      */
     public void pauseAllWithType(TransferType type) {
-        Cursor c = null;
-        try {
-            c = dbUtil.queryAllTransfersWithType(type);
-            while (c.moveToNext()) {
-                final int id = c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_ID));
-                pause(id);
-            }
-        } finally {
-            if (c != null) {
-                c.close();
+        for (Record record : Service.getInstance().getRecords()) {
+            if (record.getType().equals(type)) {
+                pause(record.getId());
             }
         }
     }
@@ -830,16 +770,9 @@ public boolean cancel(int id) {
      * @param type The type of transfers
      */
     public void cancelAllWithType(TransferType type) {
-        Cursor c = null;
-        try {
-            c = dbUtil.queryAllTransfersWithType(type);
-            while (c.moveToNext()) {
-                final int id = c.getInt(c.getColumnIndexOrThrow(TransferTable.COLUMN_ID));
-                cancel(id);
-            }
-        } finally {
-            if (c != null) {
-                c.close();
+        for (Record record : Service.getInstance().getRecords()) {
+            if (record.getType().equals(type)) {
+                cancel(record.getId());
             }
         }
     }
@@ -865,12 +798,9 @@ public boolean deleteTransferRecord(int id) {
      */
     private synchronized void sendIntent(String action, int id) {
         S3ClientReference.put(id, s3);
-        final Intent intent = new Intent(appContext, TransferService.class);
-        intent.setAction(action);
-        intent.putExtra(TransferService.INTENT_BUNDLE_TRANSFER_ID, id);
-        intent.putExtra(TransferService.INTENT_BUNDLE_TRANSFER_UTILITY_OPTIONS,
-                        this.transferUtilityOptions);
-        appContext.startService(intent);
+        TransferService service = new TransferService();
+        LOGGER.log(Level.INFO, "Sending action intent: " + action + " for id " + id);
+        service.onStartCommand(action, id, transferUtilityOptions, id, id);
     }
 
     private boolean shouldUploadInMultipart(File file) {
diff --git a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/UploadTask.java b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/UploadTask.java
index 12b4acd3e4..e7af2b8370 100644
--- a/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/UploadTask.java
+++ b/aws-java-sdk-s3/src/main/java/com/amazonaws/mobileconnectors/s3/transferutility/UploadTask.java
@@ -68,12 +68,16 @@ public UploadTask(TransferRecord uploadInfo, AmazonS3 s3, TransferDBUtil dbUtil,
      */
     @Override
     public Boolean call() throws Exception {
+        LOGGER.info("CALL Upload Task " + networkInfo.isNetworkConnected());
         if (!networkInfo.isNetworkConnected()) {
-            updater.updateState(upload.id, TransferState.WAITING_FOR_NETWORK);
+            updater.updateState(upload.getRecord().getId(), TransferState.WAITING_FOR_NETWORK);
+            LOGGER.info("Upload Task not connected - false");
             return false;
         }
-        updater.updateState(upload.id, TransferState.IN_PROGRESS);
-        if (upload.isMultipart == 1 && upload.partNumber == 0) {
+        LOGGER.info("Upload Task state progress");
+        updater.updateState(upload.getRecord().getId(), TransferState.IN_PROGRESS);
+        LOGGER.info("Upload Task - multipart " + upload.getRecord().getIsMultipart());
+        if (upload.getRecord().getIsMultipart() == 1 && upload.getRecord().getPartNumber() == 0) {
             /*
              * If part number = 0, this multipart upload record is not a real
              * part upload task, it's a summary for all the parts with part
@@ -81,7 +85,7 @@ public Boolean call() throws Exception {
              * upload parts.
              */
             return uploadMultipartAndWaitForCompletion();
-        } else if (upload.isMultipart == 0) {
+        } else if (upload.getRecord().getIsMultipart() == 0) {
             /*
              * uploads in one Chunk, doesn't support pause and resume.
              */
@@ -96,39 +100,39 @@ private Boolean uploadMultipartAndWaitForCompletion() throws ExecutionException
          * it's a resumed upload, upload.mMultipartId would not be null.
          */
         long bytesAlreadyTransferrd = 0;
-        if (upload.multipartId == null || upload.multipartId.isEmpty()) {
+        if (upload.getRecord().getMultipartId() == null || upload.getRecord().getMultipartId().isEmpty()) {
             final PutObjectRequest putObjectRequest = createPutObjectRequest(upload);
             TransferUtility.appendMultipartTransferServiceUserAgentString(putObjectRequest);
             try {
-                upload.multipartId = initiateMultipartUpload(putObjectRequest);
+                upload.getRecord().setMultipartId(initiateMultipartUpload(putObjectRequest));
             } catch (final AmazonClientException ace) {
-                LOGGER.error("Error initiating multipart upload: " + upload.id
+                LOGGER.error("Error initiating multipart upload: " + upload.getRecord().getId()
                         + " due to " + ace.getMessage(), ace);
-                updater.throwError(upload.id, ace);
-                updater.updateState(upload.id, TransferState.FAILED);
+                updater.throwError(upload.getRecord().getId(), ace);
+                updater.updateState(upload.getRecord().getId(), TransferState.FAILED);
                 return false;
             }
-            dbUtil.updateMultipartId(upload.id, upload.multipartId);
+            dbUtil.updateMultipartId(upload.getRecord().getId(), upload.getRecord().getMultipartId());
         } else {
             /*
              * For a resumed upload, we should calculate the bytes already
              * transferred.
              */
-            bytesAlreadyTransferrd = dbUtil.queryBytesTransferredByMainUploadId(upload.id);
+            bytesAlreadyTransferrd = dbUtil.queryBytesTransferredByMainUploadId(upload.getRecord().getId());
             if (bytesAlreadyTransferrd > 0) {
                 LOGGER.debug(String.format("Resume transfer %d from %d bytes",
-                        upload.id, bytesAlreadyTransferrd));
+                        upload.getRecord().getId(), bytesAlreadyTransferrd));
             }
         }
-        updater.updateProgress(upload.id, bytesAlreadyTransferrd, upload.bytesTotal);
+        updater.updateProgress(upload.getRecord().getId(), bytesAlreadyTransferrd, upload.getRecord().getBytesTotal());
 
-        final List<UploadPartRequest> requestList = dbUtil.getNonCompletedPartRequestsFromDB(upload.id,
-                upload.multipartId);
-        LOGGER.debug("multipart upload " + upload.id + " in " + requestList.size() + " parts.");
+        final List<UploadPartRequest> requestList = dbUtil.getNonCompletedPartRequestsFromDB(upload.getRecord().getId(),
+                upload.getRecord().getMultipartId());
+        LOGGER.debug("multipart upload " + upload.getRecord().getId() + " in " + requestList.size() + " parts.");
         final ArrayList<Future<Boolean>> futures = new ArrayList<Future<Boolean>>();
         for (final UploadPartRequest request : requestList) {
             TransferUtility.appendMultipartTransferServiceUserAgentString(request);
-            request.setGeneralProgressListener(updater.newProgressListener(upload.id));
+            request.setGeneralProgressListener(updater.newProgressListener(upload.getRecord().getId()));
             futures.add(TransferThreadPool.submitTask(new UploadPartTask(request, s3, dbUtil, networkInfo)));
         }
         try {
@@ -155,17 +159,17 @@ private Boolean uploadMultipartAndWaitForCompletion() throws ExecutionException
                 f.cancel(true);
             }
             // abort by user
-            LOGGER.debug("Transfer " + upload.id + " is interrupted by user");
+            LOGGER.debug("Transfer " + upload.getRecord().getId() + " is interrupted by user");
             return false;
         } catch (final ExecutionException ee) {
             // handle pause, cancel, etc
             boolean isNetworkInterrupted = false;
             if (ee.getCause() != null && ee.getCause() instanceof Exception) {
                 // check for network interruption and pause the transfer instead of failing them
-                isNetworkInterrupted = dbUtil.checkWaitingForNetworkPartRequestsFromDB(upload.id);
+                isNetworkInterrupted = dbUtil.checkWaitingForNetworkPartRequestsFromDB(upload.getRecord().getId());
                 if (isNetworkInterrupted) {
-                    LOGGER.debug("Network Connection Interrupted: Transfer " + upload.id + " waits for network");
-                    updater.updateState(upload.id, TransferState.WAITING_FOR_NETWORK);
+                    LOGGER.debug("Network Connection Interrupted: Transfer " + upload.getRecord().getId() + " waits for network");
+                    updater.updateState(upload.getRecord().getId(), TransferState.WAITING_FOR_NETWORK);
                     return false;
                 }
                 final Exception e = (Exception) ee.getCause();
@@ -174,46 +178,48 @@ private Boolean uploadMultipartAndWaitForCompletion() throws ExecutionException
                      * thread is interrupted by user. don't update the state as
                      * it's set by caller who interrupted
                      */
-                    LOGGER.debug("Transfer " + upload.id + " is interrupted by user");
+                    LOGGER.debug("Transfer " + upload.getRecord().getId() + " is interrupted by user");
                     return false;
                 } else if (e.getCause() != null && e.getCause() instanceof IOException
                         && !networkInfo.isNetworkConnected()) {
-                    LOGGER.debug("Transfer " + upload.id + " waits for network");
-                    updater.updateState(upload.id, TransferState.WAITING_FOR_NETWORK);
+                    LOGGER.debug("Transfer " + upload.getRecord().getId() + " waits for network");
+                    updater.updateState(upload.getRecord().getId(), TransferState.WAITING_FOR_NETWORK);
                 }
-                updater.throwError(upload.id, e);
+                updater.throwError(upload.getRecord().getId(), e);
             }
-            updater.updateState(upload.id, TransferState.FAILED);
+            updater.updateState(upload.getRecord().getId(), TransferState.FAILED);
             return false;
         }
 
         try {
-            completeMultiPartUpload(upload.id, upload.bucketName, upload.key,
-                    upload.multipartId);
-            updater.updateProgress(upload.id, upload.bytesTotal, upload.bytesTotal);
-            updater.updateState(upload.id, TransferState.COMPLETED);
+            completeMultiPartUpload(upload.getRecord().getId(), upload.getRecord().getBucketName(), upload.getRecord().getKey(),
+                    upload.getRecord().getMultipartId());
+            updater.updateProgress(upload.getRecord().getId(), upload.getRecord().getBytesTotal(), upload.getRecord().getBytesTotal());
+            updater.updateState(upload.getRecord().getId(), TransferState.COMPLETED);
             return true;
         } catch (final AmazonClientException ace) {
-            LOGGER.error("Failed to complete multipart: " + upload.id
+            LOGGER.error("Failed to complete multipart: " + upload.getRecord().getId()
                     + " due to " + ace.getMessage(), ace);
-            updater.throwError(upload.id, ace);
-            updater.updateState(upload.id, TransferState.FAILED);
+            updater.throwError(upload.getRecord().getId(), ace);
+            updater.updateState(upload.getRecord().getId(), TransferState.FAILED);
             return false;
         }
     }
 
     private Boolean uploadSinglePartAndWaitForCompletion() {
+        LOGGER.info("Upload single part");
         final PutObjectRequest putObjectRequest = createPutObjectRequest(upload);
 
         final long length = putObjectRequest.getFile().length();
+        LOGGER.info("length single part: " + length);
         TransferUtility.appendTransferServiceUserAgentString(putObjectRequest);
-        updater.updateProgress(upload.id, 0, length);
-        putObjectRequest.setGeneralProgressListener(updater.newProgressListener(upload.id));
+        updater.updateProgress(upload.getRecord().getId(), 0, length);
+        putObjectRequest.setGeneralProgressListener(updater.newProgressListener(upload.getRecord().getId()));
 
         try {
             s3.putObject(putObjectRequest);
-            updater.updateProgress(upload.id, length, length);
-            updater.updateState(upload.id, TransferState.COMPLETED);
+            updater.updateProgress(upload.getRecord().getId(), length, length);
+            updater.updateState(upload.getRecord().getId(), TransferState.COMPLETED);
             return true;
         } catch (final Exception e) {
             if (RetryUtils.isInterrupted(e)) {
@@ -221,23 +227,23 @@ private Boolean uploadSinglePartAndWaitForCompletion() {
                  * thread is interrupted by user. don't update the state as it's
                  * set by caller who interrupted
                  */
-                LOGGER.debug("Transfer " + upload.id + " is interrupted by user");
+                LOGGER.debug("Transfer " + upload.getRecord().getId() + " is interrupted by user");
                 return false;
             } else if (e.getCause() != null && e.getCause() instanceof AmazonClientException
                     && !networkInfo.isNetworkConnected()) {
                 // check for network interruption and pause the transfer instead of failing them
-                LOGGER.debug("Network Connection Interrupted: Transfer " + upload.id + " waits for network");
-                updater.updateState(upload.id, TransferState.WAITING_FOR_NETWORK);
+                LOGGER.debug("Network Connection Interrupted: Transfer " + upload.getRecord().getId() + " waits for network");
+                updater.updateState(upload.getRecord().getId(), TransferState.WAITING_FOR_NETWORK);
                 return false;
             } else if (e.getCause() != null && e.getCause() instanceof IOException
                     && !networkInfo.isNetworkConnected()) {
-                LOGGER.debug("Transfer " + upload.id + " waits for network");
-                updater.updateState(upload.id, TransferState.WAITING_FOR_NETWORK);
+                LOGGER.debug("Transfer " + upload.getRecord().getId() + " waits for network");
+                updater.updateState(upload.getRecord().getId(), TransferState.WAITING_FOR_NETWORK);
             }
             // all other exceptions
-            LOGGER.debug("Failed to upload: " + upload.id + " due to " + e.getMessage(), e);
-            updater.throwError(upload.id, e);
-            updater.updateState(upload.id, TransferState.FAILED);
+            LOGGER.debug("Failed to upload: " + upload.getRecord().getId() + " due to " + e.getMessage(), e);
+            updater.throwError(upload.getRecord().getId(), e);
+            updater.updateState(upload.getRecord().getId(), TransferState.FAILED);
             return false;
         }
     }
@@ -280,49 +286,49 @@ private String initiateMultipartUpload(PutObjectRequest putObjectRequest) {
      */
     @SuppressWarnings("checkstyle:hiddenfield")
     private PutObjectRequest createPutObjectRequest(TransferRecord upload) {
-        final File file = new File(upload.file);
-        final PutObjectRequest putObjectRequest = new PutObjectRequest(upload.bucketName,
-                upload.key, file);
+        final File file = new File(upload.getRecord().getFile());
+        final PutObjectRequest putObjectRequest = new PutObjectRequest(upload.getRecord().getBucketName(),
+                upload.getRecord().getKey(), file);
 
         final ObjectMetadata om = new ObjectMetadata();
         om.setContentLength(file.length());
 
-        if (upload.headerCacheControl != null) {
-            om.setCacheControl(upload.headerCacheControl);
+        if (upload.getRecord().getHeaderCacheControl() != null) {
+            om.setCacheControl(upload.getRecord().getHeaderCacheControl());
         }
-        if (upload.headerContentDisposition != null) {
-            om.setContentDisposition(upload.headerContentDisposition);
+        if (upload.getRecord().getHeaderContentDisposition() != null) {
+            om.setContentDisposition(upload.getRecord().getHeaderContentDisposition());
         }
-        if (upload.headerContentEncoding != null) {
-            om.setContentEncoding(upload.headerContentEncoding);
+        if (upload.getRecord().getHeaderContentEncoding() != null) {
+            om.setContentEncoding(upload.getRecord().getHeaderContentEncoding());
         }
-        if (upload.headerContentType != null) {
-            om.setContentType(upload.headerContentType);
+        if (upload.getRecord().getHeaderContentType() != null) {
+            om.setContentType(upload.getRecord().getHeaderContentType());
         } else {
             om.setContentType(Mimetypes.getInstance().getMimetype(file));
         }
-        if (upload.expirationTimeRuleId != null) {
-            om.setExpirationTimeRuleId(upload.expirationTimeRuleId);
+        if (upload.getRecord().getExpirationTimeRuleId() != null) {
+            om.setExpirationTimeRuleId(upload.getRecord().getExpirationTimeRuleId());
         }
-        if (upload.httpExpires != null) {
-            om.setHttpExpiresDate(new Date(Long.valueOf(upload.httpExpires)));
+        if (upload.getRecord().getHttpExpires() != null) {
+            om.setHttpExpiresDate(new Date(Long.valueOf(upload.getRecord().getHttpExpires())));
         }
-        if (upload.sseAlgorithm != null) {
-            om.setSSEAlgorithm(upload.sseAlgorithm);
+        if (upload.getRecord().getSseAlgorithm() != null) {
+            om.setSSEAlgorithm(upload.getRecord().getSseAlgorithm());
         }
-        if (upload.userMetadata != null) {
-            om.setUserMetadata(upload.userMetadata);
+        if (upload.getRecord().getUserMetadata() != null) {
+            om.setUserMetadata(upload.getRecord().getUserMetadata());
         }
-        if (upload.md5 != null) {
-            om.setContentMD5(upload.md5);
+        if (upload.getRecord().getMd5() != null) {
+            om.setContentMD5(upload.getRecord().getMd5());
         }
-        if (upload.sseKMSKey != null) {
+        if (upload.getRecord().getSseKMSKey() != null) {
             putObjectRequest
-                    .setSSEAwsKeyManagementParams(new SSEAwsKeyManagementParams(upload.sseKMSKey));
+                    .setSSEAwsKeyManagementParams(new SSEAwsKeyManagementParams(upload.getRecord().getSseKMSKey()));
         }
 
         putObjectRequest.setMetadata(om);
-        putObjectRequest.setCannedAcl(getCannedAclFromString(upload.cannedAcl));
+        putObjectRequest.setCannedAcl(getCannedAclFromString(upload.getRecord().getCannedAcl()));
 
         return putObjectRequest;
     }
