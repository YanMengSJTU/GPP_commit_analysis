diff --git a/aws-java-sdk-auth-core/src/main/java/com/amazonaws/mobile/auth/core/IdentityManager.java b/aws-java-sdk-auth-core/src/main/java/com/amazonaws/mobile/auth/core/IdentityManager.java
index c728895a41..c05c90e746 100644
--- a/aws-java-sdk-auth-core/src/main/java/com/amazonaws/mobile/auth/core/IdentityManager.java
+++ b/aws-java-sdk-auth-core/src/main/java/com/amazonaws/mobile/auth/core/IdentityManager.java
@@ -17,11 +17,6 @@
 
 package com.amazonaws.mobile.auth.core;
 
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.util.Log;
-
 import com.amazonaws.ClientConfiguration;
 import com.amazonaws.SDKGlobalConfiguration;
 
@@ -36,15 +31,13 @@
 import com.amazonaws.mobile.auth.core.signin.SignInManager;
 import com.amazonaws.mobile.auth.core.signin.SignInProvider;
 import com.amazonaws.mobile.auth.core.signin.SignInProviderResultHandler;
-import com.amazonaws.mobile.auth.core.internal.util.ThreadUtils;
 import com.amazonaws.mobile.config.AWSConfiguration;
 
 import com.amazonaws.regions.Region;
 import com.amazonaws.regions.Regions;
+import com.gluonhq.charm.down.Services;
+import com.gluonhq.charm.down.plugins.SettingsService;
 
-import java.io.IOException;
-import java.lang.reflect.Method;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.Date;
 import java.util.HashMap;
@@ -55,8 +48,11 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.function.Consumer;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javafx.application.Platform;
 
-import org.json.JSONArray;
 
 /**
  * The identity manager keeps track of the current sign-in provider and is responsible
@@ -64,8 +60,7 @@
  * 
  * <pre>
  * // Create IdentityManager and set it as the default instance.
- * IdentityManager idm = new IdentityManager(getApplicationContext(), 
- *                                           new AWSConfiguration(getApplicationContext()));
+ * IdentityManager idm = new IdentityManager(new AWSConfiguration(getApplicationContext()));
  * IdentityManager.setDefaultIdentityManager(idm);
  * 
  * // Use IdentityManager to retrieve the {@link com.amazonaws.auth.CognitoCachingCredentialsProvider}
@@ -76,6 +71,8 @@
  */
 public class IdentityManager {
 
+    private static final Logger LOG = Logger.getLogger(IdentityManager.class.getName());
+    
     /** Holder for the credentials provider, allowing the underlying provider to be swapped when necessary. */
     private class AWSCredentialsProviderHolder implements AWSCredentialsProvider {
 
@@ -102,18 +99,12 @@ private void setUnderlyingProvider(final CognitoCachingCredentialsProvider under
         }
     }
 
-    /** Log tag. */
-    private static final String LOG_TAG = IdentityManager.class.getSimpleName();
-
     /** AWS Configuration json file */
     private static final String AWS_CONFIGURATION_FILE = "awsconfiguration.json";
 
     /** Holder for the credentials provider, allowing the underlying provider to be swapped when necessary. */
     private final AWSCredentialsProviderHolder credentialsProviderHolder;
 
-    /** Application context. */
-    private final Context appContext;
-
     /** Configuration for the mobile helper. */
     private AWSConfiguration awsConfiguration;
 
@@ -177,7 +168,7 @@ public AWSRefreshingCognitoIdentityProvider(final String accountId,
         public String refresh() {
 
             if (currentIdentityProvider != null) {
-                Log.d(LOG_TAG, "Storing the Refresh token in the loginsMap.");
+                LOG.log(Level.FINE, "Storing the Refresh token in the loginsMap.");
                 final String newToken = currentIdentityProvider.refreshToken();
                 getLogins().put(currentIdentityProvider.getCognitoLoginKey(), newToken);
             }
@@ -190,8 +181,7 @@ public String refresh() {
      * 
      * @param context the application context.
      */
-    public IdentityManager(final Context context) {
-        this.appContext = context.getApplicationContext();
+    public IdentityManager() {
         this.awsConfiguration = null;
         this.clientConfiguration = null;
         this.credentialsProviderHolder = null;
@@ -202,16 +192,13 @@ public IdentityManager(final Context context) {
      * Initializes with the application context and the AWSConfiguration passed in.
      * Creates a default ClientConfiguration with the user agent from AWSConfiguration.
      *
-     * @param context the application context.
      * @param awsConfiguration the aws configuration.
      */
-    public IdentityManager(final Context context,
-                           final AWSConfiguration awsConfiguration) {
-        this.appContext = context.getApplicationContext();
+    public IdentityManager(final AWSConfiguration awsConfiguration) {
         this.awsConfiguration = awsConfiguration;
         this.clientConfiguration = new ClientConfiguration().withUserAgent(awsConfiguration.getUserAgent());
         this.credentialsProviderHolder = new AWSCredentialsProviderHolder();
-        createCredentialsProvider(this.appContext, this.clientConfiguration);
+        createCredentialsProvider(this.clientConfiguration);
     }
 
     /**
@@ -220,14 +207,11 @@ public IdentityManager(final Context context,
      * and the ClientConfiguration passed in.
      * Read the UserAgent from AWSConfiguration and set in ClientConfiguration.
      *
-     * @param context the application context.
      * @param awsConfiguration the aws configuration.
      * @param clientConfiguration the client configuration options such as retries and timeouts.
      */
-    public IdentityManager(final Context context,
-                           final AWSConfiguration awsConfiguration,
+    public IdentityManager(final AWSConfiguration awsConfiguration,
                            final ClientConfiguration clientConfiguration) {
-        this.appContext = context.getApplicationContext();
         this.awsConfiguration = awsConfiguration;
         this.clientConfiguration = clientConfiguration;
 
@@ -240,7 +224,7 @@ public IdentityManager(final Context context,
         }
 
         this.credentialsProviderHolder = new AWSCredentialsProviderHolder();
-        createCredentialsProvider(this.appContext, this.clientConfiguration);
+        createCredentialsProvider(this.clientConfiguration);
     }
 
     /**
@@ -248,14 +232,11 @@ public IdentityManager(final Context context,
      * Initializes with the activity context, application's credentials provider
      * that provides the identity and the client configuration.
      *
-     * @param context the application context.
-     * @param awsConfiguration the aws configuration.
+     * @param credentialsProvider
      * @param clientConfiguration the client configuration options such as retries and timeouts.
      */
-    public IdentityManager(final Context context,
-                           final CognitoCachingCredentialsProvider credentialsProvider,
+    public IdentityManager(final CognitoCachingCredentialsProvider credentialsProvider,
                            final ClientConfiguration clientConfiguration) {
-        this.appContext = context.getApplicationContext();
         this.clientConfiguration = clientConfiguration;
         this.credentialsProviderHolder = new AWSCredentialsProviderHolder();
         credentialsProviderHolder.setUnderlyingProvider(credentialsProvider);
@@ -309,7 +290,7 @@ public boolean areCredentialsExpired() {
             credentialsProviderHolder.getUnderlyingProvider().getSessionCredentitalsExpiration();
 
         if (credentialsExpirationDate == null) {
-            Log.d(LOG_TAG, "Credentials are EXPIRED.");
+            LOG.log(Level.FINE, "Credentials are EXPIRED.");
             return true;
         }
 
@@ -319,7 +300,7 @@ public boolean areCredentialsExpired() {
         final boolean credsAreExpired =
                 (credentialsExpirationDate.getTime() - currentTime) < 0;
 
-        Log.d(LOG_TAG, "Credentials are " + (credsAreExpired ? "EXPIRED." : "OK"));
+        LOG.log(Level.FINE, "Credentials are " + (credsAreExpired ? "EXPIRED." : "OK"));
 
         return credsAreExpired;
     }
@@ -371,13 +352,13 @@ public void run() {
                     identityId = credentialsProviderHolder.getUnderlyingProvider().getIdentityId();
                 } catch (final Exception exception) {
                     this.exception = exception;
-                    Log.e(LOG_TAG, exception.getMessage(), exception);
+                    LOG.log(Level.WARNING, exception.getMessage(), exception);
                 } finally {
                     final String result = identityId;
-                    Log.d(LOG_TAG, "Got Amazon Cognito Federated Identity ID: " + identityId);
+                    LOG.log(Level.FINE, "Got Amazon Cognito Federated Identity ID: " + identityId);
 
                     if (handler != null) {
-                        ThreadUtils.runOnUiThread(new Runnable() {
+                        Platform.runLater(new Runnable() {
                             @Override
                             public void run() {
                                 if (exception != null) {
@@ -406,7 +387,7 @@ private SignInProviderResultAdapter(final SignInProviderResultHandler handler) {
 
         @Override
         public void onSuccess(final IdentityProvider provider) {
-            Log.d(LOG_TAG,
+            LOG.log(Level.FINE,
                     String.format("SignInProviderResultAdapter.onSuccess(): %s provider sign-in succeeded.",
                             provider.getDisplayName()));
             // Update Cognito login with the token.
@@ -414,12 +395,12 @@ public void onSuccess(final IdentityProvider provider) {
         }
 
         private void onCognitoSuccess() {
-            Log.d(LOG_TAG, "SignInProviderResultAdapter.onCognitoSuccess()");
+            LOG.log(Level.FINE, "SignInProviderResultAdapter.onCognitoSuccess()");
             handler.onSuccess(currentIdentityProvider);
         }
 
         private void onCognitoError(final Exception ex) {
-            Log.d(LOG_TAG, "SignInProviderResultAdapter.onCognitoError()", ex);
+            LOG.log(Level.FINE, "SignInProviderResultAdapter.onCognitoError()", ex);
             final IdentityProvider provider = currentIdentityProvider;
             // Sign out of parent provider. This clears the currentIdentityProvider.
             IdentityManager.this.signOut();
@@ -428,7 +409,7 @@ private void onCognitoError(final Exception ex) {
 
         @Override
         public void onCancel(final IdentityProvider provider) {
-            Log.d(LOG_TAG, String.format(
+            LOG.log(Level.FINE, String.format(
                 "SignInProviderResultAdapter.onCancel(): %s provider sign-in canceled.",
                 provider.getDisplayName()));
             handler.onCancel(provider);
@@ -436,7 +417,7 @@ public void onCancel(final IdentityProvider provider) {
 
         @Override
         public void onError(final IdentityProvider provider, final Exception ex) {
-            Log.e(LOG_TAG,
+            LOG.log(Level.WARNING,
                 String.format("SignInProviderResultAdapter.onError(): %s provider error. %s",
                               provider.getDisplayName(), ex.getMessage()), ex);
             handler.onError(provider, new ProviderAuthException(provider, ex));
@@ -482,7 +463,7 @@ public SignInProviderResultAdapter getResultsAdapter() {
      * anonymous (guest) identity, call {@link #getUserID(IdentityHandler)}.
      */
     public void signOut() {
-        Log.d(LOG_TAG, "Signing out...");
+        LOG.log(Level.FINE, "Signing out...");
 
         if (currentIdentityProvider != null) {
             executorService.submit(new Runnable() {
@@ -519,15 +500,18 @@ private void refreshCredentialWithLogins(final Map<String, String> loginMap) {
         credentialsProvider.withLogins(loginMap);
       
         // Calling refresh is equivalent to calling getIdentityId() + getCredentials().
-        Log.d(LOG_TAG, "refresh credentials");
+        LOG.log(Level.FINE, "refresh credentials");
         credentialsProvider.refresh();
 
         // Set the expiration key of the Credentials Provider to 8 minutes, 30 seconds.
-        appContext.getSharedPreferences(SHARED_PREF_NAME, Context.MODE_PRIVATE)
-                  .edit()
-                  .putLong(credentialsProvider.getIdentityPoolId() + "." + EXPIRATION_KEY,
-                           System.currentTimeMillis() + (510 * 1000))
-                  .apply();
+        Services.get(SettingsService.class).ifPresent(new Consumer<SettingsService>() {
+            @Override
+            public void accept(SettingsService settings) {
+                settings.store(credentialsProvider.getIdentityPoolId() + "." + EXPIRATION_KEY,
+                           Long.toString(System.currentTimeMillis() + (510 * 1000)));
+                
+            }
+        });
     }
 
     /**
@@ -551,7 +535,7 @@ public void setProviderResultsHandler(final SignInProviderResultHandler signInPr
      * @param provider A sign-in provider.
      */
     public void federateWithProvider(final IdentityProvider provider) {
-        Log.d(LOG_TAG, "federate with provider: Populate loginsMap with token.");
+        LOG.log(Level.FINE, "federate with provider: Populate loginsMap with token.");
         final Map<String, String> loginMap = new HashMap<String, String>();
         loginMap.put(provider.getCognitoLoginKey(), provider.getToken());
         currentIdentityProvider = provider;
@@ -626,10 +610,9 @@ public boolean isUserSignedIn() {
      * @param startupAuthResultHandler the callback object
      * @param ex the exception if raised during the resume session
      */
-    private void completeHandler(final Activity callingActivity,
-                                 final StartupAuthResultHandler startupAuthResultHandler,
+    private void completeHandler(final StartupAuthResultHandler startupAuthResultHandler,
                                  final AuthException ex) {
-        runAfterStartupAuthDelay(callingActivity, new Runnable() {
+        runAfterStartupAuthDelay(new Runnable() {
             @Override
             public void run() {
                 startupAuthResultHandler.onComplete(new StartupAuthResult(IdentityManager.this,
@@ -645,19 +628,18 @@ public void run() {
      *
      * @param runnable runnable to run after the splash timeout expires.
      */
-    private void runAfterStartupAuthDelay(final Activity callingActivity,
-                                          final Runnable runnable) {
+    private void runAfterStartupAuthDelay(final Runnable runnable) {
         executorService.submit(new Runnable() {
             public void run() {
                 // Wait for the startupAuthTimeoutLatch to go to zero.
                 try {
                     startupAuthTimeoutLatch.await();
                 } catch (InterruptedException e) {
-                    Log.d(LOG_TAG, "Interrupted while waiting for startup auth minimum delay.");
+                    LOG.log(Level.FINE, "Interrupted while waiting for startup auth minimum delay.");
                 }
 
                 // Notify user by invoking the callback on the UI thread
-                callingActivity.runOnUiThread(runnable);
+                Platform.runLater(runnable);
             }
         });
     }
@@ -668,45 +650,43 @@ public void run() {
      * If the user was not previously signed in or their identity could not be refreshed with the
      * previously signed-in provider, it will attempt to obtain an unauthenticated identity.
      *
-     * @param callingActivity the calling activity.
      * @param startupAuthResultHandler a handler for returning results.
      * @param minimumDelay the minimum delay to wait before returning the sign-in result.
      */
-    public void resumeSession(final Activity callingActivity,
-                              final StartupAuthResultHandler startupAuthResultHandler,
+    public void resumeSession(final StartupAuthResultHandler startupAuthResultHandler,
                               final long minimumDelay) {
 
-        Log.d(LOG_TAG, "Resume Session called.");
+        LOG.log(Level.FINE, "Resume Session called.");
         
         executorService.submit(new Runnable() {
             public void run() {
-                Log.d(LOG_TAG, "Looking for a previously signed-in session.");
-                final SignInManager signInManager = 
-                        SignInManager.getInstance(callingActivity.getApplicationContext());
+                LOG.log(Level.FINE, "Looking for a previously signed-in session.");
+                final SignInManager signInManager = SignInManager.getInstance();
                 
-                final SignInProvider signInProvider = 
-                        signInManager.getPreviouslySignedInProvider();
+                final SignInProvider signInProvider = signInManager.getPreviouslySignedInProvider();
 
                 // if the user was previously signed-in with an sign-in provider and
                 // we are able to verify with the sign-in provider.
                 if (signInProvider != null) {
-                    Log.d(LOG_TAG, "Refreshing credentials with sign-in provider "
+                    LOG.log(Level.FINE, "Refreshing credentials with sign-in provider "
                         + signInProvider.getDisplayName());
+                    // TODO
+                    throw new UnsupportedOperationException("Not supported yet");
                     
+                    /*
                     // Use the token from the previously signed-in session to
                     // get a AWS Identity using Cognito Federated Identities
                     // The AWS Identity will be wrapped into the CredentialsProvider
                     // which will contain short-lived AWS Credentials to access
                     // AWS resources.             
-                    signInManager.refreshCredentialsWithProvider(callingActivity,
-                            signInProvider,
+                    signInManager.refreshCredentialsWithProvider(signInProvider,
                             new SignInProviderResultHandler() {
 
                                 @Override
                                 public void onSuccess(final IdentityProvider provider) {
-                                    Log.d(LOG_TAG, "Successfully got AWS Credentials.");
+                                    LOG.log(Level.FINE, "Successfully got AWS Credentials.");
         
-                                    runAfterStartupAuthDelay(callingActivity, new Runnable() {
+                                    runAfterStartupAuthDelay(new Runnable() {
                                         @Override
                                         public void run() {
                                             startupAuthResultHandler.onComplete(new StartupAuthResult(IdentityManager.this, null));
@@ -716,28 +696,29 @@ public void run() {
         
                                 @Override
                                 public void onCancel(final IdentityProvider provider) {
-                                    Log.wtf(LOG_TAG, "Cancel can't happen when handling a previously signed-in user.");
+                                    LOG.log(Level.SEVERE, "Cancel can't happen when handling a previously signed-in user.");
                                 }
         
                                 @Override
                                 public void onError(final IdentityProvider provider, final Exception ex) {
-                                    Log.e(LOG_TAG,
+                                    LOG.log(Level.WARNING,
                                             String.format("Federate with Cognito with %s Sign-in provider failed. Error: %s",
                                                     provider.getDisplayName(), ex.getMessage()), ex);
         
                                     if (ex instanceof AuthException) {
-                                        completeHandler(callingActivity, startupAuthResultHandler,
+                                        completeHandler(startupAuthResultHandler,
                                                 (AuthException) ex);
                                     } else {
-                                        completeHandler(callingActivity, startupAuthResultHandler,
+                                        completeHandler(startupAuthResultHandler,
                                                 new AuthException(provider, ex));
                                     }
                                 }
                             });
+                    */
                 } else {
                     // No previously signed-in provider found. No session to resume.
                     // Notify the user by executing the callback handler.
-                    completeHandler(callingActivity, startupAuthResultHandler, null);
+                    completeHandler(startupAuthResultHandler, null);
                 }
 
                 if (minimumDelay > 0) {
@@ -745,7 +726,7 @@ public void onError(final IdentityProvider provider, final Exception ex) {
                     try {
                         Thread.sleep(minimumDelay);
                     } catch (final InterruptedException ex) {
-                        Log.i(LOG_TAG, "Interrupted while waiting for resume session timeout.");
+                        LOG.log(Level.INFO, "Interrupted while waiting for resume session timeout.");
                     }
                 }
 
@@ -762,12 +743,10 @@ public void onError(final IdentityProvider provider, final Exception ex) {
      * previously signed in provider and sign-in is optional, it will attempt to obtain an unauthenticated (guest)
      * identity.
      *
-     * @param callingActivity the calling activity.
      * @param startupAuthResultHandler a handler for returning results.
      */
-    public void resumeSession(final Activity callingActivity,
-                              final StartupAuthResultHandler startupAuthResultHandler) {
-        resumeSession(callingActivity, startupAuthResultHandler, 0);
+    public void resumeSession(final StartupAuthResultHandler startupAuthResultHandler) {
+        resumeSession(startupAuthResultHandler, 0);
     }
 
     /**
@@ -777,14 +756,12 @@ public void resumeSession(final Activity callingActivity,
      * previously signed in provider and sign-in is optional, it will attempt to obtain an unauthenticated (guest)
      * identity.
      *
-     * @param callingActivity the calling activity.
      * @param startupAuthResultHandler a handler for returning results.
      * @deprecated Please use {@link #resumeSession(Activity, StartupAuthResultHandler)} method instead.
      */
     @Deprecated
-    public void doStartupAuth(final Activity callingActivity,
-                              final StartupAuthResultHandler startupAuthResultHandler) {
-        resumeSession(callingActivity, startupAuthResultHandler, 0);
+    public void doStartupAuth(final StartupAuthResultHandler startupAuthResultHandler) {
+        resumeSession(startupAuthResultHandler, 0);
     }
 
     /**
@@ -794,15 +771,14 @@ public void doStartupAuth(final Activity callingActivity,
      * previously signed in provider and sign-in is optional, it will attempt to obtain an unauthenticated (guest)
      * identity.
      *
-     * @param callingActivity the calling activity.
      * @param startupAuthResultHandler a handler for returning results.
+     * @param minimumDelay
      * @deprecated Please use {@link #resumeSession(Activity, StartupAuthResultHandler, long)} method instead.
      */
     @Deprecated
-    public void doStartupAuth(final Activity callingActivity,
-                              final StartupAuthResultHandler startupAuthResultHandler,
+    public void doStartupAuth(final StartupAuthResultHandler startupAuthResultHandler,
                               final long minimumDelay) {
-        resumeSession(callingActivity, startupAuthResultHandler, minimumDelay);
+        resumeSession(startupAuthResultHandler, minimumDelay);
     }
 
     /**
@@ -817,14 +793,12 @@ public void expireSignInTimeout() {
      *
      * Note: This should not be called when already signed in with a provider.
      *
-     * @param context context.
      * @param signInResultHandler the results handler.
      * @deprecated Please use {@link #login(Context, SignInResultHandler)} method instead.
      */
     @Deprecated
-    public void setUpToAuthenticate(final Context context,
-                                    final SignInResultHandler signInResultHandler) {
-        this.login(context, signInResultHandler);
+    public void setUpToAuthenticate(final SignInResultHandler signInResultHandler) {
+        this.login(signInResultHandler);
     }
 
     /**
@@ -832,21 +806,21 @@ public void setUpToAuthenticate(final Context context,
      *
      * Note: This should not be called when already signed in with a provider.
      *
-     * @param context context.
      * @param signInResultHandler the results handler.
      */
-    public void login(final Context context,
-                      final SignInResultHandler signInResultHandler) {
+    public void login(final SignInResultHandler signInResultHandler) {
         // Start the sign-in activity. 
         // We do not finish the calling activity allowing the user to navigate back.
-        try {
-            SignInManager
-                .getInstance(context.getApplicationContext())
-                .setResultHandler(signInResultHandler);
-        } catch (final Exception exception) {
-            Log.e(LOG_TAG, "Error in instantiating SignInManager. " +
-                           "Check the context and completion handler.", exception);
-        }
+        // TODO
+        throw new UnsupportedOperationException("Not supported yet");
+//        try {
+//            SignInManager
+//                .getInstance()
+//                .setResultHandler(signInResultHandler);
+//        } catch (final Exception exception) {
+//            LOG.log(Level.WARNING, "Error in instantiating SignInManager. " +
+//                           "Check the context and completion handler.", exception);
+//        }
     }
 
     /**
@@ -855,22 +829,25 @@ public void login(final Context context,
      *   in order to refresh the credentials.  Therefore, currently cached credentials are
      *   only useful for unauthenticated users.
      */
-    private void createCredentialsProvider(final Context context,
-                                           final ClientConfiguration clientConfiguration) {
-
-        Log.d(LOG_TAG, "Creating the Cognito Caching Credentials Provider "
-                + "with a refreshing Cognito Identity Provider.");
+    private void createCredentialsProvider(final ClientConfiguration clientConfiguration) {
 
-        final String region = getCognitoIdentityRegion();
-        final Regions cognitoIdentityRegion = Regions.fromName(region);
-
-        final AWSRefreshingCognitoIdentityProvider refreshingCredentialsProvider =
-            new AWSRefreshingCognitoIdentityProvider(null, getCognitoIdentityPoolId(),
-                clientConfiguration, cognitoIdentityRegion);
-
-        credentialsProviderHolder.setUnderlyingProvider(
-            new CognitoCachingCredentialsProvider(context, refreshingCredentialsProvider,
-                    cognitoIdentityRegion, clientConfiguration));
+        try {
+            LOG.log(Level.FINE, "Creating the Cognito Caching Credentials Provider "
+                    + "with a refreshing Cognito Identity Provider.");
+            
+            final String region = getCognitoIdentityRegion();
+            final Regions cognitoIdentityRegion = Regions.fromName(region);
+            
+            final AWSRefreshingCognitoIdentityProvider refreshingCredentialsProvider =
+                    new AWSRefreshingCognitoIdentityProvider(null, getCognitoIdentityPoolId(),
+                            clientConfiguration, cognitoIdentityRegion);
+            
+            credentialsProviderHolder.setUnderlyingProvider(
+                    new CognitoCachingCredentialsProvider(refreshingCredentialsProvider,
+                            cognitoIdentityRegion, clientConfiguration));
+        } catch (Throwable ex) {
+            LOG.log(Level.SEVERE, "Error createCredentialsProvider", ex);
+        }
     }
 
     /**
diff --git a/aws-java-sdk-auth-core/src/main/java/com/amazonaws/mobile/auth/core/SignInResultHandler.java b/aws-java-sdk-auth-core/src/main/java/com/amazonaws/mobile/auth/core/SignInResultHandler.java
index c2f67b704d..81a644989b 100644
--- a/aws-java-sdk-auth-core/src/main/java/com/amazonaws/mobile/auth/core/SignInResultHandler.java
+++ b/aws-java-sdk-auth-core/src/main/java/com/amazonaws/mobile/auth/core/SignInResultHandler.java
@@ -17,8 +17,6 @@
 
 package com.amazonaws.mobile.auth.core;
 
-import android.app.Activity;
-
 /**
  * Interface for handling results from calling IdentityManager's signInOrSignUp().
  */
@@ -29,14 +27,14 @@
      * @param callingActivity the calling activity that should be finished.
      * @param provider the provider or null if succeeded with an unauthenticated identity.
      */
-    void onSuccess(Activity callingActivity, IdentityProvider provider);
+    void onSuccess(IdentityProvider provider);
 
     /**
      * User cancelled signing in with a provider on the sign-in activity.
      * Note: The user is still on the sign-in activity when this call is made.
      * @param provider the provider the user canceled with.
      */
-    void onIntermediateProviderCancel(Activity callingActivity, IdentityProvider provider);
+    void onIntermediateProviderCancel(IdentityProvider provider);
 
     /**
      * User encountered an error when attempting to sign-in with a provider.
@@ -44,12 +42,12 @@
      * @param provider the provider the user attempted to sign-in with that encountered an error.
      * @param ex the exception that occurred.
      */
-    void onIntermediateProviderError(Activity callingActivity, IdentityProvider provider, Exception ex);
+    void onIntermediateProviderError(IdentityProvider provider, Exception ex);
 
     /**
      * User pressed back from the sign-in Activity.
      *
      * @return true if the activity should be finished, otherwise false.
      */
-    boolean onCancel(Activity callingActivity);
+    boolean onCancel();
 }
