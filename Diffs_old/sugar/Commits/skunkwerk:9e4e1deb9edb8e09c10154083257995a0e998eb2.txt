diff --git a/library/.settings/org.eclipse.jdt.core.prefs b/library/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 00000000..b080d2dd
--- /dev/null
+++ b/library/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,4 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
+org.eclipse.jdt.core.compiler.compliance=1.6
+org.eclipse.jdt.core.compiler.source=1.6
diff --git a/library/project.properties b/library/project.properties
index 05d02d38..ab1e121b 100644
--- a/library/project.properties
+++ b/library/project.properties
@@ -1,3 +1,3 @@
 android.library=true
 # Project target.
-target=android-15
+target=Google Inc.:Google APIs x86:19
diff --git a/library/src/com/orm/ORMProvider.java b/library/src/com/orm/ORMProvider.java
new file mode 100644
index 00000000..925bf2ad
--- /dev/null
+++ b/library/src/com/orm/ORMProvider.java
@@ -0,0 +1,143 @@
+package com.orm;
+
+import java.util.Iterator;
+import java.util.List;
+
+import android.content.ContentProvider;
+import android.content.ContentValues;
+import android.content.ContentUris;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.net.Uri;
+import android.database.sqlite.SQLiteDatabase;
+
+import com.orm.Database;
+import com.orm.SugarApp;
+import com.orm.SugarDb;
+
+public class ORMProvider extends ContentProvider
+{
+	/*
+	 * All of these methods except onCreate() can be called by multiple threads at once, so they must be thread-safe
+	 */
+	
+	@Override
+	public boolean onCreate()
+	{
+		//The Android system calls onCreate() when it starts up the provider. 
+		//You should perform only fast-running initialization tasks in this method, and defer database creation and data loading until the provider actually receives a request for the data
+		return false;
+	}
+	
+	static final String PROVIDER_NAME = "app.unifi.provider";
+	static final String URL = "content://" + PROVIDER_NAME + "/router";
+	static public final Uri CONTENT_URI = Uri.parse(URL);
+	
+	static final int ROUTER = 1;
+	static final int ROUTER_ID = 2;
+	
+	static final UriMatcher uriMatcher;
+	static
+	{
+	      uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
+	      uriMatcher.addURI(PROVIDER_NAME, "router", ROUTER);
+	      uriMatcher.addURI(PROVIDER_NAME, "router/#", ROUTER_ID);
+	}
+	
+	@Override
+	public int delete(Uri uri, String selection, String[] selectionArgs)
+	{
+		//Use the arguments to select the table and the rows to delete. Return the number of rows deleted.
+		//find the row(s) to delete first
+		//then delete them
+		//content://contacts/people/22 and the implementation is responsible for parsing the record number (22) when creating a SQL statement
+		//Uri contains the table and potentially the row id to delete
+		//selection contains any filters, like: WHERE col = value
+		//selectionArgs replace ? placeholders in the selection clause
+		//for now, just use the Uri
+		//List<Router> search_results = Router.find(Router.class, "ssid = ?", "\"InfoScout\"");
+		// UnsupportedOperationException ()
+		int count = 0;
+		switch (uriMatcher.match(uri))
+		{
+	      case ROUTER:
+	    	 Router.deleteAll(Router.class);
+	         break;
+	      case ROUTER_ID:
+	    	  String param = uri.getPathSegments().get(1);
+	    	  Long id = Long.parseLong(param);
+	    	  Router router = Router.findById(Router.class, id);
+	  		  router.delete();
+		}		
+		return count;
+	}
+
+	@Override
+	public String getType(Uri uri)
+	{
+		//Return the MIME type corresponding to a content URI
+		switch (uriMatcher.match(uri))
+		{
+	      /**
+	       * Get all router records 
+	       */
+	      case ROUTER:
+	         return "vnd.android.cursor.dir/vnd.net.akbars.unifi.router";
+	      /** 
+	       * Get a particular router
+	       */
+	      case ROUTER_ID:
+	         return "vnd.android.cursor.item/vnd.net.akbars.unifi.router";
+	      default:
+	         throw new IllegalArgumentException("Unsupported URI: " + uri);
+	    }
+	}
+
+	@Override
+	public Uri insert(Uri uri, ContentValues values)
+	{
+		//Return a content URI for the newly-inserted row
+		//getAsString returns the value or null if the value is missing or cannot be converted
+		String ssid = values.getAsString("ssid");
+		String bssid = values.getAsString("bssid");
+		Router new_router = new Router(getContext(), ssid, bssid);
+		new_router.save();
+		return null;
+	}
+
+	@Override
+	public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)
+	{
+		/* Uri maps to the table in the provider named table_name
+		 * projection is an array of columns that should be included for each row retrieved.
+		 * selection specifies the criteria for selecting rows
+		 * Selection arguments replace ? placeholders in the selection clause
+		 * sortOrder specifies the order in which rows appear in the returned Cursor
+		 */
+		Cursor cursor = null;
+		switch (uriMatcher.match(uri))
+		{
+	      case ROUTER:
+	    	  List<Router> routers = Router.find(Router.class, selection, selectionArgs);
+	    	  String[] whereArgs;
+	    	  Iterator<Router> it = Router.findAsIterator(Router.class, selection, selectionArgs);
+	    	  //cursor = Router.findAsCursor(Router.class, selection, selectionArgs);
+	    	  return cursor;
+		case ROUTER_ID:
+	    	  String param = uri.getPathSegments().get(1);
+	    	  String[] params = {param};
+	    	  //cursor = Router.findAsCursor(Router.class, "WHERE id = ?", params);
+	    	  return cursor;
+		default:
+	         throw new IllegalArgumentException("Unknown URI " + uri);
+	    }
+	}
+
+	@Override
+	public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)
+	{
+		//UPDATE Router SET(key=value) WHERE column = ?, selectionArgs
+		return 0;
+	}
+
+}
\ No newline at end of file
diff --git a/library/src/com/orm/SugarDb.java b/library/src/com/orm/SugarDb.java
index 0f859afc..8e4ef9e8 100644
--- a/library/src/com/orm/SugarDb.java
+++ b/library/src/com/orm/SugarDb.java
@@ -20,16 +20,18 @@
 import static com.orm.SugarConfig.getDatabaseVersion;
 import static com.orm.SugarConfig.getDebugEnabled;
 
-public class SugarDb extends SQLiteOpenHelper {
+public class SugarDb extends SQLiteOpenHelper
+{
     private Context context;
 
-    public SugarDb(Context context) {
+    public SugarDb(Context context)
+    {
         super(context, SugarConfig.getDatabaseName(context), new SugarCursorFactory(getDebugEnabled(context)), getDatabaseVersion(context));
         this.context = context;
-
     }
 
-    private <T extends SugarRecord<?>> List<T> getDomainClasses(Context context) {
+    private <T extends SugarRecord<?>> List<T> getDomainClasses(Context context)
+    {
         List<T> domainClasses = new ArrayList<T>();
         try {
             Enumeration<?> allClasses = getAllClasses(context);
@@ -53,7 +55,8 @@ public SugarDb(Context context) {
     }
 
     @SuppressWarnings("unchecked")
-    private <T extends SugarRecord<?>> T getDomainClass(String className, Context context) {
+    private <T extends SugarRecord<?>> T getDomainClass(String className, Context context)
+    {
         Log.i("Sugar", "domain class");
         Class<?> discoveredClass = null;
         try {
@@ -84,30 +87,35 @@ public SugarDb(Context context) {
 
     }
 
-    private Enumeration<?> getAllClasses(Context context) throws PackageManager.NameNotFoundException, IOException {
+    private Enumeration<?> getAllClasses(Context context) throws PackageManager.NameNotFoundException, IOException
+    {
         String path = getSourcePath(context);
         DexFile dexfile = new DexFile(path);
         return dexfile.entries();
     }
 
-    private String getSourcePath(Context context) throws PackageManager.NameNotFoundException {
+    private String getSourcePath(Context context) throws PackageManager.NameNotFoundException
+    {
         return context.getPackageManager().getApplicationInfo(context.getPackageName(), 0).sourceDir;
     }
 
     @Override
-    public void onCreate(SQLiteDatabase sqLiteDatabase) {
+    public void onCreate(SQLiteDatabase sqLiteDatabase)
+    {
         Log.i("Sugar", "on create");
         createDatabase(sqLiteDatabase);
     }
 
-    private <T extends SugarRecord<?>> void createDatabase(SQLiteDatabase sqLiteDatabase) {
+    private <T extends SugarRecord<?>> void createDatabase(SQLiteDatabase sqLiteDatabase)
+    {
         List<T> domainClasses = getDomainClasses(context);
         for (T domain : domainClasses) {
             createTable(domain, sqLiteDatabase);
         }
     }
 
-    private <T extends SugarRecord<?>> void createTable(T table, SQLiteDatabase sqLiteDatabase) {
+    private <T extends SugarRecord<?>> void createTable(T table, SQLiteDatabase sqLiteDatabase)
+    {
         Log.i("Sugar", "create table");
         List<Field> fields = table.getTableFields();
         StringBuilder sb = new StringBuilder("CREATE TABLE ").append(table.getSqlName()).append(
@@ -134,7 +142,8 @@ public void onCreate(SQLiteDatabase sqLiteDatabase) {
     }
 
     @Override
-    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
+    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion)
+    {
         Log.i("Sugar", "upgrading sugar");
         // check if some tables are to be created
         doUpgrade(sqLiteDatabase);
@@ -148,7 +157,8 @@ public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVers
     /**
      * Create the tables that do not exist.
      */
-    private <T extends SugarRecord<?>> void doUpgrade(SQLiteDatabase sqLiteDatabase) {
+    private <T extends SugarRecord<?>> void doUpgrade(SQLiteDatabase sqLiteDatabase)
+    {
         List<T> domainClasses = getDomainClasses(context);
         for (T domain : domainClasses) {
             try {// we try to do a select, if fails then (?) there isn't the table
@@ -160,14 +170,16 @@ public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVers
         }
     }
 
-    private <T extends SugarRecord<?>> void deleteTables(SQLiteDatabase sqLiteDatabase) {
+    private <T extends SugarRecord<?>> void deleteTables(SQLiteDatabase sqLiteDatabase)
+    {
         List<T> tables = getDomainClasses(this.context);
         for (T table : tables) {
             sqLiteDatabase.execSQL("DROP TABLE IF EXISTS " + table.getSqlName());
         }
     }
 
-    private boolean executeSugarUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+    private boolean executeSugarUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)
+    {
 
         boolean isSuccess = false;
         try {
@@ -194,7 +206,8 @@ private boolean executeSugarUpgrade(SQLiteDatabase db, int oldVersion, int newVe
         return isSuccess;
     }
 
-    private void executeScript(SQLiteDatabase db, String file) {
+    private void executeScript(SQLiteDatabase db, String file)
+    {
         try {
             InputStream is = this.context.getAssets().open("sugar_upgrades/" + file);
             BufferedReader reader = new BufferedReader(new InputStreamReader(is));
diff --git a/library/src/com/orm/SugarRecord.java b/library/src/com/orm/SugarRecord.java
index da414a66..e60215c2 100644
--- a/library/src/com/orm/SugarRecord.java
+++ b/library/src/com/orm/SugarRecord.java
@@ -18,8 +18,10 @@
 import java.util.*;
 
 import static com.orm.SugarApp.getSugarContext;
+import com.orm.ORMProvider;
 
-public class SugarRecord<T>{
+public class SugarRecord<T>
+{
 
     @Ignore
     String tableName = getSqlName();
