diff --git a/library/src/main/java/com/orm/SugarRecord.java b/library/src/main/java/com/orm/SugarRecord.java
index d15583f1..30a2d8ed 100644
--- a/library/src/main/java/com/orm/SugarRecord.java
+++ b/library/src/main/java/com/orm/SugarRecord.java
@@ -8,22 +8,30 @@
 import android.text.TextUtils;
 import android.util.Log;
 
+import com.google.common.collect.ArrayListMultimap;
+import com.google.common.collect.ListMultimap;
+
 import com.orm.dsl.Relationship;
 import com.orm.dsl.Table;
 import com.orm.util.NamingHelper;
 import com.orm.util.ReflectionUtil;
 import com.orm.util.QueryBuilder;
 
+import java.lang.Object;
+import java.lang.Override;
 import java.lang.String;
 import java.lang.StringBuffer;
 import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.NoSuchElementException;
+import java.util.Set;
+
 
 import static com.orm.SugarContext.getSugarContext;
 
@@ -53,7 +61,7 @@
             sqLiteDatabase.beginTransaction();
             sqLiteDatabase.setLockingEnabled(false);
             for (T object: objects) {
-                save(object);
+                save(getSugarContext().getSugarDb().getDB(), object);
             }
             sqLiteDatabase.setTransactionSuccessful();
         } catch (Exception e) {
@@ -292,10 +300,26 @@ private static void appendClause(StringBuilder s, String name, String clause) {
     }
 
     public static long save(Object object) {
+
+        Set<SugarRecord> recordsToSave = new HashSet<SugarRecord>();
+        ListMultimap<String, ContentValues> joinTables = ArrayListMultimap.create();
+        ReflectionUtil.getRecordsToSave(object, recordsToSave, joinTables);
+
+        if(recordsToSave != null && !recordsToSave.isEmpty()) {
+            saveInTx(recordsToSave);
+
+            if(joinTables != null) {
+                for(String tableName: joinTables.keySet()) {
+                    saveJoinTableList(getSugarContext().getSugarDb().getDB(), joinTables.get(tableName), tableName);
+                }
+            }
+        }
+
+
         return save(getSugarContext().getSugarDb().getDB(), object);
     }
 
-    static void saveJoinTable(SQLiteDatabase db, List<ContentValues> relationshipList, String joinTableName) {
+    static void saveJoinTableList(SQLiteDatabase db, List<ContentValues> relationshipList, String joinTableName) {
 
         for(ContentValues values: relationshipList) {
 
@@ -308,21 +332,30 @@ static void saveJoinTable(SQLiteDatabase db, List<ContentValues> relationshipLis
         }
     }
 
+    static void saveJoinTable(SQLiteDatabase db, ContentValues values, String joinTableName) {
+
+        //If record already exists then ignore
+        long id = db.insertWithOnConflict(joinTableName, null, values,
+                SQLiteDatabase.CONFLICT_IGNORE);
+
+        Log.i("Sugar", "Inserted Join table record for " + joinTableName + ".");
+
+    }
+
+
     static long save(SQLiteDatabase db, Object object) {
         Map<Object, Long> entitiesMap = getSugarContext().getEntitiesMap();
+
         List<Field> columns = ReflectionUtil.getTableFields(object.getClass());
         ContentValues values = new ContentValues(columns.size());
         Field idField = null;
         for (Field column : columns) {
             List<SugarRecord> children = new ArrayList<SugarRecord>();
-            List<ContentValues> relationshipList = ReflectionUtil.addFieldValueToColumn(values, column, object, entitiesMap);
+            ReflectionUtil.addFieldValueToColumn(values, column, object, entitiesMap);
             if (column.getName().equals("id")) {
                 idField = column;
             }
 
-            if(relationshipList != null && !relationshipList.isEmpty()) {
-                saveJoinTable(db, relationshipList, column.getAnnotation(Relationship.class).joinTable());
-            }
         }
 
         boolean isSugarEntity = isSugarEntity(object.getClass());
@@ -424,6 +457,21 @@ public static boolean delete(Object object) {
     }
 
     public long save() {
+
+        Set<SugarRecord> recordsToSave = new HashSet<SugarRecord>();
+        ListMultimap<String, ContentValues> joinTables = ArrayListMultimap.create();
+        ReflectionUtil.getRecordsToSave(this, recordsToSave, joinTables);
+
+        if(recordsToSave != null && !recordsToSave.isEmpty()) {
+            saveInTx(recordsToSave);
+
+            if(joinTables != null) {
+                for(String tableName: joinTables.keySet()) {
+                    saveJoinTableList(getSugarContext().getSugarDb().getDB(), joinTables.get(tableName), tableName);
+                }
+            }
+        }
+
         return save(getSugarContext().getSugarDb().getDB(), this);
     }
 
@@ -497,5 +545,21 @@ public Cursor getCursor() {
             return cursor;
         }
     }
+
+    @Override
+    /**
+     * Objects are equal if their IDs are equal and their class type is equal
+     */
+    public boolean equals(Object object) {
+        if(object == null) {
+            return false;
+        }
+
+        if(object.getClass().equals(this.getClass()) && ((SugarRecord) object).getId().equals(this.getId())) {
+            return true;
+        } else {
+            return false;
+        }
+    }
     
 }
diff --git a/library/src/main/java/com/orm/dsl/Relationship.java b/library/src/main/java/com/orm/dsl/Relationship.java
index 82cb7633..23ab20b7 100644
--- a/library/src/main/java/com/orm/dsl/Relationship.java
+++ b/library/src/main/java/com/orm/dsl/Relationship.java
@@ -17,5 +17,6 @@
     String joinTable();
     String objectIdName();
     String refObjectIdName();
+    boolean cascade() default true;
 
 }
diff --git a/library/src/main/java/com/orm/util/ReflectionUtil.java b/library/src/main/java/com/orm/util/ReflectionUtil.java
index 4ad4555f..e62ae5b0 100644
--- a/library/src/main/java/com/orm/util/ReflectionUtil.java
+++ b/library/src/main/java/com/orm/util/ReflectionUtil.java
@@ -4,6 +4,7 @@
 import android.content.Context;
 import android.content.pm.PackageManager;
 import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
 import android.util.Log;
 
 import com.orm.SugarRecord;
@@ -24,12 +25,122 @@
 import java.sql.Timestamp;
 import java.util.*;
 import java.util.Collection;
+import java.util.HashSet;
+
+import com.google.common.collect.ArrayListMultimap;
+import com.google.common.collect.ListMultimap;
 
 import dalvik.system.DexFile;
 
 public class ReflectionUtil {
 
+    public static Set<SugarRecord> getRecordsToSave(Object object, Set<SugarRecord> recordsToSave, ListMultimap<String, ContentValues> joinTables) {
+        Class table = object.getClass();
+
+        Log.d("Sugar", "Fetching properties");
+        List<Field> typeFields = new ArrayList<Field>();
+
+        getAllFields(typeFields, table);
+
+        for (Field field : typeFields) {
+            if(field.isAnnotationPresent(Relationship.class) && ((Relationship) field.getAnnotation(Relationship.class)).cascade()) {
+
+                field.setAccessible(true);
+                Class<?> columnType = field.getType();
+                Object columnValue = null;
+
+                try {
+                    columnValue = field.get(object);
+                } catch(IllegalAccessException e) {
+                    e.printStackTrace();
+                }
+
+                Relationship relationship = field.getAnnotation(Relationship.class);
+
+                if (Collection.class.isAssignableFrom(columnType)) {
+
+                    //Explicitly invoke getter instead of grabbing value from field to be safe that we don't omit getter logic
+                    //Try get{fieldName}
+                    try {
+                        Method getter = table.getMethod("get" + field.getName().substring(0, 1).toUpperCase() + field.getName().substring(1));
+                        columnValue = getter.invoke(object, (Object[]) null);
+
+                        //Try is{fieldName}
+                    } catch (Exception e) {
+                        try {
+                            Method getter = table.getMethod("is" + field.getName().substring(0, 1).toUpperCase() + field.getName().substring(1));
+                            columnValue = getter.invoke(object, (Object[]) null);
+                            //No getter available. Get from field
+                        } catch (Exception e1) {
+                            //DO NOTHING: columnValue already = columnValue
+                        }
+                    }
+
+                    if (columnValue != null) {
+                        for (Object child : (Collection) columnValue) {
+                            //They should be
+                            if (SugarRecord.isSugarEntity(child.getClass())) {
+                                boolean success = recordsToSave.add((SugarRecord) child);
+
+                                //If not then it means it is a bidirectional relationship and we don't want it showing up twice
+                                if(success) {
+
+                                    ContentValues contentValues = new ContentValues(2);
+                                    contentValues.put(relationship.objectIdName(), ((SugarRecord) object).getId());
+                                    contentValues.put(relationship.refObjectIdName(), ((SugarRecord) child).getId());
+
+                                    joinTables.put(relationship.joinTable(), contentValues);
+
+                                    ReflectionUtil.getRecordsToSave(child, recordsToSave, joinTables);
+                                }
+                            } else {
+                                break;
+                            }
+                        }
+                    }
+                } else if(columnValue != null && SugarRecord.isSugarEntity(columnValue.getClass())) {
+
+
+                    //Explicitly invoke getter instead of grabbing value from field to be safe that we don't omit getter logic
+                    //Try get{fieldName}
+                    try {
+                        Method getter = object.getClass().getMethod("get" + field.getName().substring(0, 1).toUpperCase() + field.getName().substring(1));
+                        columnValue = getter.invoke(object, (Object[]) null);
+
+                        //Try is{fieldName}
+                    } catch (Exception e) {
+                        try {
+                            Method getter = object.getClass().getMethod("is" + field.getName().substring(0, 1).toUpperCase() + field.getName().substring(1));
+                            columnValue = getter.invoke(object, (Object[]) null);
+                            //No getter available. Get from field
+                        } catch (Exception e1) {
+                            //DO NOTHING: columnValue already = columnValue
+                        }
+                    }
+
+                    if(columnValue != null) {
+                        boolean success = recordsToSave.add((SugarRecord) columnValue);
+
+                        //If not then it means it is a bidirectional relationship and we don't want it showing up twice
+                        if(success) {
+
+                            ContentValues contentValues = new ContentValues(2);
+                            contentValues.put(relationship.objectIdName(), ((SugarRecord) object).getId());
+                            contentValues.put(relationship.refObjectIdName(), ((SugarRecord) columnValue).getId());
+
+                            joinTables.put(relationship.joinTable(), contentValues);
+                            ReflectionUtil.getRecordsToSave(columnValue, recordsToSave, joinTables);
+                        }
+                    }
+                }
+            }
+        }
+
+        return recordsToSave;
+    }
+
     public static List<Field> getTableFields(Class table) {
+
         List<Field> fieldList = SugarConfig.getFields(table);
         if (fieldList != null) return fieldList;
 
@@ -164,7 +275,6 @@
                                     contentValues.put(relationship.refObjectIdName(), ((SugarRecord) child).getId());
 
                                     relationshipList.add(contentValues);
-                                    ((SugarRecord) child).save();
                                 } else {
                                     break;
                                 }
@@ -196,7 +306,6 @@
                             contentValues.put(relationship.refObjectIdName(), ((SugarRecord) object).getId());
 
                             relationshipList.add(contentValues);
-                            ((SugarRecord) columnValue).save();
                         }
                     }
 
diff --git a/settings.gradle b/settings.gradle
index 507c9f4a..19a273d5 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,2 +1,2 @@
 include ':library'
-include ':example'
+include ':example'
\ No newline at end of file
diff --git a/sugarOrm.iml b/sugarOrm.iml
deleted file mode 100644
index e1022832..00000000
--- a/sugarOrm.iml
+++ /dev/null
@@ -1,21 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id=":sugarOrm" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.satyan" external.system.module.version="1.4" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="java-gradle" name="Java-Gradle">
-      <configuration>
-        <option name="BUILD_FOLDER_PATH" value="$MODULE_DIR$/build" />
-        <option name="BUILDABLE" value="false" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
-    <output-test url="file://$MODULE_DIR$/build/intermediates/classes/androidTest/debug" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
-    </content>
-    <orderEntry type="jdk" jdkName="Android API 22 Platform" jdkType="Android SDK" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
\ No newline at end of file
