diff --git a/.DS_Store b/.DS_Store
new file mode 100644
index 00000000..9b8c5479
Binary files /dev/null and b/.DS_Store differ
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 00000000..db652ef6
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,32 @@
+apply plugin: 'com.android.library'
+//apply from: '../maven_push.gradle'
+
+android {
+    compileSdkVersion 21
+    buildToolsVersion "21.1.2"
+
+    defaultConfig {
+        minSdkVersion 9
+        targetSdkVersion 21
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+        }
+    }
+}
+
+dependencies {
+    compile 'com.android.support:support-v4:21.0.3'
+    compile 'com.google.guava:guava:18.0'
+    testCompile 'junit:junit:4.12'
+}
+
+task libraryJar(type: Jar) {
+    dependsOn assembleRelease
+    from android.sourceSets.main.java.srcDirs,
+         ['build/intermediates/classes/release/'] // Add the release classes into the jar
+    baseName 'sugar'
+}
+
diff --git a/build.properties b/build.properties
new file mode 100644
index 00000000..b5b95df0
--- /dev/null
+++ b/build.properties
@@ -0,0 +1,3 @@
+jdk.home.1.6=$JAVA_HOME
+android.home=/Users/ADMIN/Downloads/android-sdk-macosx/platforms/android-17/android.jar
+android.travis.home=/usr/local/android-sdk/platforms/android-17/android.jar
diff --git a/build.xml b/build.xml
new file mode 100644
index 00000000..927b3904
--- /dev/null
+++ b/build.xml
@@ -0,0 +1,69 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="sugar" default="all">
+
+  <property file="build.properties"/>
+
+  <patternset id="ignored.files">
+    <exclude name="**/.git/**"/>
+    <exclude name="**/*~/**"/>
+  </patternset>
+  <patternset id="library.patterns">
+    <include name="*.jar"/>
+  </patternset>
+
+  <property name="jdk.bin.1.6" value="${jdk.home.1.6}/bin"/>
+  <dirname property="module.sugar.basedir" file="${ant.file}"/>
+
+  <property name="sugar.output.dir" value="${module.sugar.basedir}/out/"/>
+
+  <path id="sugar.classpath">
+    <pathelement location="${android.home}"/>
+  </path>
+
+  <path id="sugar.travis.classpath">
+    <pathelement location="${android.travis.home}"/>
+  </path>
+
+  <patternset id="excluded.from.compilation.sugar">
+    <patternset refid="ignored.files"/>
+  </patternset>
+
+  <path id="sugar.module.sourcepath">
+    <dirset dir="${module.sugar.basedir}">
+      <include name="src"/>
+    </dirset>
+  </path>
+ 
+  <target name="compile" description="Compile module sugar; production classes">
+    <mkdir dir="${sugar.output.dir}"/>
+    <javac destdir="${sugar.output.dir}" fork="false" executable="${jdk.bin.1.6}/javac">
+      <classpath refid="sugar.classpath"/>
+      <src refid="sugar.module.sourcepath"/>
+      <patternset refid="excluded.from.compilation.sugar"/>
+    </javac>
+
+      <jar destfile="${sugar.output.dir}/sugar.jar" basedir="${sugar.output.dir}"/>
+
+  </target>
+
+  <target name="compile-travis" description="Compile module sugar for travis-cl">
+
+    <mkdir dir="${sugar.output.dir}"/>
+    <javac destdir="${sugar.output.dir}" fork="false" executable="${jdk.bin.1.6}/javac">
+      <classpath refid="sugar.travis.classpath"/>
+      <src refid="sugar.module.sourcepath"/>
+      <patternset refid="excluded.from.compilation.sugar"/>
+    </javac>
+
+      <jar destfile="${sugar.output.dir}/sugar.jar" basedir="${sugar.output.dir}"/>
+
+  </target>
+
+  <target name="clean" description="cleanup module">
+    <delete dir="${sugar.output.dir}"/>
+  </target>
+      <patternset refid="excluded.from.compilation.sugar"/>
+  <target name="all" depends="clean, compile" description="build all modules"/>
+  <target name="travis-all" depends="clean, compile-travis" description="build all modules for travis"/>
+  
+</project>
diff --git a/build/.DS_Store b/build/.DS_Store
new file mode 100644
index 00000000..2851ba4f
Binary files /dev/null and b/build/.DS_Store differ
diff --git a/build/generated/source/buildConfig/androidTest/debug/com/orm/dsl/test/BuildConfig.java b/build/generated/source/buildConfig/androidTest/debug/com/orm/dsl/test/BuildConfig.java
new file mode 100644
index 00000000..6bce5bb7
--- /dev/null
+++ b/build/generated/source/buildConfig/androidTest/debug/com/orm/dsl/test/BuildConfig.java
@@ -0,0 +1,13 @@
+/**
+ * Automatically generated file. DO NOT MODIFY
+ */
+package com.orm.dsl.test;
+
+public final class BuildConfig {
+  public static final boolean DEBUG = Boolean.parseBoolean("true");
+  public static final String APPLICATION_ID = "com.orm.dsl.test";
+  public static final String BUILD_TYPE = "debug";
+  public static final String FLAVOR = "";
+  public static final int VERSION_CODE = -1;
+  public static final String VERSION_NAME = "";
+}
diff --git a/build/generated/source/buildConfig/debug/com/orm/dsl/BuildConfig.java b/build/generated/source/buildConfig/debug/com/orm/dsl/BuildConfig.java
new file mode 100644
index 00000000..055fdb15
--- /dev/null
+++ b/build/generated/source/buildConfig/debug/com/orm/dsl/BuildConfig.java
@@ -0,0 +1,13 @@
+/**
+ * Automatically generated file. DO NOT MODIFY
+ */
+package com.orm.dsl;
+
+public final class BuildConfig {
+  public static final boolean DEBUG = Boolean.parseBoolean("true");
+  public static final String APPLICATION_ID = "com.orm.dsl";
+  public static final String BUILD_TYPE = "debug";
+  public static final String FLAVOR = "";
+  public static final int VERSION_CODE = 1;
+  public static final String VERSION_NAME = "";
+}
diff --git a/build/generated/source/buildConfig/release/com/orm/dsl/BuildConfig.java b/build/generated/source/buildConfig/release/com/orm/dsl/BuildConfig.java
new file mode 100644
index 00000000..f7e7d966
--- /dev/null
+++ b/build/generated/source/buildConfig/release/com/orm/dsl/BuildConfig.java
@@ -0,0 +1,13 @@
+/**
+ * Automatically generated file. DO NOT MODIFY
+ */
+package com.orm.dsl;
+
+public final class BuildConfig {
+  public static final boolean DEBUG = false;
+  public static final String APPLICATION_ID = "com.orm.dsl";
+  public static final String BUILD_TYPE = "release";
+  public static final String FLAVOR = "";
+  public static final int VERSION_CODE = 1;
+  public static final String VERSION_NAME = "";
+}
diff --git a/build/intermediates/bundles/debug/AndroidManifest.xml b/build/intermediates/bundles/debug/AndroidManifest.xml
new file mode 100644
index 00000000..351b7526
--- /dev/null
+++ b/build/intermediates/bundles/debug/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.orm.dsl"
+    android:versionCode="1"
+    android:versionName="1.3.1" >
+
+    <uses-sdk
+        android:minSdkVersion="9"
+        android:targetSdkVersion="21" />
+
+</manifest>
\ No newline at end of file
diff --git a/build/intermediates/bundles/debug/aapt/AndroidManifest.xml b/build/intermediates/bundles/debug/aapt/AndroidManifest.xml
new file mode 100644
index 00000000..351b7526
--- /dev/null
+++ b/build/intermediates/bundles/debug/aapt/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.orm.dsl"
+    android:versionCode="1"
+    android:versionName="1.3.1" >
+
+    <uses-sdk
+        android:minSdkVersion="9"
+        android:targetSdkVersion="21" />
+
+</manifest>
\ No newline at end of file
diff --git a/build/intermediates/bundles/debug/classes.jar b/build/intermediates/bundles/debug/classes.jar
new file mode 100644
index 00000000..20b5c4e0
Binary files /dev/null and b/build/intermediates/bundles/debug/classes.jar differ
diff --git a/build/intermediates/bundles/release/AndroidManifest.xml b/build/intermediates/bundles/release/AndroidManifest.xml
new file mode 100644
index 00000000..351b7526
--- /dev/null
+++ b/build/intermediates/bundles/release/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.orm.dsl"
+    android:versionCode="1"
+    android:versionName="1.3.1" >
+
+    <uses-sdk
+        android:minSdkVersion="9"
+        android:targetSdkVersion="21" />
+
+</manifest>
\ No newline at end of file
diff --git a/build/intermediates/bundles/release/aapt/AndroidManifest.xml b/build/intermediates/bundles/release/aapt/AndroidManifest.xml
new file mode 100644
index 00000000..351b7526
--- /dev/null
+++ b/build/intermediates/bundles/release/aapt/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.orm.dsl"
+    android:versionCode="1"
+    android:versionName="1.3.1" >
+
+    <uses-sdk
+        android:minSdkVersion="9"
+        android:targetSdkVersion="21" />
+
+</manifest>
\ No newline at end of file
diff --git a/build/intermediates/bundles/release/classes.jar b/build/intermediates/bundles/release/classes.jar
new file mode 100644
index 00000000..1abe9015
Binary files /dev/null and b/build/intermediates/bundles/release/classes.jar differ
diff --git a/build/intermediates/classes/androidTest/debug/com/orm/dsl/test/BuildConfig.class b/build/intermediates/classes/androidTest/debug/com/orm/dsl/test/BuildConfig.class
new file mode 100644
index 00000000..4b2e09b9
Binary files /dev/null and b/build/intermediates/classes/androidTest/debug/com/orm/dsl/test/BuildConfig.class differ
diff --git a/build/intermediates/classes/debug/com/orm/SchemaGenerator.class b/build/intermediates/classes/debug/com/orm/SchemaGenerator.class
new file mode 100644
index 00000000..545e02b6
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/SchemaGenerator.class differ
diff --git a/build/intermediates/classes/debug/com/orm/SugarApp.class b/build/intermediates/classes/debug/com/orm/SugarApp.class
new file mode 100644
index 00000000..7c7d4367
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/SugarApp.class differ
diff --git a/build/intermediates/classes/debug/com/orm/SugarContext.class b/build/intermediates/classes/debug/com/orm/SugarContext.class
new file mode 100644
index 00000000..f6046480
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/SugarContext.class differ
diff --git a/build/intermediates/classes/debug/com/orm/SugarDb.class b/build/intermediates/classes/debug/com/orm/SugarDb.class
new file mode 100644
index 00000000..75d98bbd
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/SugarDb.class differ
diff --git a/build/intermediates/classes/debug/com/orm/SugarRecord$CursorIterator.class b/build/intermediates/classes/debug/com/orm/SugarRecord$CursorIterator.class
new file mode 100644
index 00000000..1cbf00a7
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/SugarRecord$CursorIterator.class differ
diff --git a/build/intermediates/classes/debug/com/orm/SugarRecord.class b/build/intermediates/classes/debug/com/orm/SugarRecord.class
new file mode 100644
index 00000000..83a4f73d
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/SugarRecord.class differ
diff --git a/build/intermediates/classes/debug/com/orm/SugarTransactionHelper$Callback.class b/build/intermediates/classes/debug/com/orm/SugarTransactionHelper$Callback.class
new file mode 100644
index 00000000..b94cf769
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/SugarTransactionHelper$Callback.class differ
diff --git a/build/intermediates/classes/debug/com/orm/SugarTransactionHelper.class b/build/intermediates/classes/debug/com/orm/SugarTransactionHelper.class
new file mode 100644
index 00000000..76656f29
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/SugarTransactionHelper.class differ
diff --git a/build/intermediates/classes/debug/com/orm/dsl/BuildConfig.class b/build/intermediates/classes/debug/com/orm/dsl/BuildConfig.class
new file mode 100644
index 00000000..e07f16b0
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/dsl/BuildConfig.class differ
diff --git a/build/intermediates/classes/debug/com/orm/dsl/Column.class b/build/intermediates/classes/debug/com/orm/dsl/Column.class
new file mode 100644
index 00000000..888089b1
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/dsl/Column.class differ
diff --git a/build/intermediates/classes/debug/com/orm/dsl/Ignore.class b/build/intermediates/classes/debug/com/orm/dsl/Ignore.class
new file mode 100644
index 00000000..cf70fb06
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/dsl/Ignore.class differ
diff --git a/build/intermediates/classes/debug/com/orm/dsl/NotNull.class b/build/intermediates/classes/debug/com/orm/dsl/NotNull.class
new file mode 100644
index 00000000..7655fbc4
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/dsl/NotNull.class differ
diff --git a/build/intermediates/classes/debug/com/orm/dsl/Table.class b/build/intermediates/classes/debug/com/orm/dsl/Table.class
new file mode 100644
index 00000000..8831d7bc
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/dsl/Table.class differ
diff --git a/build/intermediates/classes/debug/com/orm/dsl/Unique.class b/build/intermediates/classes/debug/com/orm/dsl/Unique.class
new file mode 100644
index 00000000..305b8876
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/dsl/Unique.class differ
diff --git a/build/intermediates/classes/debug/com/orm/query/Condition$Check.class b/build/intermediates/classes/debug/com/orm/query/Condition$Check.class
new file mode 100644
index 00000000..a064a4b6
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/query/Condition$Check.class differ
diff --git a/build/intermediates/classes/debug/com/orm/query/Condition$Type.class b/build/intermediates/classes/debug/com/orm/query/Condition$Type.class
new file mode 100644
index 00000000..d860232b
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/query/Condition$Type.class differ
diff --git a/build/intermediates/classes/debug/com/orm/query/Condition.class b/build/intermediates/classes/debug/com/orm/query/Condition.class
new file mode 100644
index 00000000..6ad6e80d
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/query/Condition.class differ
diff --git a/build/intermediates/classes/debug/com/orm/query/Select.class b/build/intermediates/classes/debug/com/orm/query/Select.class
new file mode 100644
index 00000000..eadb053a
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/query/Select.class differ
diff --git a/build/intermediates/classes/debug/com/orm/util/Collection$Entry.class b/build/intermediates/classes/debug/com/orm/util/Collection$Entry.class
new file mode 100644
index 00000000..54b35125
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/util/Collection$Entry.class differ
diff --git a/build/intermediates/classes/debug/com/orm/util/Collection.class b/build/intermediates/classes/debug/com/orm/util/Collection.class
new file mode 100644
index 00000000..1648f44f
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/util/Collection.class differ
diff --git a/build/intermediates/classes/debug/com/orm/util/ManifestHelper.class b/build/intermediates/classes/debug/com/orm/util/ManifestHelper.class
new file mode 100644
index 00000000..3740ea0a
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/util/ManifestHelper.class differ
diff --git a/build/intermediates/classes/debug/com/orm/util/NamingHelper.class b/build/intermediates/classes/debug/com/orm/util/NamingHelper.class
new file mode 100644
index 00000000..77beedb6
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/util/NamingHelper.class differ
diff --git a/build/intermediates/classes/debug/com/orm/util/NumberComparator.class b/build/intermediates/classes/debug/com/orm/util/NumberComparator.class
new file mode 100644
index 00000000..5552e224
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/util/NumberComparator.class differ
diff --git a/build/intermediates/classes/debug/com/orm/util/QueryBuilder.class b/build/intermediates/classes/debug/com/orm/util/QueryBuilder.class
new file mode 100644
index 00000000..b82fb6cd
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/util/QueryBuilder.class differ
diff --git a/build/intermediates/classes/debug/com/orm/util/ReflectionUtil.class b/build/intermediates/classes/debug/com/orm/util/ReflectionUtil.class
new file mode 100644
index 00000000..866c97e7
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/util/ReflectionUtil.class differ
diff --git a/build/intermediates/classes/debug/com/orm/util/SugarConfig.class b/build/intermediates/classes/debug/com/orm/util/SugarConfig.class
new file mode 100644
index 00000000..cadf2dad
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/util/SugarConfig.class differ
diff --git a/build/intermediates/classes/debug/com/orm/util/SugarCursorFactory.class b/build/intermediates/classes/debug/com/orm/util/SugarCursorFactory.class
new file mode 100644
index 00000000..d09f7ef9
Binary files /dev/null and b/build/intermediates/classes/debug/com/orm/util/SugarCursorFactory.class differ
diff --git a/build/intermediates/classes/release/com/orm/SchemaGenerator.class b/build/intermediates/classes/release/com/orm/SchemaGenerator.class
new file mode 100644
index 00000000..78b83624
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/SchemaGenerator.class differ
diff --git a/build/intermediates/classes/release/com/orm/SugarApp.class b/build/intermediates/classes/release/com/orm/SugarApp.class
new file mode 100644
index 00000000..7c7d4367
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/SugarApp.class differ
diff --git a/build/intermediates/classes/release/com/orm/SugarContext.class b/build/intermediates/classes/release/com/orm/SugarContext.class
new file mode 100644
index 00000000..f6046480
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/SugarContext.class differ
diff --git a/build/intermediates/classes/release/com/orm/SugarDb.class b/build/intermediates/classes/release/com/orm/SugarDb.class
new file mode 100644
index 00000000..75d98bbd
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/SugarDb.class differ
diff --git a/build/intermediates/classes/release/com/orm/SugarRecord$CursorIterator.class b/build/intermediates/classes/release/com/orm/SugarRecord$CursorIterator.class
new file mode 100644
index 00000000..1cbf00a7
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/SugarRecord$CursorIterator.class differ
diff --git a/build/intermediates/classes/release/com/orm/SugarRecord.class b/build/intermediates/classes/release/com/orm/SugarRecord.class
new file mode 100644
index 00000000..83a4f73d
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/SugarRecord.class differ
diff --git a/build/intermediates/classes/release/com/orm/SugarTransactionHelper$Callback.class b/build/intermediates/classes/release/com/orm/SugarTransactionHelper$Callback.class
new file mode 100644
index 00000000..b94cf769
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/SugarTransactionHelper$Callback.class differ
diff --git a/build/intermediates/classes/release/com/orm/SugarTransactionHelper.class b/build/intermediates/classes/release/com/orm/SugarTransactionHelper.class
new file mode 100644
index 00000000..76656f29
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/SugarTransactionHelper.class differ
diff --git a/build/intermediates/classes/release/com/orm/dsl/BuildConfig.class b/build/intermediates/classes/release/com/orm/dsl/BuildConfig.class
new file mode 100644
index 00000000..ec925f59
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/dsl/BuildConfig.class differ
diff --git a/build/intermediates/classes/release/com/orm/dsl/Column.class b/build/intermediates/classes/release/com/orm/dsl/Column.class
new file mode 100644
index 00000000..888089b1
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/dsl/Column.class differ
diff --git a/build/intermediates/classes/release/com/orm/dsl/Ignore.class b/build/intermediates/classes/release/com/orm/dsl/Ignore.class
new file mode 100644
index 00000000..cf70fb06
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/dsl/Ignore.class differ
diff --git a/build/intermediates/classes/release/com/orm/dsl/ManyToMany.class b/build/intermediates/classes/release/com/orm/dsl/ManyToMany.class
new file mode 100644
index 00000000..785fdad7
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/dsl/ManyToMany.class differ
diff --git a/build/intermediates/classes/release/com/orm/dsl/ManyToOne.class b/build/intermediates/classes/release/com/orm/dsl/ManyToOne.class
new file mode 100644
index 00000000..bad6cdf6
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/dsl/ManyToOne.class differ
diff --git a/build/intermediates/classes/release/com/orm/dsl/NotNull.class b/build/intermediates/classes/release/com/orm/dsl/NotNull.class
new file mode 100644
index 00000000..7655fbc4
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/dsl/NotNull.class differ
diff --git a/build/intermediates/classes/release/com/orm/dsl/OneToMany.class b/build/intermediates/classes/release/com/orm/dsl/OneToMany.class
new file mode 100644
index 00000000..256040e6
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/dsl/OneToMany.class differ
diff --git a/build/intermediates/classes/release/com/orm/dsl/OneToOne.class b/build/intermediates/classes/release/com/orm/dsl/OneToOne.class
new file mode 100644
index 00000000..8b1bed8f
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/dsl/OneToOne.class differ
diff --git a/build/intermediates/classes/release/com/orm/dsl/Table.class b/build/intermediates/classes/release/com/orm/dsl/Table.class
new file mode 100644
index 00000000..8831d7bc
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/dsl/Table.class differ
diff --git a/build/intermediates/classes/release/com/orm/dsl/Unique.class b/build/intermediates/classes/release/com/orm/dsl/Unique.class
new file mode 100644
index 00000000..305b8876
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/dsl/Unique.class differ
diff --git a/build/intermediates/classes/release/com/orm/query/Condition$Check.class b/build/intermediates/classes/release/com/orm/query/Condition$Check.class
new file mode 100644
index 00000000..a064a4b6
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/query/Condition$Check.class differ
diff --git a/build/intermediates/classes/release/com/orm/query/Condition$Type.class b/build/intermediates/classes/release/com/orm/query/Condition$Type.class
new file mode 100644
index 00000000..d860232b
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/query/Condition$Type.class differ
diff --git a/build/intermediates/classes/release/com/orm/query/Condition.class b/build/intermediates/classes/release/com/orm/query/Condition.class
new file mode 100644
index 00000000..6ad6e80d
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/query/Condition.class differ
diff --git a/build/intermediates/classes/release/com/orm/query/Select.class b/build/intermediates/classes/release/com/orm/query/Select.class
new file mode 100644
index 00000000..eadb053a
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/query/Select.class differ
diff --git a/build/intermediates/classes/release/com/orm/util/Collection$Entry.class b/build/intermediates/classes/release/com/orm/util/Collection$Entry.class
new file mode 100644
index 00000000..54b35125
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/util/Collection$Entry.class differ
diff --git a/build/intermediates/classes/release/com/orm/util/Collection.class b/build/intermediates/classes/release/com/orm/util/Collection.class
new file mode 100644
index 00000000..1648f44f
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/util/Collection.class differ
diff --git a/build/intermediates/classes/release/com/orm/util/ManifestHelper.class b/build/intermediates/classes/release/com/orm/util/ManifestHelper.class
new file mode 100644
index 00000000..3740ea0a
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/util/ManifestHelper.class differ
diff --git a/build/intermediates/classes/release/com/orm/util/NamingHelper.class b/build/intermediates/classes/release/com/orm/util/NamingHelper.class
new file mode 100644
index 00000000..77beedb6
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/util/NamingHelper.class differ
diff --git a/build/intermediates/classes/release/com/orm/util/NumberComparator.class b/build/intermediates/classes/release/com/orm/util/NumberComparator.class
new file mode 100644
index 00000000..5552e224
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/util/NumberComparator.class differ
diff --git a/build/intermediates/classes/release/com/orm/util/QueryBuilder.class b/build/intermediates/classes/release/com/orm/util/QueryBuilder.class
new file mode 100644
index 00000000..b82fb6cd
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/util/QueryBuilder.class differ
diff --git a/build/intermediates/classes/release/com/orm/util/ReflectionUtil.class b/build/intermediates/classes/release/com/orm/util/ReflectionUtil.class
new file mode 100644
index 00000000..866c97e7
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/util/ReflectionUtil.class differ
diff --git a/build/intermediates/classes/release/com/orm/util/SugarConfig.class b/build/intermediates/classes/release/com/orm/util/SugarConfig.class
new file mode 100644
index 00000000..cadf2dad
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/util/SugarConfig.class differ
diff --git a/build/intermediates/classes/release/com/orm/util/SugarCursorFactory.class b/build/intermediates/classes/release/com/orm/util/SugarCursorFactory.class
new file mode 100644
index 00000000..d09f7ef9
Binary files /dev/null and b/build/intermediates/classes/release/com/orm/util/SugarCursorFactory.class differ
diff --git a/build/intermediates/exploded-aar/com.android.support/support-v4/21.0.3/AndroidManifest.xml b/build/intermediates/exploded-aar/com.android.support/support-v4/21.0.3/AndroidManifest.xml
new file mode 100644
index 00000000..2722c91f
--- /dev/null
+++ b/build/intermediates/exploded-aar/com.android.support/support-v4/21.0.3/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<!-- Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+--><manifest xmlns:android="http://schemas.android.com/apk/res/android" package="android.support.v4">
+    <uses-sdk android:minSdkVersion="4"/>
+    <application/>
+</manifest>
diff --git a/build/intermediates/exploded-aar/com.android.support/support-v4/21.0.3/aidl/android/support/v4/app/INotificationSideChannel.aidl b/build/intermediates/exploded-aar/com.android.support/support-v4/21.0.3/aidl/android/support/v4/app/INotificationSideChannel.aidl
new file mode 100644
index 00000000..9df1577e
--- /dev/null
+++ b/build/intermediates/exploded-aar/com.android.support/support-v4/21.0.3/aidl/android/support/v4/app/INotificationSideChannel.aidl
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.support.v4.app;
+
+import android.app.Notification;
+
+/**
+ * Interface used for delivering notifications via a side channel that bypasses
+ * the NotificationManagerService.
+ *
+ * @hide
+ */
+oneway interface INotificationSideChannel {
+    /**
+     * Send an ambient notification to the service.
+     */
+    void notify(String packageName, int id, String tag, in Notification notification);
+
+    /**
+     * Cancel an already-notified notification.
+     */
+    void cancel(String packageName, int id, String tag);
+
+    /**
+     * Cancel all notifications for the given package.
+     */
+    void cancelAll(String packageName);
+}
diff --git a/build/intermediates/exploded-aar/com.android.support/support-v4/21.0.3/jars/classes.jar b/build/intermediates/exploded-aar/com.android.support/support-v4/21.0.3/jars/classes.jar
new file mode 100644
index 00000000..b3379946
Binary files /dev/null and b/build/intermediates/exploded-aar/com.android.support/support-v4/21.0.3/jars/classes.jar differ
diff --git a/build/intermediates/exploded-aar/com.android.support/support-v4/21.0.3/jars/libs/internal_impl-21.0.3.jar b/build/intermediates/exploded-aar/com.android.support/support-v4/21.0.3/jars/libs/internal_impl-21.0.3.jar
new file mode 100644
index 00000000..f063abd5
Binary files /dev/null and b/build/intermediates/exploded-aar/com.android.support/support-v4/21.0.3/jars/libs/internal_impl-21.0.3.jar differ
diff --git a/build/intermediates/incremental/aidl/androidTest/debug/dependency.store b/build/intermediates/incremental/aidl/androidTest/debug/dependency.store
new file mode 100644
index 00000000..8b8400dc
Binary files /dev/null and b/build/intermediates/incremental/aidl/androidTest/debug/dependency.store differ
diff --git a/build/intermediates/incremental/aidl/debug/dependency.store b/build/intermediates/incremental/aidl/debug/dependency.store
new file mode 100644
index 00000000..8b8400dc
Binary files /dev/null and b/build/intermediates/incremental/aidl/debug/dependency.store differ
diff --git a/build/intermediates/incremental/aidl/release/dependency.store b/build/intermediates/incremental/aidl/release/dependency.store
new file mode 100644
index 00000000..8b8400dc
Binary files /dev/null and b/build/intermediates/incremental/aidl/release/dependency.store differ
diff --git a/build/intermediates/incremental/mergeAssets/androidTest/debug/merger.xml b/build/intermediates/incremental/mergeAssets/androidTest/debug/merger.xml
new file mode 100644
index 00000000..9eefddef
--- /dev/null
+++ b/build/intermediates/incremental/mergeAssets/androidTest/debug/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="21.0.3"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/build/intermediates/exploded-aar/com.android.support/support-v4/21.0.3/assets"/></dataSet><dataSet config="debug"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/build/intermediates/bundles/debug/assets"/></dataSet><dataSet config="main"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/src/androidTest/assets"/></dataSet></merger>
\ No newline at end of file
diff --git a/build/intermediates/incremental/mergeAssets/debug/merger.xml b/build/intermediates/incremental/mergeAssets/debug/merger.xml
new file mode 100644
index 00000000..4b116ccf
--- /dev/null
+++ b/build/intermediates/incremental/mergeAssets/debug/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="main"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/src/main/assets"/></dataSet><dataSet config="debug"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/src/debug/assets"/></dataSet></merger>
\ No newline at end of file
diff --git a/build/intermediates/incremental/mergeAssets/release/merger.xml b/build/intermediates/incremental/mergeAssets/release/merger.xml
new file mode 100644
index 00000000..c41347ff
--- /dev/null
+++ b/build/intermediates/incremental/mergeAssets/release/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="main"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/src/main/assets"/></dataSet><dataSet config="release"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/src/release/assets"/></dataSet></merger>
\ No newline at end of file
diff --git a/build/intermediates/incremental/mergeResources/androidTest/debug/merger.xml b/build/intermediates/incremental/mergeResources/androidTest/debug/merger.xml
new file mode 100644
index 00000000..45e51335
--- /dev/null
+++ b/build/intermediates/incremental/mergeResources/androidTest/debug/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="21.0.3"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/build/intermediates/exploded-aar/com.android.support/support-v4/21.0.3/res"/></dataSet><dataSet config="debug"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/build/intermediates/bundles/debug/res"/></dataSet><dataSet config="main"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/src/androidTest/res"/><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/build/generated/res/rs/androidTest/debug"/><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/build/generated/res/generated/androidTest/debug"/></dataSet><mergedItems/></merger>
\ No newline at end of file
diff --git a/build/intermediates/incremental/mergeResources/debug/merger.xml b/build/intermediates/incremental/mergeResources/debug/merger.xml
new file mode 100644
index 00000000..57b91e1c
--- /dev/null
+++ b/build/intermediates/incremental/mergeResources/debug/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="21.0.3"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/build/intermediates/exploded-aar/com.android.support/support-v4/21.0.3/res"/></dataSet><dataSet config="main"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/src/main/res"/><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/build/generated/res/rs/debug"/><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/build/generated/res/generated/debug"/></dataSet><dataSet config="debug"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/src/debug/res"/></dataSet><mergedItems/></merger>
\ No newline at end of file
diff --git a/build/intermediates/incremental/mergeResources/release/merger.xml b/build/intermediates/incremental/mergeResources/release/merger.xml
new file mode 100644
index 00000000..b8626f68
--- /dev/null
+++ b/build/intermediates/incremental/mergeResources/release/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="21.0.3"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/build/intermediates/exploded-aar/com.android.support/support-v4/21.0.3/res"/></dataSet><dataSet config="main"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/src/main/res"/><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/build/generated/res/rs/release"/><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/build/generated/res/generated/release"/></dataSet><dataSet config="release"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/src/release/res"/></dataSet><mergedItems/></merger>
\ No newline at end of file
diff --git a/build/intermediates/incremental/packageResources/debug/merger.xml b/build/intermediates/incremental/packageResources/debug/merger.xml
new file mode 100644
index 00000000..f067ae59
--- /dev/null
+++ b/build/intermediates/incremental/packageResources/debug/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="main"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/src/main/res"/><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/build/generated/res/rs/debug"/><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/build/generated/res/generated/debug"/></dataSet><dataSet config="debug"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/src/debug/res"/></dataSet><mergedItems/></merger>
\ No newline at end of file
diff --git a/build/intermediates/incremental/packageResources/release/merger.xml b/build/intermediates/incremental/packageResources/release/merger.xml
new file mode 100644
index 00000000..ad2e5f45
--- /dev/null
+++ b/build/intermediates/incremental/packageResources/release/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="main"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/src/main/res"/><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/build/generated/res/rs/release"/><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/build/generated/res/generated/release"/></dataSet><dataSet config="release"><source path="/Users/mbagliojr/code/Android/DataCache/sugarOrm/src/release/res"/></dataSet><mergedItems/></merger>
\ No newline at end of file
diff --git a/build/intermediates/manifests/androidTest/debug/AndroidManifest.xml b/build/intermediates/manifests/androidTest/debug/AndroidManifest.xml
new file mode 100644
index 00000000..02ea976f
--- /dev/null
+++ b/build/intermediates/manifests/androidTest/debug/AndroidManifest.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.orm.dsl.test" >
+
+    <uses-sdk
+        android:minSdkVersion="9"
+        android:targetSdkVersion="21" />
+
+    <instrumentation
+        android:name="android.test.InstrumentationTestRunner"
+        android:functionalTest="false"
+        android:handleProfiling="false"
+        android:label="Tests for com.orm.dsl.test"
+        android:targetPackage="com.orm.dsl.test" />
+
+    <application>
+        <uses-library android:name="android.test.runner" />
+    </application>
+
+</manifest>
\ No newline at end of file
diff --git a/build/intermediates/manifests/tmp/manifestMerger7237930893210798092.xml b/build/intermediates/manifests/tmp/manifestMerger7237930893210798092.xml
new file mode 100644
index 00000000..619d7960
--- /dev/null
+++ b/build/intermediates/manifests/tmp/manifestMerger7237930893210798092.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.orm.dsl.test">
+
+    <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="21" />
+
+    <application>
+        <uses-library android:name="android.test.runner" />
+    </application>
+
+    <instrumentation android:name="android.test.InstrumentationTestRunner"
+                     android:targetPackage="com.orm.dsl.test"
+                     android:handleProfiling="false"
+                     android:functionalTest="false"
+                     android:label="Tests for com.orm.dsl.test"/>
+</manifest>
diff --git a/build/intermediates/resources/resources-debug-androidTest.ap_ b/build/intermediates/resources/resources-debug-androidTest.ap_
new file mode 100644
index 00000000..8b91a489
Binary files /dev/null and b/build/intermediates/resources/resources-debug-androidTest.ap_ differ
diff --git a/build/libs/sugar.jar b/build/libs/sugar.jar
new file mode 100644
index 00000000..4dd30d1b
Binary files /dev/null and b/build/libs/sugar.jar differ
diff --git a/build/outputs/aar/sugarOrm-debug.aar b/build/outputs/aar/sugarOrm-debug.aar
new file mode 100644
index 00000000..42cb0e09
Binary files /dev/null and b/build/outputs/aar/sugarOrm-debug.aar differ
diff --git a/build/outputs/aar/sugarOrm-release.aar b/build/outputs/aar/sugarOrm-release.aar
new file mode 100644
index 00000000..dc106758
Binary files /dev/null and b/build/outputs/aar/sugarOrm-release.aar differ
diff --git a/build/tmp/libraryJar/MANIFEST.MF b/build/tmp/libraryJar/MANIFEST.MF
new file mode 100644
index 00000000..58630c02
--- /dev/null
+++ b/build/tmp/libraryJar/MANIFEST.MF
@@ -0,0 +1,2 @@
+Manifest-Version: 1.0
+
diff --git a/build/tmp/packageDebugJar/MANIFEST.MF b/build/tmp/packageDebugJar/MANIFEST.MF
new file mode 100644
index 00000000..58630c02
--- /dev/null
+++ b/build/tmp/packageDebugJar/MANIFEST.MF
@@ -0,0 +1,2 @@
+Manifest-Version: 1.0
+
diff --git a/build/tmp/packageReleaseJar/MANIFEST.MF b/build/tmp/packageReleaseJar/MANIFEST.MF
new file mode 100644
index 00000000..58630c02
--- /dev/null
+++ b/build/tmp/packageReleaseJar/MANIFEST.MF
@@ -0,0 +1,2 @@
+Manifest-Version: 1.0
+
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 00000000..07fe1d15
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,3 @@
+POM_NAME=Sugar ORM
+POM_ARTIFACT_ID=sugar
+POM_PACKAGING=aar
\ No newline at end of file
diff --git a/src/main/AndroidManifest.xml b/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..849de626
--- /dev/null
+++ b/src/main/AndroidManifest.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="com.orm.dsl"
+          android:versionCode="1"
+          android:versionName="1.3.1">
+
+</manifest>
\ No newline at end of file
diff --git a/src/main/java/com/orm/SchemaGenerator.java b/src/main/java/com/orm/SchemaGenerator.java
new file mode 100644
index 00000000..d67fb2af
--- /dev/null
+++ b/src/main/java/com/orm/SchemaGenerator.java
@@ -0,0 +1,205 @@
+package com.orm;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.util.Log;
+
+import com.orm.dsl.Column;
+import com.orm.dsl.ManyToMany;
+import com.orm.dsl.ManyToOne;
+import com.orm.dsl.NotNull;
+import com.orm.dsl.OneToOne;
+import com.orm.dsl.Unique;
+import com.orm.util.NamingHelper;
+import com.orm.util.NumberComparator;
+import com.orm.util.QueryBuilder;
+import com.orm.util.ReflectionUtil;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.lang.reflect.Field;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import static com.orm.util.ReflectionUtil.getDomainClasses;
+
+public class SchemaGenerator {
+
+    private Context context;
+
+    public SchemaGenerator(Context context) {
+        this.context = context;
+    }
+
+    public void createDatabase(SQLiteDatabase sqLiteDatabase) {
+        List<Class> domainClasses = getDomainClasses(context);
+        for (Class domain : domainClasses) {
+            createTable(domain, sqLiteDatabase);
+        }
+    }
+
+    public void doUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
+        List<Class> domainClasses = getDomainClasses(context);
+        String sql = "select count(*) from sqlite_master where type='table' and name='%s';";
+        for (Class domain : domainClasses) {
+            Cursor c = sqLiteDatabase.rawQuery(String.format(sql, NamingHelper.toSQLName(domain)), null);
+            if (c.moveToFirst() && c.getInt(0) == 0) {
+                createTable(domain, sqLiteDatabase);
+            }
+        }
+        executeSugarUpgrade(sqLiteDatabase, oldVersion, newVersion);
+    }
+
+    public void deleteTables(SQLiteDatabase sqLiteDatabase) {
+        List<Class> tables = getDomainClasses(context);
+        for (Class table : tables) {
+            sqLiteDatabase.execSQL("DROP TABLE IF EXISTS " + NamingHelper.toSQLName(table));
+        }
+    }
+
+    private boolean executeSugarUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        boolean isSuccess = false;
+
+        try {
+            List<String> files = Arrays.asList(this.context.getAssets().list("sugar_upgrades"));
+            Collections.sort(files, new NumberComparator());
+            for (String file : files) {
+                Log.i("Sugar", "filename : " + file);
+
+                try {
+                    int version = Integer.valueOf(file.replace(".sql", ""));
+
+                    if ((version > oldVersion) && (version <= newVersion)) {
+                        executeScript(db, file);
+                        isSuccess = true;
+                    }
+                } catch (NumberFormatException e) {
+                    Log.i("Sugar", "not a sugar script. ignored." + file);
+                }
+
+            }
+        } catch (IOException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+
+        return isSuccess;
+    }
+
+    private void executeScript(SQLiteDatabase db, String file) {
+        try {
+            InputStream is = this.context.getAssets().open("sugar_upgrades/" + file);
+            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
+            String line;
+            while ((line = reader.readLine()) != null) {
+                Log.i("Sugar script", line);
+                db.execSQL(line.toString());
+            }
+        } catch (IOException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+
+        Log.i("Sugar", "Script executed");
+    }
+
+    private void createTable(Class<?> table, SQLiteDatabase sqLiteDatabase) {
+        Log.i("Sugar", "Create table");
+        List<Field> fields = ReflectionUtil.getTableFields(table);
+        String tableName = NamingHelper.toSQLName(table);
+        StringBuilder sb = new StringBuilder("CREATE TABLE ");
+        sb.append(tableName).append(" ( ID INTEGER PRIMARY KEY AUTOINCREMENT ");
+
+        for (Field column : fields) {
+            String columnName = NamingHelper.toSQLName(column);
+            String columnType = QueryBuilder.getColumnType(column.getType());
+
+            if (columnType != null) {
+                if (columnName.equalsIgnoreCase("Id")) {
+                    continue;
+                }
+
+                if (column.isAnnotationPresent(Column.class)) {
+                    Column columnAnnotation = column.getAnnotation(Column.class);
+                    columnName = columnAnnotation.name();
+
+                    sb.append(", ").append(columnName).append(" ").append(columnType);
+
+                    if (columnAnnotation.notNull()) {
+                        if (columnType.endsWith(" NULL")) {
+                            sb.delete(sb.length() - 5, sb.length());
+                        }
+                        sb.append(" NOT NULL");
+                    }
+
+                    if (columnAnnotation.unique()) {
+                        sb.append(" UNIQUE");
+                    }
+
+                } else {
+                    sb.append(", ").append(columnName).append(" ").append(columnType);
+
+                    if (column.isAnnotationPresent(NotNull.class)) {
+                        if (columnType.endsWith(" NULL")) {
+                            sb.delete(sb.length() - 5, sb.length());
+                        }
+                        sb.append(" NOT NULL");
+                    }
+
+                    if (column.isAnnotationPresent(Unique.class)) {
+                        sb.append(" UNIQUE");
+                    }
+                }
+
+                if(column.isAnnotationPresent(OneToOne.class)) {
+                    OneToOne oneToOne =  column.getAnnotation(OneToOne.class);
+                    sb.append(", ").append(oneToOne.name()).append(" INTEGER");
+                } else if(column.isAnnotationPresent(ManyToOne.class)) {
+                    ManyToOne manyToOne =  column.getAnnotation(ManyToOne.class);
+                    sb.append(", ").append(manyToOne.name()).append(" INTEGER");
+                } else if(column.isAnnotationPresent(ManyToMany.class)) {
+                    ManyToMany manyToMany =  column.getAnnotation(ManyToMany.class);
+                    createJoinTable(manyToMany, sqLiteDatabase);
+                }
+            }
+        }
+
+        sb.append(" ) ");
+        Log.i("Sugar", "Creating table " + tableName);
+
+        if (!"".equals(sb.toString())) {
+            try {
+                sqLiteDatabase.execSQL(sb.toString());
+            } catch (SQLException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    private void createJoinTable(ManyToMany manyToMany, SQLiteDatabase sqLiteDatabase) {
+
+        if(manyToMany.joinTable() == null) {
+            return;
+        }
+
+        Log.i("Sugar", "Create join table");
+        StringBuilder sb = new StringBuilder("CREATE TABLE ");
+        sb.append(manyToMany.joinTable()).append(" ( ")
+                .append(manyToMany.columnOneName()).append(" INTEGER NOT NULL,")
+                .append(manyToMany.columnTwoName()).append(" INTEGER NOT NULL,")
+                .append(" PRIMARY KEY(").append(manyToMany.columnOneName()).append(", ").append(manyToMany.columnTwoName()).append(" )")
+        .append(" );");
+
+        if (!"".equals(sb.toString())) {
+            try {
+                sqLiteDatabase.execSQL(sb.toString());
+            } catch (SQLException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/com/orm/SugarApp.java b/src/main/java/com/orm/SugarApp.java
new file mode 100644
index 00000000..5140e1ee
--- /dev/null
+++ b/src/main/java/com/orm/SugarApp.java
@@ -0,0 +1,21 @@
+package com.orm;
+
+import com.orm.SugarContext;
+
+import android.app.Application;
+
+public class SugarApp extends Application {
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        SugarContext.init(this);
+    }
+
+    @Override
+    public void onTerminate() {
+        super.onTerminate();
+        SugarContext.terminate();
+    }
+
+}
diff --git a/src/main/java/com/orm/SugarContext.java b/src/main/java/com/orm/SugarContext.java
new file mode 100644
index 00000000..61acf813
--- /dev/null
+++ b/src/main/java/com/orm/SugarContext.java
@@ -0,0 +1,59 @@
+package com.orm;
+
+import android.content.Context;
+
+import com.google.common.collect.MapMaker;
+
+import java.util.concurrent.ConcurrentMap;
+
+public class SugarContext {
+
+    private static SugarContext instance = null;
+    private SugarDb sugarDb;
+    private Context context;
+    private ConcurrentMap<Object, Long> entitiesMap;
+
+    private SugarContext(Context context) {
+        this.context = context;
+        this.sugarDb = new SugarDb(context);
+        this.entitiesMap = new MapMaker().weakKeys().makeMap();
+    }
+    
+    public static SugarContext getSugarContext() {
+        if (instance == null) {
+            throw new NullPointerException("SugarContext has not been initialized properly. Call SugarContext.init(Context) in your Application.onCreate() method and SugarContext.terminate() in your Application.onTerminate() method.");
+        }
+        return instance;
+    }
+
+    public static void init(Context context) {
+        instance = new SugarContext(context);
+    }
+
+    public static void terminate() {
+        if (instance == null) {
+            return;
+        }
+        instance.doTerminate();
+    }
+
+    /*
+     * Per issue #106 on Github, this method won't be called in
+     * any real Android device. This method is used purely in
+     * emulated process environments such as an emulator or
+     * Robolectric Android mock.
+     */
+    private void doTerminate() {
+        if (this.sugarDb != null) {
+            this.sugarDb.getDB().close();
+        }
+    }
+
+    protected SugarDb getSugarDb() {
+        return sugarDb;
+    }
+
+    ConcurrentMap<Object, Long> getEntitiesMap() {
+        return entitiesMap;
+    }
+}
diff --git a/src/main/java/com/orm/SugarDb.java b/src/main/java/com/orm/SugarDb.java
new file mode 100644
index 00000000..a15110a3
--- /dev/null
+++ b/src/main/java/com/orm/SugarDb.java
@@ -0,0 +1,42 @@
+package com.orm;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+
+import com.orm.util.ManifestHelper;
+import com.orm.util.SugarCursorFactory;
+
+import static com.orm.util.ManifestHelper.getDatabaseVersion;
+import static com.orm.util.ManifestHelper.getDebugEnabled;
+
+public class SugarDb extends SQLiteOpenHelper {
+
+    private final SchemaGenerator schemaGenerator;
+    private SQLiteDatabase sqLiteDatabase;
+
+    public SugarDb(Context context) {
+        super(context, ManifestHelper.getDatabaseName(context),
+                new SugarCursorFactory(getDebugEnabled(context)), getDatabaseVersion(context));
+        schemaGenerator = new SchemaGenerator(context);
+    }
+
+    @Override
+    public void onCreate(SQLiteDatabase sqLiteDatabase) {
+        schemaGenerator.createDatabase(sqLiteDatabase);
+    }
+
+    @Override
+    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
+        schemaGenerator.doUpgrade(sqLiteDatabase, oldVersion, newVersion);
+    }
+
+    public synchronized SQLiteDatabase getDB() {
+        if (this.sqLiteDatabase == null) {
+            this.sqLiteDatabase = getWritableDatabase();
+        }
+
+        return this.sqLiteDatabase;
+    }
+
+}
diff --git a/src/main/java/com/orm/SugarRecord.java b/src/main/java/com/orm/SugarRecord.java
new file mode 100644
index 00000000..642b58a2
--- /dev/null
+++ b/src/main/java/com/orm/SugarRecord.java
@@ -0,0 +1,434 @@
+package com.orm;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+import android.database.sqlite.SQLiteStatement;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.orm.dsl.Table;
+import com.orm.util.NamingHelper;
+import com.orm.util.ReflectionUtil;
+import com.orm.util.QueryBuilder;
+
+import java.lang.String;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.NoSuchElementException;
+
+import static com.orm.SugarContext.getSugarContext;
+
+public class SugarRecord {
+
+    private Long id = null;
+
+    public static <T> int deleteAll(Class<T> type) {
+        return deleteAll(type, null);
+    }
+
+    public static <T> int deleteAll(Class<T> type, String whereClause, String... whereArgs) {
+        SugarDb db = getSugarContext().getSugarDb();
+        SQLiteDatabase sqLiteDatabase = db.getDB();
+        return sqLiteDatabase.delete(NamingHelper.toSQLName(type), whereClause, whereArgs);
+    }
+
+    @SuppressWarnings("deprecation")
+    public static <T> void saveInTx(T... objects) {
+        saveInTx(Arrays.asList(objects));
+    }
+
+    @SuppressWarnings("deprecation")
+    public static <T> void saveInTx(Collection<T> objects) {
+        SQLiteDatabase sqLiteDatabase = getSugarContext().getSugarDb().getDB();
+        try {
+            sqLiteDatabase.beginTransaction();
+            sqLiteDatabase.setLockingEnabled(false);
+            for (T object: objects) {
+                save(object);
+            }
+            sqLiteDatabase.setTransactionSuccessful();
+        } catch (Exception e) {
+            Log.i("Sugar", "Error in saving in transaction " + e.getMessage());
+        } finally {
+            sqLiteDatabase.endTransaction();
+            sqLiteDatabase.setLockingEnabled(true);
+        }
+    }
+
+    @SuppressWarnings("deprecation")
+    public static <T> int deleteInTx(T... objects) {
+        return deleteInTx(Arrays.asList(objects));
+    }
+
+    @SuppressWarnings("deprecation")
+    public static <T> int deleteInTx(Collection<T> objects) {
+        SQLiteDatabase sqLiteDatabase = getSugarContext().getSugarDb().getDB();
+        int deletedRows = 0;
+        try {
+            sqLiteDatabase.beginTransaction();
+            sqLiteDatabase.setLockingEnabled(false);
+            for (T object : objects) {
+                if (delete(object)) {
+                    ++deletedRows;
+                }
+            }
+            sqLiteDatabase.setTransactionSuccessful();
+        } catch (Exception e) {
+            deletedRows = 0;
+            Log.i("Sugar", "Error in deleting in transaction " + e.getMessage());
+        } finally {
+            sqLiteDatabase.endTransaction();
+            sqLiteDatabase.setLockingEnabled(true);
+        }
+        return deletedRows;
+    }
+
+    public static <T> List<T> listAll(Class<T> type) {
+        return find(type, null, null, null, null, null);
+    }
+    
+    public static <T> List<T> listAll(Class<T> type, String orderBy) {
+        return find(type, null, null, null, orderBy, null);
+    }
+
+    public static <T> T findById(Class<T> type, Long id) {
+        List<T> list = find(type, "id=?", new String[]{String.valueOf(id)}, null, null, "1");
+        if (list.isEmpty()) return null;
+        return list.get(0);
+    }
+
+    public static <T> T findById(Class<T> type, Integer id) {
+        return findById(type, Long.valueOf(id));
+    }
+
+    public static <T> List<T> findById(Class<T> type, String[] ids) {
+        String whereClause = "id IN (" + QueryBuilder.generatePlaceholders(ids.length) + ")";
+        return find(type, whereClause, ids);
+    }
+
+    public static <T> T first(Class<T>type) {
+        List<T> list = findWithQuery(type,
+                "SELECT * FROM " + NamingHelper.toSQLName(type) + " ORDER BY ID ASC LIMIT 1");
+        if (list.isEmpty()) {
+            return null;
+        }
+        return list.get(0);
+    }
+
+    public static <T> T last(Class<T>type) {
+        List<T> list = findWithQuery(type,
+                "SELECT * FROM " + NamingHelper.toSQLName(type) + " ORDER BY ID DESC LIMIT 1");
+        if (list.isEmpty()) {
+            return null;
+        }
+        return list.get(0);
+    }
+
+    public static <T> Iterator<T> findAll(Class<T> type) {
+        return findAsIterator(type, null, null, null, null, null);
+    }
+
+    public static <T> Iterator<T> findAsIterator(Class<T> type, String whereClause, String... whereArgs) {
+        return findAsIterator(type, whereClause, whereArgs, null, null, null);
+    }
+
+    public static <T> Iterator<T> findWithQueryAsIterator(Class<T> type, String query, String... arguments) {
+        SugarDb db = getSugarContext().getSugarDb();
+        SQLiteDatabase sqLiteDatabase = db.getDB();
+        Cursor c = sqLiteDatabase.rawQuery(query, arguments);
+        return new CursorIterator<T>(type, c);
+    }
+
+    public static <T> Iterator<T> findAsIterator(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
+        SugarDb db = getSugarContext().getSugarDb();
+        SQLiteDatabase sqLiteDatabase = db.getDB();
+        Cursor c = sqLiteDatabase.query(NamingHelper.toSQLName(type), null, whereClause, whereArgs,
+                groupBy, null, orderBy, limit);
+        return new CursorIterator<T>(type, c);
+    }
+
+    public static <T> List<T> find(Class<T> type, String whereClause, String... whereArgs) {
+        return find(type, whereClause, whereArgs, null, null, null);
+    }
+
+    public static <T> List<T> findWithQuery(Class<T> type, String query, String... arguments) {
+        SugarDb db = getSugarContext().getSugarDb();
+        SQLiteDatabase sqLiteDatabase = db.getDB();
+        T entity;
+        List<T> toRet = new ArrayList<T>();
+        Cursor c = sqLiteDatabase.rawQuery(query, arguments);
+
+        try {
+            while (c.moveToNext()) {
+                entity = type.getDeclaredConstructor().newInstance();
+                inflate(c, entity, getSugarContext().getEntitiesMap());
+                toRet.add(entity);
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            c.close();
+        }
+
+        return toRet;
+    }
+
+    public static void executeQuery(String query, String... arguments) {
+        getSugarContext().getSugarDb().getDB().execSQL(query, arguments);
+    }
+
+    public static <T> List<T> find(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
+        SugarDb db = getSugarContext().getSugarDb();
+        SQLiteDatabase sqLiteDatabase = db.getDB();
+        T entity;
+        List<T> toRet = new ArrayList<T>();
+        Cursor c = sqLiteDatabase.query(NamingHelper.toSQLName(type), null, whereClause, whereArgs,
+                groupBy, null, orderBy, limit);
+        try {
+            while (c.moveToNext()) {
+                entity = type.getDeclaredConstructor().newInstance();
+                inflate(c, entity, getSugarContext().getEntitiesMap());
+                toRet.add(entity);
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            c.close();
+        }
+        return toRet;
+    }
+
+    public static <T> long count(Class<?> type) {
+        return count(type, null, null, null, null, null);
+    }
+
+    public static <T> long count(Class<?> type, String whereClause, String[] whereArgs) {
+    	return count(type, whereClause, whereArgs, null, null, null);
+    }
+
+    public static <T> long count(Class<?> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
+        SugarDb db = getSugarContext().getSugarDb();
+        SQLiteDatabase sqLiteDatabase = db.getDB();
+
+        long toRet = -1;
+        String filter = (!TextUtils.isEmpty(whereClause)) ? " where "  + whereClause : "";
+        SQLiteStatement sqliteStatement;
+        try {
+            sqliteStatement = sqLiteDatabase.compileStatement("SELECT count(*) FROM " + NamingHelper.toSQLName(type) + filter);
+        } catch (SQLiteException e) {
+            e.printStackTrace();
+            return toRet;
+        }
+
+        if (whereArgs != null) {
+            for (int i = whereArgs.length; i != 0; i--) {
+                sqliteStatement.bindString(i, whereArgs[i - 1]);
+            }
+        }
+
+        try {
+            toRet = sqliteStatement.simpleQueryForLong();
+        } finally {
+            sqliteStatement.close();
+        }
+
+        return toRet;
+    }
+
+    public static long save(Object object) {
+        return save(getSugarContext().getSugarDb().getDB(), object);
+    }
+
+    static long save(SQLiteDatabase db, Object object) {
+        Map<Object, Long> entitiesMap = getSugarContext().getEntitiesMap();
+        List<Field> columns = ReflectionUtil.getTableFields(object.getClass());
+        ContentValues values = new ContentValues(columns.size());
+        Field idField = null;
+        for (Field column : columns) {
+            ReflectionUtil.addFieldValueToColumn(values, column, object, entitiesMap);
+            if (column.getName().equals("id")) {
+                idField = column;
+            }
+        }
+
+        boolean isSugarEntity = isSugarEntity(object.getClass());
+        if (isSugarEntity && entitiesMap.containsKey(object)) {
+                values.put("id", entitiesMap.get(object));
+        }
+
+        long id = db.insertWithOnConflict(NamingHelper.toSQLName(object.getClass()), null, values,
+                SQLiteDatabase.CONFLICT_REPLACE);
+
+        if (object.getClass().isAnnotationPresent(Table.class)) {
+            if (idField != null) {
+                idField.setAccessible(true);
+                try {
+                    idField.set(object, new Long(id));
+                } catch (IllegalAccessException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                entitiesMap.put(object, id);
+            }
+        } else if (SugarRecord.class.isAssignableFrom(object.getClass())) {
+            ((SugarRecord) object).setId(id);
+        }
+
+        Log.i("Sugar", object.getClass().getSimpleName() + " saved : " + id);
+
+        return id;
+    }
+
+    public static boolean isSugarEntity(Class<?> objectClass) {
+        return objectClass.isAnnotationPresent(Table.class) || SugarRecord.class.isAssignableFrom(objectClass);
+    }
+
+    private static void inflate(Cursor cursor, Object object, Map<Object, Long> entitiesMap) {
+        List<Field> columns = ReflectionUtil.getTableFields(object.getClass());
+        if (!entitiesMap.containsKey(object)) {
+            entitiesMap.put(object, cursor.getLong(cursor.getColumnIndex(("ID"))));
+        }
+
+        for (Field field : columns) {
+        	field.setAccessible(true);
+            Class<?> fieldType = field.getType();
+            if (isSugarEntity(fieldType)) {
+                try {
+                    long id = cursor.getLong(cursor.getColumnIndex(NamingHelper.toSQLName(field)));
+                    field.set(object, (id > 0) ? findById(fieldType, id) : null);
+                } catch (IllegalAccessException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                ReflectionUtil.setFieldValueFromCursor(cursor, field, object);
+            }
+        }
+    }
+
+    public boolean delete() {
+        Long id = getId();
+        Class<?> type = getClass();
+        if (id != null && id > 0L) {
+            SQLiteDatabase db = getSugarContext().getSugarDb().getDB();
+            Log.i("Sugar", type.getSimpleName() + " deleted : " + id);
+            return db.delete(NamingHelper.toSQLName(type), "Id=?", new String[]{id.toString()}) == 1;
+        } else {
+            Log.i("Sugar", "Cannot delete object: " + type.getSimpleName() + " - object has not been saved");
+            return false;
+        }
+    }
+    
+    public static boolean delete(Object object) {
+        Class<?> type = object.getClass();
+        if (type.isAnnotationPresent(Table.class)) {
+            try {
+                Field field = type.getDeclaredField("id");
+                field.setAccessible(true);
+                Long id = (Long) field.get(object);
+                if (id != null && id > 0L) {
+                    SQLiteDatabase db = getSugarContext().getSugarDb().getDB();
+                    boolean deleted = db.delete(NamingHelper.toSQLName(type), "Id=?", new String[]{id.toString()}) == 1;
+                    Log.i("Sugar", type.getSimpleName() + " deleted : " + id);
+                    return deleted;
+                } else {
+                    Log.i("Sugar", "Cannot delete object: " + object.getClass().getSimpleName() + " - object has not been saved");
+                    return false;
+                }
+            } catch (NoSuchFieldException e) {
+                Log.i("Sugar", "Cannot delete object: " + object.getClass().getSimpleName() + " - annotated object has no id");
+                return false;
+            } catch (IllegalAccessException e) {
+                Log.i("Sugar", "Cannot delete object: " + object.getClass().getSimpleName() + " - can't access id");
+                return false;
+            }
+        } else if (SugarRecord.class.isAssignableFrom(type)) {
+            return ((SugarRecord) object).delete();
+        } else {
+            Log.i("Sugar", "Cannot delete object: " + object.getClass().getSimpleName() + " - not persisted");
+            return false;
+        }
+    }
+
+    public long save() {
+        return save(getSugarContext().getSugarDb().getDB(), this);
+    }
+
+    @SuppressWarnings("unchecked")
+    void inflate(Cursor cursor) {
+        inflate(cursor, this, getSugarContext().getEntitiesMap());
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public static class CursorIterator<E> implements Iterator<E> {
+        Class<E> type;
+        Cursor cursor;
+
+        public CursorIterator(Class<E> type, Cursor cursor) {
+            this.type = type;
+            this.cursor = cursor;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return cursor != null && !cursor.isClosed() && !cursor.isAfterLast();
+        }
+
+        @Override
+        public E next() {
+            E entity = null;
+            if (cursor == null || cursor.isAfterLast()) {
+                throw new NoSuchElementException();
+            }
+
+            if (cursor.isBeforeFirst()) {
+                cursor.moveToFirst();
+            }
+
+            try {
+                entity = type.getDeclaredConstructor().newInstance();
+                inflate(cursor, entity, getSugarContext().getEntitiesMap());
+            } catch (Exception e) {
+                e.printStackTrace();
+            } finally {
+                cursor.moveToNext();
+                if (cursor.isAfterLast()) {
+                    cursor.close();
+                }
+            }
+
+            return entity;
+        }
+
+        @Override
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+
+        public E getItemAtPosition(int position) {
+            if(cursor.moveToPosition(position)) {
+                return this.next();
+            } else {
+                return null;
+            }
+        }
+        
+        public Cursor getCursor() {
+            return cursor;
+        }
+    }
+    
+}
diff --git a/src/main/java/com/orm/SugarTransactionHelper.java b/src/main/java/com/orm/SugarTransactionHelper.java
new file mode 100644
index 00000000..73440635
--- /dev/null
+++ b/src/main/java/com/orm/SugarTransactionHelper.java
@@ -0,0 +1,30 @@
+package com.orm;
+
+import android.database.sqlite.SQLiteDatabase;
+import android.util.Log;
+
+public class SugarTransactionHelper {
+
+    public static void doInTransaction(SugarTransactionHelper.Callback callback) {
+        SQLiteDatabase database = SugarContext.getSugarContext().getSugarDb().getDB();
+        database.beginTransaction();
+
+        try {
+            Log.d(SugarTransactionHelper.class.getSimpleName(),
+                    "Callback executing within transaction");
+            callback.manipulateInTransaction();
+            database.setTransactionSuccessful();
+            Log.d(SugarTransactionHelper.class.getSimpleName(),
+                    "Callback successfully executed within transaction");
+        } catch (Throwable e) {
+            Log.d(SugarTransactionHelper.class.getSimpleName(),
+                    "Could execute callback within transaction", e);
+        } finally {
+            database.endTransaction();
+        }
+    }
+
+    public static interface Callback {
+        void manipulateInTransaction();
+    }
+}
diff --git a/src/main/java/com/orm/dsl/Column.java b/src/main/java/com/orm/dsl/Column.java
new file mode 100644
index 00000000..2c47e3c0
--- /dev/null
+++ b/src/main/java/com/orm/dsl/Column.java
@@ -0,0 +1,11 @@
+package com.orm.dsl;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Column {
+    String name();
+    boolean unique() default false;
+    boolean notNull() default false;
+}
diff --git a/src/main/java/com/orm/dsl/Ignore.java b/src/main/java/com/orm/dsl/Ignore.java
new file mode 100644
index 00000000..9678d33a
--- /dev/null
+++ b/src/main/java/com/orm/dsl/Ignore.java
@@ -0,0 +1,8 @@
+package com.orm.dsl;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Ignore {
+}
diff --git a/src/main/java/com/orm/dsl/ManyToMany.java b/src/main/java/com/orm/dsl/ManyToMany.java
new file mode 100644
index 00000000..9af0a93d
--- /dev/null
+++ b/src/main/java/com/orm/dsl/ManyToMany.java
@@ -0,0 +1,21 @@
+package com.orm.dsl;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Created by mbagliojr on 7/20/15.
+ */
+@Documented
+@Target(ElementType.FIELD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface ManyToMany {
+
+    String joinTable();
+    String columnOneName();
+    String columnTwoName();
+
+}
diff --git a/src/main/java/com/orm/dsl/ManyToOne.java b/src/main/java/com/orm/dsl/ManyToOne.java
new file mode 100644
index 00000000..90b51f16
--- /dev/null
+++ b/src/main/java/com/orm/dsl/ManyToOne.java
@@ -0,0 +1,19 @@
+package com.orm.dsl;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Created by mbagliojr on 7/20/15.
+ */
+@Documented
+@Target(ElementType.FIELD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface ManyToOne {
+
+    String name();
+
+}
diff --git a/src/main/java/com/orm/dsl/NotNull.java b/src/main/java/com/orm/dsl/NotNull.java
new file mode 100644
index 00000000..b2361851
--- /dev/null
+++ b/src/main/java/com/orm/dsl/NotNull.java
@@ -0,0 +1,8 @@
+package com.orm.dsl;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+public @interface NotNull {
+}
diff --git a/src/main/java/com/orm/dsl/OneToMany.java b/src/main/java/com/orm/dsl/OneToMany.java
new file mode 100644
index 00000000..29ec677d
--- /dev/null
+++ b/src/main/java/com/orm/dsl/OneToMany.java
@@ -0,0 +1,19 @@
+package com.orm.dsl;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Created by mbagliojr on 7/20/15.
+ */
+@Documented
+@Target(ElementType.FIELD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface OneToMany {
+
+    String parentFieldName();
+
+}
diff --git a/src/main/java/com/orm/dsl/OneToOne.java b/src/main/java/com/orm/dsl/OneToOne.java
new file mode 100644
index 00000000..87c32655
--- /dev/null
+++ b/src/main/java/com/orm/dsl/OneToOne.java
@@ -0,0 +1,19 @@
+package com.orm.dsl;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Created by mbagliojr on 7/20/15.
+ */
+@Documented
+@Target(ElementType.FIELD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface OneToOne {
+
+    String name();
+
+}
diff --git a/src/main/java/com/orm/dsl/Table.java b/src/main/java/com/orm/dsl/Table.java
new file mode 100644
index 00000000..0dfaa18b
--- /dev/null
+++ b/src/main/java/com/orm/dsl/Table.java
@@ -0,0 +1,9 @@
+package com.orm.dsl;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Table {
+    String name() default "";
+}
diff --git a/src/main/java/com/orm/dsl/Unique.java b/src/main/java/com/orm/dsl/Unique.java
new file mode 100644
index 00000000..7384b749
--- /dev/null
+++ b/src/main/java/com/orm/dsl/Unique.java
@@ -0,0 +1,8 @@
+package com.orm.dsl;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Unique {
+}
diff --git a/src/main/java/com/orm/query/Condition.java b/src/main/java/com/orm/query/Condition.java
new file mode 100644
index 00000000..52ae052c
--- /dev/null
+++ b/src/main/java/com/orm/query/Condition.java
@@ -0,0 +1,124 @@
+package com.orm.query;
+
+import com.orm.SugarRecord;
+
+public class Condition {
+
+    private String property;
+    private Object value;
+    private Check check;
+
+    enum Check {
+        EQUALS(" = "),
+        GREATER_THAN(" > "),
+        LESSER_THAN(" < "),
+        NOT_EQUALS (" != "),
+        LIKE(" LIKE "),
+        NOT_LIKE(" NOT LIKE "),
+        IS_NULL(" IS NULL "),
+        IS_NOT_NULL(" IS NOT NULL ");
+
+        private String symbol;
+
+        Check(String symbol) {
+            this.symbol = symbol;
+        }
+
+        public String getSymbol() {
+            return symbol;
+        }
+    }
+
+    enum Type {
+        AND,
+        OR,
+        NOT
+    }
+
+    public Condition(String property) {
+        this.property = property;
+    }
+
+    public static Condition prop(String property) {
+        return new Condition(property);
+    }
+
+    public Condition eq(Object value) {
+        if (value == null) {
+            return isNull();
+        }
+        setValue(value);
+        check = Check.EQUALS;
+        return this;
+    }
+
+    public Condition like(Object value) {
+        setValue(value);
+        check = Check.LIKE;
+        return this;
+    }
+
+    public Condition notLike(Object value) {
+        setValue(value);
+        check = Check.NOT_LIKE;
+        return this;
+    }
+
+    public Condition notEq(Object value) {
+        if (value == null) {
+            return isNotNull();
+        }
+        setValue(value);
+        check = Check.NOT_EQUALS;
+        return this;
+    }
+
+    public Condition gt(Object value) {
+        setValue(value);
+        check = Check.GREATER_THAN;
+        return this;
+    }
+
+    public Condition lt(Object value) {
+        setValue(value);
+        check = Check.LESSER_THAN;
+        return this;
+    }
+
+    public Condition isNull() {
+        setValue(null);
+        check = Check.IS_NULL;
+        return this;
+    }
+
+    public Condition isNotNull() {
+        setValue(null);
+        check = Check.IS_NOT_NULL;
+        return this;
+    }
+
+    public String getProperty() {
+        return property;
+    }
+
+    public Object getValue() {
+        return value;
+    }
+
+    public Check getCheck() {
+        return check;
+    }
+
+    public String getCheckSymbol() {
+        return check.getSymbol();
+    }
+
+    private void setValue(Object value) {
+        if (value instanceof SugarRecord) {
+            this.value = ((SugarRecord)value).getId();
+        } else {
+            this.value = value;
+        }
+    }
+
+}
diff --git a/src/main/java/com/orm/query/Select.java b/src/main/java/com/orm/query/Select.java
new file mode 100644
index 00000000..9c52a9b4
--- /dev/null
+++ b/src/main/java/com/orm/query/Select.java
@@ -0,0 +1,188 @@
+package com.orm.query;
+
+import com.orm.SugarRecord;
+import com.orm.util.NamingHelper;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+public class Select<T> implements Iterable {
+
+    private Class<T> record;
+    private String[] arguments;
+    private String whereClause = "";
+    private String orderBy;
+    private String groupBy;
+    private String limit;
+    private String offset;
+    private List<Object> args = new ArrayList<Object>();
+
+    public Select(Class<T> record) {
+        this.record = record;
+    }
+
+    public static <T> Select<T> from(Class<T> record) {
+        return new Select<T>(record);
+    }
+
+    public Select<T> orderBy(String prop) {
+        this.orderBy = prop;
+        return this;
+    }
+
+    public Select<T> groupBy(String prop) {
+        this.groupBy = prop;
+        return this;
+    }
+
+    public Select<T> limit(String limit) {
+        this.limit = limit;
+        return this;
+    }
+
+    public Select<T> where(String whereClause) {
+        this.whereClause = whereClause;
+        return this;
+    }
+
+    public Select<T> where(Condition... condition) {
+
+        mergeConditions(condition, Condition.Type.AND);
+
+        return this;
+    }
+
+    private void mergeConditions(Condition[] conditions, Condition.Type type) {
+        StringBuilder toAppend = new StringBuilder("");
+        for (Condition condition : conditions) {
+            if (toAppend.length() != 0) {
+                toAppend.append(" ").append(type.name()).append(" ");
+            }
+
+            if (Condition.Check.LIKE.equals(condition.getCheck()) ||
+                    Condition.Check.NOT_LIKE.equals(condition.getCheck())) {
+                toAppend
+                    .append(condition.getProperty())
+                    .append(condition.getCheckSymbol())
+                    .append("'")
+                    .append(condition.getValue().toString())
+                    .append("'");
+            } else if (Condition.Check.IS_NULL.equals(condition.getCheck()) ||
+                    Condition.Check.IS_NOT_NULL.equals(condition.getCheck())) {
+                toAppend
+                    .append(condition.getProperty())
+                    .append(condition.getCheckSymbol());
+            } else {
+                toAppend
+                    .append(condition.getProperty())
+                    .append(condition.getCheckSymbol())
+                    .append("? ");
+                args.add(condition.getValue());
+            }
+        }
+        
+        if (!"".equals(whereClause)) {
+            whereClause += " " + type.name() + " ";
+        }
+
+        whereClause += "(" + toAppend + ")";
+    }
+
+    public Select<T> whereOr(Condition... args) {
+        mergeConditions(args, Condition.Type.OR);
+        return this;
+    }
+
+    public Select<T> and(Condition... args) {
+        mergeConditions(args, Condition.Type.AND);
+        return this;
+    }
+
+    public Select<T> or(Condition... args) {
+        mergeConditions(args, Condition.Type.OR);
+        return this;
+    }
+
+    public Select<T> where(String whereClause, String[] args) {
+        this.whereClause = whereClause;
+        this.arguments = args;
+        return this;
+    }
+
+    public List<T> list() {
+        if (arguments == null) {
+            arguments = convertArgs(args);
+        }
+
+        return SugarRecord.find(record, whereClause, arguments, groupBy, orderBy, limit);
+    }
+    
+    public long count() {
+        if (arguments == null) {
+            arguments = convertArgs(args);
+        }
+    	
+        return SugarRecord.count(record, whereClause, arguments, groupBy, orderBy, limit);
+    }
+
+    public T first() {
+        if (arguments == null) {
+            arguments = convertArgs(args);
+        }
+
+        List<T> list = SugarRecord.find(record, whereClause, arguments, groupBy, orderBy, "1");
+        return list.size() > 0 ? list.get(0) : null;
+    }
+    
+    String toSql() {
+        StringBuilder sql = new StringBuilder();
+        sql.append("SELECT * FROM ").append(NamingHelper.toSQLName(this.record)).append(" ");
+
+        if (whereClause != null) {
+            sql.append("WHERE ").append(whereClause).append(" ");
+        }
+
+        if (orderBy != null) {
+            sql.append("ORDER BY ").append(orderBy).append(" ");
+        }
+
+        if (limit != null) {
+            sql.append("LIMIT ").append(limit).append(" ");
+        }
+
+        if (offset != null) {
+            sql.append("OFFSET ").append(offset).append(" ");
+        }
+
+        return sql.toString();
+    }
+
+    String getWhereCond() {
+        return whereClause;
+    }
+
+    String[] getArgs() {
+        return convertArgs(args);
+    }
+
+    private String[] convertArgs(List<Object> argsList) {
+        String[] argsArray = new String[argsList.size()];
+
+        for (int i = 0; i < argsList.size(); i++) {
+             argsArray[i] = argsList.get(i).toString();
+        }
+
+        return argsArray;
+    }
+
+    @Override
+    public Iterator<T> iterator() {
+        if (arguments == null) {
+            arguments = convertArgs(args);
+        }
+
+        return SugarRecord.findAsIterator(record, whereClause, arguments, groupBy, orderBy, limit);
+    }
+
+}
diff --git a/src/main/java/com/orm/util/Collection.java b/src/main/java/com/orm/util/Collection.java
new file mode 100644
index 00000000..fe7a7e63
--- /dev/null
+++ b/src/main/java/com/orm/util/Collection.java
@@ -0,0 +1,40 @@
+package com.orm.util;
+import java.util.*;
+
+public class Collection {
+
+    public static <T> List<T> list(T... args) {
+        return Arrays.asList(args);
+    }
+
+    public static <T> Set<T> set(T... args) {
+        Set<T> result = new HashSet<T>(args.length);
+        result.addAll(Arrays.asList(args));
+        return result;
+    }
+
+    public static <K, V> Map<K, V> map(Entry<? extends K, ? extends V>... entries) {
+        Map<K, V> result = new HashMap<K, V>(entries.length);
+
+        for (Entry<? extends K, ? extends V> entry : entries)
+            if (entry.value != null)
+                result.put(entry.key, entry.value);
+
+        return result;
+    }
+
+    public static <K, V> Entry<K, V> entry(K key, V value) {
+        return new Entry<K, V>(key, value);
+    }
+
+    public static class Entry<K, V> {
+        K key;
+        V value;
+
+        public Entry(K key, V value) {
+            this.key = key;
+            this.value = value;
+        }
+    }
+
+}
diff --git a/src/main/java/com/orm/util/ManifestHelper.java b/src/main/java/com/orm/util/ManifestHelper.java
new file mode 100644
index 00000000..fb65724c
--- /dev/null
+++ b/src/main/java/com/orm/util/ManifestHelper.java
@@ -0,0 +1,133 @@
+package com.orm.util;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.util.Log;
+
+/**
+ * Helper class for accessing properties in the AndroidManifest
+ */
+public class ManifestHelper {
+
+    /**
+     * Key for the database name meta data.
+     */
+    public final static String METADATA_DATABASE = "DATABASE";
+    /**
+     * Key for the database verison meta data.
+     */
+    public final static String METADATA_VERSION = "VERSION";
+    public final static String METADATA_DOMAIN_PACKAGE_NAME = "DOMAIN_PACKAGE_NAME";
+    public final static String METADATA_QUERY_LOG = "QUERY_LOG";
+    /**
+     * The default name for the database unless specified in the AndroidManifest.
+     */
+    public final static String DATABASE_DEFAULT_NAME = "Sugar.db";
+
+    /**
+     * Grabs the database version from the manifest.
+     *
+     * @param context  the {@link android.content.Context} of the Android application
+     * @return the database version as specified by the {@link #METADATA_VERSION} version or 1 of
+     *         not present
+     */
+    public static int getDatabaseVersion(Context context) {
+        Integer databaseVersion = getMetaDataInteger(context, METADATA_VERSION);
+
+        if ((databaseVersion == null) || (databaseVersion == 0)) {
+            databaseVersion = 1;
+        }
+
+        return databaseVersion;
+    }
+
+    /**
+     * Grabs the domain name of the model classes from the manifest. 
+     *
+     * @param context  the {@link android.content.Context} of the Android application
+     * @return the package String that Sugar uses to search for model classes
+     */
+    public static String getDomainPackageName(Context context){
+        String domainPackageName = getMetaDataString(context, METADATA_DOMAIN_PACKAGE_NAME);
+
+        if (domainPackageName == null) {
+            domainPackageName = "";
+        }
+
+        return domainPackageName;
+    }
+
+    /**
+     * Grabs the name of the database file specified in the manifest.
+     *
+     * @param context  the {@link android.content.Context} of the Android application
+     * @return the value for the {@value #METADATA_DATABASE} meta data in the AndroidManifest or
+     *         {@link #DATABASE_DEFAULT_NAME} if not present
+     */
+    public static String getDatabaseName(Context context) {
+        String databaseName = getMetaDataString(context, METADATA_DATABASE);
+
+        if (databaseName == null) {
+            databaseName = DATABASE_DEFAULT_NAME;
+        }
+
+        return databaseName;
+    }
+
+    /**
+     * Grabs the debug flag from the manifest.
+     *
+     * @param context  the {@link android.content.Context} of the Android application
+     * @return true if the debug flag is enabled
+     */
+    public static boolean getDebugEnabled(Context context) {
+        return getMetaDataBoolean(context, METADATA_QUERY_LOG);
+    }
+
+    private static String getMetaDataString(Context context, String name) {
+        String value = null;
+
+        PackageManager pm = context.getPackageManager();
+        try {
+            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(),
+                    PackageManager.GET_META_DATA);
+            value = ai.metaData.getString(name);
+        } catch (Exception e) {
+            Log.d("sugar", "Couldn't find config value: " + name);
+        }
+
+        return value;
+    }
+
+    private static Integer getMetaDataInteger(Context context, String name) {
+        Integer value = null;
+
+        PackageManager pm = context.getPackageManager();
+        try {
+            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(),
+                    PackageManager.GET_META_DATA);
+            value = ai.metaData.getInt(name);
+        } catch (Exception e) {
+            Log.d("sugar", "Couldn't find config value: " + name);
+        }
+
+        return value;
+    }
+
+    private static Boolean getMetaDataBoolean(Context context, String name) {
+        Boolean value = false;
+
+        PackageManager pm = context.getPackageManager();
+        try {
+            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(),
+                    PackageManager.GET_META_DATA);
+            value = ai.metaData.getBoolean(name);
+        } catch (Exception e) {
+            Log.d("sugar", "Couldn't find config value: " + name);
+        }
+
+        return value;
+    }
+
+}
diff --git a/src/main/java/com/orm/util/NamingHelper.java b/src/main/java/com/orm/util/NamingHelper.java
new file mode 100644
index 00000000..734b4a56
--- /dev/null
+++ b/src/main/java/com/orm/util/NamingHelper.java
@@ -0,0 +1,94 @@
+package com.orm.util;
+
+import android.text.TextUtils;
+
+import com.orm.dsl.Column;
+import com.orm.dsl.Table;
+
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+
+public class NamingHelper {
+
+    /**
+     * Converts a given CamelCasedString to UPPER_CASE_UNDER_SCORE.
+     *
+     * @param camelCased  a non empty camelCased string
+     * @return the equivalent string converted to UPPER_CASE_UNDER_SCORE unless camelCased equals
+     *         "_id" (not case sensitive) in which case "_id" is returned
+     */
+    public static String toSQLNameDefault(String camelCased) {
+        if (camelCased.equalsIgnoreCase("_id")) {
+            return "_id";
+        }
+
+        StringBuilder sb = new StringBuilder();
+        char[] buf = camelCased.toCharArray();
+
+        for (int i = 0; i < buf.length; i++) {
+            char prevChar = (i > 0) ? buf[i - 1] : 0;
+            char c = buf[i];
+            char nextChar = (i < buf.length - 1) ? buf[i + 1] : 0;
+            boolean isFirstChar = (i == 0);
+
+            if (isFirstChar || Character.isLowerCase(c) || Character.isDigit(c)) {
+                sb.append(Character.toUpperCase(c));
+            } else if (Character.isUpperCase(c)) {
+                if (Character.isLetterOrDigit(prevChar)) {
+                    if (Character.isLowerCase(prevChar)) {
+                        sb.append('_').append(c);
+                    } else if (nextChar > 0 && Character.isLowerCase(nextChar)) {
+                        sb.append('_').append(c);
+                    } else {
+                        sb.append(c);
+                    }
+                } else {
+                    sb.append(c);
+                }
+            }
+        }
+
+        return sb.toString();
+    }
+
+    /**
+     * Maps a Java Field object to the database's column name.
+     *
+     * @param field  the {@link java.lang.reflect.Field} that will be mapped
+     * @return the name of the given Field as represented in the database. If the Field is annotated
+     *         with {@link com.orm.dsl.Column} then the {@link com.orm.dsl.Column#name()} will be
+     *         returned. Else, the Field's {@link java.lang.reflect.Field#getName()} will be
+     *         converted from CamelCase to UNDER_SCORE notation
+     */
+    public static String toSQLName(Field field) {
+        if (field.isAnnotationPresent(Column.class)) {
+            Column annotation = field.getAnnotation(Column.class);
+            return annotation.name();
+        }
+
+        return toSQLNameDefault(field.getName());
+    }
+
+    /**
+     * Maps a Java Class to the name of the class.
+     *
+     * @param table  the generic {@link java.lang.Class<T>} that defines a database table
+     * @return if the given class is annotated with {@link com.orm.dsl.Table} then the value for
+     *         {@link com.orm.dsl.Table#name()} will be returned. Else, the class' simple name will 
+     *         be converted from CamelCase to UNDER_SCORE notation
+     */
+    public static String toSQLName(Class<?> table) {
+        if (table.isAnnotationPresent(Table.class)) {
+            Table annotation = table.getAnnotation(Table.class);
+            if ("".equals(annotation.name())) {
+                return NamingHelper.toSQLNameDefault(table.getSimpleName());
+            }
+            return annotation.name();
+        }
+
+        return NamingHelper.toSQLNameDefault(table.getSimpleName());
+    }
+
+}
diff --git a/src/main/java/com/orm/util/NumberComparator.java b/src/main/java/com/orm/util/NumberComparator.java
new file mode 100644
index 00000000..b39ca9c9
--- /dev/null
+++ b/src/main/java/com/orm/util/NumberComparator.java
@@ -0,0 +1,101 @@
+package com.orm.util;
+
+import java.util.Comparator;
+
+public class NumberComparator implements Comparator<Object> {
+
+    private static char charAt(String s, int i) {
+        if (i >= s.length()) {
+            return '\000';
+        }
+
+        return s.charAt(i);
+    }
+
+    private int compareRight(String a, String b) {
+        int bias = 0;
+        int ia = 0;
+        int ib = 0;
+        while (true) {
+            char ca = charAt(a, ia);
+            char cb = charAt(b, ib);
+
+            if ((!Character.isDigit(ca)) && (!Character.isDigit(cb))) {
+                return bias;
+            }
+            if (!Character.isDigit(ca)) {
+                return -1;
+            }
+            if (!Character.isDigit(cb)) {
+                return 1;
+            }
+            if (ca < cb) {
+                if (bias == 0) {
+                    bias = -1;
+                }
+            } else if (ca > cb) {
+                if (bias == 0)
+                    bias = 1;
+            } else if ((ca == 0) && (cb == 0))
+                return bias;
+            ia++;
+            ib++;
+        }
+    }
+
+    public int compare(Object o1, Object o2) {
+        String a = o1.toString();
+        String b = o2.toString();
+
+        int ia = 0;
+        int ib = 0;
+        int nza = 0;
+        int nzb = 0;
+        while (true) {
+            nza = nzb = 0;
+
+            char ca = charAt(a, ia);
+            char cb = charAt(b, ib);
+
+            while ((Character.isSpaceChar(ca)) || (ca == '0')) {
+                if (ca == '0') {
+                    nza++;
+                } else {
+                    nza = 0;
+                }
+
+                ca = charAt(a, ++ia);
+            }
+
+            while ((Character.isSpaceChar(cb)) || (cb == '0')) {
+                if (cb == '0') {
+                    nzb++;
+                } else {
+                    nzb = 0;
+                }
+
+                cb = charAt(b, ++ib);
+            }
+            int result;
+            if ((Character.isDigit(ca)) && (Character.isDigit(cb)) &&
+                    ((result = compareRight(a.substring(ia), b.substring(ib))) != 0)) {
+                return result;
+            }
+
+            if ((ca == 0) && (cb == 0)) {
+                return nza - nzb;
+            }
+
+            if (ca < cb) {
+                return -1;
+            }
+            if (ca > cb) {
+                return 1;
+            }
+
+            ia++;
+            ib++;
+        }
+    }
+
+}
diff --git a/src/main/java/com/orm/util/QueryBuilder.java b/src/main/java/com/orm/util/QueryBuilder.java
new file mode 100644
index 00000000..e1c3557f
--- /dev/null
+++ b/src/main/java/com/orm/util/QueryBuilder.java
@@ -0,0 +1,58 @@
+package com.orm.util;
+
+import com.orm.SugarRecord;
+
+import java.lang.RuntimeException;
+import java.lang.StringBuilder;
+import java.math.BigDecimal;
+
+public class QueryBuilder {
+
+    public static String getColumnType(Class<?> type) {
+        if ((type.equals(Boolean.class)) ||
+                (type.equals(Boolean.TYPE)) ||
+                (type.equals(Integer.class)) ||
+                (type.equals(Integer.TYPE)) ||
+                (type.equals(Long.class)) ||
+                (type.equals(Long.TYPE)) || (
+                (!type.isPrimitive()) &&
+                        (SugarRecord.class.isAssignableFrom(type))))  {
+            return "INTEGER";
+        }
+
+        if ((type.equals(java.util.Date.class)) ||
+                (type.equals(java.sql.Date.class)) ||
+                (type.equals(java.util.Calendar.class))) {
+            return "INTEGER NULL";
+        }
+
+        if (type.getName().equals("[B")) {
+            return "BLOB";
+        }
+
+        if ((type.equals(Double.class)) || (type.equals(Double.TYPE)) || (type.equals(Float.class)) ||
+                (type.equals(Float.TYPE))) {
+            return "FLOAT";
+        }
+
+        if ((type.equals(String.class)) || (type.equals(Character.TYPE)) ||
+                (type.equals(BigDecimal.class))) {
+            return "TEXT";
+        }
+
+        return "";
+    }
+
+    public static String generatePlaceholders(int numberOfArgs) {
+        if (numberOfArgs < 1) {
+            throw new RuntimeException("The number of arguments must be greater than or equal to 1.");
+        }
+
+        StringBuilder stringBuilder = new StringBuilder(numberOfArgs * 2 - 1);
+        stringBuilder.append("?");
+        for (int i = 1; i < numberOfArgs; i++) {
+            stringBuilder.append(",?");
+        }
+        return stringBuilder.toString();
+    }
+}
diff --git a/src/main/java/com/orm/util/ReflectionUtil.java b/src/main/java/com/orm/util/ReflectionUtil.java
new file mode 100644
index 00000000..a740b42d
--- /dev/null
+++ b/src/main/java/com/orm/util/ReflectionUtil.java
@@ -0,0 +1,349 @@
+package com.orm.util;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.util.Log;
+
+import com.orm.SugarRecord;
+import com.orm.dsl.Ignore;
+import com.orm.dsl.Table;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.math.BigDecimal;
+import java.net.URL;
+import java.sql.Timestamp;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Collections;
+import java.util.Date;
+import java.util.Enumeration;
+import java.util.List;
+import java.util.Map;
+
+import dalvik.system.DexFile;
+
+public class ReflectionUtil {
+
+    public static List<Field> getTableFields(Class table) {
+        List<Field> fieldList = SugarConfig.getFields(table);
+        if (fieldList != null) return fieldList;
+
+        Log.d("Sugar", "Fetching properties");
+        List<Field> typeFields = new ArrayList<Field>();
+
+        getAllFields(typeFields, table);
+
+        List<Field> toStore = new ArrayList<Field>();
+        for (Field field : typeFields) {
+            if (!field.isAnnotationPresent(Ignore.class) && !Modifier.isStatic(field.getModifiers()) && !Modifier.isTransient(field.getModifiers())) {
+                toStore.add(field);
+            }
+        }
+
+        SugarConfig.setFields(table, toStore);
+        return toStore;
+    }
+
+    private static List<Field> getAllFields(List<Field> fields, Class<?> type) {
+        Collections.addAll(fields, type.getDeclaredFields());
+
+        if (type.getSuperclass() != null) {
+            fields = getAllFields(fields, type.getSuperclass());
+        }
+
+        return fields;
+    }
+
+    public static void addFieldValueToColumn(ContentValues values, Field column, Object object,
+                                             Map<Object, Long> entitiesMap) {
+        column.setAccessible(true);
+        Class<?> columnType = column.getType();
+        try {
+            String columnName = NamingHelper.toSQLName(column);
+            Object columnValue = column.get(object);
+
+            if (columnType.isAnnotationPresent(Table.class)) {
+                Field field = null;
+                try {
+                    field = columnType.getDeclaredField("id");
+                    field.setAccessible(true);
+                    values.put(columnName,
+                            (field != null)
+                                    ? String.valueOf(field.get(columnValue)) : "0");
+                } catch (NoSuchFieldException e) {
+                    if (entitiesMap.containsKey(columnValue)) {
+                        values.put(columnName, entitiesMap.get(columnValue));
+                    }
+                }
+            } else if (SugarRecord.class.isAssignableFrom(columnType)) {
+                values.put(columnName,
+                        (columnValue != null)
+                                ? String.valueOf(((SugarRecord) columnValue).getId())
+                                : "0");
+            } else {
+                if (columnType.equals(Short.class) || columnType.equals(short.class)) {
+                    values.put(columnName, (Short) columnValue);
+                } else if (columnType.equals(Integer.class) || columnType.equals(int.class)) {
+                    values.put(columnName, (Integer) columnValue);
+                } else if (columnType.equals(Long.class) || columnType.equals(long.class)) {
+                    values.put(columnName, (Long) columnValue);
+                } else if (columnType.equals(Float.class) || columnType.equals(float.class)) {
+                    values.put(columnName, (Float) columnValue);
+                } else if (columnType.equals(Double.class) || columnType.equals(double.class)) {
+                    values.put(columnName, (Double) columnValue);
+                } else if (columnType.equals(Boolean.class) || columnType.equals(boolean.class)) {
+                    values.put(columnName, (Boolean) columnValue);
+                } else if (columnType.equals(BigDecimal.class)) {
+                    try {
+                        values.put(columnName, column.get(object).toString());
+                    } catch (NullPointerException e) {
+                        values.putNull(columnName);
+                    }
+                } else if (Timestamp.class.equals(columnType)) {
+                    try {
+                        values.put(columnName, ((Timestamp) column.get(object)).getTime());
+                    } catch (NullPointerException e) {
+                        values.put(columnName, (Long) null);
+                    }
+                } else if (Date.class.equals(columnType)) {
+                    try {
+                        values.put(columnName, ((Date) column.get(object)).getTime());
+                    } catch (NullPointerException e) {
+                        values.put(columnName, (Long) null);
+                    }
+                } else if (Calendar.class.equals(columnType)) {
+                    try {
+                        values.put(columnName, ((Calendar) column.get(object)).getTimeInMillis());
+                    } catch (NullPointerException e) {
+                        values.put(columnName, (Long) null);
+                    }
+                } else if (columnType.equals(byte[].class)) {
+                    if (columnValue == null) {
+                        values.put(columnName, "".getBytes());
+                    } else {
+                        values.put(columnName, (byte[]) columnValue);
+                    }
+                } else {
+                    if (columnValue == null) {
+                        values.putNull(columnName);
+                    } else if (columnType.isEnum()) {
+                        values.put(columnName, ((Enum) columnValue).name());
+                    } else {
+                        values.put(columnName, String.valueOf(columnValue));
+                    }
+                }
+            }
+
+        } catch (IllegalAccessException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+    }
+
+    public static void setFieldValueFromCursor(Cursor cursor, Field field, Object object) {
+        field.setAccessible(true);
+        try {
+            Class fieldType = field.getType();
+            String colName = NamingHelper.toSQLName(field);
+
+            int columnIndex = cursor.getColumnIndex(colName);
+
+            if (cursor.isNull(columnIndex)) {
+                return;
+            }
+
+            if (colName.equalsIgnoreCase("id")) {
+                long cid = cursor.getLong(columnIndex);
+                field.set(object, Long.valueOf(cid));
+            } else if (fieldType.equals(long.class) || fieldType.equals(Long.class)) {
+                field.set(object,
+                        cursor.getLong(columnIndex));
+            } else if (fieldType.equals(String.class)) {
+                String val = cursor.getString(columnIndex);
+                field.set(object, val != null && val.equals("null") ? null : val);
+            } else if (fieldType.equals(double.class) || fieldType.equals(Double.class)) {
+                field.set(object,
+                        cursor.getDouble(columnIndex));
+            } else if (fieldType.equals(boolean.class) || fieldType.equals(Boolean.class)) {
+                field.set(object,
+                        cursor.getString(columnIndex).equals("1"));
+            } else if (fieldType.equals(int.class) || fieldType.equals(Integer.class)) {
+                field.set(object,
+                        cursor.getInt(columnIndex));
+            } else if (fieldType.equals(float.class) || fieldType.equals(Float.class)) {
+                field.set(object,
+                        cursor.getFloat(columnIndex));
+            } else if (fieldType.equals(short.class) || fieldType.equals(Short.class)) {
+                field.set(object,
+                        cursor.getShort(columnIndex));
+            } else if (fieldType.equals(BigDecimal.class)) {
+                String val = cursor.getString(columnIndex);
+                field.set(object, val != null && val.equals("null") ? null : new BigDecimal(val));
+            } else if (fieldType.equals(Timestamp.class)) {
+                long l = cursor.getLong(columnIndex);
+                field.set(object, new Timestamp(l));
+            } else if (fieldType.equals(Date.class)) {
+                long l = cursor.getLong(columnIndex);
+                field.set(object, new Date(l));
+            } else if (fieldType.equals(Calendar.class)) {
+                long l = cursor.getLong(columnIndex);
+                Calendar c = Calendar.getInstance();
+                c.setTimeInMillis(l);
+                field.set(object, c);
+            } else if (fieldType.equals(byte[].class)) {
+                byte[] bytes = cursor.getBlob(columnIndex);
+                if (bytes == null) {
+                    field.set(object, "".getBytes());
+                } else {
+                    field.set(object, cursor.getBlob(columnIndex));
+                }
+            } else if (Enum.class.isAssignableFrom(fieldType)) {
+                try {
+                    Method valueOf = field.getType().getMethod("valueOf", String.class);
+                    String strVal = cursor.getString(columnIndex);
+                    Object enumVal = valueOf.invoke(field.getType(), strVal);
+                    field.set(object, enumVal);
+                } catch (Exception e) {
+                    Log.e("Sugar", "Enum cannot be read from Sqlite3 database. Please check the type of field " + field.getName());
+                }
+            } else
+                Log.e("Sugar", "Class cannot be read from Sqlite3 database. Please check the type of field " + field.getName() + "(" + field.getType().getName() + ")");
+        } catch (IllegalArgumentException e) {
+            Log.e("field set error", e.getMessage());
+        } catch (IllegalAccessException e) {
+            Log.e("field set error", e.getMessage());
+        }
+    }
+
+    private static Field getDeepField(String fieldName, Class<?> type) throws NoSuchFieldException {
+        try {
+            Field field = type.getDeclaredField(fieldName);
+            return field;
+        } catch (NoSuchFieldException e) {
+            Class superclass = type.getSuperclass();
+            if (superclass != null) {
+                Field field = getDeepField(fieldName, superclass);
+                return field;
+            } else {
+                throw e;
+            }
+        }
+    }
+
+    public static void setFieldValueForId(Object object, Long value) {
+        try {
+            Field field = getDeepField("id", object.getClass());
+            field.setAccessible(true);
+            field.set(object, value);
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        } catch (NoSuchFieldException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static List<Class> getDomainClasses(Context context) {
+        List<Class> domainClasses = new ArrayList<Class>();
+        try {
+            for (String className : getAllClasses(context)) {
+                Class domainClass = getDomainClass(className, context);
+                if (domainClass != null) domainClasses.add(domainClass);
+            }
+        } catch (IOException e) {
+            Log.e("Sugar", e.getMessage());
+        } catch (PackageManager.NameNotFoundException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+
+        return domainClasses;
+    }
+
+
+    private static Class getDomainClass(String className, Context context) {
+        Class<?> discoveredClass = null;
+        try {
+            discoveredClass = Class.forName(className, true, context.getClass().getClassLoader());
+        } catch (ClassNotFoundException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+
+        if ((discoveredClass != null) &&
+                ((SugarRecord.class.isAssignableFrom(discoveredClass) &&
+                        !SugarRecord.class.equals(discoveredClass)) ||
+                        discoveredClass.isAnnotationPresent(Table.class)) &&
+                !Modifier.isAbstract(discoveredClass.getModifiers())) {
+
+            Log.i("Sugar", "domain class : " + discoveredClass.getSimpleName());
+            return discoveredClass;
+
+        } else {
+            return null;
+        }
+    }
+
+
+    private static List<String> getAllClasses(Context context) throws PackageManager.NameNotFoundException, IOException {
+        String packageName = ManifestHelper.getDomainPackageName(context);
+        String path = getSourcePath(context);
+        List<String> classNames = new ArrayList<String>();
+        DexFile dexfile = null;
+        try {
+            dexfile = new DexFile(path);
+            Enumeration<String> dexEntries = dexfile.entries();
+            while (dexEntries.hasMoreElements()) {
+                String className = dexEntries.nextElement();
+                if (className.startsWith(packageName)) classNames.add(className);
+            }
+        } catch (NullPointerException e) {
+            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+            Enumeration<URL> urls = classLoader.getResources("");
+            while (urls.hasMoreElements()) {
+                List<String> fileNames = new ArrayList<String>();
+                String classDirectoryName = urls.nextElement().getFile();
+                if (classDirectoryName.contains("bin") || classDirectoryName.contains("classes")) {
+                    File classDirectory = new File(classDirectoryName);
+                    for (File filePath : classDirectory.listFiles()) {
+                        populateFiles(filePath, fileNames, "");
+                    }
+                    for (String fileName : fileNames) {
+                        if (fileName.startsWith(packageName)) classNames.add(fileName);
+                    }
+                }
+            }
+        } finally {
+            if (null != dexfile) dexfile.close();
+        }
+        return classNames;
+    }
+
+    private static void populateFiles(File path, List<String> fileNames, String parent) {
+        if (path.isDirectory()) {
+            for (File newPath : path.listFiles()) {
+                if ("".equals(parent)) {
+                    populateFiles(newPath, fileNames, path.getName());
+                } else {
+                    populateFiles(newPath, fileNames, parent + "." + path.getName());
+                }
+            }
+        } else {
+            String pathName = path.getName();
+            String classSuffix = ".class";
+            pathName = pathName.endsWith(classSuffix) ?
+                    pathName.substring(0, pathName.length() - classSuffix.length()) : pathName;
+            if ("".equals(parent)) {
+                fileNames.add(pathName);
+            } else {
+                fileNames.add(parent + "." + pathName);
+            }
+        }
+    }
+
+    private static String getSourcePath(Context context) throws PackageManager.NameNotFoundException {
+        return context.getPackageManager().getApplicationInfo(context.getPackageName(), 0).sourceDir;
+    }
+}
diff --git a/src/main/java/com/orm/util/SugarConfig.java b/src/main/java/com/orm/util/SugarConfig.java
new file mode 100644
index 00000000..b93da25e
--- /dev/null
+++ b/src/main/java/com/orm/util/SugarConfig.java
@@ -0,0 +1,37 @@
+package com.orm.util;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.util.Log;
+
+import java.lang.reflect.Field;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+
+public class SugarConfig {
+
+    static Map<Class<?>, List<Field>> fields = new HashMap<Class<?>, List<Field>>();
+
+    public static void setFields(Class<?> clazz, List<Field> fieldz) {
+         fields.put(clazz, fieldz);
+    }
+
+    public static List<Field> getFields(Class<?> clazz) {
+        if (fields.containsKey(clazz)) {
+            List<Field> list = fields.get(clazz);
+            return Collections.synchronizedList(list);
+        }
+
+        return null;
+    }
+
+    public static void clearCache() {
+        fields.clear();
+        fields = new HashMap<Class<?>, List<Field>>();
+    }
+
+}
diff --git a/src/main/java/com/orm/util/SugarCursorFactory.java b/src/main/java/com/orm/util/SugarCursorFactory.java
new file mode 100644
index 00000000..12706516
--- /dev/null
+++ b/src/main/java/com/orm/util/SugarCursorFactory.java
@@ -0,0 +1,36 @@
+package com.orm.util;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteCursor;
+import android.database.sqlite.SQLiteCursorDriver;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteQuery;
+import android.util.Log;
+
+public class SugarCursorFactory implements SQLiteDatabase.CursorFactory {
+
+    private boolean debugEnabled;
+
+    public SugarCursorFactory() {
+        this.debugEnabled = false;
+    }
+
+    public SugarCursorFactory(boolean debugEnabled) {
+
+        this.debugEnabled = debugEnabled;
+    }
+
+    @SuppressWarnings("deprecation")
+    public Cursor newCursor(SQLiteDatabase sqLiteDatabase,
+            SQLiteCursorDriver sqLiteCursorDriver,
+            String editTable,
+            SQLiteQuery sqLiteQuery) {
+
+        if (debugEnabled) {
+            Log.d("SQL Log", sqLiteQuery.toString());
+        }
+
+        return new SQLiteCursor(sqLiteDatabase, sqLiteCursorDriver, editTable, sqLiteQuery);
+    }
+
+}
diff --git a/src/test/java/com/orm/NamingHelperTest.java b/src/test/java/com/orm/NamingHelperTest.java
new file mode 100644
index 00000000..3166a107
--- /dev/null
+++ b/src/test/java/com/orm/NamingHelperTest.java
@@ -0,0 +1,37 @@
+package com.orm;
+
+import com.orm.util.NamingHelper;
+
+import org.junit.Test;
+
+import static junit.framework.Assert.assertEquals;
+
+public class NamingHelperTest {
+    @Test
+    public void testToSQLNameCaseConversion() throws Exception {
+        assertToSqlNameEquals("TESTLOWERCASE", "testlowercase");
+        assertToSqlNameEquals("TESTUPPERCASE", "TESTUPPERCASE");
+    }
+
+    @Test
+    public void testToSQLNameUnderscore() {
+        assertToSqlNameEquals("TEST_UNDERSCORE", "testUnderscore");
+        assertToSqlNameEquals("AB_CD", "AbCd");
+        assertToSqlNameEquals("AB_CD", "ABCd");
+        assertToSqlNameEquals("AB_CD", "AbCD");
+        assertToSqlNameEquals("SOME_DETAILS_OBJECT", "SomeDetailsObject");
+        assertToSqlNameEquals("H_OL_A","hOlA");
+        assertToSqlNameEquals("A","a");
+    }
+
+    /**
+     * Helper method that asserts a CamelCaseString is converted to UPPER_CASE_UNDER_SCORE.
+     *
+     * @param expected  a CamelCaseString
+     * @param actual    the expected UPPER_CASE_UNDER_SCORE string
+     */
+    private static void assertToSqlNameEquals(String expected, String actual) {
+        assertEquals(expected, NamingHelper.toSQLNameDefault(actual));
+    }
+
+}
diff --git a/src/test/java/com/orm/query/DummyContext.java b/src/test/java/com/orm/query/DummyContext.java
new file mode 100644
index 00000000..5505b37f
--- /dev/null
+++ b/src/test/java/com/orm/query/DummyContext.java
@@ -0,0 +1,474 @@
+package com.orm.query;
+
+import android.content.*;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.content.res.AssetManager;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.database.DatabaseErrorHandler;
+import android.database.sqlite.SQLiteDatabase;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.UserHandle;
+import android.view.Display;
+
+import java.io.*;
+
+public class DummyContext extends Context {
+    @Override
+    public File getCodeCacheDir() {
+        return null;
+    }
+
+    @Override
+    public File[] getExternalFilesDirs(String type) {
+        return null;
+    }
+
+    @Override
+    public File[] getExternalCacheDirs() {
+        return null;
+    }
+
+    @Override
+    public File getNoBackupFilesDir() {
+        return null;
+    }
+
+    @Override
+    public File[] getObbDirs() {
+        return null;
+    }
+
+    @Override
+    public File[] getExternalMediaDirs() {
+        return null;
+    }
+
+    @Override
+    public AssetManager getAssets() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public Resources getResources() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public PackageManager getPackageManager() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public ContentResolver getContentResolver() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public Looper getMainLooper() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public Context getApplicationContext() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void setTheme(int i) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public Resources.Theme getTheme() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public ClassLoader getClassLoader() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public String getPackageName() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public ApplicationInfo getApplicationInfo() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public String getPackageResourcePath() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public String getPackageCodePath() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public SharedPreferences getSharedPreferences(String s, int i) {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public FileInputStream openFileInput(String s) throws FileNotFoundException {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public FileOutputStream openFileOutput(String s, int i) throws FileNotFoundException {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public boolean deleteFile(String s) {
+        return false;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public File getFileStreamPath(String s) {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public File getFilesDir() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public File getExternalFilesDir(String s) {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public File getObbDir() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public File getCacheDir() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public File getExternalCacheDir() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public String[] fileList() {
+        return new String[0];  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public File getDir(String s, int i) {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public SQLiteDatabase openOrCreateDatabase(String s, int i, SQLiteDatabase.CursorFactory cursorFactory) {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public SQLiteDatabase openOrCreateDatabase(String s, int i, SQLiteDatabase.CursorFactory cursorFactory, DatabaseErrorHandler databaseErrorHandler) {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public boolean deleteDatabase(String s) {
+        return false;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public File getDatabasePath(String s) {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public String[] databaseList() {
+        return new String[0];  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public Drawable getWallpaper() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public Drawable peekWallpaper() {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public int getWallpaperDesiredMinimumWidth() {
+        return 0;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public int getWallpaperDesiredMinimumHeight() {
+        return 0;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void setWallpaper(Bitmap bitmap) throws IOException {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void setWallpaper(InputStream inputStream) throws IOException {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void clearWallpaper() throws IOException {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void startActivity(Intent intent) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void startActivity(Intent intent, Bundle options) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+
+    @Override
+    public void startActivities(Intent[] intents) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void startActivities(Intent[] intents, Bundle options) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+
+    @Override
+    public void startIntentSender(IntentSender intentSender, Intent intent, int i, int i1, int i2) throws IntentSender.SendIntentException {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options) throws IntentSender.SendIntentException {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void sendBroadcast(Intent intent) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void sendBroadcast(Intent intent, String s) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void sendOrderedBroadcast(Intent intent, String s) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void sendOrderedBroadcast(Intent intent, String s, BroadcastReceiver broadcastReceiver, Handler handler, int i, String s1, Bundle bundle) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void sendBroadcastAsUser(Intent intent, UserHandle user) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void sendStickyBroadcast(Intent intent) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void sendStickyOrderedBroadcast(Intent intent, BroadcastReceiver broadcastReceiver, Handler handler, int i, String s, Bundle bundle) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void removeStickyBroadcast(Intent intent) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void sendStickyBroadcastAsUser(Intent intent, UserHandle user) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void sendStickyOrderedBroadcastAsUser(Intent intent, UserHandle user, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void removeStickyBroadcastAsUser(Intent intent, UserHandle user) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public Intent registerReceiver(BroadcastReceiver broadcastReceiver, IntentFilter intentFilter) {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public Intent registerReceiver(BroadcastReceiver broadcastReceiver, IntentFilter intentFilter, String s, Handler handler) {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void unregisterReceiver(BroadcastReceiver broadcastReceiver) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public ComponentName startService(Intent intent) {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public boolean stopService(Intent intent) {
+        return false;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public boolean bindService(Intent intent, ServiceConnection serviceConnection, int i) {
+        return false;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void unbindService(ServiceConnection serviceConnection) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public boolean startInstrumentation(ComponentName componentName, String s, Bundle bundle) {
+        return false;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public Object getSystemService(String s) {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public int checkPermission(String s, int i, int i1) {
+        return 0;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public int checkCallingPermission(String s) {
+        return 0;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public int checkCallingOrSelfPermission(String s) {
+        return 0;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void enforcePermission(String s, int i, int i1, String s1) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void enforceCallingPermission(String s, String s1) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void enforceCallingOrSelfPermission(String s, String s1) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void grantUriPermission(String s, Uri uri, int i) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void revokeUriPermission(Uri uri, int i) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public int checkUriPermission(Uri uri, int i, int i1, int i2) {
+        return 0;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public int checkCallingUriPermission(Uri uri, int i) {
+        return 0;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public int checkCallingOrSelfUriPermission(Uri uri, int i) {
+        return 0;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public int checkUriPermission(Uri uri, String s, String s1, int i, int i1, int i2) {
+        return 0;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void enforceUriPermission(Uri uri, int i, int i1, int i2, String s) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void enforceCallingUriPermission(Uri uri, int i, String s) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void enforceCallingOrSelfUriPermission(Uri uri, int i, String s) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public void enforceUriPermission(Uri uri, String s, String s1, int i, int i1, int i2, String s2) {
+        //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public Context createPackageContext(String s, int i) throws PackageManager.NameNotFoundException {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public Context createConfigurationContext(Configuration overrideConfiguration) {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+
+    @Override
+    public Context createDisplayContext(Display display) {
+        return null;  //To change body of implemented methods use File | Settings | File Templates.
+    }
+}
diff --git a/src/test/java/com/orm/query/QueryBuilderTests.java b/src/test/java/com/orm/query/QueryBuilderTests.java
new file mode 100644
index 00000000..96e3c79f
--- /dev/null
+++ b/src/test/java/com/orm/query/QueryBuilderTests.java
@@ -0,0 +1,29 @@
+package com.orm.query;
+
+import com.orm.util.QueryBuilder;
+
+import org.junit.Test;
+
+import static junit.framework.Assert.assertEquals;
+
+public class QueryBuilderTests {
+    @Test(expected=RuntimeException.class)
+    public void noArgumentsTest() {
+        QueryBuilder.generatePlaceholders(0);
+    }
+
+    @Test()
+    public void oneArgumentsTest() {
+        assertEquals("?", QueryBuilder.generatePlaceholders(1));
+    }
+
+    @Test
+    public void twoArgumentsTest() {
+        assertEquals("?,?", QueryBuilder.generatePlaceholders(2));
+    }
+
+    @Test
+    public void manyArgumentsTest() {
+        assertEquals("?,?,?,?,?,?,?,?,?,?", QueryBuilder.generatePlaceholders(10));
+    }
+}
diff --git a/src/test/java/com/orm/query/SelectTest.java b/src/test/java/com/orm/query/SelectTest.java
new file mode 100644
index 00000000..3ab345ae
--- /dev/null
+++ b/src/test/java/com/orm/query/SelectTest.java
@@ -0,0 +1,104 @@
+package com.orm.query;
+
+import org.junit.Test;
+
+import static junit.framework.Assert.assertEquals;
+
+public class SelectTest {
+
+    @Test
+    public void testMergeCondition(){
+        Select where = Select.from(TestRecord.class).where(Condition.prop("test").eq("satya"));
+        assertEquals("(test = ? )", where.getWhereCond());
+        assertEquals(1, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+
+        where = Select.from(TestRecord.class).where(Condition.prop("test").eq("satya"), Condition.prop("prop").eq(2));
+        assertEquals("(test = ?  AND prop = ? )", where.getWhereCond());
+        assertEquals(2, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+        assertEquals("2", where.getArgs()[1]);
+    }
+
+
+    @Test
+    public void testWhere(){
+        Select where = Select.from(TestRecord.class).where(Condition.prop("test").eq("satya"));
+        assertEquals("(test = ? )", where.getWhereCond());
+        assertEquals(1, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+
+        where = Select.from(TestRecord.class).where(Condition.prop("test").eq("satya"), Condition.prop("prop").eq(2));
+        assertEquals("(test = ?  AND prop = ? )", where.getWhereCond());
+        assertEquals(2, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+        assertEquals("2", where.getArgs()[1]);
+    }
+
+
+    @Test
+    public void testWhereOr(){
+        Select where = Select.from(TestRecord.class).whereOr(Condition.prop("test").eq("satya"));
+        assertEquals("(test = ? )", where.getWhereCond());
+        assertEquals(1, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+
+        where = Select.from(TestRecord.class).whereOr(Condition.prop("test").eq("satya"), Condition.prop("prop").eq(2));
+        assertEquals("(test = ?  OR prop = ? )", where.getWhereCond());
+        assertEquals(2, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+        assertEquals("2", where.getArgs()[1]);
+    }
+
+    @Test
+    public void testAnd(){
+        Select where = Select.from(TestRecord.class).whereOr(Condition.prop("test").eq("satya"));
+        assertEquals("(test = ? )", where.getWhereCond());
+        assertEquals(1, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+
+        where.and(Condition.prop("prop").eq(2));
+
+        assertEquals("(test = ? ) AND (prop = ? )", where.getWhereCond());
+        assertEquals(2, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+        assertEquals("2", where.getArgs()[1]);
+    }
+
+    @Test
+    public void testOr(){
+        Select where = Select.from(TestRecord.class).whereOr(Condition.prop("test").eq("satya"));
+        assertEquals("(test = ? )", where.getWhereCond());
+        assertEquals(1, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+
+        where.or(Condition.prop("prop").eq(2));
+
+        assertEquals("(test = ? ) OR (prop = ? )", where.getWhereCond());
+        assertEquals(2, where.getArgs().length);
+        assertEquals("satya", where.getArgs()[0]);
+        assertEquals("2", where.getArgs()[1]);
+    }
+
+    @Test
+    public void testIsNull() {
+        Select where = Select.from(TestRecord.class).where(Condition.prop("test").isNull());
+        assertEquals("(test IS NULL )", where.getWhereCond());
+        assertEquals(0, where.getArgs().length);
+
+        where = Select.from(TestRecord.class).where(Condition.prop("test").eq(null));
+        assertEquals("(test IS NULL )", where.getWhereCond());
+        assertEquals(0, where.getArgs().length);
+    }
+
+    @Test
+    public void testIsNotNull() {
+        Select where = Select.from(TestRecord.class).where(Condition.prop("test").isNotNull());
+        assertEquals("(test IS NOT NULL )", where.getWhereCond());
+        assertEquals(0, where.getArgs().length);
+
+        where = Select.from(TestRecord.class).where(Condition.prop("test").notEq(null));
+        assertEquals("(test IS NOT NULL )", where.getWhereCond());
+        assertEquals(0, where.getArgs().length);
+    }
+}
diff --git a/src/test/java/com/orm/query/TestRecord.java b/src/test/java/com/orm/query/TestRecord.java
new file mode 100644
index 00000000..50997205
--- /dev/null
+++ b/src/test/java/com/orm/query/TestRecord.java
@@ -0,0 +1,13 @@
+package com.orm.query;
+
+import android.content.Context;
+import com.orm.SugarRecord;
+
+public class TestRecord extends SugarRecord {
+
+    private String name;
+
+    public TestRecord(Context context) {
+        super();
+    }
+}
diff --git a/sugarOrm.iml b/sugarOrm.iml
new file mode 100644
index 00000000..13231449
--- /dev/null
+++ b/sugarOrm.iml
@@ -0,0 +1,96 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id=":sugarOrm" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="DataCache" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android-gradle" name="Android-Gradle">
+      <configuration>
+        <option name="GRADLE_PROJECT_PATH" value=":sugarOrm" />
+      </configuration>
+    </facet>
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="SELECTED_BUILD_VARIANT" value="debug" />
+        <option name="SELECTED_TEST_ARTIFACT" value="_android_test_" />
+        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
+        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
+        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
+        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugAndroidTest" />
+        <option name="COMPILE_JAVA_TEST_TASK_NAME" value="compileDebugAndroidTestSources" />
+        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugAndroidTestSources" />
+        <option name="ALLOW_USER_CONFIGURATION" value="false" />
+        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />
+        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />
+        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />
+        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />
+        <option name="LIBRARY_PROJECT" value="true" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />
+    <output-test url="file://$MODULE_DIR$/build/intermediates/classes/androidTest/debug" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/debug" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/androidTest/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/androidTest/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/androidTest/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/androidTest/debug" isTestSource="true" generated="true" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/androidTest/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/androidTest/debug" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/coverage-instrumented-classes" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex-cache" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.android.support/support-v4/21.0.3/jars" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jacoco" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/javaResources" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/libs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/lint" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/ndk" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/proguard" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/res" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
+      <excludeFolder url="file://$MODULE_DIR$/build/libs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
+      <excludeFolder url="file://$MODULE_DIR$/build/tmp" />
+    </content>
+    <orderEntry type="jdk" jdkName="Android API 21 Platform" jdkType="Android SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" exported="" name="support-annotations-21.0.3" level="project" />
+    <orderEntry type="library" exported="" name="support-v4-21.0.3" level="project" />
+    <orderEntry type="library" exported="" name="guava-18.0" level="project" />
+  </component>
+</module>
\ No newline at end of file
