diff --git a/library/AndroidManifest.xml b/library/AndroidManifest.xml
index 65bb4873..be9bceb3 100644
--- a/library/AndroidManifest.xml
+++ b/library/AndroidManifest.xml
@@ -3,6 +3,6 @@
           package="com.orm.dsl"
           android:versionCode="1"
           android:versionName="1.0">
-    <uses-sdk android:minSdkVersion="4" />
+    <uses-sdk android:minSdkVersion="11" />
 
 </manifest>
\ No newline at end of file
diff --git a/library/src/com/orm/ORMProvider.java b/library/src/com/orm/ORMProvider.java
index 925bf2ad..c877ff8b 100644
--- a/library/src/com/orm/ORMProvider.java
+++ b/library/src/com/orm/ORMProvider.java
@@ -1,5 +1,7 @@
 package com.orm;
 
+import static com.orm.SugarApp.getSugarContext;
+
 import java.util.Iterator;
 import java.util.List;
 
@@ -21,27 +23,33 @@
 	 * All of these methods except onCreate() can be called by multiple threads at once, so they must be thread-safe
 	 */
 	
-	@Override
-	public boolean onCreate()
-	{
-		//The Android system calls onCreate() when it starts up the provider. 
-		//You should perform only fast-running initialization tasks in this method, and defer database creation and data loading until the provider actually receives a request for the data
-		return false;
-	}
-	
+	private SQLiteDatabase db;
 	static final String PROVIDER_NAME = "app.unifi.provider";
 	static final String URL = "content://" + PROVIDER_NAME + "/router";
 	static public final Uri CONTENT_URI = Uri.parse(URL);
 	
-	static final int ROUTER = 1;
-	static final int ROUTER_ID = 2;
-	
+	static final int TABLE = 1;
+	static final int ROW = 2;
+	static final int RAW_QUERY = 3;
+	static final int EXEC_SQL = 4;
+
 	static final UriMatcher uriMatcher;
 	static
 	{
 	      uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
-	      uriMatcher.addURI(PROVIDER_NAME, "router", ROUTER);
-	      uriMatcher.addURI(PROVIDER_NAME, "router/#", ROUTER_ID);
+	      uriMatcher.addURI(PROVIDER_NAME, "RAW_QUERY", RAW_QUERY);
+	      uriMatcher.addURI(PROVIDER_NAME, "EXEC_SQL", EXEC_SQL);
+	      uriMatcher.addURI(PROVIDER_NAME, "*", TABLE);//only matches one segment
+	      uriMatcher.addURI(PROVIDER_NAME, "*/#", ROW);
+	}
+	
+	@Override
+	public boolean onCreate()
+	{
+		//The Android system calls onCreate() when it starts up the provider. 
+		//You should perform only fast-running initialization tasks in this method, and defer database creation and data loading until the provider actually receives a request for the data
+		db = getSugarContext().getDatabase().getDB();
+		return (db == null)? false:true;
 	}
 	
 	@Override
@@ -58,36 +66,41 @@ public int delete(Uri uri, String selection, String[] selectionArgs)
 		//List<Router> search_results = Router.find(Router.class, "ssid = ?", "\"InfoScout\"");
 		// UnsupportedOperationException ()
 		int count = 0;
+		String table;
 		switch (uriMatcher.match(uri))
 		{
-	      case ROUTER:
-	    	 Router.deleteAll(Router.class);
+	      case TABLE:
+	    	 table = uri.getPathSegments().get(0);
+	    	 db.delete(table, selection, selectionArgs);
 	         break;
-	      case ROUTER_ID:
-	    	  String param = uri.getPathSegments().get(1);
-	    	  Long id = Long.parseLong(param);
-	    	  Router router = Router.findById(Router.class, id);
-	  		  router.delete();
-		}		
+	      case ROW:
+	    	  /*table = uri.getPathSegments().get(0);
+	    	  String row = uri.getPathSegments().get(1);
+		      db.delete(table, selection, selectionArgs);*/
+	    	  throw new UnsupportedOperationException( "Not Implemented");
+		}
 		return count;
 	}
 
 	@Override
 	public String getType(Uri uri)
 	{
+		String table;
 		//Return the MIME type corresponding to a content URI
 		switch (uriMatcher.match(uri))
 		{
 	      /**
-	       * Get all router records 
+	       * Get all table records 
 	       */
-	      case ROUTER:
-	         return "vnd.android.cursor.dir/vnd.net.akbars.unifi.router";
+	      case TABLE:
+	    	 table = uri.getPathSegments().get(0);
+	         return "vnd.android.cursor.dir/vnd.net.akbars.unifi." + table;
 	      /** 
 	       * Get a particular router
 	       */
-	      case ROUTER_ID:
-	         return "vnd.android.cursor.item/vnd.net.akbars.unifi.router";
+	      case ROW:
+	    	 table = uri.getPathSegments().get(0);
+	         return "vnd.android.cursor.item/vnd.net.akbars.unifi." + table;
 	      default:
 	         throw new IllegalArgumentException("Unsupported URI: " + uri);
 	    }
@@ -98,10 +111,8 @@ public Uri insert(Uri uri, ContentValues values)
 	{
 		//Return a content URI for the newly-inserted row
 		//getAsString returns the value or null if the value is missing or cannot be converted
-		String ssid = values.getAsString("ssid");
-		String bssid = values.getAsString("bssid");
-		Router new_router = new Router(getContext(), ssid, bssid);
-		new_router.save();
+		String table = uri.getPathSegments().get(0);
+		db.insert(table, null, values);
 		return null;
 	}
 
@@ -115,19 +126,23 @@ public Cursor query(Uri uri, String[] projection, String selection, String[] sel
 		 * sortOrder specifies the order in which rows appear in the returned Cursor
 		 */
 		Cursor cursor = null;
+		String table = null;
 		switch (uriMatcher.match(uri))
 		{
-	      case ROUTER:
-	    	  List<Router> routers = Router.find(Router.class, selection, selectionArgs);
-	    	  String[] whereArgs;
-	    	  Iterator<Router> it = Router.findAsIterator(Router.class, selection, selectionArgs);
-	    	  //cursor = Router.findAsCursor(Router.class, selection, selectionArgs);
+	      case TABLE:
+	    	  table = uri.getPathSegments().get(0);
+	    	  cursor = db.query(table,projection,selection,selectionArgs,null,null,sortOrder);
 	    	  return cursor;
-		case ROUTER_ID:
-	    	  String param = uri.getPathSegments().get(1);
-	    	  String[] params = {param};
-	    	  //cursor = Router.findAsCursor(Router.class, "WHERE id = ?", params);
+		case ROW:
+			  table = uri.getPathSegments().get(0);
+	    	  cursor = db.query(table,projection,selection,selectionArgs,null,null,sortOrder);
 	    	  return cursor;
+		case RAW_QUERY:
+			cursor = db.rawQuery(selection, selectionArgs);//query, arguments
+			return cursor;
+		case EXEC_SQL:
+			db.execSQL(selection, selectionArgs);//query, arguments
+			return null;
 		default:
 	         throw new IllegalArgumentException("Unknown URI " + uri);
 	    }
@@ -136,7 +151,7 @@ public Cursor query(Uri uri, String[] projection, String selection, String[] sel
 	@Override
 	public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)
 	{
-		//UPDATE Router SET(key=value) WHERE column = ?, selectionArgs
+		db.update(uri.getPathSegments().get(0), values, selection, selectionArgs);
 		return 0;
 	}
 
diff --git a/library/src/com/orm/SugarRecord.java b/library/src/com/orm/SugarRecord.java
index e60215c2..b9f63864 100644
--- a/library/src/com/orm/SugarRecord.java
+++ b/library/src/com/orm/SugarRecord.java
@@ -5,7 +5,9 @@
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteException;
+import android.database.sqlite.SQLiteQueryBuilder;
 import android.database.sqlite.SQLiteStatement;
+import android.net.Uri;
 import android.text.TextUtils;
 import android.util.Log;
 import com.orm.dsl.Ignore;
@@ -25,37 +27,49 @@
 
     @Ignore
     String tableName = getSqlName();
+	static ORMProvider db;
+	static String PROVIDER_NAME = "app.unifi.provider";
 
     protected Long id = null;
 
-    public void delete() {
-        SQLiteDatabase db = getSugarContext().getDatabase().getDB();
-        db.delete(this.tableName, "Id=?", new String[]{getId().toString()});
+    public void delete()
+    {
+    	//create the URI based on the table name
+    	String url = "content://" + PROVIDER_NAME + "/" + this.tableName;
+    	Uri uri = Uri.parse(url);
+    	db.delete(uri, "Id=?", new String[]{getId().toString()});
     }
 
-    public static <T extends SugarRecord<?>> void deleteAll(Class<T> type) {
-        Database db = getSugarContext().getDatabase();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-        sqLiteDatabase.delete(getTableName(type), null, null);
+    public static <T extends SugarRecord<?>> void deleteAll(Class<T> type)
+    {
+    	//create the URI based on the table name
+    	String url = "content://" + PROVIDER_NAME + "/" + getTableName(type);
+    	Uri uri = Uri.parse(url);
+    	db.delete(uri, null, null);
     }
 
-    public static <T extends SugarRecord<?>> void deleteAll(Class<T> type, String whereClause, String... whereArgs ) {
-        Database db = getSugarContext().getDatabase();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-        sqLiteDatabase.delete(getTableName(type), whereClause, whereArgs);
+    public static <T extends SugarRecord<?>> void deleteAll(Class<T> type, String whereClause, String... whereArgs )
+    {
+    	//create the URI based on the table name
+    	String url = "content://" + PROVIDER_NAME + "/" + getTableName(type);
+    	Uri uri = Uri.parse(url);
+        db.delete(uri, whereClause, whereArgs);
     }
 
-    public void save() {
-        save(getSugarContext().getDatabase().getDB());
+    public void save()
+    {
+        save(db);
     }
 
-    @SuppressWarnings("deprecation")
-    public static <T extends SugarRecord<?>> void saveInTx(T... objects ) {
+    /*@SuppressWarnings("deprecation")
+    public static <T extends SugarRecord<?>> void saveInTx(T... objects )
+    {
         saveInTx(Arrays.asList(objects));
-    }
+    }*/
 
-    @SuppressWarnings("deprecation")
-    public static <T extends SugarRecord<?>> void saveInTx(Collection<T> objects ) {
+    /*@SuppressWarnings("deprecation")
+    public static <T extends SugarRecord<?>> void saveInTx(Collection<T> objects )
+    {
         SQLiteDatabase sqLiteDatabase = getSugarContext().getDatabase().getDB();
 
         try{
@@ -72,117 +86,151 @@ public void save() {
             sqLiteDatabase.setLockingEnabled(true);
         }
 
-    }
-
-    void save(SQLiteDatabase db) {
+    }*/
 
+    void save(ORMProvider orm)
+    {
         List<Field> columns = getTableFields();
         ContentValues values = new ContentValues(columns.size());
-        for (Field column : columns) {
+        for (Field column : columns)
+        {
             column.setAccessible(true);
             Class<?> columnType = column.getType();
             try {
                 String columnName = StringUtil.toSQLName(column.getName());
                 Object columnValue = column.get(this);
-                if (SugarRecord.class.isAssignableFrom(columnType)) {
+                if (SugarRecord.class.isAssignableFrom(columnType))
+                {
                     values.put(columnName,
                             (columnValue != null)
                                     ? String.valueOf(((SugarRecord) columnValue).id)
                                     : "0");
-                } else {
-                    if (!"id".equalsIgnoreCase(column.getName())) {
-                        if (columnType.equals(Short.class) || columnType.equals(short.class)) {
+                } 
+                else
+                {
+                    if (!"id".equalsIgnoreCase(column.getName()))
+                    {
+                        if (columnType.equals(Short.class) || columnType.equals(short.class))
+                        {
                             values.put(columnName, (Short) columnValue);
                         }
-                        else if (columnType.equals(Integer.class) || columnType.equals(int.class)) {
+                        else if (columnType.equals(Integer.class) || columnType.equals(int.class))
+                        {
                             values.put(columnName, (Integer) columnValue);
                         }
-                        else if (columnType.equals(Long.class) || columnType.equals(long.class)) {
+                        else if (columnType.equals(Long.class) || columnType.equals(long.class))
+                        {
                             values.put(columnName, (Long) columnValue);
                         }
-                        else if (columnType.equals(Float.class) || columnType.equals(float.class)) {
+                        else if (columnType.equals(Float.class) || columnType.equals(float.class))
+                        {
                             values.put(columnName, (Float) columnValue);
                         }
-                        else if (columnType.equals(Double.class) || columnType.equals(double.class)) {
+                        else if (columnType.equals(Double.class) || columnType.equals(double.class))
+                        {
                             values.put(columnName, (Double) columnValue);
                         }
-                        else if (columnType.equals(Boolean.class) || columnType.equals(boolean.class)) {
+                        else if (columnType.equals(Boolean.class) || columnType.equals(boolean.class))
+                        {
                             values.put(columnName, (Boolean) columnValue);
                         }
-                        else if (Date.class.equals(columnType)) {
+                        else if (Date.class.equals(columnType))
+                        {
                             values.put(columnName, ((Date) column.get(this)).getTime());
                         }
-                        else if (Calendar.class.equals(columnType)) {
+                        else if (Calendar.class.equals(columnType))
+                        {
                             values.put(columnName, ((Calendar) column.get(this)).getTimeInMillis());
-                        }else{
+                        }
+                        else
+                        {
                             values.put(columnName, String.valueOf(columnValue));
                         }
-
                     }
                 }
-
-            } catch (IllegalAccessException e) {
+            }
+            catch (IllegalAccessException e)
+            {
                 Log.e("Sugar", e.getMessage());
             }
         }
 
+        //create the URI based on the table name
+    	String url = "content://" + PROVIDER_NAME + "/" + getSqlName();
+    	Uri uri = Uri.parse(url);
         if (id == null)
-            id = db.insert(getSqlName(), null, values);
+        {
+            Uri new_row = orm.insert(uri, values);
+            id = Long.parseLong(uri.getPathSegments().get(1));
+        }
         else
-            db.update(getSqlName(), values, "ID = ?", new String[]{String.valueOf(id)});
+        	orm.update(uri, values, "ID = ?", new String[]{String.valueOf(id)});
 
         Log.i("Sugar", getClass().getSimpleName() + " saved : " + id);
     }
 
-    public static <T extends SugarRecord<?>> List<T> listAll(Class<T> type) {
+    public static <T extends SugarRecord<?>> List<T> listAll(Class<T> type)
+    {
         return find(type, null, null, null, null, null);
     }
 
-    public static <T extends SugarRecord<?>> T findById(Class<T> type, Long id) {
+    public static <T extends SugarRecord<?>> T findById(Class<T> type, Long id)
+    {
         List<T> list = find( type, "id=?", new String[]{String.valueOf(id)}, null, null, "1");
         if (list.isEmpty()) return null;
         return list.get(0);
     }
 
-    public static <T extends SugarRecord<?>> Iterator<T> findAll(Class<T> type) {
+    public static <T extends SugarRecord<?>> Iterator<T> findAll(Class<T> type)
+    {
         return findAsIterator(type, null, null, null, null, null);
     }
 
     public static <T extends SugarRecord<?>> Iterator<T> findAsIterator(Class<T> type,
-                                                                        String whereClause, String... whereArgs) {
+                                                                        String whereClause, String... whereArgs)
+    {
         return findAsIterator(type, whereClause, whereArgs, null, null, null);
     }
 
-    public static <T extends SugarRecord<?>> Iterator<T> findWithQueryAsIterator(Class<T> type, String query, String... arguments) {
-        Database db = getSugarContext().getDatabase();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-        Cursor c = sqLiteDatabase.rawQuery(query, arguments);
+    public static <T extends SugarRecord<?>> Iterator<T> findWithQueryAsIterator(Class<T> type, String query, String... arguments)
+    {
+    	//create the URI based on the table name
+    	String url = "content://" + PROVIDER_NAME + "/RAW_QUERY";
+    	Uri uri = Uri.parse(url);
+        Cursor c = db.query(uri, null, query, arguments, null);
         return new CursorIterator<T>(type, c);
     }
 
     public static <T extends SugarRecord<?>> Iterator<T> findAsIterator(Class<T> type,
                                                                     String whereClause, String[] whereArgs,
-                                                                    String groupBy, String orderBy, String limit) {
-
-        Database db = getSugarContext().getDatabase();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-        Cursor c = sqLiteDatabase.query(getTableName(type), null,
-                whereClause, whereArgs, groupBy, null, orderBy, limit);
+                                                                    String groupBy, String orderBy, String limit)
+    {
+    	String url = "content://" + PROVIDER_NAME + "/RAW_SQL";
+    	Uri uri = Uri.parse(url);
+    	//is deprecated: buildQuery (String[] projectionIn, String selection, String[] selectionArgs, String groupBy, String having, String sortOrder, String limit)
+        Object args[] = whereArgs;
+    	String where_query = String.format(whereClause, args);
+    	SQLiteQueryBuilder builder = new SQLiteQueryBuilder();
+    	builder.setTables(getTableName(type));
+    	String query = builder.buildQuery(null, where_query, groupBy, null, orderBy, limit);
+        Cursor c = db.query(uri, null, query, null, null);
         return new CursorIterator<T>(type, c);
     }
 
     public static <T extends SugarRecord<?>> List<T> find(Class<T> type,
-                                                       String whereClause, String... whereArgs) {
+                                                       String whereClause, String... whereArgs)
+    {
         return find(type, whereClause, whereArgs, null, null, null);
     }
 
-    public static <T extends SugarRecord<?>> List<T> findWithQuery(Class<T> type, String query, String... arguments){
-
-        Database db = getSugarContext().getDatabase();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
+    public static <T extends SugarRecord<?>> List<T> findWithQuery(Class<T> type, String query, String... arguments)
+    {
         T entity;
         List<T> toRet = new ArrayList<T>();
-        Cursor c = sqLiteDatabase.rawQuery(query, arguments);
+        //create the URI based on the table name
+    	String url = "content://" + PROVIDER_NAME + "/RAW_QUERY";
+    	Uri uri = Uri.parse(url);
+        Cursor c = db.query(uri, null, query, arguments, null);
 
         try {
             while (c.moveToNext()) {
@@ -198,19 +246,30 @@ else if (Calendar.class.equals(columnType)) {
         return toRet;
     }
 
-    public static void executeQuery(String query, String... arguments){
-        getSugarContext().getDatabase().getDB().execSQL(query, arguments);
+    public static void executeQuery(String query, String... arguments)
+    {
+    	//create the URI based on the table name
+    	String url = "content://" + PROVIDER_NAME + "/EXEC_SQL";
+    	Uri uri = Uri.parse(url);
+        db.query(uri, null, query, arguments, null);
     }
 
     public static <T extends SugarRecord<?>> List<T> find(Class<T> type,
                                                        String whereClause, String[] whereArgs,
-                                                       String groupBy, String orderBy, String limit) {
-        Database db = getSugarContext().getDatabase();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
+                                                       String groupBy, String orderBy, String limit)
+    {
+    	String url = "content://" + PROVIDER_NAME + "/RAW_SQL";
+    	Uri uri = Uri.parse(url);
+    	//is deprecated: buildQuery (String[] projectionIn, String selection, String[] selectionArgs, String groupBy, String having, String sortOrder, String limit)
+        Object args[] = whereArgs;
+    	String where_query = String.format(whereClause, args);
+    	SQLiteQueryBuilder builder = new SQLiteQueryBuilder();
+    	builder.setTables(getTableName(type));
+    	String query = builder.buildQuery(null, where_query, groupBy, null, orderBy, limit);
+        
         T entity;
         List<T> toRet = new ArrayList<T>();
-        Cursor c = sqLiteDatabase.query(getTableName(type), null,
-                whereClause, whereArgs, groupBy, null, orderBy, limit);
+        Cursor c = db.query(uri, null, query, null, null);
         try {
             while (c.moveToNext()) {
                 entity = type.getDeclaredConstructor().newInstance();
@@ -226,18 +285,19 @@ public static void executeQuery(String query, String... arguments){
     }
     
     public static <T extends SugarRecord<?>> long count(Class<?> type,
-            String whereClause, String[] whereArgs) {
+            String whereClause, String[] whereArgs)
+    {
     	return count(type, whereClause, whereArgs, null, null, null);
     }
     
     public static <T extends SugarRecord<?>> long count(Class<?> type,
             String whereClause, String[] whereArgs,
-            String groupBy, String orderBy, String limit) {
-    	
-    	Database db = getSugarContext().getDatabase();
+            String groupBy, String orderBy, String limit)
+    {
+    	/*Database db = getSugarContext().getDatabase();
         SQLiteDatabase sqLiteDatabase = db.getDB();
-
         long toRet = -1;
+
         String filter = (!TextUtils.isEmpty(whereClause)) ? " where "  + whereClause : "";
         SQLiteStatement sqLiteStatament = sqLiteDatabase.compileStatement("SELECT count(*) FROM " + getTableName(type) + filter);
 
@@ -254,8 +314,12 @@ public static void executeQuery(String query, String... arguments){
         } finally {
             sqLiteStatament.close();
         }
-        
-    	return toRet;
+        return toRet;
+        */
+        String url = "content://" + PROVIDER_NAME + "/" + getTableName(type);
+    	Uri uri = Uri.parse(url);
+        Cursor c = db.query(uri, null, whereClause, whereArgs, null);
+        return c.getCount();
     }
 
     @SuppressWarnings("unchecked")
@@ -348,7 +412,8 @@ void inflate(Cursor cursor) {
         }
     }
 
-    public List<Field> getTableFields() {
+    public List<Field> getTableFields()
+    {
         List<Field> fieldList = SugarConfig.getFields(getClass());
         if(fieldList != null) return fieldList;
 
@@ -368,7 +433,8 @@ void inflate(Cursor cursor) {
         return toStore;
     }
 
-    private static List<Field> getAllFields(List<Field> fields, Class<?> type) {
+    private static List<Field> getAllFields(List<Field> fields, Class<?> type)
+    {
         Collections.addAll(fields, type.getDeclaredFields());
 
         if (type.getSuperclass() != null) {
@@ -378,39 +444,46 @@ void inflate(Cursor cursor) {
         return fields;
     }
 
-    public String getSqlName() {
+    public String getSqlName()
+    {
         return getTableName(getClass());
     }
 
-
-    public static String getTableName(Class<?> type) {
+    public static String getTableName(Class<?> type)
+    {
         return StringUtil.toSQLName(type.getSimpleName());
     }
 
-    public Long getId() {
+    public Long getId()
+    {
         return id;
     }
 
-    public void setId(Long id) {
+    public void setId(Long id)
+    {
         this.id = id;
     }
 
-    static class CursorIterator<E extends SugarRecord<?>> implements Iterator<E> {
+    static class CursorIterator<E extends SugarRecord<?>> implements Iterator<E>
+    {
         Class<E> type;
         Cursor cursor;
 
-        public CursorIterator(Class<E> type, Cursor cursor) {
+        public CursorIterator(Class<E> type, Cursor cursor)
+        {
             this.type = type;
             this.cursor = cursor;
         }
 
         @Override
-        public boolean hasNext() {
+        public boolean hasNext()
+        {
             return cursor != null && !cursor.isClosed() && !cursor.isAfterLast();
         }
 
         @Override
-        public E next() {
+        public E next()
+        {
             E entity = null;
             if (cursor == null || cursor.isAfterLast()) {
                 throw new NoSuchElementException();
@@ -435,11 +508,9 @@ public E next() {
         }
 
         @Override
-        public void remove() {
+        public void remove()
+        {
             throw new UnsupportedOperationException();
         }
-
-
     }
-
 }
