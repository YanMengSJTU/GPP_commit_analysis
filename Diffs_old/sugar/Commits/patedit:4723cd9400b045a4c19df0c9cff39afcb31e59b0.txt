diff --git a/README.md b/README.md
index 6986479b..e23d303d 100644
--- a/README.md
+++ b/README.md
@@ -1,209 +1,19 @@
-# Sugar ORM [![Build Status](https://travis-ci.org/satyan/sugar.svg?branch=master)](https://travis-ci.org/satyan/sugar) [![Coverage Status](https://coveralls.io/repos/satyan/sugar/badge.svg?branch=master)](https://coveralls.io/r/satyan/sugar?branch=master) [![Code Triagers Badge](http://www.codetriage.com/satyan/sugar/badges/users.svg)](http://www.codetriage.com/satyan/sugar)
+Please follow the sugar documentation at
+http://satyan.github.io/sugar
 
-[![Join the chat at https://gitter.im/satyan/sugar](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/satyan/sugar?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
+The example application is provided in the "example" folder in the source.
 
-Insanely easy way to work with Android databases.
+# Sugar Cipher Changes
 
-Official documentation can be found [here](http://satyan.github.io/sugar) - Check some examples below. The example application is provided in the **example** folder in the source.
+Add a meta property named ENCRYPTION_KEY in your manifest file along with other Sugar configuration as follows:
 
-## Looking for contributors
-We need contributors to help maintain this project, ask @satyan for repo permission
+        <meta-data android:name="ENCRYPTION_KEY" android:value="<your own key here>" />
+        
+Include the SQLCipher libraries and assets from this link:
+https://s3.amazonaws.com/sqlcipher/SQLCipher+for+Android+v3.1.0.zip
 
-Otherwise you can use another ORM, like https://github.com/requery/requery or https://realm.io/
+Extract the libs and assets into your application. This dependency is not included in the sugar library.
 
-## Features
+You're good to go. Use Sugar as usual and your database is encrypted now.
 
-Sugar ORM was built in contrast to other ORM's to have:
 
-- A simple, concise, and clean integration process with minimal configuration.
-- Automatic table and column naming through reflection.
-- Support for migrations between different schema versions.
-
-## Installing
-
-There are four ways to install Sugar:
-
-#### As a Gradle dependency
-
-This is the preferred way. Simply add:
-
-```groovy
-compile 'com.github.satyan:sugar:1.5'
-```
-
-to your project dependencies and run `gradle build` or `gradle assemble`.
-
-#### As a Maven dependency
-
-Declare the dependency in Maven:
-
-```xml
-<dependency>
-    <groupId>com.github.satyan</groupId>
-    <artifactId>sugar</artifactId>
-    <version>1.5</version>
-</dependency>
-```
-
-#### As a library project
-
-Download the source code and import it as a library project in Eclipse. The project is available in the folder **library**. For more information on how to do this, read [here](http://developer.android.com/tools/projects/index.html#LibraryProjects).
-
-#### As a jar
-
-Visit the [releases](https://github.com/satyan/sugar/releases) page to download jars directly. You can drop them into your `libs` folder and configure the Java build path to include the library. See this [tutorial](http://www.vogella.com/tutorials/AndroidLibraryProjects/article.html) for an excellent guide on how to do this.
-
-
-### How to use master version
-First, download sugar repository
-```
-git clone git@github.com:satyan/sugar.git
-```
-
-include this in your **settings.gradle**
-```gradle
-include ':app' // your module app
-include ':sugar'
-
-def getLocalProperty(prop) {
-	Properties properties = new Properties()
-	properties.load(new File(rootDir.absolutePath + '/local.properties').newDataInputStream())
-	return properties.getProperty(prop, '')
-}
-
-project(':sugar').projectDir = new File(getLocalProperty('sugar.dir'))
-
-```
-
-include this in your **local.properties**
-```
-sugar.dir=/path/to/sugar/library
-```
-
-add sugar project to the dependencies of your main project (build.gradle)
-```gradle
-dependencies {
-    compile project(':sugar')
-}
-```
-
-You should also comment this line just comment this line (library/build.gradle): https://github.com/satyan/sugar/blob/master/library%2Fbuild.gradle#L2
-
-```gradle
-// apply from: '../maven_push.gradle'
-```
-===================
-
-After installing, check out how to set up your first database and models [here](http://satyan.github.io/sugar/getting-started.html) **Outdated**. Check examples of 1.4 and master below: 
-
-## Examples
-### SugarRecord
-```java
-public class Book extends SugarRecord {
-  @Unique
-  String isbn;
-  String title;
-  String edition;
-
-  // Default constructor is necessary for SugarRecord
-  public Book() {
-
-  }
-
-  public Book(String isbn, String title, String edition) {
-    this.isbn = isbn;
-    this.title = title;
-    this.edition = edition;
-  }
-}
-```
-or
-```java
-@Table
-public class Book { ... }
-```
-
-### Save Entity
-```java
-Book book = new Book("isbn123", "Title here", "2nd edition")
-book.save();
-```
-
-or
-```java
-SugarRecord.save(book); // if using the @Table annotation 
-```
-
-### Load Entity
-```java
-Book book = Book.findById(Book.class, 1);
-```
-
-### Update Entity
-```java
-Book book = Book.findById(Book.class, 1);
-book.title = "updated title here"; // modify the values
-book.edition = "3rd edition";
-book.save(); // updates the previous entry with new values.
-```
-
-
-### Delete Entity
-```java
-Book book = Book.findById(Book.class, 1);
-book.delete();
-```
-
-or
-```java
-SugarRecord.delete(book); // if using the @Table annotation 
-```
-
-### Update Entity based on Unique values
-```java
-Book book = new Book("isbn123", "Title here", "2nd edition")
-book.save();
-
-// Update book with isbn123
-Book sameBook = new Book("isbn123", "New Title", "5th edition")
-sameBook.update();
-
-book.getId() == sameBook.getId(); // true
-```
-
-or
-```java
-SugarRecord.update(sameBook); // if using the @Table annotation 
-```
-
-### Bulk Insert
-```java
-List<Book> books = new ArrayList<>();
-books.add(new Book("isbn123", "Title here", "2nd edition"))
-books.add(new Book("isbn456", "Title here 2", "3nd edition"))
-books.add(new Book("isbn789", "Title here 3", "4nd edition"))
-SugarRecord.saveInTx(books);
-```
-
-### When using ProGuard
-```java
-# Ensures entities remain un-obfuscated so table and columns are named correctly
--keep class com.yourpackage.yourapp.domainclasspackage.** { *; }
-```
-
-### Known Issues. 
-#### 1. Instant Run. 
-Instant-Run seems to prevent Sugar ORM from finding the "table" classes, therefore it cannot create the DB tables if you run the app for the first time 
-
-When running your app for the first time Turn off Instant run once to allow for the DB tables to be created
-You can enable it after the tables have been created. 
-
-To disable Instant-Run in Android Studio: 
-
-``(Preferences (Mac) or Settings (PC) -> Build, Execution, Deployment -> Instant Run -> Untick "Enable Instant Run..." )``
-
-## [CHANGELOG](https://github.com/satyan/sugar/blob/master/CHANGELOG.md)
-
-## Contributing
-
-Please fork this repository and contribute back using [pull requests](https://github.com/satyan/sugar/pulls). Features can be requested using [issues](https://github.com/satyan/sugar/issues). All code, comments, and critiques are greatly appreciated.
diff --git a/dist/sugar_cipher.jar b/dist/sugar_cipher.jar
new file mode 100644
index 00000000..308e26eb
Binary files /dev/null and b/dist/sugar_cipher.jar differ
diff --git a/example/assets/icudt46l.zip b/example/assets/icudt46l.zip
new file mode 100644
index 00000000..91dc7f71
Binary files /dev/null and b/example/assets/icudt46l.zip differ
diff --git a/example/libs/armeabi-v7a/libdatabase_sqlcipher.so b/example/libs/armeabi-v7a/libdatabase_sqlcipher.so
new file mode 100755
index 00000000..54164f8a
Binary files /dev/null and b/example/libs/armeabi-v7a/libdatabase_sqlcipher.so differ
diff --git a/example/libs/armeabi-v7a/libsqlcipher_android.so b/example/libs/armeabi-v7a/libsqlcipher_android.so
new file mode 100755
index 00000000..0871db16
Binary files /dev/null and b/example/libs/armeabi-v7a/libsqlcipher_android.so differ
diff --git a/example/libs/armeabi-v7a/libstlport_shared.so b/example/libs/armeabi-v7a/libstlport_shared.so
new file mode 100755
index 00000000..0355c25f
Binary files /dev/null and b/example/libs/armeabi-v7a/libstlport_shared.so differ
diff --git a/example/libs/armeabi/libdatabase_sqlcipher.so b/example/libs/armeabi/libdatabase_sqlcipher.so
new file mode 100755
index 00000000..fbf1de33
Binary files /dev/null and b/example/libs/armeabi/libdatabase_sqlcipher.so differ
diff --git a/example/libs/armeabi/libsqlcipher_android.so b/example/libs/armeabi/libsqlcipher_android.so
new file mode 100755
index 00000000..f56fff76
Binary files /dev/null and b/example/libs/armeabi/libsqlcipher_android.so differ
diff --git a/example/libs/armeabi/libstlport_shared.so b/example/libs/armeabi/libstlport_shared.so
new file mode 100755
index 00000000..00947b2c
Binary files /dev/null and b/example/libs/armeabi/libstlport_shared.so differ
diff --git a/example/libs/commons-codec.jar b/example/libs/commons-codec.jar
new file mode 100644
index 00000000..957b6752
Binary files /dev/null and b/example/libs/commons-codec.jar differ
diff --git a/example/libs/guava-r09.jar b/example/libs/guava-r09.jar
new file mode 100644
index 00000000..f8da8b1c
Binary files /dev/null and b/example/libs/guava-r09.jar differ
diff --git a/example/libs/sqlcipher.jar b/example/libs/sqlcipher.jar
new file mode 100644
index 00000000..e35ee64a
Binary files /dev/null and b/example/libs/sqlcipher.jar differ
diff --git a/example/libs/x86/libdatabase_sqlcipher.so b/example/libs/x86/libdatabase_sqlcipher.so
new file mode 100755
index 00000000..826443a3
Binary files /dev/null and b/example/libs/x86/libdatabase_sqlcipher.so differ
diff --git a/example/libs/x86/libsqlcipher_android.so b/example/libs/x86/libsqlcipher_android.so
new file mode 100755
index 00000000..4d16e4e2
Binary files /dev/null and b/example/libs/x86/libsqlcipher_android.so differ
diff --git a/example/libs/x86/libstlport_shared.so b/example/libs/x86/libstlport_shared.so
new file mode 100755
index 00000000..a3a6dc59
Binary files /dev/null and b/example/libs/x86/libstlport_shared.so differ
diff --git a/example/src/main/AndroidManifest.xml b/example/src/main/AndroidManifest.xml
index eb802533..ca4cc08f 100644
--- a/example/src/main/AndroidManifest.xml
+++ b/example/src/main/AndroidManifest.xml
@@ -13,5 +13,6 @@
         <meta-data android:name="DATABASE" android:value="sugar_example.db" />
         <meta-data android:name="VERSION" android:value="3" />
         <meta-data android:name="QUERY_LOG" android:value="true" />
+        <meta-data android:name="ENCRYPTION_KEY" android:value="qwerqweradflj;qwekrjlqw;erj" />
     </application>
 </manifest> 
diff --git a/library/build.gradle b/library/build.gradle
index 907162ee..8dd27987 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,36 +1,29 @@
-apply plugin: 'com.android.library'
-apply from: '../maven_push.gradle'
-
-android {
-    compileSdkVersion 23
-    buildToolsVersion "23.0.3"
+buildscript {
+        repositories {
+            mavenCentral()
+        }
 
-    defaultConfig {
-        minSdkVersion 9
-        targetSdkVersion 23
-    }
-    buildTypes {
-        release {
-            minifyEnabled false
+        dependencies {
+            classpath 'com.android.tools.build:gradle:0.11.+'
         }
     }
-    testOptions {
-        unitTests.returnDefaultValues = true
-    }
-    lintOptions {
-        abortOnError false
-    }
-}
 
-dependencies {
-    testCompile 'junit:junit:4.12'
-    testCompile 'org.robolectric:robolectric:3.0'
-}
+    apply plugin: 'android-library'
 
-task libraryJar(type: Jar) {
-    dependsOn assembleRelease
-    from android.sourceSets.main.java.srcDirs,
-         ['build/intermediates/classes/release/'] // Add the release classes into the jar
-    baseName 'sugar'
-}
+    dependencies {
+        compile 'com.android.support:support-v4:19.0.1'
+    }
 
+    android {
+        compileSdkVersion 19
+        buildToolsVersion "19.0.3"
+        sourceSets {
+            main {
+                manifest.srcFile 'AndroidManifest.xml'
+                java.srcDirs = ['src']
+                resources.srcDirs = ['src']
+                res.srcDirs = ['res']
+                assets.srcDirs = ['assets']
+            }
+        }
+    }
diff --git a/library/src/com/orm/Database.java b/library/src/com/orm/Database.java
new file mode 100644
index 00000000..b4f9e973
--- /dev/null
+++ b/library/src/com/orm/Database.java
@@ -0,0 +1,27 @@
+package com.orm;
+
+import android.content.Context;
+import net.sqlcipher.database.SQLiteDatabase;
+
+
+public class Database {
+    private final String databasePassword;
+    private SugarDb sugarDb;
+    private SQLiteDatabase sqLiteDatabase;
+
+    public Database(Context context){
+        SQLiteDatabase.loadLibs(context);
+        databasePassword = SugarConfig.getDatabasePassword(context);
+        this.sugarDb  = new SugarDb(context);
+    }
+
+
+    public synchronized SQLiteDatabase getDB() {
+        if (this.sqLiteDatabase == null) {
+            this.sqLiteDatabase = this.sugarDb.getWritableDatabase(databasePassword);
+        }
+
+        return this.sqLiteDatabase;
+    }
+
+}
diff --git a/library/src/com/orm/SugarConfig.java b/library/src/com/orm/SugarConfig.java
new file mode 100644
index 00000000..3a0816ff
--- /dev/null
+++ b/library/src/com/orm/SugarConfig.java
@@ -0,0 +1,122 @@
+package com.orm;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.util.Log;
+
+import java.lang.reflect.Field;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class SugarConfig {
+
+    static Map<Class<?>, List<Field>> fields = new HashMap<Class<?>, List<Field>>();
+
+    public static String getDatabaseName(Context context) {
+        String databaseName = getMetaDataString(context, "DATABASE");
+
+        if (databaseName == null) {
+            databaseName = "Sugar.db";
+        }
+
+        return databaseName;
+    }
+
+    public static void setFields(Class<?> clazz, List<Field> fieldz){
+         fields.put(clazz, fieldz);
+    }
+
+    public static List<Field> getFields(Class<?> clazz){
+
+        if(fields.containsKey(clazz)){
+            List<Field> list = fields.get(clazz);
+            return Collections.synchronizedList(list);
+        }
+
+        return null;
+    }
+
+    public static void clearCache(){
+        fields.clear();
+        fields = new HashMap<Class<?>, List<Field>>();
+    }
+
+    public static int getDatabaseVersion(Context context) {
+        Integer databaseVersion = getMetaDataInteger(context, "VERSION");
+
+        if ((databaseVersion == null) || (databaseVersion == 0)) {
+            databaseVersion = 1;
+        }
+
+        return databaseVersion;
+    }
+
+    public static String getDatabasePassword(Context context) {
+        String encryptionKey = getMetaDataString(context, "ENCRYPTION_KEY");
+
+        if ((encryptionKey == null) || (encryptionKey.trim().equals(""))) {
+            encryptionKey = "DEFAULT_ENCRYPTION_KEY";
+        }
+
+        return encryptionKey;
+    }
+
+    public static String getDomainPackageName(Context context){
+        String domainPackageName = getMetaDataString(context, "DOMAIN_PACKAGE_NAME");
+
+        if (domainPackageName == null) {
+            domainPackageName = "";
+        }
+
+        return domainPackageName;
+    }
+
+    public static boolean getDebugEnabled(Context context) {
+        return getMetaDataBoolean(context, "QUERY_LOG");
+    }
+
+    public static String getMetaDataString(Context context, String name) {
+        String value = null;
+
+        PackageManager pm = context.getPackageManager();
+        try {
+            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(), 128);
+            value = ai.metaData.getString(name);
+        } catch (Exception e) {
+            Log.d("sugar", "Couldn't find config value: " + name);
+        }
+
+        return value;
+    }
+
+    public static Integer getMetaDataInteger(Context context, String name) {
+        Integer value = null;
+
+        PackageManager pm = context.getPackageManager();
+        try {
+            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(), 128);
+            value = ai.metaData.getInt(name);
+        } catch (Exception e) {
+            Log.d("sugar", "Couldn't find config value: " + name);
+        }
+
+        return value;
+    }
+
+    public static Boolean getMetaDataBoolean(Context context, String name) {
+        Boolean value = false;
+
+        PackageManager pm = context.getPackageManager();
+        try {
+            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(), 128);
+            value = ai.metaData.getBoolean(name);
+        } catch (Exception e) {
+            Log.d("sugar", "Couldn't find config value: " + name);
+        }
+
+        return value;
+    }
+}
diff --git a/library/src/com/orm/SugarDb.java b/library/src/com/orm/SugarDb.java
new file mode 100644
index 00000000..c0f6d8e3
--- /dev/null
+++ b/library/src/com/orm/SugarDb.java
@@ -0,0 +1,212 @@
+package com.orm;
+
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.util.Log;
+import dalvik.system.DexFile;
+import net.sqlcipher.database.SQLiteDatabase;
+import net.sqlcipher.database.SQLiteException;
+import net.sqlcipher.database.SQLiteOpenHelper;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Modifier;
+import java.util.*;
+
+import static com.orm.SugarConfig.getDatabaseVersion;
+import static com.orm.SugarConfig.getDebugEnabled;
+
+public class SugarDb extends SQLiteOpenHelper {
+    private Context context;
+
+    public SugarDb(Context context) {
+        super(context, SugarConfig.getDatabaseName(context), new SugarCursorFactory(getDebugEnabled(context)), getDatabaseVersion(context));
+        this.context = context;
+
+    }
+
+    private <T extends SugarRecord<?>> List<T> getDomainClasses(Context context) {
+        List<T> domainClasses = new ArrayList<T>();
+        try {
+            Enumeration<?> allClasses = getAllClasses(context);
+
+            while (allClasses.hasMoreElements()) {
+                String className = (String) allClasses.nextElement();
+
+                if (className.startsWith(SugarConfig.getDomainPackageName(context))) {
+                    T domainClass = getDomainClass(className, context);
+                    if (domainClass != null) domainClasses.add(domainClass);
+                }
+            }
+
+        } catch (IOException e) {
+            Log.e("Sugar", e.getMessage());
+        } catch (PackageManager.NameNotFoundException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+
+        return domainClasses;
+    }
+
+    @SuppressWarnings("unchecked")
+    private <T extends SugarRecord<?>> T getDomainClass(String className, Context context) {
+        Log.i("Sugar", "domain class");
+        Class<?> discoveredClass = null;
+        try {
+            discoveredClass = Class.forName(className, true, context.getClass().getClassLoader());
+        } catch (ClassNotFoundException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+
+        if ((discoveredClass == null) ||
+                (!SugarRecord.class.isAssignableFrom(discoveredClass)) ||
+                Modifier.isAbstract(discoveredClass.getModifiers())) {
+            return null;
+        } else {
+            try {
+                return (T) discoveredClass.getDeclaredConstructor().newInstance();
+            } catch (InstantiationException e) {
+                Log.e("Sugar", e.getMessage());
+            } catch (IllegalAccessException e) {
+                Log.e("Sugar", e.getMessage());
+            } catch (NoSuchMethodException e) {
+                Log.e("Sugar", e.getMessage());
+            } catch (InvocationTargetException e) {
+                Log.e("Sugar", e.getMessage());
+            }
+        }
+
+        return null;
+
+    }
+
+    private Enumeration<?> getAllClasses(Context context) throws PackageManager.NameNotFoundException, IOException {
+        String path = getSourcePath(context);
+        DexFile dexfile = new DexFile(path);
+        return dexfile.entries();
+    }
+
+    private String getSourcePath(Context context) throws PackageManager.NameNotFoundException {
+        return context.getPackageManager().getApplicationInfo(context.getPackageName(), 0).sourceDir;
+    }
+
+    @Override
+    public void onCreate(SQLiteDatabase sqLiteDatabase) {
+        Log.i("Sugar", "on create");
+        createDatabase(sqLiteDatabase);
+    }
+
+    private <T extends SugarRecord<?>> void createDatabase(SQLiteDatabase sqLiteDatabase) {
+        List<T> domainClasses = getDomainClasses(context);
+        for (T domain : domainClasses) {
+            createTable(domain, sqLiteDatabase);
+        }
+    }
+
+    private <T extends SugarRecord<?>> void createTable(T table, SQLiteDatabase sqLiteDatabase) {
+        Log.i("Sugar", "create table");
+        List<Field> fields = table.getTableFields();
+        StringBuilder sb = new StringBuilder("CREATE TABLE ").append(table.getSqlName()).append(
+                " ( ID INTEGER PRIMARY KEY AUTOINCREMENT ");
+
+        for (Field column : fields) {
+            String columnName = StringUtil.toSQLName(column.getName());
+            String columnType = QueryBuilder.getColumnType(column.getType());
+
+            if (columnType != null) {
+
+                if (columnName.equalsIgnoreCase("Id")) {
+                    continue;
+                }
+                sb.append(", ").append(columnName).append(" ").append(columnType);
+            }
+        }
+        sb.append(" ) ");
+
+        Log.i("Sugar", "creating table " + table.getSqlName());
+
+        if (!"".equals(sb.toString()))
+            sqLiteDatabase.execSQL(sb.toString());
+    }
+
+    @Override
+    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
+        Log.i("Sugar", "upgrading sugar");
+        // check if some tables are to be created
+        doUpgrade(sqLiteDatabase);
+
+        if (!executeSugarUpgrade(sqLiteDatabase, oldVersion, newVersion)) {
+            deleteTables(sqLiteDatabase);
+            onCreate(sqLiteDatabase);
+        }
+    }
+
+    /**
+     * Create the tables that do not exist.
+     */
+    private <T extends SugarRecord<?>> void doUpgrade(SQLiteDatabase sqLiteDatabase) {
+        List<T> domainClasses = getDomainClasses(context);
+        for (T domain : domainClasses) {
+            try {// we try to do a select, if fails then (?) there isn't the table
+                sqLiteDatabase.query(domain.tableName, null, null, null, null, null, null);
+            } catch (SQLiteException e) {
+                Log.i("Sugar", String.format("creating table on update (error was '%s')", e.getMessage()));
+                createTable(domain, sqLiteDatabase);
+            }
+        }
+    }
+
+    private <T extends SugarRecord<?>> void deleteTables(SQLiteDatabase sqLiteDatabase) {
+        List<T> tables = getDomainClasses(this.context);
+        for (T table : tables) {
+            sqLiteDatabase.execSQL("DROP TABLE IF EXISTS " + table.getSqlName());
+        }
+    }
+
+    private boolean executeSugarUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+
+        boolean isSuccess = false;
+        try {
+            List<String> files = Arrays.asList(this.context.getAssets().list("sugar_upgrades"));
+            Collections.sort(files, new NumberComparator());
+
+            for (String file : files){
+                Log.i("Sugar", "filename : " + file);
+                try {
+                    int version = Integer.valueOf(file.replace(".sql", ""));
+
+                    if ((version > oldVersion) && (version <= newVersion)) {
+                        executeScript(db, file);
+                        isSuccess = true;
+                    }
+                } catch (NumberFormatException e) {
+                    Log.i("Sugar", "not a sugar script. ignored." + file);
+                }
+            }
+        } catch (IOException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+
+        return isSuccess;
+    }
+
+    private void executeScript(SQLiteDatabase db, String file) {
+        try {
+            InputStream is = this.context.getAssets().open("sugar_upgrades/" + file);
+            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
+            String line;
+            while ((line = reader.readLine()) != null) {
+                Log.i("Sugar script", line);
+                db.execSQL(line.toString());
+            }
+        } catch (IOException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+
+        Log.i("Sugar", "script executed");
+    }
+}
diff --git a/library/src/com/orm/SugarRecord.java b/library/src/com/orm/SugarRecord.java
new file mode 100644
index 00000000..cc3978fa
--- /dev/null
+++ b/library/src/com/orm/SugarRecord.java
@@ -0,0 +1,441 @@
+package com.orm;
+
+import android.content.ContentValues;
+import android.text.TextUtils;
+import android.util.Log;
+import com.orm.dsl.Ignore;
+import net.sqlcipher.Cursor;
+import net.sqlcipher.database.SQLiteDatabase;
+import net.sqlcipher.database.SQLiteException;
+import net.sqlcipher.database.SQLiteStatement;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.sql.Timestamp;
+import java.util.*;
+
+import static com.orm.SugarApp.getSugarContext;
+
+public class SugarRecord<T>{
+
+    @Ignore
+    String tableName = getSqlName();
+
+    protected Long id = null;
+
+    public void delete() {
+        SQLiteDatabase db = getSugarContext().getDatabase().getDB();
+        db.delete(this.tableName, "Id=?", new String[]{getId().toString()});
+    }
+
+    public static <T extends SugarRecord<?>> void deleteAll(Class<T> type) {
+        Database db = getSugarContext().getDatabase();
+        SQLiteDatabase sqLiteDatabase = db.getDB();
+        sqLiteDatabase.delete(getTableName(type), null, null);
+    }
+
+    public static <T extends SugarRecord<?>> void deleteAll(Class<T> type, String whereClause, String... whereArgs ) {
+        Database db = getSugarContext().getDatabase();
+        SQLiteDatabase sqLiteDatabase = db.getDB();
+        sqLiteDatabase.delete(getTableName(type), whereClause, whereArgs);
+    }
+
+    public void save() {
+        save(getSugarContext().getDatabase().getDB());
+    }
+
+    @SuppressWarnings("deprecation")
+    public static <T extends SugarRecord<?>> void saveInTx(T... objects ) {
+        saveInTx(Arrays.asList(objects));
+    }
+
+    @SuppressWarnings("deprecation")
+    public static <T extends SugarRecord<?>> void saveInTx(Collection<T> objects ) {
+        SQLiteDatabase sqLiteDatabase = getSugarContext().getDatabase().getDB();
+
+        try{
+            sqLiteDatabase.beginTransaction();
+            sqLiteDatabase.setLockingEnabled(false);
+            for(T object: objects){
+                object.save(sqLiteDatabase);
+            }
+            sqLiteDatabase.setTransactionSuccessful();
+        }catch (Exception e){
+            Log.i("Sugar", "Error in saving in transaction " + e.getMessage());
+        }finally {
+            sqLiteDatabase.endTransaction();
+            sqLiteDatabase.setLockingEnabled(true);
+        }
+
+    }
+
+    void save(SQLiteDatabase db) {
+
+        List<Field> columns = getTableFields();
+        ContentValues values = new ContentValues(columns.size());
+        for (Field column : columns) {
+            column.setAccessible(true);
+            Class<?> columnType = column.getType();
+            try {
+                String columnName = StringUtil.toSQLName(column.getName());
+                Object columnValue = column.get(this);
+                if (SugarRecord.class.isAssignableFrom(columnType)) {
+                    values.put(columnName,
+                            (columnValue != null)
+                                    ? String.valueOf(((SugarRecord) columnValue).id)
+                                    : "0");
+                } else {
+                    if (!"id".equalsIgnoreCase(column.getName())) {
+                        if (columnType.equals(Short.class) || columnType.equals(short.class)) {
+                            values.put(columnName, (Short) columnValue);
+                        }
+                        else if (columnType.equals(Integer.class) || columnType.equals(int.class)) {
+                            values.put(columnName, (Integer) columnValue);
+                        }
+                        else if (columnType.equals(Long.class) || columnType.equals(long.class)) {
+                            values.put(columnName, (Long) columnValue);
+                        }
+                        else if (columnType.equals(Float.class) || columnType.equals(float.class)) {
+                            values.put(columnName, (Float) columnValue);
+                        }
+                        else if (columnType.equals(Double.class) || columnType.equals(double.class)) {
+                            values.put(columnName, (Double) columnValue);
+                        }
+                        else if (columnType.equals(Boolean.class) || columnType.equals(boolean.class)) {
+                            values.put(columnName, (Boolean) columnValue);
+                        }
+                        else if (Date.class.equals(columnType)) {
+                            values.put(columnName, ((Date) column.get(this)).getTime());
+                        }
+                        else if (Calendar.class.equals(columnType)) {
+                            values.put(columnName, ((Calendar) column.get(this)).getTimeInMillis());
+                        }else{
+                            values.put(columnName, String.valueOf(columnValue));
+                        }
+
+                    }
+                }
+
+            } catch (IllegalAccessException e) {
+                Log.e("Sugar", e.getMessage());
+            }
+        }
+
+        if (id == null)
+            id = db.insert(getSqlName(), null, values);
+        else
+            db.update(getSqlName(), values, "ID = ?", new String[]{String.valueOf(id)});
+
+        Log.i("Sugar", getClass().getSimpleName() + " saved : " + id);
+    }
+
+    public static <T extends SugarRecord<?>> List<T> listAll(Class<T> type) {
+        return find(type, null, null, null, null, null);
+    }
+
+    public static <T extends SugarRecord<?>> T findById(Class<T> type, Long id) {
+        List<T> list = find( type, "id=?", new String[]{String.valueOf(id)}, null, null, "1");
+        if (list.isEmpty()) return null;
+        return list.get(0);
+    }
+
+    public static <T extends SugarRecord<?>> Iterator<T> findAll(Class<T> type) {
+        return findAsIterator(type, null, null, null, null, null);
+    }
+
+    public static <T extends SugarRecord<?>> Iterator<T> findAsIterator(Class<T> type,
+                                                                        String whereClause, String... whereArgs) {
+        return findAsIterator(type, whereClause, whereArgs, null, null, null);
+    }
+
+    public static <T extends SugarRecord<?>> Iterator<T> findWithQueryAsIterator(Class<T> type, String query, String... arguments) {
+        Database db = getSugarContext().getDatabase();
+        SQLiteDatabase sqLiteDatabase = db.getDB();
+        Cursor c = sqLiteDatabase.rawQuery(query, arguments);
+        return new CursorIterator<T>(type, c);
+    }
+
+    public static <T extends SugarRecord<?>> Iterator<T> findAsIterator(Class<T> type,
+                                                                    String whereClause, String[] whereArgs,
+                                                                    String groupBy, String orderBy, String limit) {
+
+        Database db = getSugarContext().getDatabase();
+        SQLiteDatabase sqLiteDatabase = db.getDB();
+        Cursor c = sqLiteDatabase.query(getTableName(type), null,
+                whereClause, whereArgs, groupBy, null, orderBy, limit);
+        return new CursorIterator<T>(type, c);
+    }
+
+    public static <T extends SugarRecord<?>> List<T> find(Class<T> type,
+                                                       String whereClause, String... whereArgs) {
+        return find(type, whereClause, whereArgs, null, null, null);
+    }
+
+    public static <T extends SugarRecord<?>> List<T> findWithQuery(Class<T> type, String query, String... arguments){
+
+        Database db = getSugarContext().getDatabase();
+        SQLiteDatabase sqLiteDatabase = db.getDB();
+        T entity;
+        List<T> toRet = new ArrayList<T>();
+        Cursor c = sqLiteDatabase.rawQuery(query, arguments);
+
+        try {
+            while (c.moveToNext()) {
+                entity = type.getDeclaredConstructor().newInstance();
+                entity.inflate(c);
+                toRet.add(entity);
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            c.close();
+        }
+        return toRet;
+    }
+
+    public static void executeQuery(String query, String... arguments){
+        getSugarContext().getDatabase().getDB().execSQL(query, arguments);
+    }
+
+    public static <T extends SugarRecord<?>> List<T> find(Class<T> type,
+                                                       String whereClause, String[] whereArgs,
+                                                       String groupBy, String orderBy, String limit) {
+        Database db = getSugarContext().getDatabase();
+        SQLiteDatabase sqLiteDatabase = db.getDB();
+        T entity;
+        List<T> toRet = new ArrayList<T>();
+        Cursor c = sqLiteDatabase.query(getTableName(type), null,
+                whereClause, whereArgs, groupBy, null, orderBy, limit);
+        try {
+            while (c.moveToNext()) {
+                entity = type.getDeclaredConstructor().newInstance();
+                entity.inflate(c);
+                toRet.add(entity);
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            c.close();
+        }
+        return toRet;
+    }
+    
+    public static <T extends SugarRecord<?>> long count(Class<?> type,
+            String whereClause, String[] whereArgs) {
+    	return count(type, whereClause, whereArgs, null, null, null);
+    }
+    
+    public static <T extends SugarRecord<?>> long count(Class<?> type,
+            String whereClause, String[] whereArgs,
+            String groupBy, String orderBy, String limit) {
+    	
+    	Database db = getSugarContext().getDatabase();
+        SQLiteDatabase sqLiteDatabase = db.getDB();
+
+        long toRet = -1;
+        String filter = (!TextUtils.isEmpty(whereClause)) ? " where "  + whereClause : "";
+        SQLiteStatement sqLiteStatament = sqLiteDatabase.compileStatement("SELECT count(*) FROM " + getTableName(type) + filter);
+
+        if (whereArgs != null) {
+            for (int i = whereArgs.length; i != 0; i--) {
+                sqLiteStatament.bindString(i, whereArgs[i - 1]);
+            }
+        }
+
+        try {
+            toRet = sqLiteStatament.simpleQueryForLong();
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            sqLiteStatament.close();
+        }
+        
+    	return toRet;
+    }
+
+    @SuppressWarnings("unchecked")
+    void inflate(Cursor cursor) {
+        Map<Field, Long> entities = new HashMap<Field, Long>();
+        List<Field> columns = getTableFields();
+        for (Field field : columns) {
+            field.setAccessible(true);
+            try {
+                Class fieldType = field.getType();
+                String colName = StringUtil.toSQLName(field.getName());
+
+                int columnIndex = cursor.getColumnIndex(colName);
+
+                if (cursor.isNull(columnIndex)) {
+                    continue;
+                }
+
+                if(colName.equalsIgnoreCase("id")){
+                    long cid = cursor.getLong(columnIndex);
+                    field.set(this, Long.valueOf(cid));
+                }else if (fieldType.equals(long.class) || fieldType.equals(Long.class)) {
+                    field.set(this,
+                            cursor.getLong(columnIndex));
+                } else if (fieldType.equals(String.class)) {
+                    String val = cursor.getString(columnIndex);
+                    field.set(this, val != null && val.equals("null") ? null : val);
+                } else if (fieldType.equals(double.class) || fieldType.equals(Double.class)) {
+                    field.set(this,
+                            cursor.getDouble(columnIndex));
+                } else if (fieldType.equals(boolean.class) || fieldType.equals(Boolean.class)) {
+                    field.set(this,
+                            cursor.getString(columnIndex).equals("1"));
+                } else if (field.getType().getName().equals("[B")) {
+                    field.set(this,
+                            cursor.getBlob(columnIndex));
+                } else if (fieldType.equals(int.class) || fieldType.equals(Integer.class)) {
+                    field.set(this,
+                            cursor.getInt(columnIndex));
+                } else if (fieldType.equals(float.class) || fieldType.equals(Float.class)) {
+                    field.set(this,
+                            cursor.getFloat(columnIndex));
+                } else if (fieldType.equals(short.class) || fieldType.equals(Short.class)) {
+                    field.set(this,
+                            cursor.getShort(columnIndex));
+                } else if (fieldType.equals(Timestamp.class)) {
+                    long l = cursor.getLong(columnIndex);
+                    field.set(this, new Timestamp(l));
+                } else if (fieldType.equals(Date.class)) {
+                    long l = cursor.getLong(columnIndex);
+                    field.set(this, new Date(l));
+                } else if (fieldType.equals(Calendar.class)) {
+                    long l = cursor.getLong(columnIndex);
+                    Calendar c = Calendar.getInstance();
+                    c.setTimeInMillis(l);
+                    field.set(this, c);
+                } else if (Enum.class.isAssignableFrom(fieldType)) {
+                    try {
+                        Method valueOf = field.getType().getMethod("valueOf", String.class);
+                        String strVal = cursor.getString(columnIndex);
+                        Object enumVal = valueOf.invoke(field.getType(), strVal);
+                        field.set(this, enumVal);
+                    } catch (Exception e) {
+                        Log.e("Sugar", "Enum cannot be read from Sqlite3 database. Please check the type of field " + field.getName());
+                    }
+                } else if (SugarRecord.class.isAssignableFrom(fieldType)) {
+                    long id = cursor.getLong(columnIndex);
+                    if (id > 0)
+                        entities.put(field, id);
+                    else
+                        field.set(this, null);
+                } else
+                    Log.e("Sugar", "Class cannot be read from Sqlite3 database. Please check the type of field " + field.getName() + "(" + field.getType().getName() + ")");
+            } catch (IllegalArgumentException e) {
+                Log.e("field set error", e.getMessage());
+            } catch (IllegalAccessException e) {
+                Log.e("field set error", e.getMessage());
+            }
+
+        }
+
+        for (Field f : entities.keySet()) {
+            try {
+                f.set(this, findById((Class<? extends SugarRecord<?>>) f.getType(), 
+                        entities.get(f)));
+            } catch (SQLiteException e) {
+            } catch (IllegalArgumentException e) {
+            } catch (IllegalAccessException e) {
+            }
+        }
+    }
+
+    public List<Field> getTableFields() {
+        List<Field> fieldList = SugarConfig.getFields(getClass());
+        if(fieldList != null) return fieldList;
+
+        Log.d("Sugar", "Fetching properties");
+        List<Field> typeFields = new ArrayList<Field>();
+
+        getAllFields(typeFields, getClass());
+
+        List<Field> toStore = new ArrayList<Field>();
+        for (Field field : typeFields) {
+            if (!field.isAnnotationPresent(Ignore.class) && !Modifier.isStatic(field.getModifiers())&& !Modifier.isTransient(field.getModifiers())) {
+                toStore.add(field);
+            }
+        }
+
+        SugarConfig.setFields(getClass(), toStore);
+        return toStore;
+    }
+
+    private static List<Field> getAllFields(List<Field> fields, Class<?> type) {
+        Collections.addAll(fields, type.getDeclaredFields());
+
+        if (type.getSuperclass() != null) {
+            fields = getAllFields(fields, type.getSuperclass());
+        }
+
+        return fields;
+    }
+
+    public String getSqlName() {
+        return getTableName(getClass());
+    }
+
+
+    public static String getTableName(Class<?> type) {
+        return StringUtil.toSQLName(type.getSimpleName());
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    static class CursorIterator<E extends SugarRecord<?>> implements Iterator<E> {
+        Class<E> type;
+        Cursor cursor;
+
+        public CursorIterator(Class<E> type, Cursor cursor) {
+            this.type = type;
+            this.cursor = cursor;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return cursor != null && !cursor.isClosed() && !cursor.isAfterLast();
+        }
+
+        @Override
+        public E next() {
+            E entity = null;
+            if (cursor == null || cursor.isAfterLast()) {
+                throw new NoSuchElementException();
+            }
+
+            if (cursor.isBeforeFirst()) {
+                cursor.moveToFirst();
+            }
+
+            try {
+                entity = type.getDeclaredConstructor().newInstance();
+                entity.inflate(cursor);
+            } catch (Exception e) {
+                e.printStackTrace();
+            } finally {
+                cursor.moveToNext();
+                if (cursor.isAfterLast()) {
+                    cursor.close();
+                }
+            }
+            return entity;
+        }
+
+        @Override
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+
+
+    }
+
+}
diff --git a/library/src/com/orm/SugarTransactionHelper.java b/library/src/com/orm/SugarTransactionHelper.java
new file mode 100644
index 00000000..2f9b8c51
--- /dev/null
+++ b/library/src/com/orm/SugarTransactionHelper.java
@@ -0,0 +1,29 @@
+package com.orm;
+
+import android.util.Log;
+import net.sqlcipher.database.SQLiteDatabase;
+
+public class SugarTransactionHelper {
+
+    public static void doInTansaction(SugarTransactionHelper.Callback callback) {
+
+        SQLiteDatabase database = SugarApp.getSugarContext().getDatabase().getDB();
+
+        database.beginTransaction();
+
+        try {
+            Log.d(SugarTransactionHelper.class.getSimpleName(), "callback executing within transaction");
+            callback.manipulateInTransaction();
+            database.setTransactionSuccessful();
+            Log.d(SugarTransactionHelper.class.getSimpleName(), "callback successfully executed within transaction");
+        } catch (Throwable e) {
+            Log.d(SugarTransactionHelper.class.getSimpleName(), "could execute callback within transaction", e);
+        } finally {
+            database.endTransaction();
+        }
+    }
+
+    public static interface Callback {
+        void manipulateInTransaction();
+    }
+}
diff --git a/library/src/main/java/com/orm/util/SugarCursorFactory.java b/library/src/main/java/com/orm/util/SugarCursorFactory.java
index 3274fccc..f68453d3 100644
--- a/library/src/main/java/com/orm/util/SugarCursorFactory.java
+++ b/library/src/main/java/com/orm/util/SugarCursorFactory.java
@@ -1,11 +1,11 @@
 package com.orm.util;
 
-import android.database.Cursor;
-import android.database.sqlite.SQLiteCursor;
-import android.database.sqlite.SQLiteCursorDriver;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteQuery;
 import android.util.Log;
+import net.sqlcipher.Cursor;
+import net.sqlcipher.database.SQLiteCursor;
+import net.sqlcipher.database.SQLiteCursorDriver;
+import net.sqlcipher.database.SQLiteDatabase;
+import net.sqlcipher.database.SQLiteQuery;
 
 public class SugarCursorFactory implements SQLiteDatabase.CursorFactory {
 
