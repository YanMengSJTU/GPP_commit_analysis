diff --git a/library/src/com/orm/ORMProvider.java b/library/src/com/orm/ORMProvider.java
index c877ff8b..eb9e4433 100644
--- a/library/src/com/orm/ORMProvider.java
+++ b/library/src/com/orm/ORMProvider.java
@@ -8,9 +8,12 @@
 import android.content.ContentProvider;
 import android.content.ContentValues;
 import android.content.ContentUris;
+import android.content.Context;
 import android.content.UriMatcher;
 import android.database.Cursor;
 import android.net.Uri;
+import android.os.Bundle;
+import android.util.Log;
 import android.database.sqlite.SQLiteDatabase;
 
 import com.orm.Database;
@@ -24,7 +27,7 @@
 	 */
 	
 	private SQLiteDatabase db;
-	static final String PROVIDER_NAME = "app.unifi.provider";
+	static final String PROVIDER_NAME = "com.orm.provider";
 	static final String URL = "content://" + PROVIDER_NAME + "/router";
 	static public final Uri CONTENT_URI = Uri.parse(URL);
 	
@@ -32,6 +35,8 @@
 	static final int ROW = 2;
 	static final int RAW_QUERY = 3;
 	static final int EXEC_SQL = 4;
+	static final int EXTENDED_QUERY = 5;
+	//static final String EXTENDED_QUERY = "EXTENDED_QUERY";
 
 	static final UriMatcher uriMatcher;
 	static
@@ -39,6 +44,7 @@
 	      uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
 	      uriMatcher.addURI(PROVIDER_NAME, "RAW_QUERY", RAW_QUERY);
 	      uriMatcher.addURI(PROVIDER_NAME, "EXEC_SQL", EXEC_SQL);
+	      uriMatcher.addURI(PROVIDER_NAME, "EXTENDED_QUERY", EXTENDED_QUERY);
 	      uriMatcher.addURI(PROVIDER_NAME, "*", TABLE);//only matches one segment
 	      uriMatcher.addURI(PROVIDER_NAME, "*/#", ROW);
 	}
@@ -48,7 +54,10 @@ public boolean onCreate()
 	{
 		//The Android system calls onCreate() when it starts up the provider. 
 		//You should perform only fast-running initialization tasks in this method, and defer database creation and data loading until the provider actually receives a request for the data
-		db = getSugarContext().getDatabase().getDB();
+		//SugarApp app = new SugarApp();
+		Context context = getContext();
+		SugarDb sugarDb = new SugarDb(context);
+		db = sugarDb.getWritableDatabase();//nullpointer exception here!
 		return (db == null)? false:true;
 	}
 	
@@ -112,8 +121,10 @@ public Uri insert(Uri uri, ContentValues values)
 		//Return a content URI for the newly-inserted row
 		//getAsString returns the value or null if the value is missing or cannot be converted
 		String table = uri.getPathSegments().get(0);
-		db.insert(table, null, values);
-		return null;
+		long row_id = db.insert(table, null, values);
+		String url = "content://" + PROVIDER_NAME + "/" + table + "/" + Long.toString(row_id);
+    	Uri new_row_uri = Uri.parse(url);
+		return new_row_uri;
 	}
 
 	@Override
@@ -143,6 +154,22 @@ public Cursor query(Uri uri, String[] projection, String selection, String[] sel
 		case EXEC_SQL:
 			db.execSQL(selection, selectionArgs);//query, arguments
 			return null;
+		case EXTENDED_QUERY:
+			Log.d("in ORM","in extended query");
+			table = projection[0];
+			String groupBy = projection[1];
+			String orderBy = projection[2];
+			String limit = projection[3];
+			Log.d("in ORM","table:" + table);
+			Log.d("in ORM","selection:" + selection);
+			if (selectionArgs!=null)
+				Log.d("in ORM","selectionArgs:" + selectionArgs[0]);
+			else
+				Log.d("in ORM","selectionArgs: null");
+			//Passing null will return all columns
+			cursor = db.query(table, null, selection, selectionArgs, groupBy, null, orderBy, limit);
+			Log.d("in ORM cursor, got rows:", Long.toString(cursor.getCount()));
+			return cursor;
 		default:
 	         throw new IllegalArgumentException("Unknown URI " + uri);
 	    }
@@ -154,5 +181,19 @@ public int update(Uri uri, ContentValues values, String selection, String[] sele
 		db.update(uri.getPathSegments().get(0), values, selection, selectionArgs);
 		return 0;
 	}
+	
+	//from client:
+	//getContentResolver().call(Provider.Constants.CONTENT_URI,
+    //Provider.SET_KEY_METHOD, "sekrit", null);
+	/*@Override
+	public Bundle call(String method, String table, Bundle args)
+	{
+	    if (EXTENDED_QUERY.equals(method) && args != null)
+	    {
+	      //db.query(distinct, table, columns, selection, selectionArgs, groupBy, having, orderBy, limit, cancellationSignal);
+	    }
+
+	    return(null);
+	}*/
 
 }
\ No newline at end of file
diff --git a/library/src/com/orm/SugarApp.java b/library/src/com/orm/SugarApp.java
index d15c411f..71529524 100644
--- a/library/src/com/orm/SugarApp.java
+++ b/library/src/com/orm/SugarApp.java
@@ -1,6 +1,7 @@
 package com.orm;
 
-public class SugarApp extends android.app.Application{
+public class SugarApp extends android.app.Application
+{
 
     private Database database;
     private static SugarApp sugarContext;
diff --git a/library/src/com/orm/SugarRecord.java b/library/src/com/orm/SugarRecord.java
index b9f63864..2b625728 100644
--- a/library/src/com/orm/SugarRecord.java
+++ b/library/src/com/orm/SugarRecord.java
@@ -1,5 +1,6 @@
 package com.orm;
 
+import android.content.ContentResolver;
 import android.content.ContentValues;
 import android.content.Context;
 import android.database.Cursor;
@@ -8,27 +9,28 @@
 import android.database.sqlite.SQLiteQueryBuilder;
 import android.database.sqlite.SQLiteStatement;
 import android.net.Uri;
+import android.os.Bundle;
 import android.text.TextUtils;
 import android.util.Log;
 import com.orm.dsl.Ignore;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.sql.Timestamp;
 import java.util.*;
 
 import static com.orm.SugarApp.getSugarContext;
-import com.orm.ORMProvider;
 
 public class SugarRecord<T>
 {
 
     @Ignore
     String tableName = getSqlName();
-	static ORMProvider db;
-	static String PROVIDER_NAME = "app.unifi.provider";
+	static ContentResolver db = getSugarContext().getContentResolver();
+	static String PROVIDER_NAME = "com.orm.provider";
 
     protected Long id = null;
 
@@ -88,7 +90,7 @@ public void save()
 
     }*/
 
-    void save(ORMProvider orm)
+    void save(ContentResolver orm)
     {
         List<Field> columns = getTableFields();
         ContentValues values = new ContentValues(columns.size());
@@ -161,7 +163,7 @@ else if (Calendar.class.equals(columnType))
         if (id == null)
         {
             Uri new_row = orm.insert(uri, values);
-            id = Long.parseLong(uri.getPathSegments().get(1));
+            id = Long.parseLong(new_row.getPathSegments().get(1));
         }
         else
         	orm.update(uri, values, "ID = ?", new String[]{String.valueOf(id)});
@@ -176,7 +178,7 @@ else if (Calendar.class.equals(columnType))
 
     public static <T extends SugarRecord<?>> T findById(Class<T> type, Long id)
     {
-        List<T> list = find( type, "id=?", new String[]{String.valueOf(id)}, null, null, "1");
+        List<T> list = find(type, "id=?", new String[]{String.valueOf(id)}, null, null, "1");
         if (list.isEmpty()) return null;
         return list.get(0);
     }
@@ -205,21 +207,17 @@ else if (Calendar.class.equals(columnType))
                                                                     String whereClause, String[] whereArgs,
                                                                     String groupBy, String orderBy, String limit)
     {
-    	String url = "content://" + PROVIDER_NAME + "/RAW_SQL";
+    	String url = "content://" + PROVIDER_NAME + "/EXTENDED_QUERY";
     	Uri uri = Uri.parse(url);
-    	//is deprecated: buildQuery (String[] projectionIn, String selection, String[] selectionArgs, String groupBy, String having, String sortOrder, String limit)
-        Object args[] = whereArgs;
-    	String where_query = String.format(whereClause, args);
-    	SQLiteQueryBuilder builder = new SQLiteQueryBuilder();
-    	builder.setTables(getTableName(type));
-    	String query = builder.buildQuery(null, where_query, groupBy, null, orderBy, limit);
-        Cursor c = db.query(uri, null, query, null, null);
+    	String[] args = {getTableName(type), groupBy, orderBy, limit};
+        Cursor c = db.query(uri, args, whereClause, whereArgs, null);
         return new CursorIterator<T>(type, c);
     }
 
     public static <T extends SugarRecord<?>> List<T> find(Class<T> type,
                                                        String whereClause, String... whereArgs)
     {
+    	Log.d("in sugar", "find called");
         return find(type, whereClause, whereArgs, null, null, null);
     }
 
@@ -234,8 +232,9 @@ else if (Calendar.class.equals(columnType))
 
         try {
             while (c.moveToNext()) {
-                entity = type.getDeclaredConstructor().newInstance();
-                entity.inflate(c);
+                //entity = type.getDeclaredConstructor().newInstance();
+            	entity = type.getDeclaredConstructor(new Class[] {android.content.Context.class}).newInstance(getSugarContext());
+            	entity.inflate(c);
                 toRet.add(entity);
             }
         } catch (Exception e) {
@@ -258,21 +257,42 @@ public static void executeQuery(String query, String... arguments)
                                                        String whereClause, String[] whereArgs,
                                                        String groupBy, String orderBy, String limit)
     {
-    	String url = "content://" + PROVIDER_NAME + "/RAW_SQL";
+    	String url = "content://" + PROVIDER_NAME + "/EXTENDED_QUERY";
     	Uri uri = Uri.parse(url);
     	//is deprecated: buildQuery (String[] projectionIn, String selection, String[] selectionArgs, String groupBy, String having, String sortOrder, String limit)
-        Object args[] = whereArgs;
+        /*Object args[] = whereArgs;
     	String where_query = String.format(whereClause, args);
     	SQLiteQueryBuilder builder = new SQLiteQueryBuilder();
     	builder.setTables(getTableName(type));
+    	String query = builder.buildQuery(null, whereClause, whereArgs, groupBy, null, orderBy, limit);
     	String query = builder.buildQuery(null, where_query, groupBy, null, orderBy, limit);
-        
+    	Cursor c = db.query(uri, null, query, null, null);//null pointer exception here*/
+    	/*Bundle b = new Bundle();
+    	b.putString("whereClause", whereClause);
+    	b.putStringArray("whereArgs", whereArgs);
+        b.putString("groupBy", groupBy);
+        b.putString("orderBy", orderBy);
+        b.putString("limit", limit);
+        Bundle ret = db.call("EXTENDED_QUERY", getTableName(type), b);
+        //how do i put a cursor in the return bundle?  don't want to do this logic inside the call method itself*/
+    	String[] args = {getTableName(type), groupBy, orderBy, limit};
+    	/*Log.d("null testing", uri.toString());
+    	Log.d("null testing", args.toString());
+    	Log.d("null testing", whereClause.toString());
+    	Log.d("null testing", whereArgs.toString());*/
+    	
         T entity;
         List<T> toRet = new ArrayList<T>();
-        Cursor c = db.query(uri, null, query, null, null);
+        Log.d("in find", "db.query()");
+        Cursor c = db.query(uri, args, whereClause, whereArgs, null);
         try {
-            while (c.moveToNext()) {
-                entity = type.getDeclaredConstructor().newInstance();
+            while (c.moveToNext())
+            {
+            	Log.d("in find", "got result row from query");
+                //entity = type.getDeclaredConstructor().newInstance();//error here
+            	//The parameterTypes parameter is an array of Class objects that identify the constructor's formal parameter types, in declared order.
+                entity = type.getDeclaredConstructor(new Class[] {android.content.Context.class}).newInstance(getSugarContext());
+                Log.d("constructor","got constructor & new instance");
                 entity.inflate(c);
                 toRet.add(entity);
             }
@@ -494,7 +514,8 @@ public E next()
             }
 
             try {
-                entity = type.getDeclaredConstructor().newInstance();
+                //entity = type.getDeclaredConstructor().newInstance();
+            	entity = type.getDeclaredConstructor(new Class[] {android.content.Context.class}).newInstance(getSugarContext());
                 entity.inflate(cursor);
             } catch (Exception e) {
                 e.printStackTrace();
