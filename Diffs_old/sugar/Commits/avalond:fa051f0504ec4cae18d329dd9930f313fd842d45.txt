diff --git a/.travis.yml b/.travis.yml
index 9cd5cea5..db407323 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,11 +1,28 @@
 language: android
+jdk: oraclejdk7
 
+env:
+  global:
+    - TERM=dumb
 android:
   components:
     - sys-img-armeabi-v7a-android-23
-    - build-tools-23.0.2
+    - tools
+    - build-tools-23.0.3
     - android-23
-
+    - extra-android-m2repository
+before_script:
+  - sudo service postgresql stop || true
+  - sudo service mysql stop || true
+  - sudo service memcached stop || true
+  - sudo service bootlogd stop || true
+  - sudo service elasticsearch stop || true
+  - sudo service mongodb stop || true
+  - sudo service neo4j stop || true
+  - sudo service cassandra stop || true
+  - sudo service riak stop || true
+  - sudo service rsync stop || true
+  - sudo service x11-common stop || true
 script:
   - gradle clean build connectedCheck coveralls
 
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 85a61493..7015053d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,14 +1,23 @@
 # Sugar Releases
 
 ## [Unreleased]
+
+
+## v1.5
 ### Added
+* [#328](https://github.com/satyan/sugar/pull/328) @jedid auto add new columns during database upgrade, fix [#299](https://github.com/satyan/sugar/issues/299) and [#151](https://github.com/satyan/sugar/issues/151)
+* [#389](https://github.com/satyan/sugar/pull/389) @alfmatos MultiUnique DSL to handle MultiColumn Unique Table constraint
+* @sibeliusseraphini update, updateInTx methods based on Unique values of SugarRecord
 * [#155](https://github.com/satyan/sugar/issues/155) @benohalloran adding Cursors for Cursor Adapters [Pull 312](https://github.com/satyan/sugar/pull/312)
 * [#430](https://github.com/satyan/sugar/pull/430) @sibeliusseraphini update to roboelectric 3.0 and target android-32
 
 ### Changed
+* [#437](https://github.com/satyan/sugar/pull/437) @dnalves removing guava dependency, using synchronized WeakHashMap instead
 * [#423](https://github.com/satyan/sugar/pull/423) @sibeliusseraphini moving changelog of README.md to CHANGELOG.md
 
 ### Fixed
+* [#362](https://github.com/satyan/sugar/pull/362) @mitchyboy9 fixed NoClassDefFoundError
+* [#455](https://github.com/satyan/sugar/pull/455) @nurolopher fixed travis and coveralls config 
 * [#434](https://github.com/satyan/sugar/pull/434) @bendaniel10 fix multi-dex
 * [#410](https://github.com/satyan/sugar/pull/410) [#408](https://github.com/satyan/sugar/pull/408) @RoyMontoya simplify code
 * [#327](https://github.com/satyan/sugar/pull/327) @tracytheron support multi-dex
diff --git a/README.md b/README.md
index 54635c36..fa8a2c14 100644
--- a/README.md
+++ b/README.md
@@ -1,8 +1,10 @@
-# Sugar ORM [![Build Status](https://travis-ci.org/satyan/sugar.svg?branch=master)](https://travis-ci.org/satyan/sugar) [![Coverage Status](https://coveralls.io/repos/satyan/sugar/badge.svg?branch=master)](https://coveralls.io/r/satyan/sugar?branch=master)
+# Sugar ORM [![Build Status](https://travis-ci.org/satyan/sugar.svg?branch=master)](https://travis-ci.org/satyan/sugar) [![Coverage Status](https://coveralls.io/repos/satyan/sugar/badge.svg?branch=master)](https://coveralls.io/r/satyan/sugar?branch=master) [![Code Triagers Badge](http://www.codetriage.com/satyan/sugar/badges/users.svg)](http://www.codetriage.com/satyan/sugar)
+
+[![Join the chat at https://gitter.im/satyan/sugar](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/satyan/sugar?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
 
 Insanely easy way to work with Android databases.
 
-Official documentation can be found [here](http://satyan.github.io/sugar). The example application is provided in the **example** folder in the source.
+Official documentation can be found [here](http://satyan.github.io/sugar) - Check some examples below. The example application is provided in the **example** folder in the source.
 
 ## Features
 
@@ -21,7 +23,7 @@ There are four ways to install Sugar:
 This is the preferred way. Simply add:
 
 ```groovy
-compile 'com.github.satyan:sugar:1.4.0'
+compile 'com.github.satyan:sugar:1.5'
 ```
 
 to your project dependencies and run `gradle build` or `gradle assemble`.
@@ -34,7 +36,7 @@ Declare the dependency in Maven:
 <dependency>
     <groupId>com.github.satyan</groupId>
     <artifactId>sugar</artifactId>
-    <version>1.4</version>
+    <version>1.5</version>
 </dependency>
 ```
 
@@ -46,9 +48,140 @@ Download the source code and import it as a library project in Eclipse. The proj
 
 Visit the [releases](https://github.com/satyan/sugar/releases) page to download jars directly. You can drop them into your `libs` folder and configure the Java build path to include the library. See this [tutorial](http://www.vogella.com/tutorials/AndroidLibraryProjects/article.html) for an excellent guide on how to do this.
 
+
+### How to use master version
+First, download sugar repository
+```
+git clone git@github.com:satyan/sugar.git
+```
+
+include this in your **settings.gradle**
+```gradle
+include ':app' // your module app
+include ':sugar'
+
+def getLocalProperty(prop) {
+	Properties properties = new Properties()
+	properties.load(new File(rootDir.absolutePath + '/local.properties').newDataInputStream())
+	return properties.getProperty(prop, '')
+}
+
+project(':sugar').projectDir = new File(getLocalProperty('sugar.dir'))
+
+```
+
+include this in your **local.properties**
+```
+sugar.dir=/path/to/sugar/library
+```
+
+add sugar project to the dependencies of your main project (build.gradle)
+```gradle
+dependencies {
+    compile project(':sugar')
+}
+```
+
 ===================
 
-After installing, check out how to set up your first database and models [here](http://satyan.github.io/sugar/getting-started.html).
+After installing, check out how to set up your first database and models [here](http://satyan.github.io/sugar/getting-started.html) **Outdated**. Check examples of 1.4 and master below: 
+
+## Examples
+### SugarRecord
+```java
+public class Book extends SugarRecord {
+  @Unique
+  String isbn;
+  String title;
+  String edition;
+
+  // Default constructor is necessary for SugarRecord
+  public Book() {
+
+  }
+
+  public Book(String isbn, String title, String edition) {
+    this.isbn = isbn;
+    this.title = title;
+    this.edition = edition;
+  }
+}
+```
+or
+```java
+@Table
+public class Book { ... }
+```
+
+### Save Entity
+```java
+Book book = new Book("isbn123", "Title here", "2nd edition")
+book.save();
+```
+
+or
+```java
+SugarRecord.save(book); // if using the @Table annotation 
+```
+
+### Load Entity
+```java
+Book book = Book.findById(Book.class, 1);
+```
+
+### Update Entity
+```java
+Book book = Book.findById(Book.class, 1);
+book.title = "updated title here"; // modify the values
+book.edition = "3rd edition";
+book.save(); // updates the previous entry with new values.
+```
+
+
+### Delete Entity
+```java
+Book book = Book.findById(Book.class, 1);
+book.delete();
+```
+
+or
+```java
+SugarRecord.delete(book); // if using the @Table annotation 
+```
+
+### Update Entity based on Unique values
+```java
+Book book = new Book("isbn123", "Title here", "2nd edition")
+book.save();
+
+// Update book with isbn123
+Book sameBook = new Book("isbn123", "New Title", "5th edition")
+sameBook.update();
+
+book.getId() == sameBook.getId(); // true
+```
+
+or
+```java
+SugarRecord.update(sameBook); // if using the @Table annotation 
+```
+
+### Bulk Insert
+```java
+List<Book> books = new ArrayList<>();
+books.add(new Book("isbn123", "Title here", "2nd edition"))
+books.add(new Book("isbn456", "Title here 2", "3nd edition"))
+books.add(new Book("isbn789", "Title here 3", "4nd edition"))
+SugarRecord.saveInTx(books);
+```
+
+### When using ProGuard
+```java
+# Ensures entities remain un-obfuscated so table and columns are named correctly
+-keep class com.yourpackage.yourapp.domainclasspackage.** { *; }
+```
+
+## [CHANGELOG](https://github.com/satyan/sugar/blob/master/CHANGELOG.md)
 
 ## Contributing
 
diff --git a/build.gradle b/build.gradle
index c6970775..952f49e1 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,12 +1,13 @@
 apply plugin: 'jacoco'
 apply plugin: 'com.github.kt3k.coveralls'
+apply plugin: 'java'
 
 buildscript {
     repositories {
         mavenCentral()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.3.0'
+        classpath 'com.android.tools.build:gradle:1.5.0'
         classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.3.1'
     }
 }
@@ -14,7 +15,11 @@ buildscript {
 def isReleaseBuild() {
     return version.contains("SNAPSHOT") == false
 }
-
+test{
+    testLogging{
+        exceptionFormat = 'full'
+    }
+}
 allprojects {
     version = VERSION_NAME
     group = GROUP
@@ -33,7 +38,7 @@ subprojects { proj ->
         version "0.7.1.201405082137"
     }
 
-    task jacocoTestReport(type: JacocoReport, dependsOn: "testDebug") {
+    task jacocoTestReport(type: JacocoReport) {
         group = "Reporting"
         description = "Generate Jacoco coverage reports after running tests."
         reports {
@@ -45,7 +50,7 @@ subprojects { proj ->
             excludes: ['**/R*.class',
                        '**/BuildConfig*'])
         sourceDirectories = files('src/main/java')
-        executionData = files('build/jacoco/testDebug.exec')
+        executionData = files('build/jacoco/testDebugUnitTest.exec')
         doFirst {
             files('build/intermediates/classes/debug').getFiles().each { file ->
                 if (file.name.contains('$$')) {
@@ -91,4 +96,4 @@ tasks.coveralls {
 
     dependsOn jacocoRootReport
     onlyIf { System.env.'CI' }
-}
+}
\ No newline at end of file
diff --git a/example/build.gradle b/example/build.gradle
index 129eb11e..b9fe1be7 100644
--- a/example/build.gradle
+++ b/example/build.gradle
@@ -1,8 +1,7 @@
 apply plugin: 'com.android.application'
-
 android {
     compileSdkVersion 23
-    buildToolsVersion "23.0.2"
+    buildToolsVersion "23.0.3"
 
     defaultConfig {
         applicationId "com.example"
@@ -15,11 +14,18 @@ android {
             minifyEnabled false
         }
     }
+
+    testOptions{
+        unitTests.returnDefaultValues = true
+    }
+    lintOptions{
+        abortOnError false
+    }
 }
 
 dependencies {
     compile project (':library')
-    compile 'com.android.support:appcompat-v7:23.1.1'
+    compile 'com.android.support:appcompat-v7:23.2.1'
     testCompile 'org.robolectric:robolectric:3.0'
     testCompile 'junit:junit:4.12'
 }
diff --git a/example/src/main/java/com/example/ClientApp.java b/example/src/main/java/com/example/ClientApp.java
index e546e11d..6637ea26 100644
--- a/example/src/main/java/com/example/ClientApp.java
+++ b/example/src/main/java/com/example/ClientApp.java
@@ -5,6 +5,7 @@
 import com.orm.SugarContext;
 
 public class ClientApp extends Application {
+
     @Override
     public void onCreate() {
         super.onCreate();
diff --git a/example/src/main/java/com/example/activities/SugarActivity.java b/example/src/main/java/com/example/activities/SugarActivity.java
index 197314a0..81044546 100644
--- a/example/src/main/java/com/example/activities/SugarActivity.java
+++ b/example/src/main/java/com/example/activities/SugarActivity.java
@@ -1,7 +1,6 @@
 package com.example.activities;
 
 import android.app.Activity;
-import android.content.Intent;
 import android.os.Bundle;
 
 import com.example.R;
diff --git a/gradle.properties b/gradle.properties
index b1d9b965..35b4c26f 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,6 +16,7 @@
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
+org.gradle.daemon=true
 
 VERSION_NAME=2
 VERSION_CODE=2
diff --git a/library/build.gradle b/library/build.gradle
index b38dc8ee..5c523c6f 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -3,7 +3,7 @@ apply from: '../maven_push.gradle'
 
 android {
     compileSdkVersion 23
-    buildToolsVersion "23.0.2"
+    buildToolsVersion "23.0.3"
 
     defaultConfig {
         minSdkVersion 9
@@ -15,11 +15,17 @@ android {
             minifyEnabled false
         }
     }
+
+    testOptions{
+        unitTests.returnDefaultValues = true
+    }
+
+    lintOptions{
+        abortOnError false
+    }
 }
 
 dependencies {
-    compile 'com.android.support:appcompat-v7:23.1.1'
-    compile 'com.google.guava:guava:18.0'
     testCompile 'junit:junit:4.12'
 }
 
diff --git a/library/src/main/java/com/orm/SchemaGenerator.java b/library/src/main/java/com/orm/SchemaGenerator.java
index 91f80e1b..b2da4d86 100644
--- a/library/src/main/java/com/orm/SchemaGenerator.java
+++ b/library/src/main/java/com/orm/SchemaGenerator.java
@@ -1,14 +1,16 @@
 package com.orm;
 
-import android.content.Context;
 import android.database.Cursor;
 import android.database.SQLException;
 import android.database.sqlite.SQLiteDatabase;
 import android.util.Log;
 
 import com.orm.dsl.Column;
+import com.orm.dsl.MultiUnique;
 import com.orm.dsl.NotNull;
 import com.orm.dsl.Unique;
+import com.orm.util.KeyWordUtil;
+import com.orm.util.MigrationFileParser;
 import com.orm.util.NamingHelper;
 import com.orm.util.NumberComparator;
 import com.orm.util.QueryBuilder;
@@ -19,46 +21,65 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.lang.reflect.Field;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
 import static com.orm.util.ReflectionUtil.getDomainClasses;
+import static com.orm.util.ContextUtil.getAssets;
 
 public class SchemaGenerator {
-
-    private Context context;
-
     public static final String NULL = " NULL";
     public static final String NOT_NULL = " NOT NULL";
     public static final String UNIQUE = " UNIQUE";
     public static final String SUGAR = "Sugar";
 
-    public SchemaGenerator(Context context) {
-        this.context = context;
+    //Prevent instantiation
+    private SchemaGenerator() { }
+
+    public static SchemaGenerator getInstance() {
+        return new SchemaGenerator();
     }
 
     public void createDatabase(SQLiteDatabase sqLiteDatabase) {
-        List<Class> domainClasses = getDomainClasses(context);
+        List<Class> domainClasses = getDomainClasses();
         for (Class domain : domainClasses) {
             createTable(domain, sqLiteDatabase);
         }
     }
 
     public void doUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
-        List<Class> domainClasses = getDomainClasses(context);
+        List<Class> domainClasses = getDomainClasses();
         String sql = "select count(*) from sqlite_master where type='table' and name='%s';";
+
         for (Class domain : domainClasses) {
-            Cursor cursor = sqLiteDatabase.rawQuery(String.format(sql, NamingHelper.toSQLName(domain)), null);
-            if (cursor.moveToFirst() && cursor.getInt(0) == 0) {
-            	createTable(domain, sqLiteDatabase);
+            String tableName = NamingHelper.toSQLName(domain);
+            Cursor c = sqLiteDatabase.rawQuery(String.format(sql, tableName), null);
+            if (c.moveToFirst() && c.getInt(0) == 0) {
+                createTable(domain, sqLiteDatabase);
+            } else {
+                addColumns(domain, sqLiteDatabase);
             }
         }
         executeSugarUpgrade(sqLiteDatabase, oldVersion, newVersion);
     }
 
+    private ArrayList<String> getColumnNames(SQLiteDatabase sqLiteDatabase, String tableName) {
+        Cursor resultsQuery = sqLiteDatabase.query(tableName, null, null, null, null, null, null);
+        //Check if columns match vs the one on the domain class
+        ArrayList<String> columnNames = new ArrayList<>();
+        for (int i = 0; i < resultsQuery.getColumnCount(); i++) {
+            String columnName = resultsQuery.getColumnName(i);
+            columnNames.add(columnName);
+        }
+        resultsQuery.close();
+        return columnNames;
+    }
+
+
     public void deleteTables(SQLiteDatabase sqLiteDatabase) {
-        List<Class> tables = getDomainClasses(context);
+        List<Class> tables = getDomainClasses();
         for (Class table : tables) {
             sqLiteDatabase.execSQL("DROP TABLE IF EXISTS " + NamingHelper.toSQLName(table));
         }
@@ -68,7 +89,7 @@ private boolean executeSugarUpgrade(SQLiteDatabase db, int oldVersion, int newVe
         boolean isSuccess = false;
 
         try {
-            List<String> files = Arrays.asList(this.context.getAssets().list("sugar_upgrades"));
+            List<String> files = Arrays.asList(getAssets().list("sugar_upgrades"));
             Collections.sort(files, new NumberComparator());
             for (String file : files) {
                 Log.i(SUGAR, "filename : " + file);
@@ -94,13 +115,21 @@ private boolean executeSugarUpgrade(SQLiteDatabase db, int oldVersion, int newVe
 
     private void executeScript(SQLiteDatabase db, String file) {
         try {
-            InputStream is = this.context.getAssets().open("sugar_upgrades/" + file);
+            InputStream is = getAssets().open("sugar_upgrades/" + file);
             BufferedReader reader = new BufferedReader(new InputStreamReader(is));
+            StringBuilder sb = new StringBuilder();
             String line;
             while ((line = reader.readLine()) != null) {
-                Log.i("Sugar script", line);
-                db.execSQL(line);
+                sb.append(line);
+            }
+            MigrationFileParser migrationFileParser = new MigrationFileParser(sb.toString());
+            for(String statement: migrationFileParser.getStatements()){
+                Log.i("Sugar script", statement);
+                if (!statement.isEmpty()) {
+                    db.execSQL(statement);
+                }
             }
+
         } catch (IOException e) {
             Log.e(SUGAR, e.getMessage());
         }
@@ -108,10 +137,54 @@ private void executeScript(SQLiteDatabase db, String file) {
         Log.i(SUGAR, "Script executed");
     }
 
-    private void createTable(Class<?> table, SQLiteDatabase sqLiteDatabase) {
+    private void addColumns(Class<?> table, SQLiteDatabase sqLiteDatabase) {
+        List<Field> fields = ReflectionUtil.getTableFields(table);
+        String tableName = NamingHelper.toSQLName(table);
+        ArrayList<String> presentColumns = getColumnNames(sqLiteDatabase, tableName);
+        ArrayList<String> alterCommands = new ArrayList<>();
+
+        for (Field column : fields) {
+            String columnName = NamingHelper.toSQLName(column);
+            String columnType = QueryBuilder.getColumnType(column.getType());
+
+            if (column.isAnnotationPresent(Column.class)) {
+                Column columnAnnotation = column.getAnnotation(Column.class);
+                columnName = columnAnnotation.name();
+            }
+
+            if (!presentColumns.contains(columnName)) {
+                StringBuilder sb = new StringBuilder("ALTER TABLE ");
+                sb.append(tableName).append(" ADD COLUMN ").append(columnName).append(" ").append(columnType);
+                if (column.isAnnotationPresent(NotNull.class)) {
+                    if (columnType.endsWith(" NULL")) {
+                        sb.delete(sb.length() - 5, sb.length());
+                    }
+                    sb.append(" NOT NULL");
+                }
+
+                // Unique is not working on ALTER TABLE
+//                if (column.isAnnotationPresent(Unique.class)) {
+//                    sb.append(" UNIQUE");
+//                }
+                alterCommands.add(sb.toString());
+            }
+        }
+
+        for (String command : alterCommands) {
+            Log.i("Sugar", command);
+            sqLiteDatabase.execSQL(command);
+        }
+    }
+
+    protected String createTableSQL(Class<?> table) {
         Log.i(SUGAR, "Create table if not exists");
         List<Field> fields = ReflectionUtil.getTableFields(table);
         String tableName = NamingHelper.toSQLName(table);
+
+        if(KeyWordUtil.isKeyword(tableName)) {
+            Log.i(SUGAR,"ERROR, SQLITE RESERVED WORD USED IN " + tableName);
+        }
+
         StringBuilder sb = new StringBuilder("CREATE TABLE IF NOT EXISTS ");
         sb.append(tableName).append(" ( ID INTEGER PRIMARY KEY AUTOINCREMENT ");
 
@@ -158,12 +231,36 @@ private void createTable(Class<?> table, SQLiteDatabase sqLiteDatabase) {
             }
         }
 
+        if (table.isAnnotationPresent(MultiUnique.class)) {
+            String constraint = table.getAnnotation(MultiUnique.class).value();
+
+            sb.append(", UNIQUE(");
+
+            String[] constraintFields = constraint.split(",");
+            for(int i = 0; i < constraintFields.length; i++) {
+                String columnName = NamingHelper.toSQLNameDefault(constraintFields[i]);
+                sb.append(columnName);
+
+                if(i < (constraintFields.length -1)) {
+                    sb.append(",");
+                }
+            }
+
+            sb.append(") ON CONFLICT REPLACE");
+        }
+
         sb.append(" ) ");
         Log.i(SUGAR, "Creating table " + tableName);
 
-        if (!sb.toString().isEmpty()) {
+        return sb.toString();
+    }
+
+    private void createTable(Class<?> table, SQLiteDatabase sqLiteDatabase) {
+        String createSQL = createTableSQL(table);
+
+        if (!createSQL.isEmpty()) {
             try {
-                sqLiteDatabase.execSQL(sb.toString());
+                sqLiteDatabase.execSQL(createSQL);
             } catch (SQLException e) {
                 e.printStackTrace();
             }
diff --git a/library/src/main/java/com/orm/SugarApp.java b/library/src/main/java/com/orm/SugarApp.java
index 5140e1ee..cab35ca7 100644
--- a/library/src/main/java/com/orm/SugarApp.java
+++ b/library/src/main/java/com/orm/SugarApp.java
@@ -1,7 +1,5 @@
 package com.orm;
 
-import com.orm.SugarContext;
-
 import android.app.Application;
 
 public class SugarApp extends Application {
diff --git a/library/src/main/java/com/orm/SugarContext.java b/library/src/main/java/com/orm/SugarContext.java
index 61acf813..511126f5 100644
--- a/library/src/main/java/com/orm/SugarContext.java
+++ b/library/src/main/java/com/orm/SugarContext.java
@@ -2,21 +2,21 @@
 
 import android.content.Context;
 
-import com.google.common.collect.MapMaker;
+import com.orm.util.ContextUtil;
 
-import java.util.concurrent.ConcurrentMap;
+import java.util.Collections;
+import java.util.Map;
+import java.util.WeakHashMap;
 
 public class SugarContext {
 
     private static SugarContext instance = null;
     private SugarDb sugarDb;
-    private Context context;
-    private ConcurrentMap<Object, Long> entitiesMap;
+    private Map<Object, Long> entitiesMap;
 
-    private SugarContext(Context context) {
-        this.context = context;
-        this.sugarDb = new SugarDb(context);
-        this.entitiesMap = new MapMaker().weakKeys().makeMap();
+    private SugarContext() {
+        this.sugarDb = SugarDb.getInstance();
+        this.entitiesMap = Collections.synchronizedMap(new WeakHashMap<Object, Long>());
     }
     
     public static SugarContext getSugarContext() {
@@ -27,7 +27,8 @@ public static SugarContext getSugarContext() {
     }
 
     public static void init(Context context) {
-        instance = new SugarContext(context);
+        ContextUtil.init(context);
+        instance = new SugarContext();
     }
 
     public static void terminate() {
@@ -35,6 +36,7 @@ public static void terminate() {
             return;
         }
         instance.doTerminate();
+        ContextUtil.terminate();
     }
 
     /*
@@ -49,11 +51,11 @@ private void doTerminate() {
         }
     }
 
-    protected SugarDb getSugarDb() {
+    public SugarDb getSugarDb() {
         return sugarDb;
     }
 
-    ConcurrentMap<Object, Long> getEntitiesMap() {
+    Map<Object, Long> getEntitiesMap() {
         return entitiesMap;
     }
 }
diff --git a/library/src/main/java/com/orm/SugarDb.java b/library/src/main/java/com/orm/SugarDb.java
index a15110a3..2b653ee7 100644
--- a/library/src/main/java/com/orm/SugarDb.java
+++ b/library/src/main/java/com/orm/SugarDb.java
@@ -1,24 +1,32 @@
 package com.orm;
 
-import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
+import android.util.Log;
 
-import com.orm.util.ManifestHelper;
 import com.orm.util.SugarCursorFactory;
 
 import static com.orm.util.ManifestHelper.getDatabaseVersion;
 import static com.orm.util.ManifestHelper.getDebugEnabled;
+import static com.orm.util.ManifestHelper.getDbName;
+
+import static com.orm.util.ContextUtil.*;
 
 public class SugarDb extends SQLiteOpenHelper {
+    private static final String LOG_TAG = "Sugar";
 
     private final SchemaGenerator schemaGenerator;
     private SQLiteDatabase sqLiteDatabase;
+    private int openedConnections = 0;
+
+    //Prevent instantiation
+    private SugarDb() {
+        super(getContext(), getDbName(), new SugarCursorFactory(getDebugEnabled()), getDatabaseVersion());
+        schemaGenerator = SchemaGenerator.getInstance();
+    }
 
-    public SugarDb(Context context) {
-        super(context, ManifestHelper.getDatabaseName(context),
-                new SugarCursorFactory(getDebugEnabled(context)), getDatabaseVersion(context));
-        schemaGenerator = new SchemaGenerator(context);
+    public static SugarDb getInstance() {
+        return new SugarDb();
     }
 
     @Override
@@ -39,4 +47,20 @@ public synchronized SQLiteDatabase getDB() {
         return this.sqLiteDatabase;
     }
 
+    @Override
+    public synchronized SQLiteDatabase getReadableDatabase() {
+        Log.d(LOG_TAG, "getReadableDatabase");
+        openedConnections++;
+        return super.getReadableDatabase();
+    }
+
+    @Override
+    public synchronized void close() {
+        Log.d(LOG_TAG, "getReadableDatabase");
+        openedConnections--;
+        if(openedConnections == 0) {
+            Log.d(LOG_TAG, "closing");
+            super.close();
+        }
+    }
 }
diff --git a/library/src/main/java/com/orm/SugarRecord.java b/library/src/main/java/com/orm/SugarRecord.java
index ce09527d..44cee5ff 100644
--- a/library/src/main/java/com/orm/SugarRecord.java
+++ b/library/src/main/java/com/orm/SugarRecord.java
@@ -9,6 +9,7 @@
 import android.util.Log;
 
 import com.orm.dsl.Table;
+import com.orm.dsl.Unique;
 import com.orm.util.NamingHelper;
 import com.orm.util.QueryBuilder;
 import com.orm.util.ReflectionUtil;
@@ -26,8 +27,8 @@
 import static com.orm.SugarContext.getSugarContext;
 
 public class SugarRecord {
-
     public static final String SUGAR = "Sugar";
+
     private Long id = null;
 
     private static SQLiteDatabase getSugarDataBase() {
@@ -71,6 +72,29 @@ private static SQLiteDatabase getSugarDataBase() {
         }
     }
 
+    @SuppressWarnings("deprecation")
+    public static <T> void updateInTx(T... objects) {
+        updateInTx(Arrays.asList(objects));
+    }
+
+    @SuppressWarnings("deprecation")
+    public static <T> void updateInTx(Collection<T> objects) {
+        SQLiteDatabase sqLiteDatabase = getSugarDataBase();
+        try {
+            sqLiteDatabase.beginTransaction();
+            sqLiteDatabase.setLockingEnabled(false);
+            for (T object: objects) {
+                update(object);
+            }
+            sqLiteDatabase.setTransactionSuccessful();
+        } catch (Exception e) {
+            Log.i(SUGAR, "Error in saving in transaction " + e.getMessage());
+        } finally {
+            sqLiteDatabase.endTransaction();
+            sqLiteDatabase.setLockingEnabled(true);
+        }
+    }
+
     @SuppressWarnings("deprecation")
     public static <T> int deleteInTx(T... objects) {
         return deleteInTx(Arrays.asList(objects));
@@ -150,13 +174,13 @@ private static SQLiteDatabase getSugarDataBase() {
 
     public static <T> Iterator<T> findWithQueryAsIterator(Class<T> type, String query, String... arguments) {
         Cursor cursor = getSugarDataBase().rawQuery(query, arguments);
-        return new CursorIterator<T>(type, cursor);
+        return new CursorIterator<>(type, cursor);
     }
 
     public static <T> Iterator<T> findAsIterator(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
         Cursor cursor = getSugarDataBase().query(NamingHelper.toSQLName(type), null, whereClause, whereArgs,
                 groupBy, null, orderBy, limit);
-        return new CursorIterator<T>(type, cursor);
+        return new CursorIterator<>(type, cursor);
     }
 
     public static <T> List<T> find(Class<T> type, String whereClause, String... whereArgs) {
@@ -174,7 +198,11 @@ public static void executeQuery(String query, String... arguments) {
     }
 
     public static <T> List<T> find(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
-        Cursor cursor = getSugarDataBase().query(NamingHelper.toSQLName(type), null, whereClause, whereArgs,
+
+        String args[];
+        args = (whereArgs == null) ? null : replaceArgs(whereArgs);
+
+        Cursor cursor = getSugarDataBase().query(NamingHelper.toSQLName(type), null, whereClause, args,
                 groupBy, null, orderBy, limit);
 
         return getEntitiesFromCursor(cursor, type);
@@ -182,7 +210,7 @@ public static void executeQuery(String query, String... arguments) {
 
     public static <T> List<T> getEntitiesFromCursor(Cursor cursor, Class<T> type){
         T entity;
-        List<T> result = new ArrayList<T>();
+        List<T> result = new ArrayList<>();
         try {
             while (cursor.moveToNext()) {
                 entity = type.getDeclaredConstructor().newInstance();
@@ -198,15 +226,15 @@ public static void executeQuery(String query, String... arguments) {
         return result;
     }
 
-    public static <T> long count(Class<?> type) {
+    public static <T> long count(Class<T> type) {
         return count(type, null, null, null, null, null);
     }
 
-    public static <T> long count(Class<?> type, String whereClause, String[] whereArgs) {
+    public static <T> long count(Class<T> type, String whereClause, String[] whereArgs) {
     	return count(type, whereClause, whereArgs, null, null, null);
     }
 
-    public static <T> long count(Class<?> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
+    public static <T> long count(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
         long result = -1;
         String filter = (!TextUtils.isEmpty(whereClause)) ? " where "  + whereClause : "";
         SQLiteStatement sqliteStatement;
@@ -260,7 +288,7 @@ static long save(SQLiteDatabase db, Object object) {
             if (idField != null) {
                 idField.setAccessible(true);
                 try {
-                    idField.set(object, new Long(id));
+                    idField.set(object, id);
                 } catch (IllegalAccessException e) {
                     e.printStackTrace();
                 }
@@ -276,6 +304,50 @@ static long save(SQLiteDatabase db, Object object) {
         return id;
     }
 
+    public static long update(Object object) {
+        return update(getSugarDataBase(), object);
+    }
+
+    static long update(SQLiteDatabase db, Object object) {
+        Map<Object, Long> entitiesMap = getSugarContext().getEntitiesMap();
+        List<Field> columns = ReflectionUtil.getTableFields(object.getClass());
+        ContentValues values = new ContentValues(columns.size());
+
+        StringBuilder whereClause = new StringBuilder();
+        List<String> whereArgs = new ArrayList<>();
+
+        for (Field column : columns) {
+            if(column.isAnnotationPresent(Unique.class)) {
+                try {
+                    column.setAccessible(true);
+                    String columnName = NamingHelper.toSQLName(column);
+                    Object columnValue = column.get(object);
+
+                    whereClause.append(columnName).append(" = ?");
+                    whereArgs.add(String.valueOf(columnValue));
+                } catch (IllegalAccessException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                if (!column.getName().equals("id")) {
+                    ReflectionUtil.addFieldValueToColumn(values, column, object, entitiesMap);
+                }
+            }
+        }
+
+        String[] whereArgsArray = whereArgs.toArray(new String[whereArgs.size()]);
+        // Get SugarRecord based on Unique values
+        long rowsEffected = db.update(NamingHelper.toSQLName(object.getClass()), values, whereClause.toString(), whereArgsArray);
+
+        if (rowsEffected == 0) {
+            return save(db, object);
+        } else {
+            return rowsEffected;
+        }
+    }
+
+
+
     public static boolean isSugarEntity(Class<?> objectClass) {
         return objectClass.isAnnotationPresent(Table.class) || SugarRecord.class.isAssignableFrom(objectClass);
     }
@@ -348,6 +420,10 @@ public long save() {
         return save(getSugarDataBase(), this);
     }
 
+    public long update() {
+        return update(getSugarDataBase(), this);
+    }
+
     @SuppressWarnings("unchecked")
     void inflate(Cursor cursor) {
         inflate(cursor, this, getSugarContext().getEntitiesMap());
@@ -407,4 +483,17 @@ public void remove() {
         }
     }
 
+    public static String[] replaceArgs(String[] args){
+
+        String [] replace = new String[args.length];
+        for (int i=0; i<args.length; i++){
+
+            replace[i]= (args[i].equals("true")) ? replace[i]="1" : (args[i].equals("false")) ? replace[i]="0" : args[i];
+
+        }
+
+        return replace;
+
+    }
+
 }
diff --git a/library/src/main/java/com/orm/SugarTransactionHelper.java b/library/src/main/java/com/orm/SugarTransactionHelper.java
index 73440635..74054cb3 100644
--- a/library/src/main/java/com/orm/SugarTransactionHelper.java
+++ b/library/src/main/java/com/orm/SugarTransactionHelper.java
@@ -4,27 +4,27 @@
 import android.util.Log;
 
 public class SugarTransactionHelper {
+    private static final String LOG_TAG = SugarTransactionHelper.class.getSimpleName();
 
     public static void doInTransaction(SugarTransactionHelper.Callback callback) {
         SQLiteDatabase database = SugarContext.getSugarContext().getSugarDb().getDB();
         database.beginTransaction();
 
         try {
-            Log.d(SugarTransactionHelper.class.getSimpleName(),
-                    "Callback executing within transaction");
+            Log.d(LOG_TAG, "Callback executing within transaction");
+
             callback.manipulateInTransaction();
             database.setTransactionSuccessful();
-            Log.d(SugarTransactionHelper.class.getSimpleName(),
-                    "Callback successfully executed within transaction");
+
+            Log.d(LOG_TAG, "Callback successfully executed within transaction");
         } catch (Throwable e) {
-            Log.d(SugarTransactionHelper.class.getSimpleName(),
-                    "Could execute callback within transaction", e);
+            Log.d(LOG_TAG, "Could execute callback within transaction", e);
         } finally {
             database.endTransaction();
         }
     }
 
-    public static interface Callback {
+    public interface Callback {
         void manipulateInTransaction();
     }
 }
diff --git a/library/src/main/java/com/orm/dsl/Column.java b/library/src/main/java/com/orm/dsl/Column.java
index 2c47e3c0..58e66529 100644
--- a/library/src/main/java/com/orm/dsl/Column.java
+++ b/library/src/main/java/com/orm/dsl/Column.java
@@ -1,9 +1,12 @@
 package com.orm.dsl;
 
+import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 
 @Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
 public @interface Column {
     String name();
     boolean unique() default false;
diff --git a/library/src/main/java/com/orm/dsl/Ignore.java b/library/src/main/java/com/orm/dsl/Ignore.java
index 9678d33a..e4d748f1 100644
--- a/library/src/main/java/com/orm/dsl/Ignore.java
+++ b/library/src/main/java/com/orm/dsl/Ignore.java
@@ -1,8 +1,11 @@
 package com.orm.dsl;
 
+import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 
 @Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
 public @interface Ignore {
 }
diff --git a/library/src/main/java/com/orm/dsl/MultiUnique.java b/library/src/main/java/com/orm/dsl/MultiUnique.java
new file mode 100644
index 00000000..86c6e323
--- /dev/null
+++ b/library/src/main/java/com/orm/dsl/MultiUnique.java
@@ -0,0 +1,12 @@
+package com.orm.dsl;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+public @interface MultiUnique {
+    String value();
+}
diff --git a/library/src/main/java/com/orm/dsl/NotNull.java b/library/src/main/java/com/orm/dsl/NotNull.java
index b2361851..f71ebf54 100644
--- a/library/src/main/java/com/orm/dsl/NotNull.java
+++ b/library/src/main/java/com/orm/dsl/NotNull.java
@@ -1,8 +1,11 @@
 package com.orm.dsl;
 
+import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 
 @Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
 public @interface NotNull {
 }
diff --git a/library/src/main/java/com/orm/dsl/Table.java b/library/src/main/java/com/orm/dsl/Table.java
index 0dfaa18b..9c64fa74 100644
--- a/library/src/main/java/com/orm/dsl/Table.java
+++ b/library/src/main/java/com/orm/dsl/Table.java
@@ -1,9 +1,12 @@
 package com.orm.dsl;
 
+import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 
 @Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
 public @interface Table {
     String name() default "";
 }
diff --git a/library/src/main/java/com/orm/dsl/Unique.java b/library/src/main/java/com/orm/dsl/Unique.java
index 7384b749..c05960ed 100644
--- a/library/src/main/java/com/orm/dsl/Unique.java
+++ b/library/src/main/java/com/orm/dsl/Unique.java
@@ -1,8 +1,11 @@
 package com.orm.dsl;
 
+import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 
 @Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
 public @interface Unique {
 }
diff --git a/library/src/main/java/com/orm/query/Select.java b/library/src/main/java/com/orm/query/Select.java
index cadea7b3..83f7102b 100644
--- a/library/src/main/java/com/orm/query/Select.java
+++ b/library/src/main/java/com/orm/query/Select.java
@@ -10,22 +10,32 @@
 import java.util.List;
 
 public class Select<T> implements Iterable {
+    private static final String SPACE = " ";
+    private static final String SINGLE_QUOTE = "'";
+    private static final String LEFT_PARENTHESIS = "(";
+    private static final String RIGHT_PARENTHESIS = ")";
+    private static final String SELECT_FROM = "SELECT * FROM ";
+    private static final String WHERE = "WHERE ";
+    private static final String ORDER_BY = "ORDER BY ";
+    private static final String GROUP_BY = "GROUP BY ";
+    private static final String LIMIT = "LIMIT ";
+    private static final String OFFSET = "OFFSET ";
 
     private Class<T> record;
     private String[] arguments;
     private String whereClause = "";
-    private String orderBy;
-    private String groupBy;
-    private String limit;
-    private String offset;
-    private List<Object> args = new ArrayList<Object>();
+    private String orderBy = "";
+    private String groupBy = "";
+    private String limit = "";
+    private String offset = "";
+    private List<String> args = new ArrayList<>();
 
     public Select(Class<T> record) {
         this.record = record;
     }
 
     public static <T> Select<T> from(Class<T> record) {
-        return new Select<T>(record);
+        return new Select<>(record);
     }
 
     public Select<T> orderBy(String prop) {
@@ -43,6 +53,11 @@ public Select(Class<T> record) {
         return this;
     }
 
+    public Select<T> offset(String offset) {
+        this.offset = offset;
+        return this;
+    }
+
     public Select<T> where(String whereClause) {
         this.whereClause = whereClause;
         return this;
@@ -56,10 +71,10 @@ public Select(Class<T> record) {
     }
 
     private void mergeConditions(Condition[] conditions, Condition.Type type) {
-        StringBuilder toAppend = new StringBuilder("");
+        StringBuilder toAppend = new StringBuilder();
         for (Condition condition : conditions) {
             if (toAppend.length() != 0) {
-                toAppend.append(" ").append(type.name()).append(" ");
+                toAppend.append(SPACE).append(type.name()).append(SPACE);
             }
 
             if (Condition.Check.LIKE.equals(condition.getCheck()) ||
@@ -67,9 +82,9 @@ private void mergeConditions(Condition[] conditions, Condition.Type type) {
                 toAppend
                     .append(condition.getProperty())
                     .append(condition.getCheckSymbol())
-                    .append("'")
+                    .append(SINGLE_QUOTE)
                     .append(condition.getValue().toString())
-                    .append("'");
+                    .append(SINGLE_QUOTE);
             } else if (Condition.Check.IS_NULL.equals(condition.getCheck()) ||
                     Condition.Check.IS_NOT_NULL.equals(condition.getCheck())) {
                 toAppend
@@ -80,15 +95,15 @@ private void mergeConditions(Condition[] conditions, Condition.Type type) {
                     .append(condition.getProperty())
                     .append(condition.getCheckSymbol())
                     .append("? ");
-                args.add(condition.getValue());
+                args.add(condition.getValue().toString());
             }
         }
         
-        if (!"".equals(whereClause)) {
-            whereClause += " " + type.name() + " ";
+        if (!whereClause.isEmpty()) {
+            whereClause += SPACE + type.name() + SPACE;
         }
 
-        whereClause += "(" + toAppend + ")";
+        whereClause += LEFT_PARENTHESIS + toAppend + RIGHT_PARENTHESIS;
     }
 
     public Select<T> whereOr(Condition... args) {
@@ -142,22 +157,26 @@ public T first() {
     
     String toSql() {
         StringBuilder sql = new StringBuilder();
-        sql.append("SELECT * FROM ").append(NamingHelper.toSQLName(this.record)).append(" ");
+        sql.append(SELECT_FROM).append(NamingHelper.toSQLName(this.record)).append(SPACE);
+
+        if (!whereClause.isEmpty()) {
+            sql.append(WHERE).append(whereClause).append(SPACE);
+        }
 
-        if (whereClause != null) {
-            sql.append("WHERE ").append(whereClause).append(" ");
+        if (!orderBy.isEmpty()) {
+            sql.append(ORDER_BY).append(orderBy).append(SPACE);
         }
 
-        if (orderBy != null) {
-            sql.append("ORDER BY ").append(orderBy).append(" ");
+        if (!groupBy.isEmpty()) {
+            sql.append(GROUP_BY).append(groupBy).append(SPACE);
         }
 
-        if (limit != null) {
-            sql.append("LIMIT ").append(limit).append(" ");
+        if (!limit.isEmpty()) {
+            sql.append(LIMIT).append(limit).append(SPACE);
         }
 
-        if (offset != null) {
-            sql.append("OFFSET ").append(offset).append(" ");
+        if (!offset.isEmpty()) {
+            sql.append(OFFSET).append(offset).append(SPACE);
         }
 
         return sql.toString();
@@ -171,14 +190,8 @@ String getWhereCond() {
         return convertArgs(args);
     }
 
-    private String[] convertArgs(List<Object> argsList) {
-        String[] argsArray = new String[argsList.size()];
-
-        for (int i = 0; i < argsList.size(); i++) {
-             argsArray[i] = argsList.get(i).toString();
-        }
-
-        return argsArray;
+    private String[] convertArgs(List<String> argsList) {
+        return argsList.toArray(new String[argsList.size()]);
     }
 
     @Override
diff --git a/library/src/main/java/com/orm/util/Collection.java b/library/src/main/java/com/orm/util/Collection.java
deleted file mode 100644
index fe7a7e63..00000000
--- a/library/src/main/java/com/orm/util/Collection.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.orm.util;
-import java.util.*;
-
-public class Collection {
-
-    public static <T> List<T> list(T... args) {
-        return Arrays.asList(args);
-    }
-
-    public static <T> Set<T> set(T... args) {
-        Set<T> result = new HashSet<T>(args.length);
-        result.addAll(Arrays.asList(args));
-        return result;
-    }
-
-    public static <K, V> Map<K, V> map(Entry<? extends K, ? extends V>... entries) {
-        Map<K, V> result = new HashMap<K, V>(entries.length);
-
-        for (Entry<? extends K, ? extends V> entry : entries)
-            if (entry.value != null)
-                result.put(entry.key, entry.value);
-
-        return result;
-    }
-
-    public static <K, V> Entry<K, V> entry(K key, V value) {
-        return new Entry<K, V>(key, value);
-    }
-
-    public static class Entry<K, V> {
-        K key;
-        V value;
-
-        public Entry(K key, V value) {
-            this.key = key;
-            this.value = value;
-        }
-    }
-
-}
diff --git a/library/src/main/java/com/orm/util/ContextUtil.java b/library/src/main/java/com/orm/util/ContextUtil.java
new file mode 100644
index 00000000..3e6eff58
--- /dev/null
+++ b/library/src/main/java/com/orm/util/ContextUtil.java
@@ -0,0 +1,48 @@
+package com.orm.util;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.pm.PackageManager;
+import android.content.res.AssetManager;
+
+/**
+ * @author jonatan.salas
+ */
+public final class ContextUtil {
+    private static Context ctx;
+
+    //Prevent instantiation
+    private ContextUtil() { }
+
+    public static void init(Context context) {
+        if (null == context) {
+            throw new IllegalArgumentException("context shouldn't be null!");
+        }
+
+        ctx = context;
+    }
+
+    public static void terminate() {
+        ctx = null;
+    }
+
+    public static Context getContext() {
+        return ctx;
+    }
+
+    public static AssetManager getAssets() {
+        return getContext().getAssets();
+    }
+
+    public static PackageManager getPackageManager() {
+        return getContext().getPackageManager();
+    }
+
+    public static String getPackageName() {
+        return getContext().getPackageName();
+    }
+
+    public static SharedPreferences getSharedPreferences(String name, int mode) {
+        return getContext().getSharedPreferences(name, mode);
+    }
+}
diff --git a/library/src/main/java/com/orm/util/KeyWordUtil.java b/library/src/main/java/com/orm/util/KeyWordUtil.java
new file mode 100644
index 00000000..8983e7cf
--- /dev/null
+++ b/library/src/main/java/com/orm/util/KeyWordUtil.java
@@ -0,0 +1,41 @@
+package com.orm.util;
+
+/**
+ * @author jonatan.salas
+ */
+public final class KeyWordUtil {
+
+    private static final String[] KEY_WORDS = new String[] {
+            "", "ABORT", "ACTION", "ADD", "AFTER", "ALTER", "ANALYZE", "AND", "AS", "ASC", "ATTACH",
+            "AUTOINCREMENT", "BEFORE", "BEGIN", "BETWEEN", "BY", "CASCADE", "CASE", "CAST", "CHECK",
+            "COLLATE", "COLUMN", "COMMIT", "CONFLICT", "CONSTRAINT", "CREATE", "CROSS", "CURRENT_DATE",
+            "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATABASE", "DEFAULT", "DEFERRABLE", "DEFERRED", "DELETE",
+            "DESC", "DETACH", "DISTINCT", "DROP", "EACH", "ELSE", "END", "ESCAPE", "EXCEPT", "EXCLUSIVE",
+            "EXISTS", "EXPLAIN", "FAIL", "FOR", "FOREIGN", "FROM", "FULL", "GLOB", "GROUP", "HAVING",
+            "IF", "IGNORE", "IMMEDIATE", "IN", "INDEX", "INDEXED", "INITIALLY", "INNER", "INSERT", "INSTEAD",
+            "INTERSECT", "INTO", "IS", "ISNULL", "JOIN", "KEY", "LEFT", "LIKE", "LIMIT", "MATCH", "NATURAL",
+            "NO", "NOT", "NOTNULL", "NULL", "OF", "OFFSET", "ON", "OR", "ORDER", "OUTER", "PLAN", "PRAGMA",
+            "PRIMARY", "QUERY", "RAISE", "RECURSIVE", "REFERENCES", "REGEXP", "REINDEX", "RELEASE", "RENAME",
+            "REPLACE", "RESTRICT", "RIGHT", "ROLLBACK", "ROW", "SAVEPOINT", "SELECT", "SET", "TABLE", "TEMP",
+            "TEMPORARY", "THEN", "TO", "TRANSACTION", "TRIGGER", "UNION", "UNIQUE", "UPDATE", "USING", "VACUUM",
+            "VALUES", "VIEW", "VIRTUAL", "WHEN", "WHERE", "WITH", "WITHOUT"
+    };
+
+    //Prevent instantiation
+    private KeyWordUtil() { }
+
+    public static boolean isKeyword(String word) {
+        if (null == word) {
+            return false;
+        }
+
+        for (String keyWord: KEY_WORDS) {
+            if (keyWord.equals(word)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
+
diff --git a/library/src/main/java/com/orm/util/ManifestHelper.java b/library/src/main/java/com/orm/util/ManifestHelper.java
index fb65724c..f986a58b 100644
--- a/library/src/main/java/com/orm/util/ManifestHelper.java
+++ b/library/src/main/java/com/orm/util/ManifestHelper.java
@@ -1,39 +1,45 @@
 package com.orm.util;
 
-import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.util.Log;
 
+import static com.orm.util.ContextUtil.*;
+
 /**
  * Helper class for accessing properties in the AndroidManifest
  */
-public class ManifestHelper {
+public final class ManifestHelper {
+    private static final String LOG_TAG = "Sugar";
 
     /**
      * Key for the database name meta data.
      */
     public final static String METADATA_DATABASE = "DATABASE";
+
     /**
-     * Key for the database verison meta data.
+     * Key for the database version meta data.
      */
     public final static String METADATA_VERSION = "VERSION";
     public final static String METADATA_DOMAIN_PACKAGE_NAME = "DOMAIN_PACKAGE_NAME";
     public final static String METADATA_QUERY_LOG = "QUERY_LOG";
+
     /**
      * The default name for the database unless specified in the AndroidManifest.
      */
     public final static String DATABASE_DEFAULT_NAME = "Sugar.db";
 
+    //Prevent instantiation
+    private ManifestHelper() { }
+
     /**
      * Grabs the database version from the manifest.
      *
-     * @param context  the {@link android.content.Context} of the Android application
      * @return the database version as specified by the {@link #METADATA_VERSION} version or 1 of
      *         not present
      */
-    public static int getDatabaseVersion(Context context) {
-        Integer databaseVersion = getMetaDataInteger(context, METADATA_VERSION);
+    public static int getDatabaseVersion() {
+        Integer databaseVersion = getMetaDataInteger(METADATA_VERSION);
 
         if ((databaseVersion == null) || (databaseVersion == 0)) {
             databaseVersion = 1;
@@ -45,11 +51,10 @@ public static int getDatabaseVersion(Context context) {
     /**
      * Grabs the domain name of the model classes from the manifest. 
      *
-     * @param context  the {@link android.content.Context} of the Android application
      * @return the package String that Sugar uses to search for model classes
      */
-    public static String getDomainPackageName(Context context){
-        String domainPackageName = getMetaDataString(context, METADATA_DOMAIN_PACKAGE_NAME);
+    public static String getDomainPackageName() {
+        String domainPackageName = getMetaDataString(METADATA_DOMAIN_PACKAGE_NAME);
 
         if (domainPackageName == null) {
             domainPackageName = "";
@@ -61,12 +66,11 @@ public static String getDomainPackageName(Context context){
     /**
      * Grabs the name of the database file specified in the manifest.
      *
-     * @param context  the {@link android.content.Context} of the Android application
      * @return the value for the {@value #METADATA_DATABASE} meta data in the AndroidManifest or
      *         {@link #DATABASE_DEFAULT_NAME} if not present
      */
-    public static String getDatabaseName(Context context) {
-        String databaseName = getMetaDataString(context, METADATA_DATABASE);
+    public static String getDatabaseName() {
+        String databaseName = getMetaDataString(METADATA_DATABASE);
 
         if (databaseName == null) {
             databaseName = DATABASE_DEFAULT_NAME;
@@ -75,59 +79,58 @@ public static String getDatabaseName(Context context) {
         return databaseName;
     }
 
+    public static String getDbName() {
+        return getDatabaseName();
+    }
+
     /**
      * Grabs the debug flag from the manifest.
      *
-     * @param context  the {@link android.content.Context} of the Android application
      * @return true if the debug flag is enabled
      */
-    public static boolean getDebugEnabled(Context context) {
-        return getMetaDataBoolean(context, METADATA_QUERY_LOG);
+    public static boolean getDebugEnabled() {
+        return getMetaDataBoolean(METADATA_QUERY_LOG);
     }
 
-    private static String getMetaDataString(Context context, String name) {
+    private static String getMetaDataString(String name) {
+        PackageManager pm = getPackageManager();
         String value = null;
 
-        PackageManager pm = context.getPackageManager();
         try {
-            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(),
-                    PackageManager.GET_META_DATA);
+            ApplicationInfo ai = pm.getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);
             value = ai.metaData.getString(name);
         } catch (Exception e) {
-            Log.d("sugar", "Couldn't find config value: " + name);
+            Log.d(LOG_TAG, "Couldn't find config value: " + name);
         }
 
         return value;
     }
 
-    private static Integer getMetaDataInteger(Context context, String name) {
+    private static Integer getMetaDataInteger(String name) {
+        PackageManager pm = getPackageManager();
         Integer value = null;
 
-        PackageManager pm = context.getPackageManager();
         try {
-            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(),
-                    PackageManager.GET_META_DATA);
+            ApplicationInfo ai = pm.getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);
             value = ai.metaData.getInt(name);
         } catch (Exception e) {
-            Log.d("sugar", "Couldn't find config value: " + name);
+            Log.d(LOG_TAG, "Couldn't find config value: " + name);
         }
 
         return value;
     }
 
-    private static Boolean getMetaDataBoolean(Context context, String name) {
+    private static Boolean getMetaDataBoolean(String name) {
+        PackageManager pm = getPackageManager();
         Boolean value = false;
 
-        PackageManager pm = context.getPackageManager();
         try {
-            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(),
-                    PackageManager.GET_META_DATA);
+            ApplicationInfo ai = pm.getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);
             value = ai.metaData.getBoolean(name);
         } catch (Exception e) {
-            Log.d("sugar", "Couldn't find config value: " + name);
+            Log.d(LOG_TAG, "Couldn't find config value: " + name);
         }
 
         return value;
     }
-
 }
diff --git a/library/src/main/java/com/orm/util/MigrationFileParser.java b/library/src/main/java/com/orm/util/MigrationFileParser.java
new file mode 100644
index 00000000..1691a1eb
--- /dev/null
+++ b/library/src/main/java/com/orm/util/MigrationFileParser.java
@@ -0,0 +1,21 @@
+package com.orm.util;
+
+/**
+ * Created by Nursultan Turdaliev on 12/4/15.
+ */
+public class MigrationFileParser {
+
+    private String content;
+
+    /**
+     * @param content
+     */
+    public MigrationFileParser(String content){
+        this.content = content.replaceAll("(\\/\\*([\\s\\S]*?)\\*\\/)|(--(.)*)|(\n)","");
+    }
+
+    public String[] getStatements(){
+        return this.content.split(";");
+    }
+
+}
diff --git a/library/src/main/java/com/orm/util/MultiDexHelper.java b/library/src/main/java/com/orm/util/MultiDexHelper.java
index 37b57894..c074eeee 100644
--- a/library/src/main/java/com/orm/util/MultiDexHelper.java
+++ b/library/src/main/java/com/orm/util/MultiDexHelper.java
@@ -14,48 +14,56 @@
 
 import dalvik.system.DexFile;
 
+import static com.orm.util.ContextUtil.getSharedPreferences;
+import static com.orm.util.ContextUtil.getPackageManager;
+import static com.orm.util.ContextUtil.getPackageName;
+
 /**
  * Created by xudshen@hotmail.com on 14/11/13.
  */
-
 //http://stackoverflow.com/a/26892658
 public class MultiDexHelper {
     private static final String EXTRACTED_NAME_EXT = ".classes";
     private static final String EXTRACTED_SUFFIX = ".zip";
-
-    private static final String SECONDARY_FOLDER_NAME = "code_cache" + File.separator +
-            "secondary-dexes";
-
+    private static final String INSTANT_RUN_DEX_DIR_PATH = "files/instant-run/dex/";
+    private static final String SECONDARY_FOLDER_NAME = "code_cache" + File.separator + "secondary-dexes";
     private static final String PREFS_FILE = "multidex.version";
     private static final String KEY_DEX_NUMBER = "dex.number";
 
-    private static SharedPreferences getMultiDexPreferences(Context context) {
-        return context.getSharedPreferences(PREFS_FILE,
-                Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB
-                        ? Context.MODE_PRIVATE
-                        : Context.MODE_PRIVATE | Context.MODE_MULTI_PROCESS);
+    private static SharedPreferences getMultiDexPreferences() {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
+            return getSharedPreferences(PREFS_FILE, Context.MODE_PRIVATE);
+        } else {
+            return getSharedPreferences(PREFS_FILE, Context.MODE_MULTI_PROCESS);
+        }
     }
 
     /**
      * get all the dex path
      *
-     * @param context the application context
-     * @return all the dex path
+     * @return all the dex path, including the ones in the newly added instant-run folder
      * @throws PackageManager.NameNotFoundException
      * @throws IOException
      */
-    public static List<String> getSourcePaths(Context context) throws PackageManager.NameNotFoundException, IOException {
-        ApplicationInfo applicationInfo = context.getPackageManager().getApplicationInfo(context.getPackageName(), 0);
+    public static List<String> getSourcePaths() throws PackageManager.NameNotFoundException, IOException {
+        ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(getPackageName(), 0);
         File sourceApk = new File(applicationInfo.sourceDir);
         File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);
+        File instantRunDir = new File(applicationInfo.dataDir, INSTANT_RUN_DEX_DIR_PATH); //default instant-run dir
 
-        List<String> sourcePaths = new ArrayList<String>();
+        List<String> sourcePaths = new ArrayList<>();
         sourcePaths.add(applicationInfo.sourceDir); //add the default apk path
 
+        if (instantRunDir.exists()) { //check if app using instant run
+            for(final File dexFile : instantRunDir.listFiles()) { //add all sources from instan-run
+                sourcePaths.add(dexFile.getAbsolutePath());
+            }
+        }
+
         //the prefix of extracted file, ie: test.classes
         String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;
         //the total dex numbers
-        int totalDexNumber = getMultiDexPreferences(context).getInt(KEY_DEX_NUMBER, 1);
+        int totalDexNumber = getMultiDexPreferences().getInt(KEY_DEX_NUMBER, 1);
 
         for (int secondaryNumber = 2; secondaryNumber <= totalDexNumber; secondaryNumber++) {
             //for each dex file, ie: test.classes2.zip, test.classes3.zip...
@@ -64,9 +72,6 @@ private static SharedPreferences getMultiDexPreferences(Context context) {
             if (extractedFile.isFile()) {
                 sourcePaths.add(extractedFile.getAbsolutePath());
                 //we ignore the verify zip part
-            } else {
-                throw new IOException("Missing extracted secondary dex file '" +
-                        extractedFile.getPath() + "'");
             }
         }
 
@@ -76,16 +81,15 @@ private static SharedPreferences getMultiDexPreferences(Context context) {
     /**
      * get all the classes name in "classes.dex", "classes2.dex", ....
      *
-     * @param context the application context
      * @return all the classes name
      * @throws PackageManager.NameNotFoundException
      * @throws IOException
      */
-    public static List<String> getAllClasses(Context context) throws PackageManager.NameNotFoundException, IOException {
-        List<String> classNames = new ArrayList<String>();
-        for (String path : getSourcePaths(context)) {
+    public static List<String> getAllClasses() throws PackageManager.NameNotFoundException, IOException {
+        List<String> classNames = new ArrayList<>();
+        for (String path : getSourcePaths()) {
             try {
-                DexFile dexfile = null;
+                DexFile dexfile;
                 if (path.endsWith(EXTRACTED_SUFFIX)) {
                     //NOT use new DexFile(path), because it will throw "permission error in /data/dalvik-cache"
                     dexfile = DexFile.loadDex(path, path + ".tmp", 0);
@@ -97,10 +101,9 @@ private static SharedPreferences getMultiDexPreferences(Context context) {
                     classNames.add(dexEntries.nextElement());
                 }
             } catch (IOException e) {
-                throw new IOException("Error at loading dex file '" +
-                        path + "'");
+                throw new IOException("Error at loading dex file '" + path + "'");
             }
         }
         return classNames;
     }
-}
\ No newline at end of file
+}
diff --git a/library/src/main/java/com/orm/util/NamingHelper.java b/library/src/main/java/com/orm/util/NamingHelper.java
index 734b4a56..55253ebd 100644
--- a/library/src/main/java/com/orm/util/NamingHelper.java
+++ b/library/src/main/java/com/orm/util/NamingHelper.java
@@ -1,14 +1,9 @@
 package com.orm.util;
 
-import android.text.TextUtils;
-
 import com.orm.dsl.Column;
 import com.orm.dsl.Table;
 
 import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
 
 public class NamingHelper {
 
@@ -74,7 +69,7 @@ public static String toSQLName(Field field) {
     /**
      * Maps a Java Class to the name of the class.
      *
-     * @param table  the generic {@link java.lang.Class<T>} that defines a database table
+     * @param table  the generic {@link java.lang.Class} that defines a database table
      * @return if the given class is annotated with {@link com.orm.dsl.Table} then the value for
      *         {@link com.orm.dsl.Table#name()} will be returned. Else, the class' simple name will 
      *         be converted from CamelCase to UNDER_SCORE notation
diff --git a/library/src/main/java/com/orm/util/NumberComparator.java b/library/src/main/java/com/orm/util/NumberComparator.java
index b39ca9c9..08a9f0b4 100644
--- a/library/src/main/java/com/orm/util/NumberComparator.java
+++ b/library/src/main/java/com/orm/util/NumberComparator.java
@@ -49,8 +49,8 @@ public int compare(Object o1, Object o2) {
 
         int ia = 0;
         int ib = 0;
-        int nza = 0;
-        int nzb = 0;
+        int nza;
+        int nzb;
         while (true) {
             nza = nzb = 0;
 
diff --git a/library/src/main/java/com/orm/util/ReflectionUtil.java b/library/src/main/java/com/orm/util/ReflectionUtil.java
index d8492222..2ff1162b 100644
--- a/library/src/main/java/com/orm/util/ReflectionUtil.java
+++ b/library/src/main/java/com/orm/util/ReflectionUtil.java
@@ -17,7 +17,6 @@
 import java.lang.reflect.Modifier;
 import java.math.BigDecimal;
 import java.net.URL;
-import java.sql.Ref;
 import java.sql.Timestamp;
 import java.util.ArrayList;
 import java.util.Calendar;
@@ -27,22 +26,20 @@
 import java.util.List;
 import java.util.Map;
 
-import dalvik.system.DexFile;
+import static com.orm.util.ContextUtil.getContext;
 
 public class ReflectionUtil {
 
-    private static final String TAG = ReflectionUtil.class.getSimpleName();
-
     public static List<Field> getTableFields(Class table) {
         List<Field> fieldList = SugarConfig.getFields(table);
         if (fieldList != null) return fieldList;
 
         Log.d("Sugar", "Fetching properties");
-        List<Field> typeFields = new ArrayList<Field>();
+        List<Field> typeFields = new ArrayList<>();
 
         getAllFields(typeFields, table);
 
-        List<Field> toStore = new ArrayList<Field>();
+        List<Field> toStore = new ArrayList<>();
         for (Field field : typeFields) {
             if (!field.isAnnotationPresent(Ignore.class) && !Modifier.isStatic(field.getModifiers()) && !Modifier.isTransient(field.getModifiers())) {
                 toStore.add(field);
@@ -72,7 +69,7 @@ public static void addFieldValueToColumn(ContentValues values, Field column, Obj
             Object columnValue = column.get(object);
 
             if (columnType.isAnnotationPresent(Table.class)) {
-                Field field = null;
+                Field field;
                 try {
                     field = columnType.getDeclaredField("id");
                     field.setAccessible(true);
@@ -156,13 +153,19 @@ public static void setFieldValueFromCursor(Cursor cursor, Field field, Object ob
 
             int columnIndex = cursor.getColumnIndex(colName);
 
+            //TODO auto upgrade to add new columns
+            if (columnIndex < 0) {
+                Log.e("SUGAR", "Invalid colName, you should upgrade database");
+                return;
+            }
+
             if (cursor.isNull(columnIndex)) {
                 return;
             }
 
             if (colName.equalsIgnoreCase("id")) {
                 long cid = cursor.getLong(columnIndex);
-                field.set(object, Long.valueOf(cid));
+                field.set(object, cid);
             } else if (fieldType.equals(long.class) || fieldType.equals(Long.class)) {
                 field.set(object,
                         cursor.getLong(columnIndex));
@@ -216,22 +219,18 @@ public static void setFieldValueFromCursor(Cursor cursor, Field field, Object ob
                 }
             } else
                 Log.e("Sugar", "Class cannot be read from Sqlite3 database. Please check the type of field " + field.getName() + "(" + field.getType().getName() + ")");
-        } catch (IllegalArgumentException e) {
-            Log.e("field set error", e.getMessage());
-        } catch (IllegalAccessException e) {
+        } catch (IllegalArgumentException | IllegalAccessException e) {
             Log.e("field set error", e.getMessage());
         }
     }
 
     private static Field getDeepField(String fieldName, Class<?> type) throws NoSuchFieldException {
         try {
-            Field field = type.getDeclaredField(fieldName);
-            return field;
+            return type.getDeclaredField(fieldName);
         } catch (NoSuchFieldException e) {
             Class superclass = type.getSuperclass();
             if (superclass != null) {
-                Field field = getDeepField(fieldName, superclass);
-                return field;
+                return getDeepField(fieldName, superclass);
             } else {
                 throw e;
             }
@@ -243,24 +242,19 @@ public static void setFieldValueForId(Object object, Long value) {
             Field field = getDeepField("id", object.getClass());
             field.setAccessible(true);
             field.set(object, value);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        } catch (NoSuchFieldException e) {
+        } catch (Exception e) {
             e.printStackTrace();
         }
     }
 
-    public static List<Class> getDomainClasses(Context context) {
-        List<Class> domainClasses = new ArrayList<Class>();
+    public static List<Class> getDomainClasses() {
+        List<Class> domainClasses = new ArrayList<>();
         try {
-            for (String className : getAllClasses(context)) {
-                Log.d(TAG, className);
-                Class domainClass = getDomainClass(className, context);
+            for (String className : getAllClasses()) {
+                Class domainClass = getDomainClass(className);
                 if (domainClass != null) domainClasses.add(domainClass);
             }
-        } catch (IOException e) {
-            Log.e("Sugar", e.getMessage());
-        } catch (PackageManager.NameNotFoundException e) {
+        } catch (IOException | PackageManager.NameNotFoundException  e) {
             Log.e("Sugar", e.getMessage());
         }
 
@@ -268,12 +262,13 @@ public static void setFieldValueForId(Object object, Long value) {
     }
 
 
-    private static Class getDomainClass(String className, Context context) {
+    private static Class getDomainClass(String className) {
         Class<?> discoveredClass = null;
         try {
-            discoveredClass = Class.forName(className, true, context.getClass().getClassLoader());
-        } catch (ClassNotFoundException e) {
-            Log.e("Sugar", e.getMessage());
+            discoveredClass = Class.forName(className, true, Thread.currentThread().getContextClassLoader());
+        } catch (Throwable e) {
+            String error = (e.getMessage() == null) ? "getDomainClass " + className + " error" : e.getMessage();
+            Log.e("Sugar", error);
         }
 
         if ((discoveredClass != null) &&
@@ -291,11 +286,11 @@ private static Class getDomainClass(String className, Context context) {
     }
 
 
-    private static List<String> getAllClasses(Context context) throws PackageManager.NameNotFoundException, IOException {
-        String packageName = ManifestHelper.getDomainPackageName(context);
-        List<String> classNames = new ArrayList<String>();
+    private static List<String> getAllClasses() throws PackageManager.NameNotFoundException, IOException {
+        String packageName = ManifestHelper.getDomainPackageName();
+        List<String> classNames = new ArrayList<>();
         try {
-            List<String> allClasses = MultiDexHelper.getAllClasses(context);
+            List<String> allClasses = MultiDexHelper.getAllClasses();
             for (String classString : allClasses) {
                 if (classString.startsWith(packageName)) classNames.add(classString);
             }
@@ -303,9 +298,10 @@ private static Class getDomainClass(String className, Context context) {
             ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
             Enumeration<URL> urls = classLoader.getResources("");
             while (urls.hasMoreElements()) {
-                List<String> fileNames = new ArrayList<String>();
+                List<String> fileNames = new ArrayList<>();
                 String classDirectoryName = urls.nextElement().getFile();
-                if (classDirectoryName.contains("bin") || classDirectoryName.contains("classes")) {
+                if (classDirectoryName.contains("bin") || classDirectoryName.contains("classes")
+                        || classDirectoryName.contains("retrolambda")) {
                     File classDirectory = new File(classDirectoryName);
                     for (File filePath : classDirectory.listFiles()) {
                         populateFiles(filePath, fileNames, "");
@@ -315,9 +311,11 @@ private static Class getDomainClass(String className, Context context) {
                     }
                 }
             }
-        } finally {
-//            if (null != dexfile) dexfile.close();
         }
+//        } finally {
+//            if (null != dexfile) dexfile.close();
+//        }
+
         return classNames;
     }
 
diff --git a/library/src/main/java/com/orm/util/SugarConfig.java b/library/src/main/java/com/orm/util/SugarConfig.java
index b93da25e..9328c82f 100644
--- a/library/src/main/java/com/orm/util/SugarConfig.java
+++ b/library/src/main/java/com/orm/util/SugarConfig.java
@@ -1,20 +1,14 @@
 package com.orm.util;
 
-import android.content.Context;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageManager;
-import android.util.Log;
-
 import java.lang.reflect.Field;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
-
 public class SugarConfig {
 
-    static Map<Class<?>, List<Field>> fields = new HashMap<Class<?>, List<Field>>();
+    static Map<Class<?>, List<Field>> fields = new HashMap<>();
 
     public static void setFields(Class<?> clazz, List<Field> fieldz) {
          fields.put(clazz, fieldz);
@@ -31,7 +25,7 @@ public static void setFields(Class<?> clazz, List<Field> fieldz) {
 
     public static void clearCache() {
         fields.clear();
-        fields = new HashMap<Class<?>, List<Field>>();
+        fields = new HashMap<>();
     }
 
 }
diff --git a/library/src/main/java/com/orm/util/SugarCursor.java b/library/src/main/java/com/orm/util/SugarCursor.java
index e326f49b..d058c5c1 100644
--- a/library/src/main/java/com/orm/util/SugarCursor.java
+++ b/library/src/main/java/com/orm/util/SugarCursor.java
@@ -4,6 +4,7 @@
 import android.database.CursorWrapper;
 
 public class SugarCursor extends CursorWrapper {
+
     public SugarCursor(Cursor cursor) {
         super(cursor);
     }
diff --git a/library/src/main/java/com/orm/util/SugarCursorFactory.java b/library/src/main/java/com/orm/util/SugarCursorFactory.java
index 12706516..3274fccc 100644
--- a/library/src/main/java/com/orm/util/SugarCursorFactory.java
+++ b/library/src/main/java/com/orm/util/SugarCursorFactory.java
@@ -16,7 +16,6 @@ public SugarCursorFactory() {
     }
 
     public SugarCursorFactory(boolean debugEnabled) {
-
         this.debugEnabled = debugEnabled;
     }
 
diff --git a/library/src/test/java/com/orm/SchemaGeneratorTest.java b/library/src/test/java/com/orm/SchemaGeneratorTest.java
new file mode 100644
index 00000000..00dea418
--- /dev/null
+++ b/library/src/test/java/com/orm/SchemaGeneratorTest.java
@@ -0,0 +1,82 @@
+package com.orm;
+
+import com.orm.models.EmptyModel;
+import com.orm.models.IntUniqueModel;
+import com.orm.models.MultiColumnUniqueModel;
+import com.orm.models.StringFieldAnnotatedModel;
+import com.orm.models.StringFieldExtendedModel;
+import com.orm.models.StringFieldExtendedModelAnnotatedColumn;
+import com.orm.query.DummyContext;
+import com.orm.util.ContextUtil;
+import com.orm.util.NamingHelper;
+
+import org.junit.Test;
+
+import static junit.framework.Assert.assertEquals;
+
+public class SchemaGeneratorTest {
+
+    @Test
+    public void testEmptyTableCreation() throws Exception {
+        ContextUtil.init(new DummyContext());
+        SchemaGenerator schemaGenerator = SchemaGenerator.getInstance();
+        String createSQL = schemaGenerator.createTableSQL(EmptyModel.class);
+        assertEquals(
+                "CREATE TABLE IF NOT EXISTS " + NamingHelper.toSQLName(EmptyModel.class) +
+                    " ( ID INTEGER PRIMARY KEY AUTOINCREMENT  ) ",
+                createSQL);
+    }
+
+    @Test
+    public void testSimpleColumnTableCreation() throws Exception {
+        ContextUtil.init(new DummyContext());
+        SchemaGenerator schemaGenerator = SchemaGenerator.getInstance();
+        String createSQL = schemaGenerator.createTableSQL(StringFieldExtendedModel.class);
+        assertEquals(
+                "CREATE TABLE IF NOT EXISTS " + NamingHelper.toSQLName(StringFieldExtendedModel.class) +
+                        " ( ID INTEGER PRIMARY KEY AUTOINCREMENT , " +
+                        "NAME TEXT ) ",
+                createSQL);
+
+        String createSQL2 = schemaGenerator.createTableSQL(StringFieldAnnotatedModel.class);
+
+        assertEquals(
+                "CREATE TABLE IF NOT EXISTS " + NamingHelper.toSQLName(StringFieldAnnotatedModel.class) +
+                        " ( ID INTEGER PRIMARY KEY AUTOINCREMENT , " +
+                        "NAME TEXT ) ",
+                createSQL2);
+
+        String createSQL3 = schemaGenerator.createTableSQL(StringFieldExtendedModelAnnotatedColumn.class);
+
+        assertEquals(
+                "CREATE TABLE IF NOT EXISTS " + NamingHelper.toSQLName(StringFieldExtendedModelAnnotatedColumn.class) +
+                        " ( ID INTEGER PRIMARY KEY AUTOINCREMENT , " +
+                        "anyName TEXT ) ",
+                createSQL3);
+    }
+
+    @Test
+    public void testUniqueTableCreation() {
+        ContextUtil.init(new DummyContext());
+        SchemaGenerator schemaGenerator = SchemaGenerator.getInstance();
+        String createSQL = schemaGenerator.createTableSQL(IntUniqueModel.class);
+        assertEquals(
+                "CREATE TABLE IF NOT EXISTS " + NamingHelper.toSQLName(IntUniqueModel.class) +
+                        " ( ID INTEGER PRIMARY KEY AUTOINCREMENT , " +
+                        "VALUE INTEGER UNIQUE ) ",
+                createSQL);
+    }
+
+    @Test
+    public void testMultiColumnUniqueTableCreation() {
+        ContextUtil.init(new DummyContext());
+        SchemaGenerator schemaGenerator = SchemaGenerator.getInstance();
+        String createSQL = schemaGenerator.createTableSQL(MultiColumnUniqueModel.class);
+        assertEquals(
+                "CREATE TABLE IF NOT EXISTS " + NamingHelper.toSQLName(MultiColumnUniqueModel.class) +
+                        " ( ID INTEGER PRIMARY KEY AUTOINCREMENT , " +
+                        "A INTEGER, B INTEGER, " +
+                        "UNIQUE(A, B) ON CONFLICT REPLACE ) ",
+                createSQL);
+    }
+}
diff --git a/library/src/test/java/com/orm/models/EmptyModel.java b/library/src/test/java/com/orm/models/EmptyModel.java
new file mode 100644
index 00000000..73459b51
--- /dev/null
+++ b/library/src/test/java/com/orm/models/EmptyModel.java
@@ -0,0 +1,10 @@
+package com.orm.models;
+
+import com.orm.SugarRecord;
+
+/**
+ * Created by sibelius on 02/12/15.
+ */
+public class EmptyModel extends SugarRecord {
+    public EmptyModel() { }
+}
diff --git a/library/src/test/java/com/orm/models/IntUniqueModel.java b/library/src/test/java/com/orm/models/IntUniqueModel.java
new file mode 100644
index 00000000..d7b88d3f
--- /dev/null
+++ b/library/src/test/java/com/orm/models/IntUniqueModel.java
@@ -0,0 +1,19 @@
+package com.orm.models;
+
+import com.orm.SugarRecord;
+import com.orm.dsl.Unique;
+
+/**
+ * Created by sibelius on 02/12/15.
+ */
+public class IntUniqueModel extends SugarRecord {
+
+    @Unique
+    private int value;
+
+    public IntUniqueModel() { }
+
+    public IntUniqueModel(int value) {
+        this.value = value;
+    }
+}
diff --git a/library/src/test/java/com/orm/models/MultiColumnUniqueModel.java b/library/src/test/java/com/orm/models/MultiColumnUniqueModel.java
new file mode 100644
index 00000000..eea5ec55
--- /dev/null
+++ b/library/src/test/java/com/orm/models/MultiColumnUniqueModel.java
@@ -0,0 +1,22 @@
+package com.orm.models;
+
+import com.orm.SugarRecord;
+import com.orm.dsl.MultiUnique;
+import com.orm.dsl.Unique;
+
+/**
+ * Created by sibelius on 02/12/15.
+ */
+@MultiUnique("a, b")
+public class MultiColumnUniqueModel extends SugarRecord {
+
+    private int a;
+    private int b;
+
+    public MultiColumnUniqueModel() { }
+
+    public MultiColumnUniqueModel(int a, int b) {
+        this.a = a;
+        this.b = b;
+    }
+}
\ No newline at end of file
diff --git a/library/src/test/java/com/orm/models/StringFieldAnnotatedModel.java b/library/src/test/java/com/orm/models/StringFieldAnnotatedModel.java
new file mode 100644
index 00000000..2f732b42
--- /dev/null
+++ b/library/src/test/java/com/orm/models/StringFieldAnnotatedModel.java
@@ -0,0 +1,19 @@
+package com.orm.models;
+
+import com.orm.SugarRecord;
+import com.orm.dsl.Column;
+import com.orm.dsl.Table;
+
+/**
+ * Created by sibelius on 02/12/15.
+ */
+@Table
+public class StringFieldAnnotatedModel extends SugarRecord {
+    public String name;
+
+    public StringFieldAnnotatedModel() { }
+
+    public StringFieldAnnotatedModel(String name) {
+        this.name = name;
+    }
+}
diff --git a/library/src/test/java/com/orm/models/StringFieldExtendedModel.java b/library/src/test/java/com/orm/models/StringFieldExtendedModel.java
new file mode 100644
index 00000000..2aff85d7
--- /dev/null
+++ b/library/src/test/java/com/orm/models/StringFieldExtendedModel.java
@@ -0,0 +1,16 @@
+package com.orm.models;
+
+import com.orm.SugarRecord;
+
+/**
+ * Created by sibelius on 02/12/15.
+ */
+public class StringFieldExtendedModel extends SugarRecord {
+    public String name;
+
+    public StringFieldExtendedModel() { }
+
+    public StringFieldExtendedModel(String name) {
+        this.name = name;
+    }
+}
diff --git a/library/src/test/java/com/orm/models/StringFieldExtendedModelAnnotatedColumn.java b/library/src/test/java/com/orm/models/StringFieldExtendedModelAnnotatedColumn.java
new file mode 100644
index 00000000..b2117926
--- /dev/null
+++ b/library/src/test/java/com/orm/models/StringFieldExtendedModelAnnotatedColumn.java
@@ -0,0 +1,18 @@
+package com.orm.models;
+
+import com.orm.SugarRecord;
+import com.orm.dsl.Column;
+
+/**
+ * Created by sibelius on 02/12/15.
+ */
+public class StringFieldExtendedModelAnnotatedColumn extends SugarRecord {
+    @Column(name="anyName")
+    public String name;
+
+    public StringFieldExtendedModelAnnotatedColumn() { }
+
+    public StringFieldExtendedModelAnnotatedColumn(String name) {
+        this.name = name;
+    }
+}
diff --git a/library/src/test/java/com/orm/query/QueryBuilderTests.java b/library/src/test/java/com/orm/query/QueryBuilderTests.java
index 96e3c79f..d43ca5ee 100644
--- a/library/src/test/java/com/orm/query/QueryBuilderTests.java
+++ b/library/src/test/java/com/orm/query/QueryBuilderTests.java
@@ -7,6 +7,7 @@
 import static junit.framework.Assert.assertEquals;
 
 public class QueryBuilderTests {
+
     @Test(expected=RuntimeException.class)
     public void noArgumentsTest() {
         QueryBuilder.generatePlaceholders(0);
diff --git a/library/src/test/java/com/orm/query/SelectTest.java b/library/src/test/java/com/orm/query/SelectTest.java
index 3ab345ae..39508b77 100644
--- a/library/src/test/java/com/orm/query/SelectTest.java
+++ b/library/src/test/java/com/orm/query/SelectTest.java
@@ -35,6 +35,34 @@ public void testWhere(){
         assertEquals("2", where.getArgs()[1]);
     }
 
+    @Test
+    public void toSqlAllClauses(){
+        String toSql = Select.from(TestRecord.class)
+                .where("foo")
+                .orderBy("doe")
+                .groupBy("john")
+                .limit("5")
+                .offset("10")
+                .toSql();
+        assertEquals("SELECT * FROM TEST_RECORD WHERE foo ORDER BY doe GROUP BY john LIMIT 5 OFFSET 10 ", toSql);
+    }
+
+    @Test
+    public void toSqlNoClauses(){
+        String toSql = Select.from(TestRecord.class)
+                .toSql();
+        assertEquals("SELECT * FROM TEST_RECORD ", toSql);
+    }
+
+    @Test
+    public void toSqlWhereLimitClauses(){
+        String toSql = Select.from(TestRecord.class)
+                .where("foo")
+                .limit("10")
+                .toSql();
+        assertEquals("SELECT * FROM TEST_RECORD WHERE foo LIMIT 10 ", toSql);
+    }
+
 
     @Test
     public void testWhereOr(){
@@ -101,4 +129,4 @@ public void testIsNotNull() {
         assertEquals("(test IS NOT NULL )", where.getWhereCond());
         assertEquals(0, where.getArgs().length);
     }
-}
+}
\ No newline at end of file
diff --git a/library/src/test/java/com/orm/query/TestRecord.java b/library/src/test/java/com/orm/query/TestRecord.java
index 50997205..383a5234 100644
--- a/library/src/test/java/com/orm/query/TestRecord.java
+++ b/library/src/test/java/com/orm/query/TestRecord.java
@@ -1,13 +1,12 @@
 package com.orm.query;
 
-import android.content.Context;
 import com.orm.SugarRecord;
 
 public class TestRecord extends SugarRecord {
 
     private String name;
 
-    public TestRecord(Context context) {
+    public TestRecord() {
         super();
     }
 }
diff --git a/library/src/test/java/com/orm/util/ContextUtilTest.java b/library/src/test/java/com/orm/util/ContextUtilTest.java
new file mode 100644
index 00000000..fc627076
--- /dev/null
+++ b/library/src/test/java/com/orm/util/ContextUtilTest.java
@@ -0,0 +1,59 @@
+package com.orm.util;
+
+import android.content.Context;
+
+import com.orm.query.DummyContext;
+
+import org.junit.Test;
+
+
+import static junit.framework.Assert.assertNotNull;
+import static junit.framework.Assert.assertNull;
+import static com.orm.util.ContextUtil.*;
+
+/**
+ * @author jonatan.salas
+ */
+public class ContextUtilTest {
+
+    public void initContextUtil() {
+        init(new DummyContext());
+    }
+
+    @Test
+    public void testInitContext() {
+        initContextUtil();
+        assertNotNull(getContext());
+    }
+
+    @Test
+    public void testGetAssets() {
+        initContextUtil();
+        assertNull(getAssets());
+    }
+
+    @Test
+    public void testGetPackageManager() {
+        initContextUtil();
+        assertNull(getPackageManager());
+    }
+
+    @Test
+    public void testGetPackageName() {
+        initContextUtil();
+        assertNull(getPackageName());
+    }
+
+    @Test
+    public void testGetPreferences() {
+        initContextUtil();
+        assertNull(getSharedPreferences("lala", Context.MODE_PRIVATE));
+    }
+
+    @Test
+    public void testTerminateContext() {
+        initContextUtil();
+        terminate();
+        assertNull(getContext());
+    }
+}
diff --git a/library/src/test/java/com/orm/util/KeyWordUtilTest.java b/library/src/test/java/com/orm/util/KeyWordUtilTest.java
new file mode 100644
index 00000000..0f132e3a
--- /dev/null
+++ b/library/src/test/java/com/orm/util/KeyWordUtilTest.java
@@ -0,0 +1,29 @@
+package com.orm.util;
+
+import org.junit.Test;
+
+import static junit.framework.Assert.assertEquals;
+
+/**
+ * @author jonatan.salas
+ */
+public class KeyWordUtilTest {
+
+    @Test
+    public void testKeyWord() {
+        assertEquals(true, KeyWordUtil.isKeyword("SELECT"));
+        assertEquals(true, KeyWordUtil.isKeyword("TRANSACTION"));
+        assertEquals(true, KeyWordUtil.isKeyword("MATCH"));
+        assertEquals(true, KeyWordUtil.isKeyword("AS"));
+        assertEquals(true, KeyWordUtil.isKeyword("NOTNULL"));
+        assertEquals(true, KeyWordUtil.isKeyword("NOT"));
+        assertEquals(false, KeyWordUtil.isKeyword("PERSONS"));
+        assertEquals(false, KeyWordUtil.isKeyword("NAME"));
+        assertEquals(false, KeyWordUtil.isKeyword("LOCATION"));
+    }
+
+    @Test
+    public void testNullKeyword() {
+        assertEquals(false, KeyWordUtil.isKeyword(null));
+    }
+}
diff --git a/library/src/test/java/com/orm/util/ManifestHelperTest.java b/library/src/test/java/com/orm/util/ManifestHelperTest.java
new file mode 100644
index 00000000..01431634
--- /dev/null
+++ b/library/src/test/java/com/orm/util/ManifestHelperTest.java
@@ -0,0 +1,49 @@
+package com.orm.util;
+
+import com.orm.query.DummyContext;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+import static com.orm.util.ManifestHelper.*;
+import static com.orm.util.ContextUtil.init;
+
+/**
+ * @author jonatan.salas
+ */
+public class ManifestHelperTest {
+
+    public void initContext() {
+        init(new DummyContext());
+    }
+
+    @Test
+    public void testGetDbName() {
+        initContext();
+        assertEquals(DATABASE_DEFAULT_NAME, getDatabaseName());
+    }
+
+    @Test
+    public void testGetDatabaseName() {
+        initContext();
+        assertEquals(DATABASE_DEFAULT_NAME, getDatabaseName());
+    }
+
+    @Test
+    public void testGetDatabaseVersion() {
+        initContext();
+        assertEquals(1, getDatabaseVersion());
+    }
+
+    @Test
+    public void testGetDomainPackageName() {
+        initContext();
+        assertNotNull(getDomainPackageName());
+    }
+
+    @Test
+    public void testGetDebugEnabled() {
+        initContext();
+        assertEquals(false, getDebugEnabled());
+    }
+}
diff --git a/library/src/test/java/com/orm/util/MigrationFileParserTest.java b/library/src/test/java/com/orm/util/MigrationFileParserTest.java
new file mode 100644
index 00000000..72b9f9ca
--- /dev/null
+++ b/library/src/test/java/com/orm/util/MigrationFileParserTest.java
@@ -0,0 +1,44 @@
+package com.orm.util;
+
+import org.junit.Test;
+
+import java.lang.String;
+
+import static junit.framework.Assert.assertEquals;
+
+public class MigrationFileParserTest {
+
+    @Test
+    public void testSingleLineStatement() {
+        MigrationFileParser singleLineComment = new MigrationFileParser("insert into table--comment");
+
+        String statements[] = singleLineComment.getStatements();
+        assertEquals("Testing single line statement size",1,statements.length);
+        assertEquals("Testing single line statement content","insert into table",statements[0]);
+
+        singleLineComment = new MigrationFileParser("insert into table--comment\n");
+
+        singleLineComment.getStatements();
+        assertEquals("Testing single line statement size",1,statements.length);
+        assertEquals("Testing single line statement content","insert into table",statements[0]);
+    }
+
+    @Test
+    public void testMultiLineComment() {
+        MigrationFileParser multiLineComment = new MigrationFileParser("insert into table /**comment \n new line 2 \n new line 3 */hello");
+
+        String statements[] = multiLineComment.getStatements();
+        assertEquals("Testing multiline statement size",1,statements.length);
+        assertEquals("Testing multiline comment","insert into table hello",statements[0]);
+    }
+
+    @Test
+    public void testMixedComment() {
+        MigrationFileParser mixedComment = new MigrationFileParser("insert into/*multiline\n **comment*/--comment");
+
+        String statements[] = mixedComment.getStatements();
+
+        assertEquals("Testing mixed comment statement size",1,statements.length);
+        assertEquals("Testing mixed comment statments", "insert into", statements[0]);
+    }
+}
diff --git a/sugar.iml b/sugar.iml
deleted file mode 100644
index e19b5594..00000000
--- a/sugar.iml
+++ /dev/null
@@ -1,19 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.id="sugar" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
-  <component name="FacetManager">
-    <facet type="java-gradle" name="Java-Gradle">
-      <configuration>
-        <option name="BUILD_FOLDER_PATH" value="$MODULE_DIR$/build" />
-        <option name="BUILDABLE" value="false" />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
-    </content>
-    <orderEntry type="jdk" jdkName="1.7" jdkType="JavaSDK" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
\ No newline at end of file
