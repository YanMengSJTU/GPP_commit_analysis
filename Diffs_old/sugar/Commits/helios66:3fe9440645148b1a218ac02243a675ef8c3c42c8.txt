diff --git a/.gitignore b/.gitignore
index b2d2fc5b..2adde673 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,6 +1,8 @@
 library/bin
+library/build
 library/gen
 library/.project
 library/.classpath
+library/library.iml
 *.class
 .DS_Store
diff --git a/README.md b/README.md
index e6916fb1..2cea7303 100644
--- a/README.md
+++ b/README.md
@@ -1,34 +1,91 @@
-Please follow the documentation at
-http://satyan.github.io/sugar
+# Sugar ORM
 
-The example application is provided in the "example" folder in the source.
+Insanely easy way to work with Android databases.
 
+Official documentation can be found [here](http://satyan.github.io/sugar). The example application is provided in the **example** folder in the source.
 
-# Getting Started:
+## Features
 
-Sugar is now available as a library project also. Add it to your project and utilize the latest changes.
-The project is available in the folder "library"
-http://developer.android.com/tools/projects/index.html#LibraryProjects
+Sugar ORM was built in contrast to other ORM's to have:
 
-# New in version 1.2
+- A simple, concise, and clean integration process with minimal configuration.
+- Automatic table and column naming through reflection.
+- Support for migrations between different schema versions.
 
-1. package restriction for domain classes.
-2. metadata caching
-3. QueryBuilder v1
-4. Database Migrations
-5. Provision for Raw queries
-6. Better and more organized api guide and usage instructions.
+## Installing
 
-# What's new in 1.1:
+There are four ways to install Sugar:
 
-1. Static api doesn't take context anymore. Hence
+#### As a Gradle dependency
 
-        Book.findById(context, Book.class, 1);
+This is the preferred way. Simply add:
 
-        becomes
+```groovy
+compile 'com.github.satyan:sugar:1.3'
+```
 
-        Book.findById(Book.class, 1);
+to your project dependencies and run `gradle build` or `gradle assemble`.
 
+#### As a Maven dependency
 
-2. Some cleanup in the code.
+Declare the dependency in Maven:
 
+```xml
+<dependency>
+    <groupId>com.github.satyan</groupId>
+    <artifactId>sugar</artifactId>
+    <version>1.3</version>
+</dependency>
+```
+
+#### As a library project
+
+Download the source code and import it as a library project in Eclipse. The project is available in the folder **library**. For more information on how to do this, read [here](http://developer.android.com/tools/projects/index.html#LibraryProjects).
+
+#### Use a jar
+
+Visit the [releases](https://github.com/satyan/sugar/releases) page to download jars directly. You can drop them into your `libs` folder and configure the Java build path to include the library. See this [tutorial](http://www.vogella.com/tutorials/AndroidLibraryProjects/article.html) for an excellent guide on how to do this.
+
+===================
+
+After installing, check out how to set up your first database and models [here](http://satyan.github.io/sugar/getting-started.html).
+
+## Contributing
+
+Please fork this repository and contribute back using [pull requests](https://github.com/satyan/sugar/pulls). Features can be requested using [issues](https://github.com/satyan/sugar/issues). All code, comments, and critiques are greatly appreciated.
+
+## Changelog
+
+#### v1.3 [[jar](https://github.com/satyan/sugar/releases/download/v1.3/sugar-1.3.jar)]
+
+- Transaction Support
+- Bulk Insert of records 
+- Encrypted datastore (branch : sugar-cipher using sqlcipher)
+- Removed Constructor with context parameter. Needs default constructor now.
+- Enhancements to QueryBuilder
+- Bug fixes and other improvements.
+
+#### v1.2 [[jar](https://github.com/satyan/sugar/releases/download/v1.2/sugar-1.2.jar)]
+
+- package restriction for domain classes.
+- metadata caching
+- QueryBuilder v1
+- Database Migrations
+- Provision for Raw queries
+- Better and more organized api guide and usage instructions.
+
+#### v1.1 [[jar](https://github.com/satyan/sugar/releases/download/v1.1/sugar-1.1.jar)]
+
+- Static api doesn't take context anymore. Hence
+
+```java
+Book.findById(context, Book.class, 1);
+```
+
+becomes
+
+```java
+Book.findById(Book.class, 1);
+```
+
+- Some cleanup in the code.
diff --git a/dist/sugar-1.0.jar b/dist/sugar-1.0.jar
deleted file mode 100644
index 2bf1abd3..00000000
Binary files a/dist/sugar-1.0.jar and /dev/null differ
diff --git a/dist/sugar-1.1.jar b/dist/sugar-1.1.jar
deleted file mode 100644
index 96a6b77e..00000000
Binary files a/dist/sugar-1.1.jar and /dev/null differ
diff --git a/dist/sugar-1.2.jar b/dist/sugar-1.2.jar
deleted file mode 100644
index 2e6f0290..00000000
Binary files a/dist/sugar-1.2.jar and /dev/null differ
diff --git a/dist/sugar-1.3_beta.jar b/dist/sugar-1.3_beta.jar
deleted file mode 100644
index b67161da..00000000
Binary files a/dist/sugar-1.3_beta.jar and /dev/null differ
diff --git a/example/src/com/example/AddNoteActivity.java b/example/src/com/example/AddNoteActivity.java
index 06a6c62f..aba5e236 100755
--- a/example/src/com/example/AddNoteActivity.java
+++ b/example/src/com/example/AddNoteActivity.java
@@ -9,6 +9,8 @@
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
+import static com.orm.SugarRecord.save;
+
 
 public class AddNoteActivity extends Activity {
     public void onCreate(Bundle savedInstanceState) {
@@ -39,8 +41,8 @@ public void onCreate(Bundle savedInstanceState) {
         save.setOnClickListener(new View.OnClickListener() {
             public void onClick(View view) {
                 Tag tag = new Tag(tagBox.getText().toString());
-                tag.save();
-                new Note( 10, titleBox.getText().toString(), descBox.getText().toString(),tag).save();
+                save(tag);
+                save(new Note(10 + (int) (10 * Math.random()), titleBox.getText().toString(), descBox.getText().toString(), tag));
                 Intent intent = new Intent(AddNoteActivity.this, NoteListActivity.class);
                 startActivity(intent);
             }
diff --git a/example/src/com/example/NewNote.java b/example/src/com/example/NewNote.java
new file mode 100644
index 00000000..a80e2d4a
--- /dev/null
+++ b/example/src/com/example/NewNote.java
@@ -0,0 +1,11 @@
+package com.example;
+
+import com.orm.dsl.Table;
+
+@Table(name = "new_note")
+public class NewNote {
+
+    public long id;
+    public String name;
+
+}
diff --git a/example/src/com/example/Note.java b/example/src/com/example/Note.java
index 468b074c..b83f730f 100755
--- a/example/src/com/example/Note.java
+++ b/example/src/com/example/Note.java
@@ -1,10 +1,16 @@
 package com.example;
 
-import android.content.Context;
-import com.orm.SugarRecord;
+import com.orm.dsl.Column;
+import com.orm.dsl.Table;
 
-public class Note extends SugarRecord<Note>{
+@Table(name = "Note")
+public class Note {
+
+    private long id;
+
+    @Column(name = "noteId", unique = true, notNull = true)
     private int noteId;
+
     private String title;
     private String description;
    private String name;
@@ -39,25 +45,25 @@ public String getTitle() {
         return title;
     }
 
-    public String getDescription() {
-        return description;
+    public void setTitle(String title) {
+        this.title = title;
     }
 
-    public Tag getTag() {
-        return tag;
+    public String getDescription() {
+        return description;
     }
 
     public void setDescription(String description){
         this.description = description;
     }
 
-    public void setTitle(String title) {
-        this.title = title;
+    public Tag getTag() {
+        return tag;
     }
 
     @Override
     public String toString() {
-        return  title + "id: " + id + " - " + tag + " " + tag.getId();
+        return title + "id: " + noteId;
 
     }
 }
diff --git a/example/src/com/example/NoteListActivity.java b/example/src/com/example/NoteListActivity.java
index a5d0399b..09877f2d 100755
--- a/example/src/com/example/NoteListActivity.java
+++ b/example/src/com/example/NoteListActivity.java
@@ -6,7 +6,7 @@
 import android.util.Log;
 import android.view.View;
 import android.widget.ArrayAdapter;
-
+import com.orm.SugarRecord;
 import com.orm.query.Condition;
 import com.orm.query.Select;
 
@@ -19,8 +19,9 @@ public void onCreate(Bundle savedInstanceState) {
         setContentView(R.layout.notelist);
 
         List<Note> notes = Select.from(Note.class).orderBy("title").list();//Note.listAll(Note.class);
+        List<NewNote> list = SugarRecord.listAll(NewNote.class);
 
-        setListAdapter(new ArrayAdapter<Note>(this,android.R.layout.simple_list_item_1, notes));
+        setListAdapter(new ArrayAdapter<Note>(this, android.R.layout.simple_list_item_1, notes));
 
         findViewById(R.id.Button01).setOnClickListener(new View.OnClickListener() {
             public void onClick(View view) {
diff --git a/example/src/com/example/NoteRelation.java b/example/src/com/example/NoteRelation.java
index 1a971d7d..a64d055a 100644
--- a/example/src/com/example/NoteRelation.java
+++ b/example/src/com/example/NoteRelation.java
@@ -1,9 +1,10 @@
 package com.example;
 
 import android.content.Context;
-import com.orm.SugarRecord;
+import com.orm.dsl.Table;
 
-public class NoteRelation  extends SugarRecord<Note> {
+@Table(name = "note_relation")
+public class NoteRelation {
     String name;
     int noteId;
 
diff --git a/example/src/com/example/SugarActivity.java b/example/src/com/example/SugarActivity.java
index 22dd9c1c..b7130f86 100755
--- a/example/src/com/example/SugarActivity.java
+++ b/example/src/com/example/SugarActivity.java
@@ -2,11 +2,10 @@
 
 import android.app.Activity;
 import android.content.Intent;
-import android.database.sqlite.SQLiteDatabase;
 import android.os.Bundle;
-import android.util.Log;
-import com.orm.Database;
-import com.orm.SugarApp;
+import com.orm.SugarRecord;
+
+import static com.orm.SugarRecord.save;
 
 public class SugarActivity extends Activity
 {
@@ -16,9 +15,10 @@ public void onCreate(Bundle savedInstanceState)
     {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.main);
-         Note.deleteAll(Note.class);
-        TextNote.deleteAll(TextNote.class);
-        Tag.deleteAll(Tag.class);
+        SugarRecord.deleteAll(Note.class);
+        SugarRecord.deleteAll(TextNote.class);
+        SugarRecord.deleteAll(Tag.class);
+        SugarRecord.deleteAll(NewNote.class);
         initDb();
         Intent intent = new Intent(this, NoteListActivity.class);
         startActivity(intent);
@@ -28,34 +28,36 @@ private void initDb() {
 
         Tag t1 = new Tag("tag1");
         Tag t2 = new Tag("tag2");
-        t1.save();
-        t2.save();
+         save(t1);
+         save(t2);
 
         Note n1 = new Note( 10, "note1", "description1", t1);
-        Note n2 = new Note(10, "note12", "description2", t1);
-        Note n3 = new Note( 10, "note13", "description3", t2);
-        Note n4 = new Note( 10, "note4", "description4", t2);
+        Note n2 = new Note(11, "note12", "description2", t1);
+        Note n3 = new Note( 12, "note13", "description3", t2);
+        Note n4 = new Note( 13, "note4", "description4", t2);
 
          TextNote textNote = new TextNote();
          textNote.desc = "Test";
 
-         textNote.save();
-        n1.save();
-        n2.save();
-        n3.save();
-        n4.save();
+         save(textNote);
+         save(n1);
+         save(n2);
+         save(n3);
+         save(n4);
 
          n1.setDescription("matrix");
          n1.setTitle("atrix");
-         n1.save();
+         save(n1);
          n2.setDescription("matrix");
          n2.setTitle("satrix");
-         n2.save();
+         save(n2);
          n3.setDescription("matrix");
          n3.setTitle("batrix");
-         n3.save();
-         
-        
+         save(n3);
 
-    }
+         NewNote newNote = new NewNote();
+         newNote.name = "name";
+         save(newNote);
+
+     }
 }
diff --git a/example/src/com/example/Tag.java b/example/src/com/example/Tag.java
index 24d8c145..6600c14a 100755
--- a/example/src/com/example/Tag.java
+++ b/example/src/com/example/Tag.java
@@ -1,9 +1,9 @@
 package com.example;
 
-import android.content.Context;
-import com.orm.SugarRecord;
+import com.orm.dsl.Table;
 
-public class Tag extends SugarRecord<Tag>{
+@Table(name = "tag")
+public class Tag {
     private String name;
 
     public Tag(String name) {
diff --git a/example/src/com/example/TextNote.java b/example/src/com/example/TextNote.java
index c4025774..91b7a33c 100644
--- a/example/src/com/example/TextNote.java
+++ b/example/src/com/example/TextNote.java
@@ -1,5 +1,8 @@
 package com.example;
 
+import com.orm.dsl.Table;
+
+@Table(name = "text_note")
 public class TextNote extends Note {
 
     public String desc;
diff --git a/library/AndroidManifest.xml b/library/AndroidManifest.xml
index 65bb4873..a48c294b 100644
--- a/library/AndroidManifest.xml
+++ b/library/AndroidManifest.xml
@@ -3,6 +3,6 @@
           package="com.orm.dsl"
           android:versionCode="1"
           android:versionName="1.0">
-    <uses-sdk android:minSdkVersion="4" />
+    <uses-sdk android:minSdkVersion="8" />
 
 </manifest>
\ No newline at end of file
diff --git a/library/build.gradle b/library/build.gradle
new file mode 100644
index 00000000..43157b3c
--- /dev/null
+++ b/library/build.gradle
@@ -0,0 +1,29 @@
+buildscript {
+        repositories {
+            mavenCentral()
+        }
+
+        dependencies {
+            classpath 'com.android.tools.build:gradle:0.9.+'
+        }
+    }
+
+    apply plugin: 'android-library'
+
+    dependencies {
+        compile 'com.android.support:support-v4:19.0.1'
+    }
+
+    android {
+        compileSdkVersion 19
+        buildToolsVersion "19.0.3"
+        sourceSets {
+            main {
+                manifest.srcFile 'AndroidManifest.xml'
+                java.srcDirs = ['src']
+                resources.srcDirs = ['src']
+                res.srcDirs = ['res']
+                assets.srcDirs = ['assets']
+            }
+        }
+    }
diff --git a/library/src/com/orm/Database.java b/library/src/com/orm/Database.java
deleted file mode 100644
index 0896ee1f..00000000
--- a/library/src/com/orm/Database.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.orm;
-
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-
-
-public class Database {
-    private SugarDb sugarDb;
-    private SQLiteDatabase sqLiteDatabase;
-
-    public Database(Context context){
-        this.sugarDb  = new SugarDb(context);
-    }
-
-
-    public synchronized SQLiteDatabase getDB() {
-        if (this.sqLiteDatabase == null) {
-            this.sqLiteDatabase = this.sugarDb.getWritableDatabase();
-        }
-
-        return this.sqLiteDatabase;
-    }
-
-}
diff --git a/library/src/com/orm/SchemaGenerator.java b/library/src/com/orm/SchemaGenerator.java
new file mode 100644
index 00000000..a7f25b51
--- /dev/null
+++ b/library/src/com/orm/SchemaGenerator.java
@@ -0,0 +1,169 @@
+package com.orm;
+
+import android.content.Context;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+import android.util.Log;
+import com.orm.dsl.Column;
+import com.orm.dsl.NotNull;
+import com.orm.dsl.Unique;
+import com.orm.util.NamingHelper;
+import com.orm.util.NumberComparator;
+import com.orm.util.QueryBuilder;
+import com.orm.util.ReflectionUtil;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.lang.reflect.Field;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import static com.orm.util.ReflectionUtil.getDomainClasses;
+
+public class SchemaGenerator {
+
+    private Context context;
+
+    public SchemaGenerator(Context context) {
+        this.context = context;
+    }
+
+    public void createDatabase(SQLiteDatabase sqLiteDatabase) {
+        List<Class> domainClasses = getDomainClasses(context);
+        for (Class domain : domainClasses) {
+            createTable(domain, sqLiteDatabase);
+        }
+    }
+
+    public void doUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
+        List<Class> domainClasses = getDomainClasses(context);
+        for (Class domain : domainClasses) {
+            try {  // we try to do a select, if fails then (?) there isn't the table
+                sqLiteDatabase.query(NamingHelper.toSQLName(domain), null, null, null, null, null, null);
+            } catch (SQLiteException e) {
+                Log.i("Sugar", String.format("Creating table on update (error was '%s')",
+                        e.getMessage()));
+                createTable(domain, sqLiteDatabase);
+            }
+        }
+        executeSugarUpgrade(sqLiteDatabase, oldVersion, newVersion);
+    }
+
+    public void deleteTables(SQLiteDatabase sqLiteDatabase) {
+        List<Class> tables = getDomainClasses(context);
+        for (Class table : tables) {
+            sqLiteDatabase.execSQL("DROP TABLE IF EXISTS " + NamingHelper.toSQLName(table));
+        }
+    }
+
+    private boolean executeSugarUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        boolean isSuccess = false;
+
+        try {
+            List<String> files = Arrays.asList(this.context.getAssets().list("sugar_upgrades"));
+            Collections.sort(files, new NumberComparator());
+            for (String file : files) {
+                Log.i("Sugar", "filename : " + file);
+
+                try {
+                    int version = Integer.valueOf(file.replace(".sql", ""));
+
+                    if ((version > oldVersion) && (version <= newVersion)) {
+                        executeScript(db, file);
+                        isSuccess = true;
+                    }
+                } catch (NumberFormatException e) {
+                    Log.i("Sugar", "not a sugar script. ignored." + file);
+                }
+
+            }
+        } catch (IOException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+
+        return isSuccess;
+    }
+
+    private void executeScript(SQLiteDatabase db, String file) {
+        try {
+            InputStream is = this.context.getAssets().open("sugar_upgrades/" + file);
+            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
+            String line;
+            while ((line = reader.readLine()) != null) {
+                Log.i("Sugar script", line);
+                db.execSQL(line.toString());
+            }
+        } catch (IOException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+
+        Log.i("Sugar", "Script executed");
+    }
+
+    private void createTable(Class<?> table, SQLiteDatabase sqLiteDatabase) {
+        Log.i("Sugar", "Create table");
+        List<Field> fields = ReflectionUtil.getTableFields(table);
+        String tableName = NamingHelper.toSQLName(table);
+        StringBuilder sb = new StringBuilder("CREATE TABLE ");
+        sb.append(tableName).append(" ( ID INTEGER PRIMARY KEY AUTOINCREMENT ");
+
+        for (Field column : fields) {
+            String columnName = NamingHelper.toSQLName(column);
+            String columnType = QueryBuilder.getColumnType(column.getType());
+
+            if (columnType != null) {
+                if (columnName.equalsIgnoreCase("Id")) {
+                    continue;
+                }
+
+                if (column.isAnnotationPresent(Column.class)) {
+                    Column columnAnnotation = column.getAnnotation(Column.class);
+                    columnName = columnAnnotation.name();
+
+                    sb.append(", ").append(columnName).append(" ").append(columnType);
+
+                    if (columnAnnotation.notNull()) {
+                        if (columnType.endsWith(" NULL")) {
+                            sb.delete(sb.length() - 5, sb.length());
+                        }
+                        sb.append(" NOT NULL");
+                    }
+
+                    if (columnAnnotation.unique()) {
+                        sb.append(" UNIQUE");
+                    }
+
+                } else {
+                    sb.append(", ").append(columnName).append(" ").append(columnType);
+
+                    if (column.isAnnotationPresent(NotNull.class)) {
+                        if (columnType.endsWith(" NULL")) {
+                            sb.delete(sb.length() - 5, sb.length());
+                        }
+                        sb.append(" NOT NULL");
+                    }
+
+                    if (column.isAnnotationPresent(Unique.class)) {
+                        sb.append(" UNIQUE");
+                    }
+                }
+            }
+        }
+
+        sb.append(" ) ");
+        Log.i("Sugar", "Creating table " + tableName);
+
+        if (!"".equals(sb.toString())) {
+            try {
+                sqLiteDatabase.execSQL(sb.toString());
+            } catch (SQLException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+}
diff --git a/library/src/com/orm/StringUtil.java b/library/src/com/orm/StringUtil.java
deleted file mode 100644
index 40fabf48..00000000
--- a/library/src/com/orm/StringUtil.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package com.orm;
-
-public class StringUtil {
-    public static String toSQLName(String javaNotation) {
-            if(javaNotation.equalsIgnoreCase("_id"))
-                    return "_id";
-
-            StringBuilder sb = new StringBuilder();
-            char[] buf = javaNotation.toCharArray();
-
-            for (int i = 0; i < buf.length; i++) {
-                    char prevChar = (i > 0) ? buf[i - 1] : 0;
-                    char c = buf[i];
-                    char nextChar = (i < buf.length - 1) ? buf[i + 1] : 0;
-                    boolean isFirstChar = (i == 0);
-
-                    if (isFirstChar || Character.isLowerCase(c) || Character.isDigit(c)) {
-                            sb.append(Character.toUpperCase(c));
-                    } else if (Character.isUpperCase(c)) {
-                            if (Character.isLetterOrDigit(prevChar)) {
-                                    if (Character.isLowerCase(prevChar)) {
-                                            sb.append('_').append(Character.toUpperCase(c));
-                                    } else if (nextChar > 0 && Character.isLowerCase(nextChar)) {
-                                            sb.append('_').append(Character.toUpperCase(c));
-                                    } else {
-                                            sb.append(c);
-                                    }
-                            }
-                            else {
-                                    sb.append(c);
-                            }
-                    }
-            }
-
-            return sb.toString();
-    }
-
-}
diff --git a/library/src/com/orm/SugarApp.java b/library/src/com/orm/SugarApp.java
index d15c411f..18142acb 100644
--- a/library/src/com/orm/SugarApp.java
+++ b/library/src/com/orm/SugarApp.java
@@ -1,28 +1,35 @@
 package com.orm;
 
-public class SugarApp extends android.app.Application{
+public class SugarApp extends android.app.Application {
 
-    private Database database;
     private static SugarApp sugarContext;
+    private SugarDb sugarDb;
 
-    public void onCreate(){
+    public static SugarApp getSugarContext() {
+        return sugarContext;
+    }
+
+    public void onCreate() {
         super.onCreate();
         SugarApp.sugarContext = this;
-        this.database = new Database(this);
+        this.sugarDb = new SugarDb(this);
     }
 
-    public void onTerminate(){
-        if (this.database != null) {
-            this.database.getDB().close();
+    /*
+     * Per issue #106 on Github, this method won't be called in
+     * any real Android device. This method is used purely in
+     * emulated process environments such as an emulator or
+     * Robolectric Android mock.
+     */
+    public void onTerminate() {
+        if (this.sugarDb != null) {
+            this.sugarDb.getDB().close();
         }
         super.onTerminate();
     }
 
-    public static SugarApp getSugarContext(){
-        return sugarContext;
+    protected SugarDb getSugarDb() {
+        return sugarDb;
     }
 
-    protected Database getDatabase() {
-        return database;
-    }
 }
diff --git a/library/src/com/orm/SugarDb.java b/library/src/com/orm/SugarDb.java
index 0f859afc..21895f6b 100644
--- a/library/src/com/orm/SugarDb.java
+++ b/library/src/com/orm/SugarDb.java
@@ -1,212 +1,41 @@
 package com.orm;
 
 import android.content.Context;
-import android.content.pm.PackageManager;
 import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteException;
 import android.database.sqlite.SQLiteOpenHelper;
-import android.util.Log;
-import dalvik.system.DexFile;
+import com.orm.util.SugarConfig;
+import com.orm.util.SugarCursorFactory;
 
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Modifier;
-import java.util.*;
-
-import static com.orm.SugarConfig.getDatabaseVersion;
-import static com.orm.SugarConfig.getDebugEnabled;
+import static com.orm.util.SugarConfig.getDatabaseVersion;
+import static com.orm.util.SugarConfig.getDebugEnabled;
 
 public class SugarDb extends SQLiteOpenHelper {
-    private Context context;
-
-    public SugarDb(Context context) {
-        super(context, SugarConfig.getDatabaseName(context), new SugarCursorFactory(getDebugEnabled(context)), getDatabaseVersion(context));
-        this.context = context;
-
-    }
-
-    private <T extends SugarRecord<?>> List<T> getDomainClasses(Context context) {
-        List<T> domainClasses = new ArrayList<T>();
-        try {
-            Enumeration<?> allClasses = getAllClasses(context);
 
-            while (allClasses.hasMoreElements()) {
-                String className = (String) allClasses.nextElement();
+    private final SchemaGenerator schemaGenerator;
+    private SQLiteDatabase sqLiteDatabase;
 
-                if (className.startsWith(SugarConfig.getDomainPackageName(context))) {
-                    T domainClass = getDomainClass(className, context);
-                    if (domainClass != null) domainClasses.add(domainClass);
-                }
-            }
-
-        } catch (IOException e) {
-            Log.e("Sugar", e.getMessage());
-        } catch (PackageManager.NameNotFoundException e) {
-            Log.e("Sugar", e.getMessage());
-        }
-
-        return domainClasses;
-    }
-
-    @SuppressWarnings("unchecked")
-    private <T extends SugarRecord<?>> T getDomainClass(String className, Context context) {
-        Log.i("Sugar", "domain class");
-        Class<?> discoveredClass = null;
-        try {
-            discoveredClass = Class.forName(className, true, context.getClass().getClassLoader());
-        } catch (ClassNotFoundException e) {
-            Log.e("Sugar", e.getMessage());
-        }
-
-        if ((discoveredClass == null) ||
-                (!SugarRecord.class.isAssignableFrom(discoveredClass)) ||
-                Modifier.isAbstract(discoveredClass.getModifiers())) {
-            return null;
-        } else {
-            try {
-                return (T) discoveredClass.getDeclaredConstructor().newInstance();
-            } catch (InstantiationException e) {
-                Log.e("Sugar", e.getMessage());
-            } catch (IllegalAccessException e) {
-                Log.e("Sugar", e.getMessage());
-            } catch (NoSuchMethodException e) {
-                Log.e("Sugar", e.getMessage());
-            } catch (InvocationTargetException e) {
-                Log.e("Sugar", e.getMessage());
-            }
-        }
-
-        return null;
-
-    }
-
-    private Enumeration<?> getAllClasses(Context context) throws PackageManager.NameNotFoundException, IOException {
-        String path = getSourcePath(context);
-        DexFile dexfile = new DexFile(path);
-        return dexfile.entries();
-    }
-
-    private String getSourcePath(Context context) throws PackageManager.NameNotFoundException {
-        return context.getPackageManager().getApplicationInfo(context.getPackageName(), 0).sourceDir;
+    public SugarDb(Context context) {
+        super(context, SugarConfig.getDatabaseName(context),
+                new SugarCursorFactory(getDebugEnabled(context)), getDatabaseVersion(context));
+        schemaGenerator = new SchemaGenerator(context);
     }
 
     @Override
     public void onCreate(SQLiteDatabase sqLiteDatabase) {
-        Log.i("Sugar", "on create");
-        createDatabase(sqLiteDatabase);
-    }
-
-    private <T extends SugarRecord<?>> void createDatabase(SQLiteDatabase sqLiteDatabase) {
-        List<T> domainClasses = getDomainClasses(context);
-        for (T domain : domainClasses) {
-            createTable(domain, sqLiteDatabase);
-        }
-    }
-
-    private <T extends SugarRecord<?>> void createTable(T table, SQLiteDatabase sqLiteDatabase) {
-        Log.i("Sugar", "create table");
-        List<Field> fields = table.getTableFields();
-        StringBuilder sb = new StringBuilder("CREATE TABLE ").append(table.getSqlName()).append(
-                " ( ID INTEGER PRIMARY KEY AUTOINCREMENT ");
-
-        for (Field column : fields) {
-            String columnName = StringUtil.toSQLName(column.getName());
-            String columnType = QueryBuilder.getColumnType(column.getType());
-
-            if (columnType != null) {
-
-                if (columnName.equalsIgnoreCase("Id")) {
-                    continue;
-                }
-                sb.append(", ").append(columnName).append(" ").append(columnType);
-            }
-        }
-        sb.append(" ) ");
-
-        Log.i("Sugar", "creating table " + table.getSqlName());
-
-        if (!"".equals(sb.toString()))
-            sqLiteDatabase.execSQL(sb.toString());
+        schemaGenerator.createDatabase(sqLiteDatabase);
     }
 
     @Override
     public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
-        Log.i("Sugar", "upgrading sugar");
-        // check if some tables are to be created
-        doUpgrade(sqLiteDatabase);
-
-        if (!executeSugarUpgrade(sqLiteDatabase, oldVersion, newVersion)) {
-            deleteTables(sqLiteDatabase);
-            onCreate(sqLiteDatabase);
-        }
+        schemaGenerator.doUpgrade(sqLiteDatabase, oldVersion, newVersion);
     }
 
-    /**
-     * Create the tables that do not exist.
-     */
-    private <T extends SugarRecord<?>> void doUpgrade(SQLiteDatabase sqLiteDatabase) {
-        List<T> domainClasses = getDomainClasses(context);
-        for (T domain : domainClasses) {
-            try {// we try to do a select, if fails then (?) there isn't the table
-                sqLiteDatabase.query(domain.tableName, null, null, null, null, null, null);
-            } catch (SQLiteException e) {
-                Log.i("Sugar", String.format("creating table on update (error was '%s')", e.getMessage()));
-                createTable(domain, sqLiteDatabase);
-            }
+    public synchronized SQLiteDatabase getDB() {
+        if (this.sqLiteDatabase == null) {
+            this.sqLiteDatabase = getWritableDatabase();
         }
-    }
 
-    private <T extends SugarRecord<?>> void deleteTables(SQLiteDatabase sqLiteDatabase) {
-        List<T> tables = getDomainClasses(this.context);
-        for (T table : tables) {
-            sqLiteDatabase.execSQL("DROP TABLE IF EXISTS " + table.getSqlName());
-        }
+        return this.sqLiteDatabase;
     }
 
-    private boolean executeSugarUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-
-        boolean isSuccess = false;
-        try {
-            List<String> files = Arrays.asList(this.context.getAssets().list("sugar_upgrades"));
-            Collections.sort(files, new NumberComparator());
-
-            for (String file : files){
-                Log.i("Sugar", "filename : " + file);
-                try {
-                    int version = Integer.valueOf(file.replace(".sql", ""));
-
-                    if ((version > oldVersion) && (version <= newVersion)) {
-                        executeScript(db, file);
-                        isSuccess = true;
-                    }
-                } catch (NumberFormatException e) {
-                    Log.i("Sugar", "not a sugar script. ignored." + file);
-                }
-            }
-        } catch (IOException e) {
-            Log.e("Sugar", e.getMessage());
-        }
-
-        return isSuccess;
-    }
-
-    private void executeScript(SQLiteDatabase db, String file) {
-        try {
-            InputStream is = this.context.getAssets().open("sugar_upgrades/" + file);
-            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
-            String line;
-            while ((line = reader.readLine()) != null) {
-                Log.i("Sugar script", line);
-                db.execSQL(line.toString());
-            }
-        } catch (IOException e) {
-            Log.e("Sugar", e.getMessage());
-        }
-
-        Log.i("Sugar", "script executed");
-    }
 }
diff --git a/library/src/com/orm/SugarRecord.java b/library/src/com/orm/SugarRecord.java
index c7b587a5..a6a05f51 100644
--- a/library/src/com/orm/SugarRecord.java
+++ b/library/src/com/orm/SugarRecord.java
@@ -1,182 +1,102 @@
 package com.orm;
 
 import android.content.ContentValues;
-import android.content.Context;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteException;
 import android.database.sqlite.SQLiteStatement;
 import android.text.TextUtils;
 import android.util.Log;
-import com.orm.dsl.Ignore;
+import com.orm.dsl.Table;
+import com.orm.util.NamingHelper;
+import com.orm.util.ReflectionUtil;
 
-import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.sql.Timestamp;
 import java.util.*;
 
 import static com.orm.SugarApp.getSugarContext;
 
-public class SugarRecord<T>{
-
-    @Ignore
-    String tableName = getSqlName();
+public class SugarRecord {
 
     protected Long id = null;
 
-    public void delete() {
-        SQLiteDatabase db = getSugarContext().getDatabase().getDB();
-        db.delete(this.tableName, "Id=?", new String[]{getId().toString()});
-    }
-
-    public static <T extends SugarRecord<?>> void deleteAll(Class<T> type) {
-        Database db = getSugarContext().getDatabase();
+    public static <T> void deleteAll(Class<T> type) {
+        SugarDb db = getSugarContext().getSugarDb();
         SQLiteDatabase sqLiteDatabase = db.getDB();
-        sqLiteDatabase.delete(getTableName(type), null, null);
+        sqLiteDatabase.delete(NamingHelper.toSQLName(type), null, null);
     }
 
-    public static <T extends SugarRecord<?>> void deleteAll(Class<T> type, String whereClause, String... whereArgs ) {
-        Database db = getSugarContext().getDatabase();
+    public static <T> void deleteAll(Class<T> type, String whereClause, String... whereArgs) {
+        SugarDb db = getSugarContext().getSugarDb();
         SQLiteDatabase sqLiteDatabase = db.getDB();
-        sqLiteDatabase.delete(getTableName(type), whereClause, whereArgs);
-    }
-
-    public void save() {
-        save(getSugarContext().getDatabase().getDB());
+        sqLiteDatabase.delete(NamingHelper.toSQLName(type), whereClause, whereArgs);
     }
 
     @SuppressWarnings("deprecation")
-    public static <T extends SugarRecord<?>> void saveInTx(T... objects ) {
+    public static <T> void saveInTx(T... objects) {
         saveInTx(Arrays.asList(objects));
     }
 
     @SuppressWarnings("deprecation")
-    public static <T extends SugarRecord<?>> void saveInTx(Collection<T> objects ) {
-        SQLiteDatabase sqLiteDatabase = getSugarContext().getDatabase().getDB();
-
-        try{
+    public static <T> void saveInTx(Collection<T> objects) {
+        SQLiteDatabase sqLiteDatabase = getSugarContext().getSugarDb().getDB();
+        try {
             sqLiteDatabase.beginTransaction();
             sqLiteDatabase.setLockingEnabled(false);
-            for(T object: objects){
-                object.save(sqLiteDatabase);
+            for (T object: objects) {
+                SugarRecord.save(object);
             }
             sqLiteDatabase.setTransactionSuccessful();
-        }catch (Exception e){
+        } catch (Exception e) {
             Log.i("Sugar", "Error in saving in transaction " + e.getMessage());
-        }finally {
+        } finally {
             sqLiteDatabase.endTransaction();
             sqLiteDatabase.setLockingEnabled(true);
         }
-
-    }
-
-    void save(SQLiteDatabase db) {
-
-        List<Field> columns = getTableFields();
-        ContentValues values = new ContentValues(columns.size());
-        for (Field column : columns) {
-            column.setAccessible(true);
-            Class<?> columnType = column.getType();
-            try {
-                String columnName = StringUtil.toSQLName(column.getName());
-                Object columnValue = column.get(this);
-                if (SugarRecord.class.isAssignableFrom(columnType)) {
-                    values.put(columnName,
-                            (columnValue != null)
-                                    ? String.valueOf(((SugarRecord) columnValue).id)
-                                    : "0");
-                } else {
-                    if (!"id".equalsIgnoreCase(column.getName())) {
-                        if (columnType.equals(Short.class) || columnType.equals(short.class)) {
-                            values.put(columnName, (Short) columnValue);
-                        }
-                        else if (columnType.equals(Integer.class) || columnType.equals(int.class)) {
-                            values.put(columnName, (Integer) columnValue);
-                        }
-                        else if (columnType.equals(Long.class) || columnType.equals(long.class)) {
-                            values.put(columnName, (Long) columnValue);
-                        }
-                        else if (columnType.equals(Float.class) || columnType.equals(float.class)) {
-                            values.put(columnName, (Float) columnValue);
-                        }
-                        else if (columnType.equals(Double.class) || columnType.equals(double.class)) {
-                            values.put(columnName, (Double) columnValue);
-                        }
-                        else if (columnType.equals(Boolean.class) || columnType.equals(boolean.class)) {
-                            values.put(columnName, (Boolean) columnValue);
-                        }
-                        else if (Date.class.equals(columnType)) {
-                            values.put(columnName, ((Date) column.get(this)).getTime());
-                        }
-                        else if (Calendar.class.equals(columnType)) {
-                            values.put(columnName, ((Calendar) column.get(this)).getTimeInMillis());
-                        }else{
-                            values.put(columnName, String.valueOf(columnValue));
-                        }
-
-                    }
-                }
-
-            } catch (IllegalAccessException e) {
-                Log.e("Sugar", e.getMessage());
-            }
-        }
-
-        if (id == null)
-            id = db.insert(getSqlName(), null, values);
-        else
-            db.update(getSqlName(), values, "ID = ?", new String[]{String.valueOf(id)});
-
-        Log.i("Sugar", getClass().getSimpleName() + " saved : " + id);
     }
 
-    public static <T extends SugarRecord<?>> List<T> listAll(Class<T> type) {
+    public static <T> List<T> listAll(Class<T> type) {
         return find(type, null, null, null, null, null);
     }
 
-    public static <T extends SugarRecord<?>> T findById(Class<T> type, Long id) {
-        List<T> list = find( type, "id=?", new String[]{String.valueOf(id)}, null, null, "1");
+    public static <T> T findById(Class<T> type, Long id) {
+        List<T> list = find(type, "id=?", new String[]{String.valueOf(id)}, null, null, "1");
         if (list.isEmpty()) return null;
         return list.get(0);
     }
 
-    public static <T extends SugarRecord<?>> Iterator<T> findAll(Class<T> type) {
+    public static <T> T findById(Class<T> type, Integer id) {
+        return findById(type, Long.valueOf(id));
+    }
+
+    public static <T> Iterator<T> findAll(Class<T> type) {
         return findAsIterator(type, null, null, null, null, null);
     }
 
-    public static <T extends SugarRecord<?>> Iterator<T> findAsIterator(Class<T> type,
-                                                                        String whereClause, String... whereArgs) {
+    public static <T> Iterator<T> findAsIterator(Class<T> type, String whereClause, String... whereArgs) {
         return findAsIterator(type, whereClause, whereArgs, null, null, null);
     }
 
-    public static <T extends SugarRecord<?>> Iterator<T> findWithQueryAsIterator(Class<T> type, String query, String... arguments) {
-        Database db = getSugarContext().getDatabase();
+    public static <T> Iterator<T> findWithQueryAsIterator(Class<T> type, String query, String... arguments) {
+        SugarDb db = getSugarContext().getSugarDb();
         SQLiteDatabase sqLiteDatabase = db.getDB();
         Cursor c = sqLiteDatabase.rawQuery(query, arguments);
         return new CursorIterator<T>(type, c);
     }
 
-    public static <T extends SugarRecord<?>> Iterator<T> findAsIterator(Class<T> type,
-                                                                    String whereClause, String[] whereArgs,
-                                                                    String groupBy, String orderBy, String limit) {
-
-        Database db = getSugarContext().getDatabase();
+    public static <T> Iterator<T> findAsIterator(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
+        SugarDb db = getSugarContext().getSugarDb();
         SQLiteDatabase sqLiteDatabase = db.getDB();
-        Cursor c = sqLiteDatabase.query(getTableName(type), null,
-                whereClause, whereArgs, groupBy, null, orderBy, limit);
+        Cursor c = sqLiteDatabase.query(NamingHelper.toSQLName(type), null, whereClause, whereArgs,
+                groupBy, null, orderBy, limit);
         return new CursorIterator<T>(type, c);
     }
 
-    public static <T extends SugarRecord<?>> List<T> find(Class<T> type,
-                                                       String whereClause, String... whereArgs) {
+    public static <T> List<T> find(Class<T> type, String whereClause, String... whereArgs) {
         return find(type, whereClause, whereArgs, null, null, null);
     }
 
-    public static <T extends SugarRecord<?>> List<T> findWithQuery(Class<T> type, String query, String... arguments){
-
-        Database db = getSugarContext().getDatabase();
+    public static <T> List<T> findWithQuery(Class<T> type, String query, String... arguments) {
+        SugarDb db = getSugarContext().getSugarDb();
         SQLiteDatabase sqLiteDatabase = db.getDB();
         T entity;
         List<T> toRet = new ArrayList<T>();
@@ -185,7 +105,7 @@ else if (Calendar.class.equals(columnType)) {
         try {
             while (c.moveToNext()) {
                 entity = type.getDeclaredConstructor().newInstance();
-                entity.inflate(c);
+                SugarRecord.inflate(c, entity);
                 toRet.add(entity);
             }
         } catch (Exception e) {
@@ -193,26 +113,25 @@ else if (Calendar.class.equals(columnType)) {
         } finally {
             c.close();
         }
+
         return toRet;
     }
 
-    public static void executeQuery(String query, String... arguments){
-        getSugarContext().getDatabase().getDB().execSQL(query, arguments);
+    public static void executeQuery(String query, String... arguments) {
+        getSugarContext().getSugarDb().getDB().execSQL(query, arguments);
     }
 
-    public static <T extends SugarRecord<?>> List<T> find(Class<T> type,
-                                                       String whereClause, String[] whereArgs,
-                                                       String groupBy, String orderBy, String limit) {
-        Database db = getSugarContext().getDatabase();
+    public static <T> List<T> find(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
+        SugarDb db = getSugarContext().getSugarDb();
         SQLiteDatabase sqLiteDatabase = db.getDB();
         T entity;
         List<T> toRet = new ArrayList<T>();
-        Cursor c = sqLiteDatabase.query(getTableName(type), null,
-                whereClause, whereArgs, groupBy, null, orderBy, limit);
+        Cursor c = sqLiteDatabase.query(NamingHelper.toSQLName(type), null, whereClause, whereArgs,
+                groupBy, null, orderBy, limit);
         try {
             while (c.moveToNext()) {
                 entity = type.getDeclaredConstructor().newInstance();
-                entity.inflate(c);
+                SugarRecord.inflate(c, entity);
                 toRet.add(entity);
             }
         } catch (Exception e) {
@@ -222,22 +141,22 @@ public static void executeQuery(String query, String... arguments){
         }
         return toRet;
     }
-    
-    public static <T extends SugarRecord<?>> long count(Class<?> type,
-            String whereClause, String[] whereArgs) {
+
+    public static <T> long count(Class<?> type) {
+        return count(type, null, null, null, null, null);
+    }
+
+    public static <T> long count(Class<?> type, String whereClause, String[] whereArgs) {
     	return count(type, whereClause, whereArgs, null, null, null);
     }
-    
-    public static <T extends SugarRecord<?>> long count(Class<?> type,
-            String whereClause, String[] whereArgs,
-            String groupBy, String orderBy, String limit) {
-    	
-    	Database db = getSugarContext().getDatabase();
+
+    public static <T> long count(Class<?> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
+        SugarDb db = getSugarContext().getSugarDb();
         SQLiteDatabase sqLiteDatabase = db.getDB();
 
         long toRet = -1;
         String filter = (!TextUtils.isEmpty(whereClause)) ? " where "  + whereClause : "";
-        SQLiteStatement sqLiteStatament = sqLiteDatabase.compileStatement("SELECT count(*) FROM " + getTableName(type) + filter);
+        SQLiteStatement sqLiteStatament = sqLiteDatabase.compileStatement("SELECT count(*) FROM " + NamingHelper.toSQLName(type) + filter);
 
         if (whereArgs != null) {
             for (int i = whereArgs.length; i != 0; i--) {
@@ -252,137 +171,61 @@ public static void executeQuery(String query, String... arguments){
         } finally {
             sqLiteStatament.close();
         }
-        
-    	return toRet;
-    }
 
-    @SuppressWarnings("unchecked")
-    void inflate(Cursor cursor) {
-        Map<Field, Long> entities = new HashMap<Field, Long>();
-        List<Field> columns = getTableFields();
-        for (Field field : columns) {
-            field.setAccessible(true);
-            try {
-                Class fieldType = field.getType();
-                String colName = StringUtil.toSQLName(field.getName());
+        return toRet;
+    }
 
-                int columnIndex = cursor.getColumnIndex(colName);
+    public static long save(Object object) {
+        return save(getSugarContext().getSugarDb().getDB(), object);
+    }
 
-                if (cursor.isNull(columnIndex)) {
-                    continue;
-                }
+    static long save(SQLiteDatabase db, Object object) {
+        List<Field> columns = ReflectionUtil.getTableFields(object.getClass());
+        ContentValues values = new ContentValues(columns.size());
+        for (Field column : columns) {
+            ReflectionUtil.addFieldValueToColumn(values, column, object);
+        }
 
-                if(colName.equalsIgnoreCase("id")){
-                    long cid = cursor.getLong(columnIndex);
-                    field.set(this, Long.valueOf(cid));
-                }else if (fieldType.equals(long.class) || fieldType.equals(Long.class)) {
-                    field.set(this,
-                            cursor.getLong(columnIndex));
-                } else if (fieldType.equals(String.class)) {
-                    String val = cursor.getString(columnIndex);
-                    field.set(this, val != null && val.equals("null") ? null : val);
-                } else if (fieldType.equals(double.class) || fieldType.equals(Double.class)) {
-                    field.set(this,
-                            cursor.getDouble(columnIndex));
-                } else if (fieldType.equals(boolean.class) || fieldType.equals(Boolean.class)) {
-                    field.set(this,
-                            cursor.getString(columnIndex).equals("1"));
-                } else if (field.getType().getName().equals("[B")) {
-                    field.set(this,
-                            cursor.getBlob(columnIndex));
-                } else if (fieldType.equals(int.class) || fieldType.equals(Integer.class)) {
-                    field.set(this,
-                            cursor.getInt(columnIndex));
-                } else if (fieldType.equals(float.class) || fieldType.equals(Float.class)) {
-                    field.set(this,
-                            cursor.getFloat(columnIndex));
-                } else if (fieldType.equals(short.class) || fieldType.equals(Short.class)) {
-                    field.set(this,
-                            cursor.getShort(columnIndex));
-                } else if (fieldType.equals(Timestamp.class)) {
-                    long l = cursor.getLong(columnIndex);
-                    field.set(this, new Timestamp(l));
-                } else if (fieldType.equals(Date.class)) {
-                    long l = cursor.getLong(columnIndex);
-                    field.set(this, new Date(l));
-                } else if (fieldType.equals(Calendar.class)) {
-                    long l = cursor.getLong(columnIndex);
-                    Calendar c = Calendar.getInstance();
-                    c.setTimeInMillis(l);
-                    field.set(this, c);
-                } else if (Enum.class.isAssignableFrom(fieldType)) {
-                    try {
-                        Method valueOf = field.getType().getMethod("valueOf", String.class);
-                        String strVal = cursor.getString(columnIndex);
-                        Object enumVal = valueOf.invoke(field.getType(), strVal);
-                        field.set(this, enumVal);
-                    } catch (Exception e) {
-                        Log.e("Sugar", "Enum cannot be read from Sqlite3 database. Please check the type of field " + field.getName());
-                    }
-                } else if (SugarRecord.class.isAssignableFrom(fieldType)) {
-                    long id = cursor.getLong(columnIndex);
-                    if (id > 0)
-                        entities.put(field, id);
-                    else
-                        field.set(this, null);
-                } else
-                    Log.e("Sugar", "Class cannot be read from Sqlite3 database. Please check the type of field " + field.getName() + "(" + field.getType().getName() + ")");
-            } catch (IllegalArgumentException e) {
-                Log.e("field set error", e.getMessage());
-            } catch (IllegalAccessException e) {
-                Log.e("field set error", e.getMessage());
-            }
+        long id = db.insertWithOnConflict(NamingHelper.toSQLName(object.getClass()), null, values,
+                SQLiteDatabase.CONFLICT_REPLACE);
 
+        if (SugarRecord.class.isAssignableFrom(object.getClass())) {
+            ReflectionUtil.setFieldValueForId(object, id);
         }
+        Log.i("Sugar", object.getClass().getSimpleName() + " saved : " + id);
 
-        for (Field f : entities.keySet()) {
-            try {
-                f.set(this, findById((Class<? extends SugarRecord<?>>) f.getType(), 
-                        entities.get(f)));
-            } catch (SQLiteException e) {
-            } catch (IllegalArgumentException e) {
-            } catch (IllegalAccessException e) {
-            }
-        }
+        return id;
     }
 
-    public List<Field> getTableFields() {
-        List<Field> fieldList = SugarConfig.getFields(getClass());
-        if(fieldList != null) return fieldList;
-
-        Log.d("Sugar", "Fetching properties");
-        List<Field> typeFields = new ArrayList<Field>();
+    private static void inflate(Cursor cursor, Object object) {
+        List<Field> columns = ReflectionUtil.getTableFields(object.getClass());
 
-        getAllFields(typeFields, getClass());
-
-        List<Field> toStore = new ArrayList<Field>();
-        for (Field field : typeFields) {
-            if (!field.isAnnotationPresent(Ignore.class) && !Modifier.isStatic(field.getModifiers())) {
-                toStore.add(field);
+        for (Field field : columns) {
+            if (field.getClass().isAnnotationPresent(Table.class)) {
+                try {
+                    long id = cursor.getLong(cursor.getColumnIndex(NamingHelper.toSQLName(field)));
+                    field.set(object, (id > 0) ? findById(field.getType(), id) : null);
+                } catch (IllegalAccessException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                ReflectionUtil.setFieldValueFromCursor(cursor, field, object);
             }
         }
-
-        SugarConfig.setFields(getClass(), toStore);
-        return toStore;
     }
 
-    private static List<Field> getAllFields(List<Field> fields, Class<?> type) {
-        Collections.addAll(fields, type.getDeclaredFields());
-
-        if (type.getSuperclass() != null) {
-            fields = getAllFields(fields, type.getSuperclass());
-        }
-
-        return fields;
+    public void delete() {
+        SQLiteDatabase db = getSugarContext().getSugarDb().getDB();
+        db.delete(NamingHelper.toSQLName(getClass()), "Id=?", new String[]{getId().toString()});
     }
 
-    public String getSqlName() {
-        return getTableName(getClass());
+    public long save() {
+        return save(getSugarContext().getSugarDb().getDB(), this);
     }
 
-
-    public static String getTableName(Class<?> type) {
-        return StringUtil.toSQLName(type.getSimpleName());
+    @SuppressWarnings("unchecked")
+    void inflate(Cursor cursor) {
+        inflate(cursor, this);
     }
 
     public Long getId() {
@@ -393,7 +236,7 @@ public void setId(Long id) {
         this.id = id;
     }
 
-    static class CursorIterator<E extends SugarRecord<?>> implements Iterator<E> {
+    static class CursorIterator<E> implements Iterator<E> {
         Class<E> type;
         Cursor cursor;
 
@@ -420,7 +263,7 @@ public E next() {
 
             try {
                 entity = type.getDeclaredConstructor().newInstance();
-                entity.inflate(cursor);
+                SugarRecord.inflate(cursor, entity);
             } catch (Exception e) {
                 e.printStackTrace();
             } finally {
@@ -429,6 +272,7 @@ public E next() {
                     cursor.close();
                 }
             }
+
             return entity;
         }
 
@@ -436,8 +280,6 @@ public E next() {
         public void remove() {
             throw new UnsupportedOperationException();
         }
-
-
     }
 
 }
diff --git a/library/src/com/orm/SugarTransactionHelper.java b/library/src/com/orm/SugarTransactionHelper.java
index 505547df..d5758718 100644
--- a/library/src/com/orm/SugarTransactionHelper.java
+++ b/library/src/com/orm/SugarTransactionHelper.java
@@ -6,24 +6,27 @@
 public class SugarTransactionHelper {
 
     public static void doInTansaction(SugarTransactionHelper.Callback callback) {
-
-        SQLiteDatabase database = SugarApp.getSugarContext().getDatabase().getDB();
-
+        SQLiteDatabase database = SugarApp.getSugarContext().getSugarDb().getDB();
         database.beginTransaction();
 
         try {
-            Log.d(SugarTransactionHelper.class.getSimpleName(), "callback executing within transaction");
+            Log.d(SugarTransactionHelper.class.getSimpleName(),
+                    "Callback executing within transaction");
             callback.manipulateInTransaction();
             database.setTransactionSuccessful();
-            Log.d(SugarTransactionHelper.class.getSimpleName(), "callback successfully executed within transaction");
+            Log.d(SugarTransactionHelper.class.getSimpleName(),
+                    "Callback successfully executed within transaction");
         } catch (Throwable e) {
-            Log.d(SugarTransactionHelper.class.getSimpleName(), "could execute callback within transaction", e);
+            Log.d(SugarTransactionHelper.class.getSimpleName(),
+                    "Could execute callback within transaction", e);
         } finally {
             database.endTransaction();
         }
+
     }
 
     public static interface Callback {
         void manipulateInTransaction();
     }
+
 }
diff --git a/library/src/com/orm/dsl/Column.java b/library/src/com/orm/dsl/Column.java
new file mode 100644
index 00000000..2c47e3c0
--- /dev/null
+++ b/library/src/com/orm/dsl/Column.java
@@ -0,0 +1,11 @@
+package com.orm.dsl;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Column {
+    String name();
+    boolean unique() default false;
+    boolean notNull() default false;
+}
diff --git a/library/src/com/orm/dsl/NotNull.java b/library/src/com/orm/dsl/NotNull.java
new file mode 100644
index 00000000..b2361851
--- /dev/null
+++ b/library/src/com/orm/dsl/NotNull.java
@@ -0,0 +1,8 @@
+package com.orm.dsl;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+public @interface NotNull {
+}
diff --git a/library/src/com/orm/dsl/Table.java b/library/src/com/orm/dsl/Table.java
new file mode 100644
index 00000000..0dfaa18b
--- /dev/null
+++ b/library/src/com/orm/dsl/Table.java
@@ -0,0 +1,9 @@
+package com.orm.dsl;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Table {
+    String name() default "";
+}
diff --git a/library/src/com/orm/dsl/Unique.java b/library/src/com/orm/dsl/Unique.java
new file mode 100644
index 00000000..7384b749
--- /dev/null
+++ b/library/src/com/orm/dsl/Unique.java
@@ -0,0 +1,8 @@
+package com.orm.dsl;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Unique {
+}
diff --git a/library/src/com/orm/query/Condition.java b/library/src/com/orm/query/Condition.java
index 6838b843..989bd458 100644
--- a/library/src/com/orm/query/Condition.java
+++ b/library/src/com/orm/query/Condition.java
@@ -1,16 +1,22 @@
 package com.orm.query;
 
 public class Condition {
+
     private String property;
     private Object value;
     private Check check;
 
     enum Check {
-        EQUALS(" = "), GREATER_THAN(" > "), LESSER_THAN(" < "), NOT_EQUALS (" != "), LIKE(" LIKE "), NOT_LIKE(" NOT LIKE ");
+        EQUALS(" = "),
+        GREATER_THAN(" > "),
+        LESSER_THAN(" < "),
+        NOT_EQUALS (" != "),
+        LIKE(" LIKE "),
+        NOT_LIKE(" NOT LIKE ");
+
         private String symbol;
 
         Check(String symbol) {
-
             this.symbol = symbol;
         }
 
@@ -20,48 +26,50 @@ public String getSymbol() {
     }
 
     enum Type {
-        AND, OR, NOT
+        AND,
+        OR,
+        NOT
     }
 
     public Condition(String property) {
         this.property = property;
     }
 
-    public static Condition prop(String property){
+    public static Condition prop(String property) {
         return new Condition(property);
     }
 
-    public Condition eq(Object value){
+    public Condition eq(Object value) {
         this.value = value;
         check = Check.EQUALS;
         return this;
     }
 
-    public Condition like(Object value){
+    public Condition like(Object value) {
         this.value = value;
         check = Check.LIKE;
         return this;
     }
 
-    public Condition notLike(Object value){
+    public Condition notLike(Object value) {
         this.value = value;
         check = Check.NOT_LIKE;
         return this;
     }
 
-    public Condition notEq(Object value){
+    public Condition notEq(Object value) {
         this.value = value;
         check = Check.NOT_EQUALS;
         return this;
     }
 
-    public Condition gt(Object value){
+    public Condition gt(Object value) {
         this.value = value;
         check = Check.GREATER_THAN;
         return this;
     }
 
-    public Condition lt(Object value){
+    public Condition lt(Object value) {
         this.value = value;
         check = Check.LESSER_THAN;
         return this;
@@ -79,7 +87,8 @@ public Check getCheck() {
         return check;
     }
 
-    public String getCheckSymbol(){
+    public String getCheckSymbol() {
         return check.getSymbol();
     }
+
 }
diff --git a/library/src/com/orm/query/Select.java b/library/src/com/orm/query/Select.java
index ceaac65c..9e91543c 100644
--- a/library/src/com/orm/query/Select.java
+++ b/library/src/com/orm/query/Select.java
@@ -1,12 +1,13 @@
 package com.orm.query;
 
 import com.orm.SugarRecord;
+import com.orm.util.NamingHelper;
 
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
-public class Select<T extends SugarRecord<?>> implements Iterable {
+public class Select<T> implements Iterable {
 
     private Class<T> record;
     private String[] arguments;
@@ -15,14 +16,13 @@
     private String groupBy;
     private String limit;
     private String offset;
-
     private List<Object> args = new ArrayList<Object>();
 
     public Select(Class<T> record) {
         this.record = record;
     }
 
-    public static <T extends SugarRecord<T>> Select<T> from(Class<T> record) {
+    public static <T> Select<T> from(Class<T> record) {
         return new Select<T>(record);
     }
 
@@ -41,8 +41,6 @@ public Select(Class<T> record) {
         return this;
     }
 
-
-
     public Select<T> where(String whereClause) {
         this.whereClause = whereClause;
         return this;
@@ -56,23 +54,35 @@ public Select(Class<T> record) {
     }
 
     private void mergeConditions(Condition[] conditions, Condition.Type type) {
+        StringBuilder toAppend = new StringBuilder("");
         for (Condition condition : conditions) {
-
-            if (!"".equals(whereClause)) {
-                whereClause += " " + type.name() + " ";
+            if (toAppend.length() != 0) {
+                toAppend.append(" ").append(type.name()).append(" ");
             }
 
-            if(Condition.Check.LIKE.equals(condition.getCheck()) || Condition.Check.NOT_LIKE.equals(condition.getCheck())){
-
-                whereClause += condition.getProperty() + condition.getCheckSymbol() + "'" + condition.getValue().toString() +"'";
-
-            }else{
-
-                whereClause += condition.getProperty() + condition.getCheckSymbol() + "? ";
+            if (Condition.Check.LIKE.equals(condition.getCheck()) ||
+                    Condition.Check.NOT_LIKE.equals(condition.getCheck())) {
+                toAppend
+                    .append(condition.getProperty())
+                    .append(condition.getCheckSymbol())
+                    .append("'")
+                    .append(condition.getValue().toString())
+                    .append("'");
+
+            } else {
+                toAppend
+                    .append(condition.getProperty())
+                    .append(condition.getCheckSymbol())
+                    .append("? ");
                 args.add(condition.getValue());
             }
-
         }
+        
+        if (!"".equals(whereClause)) {
+            whereClause += " " + type.name() + " ";
+        }
+
+        whereClause += "(" + toAppend + ")";
     }
 
     public Select<T> whereOr(Condition... args) {
@@ -97,51 +107,48 @@ private void mergeConditions(Condition[] conditions, Condition.Type type) {
     }
 
     public List<T> list() {
+        if (arguments == null) {
+            arguments = convertArgs(args);
+        }
 
-        if(arguments == null) arguments = convertArgs(args);
-
-        return T.find(record, whereClause, arguments, groupBy, orderBy, limit);
-
+        return SugarRecord.find(record, whereClause, arguments, groupBy, orderBy, limit);
     }
     
     public long count() {
+        if (arguments == null) {
+            arguments = convertArgs(args);
+        }
     	
-    	if(arguments == null) arguments = convertArgs(args);
-    	
-    	return SugarRecord.count(record, whereClause, arguments, groupBy, orderBy, limit);
+        return SugarRecord.count(record, whereClause, arguments, groupBy, orderBy, limit);
     }
 
     public T first() {
+        if (arguments == null) {
+            arguments = convertArgs(args);
+        }
 
-        if(arguments == null) arguments = convertArgs(args);
-
-        List<T> list = T.find(record, whereClause, arguments, groupBy, orderBy, "1");
+        List<T> list = SugarRecord.find(record, whereClause, arguments, groupBy, orderBy, "1");
         return list.size() > 0 ? list.get(0) : null;
     }
     
     String toSql() {
         StringBuilder sql = new StringBuilder();
-
-        sql.append("SELECT * FROM");
-
-        sql.append("FROM ");
-
-        sql.append(SugarRecord.getTableName(this.record) + " ");
+        sql.append("SELECT * FROM ").append(NamingHelper.toSQLName(this.record)).append(" ");
 
         if (whereClause != null) {
-            sql.append("WHERE " + whereClause + " ");
+            sql.append("WHERE ").append(whereClause).append(" ");
         }
 
         if (orderBy != null) {
-            sql.append("ORDER BY " + orderBy + " ");
+            sql.append("ORDER BY ").append(orderBy).append(" ");
         }
 
         if (limit != null) {
-            sql.append("LIMIT " + limit + " ");
+            sql.append("LIMIT ").append(limit).append(" ");
         }
 
         if (offset != null) {
-            sql.append("OFFSET " + offset + " ");
+            sql.append("OFFSET ").append(offset).append(" ");
         }
 
         return sql.toString();
@@ -151,14 +158,14 @@ String getWhereCond() {
         return whereClause;
     }
 
-    String[] getArgs(){
+    String[] getArgs() {
         return convertArgs(args);
     }
 
     private String[] convertArgs(List<Object> argsList) {
         String[] argsArray = new String[argsList.size()];
 
-        for(int i=0; i< argsList.size();i++){
+        for (int i = 0; i < argsList.size(); i++) {
              argsArray[i] = argsList.get(i).toString();
         }
 
@@ -167,8 +174,11 @@ String getWhereCond() {
 
     @Override
     public Iterator<T> iterator() {
-        if(arguments == null) arguments = convertArgs(args);
+        if (arguments == null) {
+            arguments = convertArgs(args);
+        }
 
-        return T.findAsIterator(record, whereClause, arguments, groupBy, orderBy, limit);
+        return SugarRecord.findAsIterator(record, whereClause, arguments, groupBy, orderBy, limit);
     }
+
 }
diff --git a/library/src/com/orm/dsl/Collection.java b/library/src/com/orm/util/Collection.java
similarity index 97%
rename from library/src/com/orm/dsl/Collection.java
rename to library/src/com/orm/util/Collection.java
index 6f1b5075..fe7a7e63 100644
--- a/library/src/com/orm/dsl/Collection.java
+++ b/library/src/com/orm/util/Collection.java
@@ -1,4 +1,4 @@
-package com.orm.dsl;
+package com.orm.util;
 import java.util.*;
 
 public class Collection {
@@ -36,4 +36,5 @@ public Entry(K key, V value) {
             this.value = value;
         }
     }
+
 }
diff --git a/library/src/com/orm/util/NamingHelper.java b/library/src/com/orm/util/NamingHelper.java
new file mode 100644
index 00000000..3d1622aa
--- /dev/null
+++ b/library/src/com/orm/util/NamingHelper.java
@@ -0,0 +1,65 @@
+package com.orm.util;
+
+import com.orm.dsl.Column;
+import com.orm.dsl.Table;
+
+import java.lang.reflect.Field;
+
+public class NamingHelper {
+
+    public static String toSQLNameDefault(String javaNotation) {
+        if (javaNotation.equalsIgnoreCase("_id")) {
+            return "_id";
+        }
+
+        StringBuilder sb = new StringBuilder();
+        char[] buf = javaNotation.toCharArray();
+
+        for (int i = 0; i < buf.length; i++) {
+            char prevChar = (i > 0) ? buf[i - 1] : 0;
+            char c = buf[i];
+            char nextChar = (i < buf.length - 1) ? buf[i + 1] : 0;
+            boolean isFirstChar = (i == 0);
+
+            if (isFirstChar || Character.isLowerCase(c) || Character.isDigit(c)) {
+                sb.append(Character.toUpperCase(c));
+            } else if (Character.isUpperCase(c)) {
+                if (Character.isLetterOrDigit(prevChar)) {
+                    if (Character.isLowerCase(prevChar)) {
+                        sb.append('_').append(Character.toUpperCase(c));
+                    } else if (nextChar > 0 && Character.isLowerCase(nextChar)) {
+                        sb.append('_').append(Character.toUpperCase(c));
+                    } else {
+                        sb.append(c);
+                    }
+                } else {
+                    sb.append(c);
+                }
+            }
+        }
+
+        return sb.toString();
+    }
+
+    public static String toSQLName(Field field) {
+        if (field.isAnnotationPresent(Column.class)) {
+            Column annotation = field.getAnnotation(Column.class);
+            return annotation.name();
+        }
+
+        return toSQLNameDefault(field.getName());
+    }
+
+    public static String toSQLName(Class<?> table) {
+        if (table.isAnnotationPresent(Table.class)) {
+            Table annotation = table.getAnnotation(Table.class);
+            if ("".equals(annotation.name())) {
+                return NamingHelper.toSQLNameDefault(table.getSimpleName());
+            }
+            return annotation.name();
+        }
+
+        return NamingHelper.toSQLNameDefault(table.getSimpleName());
+    }
+
+}
diff --git a/library/src/com/orm/NumberComparator.java b/library/src/com/orm/util/NumberComparator.java
similarity index 94%
rename from library/src/com/orm/NumberComparator.java
rename to library/src/com/orm/util/NumberComparator.java
index 244d3281..b39ca9c9 100644
--- a/library/src/com/orm/NumberComparator.java
+++ b/library/src/com/orm/util/NumberComparator.java
@@ -1,10 +1,18 @@
-package com.orm;
+package com.orm.util;
 
 import java.util.Comparator;
 
 public class NumberComparator implements Comparator<Object> {
 
-    int compareRight(String a, String b) {
+    private static char charAt(String s, int i) {
+        if (i >= s.length()) {
+            return '\000';
+        }
+
+        return s.charAt(i);
+    }
+
+    private int compareRight(String a, String b) {
         int bias = 0;
         int ia = 0;
         int ib = 0;
@@ -90,11 +98,4 @@ public int compare(Object o1, Object o2) {
         }
     }
 
-    static char charAt(String s, int i) {
-        if (i >= s.length()) {
-            return '\000';
-        }
-
-        return s.charAt(i);
-    }
 }
diff --git a/library/src/com/orm/QueryBuilder.java b/library/src/com/orm/util/QueryBuilder.java
similarity index 82%
rename from library/src/com/orm/QueryBuilder.java
rename to library/src/com/orm/util/QueryBuilder.java
index 8ff00beb..6de9e8ca 100644
--- a/library/src/com/orm/QueryBuilder.java
+++ b/library/src/com/orm/util/QueryBuilder.java
@@ -1,13 +1,12 @@
-package com.orm;
+package com.orm.util;
+
+import com.orm.SugarRecord;
 
 public class QueryBuilder {
 
     public static String getColumnType(Class<?> type) {
         if ((type.equals(Boolean.class)) ||
                 (type.equals(Boolean.TYPE)) ||
-                (type.equals(java.util.Date.class)) ||
-                (type.equals(java.util.Calendar.class)) ||
-                (type.equals(java.sql.Date.class)) ||
                 (type.equals(Integer.class)) ||
                 (type.equals(Integer.TYPE)) ||
                 (type.equals(Long.class)) ||
@@ -17,6 +16,12 @@ public static String getColumnType(Class<?> type) {
             return "INTEGER";
         }
 
+        if ((type.equals(java.util.Date.class)) ||
+                (type.equals(java.sql.Date.class)) ||
+                (type.equals(java.util.Calendar.class))) {
+            return "INTEGER NULL";
+        }
+
         if (type.getName().equals("[B")) {
             return "BLOB";
         }
@@ -32,4 +37,5 @@ public static String getColumnType(Class<?> type) {
 
         return "";
     }
+
 }
diff --git a/library/src/com/orm/util/ReflectionUtil.java b/library/src/com/orm/util/ReflectionUtil.java
new file mode 100644
index 00000000..7a213cae
--- /dev/null
+++ b/library/src/com/orm/util/ReflectionUtil.java
@@ -0,0 +1,281 @@
+package com.orm.util;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.util.Log;
+import com.orm.SugarRecord;
+import com.orm.dsl.Ignore;
+import com.orm.dsl.Table;
+import dalvik.system.DexFile;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.net.URL;
+import java.sql.Timestamp;
+import java.util.*;
+
+public class ReflectionUtil {
+
+    public static List<Field> getTableFields(Class table) {
+        List<Field> fieldList = SugarConfig.getFields(table);
+        if (fieldList != null) return fieldList;
+
+        Log.d("Sugar", "Fetching properties");
+        List<Field> typeFields = new ArrayList<Field>();
+
+        getAllFields(typeFields, table);
+
+        List<Field> toStore = new ArrayList<Field>();
+        for (Field field : typeFields) {
+            if (!field.isAnnotationPresent(Ignore.class) && !Modifier.isStatic(field.getModifiers()) && !Modifier.isTransient(field.getModifiers())) {
+                toStore.add(field);
+            }
+        }
+
+        SugarConfig.setFields(table, toStore);
+        return toStore;
+    }
+
+    private static List<Field> getAllFields(List<Field> fields, Class<?> type) {
+        Collections.addAll(fields, type.getDeclaredFields());
+
+        if (type.getSuperclass() != null) {
+            fields = getAllFields(fields, type.getSuperclass());
+        }
+
+        return fields;
+    }
+
+    public static void addFieldValueToColumn(ContentValues values, Field column, Object object) {
+        column.setAccessible(true);
+        Class<?> columnType = column.getType();
+        try {
+            String columnName = NamingHelper.toSQLName(column);
+            Object columnValue = column.get(object);
+
+            if (SugarRecord.class.isAssignableFrom(columnType)) {
+                values.put(columnName,
+                        (columnValue != null)
+                                ? String.valueOf(((SugarRecord) columnValue).getId())
+                                : "0");
+            } else {
+                if (columnType.equals(Short.class) || columnType.equals(short.class)) {
+                    values.put(columnName, (Short) columnValue);
+                } else if (columnType.equals(Integer.class) || columnType.equals(int.class)) {
+                    values.put(columnName, (Integer) columnValue);
+                } else if (columnType.equals(Long.class) || columnType.equals(long.class)) {
+                    values.put(columnName, (Long) columnValue);
+                } else if (columnType.equals(Float.class) || columnType.equals(float.class)) {
+                    values.put(columnName, (Float) columnValue);
+                } else if (columnType.equals(Double.class) || columnType.equals(double.class)) {
+                    values.put(columnName, (Double) columnValue);
+                } else if (columnType.equals(Boolean.class) || columnType.equals(boolean.class)) {
+                    values.put(columnName, (Boolean) columnValue);
+                } else if (Date.class.equals(columnType)) {
+                    try {
+                        values.put(columnName, ((Date) column.get(object)).getTime());
+                    } catch (NullPointerException e) {
+                        values.put(columnName, (Long) null);
+                    }
+                } else if (Calendar.class.equals(columnType)) {
+                    try {
+                        values.put(columnName, ((Calendar) column.get(object)).getTimeInMillis());
+                    } catch (NullPointerException e) {
+                        values.put(columnName, (Long) null);
+                    }
+                } else {
+                    if (columnValue == null) {
+                        values.putNull(columnName);
+                    } else {
+                        values.put(columnName, String.valueOf(columnValue));
+                    }
+                }
+            }
+
+        } catch (IllegalAccessException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+    }
+
+    public static void setFieldValueFromCursor(Cursor cursor, Field field, Object object) {
+        field.setAccessible(true);
+        try {
+            Class fieldType = field.getType();
+            String colName = NamingHelper.toSQLName(field);
+
+            int columnIndex = cursor.getColumnIndex(colName);
+
+            if (cursor.isNull(columnIndex)) {
+                return;
+            }
+
+            if (colName.equalsIgnoreCase("id")) {
+                long cid = cursor.getLong(columnIndex);
+                field.set(object, Long.valueOf(cid));
+            } else if (fieldType.equals(long.class) || fieldType.equals(Long.class)) {
+                field.set(object,
+                        cursor.getLong(columnIndex));
+            } else if (fieldType.equals(String.class)) {
+                String val = cursor.getString(columnIndex);
+                field.set(object, val != null && val.equals("null") ? null : val);
+            } else if (fieldType.equals(double.class) || fieldType.equals(Double.class)) {
+                field.set(object,
+                        cursor.getDouble(columnIndex));
+            } else if (fieldType.equals(boolean.class) || fieldType.equals(Boolean.class)) {
+                field.set(object,
+                        cursor.getString(columnIndex).equals("1"));
+            } else if (field.getType().getName().equals("[B")) {
+                field.set(object,
+                        cursor.getBlob(columnIndex));
+            } else if (fieldType.equals(int.class) || fieldType.equals(Integer.class)) {
+                field.set(object,
+                        cursor.getInt(columnIndex));
+            } else if (fieldType.equals(float.class) || fieldType.equals(Float.class)) {
+                field.set(object,
+                        cursor.getFloat(columnIndex));
+            } else if (fieldType.equals(short.class) || fieldType.equals(Short.class)) {
+                field.set(object,
+                        cursor.getShort(columnIndex));
+            } else if (fieldType.equals(Timestamp.class)) {
+                long l = cursor.getLong(columnIndex);
+                field.set(object, new Timestamp(l));
+            } else if (fieldType.equals(Date.class)) {
+                long l = cursor.getLong(columnIndex);
+                field.set(object, new Date(l));
+            } else if (fieldType.equals(Calendar.class)) {
+                long l = cursor.getLong(columnIndex);
+                Calendar c = Calendar.getInstance();
+                c.setTimeInMillis(l);
+                field.set(object, c);
+            } else if (Enum.class.isAssignableFrom(fieldType)) {
+                try {
+                    Method valueOf = field.getType().getMethod("valueOf", String.class);
+                    String strVal = cursor.getString(columnIndex);
+                    Object enumVal = valueOf.invoke(field.getType(), strVal);
+                    field.set(object, enumVal);
+                } catch (Exception e) {
+                    Log.e("Sugar", "Enum cannot be read from Sqlite3 database. Please check the type of field " + field.getName());
+                }
+            } else
+                Log.e("Sugar", "Class cannot be read from Sqlite3 database. Please check the type of field " + field.getName() + "(" + field.getType().getName() + ")");
+        } catch (IllegalArgumentException e) {
+            Log.e("field set error", e.getMessage());
+        } catch (IllegalAccessException e) {
+            Log.e("field set error", e.getMessage());
+        }
+    }
+
+    public static void setFieldValueForId(Object object, Long value) {
+
+        try {
+            Field field = object.getClass().getField("id");
+
+            field.setAccessible(true);
+            field.set(object, value);
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        } catch (NoSuchFieldException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static List<Class> getDomainClasses(Context context) {
+        List<Class> domainClasses = new ArrayList<Class>();
+        try {
+            for (String className : getAllClasses(context)) {
+                if (className.startsWith(SugarConfig.getDomainPackageName(context))) {
+                    Class domainClass = getDomainClass(className, context);
+                    if (domainClass != null) domainClasses.add(domainClass);
+                }
+            }
+        } catch (IOException e) {
+            Log.e("Sugar", e.getMessage());
+        } catch (PackageManager.NameNotFoundException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+
+        return domainClasses;
+    }
+
+
+    private static Class getDomainClass(String className, Context context) {
+        Class<?> discoveredClass = null;
+        try {
+            discoveredClass = Class.forName(className, true, context.getClass().getClassLoader());
+        } catch (ClassNotFoundException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+
+        if ((discoveredClass != null) &&
+                ((SugarRecord.class.isAssignableFrom(discoveredClass) &&
+                        !SugarRecord.class.equals(discoveredClass)) ||
+                        discoveredClass.isAnnotationPresent(Table.class)) &&
+                !Modifier.isAbstract(discoveredClass.getModifiers())) {
+
+            Log.i("Sugar", "domain class : " + discoveredClass.getSimpleName());
+            return discoveredClass;
+
+        } else {
+            return null;
+        }
+    }
+
+
+    private static List<String> getAllClasses(Context context) throws PackageManager.NameNotFoundException, IOException {
+        String path = getSourcePath(context);
+        List<String> classNames = new ArrayList<String>();
+        try {
+            DexFile dexfile = new DexFile(path);
+            Enumeration<String> dexEntries = dexfile.entries();
+            while (dexEntries.hasMoreElements()) {
+                classNames.add(dexEntries.nextElement());
+            }
+        } catch (NullPointerException e) {
+            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+            Enumeration<URL> urls = classLoader.getResources("");
+            List<String> fileNames = new ArrayList<String>();
+            while (urls.hasMoreElements()) {
+                String classDirectoryName = urls.nextElement().getFile();
+                if (classDirectoryName.contains("bin") || classDirectoryName.contains("classes")) {
+                    File classDirectory = new File(classDirectoryName);
+                    for (File filePath : classDirectory.listFiles()) {
+                        populateFiles(filePath, fileNames, "");
+                    }
+                    classNames.addAll(fileNames);
+                }
+            }
+        }
+        return classNames;
+    }
+
+    private static void populateFiles(File path, List<String> fileNames, String parent) {
+        if (path.isDirectory()) {
+            for (File newPath : path.listFiles()) {
+                if ("".equals(parent)) {
+                    populateFiles(newPath, fileNames, path.getName());
+                } else {
+                    populateFiles(newPath, fileNames, parent + "." + path.getName());
+                }
+            }
+        } else {
+            String pathName = path.getName();
+            String classSuffix = ".class";
+            pathName = pathName.endsWith(classSuffix) ?
+                    pathName.substring(0, pathName.length() - classSuffix.length()) : pathName;
+            if ("".equals(parent)) {
+                fileNames.add(pathName);
+            } else {
+                fileNames.add(parent + "." + pathName);
+            }
+        }
+    }
+
+    private static String getSourcePath(Context context) throws PackageManager.NameNotFoundException {
+        return context.getPackageManager().getApplicationInfo(context.getPackageName(), 0).sourceDir;
+    }
+}
diff --git a/library/src/com/orm/SugarConfig.java b/library/src/com/orm/util/SugarConfig.java
similarity index 86%
rename from library/src/com/orm/SugarConfig.java
rename to library/src/com/orm/util/SugarConfig.java
index aaeb79b6..9568fa67 100644
--- a/library/src/com/orm/SugarConfig.java
+++ b/library/src/com/orm/util/SugarConfig.java
@@ -1,4 +1,4 @@
-package com.orm;
+package com.orm.util;
 
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
@@ -25,13 +25,12 @@ public static String getDatabaseName(Context context) {
         return databaseName;
     }
 
-    public static void setFields(Class<?> clazz, List<Field> fieldz){
+    public static void setFields(Class<?> clazz, List<Field> fieldz) {
          fields.put(clazz, fieldz);
     }
 
-    public static List<Field> getFields(Class<?> clazz){
-
-        if(fields.containsKey(clazz)){
+    public static List<Field> getFields(Class<?> clazz) {
+        if (fields.containsKey(clazz)) {
             List<Field> list = fields.get(clazz);
             return Collections.synchronizedList(list);
         }
@@ -39,14 +38,13 @@ public static void setFields(Class<?> clazz, List<Field> fieldz){
         return null;
     }
 
-    public static void clearCache(){
+    public static void clearCache() {
         fields.clear();
         fields = new HashMap<Class<?>, List<Field>>();
     }
 
     public static int getDatabaseVersion(Context context) {
         Integer databaseVersion = getMetaDataInteger(context, "VERSION");
-
         if ((databaseVersion == null) || (databaseVersion == 0)) {
             databaseVersion = 1;
         }
@@ -54,9 +52,8 @@ public static int getDatabaseVersion(Context context) {
         return databaseVersion;
     }
 
-    public static String getDomainPackageName(Context context){
+    public static String getDomainPackageName(Context context) {
         String domainPackageName = getMetaDataString(context, "DOMAIN_PACKAGE_NAME");
-
         if (domainPackageName == null) {
             domainPackageName = "";
         }
@@ -70,13 +67,13 @@ public static boolean getDebugEnabled(Context context) {
 
     public static String getMetaDataString(Context context, String name) {
         String value = null;
-
         PackageManager pm = context.getPackageManager();
+
         try {
             ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(), 128);
             value = ai.metaData.getString(name);
         } catch (Exception e) {
-            Log.d("sugar", "Couldn't find config value: " + name);
+            Log.d("Sugar", "Couldn't find config value: " + name);
         }
 
         return value;
@@ -84,13 +81,13 @@ public static String getMetaDataString(Context context, String name) {
 
     public static Integer getMetaDataInteger(Context context, String name) {
         Integer value = null;
-
         PackageManager pm = context.getPackageManager();
+
         try {
             ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(), 128);
             value = ai.metaData.getInt(name);
         } catch (Exception e) {
-            Log.d("sugar", "Couldn't find config value: " + name);
+            Log.d("Sugar", "Couldn't find config value: " + name);
         }
 
         return value;
@@ -98,13 +95,13 @@ public static Integer getMetaDataInteger(Context context, String name) {
 
     public static Boolean getMetaDataBoolean(Context context, String name) {
         Boolean value = false;
-
         PackageManager pm = context.getPackageManager();
+
         try {
             ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(), 128);
             value = ai.metaData.getBoolean(name);
         } catch (Exception e) {
-            Log.d("sugar", "Couldn't find config value: " + name);
+            Log.d("Sugar", "Couldn't find config value: " + name);
         }
 
         return value;
diff --git a/library/src/com/orm/SugarCursorFactory.java b/library/src/com/orm/util/SugarCursorFactory.java
similarity index 70%
rename from library/src/com/orm/SugarCursorFactory.java
rename to library/src/com/orm/util/SugarCursorFactory.java
index 17c60c59..12706516 100644
--- a/library/src/com/orm/SugarCursorFactory.java
+++ b/library/src/com/orm/util/SugarCursorFactory.java
@@ -1,4 +1,4 @@
-package com.orm;
+package com.orm.util;
 
 import android.database.Cursor;
 import android.database.sqlite.SQLiteCursor;
@@ -15,18 +15,22 @@ public SugarCursorFactory() {
         this.debugEnabled = false;
     }
 
-    public SugarCursorFactory(boolean debugEnabled){
+    public SugarCursorFactory(boolean debugEnabled) {
 
         this.debugEnabled = debugEnabled;
     }
 
     @SuppressWarnings("deprecation")
-    public Cursor newCursor(SQLiteDatabase sqLiteDatabase, SQLiteCursorDriver sqLiteCursorDriver, String editTable, SQLiteQuery sqLiteQuery) {
+    public Cursor newCursor(SQLiteDatabase sqLiteDatabase,
+            SQLiteCursorDriver sqLiteCursorDriver,
+            String editTable,
+            SQLiteQuery sqLiteQuery) {
 
-        if(debugEnabled){
+        if (debugEnabled) {
             Log.d("SQL Log", sqLiteQuery.toString());
         }
 
         return new SQLiteCursor(sqLiteDatabase, sqLiteCursorDriver, editTable, sqLiteQuery);
     }
+
 }
diff --git a/library/test/com/orm/NamingHelperTest.java b/library/test/com/orm/NamingHelperTest.java
new file mode 100644
index 00000000..d7c2e30e
--- /dev/null
+++ b/library/test/com/orm/NamingHelperTest.java
@@ -0,0 +1,25 @@
+package com.orm;
+
+import com.orm.util.NamingHelper;
+import org.junit.Test;
+
+import static junit.framework.Assert.assertEquals;
+
+public class NamingHelperTest {
+    @Test
+    public void testToSQLNameCaseConversion() throws Exception {
+        assertEquals("TESTLOWERCASE", NamingHelper.toSQLNameDefault("testlowercase"));
+        assertEquals("TESTUPPERCASE", NamingHelper.toSQLNameDefault("TESTUPPERCASE"));
+    }
+
+    @Test
+    public void testToSQLNameUnderscore() {
+        assertEquals("TEST_UNDERSCORE", NamingHelper.toSQLNameDefault("testUnderscore"));
+        assertEquals("AB_CD", NamingHelper.toSQLNameDefault("AbCd"));
+        assertEquals("AB_CD", NamingHelper.toSQLNameDefault("ABCd"));
+        assertEquals("AB_CD", NamingHelper.toSQLNameDefault("AbCD"));
+        assertEquals("SOME_DETAILS_OBJECT", NamingHelper.toSQLNameDefault("SomeDetailsObject"));
+    }
+
+
+}
diff --git a/library/test/com/orm/StringUtilTest.java b/library/test/com/orm/StringUtilTest.java
deleted file mode 100644
index 923bf98d..00000000
--- a/library/test/com/orm/StringUtilTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.orm;
-
-import org.junit.Test;
-
-import static junit.framework.Assert.assertEquals;
-
-public class StringUtilTest {
-    @Test
-    public void testToSQLNameCaseConversion() throws Exception {
-        assertEquals("TESTLOWERCASE", StringUtil.toSQLName("testlowercase"));
-        assertEquals("TESTUPPERCASE", StringUtil.toSQLName("TESTUPPERCASE"));
-    }
-
-    @Test
-    public void testToSQLNameUnderscore(){
-        assertEquals("TEST_UNDERSCORE", StringUtil.toSQLName("testUnderscore"));
-        assertEquals("AB_CD", StringUtil.toSQLName("AbCd"));
-        assertEquals("AB_CD", StringUtil.toSQLName("ABCd"));
-        assertEquals("AB_CD", StringUtil.toSQLName("AbCD"));
-        assertEquals("SOME_DETAILS_OBJECT", StringUtil.toSQLName("SomeDetailsObject"));
-    }
-
-
-}
diff --git a/library/test/com/orm/query/TestRecord.java b/library/test/com/orm/query/TestRecord.java
index 0751a936..50997205 100644
--- a/library/test/com/orm/query/TestRecord.java
+++ b/library/test/com/orm/query/TestRecord.java
@@ -1,10 +1,9 @@
 package com.orm.query;
 
 import android.content.Context;
-import com.orm.SugarApp;
 import com.orm.SugarRecord;
 
-public class TestRecord extends SugarRecord<TestRecord>{
+public class TestRecord extends SugarRecord {
 
     private String name;
 
