diff --git a/.gitignore b/.gitignore
index d1186da8..f249d1da 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,12 @@
+library/bin
+library/build
+library/gen
+library/.project
+library/.classpath
+library/library.iml
+library/.gradle
+*.class
+.DS_Store
 #Android generated
 bin
 gen
diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 00000000..ab91b91e
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,13 @@
+language: android
+android:
+  components:
+    - sys-img-x86-android-17
+    - build-tools-19.1.0
+    - android-17
+    - android-19
+
+before_script:
+  - cd library
+
+script:
+  - ant travis-all
diff --git a/README.md b/README.md
index e6916fb1..4480e154 100644
--- a/README.md
+++ b/README.md
@@ -1,34 +1,91 @@
-Please follow the documentation at
-http://satyan.github.io/sugar
+# Sugar ORM [![Build Status](https://travis-ci.org/satyan/sugar.svg?branch=master)](https://travis-ci.org/satyan/sugar)
 
-The example application is provided in the "example" folder in the source.
+Insanely easy way to work with Android databases.
 
+Official documentation can be found [here](http://satyan.github.io/sugar). The example application is provided in the **example** folder in the source.
 
-# Getting Started:
+## Features
 
-Sugar is now available as a library project also. Add it to your project and utilize the latest changes.
-The project is available in the folder "library"
-http://developer.android.com/tools/projects/index.html#LibraryProjects
+Sugar ORM was built in contrast to other ORM's to have:
 
-# New in version 1.2
+- A simple, concise, and clean integration process with minimal configuration.
+- Automatic table and column naming through reflection.
+- Support for migrations between different schema versions.
 
-1. package restriction for domain classes.
-2. metadata caching
-3. QueryBuilder v1
-4. Database Migrations
-5. Provision for Raw queries
-6. Better and more organized api guide and usage instructions.
+## Installing
 
-# What's new in 1.1:
+There are four ways to install Sugar:
 
-1. Static api doesn't take context anymore. Hence
+#### As a Gradle dependency
 
-        Book.findById(context, Book.class, 1);
+This is the preferred way. Simply add:
 
-        becomes
+```groovy
+compile 'com.github.satyan:sugar:1.3'
+```
 
-        Book.findById(Book.class, 1);
+to your project dependencies and run `gradle build` or `gradle assemble`.
 
+#### As a Maven dependency
 
-2. Some cleanup in the code.
+Declare the dependency in Maven:
 
+```xml
+<dependency>
+    <groupId>com.github.satyan</groupId>
+    <artifactId>sugar</artifactId>
+    <version>1.3</version>
+</dependency>
+```
+
+#### As a library project
+
+Download the source code and import it as a library project in Eclipse. The project is available in the folder **library**. For more information on how to do this, read [here](http://developer.android.com/tools/projects/index.html#LibraryProjects).
+
+#### Use a jar
+
+Visit the [releases](https://github.com/satyan/sugar/releases) page to download jars directly. You can drop them into your `libs` folder and configure the Java build path to include the library. See this [tutorial](http://www.vogella.com/tutorials/AndroidLibraryProjects/article.html) for an excellent guide on how to do this.
+
+===================
+
+After installing, check out how to set up your first database and models [here](http://satyan.github.io/sugar/getting-started.html).
+
+## Contributing
+
+Please fork this repository and contribute back using [pull requests](https://github.com/satyan/sugar/pulls). Features can be requested using [issues](https://github.com/satyan/sugar/issues). All code, comments, and critiques are greatly appreciated.
+
+## Changelog
+
+#### v1.3 [[jar](https://github.com/satyan/sugar/releases/download/v1.3/sugar-1.3.jar)]
+
+- Transaction Support
+- Bulk Insert of records 
+- Encrypted datastore (branch : sugar-cipher using sqlcipher)
+- Removed Constructor with context parameter. Needs default constructor now.
+- Enhancements to QueryBuilder
+- Bug fixes and other improvements.
+
+#### v1.2 [[jar](https://github.com/satyan/sugar/releases/download/v1.2/sugar-1.2.jar)]
+
+- package restriction for domain classes.
+- metadata caching
+- QueryBuilder v1
+- Database Migrations
+- Provision for Raw queries
+- Better and more organized api guide and usage instructions.
+
+#### v1.1 [[jar](https://github.com/satyan/sugar/releases/download/v1.1/sugar-1.1.jar)]
+
+- Static api doesn't take context anymore. Hence
+
+```java
+Book.findById(context, Book.class, 1);
+```
+
+becomes
+
+```java
+Book.findById(Book.class, 1);
+```
+
+- Some cleanup in the code.
diff --git a/dist/sugar-1.0.jar b/dist/sugar-1.0.jar
deleted file mode 100644
index 2bf1abd3..00000000
Binary files a/dist/sugar-1.0.jar and /dev/null differ
diff --git a/dist/sugar-1.1.jar b/dist/sugar-1.1.jar
deleted file mode 100644
index 96a6b77e..00000000
Binary files a/dist/sugar-1.1.jar and /dev/null differ
diff --git a/dist/sugar-1.2.jar b/dist/sugar-1.2.jar
deleted file mode 100644
index 2e6f0290..00000000
Binary files a/dist/sugar-1.2.jar and /dev/null differ
diff --git a/dist/sugar-1.3_beta.jar b/dist/sugar-1.3_beta.jar
deleted file mode 100644
index a9d0ed8c..00000000
Binary files a/dist/sugar-1.3_beta.jar and /dev/null differ
diff --git a/example/AndroidManifest.xml b/example/AndroidManifest.xml
index e647f387..e03f036a 100755
--- a/example/AndroidManifest.xml
+++ b/example/AndroidManifest.xml
@@ -3,7 +3,7 @@
       package="com.example"
       android:versionCode="1"
       android:versionName="1.0">
-    <application android:label="@string/app_name" android:icon="@drawable/icon" android:name="com.orm.SugarApp">
+    <application android:label="@string/app_name" android:icon="@drawable/icon" android:name="ClientApp">
         <activity android:name="SugarActivity"
                   android:label="@string/app_name">
             <intent-filter>
diff --git a/example/src/com/example/AddNoteActivity.java b/example/src/com/example/AddNoteActivity.java
index 4c1585d8..027fcb5c 100755
--- a/example/src/com/example/AddNoteActivity.java
+++ b/example/src/com/example/AddNoteActivity.java
@@ -9,6 +9,9 @@
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
+import static com.orm.SugarRecord.save;
+
+
 public class AddNoteActivity extends Activity {
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
@@ -38,8 +41,8 @@ public void onCreate(Bundle savedInstanceState) {
         save.setOnClickListener(new View.OnClickListener() {
             public void onClick(View view) {
                 Tag tag = new Tag(tagBox.getText().toString());
-                tag.save();
-                new Note( 10, titleBox.getText().toString(), descBox.getText().toString(),tag).save();
+                save(tag);
+                save(new Note(10 + (int) (10 * Math.random()), titleBox.getText().toString(), descBox.getText().toString(), tag));
                 Intent intent = new Intent(AddNoteActivity.this, NoteListActivity.class);
                 startActivity(intent);
             }
diff --git a/example/src/com/example/ClientApp.java b/example/src/com/example/ClientApp.java
new file mode 100644
index 00000000..6e241a9d
--- /dev/null
+++ b/example/src/com/example/ClientApp.java
@@ -0,0 +1,21 @@
+package com.example;
+
+import com.orm.SugarContext;
+
+import android.app.Application;
+
+public class ClientApp extends Application {
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        SugarContext.init(this);
+    }
+
+    @Override
+    public void onTerminate() {
+        super.onTerminate();
+        SugarContext.terminate();
+    }
+
+}
diff --git a/example/src/com/example/NewNote.java b/example/src/com/example/NewNote.java
new file mode 100644
index 00000000..a80e2d4a
--- /dev/null
+++ b/example/src/com/example/NewNote.java
@@ -0,0 +1,11 @@
+package com.example;
+
+import com.orm.dsl.Table;
+
+@Table(name = "new_note")
+public class NewNote {
+
+    public long id;
+    public String name;
+
+}
diff --git a/example/src/com/example/Note.java b/example/src/com/example/Note.java
index 597f3766..82f73de3 100755
--- a/example/src/com/example/Note.java
+++ b/example/src/com/example/Note.java
@@ -1,12 +1,27 @@
 package com.example;
 
-import java.util.Calendar;
-import com.orm.SugarRecord;
-
-public class Note extends SugarRecord<Note> {
-	private int noteId;
-	private String title;
-	private String description;
+import com.orm.dsl.Column;
+import com.orm.dsl.Table;
+
+@Table(name = "Note")
+public class Note {
+
+    private long id;
+
+    @Column(name = "noteId", unique = true, notNull = true)
+    private int noteId;
+
+    private String title;
+    private String description;
+    private String name;
+    private Integer noteNumber = 2;
+    private Float tagNumber = 4.0f;
+    private float tagNo = 5.0f;
+    private Boolean isTag = true;
+    private boolean isTagged = false;
+    private Double noteTagNo = 40.5;
+    private double noteTagNumber = 24.4;
+    private Tag tag;
 
 	private Integer testIntegerObj;
 	private Integer testIntegerObjNull;
diff --git a/example/src/com/example/NoteListActivity.java b/example/src/com/example/NoteListActivity.java
index d722b361..4b8c96f5 100755
--- a/example/src/com/example/NoteListActivity.java
+++ b/example/src/com/example/NoteListActivity.java
@@ -6,7 +6,7 @@
 import android.util.Log;
 import android.view.View;
 import android.widget.ArrayAdapter;
-
+import com.orm.SugarRecord;
 import com.orm.query.Condition;
 import com.orm.query.Select;
 
@@ -19,8 +19,9 @@ public void onCreate(Bundle savedInstanceState) {
         setContentView(R.layout.notelist);
 
         List<Note> notes = Select.from(Note.class).orderBy("title").list();//Note.listAll(Note.class);
+        List<NewNote> list = SugarRecord.listAll(NewNote.class);
 
-        setListAdapter(new ArrayAdapter<Note>(this,android.R.layout.simple_list_item_1, notes));
+        setListAdapter(new ArrayAdapter<Note>(this, android.R.layout.simple_list_item_1, notes));
 
         findViewById(R.id.Button01).setOnClickListener(new View.OnClickListener() {
             public void onClick(View view) {
diff --git a/example/src/com/example/NoteRelation.java b/example/src/com/example/NoteRelation.java
index b2196b37..3331b5e4 100644
--- a/example/src/com/example/NoteRelation.java
+++ b/example/src/com/example/NoteRelation.java
@@ -1,11 +1,12 @@
 package com.example;
 
 import android.content.Context;
-import com.orm.SugarRecord;
+import com.orm.dsl.Table;
 
-public class NoteRelation extends SugarRecord<Note> {
-	String name;
-	int noteId;
+@Table(name = "note_relation")
+public class NoteRelation {
+    String name;
+    int noteId;
 
 	public NoteRelation() {
 	}
diff --git a/example/src/com/example/SugarActivity.java b/example/src/com/example/SugarActivity.java
index 60ca3b65..c2164d07 100755
--- a/example/src/com/example/SugarActivity.java
+++ b/example/src/com/example/SugarActivity.java
@@ -5,54 +5,59 @@
 import android.content.Intent;
 import android.os.Bundle;
 import android.util.Log;
+import com.orm.SugarRecord;
 
-public class SugarActivity extends Activity {
-	
-	/** Called when the activity is first created. */
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.main);
-		Note.deleteAll(Note.class);
-		TextNote.deleteAll(TextNote.class);
-		Tag.deleteAll(Tag.class);
-		initDb();
-		Intent intent = new Intent(this, NoteListActivity.class);
-		startActivity(intent);
-	}
+import static com.orm.SugarRecord.save;
+
+public class SugarActivity extends Activity
+{
+    /** Called when the activity is first created. */
+    @Override
+    public void onCreate(Bundle savedInstanceState)
+    {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+        SugarRecord.deleteAll(Note.class);
+        SugarRecord.deleteAll(TextNote.class);
+        SugarRecord.deleteAll(Tag.class);
+        SugarRecord.deleteAll(NewNote.class);
+        initDb();
+        Intent intent = new Intent(this, NoteListActivity.class);
+        startActivity(intent);
+    }
+
+     private void initDb() {
+
+        Tag t1 = new Tag("tag1");
+        Tag t2 = new Tag("tag2");
+        save(t1);
+        save(t2);
+
+        Note n1 = new Note(10, "note1", "description1", t1);
+        Note n2 = new Note(10, "note2", "description2", t1);
+        Note n3 = new Note(10, "note3", "description3", t2);
+        Note n4 = new Note(10, "note4", "description4", t2);
+
+        if (!n1.Validate()) Log.e("TEST", "Validation before saving failed!");
+        
+        TextNote textNote = new TextNote();
+        textNote.desc = "Test";
+
+         save(textNote);
+         save(n1);
+         save(n2);
+         save(n3);
+         save(n4);
 
-	private void initDb() {
-
-		Tag t1 = new Tag("tag1");
-		Tag t2 = new Tag("tag2");
-		t1.save();
-		t2.save();
-
-		Note n1 = new Note(10, "note1", "description1", t1);
-		Note n2 = new Note(10, "note2", "description2", t1);
-		Note n3 = new Note(10, "note3", "description3", t2);
-		Note n4 = new Note(10, "note4", "description4", t2);
-
-		if (!n1.Validate()) Log.e("TEST", "Validation before saving failed!");
-		
-		TextNote textNote = new TextNote();
-		textNote.desc = "Test";
-
-		textNote.save();
-		n1.save();
-		n2.save();
-		n3.save();
-		n4.save();
-
-		n1.setDescription("matrix");
-		n1.setTitle("atrix");
-		n1.save();
-		n2.setDescription("matrix");
-		n2.setTitle("satrix");
-		n2.save();
-		n3.setDescription("matrix");
-		n3.setTitle("batrix");
-		n3.save();
+         n1.setDescription("matrix");
+         n1.setTitle("atrix");
+         save(n1);
+         n2.setDescription("matrix");
+         n2.setTitle("satrix");
+         save(n2);
+         n3.setDescription("matrix");
+         n3.setTitle("batrix");
+         save(n3);
 
         Note existingNote = Select.from(Note.class).where("TITLE = ?", new String[] { "atrix" }).first();
         if (!existingNote.Validate()) Log.e("TEST", "Validation after loading failed!");
diff --git a/example/src/com/example/Tag.java b/example/src/com/example/Tag.java
index 9bdbdd16..5f8f67e0 100755
--- a/example/src/com/example/Tag.java
+++ b/example/src/com/example/Tag.java
@@ -1,9 +1,10 @@
 package com.example;
 
-import com.orm.SugarRecord;
+import com.orm.dsl.Table;
 
-public class Tag extends SugarRecord<Tag> {
-	private String name;
+@Table(name = "tag")
+public class Tag {
+    private String name;
 
 	public Tag(String name) {
 		this.name = name;
diff --git a/example/src/com/example/TextNote.java b/example/src/com/example/TextNote.java
index 7f95b9d9..bf7ada71 100644
--- a/example/src/com/example/TextNote.java
+++ b/example/src/com/example/TextNote.java
@@ -1,5 +1,8 @@
 package com.example;
 
+import com.orm.dsl.Table;
+
+@Table(name = "text_note")
 public class TextNote extends Note {
 
 	public String desc;
diff --git a/library/AndroidManifest.xml b/library/AndroidManifest.xml
index e37ad6f3..be9bceb3 100644
--- a/library/AndroidManifest.xml
+++ b/library/AndroidManifest.xml
@@ -1,9 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.orm.dsl"
-    android:versionCode="1"
-    android:versionName="1.0" >
-
+          package="com.orm.dsl"
+          android:versionCode="1"
+          android:versionName="1.0">
     <uses-sdk android:minSdkVersion="11" />
 
 </manifest>
\ No newline at end of file
diff --git a/library/build.properties b/library/build.properties
index ff5c1fe8..b5b95df0 100644
--- a/library/build.properties
+++ b/library/build.properties
@@ -1,2 +1,3 @@
-jdk.home.1.6=/Library/Java/Home
-android.home=/Users/ADMIN/Downloads/android-sdk-macosx/platforms/android-17/android.jar
\ No newline at end of file
+jdk.home.1.6=$JAVA_HOME
+android.home=/Users/ADMIN/Downloads/android-sdk-macosx/platforms/android-17/android.jar
+android.travis.home=/usr/local/android-sdk/platforms/android-17/android.jar
diff --git a/library/build.xml b/library/build.xml
index ef746a37..927b3904 100644
--- a/library/build.xml
+++ b/library/build.xml
@@ -20,6 +20,10 @@
     <pathelement location="${android.home}"/>
   </path>
 
+  <path id="sugar.travis.classpath">
+    <pathelement location="${android.travis.home}"/>
+  </path>
+
   <patternset id="excluded.from.compilation.sugar">
     <patternset refid="ignored.files"/>
   </patternset>
@@ -29,10 +33,10 @@
       <include name="src"/>
     </dirset>
   </path>
-  
+ 
   <target name="compile" description="Compile module sugar; production classes">
     <mkdir dir="${sugar.output.dir}"/>
-    <javac destdir="${sugar.output.dir}" fork="true" executable="${jdk.bin.1.6}/javac">
+    <javac destdir="${sugar.output.dir}" fork="false" executable="${jdk.bin.1.6}/javac">
       <classpath refid="sugar.classpath"/>
       <src refid="sugar.module.sourcepath"/>
       <patternset refid="excluded.from.compilation.sugar"/>
@@ -41,12 +45,25 @@
       <jar destfile="${sugar.output.dir}/sugar.jar" basedir="${sugar.output.dir}"/>
 
   </target>
-  
+
+  <target name="compile-travis" description="Compile module sugar for travis-cl">
+
+    <mkdir dir="${sugar.output.dir}"/>
+    <javac destdir="${sugar.output.dir}" fork="false" executable="${jdk.bin.1.6}/javac">
+      <classpath refid="sugar.travis.classpath"/>
+      <src refid="sugar.module.sourcepath"/>
+      <patternset refid="excluded.from.compilation.sugar"/>
+    </javac>
+
+      <jar destfile="${sugar.output.dir}/sugar.jar" basedir="${sugar.output.dir}"/>
+
+  </target>
 
   <target name="clean" description="cleanup module">
     <delete dir="${sugar.output.dir}"/>
   </target>
-
+      <patternset refid="excluded.from.compilation.sugar"/>
   <target name="all" depends="clean, compile" description="build all modules"/>
+  <target name="travis-all" depends="clean, compile-travis" description="build all modules for travis"/>
   
-</project>
\ No newline at end of file
+</project>
diff --git a/library/src/com/orm/Database.java b/library/src/com/orm/Database.java
deleted file mode 100644
index 34b581c3..00000000
--- a/library/src/com/orm/Database.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package com.orm;
-
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-
-
-public class Database {
-    private SugarDb sugarDb;
-    private SQLiteDatabase sqLiteDatabase;
-
-    public Database(Context context) {
-        this.sugarDb  = new SugarDb(context);
-    }
-
-    public synchronized SQLiteDatabase getDB() {
-        if (this.sqLiteDatabase == null) {
-            this.sqLiteDatabase = this.sugarDb.getWritableDatabase();
-        }
-
-        return this.sqLiteDatabase;
-    }
-
-    public void deleteDatabase() {
-        this.sugarDb.deleteTables(this.getDB());
-        this.sugarDb.onCreate(this.getDB());
-    }
-}
diff --git a/library/src/com/orm/SchemaGenerator.java b/library/src/com/orm/SchemaGenerator.java
new file mode 100644
index 00000000..a7f25b51
--- /dev/null
+++ b/library/src/com/orm/SchemaGenerator.java
@@ -0,0 +1,169 @@
+package com.orm;
+
+import android.content.Context;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+import android.util.Log;
+import com.orm.dsl.Column;
+import com.orm.dsl.NotNull;
+import com.orm.dsl.Unique;
+import com.orm.util.NamingHelper;
+import com.orm.util.NumberComparator;
+import com.orm.util.QueryBuilder;
+import com.orm.util.ReflectionUtil;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.lang.reflect.Field;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import static com.orm.util.ReflectionUtil.getDomainClasses;
+
+public class SchemaGenerator {
+
+    private Context context;
+
+    public SchemaGenerator(Context context) {
+        this.context = context;
+    }
+
+    public void createDatabase(SQLiteDatabase sqLiteDatabase) {
+        List<Class> domainClasses = getDomainClasses(context);
+        for (Class domain : domainClasses) {
+            createTable(domain, sqLiteDatabase);
+        }
+    }
+
+    public void doUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
+        List<Class> domainClasses = getDomainClasses(context);
+        for (Class domain : domainClasses) {
+            try {  // we try to do a select, if fails then (?) there isn't the table
+                sqLiteDatabase.query(NamingHelper.toSQLName(domain), null, null, null, null, null, null);
+            } catch (SQLiteException e) {
+                Log.i("Sugar", String.format("Creating table on update (error was '%s')",
+                        e.getMessage()));
+                createTable(domain, sqLiteDatabase);
+            }
+        }
+        executeSugarUpgrade(sqLiteDatabase, oldVersion, newVersion);
+    }
+
+    public void deleteTables(SQLiteDatabase sqLiteDatabase) {
+        List<Class> tables = getDomainClasses(context);
+        for (Class table : tables) {
+            sqLiteDatabase.execSQL("DROP TABLE IF EXISTS " + NamingHelper.toSQLName(table));
+        }
+    }
+
+    private boolean executeSugarUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        boolean isSuccess = false;
+
+        try {
+            List<String> files = Arrays.asList(this.context.getAssets().list("sugar_upgrades"));
+            Collections.sort(files, new NumberComparator());
+            for (String file : files) {
+                Log.i("Sugar", "filename : " + file);
+
+                try {
+                    int version = Integer.valueOf(file.replace(".sql", ""));
+
+                    if ((version > oldVersion) && (version <= newVersion)) {
+                        executeScript(db, file);
+                        isSuccess = true;
+                    }
+                } catch (NumberFormatException e) {
+                    Log.i("Sugar", "not a sugar script. ignored." + file);
+                }
+
+            }
+        } catch (IOException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+
+        return isSuccess;
+    }
+
+    private void executeScript(SQLiteDatabase db, String file) {
+        try {
+            InputStream is = this.context.getAssets().open("sugar_upgrades/" + file);
+            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
+            String line;
+            while ((line = reader.readLine()) != null) {
+                Log.i("Sugar script", line);
+                db.execSQL(line.toString());
+            }
+        } catch (IOException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+
+        Log.i("Sugar", "Script executed");
+    }
+
+    private void createTable(Class<?> table, SQLiteDatabase sqLiteDatabase) {
+        Log.i("Sugar", "Create table");
+        List<Field> fields = ReflectionUtil.getTableFields(table);
+        String tableName = NamingHelper.toSQLName(table);
+        StringBuilder sb = new StringBuilder("CREATE TABLE ");
+        sb.append(tableName).append(" ( ID INTEGER PRIMARY KEY AUTOINCREMENT ");
+
+        for (Field column : fields) {
+            String columnName = NamingHelper.toSQLName(column);
+            String columnType = QueryBuilder.getColumnType(column.getType());
+
+            if (columnType != null) {
+                if (columnName.equalsIgnoreCase("Id")) {
+                    continue;
+                }
+
+                if (column.isAnnotationPresent(Column.class)) {
+                    Column columnAnnotation = column.getAnnotation(Column.class);
+                    columnName = columnAnnotation.name();
+
+                    sb.append(", ").append(columnName).append(" ").append(columnType);
+
+                    if (columnAnnotation.notNull()) {
+                        if (columnType.endsWith(" NULL")) {
+                            sb.delete(sb.length() - 5, sb.length());
+                        }
+                        sb.append(" NOT NULL");
+                    }
+
+                    if (columnAnnotation.unique()) {
+                        sb.append(" UNIQUE");
+                    }
+
+                } else {
+                    sb.append(", ").append(columnName).append(" ").append(columnType);
+
+                    if (column.isAnnotationPresent(NotNull.class)) {
+                        if (columnType.endsWith(" NULL")) {
+                            sb.delete(sb.length() - 5, sb.length());
+                        }
+                        sb.append(" NOT NULL");
+                    }
+
+                    if (column.isAnnotationPresent(Unique.class)) {
+                        sb.append(" UNIQUE");
+                    }
+                }
+            }
+        }
+
+        sb.append(" ) ");
+        Log.i("Sugar", "Creating table " + tableName);
+
+        if (!"".equals(sb.toString())) {
+            try {
+                sqLiteDatabase.execSQL(sb.toString());
+            } catch (SQLException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+}
diff --git a/library/src/com/orm/StringUtil.java b/library/src/com/orm/StringUtil.java
deleted file mode 100644
index 40fabf48..00000000
--- a/library/src/com/orm/StringUtil.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package com.orm;
-
-public class StringUtil {
-    public static String toSQLName(String javaNotation) {
-            if(javaNotation.equalsIgnoreCase("_id"))
-                    return "_id";
-
-            StringBuilder sb = new StringBuilder();
-            char[] buf = javaNotation.toCharArray();
-
-            for (int i = 0; i < buf.length; i++) {
-                    char prevChar = (i > 0) ? buf[i - 1] : 0;
-                    char c = buf[i];
-                    char nextChar = (i < buf.length - 1) ? buf[i + 1] : 0;
-                    boolean isFirstChar = (i == 0);
-
-                    if (isFirstChar || Character.isLowerCase(c) || Character.isDigit(c)) {
-                            sb.append(Character.toUpperCase(c));
-                    } else if (Character.isUpperCase(c)) {
-                            if (Character.isLetterOrDigit(prevChar)) {
-                                    if (Character.isLowerCase(prevChar)) {
-                                            sb.append('_').append(Character.toUpperCase(c));
-                                    } else if (nextChar > 0 && Character.isLowerCase(nextChar)) {
-                                            sb.append('_').append(Character.toUpperCase(c));
-                                    } else {
-                                            sb.append(c);
-                                    }
-                            }
-                            else {
-                                    sb.append(c);
-                            }
-                    }
-            }
-
-            return sb.toString();
-    }
-
-}
diff --git a/library/src/com/orm/SugarApp.java b/library/src/com/orm/SugarApp.java
index 7e277701..5140e1ee 100644
--- a/library/src/com/orm/SugarApp.java
+++ b/library/src/com/orm/SugarApp.java
@@ -1,32 +1,21 @@
 package com.orm;
 
-public class SugarApp extends android.app.Application{
+import com.orm.SugarContext;
 
-    private Database database;
-    private static SugarApp sugarContext;
+import android.app.Application;
 
-    public void onCreate(){
+public class SugarApp extends Application {
+
+    @Override
+    public void onCreate() {
         super.onCreate();
-        SugarApp.sugarContext = this;
-        this.database = new Database(this);
+        SugarContext.init(this);
     }
 
-    public void onTerminate(){
-        if (this.database != null) {
-            this.database.getDB().close();
-        }
+    @Override
+    public void onTerminate() {
         super.onTerminate();
+        SugarContext.terminate();
     }
 
-    public static SugarApp getSugarContext(){
-        return sugarContext;
-    }
-    
-    public void deleteDatabase(){
-        this.database.deleteDatabase();
-    }
-
-    protected Database getDatabase() {
-        return database;
-    }
 }
diff --git a/library/src/com/orm/SugarConfig.java b/library/src/com/orm/SugarConfig.java
deleted file mode 100644
index aaeb79b6..00000000
--- a/library/src/com/orm/SugarConfig.java
+++ /dev/null
@@ -1,112 +0,0 @@
-package com.orm;
-
-import android.content.Context;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageManager;
-import android.util.Log;
-
-import java.lang.reflect.Field;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-public class SugarConfig {
-
-    static Map<Class<?>, List<Field>> fields = new HashMap<Class<?>, List<Field>>();
-
-    public static String getDatabaseName(Context context) {
-        String databaseName = getMetaDataString(context, "DATABASE");
-
-        if (databaseName == null) {
-            databaseName = "Sugar.db";
-        }
-
-        return databaseName;
-    }
-
-    public static void setFields(Class<?> clazz, List<Field> fieldz){
-         fields.put(clazz, fieldz);
-    }
-
-    public static List<Field> getFields(Class<?> clazz){
-
-        if(fields.containsKey(clazz)){
-            List<Field> list = fields.get(clazz);
-            return Collections.synchronizedList(list);
-        }
-
-        return null;
-    }
-
-    public static void clearCache(){
-        fields.clear();
-        fields = new HashMap<Class<?>, List<Field>>();
-    }
-
-    public static int getDatabaseVersion(Context context) {
-        Integer databaseVersion = getMetaDataInteger(context, "VERSION");
-
-        if ((databaseVersion == null) || (databaseVersion == 0)) {
-            databaseVersion = 1;
-        }
-
-        return databaseVersion;
-    }
-
-    public static String getDomainPackageName(Context context){
-        String domainPackageName = getMetaDataString(context, "DOMAIN_PACKAGE_NAME");
-
-        if (domainPackageName == null) {
-            domainPackageName = "";
-        }
-
-        return domainPackageName;
-    }
-
-    public static boolean getDebugEnabled(Context context) {
-        return getMetaDataBoolean(context, "QUERY_LOG");
-    }
-
-    public static String getMetaDataString(Context context, String name) {
-        String value = null;
-
-        PackageManager pm = context.getPackageManager();
-        try {
-            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(), 128);
-            value = ai.metaData.getString(name);
-        } catch (Exception e) {
-            Log.d("sugar", "Couldn't find config value: " + name);
-        }
-
-        return value;
-    }
-
-    public static Integer getMetaDataInteger(Context context, String name) {
-        Integer value = null;
-
-        PackageManager pm = context.getPackageManager();
-        try {
-            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(), 128);
-            value = ai.metaData.getInt(name);
-        } catch (Exception e) {
-            Log.d("sugar", "Couldn't find config value: " + name);
-        }
-
-        return value;
-    }
-
-    public static Boolean getMetaDataBoolean(Context context, String name) {
-        Boolean value = false;
-
-        PackageManager pm = context.getPackageManager();
-        try {
-            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(), 128);
-            value = ai.metaData.getBoolean(name);
-        } catch (Exception e) {
-            Log.d("sugar", "Couldn't find config value: " + name);
-        }
-
-        return value;
-    }
-}
diff --git a/library/src/com/orm/SugarContext.java b/library/src/com/orm/SugarContext.java
new file mode 100644
index 00000000..ea853766
--- /dev/null
+++ b/library/src/com/orm/SugarContext.java
@@ -0,0 +1,50 @@
+package com.orm;
+
+import android.content.Context;
+
+public class SugarContext {
+
+    private static SugarContext instance = null;
+    private SugarDb sugarDb;
+    private Context context;
+
+    private SugarContext(Context context) {
+        this.context = context;
+        this.sugarDb = new SugarDb(context);
+    }
+    
+    public static SugarContext getSugarContext() {
+        if (instance == null) {
+            throw new NullPointerException("SugarContext has not been initialized properly. Call SugarContext.init(Context) in your Application.onCreate() method and SugarContext.terminate() in your Application.onTerminate() method.");
+        }
+        return instance;
+    }
+
+    public static void init(Context context) {
+        instance = new SugarContext(context);
+    }
+
+    public static void terminate() {
+        if (instance == null) {
+            return;
+        }
+        instance.doTerminate();
+    }
+
+    /*
+     * Per issue #106 on Github, this method won't be called in
+     * any real Android device. This method is used purely in
+     * emulated process environments such as an emulator or
+     * Robolectric Android mock.
+     */
+    private void doTerminate() {
+        if (this.sugarDb != null) {
+            this.sugarDb.getDB().close();
+        }
+    }
+
+    protected SugarDb getSugarDb() {
+        return sugarDb;
+    }
+
+}
diff --git a/library/src/com/orm/SugarDb.java b/library/src/com/orm/SugarDb.java
index f58450b9..6158b20c 100644
--- a/library/src/com/orm/SugarDb.java
+++ b/library/src/com/orm/SugarDb.java
@@ -1,210 +1,43 @@
 package com.orm;
 
 import android.content.Context;
-import android.content.pm.PackageManager;
 import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteException;
 import android.database.sqlite.SQLiteOpenHelper;
-import android.util.Log;
-import dalvik.system.DexFile;
 
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Modifier;
-import java.util.*;
+import com.orm.util.ManifestHelper;
+import com.orm.util.SugarCursorFactory;
 
-import static com.orm.SugarConfig.getDatabaseVersion;
-import static com.orm.SugarConfig.getDebugEnabled;
+import static com.orm.util.ManifestHelper.getDatabaseVersion;
+import static com.orm.util.ManifestHelper.getDebugEnabled;
 
 public class SugarDb extends SQLiteOpenHelper {
-    private Context context;
 
-    public SugarDb(Context context) {
-        super(context, SugarConfig.getDatabaseName(context), new SugarCursorFactory(getDebugEnabled(context)), getDatabaseVersion(context));
-        this.context = context;
-    }
-
-    private <T extends SugarRecord<?>> List<T> getDomainClasses(Context context) {
-        List<T> domainClasses = new ArrayList<T>();
-        try {
-            Enumeration<?> allClasses = getAllClasses(context);
-
-            while (allClasses.hasMoreElements()) {
-                String className = (String) allClasses.nextElement();
-
-                if (className.startsWith(SugarConfig.getDomainPackageName(context))) {
-                    T domainClass = getDomainClass(className, context);
-                    if (domainClass != null) domainClasses.add(domainClass);
-                }
-            }
-
-        } catch (IOException e) {
-            Log.e("Sugar", e.getMessage());
-        } catch (PackageManager.NameNotFoundException e) {
-            Log.e("Sugar", e.getMessage());
-        }
-
-        return domainClasses;
-    }
-
-    @SuppressWarnings("unchecked")
-    private <T extends SugarRecord<?>> T getDomainClass(String className, Context context) {
-        Log.i("Sugar", "domain class: " + className);
-        Class<?> discoveredClass = null;
-        try {
-            discoveredClass = Class.forName(className, true, context.getClass().getClassLoader());
-        } catch (ClassNotFoundException e) {
-            Log.e("Sugar", e.getMessage());
-        }
+    private final SchemaGenerator schemaGenerator;
+    private SQLiteDatabase sqLiteDatabase;
 
-        if ((discoveredClass == null) ||
-                (!SugarRecord.class.isAssignableFrom(discoveredClass)) ||
-                Modifier.isAbstract(discoveredClass.getModifiers())) {
-            return null;
-        } else {
-            try {
-                return (T) discoveredClass.getDeclaredConstructor().newInstance();
-            } catch (InstantiationException e) {
-                Log.e("Sugar", e.getMessage());
-            } catch (IllegalAccessException e) {
-                Log.e("Sugar", e.getMessage());
-            } catch (NoSuchMethodException e) {
-                Log.e("Sugar", e.getMessage());
-            } catch (InvocationTargetException e) {
-                Log.e("Sugar", e.getMessage());
-            }
-        }
-
-        return null;
-    }
-
-    private Enumeration<?> getAllClasses(Context context) throws PackageManager.NameNotFoundException, IOException {
-        String path = getSourcePath(context);
-        DexFile dexfile = new DexFile(path);
-        return dexfile.entries();
-    }
-
-    private String getSourcePath(Context context) throws PackageManager.NameNotFoundException {
-        return context.getPackageManager().getApplicationInfo(context.getPackageName(), 0).sourceDir;
+    public SugarDb(Context context) {
+        super(context, ManifestHelper.getDatabaseName(context),
+                new SugarCursorFactory(getDebugEnabled(context)), getDatabaseVersion(context));
+        schemaGenerator = new SchemaGenerator(context);
     }
 
     @Override
     public void onCreate(SQLiteDatabase sqLiteDatabase) {
-        Log.i("Sugar", "on create");
-        createDatabase(sqLiteDatabase);
-    }
-
-    public <T extends SugarRecord<?>> void createDatabase(SQLiteDatabase sqLiteDatabase) {
-        List<T> domainClasses = getDomainClasses(context);
-        for (T domain : domainClasses) {
-            createTable(domain, sqLiteDatabase);
-        }
-    }
-
-    private <T extends SugarRecord<?>> void createTable(T table, SQLiteDatabase sqLiteDatabase) {
-        List<Field> fields = table.getTableFields();
-        StringBuilder sb = new StringBuilder("CREATE TABLE ").append(table.getSqlName()).append(
-                " ( ID INTEGER PRIMARY KEY AUTOINCREMENT ");
-
-        for (Field column : fields) {
-            String columnName = StringUtil.toSQLName(column.getName());
-            String columnType = QueryBuilder.getColumnType(column.getType());
-
-            if (columnType != null) {
-
-                if (columnName.equalsIgnoreCase("Id")) {
-                    continue;
-                }
-                sb.append(", ").append(columnName).append(" ").append(columnType);
-            }
-        }
-        sb.append(" ) ");
-
-        Log.i("Sugar", "creating table: " + table.getSqlName());
-
-        if (!"".equals(sb.toString()))
-            sqLiteDatabase.execSQL(sb.toString());
+        schemaGenerator.createDatabase(sqLiteDatabase);
     }
 
     @Override
     public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
-        Log.i("Sugar", "upgrading sugar");
-        // check if some tables are to be created
-        doUpgrade(sqLiteDatabase);
-
-        if (!executeSugarUpgrade(sqLiteDatabase, oldVersion, newVersion)) {
-            deleteTables(sqLiteDatabase);
-            onCreate(sqLiteDatabase);
-        }
+        schemaGenerator.doUpgrade(sqLiteDatabase, oldVersion, newVersion);
     }
 
-    /**
-     * Create the tables that do not exist.
-     */
-    private <T extends SugarRecord<?>> void doUpgrade(SQLiteDatabase sqLiteDatabase) {
-        List<T> domainClasses = getDomainClasses(context);
-        for (T domain : domainClasses) {
-            try {// we try to do a select, if fails then (?) there isn't the table
-                sqLiteDatabase.query(domain.tableName, null, null, null, null, null, null);
-            } catch (SQLiteException e) {
-                Log.i("Sugar", String.format("creating table on update (error was '%s')", e.getMessage()));
-                createTable(domain, sqLiteDatabase);
-            }
+    public synchronized SQLiteDatabase getDB() {
+        if (this.sqLiteDatabase == null) {
+            this.sqLiteDatabase = getWritableDatabase();
         }
-    }
 
     public <T extends SugarRecord<?>> void deleteTables(SQLiteDatabase sqLiteDatabase) {
-        List<T> tables = getDomainClasses(this.context);
-        for (T table : tables) {
-            Log.i("Sugar", "dropping table: " + table.getSqlName());
-            sqLiteDatabase.execSQL("DROP TABLE IF EXISTS " + table.getSqlName());
-        }
+        return this.sqLiteDatabase;
     }
 
-    private boolean executeSugarUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-
-        boolean isSuccess = false;
-        try {
-            List<String> files = Arrays.asList(this.context.getAssets().list("sugar_upgrades"));
-            Collections.sort(files, new NumberComparator());
-
-            for (String file : files){
-                Log.i("Sugar", "filename: " + file);
-                try {
-                    int version = Integer.valueOf(file.replace(".sql", ""));
-
-                    if ((version > oldVersion) && (version <= newVersion)) {
-                        executeScript(db, file);
-                        isSuccess = true;
-                    }
-                } catch (NumberFormatException e) {
-                    Log.i("Sugar", "not a sugar script. ignored." + file);
-                }
-            }
-        } catch (IOException e) {
-            Log.e("Sugar", e.getMessage());
-        }
-
-        return isSuccess;
-    }
-
-    private void executeScript(SQLiteDatabase db, String file) {
-        try {
-            InputStream is = this.context.getAssets().open("sugar_upgrades/" + file);
-            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
-            String line;
-            while ((line = reader.readLine()) != null) {
-                Log.i("Sugar script", line);
-                db.execSQL(line.toString());
-            }
-        } catch (IOException e) {
-            Log.e("Sugar", e.getMessage());
-        }
-
-        Log.i("Sugar", "script executed: " + file);
-    }
 }
diff --git a/library/src/com/orm/SugarRecord.java b/library/src/com/orm/SugarRecord.java
index 0b84d141..e8174ce4 100644
--- a/library/src/com/orm/SugarRecord.java
+++ b/library/src/com/orm/SugarRecord.java
@@ -4,32 +4,27 @@
 import android.database.Cursor;
 import android.database.DatabaseUtils;
 import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteException;
 import android.database.sqlite.SQLiteStatement;
 import android.net.Uri;
 import android.text.TextUtils;
 import android.util.Log;
-import com.orm.dsl.Ignore;
+import com.orm.dsl.Table;
+import com.orm.util.NamingHelper;
+import com.orm.util.ReflectionUtil;
 
 import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.sql.Timestamp;
 import java.util.*;
 
-import static com.orm.SugarApp.getSugarContext;
+import static com.orm.SugarContext.getSugarContext;
 
-public class SugarRecord<T>{
-
-    @Ignore
-    String tableName = getSqlName();
+public class SugarRecord {
 
     protected Long id = null;
 
     public void delete() {
         if (id != null)
         {
-            SQLiteDatabase db = getSugarContext().getDatabase().getDB();
+            SQLiteDatabase db = getSugarContext().getSugarDb().getDB();
             db.delete(this.tableName, "Id=?", new String[]{getId().toString()});
             Log.i("Sugar", getClass().getSimpleName() + " deleted: " + id);
             id = null;
@@ -37,171 +32,88 @@ public void delete() {
     }
 
     public static <T extends SugarRecord<?>> void deleteAll(Class<T> type) {
-        Database db = getSugarContext().getDatabase();
+        SugarDb db = getSugarContext().getSugarDb();
         SQLiteDatabase sqLiteDatabase = db.getDB();
-        sqLiteDatabase.delete(getTableName(type), null, null);
+        sqLiteDatabase.delete(NamingHelper.toSQLName(type), null, null);
     }
 
-    public static <T extends SugarRecord<?>> void deleteAll(Class<T> type, String whereClause, String... whereArgs ) {
-        Database db = getSugarContext().getDatabase();
+    public static <T> void deleteAll(Class<T> type, String whereClause, String... whereArgs) {
+        SugarDb db = getSugarContext().getSugarDb();
         SQLiteDatabase sqLiteDatabase = db.getDB();
-        sqLiteDatabase.delete(getTableName(type), whereClause, whereArgs);
+        sqLiteDatabase.delete(NamingHelper.toSQLName(type), whereClause, whereArgs);
     }
 
     public static <T extends SugarRecord<?>> void deleteById(Class<T> type, Long id) {
-        Database db = getSugarContext().getDatabase();
+        Database db = getSugarContext().getSugarDb();
         SQLiteDatabase sqLiteDatabase = db.getDB();
         sqLiteDatabase.delete(getTableName(type), "id=?", new String[]{String.valueOf(id)});
     }
     
-    public void save() {
-        save(getSugarContext().getDatabase().getDB());
-    }
-
-    public static <T extends SugarRecord<?>> void saveInTx(T... objects ) {
+    public static <T> void saveInTx(T... objects) {
         saveInTx(Arrays.asList(objects));
     }
 
     @SuppressWarnings("deprecation")
-    public static <T extends SugarRecord<?>> void saveInTx(Collection<T> objects ) {
-        SQLiteDatabase sqLiteDatabase = getSugarContext().getDatabase().getDB();
-
-        try{
+    public static <T> void saveInTx(Collection<T> objects) {
+        SQLiteDatabase sqLiteDatabase = getSugarContext().getSugarDb().getDB();
+        try {
             sqLiteDatabase.beginTransaction();
             sqLiteDatabase.setLockingEnabled(false);
-            for(T object: objects){
-                object.save(sqLiteDatabase);
+            for (T object: objects) {
+                SugarRecord.save(object);
             }
             sqLiteDatabase.setTransactionSuccessful();
-        }catch (Exception e){
+        } catch (Exception e) {
             Log.i("Sugar", "Error in saving in transaction " + e.getMessage());
-        }finally {
+        } finally {
             sqLiteDatabase.endTransaction();
             sqLiteDatabase.setLockingEnabled(true);
         }
-
-    }
-
-    protected void save(SQLiteDatabase db) {
-
-        List<Field> columns = getTableFields();
-        ContentValues values = new ContentValues(columns.size());
-        for (Field column : columns) {
-            column.setAccessible(true);
-
-            try {
-                Class<?> columnType = column.getType();
-                String columnName = StringUtil.toSQLName(column.getName());
-                Object columnValue = column.get(this);
-                
-                if (SugarRecord.class.isAssignableFrom(columnType)) {
-                    values.put(columnName, (columnValue != null) ? String.valueOf(((SugarRecord<?>) columnValue).id) : "0");
-                } else {
-                    if (!"id".equalsIgnoreCase(columnName)) {
-                        if (columnValue == null) {
-                            values.putNull(columnName);
-                        }
-                        else if (columnType.equals(Byte.class) || columnType.equals(byte.class)) {
-                            values.put(columnName, (Byte) columnValue);
-                        } 
-                        else if (columnType.equals(Short.class) || columnType.equals(short.class)) {
-                            values.put(columnName, (Short) columnValue);
-                        } 
-                        else if (columnType.equals(Integer.class) || columnType.equals(int.class)) {
-                            values.put(columnName, (Integer) columnValue);
-                        }
-                        else if (columnType.equals(Long.class) || columnType.equals(long.class)) {
-                            values.put(columnName, (Long) columnValue);
-                        }
-                        else if (columnType.equals(Float.class) || columnType.equals(float.class)) {
-                            values.put(columnName, (Float) columnValue);
-                        }
-                        else if (columnType.equals(Double.class) || columnType.equals(double.class)) {
-                            values.put(columnName, (Double) columnValue);
-                        }
-                        else if (columnType.equals(Boolean.class) || columnType.equals(boolean.class)) {
-                            values.put(columnName, (Boolean) columnValue);
-                        } 
-                        else if (columnType.equals(Character.class) || columnType.equals(char.class)) {
-                            values.put(columnName, (Integer) (int) ((Character) columnValue).charValue());
-                        }
-                        else if (columnType.equals(Date.class)) {
-                            values.put(columnName, columnValue != null ? ((Date) columnValue).getTime() : null);
-                        }
-                        else if (columnType.equals(Calendar.class)) {
-                            values.put(columnName, columnValue != null ? ((Calendar) columnValue).getTimeInMillis() : null);
-                        }
-                        else if (columnType.equals(Uri.class)) {
-                            values.put(columnName, columnValue.toString());
-                        }
-                        else if (columnType.equals(byte[].class)) {
-                            values.put(columnName, (byte[]) columnValue);
-                        }
-                        else {
-                            values.put(columnName, String.valueOf(columnValue));
-                        }
-                    }
-                }
-
-            } catch (IllegalAccessException e) {
-                Log.e("Sugar", e.getMessage());
-            }
-        }
-
-        if (id == null) {
-            id = db.insertOrThrow(getSqlName(), null, values);
-            Log.i("Sugar", getClass().getSimpleName() + " saved: " + id);
-        } else {
-            db.update(getSqlName(), values, "ID = ?", new String[]{String.valueOf(id)});
-            Log.i("Sugar", getClass().getSimpleName() + " updated: " + id);
-        }
     }
 
-    public static <T extends SugarRecord<?>> List<T> listAll(Class<T> type) {
+    public static <T> List<T> listAll(Class<T> type) {
         return find(type, null, null, null, null, null);
     }
 
-    public static <T extends SugarRecord<?>> T findById(Class<T> type, Long id) {
-        List<T> list = find( type, "id=?", new String[]{String.valueOf(id)}, null, null, "1");
+    public static <T> T findById(Class<T> type, Long id) {
+        List<T> list = find(type, "id=?", new String[]{String.valueOf(id)}, null, null, "1");
         if (list.isEmpty()) return null;
         return list.get(0);
     }
 
-    public static <T extends SugarRecord<?>> Iterator<T> findAll(Class<T> type) {
+    public static <T> T findById(Class<T> type, Integer id) {
+        return findById(type, Long.valueOf(id));
+    }
+
+    public static <T> Iterator<T> findAll(Class<T> type) {
         return findAsIterator(type, null, null, null, null, null);
     }
 
-    public static <T extends SugarRecord<?>> Iterator<T> findAsIterator(Class<T> type,
-                                                                        String whereClause, String... whereArgs) {
+    public static <T> Iterator<T> findAsIterator(Class<T> type, String whereClause, String... whereArgs) {
         return findAsIterator(type, whereClause, whereArgs, null, null, null);
     }
 
-    public static <T extends SugarRecord<?>> Iterator<T> findWithQueryAsIterator(Class<T> type, String query, String... arguments) {
-        Database db = getSugarContext().getDatabase();
+    public static <T> Iterator<T> findWithQueryAsIterator(Class<T> type, String query, String... arguments) {
+        SugarDb db = getSugarContext().getSugarDb();
         SQLiteDatabase sqLiteDatabase = db.getDB();
         Cursor c = sqLiteDatabase.rawQuery(query, arguments);
         return new CursorIterator<T>(type, c);
     }
 
-    public static <T extends SugarRecord<?>> Iterator<T> findAsIterator(Class<T> type,
-                                                                    String whereClause, String[] whereArgs,
-                                                                    String groupBy, String orderBy, String limit) {
-
-        Database db = getSugarContext().getDatabase();
+    public static <T> Iterator<T> findAsIterator(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
+        SugarDb db = getSugarContext().getSugarDb();
         SQLiteDatabase sqLiteDatabase = db.getDB();
-        Cursor c = sqLiteDatabase.query(getTableName(type), null,
-                whereClause, whereArgs, groupBy, null, orderBy, limit);
+        Cursor c = sqLiteDatabase.query(NamingHelper.toSQLName(type), null, whereClause, whereArgs,
+                groupBy, null, orderBy, limit);
         return new CursorIterator<T>(type, c);
     }
 
-    public static <T extends SugarRecord<?>> List<T> find(Class<T> type,
-                                                       String whereClause, String... whereArgs) {
+    public static <T> List<T> find(Class<T> type, String whereClause, String... whereArgs) {
         return find(type, whereClause, whereArgs, null, null, null);
     }
 
-    public static <T extends SugarRecord<?>> List<T> findWithQuery(Class<T> type, String query, String... arguments){
-
-        Database db = getSugarContext().getDatabase();
+    public static <T> List<T> findWithQuery(Class<T> type, String query, String... arguments) {
+        SugarDb db = getSugarContext().getSugarDb();
         SQLiteDatabase sqLiteDatabase = db.getDB();
         T entity;
         List<T> toRet = new ArrayList<T>();
@@ -210,7 +122,7 @@ else if (columnType.equals(byte[].class)) {
         try {
             while (c.moveToNext()) {
                 entity = type.getDeclaredConstructor().newInstance();
-                entity.inflate(c);
+                SugarRecord.inflate(c, entity);
                 toRet.add(entity);
             }
         } catch (Exception e) {
@@ -218,26 +130,25 @@ else if (columnType.equals(byte[].class)) {
         } finally {
             c.close();
         }
+
         return toRet;
     }
 
-    public static void executeQuery(String query, String... arguments){
-        getSugarContext().getDatabase().getDB().execSQL(query, arguments);
+    public static void executeQuery(String query, String... arguments) {
+        getSugarContext().getSugarDb().getDB().execSQL(query, arguments);
     }
 
-    public static <T extends SugarRecord<?>> List<T> find(Class<T> type,
-                                                       String whereClause, String[] whereArgs,
-                                                       String groupBy, String orderBy, String limit) {
-        Database db = getSugarContext().getDatabase();
+    public static <T> List<T> find(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
+        SugarDb db = getSugarContext().getSugarDb();
         SQLiteDatabase sqLiteDatabase = db.getDB();
         T entity;
         List<T> toRet = new ArrayList<T>();
-        Cursor c = sqLiteDatabase.query(getTableName(type), null,
-                whereClause, whereArgs, groupBy, null, orderBy, limit);
+        Cursor c = sqLiteDatabase.query(NamingHelper.toSQLName(type), null, whereClause, whereArgs,
+                groupBy, null, orderBy, limit);
         try {
             while (c.moveToNext()) {
                 entity = type.getDeclaredConstructor().newInstance();
-                entity.inflate(c);
+                SugarRecord.inflate(c, entity);
                 toRet.add(entity);
             }
         } catch (Exception e) {
@@ -247,37 +158,22 @@ public static void executeQuery(String query, String... arguments){
         }
         return toRet;
     }
-    
-    public static <T extends SugarRecord<?>> long count(Class<T> type){
-        return count(type, null, new String[]{});
-    }
 
-    public static <T extends SugarRecord<?>> long count(Class<T> type, String query){
-        return count(type, query, new String[]{});
+    public static <T> long count(Class<?> type) {
+        return count(type, null, null, null, null, null);
     }
 
-    public static <T extends SugarRecord<?>> long count(Class<T> type, String query, String... arguments){
-         Database db = getSugarContext().getDatabase();
-         SQLiteDatabase sqLiteDatabase = db.getDB();
-         String table = getTableName(type);
-         try {
-             return DatabaseUtils.queryNumEntries(sqLiteDatabase, table, query, arguments);
-         } catch (Exception e) {
-             e.printStackTrace();
-             return -1;
-         } 
+    public static <T> long count(Class<?> type, String whereClause, String[] whereArgs) {
+    	return count(type, whereClause, whereArgs, null, null, null);
     }
-    
-    public static <T extends SugarRecord<?>> long count(Class<?> type,
-            String whereClause, String[] whereArgs,
-            String groupBy, String orderBy, String limit) {
-    	
-    	Database db = getSugarContext().getDatabase();
+
+    public static <T> long count(Class<?> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
+        SugarDb db = getSugarContext().getSugarDb();
         SQLiteDatabase sqLiteDatabase = db.getDB();
 
         long toRet = -1;
         String filter = (!TextUtils.isEmpty(whereClause)) ? " where "  + whereClause : "";
-        SQLiteStatement sqLiteStatament = sqLiteDatabase.compileStatement("SELECT count(*) FROM " + getTableName(type) + filter);
+        SQLiteStatement sqLiteStatament = sqLiteDatabase.compileStatement("SELECT count(*) FROM " + NamingHelper.toSQLName(type) + filter);
 
         if (whereArgs != null) {
             for (int i = whereArgs.length; i != 0; i--) {
@@ -292,175 +188,62 @@ public static void executeQuery(String query, String... arguments){
         } finally {
             sqLiteStatament.close();
         }
-        
+
         return toRet;
     }
 
-    @SuppressWarnings("unchecked")
-    protected void inflate(Cursor cursor) {
-        Map<Field, Long> entities = new HashMap<Field, Long>();
-        List<Field> columns = getTableFields();
-        for (Field field : columns) {
-            field.setAccessible(true);
-            try {
-                Class<?> fieldType = field.getType();
-                String colName = StringUtil.toSQLName(field.getName());
-                int index = cursor.getColumnIndex(colName);
-                
-                if (cursor.isNull(index)) {
-                    field.set(this, null);
-                } 
-                else if(colName.equalsIgnoreCase("id")){
-                    long cid = cursor.getLong(index);
-                    field.set(this, Long.valueOf(cid));
-                }
-                else if (fieldType.equals(long.class)) {
-                    field.set(this, cursor.getLong(index));
-                } 
-                else if (fieldType.equals(Long.class)) {
-                    field.set(this, (Long) cursor.getLong(index));
-                } 
-                else if (fieldType.equals(String.class)) {
-                    String val = cursor.getString(index);
-                    field.set(this, val != null && val.equals("null") ? null : val);
-                } 
-                else if (fieldType.equals(double.class)) {
-                    field.set(this, cursor.getDouble(index));
-                } 
-                else if (fieldType.equals(Double.class)) {
-                    field.set(this, (Double) cursor.getDouble(index));
-                } 
-                else if (fieldType.equals(boolean.class) || fieldType.equals(Boolean.class)) {
-                    field.set(this, Boolean.parseBoolean(cursor.getString(index)) || cursor.getString(index).equals("1"));
-                } 
-                else if (fieldType.equals(byte[].class)) {
-                    field.set(this, cursor.getBlob(index));
-                } 
-                else if (fieldType.equals(int.class)) {
-                    field.set(this, cursor.getInt(index));
-                } 
-                else if (fieldType.equals(Integer.class)) {
-                    field.set(this, (Integer) cursor.getInt(index));
-                } 
-                else if (fieldType.equals(float.class)) {
-                    field.set(this, cursor.getFloat(index));
-                } 
-                else if (fieldType.equals(Float.class)) {
-                    field.set(this, (Float) cursor.getFloat(index));
-                } 
-                else if (fieldType.equals(short.class)) {
-                    field.set(this, cursor.getShort(index));
-                } 
-                else if (fieldType.equals(Short.class)) {
-                    field.set(this, (Short) cursor.getShort(index));
-                } 
-                else if (fieldType.equals(byte.class)) {
-                    field.set(this, (byte) cursor.getShort(index));
-                } 
-                else if (fieldType.equals(Byte.class)) {
-                    field.set(this, (Byte) (byte) cursor.getShort(index));
-                } 
-                else if (fieldType.equals(char.class)) {
-                    field.set(this, (char) cursor.getInt(index));
-                } 
-                else if (fieldType.equals(Character.class)) {
-                    field.set(this, (Character) (char) cursor.getInt(index));
-                } 
-                else if (fieldType.equals(Uri.class)) {
-                    String uri = cursor.getString(index);
-                    field.set(this, Uri.parse(uri));
-                } 
-                else if (fieldType.equals(Timestamp.class)) {
-                    long l = cursor.getLong(index);
-                    field.set(this, new Timestamp(l));
-                } 
-                else if (fieldType.equals(Date.class)) {
-                    long l = cursor.getLong(index);
-                    field.set(this, new Date(l));
-                } 
-                else if (fieldType.equals(Calendar.class)) {
-                    long l = cursor.getLong(index);
-                    Calendar c = Calendar.getInstance();
-                    c.setTimeInMillis(l);
-                    field.set(this, c);
-                } 
-                else if (Enum.class.isAssignableFrom(fieldType)) {
-                    try {
-                        Method valueOf = fieldType.getMethod("valueOf", String.class);
-                        String strVal = cursor.getString(index);
-                        Object enumVal = valueOf.invoke(fieldType, strVal);
-                        field.set(this, enumVal);
-                    } catch (Exception e) {
-                        Log.e("Sugar", "Enum cannot be read from Sqlite3 database. Please check the type of field " + field.getName());
-                    }
-                } 
-                else if (SugarRecord.class.isAssignableFrom(fieldType)) {
-                    long id = cursor.getLong(index);
-                    if (id > 0)
-                        entities.put(field, id);
-                    else
-                        field.set(this, null);
-                } 
-                else if (field.getName() == "shadow$_klass_")
-                {
-                    // skip this, it's generated by ART
-                }
-                else
-                    Log.e("Sugar", "Class cannot be read from Sqlite3 database. Please check the type of field " + field.getName() + " (" + fieldType.getName() + ")");
-            } catch (IllegalArgumentException e) {
-                Log.e("Sugar", "Field set error (IllegalArgumentException). Please check the field " + field.getName());
-            } catch (IllegalAccessException e) {
-                Log.e("Sugar", "Field set error (IllegalAccessException). Please check the field " + field.getName());
-            }
-        }
-
-        for (Field f : entities.keySet()) {
-            try {
-                f.set(this, findById((Class<? extends SugarRecord<?>>) f.getType(), entities.get(f)));
-            } catch (SQLiteException e) {
-            } catch (IllegalArgumentException e) {
-            } catch (IllegalAccessException e) {
-            }
-        }
+    public static long save(Object object) {
+        return save(getSugarContext().getSugarDb().getDB(), object);
     }
 
-    public List<Field> getTableFields() {
-        List<Field> fieldList = SugarConfig.getFields(getClass());
-        if(fieldList != null) return fieldList;
-
-        Log.d("Sugar", "fetching properties for " + getClass().getSimpleName());
-        List<Field> typeFields = new ArrayList<Field>();
+    static long save(SQLiteDatabase db, Object object) {
+        List<Field> columns = ReflectionUtil.getTableFields(object.getClass());
+        ContentValues values = new ContentValues(columns.size());
+        for (Field column : columns) {
+            ReflectionUtil.addFieldValueToColumn(values, column, object);
+        }
 
-        getAllFields(typeFields, getClass());
+        long id = db.insertWithOnConflict(NamingHelper.toSQLName(object.getClass()), null, values,
+                SQLiteDatabase.CONFLICT_REPLACE);
 
-        List<Field> toStore = new ArrayList<Field>();
-        for (Field field : typeFields) {
-            if (!field.isAnnotationPresent(Ignore.class) && !Modifier.isStatic(field.getModifiers())&& !Modifier.isTransient(field.getModifiers())) {
-                toStore.add(field);
-            }
+        if (SugarRecord.class.isAssignableFrom(object.getClass())) {
+            ReflectionUtil.setFieldValueForId(object, id);
         }
+        Log.i("Sugar", object.getClass().getSimpleName() + " saved : " + id);
 
-        SugarConfig.setFields(getClass(), toStore);
-        return toStore;
+        return id;
     }
 
-    private static List<Field> getAllFields(List<Field> fields, Class<?> type) {
-        Collections.addAll(fields, type.getDeclaredFields());
+    private static void inflate(Cursor cursor, Object object) {
+        List<Field> columns = ReflectionUtil.getTableFields(object.getClass());
 
-        if (type.getSuperclass() != null) {
-            fields = getAllFields(fields, type.getSuperclass());
+        for (Field field : columns) {
+            if (field.getClass().isAnnotationPresent(Table.class)) {
+                try {
+                    long id = cursor.getLong(cursor.getColumnIndex(NamingHelper.toSQLName(field)));
+                    field.set(object, (id > 0) ? findById(field.getType(), id) : null);
+                } catch (IllegalAccessException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                ReflectionUtil.setFieldValueFromCursor(cursor, field, object);
+            }
         }
-
-        return fields;
     }
 
-    public String getSqlName() {
-        return getTableName(getClass());
+    public void delete() {
+        SQLiteDatabase db = getSugarContext().getSugarDb().getDB();
+        db.delete(NamingHelper.toSQLName(getClass()), "Id=?", new String[]{getId().toString()});
+        Log.i("Sugar", getClass().getSimpleName() + " deleted : " + getId().toString());
     }
 
+    public long save() {
+        return save(getSugarContext().getSugarDb().getDB(), this);
+    }
 
-    public static String getTableName(Class<?> type) {
-        return StringUtil.toSQLName(type.getSimpleName());
+    @SuppressWarnings("unchecked")
+    void inflate(Cursor cursor) {
+        inflate(cursor, this);
     }
 
     public Long getId() {
@@ -471,7 +254,7 @@ public void setId(Long id) {
         this.id = id;
     }
 
-    static class CursorIterator<E extends SugarRecord<?>> implements Iterator<E> {
+    static class CursorIterator<E> implements Iterator<E> {
         Class<E> type;
         Cursor cursor;
 
@@ -496,7 +279,7 @@ public E next() {
 
             try {
                 entity = type.getDeclaredConstructor().newInstance();
-                entity.inflate(cursor);
+                SugarRecord.inflate(cursor, entity);
             } catch (Exception e) {
                 e.printStackTrace();
             } finally {
@@ -505,6 +288,7 @@ public E next() {
                     cursor.close();
                 }
             }
+
             return entity;
         }
 
diff --git a/library/src/com/orm/SugarTransactionHelper.java b/library/src/com/orm/SugarTransactionHelper.java
index 505547df..0f2683f2 100644
--- a/library/src/com/orm/SugarTransactionHelper.java
+++ b/library/src/com/orm/SugarTransactionHelper.java
@@ -6,24 +6,27 @@
 public class SugarTransactionHelper {
 
     public static void doInTansaction(SugarTransactionHelper.Callback callback) {
-
-        SQLiteDatabase database = SugarApp.getSugarContext().getDatabase().getDB();
-
+        SQLiteDatabase database = SugarContext.getSugarContext().getSugarDb().getDB();
         database.beginTransaction();
 
         try {
-            Log.d(SugarTransactionHelper.class.getSimpleName(), "callback executing within transaction");
+            Log.d(SugarTransactionHelper.class.getSimpleName(),
+                    "Callback executing within transaction");
             callback.manipulateInTransaction();
             database.setTransactionSuccessful();
-            Log.d(SugarTransactionHelper.class.getSimpleName(), "callback successfully executed within transaction");
+            Log.d(SugarTransactionHelper.class.getSimpleName(),
+                    "Callback successfully executed within transaction");
         } catch (Throwable e) {
-            Log.d(SugarTransactionHelper.class.getSimpleName(), "could execute callback within transaction", e);
+            Log.d(SugarTransactionHelper.class.getSimpleName(),
+                    "Could execute callback within transaction", e);
         } finally {
             database.endTransaction();
         }
+
     }
 
     public static interface Callback {
         void manipulateInTransaction();
     }
+
 }
diff --git a/library/src/com/orm/dsl/Column.java b/library/src/com/orm/dsl/Column.java
new file mode 100644
index 00000000..2c47e3c0
--- /dev/null
+++ b/library/src/com/orm/dsl/Column.java
@@ -0,0 +1,11 @@
+package com.orm.dsl;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Column {
+    String name();
+    boolean unique() default false;
+    boolean notNull() default false;
+}
diff --git a/library/src/com/orm/dsl/NotNull.java b/library/src/com/orm/dsl/NotNull.java
new file mode 100644
index 00000000..b2361851
--- /dev/null
+++ b/library/src/com/orm/dsl/NotNull.java
@@ -0,0 +1,8 @@
+package com.orm.dsl;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+public @interface NotNull {
+}
diff --git a/library/src/com/orm/dsl/Table.java b/library/src/com/orm/dsl/Table.java
new file mode 100644
index 00000000..0dfaa18b
--- /dev/null
+++ b/library/src/com/orm/dsl/Table.java
@@ -0,0 +1,9 @@
+package com.orm.dsl;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Table {
+    String name() default "";
+}
diff --git a/library/src/com/orm/dsl/Unique.java b/library/src/com/orm/dsl/Unique.java
new file mode 100644
index 00000000..7384b749
--- /dev/null
+++ b/library/src/com/orm/dsl/Unique.java
@@ -0,0 +1,8 @@
+package com.orm.dsl;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Unique {
+}
diff --git a/library/src/com/orm/query/Condition.java b/library/src/com/orm/query/Condition.java
index 6838b843..989bd458 100644
--- a/library/src/com/orm/query/Condition.java
+++ b/library/src/com/orm/query/Condition.java
@@ -1,16 +1,22 @@
 package com.orm.query;
 
 public class Condition {
+
     private String property;
     private Object value;
     private Check check;
 
     enum Check {
-        EQUALS(" = "), GREATER_THAN(" > "), LESSER_THAN(" < "), NOT_EQUALS (" != "), LIKE(" LIKE "), NOT_LIKE(" NOT LIKE ");
+        EQUALS(" = "),
+        GREATER_THAN(" > "),
+        LESSER_THAN(" < "),
+        NOT_EQUALS (" != "),
+        LIKE(" LIKE "),
+        NOT_LIKE(" NOT LIKE ");
+
         private String symbol;
 
         Check(String symbol) {
-
             this.symbol = symbol;
         }
 
@@ -20,48 +26,50 @@ public String getSymbol() {
     }
 
     enum Type {
-        AND, OR, NOT
+        AND,
+        OR,
+        NOT
     }
 
     public Condition(String property) {
         this.property = property;
     }
 
-    public static Condition prop(String property){
+    public static Condition prop(String property) {
         return new Condition(property);
     }
 
-    public Condition eq(Object value){
+    public Condition eq(Object value) {
         this.value = value;
         check = Check.EQUALS;
         return this;
     }
 
-    public Condition like(Object value){
+    public Condition like(Object value) {
         this.value = value;
         check = Check.LIKE;
         return this;
     }
 
-    public Condition notLike(Object value){
+    public Condition notLike(Object value) {
         this.value = value;
         check = Check.NOT_LIKE;
         return this;
     }
 
-    public Condition notEq(Object value){
+    public Condition notEq(Object value) {
         this.value = value;
         check = Check.NOT_EQUALS;
         return this;
     }
 
-    public Condition gt(Object value){
+    public Condition gt(Object value) {
         this.value = value;
         check = Check.GREATER_THAN;
         return this;
     }
 
-    public Condition lt(Object value){
+    public Condition lt(Object value) {
         this.value = value;
         check = Check.LESSER_THAN;
         return this;
@@ -79,7 +87,8 @@ public Check getCheck() {
         return check;
     }
 
-    public String getCheckSymbol(){
+    public String getCheckSymbol() {
         return check.getSymbol();
     }
+
 }
diff --git a/library/src/com/orm/query/Select.java b/library/src/com/orm/query/Select.java
index 2c82bb65..1e353906 100644
--- a/library/src/com/orm/query/Select.java
+++ b/library/src/com/orm/query/Select.java
@@ -1,12 +1,13 @@
 package com.orm.query;
 
 import com.orm.SugarRecord;
+import com.orm.util.NamingHelper;
 
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
-public class Select<T extends SugarRecord<?>> implements Iterable<T> {
+public class Select<T> implements Iterable {
 
     private Class<T> record;
     private String[] arguments;
@@ -15,14 +16,13 @@
     private String groupBy;
     private String limit;
     private String offset;
-
     private List<Object> args = new ArrayList<Object>();
 
     public Select(Class<T> record) {
         this.record = record;
     }
 
-    public static <T extends SugarRecord<T>> Select<T> from(Class<T> record) {
+    public static <T> Select<T> from(Class<T> record) {
         return new Select<T>(record);
     }
 
@@ -41,8 +41,6 @@ public Select(Class<T> record) {
         return this;
     }
 
-
-
     public Select<T> where(String whereClause) {
         this.whereClause = whereClause;
         return this;
@@ -56,22 +54,35 @@ public Select(Class<T> record) {
     }
 
     private void mergeConditions(Condition[] conditions, Condition.Type type) {
+        StringBuilder toAppend = new StringBuilder("");
         for (Condition condition : conditions) {
-
-            if (!"".equals(whereClause)) {
-                whereClause += " " + type.name() + " ";
+            if (toAppend.length() != 0) {
+                toAppend.append(" ").append(type.name()).append(" ");
             }
 
-            if(Condition.Check.LIKE.equals(condition.getCheck()) || Condition.Check.NOT_LIKE.equals(condition.getCheck())){
-
-                whereClause += condition.getProperty() + condition.getCheckSymbol() + "'" + condition.getValue().toString() +"'";
-
-            }else{
-
-                whereClause += condition.getProperty() + condition.getCheckSymbol() + "? ";
+            if (Condition.Check.LIKE.equals(condition.getCheck()) ||
+                    Condition.Check.NOT_LIKE.equals(condition.getCheck())) {
+                toAppend
+                    .append(condition.getProperty())
+                    .append(condition.getCheckSymbol())
+                    .append("'")
+                    .append(condition.getValue().toString())
+                    .append("'");
+
+            } else {
+                toAppend
+                    .append(condition.getProperty())
+                    .append(condition.getCheckSymbol())
+                    .append("? ");
                 args.add(condition.getValue());
             }
         }
+        
+        if (!"".equals(whereClause)) {
+            whereClause += " " + type.name() + " ";
+        }
+
+        whereClause += "(" + toAppend + ")";
     }
 
     public Select<T> whereOr(Condition... args) {
@@ -96,51 +107,48 @@ private void mergeConditions(Condition[] conditions, Condition.Type type) {
     }
 
     public List<T> list() {
+        if (arguments == null) {
+            arguments = convertArgs(args);
+        }
 
-        if(arguments == null) arguments = convertArgs(args);
-
-        return T.find(record, whereClause, arguments, groupBy, orderBy, limit);
-
+        return SugarRecord.find(record, whereClause, arguments, groupBy, orderBy, limit);
     }
     
     public long count() {
+        if (arguments == null) {
+            arguments = convertArgs(args);
+        }
     	
-    	if(arguments == null) arguments = convertArgs(args);
-    	
-    	return SugarRecord.count(record, whereClause, arguments, groupBy, orderBy, limit);
+        return SugarRecord.count(record, whereClause, arguments, groupBy, orderBy, limit);
     }
 
     public T first() {
+        if (arguments == null) {
+            arguments = convertArgs(args);
+        }
 
-        if(arguments == null) arguments = convertArgs(args);
-
-        List<T> list = T.find(record, whereClause, arguments, groupBy, orderBy, "1");
+        List<T> list = SugarRecord.find(record, whereClause, arguments, groupBy, orderBy, "1");
         return list.size() > 0 ? list.get(0) : null;
     }
     
     String toSql() {
         StringBuilder sql = new StringBuilder();
-
-        sql.append("SELECT * FROM");
-
-        sql.append("FROM ");
-
-        sql.append(SugarRecord.getTableName(this.record) + " ");
+        sql.append("SELECT * FROM ").append(NamingHelper.toSQLName(this.record)).append(" ");
 
         if (whereClause != null) {
-            sql.append("WHERE " + whereClause + " ");
+            sql.append("WHERE ").append(whereClause).append(" ");
         }
 
         if (orderBy != null) {
-            sql.append("ORDER BY " + orderBy + " ");
+            sql.append("ORDER BY ").append(orderBy).append(" ");
         }
 
         if (limit != null) {
-            sql.append("LIMIT " + limit + " ");
+            sql.append("LIMIT ").append(limit).append(" ");
         }
 
         if (offset != null) {
-            sql.append("OFFSET " + offset + " ");
+            sql.append("OFFSET ").append(offset).append(" ");
         }
 
         return sql.toString();
@@ -150,14 +158,14 @@ String getWhereCond() {
         return whereClause;
     }
 
-    String[] getArgs(){
+    String[] getArgs() {
         return convertArgs(args);
     }
 
     private String[] convertArgs(List<Object> argsList) {
         String[] argsArray = new String[argsList.size()];
 
-        for(int i=0; i< argsList.size();i++){
+        for (int i = 0; i < argsList.size(); i++) {
              argsArray[i] = argsList.get(i).toString();
         }
 
@@ -165,8 +173,11 @@ String getWhereCond() {
     }
 
     public Iterator<T> iterator() {
-        if(arguments == null) arguments = convertArgs(args);
+        if (arguments == null) {
+            arguments = convertArgs(args);
+        }
 
-        return T.findAsIterator(record, whereClause, arguments, groupBy, orderBy, limit);
+        return SugarRecord.findAsIterator(record, whereClause, arguments, groupBy, orderBy, limit);
     }
+
 }
diff --git a/library/src/com/orm/dsl/Collection.java b/library/src/com/orm/util/Collection.java
similarity index 97%
rename from library/src/com/orm/dsl/Collection.java
rename to library/src/com/orm/util/Collection.java
index 6f1b5075..fe7a7e63 100644
--- a/library/src/com/orm/dsl/Collection.java
+++ b/library/src/com/orm/util/Collection.java
@@ -1,4 +1,4 @@
-package com.orm.dsl;
+package com.orm.util;
 import java.util.*;
 
 public class Collection {
@@ -36,4 +36,5 @@ public Entry(K key, V value) {
             this.value = value;
         }
     }
+
 }
diff --git a/library/src/com/orm/util/ManifestHelper.java b/library/src/com/orm/util/ManifestHelper.java
new file mode 100644
index 00000000..fb65724c
--- /dev/null
+++ b/library/src/com/orm/util/ManifestHelper.java
@@ -0,0 +1,133 @@
+package com.orm.util;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.util.Log;
+
+/**
+ * Helper class for accessing properties in the AndroidManifest
+ */
+public class ManifestHelper {
+
+    /**
+     * Key for the database name meta data.
+     */
+    public final static String METADATA_DATABASE = "DATABASE";
+    /**
+     * Key for the database verison meta data.
+     */
+    public final static String METADATA_VERSION = "VERSION";
+    public final static String METADATA_DOMAIN_PACKAGE_NAME = "DOMAIN_PACKAGE_NAME";
+    public final static String METADATA_QUERY_LOG = "QUERY_LOG";
+    /**
+     * The default name for the database unless specified in the AndroidManifest.
+     */
+    public final static String DATABASE_DEFAULT_NAME = "Sugar.db";
+
+    /**
+     * Grabs the database version from the manifest.
+     *
+     * @param context  the {@link android.content.Context} of the Android application
+     * @return the database version as specified by the {@link #METADATA_VERSION} version or 1 of
+     *         not present
+     */
+    public static int getDatabaseVersion(Context context) {
+        Integer databaseVersion = getMetaDataInteger(context, METADATA_VERSION);
+
+        if ((databaseVersion == null) || (databaseVersion == 0)) {
+            databaseVersion = 1;
+        }
+
+        return databaseVersion;
+    }
+
+    /**
+     * Grabs the domain name of the model classes from the manifest. 
+     *
+     * @param context  the {@link android.content.Context} of the Android application
+     * @return the package String that Sugar uses to search for model classes
+     */
+    public static String getDomainPackageName(Context context){
+        String domainPackageName = getMetaDataString(context, METADATA_DOMAIN_PACKAGE_NAME);
+
+        if (domainPackageName == null) {
+            domainPackageName = "";
+        }
+
+        return domainPackageName;
+    }
+
+    /**
+     * Grabs the name of the database file specified in the manifest.
+     *
+     * @param context  the {@link android.content.Context} of the Android application
+     * @return the value for the {@value #METADATA_DATABASE} meta data in the AndroidManifest or
+     *         {@link #DATABASE_DEFAULT_NAME} if not present
+     */
+    public static String getDatabaseName(Context context) {
+        String databaseName = getMetaDataString(context, METADATA_DATABASE);
+
+        if (databaseName == null) {
+            databaseName = DATABASE_DEFAULT_NAME;
+        }
+
+        return databaseName;
+    }
+
+    /**
+     * Grabs the debug flag from the manifest.
+     *
+     * @param context  the {@link android.content.Context} of the Android application
+     * @return true if the debug flag is enabled
+     */
+    public static boolean getDebugEnabled(Context context) {
+        return getMetaDataBoolean(context, METADATA_QUERY_LOG);
+    }
+
+    private static String getMetaDataString(Context context, String name) {
+        String value = null;
+
+        PackageManager pm = context.getPackageManager();
+        try {
+            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(),
+                    PackageManager.GET_META_DATA);
+            value = ai.metaData.getString(name);
+        } catch (Exception e) {
+            Log.d("sugar", "Couldn't find config value: " + name);
+        }
+
+        return value;
+    }
+
+    private static Integer getMetaDataInteger(Context context, String name) {
+        Integer value = null;
+
+        PackageManager pm = context.getPackageManager();
+        try {
+            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(),
+                    PackageManager.GET_META_DATA);
+            value = ai.metaData.getInt(name);
+        } catch (Exception e) {
+            Log.d("sugar", "Couldn't find config value: " + name);
+        }
+
+        return value;
+    }
+
+    private static Boolean getMetaDataBoolean(Context context, String name) {
+        Boolean value = false;
+
+        PackageManager pm = context.getPackageManager();
+        try {
+            ApplicationInfo ai = pm.getApplicationInfo(context.getPackageName(),
+                    PackageManager.GET_META_DATA);
+            value = ai.metaData.getBoolean(name);
+        } catch (Exception e) {
+            Log.d("sugar", "Couldn't find config value: " + name);
+        }
+
+        return value;
+    }
+
+}
diff --git a/library/src/com/orm/util/NamingHelper.java b/library/src/com/orm/util/NamingHelper.java
new file mode 100644
index 00000000..734b4a56
--- /dev/null
+++ b/library/src/com/orm/util/NamingHelper.java
@@ -0,0 +1,94 @@
+package com.orm.util;
+
+import android.text.TextUtils;
+
+import com.orm.dsl.Column;
+import com.orm.dsl.Table;
+
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+
+public class NamingHelper {
+
+    /**
+     * Converts a given CamelCasedString to UPPER_CASE_UNDER_SCORE.
+     *
+     * @param camelCased  a non empty camelCased string
+     * @return the equivalent string converted to UPPER_CASE_UNDER_SCORE unless camelCased equals
+     *         "_id" (not case sensitive) in which case "_id" is returned
+     */
+    public static String toSQLNameDefault(String camelCased) {
+        if (camelCased.equalsIgnoreCase("_id")) {
+            return "_id";
+        }
+
+        StringBuilder sb = new StringBuilder();
+        char[] buf = camelCased.toCharArray();
+
+        for (int i = 0; i < buf.length; i++) {
+            char prevChar = (i > 0) ? buf[i - 1] : 0;
+            char c = buf[i];
+            char nextChar = (i < buf.length - 1) ? buf[i + 1] : 0;
+            boolean isFirstChar = (i == 0);
+
+            if (isFirstChar || Character.isLowerCase(c) || Character.isDigit(c)) {
+                sb.append(Character.toUpperCase(c));
+            } else if (Character.isUpperCase(c)) {
+                if (Character.isLetterOrDigit(prevChar)) {
+                    if (Character.isLowerCase(prevChar)) {
+                        sb.append('_').append(c);
+                    } else if (nextChar > 0 && Character.isLowerCase(nextChar)) {
+                        sb.append('_').append(c);
+                    } else {
+                        sb.append(c);
+                    }
+                } else {
+                    sb.append(c);
+                }
+            }
+        }
+
+        return sb.toString();
+    }
+
+    /**
+     * Maps a Java Field object to the database's column name.
+     *
+     * @param field  the {@link java.lang.reflect.Field} that will be mapped
+     * @return the name of the given Field as represented in the database. If the Field is annotated
+     *         with {@link com.orm.dsl.Column} then the {@link com.orm.dsl.Column#name()} will be
+     *         returned. Else, the Field's {@link java.lang.reflect.Field#getName()} will be
+     *         converted from CamelCase to UNDER_SCORE notation
+     */
+    public static String toSQLName(Field field) {
+        if (field.isAnnotationPresent(Column.class)) {
+            Column annotation = field.getAnnotation(Column.class);
+            return annotation.name();
+        }
+
+        return toSQLNameDefault(field.getName());
+    }
+
+    /**
+     * Maps a Java Class to the name of the class.
+     *
+     * @param table  the generic {@link java.lang.Class<T>} that defines a database table
+     * @return if the given class is annotated with {@link com.orm.dsl.Table} then the value for
+     *         {@link com.orm.dsl.Table#name()} will be returned. Else, the class' simple name will 
+     *         be converted from CamelCase to UNDER_SCORE notation
+     */
+    public static String toSQLName(Class<?> table) {
+        if (table.isAnnotationPresent(Table.class)) {
+            Table annotation = table.getAnnotation(Table.class);
+            if ("".equals(annotation.name())) {
+                return NamingHelper.toSQLNameDefault(table.getSimpleName());
+            }
+            return annotation.name();
+        }
+
+        return NamingHelper.toSQLNameDefault(table.getSimpleName());
+    }
+
+}
diff --git a/library/src/com/orm/NumberComparator.java b/library/src/com/orm/util/NumberComparator.java
similarity index 94%
rename from library/src/com/orm/NumberComparator.java
rename to library/src/com/orm/util/NumberComparator.java
index 244d3281..b39ca9c9 100644
--- a/library/src/com/orm/NumberComparator.java
+++ b/library/src/com/orm/util/NumberComparator.java
@@ -1,10 +1,18 @@
-package com.orm;
+package com.orm.util;
 
 import java.util.Comparator;
 
 public class NumberComparator implements Comparator<Object> {
 
-    int compareRight(String a, String b) {
+    private static char charAt(String s, int i) {
+        if (i >= s.length()) {
+            return '\000';
+        }
+
+        return s.charAt(i);
+    }
+
+    private int compareRight(String a, String b) {
         int bias = 0;
         int ia = 0;
         int ib = 0;
@@ -90,11 +98,4 @@ public int compare(Object o1, Object o2) {
         }
     }
 
-    static char charAt(String s, int i) {
-        if (i >= s.length()) {
-            return '\000';
-        }
-
-        return s.charAt(i);
-    }
 }
diff --git a/library/src/com/orm/QueryBuilder.java b/library/src/com/orm/util/QueryBuilder.java
similarity index 74%
rename from library/src/com/orm/QueryBuilder.java
rename to library/src/com/orm/util/QueryBuilder.java
index e0f98222..25e62f8d 100644
--- a/library/src/com/orm/QueryBuilder.java
+++ b/library/src/com/orm/util/QueryBuilder.java
@@ -1,13 +1,12 @@
-package com.orm;
+package com.orm.util;
+
+import com.orm.SugarRecord;
 
 public class QueryBuilder {
 
     public static String getColumnType(Class<?> type) {
         if ((type.equals(Boolean.class)) ||
                 (type.equals(Boolean.TYPE)) ||
-                (type.equals(java.util.Date.class)) ||
-                (type.equals(java.util.Calendar.class)) ||
-                (type.equals(java.sql.Date.class)) ||
                 (type.equals(Byte.class)) ||
                 (type.equals(Byte.TYPE)) ||
                 (type.equals(Short.class)) ||
@@ -21,9 +20,17 @@ public static String getColumnType(Class<?> type) {
             return "INTEGER";
         }
 
-        if ((type.equals(Double.class)) || 
-                (type.equals(Double.TYPE)) || 
-                (type.equals(Float.class)) ||
+        if ((type.equals(java.util.Date.class)) ||
+                (type.equals(java.sql.Date.class)) ||
+                (type.equals(java.util.Calendar.class))) {
+            return "INTEGER NULL";
+        }
+
+        if (type.getName().equals("[B")) {
+            return "BLOB";
+        }
+
+        if ((type.equals(Double.class)) || (type.equals(Double.TYPE)) || (type.equals(Float.class)) ||
                 (type.equals(Float.TYPE))) {
             return "FLOAT";
         }
@@ -40,4 +47,5 @@ public static String getColumnType(Class<?> type) {
 
         return "";
     }
+
 }
diff --git a/library/src/com/orm/util/ReflectionUtil.java b/library/src/com/orm/util/ReflectionUtil.java
new file mode 100644
index 00000000..3dc2b59d
--- /dev/null
+++ b/library/src/com/orm/util/ReflectionUtil.java
@@ -0,0 +1,287 @@
+package com.orm.util;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.util.Log;
+import com.orm.SugarRecord;
+import com.orm.dsl.Ignore;
+import com.orm.dsl.Table;
+import dalvik.system.DexFile;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.net.URL;
+import java.sql.Timestamp;
+import java.util.*;
+
+public class ReflectionUtil {
+
+    public static List<Field> getTableFields(Class table) {
+        List<Field> fieldList = SugarConfig.getFields(table);
+        if (fieldList != null) return fieldList;
+
+        Log.d("Sugar", "Fetching properties");
+        List<Field> typeFields = new ArrayList<Field>();
+
+        getAllFields(typeFields, table);
+
+        List<Field> toStore = new ArrayList<Field>();
+        for (Field field : typeFields) {
+            if (!field.isAnnotationPresent(Ignore.class) && !Modifier.isStatic(field.getModifiers()) && !Modifier.isTransient(field.getModifiers())) {
+                toStore.add(field);
+            }
+        }
+
+        SugarConfig.setFields(table, toStore);
+        return toStore;
+    }
+
+    private static List<Field> getAllFields(List<Field> fields, Class<?> type) {
+        Collections.addAll(fields, type.getDeclaredFields());
+
+        if (type.getSuperclass() != null) {
+            fields = getAllFields(fields, type.getSuperclass());
+        }
+
+        return fields;
+    }
+
+    public static void addFieldValueToColumn(ContentValues values, Field column, Object object) {
+        column.setAccessible(true);
+        Class<?> columnType = column.getType();
+        try {
+            String columnName = NamingHelper.toSQLName(column);
+            Object columnValue = column.get(object);
+
+            if (SugarRecord.class.isAssignableFrom(columnType)) {
+                values.put(columnName,
+                        (columnValue != null)
+                                ? String.valueOf(((SugarRecord) columnValue).getId())
+                                : "0");
+            } else {
+                if (columnType.equals(Short.class) || columnType.equals(short.class)) {
+                    values.put(columnName, (Short) columnValue);
+                } else if (columnType.equals(Integer.class) || columnType.equals(int.class)) {
+                    values.put(columnName, (Integer) columnValue);
+                } else if (columnType.equals(Long.class) || columnType.equals(long.class)) {
+                    values.put(columnName, (Long) columnValue);
+                } else if (columnType.equals(Float.class) || columnType.equals(float.class)) {
+                    values.put(columnName, (Float) columnValue);
+                } else if (columnType.equals(Double.class) || columnType.equals(double.class)) {
+                    values.put(columnName, (Double) columnValue);
+                } else if (columnType.equals(Boolean.class) || columnType.equals(boolean.class)) {
+                    values.put(columnName, (Boolean) columnValue);
+                } else if (Timestamp.class.equals(columnType)) {
+                    try {
+                        values.put(columnName, ((Timestamp) column.get(object)).getTime());
+                    } catch (NullPointerException e) {
+                        values.put(columnName, (Long) null);
+                    }
+                } else if (Date.class.equals(columnType)) {
+                    try {
+                        values.put(columnName, ((Date) column.get(object)).getTime());
+                    } catch (NullPointerException e) {
+                        values.put(columnName, (Long) null);
+                    }
+                } else if (Calendar.class.equals(columnType)) {
+                    try {
+                        values.put(columnName, ((Calendar) column.get(object)).getTimeInMillis());
+                    } catch (NullPointerException e) {
+                        values.put(columnName, (Long) null);
+                    }
+                } else {
+                    if (columnValue == null) {
+                        values.putNull(columnName);
+                    } else {
+                        values.put(columnName, String.valueOf(columnValue));
+                    }
+                }
+            }
+
+        } catch (IllegalAccessException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+    }
+
+    public static void setFieldValueFromCursor(Cursor cursor, Field field, Object object) {
+        field.setAccessible(true);
+        try {
+            Class fieldType = field.getType();
+            String colName = NamingHelper.toSQLName(field);
+
+            int columnIndex = cursor.getColumnIndex(colName);
+
+            if (cursor.isNull(columnIndex)) {
+                return;
+            }
+
+            if (colName.equalsIgnoreCase("id")) {
+                long cid = cursor.getLong(columnIndex);
+                field.set(object, Long.valueOf(cid));
+            } else if (fieldType.equals(long.class) || fieldType.equals(Long.class)) {
+                field.set(object,
+                        cursor.getLong(columnIndex));
+            } else if (fieldType.equals(String.class)) {
+                String val = cursor.getString(columnIndex);
+                field.set(object, val != null && val.equals("null") ? null : val);
+            } else if (fieldType.equals(double.class) || fieldType.equals(Double.class)) {
+                field.set(object,
+                        cursor.getDouble(columnIndex));
+            } else if (fieldType.equals(boolean.class) || fieldType.equals(Boolean.class)) {
+                field.set(object,
+                        cursor.getString(columnIndex).equals("1"));
+            } else if (field.getType().getName().equals("[B")) {
+                field.set(object,
+                        cursor.getBlob(columnIndex));
+            } else if (fieldType.equals(int.class) || fieldType.equals(Integer.class)) {
+                field.set(object,
+                        cursor.getInt(columnIndex));
+            } else if (fieldType.equals(float.class) || fieldType.equals(Float.class)) {
+                field.set(object,
+                        cursor.getFloat(columnIndex));
+            } else if (fieldType.equals(short.class) || fieldType.equals(Short.class)) {
+                field.set(object,
+                        cursor.getShort(columnIndex));
+            } else if (fieldType.equals(Timestamp.class)) {
+                long l = cursor.getLong(columnIndex);
+                field.set(object, new Timestamp(l));
+            } else if (fieldType.equals(Date.class)) {
+                long l = cursor.getLong(columnIndex);
+                field.set(object, new Date(l));
+            } else if (fieldType.equals(Calendar.class)) {
+                long l = cursor.getLong(columnIndex);
+                Calendar c = Calendar.getInstance();
+                c.setTimeInMillis(l);
+                field.set(object, c);
+            } else if (Enum.class.isAssignableFrom(fieldType)) {
+                try {
+                    Method valueOf = field.getType().getMethod("valueOf", String.class);
+                    String strVal = cursor.getString(columnIndex);
+                    Object enumVal = valueOf.invoke(field.getType(), strVal);
+                    field.set(object, enumVal);
+                } catch (Exception e) {
+                    Log.e("Sugar", "Enum cannot be read from Sqlite3 database. Please check the type of field " + field.getName());
+                }
+            } else
+                Log.e("Sugar", "Class cannot be read from Sqlite3 database. Please check the type of field " + field.getName() + "(" + field.getType().getName() + ")");
+        } catch (IllegalArgumentException e) {
+            Log.e("field set error", e.getMessage());
+        } catch (IllegalAccessException e) {
+            Log.e("field set error", e.getMessage());
+        }
+    }
+
+    public static void setFieldValueForId(Object object, Long value) {
+
+        try {
+            Field field = object.getClass().getField("id");
+
+            field.setAccessible(true);
+            field.set(object, value);
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        } catch (NoSuchFieldException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static List<Class> getDomainClasses(Context context) {
+        List<Class> domainClasses = new ArrayList<Class>();
+        try {
+            for (String className : getAllClasses(context)) {
+                if (className.startsWith(ManifestHelper.getDomainPackageName(context))) {
+                    Class domainClass = getDomainClass(className, context);
+                    if (domainClass != null) domainClasses.add(domainClass);
+                }
+            }
+        } catch (IOException e) {
+            Log.e("Sugar", e.getMessage());
+        } catch (PackageManager.NameNotFoundException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+
+        return domainClasses;
+    }
+
+
+    private static Class getDomainClass(String className, Context context) {
+        Class<?> discoveredClass = null;
+        try {
+            discoveredClass = Class.forName(className, true, context.getClass().getClassLoader());
+        } catch (ClassNotFoundException e) {
+            Log.e("Sugar", e.getMessage());
+        }
+
+        if ((discoveredClass != null) &&
+                ((SugarRecord.class.isAssignableFrom(discoveredClass) &&
+                        !SugarRecord.class.equals(discoveredClass)) ||
+                        discoveredClass.isAnnotationPresent(Table.class)) &&
+                !Modifier.isAbstract(discoveredClass.getModifiers())) {
+
+            Log.i("Sugar", "domain class : " + discoveredClass.getSimpleName());
+            return discoveredClass;
+
+        } else {
+            return null;
+        }
+    }
+
+
+    private static List<String> getAllClasses(Context context) throws PackageManager.NameNotFoundException, IOException {
+        String path = getSourcePath(context);
+        List<String> classNames = new ArrayList<String>();
+        try {
+            DexFile dexfile = new DexFile(path);
+            Enumeration<String> dexEntries = dexfile.entries();
+            while (dexEntries.hasMoreElements()) {
+                classNames.add(dexEntries.nextElement());
+            }
+        } catch (NullPointerException e) {
+            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+            Enumeration<URL> urls = classLoader.getResources("");
+            List<String> fileNames = new ArrayList<String>();
+            while (urls.hasMoreElements()) {
+                String classDirectoryName = urls.nextElement().getFile();
+                if (classDirectoryName.contains("bin") || classDirectoryName.contains("classes")) {
+                    File classDirectory = new File(classDirectoryName);
+                    for (File filePath : classDirectory.listFiles()) {
+                        populateFiles(filePath, fileNames, "");
+                    }
+                    classNames.addAll(fileNames);
+                }
+            }
+        }
+        return classNames;
+    }
+
+    private static void populateFiles(File path, List<String> fileNames, String parent) {
+        if (path.isDirectory()) {
+            for (File newPath : path.listFiles()) {
+                if ("".equals(parent)) {
+                    populateFiles(newPath, fileNames, path.getName());
+                } else {
+                    populateFiles(newPath, fileNames, parent + "." + path.getName());
+                }
+            }
+        } else {
+            String pathName = path.getName();
+            String classSuffix = ".class";
+            pathName = pathName.endsWith(classSuffix) ?
+                    pathName.substring(0, pathName.length() - classSuffix.length()) : pathName;
+            if ("".equals(parent)) {
+                fileNames.add(pathName);
+            } else {
+                fileNames.add(parent + "." + pathName);
+            }
+        }
+    }
+
+    private static String getSourcePath(Context context) throws PackageManager.NameNotFoundException {
+        return context.getPackageManager().getApplicationInfo(context.getPackageName(), 0).sourceDir;
+    }
+}
diff --git a/library/src/com/orm/util/SugarConfig.java b/library/src/com/orm/util/SugarConfig.java
new file mode 100644
index 00000000..b93da25e
--- /dev/null
+++ b/library/src/com/orm/util/SugarConfig.java
@@ -0,0 +1,37 @@
+package com.orm.util;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.util.Log;
+
+import java.lang.reflect.Field;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+
+public class SugarConfig {
+
+    static Map<Class<?>, List<Field>> fields = new HashMap<Class<?>, List<Field>>();
+
+    public static void setFields(Class<?> clazz, List<Field> fieldz) {
+         fields.put(clazz, fieldz);
+    }
+
+    public static List<Field> getFields(Class<?> clazz) {
+        if (fields.containsKey(clazz)) {
+            List<Field> list = fields.get(clazz);
+            return Collections.synchronizedList(list);
+        }
+
+        return null;
+    }
+
+    public static void clearCache() {
+        fields.clear();
+        fields = new HashMap<Class<?>, List<Field>>();
+    }
+
+}
diff --git a/library/src/com/orm/SugarCursorFactory.java b/library/src/com/orm/util/SugarCursorFactory.java
similarity index 70%
rename from library/src/com/orm/SugarCursorFactory.java
rename to library/src/com/orm/util/SugarCursorFactory.java
index 17c60c59..12706516 100644
--- a/library/src/com/orm/SugarCursorFactory.java
+++ b/library/src/com/orm/util/SugarCursorFactory.java
@@ -1,4 +1,4 @@
-package com.orm;
+package com.orm.util;
 
 import android.database.Cursor;
 import android.database.sqlite.SQLiteCursor;
@@ -15,18 +15,22 @@ public SugarCursorFactory() {
         this.debugEnabled = false;
     }
 
-    public SugarCursorFactory(boolean debugEnabled){
+    public SugarCursorFactory(boolean debugEnabled) {
 
         this.debugEnabled = debugEnabled;
     }
 
     @SuppressWarnings("deprecation")
-    public Cursor newCursor(SQLiteDatabase sqLiteDatabase, SQLiteCursorDriver sqLiteCursorDriver, String editTable, SQLiteQuery sqLiteQuery) {
+    public Cursor newCursor(SQLiteDatabase sqLiteDatabase,
+            SQLiteCursorDriver sqLiteCursorDriver,
+            String editTable,
+            SQLiteQuery sqLiteQuery) {
 
-        if(debugEnabled){
+        if (debugEnabled) {
             Log.d("SQL Log", sqLiteQuery.toString());
         }
 
         return new SQLiteCursor(sqLiteDatabase, sqLiteCursorDriver, editTable, sqLiteQuery);
     }
+
 }
diff --git a/library/test/com/orm/NamingHelperTest.java b/library/test/com/orm/NamingHelperTest.java
new file mode 100644
index 00000000..28c705a0
--- /dev/null
+++ b/library/test/com/orm/NamingHelperTest.java
@@ -0,0 +1,36 @@
+package com.orm;
+
+import com.orm.util.NamingHelper;
+import org.junit.Test;
+
+import static junit.framework.Assert.assertEquals;
+
+public class NamingHelperTest {
+    @Test
+    public void testToSQLNameCaseConversion() throws Exception {
+        assertToSqlNameEquals("TESTLOWERCASE", "testlowercase");
+        assertToSqlNameEquals("TESTUPPERCASE", "TESTUPPERCASE");
+    }
+
+    @Test
+    public void testToSQLNameUnderscore() {
+        assertToSqlNameEquals("TEST_UNDERSCORE", "testUnderscore");
+        assertToSqlNameEquals("AB_CD", "AbCd");
+        assertToSqlNameEquals("AB_CD", "ABCd");
+        assertToSqlNameEquals("AB_CD", "AbCD");
+        assertToSqlNameEquals("SOME_DETAILS_OBJECT", "SomeDetailsObject");
+        assertToSqlNameEquals("H_OL_A","hOlA");
+        assertToSqlNameEquals("A","a");
+    }
+
+    /**
+     * Helper method that asserts a CamelCaseString is converted to UPPER_CASE_UNDER_SCORE.
+     *
+     * @param expected  a CamelCaseString
+     * @param actual    the expected UPPER_CASE_UNDER_SCORE string
+     */
+    private static void assertToSqlNameEquals(String expected, String actual) {
+        assertEquals(expected, NamingHelper.toSQLNameDefault(actual));
+    }
+
+}
diff --git a/library/test/com/orm/StringUtilTest.java b/library/test/com/orm/StringUtilTest.java
deleted file mode 100644
index 923bf98d..00000000
--- a/library/test/com/orm/StringUtilTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.orm;
-
-import org.junit.Test;
-
-import static junit.framework.Assert.assertEquals;
-
-public class StringUtilTest {
-    @Test
-    public void testToSQLNameCaseConversion() throws Exception {
-        assertEquals("TESTLOWERCASE", StringUtil.toSQLName("testlowercase"));
-        assertEquals("TESTUPPERCASE", StringUtil.toSQLName("TESTUPPERCASE"));
-    }
-
-    @Test
-    public void testToSQLNameUnderscore(){
-        assertEquals("TEST_UNDERSCORE", StringUtil.toSQLName("testUnderscore"));
-        assertEquals("AB_CD", StringUtil.toSQLName("AbCd"));
-        assertEquals("AB_CD", StringUtil.toSQLName("ABCd"));
-        assertEquals("AB_CD", StringUtil.toSQLName("AbCD"));
-        assertEquals("SOME_DETAILS_OBJECT", StringUtil.toSQLName("SomeDetailsObject"));
-    }
-
-
-}
diff --git a/library/test/com/orm/query/TestRecord.java b/library/test/com/orm/query/TestRecord.java
index 0751a936..50997205 100644
--- a/library/test/com/orm/query/TestRecord.java
+++ b/library/test/com/orm/query/TestRecord.java
@@ -1,10 +1,9 @@
 package com.orm.query;
 
 import android.content.Context;
-import com.orm.SugarApp;
 import com.orm.SugarRecord;
 
-public class TestRecord extends SugarRecord<TestRecord>{
+public class TestRecord extends SugarRecord {
 
     private String name;
 
