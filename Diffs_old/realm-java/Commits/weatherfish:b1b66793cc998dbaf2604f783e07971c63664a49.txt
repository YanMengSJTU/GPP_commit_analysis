diff --git a/CHANGELOG.md b/CHANGELOG.md
index b756b905ad..7b3e37cc55 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,24 +1,37 @@
-## 2.3.0
+## 2.4.0
 
-### Object Server API Changes (In Beta)
+## 2.3.0
 
-* Add a default `UserStore` based on the Realm Object Store (`ObjectStoreUserStore`).
-* Change the order of arguments to SyncCredentials.custom to match iOS: token, provider, userInfo
+### Object Server API Changes 
 
-## 2.2.3
+* Realm Sync v1.0.0 has been released, and Realm Mobile Platform is no longer considered in beta.
+* Breaking change: Location of Realm files are now placed in `getFilesDir()/<userIdentifier>` instead of `getFilesDir()/`.
+  This is done in order to support shared Realms among users, while each user retaining their own local copy.
+* Breaking change: `SyncUser.all()` now returns Map instead of List.
+* Breaking change: Added a default `UserStore` saving users in a Realm file (`RealmFileUserStore`).
+* Breaking change: Added multi-user support to `UserStore`. Added `get(String)` and `remove(String)`, removed `remove()` and renamed `get()` to `getCurrent()`.
+* Breaking change: Changed the order of arguments to `SyncCredentials.custom()` to match iOS: token, provider, userInfo.
+* Added support for `PermissionOffer` and `PermissionOfferResponse` to `SyncUser.getManagementRealm()`.
+* Exceptions thrown in error handlers are ignored but logged (#3559).
+* Removed unused public constants in `SyncConfiguration` (#4047).
+* Fixed bug, preventing Sync client to renew the access token (#4038) (#4039).
+* Now `SyncUser.logout()` properly revokes tokens (#3639).
 
 ### Bug fixes
 
 * Fixed native memory leak setting the value of a primary key (#3993).
 * Activated Realm's annotation processor on connectedTest when the project is using kapt (#4008).
+* Fixed "too many open files" issue (#4002).
+* Added temporary work-around for bug crashing Samsung Tab 3 devices on startup (#3651).
 
-### Object Server API Changes (In Beta)
+### Enhancements
 
-* Exceptions thrown in error handlers are ignored but logged (#3559).
+* Added `like` predicate for String fields (#3752).
 
 ### Internal
 
-* Updated Realm Sync to 1.0.0-BETA-7.1.
+* Updated to Realm Sync v1.0.0.
+* Added a Realm backup when receiving a Sync client reset message from the server.
 
 ## 2.2.2
 
@@ -40,7 +53,6 @@
 * All major public classes are now non-final. This is mostly a compromise to support Mockito. All protected fields/methods are still not considered part of the public API and can change without notice (#3869).
 * All Realm instances share a single notification daemon thread.
 * Fixed Java lint warnings with generated proxy classes (#2929).
-* Add 'like' predicate for String fields (#3752)
 
 ### Internal
 
diff --git a/Jenkinsfile b/Jenkinsfile
index 364ad7d9fb..4356ad68aa 100644
--- a/Jenkinsfile
+++ b/Jenkinsfile
@@ -24,9 +24,6 @@ try {
       def buildEnv
       def rosEnv
       stage('Docker build') {
-        // Clean any potential old containers
-        sh 'docker rm ros || true' 
-
         // Docker image for build
         buildEnv = docker.build 'realm-java:snapshot'
         // Docker image for testing Realm Object Server
@@ -35,8 +32,7 @@ try {
         rosEnv = docker.build 'ros:snapshot', "--build-arg ROS_DE_VERSION=${rosDeVersion} tools/sync_test_server"
       }
 
-      rosContainer = rosEnv.run("-v /tmp=/tmp/.ros " +
-              "--name ros")
+      rosContainer = rosEnv.run('-v /tmp=/tmp/.ros')
 
       try {
           buildEnv.inside("-e HOME=/tmp " +
@@ -47,7 +43,7 @@ try {
                   "-v ${env.HOME}/.android:/tmp/.android " +
                   "-v ${env.HOME}/ccache:/tmp/.ccache " +
                   "-v ${env.HOME}/lcache:/tmp/.lcache " +
-                  "--network container:ros") {
+                  "--network container:${rosContainer.id}") {
             stage('JVM tests') {
               try {
                 withCredentials([[$class: 'FileBinding', credentialsId: 'c0cc8f9e-c3f1-4e22-b22f-6568392e26ae', variable: 'S3CFG']]) {
@@ -107,7 +103,7 @@ try {
             }
           }
       } finally {
-          sh "docker logs ros"
+          sh "docker logs ${rosContainer.id}"
           rosContainer.stop()
       }
     }
@@ -138,8 +134,7 @@ try {
 }
 
 def forwardAdbPorts() {
-  sh ''' adb reverse tcp:7800 tcp:7800 &&
-      adb reverse tcp:8080 tcp:8080 &&
+  sh ''' adb reverse tcp:9080 tcp:9080 &&
       adb reverse tcp:8888 tcp:8888
   '''
 }
diff --git a/README.md b/README.md
index 7e985ef5c4..b4dc035638 100644
--- a/README.md
+++ b/README.md
@@ -61,26 +61,23 @@ In case you don't want to use the precompiled version, you can build Realm yours
 
  * Download the [**JDK 7**](http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html) or [**JDK 8**](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) from Oracle and install it.
  * Download & install the Android SDK **Build-Tools 24.0.0**, **Android N (API 24)** (for example through Android Studioâ€™s **Android SDK Manager**).
- * Download the **Android NDK (= r10e)** for [OS X](http://dl.google.com/android/ndk/android-ndk-r10e-darwin-x86_64.bin) or [Linux](http://dl.google.com/android/ndk/android-ndk-r10e-linux-x86_64.bin).
  * Install CMake from SDK manager in Android Studio ("SDK Tools" -> "CMake").
- * Or you can use [Hombrew-versions](https://github.com/Homebrew/homebrew-versions) to install Android NDK for Mac:
 
-    ```
-    brew tap homebrew/versions
-    brew install android-ndk-r10e
-    ```
+ * Realm currently requires version r10e of the NDK.  Download the one appropriate for your development platform, from the NDK [archive](https://developer.android.com/ndk/downloads/older_releases.html).
+You may unzip the file wherever you choose.  For OSX, a suggested location is `~/Library/Android`.  The download will unzip as the directory `android-ndk-r10e`.
 
- * Add two environment variables to your profile (presuming you used brew to install the NDK):
+ * If you will be building with Android Studio, you will need to tell it to use the correct NDK.  To do this, define the variable `ndk.dir` in `realm/local.properties` and assign it the full path name of the directory that you unzipped above.  Note that there is a `local.properites` in the root directory that is *not* the one that needs to be edited.
 
     ```
-    export ANDROID_HOME=~/Library/Android/sdk
-    export ANDROID_NDK_HOME=/usr/local/Cellar/android-ndk-r10e/r10e
+    ndk.dir=/Users/brian/Library/Android/android-ndk-r10e/r10e
+
     ```
 
- * If you want to build with Android Studio, `ndk.dir` has to be defined in the `realm/local.properties` as well.  Note that there is a `local.properites` in the root directory that is *not* the one that needs to be edited.  Again, presuming you used brew to install the NDK:
+ * Add two environment variables to your profile (presuming you installed the NDK in `~/Library/android-ndk-r10e`):
 
     ```
-    ndk.dir=/usr/local/Cellar/android-ndk-r10e/r10e
+    export ANDROID_HOME=~/Library/Android/sdk
+    export ANDROID_NDK_HOME=~/Library/Android/android-ndk-r10e
     ```
 
  * If you will be launching Android Studio from the OS X Finder, you should also run the following two commands:
@@ -220,6 +217,9 @@ To run a testing server locally:
 	./gradlew connectedObjectServerDebugAndroidTest
 	```
 
+Note that if using VirtualBox (Genymotion), the network needs to be bridged for the tests to work.
+This is done in `VirtualBox > Network`. Set "Adapter 2" to "Bridged Adapter".
+
 These tests may take as much as half an hour to complete.
 
 ## Contributing
diff --git a/dependencies.list b/dependencies.list
index 769de14b97..daca48ea06 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,8 +1,10 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=1.0.0-BETA-7.1
-REALM_SYNC_SHA256=5412b42d96dd525af3ec6a0b7943330c43beae2c663b32376b77278ea54e34a5
+REALM_SYNC_VERSION=1.0.0
+REALM_SYNC_SHA256=0e95ee9ed06f1bf66d1531086197e6549ad7ca36da6400b0c5026c5a0c3c4249
 
 # Object Server Release used by Integration tests
+# `realm` is stable releases, `realm-testing` is developer builds.
 # https://packagecloud.io/realm/realm?filter=debs
-REALM_OBJECT_SERVER_DE_VERSION=1.0.0-BETA-4.11-449
+# https://packagecloud.io/realm/realm-testing?filter=debs
+REALM_OBJECT_SERVER_DE_VERSION=1.0.0-BETA-6.1-133
diff --git a/realm/config/findbugs/findbugs-filter.xml b/realm/config/findbugs/findbugs-filter.xml
index e28c4a627c..c7079866b1 100644
--- a/realm/config/findbugs/findbugs-filter.xml
+++ b/realm/config/findbugs/findbugs-filter.xml
@@ -15,4 +15,11 @@
     <Match>
         <Class name="io.realm.PermissionChangeRealmProxy"/>
     </Match>
+    <Match>
+        <Class name="io.realm.PermissionOfferRealmProxy"/>
+    </Match>
+    <Match>
+        <Class name="io.realm.PermissionOfferResponseRealmProxy"/>
+    </Match>
+
 </FindBugsFilter>
diff --git a/realm/realm-library/src/androidTest/AndroidManifest.xml b/realm/realm-library/src/androidTest/AndroidManifest.xml
index c7741a695f..d9e252dce4 100644
--- a/realm/realm-library/src/androidTest/AndroidManifest.xml
+++ b/realm/realm-library/src/androidTest/AndroidManifest.xml
@@ -21,6 +21,23 @@
             android:exported="true"
             android:process=":remote">
         </service>
+
+         <!--
+          FIXME: Manifest merger doesn't seem to work correctly with test flavours.
+          Figure out why. For now place services here
+          -->
+        <service
+            android:name="io.realm.objectserver.service.SendOneCommit"
+            android:enabled="true"
+            android:exported="true"
+            android:process=":remote">
+        </service>
+        <service
+            android:name="io.realm.objectserver.service.SendsALot"
+            android:enabled="true"
+            android:exported="true"
+            android:process=":remote">
+        </service>
     </application>
 
 </manifest>
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index 9c13abf838..0bbf6178a8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -778,7 +778,7 @@ public static void populateForDistinctFieldsOrder(Realm realm, long numberOfBloc
     }
 
     public static void awaitOrFail(CountDownLatch latch) {
-        awaitOrFail(latch, 10);
+        awaitOrFail(latch, 60);
     }
 
     public static void awaitOrFail(CountDownLatch latch, int numberOfSeconds) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
index 8a77d1e983..cf4041c3d2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
@@ -24,8 +24,9 @@
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
-import java.lang.annotation.Annotation;
+import java.util.ArrayList;
 import java.util.LinkedList;
+import java.util.List;
 import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
@@ -48,7 +49,11 @@
  * and this class does not agree in which order to delete all open Realms.
  */
 public class RunInLooperThread extends TestRealmConfigurationFactory {
+
+    // Default Realm created by this Rule. It is guaranteed to be closed when the test finishes.
     public Realm realm;
+    // Custom Realm used by the test. Saving the reference here will guarantee the instance is closed when exiting the test.
+    public List<Realm> testRealms = new ArrayList<Realm>();
     public RealmConfiguration realmConfiguration;
     private CountDownLatch signalTestCompleted;
     private Handler backgroundHandler;
@@ -72,6 +77,7 @@ protected void after() {
         super.after();
         realmConfiguration = null;
         realm = null;
+        testRealms.clear();
         keepStrongReference = null;
     }
 
@@ -128,6 +134,11 @@ public void run() {
                                 if (realm != null) {
                                     realm.close();
                                 }
+                                if (!testRealms.isEmpty()) {
+                                    for (Realm testRealm : testRealms) {
+                                        testRealm.close();
+                                    }
+                                }
                                 signalClosedRealm.countDown();
                             }
                         }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
index cb8a1c62a8..8bec3bfa4c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
@@ -142,25 +142,39 @@ public RealmConfiguration createConfiguration(String name, byte[] key) {
     }
 
     // Copies a Realm file from assets to temp dir
-    public void copyRealmFromAssets(Context context, String realmPath, String newName)
-            throws IOException {
-        // Delete the existing file before copy
-        RealmConfiguration configToDelete = new RealmConfiguration.Builder()
+    public void copyRealmFromAssets(Context context, String realmPath, String newName) throws IOException {
+        RealmConfiguration config = new RealmConfiguration.Builder()
                 .directory(getRoot())
                 .name(newName)
                 .build();
-        Realm.deleteRealm(configToDelete);
-
-        AssetManager assetManager = context.getAssets();
-        InputStream is = assetManager.open(realmPath);
-        File file = new File(getRoot(), newName);
-        FileOutputStream outputStream = new FileOutputStream(file);
-        byte[] buf = new byte[1024];
-        int bytesRead;
-        while ((bytesRead = is.read(buf)) > -1) {
-            outputStream.write(buf, 0, bytesRead);
+
+        copyRealmFromAssets(context, realmPath, config);
+    }
+
+    public void copyRealmFromAssets(Context context, String realmPath, RealmConfiguration config) throws IOException {
+        // Delete the existing file before copy
+        Realm.deleteRealm(config);
+
+        File outFile = new File(config.getRealmDirectory(), config.getRealmFileName());
+
+        InputStream is = null;
+        FileOutputStream os = null;
+        try {
+            is = context.getAssets().open(realmPath);
+            os = new FileOutputStream(outFile);
+
+            byte[] buf = new byte[1024];
+            int bytesRead;
+            while ((bytesRead = is.read(buf)) > -1) {
+                os.write(buf, 0, bytesRead);
+            }
+        } finally {
+            if (is != null) {
+                try { is.close(); } catch (IOException ignore) {}
+            }
+            if (os != null) {
+                try { os.close(); } catch (IOException ignore) {}
+            }
         }
-        outputStream.close();
-        is.close();
     }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/assets/schemaversion_v1.realm b/realm/realm-library/src/androidTestObjectServer/assets/schemaversion_v1.realm
new file mode 100644
index 0000000000..d2dac44060
Binary files /dev/null and b/realm/realm-library/src/androidTestObjectServer/assets/schemaversion_v1.realm differ
diff --git a/realm/realm-library/src/androidTestObjectServer/assets/versionTest.realm b/realm/realm-library/src/androidTestObjectServer/assets/versionTest.realm
new file mode 100644
index 0000000000..85cd0c426d
Binary files /dev/null and b/realm/realm-library/src/androidTestObjectServer/assets/versionTest.realm differ
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
index a95159a505..58203b7461 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
@@ -33,10 +33,12 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import io.realm.entities.AllJavaTypes;
 import io.realm.entities.StringOnly;
 import io.realm.rule.RunInLooperThread;
-import io.realm.rule.TestRealmConfigurationFactory;
+import io.realm.rule.TestSyncConfigurationFactory;
 
+import static io.realm.util.SyncTestUtils.createNamedTestUser;
 import static io.realm.util.SyncTestUtils.createTestUser;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -48,7 +50,7 @@
 @RunWith(AndroidJUnit4.class)
 public class SyncConfigurationTests {
     @Rule
-    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    public final TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
 
     @Rule
     public final RunInLooperThread looperThread = new RunInLooperThread();
@@ -94,10 +96,11 @@ public void user_invalidUserThrows() {
     @Test
     public void serverUrl_setsFolderAndFileName() {
         SyncUser user = createTestUser();
+        String identity = user.getIdentity();
         String[][] validUrls = {
                 // <URL>, <Folder>, <FileName>
-                { "realm://objectserver.realm.io/~/default", "realm-object-server/" + user.getIdentity(), "default" },
-                { "realm://objectserver.realm.io/~/sub/default", "realm-object-server/" + user.getIdentity() + "/sub", "default" }
+                { "realm://objectserver.realm.io/~/default", "realm-object-server/" + identity + "/" + identity, "default" },
+                { "realm://objectserver.realm.io/~/sub/default", "realm-object-server/" + identity + "/" + identity + "/sub", "default" }
         };
 
         for (String[] validUrl : validUrls) {
@@ -358,7 +361,8 @@ public void initialData() {
         SyncUser user = createTestUser();
         String url = "realm://objectserver.realm.io/default";
 
-        SyncConfiguration config = new SyncConfiguration.Builder(user, url)
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
+                .schema(StringOnly.class)
                 .initialData(new Realm.Transaction() {
                     @Override
                     public void execute(Realm realm) {
@@ -411,4 +415,113 @@ public void compact_NotAllowed() {
 
         Realm.compactRealm(config);
     }
+
+    @Test
+    public void schemaVersion_throwsIfLessThanCurrentVersion() throws IOException {
+        SyncUser user = createTestUser();
+        String url = "realm://ros.realm.io/~/default";
+        @SuppressWarnings("unchecked")
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
+                .schema(AllJavaTypes.class, StringOnly.class)
+                .name("schemaversion_v1.realm")
+                .schemaVersion(0)
+                .build();
+
+        // Add v1 of the Realm to the filsystem
+        configFactory.copyRealmFromAssets(context, "schemaversion_v1.realm", config);
+
+        // Opening the Realm should throw an exception since the schema version is less than the one in the file.
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(config);
+            fail();
+        } catch(IllegalArgumentException ignore) {
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
+
+    @Test
+    public void schemaVersion_bumpWhenUpgradingSchema() throws IOException {
+        SyncUser user = createTestUser();
+        String url = "realm://ros.realm.io/~/default";
+        @SuppressWarnings("unchecked")
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
+                .schema(AllJavaTypes.class, StringOnly.class)
+                .name("schemaversion_v1.realm")
+                .schemaVersion(2)
+                .build();
+
+        // Add v1 of the Realm to the file system. v1 is missing the class `StringOnly`
+        configFactory.copyRealmFromAssets(context, "schemaversion_v1.realm", config);
+
+        // Opening the Realm should automatically upgrade the schema and version
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(config);
+            assertEquals(2, realm.getVersion());
+            assertTrue(realm.getSchema().contains(StringOnly.class.getSimpleName()));
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
+
+    @Test
+    public void schemaVersion_throwsIfNotUpdatedForSchemaUpgrade() throws IOException {
+        SyncUser user = createTestUser();
+        String url = "realm://ros.realm.io/~/default";
+        @SuppressWarnings("unchecked")
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
+                .schema(AllJavaTypes.class, StringOnly.class)
+                .name("schemaversion_v1.realm")
+                .schemaVersion(1)
+                .build();
+
+        // Add v1 of the Realm to the file system. v1 is missing the class `StringOnly`
+        configFactory.copyRealmFromAssets(context, "schemaversion_v1.realm", config);
+
+        // Opening the Realm should throw an exception since the schema changed, but the provided schema version is
+        // the same.
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(config);
+            fail();
+        } catch(IllegalArgumentException ignore) {
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
+
+    // Check that it is possible for multiple users to reference the same Realm URL while each user still use their
+    // own copy on the filesystem. This is e.g. what happens if a Realm is shared using a PermissionOffer.
+    @Test
+    public void multipleUsersReferenceSameRealm() {
+        SyncUser user1 = createNamedTestUser("user1");
+        SyncUser user2 = createNamedTestUser("user2");
+        String sharedUrl = "realm://ros.realm.io/42/default";
+        SyncConfiguration config1 = new SyncConfiguration.Builder(user1, sharedUrl).build();
+        Realm realm1 = Realm.getInstance(config1);
+        SyncConfiguration config2 = new SyncConfiguration.Builder(user2, sharedUrl).build();
+        Realm realm2 = null;
+
+        // Verify that two different configurations can be used for the same URL
+        try {
+            realm2 = Realm.getInstance(config1);
+        } finally {
+            realm1.close();
+            if (realm2 != null) {
+                realm2.close();
+            }
+        }
+
+        // Verify that we actually save two different files
+        assertNotEquals(config1.getPath(), config2.getPath());
+    }
+
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
index 510bfca5aa..47fb8dd437 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
@@ -51,12 +51,17 @@ public void setUp() {
             public void put(SyncUser user) {}
 
             @Override
-            public SyncUser get() {
+            public SyncUser getCurrent() {
                 return null;
             }
 
             @Override
-            public void remove() {}
+            public SyncUser get(String identity) {
+                return null;
+            }
+
+            @Override
+            public void remove(String identity) {}
 
             @Override
             public Collection<SyncUser> allUsers() {
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
index 18a8eb9aea..27f92b0dce 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -31,7 +31,7 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
-import java.util.Collection;
+import java.util.Map;
 import java.util.UUID;
 
 import io.realm.internal.network.AuthenticateResponse;
@@ -136,7 +136,7 @@ public void currentUser_clearedOnLogout() {
     // `all()` returns an empty list if no users are logged in
     @Test
     public void all_empty() {
-        Collection<SyncUser> users = SyncUser.all();
+        Map<String, SyncUser> users = SyncUser.all();
         assertTrue(users.isEmpty());
     }
 
@@ -148,9 +148,9 @@ public void all_validUsers() {
         userStore.put(SyncTestUtils.createTestUser(Long.MIN_VALUE));
         userStore.put(SyncTestUtils.createTestUser(Long.MAX_VALUE));
 
-        Collection<SyncUser> users = SyncUser.all();
+        Map<String, SyncUser> users = SyncUser.all();
         assertEquals(1, users.size());
-        assertTrue(users.iterator().next().isValid());
+        assertTrue(users.entrySet().iterator().next().getValue().isValid());
     }
 
     // Tests that the user store returns the last user to login
@@ -197,4 +197,19 @@ public void toString_returnDescription() {
         assertTrue(str != null && !str.isEmpty());
     }
 
+    // Test that a login with an access token logs the user in directly without touching the network
+    @Test
+    public void login_withAccessToken() {
+        AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
+        when(authServer.loginUser(any(SyncCredentials.class), any(URL.class))).thenThrow(new AssertionError("Server contacted."));
+        AuthenticationServer originalServer = SyncManager.getAuthServer();
+        SyncManager.setAuthServerImpl(authServer);
+        try {
+            SyncCredentials credentials = SyncCredentials.accessToken("foo", "bar");
+            SyncUser user = SyncUser.login(credentials, "http://ros.realm.io/auth");
+            assertTrue(user.isValid());
+        } finally {
+            SyncManager.setAuthServerImpl(originalServer);
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/internal/objectserver/ObjectServerUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/internal/objectserver/ObjectServerUserTests.java
new file mode 100644
index 0000000000..aa68bf09f7
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/internal/objectserver/ObjectServerUserTests.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.objectserver;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertTrue;
+
+@RunWith(AndroidJUnit4.class)
+public class ObjectServerUserTests {
+
+    private static final URL authUrl;
+
+    static {
+        try {
+            authUrl = new URL("http://localhost/auth");
+        } catch (MalformedURLException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+
+    private static ObjectServerUser createFakeUser(String id) {
+        final Token token = new Token("token_value", id, "path_value", Long.MAX_VALUE, null);
+        return new ObjectServerUser(token, authUrl);
+    }
+
+    @Test
+    public void equals_validUser() {
+        final ObjectServerUser user1 = createFakeUser("id_value");
+        final ObjectServerUser user2 = createFakeUser("id_value");
+        assertTrue(user1.equals(user2));
+    }
+
+    @Test
+    public void equals_loggedOutUser() {
+        final ObjectServerUser user1 = createFakeUser("id_value");
+        final ObjectServerUser user2 = createFakeUser("id_value");
+        user1.clearTokens();
+        user2.clearTokens();
+        assertTrue(user1.equals(user2));
+    }
+
+    @Test
+    public void hashCode_validUser() {
+        final ObjectServerUser user = createFakeUser("id_value");
+        assertNotEquals(0, user.hashCode());
+    }
+
+    @Test
+    public void hashCode_loggedOutUser() {
+        final ObjectServerUser user = createFakeUser("id_value");
+        user.clearTokens();
+        assertNotEquals(0, user.hashCode());
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/rule/TestSyncConfigurationFactory.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/rule/TestSyncConfigurationFactory.java
new file mode 100644
index 0000000000..23b8f908a5
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/rule/TestSyncConfigurationFactory.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.rule;
+
+import io.realm.SyncConfiguration;
+import io.realm.SyncUser;
+
+/**
+ * Test rule used for creating SyncConfigurations. Will ensure that any Realm files are deleted when the
+ * test ends.
+ */
+public class TestSyncConfigurationFactory extends TestRealmConfigurationFactory {
+
+    public SyncConfiguration.Builder createSyncConfigurationBuilder(SyncUser user, String url) {
+        return new SyncConfiguration.Builder(user, url).directory(getRoot());
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
index ef3ead5f2f..cb296dc293 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
@@ -31,29 +31,38 @@
 
 public class SyncTestUtils {
 
-    public static String USER_TOKEN = UUID.randomUUID().toString();
-    public static String REALM_TOKEN = UUID.randomUUID().toString();
-    public static String DEFAULT_AUTH_URL = "http://objectserver.realm.io/auth";
+    public static final String USER_TOKEN = UUID.randomUUID().toString();
+    public static final String REALM_TOKEN = UUID.randomUUID().toString();
+    public static final String DEFAULT_AUTH_URL = "http://objectserver.realm.io/auth";
+    public static final String DEFAULT_USER_IDENTIFIER = "JohnDoe";
 
     public static SyncUser createRandomTestUser() {
-        return createTestUser(UUID.randomUUID().toString(), UUID.randomUUID().toString(), DEFAULT_AUTH_URL, Long.MAX_VALUE);
+        return createTestUser(UUID.randomUUID().toString(),
+                UUID.randomUUID().toString(),
+                UUID.randomUUID().toString(),
+                DEFAULT_AUTH_URL,
+                Long.MAX_VALUE);
     }
 
     public static SyncUser createTestUser() {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_AUTH_URL, Long.MAX_VALUE);
+        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_USER_IDENTIFIER, DEFAULT_AUTH_URL, Long.MAX_VALUE);
     }
 
     public static SyncUser createTestUser(long expires) {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_AUTH_URL, expires);
+        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_USER_IDENTIFIER,  DEFAULT_AUTH_URL, expires);
     }
 
     public static SyncUser createTestUser(String authUrl) {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, authUrl, Long.MAX_VALUE);
+        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_USER_IDENTIFIER,  authUrl, Long.MAX_VALUE);
     }
 
-    public static SyncUser createTestUser(String userTokenValue, String realmTokenValue, String authUrl, long expires) {
-        Token userToken = new Token(userTokenValue, "JohnDoe", null, expires, null);
-        Token accessToken = new Token(realmTokenValue, "JohnDoe", "/foo", expires, new Token.Permission[] {Token.Permission.DOWNLOAD });
+    public static SyncUser createNamedTestUser(String userIdentifier) {
+        return createTestUser(USER_TOKEN, REALM_TOKEN, userIdentifier, DEFAULT_AUTH_URL, Long.MAX_VALUE);
+    }
+
+    public static SyncUser createTestUser(String userTokenValue, String realmTokenValue, String userIdentifier, String authUrl, long expires) {
+        Token userToken = new Token(userTokenValue, userIdentifier, null, expires, null);
+        Token accessToken = new Token(realmTokenValue, userIdentifier, "/foo", expires, new Token.Permission[] {Token.Permission.DOWNLOAD });
         ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(accessToken, "/data/data/myapp/files/default", false);
 
         JSONObject obj = new JSONObject();
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index cb52a9454c..dadf5648c1 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -164,6 +164,8 @@ file(GLOB objectstore_SRC
 # Sync needed Object Store files
 if (build_SYNC)
     file(GLOB objectstore_sync_SRC
+        "object-store/src/results.cpp"
+        "object-store/src/impl/results_notifier.cpp"
         "object-store/src/sync/*.cpp"
         "object-store/src/sync/impl/*.cpp")
 endif()
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
index a3f98fc0ca..e4a0a4a60f 100644
--- a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
@@ -23,20 +23,37 @@
 
 using namespace realm;
 
-static const char* ERR_NO_LOGGED_IN_USER = "No user logged in yet.";
 static const char* ERR_COULD_NOT_ALLOCATE_MEMORY = "Could not allocate memory to return all users.";
 
+static jstring
+to_user_string_or_null (JNIEnv *env, const std::shared_ptr<SyncUser>& user)
+{
+    if (user) {
+        return to_jstring(env, user->refresh_token().data());
+    } else {
+        return nullptr;
+    }
+}
+
 JNIEXPORT jstring JNICALL
 Java_io_realm_RealmFileUserStore_nativeGetCurrentUser (JNIEnv *env, jclass)
 {
     TR_ENTER()
     try {
-        const std::shared_ptr<SyncUser> &user = SyncManager::shared().get_current_user();
-        if (user) {
-            return to_jstring(env, user->refresh_token().data());
-        } else {
-            return nullptr;
-        }
+        const std::shared_ptr<SyncUser>& user = SyncManager::shared().get_current_user();
+        return to_user_string_or_null(env, user);
+    } CATCH_STD()
+    return nullptr;
+}
+
+JNIEXPORT jstring JNICALL
+Java_io_realm_RealmFileUserStore_nativeGetUser (JNIEnv *env, jclass, jstring identity)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor id(env, identity); // throws
+        const std::shared_ptr<SyncUser>& user = SyncManager::shared().get_existing_logged_in_user(id);
+        return to_user_string_or_null(env, user);
     } CATCH_STD()
     return nullptr;
 }
@@ -55,15 +72,14 @@ Java_io_realm_RealmFileUserStore_nativeUpdateOrCreateUser (JNIEnv *env, jclass,
 }
 
 JNIEXPORT void JNICALL
-Java_io_realm_RealmFileUserStore_nativeLogoutCurrentUser (JNIEnv *env, jclass)
+Java_io_realm_RealmFileUserStore_nativeLogoutUser (JNIEnv *env, jclass, jstring identity)
 {
     TR_ENTER()
     try {
-        const std::shared_ptr<SyncUser>& user = SyncManager::shared().get_current_user();
+        JStringAccessor id(env, identity); // throws
+        const std::shared_ptr<SyncUser>& user = SyncManager::shared().get_existing_logged_in_user(id);
         if (user) {
             user->log_out();
-        } else {
-            throw std::runtime_error(ERR_NO_LOGGED_IN_USER);
         }
     } CATCH_STD()
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
index 17406c075b..fb45d1936f 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
@@ -31,6 +31,9 @@
 
 #include "jni_util/log.hpp"
 #include "jni_util/jni_utils.hpp"
+#include "sync/sync_manager.hpp"
+#include "sync/sync_user.hpp"
+#include "util.hpp"
 
 using namespace realm;
 using namespace realm::sync;
@@ -59,3 +62,13 @@ Java_io_realm_SyncManager_nativeRunClient(JNIEnv *env, jclass)
         sync_client->run();
     } CATCH_STD()
 }
+
+JNIEXPORT void JNICALL
+Java_io_realm_SyncManager_nativeConfigureMetaDataSystem(JNIEnv *env, jclass,
+                                                        jstring baseFile) {
+    TR_ENTER()
+    try {
+        JStringAccessor base_file_path(env, baseFile); // throws
+        SyncManager::shared().configure_file_system(base_file_path, SyncManager::MetadataMode::NoEncryption);
+    } CATCH_STD()
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
index 37614dde25..76cfd7a2b0 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -42,7 +42,7 @@ Java_io_realm_internal_SharedRealm_nativeInit(JNIEnv *env, jclass, jstring tempo
 
 JNIEXPORT jlong JNICALL
 Java_io_realm_internal_SharedRealm_nativeCreateConfig(JNIEnv *env, jclass, jstring realm_path, jbyteArray key,
-        jbyte schema_mode, jboolean in_memory, jboolean cache, jboolean disable_format_upgrade,
+        jbyte schema_mode, jboolean in_memory, jboolean cache, jlong /* schema_version */, jboolean disable_format_upgrade,
         jboolean auto_change_notification, REALM_UNUSED jstring sync_server_url, jstring /*sync_user_token*/)
 {
     TR_ENTER()
@@ -52,6 +52,7 @@ Java_io_realm_internal_SharedRealm_nativeCreateConfig(JNIEnv *env, jclass, jstri
         JniByteArray key_array(env, key);
         Realm::Config *config = new Realm::Config();
         config->path = path;
+        // config->schema_version = schema_version; TODO: Disabled until we remove version handling from Java
         config->encryption_key = key_array;
         config->schema_mode = static_cast<SchemaMode>(schema_mode);
         config->in_memory = in_memory;
@@ -436,9 +437,24 @@ Java_io_realm_internal_SharedRealm_nativeUpdateSchema(JNIEnv *env, jclass, jlong
     try {
         auto shared_realm = *(reinterpret_cast<SharedRealm*>(nativePtr));
         auto *schema = reinterpret_cast<Schema*>(nativeSchemaPtr);
-        shared_realm->update_schema(*schema, static_cast<uint64_t>(version));
+        shared_realm->update_schema(*schema, static_cast<uint64_t>(version), nullptr, true);
     }
     CATCH_STD()
 }
 
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_SharedRealm_nativeRequiresMigration(JNIEnv *env, jclass, jlong nativePtr,
+                                                           jlong nativeSchemaPtr) {
+
+    TR_ENTER()
+    try {
+        auto shared_realm = *(reinterpret_cast<SharedRealm*>(nativePtr));
+        auto *schema = reinterpret_cast<Schema*>(nativeSchemaPtr);
+        const std::vector<SchemaChange> &change_list = shared_realm->schema().compare(*schema);
+        return static_cast<jboolean>(!change_list.empty());
+    }
+    CATCH_STD()
+    return JNI_FALSE;
+}
+
 
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index ac2f607264..0ebca0f031 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit ac2f60726434654cace0bb5e57a92df7555c8f1f
+Subproject commit 0ebca0f03141f52131d6d9f0e6b2f2e32ab9a56d
diff --git a/realm/realm-library/src/main/cpp/objectserver_shared.hpp b/realm/realm-library/src/main/cpp/objectserver_shared.hpp
index bf079cb824..2efb7c8b74 100644
--- a/realm/realm-library/src/main/cpp/objectserver_shared.hpp
+++ b/realm/realm-library/src/main/cpp/objectserver_shared.hpp
@@ -28,6 +28,8 @@
 
 #include <impl/realm_coordinator.hpp>
 #include <sync/sync_manager.hpp>
+#include <object-store/src/sync/impl/sync_metadata.hpp>
+#include <object-store/src/sync/impl/sync_file.hpp>
 
 #include "util.hpp"
 #include "jni_util/jni_utils.hpp"
@@ -61,8 +63,8 @@ class JniSession {
                 coordinator->wake_up_notifier_worker();
             }
         };
-        auto error_handler = [weak_session_ref](std::error_code error_code, bool is_fatal, const std::string message) {
-            if (error_code.category() != realm::sync::protocol_error_category() ||
+        auto error_handler = [weak_session_ref, local_realm_path](std::error_code error_code, bool is_fatal, const std::string message) {
+            if (error_code.category() != realm::sync::protocol_error_category() &&
                     error_code.category() != realm::sync::client_error_category()) {
                 // FIXME: Consider below when moving to the OS sync manager.
                 // Ignore this error since it may cause exceptions in java ErrorCode.fromInt(). Throwing exception there
@@ -74,14 +76,47 @@ class JniSession {
                 return;
             }
 
-            auto session_ref = weak_session_ref.lock();
-            if (session_ref) {
-                session_ref.get()->call_with_local_ref([&](JNIEnv* local_env, jobject obj) {
-                    static realm::jni_util::JavaMethod notify_error_handler(
-                            local_env, obj, "notifySessionError", "(ILjava/lang/String;)V");
-                    local_env->CallVoidMethod(
-                            obj, notify_error_handler, error_code.value(), local_env->NewStringUTF(message.c_str()));
+            // Handle client reset, without returning to Java
+
+            // we don't have the original SyncError so we can't call SyncError#is_client_reset_requested
+            // we need to transform the error code to an enum, then do the check manually
+            using ProtocolError = realm::sync::ProtocolError;
+            auto protocol_error = static_cast<ProtocolError>(error_code.value());
+
+            // Documented here: https://realm.io/docs/realm-object-server/#client-recovery-from-a-backup
+            if (protocol_error == ProtocolError::bad_server_file_ident
+                || protocol_error == ProtocolError::bad_client_file_ident
+                || protocol_error == ProtocolError::bad_server_version
+                || protocol_error == ProtocolError::diverging_histories) {
+
+                // Add a SyncFileActionMetadata marking the Realm as needing to be deleted.
+                auto recovery_path = realm::util::reserve_unique_file_name(
+                        realm::SyncManager::shared().recovery_directory_path(),
+                        realm::util::create_timestamped_template("recovered_realm"));
+                auto original_path = local_realm_path;
+
+                realm::jni_util::Log::d("A client reset is scheduled for the next app start");
+                realm::SyncManager::shared().perform_metadata_update([original_path = std::move(original_path),
+                        recovery_path = std::move(recovery_path)](const auto &manager) {
+                    realm::SyncFileActionMetadata(manager,
+                                                  realm::SyncFileActionMetadata::Action::HandleRealmForClientReset,
+                                                  original_path,
+                                                  "",
+                                                  "",
+                                                  realm::util::Optional<std::string>(
+                                                          std::move(recovery_path)));
                 });
+
+            } else {
+                auto session_ref = weak_session_ref.lock();
+                if (session_ref) {
+                        session_ref.get()->call_with_local_ref([&](JNIEnv* local_env, jobject obj) {
+                            static realm::jni_util::JavaMethod notify_error_handler(
+                                    local_env, obj, "notifySessionError", "(ILjava/lang/String;)V");
+                            local_env->CallVoidMethod(
+                                    obj, notify_error_handler, error_code.value(), local_env->NewStringUTF(message.c_str()));
+                        });
+                }
             }
         };
         m_sync_session->set_sync_transact_callback(sync_transact_callback);
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index 840e0463cf..ee2ee17f0d 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -18,6 +18,7 @@
 #include <stdexcept>
 
 #include <realm/util/assert.hpp>
+#include <realm/util/file.hpp>
 #include <realm/unicode.hpp>
 #include "utf8.hpp"
 
@@ -70,6 +71,10 @@ void ConvertException(JNIEnv* env, const char *file, int line)
         ss << e.what() << " (" <<  e.underlying() <<  ") in " << file << " line " << line;
         ThrowRealmFileException(env, ss.str(), e.kind());
     }
+    catch (File::AccessError& e) {
+        ss << e.what() << " (" <<  e.get_path() <<  ") in " << file << " line " << line;
+        ThrowException(env, FatalError, ss.str());
+    }
     catch (InvalidTransactionException& e) {
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, IllegalState, ss.str());
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 0c02c401b3..f03be41aa0 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -29,17 +29,17 @@
 
 import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.ColumnInfo;
 import io.realm.internal.InvalidRow;
+import io.realm.internal.ObjectServerFacade;
 import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.SharedRealm;
-import io.realm.internal.ColumnInfo;
 import io.realm.internal.Row;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.UncheckedRow;
 import io.realm.internal.Util;
 import io.realm.internal.async.RealmThreadPoolExecutor;
 import io.realm.log.RealmLog;
-import io.realm.internal.ObjectServerFacade;
 import rx.Observable;
 
 /**
@@ -60,7 +60,7 @@
     private static final String NOT_IN_TRANSACTION_MESSAGE =
             "Changing Realm data can only be done from inside a transaction.";
 
-    
+
     volatile static Context applicationContext;
 
     // Thread pool for all async operations (Query & transaction)
@@ -591,7 +591,8 @@ static boolean compactRealm(final RealmConfiguration configuration) {
     /**
      * Migrates the Realm file defined by the given configuration using the provided migration block.
      *
-     * @param configuration configuration for the Realm that should be migrated.
+     * @param configuration configuration for the Realm that should be migrated. If this is a SyncConfiguration this
+     *                      method does nothing.
      * @param migration if set, this migration block will override what is set in {@link RealmConfiguration}.
      * @param callback callback for specific Realm type behaviors.
      * @param cause which triggers this migration.
@@ -600,9 +601,13 @@ static boolean compactRealm(final RealmConfiguration configuration) {
     protected static void migrateRealm(final RealmConfiguration configuration, final RealmMigration migration,
                                        final MigrationCallback callback, final RealmMigrationNeededException cause)
             throws FileNotFoundException {
+
         if (configuration == null) {
             throw new IllegalArgumentException("RealmConfiguration must be provided");
         }
+        if (configuration.isSyncConfiguration()) {
+            return;
+        }
         if (migration == null && configuration.getMigration() == null) {
             throw new RealmMigrationNeededException(configuration.getPath(), "RealmMigration must be provided", cause);
         }
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index fffb1f57eb..56b6f52235 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -149,7 +149,7 @@
     /**
      * Initializes the Realm library and creates a default configuration that is ready to use. It is required to call
      * this method before interacting with any other of the Realm API's.
-     *
+     * <p>
      * A good place is in an {@link android.app.Application} subclass:
      * <pre>
      * {@code
@@ -162,7 +162,7 @@
      * }
      * }
      * </pre>
-     *
+     * <p>
      * Remember to register it in the {@code AndroidManifest.xml} file:
      * <pre>
      * {@code
@@ -281,103 +281,149 @@ static Realm createInstance(RealmConfiguration configuration, ColumnIndices[] gl
 
     static Realm createAndValidate(RealmConfiguration configuration, ColumnIndices[] globalCacheArray) {
         Realm realm = new Realm(configuration);
-        long currentVersion = realm.getVersion();
-        long requiredVersion = configuration.getSchemaVersion();
+
+        final long currentVersion = realm.getVersion();
+        final long requiredVersion = configuration.getSchemaVersion();
+
         final ColumnIndices columnIndices = RealmCache.findColumnIndices(globalCacheArray, requiredVersion);
-        if (currentVersion != UNVERSIONED && currentVersion < requiredVersion && columnIndices == null) {
-            realm.doClose();
-            throw new RealmMigrationNeededException(configuration.getPath(), String.format("Realm on disk need to migrate from v%s to v%s", currentVersion, requiredVersion));
-        }
-        if (currentVersion != UNVERSIONED && requiredVersion < currentVersion && columnIndices == null) {
-            realm.doClose();
-            throw new IllegalArgumentException(String.format("Realm on disk is newer than the one specified: v%s vs. v%s", currentVersion, requiredVersion));
-        }
 
-        // Initialize Realm schema if needed
-        if (columnIndices == null) {
+        if (columnIndices != null) {
+            // copy global cache as a Realm local indices cache
+            realm.schema.columnIndices = columnIndices.clone();
+        } else {
+            final boolean syncingConfig = configuration.isSyncConfiguration();
+
+            if (!syncingConfig && (currentVersion != UNVERSIONED)) {
+                if (currentVersion < requiredVersion) {
+                    realm.doClose();
+                    throw new RealmMigrationNeededException(
+                            configuration.getPath(),
+                            String.format("Realm on disk need to migrate from v%s to v%s", currentVersion, requiredVersion));
+                }
+                if (requiredVersion < currentVersion) {
+                    realm.doClose();
+                    throw new IllegalArgumentException(
+                            String.format("Realm on disk is newer than the one specified: v%s vs. v%s", currentVersion, requiredVersion));
+                }
+            }
+
+            // Initialize Realm schema if needed
             try {
-                initializeRealm(realm);
+                if (!syncingConfig) {
+                    initializeRealm(realm);
+                } else {
+                    initializeSyncedRealm(realm);
+                }
             } catch (RuntimeException e) {
                 realm.doClose();
                 throw e;
             }
-        } else {
-            // copy global cache as a Realm local indices cache
-            realm.schema.columnIndices = columnIndices.clone();
         }
 
         return realm;
     }
 
-    @SuppressWarnings("unchecked")
     private static void initializeRealm(Realm realm) {
-        long version = realm.getVersion();
-        boolean commitNeeded = false;
-        boolean syncAvailable = realm.configuration.isSyncConfiguration();
-
+        // Everything in this method needs to be behind a transaction lock to prevent multi-process interaction while
+        // the Realm is initialized.
+        boolean commitChanges = false;
         try {
-            if (!syncAvailable) {
-                realm.beginTransaction();
-                if (version == UNVERSIONED) {
-                    commitNeeded = true;
-                    realm.setVersion(realm.configuration.getSchemaVersion());
-                }
-            }
+            realm.beginTransaction();
+            long currentVersion = realm.getVersion();
+            boolean unversioned = currentVersion == UNVERSIONED;
+            commitChanges = unversioned;
 
-            RealmProxyMediator mediator = realm.configuration.getSchemaMediator();
+            if (unversioned) {
+                realm.setVersion(realm.configuration.getSchemaVersion());
+            }
+            final RealmProxyMediator mediator = realm.configuration.getSchemaMediator();
             final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
-            final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap;
-            columnInfoMap = new HashMap<Class<? extends RealmModel>, ColumnInfo>(modelClasses.size());
-            ArrayList<RealmObjectSchema> realmObjectSchemas = new ArrayList<>();
-            RealmSchema realmSchemaCache = new RealmSchema();
+
+            final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
             for (Class<? extends RealmModel> modelClass : modelClasses) {
                 // Create and validate table
-                if (version == UNVERSIONED && !syncAvailable) {
+                if (unversioned) {
                     mediator.createTable(modelClass, realm.sharedRealm);
                 }
-                if (syncAvailable) {
-                    RealmObjectSchema realmObjectSchema = mediator.createRealmObjectSchema(modelClass, realmSchemaCache);
-                    realmObjectSchemas.add(realmObjectSchema);
-                } else {
-                    columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
+                columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
+            }
+
+            realm.schema.columnIndices = new ColumnIndices(
+                    (unversioned) ? realm.configuration.getSchemaVersion() : currentVersion, columnInfoMap);
+
+            if (unversioned) {
+                final Transaction transaction = realm.configuration.getInitialDataTransaction();
+                if (transaction != null) {
+                    transaction.execute(realm);
                 }
             }
-            if (syncAvailable) {
-                RealmSchema schema = new RealmSchema(realmObjectSchemas);
-                // Assumption: when SyncConfiguration then additive schema update mode
-                realm.sharedRealm.updateSchema(schema, version);
-                for (Class<? extends RealmModel> modelClass : modelClasses) {
-                    columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
+        } catch (Exception e) {
+            commitChanges = false;
+            throw e;
+        } finally {
+            if (commitChanges) {
+                realm.commitTransaction(false);
+            } else {
+                realm.cancelTransaction();
+            }
+        }
+    }
+
+    private static void initializeSyncedRealm(Realm realm) {
+        // Everything in this method needs to be behind a transaction lock to prevent multi-process interaction while
+        // the Realm is initialized.
+        boolean commitChanges = false;
+        try {
+            realm.beginTransaction();
+            long currentVersion = realm.getVersion();
+            final boolean unversioned = (currentVersion == UNVERSIONED);
+
+            final RealmProxyMediator mediator = realm.configuration.getSchemaMediator();
+            final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
+
+            final ArrayList<RealmObjectSchema> realmObjectSchemas = new ArrayList<>();
+            final RealmSchema realmSchemaCache = new RealmSchema();
+            for (Class<? extends RealmModel> modelClass : modelClasses) {
+                RealmObjectSchema realmObjectSchema = mediator.createRealmObjectSchema(modelClass, realmSchemaCache);
+                realmObjectSchemas.add(realmObjectSchema);
+            }
+
+            // Assumption: when SyncConfiguration then additive schema update mode
+            final RealmSchema schema = new RealmSchema(realmObjectSchemas);
+            long newVersion = realm.configuration.getSchemaVersion();
+            if (realm.sharedRealm.requiresMigration(schema)) {
+                if (currentVersion >= newVersion) {
+                    throw new IllegalArgumentException(String.format("The schema was changed but the schema version " +
+                            "was not updated. The configured schema version (%d) must be higher than the one in the Realm " +
+                            "file (%d) in order to update the schema.", newVersion, currentVersion));
                 }
+                realm.sharedRealm.updateSchema(schema, newVersion);
+                // The OS currently does not handle setting the schema version. We have to do it manually.
+                realm.setVersion(newVersion);
+                commitChanges = true;
             }
-            realm.schema.columnIndices = new ColumnIndices(
-                    (version == UNVERSIONED) ? realm.configuration.getSchemaVersion() : version,
-                    columnInfoMap);
 
-            if (version == UNVERSIONED) {
-                final Transaction transaction = realm.getConfiguration().getInitialDataTransaction();
+            final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
+            for (Class<? extends RealmModel> modelClass : modelClasses) {
+                columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
+            }
+
+            realm.schema.columnIndices = new ColumnIndices((unversioned) ? newVersion : currentVersion, columnInfoMap);
+
+            if (unversioned) {
+                final Transaction transaction = realm.configuration.getInitialDataTransaction();
                 if (transaction != null) {
-                    if (syncAvailable) {
-                        realm.executeTransaction(transaction);
-                        realm.executeTransaction(new Transaction() {
-                            @Override
-                            public void execute(Realm realm) {
-                                realm.setVersion(realm.configuration.getSchemaVersion());
-                            }
-                        });
-                    } else {
-                        transaction.execute(realm);
-                    }
+                    transaction.execute(realm);
                 }
-
             }
+        } catch (Exception e) {
+            commitChanges = false;
+            throw e;
         } finally {
-            if (!syncAvailable) {
-                if (commitNeeded) {
-                    realm.commitTransaction(false);
-                } else {
-                    realm.cancelTransaction();
-                }
+            if (commitChanges) {
+                realm.commitTransaction(false);
+            } else {
+                realm.cancelTransaction();
             }
         }
     }
@@ -798,7 +844,7 @@ private Scanner getFullStringScanner(InputStream in) {
      */
     public <E extends RealmModel> E createObject(Class<E> clazz) {
         checkIfValid();
-        return createObjectInternal(clazz, true, Collections.<String> emptyList());
+        return createObjectInternal(clazz, true, Collections.<String>emptyList());
     }
 
     /**
@@ -811,9 +857,10 @@ private Scanner getFullStringScanner(InputStream in) {
      * @throws RealmException if the primary key is defined in the model class or an object cannot be created.
      */
     // called from proxy classes
-    <E extends RealmModel> E createObjectInternal(Class<E> clazz,
-                                                            boolean acceptDefaultValue,
-                                                            List<String> excludeFields) {
+    <E extends RealmModel> E createObjectInternal(
+            Class<E> clazz,
+            boolean acceptDefaultValue,
+            List<String> excludeFields) {
         Table table = schema.getTable(clazz);
         // Check and throw the exception earlier for a better exception message.
         if (table.hasPrimaryKey()) {
@@ -841,7 +888,7 @@ private Scanner getFullStringScanner(InputStream in) {
      */
     public <E extends RealmModel> E createObject(Class<E> clazz, Object primaryKeyValue) {
         checkIfValid();
-        return createObjectInternal(clazz, primaryKeyValue, true, Collections.<String> emptyList());
+        return createObjectInternal(clazz, primaryKeyValue, true, Collections.<String>emptyList());
     }
 
     /**
@@ -857,9 +904,11 @@ private Scanner getFullStringScanner(InputStream in) {
      * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
      */
     // called from proxy classes
-    <E extends RealmModel> E createObjectInternal(Class<E> clazz, Object primaryKeyValue,
-                                                            boolean acceptDefaultValue,
-                                                            List<String> excludeFields) {
+    <E extends RealmModel> E createObjectInternal(
+            Class<E> clazz,
+            Object primaryKeyValue,
+            boolean acceptDefaultValue,
+            List<String> excludeFields) {
         Table table = schema.getTable(clazz);
         long rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
         return get(clazz, rowIndex, acceptDefaultValue, excludeFields);
@@ -894,7 +943,7 @@ private Scanner getFullStringScanner(InputStream in) {
      * @param object {@link io.realm.RealmObject} to copy or update.
      * @return the new or updated RealmObject with all its properties backed by the Realm.
      * @throws java.lang.IllegalArgumentException if the object is {@code null} or doesn't have a Primary key defined
-     *  or it belongs to a Realm instance in a different thread.
+     *                                            or it belongs to a Realm instance in a different thread.
      * @see #copyToRealm(RealmModel)
      */
     public <E extends RealmModel> E copyToRealmOrUpdate(E object) {
@@ -984,9 +1033,9 @@ public void insert(Collection<? extends RealmModel> objects) {
      *
      * @param object RealmObjects to insert.
      * @throws IllegalStateException if the corresponding Realm is closed, called from an incorrect thread or not in a
-     * transaction.
+     *                                transaction.
      * @throws io.realm.exceptions.RealmPrimaryKeyConstraintException if two objects with the same primary key is
-     * inserted or if a primary key value already exists in the Realm.
+     *                                                                inserted or if a primary key value already exists in the Realm.
      * @see #copyToRealm(RealmModel)
      */
     public void insert(RealmModel object) {
@@ -1021,7 +1070,6 @@ public void insert(RealmModel object) {
      * transaction.
      * @throws io.realm.exceptions.RealmPrimaryKeyConstraintException if two objects with the same primary key is
      * inserted or if a primary key value already exists in the Realm.
-     *
      * @see #copyToRealmOrUpdate(Iterable)
      */
     public void insertOrUpdate(Collection<? extends RealmModel> objects) {
@@ -1134,7 +1182,7 @@ public void insertOrUpdate(RealmModel object) {
      * @param <E> type of object.
      * @return an in-memory detached copy of the RealmObjects.
      * @throws IllegalArgumentException if {@code maxDepth < 0}, the RealmObject is no longer accessible or it is a
-     *         {@link DynamicRealmObject}.
+     *                                  {@link DynamicRealmObject}.
      * @see #copyToRealmOrUpdate(Iterable)
      */
     public <E extends RealmModel> List<E> copyFromRealm(Iterable<E> realmObjects, int maxDepth) {
@@ -1192,7 +1240,7 @@ public void insertOrUpdate(RealmModel object) {
      * @param <E> type of object.
      * @return an in-memory detached copy of the managed {@link RealmObject}.
      * @throws IllegalArgumentException if {@code maxDepth < 0}, the RealmObject is no longer accessible or it is a
-     *         {@link DynamicRealmObject}.
+     *                                  {@link DynamicRealmObject}.
      * @see #copyToRealmOrUpdate(RealmModel)
      */
     public <E extends RealmModel> E copyFromRealm(E realmObject, int maxDepth) {
@@ -1327,7 +1375,7 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction, fin
 
         // If the user provided a Callback then we make sure, the current Realm has a Handler
         // we can use to deliver the result
-        if ((onSuccess != null || onError != null)  && !hasValidNotifier()) {
+        if ((onSuccess != null || onError != null) && !hasValidNotifier()) {
             throw new IllegalStateException("Your Realm is opened from a thread without a Looper" +
                     " and you provided a callback, we need a Handler to invoke your callback");
         }
@@ -1576,7 +1624,7 @@ Table getTable(Class<? extends RealmModel> clazz) {
      * @param globalCacheArray global cache of column indices. If it contains an entry for current
      *                         schema version, this method only copies the indices information in the entry.
      * @return newly created indices information for current schema version. Or {@code null} if
-     *          {@code globalCacheArray} already contains the entry for current schema version.
+     *         {@code globalCacheArray} already contains the entry for current schema version.
      */
     ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
         final long currentSchemaVersion = sharedRealm.getSchemaVersion();
@@ -1681,6 +1729,7 @@ public static int getLocalInstanceCount(RealmConfiguration configuration) {
          */
         class Callback {
             public void onSuccess() {}
+
             public void onError(Exception e) {}
         }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index 7cd6d6fcd4..2eab03463b 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -66,7 +66,7 @@
     public static final int KEY_LENGTH = 64;
 
     private static final Object DEFAULT_MODULE;
-    private static final RealmProxyMediator DEFAULT_MODULE_MEDIATOR;
+    protected static final RealmProxyMediator DEFAULT_MODULE_MEDIATOR;
     private static Boolean rxJavaAvailable;
 
     static {
@@ -453,7 +453,7 @@ public Builder directory(File directory) {
         }
 
         /**
-         * Sets the 64 bit key used to encrypt and decrypt the Realm file.
+         * Sets the 64 byte key used to encrypt and decrypt the Realm file.
          * Sets the {@value io.realm.RealmConfiguration#KEY_LENGTH} bytes key used to encrypt and decrypt the Realm file.
          */
         public Builder encryptionKey(byte[] key) {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index cc3f52827e..82aca6f7b8 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -199,6 +199,7 @@ public static SharedRealm getInstance(RealmConfiguration config, RealmNotifier r
                 rosServerUrl != null ? SchemaMode.SCHEMA_MODE_ADDITIVE.getNativeValue() : SchemaMode.SCHEMA_MODE_MANUAL.getNativeValue(),
                 config.getDurability() == Durability.MEM_ONLY,
                 enable_caching,
+                config.getSchemaVersion(),
                 disableFormatUpgrade,
                 autoChangeNotifications,
                 rosServerUrl,
@@ -326,10 +327,18 @@ public boolean compact() {
         return nativeCompact(nativePtr);
     }
 
+    /**
+     * Update the underlying schema based on the schema description.
+     * Calling this method must be done from inside a write transaction.
+     */
     public void updateSchema(RealmSchema schema, long version) {
         nativeUpdateSchema(nativePtr, schema.getNativePtr(), version);
     }
 
+    public boolean requiresMigration(RealmSchema schema) {
+        return nativeRequiresMigration(nativePtr, schema.getNativePtr());
+    }
+
     @Override
     public void close() {
         if (realmNotifier != null) {
@@ -372,7 +381,7 @@ public void invokeSchemaChangeListenerIfSchemaChanged() {
 
     private static native void nativeInit(String temporaryDirectoryPath);
     private static native long nativeCreateConfig(String realmPath, byte[] key, byte schemaMode, boolean inMemory,
-                                                  boolean cache, boolean disableFormatUpgrade,
+                                                  boolean cache, long schemaVersion, boolean disableFormatUpgrade,
                                                   boolean autoChangeNotification,
                                                   String syncServerURL, String syncUserToken);
     private static native void nativeCloseConfig(long nativeConfigPtr);
@@ -402,4 +411,5 @@ private static native long nativeCreateConfig(String realmPath, byte[] key, byte
     private static native void nativeStopWaitForChange(long nativeSharedRealmPtr);
     private static native boolean nativeCompact(long nativeSharedRealmPtr);
     private static native void nativeUpdateSchema(long nativePtr, long nativeSchemaPtr, long version);
+    private static native boolean nativeRequiresMigration(long nativePtr, long nativeSchemaPtr);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/AuthenticationListener.java b/realm/realm-library/src/objectServer/java/io/realm/AuthenticationListener.java
index c769a7d693..3602509d82 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/AuthenticationListener.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/AuthenticationListener.java
@@ -16,13 +16,9 @@
 
 package io.realm;
 
-import io.realm.annotations.Beta;
-
 /**
- * @Beta
  * Interface describing events related to Users and their authentication
  */
-@Beta
 public interface AuthenticationListener {
     /**
      * A user was logged into the Object Server
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
index 17e0365396..4c443e314f 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
@@ -16,16 +16,12 @@
 
 package io.realm;
 
-import io.realm.annotations.Beta;
-
 /**
- * @Beta
  * This class enumerate all potential errors related to using the Object Server or synchronizing data.
  */
-@Beta
 public enum ErrorCode {
 
-    // See https://github.com/realm/realm-sync/blob/master/doc/protocol.md
+    // See https://github.com/realm/realm-sync/blob/master/doc/protocol_16.md
 
     // Realm Java errors (0-49)
     UNKNOWN(-1),                                // Catch-all
@@ -63,6 +59,7 @@
     BAD_CLIENT_VERSION(210),                        // Bad client version (IDENT, UPLOAD)
     DIVERGING_HISTORIES(211),                       // Diverging histories (IDENT)
     BAD_CHANGESET(212),                             // Bad changeset (UPLOAD)
+    DISABLED_SESSION(213),                          // Disabled session
 
     // 300 - 599 Reserved for Standard HTTP error codes
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java b/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
index 9e8abe33a4..5ab8d01656 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
@@ -19,17 +19,14 @@
 import android.content.Context;
 import android.content.pm.PackageInfo;
 
-import io.realm.annotations.Beta;
 import io.realm.internal.Keep;
 
 /**
- * @Beta
  * Internal initializer class for the Object Server.
  * Use to keep the `SyncManager` free from Android dependencies
  */
 @SuppressWarnings("unused")
 @Keep
-@Beta
 class ObjectServer {
 
     public static void init(Context context) {
@@ -45,5 +42,10 @@ public static void init(Context context) {
         UserStore userStore = new RealmFileUserStore(context.getFilesDir().getPath());
 
         SyncManager.init(appId, userStore);
+
+        // init the "sync_manager.cpp" metadata Realm, this is also needed later, when re try
+        // to schedule a client reset. in realm-java#master this is already done, when initialising
+        // the RealmFileUserStore (not available now on releases)
+        SyncManager.nativeConfigureMetaDataSystem(context.getFilesDir().getPath());
     }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ObjectServerError.java b/realm/realm-library/src/objectServer/java/io/realm/ObjectServerError.java
index 56109037f8..90cdc9c65b 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ObjectServerError.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ObjectServerError.java
@@ -16,11 +16,9 @@
 
 package io.realm;
 
-import io.realm.annotations.Beta;
 import io.realm.internal.Util;
 
 /**
- * @Beta
  * This class is a wrapper for all errors happening when communicating with the Realm Object Server.
  * This include both exceptions and protocol errors.
  *
@@ -30,7 +28,6 @@
  *
  * @see ErrorCode for a list of possible errors.
  */
-@Beta
 public class ObjectServerError extends RuntimeException {
 
     private final ErrorCode error;
diff --git a/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
index 0d89455e30..9ba14bff4e 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
@@ -42,20 +42,26 @@ public void put(SyncUser user) {
      * {@inheritDoc}
      */
     @Override
-    public SyncUser get() {
+    public SyncUser getCurrent() {
         String userJson = nativeGetCurrentUser();
-        if (userJson != null) {
-            return SyncUser.fromJson(userJson);
-        }
-        return null;
+        return toSyncUserOrNull(userJson);
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
-    public void remove() {
-        nativeLogoutCurrentUser();
+    public SyncUser get(String identity) {
+        String userJson = nativeGetUser(identity);
+        return toSyncUserOrNull(userJson);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void remove(String identity) {
+        nativeLogoutUser(identity);
     }
 
     /**
@@ -74,17 +80,27 @@ public void remove() {
         return Collections.emptyList();
     }
 
+    private static SyncUser toSyncUserOrNull(String userJson) {
+        if (userJson == null) {
+            return null;
+        }
+        return SyncUser.fromJson(userJson);
+    }
+
     // init and load the Metadata Realm containing SyncUsers
     protected static native void nativeConfigureMetaDataSystem(String baseFile);
 
-    // return json data (token) of the current logged in user
+    // returns json data (token) of the current logged in user
     protected static native String nativeGetCurrentUser();
 
+    // returns json data (token) of the specified user
+    protected static native String nativeGetUser(String identity);
+
     protected static native String[] nativeGetAllUsers();
 
     protected static native void nativeUpdateOrCreateUser(String identity, String jsonToken, String url);
 
-    protected static native void nativeLogoutCurrentUser();
+    protected static native void nativeLogoutUser(String identity);
 
     // Should only be called for tests
     static native void nativeResetForTesting();
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SessionState.java b/realm/realm-library/src/objectServer/java/io/realm/SessionState.java
index 9ede02c3fc..d3e167eae7 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SessionState.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SessionState.java
@@ -16,13 +16,9 @@
 
 package io.realm;
 
-import io.realm.annotations.Beta;
-
 /**
- * @Beta
  * Enum describing the various states the Session Finite-State-Machine can be in.
  */
-@Beta
 public enum SessionState {
     INITIAL,          // Initial starting state
     UNBOUND,          // Start done, Realm is unbound.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index bc630cf99b..9ee7b0f868 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -25,11 +25,11 @@
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import io.realm.annotations.Beta;
 import io.realm.annotations.RealmModule;
 import io.realm.exceptions.RealmException;
 import io.realm.internal.RealmProxyMediator;
@@ -40,7 +40,6 @@
 import io.realm.rx.RxObservableFactory;
 
 /**
- * @Beta
  * An {@link SyncConfiguration} is used to setup a Realm that can be synchronized between devices using the Realm
  * Object Server.
  * <p>
@@ -70,12 +69,8 @@
  * Synchronized Realms are created by using {@link Realm#getInstance(RealmConfiguration)} and
  * {@link Realm#getDefaultInstance()} like ordinary unsynchronized Realms.
  */
-@Beta
 public class SyncConfiguration extends RealmConfiguration {
 
-    public static final int PORT_REALM = 80;
-    public static final int PORT_REALMS = 443;
-
     // The FAT file system has limitations of length. Also, not all characters are permitted.
     // https://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx
     public static final int MAX_FULL_PATH_LENGTH = 256;
@@ -244,6 +239,7 @@ boolean isSyncConfiguration() {
         private String fileName;
         private boolean overrideDefaultLocalFileName = false;
         private byte[] key;
+        private long schemaVersion = 0;
         private HashSet<Object> modules = new HashSet<Object>();
         private HashSet<Class<? extends RealmModel>> debugSchema = new HashSet<Class<? extends RealmModel>>();
         private RxObservableFactory rxFactory;
@@ -429,6 +425,40 @@ public Builder encryptionKey(byte[] key) {
             return this;
         }
 
+        /**
+         * DEBUG method. This restricts the Realm schema to only consist of the provided classes without having to
+         * create a module. These classes must be available in the default module. Calling this will remove any
+         * previously configured modules.
+         */
+        SyncConfiguration.Builder schema(Class<? extends RealmModel> firstClass, Class<? extends RealmModel>... additionalClasses) {
+            if (firstClass == null) {
+                throw new IllegalArgumentException("A non-null class must be provided");
+            }
+            modules.clear();
+            modules.add(DEFAULT_MODULE_MEDIATOR);
+            debugSchema.add(firstClass);
+            if (additionalClasses != null) {
+                Collections.addAll(debugSchema, additionalClasses);
+            }
+
+            return this;
+        }
+
+        /**
+         * Sets the schema version of the Realm. This must be equal to or higher than the schema version of the existing
+         * Realm file, if any. If the schema version is higher than the already existing Realm, a migration is needed.
+         *
+         * @param schemaVersion the schema version.
+         * @throws IllegalArgumentException if schema version is invalid.
+         */
+        public Builder schemaVersion(long schemaVersion) {
+            if (schemaVersion < 0) {
+                throw new IllegalArgumentException("Realm schema version numbers must be 0 (zero) or higher. Yours was: " + schemaVersion);
+            }
+            this.schemaVersion = schemaVersion;
+            return this;
+        }
+
         /**
          * Replaces the existing module(s) with one or more {@link RealmModule}s. Using this method will replace the
          * current schema for this Realm with the schema defined by the provided modules.
@@ -576,10 +606,10 @@ public SyncConfiguration build() {
 
             // Determine location on disk
             // Use the serverUrl + user to create a unique filepath unless it has been explicitly overridden.
-            // <rootDir>/<serverPath>/<serverFileNameOrOverriddenFileName>
+            // <rootDir>/<userIdentifier>/<serverPath>/<serverFileNameOrOverriddenFileName>
             URI resolvedServerUrl = resolveServerUrl(serverUrl, user.getIdentity());
             File rootDir = overrideDefaultFolder ? directory : defaultFolder;
-            String realmPathFromRootDir = getServerPath(resolvedServerUrl);
+            String realmPathFromRootDir = user.getIdentity() + "/" + getServerPath(resolvedServerUrl);
             File realmFileDirectory = new File(rootDir, realmPathFromRootDir);
 
             String realmFileName = overrideDefaultLocalFileName ? fileName : defaultLocalFileName;
@@ -622,7 +652,7 @@ public SyncConfiguration build() {
                     getCanonicalPath(new File(realmFileDirectory, realmFileName)),
                     null, // assetFile not supported by Sync. See https://github.com/realm/realm-sync/issues/241
                     key,
-                    0,
+                    schemaVersion,
                     null, // Custom migrations not supported
                     false, // MigrationNeededException is never thrown
                     durability,
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
index 02e925643c..986e3bfc03 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
@@ -20,10 +20,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import io.realm.annotations.Beta;
-
 /**
- * @Beta
  * Credentials represent a login with a 3rd party login provider in an OAuth2 login flow, and are used by the Realm
  * Object Server to verify the user and grant access.
  * <p>
@@ -63,7 +60,6 @@
  * }
  * </pre>
  */
-@Beta
 public class SyncCredentials {
 
     private final String userIdentifier;
@@ -137,7 +133,7 @@ public static SyncCredentials usernamePassword(String username, String password)
      * Creates a custom set of credentials. The behaviour will depend on the type of {@code identityProvider} and
      * {@code userInfo} used.
      *
-     * @param userIdentifier String identifying the user. Usually a username of userIdentifier.
+     * @param userIdentifier String identifying the user. Usually a username or user token.
      * @param identityProvider provider used to verify the credentials.
      * @param userInfo data describing the user further or {@code null} if the user does not have any extra data. The
      *              data will be serialized to JSON, so all values must be mappable to a valid JSON data type. Custom
@@ -155,6 +151,23 @@ public static SyncCredentials custom(String userIdentifier, String identityProvi
         return new SyncCredentials(userIdentifier, identityProvider, userInfo);
     }
 
+    /**
+     * Creates credentials from an existing access token. Since an access token is the proof that a user already
+     * has logged in. Credentials created this way are automatically assumed to have successfully logged in.
+     * This means that providing this credential to {@link SyncUser#login(SyncCredentials, String)} will always
+     * succeed, but accessing any Realm after might fail if the token is no longer valid.
+     *
+     * @param accessToken user's access token.
+     * @param identifier user identifier.
+     * @return a set of credentials that can be used to log into the Object Server using
+     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}
+     */
+    public static SyncCredentials accessToken(String accessToken, String identifier) {
+        HashMap<String, Object> userInfo = new HashMap<String, Object>();
+        userInfo.put("_token", accessToken);
+        return new SyncCredentials(identifier, IdentityProvider.ACCESS_TOKEN, userInfo);
+    }
+
     private static void assertStringNotEmpty(String string, String message) {
         if (string == null || "".equals(string)) {
             throw new IllegalArgumentException("Non-null '" + message + "' required.");
@@ -201,6 +214,14 @@ public String getUserIdentifier() {
      * verifying that a given credential is valid.
      */
     public static final class IdentityProvider {
+
+        /**
+         * The provided identity is an already registered user (represented by the access token). Logging in with this
+         * type of identity will happen purely on the device without contacting the Realm Object Server. Acquiring
+         * access to individual Realms will still require talking to the Object Server.
+         */
+        public static final String ACCESS_TOKEN = "_access_token";
+
         /**
          * Any credentials verified by the debug identity provider will always be considered valid.
          * It is only available if configured on the Object Server, and it is disabled by default.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index 3406054f72..10a2e1619c 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -22,7 +22,6 @@
 import java.util.concurrent.TimeUnit;
 
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-import io.realm.annotations.Beta;
 import io.realm.internal.Keep;
 import io.realm.internal.network.AuthenticationServer;
 import io.realm.internal.network.OkHttpAuthenticationServer;
@@ -31,7 +30,6 @@
 import io.realm.log.RealmLog;
 
 /**
- * @Beta
  * The SyncManager is the central controller for interacting with the Realm Object Server.
  * It handles the creation of {@link SyncSession}s and it is possible to configure session defaults and the underlying
  * network client using this class.
@@ -43,10 +41,21 @@
  *
  */
 @Keep
-@Beta
 @SuppressFBWarnings("MS_CANNOT_BE_FINAL")
 public class SyncManager {
 
+    /**
+     * Debugging related options.
+     */
+    @SuppressFBWarnings("MS_SHOULD_BE_FINAL")
+    public static class Debug {
+        /**
+         * Set this to true to bypass checking if the device is offline before making HTTP requests.
+         */
+        public static boolean skipOnlineChecking = false;
+
+    }
+
     /**
      * APP ID sent to the Realm Object Server. Is automatically initialized to the package name for the app.
      */
@@ -223,5 +232,6 @@ static void notifyUserLoggedOut(SyncUser user) {
 
     private static native void nativeInitializeSyncClient();
     private static native void nativeRunClient();
-
+    // init and load the Metadata Realm containing SyncUsers
+    protected static native void nativeConfigureMetaDataSystem(String baseFile);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index 046295c876..ad5ff24e39 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -18,13 +18,11 @@
 
 import java.net.URI;
 
-import io.realm.annotations.Beta;
 import io.realm.internal.Keep;
 import io.realm.log.RealmLog;
 import io.realm.internal.objectserver.ObjectServerSession;
 
 /**
- * @Beta
  * This class represents the connection to the Realm Object Server for one {@link SyncConfiguration}.
  * <p>
  * A Session is created by either calling {@link SyncManager#getSession(SyncConfiguration)} or by opening
@@ -39,7 +37,6 @@
  * @see SessionState
  */
 @Keep
-@Beta
 public class SyncSession {
 
     private final ObjectServerSession osSession;
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index c1097e8118..d191e0d278 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -28,13 +28,13 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
-import java.util.ArrayList;
 import java.util.Collection;
-import java.util.List;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.concurrent.Future;
 import java.util.concurrent.ThreadPoolExecutor;
 
-import io.realm.annotations.Beta;
 import io.realm.internal.Util;
 import io.realm.internal.async.RealmAsyncTaskImpl;
 import io.realm.internal.network.AuthenticateResponse;
@@ -47,7 +47,6 @@
 import io.realm.permissions.PermissionModule;
 
 /**
- * @Beta
  * This class represents a user on the Realm Object Server. The credentials are provided by various 3rd party
  * providers (Facebook, Google, etc.).
  * <p>
@@ -58,17 +57,24 @@
  * Persisting a user between sessions, the user's credentials are stored locally on the device, and should be treated
  * as sensitive data.
  */
-@Beta
 public class SyncUser {
 
     private static class ManagementConfig {
         private SyncConfiguration managementRealmConfig;
 
         synchronized SyncConfiguration initAndGetManagementRealmConfig(
-                ObjectServerUser syncUser, SyncUser user) {
+                ObjectServerUser syncUser, final SyncUser user) {
             if (managementRealmConfig == null) {
                 managementRealmConfig = new SyncConfiguration.Builder(
                         user, getManagementRealmUrl(syncUser.getAuthenticationUrl()))
+                        .errorHandler(new SyncSession.ErrorHandler() {
+                            @Override
+                            public void onError(SyncSession session, ObjectServerError error) {
+                                RealmLog.error(String.format("Unexpected error with %s's management Realm: %s",
+                                        user.getIdentity(),
+                                        error.toString()));
+                            }
+                        })
                         .modules(new PermissionModule())
                         .build();
             }
@@ -95,7 +101,7 @@ private SyncUser(ObjectServerUser user) {
      * @throws IllegalStateException if multiple users are logged in.
      */
     public static SyncUser currentUser() {
-        SyncUser user = SyncManager.getUserStore().get();
+        SyncUser user = SyncManager.getUserStore().getCurrent();
         if (user != null && user.isValid()) {
             return user;
         }
@@ -106,18 +112,18 @@ public static SyncUser currentUser() {
      * Returns all valid users known by this device.
      * A user is invalidated when he/she logs out or the user's access token expires.
      *
-     * @return a list of all known valid users.
+     * @return a map from user identifier to user. It includes all known valid users.
      */
-    public static Collection<SyncUser> all() {
+    public static Map<String, SyncUser> all() {
         UserStore userStore = SyncManager.getUserStore();
         Collection<SyncUser> storedUsers = userStore.allUsers();
-        List<SyncUser> result = new ArrayList<SyncUser>(storedUsers.size());
+        Map<String, SyncUser> map = new HashMap<String, SyncUser>();
         for (SyncUser user : storedUsers) {
             if (user.isValid()) {
-                result.add(user);
+                map.put(user.getIdentity(), user);
             }
         }
-        return result;
+        return Collections.unmodifiableMap(map);
     }
 
     /**
@@ -168,10 +174,20 @@ public static SyncUser login(final SyncCredentials credentials, final String aut
             throw new IllegalArgumentException("Invalid URL " + authenticationUrl + ".", e);
         }
 
-        final AuthenticationServer server = SyncManager.getAuthServer();
         ObjectServerError error;
         try {
-            AuthenticateResponse result = server.loginUser(credentials, authUrl);
+            AuthenticateResponse result;
+            if (credentials.getIdentityProvider().equals(SyncCredentials.IdentityProvider.ACCESS_TOKEN)) {
+                // Credentials using ACCESS_TOKEN as IdentityProvider are optimistically assumed to be valid already.
+                // So log them in directly without contacting the authentication server. This is done by mirroring
+                // the JSON response expected from the server.
+                String userIdentifier = credentials.getUserIdentifier();
+                String token = (String) credentials.getUserInfo().get("_token");
+                result = AuthenticateResponse.createValidResponseWithUser(userIdentifier, token);
+            } else {
+                final AuthenticationServer server = SyncManager.getAuthServer();
+                result = server.loginUser(credentials, authUrl);
+            }
             if (result.isValid()) {
                 ObjectServerUser syncUser = new ObjectServerUser(result.getRefreshToken(), authUrl);
                 SyncUser user = new SyncUser(syncUser);
@@ -263,7 +279,7 @@ public void logout() {
         // Acquire lock to prevent users creating new instances
         synchronized (Realm.class) {
             if (!syncUser.isLoggedIn()) {
-                return; // Already logged out
+                return; // Already local/global logout status
             }
 
             // Ensure that we can log out. If any Realm file is still open we should abort before doing anything
@@ -284,11 +300,7 @@ public void logout() {
                 session.getOsSession().stop();
             }
 
-            // Remove all local tokens, preventing further connections.
-            // FIXME We still need to cache the user token so it can be revoked.
-            syncUser.clearTokens();
-
-            SyncManager.getUserStore().remove();
+            SyncManager.getUserStore().remove(syncUser.getIdentity());
 
             // Delete all Realms if needed.
             for (ObjectServerUser.AccessDescription desc : syncUser.getRealms()) {
@@ -302,6 +314,11 @@ public void logout() {
                 }
             }
 
+            // Remove all local tokens, preventing further connections.
+            final Token userToken = syncUser.getUserToken();
+            syncUser.clearTokens();
+            syncUser.localLogout();
+
             // Finally revoke server token. The local user is logged out in any case.
             final AuthenticationServer server = SyncManager.getAuthServer();
             ThreadPoolExecutor networkPoolExecutor = SyncManager.NETWORK_POOL_EXECUTOR;
@@ -309,7 +326,7 @@ public void logout() {
 
                 @Override
                 protected LogoutResponse execute() {
-                    return server.logout(SyncUser.this, syncUser.getAuthenticationUrl());
+                    return server.logout(userToken, syncUser.getAuthenticationUrl());
                 }
 
                 @Override
diff --git a/realm/realm-library/src/objectServer/java/io/realm/UserStore.java b/realm/realm-library/src/objectServer/java/io/realm/UserStore.java
index 052f3759b9..7a7b488337 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/UserStore.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/UserStore.java
@@ -18,10 +18,7 @@
 
 import java.util.Collection;
 
-import io.realm.annotations.Beta;
-
 /**
- * @Beta
  * Interface for classes responsible for saving and retrieving Object Server users again.
  * <p>
  * Any implementation of a User Store is expected to not perform lengthy blocking operations as it might
@@ -30,7 +27,6 @@
  * @see SyncManager#setUserStore(UserStore)
  * @see RealmFileUserStore
  */
-@Beta
 public interface UserStore {
 
     /**
@@ -43,22 +39,28 @@
 
     /**
      * Retrieves the current {@link SyncUser}.
+     * <p>
+     * This method will throw an exception if more than one valid, logged in users exist.
+     * @return {@link SyncUser} object or {@code null} if not found.
+     */
+    SyncUser getCurrent();
+
+    /**
+     * Retrieves specified {@link SyncUser}.
      *
-     * For now, current User cannot be called if more that one valid, logged in user
-     * exists, it will throw an exception.
+     * @param identity identity of the user.
+     * @return {@link SyncUser} object or {@code null} if not found.
      */
-    //TODO when ObjectStore integration of SyncManager is completed & multiple
-    //     users are allowed, consider passing the User identity to lookup apply
-    //     the operation to a particular user.
-    SyncUser get();
+    SyncUser get(String identity);
 
     /**
-     * Removes the current user from the store.
+     * Removes the user from the store.
+     * <p>
+     * If the user is not found, this method does nothing.
+     *
+     * @param identity identity of the user.
      */
-    //TODO when ObjectStore integration of SyncManager is completed & multiple
-    //     users are allowed, consider passing the User identity to lookup apply
-    //     the operation to a particular user.
-    void remove();
+    void remove(String identity);
 
     /**
      * Returns a collection of all users saved in the User store.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java
index cad9ce933a..a5ad8e9190 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java
@@ -50,8 +50,6 @@ protected void setError(ObjectServerError error) {
         this.error = error;
     }
 
-
-
     /**
      * Parse an HTTP error from a Realm Authentication Server. The server returns errors following
      * https://tools.ietf.org/html/rfc7807 with an extra "code" field for Realm specific error codes.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java
index 75e31a0818..e0140385cb 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java
@@ -53,7 +53,7 @@ public static AuthenticateResponse from(Response response) {
             ObjectServerError error = new ObjectServerError(ErrorCode.IO_EXCEPTION, e);
             return new AuthenticateResponse(error);
         }
-        if (response.code() != 200) {
+        if (!response.isSuccessful()) {
             return new AuthenticateResponse(AuthServerResponse.createError(serverResponse, response.code()));
         } else {
             return new AuthenticateResponse(serverResponse);
@@ -74,6 +74,23 @@ public static AuthenticateResponse from(ObjectServerError error) {
         return new AuthenticateResponse(error);
     }
 
+    /**
+     * Helper method for creating a valid user login response. The user returned will be assumed to have all permissions
+     * and doesn't expire.
+     *
+     * @param identifier user identifier.
+     * @param refreshToken user's refresh token.
+     */
+    public static AuthenticateResponse createValidResponseWithUser(String identifier, String refreshToken) {
+        try {
+            JSONObject response = new JSONObject();
+            response.put(JSON_FIELD_REFRESH_TOKEN, new Token(refreshToken, identifier, null, Long.MAX_VALUE, Token.Permission.ALL).toJson());
+            return new AuthenticateResponse(response.toString());
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
     /**
      * Creates an unsuccessful authentication response. This should only happen in case of network or I/O related
      * issues.
@@ -81,7 +98,7 @@ public static AuthenticateResponse from(ObjectServerError error) {
      * @param error the network or I/O error.
      */
     private AuthenticateResponse(ObjectServerError error) {
-        RealmLog.debug("AuthenticateResponse. Error " + error.getErrorMessage());
+        RealmLog.debug("AuthenticateResponse - Error: " + error);
         setError(error);
         this.accessToken = null;
         this.refreshToken = null;
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
index 5cde174353..b217269ad7 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
@@ -55,5 +55,5 @@
      * own refresh token, but if the refresh token for some reason was shared or stolen all these devices will be
      * logged out as well.
      */
-    LogoutResponse logout(SyncUser user, URL authenticationUrl);
+    LogoutResponse logout(Token userToken, URL authenticationUrl);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java
index c7706c27e5..8cb67b56a9 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java
@@ -16,17 +16,37 @@
 
 package io.realm.internal.network;
 
-import io.realm.SyncUser;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import io.realm.internal.objectserver.Token;
 
 /**
  * This class encapsulates a request to log out a user on the Realm Authentication Server. It is responsible for
  * constructing the JSON understood by the Realm Authentication Server.
  */
 public class LogoutRequest {
-    // TODO Endpoint not finished yet
 
-    LogoutRequest fromUser(SyncUser user) {
-        return new LogoutRequest();
+    private final String token;
+
+    public static LogoutRequest revoke(Token userToken) {
+        return new LogoutRequest(userToken.value());
     }
 
+    private LogoutRequest(String token) {
+        this.token = token;
+    }
+
+    /**
+     * Converts the request into a JSON payload.
+     */
+    public String toJson() {
+        try {
+            JSONObject request = new JSONObject();
+            request.put("token", token);
+            return request.toString();
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
+    }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java
index 5439f9f769..ce356546eb 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java
@@ -28,29 +28,32 @@
  */
 public class LogoutResponse extends AuthServerResponse {
 
-    private final ObjectServerError error;
-
     /**
-     * Helper method for creating the proper Authenticate response. This method will set the appropriate error
+     * Helper method for creating the proper Logout response. This method will set the appropriate error
      * depending on any HTTP response codes or I/O errors.
      *
      * @param response the server response.
      * @return the log out response.
      */
-    static LogoutResponse createFrom(Response response) {
-        String serverResponse;
+    static LogoutResponse from(Response response) {
+        if (response.isSuccessful()) {
+            // success
+            return new LogoutResponse();
+        }
         try {
-            serverResponse = response.body().string();
+            String serverResponse = response.body().string();
+            return new LogoutResponse(AuthServerResponse.createError(serverResponse, response.code()));
         } catch (IOException e) {
             ObjectServerError error = new ObjectServerError(ErrorCode.IO_EXCEPTION, e);
             return new LogoutResponse(error);
         }
-        RealmLog.debug("Authenticate response: " + serverResponse);
-        if (response.code() != 200) {
-            return new LogoutResponse(AuthServerResponse.createError(serverResponse, response.code()));
-        } else {
-            return new LogoutResponse(serverResponse);
-        }
+    }
+
+    /**
+     * Helper method for creating a failed response.
+     */
+    public static LogoutResponse from(ObjectServerError error) {
+        return new LogoutResponse(error);
     }
 
     /**
@@ -60,17 +63,16 @@ static LogoutResponse createFrom(Response response) {
      * @param error an authentication response error.
      */
     private LogoutResponse(ObjectServerError error) {
-        this.error = error;
+        RealmLog.debug("Logout response - Error: " + error.getErrorMessage());
+        setError(error);
     }
 
     /**
-     * Parses a valid (200) server response.
-     *
-     * @param serverResponse the server response.
+     * Parses a valid (204) server response.
      */
-    private LogoutResponse(String serverResponse) {
-        this.error = null;
-        // TODO endpoint not finalized
+    private LogoutResponse() {
+        RealmLog.debug("Logout response - Success");
+        setError(null);
     }
 
     /**
@@ -79,16 +81,6 @@ private LogoutResponse(String serverResponse) {
      * @return {@code true} if valid.
      */
     public boolean isValid() {
-//        return (error == null);
-        return true;
-    }
-
-    /**
-     * Returns the error.
-     *
-     * @return the error.
-     */
-    public ObjectServerError getError() {
-        return error;
+        return (error == null) || (error.getErrorCode() == ErrorCode.EXPIRED_REFRESH_TOKEN);
     }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/NetworkStateReceiver.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/NetworkStateReceiver.java
index 5fa68176a9..d7f426d350 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/NetworkStateReceiver.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/NetworkStateReceiver.java
@@ -25,6 +25,7 @@
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
 
+import io.realm.SyncManager;
 import io.realm.internal.Util;
 
 /**
@@ -67,6 +68,9 @@ public static synchronized void removeListener(ConnectionListener listener) {
      * @return {@code true} if device is online, otherwise {@code false}.
      */
     public static boolean isOnline(Context context) {
+        if (SyncManager.Debug.skipOnlineChecking) {
+            return true;
+        }
         ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
         NetworkInfo networkInfo = cm.getActiveNetworkInfo();
         return ((networkInfo != null && networkInfo.isConnectedOrConnecting()) || Util.isEmulator());
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
index c84d408a12..fe580d438b 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
@@ -16,15 +16,16 @@
 
 package io.realm.internal.network;
 
+import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URL;
 import java.util.concurrent.TimeUnit;
 
-import io.realm.SyncCredentials;
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
-import io.realm.SyncUser;
+import io.realm.SyncCredentials;
 import io.realm.internal.objectserver.Token;
+import io.realm.log.RealmLog;
 import okhttp3.Call;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
@@ -76,8 +77,26 @@ public AuthenticateResponse refreshUser(Token userToken, URL authenticationUrl)
     }
 
     @Override
-    public LogoutResponse logout(SyncUser user, URL authenticationUrl) {
-        throw new UnsupportedOperationException("Not yet implemented");
+    public LogoutResponse logout(Token userToken, URL authenticationUrl) {
+        try {
+            String requestBody = LogoutRequest.revoke(userToken).toJson();
+            return logout(buildLogoutUrl(authenticationUrl), requestBody);
+        } catch (Exception e) {
+            return LogoutResponse.from(new ObjectServerError(ErrorCode.UNKNOWN, e));
+        }
+    }
+
+    private static URL buildLogoutUrl(URL authenticationUrl) {
+        final String baseUrlString = authenticationUrl.toExternalForm();
+        try {
+            if (baseUrlString.endsWith("/")) {
+                return new URL(baseUrlString + "revoke");
+            } else {
+                return new URL(baseUrlString + "/revoke");
+            }
+        } catch (MalformedURLException e) {
+            throw new RuntimeException(e);
+        }
     }
 
     private AuthenticateResponse authenticate(URL authenticationUrl, String requestBody) throws Exception {
@@ -85,11 +104,23 @@ private AuthenticateResponse authenticate(URL authenticationUrl, String requestB
                 .url(authenticationUrl)
                 .addHeader("Content-Type", "application/json")
                 .addHeader("Accept", "application/json")
-                .addHeader("Connection", "close") //  See https://github.com/square/okhttp/issues/2363
                 .post(RequestBody.create(JSON, requestBody))
                 .build();
+        RealmLog.debug("Authenticate: " + requestBody);
         Call call = client.newCall(request);
         Response response = call.execute();
         return AuthenticateResponse.from(response);
     }
+
+    private LogoutResponse logout(URL logoutUrl, String requestBody) throws Exception {
+        Request request = new Request.Builder()
+                .url(logoutUrl)
+                .addHeader("Content-Type", "application/json")
+                .addHeader("Accept", "application/json")
+                .post(RequestBody.create(JSON, requestBody))
+                .build();
+        Call call = client.newCall(request);
+        Response response = call.execute();
+        return LogoutResponse.from(response);
+    }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BoundState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BoundState.java
index a941440867..e3e4aa53b7 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BoundState.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BoundState.java
@@ -52,7 +52,22 @@ public void onError(ObjectServerError error) {
         // If a Realms access token has expired, trigger a rebind. If the user is still valid it will automatically
         // refresh it.
         if (error.getErrorCode() == ErrorCode.TOKEN_EXPIRED) {
+            //  the server can send a 202 (expired access token) even if the client
+            //  still consider this token to be valid (based on timestamps for example)
+            //
+            //  this may cause the server to send a fatal error (203 bad refresh) if we try to bind
+            //  the session with this token. To be safe we remove the token that has been considered by the
+            //  the server to be invalid.
+
+            // stop the session to avoid sending a bind to the server which will cause it to return
+            // a fatal 203 (bad refresh)
+            session.stopNativeSession();
+            session.removeAccessToken();
+
+            // Create a new session & bind it
+            session.createNativeSession();
             gotoNextState(SessionState.BINDING);
+
         } else {
             switch (error.getCategory()) {
                 case FATAL: gotoNextState(SessionState.STOPPED); break;
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerSession.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerSession.java
index a0e4802df3..3d78d24aa5 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerSession.java
@@ -23,10 +23,10 @@
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
 import io.realm.RealmAsyncTask;
-import io.realm.SyncSession;
 import io.realm.SessionState;
 import io.realm.SyncConfiguration;
 import io.realm.SyncManager;
+import io.realm.SyncSession;
 import io.realm.SyncUser;
 import io.realm.internal.KeepMember;
 import io.realm.internal.async.RealmAsyncTaskImpl;
@@ -240,6 +240,10 @@ void stopNativeSession() {
         }
     }
 
+    void removeAccessToken() {
+        user.removeAccessToken(configuration.getServerUrl());
+    }
+
     // Bind with proper access tokens
     // Access tokens are presumed to be present and valid at this point
     void bindWithTokens() {
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
index f74c9dd0a9..a24e2bb6ce 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
@@ -28,8 +28,8 @@
 import java.util.List;
 import java.util.Map;
 
-import io.realm.SyncSession;
 import io.realm.SyncConfiguration;
+import io.realm.SyncSession;
 
 /**
  * Internal representation of a user on the Realm Object Server.
@@ -50,11 +50,12 @@
     public ObjectServerUser(Token refreshToken, URL authenticationUrl) {
         this.identity = refreshToken.identity();
         this.authenticationUrl = authenticationUrl;
-        setRefreshToken(refreshToken);
+        this.refreshToken = refreshToken;
         this.loggedIn = true;
     }
 
-    public void setRefreshToken(final Token refreshToken) {
+    private void setRefreshToken(final Token refreshToken) {
+        // TODO Shouldn't we check if the identity of the new refreshToken is the same with previous identity?
         this.refreshToken = refreshToken; // Replace any existing token. TODO re-save the user with latest token.
     }
 
@@ -64,7 +65,7 @@ public void setRefreshToken(final Token refreshToken) {
      *
      * Authenticating will happen automatically as part of opening a Realm.
      */
-    public boolean isAuthenticated(SyncConfiguration configuration) {
+    boolean isAuthenticated(SyncConfiguration configuration) {
         Token token = getAccessToken(configuration.getServerUrl());
         return token != null && token.expiresMs() > System.currentTimeMillis();
     }
@@ -92,11 +93,15 @@ public String getIdentity() {
         return identity;
     }
 
-    public Token getAccessToken(URI serverUrl) {
+    Token getAccessToken(URI serverUrl) {
         AccessDescription accessDescription = realms.get(serverUrl);
         return (accessDescription != null) ? accessDescription.accessToken : null;
     }
 
+    void removeAccessToken(URI serverUrl) {
+        realms.remove(serverUrl);
+    }
+
     public void addRealm(URI uri, AccessDescription description) {
         realms.put(uri, description);
     }
@@ -141,6 +146,7 @@ public Token getUserToken() {
         return sessions;
     }
 
+    // TODO merge this method into localLogout(). See https://github.com/realm/realm-java/pull/3642#discussion_r96818800
     public void clearTokens() {
         realms.clear();
         refreshToken = null;
@@ -164,16 +170,19 @@ public boolean equals(Object o) {
         ObjectServerUser syncUser = (ObjectServerUser) o;
 
         if (!identity.equals(syncUser.identity)) return false;
-        if (!refreshToken.equals(syncUser.refreshToken)) return false;
+        if (refreshToken == null) {
+            if (syncUser.refreshToken != null) return false;
+        } else {
+            if (!refreshToken.equals(syncUser.refreshToken)) return false;
+        }
         if (!authenticationUrl.toString().equals(syncUser.authenticationUrl.toString())) return false;
         return realms.equals(syncUser.realms);
-
     }
 
     @Override
     public int hashCode() {
         int result = identity.hashCode();
-        result = 31 * result + refreshToken.hashCode();
+        result = 31 * result + (refreshToken == null ? 0 : refreshToken.hashCode());
         result = 31 * result + authenticationUrl.toString().hashCode();
         result = 31 * result + realms.hashCode();
         return result;
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java
index 78f0acfb04..1d45632b40 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java
@@ -23,6 +23,8 @@
 import java.util.Arrays;
 import java.util.Locale;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+
 /**
  * This class represents a value from the Realm Authentication Server.
  */
@@ -97,6 +99,7 @@ public long expiresMs() {
         }
     }
 
+    @SuppressFBWarnings("MS_MUTABLE_ARRAY")
     public Permission[] permissions() {
         return Arrays.copyOf(permissions, permissions.length);
     }
@@ -151,5 +154,7 @@ public int hashCode() {
         DOWNLOAD,
         REFRESH,
         MANAGE;
+
+        public static final Permission[] ALL = { UPLOAD, DOWNLOAD, REFRESH, MANAGE };
     }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionModule.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionModule.java
index 5c245e3215..319cd2a83a 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionModule.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionModule.java
@@ -18,6 +18,6 @@
 
 import io.realm.annotations.RealmModule;
 
-@RealmModule(library = true, classes = { PermissionChange.class })
+@RealmModule(library = true, classes = { PermissionChange.class, PermissionOffer.class, PermissionOfferResponse.class })
 public class PermissionModule {
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOffer.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOffer.java
new file mode 100644
index 0000000000..0405f5ca70
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOffer.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.permissions;
+
+import java.util.Date;
+import java.util.UUID;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import io.realm.RealmObject;
+import io.realm.annotations.Index;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
+
+/**
+ * This model is used for offering permission changes to other users.
+ * It should be used in conjunction with an {@link io.realm.SyncUser}'s management Realm.
+ *
+ * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Permissions description</a> for general
+ * documentation.
+ */
+public class PermissionOffer extends RealmObject {
+
+    // Base fields
+    @PrimaryKey
+    @Required
+    private String id = UUID.randomUUID().toString();
+    @Required
+    private Date createdAt = new Date();
+    @Required
+    private Date updatedAt = new Date();
+    private Integer statusCode; // nil=not processed, 0=success, >0=error
+    private String statusMessage;
+
+    // Offer fields
+    @Index
+    private String token;
+    @Required
+    private String realmUrl;
+    private boolean mayRead;
+    private boolean mayWrite;
+    private boolean mayManage;
+    private Date expiresAt;
+
+    public PermissionOffer() {
+        // No args constructor required by Realm
+    }
+
+    /**
+     * Construct a permission offer object used to offer permission changes to other users.
+     *
+     * @param url The URL to the Realm on which to apply these permission changes to, once the offer is accepted.
+     * @param mayRead Grant or revoke read access.
+     * @param mayWrite Grant or revoked read-write access.
+     * @param mayManage Grant or revoke administrative access.
+     * @param expiresAt When this token will expire and become invalid. Pass {@code null} if this offer should not expire.
+     */
+    @SuppressFBWarnings("EI_EXPOSE_REP2")
+    public PermissionOffer(String url, boolean mayRead, boolean mayWrite, boolean mayManage, Date expiresAt) {
+        if (url == null) {
+            throw new IllegalArgumentException("Non-null 'url' required.");
+        }
+        this.realmUrl = url;
+        this.mayRead = mayRead;
+        this.mayWrite= mayWrite;
+        this.mayManage = mayManage;
+        this.expiresAt = expiresAt;
+    }
+
+    public String getId() {
+        return id;
+    }
+
+    @SuppressFBWarnings("EI_EXPOSE_REP")
+    public Date getCreatedAt() {
+        return createdAt;
+    }
+
+    @SuppressFBWarnings("EI_EXPOSE_REP")
+    public Date getUpdatedAt() {
+        return updatedAt;
+    }
+
+    /**
+     * Returns the status code for this change.
+     *
+     * @return {@code null} if not yet processed. {@code 0} if successful, {@code >0} if an error happened. See {@link #getStatusMessage()}.
+     */
+    public Integer getStatusCode() {
+        return statusCode;
+    }
+
+    /**
+     * Check if the request was successfully handled by the Realm Object Server.
+     *
+     * @return {@code true} if request was handled successfully. {@code false} if not. See {@link #getStatusMessage()}
+     *         for the full error message.
+     */
+    public boolean isSuccessful() {
+        return statusCode != null && statusCode == 0;
+    }
+
+    public String getStatusMessage() {
+        return statusMessage;
+    }
+
+    public String getToken() {
+        return token;
+    }
+
+    public String getRealmUrl() {
+        return realmUrl;
+    }
+
+    public boolean isMayRead() {
+        return mayRead;
+    }
+
+    public boolean isMayWrite() {
+        return mayWrite;
+    }
+
+    public boolean isMayManage() {
+        return mayManage;
+    }
+
+    @SuppressFBWarnings("EI_EXPOSE_REP")
+    public Date getExpiresAt() {
+        return expiresAt;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOfferResponse.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOfferResponse.java
new file mode 100644
index 0000000000..e1562a363e
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOfferResponse.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.permissions;
+
+import java.util.Date;
+import java.util.UUID;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
+
+/**
+ * This model is used to apply permission changes defined in the permission offer
+ * object represented by the specified token, which was created by another user's
+ * {@link PermissionOffer} object.
+ *
+ * It should be used in conjunction with an {@link io.realm.SyncUser}'s management Realm.
+ *
+ * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Permissions description</a> for general
+ * documentation.
+ */
+public class PermissionOfferResponse extends RealmObject {
+
+    // Base fields
+    @PrimaryKey
+    @Required
+    private String id = UUID.randomUUID().toString();
+    @Required
+    private Date createdAt = new Date();
+    @Required
+    private Date updatedAt = new Date();
+    private Integer statusCode; // nil=not processed, 0=success, >0=error
+    private String statusMessage;
+
+    // Request fields
+    @Required
+    private String token;
+    private String realmUrl;
+
+    public PermissionOfferResponse() {
+        // No args constructor required by Realm
+    }
+
+    /**
+     * Construct a permission offer response object used to apply permission changes
+     * defined in the permission offer object represented by the specified token,
+     * which was created by another user's {@link PermissionOffer} object.
+     *
+     * @param token The received token which uniquely identifies another user's
+     *              {@link PermissionOffer}.
+     */
+    public PermissionOfferResponse(String token) {
+        if (token == null) {
+            throw new IllegalArgumentException("Non-null 'token' required.");
+        }
+        this.token = token;
+    }
+
+    public void setToken(String token) {
+        this.token = token;
+    }
+
+    public String getId() {
+        return id;
+    }
+
+    @SuppressFBWarnings("EI_EXPOSE_REP")
+    public Date getCreatedAt() {
+        return createdAt;
+    }
+
+    @SuppressFBWarnings("EI_EXPOSE_REP")
+    public Date getUpdatedAt() {
+        return updatedAt;
+    }
+
+    /**
+     * Returns the status code for this change.
+     *
+     * @return {@code null} if not yet processed. {@code 0} if successful, {@code >0} if an error happened. See {@link #getStatusMessage()}.
+     */
+    public Integer getStatusCode() {
+        return statusCode;
+    }
+
+    /**
+     * Check if the request was successfully handled by the Realm Object Server.
+     *
+     * @return {@code true} if request was handled successfully. {@code false} if not. See {@link #getStatusMessage()}
+     *         for the full error message.
+     */
+    public boolean isSuccessful() {
+        return statusCode != null && statusCode == 0;
+    }
+
+    public String getStatusMessage() {
+        return statusMessage;
+    }
+
+    public String getToken() {
+        return token;
+    }
+
+    public String getRealmUrl() {
+        return realmUrl;
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index bf6a0fc4df..fb7f68f387 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -1,10 +1,7 @@
 package io.realm.objectserver;
 
-import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -12,10 +9,14 @@
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
+import io.realm.SessionState;
+import io.realm.SyncConfiguration;
 import io.realm.SyncCredentials;
+import io.realm.SyncManager;
+import io.realm.SyncSession;
 import io.realm.SyncUser;
 import io.realm.objectserver.utils.Constants;
-import io.realm.objectserver.utils.HttpUtils;
+import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 
@@ -23,21 +24,10 @@
 import static junit.framework.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
-public class AuthTests {
+public class AuthTests extends BaseIntegrationTest {
     @Rule
     public RunInLooperThread looperThread = new RunInLooperThread();
 
-    @BeforeClass
-    public static void setUp () throws Exception {
-        Realm.init(InstrumentationRegistry.getContext());
-        HttpUtils.startSyncServer();
-    }
-
-    @AfterClass
-    public static void tearDown () throws Exception {
-        HttpUtils.stopSyncServer();
-    }
-
     @Test
     public void login_userNotExist() {
         SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
@@ -67,6 +57,44 @@ public void onError(ObjectServerError error) {
         });
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void login_withAccessToken() {
+        SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
+        SyncCredentials credentials = SyncCredentials.accessToken(admin.getAccessToken(), "custom-admin-user");
+        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
+            @Override
+            public void onSuccess(SyncUser user) {
+                final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.SYNC_SERVER_URL)
+                        .errorHandler(new SyncSession.ErrorHandler() {
+                            @Override
+                            public void onError(SyncSession session, ObjectServerError error) {
+                                fail("Session failed: " + error);
+                            }
+                        })
+                        .build();
+
+                final Realm realm = Realm.getInstance(config);
+                looperThread.testRealms.add(realm);
+
+                // FIXME: Right now we have no Java API for detecting when a session is established
+                // So we optimistically assume it has been connected after 1 second.
+                looperThread.postRunnableDelayed(new Runnable() {
+                    @Override
+                    public void run() {
+                        assertEquals(SessionState.BOUND, SyncManager.getSession(config).getState());
+                        looperThread.testComplete();
+                    }
+                }, 1000);
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail("Login failed: " + error);
+            }
+        });
+    }
+
     // The error handler throws an exception but it is ignored (but logged). That means, this test should not
     // pass and not be stopped by an IllegalArgumentException.
     @Test
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java
new file mode 100644
index 0000000000..764b511ee7
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver;
+
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+
+import io.realm.Realm;
+import io.realm.SyncManager;
+import io.realm.log.RealmLog;
+import io.realm.objectserver.utils.HttpUtils;
+
+class BaseIntegrationTest {
+
+    @BeforeClass
+    public static void setUp () throws Exception {
+        SyncManager.Debug.skipOnlineChecking = true;
+        try {
+            Realm.init(InstrumentationRegistry.getContext());
+            HttpUtils.startSyncServer();
+        } catch (Exception e) {
+            // Throwing an exception from this method will crash JUnit. Instead just log it.
+            // If this setup method fails, all unit tests in the class extending it will most likely fail as well.
+            RealmLog.error("Could not start Sync Server", e);
+        }
+    }
+
+    @AfterClass
+    public static void tearDown () throws Exception {
+        try {
+            HttpUtils.stopSyncServer();
+        } catch (Exception e) {
+            RealmLog.error("Failed to stop Sync Server", e);
+        }
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
new file mode 100644
index 0000000000..d1695c13ba
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Date;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.realm.ObjectServerError;
+import io.realm.Realm;
+import io.realm.RealmChangeListener;
+import io.realm.RealmResults;
+import io.realm.SyncConfiguration;
+import io.realm.SyncSession;
+import io.realm.SyncUser;
+import io.realm.entities.Dog;
+import io.realm.log.LogLevel;
+import io.realm.log.RealmLog;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.UserFactory;
+import io.realm.permissions.PermissionOffer;
+import io.realm.permissions.PermissionOfferResponse;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class ManagementRealmTests extends BaseIntegrationTest {
+
+    @Rule
+    public RunInLooperThread looperThread = new RunInLooperThread();
+
+    @Ignore("TODO: Test is currently flaky. See https://github.com/realm/realm-java/pull/4066")
+    @Test
+    @RunTestInLooperThread
+    public void create_acceptOffer() {
+        SyncUser user1 = UserFactory.createUser(Constants.AUTH_URL, "user1");
+        final SyncUser user2 = UserFactory.createUser(Constants.AUTH_URL, "user2");
+
+        // 1. User1 creates Realm that user2 does not have access
+        final String user1RealmUrl = "realm://127.0.0.1:9080/" + user1.getIdentity() + "/permission-offer-test";
+        SyncConfiguration config1 = new SyncConfiguration.Builder(user1, user1RealmUrl).
+                errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        fail("Realm 1 unexpected error: " + error);
+                    }
+                })
+                .build();
+        final Realm realm1 = Realm.getInstance(config1);
+        looperThread.testRealms.add(realm1);
+        realm1.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(Dog.class);
+            }
+        });
+
+        // 2. Create configuration for User2's Realm.
+        final SyncConfiguration config2 = new SyncConfiguration.Builder(user2, user1RealmUrl).build();
+
+        // 3. Create PermissionOffer
+        final AtomicReference<String> offerId = new AtomicReference<String>(null);
+        final Realm user1ManagementRealm = user1.getManagementRealm();
+        looperThread.testRealms.add(user1ManagementRealm);
+        user1ManagementRealm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                boolean readPermission = true;
+                boolean readWritePermission = true;
+                boolean managePermission = false;
+                Date expiresAt = null;
+                PermissionOffer offer = new PermissionOffer(user1RealmUrl, readPermission, readWritePermission, managePermission, expiresAt);
+                offerId.set(offer.getId());
+                realm.copyToRealm(offer);
+            }
+        }, new Realm.Transaction.OnSuccess() {
+            @Override
+            public void onSuccess() {
+                // 4. Wait for offer to get an token
+                RealmLog.error("OfferID: " + offerId.get());
+                RealmResults<PermissionOffer> offers = user1ManagementRealm.where(PermissionOffer.class)
+                        .equalTo("id", offerId.get())
+                        .findAllAsync();
+                looperThread.keepStrongReference.add(offers);
+                offers.addChangeListener(new RealmChangeListener<RealmResults<PermissionOffer>>() {
+                    @Override
+                    public void onChange(RealmResults<PermissionOffer> offers) {
+                        final PermissionOffer offer = offers.first(null);
+                        if (offer != null && offer.isSuccessful() && offer.getToken() != null) {
+                            // 5. User2 uses the token to accept the offer
+                            final String offerToken = offer.getToken();
+                            final AtomicReference<String> offerResponseId = new AtomicReference<String>();
+                            final Realm user2ManagementRealm = user2.getManagementRealm();
+                            looperThread.testRealms.add(user2ManagementRealm);
+                            user2ManagementRealm.executeTransactionAsync(new Realm.Transaction() {
+                                @Override
+                                public void execute(Realm realm) {
+                                    PermissionOfferResponse offerResponse = new PermissionOfferResponse(offerToken);
+                                    offerResponseId.set(offerResponse.getId());
+                                    realm.copyToRealm(offerResponse);
+                                }
+                            }, new Realm.Transaction.OnSuccess() {
+                                @Override
+                                public void onSuccess() {
+                                    // 6. Wait for the offer response to be accepted
+                                    RealmResults<PermissionOfferResponse> responses = user2ManagementRealm.where(PermissionOfferResponse.class)
+                                            .equalTo("id", offerResponseId.get())
+                                            .findAllAsync();
+                                    looperThread.keepStrongReference.add(responses);
+                                    responses.addChangeListener(new RealmChangeListener<RealmResults<PermissionOfferResponse>>() {
+                                        @Override
+                                        public void onChange(RealmResults<PermissionOfferResponse> responses) {
+                                            PermissionOfferResponse response = responses.first(null);
+                                            if (response != null && response.isSuccessful() && response.getToken().equals(offerToken)) {
+                                                // 7. Response accepted. It should now be possible for user2 to access user1's Realm
+                                                Realm realm = Realm.getInstance(config2);
+                                                looperThread.testRealms.add(realm);
+                                                RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
+                                                looperThread.keepStrongReference.add(dogs);
+                                                dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
+                                                    @Override
+                                                    public void onChange(RealmResults<Dog> element) {
+                                                        assertEquals(1, element.size());
+                                                        looperThread.testComplete();
+                                                    }
+                                                });
+                                            }
+                                        }
+                                    });
+                                }
+                            });
+                        }
+                    }
+                });
+            }
+        });
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
index 6e465f53f9..68ce590f3e 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
@@ -24,6 +24,7 @@
 
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -32,41 +33,31 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 
+import io.realm.ObjectServerError;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
 import io.realm.RealmResults;
 import io.realm.SyncConfiguration;
+import io.realm.SyncSession;
+import io.realm.SyncUser;
 import io.realm.objectserver.model.ProcessInfo;
 import io.realm.objectserver.model.TestObject;
 import io.realm.objectserver.service.SendOneCommit;
 import io.realm.objectserver.service.SendsALot;
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.HttpUtils;
+import io.realm.objectserver.utils.UserFactory;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
-public class ProcessCommitTests {
-    @BeforeClass
-    public static void setUp () throws Exception {
-        HttpUtils.startSyncServer();
-    }
-
-    @AfterClass
-    public static void tearDown () throws Exception {
-        HttpUtils.stopSyncServer();
-    }
+public class ProcessCommitTests extends BaseIntegrationTest {
 
-    // FIXME: At least need one method in the test class
-    @Test
-    public void dummy() {
-
-    }
-
-    // FIXME: Disable for now.
-    /*
+    // FIXME: Ignore for now. They do still not work. It might be caused by two processes each creating
+    // a Sync Client, but it needs to be investigated.
     @Test
+    @Ignore
     public void expectServerCommit() throws Throwable {
         final Throwable[] exception = new Throwable[1];
         final CountDownLatch testFinished = new CountDownLatch(1);
@@ -76,18 +67,23 @@ public void expectServerCommit() throws Throwable {
             public void run() {
                 try {
                     Looper.prepare();
-                    Context targetContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+                    Context targetContext = InstrumentationRegistry.getTargetContext();
 
-                    final SyncConfiguration syncConfig = new SyncConfiguration.Builder()
+                    SyncUser user = UserFactory.createDefaultUser(Constants.AUTH_URL);
+                    String realmUrl = Constants.SYNC_SERVER_URL;
+                    final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
                             .name(SendOneCommit.class.getSimpleName())
-                            .serverUrl(Constants.SYNC_SERVER_URL )
-                            .user(UserFactory.createDefaultUser(Constants.SYNC_SERVER_URL, Constants.USER_TOKEN))
+                            .errorHandler(new SyncSession.ErrorHandler() {
+                                @Override
+                                public void onError(SyncSession session, ObjectServerError error) {
+                                    fail("Sync failure: " + error);
+                                }
+                            })
                             .build();
                     Realm.deleteRealm(syncConfig);//TODO do this in Rule as async tests
                     final Realm realm = Realm.getInstance(syncConfig);
                     Intent intent = new Intent(targetContext, SendOneCommit.class);
                     targetContext.startService(intent);
-
                     final RealmResults<ProcessInfo> all = realm.where(ProcessInfo.class).findAll();
                     all.addChangeListener(new RealmChangeListener<RealmResults<ProcessInfo>>() {
                         @Override
@@ -113,14 +109,15 @@ public void onChange(RealmResults<ProcessInfo> element) {
             fail("Test timed out ");
         }
     }
-    */
 
+    // FIXME: Ignore for now. They do still not work. It might be caused by two processes each creating
+    // a Sync Client, but it needs to be investigated.
     //TODO send string from service and match
     //     replicate integration tests from Cocoa
     //     add gradle task to start the sh script automatically (create pid file, ==> run or kill existing process
     //     check the requirement for the issue again
-    /*
     @Test
+    @Ignore
     public void expectALot() throws Throwable {
         final Throwable[] exception = new Throwable[1];
         final CountDownLatch testFinished = new CountDownLatch(1);
@@ -132,10 +129,16 @@ public void run() {
                     Looper.prepare();
                     Context targetContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
 
-                    final SyncConfiguration syncConfig = new SyncConfiguration.Builder(targetContext)
+                    SyncUser user = UserFactory.createDefaultUser(Constants.AUTH_URL);
+                    String realmUrl = Constants.SYNC_SERVER_URL_2;
+                    final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
                             .name(SendsALot.class.getSimpleName())
-                            .serverUrl(Constants.SYNC_SERVER_URL_2)
-                            .user(UserFactory.createDefaultUser(Constants.SYNC_SERVER_URL_2, Constants.USER_TOKEN))
+                            .errorHandler(new SyncSession.ErrorHandler() {
+                                @Override
+                                public void onError(SyncSession session, ObjectServerError error) {
+                                    fail("Sync failure: " + error);
+                                }
+                            })
                             .build();
                     Realm.deleteRealm(syncConfig);//TODO do this in Rule as async tests
                     final Realm realm = Realm.getInstance(syncConfig);
@@ -171,5 +174,4 @@ public void onChange(RealmResults<TestObject> element) {
             fail("Test timed out ");
         }
     }
-    */
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendOneCommit.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendOneCommit.java
index 26c4f89de6..4653b26211 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendOneCommit.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendOneCommit.java
@@ -20,6 +20,13 @@
 import android.content.Intent;
 import android.os.IBinder;
 
+import io.realm.Realm;
+import io.realm.SyncConfiguration;
+import io.realm.SyncUser;
+import io.realm.objectserver.model.ProcessInfo;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.UserFactory;
+
 /**
  * Open a sync Realm on a different process, then send one commit.
  */
@@ -28,12 +35,11 @@
     @Override
     public void onCreate() {
         super.onCreate();
-        // FIXME: Disable for now
-        /*
-        final SyncConfiguration syncConfig = new SyncConfiguration.Builder(this)
+        Realm.init(getApplicationContext());
+        SyncUser user = UserFactory.createDefaultUser(Constants.AUTH_URL);
+        String realmUrl = Constants.SYNC_SERVER_URL;
+        final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
                 .name(SendOneCommit.class.getSimpleName())
-                .serverUrl(Constants.SYNC_SERVER_URL)
-                .user(UserFactory.createDefaultUser(Constants.SYNC_SERVER_URL, Constants.USER_TOKEN))
                 .build();
         Realm.deleteRealm(syncConfig);
         Realm realm = Realm.getInstance(syncConfig);
@@ -46,10 +52,8 @@ public void onCreate() {
         realm.commitTransaction();
 
         realm.close();//FIXME the close may not give a chance to the sync client to process/upload the changeset
-        */
     }
 
-
     @Override
     public IBinder onBind(Intent intent) {
         return null;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendsALot.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendsALot.java
index 2bcdd9d717..dca642beb2 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendsALot.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendsALot.java
@@ -20,6 +20,13 @@
 import android.content.Intent;
 import android.os.IBinder;
 
+import io.realm.Realm;
+import io.realm.SyncConfiguration;
+import io.realm.SyncUser;
+import io.realm.objectserver.model.TestObject;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.UserFactory;
+
 /**
  * Open a sync Realm on a different process, then send one commit.
  */
@@ -28,13 +35,11 @@
     @Override
     public void onCreate() {
         super.onCreate();
-        // FIXME: Disable for now.
-        /*
-        User user = UserFactory.createDefaultUser(Constants.SYNC_SERVER_URL_2, Constants.USER_TOKEN);
-        final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user)
+        Realm.init(getApplicationContext());
+        SyncUser user = UserFactory.createDefaultUser(Constants.AUTH_URL);
+        String realmUrl = Constants.SYNC_SERVER_URL_2;
+        final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
                 .name(SendsALot.class.getSimpleName())
-                .serverUrl(Constants.SYNC_SERVER_URL_2)
-                .user()
                 .build();
         Realm.deleteRealm(syncConfig);
         Realm realm = Realm.getInstance(syncConfig);
@@ -49,7 +54,6 @@ public void onCreate() {
         realm.commitTransaction();
 
         realm.close();//FIXME the close may not give a chance to the sync client to process/upload the changeset
-        */
     }
 
 
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
index e346c04c3c..e5347effc8 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
@@ -17,14 +17,10 @@
 package io.realm.objectserver.utils;
 
 public class Constants {
-    // to generate a valid token follow the guide in
-    //<root>/integration-tests/sync/test_server/keys/HowToGenerateKey.txt
-    public static String USER_TOKEN = "ewogICJpZGVudGl0eSI6ICJ0ZXN0MiIsCiAgImFjY2VzcyI6IFsKICAgICJkb3dubG9hZCIsCiAgICAidXBsb2FkIgogIF0sCiAgInRpbWVzdGFtcCI6IDE0NTU1MzA2MTQsCiAgImV4cGlyZXMiOiBudWxsLAogICJhcHBfaWQiOiAiaW8ucmVhbG0udGVzdHMuc3luYyIKfQ=="
-            + ":" +
-            "mR0/GMc0b5XHFNJEM4D9fb94oXMjho0jKxopaU1lQW4FqY1QPBa/bPiVCMhAosZVSNhEP6vEZxVjFHAxoPODKoml1Ry78geKt5Iql395HRvO6KCCN0VkMpx2eXy+SzF2pcEjU5jlldbTAcO6nMyVaQ9g2XF2SZPVjBqpkY1cy2IjMHN0HRWy9SfGelwZY/jW72jZM7+89kWpIB0SmNH8kEPKVZlnRMW4KwNAUPA8P0/+qyoRTr/4l7k7N6z5kBxIKB/+m55AeOUDiFsxA53QPlpHGvF7ThZpiv8i+UhyKZcQlXi1utoj8H1CzpeU/YzrrEf3xrr2qCO3/niU5WdnHA==";
-    public static String SYNC_SERVER_URL = "realm://127.0.0.1:7800/tests";
-    public static String SYNC_SERVER_URL_2 = "realm://127.0.0.1:7800/tests2";
 
-    public static String AUTH_SERVER_URL = "http://127.0.0.1:8080/";
+    public static String SYNC_SERVER_URL = "realm://127.0.0.1/tests";
+    public static String SYNC_SERVER_URL_2 = "realm://127.0.0.1/tests2";
+
+    public static String AUTH_SERVER_URL = "http://127.0.0.1:9080/";
     public static String AUTH_URL = AUTH_SERVER_URL + "auth";
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
index 9b15ae11e3..b63456b79d 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
@@ -16,12 +16,17 @@
 
 package io.realm.objectserver.utils;
 
+import android.support.test.InstrumentationRegistry;
+
 import java.io.IOException;
 
+import io.realm.Realm;
 import io.realm.log.RealmLog;
 import okhttp3.Headers;
+import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
+import okhttp3.RequestBody;
 import okhttp3.Response;
 
 /**
@@ -29,7 +34,10 @@
  * temp directory & start a sync server on it for each unit test.
  */
 public class HttpUtils {
-    private final static OkHttpClient client = new OkHttpClient();
+    private final static OkHttpClient client = new OkHttpClient.Builder()
+            .retryOnConnectionFailure(true)
+            .build();
+
     // adb reverse tcp:8888 tcp:8888
     // will forward this query to the host, running the integration test server on 8888
     private final static String START_SERVER = "http://127.0.0.1:8888/start";
@@ -59,21 +67,32 @@ public static void startSyncServer() throws Exception {
 
     // Checking the server
     private static boolean waitAuthServerReady() throws InterruptedException {
-        int retryTimes = 50;
+        int retryTimes = 20;
+
+        // Dummy invalid request, which will trigger a 400 (BAD REQUEST), but indicate the auth
+        // server is responsive
         Request request = new Request.Builder()
                 .url(Constants.AUTH_SERVER_URL)
                 .build();
 
         while (retryTimes != 0) {
+            Response response = null;
             try {
-                Response response = client.newCall(request).execute();
+                response = client.newCall(request).execute();
                 if (response.isSuccessful()) {
                     return true;
                 }
                 RealmLog.error("Error response from auth server: %s", response.toString());
             } catch (IOException e) {
+                // TODO As long as the auth server hasn't started yet, OKHttp cannot parse the response
+                // correctly. At this point it is unknown weather is a bug in OKHttp or an
+                // unknown host is reported. This can cause a lot of "false" errors in the log.
                 RealmLog.error(e);
-                Thread.sleep(100);
+                Thread.sleep(500);
+            } finally {
+                if (response != null) {
+                    response.close();
+                }
             }
             retryTimes--;
         }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
index 1ebb2d6ab5..1145f8a310 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
@@ -16,25 +16,24 @@
 
 package io.realm.objectserver.utils;
 
-import java.net.URI;
-import java.net.URISyntaxException;
-
+import io.realm.SyncCredentials;
 import io.realm.SyncUser;
-import io.realm.objectserver.utils.Constants;
 
 // Must be in `io.realm.objectserver` to work around package protected methods.
 public class UserFactory {
-    // FIXME: Not working right now.
-    /*
-    public static User createDefaultUser(String SERVER_URL, String USER_TOKEN) {
-        try {
-            User user = User.createLocal();
 
-            user.addAccessToken(new URI(SERVER_URL), USER_TOKEN);
-            return user;
-        } catch (URISyntaxException e) {
-            throw new RuntimeException(e);
-        }
+    public static SyncUser createDefaultUser(String authUrl) {
+        return createUser(authUrl, "test-user");
+    }
+
+    public static SyncUser createUser(String authUrl, String userIdentifier) {
+        SyncCredentials credentials = SyncCredentials.usernamePassword(userIdentifier, "myPassw0rd", true);
+        return SyncUser.login(credentials, authUrl);
+    }
+
+    public static SyncUser createAdminUser(String authUrl) {
+        // `admin` required as user identifier to be granted admin rights.
+        SyncCredentials credentials = SyncCredentials.custom("admin", "debug", null);
+        return SyncUser.login(credentials, authUrl);
     }
-    */
 }
diff --git a/tools/sync_test_server/Dockerfile b/tools/sync_test_server/Dockerfile
index f733015ca4..cddec14681 100644
--- a/tools/sync_test_server/Dockerfile
+++ b/tools/sync_test_server/Dockerfile
@@ -5,7 +5,8 @@ ARG ROS_DE_VERSION
 # Add realm repo
 RUN apt-get update -qq \
     && apt-get install -y curl npm \
-    && curl -s https://packagecloud.io/install/repositories/realm/realm/script.deb.sh | bash
+    # && curl -s https://packagecloud.io/install/repositories/realm/realm/script.deb.sh \
+    && curl -s https://packagecloud.io/install/repositories/realm/realm-testing/script.deb.sh | bash
 
 # ROS npm dependencies
 RUN npm init -y
@@ -13,6 +14,7 @@ RUN npm install winston temp httpdispatcher@1.0.0
 
 COPY keys/private.pem keys/public.pem configuration.yml /
 COPY ros-testing-server.js /usr/bin/
+
 # Install realm object server
 RUN apt-get update -qq \
     && apt-get install -y realm-object-server-developer=$ROS_DE_VERSION \
diff --git a/tools/sync_test_server/configuration.yml b/tools/sync_test_server/configuration.yml
index 6080a3beda..702e4c336a 100644
--- a/tools/sync_test_server/configuration.yml
+++ b/tools/sync_test_server/configuration.yml
@@ -19,7 +19,7 @@
 storage:
   ## The directory in which the realm server will store all its data files.
   ## This configuration option is MANDATORY.
-  root_path: /var/realm/sync-services
+  root_path: '/var/realm/sync-services'
 
 ## ----------------------------------------------------------------------------
 
@@ -27,25 +27,84 @@ auth:
   ## The path to the public and private keys (in PEM format) that will be used
   ## to validate identity tokens sent by clients.
   ## These configuration options are MANDATORY.
-  public_key_path: /public.pem
-  private_key_path: /private.pem
-
-  database:
-    ## The path for the administration database synchronisation endpoint. Do NOT
-    ## change this unless asked by Realm Support.
-    # sync_uri_path: '/public/admin'
+  public_key_path: '/public.pem'
+  private_key_path: '/private.pem'
+
+  sync_hosts:
+    ## The hosts for which the authentication service will consider itself
+    ## authoritative. It will decline to process any kind of requests for Realm
+    ## files at other URLs. Addresses specified here must include host and port
+    ## (authority part of the URL according to RFC 3986) on which the sync
+    ## server is externally reachable. In addition to hosts configured here,
+    ## the authentication service will always accept the following hosts:
+    # - localhost:27800
+    #
+    # Additionally if a proxy server for the given protocol is configured, it
+    # will also accept requests for Realm files at these hosts:
+    # - ${proxy:http:listen_address}:${proxy:http:listen_port}
+    # - ${proxy:https:listen_address}:${proxy:https:listen_port}
+    #
+    # The derived hosts will also include aliases for local addresses
+    # with the following host names: '127.0.0.1', 'localhost' and '::'.
 
   ttls:
-    ## The validity duration for Refresh Tokens. This should be a fairly high
-    ## value, typically ranging 12 hours - 3 days. This value is represented in
-    ## seconds. Default: 24 hours.
-    # refresh_token: 86400
+    ## The validity duration for Refresh Tokens. This can be a fairly high
+    ## value, ranging from a single day to multiple years, depending on
+    ## individual needs. Whenever the Refresh Token expires, clients will be
+    ## forced to delegate again to the authorizing party. If the credentials
+    ## there can be revoked by the user or are not opaquely managed by the
+    ## client, then this would force the user to manual intervention after the
+    ## expiration. Depending on the use case, this can be either desired or
+    ## should be prevented. This value is represented in seconds.
+    ## Default: 10 years.
+    # refresh_token: 315360000
 
     ## The validity duration for Access Tokens. This should be a fairly small
     ## number, especially if you are concerned with revocations being applied
     ## quickly. This value is represented in seconds. Default: 1 minute.
     # access_token: 60
 
+  providers:
+    ## Providers of authentication tokens. Each provider has a configuration
+    ## object associated with it. If a provider is included here and its
+    ## configuration is valid, it will be enabled.
+
+    ## Possible providers: cloudkit, debug, google, facebook, realm, password
+    ## Providers 'realm' and 'password' are always enabled:
+    ## - The 'realm' provider is used to derive access tokens from a refresh token.
+    ## - The 'password' provider is required for the dashboard to work. It supports
+    ##   authentication through username/password and uses a PBKDF2 implementation.
+
+    ## This enables login via CloudKit's user record name.
+    # cloudkit:
+      ## The key ID retrieved when adding the public key derived from the
+      ## specified private_key_path in CloudKit's Server-to-Server Keys,
+      ## available through the API Access settings in the CloudKit dashboard.
+      # key_id: '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef'
+
+      ## The path to the certificate.
+      # private_key_path: 'cloudkit_eckey.pem'
+
+      ## The container identifier in reverse domain name notation.
+      # container: "iCloud.io.realm.exampleApp.ios"
+
+      ## The environment in which CloudKit should be used. The default is
+      ## 'development'. For the production deployment for apps on the AppStore
+      ## you must specify 'production'.
+      # environment: 'development'
+
+    ## This enables authentication via a Google Sign-In access token for a
+    ## specific app.
+    # google:
+      ## The client ID as retrieved when setting up the app in the Google
+      ## Developer Console.
+      # clientId: '012345678901-abcdefghijklmnopqrstvuvwxyz01234.apps.googleusercontent.com'
+
+    ## This enables authentication via a Facebook access token for a specific app.
+    ## This provider needs no configuration (uncommenting the next line enables it).
+    # facebook: {}
+    debug: {}
+
 ## ----------------------------------------------------------------------------
 
 proxy:
@@ -95,7 +154,7 @@ proxy:
     ## The address/interface on which the HTTP proxy module should listen. This defaults
     ## to 127.0.0.1. If you wish to listen on all available interfaces,
     ## uncomment the following line.
-    listen_address: '0.0.0.0'
+    listen_address: '::'
 
     ## The port that the HTTP proxy module should bind to.
     # listen_port: 9080
@@ -116,7 +175,7 @@ proxy:
     ## The address/interface on which the HTTPS proxy module should listen. This defaults
     ## to 127.0.0.1. If you wish to listen on all available interfaces,
     ## uncomment the following line.
-    # listen_address: '0.0.0.0'
+    # listen_address: '::'
 
     ## The port that the HTTPS proxy module should bind to.
     # listen_port: 9443
@@ -128,68 +187,46 @@ network:
   ## the proxy module. The proxy module will automatically forward traffic to the
   ## internal modules on the ports they are configured to listen on in this section.
 
-  sync:
-    ## The address/interface on which the server should listen. This defaults
-    ## to 127.0.0.1. If you wish to listen on all available interfaces,
-    ## uncomment the following line.
-    listen_address: '0.0.0.0'
-
-    ## The port on which to listen. The Realm sync server uses port 27800 by
-    ## default. For most deployments, there should not be a need to change this.
-    listen_port: 7800
-
   http:
     ## The address/interface on which the server should listen for HTTP
     ## services. This includes Dashboard and Authentication APIs.
     ## This defaults to 127.0.0.1. If you wish to listen on all available
     ## interfaces, uncomment the following line.
-    listen_address: '0.0.0.0'
+    # listen_address: '0.0.0.0'
 
     ## The port on which to listen for incoming requests to the Dashboard
     ## and authentication APIs. This defaults to 27080.
-    listen_port: 8080
+    # listen_port: 27080
 
 ## ----------------------------------------------------------------------------
 
-  providers:
-    ## Providers of authentication tokens. Each provider has a configuration
-    ## object associated with it. If a provider is included here and its
-    ## configuration is valid, it will be enabled.
-
-    ## Possible providers: cloudkit, debug, facebook, realm, password
-    ## Providers 'realm' and 'password' are always enabled:
-    ## - The 'realm' provider is used to derive access tokens from a refresh token.
-    ## - The 'password' provider is required for the dashboard to work. It supports
-    ##   authentication through username/password and uses a PBKDF2 implementation.
-
-    ## This enables login via CloudKit's user record name.
-    # cloudkit:
-      ## The key ID retrieved when adding the public key derived from the
-      ## specified private_key_path in CloudKit's Server-to-Server Keys,
-      ## available through the API Access settings in the CloudKit dashboard.
-      # key_id: '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef'
-
-      ## The path to the certificate.
-      # private_key_path: 'cloudkit_eckey.pem'
-
-      ## The container identifier in reverse domain name notation.
-      # container: "iCloud.io.realm.exampleApp.ios"
-
-      ## The environment in which CloudKit should be used. The default is
-      ## 'development'. For the production deployment for apps on the AppStore
-      ## you must specify 'production'.
-      # environment: 'development'
-
-    ## This enables authentication via a Google Sign-In access token for a
-    ## specific app.
-    # google:
-      ## The client ID as retrieved when setting up the app in the Google
-      ## Developer Console.
-      # clientId: '012345678901-abcdefghijklmnopqrstvuvwxyz01234.apps.googleusercontent.com'
-
-    ## This enables authentication via a Facebook access token for a specific app.
-    ## This provider needs no configuration (uncommenting the next line enables it).
-    # facebook: {}
+sync:
+  ## Synchronization service settings, including clustering and load balancing.
+
+  servers:
+    ## An array of entries describing the cluster configuration.
+    ##
+    ## If no servers are configured, a default entry is inserted with the
+    ## following settings:
+    ##   - id: '0'
+    ##     address: '0.0.0.0'
+    ##     port: 27800
+    ##
+    ## Each entry must contain the following entries:
+    ##
+    ##    'id': A unique string ID used to distinguish between backend servers.
+    ##          This must remain stable, even if the particular backend server
+    ##          is moved to a different address or port.
+    ##
+    ##    'address': The address of the cluster participant. If '0.0.0.0' or
+    ##               '::', a sync server will be started on localhost (listening
+    ##               on '127.0.0.1' or '::1', respectively). Otherwise, it is
+    ##               assumed that the sync server is an external process,
+    ##               potentially on a separate machine.
+    ##
+    ##    'port': The port on which to connect to the particular cluster node.
+    ##            If address was '0.0.0.0' or '::', this is also the port number
+    ##            on which the local cluster node will listen for connections.
 
 ## ----------------------------------------------------------------------------
 
@@ -210,12 +247,12 @@ logging:
   ##   error
   ##   fatal
   ##   off: all output suppressed
-  level: 'all'
+  # level: 'info'
 
   ## The file to which the synchronisation server should log. This should
   ## be a writable path from the perspective of the user under which the
   ## server runs. If no path is specified, the server will log to stdout.
-  path: '/tmp/realm-sync.log'
+  # path: '/var/log/realm-object-server.log'
 
 ## ----------------------------------------------------------------------------
 
@@ -225,3 +262,35 @@ performance:
   ## Only change this option if directed to by Realm support.
   # max_open_files: 256
 
+## ----------------------------------------------------------------------------
+
+backup:
+  ## The backup is a server that delivers continuous backup of the Realms in
+  ## storage.root_path specified above. The backup is delivered to all connected
+  ## backup clients. Backup clients must be started separately with network
+  ## configuration parameters matching those of the server.
+
+  enable:
+    ## Whether or not to enable the backup server.
+    # enable: true
+
+  network:
+    ## The address/interface on which the backup server should listen. This
+    ## defaults to 127.0.0.1. If you wish to listen on all available interfaces,
+    ## uncomment the following line.
+    # listen_address: '0.0.0.0'
+
+    ## The port on which to listen. The backup server uses port 27810 by
+    ## default. For most deployments, there should not be a need to change this.
+    # listen_port: 27810
+
+  logging:
+    ## The logging level of the backup server.
+    ## The values are identical to the logging levels described above.
+    ## The default level is 'info'.
+    # level: 'info'
+
+    ## The file to which the synchronisation server should log. This should
+    ## be a writable path from the perspective of the user under which the
+    ## server runs. If no path is specified, the server will log to stdout.
+    # path: '/var/log/realm-object-server-backup.log'
diff --git a/tools/sync_test_server/ros-testing-server.js b/tools/sync_test_server/ros-testing-server.js
index c182652c39..c9ca2c2c5d 100755
--- a/tools/sync_test_server/ros-testing-server.js
+++ b/tools/sync_test_server/ros-testing-server.js
@@ -1,6 +1,6 @@
 #!/usr/bin/env nodejs
 
-var winston = require('winston');//logging
+var winston = require('winston'); //logging
 const temp = require('temp');
 const spawn = require('child_process').spawn;
 var http = require('http');
@@ -23,7 +23,7 @@ function handleRequest(request, response) {
     try {
         //log the request on console
         winston.log(request.url);
-        //Disptach
+        //Dispatch
         dispatcher.dispatch(request, response);
     } catch(err) {
         console.log(err);
@@ -37,9 +37,13 @@ function startRealmObjectServer() {
     temp.mkdir('ros', function(err, path) {
         if (!err) {
             winston.info("Starting sync server in ", path);
+            var env = Object.create( process.env );
+            winston.info(env.NODE_ENV);
+            env.NODE_ENV = 'development';
             syncServerChildProcess = spawn('realm-object-server',
                     ['--root', path,
-                    '--configuration', '/configuration.yml']);
+                    '--configuration', '/configuration.yml'],
+                    { env: env });
             // local config:
             syncServerChildProcess.stdout.on('data', (data) => {
                 winston.info(`stdout: ${data}`);
diff --git a/tools/sync_test_server/start_server.sh b/tools/sync_test_server/start_server.sh
index 00930f5eb1..cf49b3247f 100755
--- a/tools/sync_test_server/start_server.sh
+++ b/tools/sync_test_server/start_server.sh
@@ -7,11 +7,10 @@ ROS_DE_VERSION=$(grep REALM_OBJECT_SERVER_DE_VERSION $DOCKERFILE_DIR/../../depen
 
 TMP_DIR=$(mktemp -d /tmp/sync-test.XXXX) || { echo "Failed to mktemp $TEST_TEMP_DIR" ; exit 1 ; }
 
-adb reverse tcp:7800 tcp:7800 && \
-adb reverse tcp:8080 tcp:8080 && \
+adb reverse tcp:9080 tcp:9080 && \
 adb reverse tcp:8888 tcp:8888 || { echo "Failed to reverse adb port." ; exit 1 ; }
 
 docker build $DOCKERFILE_DIR --build-arg ROS_DE_VERSION=$ROS_DE_VERSION -t sync-test-server || { echo "Failed to build Docker image." ; exit 1 ; }
 
 echo "See log files in $TMP_DIR"
-docker run -p 8080:8080 -p 7800:7800 -p 8888:8888 -v$TMP_DIR:/tmp --name sync-test-server sync-test-server
+docker run -p 9080:9080 -p 8888:8888 -v$TMP_DIR:/tmp --name sync-test-server sync-test-server
diff --git a/version.txt b/version.txt
index a9d981d17e..b4308ebebb 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-2.3.0-SNAPSHOT
+2.4.0-SNAPSHOT
