diff --git a/CHANGELOG.md b/CHANGELOG.md
index fa6aa8705c..c645665385 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,10 +1,21 @@
-## 5.1.0 (YYYY-MM-DD)
+## 5.1.0 (2018-04-25)
 
 ### Enhancements
 
+* [ObjectServer] Added support for `SyncUser.requestPasswordReset()`, `SyncUser.completePasswordReset()`
+  and their async variants. This makes it possible to reset the password for users created using
+  `Credentials.usernamePassword()` where they used their email as username (#5821).
+* [ObjectServer] Added support for `SyncUser.requestEmailConfirmation()`, `SyncUser.confirmEmail()`
+  and their async variants. This makes it possible to ask users to confirm their email. This is only
+  supported for users created using `Credentials.usernamePassword()` who have used an email as their
+  username (#5821).
 * `RealmQuery.in()` now support `null` which will always return no matches (#4011).
 * Added support for `RealmQuery.alwaysTrue()` and `RealmQuery.alwaysFalse()`.
 
+### Bug Fixes
+
+* Changing a primary key from being nullable to being required could result in objects being deleted (##5899).
+
 
 ## 5.0.1 (2018-04-09)
 
diff --git a/Jenkinsfile b/Jenkinsfile
index 8412e67f04..4a7876c51d 100644
--- a/Jenkinsfile
+++ b/Jenkinsfile
@@ -41,8 +41,8 @@ try {
           buildEnv = docker.build 'realm-java:snapshot'
           // Docker image for testing Realm Object Server
           def dependProperties = readProperties file: 'dependencies.list'
-          def rosDeVersion = dependProperties["REALM_OBJECT_SERVER_DE_VERSION"]
-          rosEnv = docker.build 'ros:snapshot', "--build-arg ROS_DE_VERSION=${rosDeVersion} tools/sync_test_server"
+          def rosVersion = dependProperties["REALM_OBJECT_SERVER_VERSION"]
+          rosEnv = docker.build 'ros:snapshot', "--build-arg ROS_VERSION=${rosVersion} tools/sync_test_server"
         }
 
 	    rosContainer = rosEnv.run()
@@ -190,7 +190,7 @@ def stopLogCatCollector(String backgroundPid) {
 }
 
 def archiveRosLog(String id) {
-  sh "docker cp ${id}:/tmp/ros-testing-server.log ./ros.log"
+  sh "docker cp ${id}:/tmp/integration-test-command-server.log ./ros.log"
   zip([
       'zipFile': 'roslog.zip',
       'archive': true,
diff --git a/dependencies.list b/dependencies.list
index d48cd91181..949504a8b7 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -5,4 +5,4 @@ REALM_SYNC_SHA256=7764304d5dc7db7b4b9be9916f753c14c61c40e9f09fd1d92abeee3d847440
 
 # Object Server Release used by Integration tests. Installed using NPM.
 # Use `npm view realm-object-server versions` to get a list of available versions.
-REALM_OBJECT_SERVER_DE_VERSION=3.1.0
+REALM_OBJECT_SERVER_VERSION=3.1.5
diff --git a/examples/architectureComponentsExample/build.gradle b/examples/architectureComponentsExample/build.gradle
index 2bf5eedf9f..5371c339cf 100644
--- a/examples/architectureComponentsExample/build.gradle
+++ b/examples/architectureComponentsExample/build.gradle
@@ -28,7 +28,11 @@ android {
 
     buildTypes {
         release {
-            minifyEnabled false
+            minifyEnabled true
+            signingConfig signingConfigs.debug
+        }
+        debug {
+            minifyEnabled true
         }
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index 74c3b6e0cd..8ea8719c14 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -884,7 +884,7 @@ public void binaryData_nullabilityConversions() {
         assertEquals(0, list.get(0).length);
         assertArrayEquals(new byte[] {1, 2, 3}, list.get(1));
     }
-    
+
     @Test
     public void setRequired_true_onPrimaryKeyField_containsNullValues_shouldThrow() {
         if (type == ObjectSchemaType.IMMUTABLE) {
@@ -1349,4 +1349,39 @@ public void addList_modelClassThrowsWithProperError() {
     private interface FieldRunnable {
         void run(String fieldName);
     }
+
+    // Tests https://github.com/realm/realm-studio/issues/5899
+    @Test
+    public void setRequired_keepExistingRowsIfPrimaryKey() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
+        DynamicRealm dynRealm = (DynamicRealm) realm;
+        String className = "NewClass";
+        String fieldName = "field";
+
+        // Check all primary key types
+        for (PrimaryKeyFieldType fieldType : PrimaryKeyFieldType.values()) {
+            schema.addField(fieldName, fieldType.getType(), FieldAttribute.PRIMARY_KEY); // primary key field
+
+            // Hackish way to add sample data, only treat string differently
+            for (int i = 0; i < 5; i++) {
+                Object primaryKeyValue = (fieldType.getType() == String.class) ? Integer.toString(i) : i;
+                dynRealm.createObject(className, primaryKeyValue);
+            }
+
+            // Verify that sample data is intact before swapping nullability state
+            String errMsg = String.format(String.format("Count mismatch for FieldType = %s and Nullable = %s", fieldType.getType(), schema.isNullable(fieldName)));
+            assertEquals(errMsg, 5, dynRealm.where(className).count());
+
+            // Swap nullability state
+            schema.setRequired(fieldName, !schema.isRequired(fieldName));
+            errMsg = String.format(String.format("Count mismatch for FieldType = %s and Nullable = %s", fieldType.getType(), schema.isNullable(fieldName)));
+            assertEquals(errMsg, 5, dynRealm.where(className).count());
+
+            // Cleanup
+            dynRealm.delete(className);
+            schema.removeField(fieldName);
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
index d85ad5e1d9..077b0de3e9 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
@@ -215,10 +215,13 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsColumnNullable(J
 // 4d. the column to be converted will index shifted one place to column_index + 1
 // 5. search indexing must be preserved
 // 6. removing the original column and renaming the temporary column will make it look like original is being modified
+//
+// WARNING: These methods do NOT work on primary key columns if the Realm is synchronized.
+//
 
 // Converts a table to allow for nullable values
 // Works on both normal table columns and sub tables
-static void convert_column_to_nullable(JNIEnv* env, Table* old_table, size_t old_col_ndx, Table* new_table, size_t new_col_ndx, bool is_primary_key)
+static void convert_column_to_nullable(JNIEnv* env, Table* old_table, size_t old_col_ndx, Table* new_table, size_t new_col_ndx)
 {
     DataType column_type = old_table->get_column_type(old_col_ndx);
     if (old_table != new_table) {
@@ -229,12 +232,7 @@ static void convert_column_to_nullable(JNIEnv* env, Table* old_table, size_t old
             case type_String: {
                 // Payload copy is needed
                 StringData sd(old_table->get_string(old_col_ndx, i));
-                if (is_primary_key) {
-                    new_table->set_string_unique(new_col_ndx, i, sd);
-                }
-                else {
-                    new_table->set_string(new_col_ndx, i, sd);
-                }
+                new_table->set_string(new_col_ndx, i, sd);
                 break;
             }
             case type_Binary: {
@@ -243,12 +241,7 @@ static void convert_column_to_nullable(JNIEnv* env, Table* old_table, size_t old
                 break;
             }
             case type_Int:
-                if (is_primary_key) {
-                    new_table->set_int_unique(new_col_ndx, i, old_table->get_int(old_col_ndx, i));
-                }
-                else {
-                    new_table->set_int(new_col_ndx, i, old_table->get_int(old_col_ndx, i));
-                }
+                new_table->set_int(new_col_ndx, i, old_table->get_int(old_col_ndx, i));
                 break;
             case type_Bool:
                 new_table->set_bool(new_col_ndx, i, old_table->get_bool(old_col_ndx, i));
@@ -313,8 +306,11 @@ static void create_new_column(Table* table, size_t column_index, bool nullable)
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullable(JNIEnv* env, jobject obj,
                                                                                   jlong native_table_ptr,
                                                                                   jlong j_column_index,
-                                                                                  jboolean is_primary_key)
+                                                                                  jboolean)
 {
+#if REALM_ENABLE_SYNC
+    REALM_ASSERT(false);
+#endif
     Table* table = TBL(native_table_ptr);
     if (!TBL_AND_COL_INDEX_VALID(env, table, j_column_index)) {
         return;
@@ -352,11 +348,11 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullabl
             for (size_t i = 0; i < table->size(); ++i) {
                 TableRef new_subtable = table->get_subtable(column_index, i);
                 TableRef old_subtable = table->get_subtable(column_index + 1, i);
-                convert_column_to_nullable(env, old_subtable.get(), 0, new_subtable.get(), 0, is_primary_key);
+                convert_column_to_nullable(env, old_subtable.get(), 0, new_subtable.get(), 0);
             }
         }
         else {
-            convert_column_to_nullable(env, table, column_index + 1, table, column_index, is_primary_key);
+            convert_column_to_nullable(env, table, column_index + 1, table, column_index);
         }
 
         // Cleanup
@@ -373,12 +369,14 @@ static void convert_column_to_not_nullable(JNIEnv* env, Table* old_table, size_t
 {
     DataType column_type = old_table->get_column_type(old_col_ndx);
     std::string column_name = old_table->get_column_name(old_col_ndx);
+    size_t no_rows = old_table->size();
     if (old_table != new_table) {
-        new_table->add_empty_row(old_table->size());
+        new_table->add_empty_row(no_rows);
     }
-    for (size_t i = 0; i < old_table->size(); ++i) {
+    for (size_t i = 0; i < no_rows; ++i) {
         switch (column_type) { // FIXME: respect user-specified default values
             case type_String: {
+                // Payload copy is needed
                 StringData sd = old_table->get_string(old_col_ndx, i);
                 if (sd == realm::null()) {
                     if (is_primary_key) {
@@ -390,13 +388,7 @@ static void convert_column_to_not_nullable(JNIEnv* env, Table* old_table, size_t
                     }
                 }
                 else {
-                    // Payload copy is needed
-                    if (is_primary_key) {
-                        new_table->set_string_unique(new_col_ndx, i, sd);
-                    }
-                    else {
-                        new_table->set_string(new_col_ndx, i, sd);
-                    }
+                    new_table->set_string(new_col_ndx, i, sd);
                 }
                 break;
             }
@@ -423,12 +415,7 @@ static void convert_column_to_not_nullable(JNIEnv* env, Table* old_table, size_t
                     }
                 }
                 else {
-                    if (is_primary_key) {
-                        new_table->set_int_unique(new_col_ndx, i, old_table->get_int(old_col_ndx, i));
-                    }
-                    else {
-                        new_table->set_int(new_col_ndx, i, old_table->get_int(old_col_ndx, i));
-                    }
+                    new_table->set_int(new_col_ndx, i, old_table->get_int(old_col_ndx, i));
                 }
                 break;
             case type_Bool:
@@ -483,6 +470,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNull
                                                                                      jlong j_column_index,
                                                                                      jboolean is_primary_key)
 {
+#if REALM_ENABLE_SYNC
+    REALM_ASSERT(false);
+#endif
     try {
         Table* table = TBL(native_table_ptr);
         if (!TBL_AND_COL_INDEX_VALID(env, table, j_column_index)) {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java
index b897c13f5c..e9be90c80e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java
@@ -445,12 +445,20 @@ public void registerSchemaChangedCallback(SchemaChangedCallback callback) {
     }
 
     /**
-     * Returns {@code true} if this Realm is a partially synchronized Realm.
+     * Returns {@code true} if this Realm is a query-based synchronized Realm.
      */
     public boolean isPartial() {
         return nativeIsPartial(nativePtr);
     }
 
+    /**
+     * Returns {@code true} if this Realm is a synchronized Realm, either query-based or fully
+     * synchronized.
+     */
+    public boolean isSyncRealm() {
+        return osRealmConfig.getResolvedRealmURI() != null;
+    }
+
     // addIterator(), detachIterators() and invalidateIterators() are used to make RealmResults stable iterators work.
     // The iterator will iterate on a snapshot Results if it is accessed inside a transaction.
     // See https://github.com/realm/realm-java/issues/3883 for more information.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index 533603d665..063e580c75 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -226,6 +226,9 @@ public boolean isColumnNullable(long columnIndex) {
      * @param columnIndex the column index.
      */
     public void convertColumnToNullable(long columnIndex) {
+        if (sharedRealm.isSyncRealm()) {
+            throw new IllegalStateException("This method is only available for non-synchronized Realms");
+        }
         nativeConvertColumnToNullable(nativePtr, columnIndex, isPrimaryKey(columnIndex));
     }
 
@@ -235,6 +238,9 @@ public void convertColumnToNullable(long columnIndex) {
      * @param columnIndex the column index.
      */
     public void convertColumnToNotNullable(long columnIndex) {
+        if (sharedRealm.isSyncRealm()) {
+            throw new IllegalStateException("This method is only available for non-synchronized Realms");
+        }
         nativeConvertColumnToNotNullable(nativePtr, columnIndex, isPrimaryKey(columnIndex));
     }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index c7f98d65b9..08f553c743 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -44,6 +44,8 @@
 import io.realm.internal.network.ExponentialBackoffTask;
 import io.realm.internal.network.LogoutResponse;
 import io.realm.internal.network.LookupUserIdResponse;
+import io.realm.internal.network.UpdateAccountRequest;
+import io.realm.internal.network.UpdateAccountResponse;
 import io.realm.internal.objectserver.Token;
 import io.realm.log.RealmLog;
 
@@ -135,16 +137,7 @@ public static SyncUser fromJson(String user) {
      * @throws IllegalArgumentException if the URL is malformed.
      */
     public static SyncUser logIn(final SyncCredentials credentials, final String authenticationUrl) throws ObjectServerError {
-        URL authUrl;
-        try {
-            authUrl = new URL(authenticationUrl);
-            // If no path segment is provided append `/auth` which is the standard location.
-            if (authUrl.getPath().equals("")) {
-                authUrl = new URL(authUrl.toString() + "/auth");
-            }
-        } catch (MalformedURLException e) {
-            throw new IllegalArgumentException("Invalid URL " + authenticationUrl + ".", e);
-        }
+        URL authUrl = getUrl(authenticationUrl);
 
         ObjectServerError error;
         try {
@@ -177,6 +170,27 @@ public static SyncUser logIn(final SyncCredentials credentials, final String aut
         throw error;
     }
 
+    /**
+     * Converts the input URL to a Realm Authentication URL
+     *
+     * @param authenticationUrl user provided url string.
+     *
+     * @return normalized authentication url.
+     * @throws IllegalArgumentException if something was wrong with the URL.
+     */
+    private static URL getUrl(String authenticationUrl) {
+        try {
+            URL authUrl = new URL(authenticationUrl);
+            // If no path segment is provided append `/auth` which is the standard location.
+            if (authUrl.getPath().equals("")) {
+                authUrl = new URL(authUrl.toString() + "/auth");
+            }
+            return authUrl;
+        } catch (MalformedURLException e) {
+            throw new IllegalArgumentException("Invalid URL " + authenticationUrl + ".", e);
+        }
+    }
+
     /**
      * Logs in the user to the Realm Object Server. A logged in user is required to be able to create a
      * {@link SyncConfiguration}.
@@ -392,6 +406,261 @@ public SyncUser run() {
         }.start();
     }
 
+
+    /**
+     * Request a password reset email to be sent to a user's email.
+     * This will not fail, even if the email doesn't belong to a Realm Object Server user.
+     * <p>
+     * This can only be used for users who authenticated with the {@link SyncCredentials.IdentityProvider#USERNAME_PASSWORD}
+     * provider, and passed a valid email address as a username.
+     *
+     * @param email email that corresponds to the user's username.
+     * @param authenticationUrl the url used to authenticate the user.
+     * @throws IllegalStateException if this method is called on the UI thread.
+     * @throws IllegalArgumentException if no email or authenticationUrl was provided.
+     * @throws ObjectServerError if an error happened on the server.
+     */
+    public static void requestPasswordReset(String email, String authenticationUrl) throws ObjectServerError {
+        if (Util.isEmptyString(email)) {
+            throw new IllegalArgumentException("Not-null 'email' required.");
+        }
+        URL authUrl = getUrl(authenticationUrl);
+        AuthenticationServer authServer = SyncManager.getAuthServer();
+        UpdateAccountResponse response = authServer.requestPasswordReset(email, authUrl);
+        if (!response.isValid()) {
+            throw response.getError();
+        }
+    }
+
+    /**
+     * Request a password reset email to be sent to a user's email.
+     * This will not fail, even if the email doesn't belong to a Realm Object Server user.
+     * <p>
+     * This can only be used for users who authenticated with the {@link SyncCredentials.IdentityProvider#USERNAME_PASSWORD}
+     * provider, and passed a valid email address as a username.
+     *
+     * @param email email that corresponds to the user's username.
+     * @param authenticationUrl the url used to authenticate the user.
+     * @param callback callback when the request has completed or failed. The callback will always happen on the same thread
+     * as this method is called on.
+     * @return representation of the async task that can be used to cancel it if needed.
+     * @throws IllegalStateException if this method is called on a non-looper thread.
+     * @throws IllegalArgumentException if no email or authenticationUrl was provided.
+     */
+    public static RealmAsyncTask requestPasswordResetAsync(final String email, final String authenticationUrl, final Callback<Void> callback) {
+        checkLooperThread("Asynchronous requesting a password reset is only possible from looper threads.");
+        //noinspection ConstantConditions
+        if (callback == null) {
+            throw new IllegalArgumentException("Non-null 'callback' required.");
+        }
+
+        return new Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+            @Override
+            public Void run() {
+                requestPasswordReset(email, authenticationUrl);
+                return null;
+            }
+        }.start();
+    }
+
+    /**
+     * Complete the password reset flow by using the reset token sent to the user's email as a one-time authorization
+     * token to change the password.
+     * <p>
+     * This can only be used for users who authenticated with the {@link SyncCredentials.IdentityProvider#USERNAME_PASSWORD}
+     * provider, and passed a valid email address as a username.
+     * <p>
+     * By default, Realm Object Server will send a link to the user's email that will redirect to a webpage where
+     * they can enter their new password. If you wish to provide a native UX, you may wish to modify the password
+     * authentication provider to use a custom URL with deep linking, so you can open the app, extract the token, and
+     * navigate to a view that allows to change the password within the app.
+     *
+     * @param resetToken the token that was sent to the user's email address.
+     * @param newPassword the user's new password.
+     * @param authenticationUrl the url used to authenticate the user.
+     * @throws IllegalStateException if this method is called on the UI thread.
+     * @throws IllegalArgumentException if no {@code token} or {@code newPassword} was provided.
+     * @throws ObjectServerError if an error happened on the server.
+     */
+    public static void completePasswordReset(String resetToken, String newPassword, String authenticationUrl) {
+        if (Util.isEmptyString(resetToken)) {
+            throw new IllegalArgumentException("Not-null 'token' required.");
+        }
+        if (Util.isEmptyString(newPassword)) {
+            throw new IllegalArgumentException("Not-null 'newPassword' required.");
+        }
+        URL authUrl = getUrl(authenticationUrl);
+        AuthenticationServer authServer = SyncManager.getAuthServer();
+        UpdateAccountResponse response = authServer.completePasswordReset(resetToken, newPassword, authUrl);
+        if (!response.isValid()) {
+            throw response.getError();
+        }
+    }
+
+    /**
+     * Complete the password reset flow by using the reset token sent to the user's email as a one-time authorization
+     * token to change the password.
+     * <p>
+     * This can only be used for users who authenticated with the {@link SyncCredentials.IdentityProvider#USERNAME_PASSWORD}
+     * provider, and passed a valid email address as a username.
+     * <p>
+     * By default, Realm Object Server will send a link to the user's email that will redirect to a webpage where
+     * they can enter their new password. If you wish to provide a native UX, you may wish to modify the password
+     * authentication provider to use a custom URL with deep linking, so you can open the app, extract the token, and
+     * navigate to a view that allows to change the password within the app.
+     *
+     * @param resetToken the token that was sent to the user's email address.
+     * @param newPassword the user's new password.
+     * @param authenticationUrl the url used to authenticate the user.
+     * @param callback callback when the server has accepted the new password or failed. The callback will always happen on the same thread
+     * as this method is called on.
+     * @return representation of the async task that can be used to cancel it if needed.
+     * @throws IllegalStateException if this method is called on a non-looper thread.
+     * @throws IllegalArgumentException if no {@code token} or {@code newPassword} was provided.
+     */
+    public static RealmAsyncTask completePasswordResetAsync(final String resetToken,
+                                           final String newPassword,
+                                           final String authenticationUrl,
+                                           final Callback<Void> callback) throws ObjectServerError {
+        checkLooperThread("Asynchronously completing a password reset is only possible from looper threads.");
+        //noinspection ConstantConditions
+        if (callback == null) {
+            throw new IllegalArgumentException("Non-null 'callback' required.");
+        }
+
+        return new Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+            @Override
+            public Void run() {
+                completePasswordReset(resetToken, newPassword, authenticationUrl);
+                return null;
+            }
+        }.start();
+    }
+
+    /**
+     * Request an email confirmation email to be sent to a user's email.
+     * This will not fail, even if the email doesn't belong to a Realm Object Server user.
+     * <p>
+     * This can only be used for users who authenticated with the {@link SyncCredentials.IdentityProvider#USERNAME_PASSWORD}
+     * provider, and passed a valid email address as a username.
+     *
+     * @param email the email that corresponds to the user's username.
+     * @param authenticationUrl the url used to authenticate the user.
+     * @throws IllegalStateException if this method is called on the UI thread.
+     * @throws IllegalArgumentException if no {@code email} was provided.
+     * @throws ObjectServerError if an error happened on the server.
+     */
+    public static void requestEmailConfirmation(String email, String authenticationUrl) throws ObjectServerError {
+        if (Util.isEmptyString(email)) {
+            throw new IllegalArgumentException("Not-null 'email' required.");
+        }
+        URL authUrl = getUrl(authenticationUrl);
+        AuthenticationServer authServer = SyncManager.getAuthServer();
+        UpdateAccountResponse response = authServer.requestEmailConfirmation(email, authUrl);
+        if (!response.isValid()) {
+            throw response.getError();
+        }
+    }
+
+    /**
+     * Request an email confirmation email to be sent to a user's email.
+     * This will not fail, even if the email doesn't belong to a Realm Object Server user.
+     * <p>
+     * This can only be used for users who authenticated with the {@link SyncCredentials.IdentityProvider#USERNAME_PASSWORD}
+     * provider, and passed a valid email address as a username.
+     *
+     * @param email the email that corresponds to the user's username.
+     * @param authenticationUrl the url used to authenticate the user.
+     * @param callback callback when the request has completed or failed. The callback will always happen on the same thread
+     * as this method is called on.
+     * @return representation of the async task that can be used to cancel it if needed.
+     * @throws IllegalStateException if this method is called on a non-looper thread.
+     * @throws IllegalArgumentException if no {@code email} was provided.
+     */
+    public static RealmAsyncTask requestEmailConfirmationAsync(final String email, final String authenticationUrl, final Callback<Void> callback) {
+        checkLooperThread("Asynchronously requesting an email confirmation is only possible from looper threads.");
+        //noinspection ConstantConditions
+        if (callback == null) {
+            throw new IllegalArgumentException("Non-null 'callback' required.");
+        }
+
+        return new Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+            @Override
+            public Void run() {
+                requestEmailConfirmation(email, authenticationUrl);
+                return null;
+            }
+        }.start();
+    }
+
+    /**
+     * Complete the email confirmation flow by using the confirmation token sent to the user's email as a one-time
+     * authorization token to confirm their email.
+     * <p>
+     * This can only be used for users who authenticated with the {@link SyncCredentials.IdentityProvider#USERNAME_PASSWORD}
+     * provider, and passed a valid email address as a username.
+     * <p>
+     * By default, Realm Object Server will send a link to the user's email that will redirect to a webpage where
+     * they can enter their new password. If you wish to provide a native UX, you may wish to modify the password
+     * authentication provider to use a custom URL with deep linking, so you can open the app, extract the token,
+     * and navigate to a view that allows to confirm the email within the app.
+     *
+     * @param confirmationToken the token that was sent to the user's email address.
+     * @param authenticationUrl the url used to authenticate the user.
+     * @throws IllegalStateException if this method is called on the UI thread.
+     * @throws IllegalArgumentException if no {@code confirmationToken} was provided.
+     * @throws ObjectServerError if an error happened on the server.
+     */
+    public static void confirmEmail(String confirmationToken, String authenticationUrl) throws ObjectServerError {
+        if (Util.isEmptyString(confirmationToken)) {
+            throw new IllegalArgumentException("Not-null 'confirmationToken' required.");
+        }
+        URL authUrl = getUrl(authenticationUrl);
+        AuthenticationServer authServer = SyncManager.getAuthServer();
+        UpdateAccountResponse response = authServer.confirmEmail(confirmationToken, authUrl);
+        if (!response.isValid()) {
+            throw response.getError();
+        }
+    }
+
+    /**
+     * Complete the email confirmation flow by using the confirmation token sent to the user's email as a one-time
+     * authorization token to confirm their email. This functionalit
+     * <p>
+     * This can only be used for users who authenticated with the {@link SyncCredentials.IdentityProvider#USERNAME_PASSWORD}
+     * provider, and passed a valid email address as a username.
+     * <p>
+     * By default, Realm Object Server will send a link to the user's email that will redirect to a webpage where
+     * they can enter their new password. If you wish to provide a native UX, you may wish to modify the password
+     * authentication provider to use a custom URL with deep linking, so you can open the app, extract the token,
+     * and navigate to a view that allows to confirm the email within the app.
+     *
+     * @param confirmationToken the token that was sent to the user's email address.
+     * @param authenticationUrl the url used to authenticate the user.
+     * @param callback callback when the server has confirmed the email or failed. The callback will always happen on the same thread
+     * as this method is called on.
+     * @return representation of the async task that can be used to cancel it if needed.
+     * @throws IllegalStateException if this method is called on a non-looper thread.
+     * @throws IllegalArgumentException if no {@code confirmationToken} was provided.
+     */
+    public static RealmAsyncTask confirmEmailAsync(final String confirmationToken,
+                                            final String authenticationUrl,
+                                            final Callback<Void> callback) {
+        checkLooperThread("Asynchronously confirming an email is only possible from looper threads.");
+        //noinspection ConstantConditions
+        if (callback == null) {
+            throw new IllegalArgumentException("Non-null 'callback' required.");
+        }
+
+        return new Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+            @Override
+            public Void run() {
+                confirmEmail(confirmationToken, authenticationUrl);
+                return null;
+            }
+        }.start();
+    }
+
     /**
      * Given a Realm Object Server authentication provider and a provider identifier for a user (for example, a username), look up and return user information for that user.
      *
@@ -401,7 +670,9 @@ public SyncUser run() {
      *
      * @return {@code SyncUser} associated with the given identity provider and providerId, or {@code null} in case
      * of an {@code invalid} provider or {@code providerId}.
-     * @throws ObjectServerError in case of an error.
+     * @throws IllegalStateException if this method is called on the UI thread.
+     * @throws IllegalArgumentException if no {@code providerUserIdentity} or {@code provider} string was provided.
+     * @throws ObjectServerError if an error happened on the server.
      */
     public SyncUserInfo retrieveInfoForUser(final String providerUserIdentity, final String provider) throws ObjectServerError {
         if (Util.isEmptyString(providerUserIdentity)) {
@@ -435,9 +706,7 @@ public SyncUserInfo retrieveInfoForUser(final String providerUserIdentity, final
      * @param providerUserIdentity The username or identity of the user as issued by the authentication provider.
      *                             In most cases this is different from the Realm Object Server-issued identity.
      * @param provider The authentication provider {@link io.realm.SyncCredentials.IdentityProvider} that manages the user whose information is desired.
-     *
-     * @return {@code SyncUser} associated with the given identity provider and providerId, or {@code null} in case
-     * of an {@code invalid} provider or {@code providerId}.
+     * @return representation of the async task that can be used to cancel it if needed.
      * @param callback callback when the lookup has completed or failed. The callback will always happen on the same thread
      * as this method is called on.
      * @return representation of the async task that can be used to cancel it if needed.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
index 8906515e83..1e33ab0d0f 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
@@ -73,4 +73,24 @@
      * what is needed will depend on what type of {@link SyncCredentials} was used.
      */
     LookupUserIdResponse retrieveUser(Token adminToken, String provider, String providerId, URL authenticationUrl);
+
+    /**
+     * Request a password reset for the user identified by the provided email.
+     */
+    UpdateAccountResponse requestPasswordReset(String email, URL authenticationUrl);
+
+    /**
+     * Complete a password reset by sending the one-time token and the new password.
+     */
+    UpdateAccountResponse completePasswordReset(String token, String newPassword, URL authenticationUrl);
+
+    /**
+     * Request an email confirmation.
+     */
+    UpdateAccountResponse requestEmailConfirmation(String email, URL authenticationUrl);
+
+    /**
+     * Complete an email confirmation by sending the token contained in the email.
+     */
+    UpdateAccountResponse confirmEmail(String confirmationToken, URL authenticationUrl);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
index 4783b3d42e..0b3fc3ab44 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
@@ -39,6 +39,7 @@
     private static final String ACTION_LOGOUT = "revoke"; // Auth end point for logging out users
     private static final String ACTION_CHANGE_PASSWORD = "password"; // Auth end point for changing passwords
     private static final String ACTION_LOOKUP_USER_ID = "users/:provider:/:providerId:"; // Auth end point for looking up user id
+    private static final String ACTION_UPDATE_ACCOUNT = "password/updateAccount"; // Password reset and email confirmation
 
     private final OkHttpClient client = new OkHttpClient.Builder()
             .connectTimeout(15, TimeUnit.SECONDS)
@@ -125,6 +126,46 @@ public LookupUserIdResponse retrieveUser(Token adminToken, String provider, Stri
         }
     }
 
+    @Override
+    public UpdateAccountResponse requestPasswordReset(String email, URL authenticationUrl) {
+        try {
+            String requestBody = UpdateAccountRequest.requestPasswordReset(email).toJson();
+            return updateAccount(buildActionUrl(authenticationUrl, ACTION_UPDATE_ACCOUNT), requestBody);
+        } catch (Exception e) {
+            return UpdateAccountResponse.from(e);
+        }
+    }
+
+    @Override
+    public UpdateAccountResponse completePasswordReset(String token, String newPassword, URL authenticationUrl) {
+        try {
+            String requestBody = UpdateAccountRequest.completePasswordReset(token, newPassword).toJson();
+            return updateAccount(buildActionUrl(authenticationUrl, ACTION_UPDATE_ACCOUNT), requestBody);
+        } catch (Exception e) {
+            return UpdateAccountResponse.from(e);
+        }
+    }
+
+    @Override
+    public UpdateAccountResponse requestEmailConfirmation(String email, URL authenticationUrl) {
+        try {
+            String requestBody = UpdateAccountRequest.requestEmailConfirmation(email).toJson();
+            return updateAccount(buildActionUrl(authenticationUrl, ACTION_UPDATE_ACCOUNT), requestBody);
+        } catch (Exception e) {
+            return UpdateAccountResponse.from(e);
+        }
+    }
+
+    @Override
+    public UpdateAccountResponse confirmEmail(String confirmationToken, URL authenticationUrl) {
+        try {
+            String requestBody = UpdateAccountRequest.completeEmailConfirmation(confirmationToken).toJson();
+            return updateAccount(buildActionUrl(authenticationUrl, ACTION_UPDATE_ACCOUNT), requestBody);
+        } catch (Exception e) {
+            return UpdateAccountResponse.from(e);
+        }
+    }
+
     // Builds the URL for a specific auth endpoint
     private static URL buildActionUrl(URL authenticationUrl, String action) {
         final String baseUrlString = authenticationUrl.toExternalForm();
@@ -176,6 +217,16 @@ private LookupUserIdResponse lookupUserId(URL lookupUserIdUrl, String authToken)
         return LookupUserIdResponse.from(response);
     }
 
+    private UpdateAccountResponse updateAccount(URL updateAccountUrl, String requestBody) throws Exception {
+        RealmLog.debug("Network request (updateAccount): " + updateAccountUrl);
+        Request request = newAuthRequest(updateAccountUrl)
+                .post(RequestBody.create(JSON, requestBody))
+                .build();
+        Call call = client.newCall(request);
+        Response response = call.execute();
+        return UpdateAccountResponse.from(response);
+    }
+
     private Request.Builder newAuthRequest(URL url) {
         return newAuthRequest(url, null);
     }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/UpdateAccountRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/UpdateAccountRequest.java
new file mode 100644
index 0000000000..5669e6cf0f
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/UpdateAccountRequest.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import io.realm.internal.Util;
+
+/**
+ * This class encapsulates the JSON request body when either doing a password reset or an email confirmation
+ * flow.
+ */
+public class UpdateAccountRequest {
+
+    private static final Map<String, String> NO_DATA = new HashMap<>();
+
+    private final String action;
+    private final Map<String, String> data;
+    private final String providerId; // Should be an email address, but let server validate that.
+
+    public static UpdateAccountRequest requestPasswordReset(String email) {
+        return new UpdateAccountRequest("reset_password", NO_DATA, email);
+    }
+
+    public static UpdateAccountRequest completePasswordReset(String resetPasswordToken, String newPassword) {
+        Map<String, String> data = new HashMap<>();
+        data.put("token", resetPasswordToken);
+        data.put("new_password", newPassword);
+        return new UpdateAccountRequest("complete_reset", data, null);
+    }
+
+    public static UpdateAccountRequest requestEmailConfirmation(String email) {
+        return new UpdateAccountRequest("request_email_confirmation", NO_DATA, email);
+    }
+
+    public static UpdateAccountRequest completeEmailConfirmation(String confirmEmailToken) {
+        Map<String, String> data = new HashMap<>();
+        data.put("token", confirmEmailToken);
+        return new UpdateAccountRequest("confirm_email", data, null);
+    }
+
+    private UpdateAccountRequest(String action, Map<String, String> data, String providerId) {
+        this.action = action;
+        this.data = data;
+        this.providerId = providerId;
+    }
+
+    /**
+     * Converts the request into a JSON payload.
+     */
+    public String toJson() {
+        Map<String, Object> payload = new HashMap<String, Object>() {{
+            if (!Util.isEmptyString(providerId)) {
+                put("provider_id", providerId);
+            }
+            data.put("action", action);
+            put("data", data);
+        }};
+
+        return new JSONObject(payload).toString();
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/UpdateAccountResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/UpdateAccountResponse.java
new file mode 100644
index 0000000000..cdb528bd86
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/UpdateAccountResponse.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import java.io.IOException;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import okhttp3.Response;
+
+/**
+ * This class represents the response from an {@link UpdateAccountRequest} network call.
+ */
+public class UpdateAccountResponse extends AuthServerResponse {
+
+    public static UpdateAccountResponse from(Exception exception) {
+        return new UpdateAccountResponse(new ObjectServerError(ErrorCode.fromException(exception), exception));
+    }
+
+    public static UpdateAccountResponse from(Response response) {
+        if (response.isSuccessful()) {
+            return new UpdateAccountResponse();
+        } else {
+            try {
+                String serverResponse = response.body().string();
+                return new UpdateAccountResponse(AuthServerResponse.createError(serverResponse, response.code()));
+            } catch (IOException e) {
+                ObjectServerError error = new ObjectServerError(ErrorCode.IO_EXCEPTION, e);
+                return new UpdateAccountResponse(error);
+            }
+        }
+    }
+
+    /**
+     * Create a failure response object.
+     */
+    public UpdateAccountResponse(ObjectServerError error) {
+        this.error = error;
+    }
+
+    /**
+     * Create a successful response object.
+     */
+    public UpdateAccountResponse() {
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index 009a988e86..26c68b52fa 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -787,7 +787,7 @@ public void retrieve_notAdmin() {
         try {
             user1.retrieveInfoForUser(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, username2);
             fail("It should not be possible to lookup a user using non admin token");
-        } catch (IllegalArgumentException expected) {
+        } catch (IllegalArgumentException ignored) {
         }
     }
 
@@ -824,4 +824,120 @@ public void onError(ObjectServerError error) {
             }
         });
     }
+
+    @Test
+    @RunTestInLooperThread
+    @Ignore("Depends on https://github.com/realm/realm-java/pull/5909")
+    public void requestPasswordResetAsync() {
+        String email = "foo@bar.baz";
+        UserFactory.createUser(email).logOut();
+
+        // Currently no easy way to see if we actually get an email.
+        // Just verify that the network request can complete successfully.
+        SyncUser.requestPasswordResetAsync(email, Constants.AUTH_URL, new SyncUser.Callback<Void>() {
+            @Override
+            public void onSuccess(Void result) {
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    @Ignore("Depends on https://github.com/realm/realm-java/pull/5909")
+    public void requestResetPassword_unknownEmail() {
+        SyncUser.requestPasswordResetAsync("unknown@realm.io", Constants.AUTH_URL, new SyncUser.Callback<Void>() {
+            @Override
+            public void onSuccess(Void result) {
+                // Server will respond with SUCCESS if the email is incorrect (for security reasons).
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    @Ignore("Depends on https://github.com/realm/realm-java/pull/5909")
+    public void completeResetPassword_invalidToken() {
+        SyncUser.completePasswordResetAsync("invalidToken","newPassword", Constants.AUTH_URL, new SyncUser.Callback<Void>() {
+            @Override
+            public void onSuccess(Void result) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.ACCESS_DENIED, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    @Ignore("Depends on https://github.com/realm/realm-java/pull/5909")
+    public void requestEmailConfirmation() {
+        String email = "foo@bar.baz";
+        UserFactory.createUser(email).logOut();
+
+        // Currently no easy way to see if we actually get an email.
+        // Just verify that the network request can complete successfully.
+        SyncUser.requestEmailConfirmationAsync(email, Constants.AUTH_URL, new SyncUser.Callback<Void>() {
+            @Override
+            public void onSuccess(Void result) {
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+    @Test
+    @RunTestInLooperThread
+    @Ignore("Depends on https://github.com/realm/realm-java/pull/5909")
+    public void requestEmailConfirmation_invalidEmail() {
+        SyncUser.requestEmailConfirmationAsync("unknown@realm.io", Constants.AUTH_URL, new SyncUser.Callback<Void>() {
+            @Override
+            public void onSuccess(Void result) {
+                // Server will respond with SUCCESS if the email is incorrect (for security reasons).
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+
+    @Test
+    @RunTestInLooperThread
+    @Ignore("Depends on https://github.com/realm/realm-java/pull/5909")
+    public void confirmEmail_invalidToken() {
+        SyncUser.confirmEmailAsync("invalidToken", Constants.AUTH_URL, new SyncUser.Callback<Void>() {
+            @Override
+            public void onSuccess(Void result) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.ACCESS_DENIED, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
index 88c4ab3ee5..d8d7d6de35 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
@@ -39,7 +39,7 @@
 // Must be in `io.realm.objectserver` to work around package protected methods.
 // This require Realm.init() to be called before using this class.
 public class UserFactory {
-    private static final String PASSWORD = "myPassw0rd";
+    public static final String PASSWORD = "myPassw0rd";
     // Since the integration tests need to use the same user for different processes, we create a new user name when the
     // test starts and store it in a Realm. Then it can be retrieved for every process.
     private String userName;
diff --git a/tools/sync_test_server/Dockerfile b/tools/sync_test_server/Dockerfile
index 29f8e46fad..fbb9bb0f86 100644
--- a/tools/sync_test_server/Dockerfile
+++ b/tools/sync_test_server/Dockerfile
@@ -4,19 +4,32 @@ FROM node:6.11.4
 RUN cp /usr/share/zoneinfo/Europe/Copenhagen /etc/localtime
 RUN echo "Europe/Copenhagen" >  /etc/timezone
 
-ARG ROS_DE_VERSION
+ARG ROS_VERSION
 
-# Install realm object server
-RUN npm install -g realm-object-server@$ROS_DE_VERSION -S
+# Install netstat (used for debugging)
+RUN apt-get update \
+  && DEBIAN_FRONTEND=noninteractive apt-get install -y \
+    net-tools \
+    psmisc \
+  && apt-get clean \
+  && rm -rf /var/lib/apt/lists/*
+
+## Copy ROS node template project to image. Then configure and prepare it for usage.
+COPY ros /ros
+WORKDIR "/ros"
+RUN sed -i -e "s/%ROS_VERSION%/$ROS_VERSION/g" package.json
+RUN npm install
+WORKDIR "/"
 
 # Install test server dependencies
-RUN npm install winston@2.4.0 temp httpdispatcher@1.0.0 fs-extra moment
+RUN npm install winston@2.4.0 temp httpdispatcher@1.0.0 fs-extra moment is-port-available@0.1.5
 
-COPY keys/public.pem keys/private.pem keys/127_0_0_1-server.key.pem keys/127_0_0_1-chain.crt.pem configuration.yml /
-COPY ros-testing-server.js /usr/bin/
+COPY keys/public.pem keys/private.pem keys/127_0_0_1-server.key.pem keys/127_0_0_1-chain.crt.pem /
+COPY integration-test-command-server.js /usr/bin/
 
-#Bypass the ROS license check
+# Bypass the ROS license check
 ENV DOCKER_DATA_PATH /
 ENV ROS_TOS_EMAIL_ADDRESS 'ci@realm.io'
 
-CMD /usr/bin/ros-testing-server.js /tmp/ros-testing-server.log
+# Run integration test server
+CMD /usr/bin/integration-test-command-server.js /tmp/integration-test-command-server.log
diff --git a/tools/sync_test_server/configuration.yml b/tools/sync_test_server/configuration.yml
deleted file mode 100644
index 9b73a0c68c..0000000000
--- a/tools/sync_test_server/configuration.yml
+++ /dev/null
@@ -1,320 +0,0 @@
-# Realm Object Server Configuration
-#
-# For each possible setting, the commented out values are the default values
-# unless another default is mentioned explicitly.
-#
-# Paths specified in this file can be either absolute or relative.
-# Relative paths are relative to the current working directory.
-
-
-## ----------------------------------------------------------------------------
-## The following options are MANDATORY, either by providing them in this file,
-## or as command-line options:
-## - storage: root_path
-## - auth:public_key_path
-## - auth:private_key_path
-## ----------------------------------------------------------------------------
-
-
-storage:
-  ## The directory in which the realm server will store all its data files.
-  ## This configuration option is MANDATORY.
-  root_path: '/var/realm/sync-services'
-
-## ----------------------------------------------------------------------------
-
-auth:
-  ## The path to the public and private keys (in PEM format) that will be used
-  ## to validate identity tokens sent by clients.
-  ## These configuration options are MANDATORY.
-  public_key_path: '/public.pem'
-  private_key_path: '/private.pem'
-
-  sync_hosts:
-    ## The hosts for which the authentication service will consider itself
-    ## authoritative. It will decline to process any kind of requests for Realm
-    ## files at other URLs. Addresses specified here must include host and port
-    ## (authority part of the URL according to RFC 3986) on which the sync
-    ## server is externally reachable. In addition to hosts configured here,
-    ## the authentication service will always accept the following hosts:
-    # - localhost:27800
-    #
-    # Additionally if a proxy server for the given protocol is configured, it
-    # will also accept requests for Realm files at these hosts:
-    # - ${proxy:http:listen_address}:${proxy:http:listen_port}
-    # - ${proxy:https:listen_address}:${proxy:https:listen_port}
-    #
-    # The derived hosts will also include aliases for local addresses
-    # with the following host names: '127.0.0.1', 'localhost' and '::'.
-
-  ttls:
-    ## The validity duration for Refresh Tokens. This can be a fairly high
-    ## value, ranging from a single day to multiple years, depending on
-    ## individual needs. Whenever the Refresh Token expires, clients will be
-    ## forced to delegate again to the authorizing party. If the credentials
-    ## there can be revoked by the user or are not opaquely managed by the
-    ## client, then this would force the user to manual intervention after the
-    ## expiration. Depending on the use case, this can be either desired or
-    ## should be prevented. This value is represented in seconds.
-    ## Default: 10 years.
-    # refresh_token: 315360000
-
-    ## The validity duration for Access Tokens. This should be a fairly small
-    ## number, especially if you are concerned with revocations being applied
-    ## quickly. This value is represented in seconds. Default: 1 minute.
-    ##
-    ## WARNING : Changing this value may impact the timeout of the refresh
-    ##           token test (AuthTests#preemptiveTokenRefresh)
-    access_token: 20
-
-  providers:
-    ## Providers of authentication tokens. Each provider has a configuration
-    ## object associated with it. If a provider is included here and its
-    ## configuration is valid, it will be enabled.
-
-    ## Possible providers: cloudkit, debug, google, facebook, realm, password
-    ## Providers 'realm' and 'password' are always enabled:
-    ## - The 'realm' provider is used to derive access tokens from a refresh token.
-    ## - The 'password' provider is required for the dashboard to work. It supports
-    ##   authentication through username/password and uses a PBKDF2 implementation.
-
-    ## This enables login via CloudKit's user record name.
-    # cloudkit:
-      ## The key ID retrieved when adding the public key derived from the
-      ## specified private_key_path in CloudKit's Server-to-Server Keys,
-      ## available through the API Access settings in the CloudKit dashboard.
-      # key_id: '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef'
-
-      ## The path to the certificate.
-      # private_key_path: 'cloudkit_eckey.pem'
-
-      ## The container identifier in reverse domain name notation.
-      # container: "iCloud.io.realm.exampleApp.ios"
-
-      ## The environment in which CloudKit should be used. The default is
-      ## 'development'. For the production deployment for apps on the AppStore
-      ## you must specify 'production'.
-      # environment: 'development'
-
-    ## This enables authentication via a Google Sign-In access token for a
-    ## specific app.
-    # google:
-      ## The client ID as retrieved when setting up the app in the Google
-      ## Developer Console.
-      # clientId: '012345678901-abcdefghijklmnopqrstvuvwxyz01234.apps.googleusercontent.com'
-
-    ## This enables authentication via a Facebook access token for a specific app.
-    ## This provider needs no configuration (uncommenting the next line enables it).
-    # facebook: {}
-
-    ## This enables authentication via an Azure Active Directory access token for a specific directory.
-    # azuread:
-      ## The Directory Id as retrieved from the Active Directory properties in the Azure portal.
-      # tenant_id: '01234567-89ab-cdef-0123-4567890a'
-
-    ## This would enable a custom authentication provider with the name "custom/twitter".
-    ## The prefix "custom/" is necessary for all authentication providers using a custom
-    ## implementation to ensure forwards-compatiblity and avoid name clashes.
-    # custom/twitter:
-      ## The implementation to be used. This can be either one of the predefined
-      ## implementations under a custom name or a custom implementation found at
-      ## the include_path or if not given at the auth:providers_include_path.
-      # implementation: custom_provider_implementation.js
-
-      ## The include path to use for this providers custom implementation.
-      # include_path: /~/.realm/auth
-
-      ## Beyond that custom implementations can define custom configuration
-      ## options which will be populated to their configuration and merged with
-      ## the default values they can define.
-     debug: {}
-
-## ----------------------------------------------------------------------------
-
-proxy:
-  ## Network settings for the externally accessible proxy module.
-  ## This can be enabled for both HTTP and HTTPS traffic simultaneously, and
-  ## forwards traffic to the sync and services internal modules.
-  ## It is possible to disable and replace the proxy module by another reverse proxy.
-  ##
-  ## Note: The proxy module forwards traffic to the internal modules on the
-  ## addresses and ports they listen on (as configured in the `network' section below).
-  ##
-  ## Shown below is a diagram of the default network configuration:
-  ##
-  ##                                                                     +----------------------+
-  ##                                                                     |                      |
-  ##                                                                     |     Sync module      |
-  ##                                                                     |                      |
-  ##                                                                     |      (internal)      |
-  ##                                                                     |                      |
-  ##                                                                 +-> |  Defaults:           |
-  ## +----------------+             +---------------------------+    |   |   Listen: 127.0.0.1  |
-  ## |                |             |                           |    |   |   Ports:             |
-  ## |  Realm Client  +------+      |        Proxy module       |    |   |    WS: tcp/27800     |
-  ## |                |      |      |                           |    |   |                      |
-  ## +-----------------      |      |  (externally accessible)  |    |   +----------------------+
-  ##                         +----> |                           |    |
-  ##                                |  Defaults:                |    |
-  ##                         +----> |   Listen: 0.0.0.0         +----+
-  ##      +------------      |      |   Ports:                  |    |   +----------------------+
-  ##      |           |      |      |    HTTP & WS: tcp/9080    |    |   |                      |
-  ##      |  Browser  +------+      |    HTTPS & WSS: tcp/9443  |    |   |    Services module   |
-  ##      |           |             |                           |    |   |                      |
-  ##      +-----------+             +---------------------------+    |   |      (internal)      |
-  ##                                                                 +-> |                      |
-  ##                                                                     |  Defaults:           |
-  ##                            Note: The proxy module can be            |   Listen: 127.0.0.1  |
-  ##                                  replaced by NGINX or other         |    Ports:            |
-  ##                                  reverse proxies                    |     HTTP: tcp/27080  |
-  ##                                                                     |                      |
-  ##                                                                     +----------------------+
-
-  http:
-    ## Whether or not to enable the HTTP proxy module. It enables multiplexing requests
-    ## by forwarding incoming requests on a single port to all services.
-    # enable: true
-
-    ## The address/interface on which the HTTP proxy module should listen. This defaults
-    ## to 127.0.0.1. If you wish to listen on all available interfaces,
-    ## uncomment the following line.
-    listen_address: '0.0.0.0'
-
-    ## The port that the HTTP proxy module should bind to.
-    listen_port: 9080
-
-  https:
-    ## Whether or not to enable the HTTPS proxy module. It enables multiplexing requests
-    ## by forwarding incoming requests on a single port to all services.
-    ## Note that even if it enabled, the HTTPS proxy will only start if supplied
-    ## with a valid pair of certificates through certificate_path and private_key_path below.
-     enable: true
-
-    ## The path to the certificate and private keys (in PEM format) that will be used
-    ## to set up the HTTPS server accepting connections.
-    ## These configuration options are MANDATORY to start the HTTPS proxy module.
-     certificate_path: '/127_0_0_1-chain.crt.pem'
-     private_key_path: '/127_0_0_1-server.key.pem'
-
-    ## The address/interface on which the HTTPS proxy module should listen. This defaults
-    ## to 127.0.0.1. If you wish to listen on all available interfaces,
-    ## uncomment the following line.
-     listen_address: '0.0.0.0'
-
-    ## The port that the HTTPS proxy module should bind to.
-     listen_port: 9443
-
-## ----------------------------------------------------------------------------
-
-network:
-  ## Network settings for internal modules, to which traffic is forwarded from
-  ## the proxy module. The proxy module will automatically forward traffic to the
-  ## internal modules on the ports they are configured to listen on in this section.
-
-  http:
-    ## The address/interface on which the server should listen for HTTP
-    ## services. This includes Dashboard and Authentication APIs.
-    ## This defaults to 127.0.0.1. If you wish to listen on all available
-    ## interfaces, uncomment the following line.
-    # listen_address: '0.0.0.0'
-
-    ## The port on which to listen for incoming requests to the Dashboard
-    ## and authentication APIs. This defaults to 27080.
-    # listen_port: 27080
-
-## ----------------------------------------------------------------------------
-
-sync:
-  ## Synchronization service settings, including clustering and load balancing.
-
-  servers:
-    ## An array of entries describing the cluster configuration.
-    ##
-    ## If no servers are configured, a default entry is inserted with the
-    ## following settings:
-    ##   - id: '0'
-    ##     address: '0.0.0.0'
-    ##     port: 27800
-    ##
-    ## Each entry must contain the following entries:
-    ##
-    ##    'id': A unique string ID used to distinguish between backend servers.
-    ##          This must remain stable, even if the particular backend server
-    ##          is moved to a different address or port.
-    ##
-    ##    'address': The address of the cluster participant. If '0.0.0.0' or
-    ##               '::', a sync server will be started on localhost (listening
-    ##               on '127.0.0.1' or '::1', respectively). Otherwise, it is
-    ##               assumed that the sync server is an external process,
-    ##               potentially on a separate machine.
-    ##
-    ##    'port': The port on which to connect to the particular cluster node.
-    ##            If address was '0.0.0.0' or '::', this is also the port number
-    ##            on which the local cluster node will listen for connections.
-
-## ----------------------------------------------------------------------------
-
-logging:
-  ## The logging level of the server.
-  ##
-  ## Note: This used to be an integer, but has been updated to be more
-  ## descriptive. The integer values are no longer supported.
-  ##
-  ## Possible values (from most to least verbose):
-  ##
-  ##   all: no filtering
-  ##   trace
-  ##   debug
-  ##   detail
-  ##   info: good for production (default)
-  ##   warn
-  ##   error
-  ##   fatal
-  ##   off: all output suppressed
-   level: 'detail'
-
-  ## The file to which the synchronisation server should log. This should
-  ## be a writable path from the perspective of the user under which the
-  ## server runs. If no path is specified, the server will log to stdout.
-  # path: '/var/log/realm-object-server.log'
-
-## ----------------------------------------------------------------------------
-
-performance:
-  ## The maximum number of Realm files that the server will have open
-  ## concurrently (LRU cache). The default is 256.
-  ## Only change this option if directed to by Realm support.
-  # max_open_files: 256
-
-## ----------------------------------------------------------------------------
-
-backup:
-  ## The backup is a server that delivers continuous backup of the Realms in
-  ## storage.root_path specified above. The backup is delivered to all connected
-  ## backup clients. Backup clients must be started separately with network
-  ## configuration parameters matching those of the server.
-
-  enable:
-    ## Whether or not to enable the backup server.
-    # enable: true
-
-  network:
-    ## The address/interface on which the backup server should listen. This
-    ## defaults to 127.0.0.1. If you wish to listen on all available interfaces,
-    ## uncomment the following line.
-    # listen_address: '0.0.0.0'
-
-    ## The port on which to listen. The backup server uses port 27810 by
-    ## default. For most deployments, there should not be a need to change this.
-    # listen_port: 27810
-
-  logging:
-    ## The logging level of the backup server.
-    ## The values are identical to the logging levels described above.
-    ## The default level is 'info'.
-    # level: 'info'
-
-    ## The file to which the synchronisation server should log. This should
-    ## be a writable path from the perspective of the user under which the
-    ## server runs. If no path is specified, the server will log to stdout.
-    # path: '/var/log/realm-object-server-backup.log'
diff --git a/tools/sync_test_server/integration-test-command-server.js b/tools/sync_test_server/integration-test-command-server.js
new file mode 100755
index 0000000000..71d4fa6179
--- /dev/null
+++ b/tools/sync_test_server/integration-test-command-server.js
@@ -0,0 +1,204 @@
+#!/usr/bin/env nodejs
+
+/**
+ * This script controls the Command Server responsible for starting and stopping
+ * ROS instances. The integration tests running on the device will communicate
+ * with it using a predefined port in order to say when the ROS instance
+ * should be started and stopped.
+ *
+ * This script is responsible for cleaning up any server state after it has been
+ * stopped, so a new integration test will start from a clean slate.
+ */
+
+var winston = require('winston'); //logging
+const spawn = require('child_process').spawn;
+const exec = require('child_process').exec;
+const isPortAvailable = require('is-port-available');
+var http = require('http');
+var dispatcher = require('httpdispatcher');
+var fs = require('fs-extra');
+var moment = require('moment')
+
+if (process. argv. length <= 2) {
+    console.log("Usage: " + __filename + " somefile.log");
+    process.exit(-1);
+}
+
+const logFile = process.argv[2];
+winston.level = 'debug';
+winston.add(winston.transports.File, {
+    filename: logFile,
+    json: false,
+    formatter: function(options) {
+        return moment().format('YYYY-MM-DD HH:mm:ss.SSSS') + ' ' + (undefined !== options.message ? options.message : '');
+    }
+});
+
+const PORT = 8888;
+var syncServerChildProcess = null;
+
+// When starting ROS, it isn't ready immediately. This method will wait until /health/
+// returns OK indicating that ROS is now fully initialized and ready.
+function waitForRosToInitialize(attempts, onSuccess, onError, startSequence) {
+    if (attempts == 0) {
+        onError("Could not get ROS to start. See Docker log.");
+        return;
+    }
+
+    http.get("http://0.0.0.0:9080/health", function(res) {
+        if (res.statusCode != 200) {
+            winston.warn("command-server: ROS /health/ returned: " + res.statusCode)
+            setTimeout(function() {
+                waitForRosToInitialize(attempts - 1, onSuccess, onError, startSequence);
+            }, 500);
+        } else {
+            onSuccess(startSequence);
+        }
+    }).on('error', function(err) {
+        winston.warn("command-server: ROS /health/ returned an error: " + err)
+        // ROS not accepting any connections yet.
+        // Errors like ECONNREFUSED 0.0.0.0:9080 will be reported here.
+        // Wait a little before trying again (common startup is ~1 second).
+        setTimeout(function() {
+            waitForRosToInitialize(attempts - 1, onSuccess, onError, startSequence);
+        }, 500);
+    });
+}
+
+// When starting a new ROS instance, an old one might still be in the process of being
+// torn down. This can sometimes cause the new server to fail to start due to the
+// port still being used. To prevent that, we wait for the port to be ready
+// before trying to start the server.
+function waitForPortToBeReady(attempts, onSuccess, onError) {
+    if (attempts == 0) {
+        // Log as much info as possible in order to help debugging
+        exec('ps auxw', (error, stdout, stderr) => {
+            winston.info(`command-server:\n ${stdout}`);
+        });
+        exec('netstat -tulpn', (error, stdout, stderr) => {
+            winston.info(`command-server:\n ${stdout}`);
+        });
+        onError("Port failed to become ready in time");
+        return;
+    }
+
+    // Port 9080 and 9443 are being used by ROS
+    isPortAvailable("9443").then( status => {
+        if (status) {
+            onSuccess();
+        } else {
+            winston.info("command-server: Port still in use. Retrying.")
+            setTimeout(function() {
+                waitForPortToBeReady(attempts - 1, onSuccess, onError);
+            }, 500);
+        }
+    });
+}
+
+function startRealmObjectServer(onSuccess, onError) {
+    stopRealmObjectServer(() => {
+        waitForPortToBeReady(20, function() {
+            winston.info("command-server: Starting ROS in /ros");
+            var env = Object.create( process.env );
+            winston.info(env.NODE_ENV);
+            env.NODE_ENV = 'development';
+
+            // Cleanup any previous server state
+            winston.info("command-server: Cleaning old server state");
+            fs.removeSync('/ros/data');
+            fs.removeSync('/ros/realm-object-server');
+            fs.removeSync('/ros/log.txt');
+            if (fs.existsSync('/ros/data')) {
+                onError("Could not delete data directory: " + globalNotifierDir);
+                return;
+            }
+            if (fs.existsSync('/ros/realm-object-server')) {
+                onError("Could not delete global notifier directory: " + globalNotifierDir);
+                return;
+            }
+
+            // Start ROS
+            syncServerChildProcess = spawn('npm', ['start'], { env: env, cwd: '/ros' });
+
+            // Route logs from ROS to the Command Server log so we can save it
+            syncServerChildProcess.stdout.on('data', (data) => {
+                winston.info(`ros: ${data}`);
+            });
+
+            syncServerChildProcess.stderr.on('data', (data) => {
+                winston.info(`ros: ${data}`);
+            });
+
+            // The interval between every health check is 0.5 second. Give the ROS 30 seconds to get fully initialized.
+            waitForRosToInitialize(60, onSuccess, onError, Date.now());
+
+        }, onError);
+    }, onError)
+}
+
+function stopRealmObjectServer(onSuccess, onError) {
+    if(syncServerChildProcess == null || syncServerChildProcess.killed) {
+        onSuccess("No ROS process found or the process has been killed before");
+    }
+    if (syncServerChildProcess) {
+        syncServerChildProcess.on('exit', function(code) {
+            // Manually kill sub process started by node that actually runs ROS.
+            // It is not killed when killing the process running NPM
+            exec('fuser -k 9443/tcp', (error, stdout, stderr) => {
+                if (error) {
+                    onError(error)
+                    return;
+                }
+                winston.info(`command-server: Stopping process: '${stdout}'`)
+                syncServerChildProcess.removeAllListeners('exit');
+                syncServerChildProcess = null;
+                onSuccess();
+            });
+        });
+        syncServerChildProcess.kill('SIGINT');
+    }
+}
+
+// Command Server endpoint: Start a new instance of ROS
+dispatcher.onGet("/start", function(req, res) {
+     winston.info("command-server: Attempting to start ROS");
+     startRealmObjectServer((startSequence) => {
+         res.writeHead(200, {'Content-Type': 'text/plain'});
+         let response = `ROS started after ${Date.now() - startSequence} ms`;
+         res.end(response);
+         winston.info("command-server: " + response);
+     }, function (err) {
+         res.writeHead(500, {'Content-Type': 'text/plain'});
+         res.end('Starting ROS failed: ' + err);
+         winston.error('command-server: Starting ROS failed: ' + err);
+     });
+});
+
+// Command Server endpoint: Stop a running instance of ROS.
+dispatcher.onGet("/stop", function(req, res) {
+      winston.info("command-server: Attempting to stop ROS");
+      stopRealmObjectServer(function() {
+            winston.info("command-server: ROS stopped");
+            res.writeHead(200, {'Content-Type': 'text/plain'});
+            res.end('ROS stopped');
+      }, function(err) {
+            winston.error('command-server: Stopping ROS failed: ' + err);
+            res.writeHead(500, {'Content-Type': 'text/plain'});
+            res.end('Stopping ROS failed: ' + err);
+      });
+});
+
+function handleRequest(request, response) {
+    try {
+        winston.info('command-server: ' + request.url);
+        dispatcher.dispatch(request, response);
+    } catch(err) {
+        winston.error('command-server: ' + err);
+    }
+}
+
+//Create and start the Http server
+var server = http.createServer(handleRequest);
+server.listen(PORT, function() {
+    winston.info("command-server: Integration test server listening on: 127.0.0.1:%s", PORT);
+});
diff --git a/tools/sync_test_server/ros-testing-server.js b/tools/sync_test_server/ros-testing-server.js
deleted file mode 100755
index 25561bbb7e..0000000000
--- a/tools/sync_test_server/ros-testing-server.js
+++ /dev/null
@@ -1,171 +0,0 @@
-#!/usr/bin/env nodejs
-
-var winston = require('winston'); //logging
-const temp = require('temp');
-const spawn = require('child_process').spawn;
-const exec = require('child_process').exec;
-var http = require('http');
-var dispatcher = require('httpdispatcher');
-var fs = require('fs-extra');
-var moment = require('moment')
-
-// Automatically track and cleanup files at exit
-temp.track();
-
-if (process. argv. length <= 2) {
-    console.log("Usage: " + __filename + " somefile.log");
-    process.exit(-1);
-}
-
-const logFile = process.argv[2];
-winston.level = 'debug';
-winston.add(winston.transports.File, {
-    filename: logFile,
-    json: false,
-    formatter: function(options) {
-        return moment().format('YYYY-MM-DD HH:mm:ss.SSSS') + ' ' + (undefined !== options.message ? options.message : '');
-    }
-});
-
-const PORT = 8888;
-
-function handleRequest(request, response) {
-    try {
-        //log the request on console
-        winston.log(request.url);
-        //Dispatch
-        dispatcher.dispatch(request, response);
-    } catch(err) {
-        console.log(err);
-    }
-}
-
-var syncServerChildProcess = null;
-
-// Waits for ROS to be fully initialized.
-function waitForRosToInitialize(attempts, onSuccess, onError, startSequence) {
-    if (attempts == 0) {
-        onError("Could not get ROS to start. See Docker log.");
-        return;
-    }
-    http.get("http://0.0.0.0:9080/health", function(res) {
-        if (res.statusCode != 200) {
-            winston.warn("ROS /health/ returned: " + res.statusCode)
-            setTimeout(function() {
-                waitForRosToInitialize(attempts - 1, onSuccess, onError, startSequence);
-            }, 500);
-        } else {
-            onSuccess(startSequence);
-        }
-    }).on('error', function(err) {
-        winston.warn("ROS /health/ returned an error: " + err)
-        // ROS not accepting any connections yet.
-        // Errors like ECONNREFUSED 0.0.0.0:9080 will be reported here.
-        // Wait a little before trying again (common startup is ~1 second).
-        setTimeout(function() {
-            waitForRosToInitialize(attempts - 1, onSuccess, onError, startSequence);
-        }, 500);
-    });
-}
-
-function startRealmObjectServer(onSuccess, onError) {
-    stopRealmObjectServer(() => {
-        doStartRealmObjectServer(onSuccess, onError)
-    }, onError)
-}
-
-function doStartRealmObjectServer(onSuccess, onError) {
-    temp.mkdir('ros', function(err, path) {
-        if (!err) {
-            winston.info("Starting sync server in ", path);
-            var env = Object.create( process.env );
-            winston.info(env.NODE_ENV);
-            env.NODE_ENV = 'development';
-
-            // Manually cleanup Global Notifier State
-            // See https://github.com/realm/ros/issues/437#issuecomment-335380095
-            var globalNotifierDir = path + '/realm-object-server';
-            winston.info('Cleaning state in: ' + globalNotifierDir);
-            fs.removeSync(globalNotifierDir)
-            if (fs.existsSync(globalNotifierDir)) {
-                onError("Could not delete the global notifier directory: " + globalNotifierDir);
-                return;
-            }
-            fs.mkdirsSync(path + '/realm-object-server/io.realm.object-server-utility/metadata/')
-
-            // Start ROS
-            syncServerChildProcess = spawn('ros',
-                    ['start',
-                        '--data', path,
-                        '--loglevel', 'detail',
-                        '--https',
-                        '--https-key', '/127_0_0_1-server.key.pem',
-                        '--https-cert', '/127_0_0_1-chain.crt.pem',
-                        '--https-port', '9443',
-                        '--access-token-ttl', '20' //WARNING : Changing this value may impact the timeout of the refresh token test (AuthTests#preemptiveTokenRefresh)
-                    ],
-                    { env: env, cwd: path});
-
-            // local config:
-            syncServerChildProcess.stdout.on('data', (data) => {
-                winston.info(`${data}`);
-            });
-
-            syncServerChildProcess.stderr.on('data', (data) => {
-                winston.info(`${data}`);
-            });
-
-            // The interval between every health check is 0.5 second. Give the ROS 30 seconds to get fully initialized.
-            waitForRosToInitialize(60, onSuccess, onError, Date.now());
-        }
-    });
-}
-
-function stopRealmObjectServer(onSuccess, onError) {
-    if(syncServerChildProcess == null || syncServerChildProcess.killed) {
-        onSuccess("No ROS process found or the process has been killed before");
-    }
-    if (syncServerChildProcess) {
-        syncServerChildProcess.on('exit', function(code) {
-            winston.info("ROS server stopped due to process being killed. Exit code: " + code);
-            syncServerChildProcess.removeAllListeners('exit');
-            syncServerChildProcess = null;
-            onSuccess();
-        });
-
-        syncServerChildProcess.kill('SIGKILL');
-    }
-}
-
-// start sync server
-dispatcher.onGet("/start", function(req, res) {
-    winston.info("Attempting to start ROS");
-    startRealmObjectServer((startSequence) => {
-        res.writeHead(200, {'Content-Type': 'text/plain'});
-        let response = `ROS started after ${Date.now() - startSequence} ms`;
-        winston.info(response);
-        res.end(response);
-    }, function (err) {
-        winston.error('Starting ROS failed: ' + err);
-        res.writeHead(500, {'Content-Type': 'text/plain'});
-        res.end('Starting ROS failed: ' + err);
-    });
-});
-
-// stop a previously started sync server
-dispatcher.onGet("/stop", function(req, res) {
-  winston.info("Attempting to stop ROS")
-  stopRealmObjectServer(function() {
-        res.writeHead(200, {'Content-Type': 'text/plain'});
-        res.end('ROS stopped');
-  }, function(err) {
-        res.writeHead(500, {'Content-Type': 'text/plain'});
-        res.end('Stopping ROS failed: ' + err);
-  });
-});
-
-//Create and start the Http server
-var server = http.createServer(handleRequest);
-server.listen(PORT, function() {
-    winston.info("Integration test server listening on: 127.0.0.1:%s", PORT);
-});
diff --git a/tools/sync_test_server/ros/package.json b/tools/sync_test_server/ros/package.json
new file mode 100644
index 0000000000..c1baabf349
--- /dev/null
+++ b/tools/sync_test_server/ros/package.json
@@ -0,0 +1,17 @@
+{
+    "name": "ros-integration-test-server",
+    "version": "1.0.0",
+    "description": "ROS instance used by integration tests",
+    "main": "src/index.js",
+    "scripts": {
+        "build": "rm -rf dist; ./node_modules/.bin/tsc",
+        "clean": "rm -rf dist",
+        "start": "npm run build && node dist/index.js"
+    },
+    "devDependencies": {
+        "typescript": "2.5.3"
+    },
+    "dependencies": {
+        "realm-object-server": "%ROS_VERSION%"
+    }
+}
diff --git a/tools/sync_test_server/ros/src/index.ts b/tools/sync_test_server/ros/src/index.ts
new file mode 100644
index 0000000000..2501cf5cd3
--- /dev/null
+++ b/tools/sync_test_server/ros/src/index.ts
@@ -0,0 +1,99 @@
+import { BasicServer, FileConsoleLogger } from 'realm-object-server'
+import * as path from 'path'
+
+const server = new BasicServer()
+
+server.start({
+        // For all the full list of configuration parameters see:
+        // https://realm.io/docs/realm-object-server/latest/api/ros/interfaces/serverconfig.html
+
+        // This is the location where ROS will store its runtime data
+        dataPath: path.join(__dirname, '../data'),
+
+        // A logger to pipe ROS information. You can also specify the log level.
+        // The log level can be one of: all, trace, debug, detail, info, warn, error, fatal, off.
+        logger: new FileConsoleLogger(path.join(__dirname, '../log.txt'), 'all', {
+            file: {
+                timestamp: true,
+                level: 'detail'
+            },
+            console: {
+                level: 'info'
+            }
+        }),
+
+        // The address on which to listen for connections
+        // address?: string = '0.0.0.0'
+        // address: '0.0.0.0',
+
+        // The port on which to listen for connections
+        // port?: number = 9080
+        // port: 9080,
+
+        // Override the default list of authentication providers
+        // the default has PasswordAuthProvider, AnonymousAuthProvider, and NicknameAuthProvider
+        // you will need to add `import { auth, BasicServer } from 'realm-object-server'
+        // authProviders?: IAuthProvider[]
+        // authProviders: [new auth.PasswordAuthProvider({ autoCreateAdminUser: true }), new auth.NicknameAuthProvider(), new auth.AnonymousAuthProvider()]
+
+        // Autogenerate public and private keys on startup
+        // autoKeyGen?: boolean = true
+        autoKeyGen: false,
+
+        // Specify an alternative path to the private key. Otherwise, it is expected to be under the data path.
+        // privateKeyPath?: string
+        privateKeyPath: '/private.pem',
+
+        // Specify an alternative path to the public key. Otherwise, it is expected to be under the data path.
+        // publicKeyPath?: string
+        publicKeyPath: '/public.pem',
+
+        // The desired logging threshold. Can be one of: all, trace, debug, detail, info, warn, error, fatal, off)
+        // logLevel?: string = 'info'
+        logLevel: 'detail',
+
+        // Enable the HTTPS Server.
+        // https?: boolean = false
+        https: true,
+
+        // The port on which to listen for HTTPS connections.
+        // httpsAddress?: string = '0.0.0.0',
+        // httpsAddress: '0.0.0.0',
+
+        // The address on which to listen for HTTPS connections.
+        // httpsPort?: number = 9443
+        httpsPort: 9443,
+
+        // The path to your HTTPS private key in PEM format. Required if HTTPS is enabled.
+        // httpsKeyPath?: string
+        httpsKeyPath: '/127_0_0_1-server.key.pem',
+
+        // The path to your HTTPS certificate chain in PEM format. Required if HTTPS is enabled.
+        // httpsCertChainPath?: string
+        httpsCertChainPath: '/127_0_0_1-chain.crt.pem',
+
+        // Specify the length of time (in seconds) in which access tokens are valid.
+        // accessTokenTtl?: number = 600 (ten minutes)
+        accessTokenTtl: 20,
+
+        // Specify the length of time (in seconds) in which refresh tokens are valid.
+        // refreshTokenTtl?: number = 3153600000 (ten years)
+        // refreshTokenTtl: 3153600000,
+
+        // Enable Log Compaction to save on bandwidth
+        // read more at https://docs.realm.io/platform/learn/advanced/log-compaction
+        // enableLogCompaction?: boolean = true
+        // enableLogCompaction: true
+
+        // Increase or decrease the max download
+        // This affects how the Log Compaction works
+        // read more at https://docs.realm.io/platform/learn/advanced/log-compaction
+        // maxDownloadSize?: number 16000000 (16 megabytes)
+        // maxDownloadSize: 16000000
+    })
+    .then(() => {
+        console.log(`Realm Object Server was started on ${server.address}`)
+    })
+    .catch(err => {
+        console.error(`Error starting Realm Object Server: ${err.message}`)
+    })
diff --git a/tools/sync_test_server/ros/tsconfig.json b/tools/sync_test_server/ros/tsconfig.json
new file mode 100644
index 0000000000..8a5ed49104
--- /dev/null
+++ b/tools/sync_test_server/ros/tsconfig.json
@@ -0,0 +1,32 @@
+{
+    "compilerOptions": {
+      "target": "es6",
+      "module": "commonjs",
+      "moduleResolution": "node",
+      "noImplicitAny": false,
+      "removeComments": true,
+      "preserveConstEnums": true,
+      "sourceMap": true,
+      "outDir": "dist",
+      "sourceRoot": "src",
+      "declaration": true,
+      "emitDecoratorMetadata": true,
+      "experimentalDecorators": true,
+      "lib": [
+        "dom",
+        "es6",
+        "dom.iterable",
+        "scripthost",
+        "esnext",
+        "esnext.asynciterable"
+      ]
+    },
+    "include": [
+      "src/**/*.ts"
+    ],
+    "exclude": [
+      "node_modules",
+      "dist"
+    ]
+  }
+  
\ No newline at end of file
diff --git a/tools/sync_test_server/start_server.sh b/tools/sync_test_server/start_server.sh
index 37828b38d7..d8ff9a0e16 100755
--- a/tools/sync_test_server/start_server.sh
+++ b/tools/sync_test_server/start_server.sh
@@ -3,7 +3,7 @@
 # Get the script dir which contains the Dockerfile
 DOCKERFILE_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
 
-ROS_DE_VERSION=$(grep REALM_OBJECT_SERVER_DE_VERSION $DOCKERFILE_DIR/../../dependencies.list | cut -d'=' -f2)
+ROS_VERSION=$(grep REALM_OBJECT_SERVER_VERSION $DOCKERFILE_DIR/../../dependencies.list | cut -d'=' -f2)
 
 TMP_DIR=$(mktemp -d /tmp/sync-test.XXXX) || { echo "Failed to mktemp $TEST_TEMP_DIR" ; exit 1 ; }
 
@@ -11,7 +11,7 @@ adb reverse tcp:9443 tcp:9443 && \
 adb reverse tcp:9080 tcp:9080 && \
 adb reverse tcp:8888 tcp:8888 || { echo "Failed to reverse adb port." ; exit 1 ; }
 
-docker build $DOCKERFILE_DIR --build-arg ROS_DE_VERSION=$ROS_DE_VERSION -t sync-test-server || { echo "Failed to build Docker image." ; exit 1 ; }
+docker build $DOCKERFILE_DIR --build-arg ROS_VERSION=$ROS_VERSION -t sync-test-server || { echo "Failed to build Docker image." ; exit 1 ; }
 
 echo "See log files in $TMP_DIR"
 docker run -p 9080:9080 -p 9443:9443 -p 8888:8888 -v$TMP_DIR:/tmp --name sync-test-server sync-test-server
diff --git a/version.txt b/version.txt
index b0fc294f07..6555596f93 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-5.1.0-SNAPSHOT
+5.2.0-SNAPSHOT
\ No newline at end of file
