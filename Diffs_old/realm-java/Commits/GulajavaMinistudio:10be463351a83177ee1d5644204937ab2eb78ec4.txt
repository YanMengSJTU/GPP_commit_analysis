diff --git a/CHANGELOG.md b/CHANGELOG.md
index ed8f924c24..a137f3e15e 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,12 +1,27 @@
-## 3.3.0
+## 3.4.0 (YYYY-MM-DD)
+
+### Breaking Changes
+
+### Enhancements
+
+### Bug Fixes
+
+### Internal
+
+
+## 3.3.0 (2017-05-24)
 
 ### Enhancements
 
 * [ObjectServer] Added two options to `SyncConfiguration` to provide a trusted root CA `trustedRootCA` and to disable SSL validation `disableSSLVerification` (#4371).
+* [ObjectServer] Added support for changing passwords through `SyncUser.changePassword()` using an admin user (#4588).
 
-## 3.2.1 (2017-05-19)
+### Bug Fixes
 
-### Deprecated
+* Queries on proguarded Realm model classes, failed with "Table not found" (#4673).
+
+
+## 3.2.1 (2017-05-19)
 
 ### Enhancements
 
diff --git a/dependencies.list b/dependencies.list
index f78a30cfc7..f2613db9bf 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -10,4 +10,4 @@ REALM_SYNC_SHA256=71e70f83b1604672bbfd7c04fcf984ecc8ac683864943ef3de262994c2e7b7
 # /tools/sync_test_server/Dockerfile specify which repo (apt) we should
 # install/use between 'realm' and 'realm-testing', the version below should
 # correspond to an existing version on the *specified* repo.
-REALM_OBJECT_SERVER_DE_VERSION=1.4.0-302
+REALM_OBJECT_SERVER_DE_VERSION=1.6.0-35
diff --git a/examples/moduleExample/app/build.gradle b/examples/moduleExample/app/build.gradle
index c8e16e60d3..cc80f29f72 100644
--- a/examples/moduleExample/app/build.gradle
+++ b/examples/moduleExample/app/build.gradle
@@ -25,7 +25,7 @@ android {
 
     buildTypes {
         release {
-            minifyEnabled false // FIXME Why is this suddenly broken?
+            minifyEnabled true
             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
             signingConfig signingConfigs.release
         }
diff --git a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
index 1d2cb4a177..780029cf8b 100644
--- a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
+++ b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
@@ -128,7 +128,7 @@ public void execute(Realm realm) {
             }
         });
 
-        showStatus("Number of pigs on the farm : " + farmRealm.where(Pig.class).count());
+        showStatus("Number of unnamed pigs on the farm : " + farmRealm.where(Pig.class).isNull("name").count());
 
         // Each Realm is restricted to only accept the classes in their schema.
         showStatus("Trying to add an unsupported class");
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java b/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java
index 82f9726ad9..1259fbbae9 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java
@@ -32,6 +32,7 @@
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.util.Pair;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static junit.framework.Assert.assertEquals;
@@ -70,11 +71,13 @@ private ColumnIndices create(long schemaVersion) {
         final DogRealmProxy.DogColumnInfo dogColumnInfo;
         catColumnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
         dogColumnInfo = (DogRealmProxy.DogColumnInfo) mediator.validateTable(Dog.class, realm.sharedRealm, false);
-
+        Pair<Class<? extends RealmModel>, String> catDesc = Pair.<Class<? extends RealmModel>, String>create(Cat.class, "Cat");
+        Pair<Class<? extends RealmModel>, String> dogDesc = Pair.<Class<? extends RealmModel>, String>create(Dog.class, "Dog");
         return new ColumnIndices(schemaVersion,
-                ImmutableMap.<Class<? extends RealmModel>, ColumnInfo>of(
-                        Cat.class, catColumnInfo,
-                        Dog.class, dogColumnInfo));
+                ImmutableMap.of(
+                        catDesc, catColumnInfo,
+                        dogDesc, dogColumnInfo)
+        );
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
index 57fd54362b..beb63f1cef 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
@@ -23,6 +23,7 @@
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
 import java.util.Arrays;
@@ -46,6 +47,8 @@
 
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
 
     private DynamicRealm realm;
     private RealmSchema realmSchema;
@@ -100,6 +103,13 @@ public void create_invalidNameThrows() {
         }
     }
 
+    @Test
+    public void create_duplicatedNameThrows() {
+        realmSchema.create("Foo");
+        thrown.expect(IllegalArgumentException.class);
+        realmSchema.create("Foo");
+    }
+
     @Test
     public void get() {
         RealmObjectSchema objectSchema = realmSchema.get(AllJavaTypes.CLASS_NAME);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
index 8a9a492201..99e06fed58 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
@@ -79,7 +79,7 @@ private SharedRealm getSharedRealm() {
 
     private void populateData() {
         sharedRealm.beginTransaction();
-        table = sharedRealm.getTable("test_table");
+        table = sharedRealm.createTable("test_table");
         // Specify the column types and names
         long columnIdx = table.addColumn(RealmFieldType.STRING, "firstName");
         table.addSearchIndex(columnIdx);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java
deleted file mode 100644
index 95499e8a4a..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import io.realm.RealmConfiguration;
-import io.realm.RealmFieldType;
-import io.realm.rule.TestRealmConfigurationFactory;
-
-import static junit.framework.Assert.assertEquals;
-
-@RunWith(AndroidJUnit4.class)
-public class JNILinkTest {
-    @Rule
-    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
-
-    private SharedRealm sharedRealm;
-
-    @Before
-    public void setUp() {
-        RealmConfiguration config = configFactory.createConfiguration();
-        sharedRealm = SharedRealm.getInstance(config);
-        sharedRealm.beginTransaction();
-    }
-
-    @After
-    public void tearDown() {
-        sharedRealm.cancelTransaction();
-        sharedRealm.close();
-    }
-
-    @Test
-    public void testLinkColumns() {
-        Table table1 = sharedRealm.getTable("table1");
-
-        Table table2 = sharedRealm.getTable("table2");
-        table2.addColumn(RealmFieldType.INTEGER, "int");
-        table2.addColumn(RealmFieldType.STRING, "string");
-
-        table2.add(1, "c");
-        table2.add(2, "b");
-        table2.add(3, "a");
-
-        table1.addColumnLink(RealmFieldType.OBJECT, "Link", table2);
-
-        table1.addEmptyRow();
-        table1.setLink(0, 0, 1, false);
-
-        Table target = table1.getLinkTarget(0);
-
-        System.gc();
-
-        assertEquals(target.getColumnCount(), 2);
-
-        String test = target.getString(1, table1.getLink(0, 0));
-
-        assertEquals(test, "b");
-
-    }
-
-    @Test
-    public void testLinkList() {
-        Table table1 = sharedRealm.getTable("table1");
-        table1.addColumn(RealmFieldType.INTEGER, "int");
-        table1.addColumn(RealmFieldType.STRING, "string");
-        table1.add(1, "c");
-        table1.add(2, "b");
-        table1.add(3, "a");
-
-        Table table2 = sharedRealm.getTable("table2");
-
-        table2.addColumnLink(RealmFieldType.LIST, "LinkList", table1);
-
-        table2.addEmptyRow();
-
-        LinkView links = table2.getUncheckedRow(0).getLinkList(0);
-
-        assertEquals(links.isEmpty(), true);
-        assertEquals(links.size(), 0);
-
-        links.add(2);
-        links.add(1);
-
-        assertEquals(links.isEmpty(), false);
-        assertEquals(links.size(), 2);
-
-        assertEquals(links.getUncheckedRow(0).getColumnName(1), "string");
-
-        assertEquals(links.getUncheckedRow(0).getString(1), "a");
-
-        links.move(1, 0);
-
-        assertEquals(links.getUncheckedRow(0).getString(1), "b");
-
-        links.remove(0);
-
-        assertEquals(links.getUncheckedRow(0).getString(1), "a");
-        assertEquals(links.size(), 1);
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
index 46411ee027..296f22c764 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -312,7 +312,7 @@ public void getName() {
 
             // Writes transaction must be run so we are sure a db exists with the correct table.
             sharedRealm.beginTransaction();
-            sharedRealm.getTable(TABLE_NAME);
+            sharedRealm.createTable(TABLE_NAME);
             sharedRealm.commitTransaction();
 
             Table table = sharedRealm.getTable(TABLE_NAME);
@@ -600,7 +600,7 @@ public void defaultValue_setAndGet() {
         //noinspection TryFinallyCanBeTryWithResources
         try {
             sharedRealm.beginTransaction();
-            final Table table = sharedRealm.getTable(Table.getTableNameForClass("DefaultValueTest"));
+            final Table table = sharedRealm.createTable(Table.getTableNameForClass("DefaultValueTest"));
             sharedRealm.commitTransaction();
 
             List<Pair<RealmFieldType, Object>> columnInfoList = Arrays.asList(
@@ -723,7 +723,7 @@ public void defaultValue_setMultipleTimes() {
         //noinspection TryFinallyCanBeTryWithResources
         try {
             sharedRealm.beginTransaction();
-            final Table table = sharedRealm.getTable(Table.getTableNameForClass("DefaultValueTest"));
+            final Table table = sharedRealm.createTable(Table.getTableNameForClass("DefaultValueTest"));
             sharedRealm.commitTransaction();
 
             List<Pair<RealmFieldType, Object>> columnInfoList = Arrays.asList(
@@ -855,7 +855,7 @@ public void defaultValue_overwrittenByNonDefault() {
         //noinspection TryFinallyCanBeTryWithResources
         try {
             sharedRealm.beginTransaction();
-            final Table table = sharedRealm.getTable(Table.getTableNameForClass("DefaultValueTest"));
+            final Table table = sharedRealm.createTable(Table.getTableNameForClass("DefaultValueTest"));
             sharedRealm.commitTransaction();
 
             List<Pair<RealmFieldType, Object>> columnInfoList = Arrays.asList(
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
index e13b17bfca..e9b8e4bd87 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
@@ -66,7 +66,7 @@ public void tearDown() {
     private Table getTableWithStringPrimaryKey() {
         sharedRealm = SharedRealm.getInstance(config);
         sharedRealm.beginTransaction();
-        Table t = sharedRealm.getTable("TestTable");
+        Table t = sharedRealm.createTable("TestTable");
         long column = t.addColumn(RealmFieldType.STRING, "colName", true);
         t.addSearchIndex(column);
         t.setPrimaryKey("colName");
@@ -76,7 +76,7 @@ private Table getTableWithStringPrimaryKey() {
     private Table getTableWithIntegerPrimaryKey() {
         sharedRealm = SharedRealm.getInstance(config);
         sharedRealm.beginTransaction();
-        Table t = sharedRealm.getTable("TestTable");
+        Table t = sharedRealm.createTable("TestTable");
         long column = t.addColumn(RealmFieldType.INTEGER, "colName");
         t.addSearchIndex(column);
         t.setPrimaryKey("colName");
@@ -91,7 +91,7 @@ public void removingPrimaryKeyRemovesConstraint_typeSetters() {
         SharedRealm sharedRealm = SharedRealm.getInstance(config);
 
         sharedRealm.beginTransaction();
-        Table tbl = sharedRealm.getTable("EmployeeTable");
+        Table tbl = sharedRealm.createTable("EmployeeTable");
         tbl.addColumn(RealmFieldType.STRING, "name");
         tbl.setPrimaryKey("name");
 
@@ -221,7 +221,7 @@ public void migratePrimaryKeyTableIfNeeded_primaryKeyTableMigratedWithRightName(
     public void migratePrimaryKeyTableIfNeeded_primaryKeyTableNeedSearchIndex() {
         sharedRealm = SharedRealm.getInstance(config);
         sharedRealm.beginTransaction();
-        Table table = sharedRealm.getTable("TestTable");
+        Table table = sharedRealm.createTable("TestTable");
         long column = table.addColumn(RealmFieldType.INTEGER, "PKColumn");
         table.addSearchIndex(column);
         table.setPrimaryKey(column);
@@ -236,7 +236,7 @@ public void migratePrimaryKeyTableIfNeeded_primaryKeyTableNeedSearchIndex() {
         pkTable.removeSearchIndex(classColumn);
 
         // Tries to add a pk for another table.
-        Table table2 = sharedRealm.getTable("TestTable2");
+        Table table2 = sharedRealm.createTable("TestTable2");
         long column2 = table2.addColumn(RealmFieldType.INTEGER, "PKColumn");
         table2.addSearchIndex(column2);
         try {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
index c735e2dcf1..67a35b5b00 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
@@ -71,26 +71,26 @@ public void getVersionID() {
     public void hasTable() {
         assertFalse(sharedRealm.hasTable("MyTable"));
         sharedRealm.beginTransaction();
-        sharedRealm.getTable("MyTable");
+        sharedRealm.createTable("MyTable");
         sharedRealm.commitTransaction();
         assertTrue(sharedRealm.hasTable("MyTable"));
     }
 
-    @Test(expected = IllegalStateException.class)
-    public void getTable_createNotInTransactionThrows() {
-        sharedRealm.getTable("NON-EXISTING");
-    }
-
     @Test
     public void getTable() {
         assertFalse(sharedRealm.hasTable("MyTable"));
         sharedRealm.beginTransaction();
-        sharedRealm.getTable("MyTable");
+        sharedRealm.createTable("MyTable");
         sharedRealm.commitTransaction();
         assertTrue(sharedRealm.hasTable("MyTable"));
 
         // Table is existing, no need transaction to create it
-        sharedRealm.getTable("MyTable");
+        assertTrue(sharedRealm.getTable("MyTable").isValid());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void getTable_throwsIfTableNotExist() {
+        sharedRealm.getTable("NON_EXISTING");
     }
 
     @Test
@@ -112,7 +112,7 @@ public void isInTransaction_returnFalseWhenRealmClosed() {
     @Test
     public void removeTable() {
         sharedRealm.beginTransaction();
-        sharedRealm.getTable("TableToRemove");
+        sharedRealm.createTable("TableToRemove");
         assertTrue(sharedRealm.hasTable("TableToRemove"));
         sharedRealm.removeTable("TableToRemove");
         assertFalse(sharedRealm.hasTable("TableToRemove"));
@@ -122,7 +122,7 @@ public void removeTable() {
     @Test
     public void removeTable_notInTransactionThrows() {
         sharedRealm.beginTransaction();
-        sharedRealm.getTable("TableToRemove");
+        sharedRealm.createTable("TableToRemove");
         sharedRealm.commitTransaction();
         thrown.expect(IllegalStateException.class);
         sharedRealm.removeTable("TableToRemove");
@@ -140,7 +140,7 @@ public void removeTable_tableNotExist() {
     @Test
     public void renameTable() {
         sharedRealm.beginTransaction();
-        sharedRealm.getTable("OldTable");
+        sharedRealm.createTable("OldTable");
         assertTrue(sharedRealm.hasTable("OldTable"));
         sharedRealm.renameTable("OldTable", "NewTable");
         assertFalse(sharedRealm.hasTable("OldTable"));
@@ -151,7 +151,7 @@ public void renameTable() {
     @Test
     public void renameTable_notInTransactionThrows() {
         sharedRealm.beginTransaction();
-        sharedRealm.getTable("OldTable");
+        sharedRealm.createTable("OldTable");
         sharedRealm.commitTransaction();
         thrown.expect(IllegalStateException.class);
         sharedRealm.renameTable("OldTable", "NewTable");
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
index 61f67b779e..55bac40c4e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
@@ -55,7 +55,7 @@ public void setUp() {
         RealmConfiguration config = configFactory.createConfiguration();
         sharedRealm = SharedRealm.getInstance(config);
         sharedRealm.beginTransaction();
-        table = sharedRealm.getTable("test_table");
+        table = sharedRealm.createTable("test_table");
     }
 
     @After
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
index 754c7f172b..237618dd48 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -286,6 +286,14 @@ public void changePassword_nullThrows() {
         user.changePassword(null);
     }
 
+    @Test
+    public void changePassword_admin_nullThrows() {
+        SyncUser user = createTestUser();
+
+        thrown.expect(IllegalArgumentException.class);
+        user.changePassword(null, "new-password");
+    }
+
     @Test
     public void changePasswordAsync_nonLooperThreadThrows() {
         SyncUser user = createTestUser();
@@ -304,6 +312,24 @@ public void onError(ObjectServerError error) {
         });
     }
 
+    @Test
+    public void changePassword_admin_Async_nonLooperThreadThrows() {
+        SyncUser user = createTestUser();
+
+        thrown.expect(IllegalStateException.class);
+        user.changePasswordAsync("user-id", "new", new SyncUser.Callback() {
+            @Override
+            public void onSuccess(SyncUser user) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail();
+            }
+        });
+    }
+
     @Test
     @RunTestInLooperThread
     public void changePasswordAsync_nullCallbackThrows() {
@@ -312,4 +338,22 @@ public void changePasswordAsync_nullCallbackThrows() {
         thrown.expect(IllegalArgumentException.class);
         user.changePasswordAsync("new-password", null);
     }
+
+    @Test
+    @RunTestInLooperThread
+    public void changePassword_admin_Async_nullCallbackThrows() {
+        SyncUser user = createTestUser();
+
+        thrown.expect(IllegalArgumentException.class);
+        user.changePasswordAsync("user-id", "new-password", null);
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changePassword_noneAdminThrows() {
+        SyncUser user = createTestUser();
+
+        thrown.expect(IllegalStateException.class);
+        user.changePassword("user-id", "new-password");
+    }
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
index 9cd68e3eb6..4738a264d2 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -26,9 +26,12 @@
 #include "object_store.hpp"
 #include "java_binding_context.hpp"
 #include "util.hpp"
+#include "java_exception_def.hpp"
 
 #include "jni_util/java_method.hpp"
 #include "jni_util/java_class.hpp"
+#include "jni_util/java_exception_thrower.hpp"
+
 
 using namespace realm;
 using namespace realm::_impl;
@@ -410,18 +413,41 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetTable(JNIEnv
     try {
         JStringAccessor name(env, table_name); // throws
         auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-        if (!shared_realm->read_group().has_table(name) && !shared_realm->is_in_transaction()) {
-            std::ostringstream ss;
-            ss << "Class " << name << " doesn't exist and the shared Realm is not in transaction.";
-            ThrowException(env, IllegalState, ss.str());
-            return static_cast<jlong>(NULL);
+        if (!shared_realm->read_group().has_table(name)) {
+            std::string name_str = name;
+            THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalArgument,
+                                 format("The class '%1' doesn't exist in this Realm.", name_str));
         }
-        Table* pTable = LangBindHelper::get_or_add_table(shared_realm->read_group(), name);
-        return reinterpret_cast<jlong>(pTable);
+        Table* table = LangBindHelper::get_table(shared_realm->read_group(), name);
+        return reinterpret_cast<jlong>(table);
     }
     CATCH_STD()
 
-    return static_cast<jlong>(NULL);
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeCreateTable(JNIEnv* env, jclass,
+                                                                             jlong shared_realm_ptr,
+                                                                             jstring table_name)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    std::string name_str;
+    try {
+        JStringAccessor name(env, table_name); // throws
+        name_str = name;
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        shared_realm->verify_in_write(); // throws
+        Table* table = LangBindHelper::add_table(shared_realm->read_group(), name); // throws
+        return reinterpret_cast<jlong>(table);
+    }
+    catch (TableNameInUse& e) {
+        // We need to print the table name, so catch the exception here.
+        ThrowException(env, IllegalArgument, format("Class already exists: '%1'.", name_str));
+    }
+    CATCH_STD()
+
+    return reinterpret_cast<jlong>(nullptr);
 }
 
 JNIEXPORT jstring JNICALL Java_io_realm_internal_SharedRealm_nativeGetTableName(JNIEnv* env, jclass,
diff --git a/realm/realm-library/src/main/cpp/java_exception_def.cpp b/realm/realm-library/src/main/cpp/java_exception_def.cpp
new file mode 100644
index 0000000000..81246e4483
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/java_exception_def.cpp
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "java_exception_def.hpp"
+
+using namespace realm::_impl;
+
+const char* JavaExceptionDef::IllegalState = "java/lang/IllegalStateException";
+const char* JavaExceptionDef::IllegalArgument = "java/lang/IllegalArgumentException";
diff --git a/realm/realm-library/src/main/cpp/java_exception_def.hpp b/realm/realm-library/src/main/cpp/java_exception_def.hpp
new file mode 100644
index 0000000000..9842d185f4
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/java_exception_def.hpp
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_IMPL_EXCEPTION_DEF_HPP
+#define REALM_JNI_IMPL_EXCEPTION_DEF_HPP
+
+namespace realm {
+namespace _impl {
+
+// Definitions of Java exceptions which are used in JNI.
+class JavaExceptionDef {
+public:
+    // Class names
+    static const char* IllegalState;
+    static const char* IllegalArgument;
+};
+
+} // namespace realm
+} // namespace jni_impl
+
+#endif
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 24291c5741..6558851abb 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -60,6 +60,7 @@
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.async.RealmAsyncTaskImpl;
+import io.realm.internal.util.Pair;
 import io.realm.log.RealmLog;
 import rx.Observable;
 
@@ -441,9 +442,11 @@ private static void initializeRealm(Realm realm) {
             }
 
             // Now that they have all been created, validate them.
-            final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
+            final Map<Pair<Class<? extends RealmModel>, String>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
             for (Class<? extends RealmModel> modelClass : modelClasses) {
-                columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
+                String className = Table.getClassNameForTable(mediator.getTableName(modelClass));
+                Pair<Class<? extends RealmModel>, String> key = Pair.<Class<? extends RealmModel>, String>create(modelClass, className);
+                columnInfoMap.put(key, mediator.validateTable(modelClass, realm.sharedRealm, false));
             }
 
             realm.getSchema().setInitialColumnIndices(
@@ -507,9 +510,11 @@ private static void initializeSyncedRealm(Realm realm) {
             }
 
             // Validate the schema in the file
-            final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
+            final Map<Pair<Class<? extends RealmModel>, String>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
             for (Class<? extends RealmModel> modelClass : modelClasses) {
-                columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
+                String className = Table.getClassNameForTable(mediator.getTableName(modelClass));
+                Pair<Class<? extends RealmModel>, String> key = Pair.<Class<? extends RealmModel>, String>create(modelClass, className);
+                columnInfoMap.put(key, mediator.validateTable(modelClass, realm.sharedRealm, false));
             }
             realm.getSchema().setInitialColumnIndices((unversioned) ? newVersion : currentVersion, columnInfoMap);
 
@@ -1773,7 +1778,7 @@ ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
 
             // Not found in global cache. create it.
             final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
-            final Map<Class<? extends RealmModel>, ColumnInfo> map;
+            final Map<Pair<Class<? extends RealmModel>, String>, ColumnInfo> map;
             map = new HashMap<>(modelClasses.size());
 
 
@@ -1782,7 +1787,9 @@ ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
             try {
                 for (Class<? extends RealmModel> clazz : modelClasses) {
                     final ColumnInfo columnInfo = mediator.validateTable(clazz, sharedRealm, true);
-                    map.put(clazz, columnInfo);
+                    String className = Table.getClassNameForTable(mediator.getTableName(clazz));
+                    Pair<Class<? extends RealmModel>, String> key = Pair.<Class<? extends RealmModel>, String>create(clazz, className);
+                    map.put(key, columnInfo);
                 }
             } catch (RealmMigrationNeededException e) {
                 throw e;
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index f23f9a2f4c..cc7a15bbdb 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -22,6 +22,7 @@
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.Table;
+import io.realm.internal.util.Pair;
 
 
 /**
@@ -114,7 +115,7 @@ final void setInitialColumnIndices(ColumnIndices columnIndices) {
      * @param version the schema version
      * @param columnInfoMap the column info map
      */
-    final void setInitialColumnIndices(long version, Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap) {
+    final void setInitialColumnIndices(long version, Map<Pair<Class<? extends RealmModel>, String>, ColumnInfo> columnInfoMap) {
         if (this.columnIndices != null) {
             throw new IllegalStateException("An instance of ColumnIndices is already set.");
         }
diff --git a/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java b/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
index 63bee2608c..e0bbcb7a75 100644
--- a/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
@@ -107,10 +107,7 @@ public RealmObjectSchema create(String className) {
         if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
             throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: " + className.length());
         }
-        if (realm.getSharedRealm().hasTable(internalTableName)) {
-            throw new IllegalArgumentException("Class already exists: " + className);
-        }
-        return new StandardRealmObjectSchema(realm, this, realm.getSharedRealm().getTable(internalTableName));
+        return new StandardRealmObjectSchema(realm, this, realm.getSharedRealm().createTable(internalTableName));
     }
 
     /**
@@ -200,9 +197,6 @@ Table getTable(String className) {
         Table table = dynamicClassToTable.get(tableName);
         if (table != null) { return table; }
 
-        if (!realm.getSharedRealm().hasTable(tableName)) {
-            throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
-        }
         table = realm.getSharedRealm().getTable(tableName);
         dynamicClassToTable.put(tableName, table);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
index 78bbdb0f18..fffc7a65e8 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
@@ -20,6 +20,7 @@
 import java.util.Map;
 
 import io.realm.RealmModel;
+import io.realm.internal.util.Pair;
 
 
 /**
@@ -30,7 +31,7 @@
  * <li>the {@code copyFrom} method</li>
  * <li>mutating one of the ColumnInfo object to which this instance holds a reference</li>
  * </ul>
- * Immutable instances of this class protect against the first possiblity by throwing on calls
+ * Immutable instances of this class protect against the first possibility by throwing on calls
  * to {@code copyFrom}.  {@see ColumnInfo} for its mutability contract.
  *
  * There are two, redundant, lookup methods, for schema members: by Class and by String.
@@ -39,8 +40,12 @@
  * class lookup is very fast and on a hot path, so we maintain the redundant table.
  */
 public final class ColumnIndices {
+    // MultiKeyMap of <Class, String> -> ColumnInfo
+    // Right now we maintain 3 copies. One public and 2 internal ones.
+    private final Map<Pair<Class<? extends RealmModel>, String>, ColumnInfo> classesToColumnInfo;
     private final Map<Class<? extends RealmModel>, ColumnInfo> classes;
     private final Map<String, ColumnInfo> classesByName;
+
     private final boolean mutable;
     private long schemaVersion;
 
@@ -48,40 +53,45 @@
      * Create a mutable ColumnIndices initialized with the ColumnInfo objects in the passed map.
      *
      * @param schemaVersion the schema version
-     * @param classes a map of table classes to their column info
+     * @param classesMap a map of table classes to their column info
      * @throws IllegalArgumentException if any of the ColumnInfo object is immutable.
      */
-    public ColumnIndices(long schemaVersion, Map<Class<? extends RealmModel>, ColumnInfo> classes) {
-        this(schemaVersion, new HashMap<>(classes), true);
-        for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : classes.entrySet()) {
+    public ColumnIndices(long schemaVersion, Map<Pair<Class<? extends RealmModel>, String>, ColumnInfo> classesMap) {
+        this(schemaVersion, new HashMap<>(classesMap), true);
+        for (Map.Entry<Pair<Class<? extends RealmModel>, String>, ColumnInfo> entry : classesMap.entrySet()) {
             ColumnInfo columnInfo = entry.getValue();
             if (mutable != columnInfo.isMutable()) {
                 throw new IllegalArgumentException("ColumnInfo mutability does not match ColumnIndices");
             }
-            this.classesByName.put(entry.getKey().getSimpleName(), entry.getValue());
+            Pair<Class<? extends RealmModel>, String> classDescription = entry.getKey();
+            this.classes.put(classDescription.first, columnInfo);
+            this.classesByName.put(classDescription.second, columnInfo);
         }
     }
 
     /**
-     * Create a copy of the passed ColumnIndices with the specified mutablity.
+     * Create a copy of the passed ColumnIndices with the specified mutability.
      *
      * @param other the ColumnIndices object to copy
      * @param mutable if false the object is effectively final.
      */
     public ColumnIndices(ColumnIndices other, boolean mutable) {
-        this(other.schemaVersion, new HashMap<Class<? extends RealmModel>, ColumnInfo>(other.classes.size()), mutable);
-        for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : other.classes.entrySet()) {
+        this(other.schemaVersion, new HashMap<Pair<Class<? extends RealmModel>, String>, ColumnInfo>(other.classesToColumnInfo.size()), mutable);
+        for (Map.Entry<Pair<Class<? extends RealmModel>, String>, ColumnInfo> entry : other.classesToColumnInfo.entrySet()) {
             ColumnInfo columnInfo = entry.getValue().copy(mutable);
-            this.classes.put(entry.getKey(), columnInfo);
-            this.classesByName.put(entry.getKey().getSimpleName(), columnInfo);
+            Pair<Class<? extends RealmModel>, String> key = entry.getKey();
+            this.classes.put(key.first, columnInfo);
+            this.classesByName.put(key.second, columnInfo);
+            this.classesToColumnInfo.put(key, columnInfo);
         }
     }
 
-    private ColumnIndices(long schemaVersion, Map<Class<? extends RealmModel>, ColumnInfo> classes, boolean mutable) {
+    private ColumnIndices(long schemaVersion, Map<Pair<Class<? extends RealmModel>, String>, ColumnInfo> classesMap, boolean mutable) {
         this.schemaVersion = schemaVersion;
-        this.classes = classes;
+        this.classesToColumnInfo = classesMap;
         this.mutable = mutable;
-        this.classesByName = new HashMap<>(classes.size());
+        this.classes = new HashMap<>(classesMap.size());
+        this.classesByName = new HashMap<>(classesMap.size());
     }
 
     /**
@@ -164,9 +174,9 @@ public String toString() {
         buf.append(mutable).append(",");
         if (classes != null) {
             boolean commaNeeded = false;
-            for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : classes.entrySet()) {
+            for (Map.Entry<String, ColumnInfo> entry : classesByName.entrySet()) {
                 if (commaNeeded) { buf.append(","); }
-                buf.append(entry.getKey().getSimpleName()).append("->").append(entry.getValue());
+                buf.append(entry.getKey()).append("->").append(entry.getValue());
                 commaNeeded = true;
             }
         }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 303d20dc9f..821d489b3d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -292,8 +292,27 @@ public boolean hasTable(String name) {
         return nativeHasTable(nativePtr, name);
     }
 
+    /**
+     * Gets an existing {@link Table} with the given name.
+     *
+     * @param name the name of table.
+     * @return a {@link Table} object.
+     * @throws IllegalArgumentException if the table doesn't exist.
+     */
     public Table getTable(String name) {
-        return new Table(this, nativeGetTable(nativePtr, name));
+        long tablePtr = nativeGetTable(nativePtr, name);
+        return new Table(this, tablePtr);
+    }
+
+    /**
+     * Creates a {@link Table} with then given name. Native assertion will happen if the table with the same name
+     * exists.
+     *
+     * @param name the name of table.
+     * @return a created {@link Table} object.
+     */
+    public Table createTable(String name) {
+        return new Table(this, nativeCreateTable(nativePtr, name));
     }
 
     public void renameTable(String oldName, String newName) {
@@ -533,8 +552,12 @@ private static native long nativeCreateConfig(String realmPath, byte[] key, byte
 
     private static native long[] nativeGetVersionID(long nativeSharedRealmPtr);
 
+    // Throw IAE if the table doesn't exist.
     private static native long nativeGetTable(long nativeSharedRealmPtr, String tableName);
 
+    // Throw IAE if the table exists already.
+    private static native long nativeCreateTable(long nativeSharedRealmPtr, String tableName);
+
     private static native String nativeGetTableName(long nativeSharedRealmPtr, int index);
 
     private static native boolean nativeHasTable(long nativeSharedRealmPtr, String tableName);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index 97b937a99e..da1feceb15 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -753,6 +753,12 @@ private Table getPrimaryKeyTable() {
         if (sharedRealm == null) {
             return null;
         }
+
+        // FIXME: The PK table creation should be handle by Object Store after integration of OS Schema.
+        if (!sharedRealm.hasTable(PRIMARY_KEY_TABLE_NAME)) {
+            sharedRealm.createTable(PRIMARY_KEY_TABLE_NAME);
+        }
+
         Table pkTable = sharedRealm.getTable(PRIMARY_KEY_TABLE_NAME);
         if (pkTable.getColumnCount() == 0) {
             checkImmutable();
diff --git a/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java b/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java
new file mode 100644
index 0000000000..6990faf5ae
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.util;
+
+/**
+ * Copy from the Android framework to avoid the dependency on Android classes + slight adjustment
+ * to support older versions of Android.
+ *
+ * Original source: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/util/Pair.java
+ *
+ * Container to ease passing around a tuple of two objects. This object provides a sensible
+ * implementation of equals(), returning true if equals() is true on each of the contained
+ * objects.
+ */
+public class Pair<F, S> {
+    public final F first;
+    public final S second;
+
+    /**
+     * Constructor for a Pair.
+     *
+     * @param first the first object in the Pair.
+     * @param second the second object in the pair.
+     */
+    public Pair(F first, S second) {
+        this.first = first;
+        this.second = second;
+    }
+
+    /**
+     * Checks the two objects for equality by delegating to their respective
+     * {@link Object#equals(Object)} methods.
+     *
+     * @param o the {@link Pair} to which this one is to be checked for equality.
+     * @return true if the underlying objects of the Pair are both considered
+     *         equal.
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (!(o instanceof Pair)) {
+            return false;
+        }
+        Pair<?, ?> p = (Pair<?, ?>) o;
+        return equals(p.first, first) && (equals(p.second, second));
+    }
+
+    private boolean equals(Object a, Object b) {
+        return (a == b) || (a != null && a.equals(b));
+    }
+
+    /**
+     * Compute a hash code using the hash codes of the underlying objects.
+     *
+     * @return a hashcode of the Pair.
+     */
+    @Override
+    public int hashCode() {
+        return (first == null ? 0 : first.hashCode()) ^ (second == null ? 0 : second.hashCode());
+    }
+
+    @Override
+    public String toString() {
+        return "Pair{" + String.valueOf(first) + " " + String.valueOf(second) + "}";
+    }
+
+    /**
+     * Convenience method for creating an appropriately typed pair.
+     *
+     * @param a the first object in the Pair.
+     * @param b the second object in the pair.
+     * @return a Pair that is templatized with the types of a and b.
+     */
+    public static <A, B> Pair <A, B> create(A a, B b) {
+        return new Pair<A, B>(a, b);
+    }
+}
\ No newline at end of file
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index 9dcbcfd680..242ae883e1 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -16,9 +16,6 @@
 
 package io.realm;
 
-import android.os.Handler;
-import android.os.Looper;
-
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -316,13 +313,13 @@ protected void onError(LogoutResponse response) {
      * Changes this user's password. This is done synchronously and involves the network, so calling this method on the
      * Android UI thread will always crash.
      * <p>
-     * <b>WARNING:</b> Changing a users password using an authentication server that doesn't use HTTPS is a major
+     * <b>WARNING:</b> Changing a user's password through an authentication server that doesn't use HTTPS is a major
      * security flaw, and should only be done while testing.
      *
      * @param newPassword the user's new password.
      * @throws ObjectServerError if the password could not be changed.
      */
-    public void changePassword(String newPassword) throws ObjectServerError {
+    public void changePassword(final String newPassword) throws ObjectServerError {
         if (newPassword == null) {
             throw new IllegalArgumentException("Not-null 'newPassword' required.");
         }
@@ -333,6 +330,44 @@ public void changePassword(String newPassword) throws ObjectServerError {
         }
     }
 
+    /**
+     * Changes another user's password. This is done synchronously and involves the network, so calling this method on the
+     * Android UI thread will always crash.
+     * <p>
+     * This user needs admin privilege in order to change someone else's password.
+     * <p>
+     * <b>WARNING:</b> Changing a user's password through an authentication server that doesn't use HTTPS is a major
+     * security flaw, and should only be done while testing.
+     *
+     * @param userId identity ({@link #getIdentity()}) of the user we want to change the password for.
+     * @param newPassword the user's new password.
+     * @throws ObjectServerError if the password could not be changed.
+     */
+    public void changePassword(final String userId, final String newPassword) throws ObjectServerError {
+        if (newPassword == null) {
+            throw new IllegalArgumentException("Not-null 'newPassword' required.");
+        }
+
+        if (Util.isEmptyString(userId)) {
+            throw new IllegalArgumentException("None empty 'userId' required.");
+        }
+
+        if (userId.equals(getIdentity())) { // user want's to change his/her own password
+            changePassword(newPassword);
+
+        } else {
+            if (!isAdmin()) {
+                throw new IllegalStateException("User need to be admin in order to change another user's password.");
+            }
+
+            AuthenticationServer authServer = SyncManager.getAuthServer();
+            ChangePasswordResponse response = authServer.changePassword(getSyncUser().getUserToken(), userId, newPassword, getAuthenticationUrl());
+            if (!response.isValid()) {
+                throw response.getError();
+            }
+        }
+    }
+
     /**
      * Changes this user's password asynchronously.
      * <p>
@@ -359,6 +394,36 @@ public SyncUser run() {
         }.start();
     }
 
+    /**
+     * Changes another user's password asynchronously.
+     * <p>
+     * This user needs admin privilege in order to change someone else's password.
+     *
+     * <b>WARNING:</b> Changing a users password using an authentication server that doesn't use HTTPS is a major
+     * security flaw, and should only be done while testing.
+     *
+     * @param userId identity ({@link #getIdentity()}) of the user we want to change the password for.
+     * @param newPassword the user's new password.
+     * @param callback callback when login has completed or failed. The callback will always happen on the same thread
+     * as this method is called on.
+     * @return representation of the async task that can be used to cancel it if needed.
+     * @throws IllegalArgumentException if not on a Looper thread.
+     */
+    public RealmAsyncTask changePasswordAsync(final String userId, final String newPassword, final Callback callback) {
+        checkLooperThread("Asynchronous changing password is only possible from looper threads.");
+        if (callback == null) {
+            throw new IllegalArgumentException("Non-null 'callback' required.");
+        }
+
+        return new Request(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+            @Override
+            public SyncUser run() {
+                changePassword(userId, newPassword);
+                return SyncUser.this;
+            }
+        }.start();
+    }
+
     private static void checkLooperThread(String errorMessage) {
         AndroidCapabilities capabilities = new AndroidCapabilities();
         capabilities.checkCanDeliverNotification(errorMessage);
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
index 9b9c24c25e..869e39d8b6 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
@@ -61,4 +61,9 @@
      * Changes a user's password.
      */
     ChangePasswordResponse changePassword(Token userToken, String newPassword, URL authenticationUrl);
+
+    /**
+     * Changes a user's password using admin account.
+     */
+    ChangePasswordResponse changePassword(Token adminToken, String userID, String newPassword, URL authenticationUrl);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java
index 65f4886f47..8e22c09704 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java
@@ -29,16 +29,27 @@
 
     private final String token;
     private final String newPassword;
+    private String userID; //optional, used to change the password when using the admin account.
 
     public static ChangePasswordRequest create(Token userToken, String newPassword) {
         return new ChangePasswordRequest(userToken.value(), newPassword);
     }
 
+    public static ChangePasswordRequest create(Token adminToken, String userID, String newPassword) {
+        return new ChangePasswordRequest(adminToken.value(), newPassword, userID);
+    }
+
     private ChangePasswordRequest(String token, String newPassword) {
         this.token = token;
         this.newPassword = newPassword;
     }
 
+    private ChangePasswordRequest(String token, String newPassword, String userID) {
+        this.token = token;
+        this.newPassword = newPassword;
+        this.userID = userID;
+    }
+
     /**
      * Converts the request into a JSON payload.
      */
@@ -47,6 +58,9 @@ public String toJson() {
             JSONObject request = new JSONObject();
             request.put("token", token);
             request.put("password", newPassword);
+            if (userID != null) {
+                request.put("user_id", userID);
+            }
             return request.toString();
         } catch (JSONException e) {
             throw new RuntimeException(e);
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
index 46afe6e82c..709544e2f6 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
@@ -98,6 +98,16 @@ public ChangePasswordResponse changePassword(Token userToken, String newPassword
         }
     }
 
+    @Override
+    public ChangePasswordResponse changePassword(Token adminToken, String userId, String newPassword, URL authenticationUrl) {
+        try {
+            String requestBody = ChangePasswordRequest.create(adminToken, userId, newPassword).toJson();
+            return changePassword(buildActionUrl(authenticationUrl, ACTION_CHANGE_PASSWORD), requestBody);
+        } catch (Throwable e) {
+            return ChangePasswordResponse.createFailure(new ObjectServerError(ErrorCode.UNKNOWN, e));
+        }
+    }
+
     // Builds the URL for a specific auth endpoint
     private static URL buildActionUrl(URL authenticationUrl, String action) {
         final String baseUrlString = authenticationUrl.toExternalForm();
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index 6e3373d29a..1cf777cea0 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -14,7 +14,6 @@
 import java.util.UUID;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
@@ -194,6 +193,71 @@ public void changePassword() {
         assertEquals(userOld.getIdentity(), userNew.getIdentity());
     }
 
+    @Test
+    public void changePassword_using_admin() {
+        String username = UUID.randomUUID().toString();
+        String originalPassword = "password";
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, originalPassword, true);
+        SyncUser userOld = SyncUser.login(credentials, Constants.AUTH_URL);
+        assertTrue(userOld.isValid());
+
+        // Login an admin user
+        SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        assertTrue(adminUser.isValid());
+        assertTrue(adminUser.isAdmin());
+
+        // Change password using admin user
+        String newPassword = "new-password";
+        adminUser.changePassword(userOld.getIdentity(), newPassword);
+
+        // Try to log in with new password
+        userOld.logout();
+        credentials = SyncCredentials.usernamePassword(username, newPassword, false);
+        SyncUser userNew = SyncUser.login(credentials, Constants.AUTH_URL);
+
+        assertTrue(userNew.isValid());
+        assertEquals(userOld.getIdentity(), userNew.getIdentity());
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changePassword_using_admin_async() {
+        final String username = UUID.randomUUID().toString();
+        final String originalPassword = "password";
+        final SyncCredentials credentials = SyncCredentials.usernamePassword(username, originalPassword, true);
+        final SyncUser userOld = SyncUser.login(credentials, Constants.AUTH_URL);
+        assertTrue(userOld.isValid());
+
+        // Login an admin user
+        final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        assertTrue(adminUser.isValid());
+        assertTrue(adminUser.isAdmin());
+
+        // Change password using admin user
+        final String newPassword = "new-password";
+        adminUser.changePasswordAsync(userOld.getIdentity(), newPassword, new SyncUser.Callback() {
+            @Override
+            public void onSuccess(SyncUser administratorUser) {
+                assertEquals(adminUser, administratorUser);
+
+                // Try to log in with new password
+                userOld.logout();
+                SyncCredentials credentials = SyncCredentials.usernamePassword(username, newPassword, false);
+                SyncUser userNew = SyncUser.login(credentials, Constants.AUTH_URL);
+
+                assertTrue(userNew.isValid());
+                assertEquals(userOld.getIdentity(), userNew.getIdentity());
+
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.getErrorMessage());
+            }
+        });
+    }
+
     @Test
     public void changePassword_throwWhenUserIsLoggedOut() {
         String username = UUID.randomUUID().toString();
diff --git a/version.txt b/version.txt
index 105bb87d77..875e2d486a 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-3.2.2-SNAPSHOT
\ No newline at end of file
+3.4.0-SNAPSHOT
\ No newline at end of file
