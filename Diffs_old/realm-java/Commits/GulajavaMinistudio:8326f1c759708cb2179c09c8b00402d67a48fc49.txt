diff --git a/realm/realm-annotations-processor/build.gradle b/realm/realm-annotations-processor/build.gradle
index 67d444c432..d4e72dc5be 100644
--- a/realm/realm-annotations-processor/build.gradle
+++ b/realm/realm-annotations-processor/build.gradle
@@ -8,7 +8,7 @@ sourceCompatibility = '1.6'
 targetCompatibility = '1.6'
 
 dependencies {
-    compile group:'com.squareup', name:'javawriter', version:'2.5.0'
+    compile "com.squareup:javawriter:2.5.0"
     compile "io.realm:realm-annotations:${version}"
 
     testCompile files('../realm-library/build/intermediates/bundles/baseRelease/classes.jar') // Java projects cannot depend on AAR files
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index 18f4a8fda0..18db0a8a06 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -50,13 +50,13 @@
  * Utility class for holding metadata for RealmProxy classes.
  */
 public class ClassMetaData {
-
     private final TypeElement classType; // Reference to model class.
     private final String className; // Model class simple name.
     private final List<VariableElement> fields = new ArrayList<VariableElement>(); // List of all fields in the class except those @Ignored.
     private final List<VariableElement> indexedFields = new ArrayList<VariableElement>(); // list of all fields marked @Index.
     private final Set<Backlink> backlinks = new HashSet<Backlink>();
     private final Set<VariableElement> nullableFields = new HashSet<VariableElement>(); // Set of fields which can be nullable
+
     private String packageName; // package name for model class.
     private boolean hasDefaultConstructor; // True if model has a public no-arg constructor.
     private VariableElement primaryKey; // Reference to field used as primary key, if any.
@@ -332,11 +332,17 @@ private boolean checkDefaultConstructor() {
 
     private boolean checkForFinalFields() {
         for (VariableElement field : fields) {
-            if (field.getModifiers().contains(Modifier.FINAL)) {
-                Utils.error(String.format(Locale.US,
-                        "Class \"%s\" contains illegal final field \"%s\".", className, field.getSimpleName().toString()));
-                return false;
+            if (!field.getModifiers().contains(Modifier.FINAL)) {
+                continue;
             }
+            if (Utils.isMutableRealmInteger(field)) {
+                continue;
+            }
+
+            Utils.error(String.format(Locale.US, "Class \"%s\" contains illegal final field \"%s\".", className,
+                    field.getSimpleName().toString()));
+
+            return false;
         }
         return true;
     }
@@ -385,32 +391,48 @@ private boolean categorizeField(Element element) {
             if (!categorizePrimaryKeyField(field)) { return false; }
         }
 
-        // Check @LinkingObjects last since it is not allowed to be either @Index, @Required or @PrimaryKey
+        // @LinkingObjects cannot be @PrimaryKey or @Index.
         if (field.getAnnotation(LinkingObjects.class) != null) {
+            // Do not add backlinks to fields list.
             return categorizeBacklinkField(field);
         }
 
-        // Standard field that appear valid (more fine grained checks might fail later).
+        // Similarly, a MutableRealmInteger cannot be a @PrimaryKey or @LinkingObject.
+        if (Utils.isMutableRealmInteger(field)) {
+            if (!categorizeMutableRealmIntegerField(field)) { return false; }
+        }
+
+        // Standard field that appears to be valid (more fine grained checks might fail later).
         fields.add(field);
 
         return true;
     }
 
+    // The field has the @Index annotation. It's only valid for column types:
+    // STRING, DATE, INTEGER, BOOLEAN, and RealmMutableInteger
     private boolean categorizeIndexField(Element element, VariableElement variableElement) {
-        // The field has the @Index annotation. It's only valid for column types:
-        // STRING, DATE, INTEGER, BOOLEAN
-        Constants.RealmFieldType realmType = Constants.JAVA_TO_REALM_TYPES.get(variableElement.asType().toString());
-        if (realmType != null) {
-            switch (realmType) {
-                case STRING:
-                case DATE:
-                case INTEGER:
-                case BOOLEAN:
-                    indexedFields.add(variableElement);
-                    return true;
+        boolean indexable = false;
+
+        if (Utils.isMutableRealmInteger(variableElement)) {
+            indexable = true;
+        } else {
+            Constants.RealmFieldType realmType = Constants.JAVA_TO_REALM_TYPES.get(variableElement.asType().toString());
+            if (realmType != null) {
+                switch (realmType) {
+                    case STRING:
+                    case DATE:
+                    case INTEGER:
+                    case BOOLEAN:
+                        indexable = true;
+                }
             }
         }
 
+        if (indexable) {
+            indexedFields.add(variableElement);
+            return true;
+        }
+
         Utils.error(String.format(Locale.US, "Field \"%s\" of type \"%s\" cannot be an @Index.", element, element.asType()));
         return false;
     }
@@ -420,17 +442,21 @@ private void categorizeRequiredField(Element element, VariableElement variableEl
         if (Utils.isPrimitiveType(variableElement)) {
             Utils.error(String.format(Locale.US,
                     "@Required annotation is unnecessary for primitive field \"%s\".", element));
-        } else if (Utils.isRealmList(variableElement) || Utils.isRealmModel(variableElement)) {
+            return;
+        }
+
+        if (Utils.isRealmList(variableElement) || Utils.isRealmModel(variableElement)) {
             Utils.error(String.format(Locale.US,
                     "Field \"%s\" with type \"%s\" cannot be @Required.", element, element.asType()));
-        } else {
-            // Should never get here - user should remove @Required
-            if (nullableFields.contains(variableElement)) {
-                Utils.error(String.format(Locale.US,
-                        "Field \"%s\" with type \"%s\" appears to be nullable. Consider removing @Required.",
-                        element,
-                        element.asType()));
-            }
+            return;
+        }
+
+        // Should never get here - user should remove @Required
+        if (nullableFields.contains(variableElement)) {
+            Utils.error(String.format(Locale.US,
+                    "Field \"%s\" with type \"%s\" appears to be nullable. Consider removing @Required.",
+                    element,
+                    element.asType()));
         }
     }
 
@@ -473,6 +499,17 @@ private boolean categorizeBacklinkField(VariableElement variableElement) {
         return true;
     }
 
+    private boolean categorizeMutableRealmIntegerField(VariableElement field) {
+        if (field.getModifiers().contains(Modifier.FINAL)) {
+            return true;
+        }
+
+        Utils.error(String.format(Locale.US,
+                "Field \"%s\", a MutableRealmInteger, must be final.",
+                field.getSimpleName().toString()));
+        return false;
+    }
+
     private boolean isValidPrimaryKeyType(TypeMirror type) {
         for (TypeMirror validType : validPrimaryKeyTypes) {
             if (typeUtils.isAssignable(type, validType)) {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
index 2daa18769a..9dd2b68b8c 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
@@ -51,6 +51,7 @@
         STRING("STRING", "String"),
         DATE("DATE", "Date"),
         BINARY("BINARY", "BinaryByteArray"),
+        REALM_INTEGER("INTEGER", "Long"),
         OBJECT("OBJECT", "Object"),
         LIST("LIST", "List"),
         BACKLINK("BACKLINK", null);
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
index da89d6a46a..dcaa1fd63b 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
@@ -19,6 +19,7 @@
 import com.squareup.javawriter.JavaWriter;
 
 import java.io.IOException;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Locale;
 import java.util.Map;
@@ -31,140 +32,147 @@
     private static final Map<String, JsonToRealmFieldTypeConverter> JAVA_TO_JSON_TYPES;
 
     static {
-        JAVA_TO_JSON_TYPES = new HashMap<String, JsonToRealmFieldTypeConverter>();
-        JAVA_TO_JSON_TYPES.put("byte", new SimpleTypeConverter("byte", "Int"));
-        JAVA_TO_JSON_TYPES.put("short", new SimpleTypeConverter("short", "Int"));
-        JAVA_TO_JSON_TYPES.put("int", new SimpleTypeConverter("int", "Int"));
-        JAVA_TO_JSON_TYPES.put("long", new SimpleTypeConverter("long", "Long"));
-        JAVA_TO_JSON_TYPES.put("float", new SimpleTypeConverter("float", "Double"));
-        JAVA_TO_JSON_TYPES.put("double", new SimpleTypeConverter("double", "Double"));
-        JAVA_TO_JSON_TYPES.put("boolean", new SimpleTypeConverter("boolean", "Boolean"));
-        JAVA_TO_JSON_TYPES.put("java.lang.Byte", new SimpleTypeConverter("byte", "Int"));
-        JAVA_TO_JSON_TYPES.put("java.lang.Short", new SimpleTypeConverter("short", "Int"));
-        JAVA_TO_JSON_TYPES.put("java.lang.Integer", new SimpleTypeConverter("int", "Int"));
-        JAVA_TO_JSON_TYPES.put("java.lang.Long", new SimpleTypeConverter("long", "Long"));
-        JAVA_TO_JSON_TYPES.put("java.lang.Float", new SimpleTypeConverter("float", "Double"));
-        JAVA_TO_JSON_TYPES.put("java.lang.Double", new SimpleTypeConverter("double", "Double"));
-        JAVA_TO_JSON_TYPES.put("java.lang.Boolean", new SimpleTypeConverter("boolean", "Boolean"));
-        JAVA_TO_JSON_TYPES.put("java.lang.String", new SimpleTypeConverter("String", "String"));
-        JAVA_TO_JSON_TYPES.put("java.util.Date", new DateTypeConverter());
-        JAVA_TO_JSON_TYPES.put("byte[]", new ByteArrayTypeConverter());
+        Map<String, JsonToRealmFieldTypeConverter> m = new HashMap<String, JsonToRealmFieldTypeConverter>();
+        m.put("byte", new SimpleTypeConverter("byte", "Int"));
+        m.put("short", new SimpleTypeConverter("short", "Int"));
+        m.put("int", new SimpleTypeConverter("int", "Int"));
+        m.put("long", new SimpleTypeConverter("long", "Long"));
+        m.put("float", new SimpleTypeConverter("float", "Double"));
+        m.put("double", new SimpleTypeConverter("double", "Double"));
+        m.put("boolean", new SimpleTypeConverter("boolean", "Boolean"));
+        m.put("byte[]", new ByteArrayTypeConverter());
+        m.put("java.lang.Byte", m.get("byte"));
+        m.put("java.lang.Short", m.get("short"));
+        m.put("java.lang.Integer", m.get("int"));
+        m.put("java.lang.Long", m.get("long"));
+        m.put("java.lang.Float", m.get("float"));
+        m.put("java.lang.Double", m.get("double"));
+        m.put("java.lang.Boolean", m.get("boolean"));
+        m.put("java.lang.String", new SimpleTypeConverter("String", "String"));
+        m.put("java.util.Date", new DateTypeConverter());
+        m.put("io.realm.MutableRealmInteger", new MutableRealmIntegerTypeConverter());
+        JAVA_TO_JSON_TYPES = Collections.unmodifiableMap(m);
     }
 
-    public static void emitCreateObjectWithPrimaryKeyValue(
-            String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass,
-            String qualifiedFieldType, String fieldName, JavaWriter writer)
+    // Static helper class
+    private RealmJsonTypeHelper() { }
+
+    // @formatter:off
+    public static void emitIllegalJsonValueException(String fieldType, String fieldName, JavaWriter writer)
             throws IOException {
-        JsonToRealmFieldTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(qualifiedFieldType);
-        if (typeEmitter != null) {
-            typeEmitter.emitGetObjectWithPrimaryKeyValue(
-                    qualifiedRealmObjectClass, qualifiedRealmObjectProxyClass, fieldName, writer);
-        }
+        writer
+            .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_JSON_LOAD, fieldType, fieldName)
+            .endControlFlow();
     }
+    // @formatter:on
 
-    public static void emitFillJavaTypeWithJsonValue(
-            String interfaceName, String setter, String fieldName, String qualifiedFieldType, JavaWriter writer)
+    public static void emitCreateObjectWithPrimaryKeyValue(
+            String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass, String qualifiedFieldType, String fieldName, JavaWriter writer)
             throws IOException {
         JsonToRealmFieldTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(qualifiedFieldType);
         if (typeEmitter != null) {
-            typeEmitter.emitTypeConversion(interfaceName, setter, fieldName, qualifiedFieldType, writer);
+            typeEmitter.emitGetObjectWithPrimaryKeyValue(
+                    qualifiedRealmObjectClass, qualifiedRealmObjectProxyClass, fieldName, writer);
         }
     }
 
-    public static void emitIllegalJsonValueException(String fieldType, String fieldName, JavaWriter writer)
-            throws IOException {
-        writer
-                .beginControlFlow("if (json.has(\"%s\"))", fieldName)
-                .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_JSON_LOAD, fieldType, fieldName)
-                .endControlFlow();
-    }
-
     // @formatter:off
     public static void emitFillRealmObjectWithJsonValue(
-            String interfaceName, String setter, String fieldName,
-            String qualifiedFieldType, String proxyClass, JavaWriter writer)
+            String varName, String setter, String fieldName, String qualifiedFieldType, String proxyClass, JavaWriter writer)
             throws IOException {
         writer
             .beginControlFlow("if (json.has(\"%s\"))", fieldName)
                 .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                    .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                    .emitStatement("%s.%s(null)", varName, setter)
                 .nextControlFlow("else")
                     .emitStatement(
-                            "%s %sObj = %s.createOrUpdateUsingJsonObject(realm, json.getJSONObject(\"%s\"), update)",
-                            qualifiedFieldType, fieldName, proxyClass, fieldName)
-                    .emitStatement("((%s) obj).%s(%sObj)", interfaceName, setter, fieldName)
+                        "%s %sObj = %s.createOrUpdateUsingJsonObject(realm, json.getJSONObject(\"%s\"), update)",
+                        qualifiedFieldType, fieldName, proxyClass, fieldName)
+                    .emitStatement("%s.%s(%sObj)", varName, setter, fieldName)
                 .endControlFlow()
             .endControlFlow();
     }
     // @formatter:on
 
     // @formatter:off
-    public static void emitFillRealmListWithJsonValue(String interfaceName, String getter, String setter,
-        String fieldName, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer) throws IOException {
+    public static void emitFillRealmListWithJsonValue(
+            String varName, String getter, String setter, String fieldName, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer)
+            throws IOException {
         writer
             .beginControlFlow("if (json.has(\"%s\"))", fieldName)
                 .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                    .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                    .emitStatement("%s.%s(null)", varName, setter)
                 .nextControlFlow("else")
-                    .emitStatement("((%s) obj).%s().clear()", interfaceName, getter)
+                    .emitStatement("%s.%s().clear()", varName, getter)
                     .emitStatement("JSONArray array = json.getJSONArray(\"%s\")", fieldName)
                     .beginControlFlow("for (int i = 0; i < array.length(); i++)")
                         .emitStatement(
                                 "%s item = %s.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update)",
                                 fieldTypeCanonicalName, proxyClass, fieldTypeCanonicalName)
-                        .emitStatement("((%s) obj).%s().add(item)", interfaceName, getter)
+                        .emitStatement("%s.%s().add(item)", varName, getter)
                     .endControlFlow()
                 .endControlFlow()
             .endControlFlow();
     }
     // @formatter:on
 
-    public static void emitFillJavaTypeFromStream(
-            String interfaceName, ClassMetaData metaData, String fieldName, String fieldType, JavaWriter writer)
+    public static void emitFillJavaTypeWithJsonValue(
+            String varName, String accessor, String fieldName, String qualifiedFieldType, JavaWriter writer)
             throws IOException {
-        String setter = metaData.getInternalSetter(fieldName);
-        boolean isPrimaryKey = metaData.hasPrimaryKey() && metaData.getPrimaryKey().getSimpleName().toString().equals(fieldName);
-        if (JAVA_TO_JSON_TYPES.containsKey(fieldType)) {
-            JAVA_TO_JSON_TYPES.get(fieldType)
-                    .emitStreamTypeConversion(interfaceName, setter, fieldName, fieldType, writer, isPrimaryKey);
+        JsonToRealmFieldTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(qualifiedFieldType);
+        if (typeEmitter != null) {
+            typeEmitter.emitTypeConversion(varName, accessor, fieldName, qualifiedFieldType, writer);
         }
     }
 
     // @formatter:off
-    public static void emitFillRealmObjectFromStream(String interfaceName, String setter, String fieldName,
-        String fieldTypeCanonicalName, String proxyClass, JavaWriter writer) throws IOException {
+    public static void emitFillRealmObjectFromStream(
+            String varName, String setter, String fieldName, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer)
+            throws IOException {
         writer
             .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
                 .emitStatement("reader.skipValue()")
-                .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                .emitStatement("%s.%s(null)", varName, setter)
             .nextControlFlow("else")
                 .emitStatement(
                         "%s %sObj = %s.createUsingJsonStream(realm, reader)",
                         fieldTypeCanonicalName, fieldName, proxyClass)
-                .emitStatement("((%s) obj).%s(%sObj)", interfaceName, setter, fieldName)
+                .emitStatement("%s.%s(%sObj)", varName, setter, fieldName)
             .endControlFlow();
     }
     // @formatter:on
 
     // @formatter:off
-    public static void emitFillRealmListFromStream(String interfaceName, String getter, String setter,
-        String fieldTypeCanonicalName, String proxyClass, JavaWriter writer) throws IOException {
+    public static void emitFillRealmListFromStream(
+            String varName, String getter, String setter, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer)
+            throws IOException {
         writer
             .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
                 .emitStatement("reader.skipValue()")
-                .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                .emitStatement("%s.%s(null)", varName, setter)
             .nextControlFlow("else")
-                .emitStatement("((%s) obj).%s(new RealmList<%s>())", interfaceName, setter, fieldTypeCanonicalName)
+                .emitStatement("%s.%s(new RealmList<%s>())", varName, setter, fieldTypeCanonicalName)
                 .emitStatement("reader.beginArray()")
                 .beginControlFlow("while (reader.hasNext())")
                     .emitStatement("%s item = %s.createUsingJsonStream(realm, reader)", fieldTypeCanonicalName, proxyClass)
-                    .emitStatement("((%s) obj).%s().add(item)", interfaceName, getter)
+                    .emitStatement("%s.%s().add(item)", varName, getter)
                 .endControlFlow()
                 .emitStatement("reader.endArray()")
             .endControlFlow();
     }
     // @formatter:on
 
+    public static void emitFillJavaTypeFromStream(
+            String varName, ClassMetaData metaData, String accessor, String fieldName, String fieldType, JavaWriter writer)
+            throws IOException {
+        boolean isPrimaryKey = metaData.hasPrimaryKey() && metaData.getPrimaryKey().getSimpleName().toString().equals(fieldName);
+        JsonToRealmFieldTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(fieldType);
+        if (typeEmitter != null) {
+            typeEmitter.emitStreamTypeConversion(varName, accessor, fieldName, fieldType, writer, isPrimaryKey);
+        }
+    }
+
     private static class SimpleTypeConverter implements JsonToRealmFieldTypeConverter {
         private final String castType;
         private final String jsonType;
@@ -183,22 +191,21 @@ private SimpleTypeConverter(String castType, String jsonType) {
 
         @Override
         public void emitTypeConversion(
-                String interfaceName, String setter, String fieldName, String fieldType, JavaWriter writer)
+                String varName, String accessor, String fieldName, String fieldType, JavaWriter writer)
                 throws IOException {
             // Only throw exception for primitive types.
             // For boxed types and String, exception will be thrown in the setter.
             String statementSetNullOrThrow = Utils.isPrimitiveType(fieldType) ?
                     String.format(Locale.US, Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName) :
-                    String.format(Locale.US, "((%s) obj).%s(null)", interfaceName, setter);
+                    String.format(Locale.US, "%s.%s(null)", varName, accessor);
+
             // @formatter:off
             writer
                 .beginControlFlow("if (json.has(\"%s\"))", fieldName)
                     .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
                         .emitStatement(statementSetNullOrThrow)
                     .nextControlFlow("else")
-                        .emitStatement(
-                                "((%s) obj).%s((%s) json.get%s(\"%s\"))",
-                                interfaceName, setter, castType, jsonType, fieldName)
+                        .emitStatement("%s.%s((%s) json.get%s(\"%s\"))", varName, accessor, castType, jsonType, fieldName)
                     .endControlFlow()
                 .endControlFlow();
             // @formatter:on
@@ -206,41 +213,43 @@ public void emitTypeConversion(
 
         @Override
         public void emitStreamTypeConversion(
-                String interfaceName, String setter, String fieldName,
-                String fieldType, JavaWriter writer, boolean isPrimaryKey)
+                String varName, String setter, String fieldName, String fieldType, JavaWriter writer, boolean isPrimaryKey)
                 throws IOException {
-            // Only throw exception for primitive types. For boxed types and String, exception will be thrown in
-            // the setter.
+            // Only throw exception for primitive types.
+            // For boxed types and String, exception will be thrown in the setter.
             String statementSetNullOrThrow = (Utils.isPrimitiveType(fieldType)) ?
                     String.format(Locale.US, Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName) :
-                    String.format(Locale.US, "((%s) obj).%s(null)", interfaceName, setter);
+                    String.format(Locale.US, "%s.%s(null)", varName, setter);
+
             // @formatter:off
             writer
-                .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
+                .beginControlFlow("if (reader.peek() != JsonToken.NULL)")
+                    .emitStatement("%s.%s((%s) reader.next%s())", varName, setter, castType, jsonType)
+                .nextControlFlow("else")
                     .emitStatement("reader.skipValue()")
                     .emitStatement(statementSetNullOrThrow)
-                .nextControlFlow("else")
-                    .emitStatement("((%s) obj).%s((%s) reader.next%s())", interfaceName, setter, castType, jsonType)
                 .endControlFlow();
+            // @formatter:on
+
             if (isPrimaryKey) {
                 writer.emitStatement("jsonHasPrimaryKey = true");
             }
-            // @formatter:on
         }
 
         // @formatter:off
         @Override
         public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
             String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer) throws IOException {
-            // No error checking is done here for valid primary key types. This should be done by the annotation
-            // processor
+            // No error checking is done here for valid primary key types.
+            // This should be done by the annotation processor.
             writer
                 .beginControlFlow("if (json.has(\"%s\"))", fieldName)
                     .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
                         .emitStatement("obj = (%1$s) realm.createObjectInternal(%2$s.class, null, true, excludeFields)",
                                 qualifiedRealmObjectProxyClass, qualifiedRealmObjectClass)
                     .nextControlFlow("else")
-                        .emitStatement("obj = (%1$s) realm.createObjectInternal(%2$s.class, json.get%3$s(\"%4$s\"), true, excludeFields)",
+                        .emitStatement(
+                                "obj = (%1$s) realm.createObjectInternal(%2$s.class, json.get%3$s(\"%4$s\"), true, excludeFields)",
                                 qualifiedRealmObjectProxyClass, qualifiedRealmObjectClass, jsonType, fieldName)
                     .endControlFlow()
                 .nextControlFlow("else")
@@ -250,22 +259,60 @@ public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
         // @formatter:on
     }
 
+    private static class ByteArrayTypeConverter implements JsonToRealmFieldTypeConverter {
+        // @formatter:off
+        @Override
+        public void emitTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer)
+                throws IOException {
+            writer
+                .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                    .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                        .emitStatement("%s.%s(null)", varName, accessor)
+                    .nextControlFlow("else")
+                        .emitStatement("%s.%s(JsonUtils.stringToBytes(json.getString(\"%s\")))", varName, accessor, fieldName)
+                    .endControlFlow()
+                .endControlFlow();
+        }
+        // @formatter:on
+
+        // @formatter:off
+        @Override
+        public void emitStreamTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer, boolean isPrimaryKey)
+                throws IOException {
+            writer
+                .beginControlFlow("if (reader.peek() != JsonToken.NULL)")
+                    .emitStatement("%s.%s(JsonUtils.stringToBytes(reader.nextString()))", varName, accessor)
+                .nextControlFlow("else")
+                    .emitStatement("reader.skipValue()")
+                    .emitStatement("%s.%s(null)", varName, accessor)
+                .endControlFlow();
+        }
+        // @formatter:on
+
+        @Override
+        public void emitGetObjectWithPrimaryKeyValue(
+                String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer)
+                throws IOException {
+            throw new IllegalArgumentException("'byte[]' is not allowed as a primary key value.");
+        }
+    }
+
     private static class DateTypeConverter implements JsonToRealmFieldTypeConverter {
         // @formatter:off
         @Override
         public void emitTypeConversion(
-                String interfaceName, String setter, String fieldName, String fieldType, JavaWriter writer)
+                String varName, String accessor, String fieldName, String fieldType, JavaWriter writer)
                 throws IOException {
             writer
                 .beginControlFlow("if (json.has(\"%s\"))", fieldName)
                     .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                        .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                        .emitStatement("%s.%s(null)", varName, accessor)
                     .nextControlFlow("else")
                         .emitStatement("Object timestamp = json.get(\"%s\")", fieldName)
                         .beginControlFlow("if (timestamp instanceof String)")
-                            .emitStatement("((%s) obj).%s(JsonUtils.stringToDate((String) timestamp))", interfaceName, setter)
+                            .emitStatement("%s.%s(JsonUtils.stringToDate((String) timestamp))", varName, accessor)
                         .nextControlFlow("else")
-                            .emitStatement("((%s) obj).%s(new Date(json.getLong(\"%s\")))", interfaceName, setter, fieldName)
+                            .emitStatement("%s.%s(new Date(json.getLong(\"%s\")))", varName, accessor, fieldName)
                         .endControlFlow()
                     .endControlFlow()
                 .endControlFlow();
@@ -275,19 +322,19 @@ public void emitTypeConversion(
         // @formatter:off
         @Override
         public void emitStreamTypeConversion(
-                String interfaceName, String setter, String fieldName, String fieldType, JavaWriter writer, boolean isPrimaryKey)
+                String varName, String accessor, String fieldName, String fieldType, JavaWriter writer, boolean isPrimaryKey)
                 throws IOException {
             writer
                 .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
                     .emitStatement("reader.skipValue()")
-                    .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                    .emitStatement("%s.%s(null)", varName, accessor)
                 .nextControlFlow("else if (reader.peek() == JsonToken.NUMBER)")
                     .emitStatement("long timestamp = reader.nextLong()", fieldName)
                     .beginControlFlow("if (timestamp > -1)")
-                        .emitStatement("((%s) obj).%s(new Date(timestamp))", interfaceName, setter)
+                        .emitStatement("%s.%s(new Date(timestamp))", varName, accessor)
                     .endControlFlow()
                 .nextControlFlow("else")
-                    .emitStatement("((%s) obj).%s(JsonUtils.stringToDate(reader.nextString()))", interfaceName, setter)
+                    .emitStatement("%s.%s(JsonUtils.stringToDate(reader.nextString()))", varName, accessor)
                 .endControlFlow();
         }
         // @formatter:on
@@ -300,54 +347,48 @@ public void emitGetObjectWithPrimaryKeyValue(
         }
     }
 
-    private static class ByteArrayTypeConverter implements JsonToRealmFieldTypeConverter {
+    private static class MutableRealmIntegerTypeConverter implements JsonToRealmFieldTypeConverter {
         // @formatter:off
         @Override
-        public void emitTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
-                JavaWriter writer) throws IOException {
+        public void emitTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer)
+                throws IOException {
             writer
                 .beginControlFlow("if (json.has(\"%s\"))", fieldName)
-                    .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                        .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
-                    .nextControlFlow("else")
-                        .emitStatement(
-                                "((%s) obj).%s(JsonUtils.stringToBytes(json.getString(\"%s\")))",
-                                interfaceName, setter, fieldName)
-                    .endControlFlow()
+                    .emitStatement("%1$s.%2$s().set((json.isNull(\"%3$s\")) ? null : json.getLong(\"%3$s\"))", varName, accessor, fieldName)
                 .endControlFlow();
         }
         // @formatter:on
 
         // @formatter:off
         @Override
-        public void emitStreamTypeConversion(String interfaceName, String setter, String fieldName,
-                String fieldType, JavaWriter writer, boolean isPrimaryKey) throws IOException {
+        public void emitStreamTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer, boolean isPrimaryKey)
+                throws IOException {
             writer
-                .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
-                    .emitStatement("reader.skipValue()")
-                    .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                .emitStatement("Long val = null")
+                .beginControlFlow("if (reader.peek() != JsonToken.NULL)")
+                    .emitStatement("val = reader.nextLong()")
                 .nextControlFlow("else")
-                    .emitStatement("((%s) obj).%s(JsonUtils.stringToBytes(reader.nextString()))", interfaceName, setter)
-                .endControlFlow();
+                    .emitStatement("reader.skipValue()")
+                .endControlFlow()
+                .emitStatement("%1$s.%2$s().set(val)", varName, accessor);
         }
         // @formatter:on
 
         @Override
-        public void emitGetObjectWithPrimaryKeyValue(
-                String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer)
+        public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer)
                 throws IOException {
-            throw new IllegalArgumentException("'byte[]' is not allowed as a primary key value.");
+            throw new IllegalArgumentException("'MutableRealmInteger' is not allowed as a primary key value.");
         }
     }
 
     private interface JsonToRealmFieldTypeConverter {
-        void emitTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
-                JavaWriter writer) throws IOException;
+        void emitTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer)
+                throws IOException;
 
-        void emitStreamTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
-                JavaWriter writer, boolean isPrimaryKey) throws IOException;
+        void emitStreamTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer, boolean isPrimaryKey)
+                throws IOException;
 
-        void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass,
-                String fieldName, JavaWriter writer) throws IOException;
+        void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer)
+                throws IOException;
     }
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 91016683b4..bd74ae858e 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -255,10 +255,11 @@ private void emitInstanceFields(JavaWriter writer) throws IOException {
                 .emitField("ProxyState<" + qualifiedClassName + ">", "proxyState", EnumSet.of(Modifier.PRIVATE));
 
         for (VariableElement variableElement : metadata.getFields()) {
-            if (Utils.isRealmList(variableElement)) {
+            if (Utils.isMutableRealmInteger(variableElement)) {
+                emitMutableRealmIntegerField(writer, variableElement);
+            } else if (Utils.isRealmList(variableElement)) {
                 String genericType = Utils.getGenericTypeQualifiedName(variableElement);
-                writer.emitField("RealmList<" + genericType + ">", variableElement.getSimpleName().toString() +
-                        "RealmList", EnumSet.of(Modifier.PRIVATE));
+                writer.emitField("RealmList<" + genericType + ">", variableElement.getSimpleName().toString() + "RealmList", EnumSet.of(Modifier.PRIVATE));
             }
         }
 
@@ -269,10 +270,28 @@ private void emitInstanceFields(JavaWriter writer) throws IOException {
     }
     //@formatter:on
 
+    // The anonymous subclass of MutableRealmInteger.Managed holds a reference to this proxy.
+    // Even if all other references to the proxy are dropped, the proxy will not be GCed until
+    // the MutableInteger that it owns, also becomes unreachable.
+    //@formatter:off
+    private void emitMutableRealmIntegerField(JavaWriter writer, VariableElement variableElement) throws IOException{
+        writer.emitField("MutableRealmInteger.Managed",
+                mutableRealmIntegerFieldName(variableElement),
+                EnumSet.of(Modifier.PRIVATE, Modifier.FINAL),
+                String.format(
+                        "new MutableRealmInteger.Managed<%1$s>() {\n"
+                                + "    @Override protected ProxyState<%1$s> getProxyState() { return proxyState; }\n"
+                                + "    @Override protected long getColumnIndex() { return columnInfo.%2$s; }\n"
+                                + "}",
+                        qualifiedClassName, columnIndexVarName(variableElement)));
+    }
+    //@formatter:on
+
     //@formatter:off
     private void emitConstructor(JavaWriter writer) throws IOException {
         // FooRealmProxy(ColumnInfo)
-        writer.beginConstructor(EnumSet.noneOf(Modifier.class))
+        writer.emitEmptyLine()
+                .beginConstructor(EnumSet.noneOf(Modifier.class))
                 .emitStatement("proxyState.setConstructionFinished()")
                 .endConstructor()
                 .emitEmptyLine();
@@ -286,6 +305,8 @@ private void emitPersistedFieldAccessors(final JavaWriter writer) throws IOExcep
 
             if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                 emitPrimitiveType(writer, field, fieldName, fieldTypeCanonicalName);
+            } else if (Utils.isMutableRealmInteger(field)) {
+                emitMutableRealmInteger(writer, field, fieldName, fieldTypeCanonicalName);
             } else if (Utils.isRealmModel(field)) {
                 emitRealmModel(writer, field, fieldName, fieldTypeCanonicalName);
             } else if (Utils.isRealmList(field)) {
@@ -396,6 +417,16 @@ public void emit(JavaWriter writer) throws IOException {
         writer.endMethod();
     }
 
+    //@formatter:off
+    private void emitMutableRealmInteger(JavaWriter writer, VariableElement field, String fieldName, String fieldTypeCanonicalName) throws IOException {
+        writer.emitAnnotation("Override")
+            .beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
+                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
+                .emitStatement("return this.%s", mutableRealmIntegerFieldName(field))
+            .endMethod();
+    }
+    //@formatter:on
+
     /**
      * Links
      */
@@ -462,7 +493,7 @@ public void emit(JavaWriter writer) throws IOException {
                 .beginControlFlow("if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
                 .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
                 .endControlFlow()
-                .emitStatement("proxyState.getRow$realm().setLink(%s, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex())", fieldIndexVariableReference(field))
+                .emitStatement("proxyState.getRow$realm().setLink(%s, ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex())", fieldIndexVariableReference(field))
                 .endMethod();
     }
     //@formatter:on
@@ -561,6 +592,8 @@ private void emitCodeForUnderConstruction(JavaWriter writer, boolean isPrimaryKe
                 .emitEmptyLine();
     }
 
+    // Note that because of bytecode hackery, this method may run before the constructor!
+    // It may even run before fields have been initialized.
     //@formatter:off
     private void emitInjectContextMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
@@ -579,9 +612,8 @@ private void emitInjectContextMethod(JavaWriter writer) throws IOException {
                 .emitStatement("proxyState.setRealm$realm(context.getRealm())")
                 .emitStatement("proxyState.setRow$realm(context.getRow())")
                 .emitStatement("proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue())")
-                .emitStatement("proxyState.setExcludeFields$realm(context.getExcludeFields())");
-
-        writer.endMethod()
+                .emitStatement("proxyState.setExcludeFields$realm(context.getExcludeFields())")
+                .endMethod()
                 .emitEmptyLine();
     }
     //@formatter:on
@@ -673,7 +705,7 @@ private void emitGetExpectedObjectSchemaInfo(JavaWriter writer) throws IOExcepti
                 "getExpectedObjectSchemaInfo", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC)); // Modifiers
 
-        writer.emitStatement(" return expectedObjectSchemaInfo");
+        writer.emitStatement("return expectedObjectSchemaInfo");
 
         writer.endMethod()
                 .emitEmptyLine();
@@ -755,6 +787,8 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
             String fieldTypeQualifiedName = Utils.getFieldTypeQualifiedName(field);
             if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeQualifiedName)) {
                 emitValidateRealmType(writer, field, fieldName, fieldTypeQualifiedName);
+            } else if (Utils.isMutableRealmInteger(field)) {
+                emitValidateRealmType(writer, field, fieldName, fieldTypeQualifiedName);
             } else if (Utils.isRealmModel(field)) { // Links
                 emitValidateRealmModelType(writer, field, fieldIndex, fieldName);
             } else if (Utils.isRealmList(field)) { // Link Lists
@@ -946,22 +980,24 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
         );
 
         writer
-                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId)")
-                .emitStatement("throw new IllegalArgumentException(\"Objects which belong to Realm instances in other" +
-                        " threads cannot be copied into this Realm instance.\")")
-                .endControlFlow();
+                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null)")
+                    .emitStatement("final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm()")
+                    .beginControlFlow("if (otherRealm.threadId != realm.threadId)")
+                        .emitStatement("throw new IllegalArgumentException(\"Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.\")")
+                    .endControlFlow()
 
-        // If object is already in the Realm there is nothing to update
-        writer
-                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
-                .emitStatement("return object")
+                    // If object is already in the Realm there is nothing to update
+                    .beginControlFlow("if (otherRealm.getPath().equals(realm.getPath()))")
+                        .emitStatement("return object")
+                    .endControlFlow()
                 .endControlFlow();
 
+
         writer.emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()");
 
-        writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(object)");
-        writer.beginControlFlow("if (cachedRealmObject != null)")
-                .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
+        writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(object)")
+                .beginControlFlow("if (cachedRealmObject != null)")
+                    .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
                 .endControlFlow()
                 .emitEmptyLine();
 
@@ -983,18 +1019,18 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                             .emitStatement("String value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                             .emitStatement("long rowIndex = Table.NO_MATCH")
                             .beginControlFlow("if (value == null)")
-                            .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                                .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
                             .nextControlFlow("else")
-                            .emitStatement("rowIndex = table.findFirstString(pkColumnIndex, value)")
+                                .emitStatement("rowIndex = table.findFirstString(pkColumnIndex, value)")
                             .endControlFlow();
                 } else {
                     writer
                             .emitStatement("Number value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                             .emitStatement("long rowIndex = Table.NO_MATCH")
                             .beginControlFlow("if (value == null)")
-                            .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                                .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
                             .nextControlFlow("else")
-                            .emitStatement("rowIndex = table.findFirstLong(pkColumnIndex, value.longValue())")
+                                .emitStatement("rowIndex = table.findFirstLong(pkColumnIndex, value.longValue())")
                             .endControlFlow();
                 }
             } else {
@@ -1004,30 +1040,25 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
             }
 
             writer
-                    .beginControlFlow("if (rowIndex != Table.NO_MATCH)")
-                    .beginControlFlow("try")
-                    .emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex)," +
-                            " realm.getSchema().getColumnInfo(%s.class)," +
-                            " false, Collections.<String> emptyList())", qualifiedClassName)
-                    .emitStatement("realmObject = new %s()", qualifiedGeneratedClassName)
-                    .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
-                    .nextControlFlow("finally")
-                    .emitStatement("objectContext.clear()")
-                    .endControlFlow()
-
+                    .beginControlFlow("if (rowIndex == Table.NO_MATCH)")
+                        .emitStatement("canUpdate = false")
                     .nextControlFlow("else")
-                    .emitStatement("canUpdate = false")
+                        .beginControlFlow("try")
+                            .emitStatement(
+                                "objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())",
+                                qualifiedClassName)
+                            .emitStatement("realmObject = new %s()", qualifiedGeneratedClassName)
+                            .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
+                        .nextControlFlow("finally")
+                            .emitStatement("objectContext.clear()")
+                        .endControlFlow()
                     .endControlFlow();
 
             writer.endControlFlow();
 
             writer
                     .emitEmptyLine()
-                    .beginControlFlow("if (canUpdate)")
-                    .emitStatement("return update(realm, realmObject, object, cache)")
-                    .nextControlFlow("else")
-                    .emitStatement("return copy(realm, object, update, cache)")
-                    .endControlFlow();
+                       .emitStatement("return (canUpdate) ? update(realm, realmObject, object, cache) : copy(realm, object, update, cache)");
         }
 
         writer.endMethod()
@@ -1057,6 +1088,17 @@ private void setTableValues(JavaWriter writer, String fieldType, String fieldNam
             }
             writer.endControlFlow();
 
+        } else if ("io.realm.MutableRealmInteger".equals(fieldType)) {
+            writer
+                    .emitStatement("Long %s = ((%s) object).%s().get()", getter, interfaceName, getter)
+                    .beginControlFlow("if (%s != null)", getter)
+                    .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter);
+            if (isUpdate) {
+                writer.nextControlFlow("else")
+                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
+            }
+            writer.endControlFlow();
+
         } else if ("double".equals(fieldType)) {
             writer.emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);
 
@@ -1197,8 +1239,7 @@ private void emitInsertMethod(JavaWriter writer) throws IOException {
                         .endControlFlow()
                         .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                         .endControlFlow()
-                        .endControlFlow()
-                        .emitEmptyLine();
+                        .endControlFlow();
 
             } else {
                 if (metadata.getPrimaryKey() != field) {
@@ -1593,6 +1634,9 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
                         .endControlFlow()
                         .emitEmptyLine();
 
+            } else if (Utils.isMutableRealmInteger(field)) {
+                writer.emitEmptyLine()
+                        .emitStatement("realmObjectCopy.%1$s().set(realmObjectSource.%1$s().get())", getter);
             } else {
                 writer.emitStatement("realmObjectCopy.%s(realmObjectSource.%s())", setter, getter);
             }
@@ -1630,8 +1674,9 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
                 .endControlFlow();
 
         // may cause an unused variable warning if the object contains only null lists
-        writer.emitStatement("%1$s unmanagedCopy = (%1$s) unmanagedObject", interfaceName);
-        writer.emitStatement("%1$s realmSource = (%1$s) realmObject", interfaceName);
+        writer.emitStatement("%1$s unmanagedCopy = (%1$s) unmanagedObject", interfaceName)
+            .emitStatement("%1$s realmSource = (%1$s) realmObject", interfaceName);
+
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String setter = metadata.getInternalSetter(fieldName);
@@ -1662,6 +1707,9 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
                         .emitStatement("unmanaged%sList.add(item)", fieldName)
                         .endControlFlow()
                         .endControlFlow();
+            } else if (Utils.isMutableRealmInteger(field)) {
+                // If the user initializes the unmanaged MutableRealmInteger to null, this will fail mysteriously.
+                writer.emitStatement("unmanagedCopy.%s().set(realmSource.%s().get())", getter, getter);
             } else {
                 writer.emitStatement("unmanagedCopy.%s(realmSource.%s())", setter, getter);
             }
@@ -1730,6 +1778,8 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
                         .endControlFlow()
                         .endControlFlow();
 
+            } else if (Utils.isMutableRealmInteger(field)) {
+                writer.emitStatement("realmObjectTarget.%s().set(realmObjectSource.%s().get())", getter, getter);
             } else {
                 if (field != metadata.getPrimaryKey()) {
                     writer.emitStatement("realmObjectTarget.%s(realmObjectSource.%s())", setter, getter);
@@ -1773,6 +1823,8 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
                 writer.emitStatement("stringBuilder.append(\"RealmList<%s>[\").append(%s().size()).append(\"]\")",
                         genericTypeSimpleName,
                         metadata.getInternalGetter(fieldName));
+            } else if (Utils.isMutableRealmInteger(field)) {
+                writer.emitStatement("stringBuilder.append(%s().get())", metadata.getInternalGetter(fieldName));
             } else {
                 if (metadata.isNullable(field)) {
                     writer.emitStatement("stringBuilder.append(%s() != null ? %s() : \"null\")",
@@ -1846,8 +1898,7 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
                 .emitStatement("if (proxyState.getRow$realm().getIndex() != %s.proxyState.getRow$realm().getIndex()) return false", otherObjectVarName)
                 .emitEmptyLine()
                 .emitStatement("return true")
-                .endMethod()
-                .emitEmptyLine();
+                .endMethod();
     }
     //@formatter:on
 
@@ -1876,50 +1927,55 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
         } else {
             String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
             writer
-                    .emitStatement("%s obj = null", qualifiedClassName)
-                    .beginControlFlow("if (update)")
+                .emitStatement("%s obj = null", qualifiedClassName)
+                .beginControlFlow("if (update)")
                     .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
                     .emitStatement("long pkColumnIndex = table.getPrimaryKey()")
                     .emitStatement("long rowIndex = Table.NO_MATCH");
             if (metadata.isNullable(metadata.getPrimaryKey())) {
                 writer
-                        .beginControlFlow("if (json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
+                    .beginControlFlow("if (json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
                         .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
-                        .nextControlFlow("else")
-                        .emitStatement("rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
+                    .nextControlFlow("else")
+                        .emitStatement(
+                                "rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
                                 pkType, pkType, metadata.getPrimaryKey().getSimpleName())
-                        .endControlFlow();
+                    .endControlFlow();
             } else {
                 writer
-                        .beginControlFlow("if (!json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
-                        .emitStatement("rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
+                    .beginControlFlow("if (!json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
+                        .emitStatement(
+                                "rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
                                 pkType, pkType, metadata.getPrimaryKey().getSimpleName())
-                        .endControlFlow();
+                    .endControlFlow();
             }
             writer
-                    .beginControlFlow("if (rowIndex != Table.NO_MATCH)")
+                .beginControlFlow("if (rowIndex != Table.NO_MATCH)")
                     .emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
                     .beginControlFlow("try")
-                    .emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex)," +
-                            " realm.getSchema().getColumnInfo(%s.class)," +
-                            " false, Collections.<String> emptyList())", qualifiedClassName)
-                    .emitStatement("obj = new %s()", qualifiedGeneratedClassName)
+                        .emitStatement(
+                                "objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())",
+                                qualifiedClassName)
+                        .emitStatement("obj = new %s()", qualifiedGeneratedClassName)
                     .nextControlFlow("finally")
-                    .emitStatement("objectContext.clear()")
+                        .emitStatement("objectContext.clear()")
                     .endControlFlow()
-                    .endControlFlow()
-                    .endControlFlow();
+                .endControlFlow()
+            .endControlFlow();
 
             writer.beginControlFlow("if (obj == null)");
             buildExcludeFieldsList(writer, metadata.getFields());
             String primaryKeyFieldType = metadata.getPrimaryKey().asType().toString();
             String primaryKeyFieldName = metadata.getPrimaryKey().getSimpleName().toString();
-            RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedClassName, qualifiedGeneratedClassName,
-                    primaryKeyFieldType, primaryKeyFieldName, writer);
+            RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(
+                    qualifiedClassName, qualifiedGeneratedClassName, primaryKeyFieldType, primaryKeyFieldName, writer);
             writer.endControlFlow();
         }
         //@formatter:on
 
+        writer
+                .emitEmptyLine()
+                .emitStatement("final %1$s objProxy = (%1$s) obj", interfaceName);
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String qualifiedFieldType = field.asType().toString();
@@ -1929,7 +1985,7 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
             }
             if (Utils.isRealmModel(field)) {
                 RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(
-                        interfaceName,
+                        "objProxy",
                         metadata.getInternalSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
@@ -1939,7 +1995,7 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
 
             } else if (Utils.isRealmList(field)) {
                 RealmJsonTypeHelper.emitFillRealmListWithJsonValue(
-                        interfaceName,
+                        "objProxy",
                         metadata.getInternalGetter(fieldName),
                         metadata.getInternalSetter(fieldName),
                         fieldName,
@@ -1947,9 +2003,17 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
                         Utils.getProxyClassSimpleName(field),
                         writer);
 
+            } else if (Utils.isMutableRealmInteger(field)) {
+                RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
+                        "objProxy",
+                        metadata.getInternalGetter(fieldName),
+                        fieldName,
+                        qualifiedFieldType,
+                        writer);
+
             } else {
                 RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
-                        interfaceName,
+                        "objProxy",
                         metadata.getInternalSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
@@ -1989,12 +2053,12 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         if (metadata.hasPrimaryKey()) {
             writer.emitStatement("boolean jsonHasPrimaryKey = false");
         }
-        writer.emitStatement("%s obj = new %s()", qualifiedClassName, qualifiedClassName);
+        writer.emitStatement("final %s obj = new %s()", qualifiedClassName, qualifiedClassName);
+        writer.emitStatement("final %1$s objProxy = (%1$s) obj", interfaceName);
         writer.emitStatement("reader.beginObject()");
         writer.beginControlFlow("while (reader.hasNext())");
         writer.emitStatement("String name = reader.nextName()");
         writer.beginControlFlow("if (false)");
-
         Collection<VariableElement> fields = metadata.getFields();
         for (VariableElement field : fields) {
             String fieldName = field.getSimpleName().toString();
@@ -2003,7 +2067,7 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
 
             if (Utils.isRealmModel(field)) {
                 RealmJsonTypeHelper.emitFillRealmObjectFromStream(
-                        interfaceName,
+                        "objProxy",
                         metadata.getInternalSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
@@ -2013,17 +2077,27 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
 
             } else if (Utils.isRealmList(field)) {
                 RealmJsonTypeHelper.emitFillRealmListFromStream(
-                        interfaceName,
+                        "objProxy",
                         metadata.getInternalGetter(fieldName),
                         metadata.getInternalSetter(fieldName),
                         ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
                         Utils.getProxyClassSimpleName(field),
                         writer);
 
+            } else if (Utils.isMutableRealmInteger(field)) {
+                RealmJsonTypeHelper.emitFillJavaTypeFromStream(
+                        "objProxy",
+                        metadata,
+                        metadata.getInternalGetter(fieldName),
+                        fieldName,
+                        qualifiedFieldType,
+                        writer
+                );
             } else {
                 RealmJsonTypeHelper.emitFillJavaTypeFromStream(
-                        interfaceName,
+                        "objProxy",
                         metadata,
+                        metadata.getInternalSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
                         writer
@@ -2044,8 +2118,7 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
                     .endControlFlow();
         }
 
-        writer.emitStatement("obj = realm.copyToRealm(obj)");
-        writer.emitStatement("return obj");
+        writer.emitStatement("return realm.copyToRealm(obj)");
         writer.endMethod();
         writer.emitEmptyLine();
     }
@@ -2062,6 +2135,10 @@ private String columnIndexVarName(VariableElement variableElement) {
         return variableElement.getSimpleName().toString() + "Index";
     }
 
+    private String mutableRealmIntegerFieldName(VariableElement variableElement) {
+        return variableElement.getSimpleName().toString() + "MutableRealmInteger";
+    }
+
     private String fieldIndexVariableReference(VariableElement variableElement) {
         return "columnInfo." + columnIndexVarName(variableElement);
     }
@@ -2082,6 +2159,9 @@ private static int countModelOrListFields(Collection<VariableElement> fields) {
         if (type != null) {
             return type;
         }
+        if (Utils.isMutableRealmInteger(field)) {
+            return Constants.RealmFieldType.REALM_INTEGER;
+        }
         if (Utils.isRealmModel(field)) {
             return Constants.RealmFieldType.OBJECT;
         }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
index ab60954f91..ebe68a616c 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
@@ -54,24 +54,29 @@ public void generate() throws IOException {
                 .emitEmptyLine()
                 .beginType(qualifiedGeneratedInterfaceName, "interface", EnumSet.of(Modifier.PUBLIC));
         for (VariableElement field : metaData.getFields()) {
-            // The field is neither static nor ignored
-            if (!field.getModifiers().contains(Modifier.STATIC) && field.getAnnotation(Ignore.class) == null) {
-                String fieldName = field.getSimpleName().toString();
-                String fieldTypeCanonicalName = field.asType().toString();
-                writer
-                        .beginMethod(
-                                fieldTypeCanonicalName,
-                                metaData.getInternalGetter(fieldName),
-                                EnumSet.of(Modifier.PUBLIC))
-                        .endMethod()
-                        .beginMethod(
-                                "void",
-                                metaData.getInternalSetter(fieldName),
-                                EnumSet.of(Modifier.PUBLIC),
-                                fieldTypeCanonicalName,
-                                "value")
-                        .endMethod();
+            if (field.getModifiers().contains(Modifier.STATIC) || (field.getAnnotation(Ignore.class) != null)) {
+                continue;
             }
+            // The field is neither static nor ignored
+            String fieldName = field.getSimpleName().toString();
+            String fieldTypeCanonicalName = field.asType().toString();
+            writer
+                    .beginMethod(
+                            fieldTypeCanonicalName,
+                            metaData.getInternalGetter(fieldName),
+                            EnumSet.of(Modifier.PUBLIC))
+                    .endMethod();
+
+            // MutableRealmIntegers do not have setters.
+            if (Utils.isMutableRealmInteger(field)) { continue; }
+            writer
+                    .beginMethod(
+                            "void",
+                            metaData.getInternalSetter(fieldName),
+                            EnumSet.of(Modifier.PUBLIC),
+                            fieldTypeCanonicalName,
+                            "value")
+                    .endMethod();
         }
 
         // backlinks are final and have only a getter.
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
index 4b157b4404..5d08a68c25 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
@@ -12,6 +12,7 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
@@ -23,20 +24,23 @@
 
     public static Types typeUtils;
     private static Messager messager;
+    private static TypeMirror realmInteger;
     private static DeclaredType realmList;
     private static DeclaredType realmResults;
     private static DeclaredType markerInterface;
     private static TypeMirror realmModel;
 
     public static void initialize(ProcessingEnvironment env) {
+        Elements elementUtils = env.getElementUtils();
         typeUtils = env.getTypeUtils();
         messager = env.getMessager();
-        realmList = typeUtils.getDeclaredType(env.getElementUtils().getTypeElement("io.realm.RealmList"),
-                typeUtils.getWildcardType(null, null));
-        realmResults = typeUtils.getDeclaredType(env.getElementUtils().getTypeElement("io.realm.RealmResults"),
-                typeUtils.getWildcardType(null, null));
-        realmModel = env.getElementUtils().getTypeElement("io.realm.RealmModel").asType();
-        markerInterface = env.getTypeUtils().getDeclaredType(env.getElementUtils().getTypeElement("io.realm.RealmModel"));
+        realmInteger = elementUtils.getTypeElement("io.realm.MutableRealmInteger").asType();
+        realmList = typeUtils.getDeclaredType(
+                elementUtils.getTypeElement("io.realm.RealmList"), typeUtils.getWildcardType(null, null));
+        realmResults = typeUtils.getDeclaredType(
+                env.getElementUtils().getTypeElement("io.realm.RealmResults"), typeUtils.getWildcardType(null, null));
+        realmModel = elementUtils.getTypeElement("io.realm.RealmModel").asType();
+        markerInterface = typeUtils.getDeclaredType(elementUtils.getTypeElement("io.realm.RealmModel"));
     }
 
     /**
@@ -146,6 +150,13 @@ public static boolean isImplementingMarkerInterface(Element classElement) {
         return typeUtils.isAssignable(classElement.asType(), markerInterface);
     }
 
+    /**
+     * @return {@code true} if a given field type is {@code MutableRealmInteger}, {@code false} otherwise.
+     */
+    public static boolean isMutableRealmInteger(VariableElement field) {
+        return typeUtils.isAssignable(field.asType(), realmInteger);
+    }
+
     /**
      * @return {@code true} if a given field type is {@code RealmList}, {@code false} otherwise.
      */
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
index 243336069f..cfe0397ecd 100644
--- a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
@@ -69,6 +69,12 @@
     private JavaFileObject backlinksNotFound = JavaFileObjects.forResource("some/test/Backlinks_NotFound.java");
     private JavaFileObject backlinksNonFinalField = JavaFileObjects.forResource("some/test/Backlinks_NotFinal.java");
     private JavaFileObject backlinksWrongType = JavaFileObjects.forResource("some/test/Backlinks_WrongType.java");
+    private JavaFileObject counter = JavaFileObjects.forResource("some/test/Counter.java");
+    private JavaFileObject counterIgnored = JavaFileObjects.forResource("some/test/Counter_Ignored.java");
+    private JavaFileObject counterIndexed = JavaFileObjects.forResource("some/test/Counter_Indexed.java");
+    private JavaFileObject counterPK = JavaFileObjects.forResource("some/test/Counter_PK.java");
+    private JavaFileObject counterRequired = JavaFileObjects.forResource("some/test/Counter_Required.java");
+    private JavaFileObject counterStatic = JavaFileObjects.forResource("some/test/Counter_Static.java");
     private JavaFileObject nonLatinName = JavaFileObjects.forResource("some/test/ÁrvíztűrőTükörfúrógép.java");
 
     @Test
@@ -94,7 +100,9 @@ public void compileProcessedEmptyFile() throws Exception {
                 .failsToCompile();
     }
 
-    // Disabled because it does not seem to find the generated interface file @Test
+    // FIXME: @Ignore("Disabled because it does not seem to find the generated interface file")
+    @Ignore("Disabled because it does not seem to find the generated interface file")
+    @Test
     public void compileSimpleProxyFile() throws Exception {
         ASSERT.about(javaSource())
                 .that(simpleProxy)
@@ -478,6 +486,54 @@ public void compileWithInterfaceForObject() {
                 .failsToCompile();
     }
 
+    @Test
+    public void compileMutableRealmInteger() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(counter))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileIgnoredMutableRealmInteger() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(counterIgnored))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileIndexedMutableRealmInteger() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(counterIndexed))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void failOnPKMutableRealmInteger() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(counterPK))
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    @Test
+    public void compileRequiredMutableRealmInteger() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(counterRequired))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileStaticMutableRealmInteger() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(counterStatic))
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
     @Test
     public void compileBacklinks() {
         ASSERT.about(javaSources())
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index aec70877a3..734f53b8a3 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -33,7 +33,7 @@
 
 @SuppressWarnings("all")
 public class AllTypesRealmProxy extends some.test.AllTypes
-        implements RealmObjectProxy, AllTypesRealmProxyInterface {
+    implements RealmObjectProxy, AllTypesRealmProxyInterface {
 
     static final class AllTypesColumnInfo extends ColumnInfo {
         long columnStringIndex;
@@ -43,11 +43,12 @@
         long columnBooleanIndex;
         long columnDateIndex;
         long columnBinaryIndex;
+        long columnMutableRealmIntegerIndex;
         long columnObjectIndex;
         long columnRealmListIndex;
 
         AllTypesColumnInfo(SharedRealm realm, Table table) {
-            super(9);
+            super(10);
             this.columnStringIndex = addColumnDetails(table, "columnString", RealmFieldType.STRING);
             this.columnLongIndex = addColumnDetails(table, "columnLong", RealmFieldType.INTEGER);
             this.columnFloatIndex = addColumnDetails(table, "columnFloat", RealmFieldType.FLOAT);
@@ -55,6 +56,7 @@
             this.columnBooleanIndex = addColumnDetails(table, "columnBoolean", RealmFieldType.BOOLEAN);
             this.columnDateIndex = addColumnDetails(table, "columnDate", RealmFieldType.DATE);
             this.columnBinaryIndex = addColumnDetails(table, "columnBinary", RealmFieldType.BINARY);
+            this.columnMutableRealmIntegerIndex = addColumnDetails(table, "columnMutableRealmInteger", RealmFieldType.INTEGER);
             this.columnObjectIndex = addColumnDetails(table, "columnObject", RealmFieldType.OBJECT);
             this.columnRealmListIndex = addColumnDetails(table, "columnRealmList", RealmFieldType.LIST);
             addBacklinkDetails(realm, "parentObjects", "AllTypes", "columnObject");
@@ -81,6 +83,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
             dst.columnBooleanIndex = src.columnBooleanIndex;
             dst.columnDateIndex = src.columnDateIndex;
             dst.columnBinaryIndex = src.columnBinaryIndex;
+            dst.columnMutableRealmIntegerIndex = src.columnMutableRealmIntegerIndex;
             dst.columnObjectIndex = src.columnObjectIndex;
             dst.columnRealmListIndex = src.columnRealmListIndex;
         }
@@ -97,6 +100,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         fieldNames.add("columnBoolean");
         fieldNames.add("columnDate");
         fieldNames.add("columnBinary");
+        fieldNames.add("columnMutableRealmInteger");
         fieldNames.add("columnObject");
         fieldNames.add("columnRealmList");
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
@@ -104,6 +108,10 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
 
     private AllTypesColumnInfo columnInfo;
     private ProxyState<some.test.AllTypes> proxyState;
+    private final MutableRealmInteger.Managed columnMutableRealmIntegerMutableRealmInteger = new MutableRealmInteger.Managed<some.test.AllTypes>() {
+                @Override protected ProxyState<some.test.AllTypes> getProxyState() { return proxyState; }
+                @Override protected long getColumnIndex() { return columnInfo.columnMutableRealmIntegerIndex; }
+            };
     private RealmList<some.test.AllTypes> columnRealmListRealmList;
     private RealmResults<some.test.AllTypes> parentObjectsBacklinks;
 
@@ -287,6 +295,12 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         proxyState.getRow$realm().setBinaryByteArray(columnInfo.columnBinaryIndex, value);
     }
 
+    @Override
+    public MutableRealmInteger realmGet$columnMutableRealmInteger() {
+        proxyState.getRealm$realm().checkIfValid();
+        return this.columnMutableRealmIntegerMutableRealmInteger;
+    }
+
     @Override
     public some.test.AllTypes realmGet$columnObject() {
         proxyState.getRealm$realm().checkIfValid();
@@ -335,7 +349,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
             throw new IllegalArgumentException("'value' belongs to a different Realm.");
         }
-        proxyState.getRow$realm().setLink(columnInfo.columnObjectIndex, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex());
+        proxyState.getRow$realm().setLink(columnInfo.columnObjectIndex, ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex());
     }
 
     @Override
@@ -411,6 +425,7 @@ private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
         builder.addProperty("columnBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
         builder.addProperty("columnDate", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
         builder.addProperty("columnBinary", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("columnMutableRealmInteger", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
         builder.addLinkedProperty("columnObject", RealmFieldType.OBJECT, "AllTypes");
         builder.addLinkedProperty("columnRealmList", RealmFieldType.LIST, "AllTypes");
         return builder.build();
@@ -426,14 +441,14 @@ public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean
         }
         Table table = sharedRealm.getTable("class_AllTypes");
         final long columnCount = table.getColumnCount();
-        if (columnCount != 9) {
-            if (columnCount < 9) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 9 but was " + columnCount);
+        if (columnCount != 10) {
+            if (columnCount < 10) {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 10 but was " + columnCount);
             }
             if (allowExtraColumns) {
-                RealmLog.debug("Field count is more than expected - expected 9 but was %1$d", columnCount);
+                RealmLog.debug("Field count is more than expected - expected 10 but was %1$d", columnCount);
             } else {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 9 but was " + columnCount);
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 10 but was " + columnCount);
             }
         }
         Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
@@ -482,21 +497,25 @@ public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean
         if (table.isColumnNullable(columnInfo.columnBinaryIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBinary' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnBinary' or migrate using RealmObjectSchema.setNullable().");
         }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnMutableRealmInteger", RealmFieldType.INTEGER, "MutableRealmInteger");
+        if (!table.isColumnNullable(columnInfo.columnMutableRealmIntegerIndex)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnMutableRealmInteger' is required. Either set @Required to field 'columnMutableRealmInteger' or migrate using RealmObjectSchema.setNullable().");
+        }
         ProxyUtils.verifyField(sharedRealm, columnTypes, "columnObject", RealmFieldType.OBJECT, "AllTypes");
         if (!sharedRealm.hasTable("class_AllTypes")) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnObject'");
         }
-        Table table_7 = sharedRealm.getTable("class_AllTypes");
-        if (!table.getLinkTarget(columnInfo.columnObjectIndex).hasSameSchema(table_7)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'columnObject': '" + table.getLinkTarget(columnInfo.columnObjectIndex).getName() + "' expected - was '" + table_7.getName() + "'");
+        Table table_8 = sharedRealm.getTable("class_AllTypes");
+        if (!table.getLinkTarget(columnInfo.columnObjectIndex).hasSameSchema(table_8)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'columnObject': '" + table.getLinkTarget(columnInfo.columnObjectIndex).getName() + "' expected - was '" + table_8.getName() + "'");
         }
         ProxyUtils.verifyField(sharedRealm, columnTypes, "columnRealmList", RealmFieldType.LIST, "AllTypes");
         if (!sharedRealm.hasTable("class_AllTypes")) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnRealmList'");
         }
-        Table table_8 = sharedRealm.getTable("class_AllTypes");
-        if (!table.getLinkTarget(columnInfo.columnRealmListIndex).hasSameSchema(table_8)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmList type for field 'columnRealmList': '" + table.getLinkTarget(columnInfo.columnRealmListIndex).getName() + "' expected - was '" + table_8.getName() + "'");
+        Table table_9 = sharedRealm.getTable("class_AllTypes");
+        if (!table.getLinkTarget(columnInfo.columnRealmListIndex).hasSameSchema(table_9)) {
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmList type for field 'columnRealmList': '" + table.getLinkTarget(columnInfo.columnRealmListIndex).getName() + "' expected - was '" + table_9.getName() + "'");
         }
 
         long backlinkFieldIndex;
@@ -533,7 +552,7 @@ public static String getTableName() {
 
     @SuppressWarnings("cast")
     public static some.test.AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
-            throws JSONException {
+        throws JSONException {
         final List<String> excludeFields = new ArrayList<String>(2);
         some.test.AllTypes obj = null;
         if (update) {
@@ -572,70 +591,75 @@ public static String getTableName() {
                 throw new IllegalArgumentException("JSON object doesn't have the primary key field 'columnString'.");
             }
         }
+
+        final AllTypesRealmProxyInterface objProxy = (AllTypesRealmProxyInterface) obj;
         if (json.has("columnLong")) {
             if (json.isNull("columnLong")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'columnLong' to null.");
             } else {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnLong((long) json.getLong("columnLong"));
+                objProxy.realmSet$columnLong((long) json.getLong("columnLong"));
             }
         }
         if (json.has("columnFloat")) {
             if (json.isNull("columnFloat")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'columnFloat' to null.");
             } else {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnFloat((float) json.getDouble("columnFloat"));
+                objProxy.realmSet$columnFloat((float) json.getDouble("columnFloat"));
             }
         }
         if (json.has("columnDouble")) {
             if (json.isNull("columnDouble")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'columnDouble' to null.");
             } else {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnDouble((double) json.getDouble("columnDouble"));
+                objProxy.realmSet$columnDouble((double) json.getDouble("columnDouble"));
             }
         }
         if (json.has("columnBoolean")) {
             if (json.isNull("columnBoolean")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'columnBoolean' to null.");
             } else {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnBoolean((boolean) json.getBoolean("columnBoolean"));
+                objProxy.realmSet$columnBoolean((boolean) json.getBoolean("columnBoolean"));
             }
         }
         if (json.has("columnDate")) {
             if (json.isNull("columnDate")) {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(null);
+                objProxy.realmSet$columnDate(null);
             } else {
                 Object timestamp = json.get("columnDate");
                 if (timestamp instanceof String) {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(JsonUtils.stringToDate((String) timestamp));
+                    objProxy.realmSet$columnDate(JsonUtils.stringToDate((String) timestamp));
                 } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(new Date(json.getLong("columnDate")));
+                    objProxy.realmSet$columnDate(new Date(json.getLong("columnDate")));
                 }
             }
         }
         if (json.has("columnBinary")) {
             if (json.isNull("columnBinary")) {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnBinary(null);
+                objProxy.realmSet$columnBinary(null);
             } else {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnBinary(JsonUtils.stringToBytes(json.getString("columnBinary")));
+                objProxy.realmSet$columnBinary(JsonUtils.stringToBytes(json.getString("columnBinary")));
             }
         }
+        if (json.has("columnMutableRealmInteger")) {
+            objProxy.realmGet$columnMutableRealmInteger().set((json.isNull("columnMutableRealmInteger")) ? null : json.getLong("columnMutableRealmInteger"));
+        }
         if (json.has("columnObject")) {
             if (json.isNull("columnObject")) {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnObject(null);
+                objProxy.realmSet$columnObject(null);
             } else {
                 some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json.getJSONObject("columnObject"), update);
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnObject(columnObjectObj);
+                objProxy.realmSet$columnObject(columnObjectObj);
             }
         }
         if (json.has("columnRealmList")) {
             if (json.isNull("columnRealmList")) {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnRealmList(null);
+                objProxy.realmSet$columnRealmList(null);
             } else {
-                ((AllTypesRealmProxyInterface) obj).realmGet$columnRealmList().clear();
+                objProxy.realmGet$columnRealmList().clear();
                 JSONArray array = json.getJSONArray("columnRealmList");
                 for (int i = 0; i < array.length(); i++) {
                     some.test.AllTypes item = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update);
-                    ((AllTypesRealmProxyInterface) obj).realmGet$columnRealmList().add(item);
+                    objProxy.realmGet$columnRealmList().add(item);
                 }
             }
         }
@@ -645,86 +669,95 @@ public static String getTableName() {
     @SuppressWarnings("cast")
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public static some.test.AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
-            throws IOException {
+        throws IOException {
         boolean jsonHasPrimaryKey = false;
-        some.test.AllTypes obj = new some.test.AllTypes();
+        final some.test.AllTypes obj = new some.test.AllTypes();
+        final AllTypesRealmProxyInterface objProxy = (AllTypesRealmProxyInterface) obj;
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
             if (false) {
             } else if (name.equals("columnString")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnString(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$columnString((String) reader.nextString());
                 } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnString((String) reader.nextString());
+                    reader.skipValue();
+                    objProxy.realmSet$columnString(null);
                 }
                 jsonHasPrimaryKey = true;
             } else if (name.equals("columnLong")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$columnLong((long) reader.nextLong());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'columnLong' to null.");
-                } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnLong((long) reader.nextLong());
                 }
             } else if (name.equals("columnFloat")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$columnFloat((float) reader.nextDouble());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'columnFloat' to null.");
-                } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnFloat((float) reader.nextDouble());
                 }
             } else if (name.equals("columnDouble")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$columnDouble((double) reader.nextDouble());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'columnDouble' to null.");
-                } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnDouble((double) reader.nextDouble());
                 }
             } else if (name.equals("columnBoolean")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$columnBoolean((boolean) reader.nextBoolean());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'columnBoolean' to null.");
-                } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnBoolean((boolean) reader.nextBoolean());
                 }
             } else if (name.equals("columnDate")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(null);
+                    objProxy.realmSet$columnDate(null);
                 } else if (reader.peek() == JsonToken.NUMBER) {
                     long timestamp = reader.nextLong();
                     if (timestamp > -1) {
-                        ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(new Date(timestamp));
+                        objProxy.realmSet$columnDate(new Date(timestamp));
                     }
                 } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(JsonUtils.stringToDate(reader.nextString()));
+                    objProxy.realmSet$columnDate(JsonUtils.stringToDate(reader.nextString()));
                 }
             } else if (name.equals("columnBinary")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$columnBinary(JsonUtils.stringToBytes(reader.nextString()));
+                } else {
                     reader.skipValue();
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnBinary(null);
+                    objProxy.realmSet$columnBinary(null);
+                }
+            } else if (name.equals("columnMutableRealmInteger")) {
+                Long val = null;
+                if (reader.peek() != JsonToken.NULL) {
+                    val = reader.nextLong()
                 } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnBinary(JsonUtils.stringToBytes(reader.nextString()));
+                    reader.skipValue();
                 }
+                objProxy.realmGet$columnMutableRealmInteger().set(val);
             } else if (name.equals("columnObject")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnObject(null);
+                    objProxy.realmSet$columnObject(null);
                 } else {
                     some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnObject(columnObjectObj);
+                    objProxy.realmSet$columnObject(columnObjectObj);
                 }
             } else if (name.equals("columnRealmList")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnRealmList(null);
+                    objProxy.realmSet$columnRealmList(null);
                 } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnRealmList(new RealmList<some.test.AllTypes>());
+                    objProxy.realmSet$columnRealmList(new RealmList<some.test.AllTypes>());
                     reader.beginArray();
                     while (reader.hasNext()) {
                         some.test.AllTypes item = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
-                        ((AllTypesRealmProxyInterface) obj).realmGet$columnRealmList().add(item);
+                        objProxy.realmGet$columnRealmList().add(item);
                     }
                     reader.endArray();
                 }
@@ -736,16 +769,18 @@ public static String getTableName() {
         if (!jsonHasPrimaryKey) {
             throw new IllegalArgumentException("JSON object doesn't have the primary key field 'columnString'.");
         }
-        obj = realm.copyToRealm(obj);
-        return obj;
+        return realm.copyToRealm(obj);
     }
 
     public static some.test.AllTypes copyOrUpdate(Realm realm, some.test.AllTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
-            throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
-        }
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-            return object;
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
+            final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
+            if (otherRealm.threadId != realm.threadId) {
+                throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+            }
+            if (otherRealm.getPath().equals(realm.getPath())) {
+                return object;
+            }
         }
         final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
         RealmObjectProxy cachedRealmObject = cache.get(object);
@@ -765,7 +800,9 @@ public static String getTableName() {
             } else {
                 rowIndex = table.findFirstString(pkColumnIndex, value);
             }
-            if (rowIndex != Table.NO_MATCH) {
+            if (rowIndex == Table.NO_MATCH) {
+                canUpdate = false;
+            } else {
                 try {
                     objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
                     realmObject = new io.realm.AllTypesRealmProxy();
@@ -773,16 +810,10 @@ public static String getTableName() {
                 } finally {
                     objectContext.clear();
                 }
-            } else {
-                canUpdate = false;
             }
         }
 
-        if (canUpdate) {
-            return update(realm, realmObject, object, cache);
-        } else {
-            return copy(realm, object, update, cache);
-        }
+        return (canUpdate) ? update(realm, realmObject, object, cache) : copy(realm, object, update, cache);
     }
 
     public static some.test.AllTypes copy(Realm realm, some.test.AllTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
@@ -805,6 +836,8 @@ public static String getTableName() {
         realmObjectCopy.realmSet$columnDate(realmObjectSource.realmGet$columnDate());
         realmObjectCopy.realmSet$columnBinary(realmObjectSource.realmGet$columnBinary());
 
+        realmObjectCopy.realmGet$columnMutableRealmInteger().set(realmObjectSource.realmGet$columnMutableRealmInteger().get());
+
         some.test.AllTypes columnObjectObj = realmObjectSource.realmGet$columnObject();
         if (columnObjectObj == null) {
             realmObjectCopy.realmSet$columnObject(null);
@@ -867,6 +900,10 @@ public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel
         if (realmGet$columnBinary != null) {
             Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
         }
+        Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
+        if (realmGet$columnMutableRealmInteger != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
+        }
 
         some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
         if (columnObjectObj != null) {
@@ -888,7 +925,6 @@ public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel
                 LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
             }
         }
-
         return rowIndex;
     }
 
@@ -932,6 +968,10 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
             if (realmGet$columnBinary != null) {
                 Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
             }
+            Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
+            if (realmGet$columnMutableRealmInteger != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
+            }
 
             some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
             if (columnObjectObj != null) {
@@ -991,6 +1031,12 @@ public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<Re
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, false);
         }
+        Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
+        if (realmGet$columnMutableRealmInteger != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, false);
+        }
 
         some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
         if (columnObjectObj != null) {
@@ -1061,6 +1107,12 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
             } else {
                 Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, false);
             }
+            Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
+            if (realmGet$columnMutableRealmInteger != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, false);
+            }
 
             some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
             if (columnObjectObj != null) {
@@ -1115,6 +1167,7 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
         unmanagedCopy.realmSet$columnBoolean(realmSource.realmGet$columnBoolean());
         unmanagedCopy.realmSet$columnDate(realmSource.realmGet$columnDate());
         unmanagedCopy.realmSet$columnBinary(realmSource.realmGet$columnBinary());
+        unmanagedCopy.realmGet$columnMutableRealmInteger().set(realmSource.realmGet$columnMutableRealmInteger().get());
 
         // Deep copy of columnObject
         unmanagedCopy.realmSet$columnObject(AllTypesRealmProxy.createDetachedCopy(realmSource.realmGet$columnObject(), currentDepth + 1, maxDepth, cache));
@@ -1145,6 +1198,7 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
         realmObjectTarget.realmSet$columnBoolean(realmObjectSource.realmGet$columnBoolean());
         realmObjectTarget.realmSet$columnDate(realmObjectSource.realmGet$columnDate());
         realmObjectTarget.realmSet$columnBinary(realmObjectSource.realmGet$columnBinary());
+        realmObjectTarget.realmGet$columnMutableRealmInteger().set(realmObjectSource.realmGet$columnMutableRealmInteger().get());
         some.test.AllTypes columnObjectObj = realmObjectSource.realmGet$columnObject();
         if (columnObjectObj == null) {
             realmObjectTarget.realmSet$columnObject(null);
@@ -1208,6 +1262,10 @@ public String toString() {
         stringBuilder.append(realmGet$columnBinary());
         stringBuilder.append("}");
         stringBuilder.append(",");
+        stringBuilder.append("{columnMutableRealmInteger:");
+        stringBuilder.append(realmGet$columnMutableRealmInteger().get());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
         stringBuilder.append("{columnObject:");
         stringBuilder.append(realmGet$columnObject() != null ? "AllTypes" : "null");
         stringBuilder.append("}");
@@ -1255,5 +1313,4 @@ public boolean equals(Object o) {
 
         return true;
     }
-
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index 6d35d67351..b7965d3586 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -262,32 +262,33 @@ public static String getTableName() {
             throws JSONException {
         final List<String> excludeFields = Collections.<String> emptyList();
         some.test.Booleans obj = realm.createObjectInternal(some.test.Booleans.class, true, excludeFields);
+        final BooleansRealmProxyInterface objProxy = (BooleansRealmProxyInterface) obj;
         if (json.has("done")) {
             if (json.isNull("done")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'done' to null.");
             } else {
-                ((BooleansRealmProxyInterface) obj).realmSet$done((boolean) json.getBoolean("done"));
+                objProxy.realmSet$done((boolean) json.getBoolean("done"));
             }
         }
         if (json.has("isReady")) {
             if (json.isNull("isReady")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'isReady' to null.");
             } else {
-                ((BooleansRealmProxyInterface) obj).realmSet$isReady((boolean) json.getBoolean("isReady"));
+                objProxy.realmSet$isReady((boolean) json.getBoolean("isReady"));
             }
         }
         if (json.has("mCompleted")) {
             if (json.isNull("mCompleted")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'mCompleted' to null.");
             } else {
-                ((BooleansRealmProxyInterface) obj).realmSet$mCompleted((boolean) json.getBoolean("mCompleted"));
+                objProxy.realmSet$mCompleted((boolean) json.getBoolean("mCompleted"));
             }
         }
         if (json.has("anotherBoolean")) {
             if (json.isNull("anotherBoolean")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'anotherBoolean' to null.");
             } else {
-                ((BooleansRealmProxyInterface) obj).realmSet$anotherBoolean((boolean) json.getBoolean("anotherBoolean"));
+                objProxy.realmSet$anotherBoolean((boolean) json.getBoolean("anotherBoolean"));
             }
         }
         return obj;
@@ -297,54 +298,57 @@ public static String getTableName() {
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public static some.test.Booleans createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        some.test.Booleans obj = new some.test.Booleans();
+        final some.test.Booleans obj = new some.test.Booleans();
+        final BooleansRealmProxyInterface objProxy = (BooleansRealmProxyInterface) obj;
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
             if (false) {
             } else if (name.equals("done")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$done((boolean) reader.nextBoolean());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'done' to null.");
-                } else {
-                    ((BooleansRealmProxyInterface) obj).realmSet$done((boolean) reader.nextBoolean());
                 }
             } else if (name.equals("isReady")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$isReady((boolean) reader.nextBoolean());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'isReady' to null.");
-                } else {
-                    ((BooleansRealmProxyInterface) obj).realmSet$isReady((boolean) reader.nextBoolean());
                 }
             } else if (name.equals("mCompleted")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$mCompleted((boolean) reader.nextBoolean());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'mCompleted' to null.");
-                } else {
-                    ((BooleansRealmProxyInterface) obj).realmSet$mCompleted((boolean) reader.nextBoolean());
                 }
             } else if (name.equals("anotherBoolean")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$anotherBoolean((boolean) reader.nextBoolean());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'anotherBoolean' to null.");
-                } else {
-                    ((BooleansRealmProxyInterface) obj).realmSet$anotherBoolean((boolean) reader.nextBoolean());
                 }
             } else {
                 reader.skipValue();
             }
         }
         reader.endObject();
-        obj = realm.copyToRealm(obj);
-        return obj;
+        return realm.copyToRealm(obj);
     }
 
     public static some.test.Booleans copyOrUpdate(Realm realm, some.test.Booleans object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
-            throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
-        }
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-            return object;
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
+            final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
+            if (otherRealm.threadId != realm.threadId) {
+                throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+            }
+            if (otherRealm.getPath().equals(realm.getPath())) {
+                return object;
+            }
         }
         final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
         RealmObjectProxy cachedRealmObject = cache.get(object);
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index 2ff8b332ab..5aef17d6bd 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -989,162 +989,163 @@ public static String getTableName() {
             excludeFields.add("fieldObjectNull");
         }
         some.test.NullTypes obj = realm.createObjectInternal(some.test.NullTypes.class, true, excludeFields);
+        final NullTypesRealmProxyInterface objProxy = (NullTypesRealmProxyInterface) obj;
         if (json.has("fieldStringNotNull")) {
             if (json.isNull("fieldStringNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNotNull(null);
+                objProxy.realmSet$fieldStringNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNotNull((String) json.getString("fieldStringNotNull"));
+                objProxy.realmSet$fieldStringNotNull((String) json.getString("fieldStringNotNull"));
             }
         }
         if (json.has("fieldStringNull")) {
             if (json.isNull("fieldStringNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNull(null);
+                objProxy.realmSet$fieldStringNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNull((String) json.getString("fieldStringNull"));
+                objProxy.realmSet$fieldStringNull((String) json.getString("fieldStringNull"));
             }
         }
         if (json.has("fieldBooleanNotNull")) {
             if (json.isNull("fieldBooleanNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNotNull(null);
+                objProxy.realmSet$fieldBooleanNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNotNull((boolean) json.getBoolean("fieldBooleanNotNull"));
+                objProxy.realmSet$fieldBooleanNotNull((boolean) json.getBoolean("fieldBooleanNotNull"));
             }
         }
         if (json.has("fieldBooleanNull")) {
             if (json.isNull("fieldBooleanNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNull(null);
+                objProxy.realmSet$fieldBooleanNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNull((boolean) json.getBoolean("fieldBooleanNull"));
+                objProxy.realmSet$fieldBooleanNull((boolean) json.getBoolean("fieldBooleanNull"));
             }
         }
         if (json.has("fieldBytesNotNull")) {
             if (json.isNull("fieldBytesNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNotNull(null);
+                objProxy.realmSet$fieldBytesNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNotNull(JsonUtils.stringToBytes(json.getString("fieldBytesNotNull")));
+                objProxy.realmSet$fieldBytesNotNull(JsonUtils.stringToBytes(json.getString("fieldBytesNotNull")));
             }
         }
         if (json.has("fieldBytesNull")) {
             if (json.isNull("fieldBytesNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNull(null);
+                objProxy.realmSet$fieldBytesNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNull(JsonUtils.stringToBytes(json.getString("fieldBytesNull")));
+                objProxy.realmSet$fieldBytesNull(JsonUtils.stringToBytes(json.getString("fieldBytesNull")));
             }
         }
         if (json.has("fieldByteNotNull")) {
             if (json.isNull("fieldByteNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNotNull(null);
+                objProxy.realmSet$fieldByteNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNotNull((byte) json.getInt("fieldByteNotNull"));
+                objProxy.realmSet$fieldByteNotNull((byte) json.getInt("fieldByteNotNull"));
             }
         }
         if (json.has("fieldByteNull")) {
             if (json.isNull("fieldByteNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNull(null);
+                objProxy.realmSet$fieldByteNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNull((byte) json.getInt("fieldByteNull"));
+                objProxy.realmSet$fieldByteNull((byte) json.getInt("fieldByteNull"));
             }
         }
         if (json.has("fieldShortNotNull")) {
             if (json.isNull("fieldShortNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNotNull(null);
+                objProxy.realmSet$fieldShortNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNotNull((short) json.getInt("fieldShortNotNull"));
+                objProxy.realmSet$fieldShortNotNull((short) json.getInt("fieldShortNotNull"));
             }
         }
         if (json.has("fieldShortNull")) {
             if (json.isNull("fieldShortNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNull(null);
+                objProxy.realmSet$fieldShortNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNull((short) json.getInt("fieldShortNull"));
+                objProxy.realmSet$fieldShortNull((short) json.getInt("fieldShortNull"));
             }
         }
         if (json.has("fieldIntegerNotNull")) {
             if (json.isNull("fieldIntegerNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNotNull(null);
+                objProxy.realmSet$fieldIntegerNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNotNull((int) json.getInt("fieldIntegerNotNull"));
+                objProxy.realmSet$fieldIntegerNotNull((int) json.getInt("fieldIntegerNotNull"));
             }
         }
         if (json.has("fieldIntegerNull")) {
             if (json.isNull("fieldIntegerNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNull(null);
+                objProxy.realmSet$fieldIntegerNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNull((int) json.getInt("fieldIntegerNull"));
+                objProxy.realmSet$fieldIntegerNull((int) json.getInt("fieldIntegerNull"));
             }
         }
         if (json.has("fieldLongNotNull")) {
             if (json.isNull("fieldLongNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNotNull(null);
+                objProxy.realmSet$fieldLongNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNotNull((long) json.getLong("fieldLongNotNull"));
+                objProxy.realmSet$fieldLongNotNull((long) json.getLong("fieldLongNotNull"));
             }
         }
         if (json.has("fieldLongNull")) {
             if (json.isNull("fieldLongNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNull(null);
+                objProxy.realmSet$fieldLongNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNull((long) json.getLong("fieldLongNull"));
+                objProxy.realmSet$fieldLongNull((long) json.getLong("fieldLongNull"));
             }
         }
         if (json.has("fieldFloatNotNull")) {
             if (json.isNull("fieldFloatNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNotNull(null);
+                objProxy.realmSet$fieldFloatNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNotNull((float) json.getDouble("fieldFloatNotNull"));
+                objProxy.realmSet$fieldFloatNotNull((float) json.getDouble("fieldFloatNotNull"));
             }
         }
         if (json.has("fieldFloatNull")) {
             if (json.isNull("fieldFloatNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNull(null);
+                objProxy.realmSet$fieldFloatNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNull((float) json.getDouble("fieldFloatNull"));
+                objProxy.realmSet$fieldFloatNull((float) json.getDouble("fieldFloatNull"));
             }
         }
         if (json.has("fieldDoubleNotNull")) {
             if (json.isNull("fieldDoubleNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNotNull(null);
+                objProxy.realmSet$fieldDoubleNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNotNull((double) json.getDouble("fieldDoubleNotNull"));
+                objProxy.realmSet$fieldDoubleNotNull((double) json.getDouble("fieldDoubleNotNull"));
             }
         }
         if (json.has("fieldDoubleNull")) {
             if (json.isNull("fieldDoubleNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNull(null);
+                objProxy.realmSet$fieldDoubleNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNull((double) json.getDouble("fieldDoubleNull"));
+                objProxy.realmSet$fieldDoubleNull((double) json.getDouble("fieldDoubleNull"));
             }
         }
         if (json.has("fieldDateNotNull")) {
             if (json.isNull("fieldDateNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(null);
+                objProxy.realmSet$fieldDateNotNull(null);
             } else {
                 Object timestamp = json.get("fieldDateNotNull");
                 if (timestamp instanceof String) {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(JsonUtils.stringToDate((String) timestamp));
+                    objProxy.realmSet$fieldDateNotNull(JsonUtils.stringToDate((String) timestamp));
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(new Date(json.getLong("fieldDateNotNull")));
+                    objProxy.realmSet$fieldDateNotNull(new Date(json.getLong("fieldDateNotNull")));
                 }
             }
         }
         if (json.has("fieldDateNull")) {
             if (json.isNull("fieldDateNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(null);
+                objProxy.realmSet$fieldDateNull(null);
             } else {
                 Object timestamp = json.get("fieldDateNull");
                 if (timestamp instanceof String) {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(JsonUtils.stringToDate((String) timestamp));
+                    objProxy.realmSet$fieldDateNull(JsonUtils.stringToDate((String) timestamp));
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(new Date(json.getLong("fieldDateNull")));
+                    objProxy.realmSet$fieldDateNull(new Date(json.getLong("fieldDateNull")));
                 }
             }
         }
         if (json.has("fieldObjectNull")) {
             if (json.isNull("fieldObjectNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldObjectNull(null);
+                objProxy.realmSet$fieldObjectNull(null);
             } else {
                 some.test.NullTypes fieldObjectNullObj = NullTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json.getJSONObject("fieldObjectNull"), update);
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldObjectNull(fieldObjectNullObj);
+                objProxy.realmSet$fieldObjectNull(fieldObjectNullObj);
             }
         }
         return obj;
@@ -1154,184 +1155,187 @@ public static String getTableName() {
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public static some.test.NullTypes createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        some.test.NullTypes obj = new some.test.NullTypes();
+        final some.test.NullTypes obj = new some.test.NullTypes();
+        final NullTypesRealmProxyInterface objProxy = (NullTypesRealmProxyInterface) obj;
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
             if (false) {
             } else if (name.equals("fieldStringNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldStringNotNull((String) reader.nextString());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNotNull((String) reader.nextString());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldStringNotNull(null);
                 }
             } else if (name.equals("fieldStringNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldStringNull((String) reader.nextString());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNull((String) reader.nextString());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldStringNull(null);
                 }
             } else if (name.equals("fieldBooleanNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldBooleanNotNull((boolean) reader.nextBoolean());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNotNull((boolean) reader.nextBoolean());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldBooleanNotNull(null);
                 }
             } else if (name.equals("fieldBooleanNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldBooleanNull((boolean) reader.nextBoolean());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNull((boolean) reader.nextBoolean());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldBooleanNull(null);
                 }
             } else if (name.equals("fieldBytesNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldBytesNotNull(JsonUtils.stringToBytes(reader.nextString()));
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNotNull(JsonUtils.stringToBytes(reader.nextString()));
+                    reader.skipValue();
+                    objProxy.realmSet$fieldBytesNotNull(null);
                 }
             } else if (name.equals("fieldBytesNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldBytesNull(JsonUtils.stringToBytes(reader.nextString()));
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNull(JsonUtils.stringToBytes(reader.nextString()));
+                    reader.skipValue();
+                    objProxy.realmSet$fieldBytesNull(null);
                 }
             } else if (name.equals("fieldByteNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldByteNotNull((byte) reader.nextInt());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNotNull((byte) reader.nextInt());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldByteNotNull(null);
                 }
             } else if (name.equals("fieldByteNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldByteNull((byte) reader.nextInt());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNull((byte) reader.nextInt());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldByteNull(null);
                 }
             } else if (name.equals("fieldShortNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldShortNotNull((short) reader.nextInt());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNotNull((short) reader.nextInt());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldShortNotNull(null);
                 }
             } else if (name.equals("fieldShortNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldShortNull((short) reader.nextInt());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNull((short) reader.nextInt());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldShortNull(null);
                 }
             } else if (name.equals("fieldIntegerNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldIntegerNotNull((int) reader.nextInt());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNotNull((int) reader.nextInt());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldIntegerNotNull(null);
                 }
             } else if (name.equals("fieldIntegerNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldIntegerNull((int) reader.nextInt());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNull((int) reader.nextInt());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldIntegerNull(null);
                 }
             } else if (name.equals("fieldLongNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldLongNotNull((long) reader.nextLong());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNotNull((long) reader.nextLong());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldLongNotNull(null);
                 }
             } else if (name.equals("fieldLongNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldLongNull((long) reader.nextLong());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNull((long) reader.nextLong());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldLongNull(null);
                 }
             } else if (name.equals("fieldFloatNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldFloatNotNull((float) reader.nextDouble());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNotNull((float) reader.nextDouble());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldFloatNotNull(null);
                 }
             } else if (name.equals("fieldFloatNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldFloatNull((float) reader.nextDouble());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNull((float) reader.nextDouble());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldFloatNull(null);
                 }
             } else if (name.equals("fieldDoubleNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldDoubleNotNull((double) reader.nextDouble());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNotNull((double) reader.nextDouble());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldDoubleNotNull(null);
                 }
             } else if (name.equals("fieldDoubleNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldDoubleNull((double) reader.nextDouble());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNull((double) reader.nextDouble());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldDoubleNull(null);
                 }
             } else if (name.equals("fieldDateNotNull")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(null);
+                    objProxy.realmSet$fieldDateNotNull(null);
                 } else if (reader.peek() == JsonToken.NUMBER) {
                     long timestamp = reader.nextLong();
                     if (timestamp > -1) {
-                        ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(new Date(timestamp));
+                        objProxy.realmSet$fieldDateNotNull(new Date(timestamp));
                     }
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(JsonUtils.stringToDate(reader.nextString()));
+                    objProxy.realmSet$fieldDateNotNull(JsonUtils.stringToDate(reader.nextString()));
                 }
             } else if (name.equals("fieldDateNull")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(null);
+                    objProxy.realmSet$fieldDateNull(null);
                 } else if (reader.peek() == JsonToken.NUMBER) {
                     long timestamp = reader.nextLong();
                     if (timestamp > -1) {
-                        ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(new Date(timestamp));
+                        objProxy.realmSet$fieldDateNull(new Date(timestamp));
                     }
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(JsonUtils.stringToDate(reader.nextString()));
+                    objProxy.realmSet$fieldDateNull(JsonUtils.stringToDate(reader.nextString()));
                 }
             } else if (name.equals("fieldObjectNull")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldObjectNull(null);
+                    objProxy.realmSet$fieldObjectNull(null);
                 } else {
                     some.test.NullTypes fieldObjectNullObj = NullTypesRealmProxy.createUsingJsonStream(realm, reader);
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldObjectNull(fieldObjectNullObj);
+                    objProxy.realmSet$fieldObjectNull(fieldObjectNullObj);
                 }
             } else {
                 reader.skipValue();
             }
         }
         reader.endObject();
-        obj = realm.copyToRealm(obj);
-        return obj;
+        return realm.copyToRealm(obj);
     }
 
     public static some.test.NullTypes copyOrUpdate(Realm realm, some.test.NullTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
-            throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
-        }
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-            return object;
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
+            final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
+            if (otherRealm.threadId != realm.threadId) {
+                throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+            }
+            if (otherRealm.getPath().equals(realm.getPath())) {
+                return object;
+            }
         }
         final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
         RealmObjectProxy cachedRealmObject = cache.get(object);
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index b4d7ffaf35..0b2e214c2b 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -208,18 +208,19 @@ public static String getTableName() {
             throws JSONException {
         final List<String> excludeFields = Collections.<String> emptyList();
         some.test.Simple obj = realm.createObjectInternal(some.test.Simple.class, true, excludeFields);
+        final SimpleRealmProxyInterface objProxy = (SimpleRealmProxyInterface) obj;
         if (json.has("name")) {
             if (json.isNull("name")) {
-                ((SimpleRealmProxyInterface) obj).realmSet$name(null);
+                objProxy.realmSet$name(null);
             } else {
-                ((SimpleRealmProxyInterface) obj).realmSet$name((String) json.getString("name"));
+                objProxy.realmSet$name((String) json.getString("name"));
             }
         }
         if (json.has("age")) {
             if (json.isNull("age")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'age' to null.");
             } else {
-                ((SimpleRealmProxyInterface) obj).realmSet$age((int) json.getInt("age"));
+                objProxy.realmSet$age((int) json.getInt("age"));
             }
         }
         return obj;
@@ -229,40 +230,43 @@ public static String getTableName() {
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public static some.test.Simple createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        some.test.Simple obj = new some.test.Simple();
+        final some.test.Simple obj = new some.test.Simple();
+        final SimpleRealmProxyInterface objProxy = (SimpleRealmProxyInterface) obj;
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
             if (false) {
             } else if (name.equals("name")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((SimpleRealmProxyInterface) obj).realmSet$name(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$name((String) reader.nextString());
                 } else {
-                    ((SimpleRealmProxyInterface) obj).realmSet$name((String) reader.nextString());
+                    reader.skipValue();
+                    objProxy.realmSet$name(null);
                 }
             } else if (name.equals("age")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$age((int) reader.nextInt());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'age' to null.");
-                } else {
-                    ((SimpleRealmProxyInterface) obj).realmSet$age((int) reader.nextInt());
                 }
             } else {
                 reader.skipValue();
             }
         }
         reader.endObject();
-        obj = realm.copyToRealm(obj);
-        return obj;
+        return realm.copyToRealm(obj);
     }
 
     public static some.test.Simple copyOrUpdate(Realm realm, some.test.Simple object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
-            throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
-        }
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-            return object;
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
+            final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
+            if (otherRealm.threadId != realm.threadId) {
+                throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+            }
+            if (otherRealm.getPath().equals(realm.getPath())) {
+                return object;
+            }
         }
         final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
         RealmObjectProxy cachedRealmObject = cache.get(object);
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java b/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
index 80d74d91b9..f3d88fc2cb 100644
--- a/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
@@ -18,6 +18,7 @@
 
 import java.util.Date;
 
+import io.realm.MutableRealmInteger;
 import io.realm.RealmList;
 import io.realm.RealmObject;
 import io.realm.RealmResults;
@@ -32,16 +33,24 @@
 
     @PrimaryKey
     private String columnString;
+
     private long columnLong;
     private float columnFloat;
     private double columnDouble;
     private boolean columnBoolean;
+
     @Required
     private Date columnDate;
+
     @Required
     private byte[] columnBinary;
+
+    private final MutableRealmInteger columnMutableRealmInteger = MutableRealmInteger.valueOf(0);
+
     private AllTypes columnObject;
+
     private RealmList<AllTypes> columnRealmList;
+
     @LinkingObjects(FIELD_PARENTS)
     private final RealmResults<AllTypes> parentObjects = null;
 
@@ -189,4 +198,11 @@ public void setColumnRealmList(RealmList<AllTypes> columnRealmList) {
         this.columnRealmList = columnRealmList;
     }
 
+    public MutableRealmInteger getColumnMutableRealmInteger() {
+        return realmGet$columnMutableRealmInteger();
+    }
+
+    public MutableRealmInteger realmGet$columnMutableRealmInteger() {
+        return columnMutableRealmInteger;
+    }
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Counter.java b/realm/realm-annotations-processor/src/test/resources/some/test/Counter.java
new file mode 100644
index 0000000000..de5cbc6e96
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Counter.java
@@ -0,0 +1,13 @@
+package some.test;
+
+import io.realm.MutableRealmInteger;
+import io.realm.RealmObject;
+
+public class Counter extends RealmObject {
+
+    private final MutableRealmInteger columnMutableRealmInteger = MutableRealmInteger.valueOf(0);
+
+    public MutableRealmInteger getColumnMutableRealmInteger() {
+        return columnMutableRealmInteger;
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Counter_Ignored.java b/realm/realm-annotations-processor/src/test/resources/some/test/Counter_Ignored.java
new file mode 100644
index 0000000000..5a71abfdf8
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Counter_Ignored.java
@@ -0,0 +1,16 @@
+package some.test;
+
+import io.realm.MutableRealmInteger;
+import io.realm.RealmObject;
+import io.realm.annotations.Ignore;
+
+public class Counter_Ignored extends RealmObject {
+    private int id;
+
+    @Ignore
+    private final MutableRealmInteger columnMutableRealmInteger = MutableRealmInteger.valueOf(0);
+
+    public MutableRealmInteger getColumnMutableRealmInteger() {
+        return columnMutableRealmInteger;
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Counter_Indexed.java b/realm/realm-annotations-processor/src/test/resources/some/test/Counter_Indexed.java
new file mode 100644
index 0000000000..5e7e576300
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Counter_Indexed.java
@@ -0,0 +1,15 @@
+package some.test;
+
+import io.realm.MutableRealmInteger;
+import io.realm.RealmObject;
+import io.realm.annotations.Index;
+
+public class Counter_Indexed extends RealmObject {
+
+    @Index
+    private final MutableRealmInteger columnMutableRealmInteger = MutableRealmInteger.valueOf(0);
+
+    public MutableRealmInteger getColumnMutableRealmInteger() {
+        return columnMutableRealmInteger;
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Counter_PK.java b/realm/realm-annotations-processor/src/test/resources/some/test/Counter_PK.java
new file mode 100644
index 0000000000..34bd0fc983
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Counter_PK.java
@@ -0,0 +1,15 @@
+package some.test;
+
+import io.realm.MutableRealmInteger;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+
+public class Counter_PK extends RealmObject {
+
+    @PrimaryKey
+    private final MutableRealmInteger columnMutableRealmInteger = MutableRealmInteger.valueOf(0);
+
+    public MutableRealmInteger getColumnMutableRealmInteger() {
+        return columnMutableRealmInteger;
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Counter_Required.java b/realm/realm-annotations-processor/src/test/resources/some/test/Counter_Required.java
new file mode 100644
index 0000000000..a2faba1ad7
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Counter_Required.java
@@ -0,0 +1,15 @@
+package some.test;
+
+import io.realm.MutableRealmInteger;
+import io.realm.RealmObject;
+import io.realm.annotations.Required;
+
+public class Counter_Required extends RealmObject {
+
+    @Required
+    private final MutableRealmInteger columnMutableRealmInteger = MutableRealmInteger.valueOf(0);
+
+    public MutableRealmInteger getColumnMutableRealmInteger() {
+        return columnMutableRealmInteger;
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Counter_Static.java b/realm/realm-annotations-processor/src/test/resources/some/test/Counter_Static.java
new file mode 100644
index 0000000000..d5f2c5492c
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Counter_Static.java
@@ -0,0 +1,13 @@
+package some.test;
+
+import io.realm.MutableRealmInteger;
+import io.realm.RealmObject;
+
+public class Counter_Static extends RealmObject {
+
+    private static final MutableRealmInteger columnMutableRealmInteger = MutableRealmInteger.valueOf(0);
+
+    public MutableRealmInteger getColumnMutableRealmInteger() {
+        return columnMutableRealmInteger;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/assets/empty.json b/realm/realm-library/src/androidTest/assets/empty.json
new file mode 100644
index 0000000000..ffcd4415b0
--- /dev/null
+++ b/realm/realm-library/src/androidTest/assets/empty.json
@@ -0,0 +1 @@
+{ }
diff --git a/realm/realm-library/src/androidTest/assets/mutablerealminteger-int.json b/realm/realm-library/src/androidTest/assets/mutablerealminteger-int.json
new file mode 100644
index 0000000000..69fd08edf2
--- /dev/null
+++ b/realm/realm-library/src/androidTest/assets/mutablerealminteger-int.json
@@ -0,0 +1,3 @@
+{
+  "columnNullableMutableRealmInteger": 22
+}
diff --git a/realm/realm-library/src/androidTest/assets/mutablerealminteger-long.json b/realm/realm-library/src/androidTest/assets/mutablerealminteger-long.json
new file mode 100644
index 0000000000..d1343186bb
--- /dev/null
+++ b/realm/realm-library/src/androidTest/assets/mutablerealminteger-long.json
@@ -0,0 +1,3 @@
+{
+  "columnNullableMutableRealmInteger": 8589934592
+}
diff --git a/realm/realm-library/src/androidTest/assets/mutablerealminteger-null.json b/realm/realm-library/src/androidTest/assets/mutablerealminteger-null.json
new file mode 100644
index 0000000000..82ae58d9b5
--- /dev/null
+++ b/realm/realm-library/src/androidTest/assets/mutablerealminteger-null.json
@@ -0,0 +1,3 @@
+{
+  "columnNullableMutableRealmInteger": null
+}
diff --git a/realm/realm-library/src/androidTest/assets/mutablerealminteger-required-null.json b/realm/realm-library/src/androidTest/assets/mutablerealminteger-required-null.json
new file mode 100644
index 0000000000..f083d01921
--- /dev/null
+++ b/realm/realm-library/src/androidTest/assets/mutablerealminteger-required-null.json
@@ -0,0 +1,3 @@
+{
+  "columnNonNullableMutableRealmInteger": null
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/MutableRealmIntegerTests.java b/realm/realm-library/src/androidTest/java/io/realm/MutableRealmIntegerTests.java
new file mode 100644
index 0000000000..9ae057fd57
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/MutableRealmIntegerTests.java
@@ -0,0 +1,565 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import io.realm.entities.MutableRealmIntegerTypes;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.Assert.fail;
+
+
+@RunWith(AndroidJUnit4.class)
+public class MutableRealmIntegerTests {
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    private Realm realm;
+
+    @Before
+    public void setUp() throws Exception {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        if (realm != null) {
+            if (realm.isInTransaction()) {
+                realm.cancelTransaction();
+            }
+            realm.close();
+        }
+    }
+
+    /**
+     * Validate basic functions: set, increment and decrement.
+     */
+    @Test
+    public void basic_unmanaged() {
+        testBasic(MutableRealmInteger.ofNull(), MutableRealmInteger.ofNull());
+    }
+
+    /**
+     * Validate basic equality semantics.
+     */
+    @Test
+    public void equality_unmanaged() {
+        testEquality(new MutableRealmIntegerTypes(), new MutableRealmIntegerTypes());
+    }
+
+    /**
+     * Validate basic nullability semantics.
+     */
+    @Test
+    public void nullability_unmanaged() {
+        testNullability(new MutableRealmIntegerTypes());
+    }
+
+    /**
+     * Validate basic validity/managed semantics.
+     */
+    @Test
+    public void validAndManaged_unmanaged() {
+        testValidityAndManagement(new MutableRealmIntegerTypes());
+    }
+
+    /**
+     * Validate basic functions: set, increment and decrement.
+     */
+    @Test
+    public void basic_managed() {
+        realm.beginTransaction();
+        MutableRealmIntegerTypes c1 = realm.createObject(MutableRealmIntegerTypes.class);
+        MutableRealmIntegerTypes c2 = realm.createObject(MutableRealmIntegerTypes.class);
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        testBasic(c1.columnNullableMutableRealmInteger, c2.columnNullableMutableRealmInteger);
+        realm.commitTransaction();
+    }
+
+    /**
+     * Validate basic equality semantics.
+     */
+    @Test
+    public void equality_managed() {
+        realm.beginTransaction();
+        MutableRealmIntegerTypes c1 = realm.createObject(MutableRealmIntegerTypes.class);
+        MutableRealmIntegerTypes c2 = realm.createObject(MutableRealmIntegerTypes.class);
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        testEquality(c1, c2);
+        realm.commitTransaction();
+    }
+
+    /**
+     * Validate basic nullability semantics.
+     */
+    @Test
+    public void nullability_managed() {
+        realm.beginTransaction();
+        MutableRealmIntegerTypes c1 = realm.createObject(MutableRealmIntegerTypes.class);
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        testNullability(c1);
+        realm.commitTransaction();
+    }
+
+    /**
+     * Validate basic validity/managed semantics.
+     */
+    @Test
+    public void validAndManaged_managed() {
+        realm.beginTransaction();
+        MutableRealmIntegerTypes c1 = realm.createObject(MutableRealmIntegerTypes.class);
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        testValidityAndManagement(c1);
+        realm.commitTransaction();
+    }
+
+    /**
+     * @Required MutableRealmIntegers should not be nullable.
+     * There are other tests testing nullabilty: just need to test @Required here.
+     * There is no attempt to control the nullability of an unmanaged MutableRealmInteger.
+     * An attempt to copy an unmanaged model object with a null-valued MutableRealmInteger
+     * into an @Required field should fail.
+     */
+    @Test
+    public void required() {
+        realm.beginTransaction();
+        MutableRealmIntegerTypes c1 = realm.createObject(MutableRealmIntegerTypes.class);
+        realm.commitTransaction();
+
+        assertFalse(
+                realm.getSchema().get("MutableRealmIntegerTypes")
+                        .isNullable(MutableRealmIntegerTypes.FIELD_NONNULLABLE_MUTABLEREALMINTEGER));
+
+        realm.beginTransaction();
+        try {
+            c1.columnNonNullableMutableRealmInteger.set(null);
+            fail("should not be able to set an @Required MutableRealmInteger null");
+        } catch(IllegalArgumentException ignore) {
+            checkException(ignore, "is not nullable");
+        }
+        realm.commitTransaction();
+
+        c1 = new MutableRealmIntegerTypes();
+        c1.columnNonNullableMutableRealmInteger.set(null);
+        realm.beginTransaction();
+        try {
+            MutableRealmIntegerTypes c2 = realm.copyToRealm(c1);
+            fail("should not be able to copy a null value to a @Required MutableRealmInteger");
+        } catch(IllegalArgumentException ignore) {
+            checkException(ignore, "is not nullable");
+        }
+        realm.commitTransaction();
+    }
+
+
+    /**
+     * @Indexed MutableRealmIntegers should have indices.
+     * Without @Index they should not.
+     */
+    @Test
+    public void indexed() {
+        realm.beginTransaction();
+        MutableRealmIntegerTypes c1 = realm.createObject(MutableRealmIntegerTypes.class);
+        realm.commitTransaction();
+
+        assertTrue(
+                realm.getSchema().get("MutableRealmIntegerTypes")
+                        .hasIndex(MutableRealmIntegerTypes.FIELD_INDEXED_MUTABLEREALMINTEGER));
+        assertFalse(
+                realm.getSchema().get("MutableRealmIntegerTypes")
+                        .hasIndex(MutableRealmIntegerTypes.FIELD_NULLABLE_MUTABLEEALMINTEGER));
+    }
+
+    /**
+     * Be absolutely certain that we can actually compare two longs.
+     */
+    @Test
+    public void compareTo_unmanaged() {
+        MutableRealmInteger ri1 = MutableRealmInteger.valueOf(0);
+        MutableRealmInteger ri2 = MutableRealmInteger.valueOf(Long.MAX_VALUE);
+        assertEquals(-1, ri1.compareTo(ri2));
+
+        ri2.decrement(Long.MAX_VALUE);
+        assertEquals(0, ri1.compareTo(ri2));
+
+        ri2.decrement(Long.MAX_VALUE);
+        assertEquals(1, ri1.compareTo(ri2));
+    }
+
+    /**
+     * Be absolutely certain that we can actually compare two longs.
+     */
+    @Test
+    public void compareTo_managed() {
+        realm.beginTransaction();
+        MutableRealmInteger ri1 = realm.createObject(MutableRealmIntegerTypes.class).getColumnNullableMutableRealmInteger();
+        ri1.set(0);
+        MutableRealmInteger ri2 = realm.createObject(MutableRealmIntegerTypes.class).getColumnNullableMutableRealmInteger();
+        ri2.set(Long.MAX_VALUE);
+        realm.commitTransaction();
+        assertEquals(-1, ri1.compareTo(ri2));
+
+        realm.beginTransaction();
+        ri2.decrement(Long.MAX_VALUE);
+        realm.commitTransaction();
+        assertEquals(0, ri1.compareTo(ri2));
+
+        realm.beginTransaction();
+        ri2.decrement(Long.MAX_VALUE);
+        realm.commitTransaction();
+        assertEquals(1, ri1.compareTo(ri2));
+    }
+
+    /**
+     * Assure that an attempt to change the value of a managed MutableRealmInteger, outside a transaction, fails.
+     */
+    @Test
+    public void updateOutsideTransactionThrows() {
+        realm.beginTransaction();
+        realm.createObject(MutableRealmIntegerTypes.class).getColumnNullableMutableRealmInteger().set(42);
+        realm.commitTransaction();
+
+        MutableRealmInteger managedRI = realm.where(MutableRealmIntegerTypes.class).findFirst().getColumnNullableMutableRealmInteger();
+        try {
+            managedRI.set(1);
+            fail("Setting a managed MutableRealmInteger outside a transaction should fail");
+        } catch (IllegalStateException e) {
+            checkTransactionException(e);
+        }
+
+        try {
+            managedRI.increment(1);
+            fail("Incrementing a managed MutableRealmInteger outside a transaction should fail");
+        } catch (IllegalStateException e) {
+            checkTransactionException(e);
+        }
+
+        try {
+            managedRI.decrement(1);
+            fail("Decrementing a managed MutableRealmInteger outside a transaction should fail");
+        } catch (IllegalStateException e) {
+            checkTransactionException(e);
+        }
+    }
+
+    /**
+     * Assure that changes to a MutableRealmInteger acquired from a managed object are reflected in the object.
+     */
+    @Test
+    public void isLive() {
+        realm.beginTransaction();
+        realm.createObject(MutableRealmIntegerTypes.class).getColumnNullableMutableRealmInteger().set(42);
+        realm.commitTransaction();
+
+        MutableRealmInteger managedRI = realm.where(MutableRealmIntegerTypes.class).findFirst().getColumnNullableMutableRealmInteger();
+
+        realm.beginTransaction();
+        MutableRealmInteger ri = realm.where(MutableRealmIntegerTypes.class).findFirst().getColumnNullableMutableRealmInteger();
+        ri.set(37);
+        ri.increment(17);
+        ri.decrement(7);
+        realm.commitTransaction();
+
+        assertEquals(Long.valueOf(47), managedRI.get());
+    }
+
+    /**
+     * Assure that changes to a MutableRealmInteger acquired from a managed object are reflected in the object.
+     */
+    @Test
+    public void copyToisLive() {
+        MutableRealmIntegerTypes obj = new MutableRealmIntegerTypes();
+        MutableRealmInteger unmanagedRI = obj.getColumnNullableMutableRealmInteger();
+        unmanagedRI.set(42L);
+
+        realm.beginTransaction();
+        MutableRealmInteger managedRI = realm.copyToRealm(obj).getColumnNullableMutableRealmInteger();
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        MutableRealmInteger ri = realm.where(MutableRealmIntegerTypes.class).findFirst().getColumnNullableMutableRealmInteger();
+        ri.set(37);
+        ri.increment(17);
+        ri.decrement(7);
+        realm.commitTransaction();
+
+        assertEquals(Long.valueOf(42L), unmanagedRI.get());
+        assertEquals(Long.valueOf(47L), managedRI.get());
+    }
+
+    /**
+     * Assure that a MutableRealmInteger acquired from an unmanaged object is not affected by changes in the Realm.
+     */
+    @Test
+    public void copyFromIsNotLive() {
+        realm.beginTransaction();
+        realm.createObject(MutableRealmIntegerTypes.class).getColumnNullableMutableRealmInteger().set(42L);
+        realm.commitTransaction();
+
+        MutableRealmIntegerTypes obj = realm.where(MutableRealmIntegerTypes.class).findFirst();
+        MutableRealmInteger managedRI = obj.getColumnNullableMutableRealmInteger();
+        MutableRealmInteger unmanagedRI = realm.copyFromRealm(obj).getColumnNullableMutableRealmInteger();
+
+        realm.beginTransaction();
+        MutableRealmInteger ri = realm.where(MutableRealmIntegerTypes.class).findFirst().getColumnNullableMutableRealmInteger();
+        ri.set(37);
+        ri.increment(17);
+        ri.decrement(7);
+        realm.commitTransaction();
+
+        assertEquals(Long.valueOf(42L), unmanagedRI.get());
+        assertEquals(Long.valueOf(47L), managedRI.get());
+    }
+
+    @Test
+    public void testJSON() throws JSONException {
+        JSONObject json = new JSONObject();
+        realm.beginTransaction();
+        MutableRealmIntegerTypes obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, json);
+        realm.commitTransaction();
+        assertTrue(obj.columnNullableMutableRealmInteger.isNull());
+
+        json = new JSONObject();
+        json.put("columnNullableMutableRealmInteger", 8589934592L);
+        realm.beginTransaction();
+        obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, json);
+        realm.commitTransaction();
+        assertEquals(Long.valueOf(8589934592L), obj.columnNullableMutableRealmInteger.get());
+
+        json = new JSONObject();
+        json.put("columnNullableMutableRealmInteger", 22);
+        realm.beginTransaction();
+        obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, json);
+        realm.commitTransaction();
+        assertEquals(Long.valueOf(22), obj.columnNullableMutableRealmInteger.get());
+
+        json = new JSONObject();
+        json.put("columnNullableMutableRealmInteger", JSONObject.NULL);
+        realm.beginTransaction();
+        obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, json);
+        realm.commitTransaction();
+        assertTrue(obj.columnNullableMutableRealmInteger.isNull());
+
+        json = new JSONObject();
+        json.put("columnNonNullableMutableRealmInteger", JSONObject.NULL);
+        realm.beginTransaction();
+        try {
+            obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, json);
+            fail("Attempt to set @Required Mutable Realm Integer null, from JSON, should fail");
+        } catch (IllegalArgumentException ignore) {
+            checkException(ignore, "is not nullable");
+        }
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void testStream() throws IOException {
+        Context context = InstrumentationRegistry.getTargetContext();
+
+        InputStream in = TestHelper.loadJsonFromAssets(context, "empty.json");
+        realm.beginTransaction();
+        MutableRealmIntegerTypes obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, in);
+        realm.commitTransaction();
+        assertTrue(obj.columnNullableMutableRealmInteger.isNull());
+
+        in = TestHelper.loadJsonFromAssets(context, "mutablerealminteger-long.json");
+        realm.beginTransaction();
+        obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, in);
+        realm.commitTransaction();
+        assertEquals(Long.valueOf(8589934592L), obj.columnNullableMutableRealmInteger.get());
+
+        in = TestHelper.loadJsonFromAssets(context, "mutablerealminteger-int.json");
+        realm.beginTransaction();
+        obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, in);
+        realm.commitTransaction();
+        assertEquals(Long.valueOf(22), obj.columnNullableMutableRealmInteger.get());
+
+        in = TestHelper.loadJsonFromAssets(context, "mutablerealminteger-null.json");
+        realm.beginTransaction();
+        obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, in);
+        realm.commitTransaction();
+        assertTrue(obj.columnNullableMutableRealmInteger.isNull());
+
+        in = TestHelper.loadJsonFromAssets(context, "mutablerealminteger-required-null.json");
+        realm.beginTransaction();
+        try {
+            obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, in);
+            fail("Attempt to set @Required Mutable Realm Integer null, from JSON, should fail");
+        } catch (IllegalArgumentException ignore) {
+            checkException(ignore, "is not nullable");
+        }
+        realm.commitTransaction();
+    }
+
+    private void checkTransactionException(Exception e) {
+        checkException(e, "only be done from inside a transaction");
+    }
+
+    private void checkException(Exception e, String expected) {
+        assertTrue(e.getMessage().contains(expected));
+    }
+
+    /**
+     * Test basic arithmetic: set, increment, decrement and equals.
+     * Since the implementations of managed and unmanaged MutableRealmIntegers are completely
+     * different these tests should be run on both implementations.
+     *
+     * @param r1 a MutableRealmInteger
+     * @param r2 another MutableRealmInteger
+     */
+    @SuppressWarnings({"ReferenceEquality", "EqualsIncompatibleType"})
+    private void testBasic(MutableRealmInteger r1, MutableRealmInteger r2) {
+        assertFalse(r1 == r2);
+
+        r1.set(10);
+        r2.set(Long.valueOf(10));
+        assertEquals(r1, r2);
+        assertEquals(r2, r1);
+
+        r1.set(15);
+        r1.decrement(2);
+        r2.increment(3);
+        assertEquals(r1, r2);
+
+        MutableRealmInteger r3 = r1;
+        r1.set(19);
+        assertEquals(19, r3.get().intValue());
+
+        assertFalse(r2.equals(r3));
+        assertFalse(r3.equals(r2));
+    }
+
+    /**
+     * Thorough tests of equality, as defined <a href="https://github.com/realm/realm-java/issues/4266#issuecomment-308772718">here</a>
+     * and in subsequent comments.  The general principles are:
+     * <ul>
+     *     <li>MutableRealmInteger.equals tests the value of the wrapped integer<./li>
+     *     <li>All references to a single MutableRealmInteger must be {@code .equals} to the same thing.</li>
+     *     <li>Except when set to {@code null} MutableRealmInteger does not distinguish boxed and primitive types.</li>
+     * </ul>
+     * Since the implementations of managed and unmanaged MutableRealmIntegers are completely
+     * different these tests should be run on both implementations.
+     *
+     * @param c1 a MutableRealmIntegerTypes
+     * @param c2 another MutableRealmIntegerTypes
+     */
+    @SuppressWarnings({"ReferenceEquality", "EqualsIncompatibleType"})
+    private void testEquality(MutableRealmIntegerTypes c1, MutableRealmIntegerTypes c2) {
+        assertFalse(c1 == c2);
+
+        c1.columnNullableMutableRealmInteger.set(7);
+        c2.columnNullableMutableRealmInteger.set(Long.valueOf(7));
+        assertTrue(c1.columnNullableMutableRealmInteger != c2.columnNullableMutableRealmInteger);
+        assertTrue(c1.columnNullableMutableRealmInteger.equals(c2.columnNullableMutableRealmInteger));
+
+        MutableRealmInteger r1 = c1.columnNullableMutableRealmInteger;
+        r1.increment(1);
+        assertTrue(r1.equals(c1.columnNullableMutableRealmInteger));
+        assertTrue(r1 == c1.columnNullableMutableRealmInteger);
+        assertTrue(c1.columnNullableMutableRealmInteger.get().equals(8L));
+        assertFalse(c1.columnNullableMutableRealmInteger.get().equals(c2.columnNullableMutableRealmInteger.get()));
+        assertTrue(c1.columnNullableMutableRealmInteger.get().intValue() == 8);
+
+        Long n = c1.columnNullableMutableRealmInteger.get();
+        assertTrue(n.equals(Long.valueOf(8)));
+        assertTrue(n.equals(c1.columnNullableMutableRealmInteger.get()));
+        assertTrue(n.intValue() == c1.columnNullableMutableRealmInteger.get().intValue());
+
+        c1.columnNullableMutableRealmInteger.increment(1);
+        assertFalse(n.intValue() == c1.columnNullableMutableRealmInteger.get().intValue());
+        assertFalse(n.intValue() == r1.get().intValue());
+    }
+
+    /**
+     * Thorough tests of nullability, as defined <a href="https://github.com/realm/realm-java/issues/4266#issuecomment-308772718">here</a>
+     * and in subsequent comments.  The general principles are:
+     * <ul>
+     *     <li>Unless @Required, MutableRealmIntegers are nullable.</li>
+     *     <li>0L and null are distinct values.</li>
+     *     <li>All references to a single MutableRealmInteger must be {@code null} if any are./li>
+     *     <li>A null value cannot be incremented or decremented/li>
+     * </ul>
+     * Since the implementations of managed and unmanaged MutableRealmIntegers are completely
+     * different these tests should be run on both implementations.
+     *
+     * @param c1 a MutableRealmIntegerTypes
+     */
+    private void testNullability(MutableRealmIntegerTypes c1) {
+        MutableRealmInteger r1 = c1.columnNullableMutableRealmInteger;
+
+        c1.columnNullableMutableRealmInteger.set(0L);
+        assertFalse(c1.columnNullableMutableRealmInteger.isNull());
+        assertFalse(r1.isNull());
+
+        c1.columnNullableMutableRealmInteger.set(null);
+        assertFalse(c1.columnNullableMutableRealmInteger == null);
+        assertTrue(c1.columnNullableMutableRealmInteger.isNull());
+        assertTrue(r1.isNull());
+
+        assertTrue(c1.columnNullableMutableRealmInteger.get() == null);
+        assertTrue(r1.get() == null);
+
+        try {
+            c1.columnNullableMutableRealmInteger.increment(5);
+            fail("Attempt to increment a null valued MutableRealmInteger should throw ISE");
+        } catch (IllegalStateException ignore) {
+            checkException(ignore, "Set its value first");
+        }
+        try {
+            c1.columnNullableMutableRealmInteger.decrement(5);
+            fail("Attempt to decrement a null valued MutableRealmInteger should throw ISE");
+        } catch (IllegalStateException ignore) {
+            checkException(ignore, "Set its value first");
+        }
+    }
+
+    private void testValidityAndManagement(MutableRealmIntegerTypes c1) {
+        MutableRealmInteger r1 = c1.columnNullableMutableRealmInteger;
+        assertTrue(r1.isManaged() == c1.isManaged());
+        assertTrue(r1.isValid() == c1.isValid());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
index 6f1d2ddc34..a902259033 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -896,8 +896,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     // change the schema version, no migration is needed. But then, null cannot be used as a value.
     @Test
     public void openPreNullWithRequired() throws IOException {
-        configFactory.copyRealmFromAssets(context,
-                "string-only-required-pre-null-0.82.2.realm", Realm.DEFAULT_REALM_NAME);
+        configFactory.copyRealmFromAssets(context, "string-only-required-pre-null-0.82.2.realm", Realm.DEFAULT_REALM_NAME);
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                 .schemaVersion(0)
                 .schema(StringOnlyRequired.class)
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index b013187bf4..404b9efe9d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -113,7 +113,7 @@ public void row_isValid() {
         realm.commitTransaction();
 
         assertNotNull("RealmObject.realmGetRow returns zero ", row);
-        assertEquals(9, row.getColumnCount());
+        assertEquals(10, row.getColumnCount());
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypes.java
index 7d4fbba7b5..5e7d80bacc 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypes.java
@@ -18,6 +18,7 @@
 
 import java.util.Date;
 
+import io.realm.MutableRealmInteger;
 import io.realm.RealmList;
 import io.realm.RealmObject;
 import io.realm.annotations.Required;
@@ -32,10 +33,12 @@
     public static final String FIELD_BOOLEAN = "columnBoolean";
     public static final String FIELD_DATE = "columnDate";
     public static final String FIELD_BINARY = "columnBinary";
+    public static final String FIELD_MUTABLEREALMINTEGER = "columnMutableRealmInteger";
     public static final String FIELD_REALMOBJECT = "columnRealmObject";
     public static final String FIELD_REALMLIST = "columnRealmList";
 
-    public static final String[] INVALID_TYPES_FIELDS_FOR_DISTINCT = new String[]{FIELD_REALMOBJECT, FIELD_REALMLIST, FIELD_DOUBLE, FIELD_FLOAT};
+    public static final String[] INVALID_TYPES_FIELDS_FOR_DISTINCT
+            = new String[] {FIELD_REALMOBJECT, FIELD_REALMLIST, FIELD_DOUBLE, FIELD_FLOAT};
 
     @Required
     private String columnString = "";
@@ -47,6 +50,8 @@
     private Date columnDate = new Date(0);
     @Required
     private byte[] columnBinary = new byte[0];
+
+    private final MutableRealmInteger columnMutableRealmInteger = MutableRealmInteger.ofNull();
     private Dog columnRealmObject;
     private RealmList<Dog> columnRealmList;
 
@@ -102,6 +107,10 @@ public void setColumnDate(Date columnDate) {
         return columnBinary;
     }
 
+    public MutableRealmInteger getColumnRealmInteger() {
+        return columnMutableRealmInteger;
+    }
+
     public void setColumnBinary(byte[] columnBinary) {
         this.columnBinary = columnBinary;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/MutableRealmIntegerTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/MutableRealmIntegerTypes.java
new file mode 100644
index 0000000000..3448a138a3
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/MutableRealmIntegerTypes.java
@@ -0,0 +1,49 @@
+package io.realm.entities;
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import io.realm.MutableRealmInteger;
+import io.realm.RealmObject;
+import io.realm.annotations.Index;
+import io.realm.annotations.Required;
+
+
+public class MutableRealmIntegerTypes extends RealmObject {
+    public static final String CLASS_NAME = "MutableRealmIntegerTypes";
+    public static final String FIELD_NULLABLE_MUTABLEEALMINTEGER = "columnNullableMutableRealmInteger";
+    public static final String FIELD_NONNULLABLE_MUTABLEREALMINTEGER = "columnNonNullableMutableRealmInteger";
+    public static final String FIELD_INDEXED_MUTABLEREALMINTEGER = "columnIndexedMutableRealmInteger";
+
+    public final MutableRealmInteger columnNullableMutableRealmInteger = MutableRealmInteger.ofNull();
+
+    @Required
+    public final MutableRealmInteger columnNonNullableMutableRealmInteger = MutableRealmInteger.valueOf(0L);
+
+    @Index
+    public final MutableRealmInteger columnIndexedMutableRealmInteger = MutableRealmInteger.ofNull();
+
+    public MutableRealmInteger getColumnNullableMutableRealmInteger() {
+        return columnNullableMutableRealmInteger;
+    }
+
+    public MutableRealmInteger getColumnNonNullableMutableRealmInteger() {
+        return columnNonNullableMutableRealmInteger;
+    }
+
+    public MutableRealmInteger getColumnIndexedMutableRealmInteger() {
+        return columnIndexedMutableRealmInteger;
+    }
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
index c2afd189ce..ad6a75be1c 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
@@ -666,6 +666,25 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLong(JNIEnv* env, j
     CATCH_STD()
 }
 
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeIncrementLong(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                  jlong columnIndex, jlong rowIndex, jlong value)
+{
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Int)) {
+        return;
+    }
+
+    try {
+        Table* table = TBL(nativeTablePtr);
+        if (table->is_null(columnIndex, rowIndex)) {
+            THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalState,
+                                 "Cannot increment a MutableRealmInteger whose value is null. Set its value first.");
+        }
+
+        table->add_int(S(columnIndex), S(rowIndex), value);
+    }
+    CATCH_STD()
+}
+
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLongUnique(JNIEnv* env, jclass, jlong nativeTablePtr,
                                                                         jlong columnIndex, jlong rowIndex,
                                                                         jlong value)
diff --git a/realm/realm-library/src/main/java/io/realm/MutableRealmInteger.java b/realm/realm-library/src/main/java/io/realm/MutableRealmInteger.java
new file mode 100644
index 0000000000..3eec68ef79
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/MutableRealmInteger.java
@@ -0,0 +1,352 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import io.realm.annotations.Beta;
+import io.realm.internal.ManagableObject;
+import io.realm.internal.Row;
+import io.realm.internal.Table;
+
+
+/**
+ * A {@code MutableRealmInteger} is a mutable, {@link Long}-like numeric quantity.
+ * It behaves almost exactly as a reference to a {@link Long}. More specifically:
+ * <ul>
+ * <li>A {@code MutableRealmInteger} may have the value {@code null}.</li>
+ * <li>The {@link #equals} operator compares the contained {@link Long} values. {@code null}-valued {@code MutableRealmInteger} are {@code .equals}</li>
+ * <li>The {@link #compareTo} operator compares the contained {@link Long} values.  It considers {@code null} &lt; any non-{@code null} value.</li>
+ * <li>The {@link #increment} and {@link #decrement} operators throw {@link IllegalStateException} when applied to a {@code null}-valued {@code MutableRealmInteger}.</li>
+ * </ul>
+ * <p>
+ *
+ * {@code MutableRealmInteger}s are most interesting as members of a managed {@link RealmModel} object.
+ * When managed, the {@link #increment} and {@link #decrement} operators implement a
+ * <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">conflict free replicated data type</a>:
+ * Simultaneous increments and decrements from multiple distributed clients will be aggregated correctly.
+ * For instance, if the value of {@code counter} field for the object representing user "Fred" is currently 0,
+ * then the following code, executed on two different devices, simultaneously, even if connected by only a slow,
+ * unreliable network, will <b>always</b> cause the value of {@code counter} to converge, eventually on the value 2.
+ * <pre>
+ * <code> MutableRealmInteger counter = realm.where(Users.class)
+ *     .equalTo("name", Fred)
+ *     .findFirst()
+ *     .counter.increment(1);</code>
+ * </pre>
+ * Note that the {@link #set(Long)} operator must be used with extreme care. It will quash the effects of any prior calls
+ * to {@link #increment(long)} or {@link #decrement(long)}. Although the value of a {@code MutableRealmInteger} will
+ * always converge across devices, the specific value on which it converges will depend on the actual order in which
+ * operations took place. Mixing {@link #set(Long)} with {@link #increment(long)} and {@link #decrement(long)} is,
+ * therefore, not advised, unless fuzzy counting is acceptable.
+ * <p>
+ *
+ * {@code MutableRealmInteger}s may not be primary keys. Their implementations are not thread safe.
+ * Like all managed Realm objects, managed {@code MutableRealmInteger}s may not be moved across threads.
+ * Unmanaged {@code MutableRealmInteger}s may be moved across threads but require safe publication.
+ * <p>
+ *
+ * A {@code MutableRealmInteger}, in a model class, must always be declared {@code final}. For instance:
+ * <pre>
+ * {@code public final MutableRealmInteger counter = MutableRealmInteger.ofNull(); }
+ * </pre>
+ * Although initializing the {@code MutableRealmInteger} as {@code null} may work very limited circumstances,
+ * developers are advised <b>not</b> to do it:
+ * <pre>
+ * {@code
+ *  public final MutableRealmInteger counter = null; // DO NOT DO THIS! }
+ * </pre>
+ * Also note that when a {@code MutableRealmInteger} is {@code @Required}, it is better, though not required,
+ * to initialize it with a non-null value.
+ * <pre>
+ * <code>
+ * {@literal @}Required
+ *  public final MutableRealmInteger counter = MutableRealmInteger.valueOf(0L);</code>
+ * </pre>
+ *
+ *<p>
+ * A reference to a managed {@code MutableRealmInteger} is subject to all of the constraints that apply
+ * to the model object from which it was obtained: It can only be mutated within a transaction and
+ * it becomes invalid if the Realm backing it is closed. Use the {@code isManaged()}
+ * and {@code isValid()} operators to determine whether a {@code MutableRealmInteger} is
+ * in a consistent state. Note, in particular, that a reference to a managed {@code MutableRealmInteger}
+ * retains a reference to the model object to which it belongs. For example in this code:
+ * <pre>
+ * {@code MutableRealmInteger counter = realm.where(Users.class).findFirst().counter; }
+ * </pre>
+ * the {@code counter} holds a reference to the {@code User} model object from which it was obtained.
+ * Neither can be GCed until all references to both are unreachable.
+ */
+@Beta
+public abstract class MutableRealmInteger implements Comparable<MutableRealmInteger>, ManagableObject {
+
+    /**
+     * Unmanaged Implementation.
+     */
+    private static final class Unmanaged extends MutableRealmInteger {
+        private Long value;
+
+        Unmanaged(Long value) {
+            this.value = value;
+        }
+
+        @Override
+        public boolean isManaged() {
+            return false;
+        }
+
+        @Override
+        public boolean isValid() {
+            return true;
+        }
+
+        @Override
+        public void set(Long newValue) {
+            value = newValue;
+        }
+
+        @Override
+        public Long get() {
+            return value;
+        }
+
+        @Override
+        public void increment(long inc) {
+            if (value == null) {
+                throw new IllegalStateException("Cannot increment a MutableRealmInteger whose value is null. Set its value first.");
+            }
+            value = Long.valueOf(value + inc);
+        }
+
+        @Override
+        public void decrement(long dec) {
+            increment(-dec);
+        }
+    }
+
+
+    /**
+     * Managed Implementation.
+     * Proxies create new subclasses for each {@code MutableRealmInteger} field.
+     */
+    abstract static class Managed<T extends RealmModel> extends MutableRealmInteger {
+        protected abstract ProxyState<T> getProxyState();
+
+        protected abstract long getColumnIndex();
+
+        @Override
+        public final boolean isManaged() {
+            return true;
+        }
+
+        @Override
+        public final boolean isValid() {
+            return !getRealm().isClosed() && getRow().isAttached();
+        }
+
+        @Override
+        public final Long get() {
+            Row row = getRow();
+            row.checkIfAttached();
+            long columnIndex = getColumnIndex();
+            return (row.isNull(columnIndex)) ? null : row .getLong(columnIndex);
+        }
+
+        @Override
+        public final void set(Long value) {
+            ProxyState proxyState = getProxyState();
+            proxyState.getRealm$realm().checkIfValidAndInTransaction();
+
+            if (!proxyState.isUnderConstruction()) {
+                setValue(value, false);
+                return;
+            }
+
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+
+            setValue(value, true);
+        }
+
+        @Override
+        public final void increment(long inc) {
+            getRealm().checkIfValidAndInTransaction();
+            Row row = getRow();
+            row.getTable().incrementLong(getColumnIndex(), row.getIndex(), inc);
+        }
+
+        @Override
+        public final void decrement(long dec) {
+            increment(-dec);
+        }
+
+        private BaseRealm getRealm() {
+            return getProxyState().getRealm$realm();
+       }
+
+        private Row getRow() {
+            return getProxyState().getRow$realm();
+        }
+
+        private void setValue(Long value, boolean isDefault) {
+            Row row = getRow();
+            Table table = row.getTable();
+            long rowIndex = row.getIndex();
+            long columnIndex = getColumnIndex();
+            if (value == null) {
+                table.setNull(columnIndex, rowIndex, isDefault);
+            } else {
+                table.setLong(columnIndex, rowIndex, value, isDefault);
+            }
+        }
+    }
+
+    /**
+     * Creates a new, unmanaged {@code MutableRealmInteger} with the specified initial value.
+     *
+     * @param value initial value.
+     */
+    public static MutableRealmInteger valueOf(Long value) {
+        return new MutableRealmInteger.Unmanaged(value);
+    }
+
+    /**
+     * Creates a new, unmanaged {@code MutableRealmInteger} whose value is {@code null}.
+     */
+    public static MutableRealmInteger ofNull() {
+        return valueOf((Long) null);
+    }
+
+    /**
+     * Creates a new, unmanaged {@code MutableRealmInteger} with the specified initial value.
+     *
+     * @param value initial value.
+     */
+    public static MutableRealmInteger valueOf(long value) {
+        return valueOf(Long.valueOf(value));
+    }
+
+    /**
+     * Creates a new, unmanaged {@code MutableRealmInteger} with the specified initial value.
+     *
+     * @param value initial value: parsed by {@link Long#parseLong}.
+     */
+    public static MutableRealmInteger valueOf(String value) {
+        return valueOf(Long.parseLong(value));
+    }
+
+    /**
+     * Seal the class.
+     * In fact, this allows subclasses inside the package "realm.io".
+     * Because it eliminates the synthetic constructor, though, we can live with that.
+     * Don't make subclasses.
+     */
+    MutableRealmInteger() {}
+
+    /**
+     * Gets the {@code MutableRealmInteger} value.
+     * The value may be null.
+     *
+     * @return the value.
+     */
+    public abstract Long get();
+
+    /**
+     * Sets the {@code MutableRealmInteger} value.
+     * Calling {@code set} forcibly sets the {@code MutableRealmInteger} to the provided value.
+     * Doing this obliterates the effects of any calls to {@link #increment} and {@link #decrement} perceived
+     * before the call to {@code set}.
+     *
+     * @param newValue new value.
+     */
+    public abstract void set(Long newValue);
+
+    /**
+     * Sets the {@code MutableRealmInteger} value.
+     * Calling {@link #set} forcibly sets the {@code MutableRealmInteger} to the provided value.
+     * Doing this obliterates the effects of any calls to {@link #increment} and {@link #decrement} perceived
+     * before the call to {@link #set}.
+     *
+     * @param newValue new value.
+     */
+    public final void set(long newValue) {
+        set(Long.valueOf(newValue));
+    }
+
+    /**
+     * Increments the {@code MutableRealmInteger}, adding the value of the argument.
+     * Increment/decrement from all devices are reflected in the new value, which is guaranteed to converge.
+     *
+     * @param inc quantity to be added to the {@code MutableRealmInteger}.
+     */
+    public abstract void increment(long inc);
+
+    /**
+     * Decrements the {@code MutableRealmInteger}, subtracting the value of the argument.
+     * Increment/decrement from all devices are reflected in the new value, which is guaranteed to converge.
+     *
+     * @param dec quantity to be subtracted from the {@code MutableRealmInteger}.
+     */
+    public abstract void decrement(long dec);
+
+    /**
+     * @return true if and only if {@link #get} will return {@code null}.
+     */
+    public final boolean isNull() {
+        return get() == null;
+    }
+
+    /**
+     * {@code MutableRealmInteger}s compare strictly by their values.
+     * Null is a legal value for a {@code MutableRealmInteger} and {@code null} &lt; any non-{@code null} value
+     *
+     * @param o the compare target
+     * @return -1, 0, or 1, depending on whether this object's value is &lt;, =, or &gt; the target's.
+     */
+    @Override
+    public final int compareTo(MutableRealmInteger o) {
+        Long thisValue = get();
+        Long otherValue = o.get();
+        return (thisValue == null)
+                ? ((otherValue == null) ? 0 : -1)
+                : ((otherValue == null) ? 1 : thisValue.compareTo (otherValue));
+    }
+
+    /**
+     * A {@code MutableRealmInteger}'s hash code is, exactly, the hash code of its value.
+     *
+     * @return true if the target has the same value.
+     */
+    @Override
+    public final int hashCode() {
+        Long thisValue = get();
+        return (thisValue == null) ? 0 : thisValue.hashCode();
+    }
+
+    /**
+     * Two {@code MutableRealmInteger}s are {@code .equals} if and only if their {@code longValues} are equal.
+     *
+     * @param o compare target
+     * @return true if the target has the same value.
+     */
+    @Override
+    public final boolean equals(Object o) {
+        if (o == this) { return true; }
+        if (!(o instanceof MutableRealmInteger)) { return false; }
+        Long thisValue = get();
+        Long otherValue = ((MutableRealmInteger) o).get();
+        return (thisValue == null) ? otherValue == null : thisValue.equals(otherValue);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index 1b2c92e1b0..da46f0298e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -520,6 +520,12 @@ public void setLong(long columnIndex, long rowIndex, long value, boolean isDefau
         nativeSetLong(nativePtr, columnIndex, rowIndex, value, isDefault);
     }
 
+    // must not be called on a primary key field
+    public void incrementLong(long columnIndex, long rowIndex, long value) {
+        checkImmutable();
+        nativeIncrementLong(nativePtr, columnIndex, rowIndex, value);
+    }
+
     public void setBoolean(long columnIndex, long rowIndex, boolean value, boolean isDefault) {
         checkImmutable();
         nativeSetBoolean(nativePtr, columnIndex, rowIndex, value, isDefault);
@@ -932,6 +938,8 @@ public static String getTableNameForClass(String name) {
 
     public static native void nativeSetLongUnique(long nativeTablePtr, long columnIndex, long rowIndex, long value);
 
+    public static native void nativeIncrementLong(long nativeTablePtr, long columnIndex, long rowIndex, long value);
+
     public static native void nativeSetBoolean(long nativeTablePtr, long columnIndex, long rowIndex, boolean value, boolean isDefault);
 
     public static native void nativeSetFloat(long nativeTablePtr, long columnIndex, long rowIndex, float value, boolean isDefault);
