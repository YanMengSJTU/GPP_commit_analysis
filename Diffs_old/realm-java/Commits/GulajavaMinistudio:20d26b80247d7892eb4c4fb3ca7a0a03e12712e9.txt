diff --git a/CHANGELOG.md b/CHANGELOG.md
index 1bd465fb72..75c09e5384 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,4 +1,4 @@
-## 4.1.0 (YYYY-MM-DD)
+## 4.1.0 (2017-10-20)
 
 ## Enhancements
 
@@ -7,20 +7,11 @@
 ## Bug Fixes
 
 * Fix some potential database corruption caused by deleting the Realm file while a Realm instance are still opened in another process or the sync client thread.
-
-## Internal
-
-### Credits
-
-
-## 4.0.1 (YYYY-MM-DD)
-
-## Bug Fixes
-
 * Added `realm.ignoreKotlinNullability` as a kapt argument to disable treating kotlin non-null types as `@Required` (#5412) (introduced in `v3.6.0`).
+* Increased http connect/write timeout for low bandwidth network.
 
 
-## 4.0.0 (2016-10-16)
+## 4.0.0 (2017-10-16)
 
 ## Breaking Changes
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
index c6fdeb9f36..4783b3d42e 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
@@ -41,8 +41,8 @@
     private static final String ACTION_LOOKUP_USER_ID = "users/:provider:/:providerId:"; // Auth end point for looking up user id
 
     private final OkHttpClient client = new OkHttpClient.Builder()
-            .connectTimeout(10, TimeUnit.SECONDS)
-            .writeTimeout(10, TimeUnit.SECONDS)
+            .connectTimeout(15, TimeUnit.SECONDS)
+            .writeTimeout(15, TimeUnit.SECONDS)
             .readTimeout(30, TimeUnit.SECONDS)
             // using custom Connection Pool to evict idle connection after 5 seconds rather than 5 minutes (which is the default)
             // keeping idle connection on the pool will prevent the ROS to be stopped, since the HttpUtils#stopSyncServer query
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
index 307c46660a..d757107729 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
@@ -18,11 +18,13 @@
 
 import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
 import java.net.URI;
+import java.util.Locale;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -82,17 +84,32 @@ private void assertTransferComplete(Progress progress, boolean nonZeroChange) {
 
     // Create remote data for a given user.
     private URI createRemoteData(SyncUser user) {
-        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM).build();
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .name("remote")
+                .build();
         final Realm realm = Realm.getInstance(config);
-        writeSampleData(realm);
         final CountDownLatch changesUploaded = new CountDownLatch(1);
         final SyncSession session = SyncManager.getSession(config);
-        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+        final long beforeAdd = realm.where(AllTypes.class).count();
+        writeSampleData(realm);
+
+        session.addUploadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
             @Override
             public void onChange(Progress progress) {
                 if (progress.isTransferComplete()) {
-                    session.removeProgressListener(this);
-                    changesUploaded.countDown();
+                    Realm realm = Realm.getInstance(config);
+                    final long afterAdd = realm.where(AllTypes.class).count();
+                    realm.close();
+
+                    RealmLog.warn(String.format(Locale.ENGLISH,"createRemoteData upload %d/%d objects count:%d",
+                            progress.getTransferredBytes(), progress.getTransferableBytes(), afterAdd));
+                    // FIXME: Remove this after https://github.com/realm/realm-object-store/issues/581
+                    if (afterAdd == TEST_SIZE + beforeAdd) {
+                        session.removeProgressListener(this);
+                        changesUploaded.countDown();
+                    } else if (afterAdd < TEST_SIZE + beforeAdd) {
+                        fail("The added objects are more than expected.");
+                    }
                 }
             }
         });
@@ -128,6 +145,7 @@ public void onChange(Progress progress) {
     }
 
     @Test
+    @Ignore("https://github.com/realm/realm-sync/issues/1770")
     public void downloadProgressListener_indefinitely() throws InterruptedException {
         final AtomicInteger transferCompleted = new AtomicInteger(0);
         final CountDownLatch allChangesDownloaded = new CountDownLatch(1);
@@ -148,50 +166,51 @@ public void run() {
         worker.start();
 
         SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
-        final SyncConfiguration adminConfig = configFactory.createSyncConfigurationBuilder(adminUser, serverUrl.toString()).build();
+        final SyncConfiguration adminConfig = configFactory.createSyncConfigurationBuilder(adminUser, serverUrl.toString())
+                .name("local")
+                .build();
         Realm adminRealm = Realm.getInstance(adminConfig);
         Realm userRealm = Realm.getInstance(configFactory.createSyncConfigurationBuilder(userWithData, Constants.USER_REALM).build()); // Keep session alive
         SyncSession session = SyncManager.getSession(adminConfig);
         session.addDownloadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
             @Override
             public void onChange(Progress progress) {
-                if (progress.isTransferComplete()) {
+                Realm adminRealm = Realm.getInstance(adminConfig);
+                long objectCounts = adminRealm.where(AllTypes.class).count();
+                adminRealm.close();
+                // The downloading progress listener could be triggered at the db version where only contains the meta
+                // data. So we start checking from when the first 10 objects downloaded.
+                if (objectCounts != 0 && progress.isTransferComplete()) {
+
                     switch (transferCompleted.incrementAndGet()) {
-                        case 1:
-                            // Initial trigger when registering
-                            assertTransferComplete(progress, false);
-                            break;
-                        case 2: {
+                        case 1: {
+                            assertEquals(TEST_SIZE, objectCounts);
                             assertTransferComplete(progress, true);
-                            Realm adminRealm = Realm.getInstance(adminConfig);
-                            assertEquals(TEST_SIZE, adminRealm.where(AllTypes.class).count());
-                            adminRealm.close();
                             startWorker.countDown();
                             break;
                         }
-                        case 3: {
+                        case 2: {
                             assertTransferComplete(progress, true);
-                            Realm adminRealm = Realm.getInstance(adminConfig);
-                            assertEquals(TEST_SIZE * 2, adminRealm.where(AllTypes.class).count());
-                            adminRealm.close();
+                            assertEquals(TEST_SIZE * 2, objectCounts);
                             allChangesDownloaded.countDown();
                             break;
                         }
                         default:
                             fail("Transfer complete called too many times:" + transferCompleted.get());
                     }
+                    RealmLog.warn(String.format(
+                            Locale.ENGLISH,"downloadProgressListener_indefinitely download %d/%d objects count:%d",
+                            progress.getTransferredBytes(), progress.getTransferableBytes(), objectCounts));
                 }
             }
         });
         TestHelper.awaitOrFail(allChangesDownloaded);
         adminRealm.close();
         userRealm.close();
+        // worker thread will hang if logout happens before listener triggered.
+        worker.join();
         userWithData.logout();
         adminUser.logout();
-        // FIXME sometimes the worker thread doesn't terminate
-        // causing the test thread to wait  indefinitely until it times out
-        // https://github.com/realm/realm-java/issues/5245
-        worker.join();
     }
 
     // Make sure that a ProgressListener continues to report the correct thing, even if it crashed
@@ -263,7 +282,12 @@ public void uploadProgressListener_indefinitely() {
         session.addUploadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
             @Override
             public void onChange(Progress progress) {
-                if (progress.isTransferComplete()) {
+                Realm tempRealm = Realm.getInstance(config);
+                long objectsCount = tempRealm.where(AllTypes.class).count();
+                tempRealm.close();
+                // FIXME: Remove the objectsCount checking when
+                // https://github.com/realm/realm-object-store/issues/581 gets fixed
+                if (objectsCount != 0 && progress.isTransferComplete()) {
                     switch(transferCompleted.incrementAndGet()) {
                         case 1:
                             Realm realm = Realm.getInstance(config);
diff --git a/version.txt b/version.txt
index 83a328a922..2f81801b79 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-4.1.0-SNAPSHOT
\ No newline at end of file
+4.1.1-SNAPSHOT
\ No newline at end of file
