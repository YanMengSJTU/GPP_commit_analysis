diff --git a/CHANGELOG.md b/CHANGELOG.md
index 70fa4587ef..5d601e05b1 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -12,6 +12,7 @@
 
 * [ObjectServer] Fixed a crash when an authentication error happens (#4726).
 * [ObjectServer] Enabled encryption with Sync (#4561).
+* [ObjectServer] Admin users did not connect correctly to the server (#4750).
 
 ### Internal
 
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index d567cbe844..8e72d79a99 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -92,6 +92,9 @@ android {
     packagingOptions {
         exclude 'META-INF/NOTICE.txt'
         exclude 'META-INF/LICENSE.txt'
+        // We did strip with cmake for release build.
+        // Please, Gradle, you are not that smart! Pleas DO NOT strip debug symbols for debug build!
+        doNotStrip "*/*/*.so"
     }
 
     lintOptions {
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
index 148c0c8914..e2eaa319cd 100644
--- a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
@@ -60,16 +60,14 @@ JNIEXPORT jstring JNICALL Java_io_realm_RealmFileUserStore_nativeGetUser(JNIEnv*
 
 JNIEXPORT void JNICALL Java_io_realm_RealmFileUserStore_nativeUpdateOrCreateUser(JNIEnv* env, jclass,
                                                                                  jstring identity, jstring json_token,
-                                                                                 jstring url, jboolean is_admin)
+                                                                                 jstring url)
 {
     TR_ENTER()
     try {
-        JStringAccessor user_identity(env, identity);    // throws
+        JStringAccessor user_identity(env, identity);     // throws
         JStringAccessor user_json_token(env, json_token); // throws
-        JStringAccessor auth_url(env, url);              // throws
-
-        SyncUser::TokenType token_type = (is_admin) ? SyncUser::TokenType::Admin : SyncUser::TokenType::Normal;
-        SyncManager::shared().get_user(user_identity, user_json_token, std::string(auth_url), token_type);
+        JStringAccessor auth_url(env, url);               // throws
+        SyncManager::shared().get_user(user_identity, user_json_token, std::string(auth_url));
     }
     CATCH_STD()
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
index 6b03bf8573..e208131397 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
@@ -32,7 +32,7 @@
     public void put(SyncUser user) {
         String userJson = user.toJson();
         // create or update token (userJson) using identity
-        nativeUpdateOrCreateUser(user.getIdentity(), userJson, user.getSyncUser().getAuthenticationUrl().toString(), user.isAdmin());
+        nativeUpdateOrCreateUser(user.getIdentity(), userJson, user.getSyncUser().getAuthenticationUrl().toString());
     }
 
     /**
@@ -92,7 +92,7 @@ private static SyncUser toSyncUserOrNull(String userJson) {
 
     protected static native String[] nativeGetAllUsers();
 
-    protected static native void nativeUpdateOrCreateUser(String identity, String jsonToken, String url, boolean isAdmin);
+    protected static native void nativeUpdateOrCreateUser(String identity, String jsonToken, String url);
 
     protected static native void nativeLogoutUser(String identity);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index 8ef5862f5f..906454f00c 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -296,7 +296,7 @@ private synchronized static String bindSessionWithConfig(String sessionPath) {
             RealmLog.error("Matching Java SyncSession could not be found for: " + sessionPath);
         } else {
             try {
-                return syncSession.accessToken(authServer);
+                return syncSession.getAccessToken(authServer);
             } catch (Exception exception) {
                 RealmLog.error(exception);
             }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index 846e79bd98..408d1daec2 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -242,9 +242,10 @@ private void checkIfNotOnMainThread(String errorMessage) {
         void onError(SyncSession session, ObjectServerError error);
     }
 
-    String accessToken(final AuthenticationServer authServer) {
+    // Return the access token for the Realm this Session is connected to.
+    String getAccessToken(final AuthenticationServer authServer) {
         // check first if there's a valid access_token we can return immediately
-        if (getUser().getSyncUser().isAuthenticated(configuration)) {
+        if (getUser().getSyncUser().isRealmAuthenticated(configuration)) {
             Token accessToken = getUser().getSyncUser().getAccessToken(configuration.getServerUrl());
             // start refreshing this token if a refresh is not going on
             if (!onGoingAccessTokenQuery.getAndSet(true)) {
@@ -292,9 +293,9 @@ private void authenticateRealm(final AuthenticationServer authServer) {
             protected AuthenticateResponse execute() {
                 if (!isClosed && !Thread.currentThread().isInterrupted()) {
                     return authServer.loginToRealm(
-                            getUser().getAccessToken(),//refresh token in fact
+                            getUser().getAccessToken(), //refresh token in fact
                             configuration.getServerUrl(),
-                            getUser().getSyncUser().getAuthenticationUrl()
+                            getUser().getAuthenticationUrl()
                     );
                 }
                 return null;
@@ -309,9 +310,11 @@ protected void onSuccess(AuthenticateResponse response) {
                             configuration.getPath(),
                             configuration.shouldDeleteRealmOnLogout()
                     );
-                    getUser().getSyncUser().addRealm(configuration.getServerUrl(), desc);
+                    URI realmUrl = configuration.getServerUrl();
+                    getUser().getSyncUser().addRealm(realmUrl, desc);
+                    String token = getUser().getSyncUser().getAccessToken(realmUrl).value();
                     // schedule a token refresh before it expires
-                    if (nativeRefreshAccessToken(configuration.getPath(), getUser().getSyncUser().getAccessToken(configuration.getServerUrl()).value(), configuration.getServerUrl().toString())) {
+                    if (nativeRefreshAccessToken(configuration.getPath(), token, realmUrl.toString())) {
                         scheduleRefreshAccessToken(authServer, response.getAccessToken().expiresMs());
 
                     } else {
@@ -335,35 +338,35 @@ protected void onError(AuthenticateResponse response) {
     }
 
     private void scheduleRefreshAccessToken(final AuthenticationServer authServer, long expireDateInMs) {
-            // calculate the delay time before which we should refresh the access_token,
-            // we adjust to 10 second to proactively refresh the access_token before the session
-            // hit the expire date on the token
-            long refreshAfter =  expireDateInMs - System.currentTimeMillis() - REFRESH_MARGIN_DELAY;
-            if (refreshAfter < 0) {
-                // Token already expired
-                RealmLog.debug("Expires time already reached for the access token, refresh as soon as possible");
-                // we avoid refreshing directly to avoid an edge case where the client clock is ahead
-                // of the server, causing all access_token received from the server to be always
-                // expired, we will flood the server with refresh token requests then, so adding
-                // a bit of delay is the best effort in this case.
-                refreshAfter = REFRESH_MARGIN_DELAY;
-            }
+        // calculate the delay time before which we should refresh the access_token,
+        // we adjust to 10 second to proactively refresh the access_token before the session
+        // hit the expire date on the token
+        long refreshAfter =  expireDateInMs - System.currentTimeMillis() - REFRESH_MARGIN_DELAY;
+        if (refreshAfter < 0) {
+            // Token already expired
+            RealmLog.debug("Expires time already reached for the access token, refresh as soon as possible");
+            // we avoid refreshing directly to avoid an edge case where the client clock is ahead
+            // of the server, causing all access_token received from the server to be always
+            // expired, we will flood the server with refresh token requests then, so adding
+            // a bit of delay is the best effort in this case.
+            refreshAfter = REFRESH_MARGIN_DELAY;
+        }
 
-            RealmLog.debug("Scheduling an access_token refresh in " + (refreshAfter) + " milliseconds");
+        RealmLog.debug("Scheduling an access_token refresh in " + (refreshAfter) + " milliseconds");
 
-            if (refreshTokenTask != null) {
-                refreshTokenTask.cancel();
-            }
+        if (refreshTokenTask != null) {
+            refreshTokenTask.cancel();
+        }
 
-            ScheduledFuture<?> task = REFRESH_TOKENS_EXECUTOR.schedule(new Runnable() {
-                @Override
-                public void run() {
-                    if (!isClosed && !Thread.currentThread().isInterrupted()) {
-                        refreshAccessToken(authServer);
-                    }
+        ScheduledFuture<?> task = REFRESH_TOKENS_EXECUTOR.schedule(new Runnable() {
+            @Override
+            public void run() {
+                if (!isClosed && !Thread.currentThread().isInterrupted()) {
+                    refreshAccessToken(authServer);
                 }
-            }, refreshAfter, TimeUnit.MILLISECONDS);
-            refreshTokenTask = new RealmAsyncTaskImpl(task, REFRESH_TOKENS_EXECUTOR);
+            }
+        }, refreshAfter, TimeUnit.MILLISECONDS);
+        refreshTokenTask = new RealmAsyncTaskImpl(task, REFRESH_TOKENS_EXECUTOR);
     }
 
     // Authenticate by getting access tokens for the specific Realm
@@ -385,14 +388,15 @@ protected void onSuccess(AuthenticateResponse response) {
                 synchronized (SyncSession.this) {
                     if (!isClosed && !Thread.currentThread().isInterrupted()) {
                         RealmLog.debug("Access Token refreshed successfully, Sync URL: " + configuration.getServerUrl());
-                        if (nativeRefreshAccessToken(configuration.getPath(), response.getAccessToken().value(), configuration.getUser().getAuthenticationUrl().toString())) {
+                        URI realmUrl = configuration.getServerUrl();
+                        if (nativeRefreshAccessToken(configuration.getPath(), response.getAccessToken().value(), realmUrl.toString())) {
                             // replaced the user old access_token
                             ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(
                                     response.getAccessToken(),
                                     configuration.getPath(),
                                     configuration.shouldDeleteRealmOnLogout()
                             );
-                            getUser().getSyncUser().addRealm(configuration.getServerUrl(), desc);
+                            getUser().getSyncUser().addRealm(realmUrl, desc);
 
                             // schedule the next refresh
                             scheduleRefreshAccessToken(authServer, response.getAccessToken().expiresMs());
@@ -434,7 +438,7 @@ private void clearScheduledAccessTokenRefresh() {
          */
         public void waitForServerChanges() throws InterruptedException {
             if (!resultReceived) {
-               waitForChanges.await();
+                waitForChanges.await();
             }
         }
 
@@ -466,7 +470,6 @@ public void throwExceptionIfNeeded() {
         }
     }
 
-    private static native boolean nativeRefreshAccessToken(String path, String accessToken, String authURL);
+    private static native boolean nativeRefreshAccessToken(String path, String accessToken, String realmUrl);
     private native boolean nativeWaitForDownloadCompletion(String path);
 }
-
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
index 235c032a9b..a5e731bf34 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
@@ -65,7 +65,7 @@ private void setRefreshToken(final Token refreshToken) {
      *
      * Authenticating will happen automatically as part of opening a Realm.
      */
-    public boolean isAuthenticated(SyncConfiguration configuration) {
+    public boolean isRealmAuthenticated(SyncConfiguration configuration) {
         Token token = getAccessToken(configuration.getServerUrl());
         return token != null && token.expiresMs() > System.currentTimeMillis();
     }
@@ -93,6 +93,9 @@ public String getIdentity() {
         return identity;
     }
 
+    /**
+     * Return the access token for a given Realm URL or null if none was found
+     */
     public Token getAccessToken(URI serverUrl) {
         AccessDescription accessDescription = realms.get(serverUrl);
         return (accessDescription != null) ? accessDescription.accessToken : null;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
new file mode 100644
index 0000000000..f535ba3c22
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.InstrumentationRegistry;
+import android.util.Log;
+
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+import io.realm.internal.Util;
+import io.realm.log.LogLevel;
+import io.realm.log.RealmLog;
+import io.realm.objectserver.utils.HttpUtils;
+
+public class BaseIntegrationTest {
+
+    private static int originalLogLevel;
+
+    @BeforeClass
+    public static void setUp () throws Exception {
+        SyncManager.Debug.skipOnlineChecking = true;
+        try {
+            HttpUtils.startSyncServer();
+        } catch (Exception e) {
+            // Throwing an exception from this method will crash JUnit. Instead just log it.
+            // If this setup method fails, all unit tests in the class extending it will most likely fail as well.
+            Log.e(HttpUtils.TAG, "Could not start Sync Server: " + Util.getStackTrace(e));
+        }
+    }
+
+    @AfterClass
+    public static void tearDown () throws Exception {
+        try {
+            HttpUtils.stopSyncServer();
+        } catch (Exception e) {
+            Log.e(HttpUtils.TAG, "Failed to stop Sync Server" + Util.getStackTrace(e));
+        }
+    }
+
+    @Before
+    public void setupTest() throws IOException {
+        // TODO We should implement a more consistent reset method for all of Sync that reset
+        // everything completely including deleting all files.
+        deleteRosFiles();
+        if (BaseRealm.applicationContext != null) {
+            // Realm was already initialized. Reset all internal state
+            // in order to be able fully re-initialize.
+
+            // This will set the 'm_metadata_manager' in 'sync_manager.cpp' to be 'null'
+            // causing the SyncUser to remain in memory.
+            // They're actually not persisted into disk.
+            // move this call to 'tearDown' to clean in-memory & on-disk users
+            // once https://github.com/realm/realm-object-store/issues/207 is resolved
+            SyncManager.reset();
+            BaseRealm.applicationContext = null; // Required for Realm.init() to work
+        }
+        Realm.init(InstrumentationRegistry.getContext());
+        originalLogLevel = RealmLog.getLevel();
+        RealmLog.setLevel(LogLevel.DEBUG);
+    }
+
+    @After
+    public void tearDownTest() throws IOException {
+        RealmLog.setLevel(originalLogLevel);
+    }
+
+
+    // Cleanup filesystem to make sure nothing lives for the next test.
+    // Failing to do so might lead to DIVERGENT_HISTORY errors being thrown if Realms from
+    // previous tests are being accessed.
+    private static void deleteRosFiles() throws IOException {
+        File rosFiles = new File(InstrumentationRegistry.getContext().getFilesDir(),"realm-object-server");
+        deleteFile(rosFiles);
+    }
+
+    private static void deleteFile(File file) throws IOException {
+        if (file.isDirectory()) {
+            for (File c : file.listFiles()) {
+                deleteFile(c);
+            }
+        }
+        if (!file.delete()) {
+            throw new IllegalStateException("Failed to delete file or directory: " + file.getAbsolutePath());
+        }
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
index 82c024fb2f..46fc2d8a8e 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
@@ -31,7 +31,6 @@
 import io.realm.exceptions.RealmFileException;
 import io.realm.log.LogLevel;
 import io.realm.log.RealmLog;
-import io.realm.objectserver.BaseIntegrationTest;
 import io.realm.objectserver.utils.Constants;
 import io.realm.rule.TestSyncConfigurationFactory;
 
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
index c4b3c28d6d..277aa407cb 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
@@ -36,7 +36,6 @@
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.DownloadingRealmInterruptedException;
 import io.realm.exceptions.RealmMigrationNeededException;
-import io.realm.objectserver.BaseIntegrationTest;
 import io.realm.objectserver.utils.Constants;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index a315e08331..2555da89da 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -16,6 +16,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import io.realm.BaseIntegrationTest;
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java
deleted file mode 100644
index a6cd05356e..0000000000
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.objectserver;
-
-import android.support.test.InstrumentationRegistry;
-
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
-
-import io.realm.Realm;
-import io.realm.SyncManager;
-import io.realm.log.LogLevel;
-import io.realm.log.RealmLog;
-import io.realm.objectserver.utils.HttpUtils;
-
-public class BaseIntegrationTest {
-
-    private static int originalLogLevel;
-
-    @BeforeClass
-    public static void setUp () throws Exception {
-        SyncManager.Debug.skipOnlineChecking = true;
-        try {
-            Realm.init(InstrumentationRegistry.getContext());
-            originalLogLevel = RealmLog.getLevel();
-            RealmLog.setLevel(LogLevel.DEBUG);
-            HttpUtils.startSyncServer();
-        } catch (Exception e) {
-            // Throwing an exception from this method will crash JUnit. Instead just log it.
-            // If this setup method fails, all unit tests in the class extending it will most likely fail as well.
-            RealmLog.error("Could not start Sync Server", e);
-        }
-    }
-
-    @AfterClass
-    public static void tearDown () throws Exception {
-        try {
-            HttpUtils.stopSyncServer();
-            RealmLog.setLevel(originalLogLevel);
-        } catch (Exception e) {
-            RealmLog.error("Failed to stop Sync Server", e);
-        }
-    }
-}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
index 63bcb72115..b3880a158b 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
@@ -11,6 +11,7 @@
 import java.util.UUID;
 import java.util.concurrent.TimeUnit;
 
+import io.realm.BaseIntegrationTest;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
 import io.realm.RealmResults;
@@ -39,16 +40,6 @@
     @Rule
     public final TestSyncConfigurationFactory configurationFactory = new TestSyncConfigurationFactory();
 
-    @Before
-    public void before() {
-        // This will set the 'm_metadata_manager' in 'sync_manager.cpp' to be 'null'
-        // causing the SyncUser to remain in memory.
-        // They're actually not persisted into disk.
-        // move this call to 'tearDown' to clean in-memory & on-disk users
-        // once https://github.com/realm/realm-object-store/issues/207 is resolved
-        SyncTestUtils.resetSyncMetadata();
-    }
-
     // Make sure the encryption is local, i.e after deleting a synced Realm
     // re-open it again with no (or different) key, should be possible.
     @Test
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
index ecb219cdae..bf31f5bd25 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
@@ -26,11 +26,13 @@
 import java.util.Date;
 import java.util.concurrent.atomic.AtomicReference;
 
+import io.realm.BaseIntegrationTest;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
 import io.realm.RealmResults;
 import io.realm.SyncConfiguration;
+import io.realm.SyncCredentials;
 import io.realm.SyncSession;
 import io.realm.SyncUser;
 import io.realm.entities.Dog;
@@ -41,9 +43,9 @@
 import io.realm.permissions.PermissionOfferResponse;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
-import io.realm.rule.TestSyncConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
@@ -52,7 +54,43 @@
     @Rule
     public RunInLooperThread looperThread = new RunInLooperThread();
 
-    @Ignore("TODO: Test is currently flaky. See https://github.com/realm/realm-java/pull/4066")
+    // This is primarily a test making sure that an admin user actually connects correctly to ROS.
+    // See https://github.com/realm/realm-java/issues/4750
+    @Test
+    @RunTestInLooperThread
+    public void adminUser_writeInvalidPermissionOffer() {
+        final SyncUser user = UserFactory.createAdminUser(Constants.AUTH_URL);
+        assertTrue(user.isValid());
+        Realm realm = user.getManagementRealm();
+        looperThread.closeAfterTest(realm);
+        looperThread.runAfterTest(new Runnable() {
+            @Override
+            public void run() {
+                user.logout();
+            }
+        });
+        realm.beginTransaction();
+        // Invalid Permission offer
+        realm.copyToRealm(new PermissionOffer("*", true, true, false, null));
+        realm.commitTransaction();
+        RealmResults <PermissionOffer> results = realm.where(PermissionOffer.class).findAllAsync();
+        looperThread.keepStrongReference(results);
+        results.addChangeListener(new RealmChangeListener <RealmResults <PermissionOffer>>() {
+            @Override
+            public void onChange(RealmResults <PermissionOffer> offers) {
+                if (offers.size() > 0) {
+                    PermissionOffer offer = offers.first();
+                    Integer statusCode = offer.getStatusCode();
+                    if (statusCode != null && statusCode > 0) {
+                        assertTrue(offer.getStatusMessage().contains("The path is invalid or current user has no access."));
+                        looperThread.testComplete();
+                    }
+                }
+            }
+        });
+    }
+
+    @Ignore("Failing due to terminate called after throwing an instance of 'realm::MultipleSyncAgents'. Will be fixed when upgrading to Sync 1.10")
     @Test
     @RunTestInLooperThread
     public void create_acceptOffer() {
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
index 3f63754def..836d3a4eef 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
@@ -27,6 +27,7 @@
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import io.realm.BaseIntegrationTest;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
 import io.realm.RealmResults;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
index ab909c0770..fca7147dc5 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
@@ -16,9 +16,10 @@
 
 package io.realm.objectserver.utils;
 
+import android.util.Log;
+
 import java.io.IOException;
 
-import io.realm.log.RealmLog;
 import okhttp3.Headers;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
@@ -27,6 +28,8 @@
 /**
  * Start and Stop the node server responsible of creating a
  * temp directory & start a sync server on it for each unit test.
+ *
+ * WARNING: This class is called before Realm is initialized, so RealmLog cannot be used.
  */
 public class HttpUtils {
     private final static OkHttpClient client = new OkHttpClient.Builder()
@@ -35,8 +38,9 @@
 
     // adb reverse tcp:8888 tcp:8888
     // will forward this query to the host, running the integration test server on 8888
-    private final static String START_SERVER = "http://127.0.0.1:8888/start";
-    private final static String STOP_SERVER = "http://127.0.0.1:8888/stop";
+    private static final String START_SERVER = "http://127.0.0.1:8888/start";
+    private static final String STOP_SERVER = "http://127.0.0.1:8888/stop";
+    public static final String TAG = "IntegrationTestServer";
 
     public static void startSyncServer() throws Exception {
         Request request = new Request.Builder()
@@ -48,10 +52,10 @@ public static void startSyncServer() throws Exception {
 
         Headers responseHeaders = response.headers();
         for (int i = 0; i < responseHeaders.size(); i++) {
-            RealmLog.debug(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+            Log.d(TAG, responseHeaders.name(i) + ": " + responseHeaders.value(i));
         }
 
-        RealmLog.debug(response.body().string());
+        Log.d(TAG, response.body().string());
 
         // FIXME: Server ready checking should be done in the control server side!
         if (!waitAuthServerReady()) {
@@ -103,9 +107,9 @@ public static void stopSyncServer() throws Exception {
 
         Headers responseHeaders = response.headers();
         for (int i = 0; i < responseHeaders.size(); i++) {
-            RealmLog.debug(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+            Log.d(TAG, responseHeaders.name(i) + ": " + responseHeaders.value(i));
         }
 
-        RealmLog.debug(response.body().string());
+        Log.d(TAG, response.body().string());
     }
 }
