diff --git a/CHANGELOG.md b/CHANGELOG.md
index 47022631a8..726e42690c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,48 @@
-## 4.2.0 (2017-11-17)
+## 4.3.1 (2017-12-06)
 
-### Breaking Changes
+### Bug Fixes
+
+* Fixed kotlin standard library being added to both Java and Kotlin projects (#5587).
+
+
+## 4.3.0 (2017-12-05)
+
+### Deprecated
+
+* Support for mips devices are deprecated.
+* `RealmQuery.findAllSorted()` and `RealmQuery.findAllSortedAsync()` variants in favor of predicate `RealmQuery.sort().findAll()`.
+* `RealmQuery.distinct()` and `RealmQuery.distinctAsync()` variants in favor of predicate `RealmQuery.distinctValues().findAll()`
+
+### Enhancements
+
+* [ObjectServer] Added explicit support for JSON Web Tokens (JWT) using `SyncCredentials.jwt(String token)`. It requires Object Server 2.0.23+ (#5580).
+* Projects using Kotlin now include additional extension functions that make working with Kotlin easier. See [docs](https://realm.io/docs/java/latest/#kotlin) for more info (#4684).
+* New query predicate: `sort()`.
+* New query predicate: `distinctValues()`. Will be renamed to `distinct` in next major version.
+* The Realm annotation processor now has a stable output when there are no changes to model classes, improving support for incremental compilers (#5567).
+
+### Bug Fixes
+
+* Added missing `toString()` for the implementation of `OrderedCollectionChangeSet`.
+* Sync queries are evaluated immediately to solve the performance issue when the query results are huge, `RealmResults.size()` takes too long time (#5387).
+* Correctly close the Realm instance if an exception was thrown while opening it. This avoids `IllegalStateException` when deleting the Realm in the catch block (#5570).
+* Fixed the listener on `RealmList` not being called when removing the listener then adding it again (#5507). Please notice that a similar issue still exists for `RealmResults`.
+
+### Internal
+
+* Use `OsList` instead of `OsResults` to add notification token on for `RealmList<RealmModel>`.
+* Updated Gradle and plugins to support Android Studio `3.0.0` (#5472).
+* Upgraded to Realm Sync 2.1.8.
+* Upgraded to Realm Core 4.0.4.
+
+### Credits
+
+* Thanks to @tbsandee for fixing a typo (#5548).
+* Thanks to @vivekkiran for updating Gradle and plugins to support Android Studio `3.0.0` (#5472).
+* Thanks to @madisp for adding better support for incremental compilers (#5567).
+
+
+## 4.2.0 (2017-11-17)
 
 ### Enhancements
 
@@ -14,7 +56,7 @@
 * Leaked file handler in the Realm Transformer (#5521).
 * Potential fix for "RealmError: Incompatible lock file" crash (#2459).
 
-### Interal
+### Internal
 
 * Updated JavaAssist to 3.22.0-GA.
 * Upgraded to Realm Sync 2.1.4.
@@ -22,7 +64,7 @@
 
 ### Credits
 
-Thanks to @rakshithravi1997 for adding `RealmQuery.and()` (#5520).
+* Thanks to @rakshithravi1997 for adding `RealmQuery.and()` (#5520).
 
 
 ## 4.1.1 (2017-10-27)
@@ -114,7 +156,7 @@ The internal file format has been upgraded. Opening an older Realm will upgrade
 
 ### Credits
 
-Thanks to @JussiPekonen for adding support for 2-digit time zone designators when importing JSON (#5309).
+* Thanks to @JussiPekonen for adding support for 2-digit time zone designators when importing JSON (#5309).
 
 
 ## 3.7.2 (2017-09-12)
diff --git a/Dockerfile b/Dockerfile
index e2c50e9865..94700dcac9 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -52,9 +52,9 @@ RUN sdkmanager --update
 # Accept all licenses
 RUN yes y | sdkmanager --licenses
 RUN sdkmanager 'platform-tools'
-RUN sdkmanager 'build-tools;26.0.2'
+RUN sdkmanager 'build-tools;27.0.1'
 RUN sdkmanager 'extras;android;m2repository'
-RUN sdkmanager 'platforms;android-26'
+RUN sdkmanager 'platforms;android-27'
 RUN sdkmanager 'cmake;3.6.4111459'
 
 # Install the NDK
diff --git a/Jenkinsfile b/Jenkinsfile
index f511eb1188..7c8e9a7d6d 100644
--- a/Jenkinsfile
+++ b/Jenkinsfile
@@ -95,6 +95,7 @@ try {
                     } finally {
                       stopLogCatCollector(backgroundPid)
                       storeJunitResults 'realm/realm-library/build/outputs/androidTest-results/connected/**/TEST-*.xml'
+                      storeJunitResults 'realm/kotlin-extensions/build/outputs/androidTest-results/connected/**/TEST-*.xml'
                     }
                   }
                 }
@@ -195,8 +196,9 @@ def getTagsString(Map<String, String> tags) {
 def storeJunitResults(String path) {
   step([
 	 $class: 'JUnitResultArchiver',
-	testResults: path
-       ])
+     allowEmptyResults: true,
+     testResults: path
+   ])
 }
 
 def collectAarMetrics() {
diff --git a/README.md b/README.md
index e6b22c7e0b..d7b70b59ba 100644
--- a/README.md
+++ b/README.md
@@ -1,5 +1,8 @@
 ![Realm](logo.png)
 
+[![bintray](https://api.bintray.com/packages/realm/maven/realm-gradle-plugin/images/download.svg) ](https://bintray.com/realm/maven/realm-gradle-plugin/_latestVersion)
+[![License](https://img.shields.io/badge/License-Apache-blue.svg)](https://github.com/realm/realm-java/blob/master/LICENSE)
+
 Realm is a mobile database that runs directly inside phones, tablets or wearables.
 This repository holds the source code for the Java version of Realm, which currently runs only on Android.
 
@@ -21,18 +24,20 @@ The API reference is located at [realm.io/docs/java/api](https://realm.io/docs/j
 
 ## Getting Help
 
-- **Need help with your code?**: Look for previous questions on the [#realm tag](https://stackoverflow.com/questions/tagged/realm?sort=newest) — or [ask a new question](http://stackoverflow.com/questions/ask?tags=realm). We activtely monitor & answer questions on SO!
+- **Need help with your code?**: Look for previous questions on the [#realm tag](https://stackoverflow.com/questions/tagged/realm?sort=newest) — or [ask a new question](http://stackoverflow.com/questions/ask?tags=realm). We actively monitor & answer questions on StackOverflow!
 - **Have a bug to report?** [Open an issue](https://github.com/realm/realm-java/issues/new). If possible, include the version of Realm, a full log, the Realm file, and a project that shows the issue.
 - **Have a feature request?** [Open an issue](https://github.com/realm/realm-java/issues/new). Tell us what the feature should do, and why you want the feature.
 - Sign up for our [**Community Newsletter**](https://go.pardot.com/l/210132/2017-04-26/3j74l) to get regular tips, learn about other use-cases and get alerted of blogposts and tutorials about Realm.
 
 ## Using Snapshots
 
-If you want to test recent bugfixes or features that have not been packaged in an official release yet, you can use a **-SNAPSHOT** release of the current development version of Realm via Gradle, available on [Jfrog OSS](http://oss.jfrog.org/oss-snapshot-local/io/realm/realm-gradle-plugin/)
+If you want to test recent bugfixes or features that have not been packaged in an official release yet, you can use a **-SNAPSHOT** release of the current development version of Realm via Gradle, available on [JFrog OSS](http://oss.jfrog.org/oss-snapshot-local/io/realm/realm-gradle-plugin/)
 
-```gradle
+```
 buildscript {
     repositories {
+        jcenter()
+        google()
         maven {
             url 'http://oss.jfrog.org/artifactory/oss-snapshot-local'
         }
@@ -44,6 +49,8 @@ buildscript {
 
 allprojects {
     repositories {
+        jcenter()
+        google()
         maven {
             url 'http://oss.jfrog.org/artifactory/oss-snapshot-local'
         }
@@ -59,10 +66,10 @@ In case you don't want to use the precompiled version, you can build Realm yours
 
 ### Prerequisites
 
- * Download the [**JDK 7**](http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html) or [**JDK 8**](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) from Oracle and install it.
- * Download & install the Android SDK **Build-Tools 26.0.2**, **Android O (API 26)** (for example through Android Studio’s **Android SDK Manager**).
+ * Download the [**JDK 8**](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) from Oracle and install it.
+ * Download & install the Android SDK **Build-Tools 27.0.1**, **Android Oreo (API 27)** (for example through Android Studio’s **Android SDK Manager**).
  * Install CMake from SDK manager in Android Studio ("SDK Tools" -> "CMake").
- * If you use Android Studio, Android Studio 3.0 or later is required.
+ * If you use Android Studio, Android Studio 3.0 or higher is required.
 
  * Realm currently requires version r10e of the NDK.  Download the one appropriate for your development platform, from the NDK [archive](https://developer.android.com/ndk/downloads/older_releases.html).
 You may unzip the file wherever you choose.  For macOS, a suggested location is `~/Library/Android`.  The download will unzip as the directory `android-ndk-r10e`.
@@ -154,8 +161,7 @@ Generating the Javadoc using the command above may generate warnings. The Javado
 
 ### Upgrading Gradle Wrappers
 
- All gradle projects in this repository have `wrapper` task to generate Gradle Wrappers. Those tasks refer `gradleVersion` propertiy defined in `/realm.properties` in order to determine Geadle Version of generating wrappers. After generating Gradle Wrappers, we need to modify `gradle/wrapper/gradle-wrapper.properties` to use `*-all.zip` distribution instead of `*-bin.zip` distribution.
-
+ All gradle projects in this repository have `wrapper` task to generate Gradle Wrappers. Those tasks refer to `gradleVersion` property defined in `/realm.properties` in order to determine Gradle Version of generating wrappers.
 We have a script `./tools/update_gradle_wrapper.sh` to automate these steps. When you update Gradle Wrappers, please obey the following steps.
 
  1. Edit `gradleVersion` property in defined in `/realm.properties` to new Gradle Wrapper version.
diff --git a/dependencies.list b/dependencies.list
index 35394be8e1..3703b72124 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,9 +1,9 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=2.1.4
-REALM_SYNC_SHA256=6d32ef44acbf4a63b654ceeaadce036feeefd04a4ca649a95a22a0e7d56df84d
+REALM_SYNC_VERSION=2.1.8
+REALM_SYNC_SHA256=14e4aabe270638aa96f84396be27985b6809e532183035c5150dd2933d676248
 
 # Object Server Release used by Integration tests. Installed using NPM.
 # Use `npm view realm-object-server versions` to get a list of available versions.
-REALM_OBJECT_SERVER_DE_VERSION=2.0.18
+REALM_OBJECT_SERVER_DE_VERSION=2.1.0
 
diff --git a/examples/build.gradle b/examples/build.gradle
index 621691d9f1..317a72b51c 100644
--- a/examples/build.gradle
+++ b/examples/build.gradle
@@ -1,5 +1,6 @@
-project.ext.sdkVersion = 26
-project.ext.buildTools = '26.0.2'
+project.ext.sdkVersion = 27
+project.ext.minSdkVersion = 15
+project.ext.buildTools = '27.0.1'
 
 // Don't cache SNAPSHOT (changing) dependencies.
 configurations.all {
@@ -32,7 +33,7 @@ allprojects {
             maven { url 'https://jitpack.io' }
         }
         dependencies {
-            classpath 'com.android.tools.build:gradle:3.0.0-rc2'
+            classpath 'com.android.tools.build:gradle:3.0.0'
             classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
             classpath "io.realm:realm-gradle-plugin:${currentVersion}"
         }
diff --git a/examples/encryptionExample/build.gradle b/examples/encryptionExample/build.gradle
index 1d7baebd33..10707b22ae 100644
--- a/examples/encryptionExample/build.gradle
+++ b/examples/encryptionExample/build.gradle
@@ -6,9 +6,9 @@ android {
     buildToolsVersion rootProject.buildTools
 
     defaultConfig {
-        applicationId 'examples.realm.io.encryptionExample'
+        applicationId 'io.realm.examples.encryption'
         targetSdkVersion rootProject.sdkVersion
-        minSdkVersion 14
+        minSdkVersion rootProject.minSdkVersion
         versionCode 1
         versionName '1.0'
     }
diff --git a/examples/encryptionExample/src/main/AndroidManifest.xml b/examples/encryptionExample/src/main/AndroidManifest.xml
index 00f9f6c7be..93190053ee 100644
--- a/examples/encryptionExample/src/main/AndroidManifest.xml
+++ b/examples/encryptionExample/src/main/AndroidManifest.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest package="io.realm.examples.encryptionexample"
+<manifest package="io.realm.examples.encryption"
           xmlns:android="http://schemas.android.com/apk/res/android">
 
     <application
diff --git a/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java b/examples/encryptionExample/src/main/java/io/realm/examples/encryption/EncryptionExampleActivity.java
similarity index 83%
rename from examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java
rename to examples/encryptionExample/src/main/java/io/realm/examples/encryption/EncryptionExampleActivity.java
index d40a95ce1a..fd5ae8d804 100644
--- a/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java
+++ b/examples/encryptionExample/src/main/java/io/realm/examples/encryption/EncryptionExampleActivity.java
@@ -14,10 +14,11 @@
  * limitations under the License.
  */
 
-package io.realm.examples.encryptionexample;
+package io.realm.examples.encryption;
 
 import android.app.Activity;
 import android.os.Bundle;
+import android.util.Base64;
 import android.util.Log;
 
 import java.security.SecureRandom;
@@ -42,6 +43,13 @@ protected void onCreate(Bundle savedInstanceState) {
         // * http://nelenkov.blogspot.dk/2012/05/storing-application-secrets-in-androids.html
         byte[] key = new byte[64];
         new SecureRandom().nextBytes(key);
+
+        // An encrypted Realm file can be opened in Realm Studio by using a Hex encoded version
+        // of the key. Copy the key from Logcat, then download the Realm file from the device using
+        // the method described here: https://stackoverflow.com/a/28486297/1389357
+        // The path is normally `/data/data/io.realm.examples.encryption/files/default.realm`
+        Log.i("RealmEncryptionKey", Util.bytesToHex(key));
+
         RealmConfiguration realmConfiguration = new RealmConfiguration.Builder()
                 .encryptionKey(key)
                 .build();
diff --git a/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/MyApplication.java b/examples/encryptionExample/src/main/java/io/realm/examples/encryption/MyApplication.java
similarity index 94%
rename from examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/MyApplication.java
rename to examples/encryptionExample/src/main/java/io/realm/examples/encryption/MyApplication.java
index 83fc8be016..cb3cad7472 100644
--- a/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/MyApplication.java
+++ b/examples/encryptionExample/src/main/java/io/realm/examples/encryption/MyApplication.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package io.realm.examples.encryptionexample;
+package io.realm.examples.encryption;
 
 import android.app.Application;
 
diff --git a/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/Person.java b/examples/encryptionExample/src/main/java/io/realm/examples/encryption/Person.java
similarity index 95%
rename from examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/Person.java
rename to examples/encryptionExample/src/main/java/io/realm/examples/encryption/Person.java
index a2a550e4ff..d81f3069c7 100644
--- a/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/Person.java
+++ b/examples/encryptionExample/src/main/java/io/realm/examples/encryption/Person.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package io.realm.examples.encryptionexample;
+package io.realm.examples.encryption;
 
 import io.realm.RealmObject;
 
diff --git a/examples/encryptionExample/src/main/java/io/realm/examples/encryption/Util.java b/examples/encryptionExample/src/main/java/io/realm/examples/encryption/Util.java
new file mode 100644
index 0000000000..2e2bbc1543
--- /dev/null
+++ b/examples/encryptionExample/src/main/java/io/realm/examples/encryption/Util.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.examples.encryption;
+
+public class Util {
+
+    private final static char[] hexArray = "0123456789ABCDEF".toCharArray();
+
+    //Original source: https://stackoverflow.com/a/9855338/1389357
+    public static String bytesToHex(byte[] bytes) {
+        char[] hexChars = new char[bytes.length * 2];
+        for ( int j = 0; j < bytes.length; j++ ) {
+            int v = bytes[j] & 0xFF;
+            hexChars[j * 2] = hexArray[v >>> 4];
+            hexChars[j * 2 + 1] = hexArray[v & 0x0F];
+        }
+        return new String(hexChars);
+    }
+
+}
diff --git a/examples/gradle.properties b/examples/gradle.properties
index 69f84662c3..9c2c6c4094 100644
--- a/examples/gradle.properties
+++ b/examples/gradle.properties
@@ -1,5 +1,6 @@
 org.gradle.jvmargs=-Xmx2048M
 org.gradle.caching=true
+android.enableD8=true
 
 # disable AAPT2 to work around an issue of Robolectric in unitTestExample https://github.com/robolectric/robolectric/issues/3169
 android.enableAapt2=false
diff --git a/examples/gradle/wrapper/gradle-wrapper.jar b/examples/gradle/wrapper/gradle-wrapper.jar
index d457a1a990..0bdf3fe941 100644
Binary files a/examples/gradle/wrapper/gradle-wrapper.jar and b/examples/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/examples/gradle/wrapper/gradle-wrapper.properties b/examples/gradle/wrapper/gradle-wrapper.properties
index c583957d2b..702c4b68b8 100644
--- a/examples/gradle/wrapper/gradle-wrapper.properties
+++ b/examples/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.3.1-all.zip
diff --git a/examples/gradlew.bat b/examples/gradlew.bat
old mode 100644
new mode 100755
diff --git a/examples/gridViewExample/build.gradle b/examples/gridViewExample/build.gradle
index 10615bfbe1..f10dad85fa 100644
--- a/examples/gridViewExample/build.gradle
+++ b/examples/gridViewExample/build.gradle
@@ -8,7 +8,7 @@ android {
     defaultConfig {
         applicationId 'io.realm.examples.realmgridview'
         targetSdkVersion rootProject.sdkVersion
-        minSdkVersion 15
+        minSdkVersion rootProject.minSdkVersion
         versionCode 1
         versionName "1.0"
     }
@@ -38,5 +38,5 @@ android {
 }
 
 dependencies {
-    implementation 'com.google.code.gson:gson:2.5'
+    implementation 'com.google.code.gson:gson:2.8.2'
 }
diff --git a/examples/introExample/build.gradle b/examples/introExample/build.gradle
index fdf0d2dfdc..dc13980d3b 100644
--- a/examples/introExample/build.gradle
+++ b/examples/introExample/build.gradle
@@ -8,7 +8,7 @@ android {
     defaultConfig {
         applicationId 'io.realm.examples.intro'
         targetSdkVersion rootProject.sdkVersion
-        minSdkVersion 15
+        minSdkVersion rootProject.minSdkVersion
         versionCode 1
         versionName "1.0"
     }
diff --git a/examples/jsonExample/build.gradle b/examples/jsonExample/build.gradle
index e3bd188356..8f9242eef1 100644
--- a/examples/jsonExample/build.gradle
+++ b/examples/jsonExample/build.gradle
@@ -8,7 +8,7 @@ android {
     defaultConfig {
         applicationId 'io.realm.examples.json'
         targetSdkVersion rootProject.sdkVersion
-        minSdkVersion 15
+        minSdkVersion rootProject.minSdkVersion
         versionCode 1
         versionName "1.0"
         javaCompileOptions.annotationProcessorOptions.includeCompileClasspath = true
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index 91d3f3166a..df885d428c 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -24,7 +24,7 @@ android {
         applicationId 'io.realm.examples.kotlin'
         //noinspection GroovyAssignabilityCheck
         targetSdkVersion rootProject.sdkVersion
-        minSdkVersion 15
+        minSdkVersion rootProject.minSdkVersion
         versionCode 1
         versionName "1.0"
     }
@@ -44,10 +44,17 @@ android {
     }
 }
 
-// enable @ParametersAreNonnullByDefault annotation. See https://blog.jetbrains.com/kotlin/2017/08/kotlin-1-1-4-is-out/
+// This is added automatically if Kotlin is registered in the project, but Kotlin extension functions
+// for Realm can be excluded if needed.
+realm {
+    kotlinExtensionsEnabled = true
+}
+
+
+// enable @ParametersAreNonnullByDefault annotation. See https://blog.jetbrains.com/kotlin/2017/09/kotlin-1-1-50-is-out/
 tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
     kotlinOptions {
-        freeCompilerArgs = ["-Xjsr305-annotations=enable"]
+        freeCompilerArgs = ["-Xjsr305=strict"]
     }
 }
 
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
index 643704a169..82a2cfb8f5 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
@@ -26,6 +26,8 @@ import io.realm.Sort
 import io.realm.examples.kotlin.model.Cat
 import io.realm.examples.kotlin.model.Dog
 import io.realm.examples.kotlin.model.Person
+import io.realm.kotlin.createObject
+import io.realm.kotlin.where
 import org.jetbrains.anko.doAsync
 import org.jetbrains.anko.uiThread
 import kotlin.properties.Delegates
@@ -91,13 +93,13 @@ class KotlinExampleActivity : Activity() {
         // All writes must be wrapped in a transaction to facilitate safe multi threading
         realm.executeTransaction {
             // Add a person
-            val person = realm.createObject(Person::class.java, 0)
+            val person = realm.createObject<Person>(0)
             person.name = "Young Person"
             person.age = 14
         }
 
         // Find the first person (no query conditions) and read a field
-        val person = realm.where(Person::class.java).findFirst()!!
+        val person = realm.where<Person>().findFirst()!!
         showStatus(person.name + ": " + person.age)
 
         // Update person in a transaction
@@ -110,18 +112,19 @@ class KotlinExampleActivity : Activity() {
 
     private fun basicQuery(realm: Realm) {
         showStatus("\nPerforming basic Query operation...")
-        showStatus("Number of persons: ${realm.where(Person::class.java).count()}")
+        showStatus("Number of persons: ${realm.where<Person>().count()}")
 
-        val results = realm.where(Person::class.java).equalTo("age", 99.toInt()).findAll()
+        val ageCriteria = 99
+        val results = realm.where<Person>().equalTo("age", ageCriteria).findAll()
 
         showStatus("Size of result set: " + results.size)
     }
 
     private fun basicLinkQuery(realm: Realm) {
         showStatus("\nPerforming basic Link Query operation...")
-        showStatus("Number of persons: ${realm.where(Person::class.java).count()}")
+        showStatus("Number of persons: ${realm.where<Person>().count()}")
 
-        val results = realm.where(Person::class.java).equalTo("cats.name", "Tiger").findAll()
+        val results = realm.where<Person>().equalTo("cats.name", "Tiger").findAll()
 
         showStatus("Size of result set: ${results.size}")
     }
@@ -135,10 +138,10 @@ class KotlinExampleActivity : Activity() {
         try {
             // Add ten persons in one transaction
             realm.executeTransaction {
-                val fido = realm.createObject(Dog::class.java)
+                val fido = realm.createObject<Dog>()
                 fido.name = "fido"
                 for (i in 1..9) {
-                    val person = realm.createObject(Person::class.java, i.toLong())
+                    val person = realm.createObject<Person>(i.toLong())
                     person.name = "Person no. $i"
                     person.age = i
                     person.dog = fido
@@ -150,7 +153,7 @@ class KotlinExampleActivity : Activity() {
                     person.tempReference = 42
 
                     for (j in 0..i - 1) {
-                        val cat = realm.createObject(Cat::class.java)
+                        val cat = realm.createObject<Cat>()
                         cat.name = "Cat_$j"
                         person.cats.add(cat)
                     }
@@ -158,10 +161,10 @@ class KotlinExampleActivity : Activity() {
             }
 
             // Implicit read transactions allow you to access your objects
-            status += "\nNumber of persons: ${realm.where(Person::class.java).count()}"
+            status += "\nNumber of persons: ${realm.where<Person>().count()}"
 
             // Iterate over all objects
-            for (person in realm.where(Person::class.java).findAll()) {
+            for (person in realm.where<Person>().findAll()) {
                 val dogName: String = person?.dog?.name ?: "None"
 
                 status += "\n${person.name}: ${person.age} : $dogName : ${person.cats.size}"
@@ -173,8 +176,8 @@ class KotlinExampleActivity : Activity() {
             }
 
             // Sorting
-            val sortedPersons = realm.where(Person::class.java).findAllSorted("age", Sort.DESCENDING)
-            status += "\nSorting ${sortedPersons.last()?.name} == ${realm.where(Person::class.java).findAll().first()?.name}"
+            val sortedPersons = realm.where<Person>().findAllSorted(Person::age.name, Sort.DESCENDING)
+            status += "\nSorting ${sortedPersons.last()?.name} == ${realm.where<Person>().findAll().first()?.name}"
 
         } finally {
             realm.close()
@@ -189,11 +192,11 @@ class KotlinExampleActivity : Activity() {
         // extension method 'use' (pun intended).
         Realm.getDefaultInstance().use {
             // 'it' is the implicit lambda parameter of type Realm
-            status += "\nNumber of persons: ${it.where(Person::class.java).count()}"
+            status += "\nNumber of persons: ${it.where<Person>().count()}"
 
             // Find all persons where age between 7 and 9 and name begins with "Person".
             val results = it
-                    .where(Person::class.java)
+                    .where<Person>()
                     .between("age", 7, 9)       // Notice implicit "and" operation
                     .beginsWith("name", "Person")
                     .findAll()
diff --git a/examples/migrationExample/build.gradle b/examples/migrationExample/build.gradle
index b7991c006c..317d18d44d 100644
--- a/examples/migrationExample/build.gradle
+++ b/examples/migrationExample/build.gradle
@@ -8,7 +8,7 @@ android {
     defaultConfig {
         applicationId "examples.realm.io.migration"
         targetSdkVersion rootProject.sdkVersion
-        minSdkVersion 15
+        minSdkVersion rootProject.minSdkVersion
         versionCode 1
         versionName "1.0"
     }
diff --git a/examples/moduleExample/app/build.gradle b/examples/moduleExample/app/build.gradle
index 424f257901..cfcc837f6a 100644
--- a/examples/moduleExample/app/build.gradle
+++ b/examples/moduleExample/app/build.gradle
@@ -8,7 +8,7 @@ android {
     defaultConfig {
         applicationId 'io.realm.examples.appmodules'
         targetSdkVersion rootProject.sdkVersion
-        minSdkVersion 15
+        minSdkVersion rootProject.minSdkVersion
         versionCode 1
         versionName "1.0"
     }
diff --git a/examples/moduleExample/library/build.gradle b/examples/moduleExample/library/build.gradle
index 3697638a79..78c14a606d 100644
--- a/examples/moduleExample/library/build.gradle
+++ b/examples/moduleExample/library/build.gradle
@@ -7,7 +7,7 @@ android {
 
     defaultConfig {
         targetSdkVersion rootProject.sdkVersion
-        minSdkVersion 15
+        minSdkVersion rootProject.minSdkVersion
         versionCode 1
         versionName "1.0"
     }
diff --git a/examples/multiprocessExample/build.gradle b/examples/multiprocessExample/build.gradle
index 1823f58ecf..f4e84dceaf 100644
--- a/examples/multiprocessExample/build.gradle
+++ b/examples/multiprocessExample/build.gradle
@@ -25,6 +25,6 @@ android {
 }
 
 dependencies {
-    implementation 'com.android.support:appcompat-v7:26.0.1'
+    implementation 'com.android.support:appcompat-v7:27.0.1'
 }
 
diff --git a/examples/newsreaderExample/build.gradle b/examples/newsreaderExample/build.gradle
index e5cfcf0acb..60271b0fbd 100644
--- a/examples/newsreaderExample/build.gradle
+++ b/examples/newsreaderExample/build.gradle
@@ -8,7 +8,7 @@ android {
     defaultConfig {
         applicationId "io.realm.examples.newsreader"
         targetSdkVersion rootProject.sdkVersion
-        minSdkVersion 15
+        minSdkVersion rootProject.minSdkVersion
         versionCode 1
         versionName "1.0"
     }
@@ -39,16 +39,16 @@ android {
 
 dependencies {
     //noinspection GradleDependency
-    implementation 'com.android.support:appcompat-v7:26.0.1'
+    implementation 'com.android.support:appcompat-v7:27.0.1'
     //noinspection GradleDependency
-    implementation 'com.android.support:design:26.0.1'
-    implementation 'com.jakewharton.timber:timber:4.1.0'
+    implementation 'com.android.support:design:27.0.1'
+    implementation 'com.jakewharton.timber:timber:4.5.1'
     implementation 'com.jakewharton:butterknife:8.5.1'
     implementation 'com.squareup.retrofit2:adapter-rxjava2:2.3.0'
     implementation 'com.squareup.retrofit2:converter-jackson:2.3.0'
     implementation 'com.squareup.retrofit2:retrofit:2.3.0'
     implementation 'io.reactivex.rxjava2:rxandroid:2.0.1'
-    implementation 'io.reactivex.rxjava2:rxjava:2.1.0'
+    implementation 'io.reactivex.rxjava2:rxjava:2.1.5'
     implementation 'me.zhanghai.android.materialprogressbar:library:1.1.4'
-    annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1'
+    annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1' //TODO:Can be refactored with Native Android Data Binding
 }
diff --git a/examples/newsreaderExample/gradle.properties b/examples/newsreaderExample/gradle.properties
deleted file mode 100644
index 31590309be..0000000000
--- a/examples/newsreaderExample/gradle.properties
+++ /dev/null
@@ -1 +0,0 @@
-android.enableD8=true
diff --git a/examples/objectServerExample/build.gradle b/examples/objectServerExample/build.gradle
index 722e362451..5044b5d4eb 100644
--- a/examples/objectServerExample/build.gradle
+++ b/examples/objectServerExample/build.gradle
@@ -28,7 +28,7 @@ android {
     defaultConfig {
         applicationId 'io.realm.examples.objectserver'
         targetSdkVersion rootProject.sdkVersion
-        minSdkVersion 16
+        minSdkVersion rootProject.minSdkVersion
         versionCode 1
         versionName "1.0"
     }
@@ -57,10 +57,9 @@ realm {
 }
 
 dependencies {
-    implementation 'com.android.support:support-v4:26.0.1'
-    implementation 'com.android.support:appcompat-v7:26.0.1'
-    implementation 'com.android.support:design:26.0.1'
+    implementation 'com.android.support:appcompat-v7:27.0.1'
+    implementation 'com.android.support:design:27.0.1'
     implementation 'me.zhanghai.android.materialprogressbar:library:1.3.0'
-    implementation 'com.jakewharton:butterknife:8.5.1'
-    annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1'
+    implementation 'com.jakewharton:butterknife:8.8.1'//TODO:Can be refactored with Native Android Data Binding
+    annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1'//TODO:Can be refactored with Native Android Data Binding
 }
diff --git a/examples/rxJavaExample/build.gradle b/examples/rxJavaExample/build.gradle
index d6269c5c59..d08e9d7f73 100644
--- a/examples/rxJavaExample/build.gradle
+++ b/examples/rxJavaExample/build.gradle
@@ -11,7 +11,7 @@ android {
         applicationId 'io.realm.examples.rxjava'
         //noinspection GroovyAssignabilityCheck
         targetSdkVersion rootProject.sdkVersion
-        minSdkVersion 15
+        minSdkVersion rootProject.minSdkVersion
         versionCode 1
         versionName "1.0"
     }
@@ -37,7 +37,7 @@ android {
 dependencies {
     implementation 'io.reactivex.rxjava2:rxandroid:2.0.1'
     implementation 'io.reactivex.rxjava2:rxjava:2.1.0'
-    implementation 'com.android.support:appcompat-v7:26.0.1'
+    implementation 'com.android.support:appcompat-v7:27.0.1'
     implementation 'com.jakewharton.rxbinding2:rxbinding:2.0.0'
     implementation 'com.squareup.retrofit2:adapter-rxjava2:2.3.0'
     implementation 'com.squareup.retrofit2:converter-jackson:2.3.0'
diff --git a/examples/secureTokenAndroidKeyStore/build.gradle b/examples/secureTokenAndroidKeyStore/build.gradle
index 9e90be2ad2..d9a629ca4f 100644
--- a/examples/secureTokenAndroidKeyStore/build.gradle
+++ b/examples/secureTokenAndroidKeyStore/build.gradle
@@ -7,8 +7,8 @@ android {
 
     defaultConfig {
         applicationId "io.realm.examples.securetokenandroidkeystore"
-        minSdkVersion 14
-        targetSdkVersion 25
+        minSdkVersion rootProject.minSdkVersion
+        targetSdkVersion rootProject.sdkVersion
         versionCode 1
         versionName "1.0"
 
@@ -30,10 +30,10 @@ android {
 
 dependencies {
     implementation fileTree(dir: 'libs', include: ['*.jar'])
-    androidTestImplementation('com.android.support.test.espresso:espresso-core:2.2.2', {
+    androidTestImplementation('com.android.support.test.espresso:espresso-core:3.0.1', {
         exclude group: 'com.android.support', module: 'support-annotations'
     })
-    implementation 'com.android.support:appcompat-v7:26.0.1'
+    implementation 'com.android.support:appcompat-v7:27.0.1'
     testImplementation 'junit:junit:4.12'
     implementation 'io.realm:secure-userstore:1.0.1'
 }
diff --git a/examples/settings.gradle b/examples/settings.gradle
index 9edd7eb54f..42ff9775fe 100644
--- a/examples/settings.gradle
+++ b/examples/settings.gradle
@@ -1,3 +1,4 @@
+rootProject.name = 'realm-examples'
 include 'secureTokenAndroidKeyStore'
 include 'encryptionExample'
 include 'gridViewExample'
@@ -13,5 +14,3 @@ include 'newsreaderExample'
 include 'rxJavaExample'
 include 'objectServerExample'
 include 'multiprocessExample'
-
-rootProject.name = 'realm-examples'
diff --git a/examples/threadExample/build.gradle b/examples/threadExample/build.gradle
index 91f88acc74..c0188a8bb5 100644
--- a/examples/threadExample/build.gradle
+++ b/examples/threadExample/build.gradle
@@ -8,7 +8,7 @@ android {
     defaultConfig {
         applicationId "io.realm.examples.threads"
         targetSdkVersion rootProject.sdkVersion
-        minSdkVersion 15
+        minSdkVersion rootProject.minSdkVersion
         versionCode 1
         versionName "1.0"
     }
diff --git a/examples/unitTestExample/build.gradle b/examples/unitTestExample/build.gradle
index ef7e152157..fb80e93400 100644
--- a/examples/unitTestExample/build.gradle
+++ b/examples/unitTestExample/build.gradle
@@ -8,7 +8,7 @@ android {
     defaultConfig {
         applicationId 'io.realm.examples.unittesting'
         targetSdkVersion rootProject.sdkVersion
-        minSdkVersion 15
+        minSdkVersion rootProject.minSdkVersion
         versionCode 1
         versionName "1.0"
 
@@ -34,9 +34,9 @@ android {
 
 
 dependencies {
-    implementation 'com.android.support:appcompat-v7:26.0.1'
+    implementation 'com.android.support:appcompat-v7:27.0.1'
 
-    testImplementation 'io.reactivex.rxjava2:rxjava:2.1.0'
+    testImplementation 'io.reactivex.rxjava2:rxjava:2.1.5'
 
     // Testing
     testImplementation 'junit:junit:4.12'
diff --git a/gradle-plugin/build.gradle b/gradle-plugin/build.gradle
index 3d5bcc70d2..6524932ee5 100644
--- a/gradle-plugin/build.gradle
+++ b/gradle-plugin/build.gradle
@@ -22,11 +22,12 @@ props.each { key, val ->
 
 repositories {
     mavenLocal()
+    google()
     jcenter()
 }
 
-sourceCompatibility = 1.6
-targetCompatibility = 1.6
+sourceCompatibility = 1.8
+targetCompatibility = 1.8
 
 group = 'io.realm'
 version = file("${projectDir}/../version.txt").text.trim();
@@ -46,8 +47,12 @@ dependencies {
     compile gradleApi()
     compile localGroovy()
     compile "io.realm:realm-transformer:${version}"
-    compile 'com.neenbedankt.gradle.plugins:android-apt:1.8'
-    provided 'com.android.tools.build:gradle:2.1.0'
+    /*Note: the latest Android Gradle plugin has now built in support for annotation processors and warns and/or blocks android-apt,
+     see this https://bitbucket.org/hvisser/android-apt/wiki/Migration page on how to migrate
+     and this https://www.littlerobots.nl/blog/Whats-next-for-android-apt/ for more info.
+   */
+    compile 'com.neenbedankt.gradle.plugins:android-apt:1.8' //TODO: https://www.littlerobots.nl/blog/Whats-next-for-android-apt/
+    provided 'com.android.tools.build:gradle:3.1.0-alpha03'
 
     testCompile gradleTestKit()
     testCompile 'junit:junit:4.12'
diff --git a/gradle-plugin/gradle.properties b/gradle-plugin/gradle.properties
index 160890028a..5f1ed7bbe0 100644
--- a/gradle-plugin/gradle.properties
+++ b/gradle-plugin/gradle.properties
@@ -1 +1 @@
-org.gradle.caching=true
+org.gradle.caching=true
\ No newline at end of file
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar
index d457a1a990..6b6ea3ab4f 100644
Binary files a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar and b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
index c583957d2b..702c4b68b8 100644
--- a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.3.1-all.zip
diff --git a/gradle-plugin/gradlew.bat b/gradle-plugin/gradlew.bat
old mode 100644
new mode 100755
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
index 6a24fa434d..6064b95cf9 100644
--- a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
@@ -42,14 +42,16 @@ class Realm implements Plugin<Project> {
 
         def syncEnabledDefault = false
         def dependencyConfigurationName = getDependencyConfigurationName(project)
-        project.extensions.create('realm', RealmPluginExtension, project, syncEnabledDefault, dependencyConfigurationName)
-
         def usesAptPlugin = project.plugins.findPlugin('com.neenbedankt.android-apt') != null
         def isKotlinProject = project.plugins.findPlugin('kotlin-android') != null
+        def useKotlinExtensionsDefault = isKotlinProject
         def hasAnnotationProcessorConfiguration = project.getConfigurations().findByName('annotationProcessor') != null
         // TODO add a parameter in 'realm' block if this should be specified by users
         def preferAptOnKotlinProject = false
 
+
+        project.extensions.create('realm', RealmPluginExtension, project, syncEnabledDefault, useKotlinExtensionsDefault, dependencyConfigurationName)
+
         if (shouldApplyAndroidAptPlugin(usesAptPlugin, isKotlinProject,
                                         hasAnnotationProcessorConfiguration, preferAptOnKotlinProject)) {
             project.plugins.apply(AndroidAptPlugin)
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy
index 42bd8e5f39..12b51751ad 100644
--- a/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy
@@ -21,28 +21,48 @@ import org.gradle.api.Project
 class RealmPluginExtension {
     private Project project
     def boolean syncEnabled
+    def boolean kotlinExtensionsEnabled
     private String dependencyConfigurationName
 
-    RealmPluginExtension(Project project, boolean syncEnabledDefault, String dependencyConfigurationName) {
+    RealmPluginExtension(Project project, boolean syncEnabledDefault, boolean useKotlinExtensionsDefault, String dependencyConfigurationName) {
         this.project = project
         this.dependencyConfigurationName = dependencyConfigurationName
         setSyncEnabled(syncEnabledDefault)
+        setKotlinExtensionsEnabled(useKotlinExtensionsDefault)
     }
 
     void setSyncEnabled(value) {
         this.syncEnabled = value;
+        setDependencies(syncEnabled, kotlinExtensionsEnabled)
+    }
+
+    void setKotlinExtensionsEnabled(value) {
+        this.kotlinExtensionsEnabled = value
+        setDependencies(syncEnabled, kotlinExtensionsEnabled)
+    }
 
-        // remove realm android library first
+    void setDependencies(boolean syncEnabled, boolean kotlinExtensionsEnabled) {
+        // remove libraries first
         def iterator = project.getConfigurations().getByName(dependencyConfigurationName).getDependencies().iterator();
         while (iterator.hasNext()) {
             def item = iterator.next()
-            if (item.group == 'io.realm' && item.name.startsWith('realm-android-library')) {
-                iterator.remove()
+            if (item.group == 'io.realm') {
+                if (item.name.startsWith('realm-android-library')) {
+                    iterator.remove()
+                }
+                if (item.name.startsWith('realm-android-kotlin-extensions')) {
+                    iterator.remove()
+                }
             }
         }
 
         // then add again
-        def artifactName = "realm-android-library${syncEnabled ? '-object-server' : ''}"
-        project.dependencies.add(dependencyConfigurationName, "io.realm:${artifactName}:${Version.VERSION}")
+        def syncArtifactName = "realm-android-library${syncEnabled ? '-object-server' : ''}"
+        project.dependencies.add(dependencyConfigurationName, "io.realm:${syncArtifactName}:${Version.VERSION}")
+
+        if (kotlinExtensionsEnabled) {
+            def kotlinExtArtifactName = "realm-android-kotlin-extensions${syncEnabled ? '-object-server' : ''}"
+            project.dependencies.add(dependencyConfigurationName, "io.realm:${kotlinExtArtifactName}:${Version.VERSION}")
+        }
     }
 }
diff --git a/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy b/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
index c99d4f53b4..2f9080ebd8 100644
--- a/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
+++ b/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
@@ -53,7 +53,7 @@ class PluginTest {
                 jcenter()
             }
             dependencies {
-                classpath 'com.android.tools.build:gradle:2.2.0'
+                classpath 'com.android.tools.build:gradle:3.1.0-alpha03'
                 classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
                 classpath "io.realm:realm-gradle-plugin:${currentVersion}"
             }
@@ -78,7 +78,7 @@ class PluginTest {
                 jcenter()
             }
             dependencies {
-                classpath 'com.android.tools.build:gradle:2.2.0'
+                classpath 'com.android.tools.build:gradle:3.1.0-alpha03'
                 classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
                 classpath "io.realm:realm-gradle-plugin:${currentVersion}"
             }
diff --git a/gradle.properties b/gradle.properties
index a409f36833..09e1425217 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,2 +1,3 @@
 org.gradle.jvmargs=-XX:MaxPermSize=512m
 org.gradle.caching=true
+android.enableD8=true
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index d457a1a990..6b6ea3ab4f 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index c583957d2b..702c4b68b8 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.3.1-all.zip
diff --git a/gradlew.bat b/gradlew.bat
old mode 100644
new mode 100755
diff --git a/library-benchmarks/build.gradle b/library-benchmarks/build.gradle
index 5701253237..b33a32eba1 100644
--- a/library-benchmarks/build.gradle
+++ b/library-benchmarks/build.gradle
@@ -5,7 +5,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.0.0-rc2'
+        classpath 'com.android.tools.build:gradle:3.1.0-alpha03'
         classpath "io.realm:realm-gradle-plugin:${file("${rootDir}/../version.txt").text.trim()}"
     }
 }
@@ -27,12 +27,12 @@ apply plugin: 'com.android.library'
 apply plugin: 'realm-android'
 
 android {
-    compileSdkVersion 26
-    buildToolsVersion "26.0.2"
+    compileSdkVersion 27
+    buildToolsVersion "27.0.0"
 
     defaultConfig {
         minSdkVersion 15
-        targetSdkVersion 22 // Below 23 to avoid new permission system introduced in M
+        targetSdkVersion 27
         versionCode 1
         versionName "1.0"
         testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
diff --git a/library-benchmarks/gradle.properties b/library-benchmarks/gradle.properties
index 160890028a..2fdd4b5a9a 100644
--- a/library-benchmarks/gradle.properties
+++ b/library-benchmarks/gradle.properties
@@ -1 +1,2 @@
 org.gradle.caching=true
+android.enableD8=true
\ No newline at end of file
diff --git a/library-benchmarks/gradle/wrapper/gradle-wrapper.jar b/library-benchmarks/gradle/wrapper/gradle-wrapper.jar
index d457a1a990..0bdf3fe941 100644
Binary files a/library-benchmarks/gradle/wrapper/gradle-wrapper.jar and b/library-benchmarks/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/library-benchmarks/gradle/wrapper/gradle-wrapper.properties b/library-benchmarks/gradle/wrapper/gradle-wrapper.properties
index c583957d2b..702c4b68b8 100644
--- a/library-benchmarks/gradle/wrapper/gradle-wrapper.properties
+++ b/library-benchmarks/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.3.1-all.zip
diff --git a/library-benchmarks/gradlew.bat b/library-benchmarks/gradlew.bat
old mode 100644
new mode 100755
diff --git a/realm-annotations/build.gradle b/realm-annotations/build.gradle
index dcaa5dc90d..7e4ab2eb5c 100644
--- a/realm-annotations/build.gradle
+++ b/realm-annotations/build.gradle
@@ -22,8 +22,8 @@ apply plugin: 'maven-publish'
 apply plugin: 'com.jfrog.artifactory'
 apply plugin: 'com.jfrog.bintray'
 
-sourceCompatibility = '1.6'
-targetCompatibility = '1.6'
+sourceCompatibility = '1.8'
+targetCompatibility = '1.8'
 
 group = 'io.realm'
 version = file("${projectDir}/../version.txt").text.trim();
diff --git a/realm-annotations/gradle.properties b/realm-annotations/gradle.properties
index 160890028a..5f1ed7bbe0 100644
--- a/realm-annotations/gradle.properties
+++ b/realm-annotations/gradle.properties
@@ -1 +1 @@
-org.gradle.caching=true
+org.gradle.caching=true
\ No newline at end of file
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.jar b/realm-annotations/gradle/wrapper/gradle-wrapper.jar
index d457a1a990..6b6ea3ab4f 100644
Binary files a/realm-annotations/gradle/wrapper/gradle-wrapper.jar and b/realm-annotations/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.properties b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
index c583957d2b..702c4b68b8 100644
--- a/realm-annotations/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.3.1-all.zip
diff --git a/realm-annotations/gradlew.bat b/realm-annotations/gradlew.bat
old mode 100644
new mode 100755
diff --git a/realm-transformer/build.gradle b/realm-transformer/build.gradle
index a5f4d48de7..c2a125116c 100644
--- a/realm-transformer/build.gradle
+++ b/realm-transformer/build.gradle
@@ -1,5 +1,6 @@
 buildscript {
     repositories {
+        google()
         jcenter()
     }
     dependencies {
@@ -31,11 +32,12 @@ properties.load(new FileInputStream("${projectDir}/../dependencies.list"))
 
 def syncVersion = properties.getProperty('REALM_SYNC_VERSION')
 
-sourceCompatibility = '1.6'
-targetCompatibility = '1.6'
+sourceCompatibility = '1.8'
+targetCompatibility = '1.8'
 
 repositories {
     mavenLocal()
+    google()
     jcenter()
 }
 
@@ -58,7 +60,7 @@ dependencies {
     compile localGroovy()
     compile gradleApi()
     compile "io.realm:realm-annotations:${version}"
-    provided 'com.android.tools.build:gradle:2.1.0'
+    provided 'com.android.tools.build:gradle:3.1.0-alpha03'
     compile 'org.javassist:javassist:3.22.0-GA'
 
     testCompile('org.spockframework:spock-core:1.0-groovy-2.4') {
diff --git a/realm-transformer/gradle.properties b/realm-transformer/gradle.properties
index 160890028a..5f1ed7bbe0 100644
--- a/realm-transformer/gradle.properties
+++ b/realm-transformer/gradle.properties
@@ -1 +1 @@
-org.gradle.caching=true
+org.gradle.caching=true
\ No newline at end of file
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.jar b/realm-transformer/gradle/wrapper/gradle-wrapper.jar
index d457a1a990..6b6ea3ab4f 100644
Binary files a/realm-transformer/gradle/wrapper/gradle-wrapper.jar and b/realm-transformer/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.properties b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
index c583957d2b..702c4b68b8 100644
--- a/realm-transformer/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.3.1-all.zip
diff --git a/realm-transformer/gradlew.bat b/realm-transformer/gradlew.bat
old mode 100644
new mode 100755
diff --git a/realm.properties b/realm.properties
index b36f4827a1..fd53887478 100644
--- a/realm.properties
+++ b/realm.properties
@@ -1,2 +1,2 @@
-gradleVersion=4.2.1
+gradleVersion=4.3.1
 ndkVersion=r10e
diff --git a/realm/build.gradle b/realm/build.gradle
index 1be855767b..be9e85de9c 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -1,5 +1,10 @@
+project.ext.minSdkVersion = 9
+project.ext.compileSdkVersion = 26
+project.ext.buildToolsVersion = '26.0.2'
+
 buildscript {
     ext.kotlin_version = '1.1.51'
+    ext.dokka_version = '0.9.15'
     repositories {
         mavenLocal()
         google()
@@ -9,17 +14,18 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.0.0-rc2'
-        classpath 'de.undercouch:gradle-download-task:3.2.0'
-        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5'
+        classpath 'com.android.tools.build:gradle:3.1.0-alpha03'
+        classpath 'de.undercouch:gradle-download-task:3.3.0'
+        classpath 'com.github.dcendents:android-maven-gradle-plugin:2.0'
         classpath 'com.novoda:gradle-android-command-plugin:1.7.1'
         classpath 'com.github.skhatri:gradle-s3-plugin:1.0.4'
-        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.8.1'
-        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.5.2'
+        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.8.2'
+        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.5.4'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
         classpath "io.realm:realm-transformer:${file('../version.txt').text.trim()}"
-        classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.11'
+        classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.13'
         classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
+        classpath "org.jetbrains.dokka:dokka-gradle-plugin:${dokka_version}"
     }
 }
 
diff --git a/realm/gradle.properties b/realm/gradle.properties
index 0be17a49db..b9c41987bf 100644
--- a/realm/gradle.properties
+++ b/realm/gradle.properties
@@ -1,2 +1,3 @@
 org.gradle.jvmargs=-Xms512m -Xmx2048m
 org.gradle.caching=true
+kotlin.incremental=false;
diff --git a/realm/gradle/wrapper/gradle-wrapper.jar b/realm/gradle/wrapper/gradle-wrapper.jar
index d457a1a990..0bdf3fe941 100644
Binary files a/realm/gradle/wrapper/gradle-wrapper.jar and b/realm/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm/gradle/wrapper/gradle-wrapper.properties b/realm/gradle/wrapper/gradle-wrapper.properties
index c583957d2b..702c4b68b8 100644
--- a/realm/gradle/wrapper/gradle-wrapper.properties
+++ b/realm/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.3.1-all.zip
diff --git a/realm/gradlew.bat b/realm/gradlew.bat
old mode 100644
new mode 100755
diff --git a/realm/kotlin-extensions/.gitignore b/realm/kotlin-extensions/.gitignore
new file mode 100644
index 0000000000..796b96d1c4
--- /dev/null
+++ b/realm/kotlin-extensions/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/realm/kotlin-extensions/build.gradle b/realm/kotlin-extensions/build.gradle
new file mode 100644
index 0000000000..bd05e52d59
--- /dev/null
+++ b/realm/kotlin-extensions/build.gradle
@@ -0,0 +1,370 @@
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+apply plugin: 'kotlin-kapt'
+apply plugin: 'com.github.dcendents.android-maven'
+apply plugin: 'maven-publish'
+apply plugin: 'com.jfrog.artifactory'
+apply plugin: 'de.undercouch.download'
+apply plugin: 'org.jetbrains.dokka'
+
+// TODO How many of these work on Kotlin?
+//apply plugin: 'findbugs'
+//apply plugin: 'pmd'
+//apply plugin: 'checkstyle'
+//apply plugin: 'com.github.kt3k.coveralls'
+//apply plugin: 'net.ltgt.errorprone'
+
+import io.realm.transformer.RealmTransformer
+android.registerTransform(new RealmTransformer())
+
+android {
+    compileSdkVersion rootProject.compileSdkVersion
+    buildToolsVersion rootProject.buildToolsVersion
+    defaultConfig {
+        minSdkVersion rootProject.minSdkVersion
+        targetSdkVersion rootProject.compileSdkVersion
+        versionName version
+        project.archivesBaseName = "realm-kotlin-extensions"
+
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    }
+    buildTypes {
+        debug {
+            // https://youtrack.jetbrains.com/issue/KT-11333
+            // Until this is resolved, enabling code coverage will break extension functions
+            // during instrumentation testing.
+            testCoverageEnabled = false
+        }
+        release {
+            minifyEnabled false
+        }
+    }
+
+    flavorDimensions 'api'
+
+    productFlavors {
+        base {
+            dimension 'api'
+        }
+        objectServer {
+            dimension 'api'
+        }
+    }
+
+    sourceSets {
+        main.java.srcDirs += 'src/main/kotlin'
+        androidTest.java.srcDirs += ['src/androidTest/kotlin', '../realm-library/src/testUtils/java']
+        objectServer.java.srcDirs += 'src/objectServer/kotlin'
+        androidTestObjectServer.java.srcDirs += 'src/androidTestObjectServer/kotlin'
+    }
+}
+
+dependencies {
+    implementation project(':realm-library')
+    implementation "org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version"
+    androidTestImplementation 'junit:junit:4.12'
+    androidTestImplementation 'com.android.support.test:runner:1.0.1'
+    androidTestImplementation 'com.android.support.test:rules:1.0.1'
+    kaptAndroidTest project(':realm-annotations-processor')
+    androidTestImplementation "org.jetbrains.kotlin:kotlin-reflect:$kotlin_version"
+}
+
+repositories {
+    mavenCentral()
+}
+
+// enable @ParametersAreNonnullByDefault annotation. See https://blog.jetbrains.com/kotlin/2017/09/kotlin-1-1-50-is-out/
+tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
+    kotlinOptions {
+        freeCompilerArgs = ["-Xjsr305=strict"]
+    }
+}
+
+
+task sourcesJar(type: Jar) {
+    from android.sourceSets.objectServer.java.srcDirs
+    from android.sourceSets.main.java.srcDirs
+    classifier = 'sources'
+}
+
+dokka {
+    // TODO Filtering is currently not possible https://youtrack.jetbrains.com/issue/KT-21022
+    // This means we cannot filter R/BuildConfig files for the time being
+    outputFormat = 'html'
+    outputDirectory = "$buildDir/dokka"
+}
+
+task javadocJar(type: Jar, dependsOn: dokka) {
+    classifier = 'javadoc'
+    from "$buildDir/dokka"
+}
+
+// Deployment
+
+install {
+    repositories.mavenInstaller {
+        pom {
+            project {
+                packaging 'aar'
+
+                // Add your description here
+                name 'realm-kotlin-extensions'
+                description 'Kotlin specific APIs and extension functions for Realm for Android'
+                url 'http://realm.io'
+
+                // Set your license
+                licenses {
+                    license {
+                        name 'The Apache Software License, Version 2.0'
+                        url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
+                        distribution 'repo'
+                    }
+                }
+                issueManagement {
+                    system 'github'
+                    url 'https://github.com/realm/realm-java/issues'
+                }
+                scm {
+                    url 'scm:https://github.com/realm/realm-java'
+                    connection 'scm:git@github.com:realm/realm-java.git'
+                    developerConnection 'scm:git@github.com:realm/realm-java.git'
+                }
+            }
+        }
+    }
+}
+
+// The publications doesn't know about our AAR dependencies, so we have to manually add them to the pom
+// Credit: http://stackoverflow.com/questions/24743562/gradle-not-including-dependencies-in-published-pom-xml
+def createPomDependencies(configurationNames) {
+    return {
+        def dependenciesNode = asNode().appendNode('dependencies')
+        configurationNames.each { configurationName ->
+            configurations[configurationName].allDependencies.each {
+                if (it.group != null && it.name != null && it.name != 'realm-library') {
+                    def dependencyNode = dependenciesNode.appendNode('dependency')
+                    dependencyNode.appendNode('groupId', it.group)
+                    dependencyNode.appendNode('artifactId', it.name)
+                    dependencyNode.appendNode('version', it.version)
+
+                    //If there are any exclusions in dependency
+                    if (it.excludeRules.size() > 0) {
+                        def exclusionsNode = dependencyNode.appendNode('exclusions')
+                        it.excludeRules.each { rule ->
+                            def exclusionNode = exclusionsNode.appendNode('exclusion')
+                            exclusionNode.appendNode('groupId', rule.group)
+                            exclusionNode.appendNode('artifactId', rule.module)
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+
+publishing {
+    publications {
+        basePublication(MavenPublication) {
+            groupId 'io.realm'
+            artifactId 'realm-android-kotlin-extensions'
+            version project.version
+            artifact file("${rootDir}/kotlin-extensions/build/outputs/aar/realm-kotlin-extensions-base-release.aar")
+            artifact sourcesJar
+            artifact javadocJar
+
+            pom.withXml(createPomDependencies(["baseImplementation", "implementation", "baseApi", "api"]))
+        }
+
+        objectServerPublication(MavenPublication) {
+            groupId 'io.realm'
+            artifactId 'realm-android-kotlin-extensions-object-server'
+            version project.version
+            artifact file("${rootDir}/kotlin-extensions/build/outputs/aar/realm-kotlin-extensions-objectServer-release.aar")
+            artifact sourcesJar
+            artifact javadocJar
+
+            pom.withXml(createPomDependencies(["objectServerImplementation", "implementation", "objectServerApi", "api"]))
+        }
+    }
+    repositories {
+        maven {
+            credentials(AwsCredentials) {
+                accessKey project.hasProperty('s3AccessKey') ? s3AccessKey : 'noAccessKey'
+                secretKey project.hasProperty('s3SecretKey') ? s3SecretKey : 'noSecretKey'
+            }
+            if (project.version.endsWith('-SNAPSHOT')) {
+                url "s3://realm-ci-artifacts/maven/snapshots/"
+            } else {
+                url "s3://realm-ci-artifacts/maven/releases/"
+            }
+        }
+    }
+}
+
+artifactory {
+    contextUrl = 'https://oss.jfrog.org/artifactory'
+    publish {
+        repository {
+            repoKey = 'oss-snapshot-local'
+            username = project.hasProperty('bintrayUser') ? bintrayUser : 'noUser'
+            password = project.hasProperty('bintrayKey') ? bintrayKey : 'noKey'
+        }
+        defaults {
+             publications('basePublication', 'objectServerPublication')
+            publishPom = true
+            publishIvy = false
+        }
+    }
+}
+
+artifacts {
+    archives javadocJar
+    archives sourcesJar
+}
+
+publishToMavenLocal.dependsOn assemble
+
+android.productFlavors.all { flavor ->
+    def librarySuffix = flavor.name == 'base' ? '' : '-object-server'
+    def userName = project.findProperty('bintrayUser') ?: 'noUser'
+    def accessKey = project.findProperty('bintrayKey') ?: 'noKey'
+    def artifactId = "realm-android-kotlin-extensions${librarySuffix}"
+
+    // BINTRAY
+
+    task("bintrayAar${flavor.name.capitalize()}", type: Exec) {
+        dependsOn "assemble${flavor.name.capitalize()}"
+        group = 'Publishing'
+        commandLine 'curl',
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/outputs/aar/realm-kotlin-extensions-${flavor.name}-release.aar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://api.bintray.com/content/realm/maven/${artifactId}/${project.version}/io/realm/${artifactId}/${project.version}/${artifactId}-${project.version}.aar?publish=0"
+    }
+
+    task("bintraySources${flavor.name.capitalize()}", type: Exec) {
+        dependsOn sourcesJar
+        group = 'Publishing'
+        commandLine 'curl',
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/libs/realm-kotlin-extensions-${project.version}-sources.jar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://api.bintray.com/content/realm/maven/${artifactId}/${project.version}/io/realm/${artifactId}/${project.version}/${artifactId}-${project.version}-sources.jar?publish=0"
+    }
+
+    task("bintrayJavadoc${flavor.name.capitalize()}", type: Exec) {
+        dependsOn javadocJar
+        group = 'Publishing'
+        commandLine 'curl',
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/libs/realm-kotlin-extensions-${project.version}-javadoc.jar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://api.bintray.com/content/realm/maven/${artifactId}/${project.version}/io/realm/${artifactId}/${project.version}/${artifactId}-${project.version}-javadoc.jar?publish=0"
+    }
+
+    task("bintrayPom${flavor.name.capitalize()}", type: Exec) {
+        dependsOn "publish${flavor.name.capitalize()}PublicationPublicationToMavenLocal"
+        group = 'Publishing'
+        commandLine 'curl',
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/publications/${flavor.name}Publication/pom-default.xml",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://api.bintray.com/content/realm/maven/${artifactId}/${project.version}/io/realm/${artifactId}/${project.version}/${artifactId}-${project.version}.pom?publish=0"
+    }
+
+    // OJO
+
+    task("ojoAar${flavor.name.capitalize()}", type: Exec) {
+        dependsOn "assemble${flavor.name.capitalize()}"
+        group = 'Publishing'
+        commandLine 'curl',
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/outputs/aar/realm-kotlin-extensions-${flavor.name}-release.aar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://oss.jfrog.org/artifactory/oss-snapshot-local/io/realm/${artifactId}/${project.version}/${artifactId}-${project.version}.aar?publish=0"
+    }
+
+    task("ojoSources${flavor.name.capitalize()}", type: Exec) {
+        dependsOn sourcesJar
+        group = 'Publishing'
+        commandLine 'curl',
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/libs/realm-kotlin-extensions-${project.version}-sources.jar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://oss.jfrog.org/artifactory/oss-snapshot-local/io/realm/${artifactId}/${project.version}/${artifactId}-${project.version}-sources.jar?publish=0"
+    }
+
+    task("ojoJavadoc${flavor.name.capitalize()}", type: Exec) {
+        dependsOn javadocJar
+        group = 'Publishing'
+        commandLine 'curl',
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/libs/realm-kotlin-extensions-${project.version}-javadoc.jar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://oss.jfrog.org/artifactory/oss-snapshot-local/io/realm/${artifactId}/${project.version}/${artifactId}-${project.version}-javadoc.jar?publish=0"
+    }
+
+    task("ojoPom${flavor.name.capitalize()}", type: Exec) {
+        dependsOn "publish${flavor.name.capitalize()}PublicationPublicationToMavenLocal"
+        group = 'Publishing'
+        commandLine 'curl',
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/publications/${flavor.name}Publication/pom-default.xml",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://oss.jfrog.org/artifactory/oss-snapshot-local/io/realm/${artifactId}/${project.version}/${artifactId}-${project.version}.pom?publish=0"
+    }
+
+    task("bintray${flavor.name.capitalize()}") {
+        dependsOn "bintrayAar${flavor.name.capitalize()}"
+        dependsOn "bintraySources${flavor.name.capitalize()}"
+        dependsOn "bintrayJavadoc${flavor.name.capitalize()}"
+        dependsOn "bintrayPom${flavor.name.capitalize()}"
+        group = 'Publishing'
+    }
+
+    task("ojo${flavor.name.capitalize()}") {
+        dependsOn "ojoAar${flavor.name.capitalize()}"
+        dependsOn "ojoSources${flavor.name.capitalize()}"
+        dependsOn "ojoJavadoc${flavor.name.capitalize()}"
+        dependsOn "ojoPom${flavor.name.capitalize()}"
+        group = 'Publishing'
+    }
+}
+
+task bintrayUpload() {
+    android.productFlavors.all { flavor ->
+        dependsOn "bintray${flavor.name.capitalize()}"
+    }
+    group = 'Publishing'
+}
+
+task ojoUpload() {
+    android.productFlavors.all { flavor ->
+        dependsOn "ojo${flavor.name.capitalize()}"
+    }
+    group = 'Publishing'
+}
diff --git a/realm/kotlin-extensions/proguard-rules.pro b/realm/kotlin-extensions/proguard-rules.pro
new file mode 100644
index 0000000000..64bf447535
--- /dev/null
+++ b/realm/kotlin-extensions/proguard-rules.pro
@@ -0,0 +1,25 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /usr/local/opt/android-sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
diff --git a/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/KotlinRealmModelTests.kt b/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/KotlinRealmModelTests.kt
new file mode 100644
index 0000000000..4130e260d3
--- /dev/null
+++ b/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/KotlinRealmModelTests.kt
@@ -0,0 +1,229 @@
+package io.realm
+
+import android.support.test.InstrumentationRegistry
+import android.support.test.runner.AndroidJUnit4
+import io.realm.entities.PrimaryKeyClass
+import io.realm.entities.SimpleClass
+import io.realm.kotlin.*
+import io.realm.rule.RunInLooperThread
+import io.realm.rule.RunTestInLooperThread
+import io.realm.rule.TestRealmConfigurationFactory
+import org.junit.*
+import org.junit.Assert.*
+import org.junit.runner.RunWith
+
+@Suppress("FunctionName")
+@RunWith(AndroidJUnit4::class)
+class KotlinRealmModelTests {
+
+    @Suppress("MemberVisibilityCanPrivate")
+    @get:Rule
+    val configFactory = TestRealmConfigurationFactory()
+
+    @get:Rule
+    val looperThread = RunInLooperThread()
+
+    private lateinit var realm: Realm
+
+    @Before
+    fun setUp() {
+        Realm.init(InstrumentationRegistry.getTargetContext())
+        realm = Realm.getInstance(configFactory.createConfiguration())
+    }
+
+    @After
+    fun tearDown() {
+        realm.close()
+    }
+
+    @Test
+    fun deleteFromRealm() {
+        // Make sure starting with 0
+        Assert.assertEquals(0, realm.where<SimpleClass>().count())
+
+        // Add 1, check count
+        realm.executeTransaction { it.createObject<SimpleClass>() }
+        Assert.assertEquals(1, realm.where<SimpleClass>().count())
+
+        // Delete the first, check count again.  !! is intentional to make
+        // sure we are sure calling deleteFromRealm
+        realm.executeTransaction { realm.where<SimpleClass>().findFirst()!!.deleteFromRealm() }
+        Assert.assertEquals(0, realm.where<SimpleClass>().count())
+
+    }
+
+    @Test
+    fun isValid() {
+        realm.executeTransaction {
+            val obj = it.createObject<SimpleClass>()
+            assertTrue("Expected valid after insert", obj.isValid())
+
+            obj.deleteFromRealm()
+            assertFalse("Expected invalid after delete", obj.isValid())
+        }
+    }
+
+   @Test
+    fun isManaged() {
+        realm.executeTransaction {
+            var obj = SimpleClass()
+            assertFalse("Expected not managed until attached", obj.isManaged())
+
+            obj = it.copyToRealm(obj)
+            assertTrue("Expected managed after attaching", obj.isManaged())
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    fun addChangeListener_RealmObjectChangeListener_addObject() {
+        val realm = looperThread.realm
+        realm.beginTransaction()
+        val obj = realm.createObject<SimpleClass>()
+        realm.commitTransaction()
+
+        looperThread.keepStrongReference(obj)
+        obj.addChangeListener( RealmObjectChangeListener { updatedObj, changes ->
+            assertTrue(changes?.isFieldChanged(SimpleClass::name.name) ?: false)
+            assertEquals("simple1", updatedObj.name)
+            looperThread.testComplete()
+        })
+
+        realm.beginTransaction()
+        obj.name = "simple1"
+        realm.commitTransaction()
+    }
+
+    @Test
+    @RunTestInLooperThread
+    fun addChangeListener_RealmChangeListener_addObject() {
+        val realm = looperThread.realm
+        realm.beginTransaction()
+        val obj = realm.createObject<SimpleClass>()
+        realm.commitTransaction()
+
+        looperThread.keepStrongReference(obj)
+        obj.addChangeListener( RealmChangeListener { simpleClass ->
+            assertEquals("simple1", simpleClass.name)
+            looperThread.testComplete()
+        })
+
+        realm.beginTransaction()
+        obj.name = "simple1"
+        realm.commitTransaction()
+    }
+
+    @Test
+    @RunTestInLooperThread
+    fun removeChangeListener_RealmChangeListener_removeObject() {
+        val realm = looperThread.realm
+        realm.beginTransaction()
+        val obj = realm.createObject<PrimaryKeyClass>(101)
+        realm.commitTransaction()
+
+        val listener = RealmChangeListener<PrimaryKeyClass>{
+            fail()
+        }
+
+        obj.addChangeListener(listener)
+        obj.removeChangeListener(listener)
+
+        realm.beginTransaction()
+        obj.name = "Bobby Risigliano"
+        realm.commitTransaction()
+
+        // Try to trigger the listeners.
+        realm.sharedRealm.refresh()
+        looperThread.testComplete()
+    }
+
+    @Test
+    @RunTestInLooperThread
+    fun removeChangeListener_RealmObjectChangeListener_removeObject() {
+        val realm = looperThread.realm
+        realm.beginTransaction()
+        val obj = realm.createObject<PrimaryKeyClass>(101)
+        realm.commitTransaction()
+
+        val listener = RealmObjectChangeListener<PrimaryKeyClass>{ _,_ ->
+            fail()
+        }
+
+        obj.addChangeListener(listener)
+        obj.removeChangeListener(listener)
+
+        realm.beginTransaction()
+        obj.name = "Bobby Risigliano"
+        realm.commitTransaction()
+
+        // Try to trigger the listeners.
+        realm.sharedRealm.refresh()
+        looperThread.testComplete()
+    }
+
+    @Test
+    @RunTestInLooperThread
+    fun removeAllChangeListeners() {
+        val realm = looperThread.realm
+        realm.beginTransaction()
+        val obj = realm.createObject<PrimaryKeyClass>(101)
+        realm.commitTransaction()
+
+        val changeListener = RealmChangeListener<PrimaryKeyClass> {
+            fail()
+        }
+        val objectChangeListener = RealmObjectChangeListener<PrimaryKeyClass> { _,_ ->
+            fail()
+        }
+
+        obj.addChangeListener(changeListener)
+        obj.addChangeListener(objectChangeListener)
+
+        obj.removeAllChangeListeners()
+
+        realm.beginTransaction()
+        obj.name = "Bobby Risigliano"
+        realm.commitTransaction()
+
+        // Try to trigger the listeners.
+        realm.sharedRealm.refresh()
+        looperThread.testComplete()
+    }
+
+    @Test
+    @RunTestInLooperThread
+    @Throws(Throwable::class)
+    fun isLoaded() {
+        val realm = looperThread.realm
+
+        realm.executeTransaction { it.createObject<SimpleClass>() }
+
+        val result = realm.where<SimpleClass>().findFirstAsync()
+        assertFalse("Expect isLoaded is false just after async call", result.isLoaded())
+
+        looperThread.keepStrongReference(result)
+
+        result.addChangeListener(RealmChangeListener { r ->
+            assertTrue("Expected the loading to have completed", r.isLoaded())
+            looperThread.testComplete()
+        })
+    }
+
+    @Test
+    @RunTestInLooperThread
+    @Throws(Throwable::class)
+    fun load() {
+        val realm = looperThread.realm
+
+        realm.executeTransaction { it.createObject<SimpleClass>() }
+
+        val result = realm.where<SimpleClass>().findFirstAsync()
+        assertFalse("Expect isLoaded is false just after async call", result.isLoaded())
+
+        result.load()
+
+        assertTrue("Expected isLoaded is true after blocking on load()", result.isLoaded())
+        looperThread.testComplete()
+    }
+
+}
diff --git a/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/KotlinRealmQueryTests.kt b/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/KotlinRealmQueryTests.kt
new file mode 100644
index 0000000000..a7c9049eb6
--- /dev/null
+++ b/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/KotlinRealmQueryTests.kt
@@ -0,0 +1,159 @@
+package io.realm
+
+import android.support.test.InstrumentationRegistry
+import android.support.test.runner.AndroidJUnit4
+import io.realm.entities.AllPropTypesClass
+import io.realm.kotlin.createObject
+import io.realm.kotlin.oneOf
+import io.realm.kotlin.where
+import io.realm.rule.TestRealmConfigurationFactory
+import org.junit.After
+import org.junit.Assert.assertEquals
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import java.util.*
+
+@Suppress("FunctionName")
+@RunWith(AndroidJUnit4::class)
+class KotlinRealmQueryTests {
+
+    @Suppress("MemberVisibilityCanPrivate")
+    @get:Rule
+    val configFactory = TestRealmConfigurationFactory()
+
+    private lateinit var realm: Realm
+
+    @Before
+    fun setUp() {
+        Realm.init(InstrumentationRegistry.getTargetContext())
+        realm = Realm.getInstance(configFactory.createConfiguration())
+    }
+
+    @After
+    fun tearDown() {
+        realm.close()
+    }
+
+    @Test
+    fun oneOf_String() {
+        realm.beginTransaction()
+        val obj = realm.createObject<AllPropTypesClass>()
+        obj.stringVar = "test"
+        realm.commitTransaction()
+
+        assertEquals(1,
+                realm.where<AllPropTypesClass>()
+                     .oneOf(AllPropTypesClass::stringVar.name, arrayOf<String?>("test"))
+                     .count())
+    }
+
+    @Test
+    fun oneOf_Byte() {
+        realm.beginTransaction()
+        val obj = realm.createObject<AllPropTypesClass>()
+        obj.byteVar = 3
+        realm.commitTransaction()
+
+        assertEquals(1,
+                realm.where<AllPropTypesClass>()
+                        .oneOf(AllPropTypesClass::byteVar.name, arrayOf<Byte?>(3))
+                        .count())
+    }
+
+    @Test
+    fun oneOf_Short() {
+        realm.beginTransaction()
+        val obj = realm.createObject<AllPropTypesClass>()
+        obj.shortVar = 3
+        realm.commitTransaction()
+
+        assertEquals(1,
+                realm.where<AllPropTypesClass>()
+                        .oneOf(AllPropTypesClass::shortVar.name, arrayOf<Short?>(3))
+                        .count())
+    }
+
+    @Test
+    fun oneOf_Int() {
+        realm.beginTransaction()
+        val obj = realm.createObject<AllPropTypesClass>()
+        obj.intVar = 3
+        realm.commitTransaction()
+
+        assertEquals(1,
+                realm.where<AllPropTypesClass>()
+                        .oneOf(AllPropTypesClass::intVar.name, arrayOf<Int?>(3))
+                        .count())
+    }
+
+    @Test
+    fun oneOf_Long() {
+        realm.beginTransaction()
+        val obj = realm.createObject<AllPropTypesClass>()
+        obj.longVar = 3
+        realm.commitTransaction()
+
+        assertEquals(1,
+                realm.where<AllPropTypesClass>()
+                        .oneOf(AllPropTypesClass::longVar.name, arrayOf<Long?>(3))
+                        .count())
+    }
+
+    @Test
+    fun oneOf_Double() {
+        realm.beginTransaction()
+        val obj = realm.createObject<AllPropTypesClass>()
+        obj.doubleVar = 3.5
+        realm.commitTransaction()
+
+        assertEquals(1,
+                realm.where<AllPropTypesClass>()
+                        .oneOf(AllPropTypesClass::doubleVar.name, arrayOf<Double?>(3.5))
+                        .count())
+    }
+
+    @Test
+    fun oneOf_Float() {
+        realm.beginTransaction()
+        val obj = realm.createObject<AllPropTypesClass>()
+        obj.floatVar = 3.5f
+        realm.commitTransaction()
+
+        assertEquals(1,
+                realm.where<AllPropTypesClass>()
+                        .oneOf(AllPropTypesClass::floatVar.name, arrayOf<Float?>(3.5f))
+                        .count())
+    }
+
+    @Test
+    fun oneOf_Boolean() {
+        realm.beginTransaction()
+        val obj = realm.createObject<AllPropTypesClass>()
+        obj.booleanVar = true
+        realm.commitTransaction()
+
+        assertEquals(1,
+                realm.where<AllPropTypesClass>()
+                        .oneOf(AllPropTypesClass::booleanVar.name, arrayOf<Boolean?>(true))
+                        .count())
+    }
+
+    @Test
+    fun oneOf_Date() {
+
+        val testDate = Date()
+
+        realm.beginTransaction()
+        val obj = realm.createObject<AllPropTypesClass>()
+        obj.dateVar = testDate
+        realm.commitTransaction()
+
+        assertEquals(1,
+                realm.where<AllPropTypesClass>()
+                        .oneOf(AllPropTypesClass::dateVar.name, arrayOf<Date?>(testDate))
+                        .count())
+    }
+
+}
diff --git a/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/KotlinRealmTests.kt b/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/KotlinRealmTests.kt
new file mode 100644
index 0000000000..eebd34cf20
--- /dev/null
+++ b/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/KotlinRealmTests.kt
@@ -0,0 +1,61 @@
+package io.realm
+
+import android.support.test.InstrumentationRegistry
+import android.support.test.runner.AndroidJUnit4
+import io.realm.entities.PrimaryKeyClass
+import io.realm.entities.SimpleClass
+import io.realm.kotlin.createObject
+import io.realm.kotlin.where
+import io.realm.rule.TestRealmConfigurationFactory
+import org.junit.After
+import org.junit.Assert.assertEquals
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+@Suppress("FunctionName")
+@RunWith(AndroidJUnit4::class)
+class KotlinRealmTests {
+
+    @Suppress("MemberVisibilityCanPrivate")
+    @get:Rule
+    val configFactory = TestRealmConfigurationFactory()
+
+    private lateinit var realm: Realm
+
+    @Before
+    fun setUp() {
+        Realm.init(InstrumentationRegistry.getTargetContext())
+        realm = Realm.getInstance(configFactory.createConfiguration())
+    }
+
+    @After
+    fun tearDown() {
+        realm.close()
+    }
+
+    @Test
+    fun createObject() {
+        realm.executeTransaction {
+            it.createObject<SimpleClass>()
+        }
+        assertEquals(1, realm.where<SimpleClass>().count())
+    }
+
+
+    @Test
+    fun createObject_primaryKey() {
+        realm.executeTransaction {
+            it.createObject<PrimaryKeyClass>(1)
+        }
+        assertEquals(1, realm.where<PrimaryKeyClass>().count())
+    }
+
+    @Test
+    fun where() {
+        assertEquals(0, realm.where<SimpleClass>().count())
+    }
+
+
+}
\ No newline at end of file
diff --git a/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/entities/AllPropTypesClass.kt b/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/entities/AllPropTypesClass.kt
new file mode 100644
index 0000000000..35202fc7da
--- /dev/null
+++ b/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/entities/AllPropTypesClass.kt
@@ -0,0 +1,20 @@
+package io.realm.entities
+
+import io.realm.RealmModel
+import io.realm.annotations.RealmClass
+import java.util.*
+
+@RealmClass
+open class AllPropTypesClass : RealmModel {
+
+    var stringVar: String = ""
+    var byteVar: Byte = 0
+    var shortVar: Short = 0
+    var intVar: Int = 0
+    var longVar: Long = 0
+    var doubleVar: Double = 0.0
+    var floatVar: Float = 0.0f
+    var booleanVar : Boolean = false
+    var dateVar : Date = Date()
+
+}
diff --git a/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/entities/PrimaryKeyClass.kt b/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/entities/PrimaryKeyClass.kt
new file mode 100644
index 0000000000..83b1729737
--- /dev/null
+++ b/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/entities/PrimaryKeyClass.kt
@@ -0,0 +1,12 @@
+package io.realm.entities
+
+import io.realm.RealmModel
+import io.realm.annotations.PrimaryKey
+import io.realm.annotations.RealmClass
+
+@RealmClass
+open class PrimaryKeyClass: RealmModel {
+    @PrimaryKey
+    var id: Long = 0
+    var name: String = ""
+}
diff --git a/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/entities/SimpleClass.kt b/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/entities/SimpleClass.kt
new file mode 100644
index 0000000000..2091fbe672
--- /dev/null
+++ b/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/entities/SimpleClass.kt
@@ -0,0 +1,10 @@
+package io.realm.entities
+
+import io.realm.RealmModel
+import io.realm.RealmObject
+import io.realm.annotations.RealmClass
+
+@RealmClass
+open class SimpleClass : RealmModel {
+    var name: String = ""
+}
diff --git a/realm/kotlin-extensions/src/main/AndroidManifest.xml b/realm/kotlin-extensions/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..3d03c8bb1c
--- /dev/null
+++ b/realm/kotlin-extensions/src/main/AndroidManifest.xml
@@ -0,0 +1,2 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="io.realm.kotlin"/>
diff --git a/realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmExtensions.kt b/realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmExtensions.kt
new file mode 100644
index 0000000000..1307e48a38
--- /dev/null
+++ b/realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmExtensions.kt
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.kotlin
+
+import io.realm.Realm
+import io.realm.RealmModel
+import io.realm.RealmQuery
+import io.realm.exceptions.RealmException
+
+/**
+ * Returns a typed RealmQuery, which can be used to query for specific objects of this type
+ *
+ * @param T the class of the object which is to be queried for.
+ * @return a typed `RealmQuery`, which can be used to query for specific objects of this type.
+ */
+inline fun <reified T : RealmModel> Realm.where(): RealmQuery<T> {
+    return this.where(T::class.java)
+}
+
+/**
+ * Deletes all objects of the specified class from the Realm.
+ *
+ * @param T the class of the object which is to be queried for.
+ * @throws IllegalStateException if the corresponding Realm is closed or called from an incorrect thread.
+ */
+inline fun <reified T : RealmModel> Realm.delete() {
+    return this.delete(T::class.java)
+}
+
+/**
+ *
+ * Instantiates and adds a new object to the Realm.
+ *
+ * This method is only available for model classes with no `@PrimaryKey` annotation.
+ * If you like to create an object that has a primary key, use [createObject] instead.
+ *
+ * @param T the Class of the object to create.
+ * @return the new object.
+ * @throws RealmException if the primary key is defined in the model class or an object cannot be created.
+ */
+inline fun <reified T : RealmModel> Realm.createObject(): T {
+    return this.createObject(T::class.java)
+}
+
+/**
+ *
+ * Instantiates and adds a new object to the Realm with the primary key value already set.
+ *
+ * If the value violates the primary key constraint, no object will be added and a RealmException will be
+ * thrown. The default value for primary key provided by the model class will be ignored.
+ *
+ * @param T the Class of the object to create.
+ * @param primaryKeyValue value for the primary key field.
+ * @return the new object.
+ * @throws RealmException if object could not be created due to the primary key being invalid.
+ * @throws IllegalStateException if the model class does not have an primary key defined.
+ * @throws IllegalArgumentException if the `primaryKeyValue` doesn't have a value that can be converted to the
+ * expected value.
+ */
+inline fun <reified T : RealmModel> Realm.createObject(primaryKeyValue: Any?): T {
+    return this.createObject(T::class.java, primaryKeyValue)
+}
+
+/**
+TODO: Figure out if we should include this is or not. Using this makes it possible to do
+
+inline fun <T> Realm.callTransaction(crossinline action: Realm.() -> T): T {
+    val ref = AtomicReference<T>()
+    executeTransaction {
+        ref.set(action(it))
+    }
+    return ref.get()
+}
+
+Missing functions. Consider these for inclusion later:
+- createAllFromJson(Class<E> clazz, InputStream inputStream)
+- createAllFromJson(Class<E> clazz, org.json.JSONArray json)
+- createAllFromJson(Class<E> clazz, String json)
+- createObjectFromJson(Class<E> clazz, InputStream inputStream)
+- createObjectFromJson(Class<E> clazz, org.json.JSONObject json)
+- createObjectFromJson(Class<E> clazz, String json)
+- createOrUpdateAllFromJson(Class<E> clazz, InputStream in)
+- createOrUpdateAllFromJson(Class<E> clazz, org.json.JSONArray json)
+- createOrUpdateAllFromJson(Class<E> clazz, String json)
+- createOrUpdateObjectFromJson(Class<E> clazz, InputStream in)
+- createOrUpdateObjectFromJson(Class<E> clazz, org.json.JSONObject json)
+- createOrUpdateObjectFromJson(Class<E> clazz, String json)
+- createOrUpdateObjectFromJson(Class<E> clazz, String json)
+*/
\ No newline at end of file
diff --git a/realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmModelExtensions.kt b/realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmModelExtensions.kt
new file mode 100644
index 0000000000..d668c7ab4f
--- /dev/null
+++ b/realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmModelExtensions.kt
@@ -0,0 +1,213 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.kotlin
+
+import io.realm.RealmChangeListener
+import io.realm.RealmModel
+import io.realm.RealmObject
+import io.realm.RealmObjectChangeListener
+
+/**
+ * Deletes the object from the Realm it is currently associated with.
+ *
+ * After this method is called the object will be invalid and any operation (read or write) performed on it will
+ * fail with an `IllegalStateException`.
+ *
+ * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
+ * @see [isValid]
+ */
+fun RealmModel.deleteFromRealm() {
+    RealmObject.deleteFromRealm(this)
+}
+
+/**
+ * Checks if the RealmObject is still valid to use i.e., the RealmObject hasn't been deleted nor has the
+ * Realm been closed. It will always return `true` for unmanaged objects.
+ *
+ * @return `true` if the object is still accessible or an unmanaged object, `false` otherwise.
+ */
+fun RealmModel.isValid(): Boolean {
+    return RealmObject.isValid(this)
+}
+
+/**
+ * Checks if this object is managed by Realm. A managed object is just a wrapper around the data in the underlying
+ * Realm file. On Looper threads, a managed object will be live-updated so it always points to the latest data. It
+ * is possible to register a change listener using [addChangeListener] to be
+ * notified when changes happen. Managed objects are thread confined so that they cannot be accessed from other threads
+ * than the one that created them.
+ *
+ * If this method returns `false`, the object is unmanaged. An unmanaged object is just a normal Kotlin object,
+ * so it can be passed freely across threads, but the data in the object is not connected to the underlying Realm,
+ * so it will not be live updated.
+ *
+ * It is possible to create a managed object from an unmanaged object by using
+ * [io.realm.Realm.copyToRealm]. An unmanaged object can be created from a managed object by using
+ * [io.realm.Realm.copyFromRealm].
+ *
+ * @return `true` if the object is managed, `false` if it is unmanaged.
+ */
+fun RealmModel.isManaged(): Boolean {
+    return RealmObject.isManaged(this)
+}
+
+/**
+ * Checks if the query used to find this RealmObject has completed.
+ *
+ * Async methods like [io.realm.RealmQuery.findFirstAsync] return an RealmObject that represents the future result
+ * of the RealmQuery. It can be considered similar to a [java.util.concurrent.Future] in this regard.
+ *
+ * Once `isLoaded()` returns `true`, the object represents the query result even if the query
+ * didn't find any object matching the query parameters. In this case the RealmObject will
+ * become a `null` object.
+ *
+ * "Null" objects represents `null`.  An exception is thrown if any accessor is called, so it is important to also
+ * check isValid before calling any methods. A common pattern is:
+ *
+ *
+ * ```kotlin
+ * val person = realm.where<Person>().findFirstAsync()
+ * person.isLoaded() // == false
+ * person.addChangeListener { p ->
+ *     p.isLoaded() // always true here
+ *     if(p.isValid()) {
+ *         // It is safe to access this person.
+ *     }
+ * }
+ * ```
+ * Synchronous RealmObjects are by definition blocking hence this method will always return `true` for them.
+ * This method will return `true` if called on an unmanaged object (created outside of Realm).
+ *
+ * @return `true` if the query has completed, `false` if the query is in
+ * progress.
+ * @see [isValid]
+ */
+fun RealmModel.isLoaded(): Boolean {
+    return RealmObject.isLoaded(this)
+}
+
+/**
+ * Makes an asynchronous query blocking. This will also trigger any registered listeners.
+ *
+ * Note: This will return `true` if called for an unmanaged object (created outside of Realm).
+ *
+ * @return `true` if it successfully completed the query, `false` otherwise.
+ */
+fun RealmModel.load(): Boolean {
+    return RealmObject.load(this)
+}
+
+
+/**
+ * Adds a change listener to a RealmObject that will be triggered if any value field or referenced RealmObject field
+ * is changed, or the RealmList field itself is changed.
+
+ * Registering a change listener will not prevent the underlying RealmObject from being garbage collected.
+ * If the RealmObject is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+ * strong reference for as long as appropriate e.g. in a class variable.
+ *
+ * ```kotlin
+ * class MyActivity : Activity {
+ *
+ *     private var person: Person?
+ *
+ *     override fun onCreate(savedInstanceState: Bundle?) {
+ *         super.onCreate(savedInstanceState)
+ *         person = realm.where<Person>().findFirst()
+ *         person?.addChangeListener(RealmChangeListener { person ->
+ *             // React to change
+ *         })
+ *     }
+ * }
+ * ```
+ *
+ * @param listener the change listener to be notified.
+ * @throws IllegalArgumentException if the `object` is `null` or an unmanaged object, or the change
+ * listener is `null`.
+ * @throws IllegalStateException if you try to add a listener from a non-Looper or IntentService thread.
+ * @throws IllegalStateException if you try to add a listener inside a transaction.
+ */
+fun <E : RealmModel> E.addChangeListener(listener: RealmChangeListener<E>) {
+    RealmObject.addChangeListener(this, listener)
+}
+
+/**
+ * Adds a change listener to a RealmObject to get detailed information about the changes. The listener will be
+ * triggered if any value field or referenced RealmObject field is changed, or the RealmList field itself is
+ * changed.
+
+ * Registering a change listener will not prevent the underlying RealmObject from being garbage collected.
+ * If the RealmObject is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+ * strong reference for as long as appropriate e.g. in a class variable.
+ *
+ * ```kotlin
+ * class MyActivity : Activity {
+ *
+ *     private var person: Person?
+ *
+ *     override fun onCreate(savedInstanceState: Bundle?) {
+ *         super.onCreate(savedInstanceState)
+ *         person = realm.where<Person>().findFirst()
+ *         person?.addChangeListener(RealmObjectChangeListener { person, changeSet ->
+ *             // React to change
+ *         })
+ *     }
+ * }
+ * ```
+ *
+ * @param listener the change listener to be notified.
+ * @throws IllegalArgumentException if the `object` is `null` or an unmanaged object, or the change
+ * listener is `null`.
+ * @throws IllegalStateException if you try to add a listener from a non-Looper or IntentService thread.
+ * @throws IllegalStateException if you try to add a listener inside a transaction.
+ */
+fun <E : RealmModel> E.addChangeListener(listener: RealmObjectChangeListener<E>) {
+    RealmObject.addChangeListener(this, listener)
+}
+
+/**
+ * Removes a previously registered listener on the given RealmObject.
+ *
+ * @param listener the instance to be removed.
+ * @throws IllegalArgumentException if the `object` or the change listener is `null`.
+ * @throws IllegalArgumentException if object is an unmanaged RealmObject.
+ * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
+ */
+fun  <E : RealmModel> E.removeChangeListener(listener: RealmChangeListener<E>) {
+    RealmObject.removeChangeListener(this, listener)
+}
+
+/**
+ * Removes a previously registered listener on the given RealmObject.
+ *
+ * @param listener the instance to be removed.
+ * @throws IllegalArgumentException if the `object` or the change listener is `null`.
+ * @throws IllegalArgumentException if object is an unmanaged RealmObject.
+ * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
+ */
+fun  <E : RealmModel> E.removeChangeListener(listener: RealmObjectChangeListener<E>) {
+    RealmObject.removeChangeListener(this, listener)
+}
+
+/**
+ * Removes all registered listeners from the given RealmObject.
+ *
+ * @throws IllegalArgumentException if object is `null` or isn't managed by Realm.
+ */
+fun RealmModel.removeAllChangeListeners() {
+    return RealmObject.removeAllChangeListeners(this)
+}
+
diff --git a/realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmQueryExtensions.kt b/realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmQueryExtensions.kt
new file mode 100644
index 0000000000..e9f2c1a4a8
--- /dev/null
+++ b/realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmQueryExtensions.kt
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.kotlin
+
+import io.realm.Case
+import io.realm.RealmModel
+import io.realm.RealmQuery
+import java.util.*
+
+
+/**
+ * In comparison. This allows you to test if objects match any value in an array of values.
+ *
+ * @param fieldName the field to compare.
+ * @param values array of values to compare with and it cannot be null or empty.
+ * @param casing how casing is handled. [Case.INSENSITIVE] works only for the Latin-1 characters.
+ * @return the query object.
+ * @throws java.lang.IllegalArgumentException if the field isn't a String field or `values` is `null` or
+ * empty.
+ */
+fun <T : RealmModel> RealmQuery<T>.oneOf(propertyName: String,
+                                         value: Array<String?>,
+                                         casing: Case = Case.SENSITIVE): RealmQuery<T> {
+    return this.`in`(propertyName, value, casing)
+}
+
+
+/**
+ * In comparison. This allows you to test if objects match any value in an array of values.
+ *
+ * @param fieldName the field to compare.
+ * @param values array of values to compare with and it cannot be null or empty.
+ * @return the query object.
+ * @throws java.lang.IllegalArgumentException if the field isn't a Byte field or `values` is `null` or
+ * empty.
+ */
+fun <T : RealmModel> RealmQuery<T>.oneOf(propertyName: String,
+                                         value: Array<Byte?>): RealmQuery<T> {
+    return this.`in`(propertyName, value)
+}
+
+/**
+ * In comparison. This allows you to test if objects match any value in an array of values.
+ *
+ * @param fieldName the field to compare.
+ * @param values array of values to compare with and it cannot be null or empty.
+ * @return the query object.
+ * @throws java.lang.IllegalArgumentException if the field isn't a Short field or `values` is `null` or
+ * empty.
+ */
+fun <T : RealmModel> RealmQuery<T>.oneOf(propertyName: String,
+                                         value: Array<Short?>): RealmQuery<T> {
+    return this.`in`(propertyName, value)
+}
+
+/**
+ * In comparison. This allows you to test if objects match any value in an array of values.
+ *
+ * @param fieldName the field to compare.
+ * @param values array of values to compare with and it cannot be null or empty.
+ * @return the query object.
+ * @throws java.lang.IllegalArgumentException if the field isn't a Integer field or `values` is `null`
+ * or empty.
+ */
+fun <T : RealmModel> RealmQuery<T>.oneOf(propertyName: String,
+                                         value: Array<Int?>): RealmQuery<T> {
+    return this.`in`(propertyName, value)
+}
+
+/**
+ * In comparison. This allows you to test if objects match any value in an array of values.
+ *
+ * @param fieldName the field to compare.
+ * @param values array of values to compare with and it cannot be null or empty.
+ * @return the query object.
+ * @throws java.lang.IllegalArgumentException if the field isn't a Long field or `values` is `null` or
+ * empty.
+ */
+fun <T : RealmModel> RealmQuery<T>.oneOf(propertyName: String,
+                                         value: Array<Long?>): RealmQuery<T> {
+    return this.`in`(propertyName, value)
+}
+
+/**
+ * In comparison. This allows you to test if objects match any value in an array of values.
+ *
+ * @param fieldName the field to compare.
+ * @param values array of values to compare with and it cannot be null or empty.
+ * @return the query object.
+ * @throws java.lang.IllegalArgumentException if the field isn't a Double field or `values` is `null` or
+ * empty.
+ */
+fun <T : RealmModel> RealmQuery<T>.oneOf(propertyName: String,
+                                         value: Array<Double?>): RealmQuery<T> {
+    return this.`in`(propertyName, value)
+}
+
+
+/**
+ * In comparison. This allows you to test if objects match any value in an array of values.
+ *
+ * @param fieldName the field to compare.
+ * @param values array of values to compare with and it cannot be null or empty.
+ * @return the query object.
+ * @throws java.lang.IllegalArgumentException if the field isn't a Float field or `values` is `null` or
+ * empty.
+ */
+fun <T : RealmModel> RealmQuery<T>.oneOf(propertyName: String,
+                                         value: Array<Float?>): RealmQuery<T> {
+    return this.`in`(propertyName, value)
+}
+
+
+/**
+ * In comparison. This allows you to test if objects match any value in an array of values.
+ *
+ * @param fieldName the field to compare.
+ * @param values array of values to compare with and it cannot be null or empty.
+ * @return the query object.
+ * @throws java.lang.IllegalArgumentException if the field isn't a Boolean field or `values` is `null`
+ * or empty.
+ */
+fun <T : RealmModel> RealmQuery<T>.oneOf(propertyName: String,
+                                         value: Array<Boolean?>): RealmQuery<T> {
+    return this.`in`(propertyName, value)
+}
+
+/**
+ * In comparison. This allows you to test if objects match any value in an array of values.
+ *
+ * @param fieldName the field to compare.
+ * @param values array of values to compare with and it cannot be null or empty.
+ * @return the query object.
+ * @throws java.lang.IllegalArgumentException if the field isn't a Date field or `values` is `null` or
+ * empty.
+ */
+fun <T : RealmModel> RealmQuery<T>.oneOf(propertyName: String,
+                                         value: Array<Date?>): RealmQuery<T> {
+    return this.`in`(propertyName, value)
+}
diff --git a/realm/kotlin-extensions/src/main/res/values/strings.xml b/realm/kotlin-extensions/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..764b07b814
--- /dev/null
+++ b/realm/kotlin-extensions/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">kotlin-extensions</string>
+</resources>
diff --git a/realm/realm-annotations-processor/build.gradle b/realm/realm-annotations-processor/build.gradle
index 43c75faafd..5c203099a7 100644
--- a/realm/realm-annotations-processor/build.gradle
+++ b/realm/realm-annotations-processor/build.gradle
@@ -4,18 +4,18 @@ apply plugin: 'maven-publish'
 apply plugin: 'com.jfrog.artifactory'
 apply plugin: 'com.jfrog.bintray'
 
-sourceCompatibility = '1.6'
-targetCompatibility = '1.6'
+sourceCompatibility = '1.8'
+targetCompatibility = '1.8'
 
 dependencies {
-    compile "com.squareup:javawriter:2.5.0"
+    compile "com.squareup:javawriter:2.5.1"
     compile "io.realm:realm-annotations:${version}"
 
     testCompile files('../realm-library/build/intermediates/bundles/baseRelease/classes.jar') // Java projects cannot depend on AAR files
     testCompile files("${System.properties['java.home']}/../lib/tools.jar") // This is needed otherwise compile-testing won't be able to find it
     testCompile group:'junit', name:'junit', version:'4.12'
     testCompile group:'com.google.testing.compile', name:'compile-testing', version:'0.6'
-    testCompile files(file("${System.env.ANDROID_HOME}/platforms/android-26/android.jar"))
+    testCompile files(file("${System.env.ANDROID_HOME}/platforms/android-27/android.jar"))
 }
 
 // for Ant filter
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
index a9df486007..af2bf3cc35 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
@@ -18,6 +18,7 @@
 
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -81,7 +82,7 @@ public boolean generate(Set<? extends Element> clazzes) {
             if (module.allClasses()) {
                 classes = availableClasses;
             } else {
-                classes = new HashSet<ClassMetaData>();
+                classes = new LinkedHashSet<ClassMetaData>();
                 Set<String> classNames = getClassMetaDataFromModule(classElement);
                 for (String fullyQualifiedClassName : classNames) {
                     ClassMetaData metadata = classMetaData.get(fullyQualifiedClassName);
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index 1d68cae873..713ab6b2ef 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -19,6 +19,7 @@
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
 
@@ -132,7 +133,7 @@
 
 
     // List of all fields maintained by Realm (RealmResults)
-    private final Set<ClassMetaData> classesToValidate = new HashSet<ClassMetaData>();
+    private final Set<ClassMetaData> classesToValidate = new LinkedHashSet<ClassMetaData>();
     // List of backlinks
     private final Set<Backlink> backlinksToValidate = new HashSet<Backlink>();
 
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
index 29e965598d..80a30b44ef 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
@@ -32,8 +32,7 @@
 
     @Override
     public Map<Class<? extends RealmModel>, OsObjectSchemaInfo> getExpectedObjectSchemaInfoMap() {
-        Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap =
-                    new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>(1);
+        Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap = new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>(1);
         infoMap.put(some.test.AllTypes.class, io.realm.AllTypesRealmProxy.getExpectedObjectSchemaInfo());
         return infoMap;
     }
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index 34c1c257c8..ce4fd40b06 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -40,12 +40,12 @@ ext.lcachePath = project.findProperty('lcachePath') ?: System.getenv('NDK_LCACHE
 ext.enableDebugCore = project.hasProperty('enableDebugCore') ? project.getProperty('enableDebugCore') : false //FIXME Use 'false' as default until https://github.com/realm/realm-java/issues/5354 is fixed
 
 android {
-    compileSdkVersion 26
-    buildToolsVersion '26.0.2'
+    compileSdkVersion rootProject.compileSdkVersion
+    buildToolsVersion rootProject.buildToolsVersion
 
     defaultConfig {
-        minSdkVersion 9
-        targetSdkVersion 25
+        minSdkVersion rootProject.minSdkVersion
+        targetSdkVersion rootProject.compileSdkVersion
         versionName version
         project.archivesBaseName = "realm-android-library"
         testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
@@ -90,13 +90,14 @@ android {
 
     buildTypes {
         debug {
-            testCoverageEnabled = true
+            // FIXME: If enabled, crashes with https://issuetracker.google.com/issues/37116868
+            testCoverageEnabled = false
         }
     }
 
     sourceSets {
         androidTest {
-            java.srcDirs += 'src/androidTest/kotlin'
+            java.srcDirs += ['src/androidTest/kotlin', 'src/testUtils/java']
         }
         androidTestObjectServer {
             java.srcDirs += 'src/syncIntegrationTest/java'
@@ -105,8 +106,8 @@ android {
     }
 
     compileOptions {
-        sourceCompatibility JavaVersion.VERSION_1_7
-        targetCompatibility JavaVersion.VERSION_1_7
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
     }
 
     packagingOptions {
@@ -168,7 +169,7 @@ project.afterEvaluate {
     }
 }
 
-// enable @ParametersAreNonnullByDefault annotation. See https://blog.jetbrains.com/kotlin/2017/08/kotlin-1-1-4-is-out/
+// enable @ParametersAreNonnullByDefault annotation. See https://blog.jetbrains.com/kotlin/2017/09/kotlin-1-1-50-is-out/
 tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
     kotlinOptions {
         freeCompilerArgs = ["-Xjsr305=strict"]
@@ -188,7 +189,7 @@ repositories {
 
 dependencies {
 
-    compileOnly 'io.reactivex.rxjava2:rxjava:2.1.4'
+    compileOnly 'io.reactivex.rxjava2:rxjava:2.1.5'
     compileOnly 'com.google.code.findbugs:findbugs-annotations:3.0.1'
 
     api "io.realm:realm-annotations:${version}"
@@ -200,7 +201,7 @@ dependencies {
 
     kaptAndroidTest project(':realm-annotations-processor')
     androidTestImplementation fileTree(dir: 'testLibs', include: ['*.jar'])
-    androidTestImplementation 'io.reactivex.rxjava2:rxjava:2.1.4'
+    androidTestImplementation 'io.reactivex.rxjava2:rxjava:2.1.5'
     androidTestImplementation 'com.android.support.test:runner:1.0.1'
     androidTestImplementation 'com.android.support.test:rules:1.0.1'
     androidTestImplementation 'com.google.dexmaker:dexmaker:1.2'
@@ -210,7 +211,7 @@ dependencies {
     androidTestImplementation "org.jetbrains.kotlin:kotlin-reflect:$kotlin_version"
 
     // specify error prone version to prevent sudden failure
-    errorprone 'com.google.errorprone:error_prone_core:2.0.21'
+    errorprone 'com.google.errorprone:error_prone_core:2.1.2'
 }
 
 task sourcesJar(type: Jar) {
@@ -612,7 +613,7 @@ android.productFlavors.all { flavor ->
     def librarySuffix = flavor.name == 'base' ? '' : '-object-server'
     def userName = project.findProperty('bintrayUser') ?: 'noUser'
     def accessKey = project.findProperty('bintrayKey') ?: 'noKey'
-
+    def artifactId = "realm-android-library${librarySuffix}"
     // BINTRAY
 
     task("bintrayAar${flavor.name.capitalize()}", type: Exec) {
@@ -625,7 +626,7 @@ android.productFlavors.all { flavor ->
                 "${buildDir}/outputs/aar/realm-android-library-${flavor.name}-release.aar",
                 '-u',
                 "${userName}:${accessKey}",
-                "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.aar?publish=0"
+                "https://api.bintray.com/content/realm/maven/${artifactId}/${project.version}/io/realm/${artifactId}/${project.version}/${artifactId}-${project.version}.aar?publish=0"
     }
 
     task("bintraySources${flavor.name.capitalize()}", type: Exec) {
@@ -638,7 +639,7 @@ android.productFlavors.all { flavor ->
                 "${buildDir}/libs/realm-android-library-${project.version}-sources.jar",
                 '-u',
                 "${userName}:${accessKey}",
-                "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-sources.jar?publish=0"
+                "https://api.bintray.com/content/realm/maven/${artifactId}/${project.version}/io/realm/${artifactId}/${project.version}/${artifactId}-${project.version}-sources.jar?publish=0"
     }
 
     task("bintrayJavadoc${flavor.name.capitalize()}", type: Exec) {
@@ -651,7 +652,7 @@ android.productFlavors.all { flavor ->
                 "${buildDir}/libs/realm-android-library-${project.version}-javadoc.jar",
                 '-u',
                 "${userName}:${accessKey}",
-                "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-javadoc.jar?publish=0"
+                "https://api.bintray.com/content/realm/maven/${artifactId}/${project.version}/io/realm/${artifactId}/${project.version}/${artifactId}-${project.version}-javadoc.jar?publish=0"
     }
 
     task("bintrayPom${flavor.name.capitalize()}", type: Exec) {
@@ -664,7 +665,7 @@ android.productFlavors.all { flavor ->
                 "${buildDir}/publications/${flavor.name}Publication/pom-default.xml",
                 '-u',
                 "${userName}:${accessKey}",
-                "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.pom?publish=0"
+                "https://api.bintray.com/content/realm/maven/${artifactId}/${project.version}/io/realm/${artifactId}/${project.version}/${artifactId}-${project.version}.pom?publish=0"
     }
 
     // OJO
diff --git a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
index 42ece9c78d..3b1142cfc0 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
@@ -258,7 +258,7 @@ public void insert_cyclicType() {
         realm.insert(Arrays.asList(oneCyclicType, anotherCyclicType));
         realm.commitTransaction();
 
-        RealmResults<CyclicType> realmObjects = realm.where(CyclicType.class).findAllSorted(CyclicType.FIELD_NAME);
+        RealmResults<CyclicType> realmObjects = realm.where(CyclicType.class).sort(CyclicType.FIELD_NAME).findAll();
         assertNotNull(realmObjects);
         assertEquals(2, realmObjects.size());
         assertEquals("One", realmObjects.get(0).getName());
@@ -276,7 +276,7 @@ public void insertOrUpdate_cyclicType() {
         realm.insertOrUpdate(Arrays.asList(oneCyclicType, anotherCyclicType));
         realm.commitTransaction();
 
-        RealmResults<CyclicTypePrimaryKey> realmObjects = realm.where(CyclicTypePrimaryKey.class).findAllSorted("name");
+        RealmResults<CyclicTypePrimaryKey> realmObjects = realm.where(CyclicTypePrimaryKey.class).sort("name").findAll();
         assertNotNull(realmObjects);
         assertEquals(2, realmObjects.size());
         assertEquals("One", realmObjects.get(0).getName());
@@ -694,7 +694,7 @@ public void insertOrUpdate_mixingNoPrimaryKeyAndPrimaryKeyModels() {
         realm.insertOrUpdate(objA_no_pk);
         realm.commitTransaction();
 
-        all = realm.where(NoPrimaryKeyWithPrimaryKeyObjectRelation.class).findAllSorted("columnString");
+        all = realm.where(NoPrimaryKeyWithPrimaryKeyObjectRelation.class).sort("columnString").findAll();
         assertEquals(2, all.size());
         assertEquals("A", all.get(0).getColumnString());
         assertEquals(8, all.get(0).getColumnInt());
@@ -735,7 +735,9 @@ public void insertOrUpdate_mixingPrimaryAndNoPrimaryKeyList() {
         realm.insertOrUpdate(objects);
         realm.commitTransaction();
 
-        RealmResults<NoPrimaryKeyWithPrimaryKeyObjectRelation> all = realm.where(NoPrimaryKeyWithPrimaryKeyObjectRelation.class).findAllSorted("columnString", Sort.DESCENDING);
+        RealmResults<NoPrimaryKeyWithPrimaryKeyObjectRelation> all = realm.where(NoPrimaryKeyWithPrimaryKeyObjectRelation.class)
+                .sort("columnString", Sort.DESCENDING)
+                .findAll();
         assertEquals(2, all.size());
         assertEquals("B", all.get(0).getColumnString());
         assertEquals("A", all.get(1).getColumnString());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
index c45a8cd2b9..64cb64ede3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
@@ -98,7 +98,7 @@ protected void populateRealm(Realm realm, int objects) {
 
             // Adds all items to the RealmList on the first object.
             AllJavaTypes firstObj = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_ID, 0).findFirst();
-            RealmResults<AllJavaTypes> listData = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_ID, Sort.ASCENDING);
+            RealmResults<AllJavaTypes> listData = realm.where(AllJavaTypes.class).sort(AllJavaTypes.FIELD_ID, Sort.ASCENDING).findAll();
             RealmList<AllJavaTypes> list = firstObj.getFieldList();
             for (int i = 0; i < listData.size(); i++) {
                 list.add(listData.get(i));
@@ -202,7 +202,7 @@ protected void populatePartialNullRowsForNumericTesting(Realm realm) {
                     obj.setFieldString(arg);
                 }
                 realm.commitTransaction();
-                orderedCollection = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_STRING);
+                    orderedCollection = realm.where(AllJavaTypes.class).sort(AllJavaTypes.FIELD_STRING).findAll();
                 break;
 
             case REALMRESULTS_SNAPSHOT_LIST_BASE:
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
index 3ac4e327db..0acf690f3c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
@@ -220,8 +220,8 @@ public void run() {
                         try {
                             callThreadConfinedMethod(obj, method);
                             fail("IllegalStateException must be thrown.");
-                        } catch (Throwable e) {
-                            if (e instanceof IllegalStateException && expectedMessage.equals(e.getMessage())) {
+                        } catch (IllegalStateException e) {
+                            if (expectedMessage.equals(e.getMessage())) {
                                 // expected exception
                                 continue;
                             }
@@ -1613,15 +1613,14 @@ public void getRealm_illegalThreadThrows() throws Throwable {
         final DynamicRealmObject object = dynamicRealm.where(AllTypes.CLASS_NAME).findFirst();
 
         final CountDownLatch threadFinished = new CountDownLatch(1);
-        final AtomicReference<Throwable> throwable = new AtomicReference<>();
         final Thread thread = new Thread(new Runnable() {
             @Override
             public void run() {
                 try {
                     object.getDynamicRealm();
                     fail();
-                } catch (Throwable t) {
-                    throwable.set(t);
+                } catch (IllegalStateException e) {
+                    assertEquals(BaseRealm.INCORRECT_THREAD_MESSAGE, e.getMessage());
                 } finally {
                     threadFinished.countDown();
                 }
@@ -1629,11 +1628,5 @@ public void run() {
         });
         thread.start();
         TestHelper.awaitOrFail(threadFinished);
-
-        final Throwable thrownInTheThread = throwable.get();
-        if (!(thrownInTheThread instanceof IllegalStateException)) {
-            throw thrownInTheThread;
-        }
-        assertEquals(BaseRealm.INCORRECT_THREAD_MESSAGE, thrownInTheThread.getMessage());
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index 7e8d36dd75..573c1e21d7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -394,11 +394,12 @@ public void onChange(RealmResults<DynamicRealmObject> object) {
 
     @Test
     @RunTestInLooperThread
-    public void findAllSortedAsync() {
+    public void sort_async() {
         final DynamicRealm dynamicRealm = initializeDynamicRealm();
         final RealmResults<DynamicRealmObject> allTypes = dynamicRealm.where(AllTypes.CLASS_NAME)
                 .between(AllTypes.FIELD_LONG, 0, 4)
-                .findAllSortedAsync(AllTypes.FIELD_STRING, Sort.DESCENDING);
+                .sort(AllTypes.FIELD_STRING, Sort.DESCENDING)
+                .findAllAsync();
         assertFalse(allTypes.isLoaded());
         assertEquals(0, allTypes.size());
 
@@ -428,7 +429,7 @@ private DynamicRealm initializeDynamicRealm() {
 
     @Test
     @RunTestInLooperThread
-    public void findAllSortedAsync_usingMultipleFields() {
+    public void sort_async_usingMultipleFields() {
         final DynamicRealm dynamicRealm = initializeDynamicRealm();
 
         dynamicRealm.setAutoRefresh(false);
@@ -448,18 +449,20 @@ public void findAllSortedAsync_usingMultipleFields() {
 
         // Sorts first set by using: String[ASC], Long[DESC].
         final RealmResults<DynamicRealmObject> realmResults1 = dynamicRealm.where(AllTypes.CLASS_NAME)
-                .findAllSortedAsync(
+                .sort(
                         new String[]{AllTypes.FIELD_STRING, AllTypes.FIELD_LONG},
                         new Sort[]{Sort.ASCENDING, Sort.DESCENDING}
-                );
+                )
+                .findAllAsync();
 
         // Sorts second set by using: String[DESC], Long[ASC].
         final RealmResults<DynamicRealmObject> realmResults2 = dynamicRealm.where(AllTypes.CLASS_NAME)
                 .between(AllTypes.FIELD_LONG, 0, 5)
-                .findAllSortedAsync(
+                .sort(
                         new String[]{AllTypes.FIELD_STRING, AllTypes.FIELD_LONG},
                         new Sort[]{Sort.DESCENDING, Sort.ASCENDING}
-                );
+                )
+                .findAllAsync();
 
         final Runnable signalCallbackDone = new Runnable() {
             final AtomicInteger callbacksDone = new AtomicInteger(2);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
index 5b8cf56418..bd1ed35c67 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
@@ -79,7 +79,7 @@ public void iOSDataTypes() throws IOException {
             configFactory.copyRealmFromAssets(context,
                     "ios/" + iosVersion + "-alltypes.realm", REALM_NAME);
             realm = Realm.getDefaultInstance();
-            RealmResults<IOSAllTypes> result = realm.where(IOSAllTypes.class).findAllSorted("id", Sort.ASCENDING);
+            RealmResults<IOSAllTypes> result = realm.where(IOSAllTypes.class).sort("id", Sort.ASCENDING).findAll();
             // Verifies metadata.
             Table table = realm.getTable(IOSAllTypes.class);
             assertEquals("id", OsObjectStore.getPrimaryKeyForObject(realm.getSharedRealm(), IOSAllTypes.CLASS_NAME));
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
index d690a3fb44..d609d7fc8e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
@@ -678,7 +678,7 @@ public void query_multipleReferencesWithDistinct() {
 
         assertEquals(2, child.getListParents().size());
 
-        RealmResults<AllJavaTypes> distinctParents = child.getListParents().where().distinct("fieldId");
+        RealmResults<AllJavaTypes> distinctParents = child.getListParents().where().distinctValues("fieldId").findAll();
         assertEquals(1, distinctParents.size());
         assertTrue(child.getListParents().contains(parent));
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
index c50e59cc54..5fa3c49f3e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
@@ -698,7 +698,7 @@ public void deleteFirstFromRealm() {
                     dog.setName("Dog " + i);
                 }
                 realm.commitTransaction();
-                orderedCollection = realm.where(Dog.class).findAllSorted(Dog.FIELD_AGE);
+                orderedCollection = realm.where(Dog.class).sort(Dog.FIELD_AGE).findAll();
                 break;
 
             default:
@@ -779,10 +779,10 @@ public void mutableMethodsOutsideTransactions() {
                     case REMOVE_INDEX: collection.remove(0); break;
                 }
                 fail("Unknown method or it failed to throw: " + method);
-            } catch (Throwable t) {
-                if (!t.getClass().equals(expected)) {
-                    fail(method + " didn't throw the expected exception. Was: " + t + ", expected: " + expected);
-                }
+            } catch (IllegalStateException e) {
+                assertEquals(expected, e.getClass());
+            } catch (UnsupportedOperationException e) {
+                assertEquals(expected, e.getClass());
             }
         }
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
index 96fc619417..7b02a12d96 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
@@ -138,7 +138,8 @@ public void tearDown() {
             case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
                 orderedCollection = realm.where(AllJavaTypes.class)
-                        .findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+                        .sort(AllJavaTypes.FIELD_LONG, Sort.ASCENDING)
+                        .findAll();
                 break;
 
             default:
@@ -341,15 +342,15 @@ public void where_findAll_size() {
     }
 
     @Test
-    public void where_findAllSorted() {
-        RealmResults<AllJavaTypes> results = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+    public void where_sort() {
+        RealmResults<AllJavaTypes> results = realm.where(AllJavaTypes.class).sort(AllJavaTypes.FIELD_LONG, Sort.ASCENDING).findAll();
         assertEquals(TEST_SIZE, results.size());
         //noinspection ConstantConditions
         assertEquals(0, results.first().getFieldLong());
         //noinspection ConstantConditions
         assertEquals(TEST_SIZE - 1, results.last().getFieldLong());
 
-        RealmResults<AllJavaTypes> reverseList = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.DESCENDING);
+        RealmResults<AllJavaTypes> reverseList = realm.where(AllJavaTypes.class).sort(AllJavaTypes.FIELD_LONG, Sort.DESCENDING).findAll();
         assertEquals(TEST_SIZE, reverseList.size());
         //noinspection ConstantConditions
         assertEquals(0, reverseList.last().getFieldLong());
@@ -357,8 +358,7 @@ public void where_findAllSorted() {
         assertEquals(TEST_SIZE - 1, reverseList.first().getFieldLong());
 
         try {
-            realm.where(AllJavaTypes.class).findAllSorted("invalid",
-                    Sort.DESCENDING);
+            realm.where(AllJavaTypes.class).sort("invalid", Sort.DESCENDING).findAll();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -784,10 +784,10 @@ public void mutableMethodsOutsideTransactions() {
                     case RETAIN_ALL: collection.retainAll(Collections.singletonList(new AllJavaTypes())); break;
                 }
                 fail("Unknown method or it failed to throw: " + method);
-            } catch (Throwable t) {
-                if (!t.getClass().equals(expected)) {
-                    fail(method + " didn't throw the expected exception. Was: " + t + ", expected: " + expected);
-                }
+            } catch (IllegalStateException e) {
+                assertEquals(expected, e.getClass());
+            } catch (UnsupportedOperationException e) {
+                assertEquals(expected, e.getClass());
             }
         }
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
index ca5fe29fc6..a8e0b8701c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
@@ -26,6 +26,8 @@
 import java.util.Arrays;
 import java.util.List;
 
+import javax.annotation.Nullable;
+
 import io.realm.entities.Dog;
 import io.realm.entities.Owner;
 import io.realm.rule.RunInLooperThread;
@@ -38,9 +40,11 @@
 import static junit.framework.Assert.assertSame;
 import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertNotEquals;
 
 
 // Tests for the ordered collection fine grained notifications for both RealmResults and RealmList.
+@SuppressWarnings("ConstantConditions") // Suppress the null return value warnings for RealmList.get()
 @RunWith(Parameterized.class)
 public class OrderedCollectionChangeSetTests {
 
@@ -110,16 +114,6 @@ private void checkRanges(OrderedCollectionChangeSet.Range[] ranges, int... index
         }
     }
 
-    // Re-adds the dogs so they would be sorted by age in the list.
-    private void reorderRealmList(Realm realm) {
-        RealmResults<Dog> dogs = realm.where(Dog.class).findAllSorted(Dog.FIELD_AGE);
-        Owner owner = realm.where(Owner.class).findFirst();
-        owner.getDogs().clear();
-        for (Dog dog : dogs) {
-            owner.getDogs().add(dog);
-        }
-    }
-
     // Deletes Dogs objects which's columnLong is in the indices array.
     private void deleteObjects(Realm realm, int... indices) {
         for (int index : indices) {
@@ -130,10 +124,25 @@ private void deleteObjects(Realm realm, int... indices) {
     // Creates Dogs objects with columnLong set to the value elements in indices array.
     private void createObjects(Realm realm, int... indices) {
         for (int index : indices) {
-            realm.createObject(Dog.class).setAge(index);
-        }
-        if (type == ObservablesType.REALM_LIST) {
-            reorderRealmList(realm);
+            Dog dog = realm.createObject(Dog.class);
+            dog.setAge(index);
+            if (type == ObservablesType.REALM_LIST) {
+                Owner owner = realm.where(Owner.class).findFirst();
+                assertNotNull(owner);
+                RealmList<Dog> dogs = owner.getDogs();
+                boolean added = false;
+                // Insert the newly created dog to the RealmList by the order of age.
+                for (int i = 0; i < dogs.size(); i++) {
+                    if (dog.getAge() <= dogs.get(i).getAge()) {
+                        dogs.add(i, dog);
+                        added = true;
+                        break;
+                    }
+                }
+                if (!added) {
+                    dogs.add(dog);
+                }
+            }
         }
     }
 
@@ -147,30 +156,76 @@ private void modifyObjects(Realm realm, int... indices) {
     }
 
     private void moveObjects(Realm realm, int originAge, int newAge) {
-        realm.where(Dog.class).equalTo(Dog.FIELD_AGE, originAge).findFirst().setAge(newAge);
         if (type == ObservablesType.REALM_LIST) {
-            reorderRealmList(realm);
+            // For RealmList we need to:
+            // 1. Find the object by the original age and move it to the new place where it should be with the new age
+            //    set -- the RealmList is sorted by age.
+            // 2. Set the object's age with new value.
+            RealmList<Dog> dogs = realm.where(Owner.class).findFirst().getDogs();
+            int originIdx = -1;
+            int newIdx = -1;
+            for (int i = 0; i < dogs.size(); i++) {
+                Dog dog = dogs.get(i);
+                assertNotNull(dog);
+                if (dog.getAge() == originAge) {
+                    originIdx = i;
+                    break;
+                }
+            }
+            assertNotEquals(-1, originIdx);
+            for (int i = 0; i < dogs.size(); i++) {
+                if (i == originIdx) {
+                    // not precise code, but good enough for testing.
+                    continue;
+                }
+                if (newAge <= dogs.get(i).getAge()) {
+                    newIdx = i;
+                    break;
+                }
+            }
+            if (newIdx == -1) {
+                newIdx = dogs.size() - 1;
+            }
+            dogs.get(originIdx).setAge(newAge);
+            dogs.move(originIdx, newIdx);
+        } else {
+            // Since the RealmResults is sorted by age, just simply set the object's age with new value.
+            realm.where(Dog.class).equalTo(Dog.FIELD_AGE, originAge).findFirst().setAge(newAge);
         }
     }
 
-    private void registerCheckListener(Realm realm, final ChangesCheck changesCheck) {
+    private OrderedRealmCollection<Dog> getTestingCollection(Realm realm) {
         switch (type) {
             case REALM_RESULTS:
-                RealmResults<Dog> results = realm.where(Dog.class).findAllSorted(Dog.FIELD_AGE);
+                RealmResults<Dog> results = realm.where(Dog.class).sort(Dog.FIELD_AGE).findAll();
                 looperThread.keepStrongReference(results);
+                return results;
+            case REALM_LIST:
+                RealmList<Dog> list = realm.where(Owner.class).findFirst().getDogs();
+                looperThread.keepStrongReference(list);
+                return list;
+        }
+        fail();
+        return null;
+    }
+
+    private void registerCheckListener(Realm realm, final ChangesCheck changesCheck) {
+        switch (type) {
+            case REALM_RESULTS:
+                RealmResults<Dog> results = (RealmResults<Dog>) getTestingCollection(realm);
                 results.addChangeListener(new OrderedRealmCollectionChangeListener<RealmResults<Dog>>() {
                     @Override
-                    public void onChange(RealmResults<Dog> collection, OrderedCollectionChangeSet changeSet) {
+                    public void onChange(RealmResults<Dog> collection, @Nullable OrderedCollectionChangeSet changeSet) {
                         changesCheck.check(changeSet);
                     }
                 });
                 break;
             case REALM_LIST:
-                RealmList<Dog> list = realm.where(Owner.class).findFirst().getDogs();
+                RealmList<Dog> list = (RealmList<Dog>) getTestingCollection(realm);
                 looperThread.keepStrongReference(list);
                 list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Dog>>() {
                     @Override
-                    public void onChange(RealmList<Dog> collection, OrderedCollectionChangeSet changeSet) {
+                    public void onChange(RealmList<Dog> collection, @Nullable OrderedCollectionChangeSet changeSet) {
                         changesCheck.check(changeSet);
                     }
                 });
@@ -412,11 +467,11 @@ public void emptyChangeSet_findAllAsync() {
 
         Realm realm = looperThread.getRealm();
         populateData(realm, 10);
-        final RealmResults<Dog> results = realm.where(Dog.class).findAllSortedAsync(Dog.FIELD_AGE);
+        final RealmResults<Dog> results = realm.where(Dog.class).sort(Dog.FIELD_AGE).findAllAsync();
         looperThread.keepStrongReference(results);
         results.addChangeListener(new OrderedRealmCollectionChangeListener<RealmResults<Dog>>() {
             @Override
-            public void onChange(RealmResults<Dog> collection, OrderedCollectionChangeSet changeSet) {
+            public void onChange(RealmResults<Dog> collection, @Nullable OrderedCollectionChangeSet changeSet) {
                 assertSame(collection, results);
                 assertEquals(10, collection.size());
                 assertNull(changeSet);
@@ -424,4 +479,80 @@ public void onChange(RealmResults<Dog> collection, OrderedCollectionChangeSet ch
             }
         });
     }
+
+    // To reproduce https://github.com/realm/realm-java/issues/5507
+    // 1. Add listener to a collection
+    // A. change the collection in a background thread
+    // 2. Remove the listener
+    // 3. Add another listener
+    // 4. the listener added in step 3 should be triggered with change set in step A
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener_bug5507() throws InterruptedException {
+        // FIXME: See https://github.com/realm/realm-object-store/issues/605
+        if (type == ObservablesType.REALM_RESULTS) {
+            looperThread.testComplete();
+            return;
+        }
+
+        Realm realm = looperThread.getRealm();
+        populateData(realm, 1);
+
+        OrderedRealmCollectionChangeListener<OrderedRealmCollection<Dog>> listener1 =
+                new OrderedRealmCollectionChangeListener<OrderedRealmCollection<Dog>>() {
+            @Override
+            public void onChange(OrderedRealmCollection<Dog> dogs, @Nullable OrderedCollectionChangeSet changeSet) {
+                fail();
+            }
+        };
+
+        OrderedRealmCollection<Dog> dogs = getTestingCollection(realm);
+        assertEquals(1, dogs.size());
+
+        if (type == ObservablesType.REALM_LIST) {
+            //noinspection unchecked
+            ((RealmList) dogs).addChangeListener(listener1);
+        } else {
+            //noinspection unchecked
+            ((RealmResults) dogs).addChangeListener(listener1);
+        }
+
+        Thread bgThread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(looperThread.getConfiguration());
+                realm.beginTransaction();
+                createObjects(realm, 2);
+                realm.commitTransaction();
+                realm.close();
+            }
+        });
+        bgThread.start();
+        bgThread.join();
+
+        if (type == ObservablesType.REALM_LIST) {
+            //noinspection unchecked
+            ((RealmList) dogs).removeChangeListener(listener1);
+        } else {
+            //noinspection unchecked
+            ((RealmResults) dogs).removeChangeListener(listener1);
+        }
+
+        OrderedRealmCollectionChangeListener<OrderedRealmCollection<Dog>> listener2 =
+                new OrderedRealmCollectionChangeListener<OrderedRealmCollection<Dog>>() {
+                    @Override
+                    public void onChange(OrderedRealmCollection<Dog> dogs, @Nullable OrderedCollectionChangeSet changeSet) {
+                        assertEquals(2, dogs.size());
+                        looperThread.testComplete();
+                    }
+                };
+
+        if (type == ObservablesType.REALM_LIST) {
+            //noinspection unchecked
+            ((RealmList) dogs).addChangeListener(listener2);
+        } else {
+            //noinspection unchecked
+            ((RealmResults) dogs).addChangeListener(listener2);
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
index d7e705a0fd..a5d15ad8e1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
@@ -42,6 +42,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -98,7 +99,9 @@ public void tearDown() {
 
             case UNMANAGED_REALMLIST:
                 populateRealm(realm, sampleSize);
-                RealmResults<AllJavaTypes> objects = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+                RealmResults<AllJavaTypes> objects = realm.where(AllJavaTypes.class)
+                        .sort(AllJavaTypes.FIELD_LONG, Sort.ASCENDING)
+                        .findAll();
                 RealmList<AllJavaTypes> inMemoryList = new RealmList<AllJavaTypes>();
                 inMemoryList.addAll(objects);
                 return inMemoryList;
@@ -107,7 +110,8 @@ public void tearDown() {
             case REALMRESULTS:
                 populateRealm(realm, sampleSize);
                 orderedCollection = realm.where(AllJavaTypes.class)
-                        .findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+                        .sort(AllJavaTypes.FIELD_LONG, Sort.ASCENDING)
+                        .findAll();
                 break;
 
             default:
@@ -429,6 +433,7 @@ public void listIterator_remove_beforeNext() {
 
         try {
             it.remove();
+            fail();
         } catch (IllegalStateException e) {
             assertRealmList();
         } catch (UnsupportedOperationException e) {
@@ -612,22 +617,25 @@ public void listIterator_set() {
         assertEquals(42, obj.getFieldLong());
     }
 
+    @Test
     public void listIterator_add() {
-        if (skipTest(CollectionClass.REALMRESULTS)) {
+        if (skipTest(CollectionClass.REALMRESULTS, CollectionClass.REALMRESULTS_SNAPSHOT_RESULTS_BASE,
+                CollectionClass.REALMRESULTS_SNAPSHOT_LIST_BASE)) {
             return;
         }
 
         realm.beginTransaction();
         ListIterator<AllJavaTypes> it = collection.listIterator();
 
-        // Calling set() before next() should throw.
-        try {
-            it.add(new AllJavaTypes());
-            fail();
-        } catch (IllegalStateException ignored) {
-        }
+        // The element is inserted immediately before the element that would be returned by next(), if any, and after
+        // the element that would be returned by previous(), if any. (If the list contains no elements, the new element
+        // becomes the sole element on the list.)
+        it.add(new AllJavaTypes(4242));
+        AllJavaTypes obj = collection.first();
+        assertNotNull(obj);
+        assertEquals(4242, obj.getFieldLong());
 
-        AllJavaTypes obj = it.next();
+        obj = it.next();
         assertEquals(0, obj.getFieldLong());
         it.add(new AllJavaTypes(42));
         obj = it.previous();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
index 5a9ef34cb2..2b6191da8c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
@@ -428,7 +428,12 @@ public void createSnapshot() {
                 break;
             case MANAGED_REALMLIST:
             case REALMRESULTS:
-                assertEquals(collection.size(), snapshot.size());
+                int sizeBeforeChange = collection.size();
+                realm.beginTransaction();
+                collection.deleteLastFromRealm();
+                realm.commitTransaction();
+                assertEquals(sizeBeforeChange - 1, collection.size());
+                assertEquals(sizeBeforeChange, snapshot.size());
                 break;
             default:
                 break;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index 770337505e..6d7a320cd2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -20,7 +20,6 @@
 import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -769,13 +768,14 @@ public void onChange(AllTypes element) {
     // similar UC as #testFindAllAsync using 'findAllSorted'
     @Test
     @RunTestInLooperThread
-    public void findAllSortedAsync() throws Throwable {
+    public void sort_async() throws Throwable {
         final Realm realm = looperThread.getRealm();
         populateTestRealm(realm, 10);
 
         final RealmResults<AllTypes> results = realm.where(AllTypes.class)
                 .between("columnLong", 0, 4)
-                .findAllSortedAsync("columnString", Sort.DESCENDING);
+                .sort("columnString", Sort.DESCENDING)
+                .findAllAsync();
 
         assertFalse(results.isLoaded());
         assertEquals(0, results.size());
@@ -879,16 +879,16 @@ public void run() {
 
     @Test
     @RunTestInLooperThread
-    public void distinctAsync() throws Throwable {
+    public void distinct_async() throws Throwable {
         Realm realm = looperThread.getRealm();
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctAsync("indexBoolean");
-        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).distinctAsync("indexLong");
-        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).distinctAsync("indexDate");
-        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).distinctAsync("indexString");
+        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctValues("indexBoolean").findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).distinctValues("indexLong").findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).distinctValues("indexDate").findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).distinctValues("indexString").findAllAsync();
 
         assertFalse(distinctBool.isLoaded());
         assertTrue(distinctBool.isValid());
@@ -955,7 +955,7 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
 
     @Test
     @RunTestInLooperThread()
-    public void distinctAsync_rememberQueryParams() {
+    public void distinct_async_rememberQueryParams() {
         final Realm realm = looperThread.getRealm();
         realm.beginTransaction();
         final int TEST_SIZE = 10;
@@ -966,7 +966,8 @@ public void distinctAsync_rememberQueryParams() {
 
         RealmResults<AllJavaTypes> results = realm.where(AllJavaTypes.class)
                 .notEqualTo(AllJavaTypes.FIELD_ID, TEST_SIZE / 2)
-                .distinctAsync(AllJavaTypes.FIELD_ID);
+                .distinctValues(AllJavaTypes.FIELD_ID)
+                .findAllAsync();
 
         results.addChangeListener(new RealmChangeListener<RealmResults<AllJavaTypes>>() {
             @Override
@@ -987,13 +988,17 @@ public void distinctAsync_notIndexedFields() throws Throwable {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class)
-                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL);
+                .distinctValues(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL)
+                .findAllAsync();
         final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class)
-                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_LONG);
+                .distinctValues(AnnotationIndexTypes.FIELD_NOT_INDEX_LONG)
+                .findAllAsync();
         final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class)
-                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_DATE);
+                .distinctValues(AnnotationIndexTypes.FIELD_NOT_INDEX_DATE)
+                .findAllAsync();
         final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class)
-                .distinctAsync(AnnotationIndexTypes.FIELD_INDEX_STRING);
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_STRING)
+                .findAllAsync();
 
         assertFalse(distinctBool.isLoaded());
         assertTrue(distinctBool.isValid());
@@ -1067,7 +1072,7 @@ public void distinctAsync_noneExistingField() throws Throwable {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         try {
-            realm.where(AnnotationIndexTypes.class).distinctAsync("doesNotExist");
+            realm.where(AnnotationIndexTypes.class).distinctValues("doesNotExist").findAllAsync();
             fail();
         } catch (IllegalArgumentException ignored) {
             looperThread.testComplete();
@@ -1094,10 +1099,10 @@ public void batchUpdateDifferentTypeOfQueries() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmResults<AllTypes> findAllAsync = realm.where(AllTypes.class).findAllAsync();
-        RealmResults<AllTypes> findAllSorted = realm.where(AllTypes.class).findAllSortedAsync("columnString", Sort.ASCENDING);
-        RealmResults<AllTypes> findAllSortedMulti = realm.where(AllTypes.class).findAllSortedAsync(new String[]{"columnString", "columnLong"},
-                new Sort[]{Sort.ASCENDING, Sort.DESCENDING});
-        RealmResults<AnnotationIndexTypes> findDistinct = realm.where(AnnotationIndexTypes.class).distinctAsync("indexString");
+        RealmResults<AllTypes> findAllSorted = realm.where(AllTypes.class).sort("columnString", Sort.ASCENDING).findAllAsync();
+        RealmResults<AllTypes> findAllSortedMulti = realm.where(AllTypes.class).sort(new String[]{"columnString", "columnLong"},
+                new Sort[]{Sort.ASCENDING, Sort.DESCENDING}).findAllAsync();
+        RealmResults<AnnotationIndexTypes> findDistinct = realm.where(AnnotationIndexTypes.class).distinctValues("indexString").findAllAsync();
 
         looperThread.keepStrongReference(findAllAsync);
         looperThread.keepStrongReference(findAllSorted);
@@ -1264,7 +1269,7 @@ public void badVersion_syncTransaction() throws NoSuchFieldException, IllegalAcc
         Realm realm = looperThread.getRealm();
 
         // 1. Makes sure that async query is not started.
-        final RealmResults<AllTypes> result = realm.where(AllTypes.class).findAllSortedAsync(AllTypes.FIELD_STRING);
+        final RealmResults<AllTypes> result = realm.where(AllTypes.class).sort(AllTypes.FIELD_STRING).findAllAsync();
         looperThread.keepStrongReference(result);
         result.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
index 91e0d6945b..2c56308eca 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -777,7 +777,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         assertNotNull(objectSchema);
         assertEquals(PrimaryKeyAsString.FIELD_PRIMARY_KEY, objectSchema.getPrimaryKey());
         RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class)
-                .findAllSorted(PrimaryKeyAsString.FIELD_ID);
+                .sort(PrimaryKeyAsString.FIELD_ID)
+                .findAll();
         assertEquals(2, results.size());
         assertEquals("string0", results.get(0).getName());
         assertEquals("string1", results.get(1).getName());
@@ -822,7 +823,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         assertNotNull(objectSchema);
         assertEquals(PrimaryKeyAsInteger.FIELD_ID, objectSchema.getPrimaryKey());
         RealmResults<PrimaryKeyAsInteger> results = realm.where(PrimaryKeyAsInteger.class)
-                .findAllSorted(PrimaryKeyAsInteger.FIELD_ID);
+                .sort(PrimaryKeyAsInteger.FIELD_ID)
+                .findAll();
         assertEquals(2, results.size());
         assertEquals(0, results.get(0).getId());
         assertEquals(1, results.get(1).getId());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
index 1bf59fdf2a..cbaae6111e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
@@ -125,7 +125,10 @@ public void copyToRealm() {
     public void copyFromRealm() {
         populateTestRealm(realm, TEST_DATA_SIZE);
 
-        AllTypesRealmModel realmObject = realm.where(AllTypesRealmModel.class).findAllSorted(AllTypesRealmModel.FIELD_LONG).first();
+        AllTypesRealmModel realmObject = realm.where(AllTypesRealmModel.class)
+                .sort(AllTypesRealmModel.FIELD_LONG)
+                .findAll()
+                .first();
         AllTypesRealmModel unmanagedObject = realm.copyFromRealm(realmObject);
         assertArrayEquals(realmObject.columnBinary, unmanagedObject.columnBinary);
         assertEquals(realmObject.columnString, unmanagedObject.columnString);
@@ -198,7 +201,7 @@ public void async_query() {
         Realm realm = looperThread.getRealm();
         populateTestRealm(realm, TEST_DATA_SIZE);
 
-        final RealmResults<AllTypesRealmModel> allTypesRealmModels = realm.where(AllTypesRealmModel.class).distinctAsync(AllTypesRealmModel.FIELD_STRING);
+        final RealmResults<AllTypesRealmModel> allTypesRealmModels = realm.where(AllTypesRealmModel.class).distinctValues(AllTypesRealmModel.FIELD_STRING).findAllAsync();
         looperThread.keepStrongReference(allTypesRealmModels);
         allTypesRealmModels.addChangeListener(new RealmChangeListener<RealmResults<AllTypesRealmModel>>() {
             @Override
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index 6615bffa9b..039e411a32 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -919,7 +919,7 @@ private void setRequired_onPrimaryKeyField(boolean isRequired) {
             assertTrue(schema.hasPrimaryKey());
             assertTrue(schema.hasIndex(fieldName));
 
-            RealmResults<DynamicRealmObject> results = ((DynamicRealm)realm).where(className).findAllSorted(fieldName);
+            RealmResults<DynamicRealmObject> results = ((DynamicRealm)realm).where(className).sort(fieldName).findAll();
             assertEquals(2, results.size());
             if (fieldType == PrimaryKeyFieldType.STRING) {
                 assertEquals("1", results.get(0).getString(fieldName));
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index 667336ce69..8d99101714 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -2080,23 +2080,20 @@ public void getRealm_illegalThreadThrows() throws Throwable {
         realm.commitTransaction();
 
         final CountDownLatch threadFinished = new CountDownLatch(1);
-        final AtomicReference<Throwable> throwable = new AtomicReference<>();
         final Thread thread = new Thread(new Runnable() {
             @Override
             public void run() {
                 try {
                     object.getRealm();
                     fail();
-                } catch (Throwable t) {
-                    throwable.set(t);
-                    threadFinished.countDown();
-                    return;
+                } catch (IllegalStateException e) {
+                    assertEquals(BaseRealm.INCORRECT_THREAD_MESSAGE, e.getMessage());
                 }
                 try {
                     RealmObject.getRealm(object);
                     fail();
-                } catch (Throwable t) {
-                    throwable.set(t);
+                } catch (IllegalStateException e) {
+                    assertEquals(BaseRealm.INCORRECT_THREAD_MESSAGE, e.getMessage());
                 } finally {
                     threadFinished.countDown();
                 }
@@ -2104,12 +2101,6 @@ public void run() {
         });
         thread.start();
         TestHelper.awaitOrFail(threadFinished);
-
-        final Throwable thrownInTheThread = throwable.get();
-        if (!(thrownInTheThread instanceof IllegalStateException)) {
-            throw thrownInTheThread;
-        }
-        assertEquals(BaseRealm.INCORRECT_THREAD_MESSAGE, thrownInTheThread.getMessage());
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index ece9fabd6c..50467274cb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -209,7 +209,6 @@ private void populateNoPrimaryKeyNullTypesRows() {
         IS_VALID,
         DISTINCT,
         DISTINCT_BY_MULTIPLE_FIELDS,
-        DISTINCT_ASYNC,
 
         SUM,
         AVERAGE,
@@ -221,14 +220,9 @@ private void populateNoPrimaryKeyNullTypesRows() {
 
         FIND_ALL,
         FIND_ALL_ASYNC,
-        FIND_ALL_SORTED,
-        FIND_ALL_SORTED_ASYNC,
-        FIND_ALL_SORTED_WITH_ORDER,
-        FIND_ALL_SORTED_ASYNC_WITH_ORDER,
-        FIND_ALL_SORTED_WITH_TWO_ORDERS,
-        FIND_ALL_SORTED_ASYNC_WITH_TWO_ORDERS,
-        FIND_ALL_SORTED_WITH_MANY_ORDERS,
-        FIND_ALL_SORTED_ASYNC_WITH_MANY_ORDERS,
+        SORT,
+        SORT_WITH_ORDER,
+        SORT_WITH_MANY_ORDERS,
 
         FIND_FIRST,
         FIND_FIRST_ASYNC,
@@ -324,9 +318,8 @@ private static void callThreadConfinedMethod(RealmQuery<?> query, ThreadConfined
             case IS_NOT_EMPTY: query.isNotEmpty( AllJavaTypes.FIELD_STRING); break;
 
             case IS_VALID: query.isValid(); break;
-            case DISTINCT: query.distinct(                    AllJavaTypes.FIELD_STRING); break;
-            case DISTINCT_BY_MULTIPLE_FIELDS: query.distinct( AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID); break;
-            case DISTINCT_ASYNC: query.distinctAsync(         AllJavaTypes.FIELD_STRING); break;
+            case DISTINCT: query.distinctValues(                    AllJavaTypes.FIELD_STRING); break;
+            case DISTINCT_BY_MULTIPLE_FIELDS: query.distinctValues( AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID); break;
 
             case SUM: query.sum(                  AllJavaTypes.FIELD_INT); break;
             case AVERAGE: query.average(          AllJavaTypes.FIELD_INT); break;
@@ -338,15 +331,9 @@ private static void callThreadConfinedMethod(RealmQuery<?> query, ThreadConfined
 
             case FIND_ALL: query.findAll(); break;
             case FIND_ALL_ASYNC: query.findAllAsync(); break;
-            case FIND_ALL_SORTED: query.findAllSorted(                             AllJavaTypes.FIELD_STRING); break;
-            case FIND_ALL_SORTED_ASYNC: query.findAllSortedAsync(                  AllJavaTypes.FIELD_STRING); break;
-            case FIND_ALL_SORTED_WITH_ORDER: query.findAllSorted(                  AllJavaTypes.FIELD_STRING, Sort.DESCENDING); break;
-            case FIND_ALL_SORTED_ASYNC_WITH_ORDER: query.findAllSortedAsync(       AllJavaTypes.FIELD_STRING, Sort.DESCENDING); break;
-            case FIND_ALL_SORTED_WITH_TWO_ORDERS: query.findAllSorted(             AllJavaTypes.FIELD_STRING, Sort.DESCENDING, AllJavaTypes.FIELD_ID, Sort.DESCENDING); break;
-            case FIND_ALL_SORTED_ASYNC_WITH_TWO_ORDERS: query.findAllSortedAsync(  AllJavaTypes.FIELD_STRING, Sort.DESCENDING, AllJavaTypes.FIELD_ID, Sort.DESCENDING); break;
-            case FIND_ALL_SORTED_WITH_MANY_ORDERS: query.findAllSorted(            new String[] {AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID}, new Sort[] {Sort.DESCENDING, Sort.DESCENDING}); break;
-            case FIND_ALL_SORTED_ASYNC_WITH_MANY_ORDERS: query.findAllSortedAsync( new String[] {AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID}, new Sort[] {Sort.DESCENDING, Sort.DESCENDING}); break;
-
+            case SORT: query.sort(AllJavaTypes.FIELD_STRING); break;
+            case SORT_WITH_ORDER: query.sort(AllJavaTypes.FIELD_STRING, Sort.ASCENDING); break;
+            case SORT_WITH_MANY_ORDERS: query.sort(new String[] {AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID}, new Sort[] {Sort.DESCENDING, Sort.DESCENDING}); break;
             case FIND_FIRST: query.findFirst(); break;
             case FIND_FIRST_ASYNC: query.findFirstAsync(); break;
 
@@ -359,7 +346,6 @@ private static void callThreadConfinedMethod(RealmQuery<?> query, ThreadConfined
     public void callThreadConfinedMethodsFromWrongThread() throws Throwable {
         final RealmQuery<AllJavaTypes> query = realm.where(AllJavaTypes.class);
 
-        final AtomicReference<Throwable> throwableFromThread = new AtomicReference<Throwable>();
         final CountDownLatch testFinished = new CountDownLatch(1);
 
         final String expectedMessage;
@@ -382,13 +368,8 @@ public void run() {
                         try {
                             callThreadConfinedMethod(query, method);
                             fail("IllegalStateException must be thrown.");
-                        } catch (Throwable e) {
-                            if (e instanceof IllegalStateException && expectedMessage.equals(e.getMessage())) {
-                                // expected exception
-                                continue;
-                            }
-                            throwableFromThread.set(e);
-                            return;
+                        } catch (IllegalStateException e) {
+                            assertEquals(expectedMessage, e.getMessage());
                         }
                     }
                 } finally {
@@ -399,10 +380,6 @@ public void run() {
         thread.start();
 
         TestHelper.awaitOrFail(testFinished);
-        final Throwable throwable = throwableFromThread.get();
-        if (throwable != null) {
-            throw throwable;
-        }
     }
 
     @Test
@@ -1276,36 +1253,42 @@ public void queryLink() {
         // Dog.weight has index 4 which is more than the total number of columns in Owner
         // This tests exposes a subtle error where the Owner table spec is used instead of Dog table spec.
         RealmResults<Dog> dogs = realm.where(Owner.class).findFirst().getDogs().where()
-                .findAllSorted("name", Sort.ASCENDING);
+                .sort("name", Sort.ASCENDING)
+                .findAll();
         Dog dog = dogs.where().equalTo("weight", 1d).findFirst();
         assertEquals(dog1, dog);
     }
 
     @Test
-    public void findAllSorted_multiFailures() {
+    public void sort_multiFailures() {
         // Zero fields specified.
         try {
-            realm.where(AllTypes.class).findAllSorted(new String[]{}, new Sort[]{});
+            realm.where(AllTypes.class).sort(new String[]{}, new Sort[]{}).findAll();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         // Number of fields and sorting orders don't match.
         try {
-            realm.where(AllTypes.class).findAllSorted(new String[]{AllTypes.FIELD_STRING},
-                    new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
+            realm.where(AllTypes.class)
+                    .sort(new String[]{AllTypes.FIELD_STRING},new Sort[]{Sort.ASCENDING, Sort.ASCENDING})
+                    .findAll();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         // Null is not allowed.
         try {
-            realm.where(AllTypes.class).findAllSorted((String[]) null, null);
+            realm.where(AllTypes.class)
+                    .sort((String[]) null, null)
+                    .findAll();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
         try {
-            realm.where(AllTypes.class).findAllSorted(new String[]{AllTypes.FIELD_STRING}, null);
+            realm.where(AllTypes.class)
+                    .sort(new String[]{AllTypes.FIELD_STRING}, null)
+                    .findAll();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -1313,15 +1296,24 @@ public void findAllSorted_multiFailures() {
         // Non-existing field name.
         try {
             realm.where(AllTypes.class)
-                    .findAllSorted(new String[]{AllTypes.FIELD_STRING, "do-not-exist"},
-                            new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
+                    .sort(new String[]{AllTypes.FIELD_STRING, "do-not-exist"}, new Sort[]{Sort.ASCENDING, Sort.ASCENDING})
+                    .findAll();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
+
+        // Defining sort multiple times
+        try {
+            realm.where(AllTypes.class)
+                    .sort(AllTypes.FIELD_STRING)
+                    .sort(AllTypes.FIELD_STRING);
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
     }
 
     @Test
-    public void findAllSorted_singleField() {
+    public void sort_singleField() {
         realm.beginTransaction();
         for (int i = 0; i < TEST_DATA_SIZE; i++) {
             AllTypes allTypes = realm.createObject(AllTypes.class);
@@ -1330,7 +1322,8 @@ public void findAllSorted_singleField() {
         realm.commitTransaction();
 
         RealmResults<AllTypes> sortedList = realm.where(AllTypes.class)
-                .findAllSorted(new String[]{AllTypes.FIELD_LONG}, new Sort[]{Sort.DESCENDING});
+                .sort(new String[]{AllTypes.FIELD_LONG}, new Sort[]{Sort.DESCENDING})
+                .findAll();
         assertEquals(TEST_DATA_SIZE, sortedList.size());
         assertEquals(TEST_DATA_SIZE - 1, sortedList.first().getColumnLong());
         assertEquals(0, sortedList.last().getColumnLong());
@@ -2893,21 +2886,23 @@ public void execute(Realm realm) {
     }
 
     @Test
-    public void findAllSorted_onSubObjectField() {
+    public void sort_onSubObjectField() {
         populateTestRealm(realm, TEST_DATA_SIZE);
         RealmResults<AllTypes> results = realm.where(AllTypes.class)
-                .findAllSorted(AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE);
+                .sort(AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE)
+                .findAll();
         assertEquals(0, results.get(0).getColumnRealmObject().getAge());
         assertEquals(TEST_DATA_SIZE - 1, results.get(TEST_DATA_SIZE - 1).getColumnRealmObject().getAge());
     }
 
     @Test
     @RunTestInLooperThread
-    public void findAllSortedAsync_onSubObjectField() {
+    public void sort_async_onSubObjectField() {
         Realm realm = looperThread.getRealm();
         populateTestRealm(realm, TEST_DATA_SIZE);
         RealmResults<AllTypes> results = realm.where(AllTypes.class)
-                .findAllSortedAsync(AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE);
+                .sort(AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE)
+                .findAllAsync();
         looperThread.keepStrongReference(results);
         results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
@@ -2934,7 +2929,7 @@ public void findAll_indexedCaseInsensitiveFields() {
     }
 
     @Test
-    public void findAllSorted_listOnSubObjectField() {
+    public void sort_listOnSubObjectField() {
         String[] fieldNames = new String[2];
         fieldNames[0] = AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE;
         fieldNames[1] = AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE;
@@ -2945,37 +2940,12 @@ public void findAllSorted_listOnSubObjectField() {
 
         populateTestRealm(realm, TEST_DATA_SIZE);
         RealmResults<AllTypes> results = realm.where(AllTypes.class)
-                .findAllSorted(fieldNames, sorts);
+                .sort(fieldNames, sorts)
+                .findAll();
         assertEquals(0, results.get(0).getColumnRealmObject().getAge());
         assertEquals(TEST_DATA_SIZE - 1, results.get(TEST_DATA_SIZE - 1).getColumnRealmObject().getAge());
     }
 
-    @Test
-    @RunTestInLooperThread
-    public void findAllSortedAsync_listOnSubObjectField() {
-        Realm realm = looperThread.getRealm();
-        String[] fieldNames = new String[2];
-        fieldNames[0] = AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE;
-        fieldNames[1] = AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE;
-
-        Sort[] sorts = new Sort[2];
-        sorts[0] = Sort.ASCENDING;
-        sorts[1] = Sort.ASCENDING;
-
-        populateTestRealm(realm, TEST_DATA_SIZE);
-        RealmResults<AllTypes> results = realm.where(AllTypes.class)
-                .findAllSortedAsync(fieldNames, sorts);
-        looperThread.keepStrongReference(results);
-        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
-            @Override
-            public void onChange(RealmResults<AllTypes> results) {
-                assertEquals(0, results.get(0).getColumnRealmObject().getAge());
-                assertEquals(TEST_DATA_SIZE - 1, results.get(TEST_DATA_SIZE - 1).getColumnRealmObject().getAge());
-                looperThread.testComplete();
-            }
-        });
-    }
-
     // RealmQuery.distinct(): requires indexing, and type = boolean, integer, date, string.
     private void populateForDistinct(Realm realm, long numberOfBlocks, long numberOfObjects, boolean withNull) {
         realm.beginTransaction();
@@ -3012,10 +2982,10 @@ public void distinct() {
         final long numberOfObjects = 3; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL);
+        RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL).findAll();
         assertEquals(2, distinctBool.size());
         for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
-            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinct(field);
+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinctValues(field).findAll();
             assertEquals(field, numberOfBlocks, distinct.size());
         }
     }
@@ -3027,11 +2997,18 @@ public void distinct_withNullValues() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
-            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinct(field);
+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinctValues(field).findAll();
             assertEquals(field, 1, distinct.size());
         }
     }
 
+    @Test(expected = IllegalStateException.class)
+    public void distinct_failIfAppliedMultipleTimes() {
+        realm.where(AnnotationIndexTypes.class)
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_DATE)
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_DATE);
+    }
+
     @Test
     public void distinct_notIndexedFields() {
         final long numberOfBlocks = 3;
@@ -3039,11 +3016,12 @@ public void distinct_notIndexedFields() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class)
-                .distinct(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL);
+                .distinctValues(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL)
+                .findAll();
         assertEquals(2, distinctBool.size());
         for (String field : new String[]{AnnotationIndexTypes.FIELD_NOT_INDEX_LONG,
                 AnnotationIndexTypes.FIELD_NOT_INDEX_DATE, AnnotationIndexTypes.FIELD_NOT_INDEX_STRING}) {
-            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinct(field);
+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinctValues(field).findAll();
             assertEquals(field, numberOfBlocks, distinct.size());
         }
     }
@@ -3055,7 +3033,8 @@ public void distinct_doesNotExist() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         try {
-            realm.where(AnnotationIndexTypes.class).distinct("doesNotExist");
+            realm.where(AnnotationIndexTypes.class).distinctValues("doesNotExist").findAll();
+            fail();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3066,7 +3045,7 @@ public void distinct_invalidTypes() {
 
         for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
             try {
-                realm.where(AllTypes.class).distinct(field);
+                realm.where(AllTypes.class).distinctValues(field).findAll();
                 fail(field);
             } catch (IllegalArgumentException ignored) {
             }
@@ -3081,7 +3060,9 @@ public void distinct_indexedLinkedFields() {
 
         for (String field : AnnotationIndexTypes.INDEX_FIELDS) {
             try {
-                realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_OBJECT + "." + field);
+                realm.where(AnnotationIndexTypes.class)
+                        .distinctValues(AnnotationIndexTypes.FIELD_OBJECT + "." + field)
+                        .findAll();
                 fail("Unsupported Index" + field + " linked field");
             } catch (IllegalArgumentException ignored) {
             }
@@ -3096,7 +3077,9 @@ public void distinct_notIndexedLinkedFields() {
 
         for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
             try {
-                realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_OBJECT + "." + field);
+                realm.where(AnnotationIndexTypes.class)
+                        .distinctValues(AnnotationIndexTypes.FIELD_OBJECT + "." + field)
+                        .findAll();
                 fail("Unsupported notIndex" + field + " linked field");
             } catch (IllegalArgumentException ignored) {
             }
@@ -3108,24 +3091,26 @@ public void distinct_invalidTypesLinkedFields() {
         populateForDistinctInvalidTypesLinked(realm);
 
         try {
-            realm.where(AllJavaTypes.class).distinct(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY);
+            realm.where(AllJavaTypes.class)
+                    .distinctValues(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY)
+                    .findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
 
     @Test
     @RunTestInLooperThread
-    public void distinctAsync() throws Throwable {
+    public void distinct_async() throws Throwable {
         final AtomicInteger changeListenerCalled = new AtomicInteger(4);
         final Realm realm = looperThread.getRealm();
         final long numberOfBlocks = 3;
         final long numberOfObjects = 3; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_BOOL);
-        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_LONG);
-        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_DATE);
-        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_STRING);
+        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL).findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_LONG).findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_DATE).findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_STRING).findAllAsync();
 
         assertFalse(distinctBool.isLoaded());
         assertTrue(distinctBool.isValid());
@@ -3191,7 +3176,7 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
 
     @Test
     @RunTestInLooperThread
-    public void distinctAsync_withNullValues() throws Throwable {
+    public void distinct_async_withNullValues() throws Throwable {
         final AtomicInteger changeListenerCalled = new AtomicInteger(2);
         final Realm realm = looperThread.getRealm();
         final long numberOfBlocks = 3;
@@ -3199,9 +3184,11 @@ public void distinctAsync_withNullValues() throws Throwable {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class)
-                .distinctAsync(AnnotationIndexTypes.FIELD_INDEX_DATE);
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_DATE)
+                .findAllAsync();
         final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class)
-                .distinctAsync(AnnotationIndexTypes.FIELD_INDEX_STRING);
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_STRING)
+                .findAllAsync();
 
         final Runnable endTest = new Runnable() {
             @Override
@@ -3234,13 +3221,13 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
 
     @Test
     @RunTestInLooperThread
-    public void distinctAsync_doesNotExist() {
+    public void distinct_async_doesNotExist() {
         final long numberOfBlocks = 3;
         final long numberOfObjects = 3;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         try {
-            realm.where(AnnotationIndexTypes.class).distinctAsync("doesNotExist");
+            realm.where(AnnotationIndexTypes.class).distinctValues("doesNotExist").findAllAsync();
         } catch (IllegalArgumentException ignored) {
         }
         looperThread.testComplete();
@@ -3248,12 +3235,12 @@ public void distinctAsync_doesNotExist() {
 
     @Test
     @RunTestInLooperThread
-    public void distinctAsync_invalidTypes() {
+    public void distinct_async_invalidTypes() {
         populateTestRealm(realm, TEST_DATA_SIZE);
 
         for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
             try {
-                realm.where(AllTypes.class).distinctAsync(field);
+                realm.where(AllTypes.class).distinctValues(field).findAllAsync();
             } catch (IllegalArgumentException ignored) {
             }
         }
@@ -3262,14 +3249,14 @@ public void distinctAsync_invalidTypes() {
 
     @Test
     @RunTestInLooperThread
-    public void distinctAsync_indexedLinkedFields() {
+    public void distinct_async_indexedLinkedFields() {
         final long numberOfBlocks = 3;
         final long numberOfObjects = 3;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         for (String field : AnnotationIndexTypes.INDEX_FIELDS) {
             try {
-                realm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_OBJECT + "." + field);
+                realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_OBJECT + "." + field).findAllAsync();
                 fail("Unsupported " + field + " linked field");
             } catch (IllegalArgumentException ignored) {
             }
@@ -3279,11 +3266,11 @@ public void distinctAsync_indexedLinkedFields() {
 
     @Test
     @RunTestInLooperThread
-    public void distinctAsync_notIndexedLinkedFields() {
+    public void distinct_async_notIndexedLinkedFields() {
         populateForDistinctInvalidTypesLinked(realm);
 
         try {
-            realm.where(AllJavaTypes.class).distinctAsync(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY);
+            realm.where(AllJavaTypes.class).distinctValues(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY).findAllAsync();
         } catch (IllegalArgumentException ignored) {
         }
         looperThread.testComplete();
@@ -3296,7 +3283,7 @@ public void distinctMultiArgs() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
-        RealmResults<AnnotationIndexTypes> distinctMulti = query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.INDEX_FIELDS);
+        RealmResults<AnnotationIndexTypes> distinctMulti = query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.INDEX_FIELDS).findAll();
         assertEquals(numberOfBlocks, distinctMulti.size());
     }
 
@@ -3306,9 +3293,8 @@ public void distinctMultiArgs_switchedFieldsOrder() {
         TestHelper.populateForDistinctFieldsOrder(realm, numberOfBlocks);
 
         // Regardless of the block size defined above, the output size is expected to be the same, 4 in this case, due to receiving unique combinations of tuples.
-        RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
-        RealmResults<AnnotationIndexTypes> distinctStringLong = query.distinct(AnnotationIndexTypes.FIELD_INDEX_STRING, AnnotationIndexTypes.FIELD_INDEX_LONG);
-        RealmResults<AnnotationIndexTypes> distinctLongString = query.distinct(AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_STRING);
+        RealmResults<AnnotationIndexTypes> distinctStringLong = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_STRING, AnnotationIndexTypes.FIELD_INDEX_LONG).findAll();
+        RealmResults<AnnotationIndexTypes> distinctLongString = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_STRING).findAll();
         assertEquals(4, distinctStringLong.size());
         assertEquals(4, distinctLongString.size());
         assertEquals(distinctStringLong.size(), distinctLongString.size());
@@ -3323,47 +3309,47 @@ public void distinctMultiArgs_emptyField() {
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
         // An empty string field in the middle.
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, "", AnnotationIndexTypes.FIELD_INDEX_INT);
+            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, "", AnnotationIndexTypes.FIELD_INDEX_INT).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // An empty string field at the end.
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, "");
+            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, "").findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // A null string field in the middle.
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null, AnnotationIndexTypes.FIELD_INDEX_INT);
+            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null, AnnotationIndexTypes.FIELD_INDEX_INT).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // A null string field at the end.
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String) null);
+            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String) null).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // (String) Null makes varargs a null array.
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null);
+            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // Two (String) null for first and varargs fields.
         try {
-            query.distinct((String) null, (String) null);
+            query.distinctValues((String) null, (String) null).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // "" & (String) null combination.
         try {
-            query.distinct("", (String) null);
+            query.distinctValues("", (String) null).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // "" & (String) null combination.
         try {
-            query.distinct((String) null, "");
+            query.distinctValues((String) null, "").findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // Two empty fields tests.
         try {
-            query.distinct("", "");
+            query.distinctValues("", "").findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3375,7 +3361,7 @@ public void distinctMultiArgs_withNullValues() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
-        RealmResults<AnnotationIndexTypes> distinctMulti = query.distinct(AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING);
+        RealmResults<AnnotationIndexTypes> distinctMulti = query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING).findAll();
         assertEquals(1, distinctMulti.size());
     }
 
@@ -3387,7 +3373,7 @@ public void distinctMultiArgs_notIndexedFields() {
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_NOT_INDEX_STRING, AnnotationIndexTypes.NOT_INDEX_FIELDS);
+            query.distinctValues(AnnotationIndexTypes.FIELD_NOT_INDEX_STRING, AnnotationIndexTypes.NOT_INDEX_FIELDS).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3400,7 +3386,7 @@ public void distinctMultiArgs_doesNotExistField() {
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_INT, AnnotationIndexTypes.NONEXISTANT_MIX_FIELDS);
+            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT, AnnotationIndexTypes.NONEXISTANT_MIX_FIELDS).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3411,7 +3397,7 @@ public void distinctMultiArgs_invalidTypesFields() {
 
         RealmQuery<AllTypes> query = realm.where(AllTypes.class);
         try {
-            query.distinct(AllTypes.FIELD_REALMOBJECT, AllTypes.INVALID_TYPES_FIELDS_FOR_DISTINCT);
+            query.distinctValues(AllTypes.FIELD_REALMOBJECT, AllTypes.INVALID_TYPES_FIELDS_FOR_DISTINCT).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3424,7 +3410,7 @@ public void distinctMultiArgs_indexedLinkedFields() {
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
         try {
-            query.distinct(AnnotationIndexTypes.INDEX_LINKED_FIELD_STRING, AnnotationIndexTypes.INDEX_LINKED_FIELDS);
+            query.distinctValues(AnnotationIndexTypes.INDEX_LINKED_FIELD_STRING, AnnotationIndexTypes.INDEX_LINKED_FIELDS).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3437,7 +3423,7 @@ public void distinctMultiArgs_notIndexedLinkedFields() {
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
         try {
-            query.distinct(AnnotationIndexTypes.NOT_INDEX_LINKED_FILED_STRING, AnnotationIndexTypes.NOT_INDEX_LINKED_FIELDS);
+            query.distinctValues(AnnotationIndexTypes.NOT_INDEX_LINKED_FILED_STRING, AnnotationIndexTypes.NOT_INDEX_LINKED_FIELDS).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3448,7 +3434,7 @@ public void distinctMultiArgs_invalidTypesLinkedFields() {
 
         RealmQuery<AllJavaTypes> query = realm.where(AllJavaTypes.class);
         try {
-            query.distinct(AllJavaTypes.INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT, AllJavaTypes.INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT);
+            query.distinctValues(AllJavaTypes.INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT, AllJavaTypes.INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index 8ab8c830a9..6a7e1cdbf3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -73,7 +73,9 @@ public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfiguration();
         realm = Realm.getInstance(realmConfig);
         populateTestRealm();
-        collection = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_LONG, Sort.ASCENDING);
+        collection = realm.where(AllTypes.class)
+                .sort(AllTypes.FIELD_LONG, Sort.ASCENDING)
+                .findAll();
     }
 
     @After
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
index 7c12ddba71..73db5a1f65 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
@@ -628,24 +628,28 @@ public void mutableMethodsCalled_notInTransaction() {
 
         try {
             realmSchema.create("Foo");
+            fail();
         } catch (IllegalStateException expected) {
             assertThat(expected.getMessage(), CoreMatchers.containsString("transaction"));
         }
 
         try {
             realmSchema.createWithPrimaryKeyField("Foo", "PK", String.class);
+            fail();
         } catch (IllegalStateException expected) {
             assertThat(expected.getMessage(), CoreMatchers.containsString("transaction"));
         }
 
         try {
             realmSchema.remove("Cat");
+            fail();
         } catch (IllegalStateException expected) {
             assertThat(expected.getMessage(), CoreMatchers.containsString("transaction"));
         }
 
         try {
             realmSchema.rename("Cat", "Foo1");
+            fail();
         } catch (IllegalStateException expected) {
             assertThat(expected.getMessage(), CoreMatchers.containsString("transaction"));
         }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 7d872718ba..f1490c163c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -110,7 +110,6 @@
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
-import io.realm.util.ExceptionHolder;
 import io.realm.util.RealmThread;
 
 import static io.realm.TestHelper.testNoObjectFound;
@@ -3299,7 +3298,7 @@ public void copyFromRealm_invalidDepthThrows() {
     @Test
     public void copyFromRealm() {
         populateTestRealm();
-        AllTypes realmObject = realm.where(AllTypes.class).findAllSorted("columnLong").first();
+        AllTypes realmObject = realm.where(AllTypes.class).sort("columnLong").findAll().first();
         AllTypes unmanagedObject = realm.copyFromRealm(realmObject);
         assertArrayEquals(realmObject.getColumnBinary(), unmanagedObject.getColumnBinary());
         assertEquals(realmObject.getColumnString(), unmanagedObject.getColumnString());
@@ -3313,7 +3312,7 @@ public void copyFromRealm() {
     @Test
     public void copyFromRealm_newCopyEachTime() {
         populateTestRealm();
-        AllTypes realmObject = realm.where(AllTypes.class).findAllSorted("columnLong").first();
+        AllTypes realmObject = realm.where(AllTypes.class).sort("columnLong").findAll().first();
         AllTypes unmanagedObject1 = realm.copyFromRealm(realmObject);
         AllTypes unmanagedObject2 = realm.copyFromRealm(realmObject);
         assertFalse(unmanagedObject1 == unmanagedObject2);
@@ -4017,7 +4016,6 @@ public void run() {
     @Test
     public void waitForChange_onLooperThread() throws Throwable {
         final CountDownLatch bgRealmClosed = new CountDownLatch(1);
-        final ExceptionHolder bgError = new ExceptionHolder();
 
         Thread thread = new Thread(new Runnable() {
             @Override
@@ -4027,8 +4025,7 @@ public void run() {
                 try {
                     realm.waitForChange();
                     fail();
-                } catch (Throwable expected) {
-                    bgError.setException(expected);
+                } catch (IllegalStateException ignored) {
                 } finally {
                     realm.close();
                     bgRealmClosed.countDown();
@@ -4038,10 +4035,6 @@ public void run() {
         thread.start();
 
         TestHelper.awaitOrFail(bgRealmClosed);
-        if (bgError.getException() instanceof AssertionError) {
-            throw bgError.getException();
-        }
-        assertEquals(IllegalStateException.class, bgError.getException().getClass());
     }
 
     // Cannot wait inside of a transaction.
@@ -4473,4 +4466,28 @@ public void getInstance_wrongSchemaInReadonlyThrows() {
         } catch (RealmMigrationNeededException ignored) {
         }
     }
+
+    // https://github.com/realm/realm-java/issues/5570
+    @Test
+    public void getInstance_migrationExceptionThrows_migrationBlockDefiend_realmInstancesShouldBeClosed() {
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .name("readonly.realm")
+                .schema(StringOnlyReadOnly.class, AllJavaTypes.class)
+                .schemaVersion(2)
+                .assetFile("readonly.realm")
+                .migration(new RealmMigration() {
+                    @Override
+                    public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                    }
+                })
+                .build();
+
+        try {
+            realm = Realm.getInstance(config);
+            fail();
+        } catch (RealmMigrationNeededException ignored) {
+            // No Realm instance should be opened at this time.
+            Realm.deleteRealm(config);
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
index 287d17bf44..91d961276d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
@@ -31,6 +31,7 @@
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.AnnotationIndexTypes;
+import io.realm.entities.Dog;
 import io.realm.entities.StringOnly;
 import io.realm.internal.Table;
 import io.realm.internal.UncheckedRow;
@@ -72,18 +73,22 @@ private void populateRealm(Realm realm) {
         AllTypes object1 = realm.createObject(AllTypes.class);
         object1.setColumnLong(5);
         object1.setColumnString("Adam");
+        object1.setColumnRealmObject(realm.copyToRealm(new Dog("D")));
 
         AllTypes object2 = realm.createObject(AllTypes.class);
         object2.setColumnLong(4);
         object2.setColumnString("Brian");
+        object2.setColumnRealmObject(realm.copyToRealm(new Dog("C")));
 
         AllTypes object3 = realm.createObject(AllTypes.class);
         object3.setColumnLong(4);
         object3.setColumnString("Adam");
+        object3.setColumnRealmObject(realm.copyToRealm(new Dog("B")));
 
         AllTypes object4 = realm.createObject(AllTypes.class);
         object4.setColumnLong(5);
         object4.setColumnString("Adam");
+        object4.setColumnRealmObject(realm.copyToRealm(new Dog("A")));
 
         realm.delete(AnnotationIndexTypes.class);
         AnnotationIndexTypes obj1 = realm.createObject(AnnotationIndexTypes.class);
@@ -112,10 +117,10 @@ private UncheckedRow getRowBySourceIndexFromAllTypesTable(long sourceRowIndex) {
     @Before
     public void setUp() {
         // Creates a Realm with the following objects:
-        // 0: (5, "Adam")
-        // 1: (4, "Brian")
-        // 2: (4, "Adam")
-        // 3: (5, "Adam")
+        // 0: (5, "Adam", Dog("D"))
+        // 1: (4, "Brian", Dog("C"))
+        // 2: (4, "Adam", Dog("B"))
+        // 3: (5, "Adam", Dog("A"))
 
         // Injecting the Instrumentation instance is required
         // for your test to run with AndroidJUnitRunner.
@@ -472,7 +477,7 @@ public void sortingDates() {
 
         populateDates(realm, TEST_SIZE);
 
-        RealmResults<AllTypes> objectsAscending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.ASCENDING);
+        RealmResults<AllTypes> objectsAscending = realm.where(AllTypes.class).sort(AllTypes.FIELD_DATE, Sort.ASCENDING).findAll();
         assertEquals(TEST_SIZE, objectsAscending.size());
         int i = 0;
         for (AllTypes allTypes : objectsAscending) {
@@ -480,7 +485,7 @@ public void sortingDates() {
             i++;
         }
 
-        RealmResults<AllTypes> objectsDescending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.DESCENDING);
+        RealmResults<AllTypes> objectsDescending = realm.where(AllTypes.class).sort(AllTypes.FIELD_DATE, Sort.DESCENDING).findAll();
         assertEquals(TEST_SIZE, objectsDescending.size());
         i = TEST_SIZE - 1;
         for (AllTypes allTypes : objectsDescending) {
@@ -509,7 +514,7 @@ public void run() {
             }
         };
 
-        RealmResults<AllTypes> objectsAscending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.ASCENDING);
+        RealmResults<AllTypes> objectsAscending = realm.where(AllTypes.class).sort(AllTypes.FIELD_DATE, Sort.ASCENDING).findAll();
         assertEquals(TEST_SIZE, objectsAscending.size());
         looperThread.keepStrongReference(objectsAscending);
         objectsAscending.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
@@ -525,7 +530,7 @@ public void onChange(RealmResults<AllTypes> element) {
             }
         });
 
-        RealmResults<AllTypes> objectsDescending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.DESCENDING);
+        RealmResults<AllTypes> objectsDescending = realm.where(AllTypes.class).sort(AllTypes.FIELD_DATE, Sort.DESCENDING).findAll();
         assertEquals(TEST_SIZE, objectsDescending.size());
         looperThread.keepStrongReference(objectsDescending);
         objectsDescending.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
@@ -559,18 +564,70 @@ public void sortByLongDistinctByInt() {
         // (2, 1, "B")
         // (1, 1, "A)
         RealmResults<AnnotationIndexTypes> results1 = realm.where(AnnotationIndexTypes.class)
-                .findAllSorted(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.DESCENDING);
+                .sort(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.DESCENDING)
+                .findAll();
         assertEquals(3, results1.size());
         assertEquals(3, results1.get(0).getIndexLong());
 
         // After distinct:
         // (3, 1, "C")
-        RealmResults<AnnotationIndexTypes> results2 =  results1.where().distinct(AnnotationIndexTypes.FIELD_INDEX_INT);
+        RealmResults<AnnotationIndexTypes> results2 =  results1.where().distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT).findAll();
         assertEquals(1, results2.size());
         assertEquals("C", results2.get(0).getIndexString());
         assertEquals(3, results2.get(0).getIndexLong());
     }
 
+    @Test
+    public void sortAndDistinctMixed() {
+        // Dataset:
+        // (FIELD_INDEX_LONG, FIELD_INDEX_INT, FIELD_INDEX_STRING)
+        // (1, 1, "A")
+        // (2, 1, "B")
+        // (3, 1, "C")
+        // Depending on the sorting, distinct should pick the first element encountered.
+        // The order of sort/distinct in the query should not matter
+
+        // Case 1: Selecting highest numbers
+        RealmResults<AnnotationIndexTypes> results1a = realm.where(AnnotationIndexTypes.class)
+                .sort(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.DESCENDING)
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT)
+                .findAll();
+        assertEquals(1, results1a.size());
+        assertEquals(3, results1a.get(0).getIndexLong());
+
+        RealmResults<AnnotationIndexTypes> results1b = realm.where(AnnotationIndexTypes.class)
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT)
+                .sort(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.DESCENDING)
+                .findAll();
+        assertEquals(1, results1b.size());
+        assertEquals(3, results1b.get(0).getIndexLong());
+
+        // Case 1: Selecting lowest number numbers
+        RealmResults<AnnotationIndexTypes> results2a = realm.where(AnnotationIndexTypes.class)
+                .sort(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.ASCENDING)
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT)
+                .findAll();
+        assertEquals(1, results2a.size());
+        assertEquals(1, results2a.get(0).getIndexLong());
+
+        RealmResults<AnnotationIndexTypes> results2b = realm.where(AnnotationIndexTypes.class)
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT)
+                .sort(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.ASCENDING)
+                .findAll();
+        assertEquals(1, results2b.size());
+        assertEquals(1, results2b.get(0).getIndexLong());
+    }
+
+    @Test
+    public void sortByChildValue() {
+        RealmResults<AllTypes> result = realm.where(AllTypes.class)
+                .sort(AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_NAME, Sort.ASCENDING)
+                .findAll();
+
+        assertEquals("A", result.first().getColumnRealmObject().getName());
+        assertEquals("D", result.last().getColumnRealmObject().getName());
+    }
+
     private void createAndTest(String str) {
         realm.beginTransaction();
         realm.delete(StringOnly.class);
@@ -579,7 +636,7 @@ private void createAndTest(String str) {
             stringOnly.setChars(str.substring(i, i + 1));
         }
         realm.commitTransaction();
-        RealmResults<StringOnly> stringOnlies = realm.where(StringOnly.class).findAllSorted("chars");
+        RealmResults<StringOnly> stringOnlies = realm.where(StringOnly.class).sort("chars").findAll();
         for (int i = 0; i < chars.length(); i++) {
             assertEquals(chars.substring(i, i + 1), stringOnlies.get(i).getChars());
         }
@@ -619,7 +676,7 @@ private int factorial(int n) {
     @Test
     public void sortCaseSensitive() {
         chars = "'- !\"#$%&()*,./:;?_+<=>123aAbBcCxXyYzZ";
-        createAndTest(new StringBuffer(chars).reverse().toString());
+        createAndTest(new StringBuilder(chars).reverse().toString());
 
         // try all permutations - keep the list short
         chars = "12aAbB";
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/OsResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/OsResultsTests.java
index 48590baf9e..de67a7e5df 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/OsResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/OsResultsTests.java
@@ -152,7 +152,7 @@ private void addRow(OsSharedRealm sharedRealm) {
     @Test
     public void constructor_withDistinct() {
         SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(null, table, "firstName");
-        OsResults osResults = new OsResults(sharedRealm, table.where(), null, distinctDescriptor);
+        OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where(), null, distinctDescriptor);
 
         assertEquals(3, osResults.size());
         assertEquals("John", osResults.getUncheckedRow(0).getString(0));
@@ -164,7 +164,7 @@ public void constructor_withDistinct() {
     @Test(expected = UnsupportedOperationException.class)
     public void constructor_queryIsValidated() {
         // OsResults's constructor should call TableQuery.validateQuery()
-        new OsResults(sharedRealm, table.where().or());
+        OsResults.createFromQuery(sharedRealm, table.where().or());
     }
 
     @Test
@@ -175,20 +175,20 @@ public void constructor_queryOnDeletedTable() {
         sharedRealm.commitTransaction();
         // Query should be checked before creating OS Results.
         thrown.expect(IllegalStateException.class);
-        new OsResults(sharedRealm, query);
+        OsResults.createFromQuery(sharedRealm, query);
     }
 
     @Test
     public void size() {
-        OsResults osResults = new OsResults(sharedRealm, table.where());
+        OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         assertEquals(4, osResults.size());
     }
 
     @Test
     public void where() {
-        OsResults osResults = new OsResults(sharedRealm, table.where());
-        OsResults osResults2 = new OsResults(sharedRealm, osResults.where().equalTo(new long[] {0}, oneNullTable, "John"));
-        OsResults osResults3 = new OsResults(sharedRealm, osResults2.where().equalTo(new long[] {1}, oneNullTable, "Anderson"));
+        OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
+        OsResults osResults2 = OsResults.createFromQuery(sharedRealm, osResults.where().equalTo(new long[] {0}, oneNullTable, "John"));
+        OsResults osResults3 = OsResults.createFromQuery(sharedRealm, osResults2.where().equalTo(new long[] {1}, oneNullTable, "Anderson"));
 
         // A new native Results should be created.
         assertTrue(osResults.getNativePtr() != osResults2.getNativePtr());
@@ -201,7 +201,7 @@ public void where() {
 
     @Test
     public void sort() {
-        OsResults osResults = new OsResults(sharedRealm, table.where().greaterThan(new long[] {2}, oneNullTable, 1));
+        OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where().greaterThan(new long[] {2}, oneNullTable, 1));
         SortDescriptor sortDescriptor = SortDescriptor.getTestInstance(table, new long[] {2});
 
         OsResults osResults2 = osResults.sort(sortDescriptor);
@@ -218,7 +218,7 @@ public void sort() {
     @Test
     public void clear() {
         assertEquals(4, table.size());
-        OsResults osResults = new OsResults(sharedRealm, table.where());
+        OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         sharedRealm.beginTransaction();
         osResults.clear();
         sharedRealm.commitTransaction();
@@ -227,7 +227,7 @@ public void clear() {
 
     @Test
     public void contains() {
-        OsResults osResults = new OsResults(sharedRealm, table.where());
+        OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         UncheckedRow row = table.getUncheckedRow(0);
         assertTrue(osResults.contains(row));
     }
@@ -236,14 +236,14 @@ public void contains() {
     public void indexOf() {
         SortDescriptor sortDescriptor = SortDescriptor.getTestInstance(table, new long[] {2});
 
-        OsResults osResults = new OsResults(sharedRealm, table.where(), sortDescriptor);
+        OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where(), sortDescriptor, null);
         UncheckedRow row = table.getUncheckedRow(0);
         assertEquals(3, osResults.indexOf(row));
     }
 
     @Test
     public void distinct() {
-        OsResults osResults = new OsResults(sharedRealm, table.where().lessThan(new long[] {2}, oneNullTable, 4));
+        OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where().lessThan(new long[] {2}, oneNullTable, 4));
 
         SortDescriptor distinctDescriptor = SortDescriptor.getTestInstance(table, new long[] {2});
         OsResults osResults2 = osResults.distinct(distinctDescriptor);
@@ -266,7 +266,7 @@ public void addListener_shouldBeCalledToReturnTheQueryResults() {
         populateData(sharedRealm);
         Table table = getTable(sharedRealm);
 
-        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        final OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         looperThread.keepStrongReference(osResults);
         osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
             @Override
@@ -287,7 +287,7 @@ public void addListener_shouldBeCalledWhenRefreshToReturnTheQueryResults() {
         final OsSharedRealm sharedRealm = getSharedRealm();
         Table table = getTable(sharedRealm);
 
-        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        final OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
             @Override
             public void onChange(OsResults osResults1) {
@@ -304,7 +304,7 @@ public void onChange(OsResults osResults1) {
     @Test
     public void addListener_shouldBeCalledWhenRefreshAfterLocalCommit() {
         final CountDownLatch latch = new CountDownLatch(2);
-        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        final OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         assertEquals(4, osResults.size()); // See `populateData()`
         osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
             @Override
@@ -332,7 +332,7 @@ public void onChange(OsResults element) {
     @Test
     public void addListener_triggeredByRefresh() {
         final CountDownLatch latch = new CountDownLatch(1);
-        OsResults osResults = new OsResults(sharedRealm, table.where());
+        OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         osResults.size();
         osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
             @Override
@@ -356,7 +356,7 @@ public void addListener_queryNotReturned() {
         populateData(sharedRealm);
         Table table = getTable(sharedRealm);
 
-        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        final OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         looperThread.keepStrongReference(osResults);
         osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
             @Override
@@ -378,7 +378,7 @@ public void addListener_queryReturned() {
         populateData(sharedRealm);
         Table table = getTable(sharedRealm);
 
-        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        final OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         looperThread.keepStrongReference(osResults);
         assertEquals(4, osResults.size()); // Trigger the query to run.
         osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
@@ -404,7 +404,7 @@ public void addListener_triggeredByLocalCommit() {
         Table table = getTable(sharedRealm);
         final AtomicInteger listenerCounter = new AtomicInteger(0);
 
-        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        final OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         looperThread.keepStrongReference(osResults);
         osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
             @Override
@@ -451,7 +451,7 @@ boolean isDetached(OsSharedRealm sharedRealm) {
 
     @Test
     public void collectionIterator_detach_byBeginTransaction() {
-        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        final OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         TestIterator iterator = new TestIterator(osResults);
         assertFalse(iterator.isDetached(sharedRealm));
         sharedRealm.beginTransaction();
@@ -463,14 +463,14 @@ public void collectionIterator_detach_byBeginTransaction() {
     @Test
     public void collectionIterator_detach_createdInTransaction() {
         sharedRealm.beginTransaction();
-        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        final OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         TestIterator iterator = new TestIterator(osResults);
         assertTrue(iterator.isDetached(sharedRealm));
     }
 
     @Test
     public void collectionIterator_invalid_nonLooperThread_byRefresh() {
-        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        final OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         TestIterator iterator = new TestIterator(osResults);
         assertFalse(iterator.isDetached(sharedRealm));
         sharedRealm.refresh();
@@ -484,7 +484,7 @@ public void collectionIterator_invalid_looperThread_byRemoteTransaction() {
         final OsSharedRealm sharedRealm = getSharedRealmForLooper();
         populateData(sharedRealm);
         Table table = getTable(sharedRealm);
-        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        final OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         final TestIterator iterator = new TestIterator(osResults);
         looperThread.keepStrongReference(osResults);
         assertFalse(iterator.isDetached(sharedRealm));
@@ -506,7 +506,7 @@ public void onChange(OsResults element) {
 
     @Test
     public void collectionIterator_newInstance_throwsWhenSharedRealmIsClosed() {
-        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        final OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         sharedRealm.close();
         thrown.expect(IllegalStateException.class);
         new TestIterator(osResults);
@@ -514,7 +514,7 @@ public void collectionIterator_newInstance_throwsWhenSharedRealmIsClosed() {
 
     @Test
     public void getMode() {
-        OsResults osResults = new OsResults(sharedRealm, table.where());
+        OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         assertTrue(OsResults.Mode.QUERY == osResults.getMode());
         osResults.firstUncheckedRow(); // Run the query
         assertTrue(OsResults.Mode.TABLEVIEW == osResults.getMode());
@@ -522,7 +522,7 @@ public void getMode() {
 
     @Test
     public void createSnapshot() {
-        OsResults osResults = new OsResults(sharedRealm, table.where());
+        OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         OsResults snapshot = osResults.createSnapshot();
         assertTrue(OsResults.Mode.TABLEVIEW == snapshot.getMode());
         thrown.expect(IllegalStateException.class);
@@ -539,7 +539,7 @@ public void load() {
         final OsSharedRealm sharedRealm = getSharedRealmForLooper();
         looperThread.closeAfterTest(sharedRealm);
         populateData(sharedRealm);
-        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        final OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());
         osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
             @Override
             public void onChange(OsResults element) {
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java
index c0a5d4fffc..41e9115fb0 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java
@@ -86,6 +86,27 @@ public void google_invalidInput() {
         }
     }
 
+    @Test
+    public void jwt() {
+        SyncCredentials creds = SyncCredentials.jwt("foo");
+
+        assertEquals(SyncCredentials.IdentityProvider.JWT, creds.getIdentityProvider());
+        assertEquals("foo", creds.getUserIdentifier());
+        assertTrue(creds.getUserInfo().isEmpty());
+    }
+
+    @Test
+    public void jwt_invalidInput() {
+        String[] invalidInput = {null, ""};
+        for (String input : invalidInput) {
+            try {
+                SyncCredentials.jwt(input);
+                fail(input + " should have failed");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
     @Test
     public void usernamePassword_register() {
         SyncCredentials creds = SyncCredentials.usernamePassword("foo", "bar", true);
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
index 8a8eb0bcb3..1da13db3ce 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
@@ -155,10 +155,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetSchemaConfi
                                               reinterpret_cast<jlong>(new_shared_realm_ptr), config_global.get(), obj,
                                               old_realm->schema_version());
                 });
-                // Close the OsSharedRealm. Otherwise it will only be closed when the Java OsSharedRealm gets GCed. And
-                // that will be too late.
-                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(
-                    env, [&new_shared_realm_ptr]() { (*new_shared_realm_ptr)->close(); });
+                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env, nullptr);
             };
         }
         else {
@@ -230,10 +227,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetInitializat
                                               reinterpret_cast<jlong>(new_shared_realm_ptr), config_global_ref.get(),
                                               obj);
                 });
-                // Close the OsSharedRealm. Otherwise it will only be closed when the Java OsSharedRealm gets GCed. And
-                // that will be too late.
-                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(
-                    env, [&new_shared_realm_ptr]() { (*new_shared_realm_ptr)->close(); });
+                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env, nullptr);
             };
         }
         else {
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp
index 26f53313cc..560eb31f52 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp
@@ -52,9 +52,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeCreateResults(JNI
         }
 
         auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-
         DescriptorOrdering descriptor_ordering;
-        REALM_ASSERT_RELEASE(!(j_sort_desc && j_distinct_desc));
         if (j_sort_desc) {
             descriptor_ordering.append_sort(JavaSortDescriptor(env, j_sort_desc).sort_descriptor());
         }
@@ -70,27 +68,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeCreateResults(JNI
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeCreateResultsFromList(JNIEnv* env, jclass,
-                                                                                          jlong shared_realm_ptr,
-                                                                                          jlong list_ptr,
-                                                                                          jobject j_sort_desc)
-{
-    TR_ENTER()
-    try {
-        auto& list_wrapper = *reinterpret_cast<ObservableCollectionWrapper<List>*>(list_ptr);
-        auto& list = list_wrapper.collection();
-        auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-        Results results = j_sort_desc ?
-            list.sort(JavaSortDescriptor(env, j_sort_desc).sort_descriptor()) :
-            list.as_results();
-        auto wrapper = new ResultsWrapper(results);
-
-        return reinterpret_cast<jlong>(wrapper);
-    }
-    CATCH_STD()
-    return reinterpret_cast<jlong>(nullptr);
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeCreateSnapshot(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr);
@@ -421,3 +398,15 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeCreateResultsFrom
     CATCH_STD()
     return reinterpret_cast<jlong>(nullptr);
 }
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeEvaluateQueryIfNeeded(JNIEnv* env, jclass,
+                                                                                    jlong native_ptr,
+                                                                                    jboolean wants_notifications)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        wrapper->collection().evaluate_query_if_needed(wants_notifications);
+    }
+    CATCH_STD()
+}
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index e446a4c73c..2b7db38bd1 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit e446a4c73c52c70ac3d4eb801e0e0a286e21acbc
+Subproject commit 2b7db38bd112c82c55a0fa4bbecd24f652d45ba1
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedCollectionChangeSet.java b/realm/realm-library/src/main/java/io/realm/OrderedCollectionChangeSet.java
index a162848569..52ca14ee0c 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedCollectionChangeSet.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedCollectionChangeSet.java
@@ -16,6 +16,8 @@
 
 package io.realm;
 
+import java.util.Locale;
+
 /**
  * This interface describes the changes made to a collection during the last update.
  * <p>
@@ -95,5 +97,10 @@ public Range(int startIndex, int length) {
             this.startIndex = startIndex;
             this.length = length;
         }
+
+        @Override
+        public String toString() {
+            return String.format(Locale.ENGLISH, "startIndex: %d, length: %d", startIndex, length);
+        }
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index 1399b3e22f..3dac06e938 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -20,11 +20,11 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.ref.WeakReference;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.EnumMap;
 import java.util.Iterator;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.CountDownLatch;
@@ -200,7 +200,7 @@ public void run() {
     // are not allowed and an exception will be thrown when trying to add it to the cache list.
     // A weak ref is used to hold the RealmCache instance. The weak ref entry will be cleared if and only if there
     // is no Realm instance holding a strong ref to it and there is no Realm instance associated it is BEING created.
-    private static final List<WeakReference<RealmCache>> cachesList = new LinkedList<WeakReference<RealmCache>>();
+    private static final List<WeakReference<RealmCache>> cachesList = new ArrayList<WeakReference<RealmCache>>();
 
     // See leak()
     // isLeaked flag is used to avoid adding strong ref multiple times without iterating the list.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index 267d9aff0b..af87170e3c 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -63,7 +63,7 @@
 
     private static final String ONLY_IN_MANAGED_MODE_MESSAGE = "This method is only available in managed mode.";
     static final String ALLOWED_ONLY_FOR_REALM_MODEL_ELEMENT_MESSAGE = "This feature is available only when the element type is implementing RealmModel.";
-    public static final String REMOVE_OUTSIDE_TRANSACTION_ERROR = "Objects can only be removed from inside a write transaction.";
+    private static final String REMOVE_OUTSIDE_TRANSACTION_ERROR = "Objects can only be removed from inside a write transaction.";
 
     @Nullable
     protected Class<E> clazz;
@@ -71,11 +71,9 @@
     protected String className;
 
     // Always null if RealmList is unmanaged, always non-null if managed.
-    final ManagedListOperator<E> osListOperator;
+    private final ManagedListOperator<E> osListOperator;
     final protected BaseRealm realm;
     private List<E> unmanagedList;
-    // Used for listeners on RealmList<RealmModel>
-    private OsResults osResults;
 
     /**
      * Creates a RealmList in unmanaged mode, where the elements are not controlled by a Realm.
@@ -508,7 +506,7 @@ private E lastImpl(boolean shouldThrow, @Nullable E defaultValue) {
     @Override
     public RealmResults<E> sort(String fieldName, Sort sortOrder) {
         if (isManaged()) {
-            return this.where().findAllSorted(fieldName, sortOrder);
+            return this.where().sort(fieldName, sortOrder).findAll();
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
         }
@@ -528,7 +526,7 @@ private E lastImpl(boolean shouldThrow, @Nullable E defaultValue) {
     @Override
     public RealmResults<E> sort(String[] fieldNames, Sort[] sortOrders) {
         if (isManaged()) {
-            return where().findAllSorted(fieldNames, sortOrders);
+            return where().sort(fieldNames, sortOrders).findAll();
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
         }
@@ -760,14 +758,14 @@ private void checkValidRealm() {
         if (className != null) {
             return new OrderedRealmCollectionSnapshot<>(
                     realm,
-                    new OsResults(realm.sharedRealm, osListOperator.getOsList(), null),
+                    OsResults.createFromQuery(realm.sharedRealm, osListOperator.getOsList().getQuery()),
                     className);
         } else {
             // 'clazz' is non-null when 'dynamicClassName' is null.
             //noinspection ConstantConditions
             return new OrderedRealmCollectionSnapshot<>(
                     realm,
-                    new OsResults(realm.sharedRealm, osListOperator.getOsList(), null),
+                    OsResults.createFromQuery(realm.sharedRealm, osListOperator.getOsList().getQuery()),
                     clazz);
         }
     }
@@ -966,11 +964,7 @@ private void checkForAddRemoveListener(@Nullable Object listener, boolean checkL
      */
     public void addChangeListener(OrderedRealmCollectionChangeListener<RealmList<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        if (osListOperator.forRealmModel()) {
-            getOrCreateOsResultsForListener().addListener(this, listener);
-        } else {
-            osListOperator.getOsList().addListener(this, listener);
-        }
+        osListOperator.getOsList().addListener(this, listener);
     }
 
     /**
@@ -983,11 +977,7 @@ public void addChangeListener(OrderedRealmCollectionChangeListener<RealmList<E>>
      */
     public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmList<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        if (osListOperator.forRealmModel()) {
-            getOrCreateOsResultsForListener().removeListener(this, listener);
-        } else {
-            osListOperator.getOsList().removeListener(this, listener);
-        }
+        osListOperator.getOsList().removeListener(this, listener);
     }
 
     /**
@@ -1025,11 +1015,7 @@ public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmList<
      */
     public void addChangeListener(RealmChangeListener<RealmList<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        if (osListOperator.forRealmModel()) {
-            getOrCreateOsResultsForListener().addListener(this, listener);
-        } else {
-            osListOperator.getOsList().addListener(this, listener);
-        }
+        osListOperator.getOsList().addListener(this, listener);
     }
 
     /**
@@ -1042,11 +1028,7 @@ public void addChangeListener(RealmChangeListener<RealmList<E>> listener) {
      */
     public void removeChangeListener(RealmChangeListener<RealmList<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        if (osListOperator.forRealmModel()) {
-            getOrCreateOsResultsForListener().removeListener(this, listener);
-        } else {
-            osListOperator.getOsList().removeListener(this, listener);
-        }
+        osListOperator.getOsList().removeListener(this, listener);
     }
 
     /**
@@ -1057,11 +1039,7 @@ public void removeChangeListener(RealmChangeListener<RealmList<E>> listener) {
      */
     public void removeAllChangeListeners() {
         checkForAddRemoveListener(null, false);
-        if (osListOperator.forRealmModel()) {
-            getOrCreateOsResultsForListener().removeAllListeners();
-        } else {
-            osListOperator.getOsList().removeAllListeners();
-        }
+        osListOperator.getOsList().removeAllListeners();
     }
 
     // Custom RealmList iterator.
@@ -1281,20 +1259,6 @@ private static boolean isClassForRealmModel(Class<?> clazz) {
         }
         throw new IllegalArgumentException("Unexpected value class: " + clazz.getName());
     }
-
-    // TODO: Object Store is not able to merge change set for links list. Luckily since we were still using LinkView
-    // when ship the fine grain notifications, the listener on RealmList is actually added to a OS Results which is
-    // created from the link view. OS Results is computing the change set by comparing the old/new collection. So it
-    // will give the right results if you remove all elements from a RealmList then add all them back and add one more
-    // new element. By right results it means the change set only include one insertion. But if the listener is on the
-    // OS List, the change set will include all ranges of th list. So we keep the old behaviour for
-    // RealmList<RealmModel> for now. See https://github.com/realm/realm-object-store/issues/541
-    private OsResults getOrCreateOsResultsForListener() {
-        if (osResults == null) {
-            this.osResults = new OsResults(realm.sharedRealm, osListOperator.getOsList(), null);
-        }
-        return osResults;
-    }
 }
 
 /**
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index 353da2a112..7cb8bb2634 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -23,6 +23,7 @@
 
 import javax.annotation.Nullable;
 
+import io.realm.annotations.Beta;
 import io.realm.annotations.Required;
 import io.realm.internal.OsResults;
 import io.realm.internal.OsList;
@@ -33,6 +34,7 @@
 import io.realm.internal.Table;
 import io.realm.internal.TableQuery;
 import io.realm.internal.fields.FieldDescriptor;
+import io.realm.log.RealmLog;
 
 
 /**
@@ -63,6 +65,8 @@
     private String className;
     private final boolean forValues;
     private final OsList osList;
+    private SortDescriptor sortDescriptor;
+    private SortDescriptor distinctDescriptor;
 
     private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
     private static final String EMPTY_VALUES = "Non-empty 'values' must be provided.";
@@ -1524,7 +1528,7 @@ public boolean isValid() {
         this.query.or();
         return this;
     }
-    
+
     /**
      * Logical-and two conditions
      * Realm automatically applies logical-and between all query statements, so this is intended only as a mean to increase readability.
@@ -1533,7 +1537,7 @@ public boolean isValid() {
      */
     public RealmQuery<E> and() {
     	realm.checkIfValid();
-    	
+
     	return this;
     }
 
@@ -1584,6 +1588,8 @@ public boolean isValid() {
     }
 
     /**
+     * @deprecated Since 4.3.0, now use {@link RealmQuery#distinctValues(String)} then {@link RealmQuery#findAll()}
+     *
      * Returns a distinct set of objects of a specific class. If the result is sorted, the first
      * object will be returned in case of multiple occurrences, otherwise it is undefined which
      * object is returned.
@@ -1595,6 +1601,7 @@ public boolean isValid() {
      * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type, or points
      * to linked fields.
      */
+    @Deprecated
     public RealmResults<E> distinct(String fieldName) {
         realm.checkIfValid();
 
@@ -1603,6 +1610,8 @@ public boolean isValid() {
     }
 
     /**
+     * @deprecated Since 4.3.0, now use {@link RealmQuery#distinctValues(String)} then {@link RealmQuery#findAllAsync()}
+     *
      * Asynchronously returns a distinct set of objects of a specific class. If the result is
      * sorted, the first object will be returned in case of multiple occurrences, otherwise it is
      * undefined which object is returned.
@@ -1615,6 +1624,7 @@ public boolean isValid() {
      * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type, or points
      * to linked fields.
      */
+    @Deprecated
     public RealmResults<E> distinctAsync(String fieldName) {
         realm.checkIfValid();
 
@@ -1624,6 +1634,8 @@ public boolean isValid() {
     }
 
     /**
+     * @deprecated Since 4.3.0, now use {@link RealmQuery#distinctValues(String, String[])} then {@link RealmQuery#findAll()}
+     *
      * Returns a distinct set of objects from a specific class. When multiple distinct fields are
      * given, all unique combinations of values in the fields will be returned. In case of multiple
      * matches, it is undefined which object is returned. Unless the result is sorted, then the
@@ -1635,6 +1647,7 @@ public boolean isValid() {
      * @throws IllegalArgumentException if field names is empty or {@code null}, does not exist,
      * is an unsupported type, or points to a linked field.
      */
+    @Deprecated
     public RealmResults<E> distinct(String firstFieldName, String... remainingFieldNames) {
         realm.checkIfValid();
 
@@ -1810,7 +1823,7 @@ public long count() {
     public RealmResults<E> findAll() {
         realm.checkIfValid();
 
-        return createRealmResults(query, null, null, true);
+        return createRealmResults(query, sortDescriptor, distinctDescriptor, true);
     }
 
     /**
@@ -1824,10 +1837,12 @@ public long count() {
         realm.checkIfValid();
 
         realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
-        return createRealmResults(query, null, null, false);
+        return createRealmResults(query, sortDescriptor, distinctDescriptor, false);
     }
 
     /**
+     * @deprecated Since 4.3.0, now use {@link RealmQuery#sort(String, Sort)} then {@link RealmQuery#findAll()}
+     *
      * Finds all objects that fulfill the query conditions and sorted by specific field name.
      * <p>
      * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
@@ -1841,14 +1856,16 @@ public long count() {
      * {@link RealmObject} or a child {@link RealmList}.
      */
     @SuppressWarnings("unchecked")
+    @Deprecated
     public RealmResults<E> findAllSorted(String fieldName, Sort sortOrder) {
         realm.checkIfValid();
-
         SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldName, sortOrder);
         return createRealmResults(query, sortDescriptor, null, true);
     }
 
     /**
+     * @deprecated Since 4.3.0, now use {@link RealmQuery#sort(String, Sort)} then {@link RealmQuery#findAllAsync()}
+     *
      * Similar to {@link #findAllSorted(String, Sort)} but runs asynchronously on a worker thread
      * (need a Realm opened from a looper thread to work).
      *
@@ -1857,6 +1874,7 @@ public long count() {
      * @throws java.lang.IllegalArgumentException if field name does not exist or it belongs to a child
      * {@link RealmObject} or a child {@link RealmList}.
      */
+    @Deprecated
     public RealmResults<E> findAllSortedAsync(final String fieldName, final Sort sortOrder) {
         realm.checkIfValid();
 
@@ -1865,8 +1883,129 @@ public long count() {
         return createRealmResults(query, sortDescriptor, null, false);
     }
 
+    /**
+     * Sorts the query result by the specific field name in ascending order.
+     * <p>
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
+     * @param fieldName the field name to sort by.
+     * @throws IllegalArgumentException if the field name does not exist.
+     * @throws IllegalStateException if a sorting order was already defined.
+     */
+    public RealmQuery<E> sort(String fieldName) {
+        realm.checkIfValid();
+        return sort(fieldName, Sort.ASCENDING);
+    }
 
     /**
+     * Sorts the query result by the specified field name and order.
+     * <p>
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
+     * @param fieldName the field name to sort by.
+     * @param sortOrder how to sort the results.
+     * @throws IllegalArgumentException if the field name does not exist.
+     * @throws IllegalStateException if a sorting order was already defined.
+     */
+    public RealmQuery<E> sort(String fieldName, Sort sortOrder) {
+        realm.checkIfValid();
+        return sort(new String[] { fieldName}, new Sort[] { sortOrder});
+    }
+
+    /**
+     * Sorts the query result by the specific field names in the provided orders. {@code fieldName2} is only used
+     * in case of equal values in {@code fieldName1}.
+     * <p>
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
+     * @param fieldName1 first field name
+     * @param sortOrder1 sort order for first field
+     * @param fieldName2 second field name
+     * @param sortOrder2 sort order for second field
+     * @throws IllegalArgumentException if the field name does not exist.
+     * @throws IllegalStateException if a sorting order was already defined.
+     */
+    public RealmQuery<E> sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sortOrder2) {
+        realm.checkIfValid();
+        return sort(new String[] { fieldName1, fieldName2 }, new Sort[] { sortOrder1, sortOrder2 });
+    }
+
+    /**
+     * Sorts the query result by the specific field names in the provided orders. Later fields will only be used
+     * if the previous field values are equal.
+     * <p>
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
+     * @param fieldNames an array of field names to sort by.
+     * @param sortOrders how to sort the field names.
+     * @throws IllegalArgumentException if the field name does not exist.
+     * @throws IllegalStateException if a sorting order was already defined.
+     */
+    public RealmQuery<E> sort(String[] fieldNames, Sort[] sortOrders) {
+        realm.checkIfValid();
+        if (sortDescriptor != null) {
+            throw new IllegalStateException("A sorting order was already defined.");
+        }
+        sortDescriptor = SortDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldNames, sortOrders);
+        return this;
+    }
+
+    /**
+     * BETA API: Will be renamed to {@code distinct} in next major release.
+     *
+     * Selects a distinct set of objects of a specific class. If the result is sorted, the first object will be
+     * returned in case of multiple occurrences, otherwise it is undefined which object is returned.
+     * <p>
+     * Adding {@link io.realm.annotations.Index} to the corresponding field will make this operation much faster.
+     *
+     * @param fieldName the field name.
+     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type, or points
+     * to linked fields.
+     * @throws IllegalStateException if distinct field names were already defined.
+     */
+    @Beta
+    public RealmQuery<E> distinctValues(String fieldName) {
+        return distinctValues(fieldName, new String[]{});
+    }
+
+    /**
+     * BETA API: Will be renamed to {@code distinct} in next major release.
+     *
+     * Selects a distinct set of objects of a specific class. When multiple distinct fields are
+     * given, all unique combinations of values in the fields will be returned. In case of multiple
+     * matches, it is undefined which object is returned. Unless the result is sorted, then the
+     * first object will be returned.
+     *
+     * @param firstFieldName first field name to use when finding distinct objects.
+     * @param remainingFieldNames remaining field names when determining all unique combinations of field values.
+     * @throws IllegalArgumentException if field names is empty or {@code null}, does not exist,
+     * is an unsupported type, or points to a linked field.
+     * @throws IllegalStateException if distinct field names were already defined.
+     */
+    @Beta
+    public RealmQuery<E> distinctValues(String firstFieldName, String... remainingFieldNames) {
+        realm.checkIfValid();
+        if (distinctDescriptor != null) {
+            throw new IllegalStateException("Distinct fields have already been defined.");
+        }
+        if (remainingFieldNames.length == 0) {
+            distinctDescriptor = SortDescriptor.getInstanceForDistinct(getSchemaConnector(), table, firstFieldName);
+        } else {
+            String[] fieldNames = new String[1 + remainingFieldNames.length];
+            fieldNames[0] = firstFieldName;
+            System.arraycopy(remainingFieldNames, 0, fieldNames, 1, remainingFieldNames.length);
+            distinctDescriptor = SortDescriptor.getInstanceForDistinct(getSchemaConnector(), table, fieldNames);
+        }
+        return this;
+    }
+
+    /**
+     * @deprecated Since 4.3.0, now use {@link RealmQuery#sort(String)} then {@link RealmQuery#findAll()}
+     *
      * Finds all objects that fulfill the query conditions and sorted by specific field name in ascending order.
      * <p>
      * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
@@ -1878,11 +2017,14 @@ public long count() {
      * @throws java.lang.IllegalArgumentException if the field name does not exist or it belongs to a child
      * {@link RealmObject} or a child {@link RealmList}.
      */
+    @Deprecated
     public RealmResults<E> findAllSorted(String fieldName) {
         return findAllSorted(fieldName, Sort.ASCENDING);
     }
 
     /**
+     * @deprecated Since 4.3.0, now use {@link RealmQuery#sort(String)} then {@link RealmQuery#findAllAsync()}
+     *
      * Similar to {@link #findAllSorted(String)} but runs asynchronously on a worker thread.
      * This method is only available from a Looper thread.
      *
@@ -1891,11 +2033,14 @@ public long count() {
      * @throws java.lang.IllegalArgumentException if the field name does not exist or it belongs to a child
      * {@link RealmObject} or a child {@link RealmList}.
      */
+    @Deprecated
     public RealmResults<E> findAllSortedAsync(String fieldName) {
         return findAllSortedAsync(fieldName, Sort.ASCENDING);
     }
 
     /**
+     * @deprecated Since 4.3.0, now use {@link RealmQuery#sort(String[], Sort[])} then {@link RealmQuery#findAll()}
+     *
      * Finds all objects that fulfill the query conditions and sorted by specific field names.
      * <p>
      * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
@@ -1908,6 +2053,7 @@ public long count() {
      * @throws java.lang.IllegalArgumentException if one of the field names does not exist or it belongs to a child
      * {@link RealmObject} or a child {@link RealmList}.
      */
+    @Deprecated
     public RealmResults<E> findAllSorted(String[] fieldNames, Sort[] sortOrders) {
         realm.checkIfValid();
 
@@ -1920,6 +2066,8 @@ private boolean isDynamicQuery() {
     }
 
     /**
+     * @deprecated Since 4.3.0, now use {@link RealmQuery#sort(String[], Sort[])} then {@link RealmQuery#findAllAsync()}
+     *
      * Similar to {@link #findAllSorted(String[], Sort[])} but runs asynchronously.
      * from a worker thread.
      * This method is only available from a Looper thread.
@@ -1930,6 +2078,7 @@ private boolean isDynamicQuery() {
      * {@link RealmObject} or a child {@link RealmList}.
      * @see io.realm.RealmResults
      */
+    @Deprecated
     public RealmResults<E> findAllSortedAsync(String[] fieldNames, final Sort[] sortOrders) {
         realm.checkIfValid();
 
@@ -1939,6 +2088,8 @@ private boolean isDynamicQuery() {
     }
 
     /**
+     * @deprecated Since 4.3.0, now use {@link RealmQuery#sort(String, Sort, String, Sort)} then {@link RealmQuery#findAll()}
+     *
      * Finds all objects that fulfill the query conditions and sorted by specific field names in ascending order.
      * <p>
      * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
@@ -1953,12 +2104,15 @@ private boolean isDynamicQuery() {
      * @throws java.lang.IllegalArgumentException if a field name does not exist or it belongs to a child
      * {@link RealmObject} or a child {@link RealmList}.
      */
+    @Deprecated
     public RealmResults<E> findAllSorted(String fieldName1, Sort sortOrder1,
             String fieldName2, Sort sortOrder2) {
         return findAllSorted(new String[] {fieldName1, fieldName2}, new Sort[] {sortOrder1, sortOrder2});
     }
 
     /**
+     * @deprecated Since 4.3.0, now use {@link RealmQuery#sort(String, Sort, String, Sort)} then {@link RealmQuery#findAllAsync()}
+     *
      * Similar to {@link #findAllSorted(String, Sort, String, Sort)} but runs asynchronously on a worker thread
      * This method is only available from a Looper thread.
      *
@@ -1967,6 +2121,7 @@ private boolean isDynamicQuery() {
      * @throws java.lang.IllegalArgumentException if a field name does not exist or it belongs to a child
      * {@link RealmObject} or a child {@link RealmList}.
      */
+    @Deprecated
     public RealmResults<E> findAllSortedAsync(String fieldName1, Sort sortOrder1,
             String fieldName2, Sort sortOrder2) {
         return findAllSortedAsync(new String[] {fieldName1, fieldName2}, new Sort[] {sortOrder1, sortOrder2});
@@ -2014,7 +2169,7 @@ public E findFirstAsync() {
         if (realm.isInTransaction()) {
             // It is not possible to create async query inside a transaction. So immediately query the first object.
             // See OS Results::prepare_async()
-            row = new OsResults(realm.sharedRealm, query).firstUncheckedRow();
+            row = OsResults.createFromQuery(realm.sharedRealm, query).firstUncheckedRow();
         } else {
             // prepares an empty reference of the RealmObject which is backed by a pending query,
             // then update it once the query complete in the background.
@@ -2050,7 +2205,7 @@ public E findFirstAsync() {
             @Nullable SortDescriptor distinctDescriptor,
             boolean loadResults) {
         RealmResults<E> results;
-        OsResults osResults = new OsResults(realm.sharedRealm, query, sortDescriptor, distinctDescriptor);
+        OsResults osResults = OsResults.createFromQuery(realm.sharedRealm, query, sortDescriptor, distinctDescriptor);
         if (isDynamicQuery()) {
             results = new RealmResults<>(realm, osResults, className);
         } else {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index 9a553a092f..de4a3c388f 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -68,7 +68,7 @@
         Table srcTable = realm.getSchema().getTable(srcTableType);
         return new RealmResults<>(
                 realm,
-                OsResults.createBacklinksCollection(realm.sharedRealm, uncheckedRow, srcTable, srcFieldName),
+                OsResults.createForBacklinks(realm.sharedRealm, uncheckedRow, srcTable, srcFieldName),
                 srcTableType);
     }
 
@@ -78,7 +78,7 @@
         //noinspection ConstantConditions
         return new RealmResults<>(
                 realm,
-                OsResults.createBacklinksCollection(realm.sharedRealm, row, srcTable, srcFieldName),
+                OsResults.createForBacklinks(realm.sharedRealm, row, srcTable, srcFieldName),
                 srcClassName);
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/Sort.java b/realm/realm-library/src/main/java/io/realm/Sort.java
index 5d7c3d6f5d..861cccfbd6 100644
--- a/realm/realm-library/src/main/java/io/realm/Sort.java
+++ b/realm/realm-library/src/main/java/io/realm/Sort.java
@@ -19,7 +19,7 @@
 /**
  * This class describes the sorting order used in Realm queries.
  *
- * @see io.realm.RealmQuery#findAllSorted(String, Sort)
+ * @see io.realm.RealmQuery#sort(String, Sort)
  */
 public enum Sort {
     ASCENDING(true),
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsCollectionChangeSet.java b/realm/realm-library/src/main/java/io/realm/internal/OsCollectionChangeSet.java
index 986c18ba6d..93bbc3e7ac 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsCollectionChangeSet.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsCollectionChangeSet.java
@@ -16,6 +16,8 @@
 
 package io.realm.internal;
 
+import java.util.Arrays;
+
 import javax.annotation.Nullable;
 
 import io.realm.OrderedCollectionChangeSet;
@@ -132,4 +134,22 @@ public long getNativeFinalizerPtr() {
 
     // Returns the indices array.
     private native static int[] nativeGetIndices(long nativePtr, int type);
+
+    @Override
+    public String toString() {
+        if (nativePtr == 0)  {
+            return "Change set is empty.";
+        }
+
+        String string = "Deletion Ranges: " +
+                Arrays.toString(getDeletionRanges()) +
+                "\n" +
+                "Insertion Ranges: " +
+                Arrays.toString(getInsertionRanges()) +
+                "\n" +
+                "Change Ranges: " +
+                Arrays.toString(getChangeRanges());
+        return string;
+
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsResults.java b/realm/realm-library/src/main/java/io/realm/internal/OsResults.java
index 045472ca98..c810eb9b9b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsResults.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsResults.java
@@ -85,8 +85,6 @@ public T next() {
 
         /**
          * Not supported by Realm collection iterators.
-         *
-         * @throws UnsupportedOperationException
          */
         @Override
         @Deprecated
@@ -138,8 +136,6 @@ public ListIterator(OsResults osResults, int start) {
 
         /**
          * Unsupported by Realm collection iterators.
-         *
-         * @throws UnsupportedOperationException
          */
         @Override
         @Deprecated
@@ -193,8 +189,6 @@ public int previousIndex() {
 
         /**
          * Unsupported by RealmResults iterators.
-         *
-         * @throws UnsupportedOperationException
          */
         @Override
         @Deprecated
@@ -276,61 +270,37 @@ static Mode getByValue(byte value) {
         }
     }
 
-    public static OsResults createBacklinksCollection(OsSharedRealm realm, UncheckedRow row, Table srcTable, String srcFieldName) {
+    public static OsResults createForBacklinks(OsSharedRealm realm, UncheckedRow row, Table srcTable,
+                                               String srcFieldName) {
         long backlinksPtr = nativeCreateResultsFromBacklinks(
                 realm.getNativePtr(),
                 row.getNativePtr(),
                 srcTable.getNativePtr(),
                 srcTable.getColumnIndex(srcFieldName));
-        return new OsResults(realm, srcTable, backlinksPtr, true);
+        return new OsResults(realm, srcTable, backlinksPtr);
     }
 
-    public OsResults(OsSharedRealm sharedRealm, TableQuery query,
-                     @Nullable SortDescriptor sortDescriptor, @Nullable SortDescriptor distinctDescriptor) {
+    public static OsResults createFromQuery(OsSharedRealm sharedRealm, TableQuery query,
+                                            @Nullable SortDescriptor sortDescriptor,
+                                            @Nullable SortDescriptor distinctDescriptor) {
         query.validateQuery();
-
-        this.nativePtr = nativeCreateResults(sharedRealm.getNativePtr(), query.getNativePtr(),
+        long ptr = nativeCreateResults(sharedRealm.getNativePtr(), query.getNativePtr(),
                 sortDescriptor,
                 distinctDescriptor);
-
-        this.sharedRealm = sharedRealm;
-        this.context = sharedRealm.context;
-        this.table = query.getTable();
-        this.context.addReference(this);
-        this.loaded = false;
+        return new OsResults(sharedRealm, query.getTable(), ptr);
     }
 
-    public OsResults(OsSharedRealm sharedRealm, TableQuery query, @Nullable SortDescriptor sortDescriptor) {
-        this(sharedRealm, query, sortDescriptor, null);
+    public static OsResults createFromQuery(OsSharedRealm sharedRealm, TableQuery query) {
+        return createFromQuery(sharedRealm, query, null, null);
     }
 
-    public OsResults(OsSharedRealm sharedRealm, TableQuery query) {
-        this(sharedRealm, query, null, null);
-    }
-
-    public OsResults(OsSharedRealm sharedRealm, OsList osList, @Nullable SortDescriptor sortDescriptor) {
-        this.nativePtr = nativeCreateResultsFromList(sharedRealm.getNativePtr(), osList.getNativePtr(), sortDescriptor);
-
-        this.sharedRealm = sharedRealm;
-        this.context = sharedRealm.context;
-        this.table = osList.getTargetTable();
-        this.context.addReference(this);
-        // OsResults created from OsList is loaded by default. So that the listener won't be triggered with empty
-        // change set.
-        this.loaded = true;
-    }
-
-    private OsResults(OsSharedRealm sharedRealm, Table table, long nativePtr) {
-        this(sharedRealm, table, nativePtr, false);
-    }
-
-    OsResults(OsSharedRealm sharedRealm, Table table, long nativePtr, boolean loaded) {
+    OsResults(OsSharedRealm sharedRealm, Table table, long nativePtr) {
         this.sharedRealm = sharedRealm;
         this.context = sharedRealm.context;
         this.table = table;
         this.nativePtr = nativePtr;
         this.context.addReference(this);
-        this.loaded = loaded;
+        this.loaded = getMode() != Mode.QUERY;
     }
 
     public OsResults createSnapshot() {
@@ -477,16 +447,17 @@ public Mode getMode() {
         return Mode.getByValue(nativeGetMode(nativePtr));
     }
 
-    // The Results of Object Store will be queried asynchronously in nature. But we do have to support "sync" query by
-    // Java like RealmQuery.findAll().
+    // The Results with mode QUERY will be evaluated asynchronously in Object Store. But we do have to support "sync"
+    // query by Java like RealmQuery.findAll().
     // The flag is used for following cases:
-    // 1. For sync query, loaded will be set to true when collection is created. So we will bypass the first trigger of
-    //    listener if it comes with empty change set from Object Store since we assume user already got the query
-    //    result.
-    // 2. For async query, when load() gets called with loaded not set, the listener should be triggered with empty
+    // 1. When Results is created, loaded will be set to false if the mode is QUERY. For other modes, loaded will be set
+    //    to true.
+    // 2. For sync query (RealmQuery.findAll()), load() should be called after the Results creation. Then query will be
+    //    evaluated immediately and then loaded will be set to true (And the mode will be changed to TABLEVIEW in OS).
+    // 3. For async query, when load() gets called with loaded not set, the listener should be triggered with empty
     //    change set since it is considered as query first returned.
-    // 3. If the listener triggered with empty change set after load() called for async queries, it is treated as the
-    //    same case as 1).
+    // 4. If the listener triggered with empty change set after load() called for async queries, it is treated as the
+    //    same case as 2).
     public boolean isLoaded() {
         return loaded;
     }
@@ -495,6 +466,7 @@ public void load() {
         if (loaded) {
             return;
         }
+        nativeEvaluateQueryIfNeeded(nativePtr, false);
         notifyChangeListeners(0);
     }
 
@@ -503,9 +475,6 @@ public void load() {
     private static native long nativeCreateResults(long sharedRealmNativePtr, long queryNativePtr,
             @Nullable SortDescriptor sortDesc, @Nullable SortDescriptor distinctDesc);
 
-    private static native long nativeCreateResultsFromList(long sharedRealmPtr, long listPtr,
-                                                           @Nullable SortDescriptor sortDesc);
-
     private static native long nativeCreateSnapshot(long nativePtr);
 
     private static native long nativeGetRow(long nativePtr, int index);
@@ -546,4 +515,6 @@ private static native long nativeCreateResultsFromList(long sharedRealmPtr, long
     private static native byte nativeGetMode(long nativePtr);
 
     private static native long nativeCreateResultsFromBacklinks(long sharedRealmNativePtr, long rowNativePtr, long srcTableNativePtr, long srColIndex);
+
+    private static native void nativeEvaluateQueryIfNeeded(long nativePtr, boolean wantsNotifications);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java
index 7bb3a075af..137a2ef199 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java
@@ -160,6 +160,14 @@ protected PartialSyncCallback(String className) {
     // JNI will only hold a weak global ref to this.
     public final RealmNotifier realmNotifier;
     public final Capabilities capabilities;
+    // For the Java callbacks during constructing in Object Store, some temporary OsSharedRealm objects need to be
+    // created as the parameter of the callback. The native pointers of those temp OsSharedRealm objects have to be
+    // valid during the whole life cycle of the Java object. The living native pointers still hold a ref-count to the
+    // SharedRealm which means the SharedRealm won't be closed automatically if there is any exception throws during
+    // construction. GC will clear them later, but that would be too late. So we are tracking the temp OsSharedRealm
+    // during the construction stage and manually close them if exception throws.
+    private final static List<OsSharedRealm> sharedRealmsUnderConstruction = new CopyOnWriteArrayList<OsSharedRealm>();
+    private final List<OsSharedRealm> tempSharedRealmsForCallback = new ArrayList<OsSharedRealm>();
 
     private final List<WeakReference<PendingRow>> pendingRows = new CopyOnWriteArrayList<>();
     // Package protected for testing
@@ -169,10 +177,25 @@ private OsSharedRealm(OsRealmConfig osRealmConfig) {
         Capabilities capabilities = new AndroidCapabilities();
         RealmNotifier realmNotifier = new AndroidRealmNotifier(this, capabilities);
 
-        this.nativePtr = nativeGetSharedRealm(osRealmConfig.getNativePtr(), realmNotifier);
+        // SharedRealms under constructions are identified by the Context.
+        this.context = osRealmConfig.getContext();
+        sharedRealmsUnderConstruction.add(this);
+        try {
+            this.nativePtr = nativeGetSharedRealm(osRealmConfig.getNativePtr(), realmNotifier);
+        } catch (Throwable t) {
+            // The SharedRealm instances have to be closed before throw.
+            for (OsSharedRealm sharedRealm: tempSharedRealmsForCallback) {
+                if (!sharedRealm.isClosed()) {
+                    sharedRealm.close();
+                }
+            }
+            throw t;
+        } finally {
+            tempSharedRealmsForCallback.clear();
+            sharedRealmsUnderConstruction.remove(this);
+        }
         this.osRealmConfig = osRealmConfig;
         this.schemaInfo = new OsSchemaInfo(nativeGetSchemaInfo(nativePtr), this);
-        this.context = osRealmConfig.getContext();
         this.context.addReference(this);
 
         this.capabilities = capabilities;
@@ -198,6 +221,18 @@ private OsSharedRealm(long nativeSharedRealmPtr, OsRealmConfig osRealmConfig) {
         // This instance should never need notifications.
         this.realmNotifier = null;
         nativeSetAutoRefresh(nativePtr, false);
+
+        boolean foundParentSharedRealm = false;
+        for (OsSharedRealm sharedRealm : sharedRealmsUnderConstruction) {
+            if (sharedRealm.context == osRealmConfig.getContext())  {
+                foundParentSharedRealm = true;
+                sharedRealm.tempSharedRealmsForCallback.add(this);
+                break;
+            }
+        }
+        if (!foundParentSharedRealm) {
+            throw new IllegalStateException("Cannot find the parent 'OsSharedRealm' which is under construction.");
+        }
     }
 
 
@@ -511,7 +546,7 @@ private void runPartialSyncRegistrationCallback(@Nullable String error, long nat
         } else {
             @SuppressWarnings("ConstantConditions")
             Table table = getTable(Table.getTableNameForClass(callback.className));
-            OsResults results = new OsResults(this, table, nativeResultsPtr, true);
+            OsResults results = new OsResults(this, table, nativeResultsPtr);
             callback.onSuccess(results);
         }
     }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
index 3b4b9802be..bfa733cd33 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
@@ -40,7 +40,7 @@
     public PendingRow(OsSharedRealm sharedRealm, TableQuery query, @Nullable SortDescriptor sortDescriptor,
                       final boolean returnCheckedRow) {
         this.sharedRealm = sharedRealm;
-        pendingOsResults = new OsResults(sharedRealm, query, sortDescriptor, null);
+        pendingOsResults = OsResults.createFromQuery(sharedRealm, query, sortDescriptor, null);
 
         listener = new RealmChangeListener<PendingRow>() {
             @Override
diff --git a/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java b/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
index 9d1acc3527..d41906a017 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
@@ -24,10 +24,8 @@
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Deque;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 
@@ -142,7 +140,7 @@ public boolean isGlobalRealm() {
     private Realm defaultPermissionRealm;
 
     // Task list used to queue tasks until the underlying Realms are done opening (or failed doing so).
-    private Deque<PermissionManagerTask> delayedTasks = new LinkedList<>();
+    private List<PermissionManagerTask> delayedTasks = new ArrayList<>();
 
     // List of tasks that are being processed. Used to keep strong references for listeners to work.
     // The task must remove itself from this list once it either completes
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
index 5bd7176a6d..0ff32a6bfe 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
@@ -97,6 +97,19 @@ public static SyncCredentials google(String googleToken) {
         return new SyncCredentials(googleToken, IdentityProvider.GOOGLE, null);
     }
 
+    /**
+     * Creates credentials based on a JSON Web Token (JWT).
+     *
+     * @param jwtToken a JWT token that identifies the user.
+     * @return a set of credentials that can be used to log into the Object Server using
+     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * @throws IllegalArgumentException if the token is either {@code null} or empty.
+     */
+    public static SyncCredentials jwt(String jwtToken) {
+        assertStringNotEmpty(jwtToken, "jwtToken");
+        return new SyncCredentials(jwtToken, IdentityProvider.JWT, null);
+    }
+
     /**
      * Creates credentials based on a login with username and password. These credentials will only be verified
      * by the Object Server.
@@ -263,6 +276,12 @@ public String getUserIdentifier() {
          */
         public static final String GOOGLE = "google";
 
+        /**
+         * Credentials are given in the form of a standard JSON Web Token that will be verified
+         * by the Realm Object Server.
+         */
+        public static final String JWT = "jwt";
+
         /**
          * Credentials will be verified by the Object Server.
          *
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
index 55aab7e5f5..cf3602bfe1 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
@@ -12,7 +12,9 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
@@ -277,7 +279,7 @@ public void run() {
                         .build();
                 final Realm adminRealm = Realm.getInstance(adminConfig);
 
-                RealmResults<StringOnly> all = adminRealm.where(StringOnly.class).findAllSorted(StringOnly.FIELD_CHARS);
+                RealmResults<StringOnly> all = adminRealm.where(StringOnly.class).sort(StringOnly.FIELD_CHARS).findAll();
                 RealmChangeListener<RealmResults<StringOnly>> realmChangeListener = new RealmChangeListener<RealmResults<StringOnly>>() {
                     @Override
                     public void onChange(RealmResults<StringOnly> stringOnlies) {
@@ -309,6 +311,7 @@ public void onChange(RealmResults<StringOnly> stringOnlies) {
     // this test validate the behaviour of SyncSessionStopPolicy::AfterChangesUploaded
     @Test
     public void uploadChangesWhenRealmOutOfScope() throws InterruptedException {
+        final List<Object> strongRefs = new ArrayList<>();
         final String uniqueName = UUID.randomUUID().toString();
         SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
         SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
@@ -351,6 +354,7 @@ public void run() {
                         .build();
                 final Realm adminRealm = Realm.getInstance(adminConfig);
                 RealmResults<StringOnly> all = adminRealm.where(StringOnly.class).findAll();
+                strongRefs.add(all);
                 RealmChangeListener<RealmResults<StringOnly>> realmChangeListener = new RealmChangeListener<RealmResults<StringOnly>>() {
                     @Override
                     public void onChange(RealmResults<StringOnly> stringOnlies) {
@@ -369,9 +373,9 @@ public void onChange(RealmResults<StringOnly> stringOnlies) {
         });
 
         TestHelper.awaitOrFail(testCompleted, 60);
+        handlerThread.join();
 
         user.logout();
-        realm.close();
     }
 
     // A Realm that was opened before a user logged out should be able to resume downloading if the user logs back in.
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
index ded87c8ca1..9c0418233c 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
@@ -226,8 +226,8 @@ public void onError(SyncSession session, ObjectServerError error) {
 
         adminRealm = Realm.getInstance(adminConfigWithEncryption);
 
-        RealmResults<StringOnly> allSorted = realm.where(StringOnly.class).findAllSorted(StringOnly.FIELD_CHARS);
-        RealmResults<StringOnly> allSortedAdmin = adminRealm.where(StringOnly.class).findAllSorted(StringOnly.FIELD_CHARS);
+        RealmResults<StringOnly> allSorted = realm.where(StringOnly.class).sort(StringOnly.FIELD_CHARS).findAll();
+        RealmResults<StringOnly> allSortedAdmin = adminRealm.where(StringOnly.class).sort(StringOnly.FIELD_CHARS).findAll();
         assertEquals("Hi Alice", allSorted.get(0).getChars());
         assertEquals("Hi Bob", allSorted.get(1).getChars());
 
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
index b477f33609..2b7c9383cb 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
@@ -19,11 +19,11 @@
 import android.os.Looper;
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.io.IOException;
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -52,8 +52,9 @@
     @Rule
     public RunWithRemoteService remoteService = new RunWithRemoteService();
 
-    @Before
-    public void before() throws Exception {
+    @Override
+    public void setupTest() throws IOException {
+        super.setupTest();
         UserFactory.resetInstance();
     }
 
@@ -191,7 +192,7 @@ public void expectALot() throws Throwable {
                 .directory(looperThread.getRoot())
                 .build();
         final Realm realm = Realm.getInstance(syncConfig);
-        final RealmResults<TestObject> all = realm.where(TestObject.class).findAllSorted("intProp");
+        final RealmResults<TestObject> all = realm.where(TestObject.class).sort("intProp").findAll();
         looperThread.keepStrongReference(all);
         final AtomicInteger listenerCalledCounter = new AtomicInteger(0);
         all.addChangeListener(new RealmChangeListener<RealmResults<TestObject>>() {
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
index 3f2e74c5ad..70b9cf492b 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
@@ -23,7 +23,7 @@
     public static final String USER_REALM_2 = "realm://" + HOST + ":9080/~/tests2";
     public static final String USER_REALM_SECURE = "realms://" + HOST + ":9443/~/tests";
     public static final String SYNC_SERVER_URL = "realm://" + HOST + ":9080/~/tests";
-    public static final String SYNC_SERVER_URL_2 = "realm://" + HOST + "/~/tests2";
+    public static final String SYNC_SERVER_URL_2 = "realm://" + HOST + ":9080/~/tests2";
 
     public static final String AUTH_SERVER_URL = "http://" + HOST + ":9080/";
     public static final String AUTH_URL = AUTH_SERVER_URL + "auth";
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/testUtils/java/io/realm/TestHelper.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
rename to realm/realm-library/src/testUtils/java/io/realm/TestHelper.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypes.java b/realm/realm-library/src/testUtils/java/io/realm/entities/AllTypes.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/AllTypes.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/AllTypes.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypesPrimaryKey.java b/realm/realm-library/src/testUtils/java/io/realm/entities/AllTypesPrimaryKey.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/AllTypesPrimaryKey.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/AllTypesPrimaryKey.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AnnotationIndexTypes.java b/realm/realm-library/src/testUtils/java/io/realm/entities/AnnotationIndexTypes.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/AnnotationIndexTypes.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/AnnotationIndexTypes.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksSource.java b/realm/realm-library/src/testUtils/java/io/realm/entities/BacklinksSource.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksSource.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/BacklinksSource.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksTarget.java b/realm/realm-library/src/testUtils/java/io/realm/entities/BacklinksTarget.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksTarget.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/BacklinksTarget.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/Cat.java b/realm/realm-library/src/testUtils/java/io/realm/entities/Cat.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/Cat.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/Cat.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/Dog.java b/realm/realm-library/src/testUtils/java/io/realm/entities/Dog.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/Dog.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/Dog.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/DogPrimaryKey.java b/realm/realm-library/src/testUtils/java/io/realm/entities/DogPrimaryKey.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/DogPrimaryKey.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/DogPrimaryKey.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/NullTypes.java b/realm/realm-library/src/testUtils/java/io/realm/entities/NullTypes.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/NullTypes.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/NullTypes.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/Owner.java b/realm/realm-library/src/testUtils/java/io/realm/entities/Owner.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/Owner.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/Owner.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedByte.java b/realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsBoxedByte.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedByte.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsBoxedByte.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedInteger.java b/realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsBoxedInteger.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedInteger.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsBoxedInteger.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java b/realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsBoxedLong.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsBoxedLong.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedShort.java b/realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsBoxedShort.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedShort.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsBoxedShort.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsByte.java b/realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsByte.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsByte.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsByte.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java b/realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsInteger.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsInteger.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsLong.java b/realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsLong.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsLong.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsLong.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsShort.java b/realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsShort.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsShort.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsShort.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java b/realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsString.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsString.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java b/realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java b/realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java b/realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java b/realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java
rename to realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/objectid/NullPrimaryKey.java b/realm/realm-library/src/testUtils/java/io/realm/objectid/NullPrimaryKey.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/objectid/NullPrimaryKey.java
rename to realm/realm-library/src/testUtils/java/io/realm/objectid/NullPrimaryKey.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java b/realm/realm-library/src/testUtils/java/io/realm/rule/RunInLooperThread.java
similarity index 98%
rename from realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
rename to realm/realm-library/src/testUtils/java/io/realm/rule/RunInLooperThread.java
index ebc149f8c5..31d73961f2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
+++ b/realm/realm-library/src/testUtils/java/io/realm/rule/RunInLooperThread.java
@@ -80,7 +80,7 @@
     // events (Callbacks happening in the future), so we add a strong reference
     // to them for the duration of the test.
     // Access guarded by 'lock'
-    private LinkedList<Object> keepStrongReference;
+    private List<Object> keepStrongReference;
 
     // Custom Realm used by the test. Saving the reference here will guarantee
     // that the instance is closed when exiting the test.
@@ -266,9 +266,9 @@ protected void before() throws Throwable {
         super.before();
 
         RealmConfiguration config = createConfiguration(UUID.randomUUID().toString());
-        LinkedList<Object> refs = new LinkedList<>();
-        List<Realm> realms = new LinkedList<>();
-        LinkedList<Closeable> closeables = new LinkedList<>();
+        List<Object> refs = new ArrayList<>();
+        List<Realm> realms = new ArrayList<>();
+        List<Closeable> closeables = new ArrayList<>();
 
         synchronized (lock) {
             realmConfiguration = config;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java b/realm/realm-library/src/testUtils/java/io/realm/rule/RunTestInLooperThread.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java
rename to realm/realm-library/src/testUtils/java/io/realm/rule/RunTestInLooperThread.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestWithRemoteService.java b/realm/realm-library/src/testUtils/java/io/realm/rule/RunTestWithRemoteService.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/rule/RunTestWithRemoteService.java
rename to realm/realm-library/src/testUtils/java/io/realm/rule/RunTestWithRemoteService.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunWithRemoteService.java b/realm/realm-library/src/testUtils/java/io/realm/rule/RunWithRemoteService.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/rule/RunWithRemoteService.java
rename to realm/realm-library/src/testUtils/java/io/realm/rule/RunWithRemoteService.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java b/realm/realm-library/src/testUtils/java/io/realm/rule/TestRealmConfigurationFactory.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
rename to realm/realm-library/src/testUtils/java/io/realm/rule/TestRealmConfigurationFactory.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java b/realm/realm-library/src/testUtils/java/io/realm/services/RemoteProcessService.java
similarity index 100%
rename from realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
rename to realm/realm-library/src/testUtils/java/io/realm/services/RemoteProcessService.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteTestService.java b/realm/realm-library/src/testUtils/java/io/realm/services/RemoteTestService.java
similarity index 98%
rename from realm/realm-library/src/androidTest/java/io/realm/services/RemoteTestService.java
rename to realm/realm-library/src/testUtils/java/io/realm/services/RemoteTestService.java
index 46eee6e089..57b0deec15 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteTestService.java
+++ b/realm/realm-library/src/testUtils/java/io/realm/services/RemoteTestService.java
@@ -29,8 +29,6 @@
 
 import java.io.File;
 import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
 import java.util.HashMap;
 import java.util.Map;
 
diff --git a/realm/settings.gradle b/realm/settings.gradle
index 4540b8669d..e986dd6c2c 100644
--- a/realm/settings.gradle
+++ b/realm/settings.gradle
@@ -1,3 +1,4 @@
 // Realm projects
-include 'realm-library'
-include 'realm-annotations-processor'
+include ':realm-library'
+include ':realm-annotations-processor'
+include ':kotlin-extensions'
diff --git a/version.txt b/version.txt
index d168f1d8bd..b2595557b0 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-4.2.1-SNAPSHOT
\ No newline at end of file
+4.3.2-SNAPSHOT
\ No newline at end of file
