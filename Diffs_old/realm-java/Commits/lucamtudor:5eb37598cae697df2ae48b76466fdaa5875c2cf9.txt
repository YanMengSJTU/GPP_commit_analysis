diff --git a/.gitignore b/.gitignore
index 7b6fdcfa03..b8ed128e2b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -22,6 +22,7 @@ core-*
 */.DS_Store
 
 # JNI libs
+realm_version_check.timestamp
 /realm/src/main/jniLibs
 
 # Build artifacts
@@ -45,3 +46,4 @@ distribution/version.txt
 distribution/RealmGridViewExample/app/src
 distribution/RealmIntroExample/app/src
 distribution/RealmMigrationExample/app/src
+
diff --git a/build.gradle b/build.gradle
index e4b66f446f..e19c35cb35 100644
--- a/build.gradle
+++ b/build.gradle
@@ -12,8 +12,7 @@ buildscript {
 
 allprojects {
   group = 'io.realm'
-  version = new File('version.txt').text
-
+  version = new File("version.txt").text
   repositories {
     jcenter()
   }
diff --git a/changelog.txt b/changelog.txt
index f2c19fc7d7..d07e741485 100644
--- a/changelog.txt
+++ b/changelog.txt
@@ -3,6 +3,7 @@
   * Rewritten the notification system. The API did not change but it's not much more reliable
   * Added support for switching auto-refresh on and off (Realm.setAutoRefresh)
   * Added deleteFromRealm() method to RealmObject
+  * Json API
 
 0.72.0 (27 Oct 2014)
   * Extended sorting support to more types: boolean, byte, short, int, long, float, double, Date, and String
diff --git a/examples/jsonImportExample/.gitignore b/examples/jsonImportExample/.gitignore
new file mode 100644
index 0000000000..796b96d1c4
--- /dev/null
+++ b/examples/jsonImportExample/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/examples/jsonImportExample/build.gradle b/examples/jsonImportExample/build.gradle
new file mode 100644
index 0000000000..1f5f413e9f
--- /dev/null
+++ b/examples/jsonImportExample/build.gradle
@@ -0,0 +1,28 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 19
+    buildToolsVersion "20.0.0"
+    defaultConfig {
+        applicationId 'io.realm.examples.jsonimport'
+        minSdkVersion 15
+        targetSdkVersion 19
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            runProguard false
+        }
+    }
+    productFlavors {
+    }
+}
+
+tasks.preBuild {
+    dependsOn ":realm:androidJar"
+}
+
+dependencies {
+    compile files("../../realm/build/libs/realm-${version}.jar")
+}
diff --git a/examples/jsonImportExample/proguard-rules.pro b/examples/jsonImportExample/proguard-rules.pro
new file mode 100644
index 0000000000..200fdffd58
--- /dev/null
+++ b/examples/jsonImportExample/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /usr/local/Cellar/android-sdk/22.6.2/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/examples/jsonImportExample/src/main/AndroidManifest.xml b/examples/jsonImportExample/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..e5615233cf
--- /dev/null
+++ b/examples/jsonImportExample/src/main/AndroidManifest.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="io.realm.examples.realmgridview">
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme">
+        <activity
+            android:name=".RealmJsonExampleActivity"
+            android:configChanges="keyboard|screenSize|orientation"
+            android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/examples/jsonImportExample/src/main/assets/cities.json b/examples/jsonImportExample/src/main/assets/cities.json
new file mode 100644
index 0000000000..db4e522255
--- /dev/null
+++ b/examples/jsonImportExample/src/main/assets/cities.json
@@ -0,0 +1,64 @@
+[
+    { "name"  : "Barcelona",
+      "votes" : 23 },
+
+    { "name"  : "San Francisco",
+      "votes" : 21 },
+
+    { "name"  : "Venice",
+      "votes" : 19 },
+
+    { "name"  : "Melbourne",
+      "votes" : 18 },
+
+    { "name"  : "Paris",
+      "votes" : 17 },
+
+    { "name"  : "Seville",
+      "votes" : 14 },
+
+    { "name"  : "Sydney",
+      "votes" : 12 },
+
+    { "name"  : "New York",
+      "votes" : 11 },
+
+    { "name"  : "Krakow",
+      "votes" : 9 },
+
+    { "name"  : "Peoria",
+      "votes" : 72 },
+
+    { "name"  : "Springfield",
+      "votes" : 88 },
+
+    { "name"  : "Kansas City",
+      "votes" : 100 },
+
+    { "name"  : "Tokyo",
+      "votes" : 20 },
+
+    { "name"  : "Boise",
+      "votes" : 17 },
+
+    { "name"  : "Los Angeles",
+      "votes" : 14 },
+
+    { "name"  : "Newark",
+      "votes" : 12 },
+
+    { "name"  : "Chicago",
+      "votes" : 11 },
+
+    { "name"  : "Detroit",
+      "votes" : 91 },
+
+    { "name"  : "Florence",
+      "votes" : 4 },
+
+    { "name"  : "Madrid",
+      "votes" : 1 },
+
+    { "name"  : "London",
+      "votes" : 9 }
+]
\ No newline at end of file
diff --git a/examples/jsonImportExample/src/main/java/io/realm/examples/realmgridview/City.java b/examples/jsonImportExample/src/main/java/io/realm/examples/realmgridview/City.java
new file mode 100644
index 0000000000..f0aec3c61c
--- /dev/null
+++ b/examples/jsonImportExample/src/main/java/io/realm/examples/realmgridview/City.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.realmgridview;
+
+import io.realm.RealmObject;
+
+public class City extends RealmObject {
+
+    private String name;
+    private long votes;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public long getVotes() {
+        return votes;
+    }
+
+    public void setVotes(long votes) {
+        this.votes = votes;
+    }
+
+}
diff --git a/examples/jsonImportExample/src/main/java/io/realm/examples/realmgridview/CityAdapter.java b/examples/jsonImportExample/src/main/java/io/realm/examples/realmgridview/CityAdapter.java
new file mode 100644
index 0000000000..1b5050abfd
--- /dev/null
+++ b/examples/jsonImportExample/src/main/java/io/realm/examples/realmgridview/CityAdapter.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.realmgridview;
+
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.BaseAdapter;
+import android.widget.TextView;
+
+import java.util.List;
+
+// This adapter is strictly to interface with the GridView and doesn't
+// particular show much interesting Realm functionality.
+
+// Alternatively from this example,
+// a developer could update the getView() to pull items from the Realm.
+
+public class CityAdapter extends BaseAdapter {
+
+    public static final String TAG = RealmJsonExampleActivity.class.getName();
+
+    private LayoutInflater inflater;
+
+    private List<City> cities = null;
+
+    public CityAdapter(Context context) {
+        inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+    }
+
+    public void setData(List<City> details) {
+        this.cities = details;
+    }
+
+    @Override
+    public int getCount() {
+        if (cities == null) {
+            return 0;
+        }
+        return cities.size();
+    }
+
+    @Override
+    public Object getItem(int position) {
+        if (cities == null || cities.get(position) == null) {
+            return null;
+        }
+        return cities.get(position);
+    }
+
+    @Override
+    public long getItemId(int i) {
+        return i;
+    }
+
+    @Override
+    public View getView(int position, View currentView, ViewGroup parent) {
+        if (currentView == null) {
+            currentView = inflater.inflate(R.layout.city_listitem, parent, false);
+        }
+
+        City city = cities.get(position);
+
+        if (city != null) {
+            ((TextView) currentView.findViewById(R.id.name)).setText(city.getName());
+            ((TextView) currentView.findViewById(R.id.votes)).setText(Long.toString(city.getVotes()));
+        }
+
+        return currentView;
+    }
+}
diff --git a/examples/jsonImportExample/src/main/java/io/realm/examples/realmgridview/RealmJsonExampleActivity.java b/examples/jsonImportExample/src/main/java/io/realm/examples/realmgridview/RealmJsonExampleActivity.java
new file mode 100644
index 0000000000..214d436dbd
--- /dev/null
+++ b/examples/jsonImportExample/src/main/java/io/realm/examples/realmgridview/RealmJsonExampleActivity.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.realmgridview;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.widget.GridView;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.List;
+
+import io.realm.Realm;
+
+public class RealmJsonExampleActivity extends Activity {
+
+    public static final String TAG = RealmJsonExampleActivity.class.getName();
+
+    private GridView mGridView;
+    private CityAdapter mAdapter;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_realm_example);
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+
+        // Load from file "cities.json" first time
+        if(mAdapter == null) {
+            List<City> cities = loadCities();
+
+            //This is the GridView adapter
+            mAdapter = new CityAdapter(this);
+            mAdapter.setData(cities);
+
+            //This is the GridView which will display the list of cities
+            mGridView = (GridView) findViewById(R.id.cities_list);
+            mGridView.setAdapter(mAdapter);
+            mAdapter.notifyDataSetChanged();
+            mGridView.invalidate();
+        }
+    }
+
+    public List<City> loadCities() {
+
+        // In this case we're loading from local assets.
+        // NOTE: could alternatively easily load from network
+        InputStream stream = null;
+        try {
+            stream = getAssets().open("cities.json");
+        } catch (IOException e) {
+            return null;
+        }
+
+        Realm.deleteRealmFile(this);
+
+        // Store the retrieved items to the Realm
+        Realm realm = Realm.getInstance(this);
+
+        // Open a transaction to store items into the realm
+        try {
+            realm.beginTransaction();
+            realm.createAllFromJson(City.class, stream);
+            realm.commitTransaction();
+            stream.close();
+        } catch (IOException e) {
+            // Ignore
+        }
+
+        return realm.allObjects(City.class);
+    }
+}
diff --git a/examples/jsonImportExample/src/main/res/drawable-hdpi/ic_launcher.png b/examples/jsonImportExample/src/main/res/drawable-hdpi/ic_launcher.png
new file mode 100644
index 0000000000..96a442e5b8
Binary files /dev/null and b/examples/jsonImportExample/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/examples/jsonImportExample/src/main/res/drawable-mdpi/ic_launcher.png b/examples/jsonImportExample/src/main/res/drawable-mdpi/ic_launcher.png
new file mode 100644
index 0000000000..359047dfa4
Binary files /dev/null and b/examples/jsonImportExample/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/examples/jsonImportExample/src/main/res/drawable-xhdpi/ic_launcher.png b/examples/jsonImportExample/src/main/res/drawable-xhdpi/ic_launcher.png
new file mode 100644
index 0000000000..71c6d760f0
Binary files /dev/null and b/examples/jsonImportExample/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/examples/jsonImportExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/jsonImportExample/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..4df1894644
Binary files /dev/null and b/examples/jsonImportExample/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/examples/jsonImportExample/src/main/res/layout/activity_realm_example.xml b/examples/jsonImportExample/src/main/res/layout/activity_realm_example.xml
new file mode 100644
index 0000000000..a1a15a17a3
--- /dev/null
+++ b/examples/jsonImportExample/src/main/res/layout/activity_realm_example.xml
@@ -0,0 +1,25 @@
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    tools:context=".RealmGridLayoutActivity">
+
+    <TextView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:gravity="center_horizontal"
+        android:text="My Favorite City"
+        android:textSize="18sp" />
+
+    <GridView
+        android:id="@+id/cities_list"
+        android:listSelector="@android:color/transparent"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:numColumns="2" />
+</LinearLayout>
diff --git a/examples/jsonImportExample/src/main/res/layout/city_listitem.xml b/examples/jsonImportExample/src/main/res/layout/city_listitem.xml
new file mode 100755
index 0000000000..84a41ed2dc
--- /dev/null
+++ b/examples/jsonImportExample/src/main/res/layout/city_listitem.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:gravity="center"
+    android:orientation="horizontal">
+
+    <TextView
+        android:id="@+id/name"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_margin="5dp"
+        android:textColor="@android:color/black" />
+
+    <TextView
+        android:id="@+id/votes"
+        android:layout_width="wrap_content"
+         android:layout_height="wrap_content"
+        android:layout_margin="5dp"
+        android:textColor="@android:color/black" />
+</LinearLayout>
diff --git a/examples/jsonImportExample/src/main/res/menu/options_menu.xml b/examples/jsonImportExample/src/main/res/menu/options_menu.xml
new file mode 100644
index 0000000000..c713700d24
--- /dev/null
+++ b/examples/jsonImportExample/src/main/res/menu/options_menu.xml
@@ -0,0 +1,11 @@
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:context=".RealmGridLayoutActivity">
+
+    <item
+        android:id="@+id/action_reload"
+        android:orderInCategory="100"
+        android:showAsAction="never"
+        android:title="@string/action_reset" />
+
+</menu>
diff --git a/examples/jsonImportExample/src/main/res/values-w820dp/dimens.xml b/examples/jsonImportExample/src/main/res/values-w820dp/dimens.xml
new file mode 100644
index 0000000000..63fc816444
--- /dev/null
+++ b/examples/jsonImportExample/src/main/res/values-w820dp/dimens.xml
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
diff --git a/examples/jsonImportExample/src/main/res/values/dimens.xml b/examples/jsonImportExample/src/main/res/values/dimens.xml
new file mode 100644
index 0000000000..47c8224673
--- /dev/null
+++ b/examples/jsonImportExample/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/examples/jsonImportExample/src/main/res/values/strings.xml b/examples/jsonImportExample/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..5e6e5ad0ad
--- /dev/null
+++ b/examples/jsonImportExample/src/main/res/values/strings.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">Realm Example</string>
+    <string name="action_reset">Reset</string>
+
+</resources>
diff --git a/examples/jsonImportExample/src/main/res/values/styles.xml b/examples/jsonImportExample/src/main/res/values/styles.xml
new file mode 100644
index 0000000000..ff6c9d2c0f
--- /dev/null
+++ b/examples/jsonImportExample/src/main/res/values/styles.xml
@@ -0,0 +1,8 @@
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar">
+        <!-- Customize your theme here. -->
+    </style>
+
+</resources>
diff --git a/json_api.md b/json_api.md
new file mode 100644
index 0000000000..9317554d33
--- /dev/null
+++ b/json_api.md
@@ -0,0 +1,55 @@
+## API Methods
+
+
+### Android
+
+    Realm.createObjectFromJson(Class realmObject, JSONObject json)
+    Realm.createAllFromJson(Class realmObject, JSONArray json)
+
+    Realm.createObjectFromJson(Class realmObject, InputStream json);
+    Realm.createAllFromJson(Class realmObject, InputStream json);
+
+    Realm.createObjectFromJson(Class realmObject, String json);
+    Realm.createAllFromJson(Class realmObject, String json);
+
+
+### Java
+
+*Not implemented yet*
+
+
+## Notes about the JSON API
+
+
+- Import using InputStream only works for API 11+. Methods are annotated as such.
+
+- JSON property names need to match java variable names.
+
+- Import API does not work in standard Java. JSON is only supported from Java 7, and with a
+  different API.
+
+- If import fails, everything up to that point is put in the database (if Realm.commitTransaction()
+  is called). We need a Realm.cancelWriteTransaction() to change this behavior.
+
+- createObject() returns the created Object, createAll() doesn't. Returning it matches the current
+  API, but not being able to for Arrays is annoying. Does it make sense to return created object
+  anyway? As it is already filled.
+
+- Currently two methods are added to RealmObject: populateUsingJsonObject() and
+  populateUsingJsonStream(). They are overridden in the proxy objects with the proper
+  implementations. It would perhaps be better to move these to a separate class, but then it makes
+  it harder to hook it into the Realm object.
+
+
+### Enhancements
+
+- adding Realm.rollback() or Realm.cancelWriteTransaction() will make it possible to abort a faulty
+  import.
+
+- Java 6 does not have Json parsing capabilities. We need to add them ourselves. Perhaps using GSON.
+
+- Realm.createOrUpdateFromJson() would be a natural extension but requires primary key support.
+
+- Consider adding mapping annotations between Json and Java, but is this a Realm responsibility?
+
+- Consider which date representations we should support. There exist a multitude of options.
\ No newline at end of file
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
new file mode 100644
index 0000000000..16c8721bc3
--- /dev/null
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
@@ -0,0 +1,171 @@
+package io.realm.processor;
+
+import com.squareup.javawriter.JavaWriter;
+
+import java.io.IOException;
+import java.util.HashMap;
+
+/**
+ * Helper class for converting between Json types and data types in Java that are supported by Realm.
+ */
+public class RealmJsonTypeHelper {
+
+    private static final HashMap<String, JsonToRealmTypeConverter> JAVA_TO_JSON_TYPES;
+
+    static {
+        JAVA_TO_JSON_TYPES = new HashMap<String, JsonToRealmTypeConverter>();
+
+        JAVA_TO_JSON_TYPES.put("byte", new SimpleTypeConverter("byte", "Int"));
+        JAVA_TO_JSON_TYPES.put("short", new SimpleTypeConverter("short", "Int"));
+        JAVA_TO_JSON_TYPES.put("int", new SimpleTypeConverter("int", "Int"));
+        JAVA_TO_JSON_TYPES.put("long", new SimpleTypeConverter("long", "Long"));
+        JAVA_TO_JSON_TYPES.put("float", new SimpleTypeConverter("float", "Double"));
+        JAVA_TO_JSON_TYPES.put("double", new SimpleTypeConverter("double", "Double"));
+        JAVA_TO_JSON_TYPES.put("boolean", new SimpleTypeConverter("boolean", "Boolean"));
+        JAVA_TO_JSON_TYPES.put("Byte", new SimpleTypeConverter("Byte", "Int"));
+        JAVA_TO_JSON_TYPES.put("Short", new SimpleTypeConverter("Short", "Int"));
+        JAVA_TO_JSON_TYPES.put("Integer", new SimpleTypeConverter("Integer", "Int"));
+        JAVA_TO_JSON_TYPES.put("Long", new SimpleTypeConverter("Long", "Long"));
+        JAVA_TO_JSON_TYPES.put("Float", new SimpleTypeConverter("Float", "Double"));
+        JAVA_TO_JSON_TYPES.put("Double", new SimpleTypeConverter("Double", "Double"));
+        JAVA_TO_JSON_TYPES.put("Boolean", new SimpleTypeConverter("Boolean", "Boolean"));
+        JAVA_TO_JSON_TYPES.put("java.lang.String", new SimpleTypeConverter("String", "String"));
+        JAVA_TO_JSON_TYPES.put("java.util.Date", new JsonToRealmTypeConverter() {
+            @Override
+            public void emitTypeConversion(String fieldName, String fieldType, JavaWriter writer) throws IOException {
+                writer
+                    .emitStatement("long timestamp = json.optLong(\"%s\", -1)", fieldName)
+                    .beginControlFlow("if (timestamp > -1)")
+                        .emitStatement("set%s(new Date(timestamp))", capitaliseFirstChar(fieldName))
+                    .nextControlFlow("else")
+                        .emitStatement("String jsonDate = json.getString(\"%s\")", fieldName)
+                        .emitStatement("set%s(JsonUtils.stringToDate(jsonDate))", capitaliseFirstChar(fieldName))
+                    .endControlFlow();
+            }
+
+            @Override
+            public void emitStreamTypeConversion(String fieldName, String fieldType, JavaWriter writer) throws IOException {
+                writer
+                    .beginControlFlow("if (reader.peek() == JsonToken.NUMBER)")
+                        .emitStatement("long timestamp = reader.nextLong()", fieldName)
+                        .beginControlFlow("if (timestamp > -1)")
+                            .emitStatement("set%s(new Date(timestamp))", capitaliseFirstChar(fieldName))
+                        .endControlFlow()
+                    .nextControlFlow("else")
+                        .emitStatement("set%s(JsonUtils.stringToDate(reader.nextString()))", capitaliseFirstChar(fieldName))
+                    .endControlFlow();
+            }
+        });
+
+        JAVA_TO_JSON_TYPES.put("byte[]", new JsonToRealmTypeConverter() {
+            @Override
+            public void emitTypeConversion(String fieldName, String fieldType, JavaWriter writer) throws IOException {
+                writer.emitStatement("set%s(JsonUtils.stringToBytes(json.getString(\"%s\")))", capitaliseFirstChar(fieldName), fieldName);
+            }
+
+            @Override
+            public void emitStreamTypeConversion(String fieldName, String fieldType, JavaWriter writer) throws IOException {
+                writer.emitStatement("set%s(JsonUtils.stringToBytes(reader.nextString()))", capitaliseFirstChar(fieldName));
+            }
+        });
+    }
+
+    public static void emitFillJavaTypeWithJsonValue(String fieldName, String fieldType, JavaWriter writer) throws IOException {
+        if (JAVA_TO_JSON_TYPES.containsKey(fieldType)) {
+            writer.beginControlFlow("if (json.has(\"%s\"))", fieldName);
+                JAVA_TO_JSON_TYPES.get(fieldType).emitTypeConversion(fieldName, fieldType, writer);
+            writer.endControlFlow();
+        }
+    }
+
+    public static void emitFillRealmObjectWithJsonValue(String fieldName, String fieldTypeCanonicalName, JavaWriter writer) throws IOException {
+        writer
+            .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                .emitStatement("%s obj = getRealm().createObject(%s.class)", fieldTypeCanonicalName, fieldTypeCanonicalName)
+                .emitStatement("obj.populateUsingJsonObject(json.getJSONObject(\"%s\"))", fieldName)
+                .emitStatement("set%s(obj)", capitaliseFirstChar(fieldName))
+            .endControlFlow();
+    }
+
+    public static void emitFillRealmListWithJsonValue(String fieldName, String fieldTypeCanonicalName, JavaWriter writer) throws IOException {
+        writer
+            .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                .emitStatement("JSONArray array = json.getJSONArray(\"%s\")", fieldName)
+                .beginControlFlow("for (int i = 0; i < array.length(); i++)")
+                    .emitStatement("%s obj = getRealm().createObject(%s.class)", fieldTypeCanonicalName, fieldTypeCanonicalName)
+                    .emitStatement("obj.populateUsingJsonObject(array.getJSONObject(i))")
+                    .emitStatement("get%s().add(obj)", capitaliseFirstChar(fieldName))
+                .endControlFlow()
+            .endControlFlow();
+    }
+
+
+    public static void emitFillJavaTypeFromStream(String fieldName, String fieldType, JavaWriter writer) throws IOException {
+        if (JAVA_TO_JSON_TYPES.containsKey(fieldType)) {
+            JAVA_TO_JSON_TYPES.get(fieldType).emitStreamTypeConversion(fieldName, fieldType, writer);
+        }
+    }
+
+    public static void emitFillRealmObjectFromStream(String fieldName, String fieldTypeCanonicalName, JavaWriter writer) throws IOException {
+        writer
+            .emitStatement("%s obj = getRealm().createObject(%s.class)", fieldTypeCanonicalName, fieldTypeCanonicalName)
+            .emitStatement("obj.populateUsingJsonStream(reader)", fieldName)
+            .emitStatement("set%s(obj)", capitaliseFirstChar(fieldName));
+    }
+
+    public static void emitFillRealmListFromStream(String fieldName, String fieldTypeCanonicalName, JavaWriter writer) throws IOException {
+        writer
+            .emitStatement("reader.beginArray()")
+            .beginControlFlow("while (reader.hasNext())")
+                .emitStatement("%s obj = getRealm().createObject(%s.class)", fieldTypeCanonicalName, fieldTypeCanonicalName)
+                .emitStatement("obj.populateUsingJsonStream(reader)")
+                .emitStatement("get%s().add(obj)", capitaliseFirstChar(fieldName))
+            .endControlFlow()
+            .emitStatement("reader.endArray()");
+    }
+
+    private static String capitaliseFirstChar(String input) {
+        return input.substring(0, 1).toUpperCase() + input.substring(1);
+    }
+
+    private static class SimpleTypeConverter implements JsonToRealmTypeConverter {
+
+        private final String castType;
+        private final String jsonType;
+
+        /**
+         * Create a conversion between simple types that can be expressed of the form
+         * RealmObject.setFieldName((<castType>) json.get<jsonType>) or
+         * RealmObject.setFieldName((<castType>) reader.next<jsonType>
+         *
+         * @param castType  Java type to cast to.
+         * @param jsonType  JsonType to get data from.
+         */
+        private SimpleTypeConverter(String castType, String jsonType) {
+            this.castType = castType;
+            this.jsonType = jsonType;
+        }
+
+        @Override
+        public void emitTypeConversion(String fieldName, String fieldType, JavaWriter writer) throws IOException {
+            writer.emitStatement("set%s((%s) json.get%s(\"%s\"))",
+                    capitaliseFirstChar(fieldName),
+                    castType,
+                    jsonType,
+                    fieldName);
+        }
+
+        @Override
+        public void emitStreamTypeConversion(String fieldName, String fieldType, JavaWriter writer) throws IOException {
+            writer.emitStatement("set%s((%s) reader.next%s())",
+                    capitaliseFirstChar(fieldName),
+                    castType,
+                    jsonType);
+        }
+    }
+
+    private interface JsonToRealmTypeConverter {
+        public void emitTypeConversion(String fieldName, String fieldType, JavaWriter writer) throws IOException;
+        public void emitStreamTypeConversion(String fieldName, String fieldType, JavaWriter writer) throws IOException;
+    }
+}
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index bb6f25f438..80d45fe6bd 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -18,6 +18,16 @@
 
 import com.squareup.javawriter.JavaWriter;
 
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.EnumSet;
+import java.util.HashMap;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.Map;
+
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
@@ -26,10 +36,6 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.JavaFileObject;
-import java.io.BufferedWriter;
-import java.io.IOException;
-import java.lang.String;
-import java.util.*;
 
 public class RealmProxyClassGenerator {
     private ProcessingEnvironment processingEnvironment;
@@ -41,6 +47,11 @@
     private static final String TABLE_PREFIX = "class_";
     private static final String PROXY_SUFFIX = "RealmProxy";
 
+    private Elements elementUtils;
+    private Types typeUtils;
+    private TypeMirror realmObject;
+    private DeclaredType realmList;
+
     public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, String className, String packageName, List<VariableElement> fields, List<VariableElement> fieldsToIndex) {
         this.processingEnvironment = processingEnvironment;
         this.className = className;
@@ -200,26 +211,32 @@ public void generate() throws IOException, UnsupportedOperationException {
         JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedClassName);
         JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
 
-        Elements elementUtils = processingEnvironment.getElementUtils();
-        Types typeUtils = processingEnvironment.getTypeUtils();
+        elementUtils = processingEnvironment.getElementUtils();
+        typeUtils = processingEnvironment.getTypeUtils();
 
-        TypeMirror realmObject = elementUtils.getTypeElement("io.realm.RealmObject").asType();
-        DeclaredType realmList = typeUtils.getDeclaredType(elementUtils.getTypeElement("io.realm.RealmList"), typeUtils.getWildcardType(null, null));
+        realmObject = elementUtils.getTypeElement("io.realm.RealmObject").asType();
+        realmList = typeUtils.getDeclaredType(elementUtils.getTypeElement("io.realm.RealmList"), typeUtils.getWildcardType(null, null));
 
         // Set source code indent to 4 spaces
         writer.setIndent("    ");
 
         writer.emitPackage(REALM_PACKAGE_NAME)
                 .emitEmptyLine();
-
         writer.emitImports(
                 "io.realm.internal.ColumnType",
                 "io.realm.internal.Table",
                 "io.realm.internal.ImplicitTransaction",
                 "io.realm.internal.Row",
                 "io.realm.internal.LinkView",
+                "io.realm.internal.json.JsonUtils",
                 "io.realm.RealmList",
                 "io.realm.RealmObject",
+                "org.json.JSONObject",
+                "org.json.JSONException",
+                "org.json.JSONArray",
+                "android.util.JsonReader",
+                "android.util.JsonToken",
+                "java.io.IOException",
                 "java.util.*",
                 packageName + ".*")
                 .emitEmptyLine();
@@ -604,11 +621,105 @@ else if (typeUtils.isAssignable(field.asType(), realmObject) || typeUtils.isAssi
         writer.endMethod();
         writer.emitEmptyLine();
 
+        // Add JSON methods
+        emitPopulateUsingJsonObjectMethod(writer);
+        emitPopulateUsingJsonStreamMethod(writer);
+
         // End the class definition
         writer.endType();
         writer.close();
     }
 
+    private void emitPopulateUsingJsonObjectMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation(Override.class);
+        writer.beginMethod(
+                "void",
+                "populateUsingJsonObject",
+                EnumSet.of(Modifier.PROTECTED),
+                Arrays.asList("JSONObject", "json"),
+                Arrays.asList("JSONException"));
+
+        for (VariableElement field : fields) {
+            String fieldName = field.getSimpleName().toString();
+            String fieldTypeCanonicalName = field.asType().toString();
+            if (typeUtils.isAssignable(field.asType(), realmObject)) {
+                RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(
+                        fieldName,
+                        fieldTypeCanonicalName,
+                        writer);
+
+            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
+                RealmJsonTypeHelper.emitFillRealmListWithJsonValue(
+                        fieldName,
+                        ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
+                        writer);
+
+            } else {
+                RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
+                        fieldName,
+                        fieldTypeCanonicalName,
+                        writer);
+            }
+
+        }
+
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitPopulateUsingJsonStreamMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation(Override.class);
+        writer.beginMethod(
+                "void",
+                "populateUsingJsonStream",
+                EnumSet.of(Modifier.PROTECTED),
+                Arrays.asList("JsonReader", "reader"),
+                Arrays.asList("IOException"));
+
+        writer.emitStatement("reader.beginObject()");
+        writer.beginControlFlow("while (reader.hasNext())");
+        writer.emitStatement("String name = reader.nextName()");
+
+        for (int i = 0; i < fields.size(); i++) {
+            VariableElement field = fields.get(i);
+            String fieldName = field.getSimpleName().toString();
+            String fieldTypeCanonicalName = field.asType().toString();
+
+            if (i == 0) {
+                writer.beginControlFlow("if (name.equals(\"%s\") && reader.peek() != JsonToken.NULL)", fieldName);
+            } else {
+                writer.nextControlFlow("else if (name.equals(\"%s\")  && reader.peek() != JsonToken.NULL)", fieldName);
+            }
+
+            if (typeUtils.isAssignable(field.asType(), realmObject)) {
+                RealmJsonTypeHelper.emitFillRealmObjectFromStream(
+                        fieldName,
+                        fieldTypeCanonicalName,
+                        writer);
+
+            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
+                RealmJsonTypeHelper.emitFillRealmListFromStream(
+                        fieldName,
+                        ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
+                        writer);
+
+            } else {
+                RealmJsonTypeHelper.emitFillJavaTypeFromStream(
+                        fieldName,
+                        fieldTypeCanonicalName,
+                        writer);
+            }
+        }
+
+        writer.nextControlFlow("else");
+        writer.emitStatement("reader.skipValue()");
+        writer.endControlFlow();
+        writer.endControlFlow();
+        writer.emitStatement("reader.endObject()");
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
     private static String capitaliseFirstChar(String input) {
         return input.substring(0, 1).toUpperCase() + input.substring(1);
     }
diff --git a/realm/src/androidTest/assets/all_simple_types.json b/realm/src/androidTest/assets/all_simple_types.json
new file mode 100644
index 0000000000..f21ddd70e1
--- /dev/null
+++ b/realm/src/androidTest/assets/all_simple_types.json
@@ -0,0 +1,8 @@
+{
+	"columnString" : "String",
+	"columnLong" : 1,
+	"columnFloat" : 1.23,
+	"columnDouble" : 1.23,
+	"columnBoolean" : true,
+	"columnBinary" : "AQID"
+}
\ No newline at end of file
diff --git a/realm/src/androidTest/assets/all_types_null.json b/realm/src/androidTest/assets/all_types_null.json
new file mode 100644
index 0000000000..3b4cbdeb88
--- /dev/null
+++ b/realm/src/androidTest/assets/all_types_null.json
@@ -0,0 +1,11 @@
+{
+	"columnString" : null,
+	"columnLong" : null,
+	"columnFloat" : null,
+	"columnDouble" : null,
+	"columnBoolean" : null,
+	"columnBinary" : null,
+	"columnDate" : null,
+	"columnRealmObject" : null,
+	"columnRealmList" : null
+}
\ No newline at end of file
diff --git a/realm/src/androidTest/assets/array.json b/realm/src/androidTest/assets/array.json
new file mode 100644
index 0000000000..1c3c18ef97
--- /dev/null
+++ b/realm/src/androidTest/assets/array.json
@@ -0,0 +1,5 @@
+[
+    { "name" : "Fido-1" },
+    { "name" : "Fido-2" },
+    { "name" : "Fido-3" }
+]
\ No newline at end of file
diff --git a/realm/src/androidTest/assets/date_as_long.json b/realm/src/androidTest/assets/date_as_long.json
new file mode 100644
index 0000000000..51ee039a6a
--- /dev/null
+++ b/realm/src/androidTest/assets/date_as_long.json
@@ -0,0 +1,3 @@
+{
+    "columnDate" : 1000
+}
\ No newline at end of file
diff --git a/realm/src/androidTest/assets/date_as_string.json b/realm/src/androidTest/assets/date_as_string.json
new file mode 100644
index 0000000000..2892658ef4
--- /dev/null
+++ b/realm/src/androidTest/assets/date_as_string.json
@@ -0,0 +1,3 @@
+{
+    "columnDate" : "/Date(1000)/"
+}
\ No newline at end of file
diff --git a/realm/src/androidTest/assets/realmlist.json b/realm/src/androidTest/assets/realmlist.json
new file mode 100644
index 0000000000..c0fc1c7e00
--- /dev/null
+++ b/realm/src/androidTest/assets/realmlist.json
@@ -0,0 +1,7 @@
+{
+    "columnRealmList" : [
+        { "name" : "Fido-1" },
+        { "name" : "Fido-2" },
+        { "name" : "Fido-3" }
+    ]
+}
\ No newline at end of file
diff --git a/realm/src/androidTest/assets/realmlist_empty.json b/realm/src/androidTest/assets/realmlist_empty.json
new file mode 100644
index 0000000000..b9b4587203
--- /dev/null
+++ b/realm/src/androidTest/assets/realmlist_empty.json
@@ -0,0 +1,3 @@
+{
+    "columnRealmList" : []
+}
\ No newline at end of file
diff --git a/realm/src/androidTest/assets/single_child_object.json b/realm/src/androidTest/assets/single_child_object.json
new file mode 100644
index 0000000000..b714b8073a
--- /dev/null
+++ b/realm/src/androidTest/assets/single_child_object.json
@@ -0,0 +1,3 @@
+{
+    "columnRealmObject" : { "name" : "Fido" }
+}
\ No newline at end of file
diff --git a/realm/src/androidTest/java/io/realm/RealmJsonTest.java b/realm/src/androidTest/java/io/realm/RealmJsonTest.java
new file mode 100644
index 0000000000..1df1027670
--- /dev/null
+++ b/realm/src/androidTest/java/io/realm/RealmJsonTest.java
@@ -0,0 +1,435 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import android.content.res.AssetManager;
+import android.test.AndroidTestCase;
+import android.util.Base64;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Date;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.AnnotationTypes;
+import io.realm.entities.Dog;
+import io.realm.exceptions.RealmException;
+
+import static io.realm.internal.test.ExtraTests.assertArrayEquals;
+
+public class RealmJsonTest extends AndroidTestCase {
+
+    protected Realm testRealm;
+
+    @Override
+    protected void setUp() throws Exception {
+        testRealm = Realm.getInstance(getContext());
+        testRealm.beginTransaction();
+        testRealm.clear(AllTypes.class);
+        testRealm.clear(Dog.class);
+        testRealm.clear(AnnotationTypes.class);
+        testRealm.commitTransaction();
+    }
+
+    private InputStream loadJsonFromAssets(String file) {
+        AssetManager assetManager = getContext().getAssets();
+        InputStream input = null;
+        try {
+            input = assetManager.open(file);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        } finally {
+            return input;
+        }
+    }
+
+    public void testImportJSon_nullObject() {
+        testRealm.createObjectFromJson(AllTypes.class, (JSONObject) null);
+        assertEquals(0, testRealm.allObjects(AllTypes.class).size());
+    }
+
+    public void testImportJSon_nullArray() {
+        testRealm.createAllFromJson(AllTypes.class, (JSONArray) null);
+        assertEquals(0, testRealm.allObjects(AllTypes.class).size());
+
+    }
+
+    public void testImportJSon_allSimpSimpleObjectAllTypes() throws JSONException {
+        JSONObject json = new JSONObject();
+        json.put("columnString", "String");
+        json.put("columnLong", 1l);
+        json.put("columnFloat", 1.23f);
+        json.put("columnDouble", 1.23d);
+        json.put("columnBoolean", true);
+        json.put("columnBinary", new String(Base64.encode(new byte[] {1,2,3}, Base64.DEFAULT)));
+
+        testRealm.beginTransaction();
+        testRealm.createObjectFromJson(AllTypes.class, json);
+        testRealm.commitTransaction();
+        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
+
+        // Check that all primitive types are imported correctly
+        assertEquals("String", obj.getColumnString());
+        assertEquals(1l, obj.getColumnLong());
+        assertEquals(1.23f, obj.getColumnFloat());
+        assertEquals(1.23d, obj.getColumnDouble());
+        assertEquals(true, obj.isColumnBoolean());
+        assertArrayEquals(new byte[]{1, 2, 3}, obj.getColumnBinary());
+    }
+
+    public void testImportJSon_dateAsLong() throws JSONException {
+        JSONObject json = new JSONObject();
+        json.put("columnDate", 1000L); // Realm operates at seconds level granularity
+
+        testRealm.beginTransaction();
+        testRealm.createObjectFromJson(AllTypes.class, json);
+        testRealm.commitTransaction();
+
+        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
+        assertEquals(new Date(1000), obj.getColumnDate());
+    }
+
+    public void testImportJSon_dateAsString() throws JSONException {
+        JSONObject json = new JSONObject();
+        json.put("columnDate", "/Date(1000)/");
+
+        testRealm.beginTransaction();
+        testRealm.createObjectFromJson(AllTypes.class, json);
+        testRealm.commitTransaction();
+
+        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
+        assertEquals(new Date(1000), obj.getColumnDate());
+    }
+
+    public void testImportJSon_childObject() throws JSONException {
+        JSONObject allTypesObject = new JSONObject();
+        JSONObject dogObject = new JSONObject();
+        dogObject.put("name", "Fido");
+        allTypesObject.put("columnRealmObject", dogObject);
+
+        testRealm.beginTransaction();
+        testRealm.createObjectFromJson(AllTypes.class, allTypesObject);
+        testRealm.commitTransaction();
+
+        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
+        assertEquals("Fido", obj.getColumnRealmObject().getName());
+    }
+
+    public void testImportJSon_childObjectList() throws JSONException {
+        JSONObject allTypesObject = new JSONObject();
+        JSONObject dog1 = new JSONObject(); dog1.put("name", "Fido-1");
+        JSONObject dog2 = new JSONObject(); dog2.put("name", "Fido-2");
+        JSONObject dog3 = new JSONObject(); dog3.put("name", "Fido-3");
+        JSONArray dogList = new JSONArray();
+        dogList.put(dog1);
+        dogList.put(dog2);
+        dogList.put(dog3);
+
+        allTypesObject.put("columnRealmList", dogList);
+
+        testRealm.beginTransaction();
+        testRealm.createObjectFromJson(AllTypes.class, allTypesObject);
+        testRealm.commitTransaction();
+
+        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
+        assertEquals(3, obj.getColumnRealmList().size());
+        assertEquals("Fido-3", obj.getColumnRealmList().get(2).getName());
+    }
+
+    public void testImportJSon_emptyChildObjectList() throws JSONException {
+        JSONObject allTypesObject = new JSONObject();
+        JSONArray dogList = new JSONArray();
+
+        allTypesObject.put("columnRealmList", dogList);
+
+        testRealm.beginTransaction();
+        testRealm.createObjectFromJson(AllTypes.class, allTypesObject);
+        testRealm.commitTransaction();
+
+        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
+        assertEquals(0, obj.getColumnRealmList().size());
+    }
+
+    public void testImportJsonString_simpleObject() {
+        testRealm.beginTransaction();
+        Dog dog = testRealm.createObjectFromJson(Dog.class, "{ name: \"Foo\" }");
+        testRealm. commitTransaction();
+
+        assertEquals("Foo", dog.getName());
+        assertEquals("Foo", testRealm.allObjects(Dog.class).first().getName());
+    }
+
+
+    public void testImportJsonString_faultyJson() {
+        testRealm.beginTransaction();
+        try {
+            Dog dog = testRealm.createObjectFromJson(Dog.class, "{ name \"Foo\" }");
+        } catch (RealmException e) {
+            assertTrue(true);
+            return;
+        } finally {
+            testRealm.commitTransaction();
+        }
+
+        fail("Doesn't handle faulty JSON properly");
+    }
+
+
+    public void testImportJsonString_null() {
+        testRealm.beginTransaction();
+        Dog dog = testRealm.createObjectFromJson(Dog.class, (String) null);
+        testRealm.commitTransaction();
+
+        assertNull(dog);
+        assertEquals(0, testRealm.allObjects(Dog.class).size());
+    }
+
+    public void testImportJsonArray_empty() throws JSONException {
+        JSONArray array = new JSONArray();
+        testRealm.beginTransaction();
+        testRealm.createAllFromJson(AllTypes.class, array);
+        testRealm.commitTransaction();
+
+        assertEquals(0, testRealm.allObjects(AllTypes.class).size());
+    }
+
+    public void testImportJsonArray() throws JSONException {
+        JSONObject dog1 = new JSONObject(); dog1.put("name", "Fido-1");
+        JSONObject dog2 = new JSONObject(); dog2.put("name", "Fido-2");
+        JSONObject dog3 = new JSONObject(); dog3.put("name", "Fido-3");
+        JSONArray dogList = new JSONArray();
+        dogList.put(dog1);
+        dogList.put(dog2);
+        dogList.put(dog3);
+
+        testRealm.beginTransaction();
+        testRealm.createAllFromJson(Dog.class, dogList);
+        testRealm.commitTransaction();
+
+        assertEquals(3, testRealm.allObjects(Dog.class).size());
+        assertEquals(1, testRealm.where(Dog.class).equalTo("name", "Fido-3").findAll().size());
+    }
+
+    public void testImportJson_nullValues() throws JSONException {
+        JSONObject json = new JSONObject();
+        json.put("columnString", null);
+        json.put("columnLong", null);
+        json.put("columnFloat", null);
+        json.put("columnDouble", null);
+        json.put("columnBoolean", null);
+        json.put("columnBinary", null);
+        json.put("columnDate", null);
+        json.put("columnRealmObject", null);
+        json.put("columnRealmList", null);
+
+        testRealm.beginTransaction();
+        testRealm.createObjectFromJson(AllTypes.class, json);
+        testRealm.commitTransaction();
+        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
+
+        // Check that all primitive types are imported correctly
+        assertEquals("", obj.getColumnString());
+        assertEquals(0L, obj.getColumnLong());
+        assertEquals(0f, obj.getColumnFloat());
+        assertEquals(0d, obj.getColumnDouble());
+        assertEquals(false, obj.isColumnBoolean());
+        assertEquals(new Date(0), obj.getColumnDate());
+        assertArrayEquals(new byte[0], obj.getColumnBinary());
+        assertNull(obj.getColumnRealmObject());
+        assertEquals(0, obj.getColumnRealmList().size());
+    }
+
+    // Test that given an exception everything up to the exception is saved
+    public void testImportJson_jsonexception() throws JSONException {
+        JSONObject json = new JSONObject();
+        json.put("columnString", "Foo");
+        json.put("columnDate", "Boom");
+
+        try {
+            testRealm.beginTransaction();
+            testRealm.createObjectFromJson(AllTypes.class, json);
+        } catch (Exception e) {
+            // Ignore
+        } finally {
+            testRealm.commitTransaction();
+        }
+
+        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
+        assertEquals("Foo", obj.getColumnString());
+        assertEquals(new Date(0), obj.getColumnDate());
+    }
+
+    public void testImportJson_respectIgnoredFields() throws JSONException {
+        JSONObject json = new JSONObject();
+        json.put("indexString", "Foo");
+        json.put("notIndexString", "Bar");
+        json.put("ignoreString", "Baz");
+
+        testRealm.beginTransaction();
+        testRealm.createObjectFromJson(AnnotationTypes.class, json);
+        testRealm.commitTransaction();
+
+        AnnotationTypes annotationsObject = testRealm.allObjects(AnnotationTypes.class).first();
+        assertEquals("Foo", annotationsObject.getIndexString());
+        assertEquals(null, annotationsObject.getIgnoreString());
+    }
+
+    public void testImportJsonArrayString_simpleArray() {
+        testRealm.beginTransaction();
+        testRealm.createAllFromJson(Dog.class, "[{ name: \"Foo\" }, { name: \"Bar\" }]");
+        testRealm. commitTransaction();
+
+        assertEquals(2, testRealm.allObjects(Dog.class).size());
+    }
+
+    public void testImportJsonArrayString_faultyJson() {
+        testRealm.beginTransaction();
+        try {
+            testRealm.createAllFromJson(Dog.class, "[{ name : \"Foo\" ]");
+        } catch (RealmException e) {
+            assertTrue(true);
+            return;
+        } finally {
+            testRealm.commitTransaction();
+        }
+
+        fail("Doesn't handle faulty JSON properly");
+    }
+
+
+    public void testImportJsonArrayString_null() {
+        testRealm.beginTransaction();
+        testRealm.createAllFromJson(Dog.class, (String) null);
+        testRealm.commitTransaction();
+
+        assertEquals(0, testRealm.allObjects(Dog.class).size());
+    }
+
+   public void testImportStream_null() throws IOException {
+        testRealm.createAllFromJson(AllTypes.class, (InputStream) null);
+        assertEquals(0, testRealm.allObjects(AllTypes.class).size());
+    }
+
+    public void testImportStream_allSimpleTypes() throws IOException {
+        InputStream in = loadJsonFromAssets("all_simple_types.json");
+        testRealm.beginTransaction();
+        testRealm.createObjectFromJson(AllTypes.class, in);
+        testRealm.commitTransaction();
+        in.close();
+
+        // Check that all primitive types are imported correctly
+        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
+        assertEquals("String", obj.getColumnString());
+        assertEquals(1l, obj.getColumnLong());
+        assertEquals(1.23f, obj.getColumnFloat());
+        assertEquals(1.23d, obj.getColumnDouble());
+        assertEquals(true, obj.isColumnBoolean());
+        assertArrayEquals(new byte[]{1, 2, 3}, obj.getColumnBinary());
+    }
+
+    public void testImportStream_DateAsLong() throws IOException {
+        InputStream in = loadJsonFromAssets("date_as_long.json");
+        testRealm.beginTransaction();
+        testRealm.createObjectFromJson(AllTypes.class, in);
+        testRealm.commitTransaction();
+        in.close();
+
+        // Check that all primitive types are imported correctly
+        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
+        assertEquals(new Date(1000), obj.getColumnDate());
+    }
+
+    public void testImportStream_DateAsString() throws IOException {
+        InputStream in = loadJsonFromAssets("date_as_string.json");
+        testRealm.beginTransaction();
+        testRealm.createObjectFromJson(AllTypes.class, in);
+        testRealm.commitTransaction();
+        in.close();
+
+        // Check that all primitive types are imported correctly
+        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
+        assertEquals(new Date(1000), obj.getColumnDate());
+    }
+
+    public void testImportStream_childObject() throws IOException {
+        InputStream in = loadJsonFromAssets("single_child_object.json");
+        testRealm.beginTransaction();
+        testRealm.createObjectFromJson(AllTypes.class, in);
+        testRealm.commitTransaction();
+        in.close();
+
+        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
+        assertEquals("Fido", obj.getColumnRealmObject().getName());
+    }
+
+    public void testImportStream_emptyChildObjectList() throws IOException {
+        InputStream in = loadJsonFromAssets("realmlist_empty.json");
+        testRealm.beginTransaction();
+        testRealm.createObjectFromJson(AllTypes.class, in);
+        testRealm.commitTransaction();
+        in.close();
+
+        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
+        assertEquals(0, obj.getColumnRealmList().size());
+    }
+
+    public void testImportStream_childObjectList() throws IOException {
+        InputStream in = loadJsonFromAssets("realmlist.json");
+        testRealm.beginTransaction();
+        testRealm.createObjectFromJson(AllTypes.class, in);
+        testRealm.commitTransaction();
+        in.close();
+
+        assertEquals(3, testRealm.allObjects(Dog.class).size());
+        assertEquals(1, testRealm.where(Dog.class).equalTo("name", "Fido-3").findAll().size());
+    }
+
+    public void testImportStream_array() throws IOException {
+        InputStream in = loadJsonFromAssets("array.json");
+
+        testRealm.beginTransaction();
+        testRealm.createAllFromJson(Dog.class, in);
+        testRealm.commitTransaction();
+
+        assertEquals(3, testRealm.allObjects(Dog.class).size());
+        assertEquals(1, testRealm.where(Dog.class).equalTo("name", "Fido-3").findAll().size());
+    }
+
+
+    public void testImportStream_nullValues() throws IOException {
+        InputStream in = loadJsonFromAssets("all_types_null.json");
+        testRealm.beginTransaction();
+        testRealm.createObjectFromJson(AllTypes.class, in);
+        testRealm.commitTransaction();
+        in.close();
+
+        // Check that all primitive types are imported correctly
+        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
+        assertEquals("", obj.getColumnString());
+        assertEquals(0L, obj.getColumnLong());
+        assertEquals(0f, obj.getColumnFloat());
+        assertEquals(0d, obj.getColumnDouble());
+        assertEquals(false, obj.isColumnBoolean());
+        assertEquals(new Date(0), obj.getColumnDate());
+        assertArrayEquals(new byte[0], obj.getColumnBinary());
+        assertNull(obj.getColumnRealmObject());
+        assertEquals(0, obj.getColumnRealmList().size());
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/RealmObjectTest.java b/realm/src/androidTest/java/io/realm/RealmObjectTest.java
index bd3279ea94..9b773aa410 100644
--- a/realm/src/androidTest/java/io/realm/RealmObjectTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmObjectTest.java
@@ -46,7 +46,7 @@ public void testRealmGetRowReturnsValidRow() {
 
         testRealm.commitTransaction();
         assertNotNull("RealmObject.realmGetRow returns zero ", row);
-        assertEquals("RealmObject.realmGetRow seems to return wrong row type: ", 8, row.getColumnCount());
+        assertEquals("RealmObject.realmGetRow seems to return wrong row type: ", 9, row.getColumnCount());
     }
 
     public void testStringEncoding() {
diff --git a/realm/src/androidTest/java/io/realm/entities/AllTypes.java b/realm/src/androidTest/java/io/realm/entities/AllTypes.java
index 14984fc9d0..8eaf25c60f 100644
--- a/realm/src/androidTest/java/io/realm/entities/AllTypes.java
+++ b/realm/src/androidTest/java/io/realm/entities/AllTypes.java
@@ -18,6 +18,7 @@
 
 import java.util.Date;
 
+import io.realm.RealmList;
 import io.realm.RealmObject;
 
 public class AllTypes extends RealmObject {
@@ -29,6 +30,7 @@
     private Date columnDate;
     private byte[] columnBinary;
     private Dog columnRealmObject;
+    private RealmList<Dog> columnRealmList;
 
     public String getColumnString() {
         return columnString;
@@ -93,4 +95,12 @@ public Dog getColumnRealmObject() {
     public void setColumnRealmObject(Dog columnRealmObject) {
         this.columnRealmObject = columnRealmObject;
     }
+
+    public RealmList<Dog> getColumnRealmList() {
+        return columnRealmList;
+    }
+
+    public void setColumnRealmList(RealmList<Dog> columnRealmList) {
+        this.columnRealmList = columnRealmList;
+    }
 }
diff --git a/realm/src/androidTest/java/io/realm/entities/AnnotationTypes.java b/realm/src/androidTest/java/io/realm/entities/AnnotationTypes.java
index 35b731e749..95d3e9ac35 100644
--- a/realm/src/androidTest/java/io/realm/entities/AnnotationTypes.java
+++ b/realm/src/androidTest/java/io/realm/entities/AnnotationTypes.java
@@ -50,4 +50,6 @@ public String getIgnoreString() {
     public void setIgnoreString(String ignoreString) {
         this.ignoreString = ignoreString;
     }
+
+
 }
diff --git a/realm/src/androidTest/java/io/realm/internal/test/ExtraTests.java b/realm/src/androidTest/java/io/realm/internal/test/ExtraTests.java
index a3b8e15796..77660e48ec 100644
--- a/realm/src/androidTest/java/io/realm/internal/test/ExtraTests.java
+++ b/realm/src/androidTest/java/io/realm/internal/test/ExtraTests.java
@@ -7,8 +7,12 @@
 import static junit.framework.Assert.fail;
 
 public class ExtraTests {
-    public static void assertArrayEquals(Object[] expecteds, Object[] actuals)
-    {
+
+    public static void assertArrayEquals(Object[] expecteds, Object[] actuals) {
+        new ExactComparisonCriteria().arrayEquals(null, expecteds, actuals);
+    }
+
+    public static void assertArrayEquals(byte[] expecteds, byte[] actuals) {
         new ExactComparisonCriteria().arrayEquals(null, expecteds, actuals);
     }
 
diff --git a/realm/src/main/java/io/realm/Realm.java b/realm/src/main/java/io/realm/Realm.java
index 2cedd8d8cf..3e6f0e349f 100644
--- a/realm/src/main/java/io/realm/Realm.java
+++ b/realm/src/main/java/io/realm/Realm.java
@@ -16,13 +16,22 @@
 
 package io.realm;
 
+import android.annotation.TargetApi;
 import android.content.Context;
+import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+import android.util.JsonReader;
 import android.util.Log;
 
+import org.json.JSONArray;
+import org.json.JSONObject;
+
 import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -91,8 +100,8 @@
     private final int id;
     private final SharedGroup sharedGroup;
     private final ImplicitTransaction transaction;
-    private final Map<Class<?>, String> simpleClassNames = new HashMap<Class<?>, String>();
-    private final Map<String, Class<?>> generatedClasses = new HashMap<String, Class<?>>();
+    private final Map<Class<?>, String> simpleClassNames = new HashMap<Class<?>, String>(); // Map between original class and their class name
+    private final Map<String, Class<?>> generatedClasses = new HashMap<String, Class<?>>(); // Map between generated class names and their implementation
     private final Map<Class<?>, Constructor> constructors = new HashMap<Class<?>, Constructor>();
     private final Map<Class<?>, Method> initTableMethods = new HashMap<Class<?>, Method>();
     private final Map<Class<?>, Constructor> generatedConstructors = new HashMap<Class<?>, Constructor>();
@@ -397,7 +406,7 @@ private static Realm createAndValidate(String absolutePath, byte[] key, boolean
                 for (String className : proxyClasses) {
                     String[] splitted = className.split("\\.");
                     String modelClassName = splitted[splitted.length - 1];
-                    String generatedClassName = "io.realm." + modelClassName + "RealmProxy";
+                    String generatedClassName = getProxyClassName(modelClassName);
                     Class<?> generatedClass;
                     try {
                         generatedClass = Class.forName(generatedClassName);
@@ -475,6 +484,145 @@ private static Realm createAndValidate(String absolutePath, byte[] key, boolean
         return realm;
     }
 
+    /**
+     * Create a matching Realm object for each object in a JSON array. Unknown JSON properties are
+     * ignored. This must be done inside a transaction.
+     *
+     * @param clazz Type of Realm objects to create.
+     * @param json  Array where each JSONObject must map to the chosen class.
+     *
+     * @throws RealmException if mapping from JSON fail.
+     */
+    public <E extends RealmObject> void createAllFromJson(Class<E> clazz, JSONArray json) {
+        if (clazz == null || json == null) return;
+
+        for (int i = 0; i < json.length(); i++) {
+            E obj = createObject(clazz);
+            try {
+                obj.populateUsingJsonObject(json.getJSONObject(i));
+            } catch (Exception e) {
+                throw new RealmException("Could not map Json", e);
+            }
+        }
+    }
+
+    /**
+     * Create a matching Realm object for each object in a JSON array. Unknown JSON properties are
+     * ignored. This must be done inside a transaction.
+     *
+     * @param clazz Type of Realm objects to create.
+     * @param json  JSON array as a String where each object can map to the chosen class.
+     *
+     * @throws RealmException if mapping from JSON failed.
+     */
+    public <E extends RealmObject> void createAllFromJson(Class<E> clazz, String json) {
+        if (clazz == null || json == null || json.length() == 0) return;
+
+        JSONArray arr;
+        try {
+            arr = new JSONArray(json);
+        } catch (Exception e) {
+            throw new RealmException("Could not create JSON array from string", e);
+        }
+
+        createAllFromJson(clazz, arr);
+    }
+
+    /**
+     * Create a Realm object for each object in a JSON array. Unknown properties are
+     * ignored. This must be done inside a transaction.
+     *
+     * @param clazz         Type of Realm objects created.
+     * @param inputStream   JSON array as a InputStream. All objects in the array must be of the
+     *                      chosen class.
+     *
+     * @throws RealmException if the mapping from JSON failed.
+     * @throws IOException if something was wrong with the input stream.
+     */
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public <E extends RealmObject> void createAllFromJson(Class<E> clazz, InputStream inputStream) throws IOException {
+        if (clazz == null || inputStream == null) return;
+
+        JsonReader reader = new JsonReader(new InputStreamReader(inputStream, "UTF-8"));
+        reader.beginArray();
+        while (reader.hasNext()) {
+            E obj = createObject(clazz);
+            obj.populateUsingJsonStream(reader);
+        }
+        reader.endArray();
+        reader.close();
+    }
+
+    /**
+     * Create a Realm object prefilled with data from a JSON object. Unknown JSON properties are
+     * ignored. This must be done inside a transaction.
+     *
+     * @param clazz Type of Realm object to create.
+     * @param json  JSONObject with object data.
+     * @return Created object or null if no json data was provided.
+     *
+     * @throws RealmException if the mapping from JSON fails.
+     */
+    public <E extends RealmObject> E createObjectFromJson(Class<E> clazz, JSONObject json) {
+        if (clazz == null || json == null) return null;
+
+        E obj = createObject(clazz);
+        try {
+            obj.populateUsingJsonObject(json);
+        } catch (Exception e) {
+            throw new RealmException("Could not map Json", e);
+        }
+
+        return obj;
+    }
+
+    /**
+     * Create a Realm object prefilled with data from a JSON object. Unknown JSON properties are
+     * ignored. This must be done inside a transaction.
+     *
+     * @param clazz Type of Realm object to create.
+     * @param json  JSON string with object data.
+     * @return Created object or null if json string was empty or null.
+     *
+     * @throws RealmException if mapping to json failed.
+     */
+    public <E extends RealmObject> E createObjectFromJson(Class<E> clazz, String json) {
+        if (clazz == null || json == null || json.length() == 0) return null;
+
+        JSONObject obj;
+        try {
+            obj = new JSONObject(json);
+        } catch (Exception e) {
+            throw new RealmException("Could not create Json object from string", e);
+        }
+
+        return createObjectFromJson(clazz, obj);
+    }
+
+
+
+    /**
+     * Create a Realm object prefilled with data from a JSON object. Unknown JSON properties are
+     * ignored. This must be done inside a transaction.
+     *
+     * @param clazz         Type of Realm object to create.
+     * @param inputStream   JSON object data as a InputStream.
+     * @return Created object or null if json string was empty or null.
+     *
+     * @throws RealmException if the mapping from JSON failed.
+     * @throws IOException if something was wrong with the input stream.
+     */
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public <E extends RealmObject> E createObjectFromJson(Class<E> clazz, InputStream inputStream) throws IOException {
+        if (inputStream == null || clazz == null) return null;
+
+        JsonReader reader = new JsonReader(new InputStreamReader(inputStream, "UTF-8"));
+        E obj = createObject(clazz);
+        obj.populateUsingJsonStream(reader);
+        reader.close();
+        return obj;
+    }
+
     /**
      * Instantiates and adds a new object to the realm
      *
@@ -491,7 +639,7 @@ private static Realm createAndValidate(String absolutePath, byte[] key, boolean
                 simpleClassName = clazz.getSimpleName();
                 simpleClassNames.put(clazz, simpleClassName);
             }
-            String generatedClassName = "io.realm." + simpleClassName + "RealmProxy";
+            String generatedClassName = getProxyClassName(simpleClassName);
 
             Class<?> generatedClass = generatedClasses.get(generatedClassName);
             if (generatedClass == null) {
@@ -556,7 +704,7 @@ private static Realm createAndValidate(String absolutePath, byte[] key, boolean
                 simpleClassName = clazz.getSimpleName();
                 simpleClassNames.put(clazz, simpleClassName);
             }
-            String generatedClassName = "io.realm." + simpleClassName + "RealmProxy";
+            String generatedClassName = getProxyClassName(simpleClassName);
 
 
             Class<?> generatedClass = generatedClasses.get(generatedClassName);
@@ -598,6 +746,10 @@ private static Realm createAndValidate(String absolutePath, byte[] key, boolean
         return result;
     }
 
+    private static String getProxyClassName(String simpleClassName) {
+        return "io.realm." + simpleClassName + "RealmProxy";
+    }
+
     boolean contains(Class<?> clazz) {
         String simpleClassName = simpleClassNames.get(clazz);
         if (simpleClassName == null) {
diff --git a/realm/src/main/java/io/realm/RealmObject.java b/realm/src/main/java/io/realm/RealmObject.java
index b6fb989e18..fed2576abf 100644
--- a/realm/src/main/java/io/realm/RealmObject.java
+++ b/realm/src/main/java/io/realm/RealmObject.java
@@ -16,8 +16,16 @@
 
 package io.realm;
 
-import io.realm.internal.Row;
+import android.util.JsonReader;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.io.InputStream;
+
 import io.realm.annotations.RealmClass;
+import io.realm.internal.Row;
 
 /**
  * In Realm you define your model classes by sub-classing RealmObject and adding fields to be
@@ -52,4 +60,12 @@ public void removeFromRealm() {
         }
         row.getTable().remove(row.getIndex());
     }
+
+    protected void populateUsingJsonObject(JSONObject json) throws JSONException {
+        throw new IllegalStateException("Only use this method on objects created or fetched in a Realm. Realm.createObject() or Realm.where()");
+    }
+
+    protected void populateUsingJsonStream(JsonReader json) throws IOException {
+        throw new IllegalStateException("Only use this method on objects created or fetched in a Realm. Realm.createObject() or Realm.where()");
+    }
 }
diff --git a/realm/src/main/java/io/realm/exceptions/RealmException.java b/realm/src/main/java/io/realm/exceptions/RealmException.java
index 04873de473..ce8057fd66 100644
--- a/realm/src/main/java/io/realm/exceptions/RealmException.java
+++ b/realm/src/main/java/io/realm/exceptions/RealmException.java
@@ -20,7 +20,12 @@
  * RealmException is Realm specific exceptions.
  */
 public class RealmException extends RuntimeException {
+
     public RealmException(String detailMessage) {
         super(detailMessage);
     }
+
+    public RealmException(String detailMessage, Throwable exception) {
+        super(detailMessage, exception);
+    }
 }
diff --git a/realm/src/main/java/io/realm/internal/json/JsonUtils.java b/realm/src/main/java/io/realm/internal/json/JsonUtils.java
new file mode 100644
index 0000000000..ebbde5b8e5
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/json/JsonUtils.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.json;
+
+import android.util.Base64;
+import java.util.Date;
+
+public class JsonUtils {
+
+    /**
+     * Converts a Json string to a Java Date object. Currently supports 2 types:
+     * - "<long>"
+     * - "/Date(<long>)/"
+     * - TODO ISO 8601 String,
+     *
+     * @param str   String input of date of the the supported types.
+     * @return Date object or null if invalid input.
+     *
+     * @throws NumberFormatException If timestamp is not a proper long
+     * @throws IndexOutOfBoundsException if dates of type /Date(x)/ does not have the proper format.
+     */
+    public static Date stringToDate(String str) {
+        if (str == null || str.length() == 0) return null;
+        if (str.startsWith("/Date")) {
+            return new Date(Long.parseLong(str.substring(6, str.length() - 2)));
+        } else {
+            return new Date(Long.parseLong(str));
+        }
+    }
+
+    /**
+     * Converts a Json string to byte[]. String must be Base64 encoded.
+     *
+     * @param str   Base 64 encoded bytes.
+     * @return Byte array or empty byte array
+     */
+    public static byte[] stringToBytes(String str) {
+        if (str == null || str.length() == 0) return new byte[0];
+        return Base64.decode(str, Base64.DEFAULT);
+    }
+}
diff --git a/settings.gradle b/settings.gradle
index 898f839d2c..d6a2d9d6c5 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,4 +1,4 @@
-include 'realm', ':introExample', ':gridViewExample', ':concurrencyExample', ':encryptionExample', ':migrationExample'
+include ':realm', ':introExample', ':gridViewExample', ':concurrencyExample', ':encryptionExample', ':migrationExample', ':jsonImportExample'
 include ':performance'
 project(':performance').projectDir = new File('examples/performance')
 
@@ -8,3 +8,4 @@ project(':gridViewExample').projectDir = new File('examples/gridViewExample')
 project(':concurrencyExample').projectDir = new File('examples/concurrencyExample')
 project(':encryptionExample').projectDir = new File('examples/encryptionExample')
 project(':migrationExample').projectDir = new File('examples/migrationExample')
+project(':jsonImportExample').projectDir = new File('examples/jsonImportExample')
