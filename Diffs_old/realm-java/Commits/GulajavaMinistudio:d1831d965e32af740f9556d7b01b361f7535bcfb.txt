diff --git a/.gitignore b/.gitignore
index 7d38506f03..483d1a7ced 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,6 +1,7 @@
 # Gradle build artifacts
 build
 realm/build
+!realm-transformer/src/main/kotlin/io/realm/transformer/build
 
 # Gradle cache
 .gradle
diff --git a/CHANGELOG.md b/CHANGELOG.md
index fb7f7f0c09..e0a44d4fd6 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,11 +1,11 @@
-## 5.2.0 (YYYY-MM-DD)
+## 5.2.0 (2018-06-06)
 
 The feature previously named Partial Sync is now called Query-Based Sync and is now the default mode when synchronizing Realms.
 This has impacted a number of API's. See below for the details.
 
 ### Deprecated
 
-* [ObjectServer] `SyncConfiguration.automatic()` has been removed in favour of `SyncUser.getDefaultConfiguration()`.
+* [ObjectServer] `SyncConfiguration.automatic()` has been deprecated in favour of `SyncUser.getDefaultConfiguration()`.
 * [ObjectServer] `new SyncConfiguration.Builder(user, url)` has been deprecated in favour of `SyncUser.createConfiguration(url)`. NOTE: Creating configurations using `SyncUser` will default to using query-based Realms, while creating them using `new SyncConfiguration.Builder(user, url)` will default to fully synchronized Realms.
 * [ObjectServer] With query-based sync being the default `SyncConfiguration.Builder.partialRealm()` has been deprecated. Use ``SyncConfiguration.Builder.fullSynchronization()` if you want full synchronisation instead.
 
@@ -13,6 +13,15 @@ This has impacted a number of API's. See below for the details.
 
 * [ObjectServer] Added `SyncUser.createConfiguration(url)`. Realms created this way are query-based Realms by default.
 * [ObjectServer] Added `SyncUser.getDefaultConfiguration()`.
+* The Realm bytecode transformer now supports incremental builds (#3034).
+
+### Bug Fixes
+
+* Having files that ends with `RealmProxy` will no longer break the Realm Transformer (#3709).
+
+### Internal
+
+* Module mediator classes being generated now produces a stable output enabling better support for incremental builds (#3034).
 
 
 ## 5.1.1 (YYYY-MM-DD)
diff --git a/examples/architectureComponentsExample/build.gradle b/examples/architectureComponentsExample/build.gradle
index 5371c339cf..d44c3d0292 100644
--- a/examples/architectureComponentsExample/build.gradle
+++ b/examples/architectureComponentsExample/build.gradle
@@ -32,7 +32,7 @@ android {
             signingConfig signingConfigs.debug
         }
         debug {
-            minifyEnabled true
+            minifyEnabled false
         }
     }
 }
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
index 6984f15bf9..ce6b051beb 100644
--- a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
@@ -95,7 +95,7 @@ protected void onStart() {
         if (user == null) { return; }
 
         // Create a RealmConfiguration for our user
-        SyncConfiguration config = new SyncConfiguration.Builder(user, REALM_URL)
+        SyncConfiguration config = user.createConfiguration(REALM_URL)
                 .initialData(new Realm.Transaction() {
                     @Override
                     public void execute(@Nonnull Realm realm) {
diff --git a/realm-transformer/build.gradle b/realm-transformer/build.gradle
index eb4789361d..9026350842 100644
--- a/realm-transformer/build.gradle
+++ b/realm-transformer/build.gradle
@@ -1,4 +1,5 @@
 buildscript {
+    ext.kotlin_version = '1.2.40'
     repositories {
         google()
         jcenter()
@@ -6,6 +7,7 @@ buildscript {
     dependencies {
         classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.5.2'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
+        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
     }
 }
 
@@ -17,6 +19,7 @@ allprojects {
     }
 }
 
+apply plugin: 'kotlin'
 apply plugin: 'groovy'
 apply plugin: 'java'
 apply plugin: 'maven'
@@ -51,7 +54,7 @@ sourceSets {
     main {
         compileClasspath += configurations.provided
         java {
-            srcDir 'build/generated-src/main/java'
+            srcDirs += ['build/generated-src/main/java', 'src/main/kotlin']
         }
     }
 }
@@ -60,8 +63,9 @@ dependencies {
     compile localGroovy()
     compile gradleApi()
     compile "io.realm:realm-annotations:${version}"
-    compileOnly 'com.android.tools.build:gradle:3.1.0-alpha06'
+    compileOnly 'com.android.tools.build:gradle:3.1.1'
     compile 'org.javassist:javassist:3.21.0-GA'
+    compile "org.jetbrains.kotlin:kotlin-stdlib-jdk8:${kotlin_version}"
 
     testCompile('org.spockframework:spock-core:1.0-groovy-2.4') {
         exclude module: 'groovy-all'
@@ -79,6 +83,10 @@ task generateVersionClass(type: Copy) {
 }
 
 compileJava.dependsOn generateVersionClass
+compileGroovy.dependsOn = compileGroovy.taskDependencies.values - 'compileJava'
+compileKotlin.dependsOn compileGroovy
+compileKotlin.classpath += files(compileGroovy.destinationDir)
+classes.dependsOn compileKotlin
 
 def commonPom = {
     licenses {
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
deleted file mode 100644
index c00055369d..0000000000
--- a/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.transformer
-
-import io.realm.annotations.Ignore
-import javassist.*
-import javassist.expr.ExprEditor
-import javassist.expr.FieldAccess
-import org.slf4j.Logger
-import org.slf4j.LoggerFactory
-/**
- * This class encapsulates the bytecode manipulation code needed to transform model classes
- * and the classes using them.
- */
-class BytecodeModifier {
-
-    private static final Logger logger = LoggerFactory.getLogger('realm-logger')
-
-    static boolean isModelField(CtField field) {
-        return !field.hasAnnotation(Ignore.class) && !Modifier.isTransient(field.getModifiers()) && !Modifier.isStatic(field.getModifiers())
-    }
-
-    /**
-     * Adds Realm specific accessors to a model class.
-     * All the declared fields will be associated with a getter and a setter.
-     *
-     * @param clazz the CtClass to add accessors to.
-     */
-    public static void addRealmAccessors(CtClass clazz) {
-        logger.debug "  Realm: Adding accessors to ${clazz.simpleName}"
-        def methods = clazz.getDeclaredMethods()*.name
-        clazz.declaredFields.each { CtField field ->
-            if (isModelField(field)) {
-                if (!methods.contains("realmGet\$${field.name}".toString())) {
-                    clazz.addMethod(CtNewMethod.getter("realmGet\$${field.name}", field))
-                }
-                if (!methods.contains("realmSet\$${field.name}".toString())) {
-                    clazz.addMethod(CtNewMethod.setter("realmSet\$${field.name}", field))
-                }
-            }
-        }
-    }
-
-    /**
-     * Modifies a class replacing field accesses with the appropriate Realm accessors.
-     *
-     * @param clazz The CtClass to modify
-     * @param managedFields List of fields whose access should be replaced
-     */
-    public static void useRealmAccessors(CtClass clazz, List<CtField> managedFields) {
-        clazz.getDeclaredBehaviors().each { behavior ->
-            logger.debug "    Behavior: ${behavior.name}"
-            if (
-                (
-                    behavior instanceof CtMethod &&
-                    !behavior.name.startsWith('realmGet$') &&
-                    !behavior.name.startsWith('realmSet$')
-                ) || (
-                    behavior instanceof CtConstructor
-                )
-            ) {
-                behavior.instrument(new FieldAccessToAccessorConverter(managedFields, clazz, behavior))
-            }
-        }
-    }
-
-    /**
-     * Modifies a class adding its RealmProxy interface.
-     *
-     * @param clazz The CtClass to modify
-     * @param classPool the Javassist class pool
-     */
-    public static void addRealmProxyInterface(CtClass clazz, ClassPool classPool) {
-        def proxyInterface = classPool.get("io.realm.${clazz.getName().replace(".", "_")}RealmProxyInterface")
-        clazz.addInterface(proxyInterface)
-    }
-
-    public static void callInjectObjectContextFromConstructors(CtClass clazz) {
-        clazz.getConstructors().each {
-            it.insertBeforeBody('if ($0 instanceof io.realm.internal.RealmObjectProxy) {' +
-                    ' ((io.realm.internal.RealmObjectProxy) $0).realm$injectObjectContext();' +
-                    ' }')
-        }
-    }
-
-    /**
-     * This class goes through all the field access behaviours of a class and replaces field accesses with
-     * the appropriate accessor.
-     */
-    private static class FieldAccessToAccessorConverter extends ExprEditor {
-        final List<CtField> managedFields
-        final CtClass ctClass
-        final CtBehavior behavior
-
-        FieldAccessToAccessorConverter(List<CtField> managedFields,
-                                       CtClass ctClass,
-                                       CtBehavior behavior) {
-            this.managedFields = managedFields
-            this.ctClass = ctClass
-            this.behavior = behavior
-        }
-
-        @Override
-        void edit(FieldAccess fieldAccess) throws CannotCompileException {
-            logger.debug "      Field being accessed: ${fieldAccess.className}.${fieldAccess.fieldName}"
-            def isRealmFieldAccess = managedFields.find {
-                fieldAccess.className.equals(it.declaringClass.name) && fieldAccess.fieldName.equals(it.name)
-            }
-            if (isRealmFieldAccess != null) {
-                logger.debug "        Realm: Manipulating ${ctClass.simpleName}.${behavior.name}(): ${fieldAccess.fieldName}"
-                logger.debug "        Methods: ${ctClass.declaredMethods}"
-                def fieldName = fieldAccess.fieldName
-                if (fieldAccess.isReader()) {
-                    fieldAccess.replace('$_ = $0.realmGet$' + fieldName + '();')
-                } else if (fieldAccess.isWriter()) {
-                    fieldAccess.replace('$0.realmSet$' + fieldName + '($1);')
-                }
-            }
-        }
-    }
-
-    /**
-     * Adds a method to indicate that Realm transformer has been applied.
-     *
-     * @param clazz The CtClass to modify.
-     */
-    public static void overrideTransformedMarker(CtClass clazz) {
-        logger.debug "  Realm: Marking as transformed ${clazz.simpleName}"
-        try {
-            clazz.getDeclaredMethod("transformerApplied", new CtClass[0])
-        } catch (NotFoundException ignored) {
-            clazz.addMethod(CtNewMethod.make(Modifier.PUBLIC, CtClass.booleanType, "transformerApplied",
-                    new CtClass[0], new CtClass[0], "{return true;}", clazz))
-        }
-    }
-}
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/GroovyUtil.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/GroovyUtil.groovy
new file mode 100644
index 0000000000..1fc1028f2d
--- /dev/null
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/GroovyUtil.groovy
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.transformer
+
+import kotlin.collections.EmptyList
+import org.gradle.api.Project
+
+import javax.annotation.Nonnull
+import javax.annotation.Nullable;
+
+/**
+ * Helper methods for functionality that is really hard to port to Java/Kotlin
+ */
+class GroovyUtil {
+
+    @Nullable
+    static String getTargetSdk(@Nonnull Project project) {
+        return project?.android?.defaultConfig?.targetSdkVersion?.mApiLevel as String
+    }
+
+    @Nullable
+    static String getMinSdk(@Nonnull Project project) {
+        return project?.android?.defaultConfig?.minSdkVersion?.mApiLevel as String
+    }
+
+    @Nonnull
+    static boolean isSyncEnabled(@Nonnull Project project) {
+        return project.realm?.syncEnabled != null && project.realm.syncEnabled
+    }
+
+    @Nonnull
+    static Collection<File> getBootClasspath(@Nonnull Project project) {
+        def classpath = project.android.bootClasspath as Collection<File>
+        return (classpath != null) ? classpath : Collections.emptyList()
+    }
+}
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
deleted file mode 100644
index 53d9889db0..0000000000
--- a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
+++ /dev/null
@@ -1,273 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.transformer
-
-import com.android.SdkConstants
-import com.android.build.api.transform.*
-import com.google.common.collect.ImmutableSet
-import com.google.common.collect.Sets
-import com.google.common.io.Files
-import groovy.io.FileType
-import io.realm.annotations.RealmClass
-import javassist.ClassPool
-import javassist.CtClass
-import org.gradle.api.Project
-import org.slf4j.Logger
-import org.slf4j.LoggerFactory
-
-import java.util.jar.JarFile
-import java.util.regex.Pattern
-
-import static com.android.build.api.transform.QualifiedContent.*
-
-/**
- * This class implements the Transform API provided by the Android Gradle plugin.
- */
-@SuppressWarnings("GroovyUnusedDeclaration")
-class RealmTransformer extends Transform {
-
-    private Logger logger = LoggerFactory.getLogger('realm-logger')
-    private Project project
-
-    public RealmTransformer(Project project) {
-        this.project = project
-    }
-
-    @Override
-    String getName() {
-        return "RealmTransformer"
-    }
-
-    @Override
-    Set<ContentType> getInputTypes() {
-        return ImmutableSet.<ContentType> of(DefaultContentType.CLASSES)
-    }
-
-    @Override
-    Set<Scope> getScopes() {
-        return Sets.immutableEnumSet(Scope.PROJECT)
-    }
-
-    @Override
-    Set<Scope> getReferencedScopes() {
-        // Scope.PROJECT_LOCAL_DEPS and Scope.SUB_PROJECTS_LOCAL_DEPS is only for compatibility with AGP 1.x, 2.x
-        return Sets.immutableEnumSet(Scope.EXTERNAL_LIBRARIES, Scope.PROJECT_LOCAL_DEPS,
-                Scope.SUB_PROJECTS, Scope.SUB_PROJECTS_LOCAL_DEPS, Scope.TESTED_CODE)
-    }
-
-    @Override
-    boolean isIncremental() {
-        return false
-    }
-
-    @Override
-    void transform(Context context, Collection<TransformInput> inputs, Collection<TransformInput> referencedInputs,
-                   TransformOutputProvider outputProvider, boolean isIncremental)
-            throws IOException, TransformException, InterruptedException {
-
-        def tic = System.currentTimeMillis()
-
-        // Find all the class names
-        def inputClassNames = getClassNames(inputs)
-        def referencedClassNames = getClassNames(referencedInputs)
-        def allClassNames = merge(inputClassNames, referencedClassNames)
-
-        // Create and populate the Javassist class pool
-        ClassPool classPool = new ManagedClassPool(inputs, referencedInputs)
-        // Append android.jar to class pool. We don't need the class names of them but only the class in the pool for
-        // javassist. See https://github.com/realm/realm-java/issues/2703.
-        addBootClassesToClassPool(classPool)
-
-        logger.debug "ClassPool contains Realm classes: ${classPool.getOrNull('io.realm.RealmList') != null}"
-
-        // mark as transformed
-        def baseProxyMediator = classPool.get('io.realm.internal.RealmProxyMediator')
-        def mediatorPattern = Pattern.compile('^io\\.realm\\.[^.]+Mediator$')
-        def proxyMediatorClasses = inputClassNames
-                .findAll { it.matches(mediatorPattern) }
-                .collect { classPool.getCtClass(it) }
-                .findAll { it.superclass?.equals(baseProxyMediator) }
-        logger.debug "Proxy Mediator Classes: ${proxyMediatorClasses*.name}"
-        proxyMediatorClasses.each {
-            BytecodeModifier.overrideTransformedMarker(it)
-        }
-
-        // Find the model classes
-        def allModelClasses = allClassNames
-                .findAll { it.endsWith('RealmProxy') }
-                .collect { classPool.getCtClass(it).superclass }
-                .findAll { it.hasAnnotation(RealmClass.class) || it.superclass.hasAnnotation(RealmClass.class) }
-        def inputModelClasses = allModelClasses.findAll {
-            inputClassNames.contains(it.name)
-        }
-        logger.debug "Model Classes: ${allModelClasses*.name}"
-
-        // Populate a list of the fields that need to be managed with bytecode manipulation
-        def allManagedFields = []
-        allModelClasses.each {
-            allManagedFields.addAll(it.declaredFields.findAll {
-                BytecodeModifier.isModelField(it)
-            })
-        }
-        logger.debug "Managed Fields: ${allManagedFields*.name}"
-
-        // Add accessors to the model classes in the target project
-        inputModelClasses.each {
-            BytecodeModifier.addRealmAccessors(it)
-            BytecodeModifier.addRealmProxyInterface(it, classPool)
-            BytecodeModifier.callInjectObjectContextFromConstructors(it)
-        }
-
-        // Use accessors instead of direct field access
-        inputClassNames.each {
-            logger.debug "  Modifying class ${it}"
-            def ctClass = classPool.getCtClass(it)
-            BytecodeModifier.useRealmAccessors(ctClass, allManagedFields)
-            ctClass.writeFile(getOutputFile(outputProvider).canonicalPath)
-        }
-
-        copyResourceFiles(inputs, outputProvider)
-
-        def toc = System.currentTimeMillis()
-        logger.debug "Realm Transform time: ${toc-tic} milliseconds"
-
-        this.sendAnalytics(inputs, inputModelClasses)
-        classPool.close()
-    }
-
-    /**
-     * Sends the analytics
-     * @param inputs the inputs provided by the Transform API
-     * @param inputModelClasses a list of ctClasses describing the Realm models
-     */
-    private sendAnalytics(Collection<TransformInput> inputs, List<CtClass> inputModelClasses) {
-        def containsKotlin = false
-        inputs.each {
-            it.directoryInputs.each {
-                def path = it.file.absolutePath
-                def index = path.indexOf('build' + File.separator + 'intermediates' + File.separator + 'classes')
-                if (index != -1) {
-                    def projectPath = path.substring(0, index)
-                    def buildFile = new File(projectPath + 'build.gradle')
-                    if (buildFile.exists() && buildFile.text.contains('kotlin')) {
-                        containsKotlin = true
-                    }
-                }
-            }
-        }
-
-        def packages = inputModelClasses.collect {
-            it.getPackageName()
-        }
-
-        def targetSdk = project?.android?.defaultConfig?.targetSdkVersion?.mApiLevel as String
-        def minSdk = project?.android?.defaultConfig?.minSdkVersion?.mApiLevel as String
-
-        def env = System.getenv()
-        def disableAnalytics = env["REALM_DISABLE_ANALYTICS"]
-        if (disableAnalytics == null || disableAnalytics != "true") {
-            boolean sync = project?.realm?.syncEnabled != null && project.realm.syncEnabled
-            def analytics = new RealmAnalytics(packages as Set, containsKotlin, sync, targetSdk, minSdk)
-            analytics.execute()
-        }
-    }
-
-    private static Set<String> getClassNames(Collection<TransformInput> inputs) {
-        Set<String> classNames = new HashSet<String>()
-
-        inputs.each {
-            it.directoryInputs.each {
-                def dirPath = it.file.absolutePath
-                it.file.eachFileRecurse(FileType.FILES) {
-                    if (it.absolutePath.endsWith(SdkConstants.DOT_CLASS)) {
-                        def className =
-                                it.absolutePath.substring(
-                                        dirPath.length() + 1,
-                                        it.absolutePath.length() - SdkConstants.DOT_CLASS.length()
-                                ).replace(File.separatorChar, '.' as char)
-                        classNames.add(className)
-                    }
-                }
-            }
-
-            it.jarInputs.each {
-                def jarFile = new JarFile(it.file)
-                jarFile.entries().findAll {
-                    !it.directory && it.name.endsWith(SdkConstants.DOT_CLASS)
-                }.each {
-                    def path = it.name
-                    // The jar might not using File.separatorChar as the path separator. So we just replace both `\` and
-                    // `/`. It depends on how the jar file was created.
-                    // See http://stackoverflow.com/questions/13846000/file-separators-of-path-name-of-zipentry
-                    String className = path.substring(0, path.length() - SdkConstants.DOT_CLASS.length())
-                            .replace('/' as char , '.' as char)
-                            .replace('\\' as char , '.' as char)
-                    classNames.add(className)
-                }
-                jarFile.close() // Crash transformer if this fails
-            }
-        }
-        return classNames
-    }
-
-    private copyResourceFiles(Collection<TransformInput> inputs, TransformOutputProvider outputProvider) {
-        inputs.each {
-            it.directoryInputs.each {
-                def dirPath = it.file.absolutePath
-                it.file.eachFileRecurse(FileType.FILES) {
-                    if (!it.absolutePath.endsWith(SdkConstants.DOT_CLASS)) {
-                        logger.debug "  Copying resource ${it}"
-                        def dest = new File(getOutputFile(outputProvider),
-                                it.absolutePath.substring(dirPath.length()))
-                        dest.parentFile.mkdirs()
-                        Files.copy(it, dest)
-                    }
-                }
-            }
-
-            // no need to implement the code for `it.jarInputs.each` since PROJECT SCOPE does not use jar input.
-        }
-    }
-
-    private File getOutputFile(TransformOutputProvider outputProvider) {
-        return outputProvider.getContentLocation(
-                'realm', getInputTypes(), getScopes(), Format.DIRECTORY)
-    }
-
-    private static Set<String> merge(Set<String> set1, Set<String> set2) {
-        Set<String> merged = new HashSet<String>()
-        merged.addAll(set1)
-        merged.addAll(set2)
-        return merged
-    }
-
-    // There is no official way to get the path to android.jar for transform.
-    // See https://code.google.com/p/android/issues/detail?id=209426
-    private void addBootClassesToClassPool(ClassPool classPool) {
-        try {
-            project.android.bootClasspath.each {
-                String path = it.absolutePath
-                logger.debug "Add boot class " + path + " to class pool."
-                classPool.appendClassPath(path)
-            }
-        } catch (Exception e) {
-            // Just log it. It might not impact the transforming if the method which needs to be transformer doesn't
-            // contain classes from android.jar.
-            logger.debug("Cannot get bootClasspath caused by:", e)
-        }
-    }
-}
diff --git a/realm-transformer/src/main/kotlin/io/realm/transformer/ByteCodeModifier.kt b/realm-transformer/src/main/kotlin/io/realm/transformer/ByteCodeModifier.kt
new file mode 100644
index 0000000000..7839c95b22
--- /dev/null
+++ b/realm-transformer/src/main/kotlin/io/realm/transformer/ByteCodeModifier.kt
@@ -0,0 +1,194 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.transformer
+
+import io.realm.annotations.Ignore
+import io.realm.annotations.RealmClass
+import io.realm.transformer.ext.safeSubtypeOf
+import javassist.*
+import javassist.expr.ExprEditor
+import javassist.expr.FieldAccess
+
+/**
+ * This class encapsulates the bytecode manipulation code needed to transform model classes
+ * and the classes using them.
+ */
+class BytecodeModifier {
+
+    companion object {
+
+        fun isModelField(field: CtField): Boolean {
+            return !field.hasAnnotation(Ignore::class.java) && !Modifier.isTransient(field.getModifiers()) && !Modifier.isStatic(field.getModifiers())
+        }
+
+        /**
+         * Adds Realm specific accessors to a model class.
+         * All the declared fields will be associated with a getter and a setter.
+         *
+         * @param clazz the CtClass to add accessors to.
+         */
+        @JvmStatic
+        fun addRealmAccessors(clazz: CtClass) {
+            val methods: List<String> = clazz.declaredMethods.map { it.name }
+            clazz.declaredFields.forEach { field: CtField ->
+                if (isModelField(field)) {
+                    if (!methods.contains("realmGet\$${field.name}")) {
+                        clazz.addMethod(CtNewMethod.getter("realmGet\$${field.name}", field))
+                    }
+                    if (!methods.contains("realmSet\$${field.name}")) {
+                        clazz.addMethod(CtNewMethod.setter("realmSet\$${field.name}", field))
+                    }
+                }
+            }
+        }
+
+        /**
+         * Modifies a class replacing field accesses with the appropriate Realm accessors.
+         *
+         * @param clazz The CtClass to modify
+         * @param managedFields List of fields whose access should be replaced
+         */
+        @JvmStatic
+        fun useRealmAccessors(classPool: ClassPool, clazz: CtClass, managedFields: List<CtField>?) {
+            clazz.declaredBehaviors.forEach { behavior ->
+                logger.debug("    Behavior: ${behavior.name}")
+                if (
+                        (
+                                behavior is CtMethod &&
+                                        !behavior.name.startsWith("realmGet$") &&
+                                        !behavior.name.startsWith("realmSet$")
+                                ) || (
+                                behavior is CtConstructor
+                                )
+                ) {
+                    if (managedFields != null) {
+                        behavior.instrument(FieldAccessToAccessorConverterUsingList(managedFields, clazz, behavior))
+                    } else {
+                        behavior.instrument(FieldAccessToAccessorConverterUsingClassPool(classPool, clazz, behavior))
+                    }
+
+                }
+            }
+        }
+
+        /**
+         * Modifies a class adding its RealmProxy interface.
+         *
+         * @param clazz The CtClass to modify
+         * @param classPool the Javassist class pool
+         */
+        @JvmStatic
+        fun addRealmProxyInterface(clazz: CtClass, classPool: ClassPool) {
+            val proxyInterface: CtClass = classPool.get("io.realm.${clazz.getName().replace(".", "_")}RealmProxyInterface")
+            clazz.addInterface(proxyInterface)
+        }
+
+        fun callInjectObjectContextFromConstructors(clazz: CtClass) {
+            clazz.constructors.forEach {
+                it.insertBeforeBody("if ($0 instanceof io.realm.internal.RealmObjectProxy) {" +
+                        " ((io.realm.internal.RealmObjectProxy) $0).realm\$injectObjectContext();" +
+                        " }")
+            }
+        }
+
+
+        /**
+         * Adds a method to indicate that Realm transformer has been applied.
+         *
+         * @param clazz The CtClass to modify.
+         */
+        fun overrideTransformedMarker(clazz: CtClass) {
+            logger.debug("  Realm: Marking as transformed ${clazz.simpleName}")
+            try {
+                clazz.getDeclaredMethod("transformerApplied")
+            } catch (ignored: NotFoundException) {
+                clazz.addMethod(CtNewMethod.make(Modifier.PUBLIC, CtClass.booleanType, "transformerApplied",
+                        arrayOf(), arrayOf(), "{return true;}", clazz))
+            }
+        }
+
+    }
+
+    /**
+     * This class goes through all the field access behaviours of a class and replaces field accesses with
+     * the appropriate accessor.
+     */
+    private class FieldAccessToAccessorConverterUsingList(val managedFields: List<CtField>,
+                                                          val ctClass: CtClass,
+                                                          val behaviour: CtBehavior) : ExprEditor() {
+
+        @Throws(CannotCompileException::class)
+        override fun edit(fieldAccess: FieldAccess) {
+            logger.debug("      Field being accessed: ${fieldAccess.className}.${fieldAccess.fieldName}")
+            managedFields.find {
+                fieldAccess.className.equals(it.declaringClass.name) && fieldAccess.fieldName.equals(it.name)
+            }?.run {
+                logger.debug("        Realm: Manipulating ${ctClass.simpleName}.${behaviour.name}(): ${fieldAccess.fieldName}")
+                logger.debug("        Methods: ${ctClass.declaredMethods}")
+                val fieldName: String = fieldAccess.fieldName
+                if (fieldAccess.isReader) {
+                    fieldAccess.replace("\$_ = $0.realmGet\$$fieldName();")
+                } else if (fieldAccess.isWriter()) {
+                    fieldAccess.replace("\$0.realmSet\$$fieldName(\$1);")
+                }
+            }
+        }
+    }
+
+    /**
+     * This class goes through all the field access behaviours of a class and replaces field accesses with
+     * the appropriate accessor.
+     */
+    private class FieldAccessToAccessorConverterUsingClassPool(val classPool: ClassPool,
+                                                               val ctClass: CtClass,
+                                                               val behaviour: CtBehavior) : ExprEditor() {
+
+        val realmObjectProxyInterface: CtClass = classPool.get("io.realm.internal.RealmObjectProxy")
+
+        @Throws(CannotCompileException::class)
+        override fun edit(fieldAccess: FieldAccess) {
+            logger.debug("      Field being accessed: ${fieldAccess.className}.${fieldAccess.fieldName}")
+            if (isRealmModelClass(fieldAccess.enclosingClass) && isModelField(fieldAccess.field)) {
+                logger.debug("        Realm: Manipulating ${ctClass.simpleName}.${behaviour.name}(): ${fieldAccess.fieldName}")
+                logger.debug("        Methods: ${ctClass.declaredMethods}")
+                val fieldName: String = fieldAccess . fieldName
+                if (fieldAccess.isReader) {
+                    fieldAccess.replace("\$_ = \$0.realmGet\$$fieldName();")
+                } else if (fieldAccess.isWriter) {
+                    fieldAccess.replace("\$0.realmSet\$$fieldName(\$1);")
+                }
+            }
+        }
+
+        fun isRealmModelClass(clazz: CtClass): Boolean {
+            return arrayOf(clazz).filter {
+                if (it.hasAnnotation(RealmClass::class.java)) {
+                    return true
+                } else {
+                    try {
+                        return it.superclass?.hasAnnotation(RealmClass::class.java) == true
+                    } catch (ignored: NotFoundException) {
+                        return false
+                    }
+                }
+            }
+            .filter { !it.safeSubtypeOf(realmObjectProxyInterface) }
+            .any { it.name != "io.realm.RealmObject" }
+        }
+    }
+
+}
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/ManagedClassPool.groovy b/realm-transformer/src/main/kotlin/io/realm/transformer/ManagedClassPool.kt
similarity index 77%
rename from realm-transformer/src/main/groovy/io/realm/transformer/ManagedClassPool.groovy
rename to realm-transformer/src/main/kotlin/io/realm/transformer/ManagedClassPool.kt
index c3a0389d26..ce337d9a53 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/ManagedClassPool.groovy
+++ b/realm-transformer/src/main/kotlin/io/realm/transformer/ManagedClassPool.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 Realm Inc.
+ * Copyright 2018 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,15 +19,15 @@ package io.realm.transformer
 import com.android.build.api.transform.TransformInput
 import javassist.ClassPath
 import javassist.ClassPool
+import java.io.Closeable
 
 /**
  * This class is a wrapper around JavaAssists {@code ClassPool} class that allows for correct cleanup
  * of the resources used.
  */
-@SuppressWarnings("GroovyUnusedDeclaration")
-class ManagedClassPool extends ClassPool implements Closeable {
+class ManagedClassPool(inputs: Collection<TransformInput>, referencedInputs: Collection<TransformInput>) : ClassPool(), Closeable {
 
-    def List<ClassPath> pathElements = new ArrayList<ClassPath>()
+    val pathElements: ArrayList<ClassPath> = arrayListOf()
 
     /**
      * Constructor for creating and populating the JavAssist class pool.
@@ -37,28 +37,27 @@ class ManagedClassPool extends ClassPool implements Closeable {
      * @param referencedInputs the referencedInputs provided by the Transform API
      * @return the populated ClassPool instance
      */
-    ManagedClassPool(Collection<TransformInput> inputs, Collection<TransformInput> referencedInputs) {
+    init {
         // Don't use ClassPool.getDefault(). Doing consecutive builds in the same run (e.g. debug+release)
         // will use a cached object and all the classes will be frozen.
-        super(null)
         appendSystemPath()
 
-        inputs.each {
-            it.directoryInputs.each {
+        inputs.forEach{
+            it.directoryInputs.forEach {
                 pathElements.add(appendClassPath(it.file.absolutePath))
             }
 
-            it.jarInputs.each {
+            it.jarInputs.forEach {
                 pathElements.add(appendClassPath(it.file.absolutePath))
             }
         }
 
-        referencedInputs.each {
-            it.directoryInputs.each {
+        referencedInputs.forEach {
+            it.directoryInputs.forEach {
                 pathElements.add(appendClassPath(it.file.absolutePath))
             }
 
-            it.jarInputs.each {
+            it.jarInputs.forEach {
                 pathElements.add(appendClassPath(it.file.absolutePath))
             }
         }
@@ -67,16 +66,16 @@ class ManagedClassPool extends ClassPool implements Closeable {
     /**
      * Detach all ClassPath elements, effectively closing the class pool.
      */
-    @Override
-    void close() throws IOException {
+    override fun close() {
         // Cleanup class pool. Internally it keeps a list of JarFile references that are only
         // cleaned up if the the ClassPath element wrapping it is manually removed.
         // See https://github.com/jboss-javassist/javassist/issues/165
-        def iter = pathElements.iterator()
+        val iter: MutableIterator<ClassPath> = pathElements.iterator()
         while (iter.hasNext()) {
-            def cp = iter.next()
+            val cp = iter.next()
             removeClassPath(cp)
             iter.remove()
         }
     }
+
 }
diff --git a/realm-transformer/src/main/kotlin/io/realm/transformer/RealmTransformer.kt b/realm-transformer/src/main/kotlin/io/realm/transformer/RealmTransformer.kt
new file mode 100644
index 0000000000..7fdd2db56b
--- /dev/null
+++ b/realm-transformer/src/main/kotlin/io/realm/transformer/RealmTransformer.kt
@@ -0,0 +1,164 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.transformer
+
+import com.android.build.api.transform.*
+import io.realm.transformer.build.FullBuild
+import io.realm.transformer.build.IncrementalBuild
+import io.realm.transformer.build.BuildTemplate
+import javassist.CtClass
+import org.gradle.api.Project
+import org.slf4j.Logger
+import org.slf4j.LoggerFactory
+import java.io.File
+
+// Package level logger
+val logger: Logger = LoggerFactory.getLogger("realm-logger")
+
+/**
+ * This class implements the Transform API provided by the Android Gradle plugin.
+ */
+class RealmTransformer(val project: Project) : Transform() {
+
+    val logger: Logger = LoggerFactory.getLogger("realm-logger")
+
+    override fun getName(): String {
+        return "RealmTransformer"
+    }
+
+    override fun getInputTypes(): Set<QualifiedContent.ContentType> {
+        return setOf<QualifiedContent.ContentType>(QualifiedContent.DefaultContentType.CLASSES)
+    }
+
+    override fun isIncremental(): Boolean {
+        return true
+    }
+
+    override fun getScopes(): MutableSet<in QualifiedContent.Scope> {
+        return mutableSetOf(QualifiedContent.Scope.PROJECT)
+    }
+
+    override fun getReferencedScopes(): MutableSet<in QualifiedContent.Scope> {
+        // Scope.PROJECT_LOCAL_DEPS and Scope.SUB_PROJECTS_LOCAL_DEPS is only for compatibility with AGP 1.x, 2.x
+        return mutableSetOf(
+                QualifiedContent.Scope.EXTERNAL_LIBRARIES,
+                QualifiedContent.Scope.PROJECT_LOCAL_DEPS,
+                QualifiedContent.Scope.SUB_PROJECTS,
+                QualifiedContent.Scope.SUB_PROJECTS_LOCAL_DEPS,
+                QualifiedContent.Scope.TESTED_CODE
+        )
+    }
+
+    /**
+     * Implements the transform algorithm. The heaviest part of the transform is loading the
+     * {@code CtClass} from JavaAssist, so this should be avoided as much as possible.
+     *
+     * This is also the reason that there are significant changes between a full build and a
+     * incremental build. In a full build, we can use text matching to go from a proxy class
+     * to the model class. Something we cannot do when building incrementally. In that case
+     * we have to deduce all information from the class at hand.
+     *
+     * @param context
+     * @param inputs
+     * @param referencedInputs
+     * @param outputProvider
+     * @param isIncremental
+     * @throws IOException
+     * @throws TransformException
+     * @throws InterruptedException
+     */
+    override fun transform(context: Context?, inputs: MutableCollection<TransformInput>?,
+                           referencedInputs: Collection<TransformInput>?,
+                           outputProvider: TransformOutputProvider?, isIncremental: Boolean) {
+
+        val timer = Stopwatch()
+        timer.start("Realm Transform time")
+
+        val build: BuildTemplate = if (isIncremental) IncrementalBuild(project, outputProvider!!, this)
+        else FullBuild(project, outputProvider!!, this)
+
+        build.prepareOutputClasses(inputs!!)
+        timer.splitTime("Prepare output classes")
+        if (build.hasNoOutput()) {
+            // Abort transform as quickly as possible if no files where found for processing.
+            exitTransform(emptySet(), emptyList(), timer)
+            return
+        }
+        build.prepareReferencedClasses(referencedInputs!!);
+        timer.splitTime("Prepare referenced classes")
+        build.markMediatorsAsTransformed()
+        timer.splitTime("Mark mediators as transformed")
+        build.transformModelClasses();
+        timer.splitTime("Transform model classes")
+        build.transformDirectAccessToModelFields();
+        timer.splitTime("Transform references to model fields")
+        build.copyResourceFiles();
+        timer.splitTime("Copy resource files")
+        exitTransform(inputs, build.getOutputModelClasses(), timer)
+    }
+
+    private fun exitTransform(inputs: Collection<TransformInput>, outputModelClasses: Collection<CtClass>, timer: Stopwatch) {
+        timer.stop()
+        this.sendAnalytics(inputs, outputModelClasses)
+    }
+
+    /**
+     * Sends the analytics
+     *
+     * @param inputs the inputs provided by the Transform API
+     * @param inputModelClasses a list of ctClasses describing the Realm models
+     */
+    private fun sendAnalytics(inputs: Collection<TransformInput>, outputModelClasses: Collection<CtClass>) {
+        val disableAnalytics: Boolean = "true".equals(System.getenv()["REALM_DISABLE_ANALYTICS"])
+        if (inputs.isEmpty() || disableAnalytics) {
+            // Don't send analytics for incremental builds or if they have ben explicitly disabled.
+            return
+        }
+
+        var containsKotlin = false
+
+        outer@
+        for(input: TransformInput in inputs) {
+            for (di: DirectoryInput in input.directoryInputs) {
+                val path: String = di.file.absolutePath
+                val index: Int = path.indexOf("build${File.separator}intermediates${File.separator}classes")
+                if (index != -1) {
+                    val projectPath: String = path.substring(0, index)
+                    val buildFile = File(projectPath + "build.gradle")
+                    if (buildFile.exists() && buildFile.readText().contains("kotlin")) {
+                        containsKotlin = true
+                        break@outer
+                    }
+                }
+            }
+        }
+
+        val packages: Collection<String> = outputModelClasses.map {
+            it.packageName
+        }
+
+        val targetSdk: String? = GroovyUtil.getTargetSdk(project)
+        val minSdk: String?  = GroovyUtil.getMinSdk(project)
+
+        if (disableAnalytics) {
+            val sync: Boolean = GroovyUtil.isSyncEnabled(project)
+            val analytics = RealmAnalytics(packages as Set, containsKotlin, sync, targetSdk, minSdk)
+            analytics.execute()
+        }
+    }
+
+}
diff --git a/realm-transformer/src/main/kotlin/io/realm/transformer/Stopwatch.kt b/realm-transformer/src/main/kotlin/io/realm/transformer/Stopwatch.kt
new file mode 100644
index 0000000000..d9670a35f5
--- /dev/null
+++ b/realm-transformer/src/main/kotlin/io/realm/transformer/Stopwatch.kt
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.transformer
+
+import org.slf4j.Logger
+import org.slf4j.LoggerFactory
+import java.util.concurrent.TimeUnit
+
+class Stopwatch {
+
+    val logger: Logger = LoggerFactory.getLogger("realm-stopwatch")
+
+    var start: Long = -1L
+    var lastSplit: Long = -1L
+    lateinit var label: String
+
+    /*
+     * Start the stopwatch.
+     */
+    fun start(label: String) {
+        if (start != -1L) {
+            throw IllegalStateException("Stopwatch was already started");
+        }
+        this.label = label
+        start = System.nanoTime();
+        lastSplit = start;
+    }
+
+    /*
+     * Reports the split time.
+     *
+     * @param label Label to use when printing split time
+     * @param reportDiffFromLastSplit if `true` report the time from last split instead of the start
+     */
+    fun splitTime(label: String, reportDiffFromLastSplit: Boolean = true) {
+        val split = System.nanoTime()
+        val diff = if (reportDiffFromLastSplit) { split - lastSplit } else { split - start }
+        lastSplit = split;
+        logger.debug("$label: ${TimeUnit.NANOSECONDS.toMillis(diff)} ms.")
+    }
+
+    /**
+     * Stops the timer and report the result.
+     */
+    fun stop() {
+        val stop = System.nanoTime()
+        val diff = stop - start
+        logger.debug("$label: ${TimeUnit.NANOSECONDS.toMillis(diff)} ms.")
+    }
+}
\ No newline at end of file
diff --git a/realm-transformer/src/main/kotlin/io/realm/transformer/build/BuildTemplate.kt b/realm-transformer/src/main/kotlin/io/realm/transformer/build/BuildTemplate.kt
new file mode 100644
index 0000000000..fc77a5c215
--- /dev/null
+++ b/realm-transformer/src/main/kotlin/io/realm/transformer/build/BuildTemplate.kt
@@ -0,0 +1,168 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.transformer.build
+
+import com.android.SdkConstants
+import com.android.build.api.transform.Format
+import com.android.build.api.transform.Transform
+import com.android.build.api.transform.TransformInput
+import com.android.build.api.transform.TransformOutputProvider
+import com.google.common.io.Files
+import io.realm.transformer.BytecodeModifier
+import io.realm.transformer.GroovyUtil
+import io.realm.transformer.ManagedClassPool
+import io.realm.transformer.logger
+import javassist.ClassPool
+import javassist.CtClass
+import org.gradle.api.Project
+import java.io.File
+import java.util.regex.Pattern
+
+/**
+ * Abstract class defining the structure of doing different types of builds.
+ *
+ */
+abstract class BuildTemplate(val project: Project, val outputProvider: TransformOutputProvider, val transform: Transform) {
+
+    protected lateinit var inputs: MutableCollection<TransformInput>
+    protected lateinit var classPool: ManagedClassPool
+    protected val outputClassNames: MutableSet<String> = hashSetOf()
+    protected val outputReferencedClassNames: MutableSet<String> = hashSetOf()
+    protected val outputModelClasses: ArrayList<CtClass> = arrayListOf()
+
+    /**
+     * Find all the class names available for transforms as well as all referenced classes.
+     */
+    abstract fun prepareOutputClasses(inputs: MutableCollection<TransformInput>)
+
+    /**
+     * Helper method for going through all `TransformInput` and sort classes into buckets of
+     * source files in the current project or source files found in jar files.
+     *
+     * @param inputs set of input files
+     * @param directoryFiles the set of files in directories getting compiled. These are potential
+     * candidates for the transformer.
+     * @param jaFiles the set of files found in jar files. These will never be transformed. This should
+     * already be done when creating the jar file.
+     */
+    protected abstract fun categorizeClassNames(inputs: Collection<TransformInput>,
+                                          directoryFiles: MutableSet<String>,
+                                          referencedFiles: MutableSet<String>)
+
+    /**
+     * Returns `true` if this build contains no relevant classes to transform.
+     */
+    fun hasNoOutput(): Boolean {
+        return outputClassNames.isEmpty()
+    }
+
+
+    fun prepareReferencedClasses(referencedInputs: Collection<TransformInput>) {
+        categorizeClassNames(referencedInputs, outputReferencedClassNames, outputReferencedClassNames) // referenced files
+
+        // Create and populate the Javassist class pool
+        this.classPool = ManagedClassPool(inputs, referencedInputs)
+        // Append android.jar to class pool. We don't need the class names of them but only the class in the pool for
+        // javassist. See https://github.com/realm/realm-java/issues/2703.
+        addBootClassesToClassPool(classPool)
+        logger.debug("ClassPool contains Realm classes: ${classPool.getOrNull("io.realm.RealmList") != null}")
+
+        filterForModelClasses(outputClassNames, outputReferencedClassNames)
+    }
+
+    protected abstract fun filterForModelClasses(outputClassNames: Set<String>, outputReferencedClassNames: Set<String>)
+
+
+    fun markMediatorsAsTransformed() {
+        val baseProxyMediator: CtClass = classPool.get("io.realm.internal.RealmProxyMediator")
+        val mediatorPattern: Pattern = Pattern.compile("^io\\.realm\\.[^.]+Mediator$")
+        val proxyMediatorClasses: Collection<CtClass> = outputClassNames
+                .filter { mediatorPattern.matcher(it).find() }
+                .map { classPool.getCtClass(it) }
+                .filter { it.superclass.equals(baseProxyMediator) }
+
+        logger.debug("Proxy Mediator Classes: ${proxyMediatorClasses.joinToString(",") { it.name }}")
+        proxyMediatorClasses.forEach {
+            BytecodeModifier.overrideTransformedMarker(it)
+        }
+    }
+
+    fun transformModelClasses() {
+        // Add accessors to the model classes in the target project
+        outputModelClasses.forEach {
+            logger.debug("Modify model class: ${it.name}")
+            BytecodeModifier.addRealmAccessors(it)
+            BytecodeModifier.addRealmProxyInterface(it, classPool)
+            BytecodeModifier.callInjectObjectContextFromConstructors(it)
+        }
+    }
+
+    abstract fun transformDirectAccessToModelFields()
+
+    fun copyResourceFiles() {
+        copyResourceFiles(inputs)
+        classPool.close();
+    }
+
+    private fun copyResourceFiles(inputs: MutableCollection<TransformInput>) {
+        inputs.forEach {
+            it.directoryInputs.forEach {
+                val dirPath: String = it.file.absolutePath
+                it.file.walkTopDown().forEach {
+                    if (it.isFile) {
+                        if (!it.absolutePath.endsWith(SdkConstants.DOT_CLASS)) {
+                            logger.debug("  Copying resource $it")
+                            val dest = File(getOutputFile(outputProvider), it.absolutePath.substring(dirPath.length))
+                            dest.parentFile.mkdirs()
+                            Files.copy(it, dest)
+                        }
+                    }
+                }
+            }
+            // no need to implement the code for `it.jarInputs.each` since PROJECT SCOPE does not use jar input.
+        }
+    }
+
+    protected fun getOutputFile(outputProvider: TransformOutputProvider): File {
+        return outputProvider.getContentLocation(
+                "realm", transform.inputTypes, transform.scopes, Format.DIRECTORY)
+    }
+
+    /**
+     * There is no official way to get the path to android.jar for transform.
+     * See https://code.google.com/p/android/issues/detail?id=209426
+     */
+    private fun addBootClassesToClassPool(classPool: ClassPool) {
+        try {
+            GroovyUtil.getBootClasspath(project).forEach {
+                val path: String = it.absolutePath
+                logger.debug("Add boot class $path to class pool.")
+                classPool.appendClassPath(path)
+            }
+        } catch (e: Exception) {
+            // Just log it. It might not impact the transforming if the method which needs to be transformer doesn't
+            // contain classes from android.jar.
+            logger.debug("Cannot get bootClasspath caused by: ", e)
+        }
+    }
+
+    fun getOutputModelClasses(): Collection<CtClass> {
+        return outputModelClasses
+    }
+
+    protected abstract fun findModelClasses(classNames: Set<String>): Collection<CtClass>
+
+}
diff --git a/realm-transformer/src/main/kotlin/io/realm/transformer/build/FullBuild.kt b/realm-transformer/src/main/kotlin/io/realm/transformer/build/FullBuild.kt
new file mode 100644
index 0000000000..3bbcd1bfef
--- /dev/null
+++ b/realm-transformer/src/main/kotlin/io/realm/transformer/build/FullBuild.kt
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.transformer.build
+
+import com.android.SdkConstants
+import com.android.build.api.transform.TransformInput
+import com.android.build.api.transform.TransformOutputProvider
+import io.realm.transformer.BytecodeModifier
+import io.realm.transformer.RealmTransformer
+import io.realm.transformer.ext.safeSubtypeOf
+import io.realm.transformer.logger
+import javassist.CtClass
+import javassist.CtField
+import org.gradle.api.Project
+import java.io.File
+import java.util.jar.JarFile
+
+class FullBuild(project: Project, outputProvider: TransformOutputProvider, transformer: RealmTransformer)
+    : BuildTemplate(project, outputProvider, transformer) {
+
+    private val allModelClasses: ArrayList<CtClass> = arrayListOf()
+
+    override fun prepareOutputClasses(inputs: MutableCollection<TransformInput>) {
+        this.inputs = inputs;
+        categorizeClassNames(inputs, outputClassNames, outputReferencedClassNames)
+        logger.debug("Full build. Files being processed: ${outputClassNames.size}.")
+    }
+
+    override fun categorizeClassNames(inputs: Collection<TransformInput>,
+                                      directoryFiles: MutableSet<String>,
+                                      jarFiles: MutableSet<String>) {
+        inputs.forEach {
+            it.directoryInputs.forEach {
+                val dirPath: String = it.file.absolutePath
+                // Non-incremental build: Include all files
+                it.file.walkTopDown().forEach {
+                    if (it.isFile) {
+                        if (it.absolutePath.endsWith(SdkConstants.DOT_CLASS)) {
+                            val className: String = it.absolutePath
+                                    .substring(dirPath.length + 1, it.absolutePath.length - SdkConstants.DOT_CLASS.length)
+                                    .replace(File.separatorChar, '.')
+                            directoryFiles.add(className)
+                        }
+                    }
+                }
+            }
+
+            it.jarInputs.forEach {
+                val jarFile = JarFile(it.file)
+                jarFile.entries()
+                        .toList()
+                        .filter {
+                            !it.isDirectory && it.name.endsWith(SdkConstants.DOT_CLASS)
+                        }
+                        .forEach {
+                            val path: String = it.name
+                            // The jar might not using File.separatorChar as the path separator. So we just replace both `\` and
+                            // `/`. It depends on how the jar file was created.
+                            // See http://stackoverflow.com/questions/13846000/file-separators-of-path-name-of-zipentry
+                            val className: String = path
+                                    .substring(0, path.length - SdkConstants.DOT_CLASS.length)
+                                    .replace('/', '.')
+                                    .replace('\\', '.')
+                            jarFiles.add(className)
+                        }
+                jarFile.close() // Crash transformer if this fails
+            }
+        }
+    }
+
+    override fun findModelClasses(classNames: Set<String>): Collection<CtClass> {
+        val realmObjectProxyInterface: CtClass = classPool.get("io.realm.internal.RealmObjectProxy")
+
+        // For full builds, we are currently finding model classes by assuming that only
+        // the annotation processor is generating files ending with `RealmProxy`. This is
+        // a lot faster as we only need to compare the name of the type before we load
+        // the CtClass.
+        // Find the model classes
+        return classNames
+            // Quick and loose filter where we assume that classes ending with RealmProxy are
+            // a Realm model proxy class generated by the annotation processor. This can
+            // produce false positives: https://github.com/realm/realm-java/issues/3709
+            .filter { it.endsWith("RealmProxy") }
+            .mapNotNull {
+                // Verify the file is in fact a proxy class, in which case the super
+                // class is always present and is the real model class.
+                val clazz: CtClass = classPool.getCtClass(it)
+                if (clazz.safeSubtypeOf(realmObjectProxyInterface)) {
+                    return@mapNotNull clazz.superclass;
+                } else {
+                    return@mapNotNull null
+                }
+            }
+    }
+
+    override fun filterForModelClasses(classNames: Set<String>, extraClassNames: Set<String>) {
+
+        val allClassNames: Set<String> = merge(classNames, extraClassNames)
+
+        allModelClasses.addAll(findModelClasses(allClassNames))
+
+        outputModelClasses.addAll(allModelClasses.filter {
+            outputClassNames.contains(it.name)
+        })
+    }
+
+    override fun transformDirectAccessToModelFields() {
+        // Populate a list of the fields that need to be managed with bytecode manipulation
+        val allManagedFields: ArrayList<CtField> = arrayListOf()
+        allModelClasses.forEach {
+            allManagedFields.addAll(it.declaredFields.filter {
+                BytecodeModifier.isModelField(it)
+            })
+        }
+        logger.debug("Managed Fields: ${allManagedFields.joinToString(",") { it.name }}")
+
+        // Use accessors instead of direct field access
+        outputClassNames.forEach {
+            logger.debug("Modify accessors in class: $it")
+            val ctClass: CtClass = classPool.getCtClass(it)
+            BytecodeModifier.useRealmAccessors(classPool, ctClass, allManagedFields)
+            ctClass.writeFile(getOutputFile(outputProvider).canonicalPath)
+        }
+    }
+
+    private fun merge(set1: Set<String>, set2: Set<String>): Set<String>  {
+        val merged: MutableSet<String> = hashSetOf()
+        merged.addAll(set1)
+        merged.addAll(set2)
+        return merged
+    }
+
+}
\ No newline at end of file
diff --git a/realm-transformer/src/main/kotlin/io/realm/transformer/build/IncrementalBuild.kt b/realm-transformer/src/main/kotlin/io/realm/transformer/build/IncrementalBuild.kt
new file mode 100644
index 0000000000..8a9c9b9783
--- /dev/null
+++ b/realm-transformer/src/main/kotlin/io/realm/transformer/build/IncrementalBuild.kt
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.transformer.build
+
+import com.android.SdkConstants
+import com.android.build.api.transform.Status
+import com.android.build.api.transform.TransformInput
+import com.android.build.api.transform.TransformOutputProvider
+import io.realm.annotations.RealmClass
+import io.realm.transformer.BytecodeModifier
+import io.realm.transformer.RealmTransformer
+import io.realm.transformer.ext.safeSubtypeOf
+import io.realm.transformer.logger
+import javassist.CtClass
+import javassist.NotFoundException
+import org.gradle.api.Project
+import java.io.File
+import java.util.jar.JarFile
+
+class IncrementalBuild(project: Project, outputProvider: TransformOutputProvider, transform: RealmTransformer)
+    : BuildTemplate(project, outputProvider, transform) {
+
+    override fun prepareOutputClasses(inputs: MutableCollection<TransformInput>) {
+        this.inputs = inputs;
+        categorizeClassNames(inputs, outputClassNames, outputReferencedClassNames) // Output files
+        logger.debug("Incremental build. Files being processed: ${outputClassNames.size}.")
+        logger.debug("Incremental files: ${outputClassNames.joinToString(",")}")
+    }
+
+    override fun filterForModelClasses(outputClassNames: Set<String>, outputReferencedClassNames: Set<String>) {
+        outputModelClasses.addAll(findModelClasses(outputClassNames))
+    }
+
+    override fun transformDirectAccessToModelFields() {
+        // Use accessors instead of direct field access
+        outputClassNames.forEach {
+            logger.debug("Modify accessors in class: $it")
+            val ctClass: CtClass = classPool.getCtClass(it)
+            BytecodeModifier.useRealmAccessors(classPool, ctClass, null)
+            ctClass.writeFile(getOutputFile(outputProvider).canonicalPath)
+        }
+
+    }
+
+
+    /**
+     * Categorize the transform input into its two main categorizes: `directoryFiles` which are
+     * source files in the current project and `jarFiles` which are source files found in jars.
+     *
+     * @param inputs set of input files
+     * @param directoryFiles the set of files in directories getting compiled. These are candidates for the transformer.
+     * @param jarFiles the set of files that are possible referenced but never transformed (required by JavaAssist).
+     * @param isIncremental `true` if build is incremental.
+     */
+    override fun categorizeClassNames(inputs: Collection<TransformInput>,
+                             directoryFiles: MutableSet<String>,
+                             jarFiles: MutableSet<String>) {
+        inputs.forEach {
+             it.directoryInputs.forEach {
+                val dirPath: String = it.file.absolutePath
+
+                 it.changedFiles.entries.forEach {
+                    if (it.value == Status.NOTCHANGED || it.value == Status.REMOVED) {
+                        return@forEach
+                    }
+                    val filePath: String = it.key.absolutePath
+                    if (filePath.endsWith(SdkConstants.DOT_CLASS)) {
+                        val className = filePath
+                                .substring(dirPath.length + 1, filePath.length - SdkConstants.DOT_CLASS.length)
+                                .replace(File.separatorChar, '.')
+                        directoryFiles.add(className)
+                    }
+                }
+            }
+
+            it.jarInputs.forEach {
+                if (it.status == Status.REMOVED) {
+                    return@forEach
+                }
+
+                val jarFile = JarFile(it.file)
+                jarFile.entries()
+                        .toList()
+                        .filter {
+                            !it.isDirectory && it.name.endsWith(SdkConstants.DOT_CLASS)
+                        }
+                        .forEach {
+                            val path: String = it.name
+                            // The jar might not using File.separatorChar as the path separator. So we just replace both `\` and
+                            // `/`. It depends on how the jar file was created.
+                            // See http://stackoverflow.com/questions/13846000/file-separators-of-path-name-of-zipentry
+                            val className: String = path
+                                    .substring(0, path.length - SdkConstants.DOT_CLASS.length)
+                                    .replace('/', '.')
+                                    .replace('\\', '.')
+                            jarFiles.add(className)
+                        }
+                jarFile.close() // Crash transformer if this fails
+            }
+        }
+    }
+
+    override fun findModelClasses(classNames: Set<String>): Collection<CtClass> {
+        val realmObjectProxyInterface: CtClass = classPool.get("io.realm.internal.RealmObjectProxy")
+        // For incremental builds we need to determine if a class is a model class file
+        // based on information in the file itself. This require checks that are only
+        // possible once we loaded the CtClass from the ClassPool and is slower
+        // than the approach used when doing full builds.
+        return classNames
+                // Map strings to CtClass'es.
+                .map { classPool.getCtClass(it) }
+                // Model classes either have the @RealmClass annotation directly (if implementing RealmModel)
+                // or their superclass has it (if extends RealmObject). The annotation processor
+                // will have ensured the annotation is only present in these cases.
+                .filter {
+                    var result: Boolean
+                    if (it.hasAnnotation(RealmClass::class.java)) {
+                        result = true
+                    } else {
+                        try {
+                            result = it.superclass?.hasAnnotation(RealmClass::class.java) == true
+                        } catch (e: NotFoundException) {
+                            // Can happen if the super class is part of the `android.jar` which might
+                            // not have been loaded. In any case, any base class part of Android cannot
+                            // be a Realm model class.
+                            result = false
+                        }
+                    }
+                    return@filter result
+                }
+                // Proxy classes are generated by the Realm Annotation Processor and might accidentally
+                // pass the above check (e.g. if the model class has the @RealmClass annotation), so
+                // ignore them.
+                .filter { !it.safeSubtypeOf(realmObjectProxyInterface) }
+                // Unfortunately the RealmObject base class passes all above checks, so explicitly
+                // ignore it.
+                .filter { !it.name.equals("io.realm.RealmObject") }
+    }
+}
\ No newline at end of file
diff --git a/realm-transformer/src/main/kotlin/io/realm/transformer/ext/CtClassExt.kt b/realm-transformer/src/main/kotlin/io/realm/transformer/ext/CtClassExt.kt
new file mode 100644
index 0000000000..24a8511672
--- /dev/null
+++ b/realm-transformer/src/main/kotlin/io/realm/transformer/ext/CtClassExt.kt
@@ -0,0 +1,67 @@
+package io.realm.transformer.ext
+
+import javassist.CtClass
+import javassist.NotFoundException
+import javassist.bytecode.ClassFile
+
+
+/**
+ * Returns {@code true} if 'clazz' is considered a subtype of 'superType'.
+ *
+ * This function is different than {@link CtClass#subtypeOf(CtClass)} in the sense
+ * that it will never crash even if classes are missing from the class pool, instead
+ * it will just return {@code false}.
+ *
+ * This e.g. happens with RxJava classes which are optional, but JavaAssist will try
+ * to load them and then crash.
+ *
+ * @param typeToCheckAgainst the type we want to check against
+ * @return `true` if `clazz` is a subtype of `typeToCheckAgainst`, `false` otherwise.
+ */
+fun CtClass.safeSubtypeOf(typeToCheckAgainst: CtClass): Boolean {
+    val typeToCheckAgainstQualifiedName: String = typeToCheckAgainst.name
+    if (this == typeToCheckAgainst || this.name.equals(typeToCheckAgainstQualifiedName)) {
+        return true
+    }
+
+    val file: ClassFile = this.classFile2
+
+    // Check direct super class
+    val superName: String? = file.superclass
+    if (superName.equals(typeToCheckAgainstQualifiedName)) {
+        return true
+    }
+
+    // Check direct interfaces
+    val ifs: Array<String> = file.interfaces
+    ifs.forEach {
+        if (it == typeToCheckAgainstQualifiedName) {
+            return true
+        }
+    }
+
+    // Check other inherited super classes
+    if (superName != null) {
+        var nextSuper: CtClass
+        try {
+            nextSuper = classPool.get(superName)
+            if (nextSuper.safeSubtypeOf(typeToCheckAgainst)) {
+                return true
+            }
+        } catch (ignored: NotFoundException) {
+        }
+    }
+
+    // Check other inherited interfaces
+    ifs.forEach { interfaceName ->
+        try {
+            val interfaceClass: CtClass = classPool.get(interfaceName)
+            if (interfaceClass.safeSubtypeOf(typeToCheckAgainst)) {
+                return true
+            }
+        } catch (ignored: NotFoundException) {
+        }
+    }
+
+    return false
+}
diff --git a/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy b/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
index 2e2e6cd279..e9abb6b751 100644
--- a/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
+++ b/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
@@ -155,7 +155,7 @@ class BytecodeModifierTest extends Specification {
         BytecodeModifier.addRealmAccessors(ctClass)
 
         when: 'the field use is replaced by the accessor'
-        BytecodeModifier.useRealmAccessors(ctClass, [ctField])
+        BytecodeModifier.useRealmAccessors(classPool, ctClass, [ctField])
 
         then: 'the field is not used and getter is called in the method '
         !isFieldRead(ctMethod) && hasMethodCall(ctMethod)
@@ -186,7 +186,7 @@ class BytecodeModifierTest extends Specification {
         BytecodeModifier.addRealmAccessors(ctClass)
 
         when: 'the field use is replaced by the accessor'
-        BytecodeModifier.useRealmAccessors(ctClass, [ctField])
+        BytecodeModifier.useRealmAccessors(classPool, ctClass, [ctField])
 
         then: 'the field is not used in the method anymore'
         !isFieldRead(ctDefaultConstructor) && hasMethodCall(ctDefaultConstructor) &&
diff --git a/realm/build.gradle b/realm/build.gradle
index 82f7c806cf..f18e16dbc4 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -4,7 +4,7 @@ project.ext.buildToolsVersion = '27.0.2'
 
 buildscript {
     ext.kotlin_version = '1.2.10'
-    ext.dokka_version = '0.9.15'
+    ext.dokka_version = '0.9.16'
     repositories {
         mavenLocal()
         google()
diff --git a/realm/kotlin-extensions/build.gradle b/realm/kotlin-extensions/build.gradle
index 3ba0e38c80..532b468d5f 100644
--- a/realm/kotlin-extensions/build.gradle
+++ b/realm/kotlin-extensions/build.gradle
@@ -15,7 +15,7 @@ apply plugin: 'org.jetbrains.dokka'
 //apply plugin: 'net.ltgt.errorprone'
 
 import io.realm.transformer.RealmTransformer
-android.registerTransform(new RealmTransformer())
+android.registerTransform(new RealmTransformer(project))
 
 android {
     compileSdkVersion rootProject.compileSdkVersion
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index 8292873163..bcbb25cf26 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -20,6 +20,7 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
@@ -60,11 +61,11 @@
 
     private final TypeElement classType; // Reference to model class.
     private final String javaClassName; // Model class simple name as defined in Java.
-    private final List<RealmFieldElement> fields = new ArrayList<RealmFieldElement>(); // List of all fields in the class except those @Ignored.
-    private final List<RealmFieldElement> indexedFields = new ArrayList<RealmFieldElement>(); // list of all fields marked @Index.
-    private final Set<Backlink> backlinks = new HashSet<Backlink>();
-    private final Set<RealmFieldElement> nullableFields = new HashSet<RealmFieldElement>(); // Set of fields which can be nullable
-    private final Set<RealmFieldElement> nullableValueListFields = new HashSet<RealmFieldElement>(); // Set of fields whose elements can be nullable
+    private final List<RealmFieldElement> fields = new ArrayList<>(); // List of all fields in the class except those @Ignored.
+    private final List<RealmFieldElement> indexedFields = new ArrayList<>(); // list of all fields marked @Index.
+    private final Set<Backlink> backlinks = new LinkedHashSet<>();
+    private final Set<RealmFieldElement> nullableFields = new LinkedHashSet<>(); // Set of fields which can be nullable
+    private final Set<RealmFieldElement> nullableValueListFields = new LinkedHashSet<>(); // Set of fields whose elements can be nullable
 
     private String packageName; // package name for model class.
     private boolean hasDefaultConstructor; // True if model has a public no-arg constructor.
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
index cdae9807cc..948f662225 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
@@ -22,6 +22,7 @@
 import java.io.IOException;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.Locale;
 import java.util.Map;
 
@@ -53,7 +54,7 @@ public void generate() throws IOException {
         writer.emitPackage(Constants.REALM_PACKAGE_NAME);
         writer.emitEmptyLine();
 
-        Map<String, Boolean> attributes = new HashMap<String, Boolean>();
+        Map<String, Boolean> attributes = new LinkedHashMap<>();
         attributes.put("allClasses", Boolean.TRUE);
         writer.emitAnnotation(RealmModule.class, attributes);
         writer.beginType(
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
index d9488d92e6..c713790379 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
@@ -19,6 +19,7 @@
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -63,16 +64,16 @@
 
     // Pre-processing
     // <FullyQualifiedModuleClassName, X>
-    private Set<String> globalModules = new HashSet<>(); // All modules with `allClasses = true` set
-    private Map<String, Set<String>> specificClassesModules = new HashMap<>(); // Modules with classes specifically named
-    private Map<String, RealmNamingPolicy> classNamingPolicy = new HashMap<String, RealmNamingPolicy>();
-    private Map<String, RealmNamingPolicy> fieldNamingPolicy = new HashMap<String, RealmNamingPolicy>();
+    private Set<String> globalModules = new LinkedHashSet<>(); // All modules with `allClasses = true` set
+    private Map<String, Set<String>> specificClassesModules = new LinkedHashMap<>(); // Modules with classes specifically named
+    private Map<String, RealmNamingPolicy> classNamingPolicy = new LinkedHashMap<>();
+    private Map<String, RealmNamingPolicy> fieldNamingPolicy = new LinkedHashMap<>();
     private Map<String, RealmModule> moduleAnnotations = new HashMap<>();
 
     // Post-processing
     // <FullyQualifiedModuleClassName, X>
-    private Map<String, Set<ClassMetaData>> modules = new HashMap<String, Set<ClassMetaData>>();
-    private Map<String, Set<ClassMetaData>> libraryModules = new HashMap<String, Set<ClassMetaData>>();
+    private Map<String, Set<ClassMetaData>> modules = new LinkedHashMap<>();
+    private Map<String, Set<ClassMetaData>> libraryModules = new LinkedHashMap<>();
 
     private boolean shouldCreateDefaultModule;
 
@@ -386,7 +387,7 @@ private AnnotationValue getAnnotationValue(AnnotationMirror annotationMirror) {
      * Returns all module classes and the RealmObjects they know of.
      */
     public Map<String, Set<ClassMetaData>> getAllModules() {
-        Map<String, Set<ClassMetaData>> allModules = new HashMap<String, Set<ClassMetaData>>();
+        Map<String, Set<ClassMetaData>> allModules = new LinkedHashMap<>();
         allModules.putAll(modules);
         allModules.putAll(libraryModules);
         return allModules;
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index 20fa873053..7cb75bd181 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -188,7 +188,7 @@ coveralls.jacocoReportPath = "${buildDir}/reports/coverage/debug/report.xml"
 
 import io.realm.transformer.RealmTransformer
 
-android.registerTransform(new RealmTransformer())
+android.registerTransform(new RealmTransformer(project))
 
 repositories {
     maven { url "https://jitpack.io" }
@@ -204,7 +204,7 @@ dependencies {
     implementation 'com.google.code.findbugs:jsr305:3.0.2'
     implementation 'com.getkeepsafe.relinker:relinker:1.2.2'
 
-    kaptObjectServer project(':realm-annotations-processor')
+    kapt project(':realm-annotations-processor') // See https://github.com/realm/realm-java/issues/5799
     objectServerImplementation 'com.squareup.okhttp3:okhttp:3.9.0'
 
     kaptAndroidTest project(':realm-annotations-processor')
diff --git a/realm/realm-library/src/main/java/io/realm/internal/sync/BaseModule.java b/realm/realm-library/src/main/java/io/realm/internal/sync/BaseModule.java
new file mode 100644
index 0000000000..91f1e68b7a
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/sync/BaseModule.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.sync;
+
+import io.realm.annotations.RealmModule;
+
+// Workaround preventing `io.realm.DefaultRealmModuleMediator` being generated in the
+// Realm JAR. Related to `https://github.com/realm/realm-java/issues/5799
+@RealmModule(library = true, allClasses = true)
+public class BaseModule {
+}
diff --git a/version.txt b/version.txt
index 92baa8632a..4b448de535 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-5.2.0-SNAPSHOT
+5.3.0-SNAPSHOT
\ No newline at end of file
