diff --git a/CHANGELOG.md b/CHANGELOG.md
index 5ae3a5bf1d..3dc541ed7d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -4,6 +4,7 @@
 
 ### Enhancements
 
+* [ObjectServer] Added support for Sync Progress Notifications through `SyncSession.addDownloadProgressListener(ProgressMode, ProgressListener)` and `SyncSession.addUploadProgressListener(ProgressMode, ProgressListener)` (#4104).
 * Added support for querying inverse relationships (#2904).
 * Moved inverse relationships out of beta stage.
 * Added `Realm.getDefaultConfiguration()` (#4725).
@@ -15,6 +16,17 @@
 * Upgraded to Realm Sync 1.9.1
 * Upgraded to Realm Core 2.8.0
 
+## 3.3.3 (YYYY-MM-DD)
+
+### Breaking Changes
+
+### Enhancements
+
+### Bug Fixes
+
+* When converting nullable BLOB field to required, `null` values should be converted to `byte[0]` instead of `byte[1]`.
+
+### Internal
 
 ## 3.3.2 (2017-06-09)
 
diff --git a/examples/objectServerExample/build.gradle b/examples/objectServerExample/build.gradle
index e3080cda9f..e976f16d01 100644
--- a/examples/objectServerExample/build.gradle
+++ b/examples/objectServerExample/build.gradle
@@ -61,7 +61,9 @@ realm {
 
 dependencies {
     compile 'com.android.support:support-v4:25.2.0'
+    compile 'com.android.support:appcompat-v7:25.2.0'
     compile 'com.android.support:design:25.2.0'
+    compile 'me.zhanghai.android.materialprogressbar:library:1.3.0'
     compile 'com.jakewharton:butterknife:8.5.1'
     annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1'
 }
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
index 97c67d2443..536b24ef90 100644
--- a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
@@ -17,32 +17,67 @@
 package io.realm.examples.objectserver;
 
 import android.content.Intent;
+import android.graphics.PorterDuff;
 import android.os.Bundle;
+import android.support.annotation.ColorRes;
 import android.support.v7.app.AppCompatActivity;
 import android.view.Menu;
 import android.view.MenuItem;
+import android.view.View;
 import android.widget.TextView;
 
 import java.util.Locale;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import butterknife.BindView;
 import butterknife.ButterKnife;
 import butterknife.OnClick;
+import io.realm.Progress;
+import io.realm.ProgressListener;
+import io.realm.ProgressMode;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
 import io.realm.SyncConfiguration;
+import io.realm.SyncManager;
+import io.realm.SyncSession;
 import io.realm.SyncUser;
 import io.realm.examples.objectserver.model.CRDTCounter;
+import me.zhanghai.android.materialprogressbar.MaterialProgressBar;
 
 public class CounterActivity extends AppCompatActivity {
 
     private static final String REALM_URL = "realm://" + BuildConfig.OBJECT_SERVER_IP + ":9080/~/default";
 
     private Realm realm;
+    private SyncSession session;
     private CRDTCounter counter;
     private SyncUser user;
+    private AtomicBoolean downloadingChanges = new AtomicBoolean(false);
+    private AtomicBoolean uploadingChanges = new AtomicBoolean(false);
+    private ProgressListener downloadListener = new ProgressListener() {
+        @Override
+        public void onChange(Progress progress) {
+            downloadingChanges.set(!progress.isTransferComplete());
+            runOnUiThread(updateProgressBar);
+        }
+    };
+    private ProgressListener uploadListener = new ProgressListener() {
+        @Override
+        public void onChange(Progress progress) {
+            uploadingChanges.set(!progress.isTransferComplete());
+            runOnUiThread(updateProgressBar);
+        }
+    };
+    private Runnable updateProgressBar = new Runnable() {
+        @Override
+        public void run() {
+            updateProgressBar(downloadingChanges.get(), uploadingChanges.get());
+        }
+    };
+
 
     @BindView(R.id.text_counter) TextView counterView;
+    @BindView(R.id.progressbar) MaterialProgressBar progressBar;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -86,12 +121,21 @@ public void onChange(CRDTCounter counter) {
                 }
             });
             counterView.setText("0");
+
+            // Setup progress listeners for indeterminate progress bars
+            session = SyncManager.getSession(config);
+            session.addDownloadProgressListener(ProgressMode.INDEFINITELY, downloadListener);
+            session.addUploadProgressListener(ProgressMode.INDEFINITELY, uploadListener);
         }
     }
 
     @Override
     protected void onStop() {
         super.onStop();
+        if (session != null) {
+            session.removeProgressListener(downloadListener);
+            session.removeProgressListener(uploadListener);
+        }
         closeRealm();
         user = null;
     }
@@ -132,6 +176,22 @@ public void decrementCounter() {
         adjustCounter(-1);
     }
 
+    private void updateProgressBar(boolean downloading, boolean uploading) {
+        @ColorRes int color = android.R.color.black;
+        int visibility = View.VISIBLE;
+        if (downloading && uploading) {
+            color = R.color.progress_both;
+        } else if (downloading) {
+            color = R.color.progress_download;
+        } else if (uploading) {
+            color = R.color.progress_upload;
+        } else {
+            visibility = View.GONE;
+        }
+        progressBar.getIndeterminateDrawable().setColorFilter(getResources().getColor(color), PorterDuff.Mode.SRC_IN);
+        progressBar.setVisibility(visibility);
+    }
+
     private void adjustCounter(final int adjustment) {
         // A synchronized Realm can get written to at any point in time, so doing synchronous writes on the UI
         // thread is HIGHLY discouraged as it might block longer than intended. Only use async transactions.
diff --git a/examples/objectServerExample/src/main/res/layout/activity_counter.xml b/examples/objectServerExample/src/main/res/layout/activity_counter.xml
index 62127eca0d..df73031aa7 100644
--- a/examples/objectServerExample/src/main/res/layout/activity_counter.xml
+++ b/examples/objectServerExample/src/main/res/layout/activity_counter.xml
@@ -1,7 +1,9 @@
 <RelativeLayout
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="match_parent"
-    android:layout_height="match_parent">
+    android:layout_height="match_parent"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+
 
     <LinearLayout
         android:layout_width="match_parent"
@@ -34,4 +36,15 @@
         android:fontFamily="sans-serif-light"
         android:textSize="160sp"/>
 
+    <me.zhanghai.android.materialprogressbar.MaterialProgressBar
+        android:id="@+id/progressbar"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_gravity="top"
+        android:indeterminate="true"
+        app:mpb_progressStyle="horizontal"
+        android:visibility="gone"
+        style="@style/Widget.MaterialProgressBar.ProgressBar.Horizontal.NoPadding"
+        />
+
 </RelativeLayout>
diff --git a/examples/objectServerExample/src/main/res/values/realm_colors.xml b/examples/objectServerExample/src/main/res/values/realm_colors.xml
index aada8ea195..3d435a5c44 100644
--- a/examples/objectServerExample/src/main/res/values/realm_colors.xml
+++ b/examples/objectServerExample/src/main/res/values/realm_colors.xml
@@ -1,12 +1,12 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
-    // Grays
+    <!-- Grays -->
     <color name="charcoal">#1C233F</color>
     <color name="elephant">#9A9BA5</color>
     <color name="elephant_half">#b1b3bf</color>
     <color name="dove">#EBEBF2</color>
 
-    // Orb colors
+    <!-- Orb colors -->
     <color name="ultramarine">#39477F</color>
     <color name="indigo">#59569E</color>
     <color name="grape_jelly">#9A59A5</color>
@@ -16,8 +16,13 @@
     <color name="peach">#FC9F95</color>
     <color name="melon">#FCC397</color>
 
-    // Material adjustments
+    <!-- Material adjustments -->
     <color name="flamingo_darker">#d64881</color>
     <color name="touch_area_pressed">#dadada</color>
 
+    <!-- Progress bar colors -->
+    <color name="progress_upload">#EF5350</color>
+    <color name="progress_download">#9CCC65</color>
+    <color name="progress_both">#FFA726</color>
+
 </resources>
\ No newline at end of file
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
index 2239201e2e..1b93e5b355 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
@@ -46,107 +46,24 @@
         JAVA_TO_JSON_TYPES.put("java.lang.Double", new SimpleTypeConverter("double", "Double"));
         JAVA_TO_JSON_TYPES.put("java.lang.Boolean", new SimpleTypeConverter("boolean", "Boolean"));
         JAVA_TO_JSON_TYPES.put("java.lang.String", new SimpleTypeConverter("String", "String"));
-        JAVA_TO_JSON_TYPES.put("java.util.Date", new JsonToRealmFieldTypeConverter() {
-            // @formatter:off
-            @Override
-            public void emitTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
-                JavaWriter writer) throws IOException {
-                writer
-                    .beginControlFlow("if (json.has(\"%s\"))", fieldName)
-                        .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                            .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
-                        .nextControlFlow("else")
-                            .emitStatement("Object timestamp = json.get(\"%s\")", fieldName)
-                            .beginControlFlow("if (timestamp instanceof String)")
-                               .emitStatement("((%s) obj).%s(JsonUtils.stringToDate((String) timestamp))",
-                                       interfaceName, setter)
-                            .nextControlFlow("else")
-                                .emitStatement("((%s) obj).%s(new Date(json.getLong(\"%s\")))", interfaceName, setter,
-                                        fieldName)
-                            .endControlFlow()
-                        .endControlFlow()
-                    .endControlFlow();
-            }
-            //@formatter:on
-
-            // @formatter:off
-            @Override
-            public void emitStreamTypeConversion(String interfaceName, String setter, String fieldName,
-                String fieldType, JavaWriter writer, boolean isPrimaryKey) throws IOException {
-                writer
-                    .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
-                        .emitStatement("reader.skipValue()")
-                        .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
-                    .nextControlFlow("else if (reader.peek() == JsonToken.NUMBER)")
-                        .emitStatement("long timestamp = reader.nextLong()", fieldName)
-                        .beginControlFlow("if (timestamp > -1)")
-                            .emitStatement("((%s) obj).%s(new Date(timestamp))", interfaceName, setter)
-                        .endControlFlow()
-                    .nextControlFlow("else")
-                        .emitStatement("((%s) obj).%s(JsonUtils.stringToDate(reader.nextString()))", interfaceName,
-                                setter)
-                    .endControlFlow();
-            }
-            //@formatter:on
-
-            @Override
-            public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
-                    String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer) throws IOException {
-                throw new IllegalArgumentException("'Date' is not allowed as a primary key value.");
-            }
-        });
-        JAVA_TO_JSON_TYPES.put("byte[]", new JsonToRealmFieldTypeConverter() {
-            // @formatter:off
-            @Override
-            public void emitTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
-                JavaWriter writer) throws IOException {
-                writer
-                    .beginControlFlow("if (json.has(\"%s\"))", fieldName)
-                        .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                            .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
-                        .nextControlFlow("else")
-                            .emitStatement("((%s) obj).%s(JsonUtils.stringToBytes(json.getString(\"%s\")))",
-                                    interfaceName, setter, fieldName)
-                        .endControlFlow()
-                    .endControlFlow();
-            }
-            //@formatter:on
-
-            // @formatter:off
-            @Override
-            public void emitStreamTypeConversion(String interfaceName, String setter, String fieldName,
-                String fieldType, JavaWriter writer, boolean isPrimaryKey) throws IOException {
-                writer
-                    .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
-                        .emitStatement("reader.skipValue()")
-                        .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
-                    .nextControlFlow("else")
-                        .emitStatement("((%s) obj).%s(JsonUtils.stringToBytes(reader.nextString()))", interfaceName,
-                                setter)
-                    .endControlFlow();
-            }
-            //@formatter:on
-
-            @Override
-            public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
-                    String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer) throws IOException {
-                throw new IllegalArgumentException("'byte[]' is not allowed as a primary key value.");
-            }
-        });
+        JAVA_TO_JSON_TYPES.put("java.util.Date", new DateTypeConverter());
+        JAVA_TO_JSON_TYPES.put("byte[]", new ByteArrayTypeConverter());
     }
 
-    public static void emitCreateObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
-            String qualifiedRealmObjectProxyClass, String qualifiedFieldType, String fieldName, JavaWriter writer)
+    public static void emitCreateObjectWithPrimaryKeyValue(
+            String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass,
+            String qualifiedFieldType, String fieldName, JavaWriter writer)
             throws IOException {
         JsonToRealmFieldTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(qualifiedFieldType);
         if (typeEmitter != null) {
-            typeEmitter.emitGetObjectWithPrimaryKeyValue(qualifiedRealmObjectClass, qualifiedRealmObjectProxyClass,
-                    fieldName, writer);
+            typeEmitter.emitGetObjectWithPrimaryKeyValue(
+                    qualifiedRealmObjectClass, qualifiedRealmObjectProxyClass, fieldName, writer);
         }
     }
 
-    public static void emitFillJavaTypeWithJsonValue(String interfaceName, String setter, String fieldName,
-            String qualifiedFieldType, JavaWriter writer) throws IOException {
+    public static void emitFillJavaTypeWithJsonValue(
+            String interfaceName, String setter, String fieldName, String qualifiedFieldType, JavaWriter writer)
+            throws IOException {
         JsonToRealmFieldTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(qualifiedFieldType);
         if (typeEmitter != null) {
             typeEmitter.emitTypeConversion(interfaceName, setter, fieldName, qualifiedFieldType, writer);
@@ -155,26 +72,30 @@ public static void emitFillJavaTypeWithJsonValue(String interfaceName, String se
 
     public static void emitIllegalJsonValueException(String fieldType, String fieldName, JavaWriter writer)
             throws IOException {
-        writer.beginControlFlow("if (json.has(\"%s\"))", fieldName);
-        writer.emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_JSON_LOAD, fieldType, fieldName);
-        writer.endControlFlow();
+        writer
+                .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_JSON_LOAD, fieldType, fieldName)
+                .endControlFlow();
     }
 
     // @formatter:off
-    public static void emitFillRealmObjectWithJsonValue(String interfaceName, String setter, String fieldName,
-        String qualifiedFieldType, String proxyClass, JavaWriter writer) throws IOException {
+    public static void emitFillRealmObjectWithJsonValue(
+            String interfaceName, String setter, String fieldName,
+            String qualifiedFieldType, String proxyClass, JavaWriter writer)
+            throws IOException {
         writer
             .beginControlFlow("if (json.has(\"%s\"))", fieldName)
                 .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
                     .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
                 .nextControlFlow("else")
-                    .emitStatement("%s %sObj = %s.createOrUpdateUsingJsonObject(realm, json.getJSONObject(\"%s\"), update)",
+                    .emitStatement(
+                            "%s %sObj = %s.createOrUpdateUsingJsonObject(realm, json.getJSONObject(\"%s\"), update)",
                             qualifiedFieldType, fieldName, proxyClass, fieldName)
                     .emitStatement("((%s) obj).%s(%sObj)", interfaceName, setter, fieldName)
                 .endControlFlow()
             .endControlFlow();
     }
-    //@formatter:on
+    // @formatter:on
 
     // @formatter:off
     public static void emitFillRealmListWithJsonValue(String interfaceName, String getter, String setter,
@@ -187,25 +108,24 @@ public static void emitFillRealmListWithJsonValue(String interfaceName, String g
                     .emitStatement("((%s) obj).%s().clear()", interfaceName, getter)
                     .emitStatement("JSONArray array = json.getJSONArray(\"%s\")", fieldName)
                     .beginControlFlow("for (int i = 0; i < array.length(); i++)")
-                        .emitStatement("%s item = %s.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update)",
+                        .emitStatement(
+                                "%s item = %s.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update)",
                                 fieldTypeCanonicalName, proxyClass, fieldTypeCanonicalName)
                         .emitStatement("((%s) obj).%s().add(item)", interfaceName, getter)
                     .endControlFlow()
                 .endControlFlow()
             .endControlFlow();
     }
-    //@formatter:on
+    // @formatter:on
 
-    public static void emitFillJavaTypeFromStream(String interfaceName, ClassMetaData metaData, String fieldName,
-            String fieldType, JavaWriter writer) throws IOException {
+    public static void emitFillJavaTypeFromStream(
+            String interfaceName, ClassMetaData metaData, String fieldName, String fieldType, JavaWriter writer)
+            throws IOException {
         String setter = metaData.getInternalSetter(fieldName);
-        boolean isPrimaryKey = false;
-        if (metaData.hasPrimaryKey() && metaData.getPrimaryKey().getSimpleName().toString().equals(fieldName)) {
-            isPrimaryKey = true;
-        }
+        boolean isPrimaryKey = metaData.hasPrimaryKey() && metaData.getPrimaryKey().getSimpleName().toString().equals(fieldName);
         if (JAVA_TO_JSON_TYPES.containsKey(fieldType)) {
-            JAVA_TO_JSON_TYPES.get(fieldType).emitStreamTypeConversion(interfaceName, setter, fieldName, fieldType,
-                    writer, isPrimaryKey);
+            JAVA_TO_JSON_TYPES.get(fieldType)
+                    .emitStreamTypeConversion(interfaceName, setter, fieldName, fieldType, writer, isPrimaryKey);
         }
     }
 
@@ -217,12 +137,13 @@ public static void emitFillRealmObjectFromStream(String interfaceName, String se
                 .emitStatement("reader.skipValue()")
                 .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
             .nextControlFlow("else")
-                .emitStatement("%s %sObj = %s.createUsingJsonStream(realm, reader)", fieldTypeCanonicalName, fieldName,
-                        proxyClass)
+                .emitStatement(
+                        "%s %sObj = %s.createUsingJsonStream(realm, reader)",
+                        fieldTypeCanonicalName, fieldName, proxyClass)
                 .emitStatement("((%s) obj).%s(%sObj)", interfaceName, setter, fieldName)
             .endControlFlow();
     }
-    //@formatter:on
+    // @formatter:on
 
     // @formatter:off
     public static void emitFillRealmListFromStream(String interfaceName, String getter, String setter,
@@ -241,10 +162,9 @@ public static void emitFillRealmListFromStream(String interfaceName, String gett
                 .emitStatement("reader.endArray()")
             .endControlFlow();
     }
-    //@formatter:on
+    // @formatter:on
 
     private static class SimpleTypeConverter implements JsonToRealmFieldTypeConverter {
-
         private final String castType;
         private final String jsonType;
 
@@ -261,40 +181,38 @@ private SimpleTypeConverter(String castType, String jsonType) {
         }
 
         @Override
-        public void emitTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
-                JavaWriter writer) throws IOException {
-            String statementSetNullOrThrow;
-            if (Utils.isPrimitiveType(fieldType)) {
-                // Only throw exception for primitive types. For boxed types and String, exception will be thrown in
-                // the setter.
-                statementSetNullOrThrow = String.format(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName);
-            } else {
-                statementSetNullOrThrow = String.format("((%s) obj).%s(null)", interfaceName, setter);
-            }
+        public void emitTypeConversion(
+                String interfaceName, String setter, String fieldName, String fieldType, JavaWriter writer)
+                throws IOException {
+            // Only throw exception for primitive types.
+            // For boxed types and String, exception will be thrown in the setter.
+            String statementSetNullOrThrow = Utils.isPrimitiveType(fieldType) ?
+                    String.format(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName) :
+                    String.format("((%s) obj).%s(null)", interfaceName, setter);
             // @formatter:off
             writer
                 .beginControlFlow("if (json.has(\"%s\"))", fieldName)
                     .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
                         .emitStatement(statementSetNullOrThrow)
                     .nextControlFlow("else")
-                        .emitStatement("((%s) obj).%s((%s) json.get%s(\"%s\"))", interfaceName, setter, castType,
-                                jsonType, fieldName)
+                        .emitStatement(
+                                "((%s) obj).%s((%s) json.get%s(\"%s\"))",
+                                interfaceName, setter, castType, jsonType, fieldName)
                     .endControlFlow()
                 .endControlFlow();
-            //@formatter:on
+            // @formatter:on
         }
 
         @Override
-        public void emitStreamTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
-                JavaWriter writer, boolean isPrimaryKey) throws IOException {
-            String statementSetNullOrThrow;
-            if (Utils.isPrimitiveType(fieldType)) {
-                // Only throw exception for primitive types. For boxed types and String, exception will be thrown in
-                // the setter.
-                statementSetNullOrThrow = String.format(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName);
-            } else {
-                statementSetNullOrThrow = String.format("((%s) obj).%s(null)", interfaceName, setter);
-            }
+        public void emitStreamTypeConversion(
+                String interfaceName, String setter, String fieldName,
+                String fieldType, JavaWriter writer, boolean isPrimaryKey)
+                throws IOException {
+            // Only throw exception for primitive types. For boxed types and String, exception will be thrown in
+            // the setter.
+            String statementSetNullOrThrow = (Utils.isPrimitiveType(fieldType)) ?
+                    String.format(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName) :
+                    String.format("((%s) obj).%s(null)", interfaceName, setter);
             // @formatter:off
             writer
                 .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
@@ -306,7 +224,7 @@ public void emitStreamTypeConversion(String interfaceName, String setter, String
             if (isPrimaryKey) {
                 writer.emitStatement("jsonHasPrimaryKey = true");
             }
-            //@formatter:on
+            // @formatter:on
         }
 
         // @formatter:off
@@ -326,10 +244,100 @@ public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
                     .endControlFlow()
                 .nextControlFlow("else")
                     .emitStatement(Constants.STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON, fieldName)
-                    .endControlFlow();
+                .endControlFlow();
+        }
+        // @formatter:on
+    }
+
+    private static class DateTypeConverter implements JsonToRealmFieldTypeConverter {
+        // @formatter:off
+        @Override
+        public void emitTypeConversion(
+                String interfaceName, String setter, String fieldName, String fieldType, JavaWriter writer)
+                throws IOException {
+            writer
+                .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                    .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                        .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                    .nextControlFlow("else")
+                        .emitStatement("Object timestamp = json.get(\"%s\")", fieldName)
+                        .beginControlFlow("if (timestamp instanceof String)")
+                            .emitStatement("((%s) obj).%s(JsonUtils.stringToDate((String) timestamp))", interfaceName, setter)
+                        .nextControlFlow("else")
+                            .emitStatement("((%s) obj).%s(new Date(json.getLong(\"%s\")))", interfaceName, setter, fieldName)
+                        .endControlFlow()
+                    .endControlFlow()
+                .endControlFlow();
+        }
+        // @formatter:on
+
+        // @formatter:off
+        @Override
+        public void emitStreamTypeConversion(
+                String interfaceName, String setter, String fieldName, String fieldType, JavaWriter writer, boolean isPrimaryKey)
+                throws IOException {
+            writer
+                .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
+                    .emitStatement("reader.skipValue()")
+                    .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                .nextControlFlow("else if (reader.peek() == JsonToken.NUMBER)")
+                    .emitStatement("long timestamp = reader.nextLong()", fieldName)
+                    .beginControlFlow("if (timestamp > -1)")
+                        .emitStatement("((%s) obj).%s(new Date(timestamp))", interfaceName, setter)
+                    .endControlFlow()
+                .nextControlFlow("else")
+                    .emitStatement("((%s) obj).%s(JsonUtils.stringToDate(reader.nextString()))", interfaceName, setter)
+                .endControlFlow();
+        }
+        // @formatter:on
+
+        @Override
+        public void emitGetObjectWithPrimaryKeyValue(
+                String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer)
+                throws IOException {
+            throw new IllegalArgumentException("'Date' is not allowed as a primary key value.");
+        }
+    }
+
+    private static class ByteArrayTypeConverter implements JsonToRealmFieldTypeConverter {
+        // @formatter:off
+        @Override
+        public void emitTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
+                JavaWriter writer) throws IOException {
+            writer
+                .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                    .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                        .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                    .nextControlFlow("else")
+                        .emitStatement(
+                                "((%s) obj).%s(JsonUtils.stringToBytes(json.getString(\"%s\")))",
+                                interfaceName, setter, fieldName)
+                    .endControlFlow()
+                .endControlFlow();
+        }
+        // @formatter:on
+
+        // @formatter:off
+        @Override
+        public void emitStreamTypeConversion(String interfaceName, String setter, String fieldName,
+                String fieldType, JavaWriter writer, boolean isPrimaryKey) throws IOException {
+            writer
+                .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
+                    .emitStatement("reader.skipValue()")
+                    .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                .nextControlFlow("else")
+                    .emitStatement("((%s) obj).%s(JsonUtils.stringToBytes(reader.nextString()))", interfaceName, setter)
+                .endControlFlow();
+        }
+        // @formatter:on
+
+        @Override
+        public void emitGetObjectWithPrimaryKeyValue(
+                String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer)
+                throws IOException {
+            throw new IllegalArgumentException("'byte[]' is not allowed as a primary key value.");
         }
     }
-    //@formatter:on
 
     private interface JsonToRealmFieldTypeConverter {
         void emitTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index d8fbb9c7bd..4322557498 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -33,7 +33,6 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -507,6 +506,47 @@ public void setRemoveRequired() {
         }
     }
 
+    // When converting a nullable field to required, the null values of the field will be set to the default value
+    // according to the field type.
+    @Test
+    public void setRequired_nullValueBecomesDefaultValue() {
+        for (FieldType fieldType : FieldType.values()) {
+            String fieldName = fieldType.name();
+            switch (fieldType) {
+                case OBJECT:
+                case LIST:
+                    // Skip always nullable fields.
+                    break;
+                default:
+                    // Skip not-nullable fields .
+                    if (!fieldType.isNullable()) {
+                        break;
+                    }
+                    schema.addField(fieldName, fieldType.getType());
+                    DynamicRealmObject object = realm.createObject(schema.getClassName());
+                    assertTrue(object.isNull(fieldName));
+                    schema.setRequired(fieldName, true);
+                    assertFalse(object.isNull(fieldName));
+                    if (fieldType == FieldType.BLOB) {
+                        assertEquals(0, object.getBlob(fieldName).length);
+                    } else if (fieldType == FieldType.BOOLEAN) {
+                        assertFalse(object.getBoolean(fieldName));
+                    } else if (fieldType == FieldType.STRING) {
+                        assertEquals(0, object.getString(fieldName).length());
+                    } else if (fieldType == FieldType.FLOAT) {
+                        assertEquals(0.0F, object.getFloat(fieldName), 0F);
+                    } else if (fieldType == FieldType.DOUBLE) {
+                        assertEquals(0.0D, object.getDouble(fieldName), 0D);
+                    } else if (fieldType == FieldType.DATE) {
+                        assertEquals(new Date(0), object.getDate(fieldName));
+                    } else {
+                        assertEquals(0, object.getInt(fieldName));
+                    }
+                    break;
+            }
+        }
+    }
+
     @Test
     public void setRemovePrimaryKey() {
         for (PrimaryKeyFieldType fieldType : PrimaryKeyFieldType.values()) {
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/ProgressTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/ProgressTests.java
new file mode 100644
index 0000000000..22c31bc2a5
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/ProgressTests.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Locale;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(AndroidJUnit4.class)
+public class ProgressTests {
+
+    @Test
+    public void getFractionTransferred() {
+        Object[][] testData = {
+            { 0L, 0L, 1.0D },
+            { 0L, 1L, 0.0D },
+            { 1L, 1L, 1.0D },
+            { 1L, 2L, 0.5D }
+        };
+
+        for (Object[] test : testData) {
+            long transferredBytes = (long) test[0];
+            long transferableBytes = (long) test[1];
+            double fraction = (double) test[2];
+            Progress progress = new Progress(transferredBytes, transferableBytes);
+            String errorMessage = String.format(Locale.US, "Failed with: (%d, %d)", transferredBytes, transferableBytes);
+            assertEquals(errorMessage, fraction, progress.getFractionTransferred(), 0.0D);
+        }
+    }
+
+    @Test
+    public void getTransferredBytes () {
+        long[] testData = { 0, Long.MAX_VALUE };
+
+        for (long transferredBytes : testData) {
+            String errorMessage = String.format(Locale.US, "Failed with: %d", transferredBytes);
+            Progress progress = new Progress(transferredBytes, Long.MAX_VALUE);
+            assertEquals(errorMessage, transferredBytes, progress.getTransferredBytes());
+        }
+    }
+
+    @Test
+    public void getTransferableBytes () {
+        long[] testData = { 0, Long.MAX_VALUE };
+
+        for (long transferableBytes : testData) {
+            String errorMessage = String.format(Locale.US, "Failed with: %d", transferableBytes);
+            Progress progress = new Progress(0, transferableBytes);
+            assertEquals(errorMessage, transferableBytes, progress.getTransferableBytes());
+        }
+    }
+
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index d5c949a1bf..95bb08e745 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -61,6 +61,54 @@ public void get_syncValues() {
         assertEquals(configuration, session.getConfiguration());
     }
 
+    @Test
+    public void addDownloadProgressListener_nullThrows() {
+        SyncSession session = SyncManager.getSession(configuration);
+        try {
+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void addUploadProgressListener_nullThrows() {
+        SyncSession session = SyncManager.getSession(configuration);
+        try {
+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void removeProgressListener() {
+        Realm realm = Realm.getInstance(configuration);
+        SyncSession session = SyncManager.getSession(configuration);
+        ProgressListener[] listeners = new ProgressListener[] {
+                null,
+                new ProgressListener() {
+                    @Override
+                    public void onChange(Progress progress) {
+                        // Listener 1, not present
+                    }
+                },
+                new ProgressListener() {
+                    @Override
+                    public void onChange(Progress progress) {
+                        // Listener 2, present
+                    }
+                }
+        };
+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, listeners[2]);
+
+        // Check that remove works unconditionally for all input
+        for (ProgressListener listener : listeners) {
+            session.removeProgressListener(listener);
+        }
+        realm.close();
+    }
+
     // Check that a Client Reset is correctly reported.
     @Test
     @RunTestInLooperThread
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
index 8165ea5cb5..37bf4c087a 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
@@ -15,6 +15,7 @@
  */
 
 #include <jni.h>
+#include <string>
 
 #include "io_realm_SyncSession.h"
 
@@ -28,23 +29,22 @@
 #include "jni_util/java_local_ref.hpp"
 #include "jni_util/jni_utils.hpp"
 
-using namespace std;
 using namespace realm;
 using namespace jni_util;
 using namespace sync;
 
 JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeRefreshAccessToken(JNIEnv* env, jclass,
-                                                                              jstring localRealmPath,
-                                                                              jstring accessToken,
-                                                                              jstring sync_realm_url)
+                                                                              jstring j_local_realm_path,
+                                                                              jstring j_access_token,
+                                                                              jstring j_sync_realm_url)
 {
     TR_ENTER()
     try {
-        JStringAccessor local_realm_path(env, localRealmPath);
+        JStringAccessor local_realm_path(env, j_local_realm_path);
         auto session = SyncManager::shared().get_existing_session(local_realm_path);
         if (session) {
-            JStringAccessor access_token(env, accessToken);
-            JStringAccessor realm_url(env, sync_realm_url);
+            JStringAccessor access_token(env, j_access_token);
+            JStringAccessor realm_url(env, j_sync_realm_url);
             session->refresh_access_token(access_token, std::string(realm_url));
             return JNI_TRUE;
         }
@@ -56,13 +56,79 @@ JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeRefreshAccessToken(JN
     return JNI_FALSE;
 }
 
+JNIEXPORT jlong JNICALL Java_io_realm_SyncSession_nativeAddProgressListener(JNIEnv* env, jclass,
+                                                                            jstring j_local_realm_path,
+                                                                            jlong listener_id, jint direction,
+                                                                            jboolean is_streaming)
+{
+    try {
+        // JNIEnv is thread confined, so we need a deep copy in order to capture the string in the lambda
+        std::string local_realm_path(JStringAccessor(env, j_local_realm_path));
+        std::shared_ptr<SyncSession> session = SyncManager::shared().get_existing_active_session(local_realm_path);
+        if (!session) {
+            // FIXME: We should lift this restriction
+            ThrowException(env, IllegalState,
+                           "Cannot register a progress listener before a session is "
+                           "created. A session will be created after the first call to Realm.getInstance().");
+            return 0;
+        }
+
+        SyncSession::NotifierType type =
+            (direction == 1) ? SyncSession::NotifierType::download : SyncSession::NotifierType::upload;
+
+        static JavaClass java_syncmanager_class(env, "io/realm/SyncManager");
+        static JavaMethod java_notify_progress_listener(env, java_syncmanager_class, "notifyProgressListener", "(Ljava/lang/String;JJJ)V", true);
+
+        std::function<SyncProgressNotifierCallback> callback = [local_realm_path, listener_id](
+            uint64_t transferred, uint64_t transferrable) {
+            JNIEnv* local_env = jni_util::JniUtils::get_env(true);
+
+            auto path = to_jstring(local_env, local_realm_path);
+            local_env->CallStaticVoidMethod(java_syncmanager_class, java_notify_progress_listener, path, listener_id,
+                                            static_cast<jlong>(transferred), static_cast<jlong>(transferrable));
+
+            // All exceptions will be caught on the Java side of handlers, but Errors will still end
+            // up here, so we need to do something sensible with them.
+            // Throwing a C++ exception will terminate the sync thread and cause the pending Java
+            // exception to become visible. For some (unknown) reason Logcat will not see the C++
+            // exception, only the Java one.
+            if (local_env->ExceptionCheck()) {
+                local_env->ExceptionDescribe();
+                throw std::runtime_error("An unexpected Error was thrown from Java. See LogCat");
+            }
+
+            // Callback happens on a thread not controlled by the JVM. So manual cleanup is
+            // required.
+            local_env->DeleteLocalRef(path);
+        };
+        uint64_t token = session->register_progress_notifier(callback, type, to_bool(is_streaming));
+        return static_cast<jlong>(token);
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT void JNICALL Java_io_realm_SyncSession_nativeRemoveProgressListener(JNIEnv* env, jclass,
+                                                                              jstring j_local_realm_path,
+                                                                              jlong listener_token)
+{
+    try {
+        JStringAccessor local_realm_path(env, j_local_realm_path);
+        std::shared_ptr<SyncSession> session = SyncManager::shared().get_existing_active_session(local_realm_path);
+        if (session) {
+            session->unregister_progress_notifier(static_cast<uint64_t>(listener_token));
+        }
+    }
+    CATCH_STD()
+}
+
 JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeWaitForDownloadCompletion(JNIEnv* env,
                                                                                      jobject session_object,
-                                                                                     jstring localRealmPath)
+                                                                                     jstring j_local_realm_path)
 {
     TR_ENTER()
     try {
-        JStringAccessor local_realm_path(env, localRealmPath);
+        JStringAccessor local_realm_path(env, j_local_realm_path);
         auto session = SyncManager::shared().get_existing_session(local_realm_path);
 
         if (session) {
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
index 2a2c339ebc..7fdfbf87b4 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
@@ -338,7 +338,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNull
                 case type_Binary: {
                     BinaryData bd = table->get_binary(column_index + 1, i);
                     if (bd.is_null()) {
-                        table->set_binary(column_index, i, BinaryData(""));
+                        table->set_binary(column_index, i, BinaryData("", 0));
                     }
                     else {
                         // Payload copy is needed
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
index 3026ee5a08..4a57062471 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
@@ -29,8 +29,7 @@ static constexpr NeedToCreateLocalRef need_to_create_local_ref{};
 // Wraps jobject and automatically calls DeleteLocalRef when this object is destroyed.
 // DeleteLocalRef is not necessary to be called in most cases since all local references will be cleaned up when the
 // program returns to Java from native. But if the local ref is created in a loop, consider to use this class to wrap
-// it
-// because the size of local reference table is relative small (512 bytes on Android).
+// it because the size of local reference table is relative small (512 bytes on Android).
 template <typename T>
 class JavaLocalRef {
 public:
diff --git a/realm/realm-library/src/main/cpp/util.hpp b/realm/realm-library/src/main/cpp/util.hpp
index 29c2813d17..2a155f8915 100644
--- a/realm/realm-library/src/main/cpp/util.hpp
+++ b/realm/realm-library/src/main/cpp/util.hpp
@@ -703,6 +703,10 @@ extern jclass java_lang_string;
 extern jmethodID java_lang_double_init;
 extern jclass java_util_date;
 extern jmethodID java_util_date_init;
+#if REALM_ENABLE_SYNC
+extern jclass java_syncmanager_class;
+extern jmethodID java_notify_progress_listener;
+#endif
 
 inline jobject NewLong(JNIEnv* env, int64_t value)
 {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java b/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java
index 6990faf5ae..86fcd889d5 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java
@@ -27,8 +27,8 @@
  * objects.
  */
 public class Pair<F, S> {
-    public final F first;
-    public final S second;
+    public F first;
+    public S second;
 
     /**
      * Constructor for a Pair.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/Progress.java b/realm/realm-library/src/objectServer/java/io/realm/Progress.java
new file mode 100644
index 0000000000..77a6c01f78
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/Progress.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.log.RealmLog;
+
+
+/**
+ * Class used to encapsulate progress notifications when either downloading or uploading Realm data.
+ * Each instance of this class is an immutable snapshot of the current progress.
+ * <p>
+ * If the {@link ProgressListener} was registered with {@link ProgressMode#INDEFINITELY}, the progress reported by
+ * {@link #getFractionTransferred()} can both increase and decrease since more changes might be added while
+ * the progres listener is registered. This means it is possible for one notification to report
+ * {@code true} for {@link #isTransferComplete()}, and then on the next event report {@code false}.
+ * <p>
+ * If the {@link ProgressListener} was registered with {@link ProgressMode#CURRENT_CHANGES}, progress can only ever
+ * increase, and once {@link #isTransferComplete()} returns {@code true}, no further events will be generated.
+ *
+ * @see SyncSession#addDownloadProgressListener(ProgressMode, ProgressListener)
+ * @see SyncSession#addUploadProgressListener(ProgressMode, ProgressListener)
+ */
+public class Progress {
+
+    private final long transferredBytes;
+    private final long transferableBytes;
+
+    /**
+     * Creates a snapshot of the current progress when downloading or uploading changes.
+     *
+     * @param transferredBytes number of bytes transferred.
+     * @param transferableBytes total number of bytes that needs to be transferred (including those already transferred).
+     */
+    Progress(long transferredBytes, long transferableBytes) {
+        this.transferredBytes = transferredBytes;
+        this.transferableBytes = transferableBytes;
+    }
+
+    /**
+     * Returns the total number of bytes that has been transferred since the {@link ProgressListener} was added.
+     *
+     * @return the total number of bytes transferred since the {@link ProgressListener} was added.
+     */
+    public long getTransferredBytes() {
+        return transferredBytes;
+    }
+
+    /**
+     * Returns the total number of transferable bytes (bytes that have been transferred + bytes pending transfer).
+     * <p>
+     * If the {@link ProgressListener} is tracking downloads, this number represents the size of the changesets
+     * generated by all other clients using the Realm.
+     * <p>
+     * If the {@link ProgressListener} is tracking uploads, this number represents the size of changesets created
+     * locally.
+     *
+     * @return the total number of bytes that has been transferred + number of bytes still pending transfer.
+     */
+    public long getTransferableBytes() {
+        return transferableBytes;
+    }
+
+    /**
+     * The fraction of bytes transferred out of all transferable bytes. Counting from since the {@link ProgressListener}
+     * was added.
+     *
+     * @return a number between {@code 0.0} and {@code 1.0}, where {@code 0.0} represents that no data has been
+     * transferred yet, and {@code 1.0} that all data has been transferred.
+     */
+    public double getFractionTransferred() {
+        if (transferableBytes == 0) {
+            return 1.0D;
+        } else {
+            double percentage = (double) transferredBytes / (double) transferableBytes;
+            if (percentage > 1.0D) {
+                RealmLog.error("Invalid progress state: %s", this);
+                return 1.0D;
+            } else {
+                return percentage;
+            }
+        }
+    }
+
+    /**
+     * Returns {@code true} when all pending bytes have been transferred.
+     * <p>
+     * If the {@link ProgressListener} was registered with {@link ProgressMode#INDEFINITELY}, this method can return
+     * {@code false} for subsequent events after returning {@code true}.
+     * <p>
+     * If the {@link ProgressListener} was registered with {@link ProgressMode#CURRENT_CHANGES}, when this method
+     * returns {@code true}, no more progress events will be sent.
+     *
+     * @return {@code true} if all changes have been transferred, {@code false} otherwise.
+     */
+    public boolean isTransferComplete() {
+        return transferredBytes >= transferableBytes;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        Progress progress = (Progress) o;
+
+        if (transferredBytes != progress.transferredBytes) return false;
+        return transferableBytes == progress.transferableBytes;
+
+    }
+
+    @Override
+    public int hashCode() {
+        int result = (int) (transferredBytes ^ (transferredBytes >>> 32));
+        result = 31 * result + (int) (transferableBytes ^ (transferableBytes >>> 32));
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "Progress{" +
+                "transferredBytes=" + transferredBytes +
+                ", transferableBytes=" + transferableBytes +
+                '}';
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ProgressListener.java b/realm/realm-library/src/objectServer/java/io/realm/ProgressListener.java
new file mode 100644
index 0000000000..5b5798f2d4
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/ProgressListener.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+/**
+ * Interface used when interested in updates on data either being uploaded to or downloaded from
+ * a Realm Object Server.
+ */
+public interface ProgressListener {
+    /**
+     * This method will be called periodically from the underlying Object Server Client responsible
+     * for uploading and downloading changes from the remote Object Server.
+     * <p>
+     * This callback will <i>not</i> happen on the UI thread, but on the worker thread controlling
+     * the Object Server Client. Use {@code Activity.runOnUiThread(Runnable)} or similar to update
+     * any UI elements.
+     * <p>
+     * <pre>
+     * {@code
+     * // Adding an upload progress listener that completes when all known changes have been
+     * // uploaded.
+     * session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+     *   \@Override
+     *    public void onChange(Progress progress) {
+     *      activity.runOnUiThread(new Runnable() {
+     *        \@Override
+     *         public void run() {
+     *           updateProgressBar(progress);
+     *         }
+     *      });
+     *      if (progress.isTransferComplete() {
+     *        session.removeProgressListener(this);
+     *      }
+     *    }
+     * });
+     * }
+     * </pre>
+     *
+     * @param progress an immutable progress change event with information about current progress. This object is thread safe.
+     */
+    void onChange(Progress progress);
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ProgressMode.java b/realm/realm-library/src/objectServer/java/io/realm/ProgressMode.java
new file mode 100644
index 0000000000..f80f63150d
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/ProgressMode.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+/**
+ * Enum describing how to listen to progress changes.
+ */
+public enum ProgressMode {
+    /**
+     * When registering the {@link ProgressListener}, it will record the current size of changes, and will only
+     * continue to report progress updates until those changes have been either downloaded or uploaded. After that
+     * the progress listener will not report any further changes.
+     * <p>
+     * This means that listeners registered in this mode should be done <i>before</i> changes are written to
+     * the Realm.
+     * <p>
+     * Progress reported in this mode will only ever increase.
+     * <p>
+     * This is useful when e.g. reporting progress when downloading a Realm for the first time.
+     */
+    CURRENT_CHANGES,
+
+    /**
+     * A {@link ProgressListener} registered in this mode, will continue to report progress changes, even
+     * if changes are being added after the listener was registered.
+     * <p>
+     * Progress reported in this mode can both increase and decrease, e.g. if large amounts of data is
+     * written after registering the listener.
+     * <p>
+     * This is useful when you want to track if all changes have been uploaded to the server from the device.
+     */
+    INDEFINITELY
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index 906454f00c..63ef781fca 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -16,15 +16,16 @@
 
 package io.realm;
 
-import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import io.realm.internal.Keep;
+import io.realm.internal.KeepMember;
 import io.realm.internal.network.AuthenticationServer;
 import io.realm.internal.network.NetworkStateReceiver;
 import io.realm.internal.network.OkHttpAuthenticationServer;
@@ -91,7 +92,7 @@ public void onError(SyncSession session, ObjectServerError error) {
         }
     };
     // keeps track of SyncSession, using 'realm_path'. Java interface with the ObjectStore using the 'realm_path'
-    private static Map<String, SyncSession> sessions = new HashMap<String, SyncSession>();
+    private static Map<String, SyncSession> sessions = new ConcurrentHashMap<>();
     private static CopyOnWriteArrayList<AuthenticationListener> authListeners = new CopyOnWriteArrayList<AuthenticationListener>();
 
     // The Sync Client is lightweight, but consider creating/removing it when there is no sessions.
@@ -278,6 +279,25 @@ private static synchronized void notifyNetworkIsBack() {
         }
     }
 
+    /**
+     * All progress listener events from native Sync are reported to this method.
+     * It costs 2 HashMap lookups for each listener triggered (one to find the session, one to
+     * find the progress listener), but it means we don't have to cache anything on the C++ side which
+     * can leak since we don't have control over the session lifecycle.
+     */
+    @SuppressWarnings("unused")
+    @KeepMember
+    private static synchronized void notifyProgressListener(String localRealmPath, long listenerId, long transferedBytes, long transferableBytes) {
+        SyncSession session = sessions.get(localRealmPath);
+        if (session != null) {
+            try {
+                session.notifyProgressListener(listenerId, transferedBytes, transferableBytes);
+            } catch (Exception exception) {
+                RealmLog.error(exception);
+            }
+        }
+    }
+
     /**
      * This is called from the Object Store (through JNI) to request an {@code access_token} for
      * the session specified by sessionPath.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index 408d1daec2..601692f367 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -17,12 +17,17 @@
 package io.realm;
 
 import java.net.URI;
+import java.util.HashMap;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.Map;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Future;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.internal.Keep;
@@ -36,6 +41,7 @@
 import io.realm.internal.network.NetworkStateReceiver;
 import io.realm.internal.objectserver.ObjectServerUser;
 import io.realm.internal.objectserver.Token;
+import io.realm.internal.util.Pair;
 import io.realm.log.RealmLog;
 
 /**
@@ -53,6 +59,8 @@
 public class SyncSession {
     private final static ScheduledThreadPoolExecutor REFRESH_TOKENS_EXECUTOR = new ScheduledThreadPoolExecutor(1);
     private final static long REFRESH_MARGIN_DELAY = TimeUnit.SECONDS.toMillis(10);
+    private final static int DIRECTION_DOWNLOAD = 1;
+    private final static int DIRECTION_UPLOAD = 2;
 
     private final SyncConfiguration configuration;
     private final ErrorHandler errorHandler;
@@ -65,6 +73,19 @@
     private final AtomicReference<WaitForServerChangesWrapper> waitingForServerChanges = new AtomicReference<>(null);
     private final Object waitForChangesMutex = new Object();
 
+    // We need JavaId -> Listener so C++ can trigger callbacks without keeping a reference to the
+    // jobject, which would require a similar map on the C++ side.
+    // We need Listener -> Token map in order to remove the progress listener in C++ from Java.
+    private final Map<Long, Pair<ProgressListener, Progress>> listenerIdToProgressListenerMap = new HashMap<>();
+    private final Map<ProgressListener, Long> progressListenerToOsTokenMap = new IdentityHashMap<>();
+    // Counter used to assign all ProgressListeners on this session with a unique id.
+    // ListenerId is created by Java to enable C++ to reference the java listener without holding
+    // a reference to the actual object.
+    // ListenerToken is the same concept, but created by OS and represents the listener.
+    // We can unfortunately not just use the ListenerToken, since we need it to be available before
+    // we register the listener.
+    private final AtomicLong progressListenerId = new AtomicLong(-1);
+
     SyncSession(SyncConfiguration configuration) {
         this.configuration = configuration;
         this.errorHandler = configuration.getErrorHandler();
@@ -115,6 +136,102 @@ void notifySessionError(int errorCode, String errorMessage) {
         }
     }
 
+    synchronized void notifyProgressListener(long listenerId, long transferredBytes, long transferableBytes) {
+        Pair<ProgressListener, Progress> listener = listenerIdToProgressListenerMap.get(listenerId);
+        if (listener != null) {
+            Progress newProgressNotification = new Progress(transferredBytes, transferableBytes);
+            if (!newProgressNotification.equals(listener.second)) {
+                listener.second = newProgressNotification;
+                listener.first.onChange(newProgressNotification);
+            }
+        } else {
+            RealmLog.debug("Trying unknown listener failed: " + listenerId);
+        }
+    }
+    
+    /**
+     * Adds a progress listener tracking changes that need to be downloaded from the Realm Object
+     * Server.
+     * <p>
+     * The {@link ProgressListener} will be triggered immediately when registered, and periodically
+     * afterwards.
+     *
+     * @param mode type of mode used. See {@link ProgressMode} for more information.
+     * @param listener the listener to register.
+     */
+    public synchronized void addDownloadProgressListener(ProgressMode mode, ProgressListener listener) {
+        addProgressListener(mode, DIRECTION_DOWNLOAD, listener);
+    }
+
+    /**
+     * Adds a progress listener tracking changes that need to be uploaded from the device to the
+     * Realm Object Server.
+     * <p>
+     * The {@link ProgressListener} will be triggered immediately when registered, and periodically
+     * afterwards.
+     *
+     * @param mode type of mode used. See {@link ProgressMode} for more information.
+     * @param listener the listener to register.
+     */
+    public synchronized void addUploadProgressListener(ProgressMode mode, ProgressListener listener) {
+        addProgressListener(mode, DIRECTION_UPLOAD, listener);
+    }
+
+    /**
+     * Removes a progress listener. If the listener wasn't registered, this method will do nothing.
+     *
+     * @param listener listener to remove.
+     */
+    public synchronized void removeProgressListener(ProgressListener listener) {
+        if (listener == null) {
+            return;
+        }
+        // If an exception is thrown somewhere in here, we will most likely leave the various
+        // maps in an inconsistent manner. Not much we can do about it.
+        Long token = progressListenerToOsTokenMap.remove(listener);
+        if (token != null) {
+            Iterator<Map.Entry<Long, Pair<ProgressListener, Progress>>> it = listenerIdToProgressListenerMap.entrySet().iterator();
+            while (it.hasNext()) {
+                Map.Entry<Long, Pair<ProgressListener, Progress>> entry = it.next();
+                if (entry.getValue().first.equals(listener)) {
+                    it.remove();
+                    break;
+                }
+            }
+            nativeRemoveProgressListener(configuration.getPath(), token);
+        }
+    }
+
+    private void addProgressListener(ProgressMode mode, int direction, ProgressListener listener) {
+        checkProgressListenerArguments(mode, listener);
+        boolean isStreaming = (mode == ProgressMode.INDEFINITELY);
+        long listenerId = progressListenerId.incrementAndGet();
+
+        // A listener might be triggered immediately as part of `nativeAddProgressListener`, so
+        // we need to make sure it can be found by SyncManager.notifyProgressListener()
+        listenerIdToProgressListenerMap.put(listenerId, new Pair<ProgressListener, Progress>(listener, null));
+        long listenerToken = nativeAddProgressListener(configuration.getPath(), listenerId , direction, isStreaming);
+        if (listenerToken == 0) {
+            // ObjectStore did not register the listener. This can happen if a
+            // listener is registered with ProgressMode.CURRENT_CHANGES and no changes actually
+            // exists. In that case the listener was triggered immediately and we just need
+            // to clean it up, since it will never be called again.
+            listenerIdToProgressListenerMap.remove(listenerId);
+        } else {
+            // Listener was properly registered.
+            progressListenerToOsTokenMap.put(listener, listenerToken);
+        }
+    }
+
+    private void checkProgressListenerArguments(ProgressMode mode, ProgressListener listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException("Non-null 'listener' required.");
+        }
+        if (mode == null) {
+            throw new IllegalArgumentException("Non-null 'mode' required.");
+        }
+    }
+
     void close() {
         isClosed = true;
         if (networkRequest != null) {
@@ -470,6 +587,8 @@ public void throwExceptionIfNeeded() {
         }
     }
 
+    private static native long nativeAddProgressListener(String localRealmPath, long listenerId, int direction, boolean isStreaming);
+    private static native void nativeRemoveProgressListener(String localRealmPath, long listenerToken);
     private static native boolean nativeRefreshAccessToken(String path, String accessToken, String realmUrl);
     private native boolean nativeWaitForDownloadCompletion(String path);
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
index 3a46d16bd6..9f86b3200e 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
@@ -113,7 +113,6 @@ public void run() {
         }
     }
 
-
     // Cleanup filesystem to make sure nothing lives for the next test.
     // Failing to do so might lead to DIVERGENT_HISTORY errors being thrown if Realms from
     // previous tests are being accessed.
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
index d105b6505d..be5da797a7 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
@@ -17,7 +17,6 @@
 package io.realm;
 
 import android.os.SystemClock;
-import android.support.annotation.NonNull;
 import android.support.test.annotation.UiThreadTest;
 import android.support.test.runner.AndroidJUnit4;
 
@@ -27,15 +26,14 @@
 import java.io.File;
 import java.util.Random;
 import java.util.UUID;
-import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.DownloadingRealmInterruptedException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.objectserver.utils.Constants;
 import io.realm.rule.RunTestInLooperThread;
+import io.realm.util.SyncTestUtils;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -51,8 +49,7 @@
     @Test
     @UiThreadTest
     public void waitForInitialRemoteData_mainThreadThrows() {
-        final SyncUser user = loginUser();
-
+        final SyncUser user = SyncTestUtils.createTestUser(Constants.AUTH_URL);
         SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
                 .waitForInitialRemoteData()
                 .build();
@@ -69,23 +66,6 @@ public void waitForInitialRemoteData_mainThreadThrows() {
         }
     }
 
-    // Login user on a worker thread, so this method can be used from both UI and non-ui threads.
-    @NonNull
-    private SyncUser loginUser() {
-        final CountDownLatch userReady = new CountDownLatch(1);
-        final AtomicReference<SyncUser> user = new AtomicReference<>();
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
-                user.set(SyncUser.login(credentials, Constants.AUTH_URL));
-                userReady.countDown();
-            }
-        }).start();
-        TestHelper.awaitOrFail(userReady);
-        return user.get();
-    }
-
     @Test
     public void waitForInitialRemoteData() {
         String username = UUID.randomUUID().toString();
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
new file mode 100644
index 0000000000..dcd1dffb8f
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
@@ -0,0 +1,401 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver;
+
+import android.support.annotation.NonNull;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.net.URI;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import io.realm.BaseIntegrationTest;
+import io.realm.Progress;
+import io.realm.ProgressListener;
+import io.realm.ProgressMode;
+import io.realm.Realm;
+import io.realm.SyncConfiguration;
+import io.realm.SyncManager;
+import io.realm.SyncSession;
+import io.realm.SyncUser;
+import io.realm.TestHelper;
+import io.realm.entities.AllTypes;
+import io.realm.log.RealmLog;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.UserFactory;
+import io.realm.rule.TestSyncConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class ProgressListenerTests extends BaseIntegrationTest {
+
+    private static final long TEST_SIZE = 10;
+    @Rule
+    public TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
+
+    @NonNull
+    private SyncConfiguration createSyncConfig() {
+        SyncUser user = UserFactory.createAdminUser(Constants.AUTH_URL);
+        return configFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL).build();
+    }
+
+    private void writeSampleData(Realm realm) {
+        realm.beginTransaction();
+        for (int i = 0; i < TEST_SIZE; i++) {
+            AllTypes obj = realm.createObject(AllTypes.class);
+            obj.setColumnString("Object " + i);
+        }
+        realm.commitTransaction();
+    }
+
+    private void assertTransferComplete(Progress progress, boolean nonZeroChange) {
+        assertTrue(progress.isTransferComplete());
+        assertEquals(1.0D, progress.getFractionTransferred(), 0.0D);
+        assertEquals(progress.getTransferableBytes(), progress.getTransferredBytes());
+        if (nonZeroChange) {
+            assertTrue(progress.getTransferredBytes() > 0);
+        }
+    }
+
+    // Create remote data for a given user.
+    private URI createRemoteData(SyncUser user) {
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM).build();
+        final Realm realm = Realm.getInstance(config);
+        writeSampleData(realm);
+        final CountDownLatch changesUploaded = new CountDownLatch(1);
+        final SyncSession session = SyncManager.getSession(config);
+        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    session.removeProgressListener(this);
+                    changesUploaded.countDown();
+                }
+            }
+        });
+        TestHelper.awaitOrFail(changesUploaded);
+        realm.close();
+        return config.getServerUrl();
+    }
+
+    @Test
+    public void downloadProgressListener_changesOnly() {
+        final CountDownLatch allChangesDownloaded = new CountDownLatch(1);
+        SyncUser userWithData = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        URI serverUrl = createRemoteData(userWithData);
+        SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(adminUser, serverUrl.toString()).build();
+        Realm realm = Realm.getInstance(config);
+        SyncSession session = SyncManager.getSession(config);
+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    assertTransferComplete(progress, true);
+                    Realm realm = Realm.getInstance(config);
+                    assertEquals(TEST_SIZE, realm.where(AllTypes.class).count());
+                    realm.close();
+                    allChangesDownloaded.countDown();
+                }
+            }
+        });
+        TestHelper.awaitOrFail(allChangesDownloaded);
+        realm.close();
+        userWithData.logout();
+        adminUser.logout();
+    }
+
+    @Test
+    public void downloadProgressListener_indefinitely() throws InterruptedException {
+        final AtomicInteger transferCompleted = new AtomicInteger(0);
+        final CountDownLatch allChangesDownloaded = new CountDownLatch(1);
+        final CountDownLatch startWorker = new CountDownLatch(1);
+        final SyncUser userWithData = UserFactory.createUniqueUser(Constants.AUTH_URL);
+
+        URI serverUrl = createRemoteData(userWithData);
+
+        // Create worker thread that puts data into another Realm.
+        // This is to avoid blocking one progress listener while waiting for another to complete.
+        Thread worker = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                TestHelper.awaitOrFail(startWorker);
+                createRemoteData(userWithData);
+            }
+        });
+        worker.start();
+
+        SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        final SyncConfiguration adminConfig = configFactory.createSyncConfigurationBuilder(adminUser, serverUrl.toString()).build();
+        Realm adminRealm = Realm.getInstance(adminConfig);
+        Realm userRealm = Realm.getInstance(configFactory.createSyncConfigurationBuilder(userWithData, Constants.USER_REALM).build()); // Keep session alive
+        SyncSession session = SyncManager.getSession(adminConfig);
+        session.addDownloadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    switch (transferCompleted.incrementAndGet()) {
+                        case 1:
+                            // Initial trigger when registering
+                            assertTransferComplete(progress, false);
+                            break;
+                        case 2: {
+                            assertTransferComplete(progress, true);
+                            Realm adminRealm = Realm.getInstance(adminConfig);
+                            assertEquals(TEST_SIZE, adminRealm.where(AllTypes.class).count());
+                            adminRealm.close();
+                            startWorker.countDown();
+                            break;
+                        }
+                        case 3: {
+                            assertTransferComplete(progress, true);
+                            Realm adminRealm = Realm.getInstance(adminConfig);
+                            assertEquals(TEST_SIZE * 2, adminRealm.where(AllTypes.class).count());
+                            adminRealm.close();
+                            allChangesDownloaded.countDown();
+                            break;
+                        }
+                        default:
+                            fail();
+                    }
+                }
+            }
+        });
+        TestHelper.awaitOrFail(allChangesDownloaded);
+        adminRealm.close();
+        userRealm.close();
+        userWithData.logout();
+        adminUser.logout();
+        worker.join();
+    }
+
+    // Make sure that a ProgressListener continues to report the correct thing, even if it crashed
+    @Test
+    public void uploadListener_worksEvenIfCrashed() throws InterruptedException {
+        final AtomicInteger transferCompleted = new AtomicInteger(0);
+        final CountDownLatch testDone = new CountDownLatch(1);
+        final SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+
+        writeSampleData(realm); // Write first batch of sample data
+        SyncSession session = SyncManager.getSession(config);
+        session.addUploadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    switch(transferCompleted.incrementAndGet()) {
+                        case 1:
+                            Realm realm = Realm.getInstance(config);
+                            writeSampleData(realm);
+                            realm.close();
+                            throw new RuntimeException("Crashing the changelistener");
+                        case 2:
+                            assertTransferComplete(progress, true);
+                            testDone.countDown();
+                            break;
+                        default:
+                            fail("Unsupported number of transfers completed: " + transferCompleted.get());
+                    }
+                }
+            }
+        });
+
+        TestHelper.awaitOrFail(testDone);
+        realm.close();
+    }
+
+
+    @Test
+    public void uploadProgressListener_changesOnly() {
+        final CountDownLatch allChangeUploaded = new CountDownLatch(1);
+        SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+        writeSampleData(realm);
+
+        SyncSession session = SyncManager.getSession(config);
+        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    assertTransferComplete(progress, true);
+                    allChangeUploaded.countDown();
+                }
+            }
+        });
+
+        TestHelper.awaitOrFail(allChangeUploaded);
+        realm.close();
+    }
+
+    @Test
+    public void uploadProgressListener_indefinitely() {
+        final AtomicInteger transferCompleted = new AtomicInteger(0);
+        final CountDownLatch testDone = new CountDownLatch(1);
+        final SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+
+        writeSampleData(realm); // Write first batch of sample data
+        SyncSession session = SyncManager.getSession(config);
+        session.addUploadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    switch(transferCompleted.incrementAndGet()) {
+                        case 1:
+                            Realm realm = Realm.getInstance(config);
+                            writeSampleData(realm);
+                            realm.close();
+                            break;
+                        case 2:
+                            assertTransferComplete(progress, true);
+                            testDone.countDown();
+                            break;
+                        default:
+                            fail("Unsupported number of transfers completed: " + transferCompleted.get());
+                    }
+                }
+            }
+        });
+
+        TestHelper.awaitOrFail(testDone);
+        realm.close();
+    }
+
+    @Test
+    public void addListenerInsideCallback() {
+        final CountDownLatch allChangeUploaded = new CountDownLatch(1);
+        final SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+        writeSampleData(realm);
+
+        final SyncSession session = SyncManager.getSession(config);
+        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    Realm realm = Realm.getInstance(config);
+                    writeSampleData(realm);
+                    realm.close();
+                    session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+                        @Override
+                        public void onChange(Progress progress) {
+                            if (progress.isTransferComplete()) {
+                                allChangeUploaded.countDown();
+                            }
+                        }
+                    });
+                }
+            }
+        });
+
+        TestHelper.awaitOrFail(allChangeUploaded);
+        realm.close();
+    }
+
+    @Test
+    public void addListenerInsideCallback_mixProgressModes() {
+        final CountDownLatch allChangeUploaded = new CountDownLatch(3);
+        final AtomicBoolean progressCompletedReported = new AtomicBoolean(false);
+        final SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+        writeSampleData(realm);
+
+        final SyncSession session = SyncManager.getSession(config);
+        session.addUploadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    allChangeUploaded.countDown();
+                    if (progressCompletedReported.compareAndSet(false, true)) {
+                        Realm realm = Realm.getInstance(config);
+                        writeSampleData(realm);
+                        realm.close();
+                        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+                            @Override
+                            public void onChange(Progress progress) {
+                                if (progress.isTransferComplete()) {
+                                    allChangeUploaded.countDown();
+                                }
+                            }
+                        });
+                    }
+                }
+            }
+        });
+
+        TestHelper.awaitOrFail(allChangeUploaded);
+        realm.close();
+    }
+
+    @Test
+    public void addProgressListener_triggerImmediatelyWhenRegistered() {
+        final SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+        SyncSession session = SyncManager.getSession(config);
+
+        checkListener(session, ProgressMode.INDEFINITELY);
+        checkListener(session, ProgressMode.CURRENT_CHANGES);
+
+        realm.close();
+    }
+
+    @Test
+    public void uploadListener_keepIncreasingInSize() {
+        SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+        SyncSession session = SyncManager.getSession(config);
+        for (int i = 0; i < 10; i++) {
+            final CountDownLatch changesUploaded = new CountDownLatch(1);
+            writeSampleData(realm);
+            final int testNo = i;
+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+                @Override
+                public void onChange(Progress progress) {
+                    RealmLog.info("Test %s -> %s", Integer.toString(testNo), progress.toString());
+                    if (progress.isTransferComplete()) {
+                        assertTransferComplete(progress, true);
+                        changesUploaded.countDown();
+                    }
+                }
+            });
+            TestHelper.awaitOrFail(changesUploaded);
+        }
+
+        realm.close();
+    }
+
+    private void checkListener(SyncSession session, ProgressMode progressMode) {
+        final CountDownLatch listenerCalled = new CountDownLatch(1);
+        session.addDownloadProgressListener(progressMode, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                listenerCalled.countDown();
+            }
+        });
+        TestHelper.awaitOrFail(listenerCalled);
+    }
+
+}
