diff --git a/LICENSE b/LICENSE
index 72ae44683f..48be149531 100644
--- a/LICENSE
+++ b/LICENSE
@@ -215,11 +215,11 @@ This software contains components with separate copyright and license terms.
 Your use of these components is subject to the terms and conditions of the
 following licenses.
 
-For the Realm Core (TightDB) component
+For the Realm Core component
 
-  Realm Core (TightDB) Binary License
+  Realm Core Binary License
 
-  Copyright (c) 2011-2014 Realm Inc All rights reserved
+  Copyright (c) 2011-2015 Realm Inc All rights reserved
 
   Redistribution and use in binary form, with or without modification, is
   permitted provided that the following conditions are met:
@@ -266,4 +266,4 @@ authorize the transfer of, directly or indirectly, the Software to any prohibite
 country, including Cuba, Iran, North Korea, Sudan, or Syria, or to any person or
 organization on or affiliated with the Department of Commerce lists of Denied
 Persons, Unverified Parties or Restricted Entities, or otherwise in violation of any
-such restrictions or regulations.
\ No newline at end of file
+such restrictions or regulations.
diff --git a/changelog.txt b/changelog.txt
index e6418599b4..6b92c68e9f 100644
--- a/changelog.txt
+++ b/changelog.txt
@@ -1,3 +1,22 @@
+0.80.1
+ * Realm.createOrUpdateWithJson() no longer resets fields to their default value if they are not found in the JSON input.
+ * Realm.compactRealmFile() now uses Realm Core's compact() method which is more failure resilient.
+ * Realm.copyToRealm() now correctly handles referenced child objects that are already in the Realm.
+ * The ARM64 binary is now properly a part of the Eclipse distribution package.
+ * A RealmMigrationExceptionNeeded is now properly thrown if @Index and @PrimaryKey are not set correctly during a migration.
+ * Fixed bug causing Realms to be cached even though they failed to open correctly.
+ * Added Realm.deleteRealmFile(File) method.
+ * Fixed bug causing queries to fail if multiple Realms has different field ordering.
+ * Fixed bug when using Realm.copyToRealm() with a primary key could crash if default value was already used in the Realm.
+ * Updated Realm Core to version 0.89.0
+   - improved performance for sorting RealmResults.
+   - improved performance for refreshing a Realm after inserting or modifying strings or binary data.
+   - fixed bug causing incorrect result when querying indexed fields.
+   - fixed bug causing corruption of string index when deleting an object where there are duplicate values for the indexed field.
+   - fixed bug causing a crash after compacting the Realm file.
+ * Added RealmQuery.isNull() and RealmQuery.isNotNull() for querying relationships.
+ * Fixed a potential NPE in the RealmList constructor.
+
 0.80
 * Queries on relationships can be case sensitive.
 * Fixed bug when importing JSONObjects containing NULL values.
diff --git a/examples/adapterExample/build.gradle b/examples/adapterExample/build.gradle
index 7e811a8518..6d0581f8a8 100644
--- a/examples/adapterExample/build.gradle
+++ b/examples/adapterExample/build.gradle
@@ -7,7 +7,7 @@ android {
 
     defaultConfig {
         applicationId "io.realm.examples.realmadapters"
-        minSdkVersion 15
+        minSdkVersion 10
         targetSdkVersion 19
         versionCode 1
         versionName "1.0"
diff --git a/examples/encryptionExample/build.gradle b/examples/encryptionExample/build.gradle
index 3cd83ff083..14ac0e04d2 100644
--- a/examples/encryptionExample/build.gradle
+++ b/examples/encryptionExample/build.gradle
@@ -6,7 +6,7 @@ android {
     buildToolsVersion '20.0.0'
     defaultConfig {
         applicationId 'examples.realm.io.encryptionExample'
-        minSdkVersion 14
+        minSdkVersion 10
         targetSdkVersion 19
         versionCode 1
         versionName '1.0'
diff --git a/examples/gridViewExample/build.gradle b/examples/gridViewExample/build.gradle
index a325e0edc7..23ed199420 100644
--- a/examples/gridViewExample/build.gradle
+++ b/examples/gridViewExample/build.gradle
@@ -6,7 +6,7 @@ android {
     buildToolsVersion "20.0.0"
     defaultConfig {
         applicationId 'io.realm.examples.realmgridview'
-        minSdkVersion 15
+        minSdkVersion 10
         targetSdkVersion 19
         versionCode 1
         versionName "1.0"
diff --git a/examples/introExample/build.gradle b/examples/introExample/build.gradle
index 0dacbb9071..11f9b88d81 100644
--- a/examples/introExample/build.gradle
+++ b/examples/introExample/build.gradle
@@ -6,7 +6,7 @@ android {
     buildToolsVersion "20.0.0"
     defaultConfig {
         applicationId 'io.realm.examples.intro'
-        minSdkVersion 15
+        minSdkVersion 10
         targetSdkVersion 19
         versionCode 1
         versionName "1.0"
diff --git a/examples/jsonExample/build.gradle b/examples/jsonExample/build.gradle
index bdf7f8c44c..9a4133f73c 100644
--- a/examples/jsonExample/build.gradle
+++ b/examples/jsonExample/build.gradle
@@ -6,7 +6,7 @@ android {
     buildToolsVersion "20.0.0"
     defaultConfig {
         applicationId 'io.realm.examples.json'
-        minSdkVersion 15
+        minSdkVersion 10
         targetSdkVersion 19
         versionCode 1
         versionName "1.0"
diff --git a/examples/migrationExample/build.gradle b/examples/migrationExample/build.gradle
index 19f7ee43ef..8b9c902581 100644
--- a/examples/migrationExample/build.gradle
+++ b/examples/migrationExample/build.gradle
@@ -7,7 +7,7 @@ android {
 
     defaultConfig {
         applicationId "examples.realm.io.migration"
-        minSdkVersion 15
+        minSdkVersion 10
         targetSdkVersion 19
         versionCode 1
         versionName "1.0"
diff --git a/examples/threadExample/build.gradle b/examples/threadExample/build.gradle
index a064db9bf7..90fa256683 100644
--- a/examples/threadExample/build.gradle
+++ b/examples/threadExample/build.gradle
@@ -7,7 +7,7 @@ android {
 
     defaultConfig {
         applicationId "io.realm.examples.threads"
-        minSdkVersion 15
+        minSdkVersion 10
         targetSdkVersion 21
         versionCode 1
         versionName "1.0"
diff --git a/experimental/pathExperiment/build.gradle b/experimental/pathExperiment/build.gradle
index ea992a99d8..6bf0a97348 100644
--- a/experimental/pathExperiment/build.gradle
+++ b/experimental/pathExperiment/build.gradle
@@ -22,7 +22,7 @@ android {
 
     defaultConfig {
         applicationId "io.realm.pathrealminteroptest"
-        minSdkVersion 15
+        minSdkVersion 10
         targetSdkVersion 21
         versionCode 1
         versionName "1.0"
diff --git a/realm-annotations-processor/build.gradle b/realm-annotations-processor/build.gradle
index 3cee1a18b6..1fa45c1104 100644
--- a/realm-annotations-processor/build.gradle
+++ b/realm-annotations-processor/build.gradle
@@ -1,4 +1,14 @@
+buildscript {
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath 'com.github.jengelman.gradle.plugins:shadow:1.2.1'
+    }
+}
+
 apply plugin: 'java'
+apply plugin: 'com.github.johnrengelman.shadow'
 
 version = new File("${projectDir}/../version.txt").text
 sourceCompatibility = '1.6'
@@ -28,6 +38,12 @@ jar {
     from configurations.compile.findAll {it.name.contains('javawriter')}.collect { zipTree(it) }
 }
 
+shadowJar {
+    relocate 'com.squareup.javawriter', 'io.realm.processor.javawriter'
+    exclude 'io/realm/annotations/**'
+    classifier = ''
+}
+
 //for Ant filter
 import org.apache.tools.ant.filters.ReplaceTokens
 
@@ -58,7 +74,7 @@ task assembleRealm(type: GradleBuild) {
     tasks = ['assemble']
 }
 
-tasks.assemble {
+tasks.compileJava {
     dependsOn compileAnnotations
 }
 
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index 4579bada85..545013b592 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -334,6 +334,10 @@ private boolean categorizeClassElements() {
             fieldNames.add(field.getSimpleName().toString());
         }
 
+        if (fields.size() == 0) {
+            Utils.error(className + " must contain at least 1 persistable field");
+        }
+
         return true;
     }
 
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmJSonImplGenerator.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmJSonImplGenerator.java
index 28248eca2b..73ee437fa1 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmJSonImplGenerator.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmJSonImplGenerator.java
@@ -28,7 +28,7 @@
 
     private static final String REALM_PACKAGE_NAME = "io.realm";
     private static final String CLASS_NAME = "RealmJsonImpl";
-    private static final String EXCEPTION_MSG = "\"Could not find the generated proxy class for \" + classQualifiedName";
+    private static final String EXCEPTION_MSG = "Could not find the generated proxy class for ";
 
     public RealmJSonImplGenerator(ProcessingEnvironment processingEnv, Set<ClassMetaData> classesToValidate) {
         this.processingEnvironment = processingEnv;
@@ -69,37 +69,37 @@ public void generate() throws IOException {
                 "RealmJson");                   // Interfaces to implement
         writer.emitEmptyLine();
 
-        emitPopulateUsingJsonObject(writer);
-        emitPopulateUsingJsonStream(writer);
+        emitCreateOrUpdateUsingJsonObject(writer);
+        emitCreateUsingJsonStream(writer);
 
         writer.endType();
         writer.close();
     }
 
-    private void emitPopulateUsingJsonObject(JavaWriter writer) throws IOException {
+    private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
-                "<E extends RealmObject> void",
-                "populateUsingJsonObject",
+                "<E extends RealmObject> E",
+                "createOrUpdateUsingJsonObject",
                 EnumSet.of(Modifier.PUBLIC),
-                Arrays.asList("E", "obj", "JSONObject", "json"),
+                Arrays.asList("Class<E>", "clazz", "Realm", "realm", "JSONObject", "json", "boolean", "update"),
                 Arrays.asList("JSONException")
         );
-        emitProxySwitch("%s.populateUsingJsonObject((%s) obj, json)", writer);
+        emitProxySwitch("return (E) %s.createOrUpdateUsingJsonObject(realm, json, update)", writer);
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
-    private void emitPopulateUsingJsonStream(JavaWriter writer) throws IOException {
+    private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
-                "<E extends RealmObject> void",
-                "populateUsingJsonStream",
+                "<E extends RealmObject> E",
+                "createUsingJsonStream",
                 EnumSet.of(Modifier.PUBLIC),
-                Arrays.asList("E", "obj", "JsonReader", "reader"),
+                Arrays.asList("Class<E>", "clazz", "Realm", "realm", "JsonReader", "reader"),
                 Arrays.asList("IOException")
         );
-        emitProxySwitch("%s.populateUsingJsonStream((%s) obj, reader)", writer);
+        emitProxySwitch("return (E) %s.createUsingJsonStream(realm, reader)", writer);
         writer.endMethod();
         writer.emitEmptyLine();
     }
@@ -108,19 +108,19 @@ private void emitPopulateUsingJsonStream(JavaWriter writer) throws IOException {
     // Currently it is just if..else, which is inefficient for large amounts amounts of model classes.
     // Consider switching to HashMap or similar.
     private void emitProxySwitch(String proxyStatement, JavaWriter writer) throws IOException {
-        writer.emitStatement("String classQualifiedName = (obj.realm != null) ? obj.getClass().getSuperclass().getName() : obj.getClass().getName()");
         if (simpleModelClasses.size() == 0) {
-            writer.emitStatement("throw new RealmException(%s)", EXCEPTION_MSG);
+            writer.emitStatement("throw new RealmException(\"%s\" + clazz)", EXCEPTION_MSG);
         } else {
-            writer.beginControlFlow("if (classQualifiedName.equals(%s.class.getName()))", simpleModelClasses.get(0));
-            writer.emitStatement(proxyStatement, proxyClasses.get(0), simpleModelClasses.get(0));
+            writer.beginControlFlow("if (clazz.equals(%s.class))", simpleModelClasses.get(0));
+            writer.emitStatement(proxyStatement, proxyClasses.get(0));
             for (int i = 1; i < simpleModelClasses.size(); i++) {
-                writer.nextControlFlow("else if (classQualifiedName.equals(%s.class.getName()))", simpleModelClasses.get(i));
-                writer.emitStatement(proxyStatement, proxyClasses.get(i), simpleModelClasses.get(i));
+                writer.nextControlFlow("else if (clazz.equals(%s.class))", simpleModelClasses.get(i));
+                writer.emitStatement(proxyStatement, proxyClasses.get(i));
             }
             writer.nextControlFlow("else");
-            writer.emitStatement("throw new RealmException(%s)", EXCEPTION_MSG);
+            writer.emitStatement("throw new RealmException(\"%s\" + clazz)", EXCEPTION_MSG);
             writer.endControlFlow();
         }
     }
+
 }
\ No newline at end of file
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
index b559fc1a23..84095e17f2 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
@@ -98,11 +98,9 @@ public static void emitFillRealmObjectWithJsonValue(String setter, String fieldN
                                                         String proxyClass, JavaWriter writer) throws IOException {
         writer
             .beginControlFlow("if (!json.isNull(\"%s\"))", fieldName)
-                .emitStatement("%s %s = standalone ? new %s() : obj.realm.createObject(%s.class)",
-                        qualifiedFieldType, fieldName, qualifiedFieldType, qualifiedFieldType)
-                .emitStatement("%s.populateUsingJsonObject(%s, json.getJSONObject(\"%s\"))",
-                        proxyClass, fieldName, fieldName)
-                .emitStatement("obj.%s(%s)", setter, fieldName)
+                .emitStatement("%s %sObj = %s.createOrUpdateUsingJsonObject(realm, json.getJSONObject(\"%s\"), update)",
+                        qualifiedFieldType, fieldName, proxyClass, fieldName)
+                .emitStatement("obj.%s(%sObj)", setter, fieldName)
             .endControlFlow();
     }
 
@@ -111,13 +109,11 @@ public static void emitFillRealmListWithJsonValue(String getter, String setter,
                                                       JavaWriter writer) throws IOException {
         writer
             .beginControlFlow("if (!json.isNull(\"%s\"))", fieldName)
-                .beginControlFlow("if (standalone)")
-                    .emitStatement("obj.%s(new RealmList<%s>())", setter, fieldTypeCanonicalName)
-                .endControlFlow()
+                .emitStatement("obj.%s().clear()", getter)
                 .emitStatement("JSONArray array = json.getJSONArray(\"%s\")", fieldName)
                 .beginControlFlow("for (int i = 0; i < array.length(); i++)")
-                    .emitStatement("%s item = standalone ? new %s() : obj.realm.createObject(%s.class)", fieldTypeCanonicalName, fieldTypeCanonicalName, fieldTypeCanonicalName)
-                    .emitStatement("%s.populateUsingJsonObject(item, array.getJSONObject(i))", proxyClass)
+                    .emitStatement("%s item = %s.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update)",
+                            fieldTypeCanonicalName, proxyClass, fieldTypeCanonicalName)
                     .emitStatement("obj.%s().add(item)", getter)
                 .endControlFlow()
             .endControlFlow();
@@ -132,20 +128,15 @@ public static void emitFillJavaTypeFromStream(String setter, String fieldName, S
 
     public static void emitFillRealmObjectFromStream(String setter, String fieldName, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer) throws IOException {
         writer
-            .emitStatement("%s %sObj = standalone ? new %s() : obj.realm.createObject(%s.class)", fieldTypeCanonicalName, fieldName, fieldTypeCanonicalName, fieldTypeCanonicalName)
-            .emitStatement("%s.populateUsingJsonStream(%sObj, reader)", proxyClass, fieldName)
+            .emitStatement("%s %sObj = %s.createUsingJsonStream(realm, reader)", fieldTypeCanonicalName, fieldName, proxyClass)
             .emitStatement("obj.%s(%sObj)", setter, fieldName);
     }
 
     public static void emitFillRealmListFromStream(String getter, String setter, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer) throws IOException {
         writer
             .emitStatement("reader.beginArray()")
-            .beginControlFlow("if (standalone)")
-                .emitStatement("obj.%s(new RealmList<%s>())", setter, fieldTypeCanonicalName)
-            .endControlFlow()
             .beginControlFlow("while (reader.hasNext())")
-                .emitStatement("%s item = standalone ? new %s() : obj.realm.createObject(%s.class)", fieldTypeCanonicalName, fieldTypeCanonicalName, fieldTypeCanonicalName)
-                .emitStatement("%s.populateUsingJsonStream(item, reader)", proxyClass)
+                .emitStatement("%s item = %s.createUsingJsonStream(realm, reader)", fieldTypeCanonicalName, proxyClass)
                 .emitStatement("obj.%s().add(item)", getter)
             .endControlFlow()
             .emitStatement("reader.endArray()");
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 5ef7bb6664..600c099aa5 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -144,6 +144,7 @@ public void generate() throws IOException, UnsupportedOperationException {
         imports.add("android.support.v11.util.JsonToken");
         imports.add("io.realm.RealmObject");
         imports.add("io.realm.exceptions.RealmException");
+        imports.add("io.realm.exceptions.RealmMigrationNeededException");
         imports.add("io.realm.internal.ColumnType");
         imports.add("io.realm.internal.Table");
         imports.add("io.realm.internal.TableOrView");
@@ -151,6 +152,8 @@ public void generate() throws IOException, UnsupportedOperationException {
         imports.add("io.realm.internal.LinkView");
         imports.add("io.realm.internal.android.JsonUtils");
         imports.add("java.io.IOException");
+        imports.add("java.util.ArrayList");
+        imports.add("java.util.Collections");
         imports.add("java.util.List");
         imports.add("java.util.Arrays");
         imports.add("java.util.Date");
@@ -168,7 +171,7 @@ public void generate() throws IOException, UnsupportedOperationException {
             } else if (typeUtils.isAssignable(field.asType(), realmList)) { // LinkLists
                 fieldTypeName = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
             }
-            if (fieldTypeName != "" && !imports.contains(fieldTypeName)) {
+            if (!fieldTypeName.isEmpty() && !imports.contains(fieldTypeName)) {
                 imports.add(fieldTypeName);
             }
         }
@@ -184,12 +187,14 @@ public void generate() throws IOException, UnsupportedOperationException {
                 className)                   // class to extend
                 .emitEmptyLine();
 
+        emitClassFields(writer);
         emitAccessors(writer);
         emitInitTableMethod(writer);
         emitValidateTableMethod(writer);
         emitGetFieldNamesMethod(writer);
-        emitPopulateUsingJsonObjectMethod(writer);
-        emitPopulateUsingJsonStreamMethod(writer);
+        emitGetColumnIndicesMethod(writer);
+        emitCreateOrUpdateUsingJsonObject(writer);
+        emitCreateUsingJsonStream(writer);
         emitCopyOrUpdateMethod(writer);
         emitCopyMethod(writer);
         emitUpdateMethod(writer);
@@ -202,6 +207,22 @@ public void generate() throws IOException, UnsupportedOperationException {
         writer.close();
     }
 
+    private void emitClassFields(JavaWriter writer) throws IOException {
+        for (VariableElement variableElement : metadata.getFields()) {
+            writer.emitField("long", staticFieldIndexVarName(variableElement), EnumSet.of(Modifier.PRIVATE, Modifier.STATIC));
+        }
+        writer.emitField("Map<String, Long>", "columnIndices", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC));
+        writer.emitField("List<String>", "FIELD_NAMES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
+        writer.beginInitializer(true);
+        writer.emitStatement("List<String> fieldNames = new ArrayList<String>()");
+        for (VariableElement field : metadata.getFields()) {
+            writer.emitStatement("fieldNames.add(\"%s\")", field.getSimpleName().toString());
+        }
+        writer.emitStatement("FIELD_NAMES = Collections.unmodifiableList(fieldNames)");
+        writer.endInitializer();
+        writer.emitEmptyLine();
+    }
+
     private void emitAccessors(JavaWriter writer) throws IOException {
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
@@ -221,8 +242,8 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                         "realm.checkIfValid()"
                 );
                 writer.emitStatement(
-                        "return (%s) row.get%s(Realm.columnIndices.get(\"%s\").get(\"%s\"))",
-                        fieldTypeCanonicalName, realmType, className, fieldName);
+                        "return (%s) row.get%s(%s)",
+                        fieldTypeCanonicalName, realmType, staticFieldIndexVarName(field));
                 writer.endMethod();
                 writer.emitEmptyLine();
 
@@ -233,8 +254,8 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                         "realm.checkIfValid()"
                 );
                 writer.emitStatement(
-                        "row.set%s(Realm.columnIndices.get(\"%s\").get(\"%s\"), (%s) value)",
-                        realmType, className, fieldName, castingType);
+                        "row.set%s(%s, (%s) value)",
+                        realmType, staticFieldIndexVarName(field), castingType);
                 writer.endMethod();
             } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
                 /**
@@ -244,12 +265,12 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                 // Getter
                 writer.emitAnnotation("Override");
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
-                writer.beginControlFlow("if (row.isNullLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))", className, fieldName);
+                writer.beginControlFlow("if (row.isNullLink(%s))", staticFieldIndexVarName(field));
                 writer.emitStatement("return null");
                 writer.endControlFlow();
                 writer.emitStatement(
-                        "return realm.get(%s.class, row.getLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))",
-                        fieldTypeCanonicalName, className, fieldName);
+                        "return realm.get(%s.class, row.getLink(%s))",
+                        fieldTypeCanonicalName, staticFieldIndexVarName(field));
                 writer.endMethod();
                 writer.emitEmptyLine();
 
@@ -257,10 +278,10 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                 writer.emitAnnotation("Override");
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                 writer.beginControlFlow("if (value == null)");
-                writer.emitStatement("row.nullifyLink(Realm.columnIndices.get(\"%s\").get(\"%s\"))", className, fieldName);
+                writer.emitStatement("row.nullifyLink(%s)", staticFieldIndexVarName(field));
                 writer.emitStatement("return");
                 writer.endControlFlow();
-                writer.emitStatement("row.setLink(Realm.columnIndices.get(\"%s\").get(\"%s\"), value.row.getIndex())", className, fieldName);
+                writer.emitStatement("row.setLink(%s, value.row.getIndex())", staticFieldIndexVarName(field));
                 writer.endMethod();
             } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                 /**
@@ -272,15 +293,15 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                 writer.emitAnnotation("Override");
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
                 writer.emitStatement(
-                        "return new RealmList<%s>(%s.class, row.getLinkList(Realm.columnIndices.get(\"%s\").get(\"%s\")), realm)",
-                        genericType, genericType, className, fieldName);
+                        "return new RealmList<%s>(%s.class, row.getLinkList(%s), realm)",
+                        genericType, genericType, staticFieldIndexVarName(field));
                 writer.endMethod();
                 writer.emitEmptyLine();
 
                 // Setter
                 writer.emitAnnotation("Override");
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-                writer.emitStatement("LinkView links = row.getLinkList(Realm.columnIndices.get(\"%s\").get(\"%s\"))", className, fieldName);
+                writer.emitStatement("LinkView links = row.getLinkList(%s)", staticFieldIndexVarName(field));
                 writer.beginControlFlow("if (value == null)");
                 writer.emitStatement("return"); // TODO: delete all the links instead
                 writer.endControlFlow();
@@ -387,6 +408,21 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                         fieldTypeSimpleName, fieldName);
                 writer.endControlFlow();
+
+                // Validate @PrimaryKey
+                if (field.equals(metadata.getPrimaryKey())) {
+                    writer.beginControlFlow("if (table.getPrimaryKey() != table.getColumnIndex(\"%s\"))", fieldName);
+                    writer.emitStatement("throw new IllegalStateException(\"Primary key not defined for field '%s'\")", fieldName);
+                    writer.endControlFlow();
+                }
+
+                // Validate @Index
+                if (metadata.getIndexedFields().contains(field)) {
+                    writer.beginControlFlow("if (!table.hasIndex(table.getColumnIndex(\"%s\")))", fieldName);
+                    writer.emitStatement("throw new IllegalStateException(\"Index not defined for field '%s'\")", fieldName);
+                    writer.endControlFlow();
+                }
+
             } else if (typeUtils.isAssignable(field.asType(), realmObject)) { // Links
                 writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                 writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
@@ -426,6 +462,23 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
 //                writer.endControlFlow();
             }
         }
+
+        // Populate column indices
+        writer.emitEmptyLine();
+        writer.emitStatement("columnIndices = new HashMap<String, Long>()");
+        writer
+            .beginControlFlow("for (String fieldName : getFieldNames())")
+                .emitStatement("long index = table.getColumnIndex(fieldName)")
+                .beginControlFlow("if (index == -1)")
+                    .emitStatement("throw new RealmMigrationNeededException(\"Field '\" + fieldName + \"' not found for type %s\")", metadata.getSimpleClassName())
+                .endControlFlow()
+                .emitStatement("columnIndices.put(fieldName, index)")
+            .endControlFlow();
+        for (VariableElement field : metadata.getFields()) {
+            writer.emitStatement("%s = table.getColumnIndex(\"%s\")", staticFieldIndexVarName(field), field.getSimpleName().toString());
+        }
+        writer.nextControlFlow("else");
+        writer.emitStatement("throw new RealmMigrationNeededException(\"The %s class is missing from the schema for this Realm.\")", metadata.getSimpleClassName());
         writer.endControlFlow();
         writer.endMethod();
         writer.emitEmptyLine();
@@ -433,19 +486,14 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
 
     private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
         writer.beginMethod("List<String>", "getFieldNames", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC));
-        StringBuilder stringBuilder = new StringBuilder();
-        Iterator<VariableElement> iterator = metadata.getFields().iterator();
-        while (iterator.hasNext()) {
-            String fieldName = iterator.next().getSimpleName().toString();
-            stringBuilder.append("\"");
-            stringBuilder.append(fieldName);
-            stringBuilder.append("\"");
-            if (iterator.hasNext()) {
-                stringBuilder.append(", ");
-            }
-        }
-        String statementSection = stringBuilder.toString();
-        writer.emitStatement("return Arrays.asList(%s)", statementSection);
+        writer.emitStatement("return FIELD_NAMES");
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitGetColumnIndicesMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod("Map<String,Long>", "getColumnIndices", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC));
+        writer.emitStatement("return columnIndices");
         writer.endMethod();
         writer.emitEmptyLine();
     }
@@ -458,6 +506,12 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                 "Realm", "realm", className, "object", "boolean", "update", "Map<RealmObject,RealmObject>", "cache" // Argument type & argument name
         );
 
+        // If object is already in the Realm there is nothing to update
+        writer
+            .beginControlFlow("if (object.realm != null && object.realm.getId() == realm.getId())")
+                .emitStatement("return object")
+            .endControlFlow();
+
         if (!metadata.hasPrimaryKey()) {
             writer.emitStatement("return copy(realm, object, update, cache)");
         } else {
@@ -506,7 +560,11 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                 "Realm", "realm", className, "newObject", "boolean", "update", "Map<RealmObject,RealmObject>", "cache"); // Argument type & argument name
 
-        writer.emitStatement("%s realmObject = realm.createObject(%s.class)", className, className);
+        if (metadata.hasPrimaryKey()) {
+            writer.emitStatement("%s realmObject = realm.createObject(%s.class, newObject.%s())", className, className, metadata.getPrimaryKeyGetter());
+        } else {
+            writer.emitStatement("%s realmObject = realm.createObject(%s.class)", className, className);
+        }
         writer.emitStatement("cache.put(newObject, realmObject)");
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
@@ -710,15 +768,39 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
-    private void emitPopulateUsingJsonObjectMethod(JavaWriter writer) throws IOException {
+
+    private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                "void",
-                "populateUsingJsonObject",
+                className,
+                "createOrUpdateUsingJsonObject",
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
-                Arrays.asList(className, "obj", "JSONObject", "json"),
+                Arrays.asList("Realm", "realm", "JSONObject", "json", "boolean", "update"),
                 Arrays.asList("JSONException"));
 
-        writer.emitStatement("boolean standalone = obj.realm == null");
+        if (!metadata.hasPrimaryKey()) {
+            writer.emitStatement("%s obj = realm.createObject(%s.class)", className, className);
+        } else {
+            String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
+            writer
+                .emitStatement("%s obj = null", className)
+                .beginControlFlow("if (update)")
+                    .emitStatement("Table table = realm.getTable(%s.class)", className)
+                    .emitStatement("long pkColumnIndex = table.getPrimaryKey()")
+                    .beginControlFlow("if (!json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
+                        .emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
+                                pkType, pkType, metadata.getPrimaryKey().getSimpleName())
+                        .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
+                            .emitStatement("obj = new %s()", Utils.getProxyClassName(className))
+                            .emitStatement("obj.realm = realm")
+                            .emitStatement("obj.row = table.getRow(rowIndex)")
+                        .endControlFlow()
+                    .endControlFlow()
+                .endControlFlow()
+                .beginControlFlow("if (obj == null)")
+                    .emitStatement("obj = realm.createObject(%s.class)", className)
+                .endControlFlow();
+        }
+
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String qualifiedFieldType = field.asType().toString();
@@ -748,19 +830,20 @@ private void emitPopulateUsingJsonObjectMethod(JavaWriter writer) throws IOExcep
             }
         }
 
+        writer.emitStatement("return obj");
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
-    private void emitPopulateUsingJsonStreamMethod(JavaWriter writer) throws IOException {
+    private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                "void",
-                "populateUsingJsonStream",
+                className,
+                "createUsingJsonStream",
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
-                Arrays.asList(className, "obj", "JsonReader", "reader"),
+                Arrays.asList("Realm", "realm", "JsonReader", "reader"),
                 Arrays.asList("IOException"));
 
-        writer.emitStatement("boolean standalone = obj.realm == null");
+        writer.emitStatement("%s obj = realm.createObject(%s.class)",className, className);
         writer.emitStatement("reader.beginObject()");
         writer.beginControlFlow("while (reader.hasNext())");
         writer.emitStatement("String name = reader.nextName()");
@@ -808,7 +891,12 @@ private void emitPopulateUsingJsonStreamMethod(JavaWriter writer) throws IOExcep
         }
         writer.endControlFlow();
         writer.emitStatement("reader.endObject()");
+        writer.emitStatement("return obj");
         writer.endMethod();
         writer.emitEmptyLine();
     }
+
+    private String staticFieldIndexVarName(VariableElement variableElement) {
+        return "INDEX_" + variableElement.getSimpleName().toString().toUpperCase();
+    }
 }
diff --git a/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java b/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
index 0d73de59e9..988eb05639 100644
--- a/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
+++ b/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
@@ -52,19 +52,12 @@ public void compileProcessedSimpleFile() throws Exception {
                 .compilesWithoutError();
     }
 
-    @Test
-    public void compileEmptyFile() {
-        ASSERT.about(javaSource())
-                .that(emptyModel)
-                .compilesWithoutError();
-    }
-
     @Test
     public void compileProcessedEmptyFile() throws Exception {
         ASSERT.about(javaSource())
                 .that(emptyModel)
                 .processedWith(new RealmProcessor())
-                .compilesWithoutError();
+                .failsToCompile();
     }
 
     @Test
diff --git a/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index e8a7e8fd6a..d2fad57e02 100644
--- a/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -5,6 +5,7 @@
 import android.util.JsonToken;
 import io.realm.RealmObject;
 import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnType;
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
@@ -12,7 +13,9 @@
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
@@ -24,115 +27,140 @@
 
 public class AllTypesRealmProxy extends AllTypes {
 
+    private static long INDEX_COLUMNSTRING;
+    private static long INDEX_COLUMNLONG;
+    private static long INDEX_COLUMNFLOAT;
+    private static long INDEX_COLUMNDOUBLE;
+    private static long INDEX_COLUMNBOOLEAN;
+    private static long INDEX_COLUMNDATE;
+    private static long INDEX_COLUMNBINARY;
+    private static long INDEX_COLUMNOBJECT;
+    private static long INDEX_COLUMNREALMLIST;
+    private static Map<String, Long> columnIndices;
+    private static final List<String> FIELD_NAMES;
+    static {
+        List<String> fieldNames = new ArrayList<String>();
+        fieldNames.add("columnString");
+        fieldNames.add("columnLong");
+        fieldNames.add("columnFloat");
+        fieldNames.add("columnDouble");
+        fieldNames.add("columnBoolean");
+        fieldNames.add("columnDate");
+        fieldNames.add("columnBinary");
+        fieldNames.add("columnObject");
+        fieldNames.add("columnRealmList");
+        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
+    }
+
     @Override
     public String getColumnString() {
         realm.checkIfValid();
-        return (java.lang.String) row.getString(Realm.columnIndices.get("AllTypes").get("columnString"));
+        return (java.lang.String) row.getString(INDEX_COLUMNSTRING);
     }
 
     @Override
     public void setColumnString(String value) {
         realm.checkIfValid();
-        row.setString(Realm.columnIndices.get("AllTypes").get("columnString"), (String) value);
+        row.setString(INDEX_COLUMNSTRING, (String) value);
     }
 
     @Override
     public long getColumnLong() {
         realm.checkIfValid();
-        return (long) row.getLong(Realm.columnIndices.get("AllTypes").get("columnLong"));
+        return (long) row.getLong(INDEX_COLUMNLONG);
     }
 
     @Override
     public void setColumnLong(long value) {
         realm.checkIfValid();
-        row.setLong(Realm.columnIndices.get("AllTypes").get("columnLong"), (long) value);
+        row.setLong(INDEX_COLUMNLONG, (long) value);
     }
 
     @Override
     public float getColumnFloat() {
         realm.checkIfValid();
-        return (float) row.getFloat(Realm.columnIndices.get("AllTypes").get("columnFloat"));
+        return (float) row.getFloat(INDEX_COLUMNFLOAT);
     }
 
     @Override
     public void setColumnFloat(float value) {
         realm.checkIfValid();
-        row.setFloat(Realm.columnIndices.get("AllTypes").get("columnFloat"), (float) value);
+        row.setFloat(INDEX_COLUMNFLOAT, (float) value);
     }
 
     @Override
     public double getColumnDouble() {
         realm.checkIfValid();
-        return (double) row.getDouble(Realm.columnIndices.get("AllTypes").get("columnDouble"));
+        return (double) row.getDouble(INDEX_COLUMNDOUBLE);
     }
 
     @Override
     public void setColumnDouble(double value) {
         realm.checkIfValid();
-        row.setDouble(Realm.columnIndices.get("AllTypes").get("columnDouble"), (double) value);
+        row.setDouble(INDEX_COLUMNDOUBLE, (double) value);
     }
 
     @Override
     public boolean isColumnBoolean() {
         realm.checkIfValid();
-        return (boolean) row.getBoolean(Realm.columnIndices.get("AllTypes").get("columnBoolean"));
+        return (boolean) row.getBoolean(INDEX_COLUMNBOOLEAN);
     }
 
     @Override
     public void setColumnBoolean(boolean value) {
         realm.checkIfValid();
-        row.setBoolean(Realm.columnIndices.get("AllTypes").get("columnBoolean"), (boolean) value);
+        row.setBoolean(INDEX_COLUMNBOOLEAN, (boolean) value);
     }
 
     @Override
     public Date getColumnDate() {
         realm.checkIfValid();
-        return (java.util.Date) row.getDate(Realm.columnIndices.get("AllTypes").get("columnDate"));
+        return (java.util.Date) row.getDate(INDEX_COLUMNDATE);
     }
 
     @Override
     public void setColumnDate(Date value) {
         realm.checkIfValid();
-        row.setDate(Realm.columnIndices.get("AllTypes").get("columnDate"), (Date) value);
+        row.setDate(INDEX_COLUMNDATE, (Date) value);
     }
 
     @Override
     public byte[] getColumnBinary() {
         realm.checkIfValid();
-        return (byte[]) row.getBinaryByteArray(Realm.columnIndices.get("AllTypes").get("columnBinary"));
+        return (byte[]) row.getBinaryByteArray(INDEX_COLUMNBINARY);
     }
 
     @Override
     public void setColumnBinary(byte[] value) {
         realm.checkIfValid();
-        row.setBinaryByteArray(Realm.columnIndices.get("AllTypes").get("columnBinary"), (byte[]) value);
+        row.setBinaryByteArray(INDEX_COLUMNBINARY, (byte[]) value);
     }
 
     @Override
     public AllTypes getColumnObject() {
-        if (row.isNullLink(Realm.columnIndices.get("AllTypes").get("columnObject"))) {
+        if (row.isNullLink(INDEX_COLUMNOBJECT)) {
             return null;
         }
-        return realm.get(some.test.AllTypes.class, row.getLink(Realm.columnIndices.get("AllTypes").get("columnObject")));
+        return realm.get(some.test.AllTypes.class, row.getLink(INDEX_COLUMNOBJECT));
     }
 
     @Override
     public void setColumnObject(AllTypes value) {
         if (value == null) {
-            row.nullifyLink(Realm.columnIndices.get("AllTypes").get("columnObject"));
+            row.nullifyLink(INDEX_COLUMNOBJECT);
             return;
         }
-        row.setLink(Realm.columnIndices.get("AllTypes").get("columnObject"), value.row.getIndex());
+        row.setLink(INDEX_COLUMNOBJECT, value.row.getIndex());
     }
 
     @Override
     public RealmList<AllTypes> getColumnRealmList() {
-        return new RealmList<AllTypes>(AllTypes.class, row.getLinkList(Realm.columnIndices.get("AllTypes").get("columnRealmList")), realm);
+        return new RealmList<AllTypes>(AllTypes.class, row.getLinkList(INDEX_COLUMNREALMLIST), realm);
     }
 
     @Override
     public void setColumnRealmList(RealmList<AllTypes> value) {
-        LinkView links = row.getLinkList(Realm.columnIndices.get("AllTypes").get("columnRealmList"));
+        LinkView links = row.getLinkList(INDEX_COLUMNREALMLIST);
         if (value == null) {
             return;
         }
@@ -182,6 +210,12 @@ public static void validateTable(ImplicitTransaction transaction) {
             if (columnTypes.get("columnString") != ColumnType.STRING) {
                 throw new IllegalStateException("Invalid type 'String' for column 'columnString'");
             }
+            if (table.getPrimaryKey() != table.getColumnIndex("columnString")) {
+                throw new IllegalStateException("Primary key not defined for field 'columnString'");
+            }
+            if (!table.hasIndex(table.getColumnIndex("columnString"))) {
+                throw new IllegalStateException("Index not defined for field 'columnString'");
+            }
             if (!columnTypes.containsKey("columnLong")) {
                 throw new IllegalStateException("Missing column 'columnLong'");
             }
@@ -236,16 +270,55 @@ public static void validateTable(ImplicitTransaction transaction) {
             if (!transaction.hasTable("class_AllTypes")) {
                 throw new IllegalStateException("Missing table 'class_AllTypes' for column 'columnRealmList'");
             }
+
+            columnIndices = new HashMap<String, Long>();
+            for (String fieldName : getFieldNames()) {
+                long index = table.getColumnIndex(fieldName);
+                if (index == -1) {
+                    throw new RealmMigrationNeededException("Field '" + fieldName + "' not found for type AllTypes");
+                }
+                columnIndices.put(fieldName, index);
+            }
+            INDEX_COLUMNSTRING = table.getColumnIndex("columnString");
+            INDEX_COLUMNLONG = table.getColumnIndex("columnLong");
+            INDEX_COLUMNFLOAT = table.getColumnIndex("columnFloat");
+            INDEX_COLUMNDOUBLE = table.getColumnIndex("columnDouble");
+            INDEX_COLUMNBOOLEAN = table.getColumnIndex("columnBoolean");
+            INDEX_COLUMNDATE = table.getColumnIndex("columnDate");
+            INDEX_COLUMNBINARY = table.getColumnIndex("columnBinary");
+            INDEX_COLUMNOBJECT = table.getColumnIndex("columnObject");
+            INDEX_COLUMNREALMLIST = table.getColumnIndex("columnRealmList");
+        } else {
+            throw new RealmMigrationNeededException("The AllTypes class is missing from the schema for this Realm.");
         }
     }
 
     public static List<String> getFieldNames() {
-        return Arrays.asList("columnString", "columnLong", "columnFloat", "columnDouble", "columnBoolean", "columnDate", "columnBinary", "columnObject", "columnRealmList");
+        return FIELD_NAMES;
+    }
+
+    public static Map<String,Long> getColumnIndices() {
+        return columnIndices;
     }
 
-    public static void populateUsingJsonObject(AllTypes obj, JSONObject json)
+    public static AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        boolean standalone = obj.realm == null;
+        AllTypes obj = null;
+        if (update) {
+            Table table = realm.getTable(AllTypes.class);
+            long pkColumnIndex = table.getPrimaryKey();
+            if (!json.isNull("columnString")) {
+                long rowIndex = table.findFirstString(pkColumnIndex, json.getString("columnString"));
+                if (rowIndex != TableOrView.NO_MATCH) {
+                    obj = new AllTypesRealmProxy();
+                    obj.realm = realm;
+                    obj.row = table.getRow(rowIndex);
+                }
+            }
+        }
+        if (obj == null) {
+            obj = realm.createObject(AllTypes.class);
+        }
         if (!json.isNull("columnString")) {
             obj.setColumnString((String) json.getString("columnString"));
         }
@@ -273,26 +346,23 @@ public static void populateUsingJsonObject(AllTypes obj, JSONObject json)
         }
         obj.setColumnBinary(JsonUtils.stringToBytes(json.isNull("columnBinary") ? null : json.getString("columnBinary")));
         if (!json.isNull("columnObject")) {
-            some.test.AllTypes columnObject = standalone ? new some.test.AllTypes() : obj.realm.createObject(some.test.AllTypes.class);
-            AllTypesRealmProxy.populateUsingJsonObject(columnObject, json.getJSONObject("columnObject"));
-            obj.setColumnObject(columnObject);
+            some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json.getJSONObject("columnObject"), update);
+            obj.setColumnObject(columnObjectObj);
         }
         if (!json.isNull("columnRealmList")) {
-            if (standalone) {
-                obj.setColumnRealmList(new RealmList<some.test.AllTypes>());
-            }
+            obj.getColumnRealmList().clear();
             JSONArray array = json.getJSONArray("columnRealmList");
             for (int i = 0; i < array.length(); i++) {
-                some.test.AllTypes item = standalone ? new some.test.AllTypes() : obj.realm.createObject(some.test.AllTypes.class);
-                AllTypesRealmProxy.populateUsingJsonObject(item, array.getJSONObject(i));
+                some.test.AllTypes item = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update);
                 obj.getColumnRealmList().add(item);
             }
         }
+        return obj;
     }
 
-    public static void populateUsingJsonStream(AllTypes obj, JsonReader reader)
+    public static AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        boolean standalone = obj.realm == null;
+        AllTypes obj = realm.createObject(AllTypes.class);
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
@@ -318,17 +388,12 @@ public static void populateUsingJsonStream(AllTypes obj, JsonReader reader)
             } else if (name.equals("columnBinary")  && reader.peek() != JsonToken.NULL) {
                 obj.setColumnBinary(JsonUtils.stringToBytes(reader.nextString()));
             } else if (name.equals("columnObject")  && reader.peek() != JsonToken.NULL) {
-                some.test.AllTypes columnObjectObj = standalone ? new some.test.AllTypes() : obj.realm.createObject(some.test.AllTypes.class);
-                AllTypesRealmProxy.populateUsingJsonStream(columnObjectObj, reader);
+                some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
                 obj.setColumnObject(columnObjectObj);
             } else if (name.equals("columnRealmList")  && reader.peek() != JsonToken.NULL) {
                 reader.beginArray();
-                if (standalone) {
-                    obj.setColumnRealmList(new RealmList<some.test.AllTypes>());
-                }
                 while (reader.hasNext()) {
-                    some.test.AllTypes item = standalone ? new some.test.AllTypes() : obj.realm.createObject(some.test.AllTypes.class);
-                    AllTypesRealmProxy.populateUsingJsonStream(item, reader);
+                    some.test.AllTypes item = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
                     obj.getColumnRealmList().add(item);
                 }
                 reader.endArray();
@@ -337,9 +402,13 @@ public static void populateUsingJsonStream(AllTypes obj, JsonReader reader)
             }
         }
         reader.endObject();
+        return obj;
     }
 
     public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmObject,RealmObject> cache) {
+        if (object.realm != null && object.realm.getId() == realm.getId()) {
+            return object;
+        }
         AllTypes realmObject = null;
         boolean canUpdate = update;
         if (canUpdate) {
@@ -364,7 +433,7 @@ public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update
     }
 
     public static AllTypes copy(Realm realm, AllTypes newObject, boolean update, Map<RealmObject,RealmObject> cache) {
-        AllTypes realmObject = realm.createObject(AllTypes.class);
+        AllTypes realmObject = realm.createObject(AllTypes.class, newObject.getColumnString());
         cache.put(newObject, realmObject);
         realmObject.setColumnString(newObject.getColumnString() != null ? newObject.getColumnString() : "");
         realmObject.setColumnLong(newObject.getColumnLong());
@@ -513,4 +582,4 @@ public boolean equals(Object o) {
         return true;
     }
 
-}
\ No newline at end of file
+}
diff --git a/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index 5b29bd0b48..06c1c40d8c 100644
--- a/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -5,6 +5,7 @@
 import android.util.JsonToken;
 import io.realm.RealmObject;
 import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnType;
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
@@ -12,7 +13,9 @@
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
@@ -24,40 +27,53 @@
 
 public class BooleansRealmProxy extends Booleans {
 
+    private static long INDEX_DONE;
+    private static long INDEX_ISREADY;
+    private static long INDEX_MCOMPLETED;
+    private static Map<String, Long> columnIndices;
+    private static final List<String> FIELD_NAMES;
+    static {
+        List<String> fieldNames = new ArrayList<String>();
+        fieldNames.add("done");
+        fieldNames.add("isReady");
+        fieldNames.add("mCompleted");
+        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
+    }
+
     @Override
     public boolean isDone() {
         realm.checkIfValid();
-        return (boolean) row.getBoolean(Realm.columnIndices.get("Booleans").get("done"));
+        return (boolean) row.getBoolean(INDEX_DONE);
     }
 
     @Override
     public void setDone(boolean value) {
         realm.checkIfValid();
-        row.setBoolean(Realm.columnIndices.get("Booleans").get("done"), (boolean) value);
+        row.setBoolean(INDEX_DONE, (boolean) value);
     }
 
     @Override
     public boolean isReady() {
         realm.checkIfValid();
-        return (boolean) row.getBoolean(Realm.columnIndices.get("Booleans").get("isReady"));
+        return (boolean) row.getBoolean(INDEX_ISREADY);
     }
 
     @Override
     public void setReady(boolean value) {
         realm.checkIfValid();
-        row.setBoolean(Realm.columnIndices.get("Booleans").get("isReady"), (boolean) value);
+        row.setBoolean(INDEX_ISREADY, (boolean) value);
     }
 
     @Override
     public boolean ismCompleted() {
         realm.checkIfValid();
-        return (boolean) row.getBoolean(Realm.columnIndices.get("Booleans").get("mCompleted"));
+        return (boolean) row.getBoolean(INDEX_MCOMPLETED);
     }
 
     @Override
     public void setmCompleted(boolean value) {
         realm.checkIfValid();
-        row.setBoolean(Realm.columnIndices.get("Booleans").get("mCompleted"), (boolean) value);
+        row.setBoolean(INDEX_MCOMPLETED, (boolean) value);
     }
 
     public static Table initTable(ImplicitTransaction transaction) {
@@ -100,16 +116,34 @@ public static void validateTable(ImplicitTransaction transaction) {
             if (columnTypes.get("mCompleted") != ColumnType.BOOLEAN) {
                 throw new IllegalStateException("Invalid type 'boolean' for column 'mCompleted'");
             }
+
+            columnIndices = new HashMap<String, Long>();
+            for (String fieldName : getFieldNames()) {
+                long index = table.getColumnIndex(fieldName);
+                if (index == -1) {
+                    throw new RealmMigrationNeededException("Field '" + fieldName + "' not found for type Booleans");
+                }
+                columnIndices.put(fieldName, index);
+            }
+            INDEX_DONE = table.getColumnIndex("done");
+            INDEX_ISREADY = table.getColumnIndex("isReady");
+            INDEX_MCOMPLETED = table.getColumnIndex("mCompleted");
+        } else {
+            throw new RealmMigrationNeededException("The Booleans class is missing from the schema for this Realm.");
         }
     }
 
     public static List<String> getFieldNames() {
-        return Arrays.asList("done", "isReady", "mCompleted");
+        return FIELD_NAMES;
     }
 
-    public static void populateUsingJsonObject(Booleans obj, JSONObject json)
+    public static Map<String,Long> getColumnIndices() {
+        return columnIndices;
+    }
+
+    public static Booleans createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        boolean standalone = obj.realm == null;
+        Booleans obj = realm.createObject(Booleans.class);
         if (!json.isNull("done")) {
             obj.setDone((boolean) json.getBoolean("done"));
         }
@@ -119,11 +153,12 @@ public static void populateUsingJsonObject(Booleans obj, JSONObject json)
         if (!json.isNull("mCompleted")) {
             obj.setmCompleted((boolean) json.getBoolean("mCompleted"));
         }
+        return obj;
     }
 
-    public static void populateUsingJsonStream(Booleans obj, JsonReader reader)
+    public static Booleans createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        boolean standalone = obj.realm == null;
+        Booleans obj = realm.createObject(Booleans.class);
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
@@ -138,13 +173,17 @@ public static void populateUsingJsonStream(Booleans obj, JsonReader reader)
             }
         }
         reader.endObject();
+        return obj;
     }
 
-    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject, RealmObject> cache) {
+    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject,RealmObject> cache) {
+        if (object.realm != null && object.realm.getId() == realm.getId()) {
+            return object;
+        }
         return copy(realm, object, update, cache);
     }
 
-    public static Booleans copy(Realm realm, Booleans newObject, boolean update, Map<RealmObject, RealmObject> cache) {
+    public static Booleans copy(Realm realm, Booleans newObject, boolean update, Map<RealmObject,RealmObject> cache) {
         Booleans realmObject = realm.createObject(Booleans.class);
         cache.put(newObject, realmObject);
         realmObject.setDone(newObject.isDone());
diff --git a/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 76d5963963..75d428d8b5 100644
--- a/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -5,6 +5,7 @@
 import android.util.JsonToken;
 import io.realm.RealmObject;
 import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnType;
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
@@ -12,7 +13,9 @@
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
@@ -24,28 +27,39 @@
 
 public class SimpleRealmProxy extends Simple {
 
+    private static long INDEX_NAME;
+    private static long INDEX_AGE;
+    private static Map<String, Long> columnIndices;
+    private static final List<String> FIELD_NAMES;
+    static {
+        List<String> fieldNames = new ArrayList<String>();
+        fieldNames.add("name");
+        fieldNames.add("age");
+        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
+    }
+
     @Override
     public String getName() {
         realm.checkIfValid();
-        return (java.lang.String) row.getString(Realm.columnIndices.get("Simple").get("name"));
+        return (java.lang.String) row.getString(INDEX_NAME);
     }
 
     @Override
     public void setName(String value) {
         realm.checkIfValid();
-        row.setString(Realm.columnIndices.get("Simple").get("name"), (String) value);
+        row.setString(INDEX_NAME, (String) value);
     }
 
     @Override
     public int getAge() {
         realm.checkIfValid();
-        return (int) row.getLong(Realm.columnIndices.get("Simple").get("age"));
+        return (int) row.getLong(INDEX_AGE);
     }
 
     @Override
     public void setAge(int value) {
         realm.checkIfValid();
-        row.setLong(Realm.columnIndices.get("Simple").get("age"), (long) value);
+        row.setLong(INDEX_AGE, (long) value);
     }
 
     public static Table initTable(ImplicitTransaction transaction) {
@@ -81,27 +95,45 @@ public static void validateTable(ImplicitTransaction transaction) {
             if (columnTypes.get("age") != ColumnType.INTEGER) {
                 throw new IllegalStateException("Invalid type 'int' for column 'age'");
             }
+
+            columnIndices = new HashMap<String, Long>();
+            for (String fieldName : getFieldNames()) {
+                long index = table.getColumnIndex(fieldName);
+                if (index == -1) {
+                    throw new RealmMigrationNeededException("Field '" + fieldName + "' not found for type Simple");
+                }
+                columnIndices.put(fieldName, index);
+            }
+            INDEX_NAME = table.getColumnIndex("name");
+            INDEX_AGE = table.getColumnIndex("age");
+        } else {
+            throw new RealmMigrationNeededException("The Simple class is missing from the schema for this Realm.");
         }
     }
 
     public static List<String> getFieldNames() {
-        return Arrays.asList("name", "age");
+        return FIELD_NAMES;
     }
 
-    public static void populateUsingJsonObject(Simple obj, JSONObject json)
+    public static Map<String,Long> getColumnIndices() {
+        return columnIndices;
+    }
+
+    public static Simple createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        boolean standalone = obj.realm == null;
+        Simple obj = realm.createObject(Simple.class);
         if (!json.isNull("name")) {
             obj.setName((String) json.getString("name"));
         }
         if (!json.isNull("age")) {
             obj.setAge((int) json.getInt("age"));
         }
+        return obj;
     }
 
-    public static void populateUsingJsonStream(Simple obj, JsonReader reader)
+    public static Simple createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        boolean standalone = obj.realm == null;
+        Simple obj = realm.createObject(Simple.class);
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
@@ -114,13 +146,17 @@ public static void populateUsingJsonStream(Simple obj, JsonReader reader)
             }
         }
         reader.endObject();
+        return obj;
     }
 
-    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject, RealmObject> cache) {
+    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject,RealmObject> cache) {
+        if (object.realm != null && object.realm.getId() == realm.getId()) {
+            return object;
+        }
         return copy(realm, object, update, cache);
     }
 
-    public static Simple copy(Realm realm, Simple newObject, boolean update, Map<RealmObject, RealmObject> cache) {
+    public static Simple copy(Realm realm, Simple newObject, boolean update, Map<RealmObject,RealmObject> cache) {
         Simple realmObject = realm.createObject(Simple.class);
         cache.put(newObject, realmObject);
         realmObject.setName(newObject.getName() != null ? newObject.getName() : "");
diff --git a/realm-jni/build.gradle b/realm-jni/build.gradle
index 005ed4c792..66aaa91caf 100644
--- a/realm-jni/build.gradle
+++ b/realm-jni/build.gradle
@@ -1,4 +1,4 @@
-ext.coreVersion = '0.88.6'
+ext.coreVersion = '0.89.0'
 ext.clang = false // gcc is default for the NDK. It also produces smaller binaries
 
 def commonCflags = [ '-std=c++11', '-ffunction-sections', '-fdata-sections', '-flto' ]
@@ -148,25 +148,25 @@ targets.each { target ->
         environment PATH: "${buildDir}/standalone-toolchains/${target.toolchain.name}/bin:${System.env.PATH}"
         environment CC: "${target.toolchain.commandPrefix}-${clang?'clang':'gcc'}"
         environment STRIP: "${target.toolchain.commandPrefix}-strip"
-        environment TIGHTDB_ANDROID: '1'
+        environment REALM_ANDROID: '1'
         commandLine = [
             'make',
             '-C', "${projectDir}/src",
             "CC_IS=${clang?'clang':'gcc'}",
-            "TIGHTDB_CFLAGS=-Wno-variadic-macros -DTIGHTDB_HAVE_CONFIG -DPIC -I${projectDir}/../core-${project.coreVersion}/include",
+            "REALM_CFLAGS=-Wno-variadic-macros -DREALM_HAVE_CONFIG -DPIC -I${projectDir}/../core-${project.coreVersion}/include",
             "CFLAGS_ARCH=${(commonCflags + target.cflags).join(' ')}",
             "BASE_DENOM=${target.name}",
-            "TIGHTDB_LDFLAGS=-ltightdb-android-${target.name} -lstdc++ -lsupc++ -llog -L${projectDir}/../core-${project.coreVersion} -Wl,--gc-sections -flto",
+            "REALM_LDFLAGS=-lrealm-android-${target.name} -lstdc++ -lsupc++ -llog -L${projectDir}/../core-${project.coreVersion} -Wl,--gc-sections -flto",
             'LIB_SUFFIX_SHARED=.so',
-            "libtightdb-jni-${target.name}.so"
+            "librealm-jni-${target.name}.so"
         ]
     }
 
     task "copyAndroidJni${target.name.capitalize()}"(type: Copy) {
         dependsOn "buildAndroidJni${target.name.capitalize()}"
-        from "${projectDir}/src/libtightdb-jni-${target.name}.so"
+        from "${projectDir}/src/librealm-jni-${target.name}.so"
         into "${projectDir}/../realm/src/main/jniLibs/${target.jniFolder}"
-        rename "libtightdb-jni-${target.name}.so", 'libtightdb-jni.so'
+        rename "librealm-jni-${target.name}.so", 'librealm-jni.so'
     }
 }
 
diff --git a/realm-jni/project.mk b/realm-jni/project.mk
index f85d35e21e..7d6ac268f6 100644
--- a/realm-jni/project.mk
+++ b/realm-jni/project.mk
@@ -1,7 +1,7 @@
 ENABLE_INSTALL_DEBUG_LIBS = 1
 
 # Construct fat binaries on Darwin when using Clang
-ifneq ($(TIGHTDB_ENABLE_FAT_BINARIES),)
+ifneq ($(REALM_ENABLE_FAT_BINARIES),)
   ifeq ($(OS),Darwin)
     ifeq ($(COMPILER_IS),clang)
       CFLAGS_ARCH += -arch i386 -arch x86_64
@@ -13,7 +13,7 @@ ifeq ($(OS),Darwin)
   CFLAGS_ARCH += -mmacosx-version-min=10.8 -stdlib=libc++
 endif
 
-# FIXME: '-fno-elide-constructors' currently causes TightDB to fail
+# FIXME: '-fno-elide-constructors' currently causes Realm to fail
 #CFLAGS_DEBUG += -fno-elide-constructors
 CFLAGS_PTHREADS += -pthread
 CFLAGS_GENERAL += -Wextra -ansi -pedantic -Wno-long-long
@@ -37,11 +37,11 @@ endif
   #jnidir = $(JNI_INSTALL_DIR)
 #endif
 
-ifeq ($(TIGHTDB_ANDROID),)
-  TIGHTDB_LDFLAGS += -llog
+ifeq ($(REALM_ANDROID),)
+  REALM_LDFLAGS += -llog
   CFLAGS_INCLUDE += $(JAVA_CFLAGS)
-  ifneq ($(TIGHTDB_ENABLE_MEM_USAGE),)
-    PROJECT_CFLAGS += -DTIGHTDB_ENABLE_MEM_USAGE
+  ifneq ($(REALM_ENABLE_MEM_USAGE),)
+    PROJECT_CFLAGS += -DREALM_ENABLE_MEM_USAGE
     ifeq ($(shell pkg-config libprocps --exists 2>/dev/null && echo yes),yes)
       PROCPS_CFLAGS  := $(shell pkg-config libprocps --cflags)
       PROCPS_LDFLAGS := $(shell pkg-config libprocps --libs)
@@ -56,9 +56,9 @@ else
   CFLAGS_OPTIM = -Os -DNDEBUG
 endif
 
-PROJECT_CFLAGS_OPTIM  += $(TIGHTDB_CFLAGS)
-PROJECT_CFLAGS_DEBUG  += $(TIGHTDB_CFLAGS_DBG)
-PROJECT_CFLAGS_COVER  += $(TIGHTDB_CFLAGS_DBG)
-PROJECT_LDFLAGS_OPTIM += $(TIGHTDB_LDFLAGS)
-PROJECT_LDFLAGS_DEBUG += $(TIGHTDB_LDFLAGS_DBG)
-PROJECT_LDFLAGS_COVER += $(TIGHTDB_LDFLAGS_DBG)
+PROJECT_CFLAGS_OPTIM  += $(REALM_CFLAGS)
+PROJECT_CFLAGS_DEBUG  += $(REALM_CFLAGS_DBG)
+PROJECT_CFLAGS_COVER  += $(REALM_CFLAGS_DBG)
+PROJECT_LDFLAGS_OPTIM += $(REALM_LDFLAGS)
+PROJECT_LDFLAGS_DEBUG += $(REALM_LDFLAGS_DBG)
+PROJECT_LDFLAGS_COVER += $(REALM_LDFLAGS_DBG)
diff --git a/realm-jni/src/Makefile b/realm-jni/src/Makefile
index a06012a1ee..089e82bf0c 100644
--- a/realm-jni/src/Makefile
+++ b/realm-jni/src/Makefile
@@ -1,10 +1,10 @@
-lib_LIBRARIES = libtightdb-jni.a
+lib_LIBRARIES = librealm-jni.a
 
 JNI_SOURCES := $(wildcard *.cpp)
-libtightdb_jni_a_SOURCES = $(JNI_SOURCES)
+librealm_jni_a_SOURCES = $(JNI_SOURCES)
 
 # Used by ../../build.sh
 get-inst-libraries:
-	@echo $(filter-out libtightdb-jni-cov.%,$(TARGETS_LIB_SHARED_ALIASES))
+	@echo $(filter-out librealm-jni-cov.%,$(TARGETS_LIB_SHARED_ALIASES))
 
 include ../generic.mk
diff --git a/realm-jni/src/TableSpecUtil.cpp b/realm-jni/src/TableSpecUtil.cpp
index a11497f91d..f7f9588717 100644
--- a/realm-jni/src/TableSpecUtil.cpp
+++ b/realm-jni/src/TableSpecUtil.cpp
@@ -19,7 +19,7 @@
 #include "columntypeutil.hpp"
 
 using namespace std;
-using namespace tightdb;
+using namespace realm;
 
 jclass GetClassTableSpec(JNIEnv* env)
 {
diff --git a/realm-jni/src/TableSpecUtil.hpp b/realm-jni/src/TableSpecUtil.hpp
index 389e4bb5cd..d1d4715f45 100644
--- a/realm-jni/src/TableSpecUtil.hpp
+++ b/realm-jni/src/TableSpecUtil.hpp
@@ -20,7 +20,7 @@
 #include <cstddef>
 #include <vector>
 #include <jni.h>
-#include <tightdb/table.hpp>
+#include <realm/table.hpp>
 
 jlong Java_io_realm_TableSpec_getColumnCount(JNIEnv*, jobject jTableSpec);
 
@@ -32,8 +32,8 @@ jobject Java_io_realm_TableSpec_getTableSpec(JNIEnv*, jobject jTableSpec, jlong
 
 jlong Java_io_realm_TableSpec_getColumnIndex(JNIEnv*, jobject jTableSpec, jstring columnName);
 
-void set_descriptor(JNIEnv*,       tightdb::Descriptor&, jobject jTableSpec);
-void get_descriptor(JNIEnv*, const tightdb::Descriptor&, jobject jTableSpec);
+void set_descriptor(JNIEnv*,       realm::Descriptor&, jobject jTableSpec);
+void get_descriptor(JNIEnv*, const realm::Descriptor&, jobject jTableSpec);
 
 jclass GetClassTableSpec(JNIEnv*);
 jmethodID GetTableSpecMethodID(JNIEnv*, const char* methodStr, const char* typeStr);
diff --git a/realm-jni/src/columntypeutil.hpp b/realm-jni/src/columntypeutil.hpp
index 0a7f987bbf..07f3e5d324 100644
--- a/realm-jni/src/columntypeutil.hpp
+++ b/realm-jni/src/columntypeutil.hpp
@@ -18,11 +18,11 @@
 #define REALM_COLUMN_TYPE_UTIL_H
 
 #include <jni.h>
-#include <tightdb.hpp>
+#include <realm.hpp>
 
 #ifdef __cplusplus
 
-using tightdb::DataType;
+using realm::DataType;
 
 extern "C" {
 
diff --git a/realm-jni/src/io_realm_internal_Group.cpp b/realm-jni/src/io_realm_internal_Group.cpp
index f39edfaf82..9b85e9faf6 100644
--- a/realm-jni/src/io_realm_internal_Group.cpp
+++ b/realm-jni/src/io_realm_internal_Group.cpp
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 
-#include <tightdb/util/safe_int_ops.hpp>
+#include <realm/util/safe_int_ops.hpp>
 
 #include "util.hpp"
 #include "io_realm_internal_Group.h"
 
-using namespace tightdb;
+using namespace realm;
 using std::string;
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__(
@@ -53,7 +53,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__Ljava_lang_St
         }
 
         KeyBuffer key(env, keyArray);
-#ifdef TIGHTDB_ENABLE_ENCRYPTION
+#ifdef REALM_ENABLE_ENCRYPTION
         pGroup = new Group(file_name, key.data(), openmode);
 #else
         pGroup = new Group(file_name, NULL, openmode);
@@ -179,7 +179,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeWriteToFile(
     try {
         JStringAccessor file_name_tmp(env, jFileName); // throws
         file_name = StringData(file_name_tmp);
-#ifdef TIGHTDB_ENABLE_ENCRYPTION
+#ifdef REALM_ENABLE_ENCRYPTION
         G(nativeGroupPtr)->write(file_name, key.data());
 #else
         G(nativeGroupPtr)->write(file_name);
diff --git a/realm-jni/src/io_realm_internal_LinkView.cpp b/realm-jni/src/io_realm_internal_LinkView.cpp
index 73edc051ba..9fd98b44b9 100644
--- a/realm-jni/src/io_realm_internal_LinkView.cpp
+++ b/realm-jni/src/io_realm_internal_LinkView.cpp
@@ -18,7 +18,7 @@
 #include "tablequery.hpp"
 #include "util.hpp"
 
-using namespace tightdb;
+using namespace realm;
 
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClose
   (JNIEnv*, jclass, jlong nativeLinkViewPtr)
diff --git a/realm-jni/src/io_realm_internal_Row.cpp b/realm-jni/src/io_realm_internal_Row.cpp
index 8dfda7f190..44140a7886 100644
--- a/realm-jni/src/io_realm_internal_Row.cpp
+++ b/realm-jni/src/io_realm_internal_Row.cpp
@@ -19,7 +19,7 @@
 #include "mixedutil.hpp"
 #include "tablebase_tpl.hpp"
 
-using namespace tightdb;
+using namespace realm;
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetColumnCount
   (JNIEnv *, jobject, jlong nativeRowPtr)
diff --git a/realm-jni/src/io_realm_internal_SharedGroup.cpp b/realm-jni/src/io_realm_internal_SharedGroup.cpp
index 7f7eb4f5b7..97734cb3f5 100644
--- a/realm-jni/src/io_realm_internal_SharedGroup.cpp
+++ b/realm-jni/src/io_realm_internal_SharedGroup.cpp
@@ -18,15 +18,15 @@
 
 #include "util.hpp"
 
-#include <tightdb/group_shared.hpp>
-#include <tightdb/replication.hpp>
-#include <tightdb/commit_log.hpp>
+#include <realm/group_shared.hpp>
+#include <realm/replication.hpp>
+#include <realm/commit_log.hpp>
 
 #include "util.hpp"
 #include "io_realm_internal_SharedGroup.h"
 
 using namespace std;
-using namespace tightdb;
+using namespace realm;
 
 #define SG(ptr) reinterpret_cast<SharedGroup*>(ptr)
 
@@ -42,7 +42,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreate(
         file_name = StringData(file_name_tmp);
 
         if (enable_replication) {
-#ifdef TIGHTDB_ENABLE_REPLICATION
+#ifdef REALM_ENABLE_REPLICATION
             ThrowException(env, UnsupportedOperation,
                            "Replication is not currently supported by the Java language binding.");
 //            db = new SharedGroup(SharedGroup::replication_tag(), *file_name_ptr ? file_name_ptr : 0);
@@ -69,7 +69,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreate(
             }
 
             KeyBuffer key(env, keyArray);
-#ifdef TIGHTDB_ENABLE_ENCRYPTION
+#ifdef REALM_ENABLE_ENCRYPTION
             db = new SharedGroup(file_name, no_create!=0, level, key.data());
 #else
             db = new SharedGroup(file_name, no_create!=0, level);
@@ -88,10 +88,10 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_createNativeWithImpli
     TR_ENTER()
     try {
         KeyBuffer key(env, keyArray);
-#ifdef TIGHTDB_ENABLE_ENCRYPTION
-        SharedGroup* db = new SharedGroup(*reinterpret_cast<tightdb::Replication*>(native_replication_ptr), SharedGroup::durability_Full, key.data());
+#ifdef REALM_ENABLE_ENCRYPTION
+        SharedGroup* db = new SharedGroup(*reinterpret_cast<realm::Replication*>(native_replication_ptr), SharedGroup::durability_Full, key.data());
 #else
-        SharedGroup* db = new SharedGroup(*reinterpret_cast<tightdb::Replication*>(native_replication_ptr));
+        SharedGroup* db = new SharedGroup(*reinterpret_cast<realm::Replication*>(native_replication_ptr));
 #endif
 
         return reinterpret_cast<jlong>(db);
@@ -110,12 +110,12 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreateReplicati
         JStringAccessor file_name_tmp(env, jfile_name); // throws
         file_name = StringData(file_name_tmp);
         KeyBuffer key(env, keyArray);
-#ifdef TIGHTDB_ENABLE_ENCRYPTION
-        Replication* repl = makeWriteLogCollector(file_name, false, key.data());
+#ifdef REALM_ENABLE_ENCRYPTION
+        std::unique_ptr<Replication> repl = makeWriteLogCollector(file_name, false, key.data());
 #else
-        Replication* repl = makeWriteLogCollector(file_name);
+        std::unique_ptr<Replication> repl = makeWriteLogCollector(file_name);
 #endif
-        return reinterpret_cast<jlong>(repl);
+        return reinterpret_cast<jlong>(repl.release());
     }
     CATCH_FILE(file_name)
     CATCH_STD()
@@ -257,7 +257,7 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_SharedGroup_nativeGetDefaultRep
     JNIEnv* env, jclass)
 {
     TR_ENTER()
-#ifdef TIGHTDB_ENABLE_REPLICATION
+#ifdef REALM_ENABLE_REPLICATION
     ThrowException(env, UnsupportedOperation,
                    "Replication is not currently supported by the Java language binding.");
     return 0;
@@ -268,3 +268,15 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_SharedGroup_nativeGetDefaultRep
     return 0;
 #endif
 }
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeCompact(
+    JNIEnv* env, jobject, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        return SG(native_ptr)->compact(); // throws
+    }
+    CATCH_FILE()
+    CATCH_STD()
+    return false;
+}
diff --git a/realm-jni/src/io_realm_internal_SharedGroup.h b/realm-jni/src/io_realm_internal_SharedGroup.h
index 8c4ebcd3b6..2f6cfda0be 100644
--- a/realm-jni/src/io_realm_internal_SharedGroup.h
+++ b/realm-jni/src/io_realm_internal_SharedGroup.h
@@ -151,6 +151,14 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeClose
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCloseReplication
   (JNIEnv *, jobject, jlong);
 
+/*
+ * Class:     io_realm_internal_SharedGroup
+ * Method:    nativeCompact
+ * Signature: (J)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeCompact
+  (JNIEnv *, jobject, jlong);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/realm-jni/src/io_realm_internal_SubtableSchema.cpp b/realm-jni/src/io_realm_internal_SubtableSchema.cpp
index 2edfd12b00..4bfdcb8073 100644
--- a/realm-jni/src/io_realm_internal_SubtableSchema.cpp
+++ b/realm-jni/src/io_realm_internal_SubtableSchema.cpp
@@ -17,7 +17,7 @@
 #include "util.hpp"
 #include "io_realm_internal_SubtableSchema.h"
 
-using namespace tightdb;
+using namespace realm;
 using namespace std;
 
 void arrayToVector(JNIEnv* env, jlongArray path, vector<size_t>& nativePath)
diff --git a/realm-jni/src/io_realm_internal_TableQuery.cpp b/realm-jni/src/io_realm_internal_TableQuery.cpp
index 7db158ed64..bb26d54e11 100644
--- a/realm-jni/src/io_realm_internal_TableQuery.cpp
+++ b/realm-jni/src/io_realm_internal_TableQuery.cpp
@@ -18,14 +18,16 @@
 #include "io_realm_internal_TableQuery.h"
 #include "tablequery.hpp"
 
-using namespace tightdb;
+using namespace realm;
 
 #if 1
 #define COL_TYPE_VALID(env,ptr,col, type)           TBL_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)
+#define COL_TYPE_LINK_OR_LINKLIST(env,ptr,col)      TBL_AND_COL_INDEX_AND_LINK_OR_LINKLIST(env,ptr,col)
 #define QUERY_COL_TYPE_VALID(env, jPtr, col, type)  query_col_type_valid(env, jPtr, col, type)
 #define QUERY_VALID(env, pQuery)                    query_valid(env, pQuery)
 #else
 #define COL_TYPE_VALID(env,ptr,col, type)           (true)
+#define COL_TYPE_LINK_OR_LINKLIST(env,ptr,col)      (true)
 #define QUERY_COL_TYPE_VALID(env, jPtr, col, type)  (true)
 #define QUERY_VALID(env, pQuery)                    (true)
 #endif
@@ -1157,3 +1159,18 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeRemove(
     } CATCH_STD()
     return 0;
 }
+
+// isNull and isNotNull
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(
+    JNIEnv *env, jobject, jlong nativeQueryPtr, jlong columnIndex)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    try {
+        Table* pTable = pQuery->get_table().get();
+        if (!COL_TYPE_LINK_OR_LINKLIST(env, pTable, columnIndex))
+            return;
+        Query query = pTable->column<Link>(S(columnIndex)).is_null();
+        pQuery->and_query(query);
+    } CATCH_STD()
+}
diff --git a/realm-jni/src/io_realm_internal_TableQuery.h b/realm-jni/src/io_realm_internal_TableQuery.h
index 2c3e708b7e..5ccb9eeb7e 100644
--- a/realm-jni/src/io_realm_internal_TableQuery.h
+++ b/realm-jni/src/io_realm_internal_TableQuery.h
@@ -479,6 +479,14 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDate
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDate
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
 
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeIsNull
+ * Signature: (JJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull
+  (JNIEnv *, jobject, jlong, jlong);
+
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeCount
diff --git a/realm-jni/src/io_realm_internal_Version.cpp b/realm-jni/src/io_realm_internal_Version.cpp
index 5f4662d385..bcbdf120b0 100644
--- a/realm-jni/src/io_realm_internal_Version.cpp
+++ b/realm-jni/src/io_realm_internal_Version.cpp
@@ -19,16 +19,16 @@
 
 #include "util.hpp"
 #include "io_realm_internal_Version.h"
-#include <tightdb/version.hpp>
+#include <realm/version.hpp>
 
-static int tightdb_jni_version = 23;
+static int realm_jni_version = 23;
 
 
-using namespace tightdb;
+using namespace realm;
 
 JNIEXPORT jint JNICALL Java_io_realm_internal_Version_nativeGetAPIVersion(JNIEnv*, jclass)
 {
-    return tightdb_jni_version;
+    return realm_jni_version;
 }
 
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Version_nativeGetVersion(JNIEnv *env, jclass)
diff --git a/realm-jni/src/io_realm_internal_table.cpp b/realm-jni/src/io_realm_internal_table.cpp
index 7e2bad13b0..ee3b28bfdb 100644
--- a/realm-jni/src/io_realm_internal_table.cpp
+++ b/realm-jni/src/io_realm_internal_table.cpp
@@ -27,7 +27,7 @@
 #include "tablequery.hpp"
 
 using namespace std;
-using namespace tightdb;
+using namespace realm;
 
 // Note: Don't modify spec on a table which has a shared_spec.
 // A spec is shared on subtables that are not in Mixed columns.
@@ -254,7 +254,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddEmptyRow(
     if (!TABLE_VALID(env, pTable))
         return 0;
     if (pTable->get_column_count() < 1){
-        ThrowException(env, IndexOutOfBounds, "Table has no columns");
+        ThrowException(env, IndexOutOfBounds, concat_stringdata("Table has no columns: ", pTable->get_name()));
         return 0;
     }
     try {
@@ -1451,7 +1451,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
         // I
         if (columnName == NULL || env->GetStringLength(columnName) == 0) {
             // No primary key set. Remove any previous set keys
-            if (row_index != tightdb::not_found) {
+            if (row_index != realm::not_found) {
                 pk_table->remove(row_index);
             }
             return jlong(io_realm_internal_Table_NO_PRIMARY_KEY);
@@ -1459,7 +1459,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
         else {
             JStringAccessor columnName2(env, columnName);
             size_t primary_key_column_index = table->get_column_index(columnName2);
-            if (row_index == tightdb::not_found) {
+            if (row_index == realm::not_found) {
                 // No primary key is currently set
                 if (check_valid_primary_key_column(env, table, primary_key_column_index)) {
                     row_index = pk_table->add_empty_row();
diff --git a/realm-jni/src/io_realm_internal_tableview.cpp b/realm-jni/src/io_realm_internal_tableview.cpp
index c8d9c52c0e..f138569147 100644
--- a/realm-jni/src/io_realm_internal_tableview.cpp
+++ b/realm-jni/src/io_realm_internal_tableview.cpp
@@ -21,7 +21,7 @@
 #include "tablequery.hpp"
 #include <ostream>
 
-using namespace tightdb;
+using namespace realm;
 
 // if you disable the validation, please remember to call sync_in_needed() 
 #define VIEW_VALID_AND_IN_SYNC(env, ptr) view_valid_and_in_sync(env, ptr)
diff --git a/realm-jni/src/mem_usage.cpp b/realm-jni/src/mem_usage.cpp
index b8455c6db6..d4e337d528 100644
--- a/realm-jni/src/mem_usage.cpp
+++ b/realm-jni/src/mem_usage.cpp
@@ -16,7 +16,7 @@
 
 #include "mem_usage.hpp"
 
-#ifndef TIGHTDB_ENABLE_MEM_USAGE
+#ifndef REALM_ENABLE_MEM_USAGE
 
 size_t GetMemUsage()
 {
diff --git a/realm-jni/src/mem_usage.hpp b/realm-jni/src/mem_usage.hpp
index 85b0a634d1..e3935c6360 100644
--- a/realm-jni/src/mem_usage.hpp
+++ b/realm-jni/src/mem_usage.hpp
@@ -19,7 +19,7 @@
 
 #include <cstdlib> // size_t
 
-/// This function requires that TIGHTDB_ENABLE_MEM_USAGE is specified
+/// This function requires that REALM_ENABLE_MEM_USAGE is specified
 /// during building. Otherwise it always returns zero.
 size_t GetMemUsage();
 
diff --git a/realm-jni/src/mixedutil.cpp b/realm-jni/src/mixedutil.cpp
index 51dbcba8d5..98f3852d4c 100644
--- a/realm-jni/src/mixedutil.cpp
+++ b/realm-jni/src/mixedutil.cpp
@@ -18,7 +18,7 @@
 #include "mixedutil.hpp"
 #include "columntypeutil.hpp"
 
-using namespace tightdb;
+using namespace realm;
 
 jclass GetClassMixed(JNIEnv* env)
 {
diff --git a/realm-jni/src/mixedutil.hpp b/realm-jni/src/mixedutil.hpp
index 3ef6a1d575..e7010072b0 100644
--- a/realm-jni/src/mixedutil.hpp
+++ b/realm-jni/src/mixedutil.hpp
@@ -18,9 +18,9 @@
 #define MIXED_UTIL_H
 
 #include <jni.h>
-#include <tightdb.hpp>
+#include <realm.hpp>
 
-using namespace tightdb;
+using namespace realm;
 
 DataType GetMixedObjectType(JNIEnv* env, jobject jMixed);
 jobject CreateJMixedFromMixed(JNIEnv* env, Mixed& mixed);
diff --git a/realm-jni/src/tablequery.hpp b/realm-jni/src/tablequery.hpp
index 8f9d826b44..0c79b7d3d1 100644
--- a/realm-jni/src/tablequery.hpp
+++ b/realm-jni/src/tablequery.hpp
@@ -19,16 +19,16 @@
 
 #include <vector>
 #include <assert.h>
-#include <tightdb.hpp>
+#include <realm.hpp>
 
-class TableQuery : public tightdb::Query {
+class TableQuery : public realm::Query {
     // 'subtables' is used to figure out which subtable the query
     // is currectly working on, so that we can lookup the correct
     // table and verify the parameters related to that table.
     std::vector<size_t> subtables;  // holds subtable column indeces 
 
 public:
-    TableQuery(const Query& copy) : tightdb::Query(copy, tightdb::Query::TCopyExpressionTag{}) {};
+    TableQuery(const Query& copy) : realm::Query(copy, realm::Query::TCopyExpressionTag{}) {};
  
     void push_subtable(size_t index) {
         subtables.push_back(index);
@@ -41,8 +41,8 @@ class TableQuery : public tightdb::Query {
         return true;
     }
     
-    tightdb::TableRef get_current_table() {
-        tightdb::TableRef table = get_table();
+    realm::TableRef get_current_table() {
+        realm::TableRef table = get_table();
 
         // Go through the stack of subtables to find current subtable (if any)
         size_t size = subtables.size(); 
diff --git a/realm-jni/src/utf8.hpp b/realm-jni/src/utf8.hpp
index 3514df25fb..5811cd93b0 100644
--- a/realm-jni/src/utf8.hpp
+++ b/realm-jni/src/utf8.hpp
@@ -1,34 +1,34 @@
 /*************************************************************************
  *
- * TIGHTDB CONFIDENTIAL
+ * REALM CONFIDENTIAL
  * __________________
  *
- *  [2011] - [2012] TightDB Inc
+ *  [2011] - [2012] Realm Inc
  *  All Rights Reserved.
  *
  * NOTICE:  All information contained herein is, and remains
- * the property of TightDB Incorporated and its suppliers,
+ * the property of Realm Incorporated and its suppliers,
  * if any.  The intellectual and technical concepts contained
- * herein are proprietary to TightDB Incorporated
+ * herein are proprietary to Realm Incorporated
  * and its suppliers and may be covered by U.S. and Foreign Patents,
  * patents in process, and are protected by trade secret or copyright law.
  * Dissemination of this information or reproduction of this material
  * is strictly forbidden unless prior written permission is obtained
- * from TightDB Incorporated.
+ * from Realm Incorporated.
  *
  **************************************************************************/
-#ifndef TIGHTDB_UTIL_UTF8_HPP
-#define TIGHTDB_UTIL_UTF8_HPP
+#ifndef REALM_UTIL_UTF8_HPP
+#define REALM_UTIL_UTF8_HPP
 
 #include <stdint.h>
 #include <string>
 
-#include <tightdb/util/safe_int_ops.hpp>
-#include <tightdb/string_data.hpp>
-#include <tightdb/util/features.h>
-#include <tightdb/utilities.hpp>
+#include <realm/util/safe_int_ops.hpp>
+#include <realm/string_data.hpp>
+#include <realm/util/features.h>
+#include <realm/utilities.hpp>
 
-namespace tightdb {
+namespace realm {
 namespace util {
 
 
@@ -97,34 +97,34 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf16(const char*& in_begin, const c
     const char* in = in_begin;
     Char16* out = out_begin;
     while (in != in_end) {
-        if (TIGHTDB_UNLIKELY(out == out_end)) {
+        if (REALM_UNLIKELY(out == out_end)) {
             break; // Need space in output buffer
         }
         uint_fast16_t v1 = uint_fast16_t(traits8::to_int_type(in[0]));
-        if (TIGHTDB_LIKELY(v1 < 0x80)) { // One byte
+        if (REALM_LIKELY(v1 < 0x80)) { // One byte
             // UTF-8 layout: 0xxxxxxx
             *out++ = Traits16::to_char_type(v1);
             in += 1;
             continue;
         }
-        if (TIGHTDB_UNLIKELY(v1 < 0xC0)) {
+        if (REALM_UNLIKELY(v1 < 0xC0)) {
             invalid = true;
             break; // Invalid first byte of UTF-8 sequence
         }
-        if (TIGHTDB_LIKELY(v1 < 0xE0)) { // Two bytes
-            if (TIGHTDB_UNLIKELY(in_end - in < 2)) {
+        if (REALM_LIKELY(v1 < 0xE0)) { // Two bytes
+            if (REALM_UNLIKELY(in_end - in < 2)) {
                 invalid = 1;
                 break; // Incomplete UTF-8 sequence
             }
             uint_fast16_t v2 = uint_fast16_t(traits8::to_int_type(in[1]));
             // UTF-8 layout: 110xxxxx 10xxxxxx
-            if (TIGHTDB_UNLIKELY((v2 & 0xC0) != 0x80)) {
+            if (REALM_UNLIKELY((v2 & 0xC0) != 0x80)) {
                 invalid = 2;
                 break; // Invalid continuation byte
             }
             uint_fast16_t v = uint_fast16_t(((v1 & 0x1F) << 6) |
                                             ((v2 & 0x3F) << 0));
-            if (TIGHTDB_UNLIKELY(v < 0x80)) {
+            if (REALM_UNLIKELY(v < 0x80)) {
                 invalid = 3;
                 break; // Overlong encoding is invalid
             }
@@ -132,26 +132,26 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf16(const char*& in_begin, const c
             in += 2;
             continue;
         }
-        if (TIGHTDB_LIKELY(v1 < 0xF0)) { // Three bytes
-            if (TIGHTDB_UNLIKELY(in_end - in < 3)) {
+        if (REALM_LIKELY(v1 < 0xF0)) { // Three bytes
+            if (REALM_UNLIKELY(in_end - in < 3)) {
                 invalid = 4;
                 break; // Incomplete UTF-8 sequence
             }
             uint_fast16_t v2 = uint_fast16_t(traits8::to_int_type(in[1]));
             uint_fast16_t v3 = uint_fast16_t(traits8::to_int_type(in[2]));
             // UTF-8 layout: 1110xxxx 10xxxxxx 10xxxxxx
-            if (TIGHTDB_UNLIKELY((v2 & 0xC0) != 0x80 || (v3 & 0xC0) != 0x80)) {
+            if (REALM_UNLIKELY((v2 & 0xC0) != 0x80 || (v3 & 0xC0) != 0x80)) {
                 invalid = true;
                 break; // Invalid continuation byte
             }
             uint_fast16_t v = uint_fast16_t(((v1 & 0x0F) << 12) |
                                             ((v2 & 0x3F) <<  6) |
                                             ((v3 & 0x3F) <<  0));
-            if (TIGHTDB_UNLIKELY(v < 0x800)) {
+            if (REALM_UNLIKELY(v < 0x800)) {
                 invalid = 5;
                 break; // Overlong encoding is invalid
             }
-            if (TIGHTDB_UNLIKELY(0xD800 <= v && v < 0xE000)) {
+            if (REALM_UNLIKELY(0xD800 <= v && v < 0xE000)) {
                 invalid = 6;
                 break; // Illegal code point range (reserved for UTF-16 surrogate pairs)
             }
@@ -159,11 +159,11 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf16(const char*& in_begin, const c
             in += 3;
             continue;
         }
-        if (TIGHTDB_UNLIKELY(out + 1 == out_end)) {
+        if (REALM_UNLIKELY(out + 1 == out_end)) {
             break; // Need space in output buffer for surrogate pair
         }
-        if (TIGHTDB_LIKELY(v1 < 0xF8)) { // Four bytes
-            if (TIGHTDB_UNLIKELY(in_end - in < 4)) {
+        if (REALM_LIKELY(v1 < 0xF8)) { // Four bytes
+            if (REALM_UNLIKELY(in_end - in < 4)) {
                 invalid = 7;
                 break; // Incomplete UTF-8 sequence
             }
@@ -172,7 +172,7 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf16(const char*& in_begin, const c
             uint_fast16_t v3 = uint_fast16_t(traits8::to_int_type(in[2])); // 16 bit intended
             uint_fast16_t v4 = uint_fast16_t(traits8::to_int_type(in[3])); // 16 bit intended
             // UTF-8 layout: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
-            if (TIGHTDB_UNLIKELY((v2 & 0xC0) != 0x80 || (v3 & 0xC0) != 0x80 ||
+            if (REALM_UNLIKELY((v2 & 0xC0) != 0x80 || (v3 & 0xC0) != 0x80 ||
                                  (v4 & 0xC0) != 0x80)) {
                 invalid = 8;
                 break; // Invalid continuation byte
@@ -182,11 +182,11 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf16(const char*& in_begin, const c
                               ((v2 & 0x3F) << 12) | // Parenthesis is 32 bit partial result
                               ((v3 & 0x3F) <<  6) | // Parenthesis is 16 bit partial result
                               ((v4 & 0x3F) <<  0)); // Parenthesis is 16 bit partial result
-            if (TIGHTDB_UNLIKELY(v < 0x10000)) {
+            if (REALM_UNLIKELY(v < 0x10000)) {
                 invalid = 9;
                 break; // Overlong encoding is invalid
             }
-            if (TIGHTDB_UNLIKELY(0x110000 <= v)) {
+            if (REALM_UNLIKELY(0x110000 <= v)) {
                 invalid = 19;
                 break; // Code point too big for UTF-16
             }
@@ -219,17 +219,17 @@ inline std::size_t Utf8x16<Char16, Traits16>::find_utf16_buf_size(const char*& i
     const char* in = in_begin;
     while (in != in_end) {
         uint_fast16_t v1 = uint_fast16_t(traits8::to_int_type(in[0]));
-        if (TIGHTDB_LIKELY(v1 < 0x80)) { // One byte
+        if (REALM_LIKELY(v1 < 0x80)) { // One byte
             num_out += 1;
             in += 1;
             continue;
         }
-        if (TIGHTDB_UNLIKELY(v1 < 0xC0)) {
+        if (REALM_UNLIKELY(v1 < 0xC0)) {
             error_code = 1;
             break; // Invalid first byte of UTF-8 sequence
         }
-        if (TIGHTDB_LIKELY(v1 < 0xE0)) { // Two bytes
-            if (TIGHTDB_UNLIKELY(in_end - in < 2)) {
+        if (REALM_LIKELY(v1 < 0xE0)) { // Two bytes
+            if (REALM_UNLIKELY(in_end - in < 2)) {
                 error_code = 2;
                 break; // Incomplete UTF-8 sequence
             }
@@ -237,8 +237,8 @@ inline std::size_t Utf8x16<Char16, Traits16>::find_utf16_buf_size(const char*& i
             in += 2;
             continue;
         }
-        if (TIGHTDB_LIKELY(v1 < 0xF0)) { // Three bytes
-            if (TIGHTDB_UNLIKELY(in_end - in < 3)) {
+        if (REALM_LIKELY(v1 < 0xF0)) { // Three bytes
+            if (REALM_UNLIKELY(in_end - in < 3)) {
                 error_code = 3;
                 break; // Incomplete UTF-8 sequence
             }
@@ -246,8 +246,8 @@ inline std::size_t Utf8x16<Char16, Traits16>::find_utf16_buf_size(const char*& i
             in += 3;
             continue;
         }
-        if (TIGHTDB_LIKELY(v1 < 0xF8)) { // Four bytes
-            if (TIGHTDB_UNLIKELY(in_end - in < 4)) {
+        if (REALM_LIKELY(v1 < 0xF8)) { // Four bytes
+            if (REALM_UNLIKELY(in_end - in < 4)) {
                 error_code = 4;
                 break; // Incomplete UTF-8 sequence
             }
@@ -282,8 +282,8 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf8(const Char16*& in_begin, const
     char* out = out_begin;
     while (in != in_end) {
         uint_fast16_t v1 = uint_fast16_t(Traits16::to_int_type(in[0]));
-        if (TIGHTDB_LIKELY(v1 < 0x80)) {
-            if (TIGHTDB_UNLIKELY(out == out_end)) {
+        if (REALM_LIKELY(v1 < 0x80)) {
+            if (REALM_UNLIKELY(out == out_end)) {
                 error_code = 1;
                 break; // Not enough output buffer space
             }
@@ -292,8 +292,8 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf8(const Char16*& in_begin, const
             in += 1;
             continue;
         }
-        if (TIGHTDB_LIKELY(v1 < 0x800)) {
-            if (TIGHTDB_UNLIKELY(out_end - out < 2)) {
+        if (REALM_LIKELY(v1 < 0x800)) {
+            if (REALM_UNLIKELY(out_end - out < 2)) {
                 error_code = 2;
                 break; // Not enough output buffer space
             }
@@ -303,8 +303,8 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf8(const Char16*& in_begin, const
             in += 1;
             continue;
         }
-        if (TIGHTDB_LIKELY(v1 < 0xD800 || 0xE000 <= v1)) {
-            if (TIGHTDB_UNLIKELY(out_end - out < 3)) {
+        if (REALM_LIKELY(v1 < 0xD800 || 0xE000 <= v1)) {
+            if (REALM_UNLIKELY(out_end - out < 3)) {
                 error_code = 3;
                 break; // Not enough output buffer space
             }
@@ -317,22 +317,22 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf8(const Char16*& in_begin, const
         }
 
         // Surrogate pair
-        if (TIGHTDB_UNLIKELY(out_end - out < 4)) {
+        if (REALM_UNLIKELY(out_end - out < 4)) {
             error_code = 4;
             break; // Not enough output buffer space
         }
-        if (TIGHTDB_UNLIKELY(0xDC00 <= v1)) {
+        if (REALM_UNLIKELY(0xDC00 <= v1)) {
             error_code = 5;
             invalid = true;
             break; // Invalid first half of surrogate pair
         }
-        if (TIGHTDB_UNLIKELY(in + 1 == in_end)) {
+        if (REALM_UNLIKELY(in + 1 == in_end)) {
             error_code = 6;
             invalid = true;
             break; // Incomplete surrogate pair
         }
         uint_fast16_t v2 = uint_fast16_t(Traits16::to_int_type(in[1]));
-        if (TIGHTDB_UNLIKELY(v2 < 0xDC00 || 0xE000 <= v2)) {
+        if (REALM_UNLIKELY(v2 < 0xDC00 || 0xE000 <= v2)) {
             error_code = 7;
             invalid = true;
             break; // Invalid second half of surrogate pair
@@ -363,33 +363,33 @@ inline std::size_t Utf8x16<Char16, Traits16>::find_utf8_buf_size(const Char16*&
     const Char16* in = in_begin;
     while (in != in_end) {
         uint_fast16_t v = uint_fast16_t(Traits16::to_int_type(in[0]));
-        if (TIGHTDB_LIKELY(v < 0x80)) {
-            if (TIGHTDB_UNLIKELY(int_add_with_overflow_detect(num_out, 1))) {
+        if (REALM_LIKELY(v < 0x80)) {
+            if (REALM_UNLIKELY(int_add_with_overflow_detect(num_out, 1))) {
                 error_code = 1;
                 break; // Avoid overflow
             }
             in += 1;
         }
-        else if (TIGHTDB_LIKELY(v < 0x800)) {
-            if (TIGHTDB_UNLIKELY(int_add_with_overflow_detect(num_out, 2))) {
+        else if (REALM_LIKELY(v < 0x800)) {
+            if (REALM_UNLIKELY(int_add_with_overflow_detect(num_out, 2))) {
                 error_code = 2;
                 break; // Avoid overflow
             }
             in += 1;
         }
-        else if (TIGHTDB_LIKELY(v < 0xD800 || 0xE000 <= v)) {
-            if (TIGHTDB_UNLIKELY(int_add_with_overflow_detect(num_out, 3))) {
+        else if (REALM_LIKELY(v < 0xD800 || 0xE000 <= v)) {
+            if (REALM_UNLIKELY(int_add_with_overflow_detect(num_out, 3))) {
                 error_code = 3;
                 break; // Avoid overflow
             }
             in += 1;
         }
         else {
-            if (TIGHTDB_UNLIKELY(in + 1 == in_end)) {
+            if (REALM_UNLIKELY(in + 1 == in_end)) {
                 error_code = 4;
                 break; // Incomplete surrogate pair
             }
-            if (TIGHTDB_UNLIKELY(int_add_with_overflow_detect(num_out, 4))) {
+            if (REALM_UNLIKELY(int_add_with_overflow_detect(num_out, 4))) {
                 error_code = 5;
                 break; // Avoid overflow
             }
@@ -401,6 +401,6 @@ inline std::size_t Utf8x16<Char16, Traits16>::find_utf8_buf_size(const Char16*&
     return num_out;
 }
 } // namespace util
-} // namespace tightdb
+} // namespace realm
 
-#endif // TIGHTDB_UTIL_UTF8_HPP
+#endif // REALM_UTIL_UTF8_HPP
diff --git a/realm-jni/src/util.cpp b/realm-jni/src/util.cpp
index d92962f3c6..aa3a2fc04d 100644
--- a/realm-jni/src/util.cpp
+++ b/realm-jni/src/util.cpp
@@ -17,15 +17,15 @@
 #include <algorithm>
 #include <stdexcept>
 
-#include <tightdb/util/assert.hpp>
+#include <realm/util/assert.hpp>
 #include "utf8.hpp"
 
 #include "util.hpp"
 #include "io_realm_internal_Util.h"
 
 using namespace std;
-using namespace tightdb;
-using namespace tightdb::util;
+using namespace realm;
+using namespace realm::util;
 
 void ConvertException(JNIEnv* env, const char *file, int line)
 {
@@ -42,7 +42,7 @@ void ConvertException(JNIEnv* env, const char *file, int line)
         ThrowException(env, Unspecified, ss.str());
     }
     catch (...) { \
-        TIGHTDB_ASSERT(false);
+        REALM_ASSERT(false);
         ss << "Exception in " << file << " line " << line;
         ThrowException(env, RuntimeError, ss.str());
     }
@@ -182,7 +182,7 @@ void jprintf(JNIEnv *env, const char *format, ...)
     va_end(argptr);
 }
 
-bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, tightdb::BinaryData& bin)
+bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, realm::BinaryData& bin)
 {
     const char* data = static_cast<char*>(env->GetDirectBufferAddress(jByteBuffer));
     if (!data) {
@@ -209,8 +209,8 @@ namespace {
 // non-sign value bits, that is, an unsigned 16-bit integer, or any
 // signed or unsigned integer with more than 16 bits.
 struct JcharTraits {
-    static jchar to_int_type(jchar c)  TIGHTDB_NOEXCEPT { return c; }
-    static jchar to_char_type(jchar i) TIGHTDB_NOEXCEPT { return i; }
+    static jchar to_int_type(jchar c)  REALM_NOEXCEPT { return c; }
+    static jchar to_char_type(jchar i) REALM_NOEXCEPT { return i; }
 };
 
 struct JStringCharsAccessor {
@@ -220,8 +220,8 @@ struct JStringCharsAccessor {
     {
         m_env->ReleaseStringChars(m_string, m_data);
     }
-    const jchar* data() const TIGHTDB_NOEXCEPT { return m_data; }
-    size_t size() const TIGHTDB_NOEXCEPT { return m_size; }
+    const jchar* data() const REALM_NOEXCEPT { return m_data; }
+    size_t size() const REALM_NOEXCEPT { return m_size; }
 
 private:
     JNIEnv* const m_env;
@@ -271,6 +271,11 @@ string string_to_hex(const string& message, const jchar *str, size_t size, size_
     return ret.str();
 }
 
+string concat_stringdata(const char *message, StringData strData)
+{
+    return std::string(message) + (strData != NULL ? strData.data() : "");
+}
+
 jstring to_jstring(JNIEnv* env, StringData str)
 {
     // For efficiency, if the incoming UTF-8 string is sufficiently
@@ -281,7 +286,7 @@ jstring to_jstring(JNIEnv* env, StringData str)
 
     const size_t stack_buf_size = 48;
     jchar stack_buf[stack_buf_size];
-    UniquePtr<jchar[]> dyn_buf;
+    std::unique_ptr<jchar[]> dyn_buf;
 
     const char* in_begin = str.data();
     const char* in_end   = str.data() + str.size();
@@ -314,7 +319,7 @@ jstring to_jstring(JNIEnv* env, StringData str)
         size_t retcode = Xcode::to_utf16(in_begin, in_end, out_curr, out_end);
         if (retcode != 0) 
             throw runtime_error(string_to_hex("Failure when converting long string to UTF-16", str, in_begin, in_end, out_curr, out_end, size_t(0), retcode));
-        TIGHTDB_ASSERT(in_begin == in_end);
+        REALM_ASSERT(in_begin == in_end);
     }
 
   transcode_complete:
@@ -341,7 +346,7 @@ JStringAccessor::JStringAccessor(JNIEnv* env, jstring str)
 
     typedef Utf8x16<jchar, JcharTraits> Xcode;
     size_t max_project_size = 48;
-    TIGHTDB_ASSERT(max_project_size <= numeric_limits<size_t>::max()/4);
+    REALM_ASSERT(max_project_size <= numeric_limits<size_t>::max()/4);
     size_t buf_size;
     if (chars.size() <= max_project_size) {
         buf_size = chars.size() * 4;
diff --git a/realm-jni/src/util.hpp b/realm-jni/src/util.hpp
index 8d81cf858f..2e43b3c14a 100644
--- a/realm-jni/src/util.hpp
+++ b/realm-jni/src/util.hpp
@@ -19,6 +19,7 @@
 
 #include <string>
 #include <sstream>
+#include <memory>
 
 #include <jni.h>
 
@@ -26,11 +27,10 @@
 #define __STDC_FORMAT_MACROS
 #include <inttypes.h>
 
-#include <tightdb.hpp>
-#include <tightdb/util/meta.hpp>
-#include <tightdb/util/unique_ptr.hpp>
-#include <tightdb/util/safe_int_ops.hpp>
-#include <tightdb/lang_bind_helper.hpp>
+#include <realm.hpp>
+#include <realm/util/meta.hpp>
+#include <realm/util/safe_int_ops.hpp>
+#include <realm/lang_bind_helper.hpp>
 
 #include "io_realm_internal_Util.h"
 
@@ -94,12 +94,12 @@ std::string num_to_string(T pNumber)
 #define S(x)    static_cast<size_t>(x)
 #define B(x)    static_cast<bool>(x)
 #define S64(x)  static_cast<int64_t>(x)
-#define TBL(x)  reinterpret_cast<tightdb::Table*>(x)
-#define TV(x)   reinterpret_cast<tightdb::TableView*>(x)
-#define LV(x)   reinterpret_cast<tightdb::LinkView*>(x)
-#define Q(x)    reinterpret_cast<tightdb::Query*>(x)
-#define G(x)    reinterpret_cast<tightdb::Group*>(x)
-#define ROW(x)  reinterpret_cast<tightdb::Row*>(x)
+#define TBL(x)  reinterpret_cast<realm::Table*>(x)
+#define TV(x)   reinterpret_cast<realm::TableView*>(x)
+#define LV(x)   reinterpret_cast<realm::LinkView*>(x)
+#define Q(x)    reinterpret_cast<realm::Query*>(x)
+#define G(x)    reinterpret_cast<realm::Group*>(x)
+#define ROW(x)  reinterpret_cast<realm::Row*>(x)
 
 // Exception handling
 
@@ -173,6 +173,7 @@ extern const char *log_tag;
 #define TBL_AND_COL_INDEX_VALID(env,ptr,col)                    TblColIndexValid(env, ptr, col)
 #define COL_INDEX_AND_TYPE_VALID(env,ptr,col,type)              ColIndexAndTypeValid(env, ptr, col, type)
 #define TBL_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)     TblColIndexAndTypeValid(env, ptr, col, type)
+#define TBL_AND_COL_INDEX_AND_LINK_OR_LINKLIST(env,ptr,col)     TblColIndexAndLinkOrLinkList(env, ptr, col)
 #define INDEX_VALID(env,ptr,col,row)                            IndexValid(env, ptr, col, row)
 #define TBL_AND_INDEX_VALID(env,ptr,col,row)                    TblIndexValid(env, ptr, col, row)
 #define TBL_AND_INDEX_INSERT_VALID(env,ptr,col,row)             TblIndexInsertValid(env, ptr, col, row)
@@ -196,6 +197,7 @@ extern const char *log_tag;
 #define TBL_AND_COL_INDEX_VALID(env,ptr,col)                    (true)
 #define COL_INDEX_AND_TYPE_VALID(env,ptr,col,type)              (true)
 #define TBL_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)     (true)
+#define TBL_AND_COL_INDEX_AND_LINK_OR_LINKLIST(env,ptr,col)     (true)
 #define INDEX_VALID(env,ptr,col,row)                            (true)
 #define TBL_AND_INDEX_VALID(env,ptr,col,row)                    (true)
 #define TBL_AND_INDEX_INSERT_VALID(env,ptr,col,row)             (true)
@@ -212,7 +214,7 @@ extern const char *log_tag;
 
 
 inline jlong to_jlong_or_not_found(size_t res) {
-    return (res == tightdb::not_found) ? jlong(-1) : jlong(res);
+    return (res == realm::not_found) ? jlong(-1) : jlong(res);
 }
 
 template <class T>
@@ -221,7 +223,7 @@ inline bool TableIsValid(JNIEnv* env, T* objPtr)
     bool valid = (objPtr != NULL);
     if (valid) {
         // Check if Table is valid
-        if (tightdb::util::SameType<tightdb::Table, T>::value) {
+        if (realm::util::SameType<realm::Table, T>::value) {
             valid = TBL(objPtr)->is_attached();
         }
         // TODO: Add check for TableView
@@ -256,13 +258,13 @@ bool RowIndexesValid(JNIEnv* env, T* pTable, jlong startIndex, jlong endIndex, j
         ThrowException(env, IndexOutOfBounds, "startIndex < 0.");
         return false;
     }
-    if (tightdb::util::int_greater_than(startIndex, maxIndex)) {
+    if (realm::util::int_greater_than(startIndex, maxIndex)) {
         TR_ERR("startIndex %" PRId64 " > %" PRId64 " - invalid!", S64(startIndex), S64(maxIndex))
         ThrowException(env, IndexOutOfBounds, "startIndex > available rows.");
         return false;
     }
 
-    if (tightdb::util::int_greater_than(endIndex, maxIndex)) {
+    if (realm::util::int_greater_than(endIndex, maxIndex)) {
         TR_ERR("endIndex %" PRId64 " > %" PRId64 " - invalid!", S64(endIndex), S64(maxIndex))
         ThrowException(env, IndexOutOfBounds, "endIndex > available rows.");
         return false;
@@ -292,7 +294,7 @@ inline bool RowIndexValid(JNIEnv* env, T* pTable, jlong rowIndex, bool offset=fa
     size_t size = pTable->size();
     if (size > 0 && offset)
         size -= 1;
-    bool rowErr = tightdb::util::int_greater_than_or_equal(rowIndex, size);
+    bool rowErr = realm::util::int_greater_than_or_equal(rowIndex, size);
     if (rowErr) {
         TR_ERR("rowIndex %" PRId64 " > %" PRId64 " - invalid!", S64(rowIndex), S64(size))
         ThrowException(env, IndexOutOfBounds,
@@ -305,7 +307,7 @@ inline bool RowIndexValid(JNIEnv* env, T* pTable, jlong rowIndex, bool offset=fa
 template <class T>
 inline bool TblRowIndexValid(JNIEnv* env, T* pTable, jlong rowIndex, bool offset=false)
 {
-    if (tightdb::util::SameType<tightdb::Table, T>::value) {
+    if (realm::util::SameType<realm::Table, T>::value) {
         if (!TableIsValid(env, TBL(pTable)))
             return false;
     }
@@ -319,7 +321,7 @@ inline bool ColIndexValid(JNIEnv* env, T* pTable, jlong columnIndex)
         ThrowException(env, IndexOutOfBounds, "columnIndex is less than 0.");
         return false;
     }
-    bool colErr = tightdb::util::int_greater_than_or_equal(columnIndex, pTable->get_column_count());
+    bool colErr = realm::util::int_greater_than_or_equal(columnIndex, pTable->get_column_count());
     if (colErr) {
         TR_ERR("columnIndex %" PRId64 " > %" PRId64 " - invalid!", S64(columnIndex), S64(pTable->get_column_count()))
         ThrowException(env, IndexOutOfBounds, "columnIndex > available columns.");
@@ -330,7 +332,7 @@ inline bool ColIndexValid(JNIEnv* env, T* pTable, jlong columnIndex)
 template <class T>
 inline bool TblColIndexValid(JNIEnv* env, T* pTable, jlong columnIndex)
 {
-    if (tightdb::util::SameType<tightdb::Table, T>::value) {
+    if (realm::util::SameType<realm::Table, T>::value) {
         if (!TableIsValid(env, TBL(pTable)))
             return false;
     }
@@ -361,7 +363,7 @@ inline bool TblIndexInsertValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong
 {
     if (!TblColIndexValid(env, pTable, columnIndex))
         return false;
-    bool rowErr = tightdb::util::int_greater_than(rowIndex, pTable->size()+1);
+    bool rowErr = realm::util::int_greater_than(rowIndex, pTable->size()+1);
     if (rowErr) {
         TR_ERR("rowIndex %" PRId64 " > %" PRId64 " - invalid!", S64(rowIndex), S64(pTable->size()))
         ThrowException(env, IndexOutOfBounds,
@@ -377,7 +379,7 @@ inline bool TypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex,
     size_t col = static_cast<size_t>(columnIndex);
     int colType = pTable->get_column_type(col);
     if (allowMixed) {
-        if (colType == tightdb::type_Mixed) {
+        if (colType == realm::type_Mixed) {
             size_t row = static_cast<size_t>(rowIndex);
             colType = pTable->get_mixed_type(col, row);
         }
@@ -390,6 +392,20 @@ inline bool TypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex,
     return true;
 }
 
+template <class T>
+inline bool TypeIsLinkLike(JNIEnv* env, T* pTable, jlong columnIndex)
+{
+    size_t col = static_cast<size_t>(columnIndex);
+    int colType = pTable->get_column_type(col);
+    if (colType == type_Link || colType == type_LinkList) {
+        return true;
+    }
+
+    TR_ERR("Expected columnType %d or %d, but got %d", type_Link, type_LinkList, colType)
+    ThrowException(env, IllegalArgument, "ColumnType invalid: expected type_Link or type_LinkList");
+    return false;
+}
+
 template <class T>
 inline bool ColIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, int expectColType)
 {
@@ -403,6 +419,12 @@ inline bool TblColIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, i
         && ColIndexAndTypeValid(env, pTable, columnIndex, expectColType);
 }
 
+template <class T>
+inline bool TblColIndexAndLinkOrLinkList(JNIEnv* env, T* pTable, jlong columnIndex) {
+    return TableIsValid(env, pTable)
+        && TypeIsLinkLike(env, pTable, columnIndex);
+}
+
 inline bool RowColIndexAndTypeValid(JNIEnv* env, Row* pRow, jlong columnIndex, int expectColType)
 {
     return RowIsValid(env, pRow)
@@ -419,8 +441,7 @@ inline bool IndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong r
 template <class T>
 inline bool TblIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType, bool allowMixed)
 {
-    return TableIsValid(env, pTable)
-        && IndexAndTypeValid(env, pTable, columnIndex, rowIndex, expectColType, allowMixed);
+    return TableIsValid(env, pTable) && IndexAndTypeValid(env, pTable, columnIndex, rowIndex, expectColType, allowMixed);
 }
 
 
@@ -431,8 +452,12 @@ inline bool TblIndexAndTypeInsertValid(JNIEnv* env, T* pTable, jlong columnIndex
         && TypeValid(env, pTable, columnIndex, rowIndex, expectColType, false);
 }
 
-bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, tightdb::BinaryData& data);
+bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, realm::BinaryData& data);
+
 
+// Utility function for appending StringData, which is returned
+// by a lot of core functions, and might potentially be NULL.
+std::string concat_stringdata(const char *message, StringData data);
 
 // Note: JNI offers methods to convert between modified UTF-8 and
 // UTF-16. Unfortunately these methods are not appropriate in this
@@ -440,24 +465,24 @@ bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, tightdb::BinaryData& data);
 // UTF-8 where U+0000 is stored as 0xC0 0x80 instead of 0x00 and
 // where a character in the range U+10000 to U+10FFFF is stored as
 // two consecutive UTF-8 encodings of the corresponding UTF-16
-// surrogate pair. Because TightDB uses proper UTF-8, we need to
+// surrogate pair. Because Realm uses proper UTF-8, we need to
 // do the transcoding ourselves.
 //
 // See also http://en.wikipedia.org/wiki/UTF-8#Modified_UTF-8
 
-jstring to_jstring(JNIEnv*, tightdb::StringData);
+jstring to_jstring(JNIEnv*, realm::StringData);
 
 class JStringAccessor {
 public:
     JStringAccessor(JNIEnv*, jstring);  // throws
 
-    operator tightdb::StringData() const TIGHTDB_NOEXCEPT
+    operator realm::StringData() const REALM_NOEXCEPT
     {
-        return tightdb::StringData(m_data.get(), m_size);
+        return realm::StringData(m_data.get(), m_size);
     }
 
 private:
-    tightdb::util::UniquePtr<char[]> m_data;
+    std::unique_ptr<char[]> m_data;
     std::size_t m_size;
 };
 
@@ -468,7 +493,7 @@ class KeyBuffer {
     , m_array(arr)
     , m_ptr(0)
     {
-#ifdef TIGHTDB_ENABLE_ENCRYPTION
+#ifdef REALM_ENABLE_ENCRYPTION
         if (arr) {
             if (env->GetArrayLength(m_array) != 64)
                 ThrowException(env, UnsupportedOperation, "Encryption key must be exactly 64 bytes.");
diff --git a/realm/build.gradle b/realm/build.gradle
index 31da3493a6..197ae8ac85 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -143,7 +143,7 @@ if (version.endsWith('-SNAPSHOT')) { // Only publish if it's a snapshot version
 
 task buildApt(type: GradleBuild) {
     dir = file('../realm-annotations-processor')
-    tasks = ['assemble']
+    tasks = ['shadowJar']
 }
 
 task compileJni(type: GradleBuild) {
@@ -170,7 +170,7 @@ def examples = [
     encryptionExample: "RealmEncryptionExample"
 ]
 
-def abi = [ 'armeabi', 'armeabi-v7a', 'mips', 'x86' ]
+def abi = [ 'armeabi', 'armeabi-v7a', 'arm64-v8a', 'mips', 'x86' ]
 
 //for Ant filter
 import org.apache.tools.ant.filters.ReplaceTokens
@@ -211,7 +211,7 @@ task copyLibrariesToEclipseFolder(dependsOn: 'androidJar') << {
     }
     abi.each() { abiName ->
         copy {
-            from "build/intermediates/eclipse/lib/${abiName}/libtightdb-jni.so"
+            from "build/intermediates/eclipse/lib/${abiName}/librealm-jni.so"
             into "../distribution/eclipse/lib/${abiName}"
         }
     }
@@ -295,4 +295,4 @@ task release {
     group 'Release'
     description 'Release realm-java'
     dependsOn pushTag
-}
\ No newline at end of file
+}
diff --git a/realm/build/libs/realm-0.80.1-GINGERBREAD-SUPPORT.jar b/realm/build/libs/realm-0.80.1-GINGERBREAD-SUPPORT.jar
index 9690b0ebd2..f6badf7b6e 100644
Binary files a/realm/build/libs/realm-0.80.1-GINGERBREAD-SUPPORT.jar and b/realm/build/libs/realm-0.80.1-GINGERBREAD-SUPPORT.jar differ
diff --git a/realm/src/androidTest/java/io/realm/RealmJsonTest.java b/realm/src/androidTest/java/io/realm/RealmJsonTest.java
index fe8d542c4e..56d752c7be 100644
--- a/realm/src/androidTest/java/io/realm/RealmJsonTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmJsonTest.java
@@ -26,6 +26,7 @@
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.charset.Charset;
 import java.util.Date;
 
 import io.realm.entities.AllTypes;
@@ -63,6 +64,10 @@ private InputStream loadJsonFromAssets(String file) {
         }
     }
 
+    private InputStream strToStream(String str) {
+        return new ByteArrayInputStream(str.getBytes(Charset.forName("UTF-8")));
+    }
+
     public void testCreateObjectFromJson_nullObject() {
         testRealm.createObjectFromJson(AllTypes.class, (JSONObject) null);
         assertEquals(0, testRealm.allObjects(AllTypes.class).size());
@@ -326,7 +331,7 @@ public void testCreateAllFromJsonStringArray_null() {
    public void testCreateAllFromJsonStream_null() throws IOException {
         testRealm.createAllFromJson(AllTypes.class, (InputStream) null);
         assertEquals(0, testRealm.allObjects(AllTypes.class).size());
-    }
+   }
 
     public void testCreateObjectFromJsonStream_allSimpleTypes() throws IOException {
         InputStream in = loadJsonFromAssets("all_simple_types.json");
@@ -452,6 +457,15 @@ public void testCreateOrUpdateObjectStream_noPrimaryKeyThrows() throws IOExcepti
         fail();
     }
 
+    public void testCreateOrUpdateObjectStream_invalidJSonThrows() throws IOException {
+        try {
+            testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, strToStream("{"));
+        } catch (RealmException expected) {
+            return;
+        }
+        fail();
+    }
+
     public void testCreateOrUpdateObjectString_noPrimaryKeyThrows() throws IOException {
         try {
             testRealm.createOrUpdateObjectFromJson(AllTypes.class, "{}");
@@ -479,6 +493,37 @@ public void testCreateOrUpdateJsonObject() throws JSONException {
         assertEquals("bar", newObj.getColumnString());
     }
 
+    public void testCreateOrUpdateJsonObject_ignoreUnsetProperties() {
+        testRealm.beginTransaction();
+        AllTypesPrimaryKey obj = testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{ \"columnLong\":1, \"columnString\": \"foo\" }");
+        obj.setColumnBoolean(true);
+        testRealm.commitTransaction();
+
+        testRealm.beginTransaction();
+        obj = testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{ \"columnLong\":1, \"columnString\": \"bar\" }");
+        testRealm.commitTransaction();
+
+        assertTrue(obj.isColumnBoolean());
+    }
+
+    public void testCreateOrUpdateJsonStream_ignoreUnsetProperties() throws IOException {
+        testRealm.beginTransaction();
+        AllTypesPrimaryKey obj = testRealm.createOrUpdateObjectFromJson(
+                AllTypesPrimaryKey.class, strToStream("{ \"columnLong\":1, \"columnString\": \"foo\" }")
+        );
+        obj.setColumnBoolean(true);
+        testRealm.commitTransaction();
+
+        testRealm.beginTransaction();
+        obj = testRealm.createOrUpdateObjectFromJson(
+                AllTypesPrimaryKey.class, strToStream("{ \"columnLong\":1, \"columnString\": \"bar\" }")
+        );
+        testRealm.commitTransaction();
+
+        assertTrue(obj.isColumnBoolean());
+        assertEquals("bar", obj.getColumnString());
+    }
+
     public void testCreateOrUpdateInputStream() throws IOException {
         testRealm.beginTransaction();
         AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
@@ -486,7 +531,7 @@ public void testCreateOrUpdateInputStream() throws IOException {
         obj.setColumnString("Foo");
         testRealm.copyToRealm(obj);
 
-        ByteArrayInputStream in = new ByteArrayInputStream("{ \"columnLong\" : 1, \"columnString\" : \"bar\" }".getBytes());
+        InputStream in = strToStream("{ \"columnLong\" : 1, \"columnString\" : \"bar\" }");
         AllTypesPrimaryKey newObj = testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, in);
         testRealm.commitTransaction();
 
@@ -527,6 +572,15 @@ public void testCreateOrUpdateAllStream_noPrimaryKeyThrows() throws IOException
         fail();
     }
 
+    public void testCreateOrUpdateAllStream_invalidJSonThrows() throws IOException {
+        try {
+            testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, strToStream("["));
+        } catch (RealmException expected) {
+            return;
+        }
+        fail();
+    }
+
     public void testCreateOrUpdateAllString_noPrimaryKeyThrows() throws IOException {
         try {
             testRealm.createOrUpdateAllFromJson(AllTypes.class, "{}");
diff --git a/realm/src/androidTest/java/io/realm/RealmLinkTests.java b/realm/src/androidTest/java/io/realm/RealmLinkTests.java
index 48aa43c7ed..81d8d04d85 100644
--- a/realm/src/androidTest/java/io/realm/RealmLinkTests.java
+++ b/realm/src/androidTest/java/io/realm/RealmLinkTests.java
@@ -463,4 +463,61 @@ public void testSubquery() {
         RealmResults<Owner> subOwners = owners.where().equalTo("cat.name", "Blackie").findAll();
         assertEquals(1, subOwners.size());
     }
+
+    public void testLinkIsNull() {
+        RealmResults<Owner> owners1 = testRealm.where(Owner.class).isNull("cat").findAll();
+        assertEquals(0, owners1.size());
+
+        testRealm.beginTransaction();
+        testRealm.clear(Cat.class);
+        testRealm.commitTransaction();
+
+        RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNull("cat").findAll();
+        assertEquals(1, owners2.size());
+    }
+
+    public void testLinkListIsNull() {
+        RealmResults<Owner> owners1 = testRealm.where(Owner.class).isNull("dogs").findAll();
+        assertEquals(0, owners1.size());
+
+        testRealm.beginTransaction();
+        testRealm.clear(Dog.class);
+        testRealm.commitTransaction();
+
+        RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNull("dogs").findAll();
+        assertEquals(1, owners2.size());
+    }
+
+    public void testLinkIsNotNull() {
+        RealmResults<Owner> owners1 = testRealm.where(Owner.class).isNotNull("cat").findAll();
+        assertEquals(1, owners1.size());
+
+        testRealm.beginTransaction();
+        testRealm.clear(Cat.class);
+        testRealm.commitTransaction();
+
+        RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNotNull("cat").findAll();
+        assertEquals(0, owners2.size());
+    }
+
+    public void testLinkListIsNotNull() {
+        RealmResults<Owner> owners1 = testRealm.where(Owner.class).isNotNull("dogs").findAll();
+        assertEquals(1, owners1.size());
+
+        testRealm.beginTransaction();
+        testRealm.clear(Dog.class);
+        testRealm.commitTransaction();
+
+        RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNotNull("dogs").findAll();
+        assertEquals(0, owners2.size());
+    }
+
+    public void testIsNullWrongType() {
+        try {
+            // Owner.name is a String
+            RealmResults<Owner> owners = testRealm.where(Owner.class).isNull("name").findAll();
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
 }
diff --git a/realm/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/src/androidTest/java/io/realm/RealmMigrationTests.java
index 680965af7f..c8debea8ed 100644
--- a/realm/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -2,13 +2,35 @@
 
 import android.test.AndroidTestCase;
 
+import java.io.File;
 import java.io.IOException;
 
 import io.realm.entities.AllTypes;
+import io.realm.entities.FieldOrder;
+import io.realm.entities.AnnotationTypes;
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.ColumnType;
+import io.realm.internal.Table;
 
 public class RealmMigrationTests extends AndroidTestCase {
 
+    public Realm realm;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        Realm.deleteRealmFile(getContext());
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        super.tearDown();
+        if (realm != null) {
+            realm.close();
+        }
+        Realm.setSchema(null);
+    }
+
     public void testRealmClosedAfterMigrationException() throws IOException {
         String REALM_NAME = "default0.realm";
         Realm.deleteRealmFile(getContext(), REALM_NAME);
@@ -25,4 +47,108 @@ public void testRealmClosedAfterMigrationException() throws IOException {
         int result = realm.where(AllTypes.class).equalTo("columnString", "Foo").findAll().size();
         assertEquals(0, result);
     }
+
+    // If a migration creates a different ordering of columns on Realm A, while another ordering is generated by
+    // creating a new Realm B. Global column indices will not work. They must be calculated for each Realm.
+    public void testLocalColumnIndices() throws IOException {
+        String MIGRATED_REALM = "migrated.realm";
+        String NEW_REALM = "new.realm";
+
+        // Migrate old Realm to proper schema
+        Realm.deleteRealmFile(getContext(), MIGRATED_REALM);
+        Realm.setSchema(AllTypes.class);
+        Realm migratedRealm = Realm.getInstance(getContext(), MIGRATED_REALM);
+        migratedRealm.close();
+        Realm.migrateRealmAtPath(new File(getContext().getFilesDir(), MIGRATED_REALM).getAbsolutePath(), new RealmMigration() {
+            @Override
+            public long execute(Realm realm, long version) {
+                Table languageTable = realm.getTable(FieldOrder.class);
+                if (languageTable.getColumnCount() == 0) {
+                    languageTable.addColumn(ColumnType.INTEGER, "field2");
+                    languageTable.addColumn(ColumnType.BOOLEAN, "field1");
+                }
+
+                return version + 1;
+            }
+        });
+
+        // Open migrated Realm and populate column indices based on migration ordering.
+        Realm.setSchema(AllTypes.class, FieldOrder.class);
+        migratedRealm = Realm.getInstance(getContext(), MIGRATED_REALM);
+
+        // Create new Realm which will cause column indices to be recalculated based on the order in the java file
+        // instead of the migration
+        Realm.deleteRealmFile(getContext(), NEW_REALM);
+        Realm newRealm = Realm.getInstance(getContext(), NEW_REALM);
+        newRealm.close();
+
+        // Try to query migrated realm. With local column indices this will work. With global it will fail.
+        assertEquals(0, migratedRealm.where(FieldOrder.class).equalTo("field1", true).findAll().size());
+    }
+
+    public void testNotSettingIndexThrows() {
+        Realm.setSchema(AnnotationTypes.class);
+        Realm.migrateRealmAtPath(new File(getContext().getFilesDir(), "default.realm").getAbsolutePath(), new RealmMigration() {
+            @Override
+            public long execute(Realm realm, long version) {
+                Table table = realm.getTable(AnnotationTypes.class);
+                table.addColumn(ColumnType.INTEGER, "id");
+                table.setPrimaryKey("id");
+                table.addColumn(ColumnType.STRING, "indexString");
+                table.addColumn(ColumnType.STRING, "notIndexString");
+                // Forget to set @Index
+                return 1;
+            }
+        });
+
+        try {
+            realm = Realm.getInstance(getContext());
+            fail();
+        } catch (RealmMigrationNeededException expected) {
+        }
+    }
+
+    public void testNotSettingPrimaryKeyThrows() {
+        Realm.setSchema(AnnotationTypes.class);
+        Realm.migrateRealmAtPath(new File(getContext().getFilesDir(), "default.realm").getAbsolutePath(), new RealmMigration() {
+            @Override
+            public long execute(Realm realm, long version) {
+                Table table = realm.getTable(AnnotationTypes.class);
+                table.addColumn(ColumnType.INTEGER, "id");
+                // Forget to set @PrimaryKey
+                long columnIndex = table.addColumn(ColumnType.STRING, "indexString");
+                table.setIndex(columnIndex);
+                table.addColumn(ColumnType.STRING, "notIndexString");
+                return 1;
+            }
+        });
+
+        try {
+            realm = Realm.getInstance(getContext());
+            fail();
+        } catch (RealmMigrationNeededException expected) {
+        }
+    }
+
+    public void testSetAnnotations() {
+        Realm.setSchema(AnnotationTypes.class);
+        Realm.migrateRealmAtPath(new File(getContext().getFilesDir(), "default.realm").getAbsolutePath(), new RealmMigration() {
+            @Override
+            public long execute(Realm realm, long version) {
+                Table table = realm.getTable(AnnotationTypes.class);
+                table.addColumn(ColumnType.INTEGER, "id");
+                table.setPrimaryKey("id");
+                long columnIndex = table.addColumn(ColumnType.STRING, "indexString");
+                table.setIndex(columnIndex);
+                table.addColumn(ColumnType.STRING, "notIndexString");
+                return 1;
+            }
+        });
+
+        realm = Realm.getInstance(getContext());
+        Table table = realm.getTable(AnnotationTypes.class);
+        assertEquals(3, table.getColumnCount());
+        assertTrue(table.hasPrimaryKey());
+        assertTrue(table.hasIndex(table.getColumnIndex("indexString")));
+    }
 }
diff --git a/realm/src/androidTest/java/io/realm/RealmTest.java b/realm/src/androidTest/java/io/realm/RealmTest.java
index f9cf75af9a..881612c9b7 100644
--- a/realm/src/androidTest/java/io/realm/RealmTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmTest.java
@@ -19,10 +19,7 @@
 import android.test.AndroidTestCase;
 
 import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
 import java.io.IOException;
-import java.nio.channels.FileChannel;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
@@ -37,15 +34,16 @@
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.AllTypesPrimaryKey;
+import io.realm.entities.Cat;
 import io.realm.entities.CyclicType;
 import io.realm.entities.CyclicTypePrimaryKey;
-import io.realm.entities.Cat;
 import io.realm.entities.Dog;
 import io.realm.entities.DogPrimaryKey;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
 import io.realm.entities.OwnerPrimaryKey;
 import io.realm.entities.PrimaryKeyAsLong;
+import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.PrimaryKeyMix;
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmException;
@@ -91,12 +89,12 @@ protected void tearDown() throws Exception {
         }
     }
 
-    private void populateTestRealm(int objects) {
-        testRealm.beginTransaction();
-        testRealm.allObjects(AllTypes.class).clear();
-        testRealm.allObjects(NonLatinFieldNames.class).clear();
+    private void populateTestRealm(Realm realm, int objects) {
+        realm.beginTransaction();
+        realm.allObjects(AllTypes.class).clear();
+        realm.allObjects(NonLatinFieldNames.class).clear();
         for (int i = 0; i < objects; ++i) {
-            AllTypes allTypes = testRealm.createObject(AllTypes.class);
+            AllTypes allTypes = realm.createObject(AllTypes.class);
             allTypes.setColumnBoolean((i % 3) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
             allTypes.setColumnDate(new Date());
@@ -104,17 +102,17 @@ private void populateTestRealm(int objects) {
             allTypes.setColumnFloat(1.234567f + i);
             allTypes.setColumnString("test data " + i);
             allTypes.setColumnLong(i);
-            NonLatinFieldNames nonLatinFieldNames = testRealm.createObject(NonLatinFieldNames.class);
+            NonLatinFieldNames nonLatinFieldNames = realm.createObject(NonLatinFieldNames.class);
             nonLatinFieldNames.set델타(i);
             nonLatinFieldNames.setΔέλτα(i);
             nonLatinFieldNames.set베타(1.234567f + i);
             nonLatinFieldNames.setΒήτα(1.234567f + i);
         }
-        testRealm.commitTransaction();
+        realm.commitTransaction();
     }
 
     private void populateTestRealm() {
-        populateTestRealm(TEST_DATA_SIZE);
+        populateTestRealm(testRealm, TEST_DATA_SIZE);
     }
 
 
@@ -170,7 +168,26 @@ public void testGetInstanceFileNoWritePermissionThrows() throws IOException {
         }
     }
 
-
+    // TODO Disabled due to the build phone keep crashing on this. It might be related to https://github.com/realm/realm-java/issues/1008
+    public void DISABLEtestGetInstanceClearsCacheWhenFailed() {
+        String REALM_NAME = "invalid_cache.realm";
+        Realm.deleteRealmFile(getContext(), REALM_NAME);
+        Random random = new Random();
+        byte[] key = new byte[64];
+        random.nextBytes(key);
+        Realm realm = Realm.getInstance(getContext(), REALM_NAME, key); // Create starting Realm with key1
+        realm.close();
+        random.nextBytes(key);
+        try {
+            Realm.getInstance(getContext(), REALM_NAME, key); // Try to open with key 2
+        } catch (IllegalArgumentException expected) {
+            // Delete Realm so key 2 works. This should work as a Realm shouldn't be cached
+            // if initialization failed.
+            assertTrue(Realm.deleteRealmFile(getContext(), REALM_NAME));
+            Realm.getInstance(getContext(), REALM_NAME, key);
+            realm.close();
+        }
+    }
 
     public void testRealmCache() {
         Realm newRealm = Realm.getInstance(getContext());
@@ -267,7 +284,7 @@ public void testShouldReturnResultSet() {
 
     // Note that this test is relying on the values set while initializing the test dataset
     public void testQueriesResults() throws IOException {
-        populateTestRealm(159);
+        populateTestRealm(testRealm, 159);
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).equalTo(FIELD_LONG, 33).findAll();
         assertEquals(1, resultList.size());
 
@@ -917,14 +934,66 @@ public void testWriteCopyTo() throws IOException {
         }
     }
 
-    public void testCompactRealmFile() throws IOException {
-        final String copyRealm = "copy.realm";
-        fileCopy(
-                new File(getContext().getFilesDir(), Realm.DEFAULT_REALM_NAME),
-                new File(getContext().getFilesDir(), copyRealm));
-        long before = new File(getContext().getFilesDir(), copyRealm).length();
-        assertTrue(Realm.compactRealmFile(getContext()));
-        long after = new File(getContext().getFilesDir(), copyRealm).length();
+
+    public void testCompactRealmFileThrowsIfOpen() throws IOException {
+        try {
+            Realm.compactRealmFile(getContext());
+            fail();
+        } catch (IllegalStateException expected) {
+        }
+    }
+
+    public void testCompactEncryptedEmptyRealmFile() {
+        String REALM_NAME = "enc.realm";
+        Realm.deleteRealmFile(getContext(), REALM_NAME);
+        byte[] key = new byte[64];
+        new Random(42).nextBytes(key);
+        Realm realm = Realm.getInstance(getContext(), REALM_NAME, key);
+        realm.close();
+        // TODO: remove try/catch block when compacting encrypted Realms is supported
+        try {
+            assertTrue(Realm.compactRealmFile(getContext(), REALM_NAME, key));
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    public void testCompactEncryptedPopulatedRealmFile() {
+        String REALM_NAME = "enc.realm";
+        Realm.deleteRealmFile(getContext(), REALM_NAME);
+        byte[] key = new byte[64];
+        new Random(42).nextBytes(key);
+        Realm realm = Realm.getInstance(getContext(), REALM_NAME, key);
+        populateTestRealm(realm, 100);
+        realm.close();
+        // TODO: remove try/catch block when compacting encrypted Realms is supported
+        try {
+            assertTrue(Realm.compactRealmFile(getContext(), REALM_NAME, key));
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    public void testCompactEmptyRealmFile() throws IOException {
+        final String REALM_NAME = "test.realm";
+        Realm.deleteRealmFile(getContext(), REALM_NAME);
+        Realm realm = Realm.getInstance(getContext(), REALM_NAME);
+        realm.close();
+        long before = new File(getContext().getFilesDir(), REALM_NAME).length();
+        assertTrue(Realm.compactRealmFile(getContext(), REALM_NAME));
+        long after = new File(getContext().getFilesDir(), REALM_NAME).length();
+        assertTrue(before >= after);
+    }
+
+    public void testCompactPopulateRealmFile() throws IOException {
+        final String REALM_NAME = "test.realm";
+        Realm.deleteRealmFile(getContext(), REALM_NAME);
+        Realm realm = Realm.getInstance(getContext(), REALM_NAME);
+        populateTestRealm(realm, 100);
+        realm.close();
+        long before = new File(getContext().getFilesDir(), REALM_NAME).length();
+        assertTrue(Realm.compactRealmFile(getContext(), REALM_NAME));
+        long after = new File(getContext().getFilesDir(), REALM_NAME).length();
         assertTrue(before >= after);
     }
 
@@ -971,7 +1040,7 @@ public void testCopManagedObjectToOtherRealm() {
 
     public void testCopyToRealmObject() {
         Date date = new Date();
-        date.setTime(1000); // Remove ms. precission as Realm doesn't support it yet.
+        date.setTime(1000); // Remove ms. precision as Realm doesn't support it yet.
         Dog dog = new Dog();
         dog.setName("Fido");
         RealmList<Dog> list = new RealmList<Dog>();
@@ -1049,6 +1118,40 @@ public void testCopyToRealmDefaultValues() {
         assertArrayEquals(new byte[0], realmTypes.getColumnBinary());
     }
 
+    // Check that using copyToRealm will set the primary key directly instead of first setting
+    // it to the default value (which can fail)
+    public void testCopyToRealmWithPrimaryKeySetValueDirectly() {
+        testRealm.beginTransaction();
+        testRealm.createObject(OwnerPrimaryKey.class);
+        testRealm.copyToRealm(new OwnerPrimaryKey(1, "Foo"));
+        testRealm.commitTransaction();
+        assertEquals(2, testRealm.where(OwnerPrimaryKey.class).count());
+    }
+
+    public void testCopyToRealmWithPrimaryAsNullThrows() {
+        testRealm.beginTransaction();
+        try {
+            testRealm.copyToRealm(new PrimaryKeyAsString());
+            fail();
+        } catch (RealmException expected) {
+        } finally {
+            testRealm.cancelTransaction();
+        }
+    }
+
+    public void testCopyToRealmDontCopyNestedRealmObjets() {
+        testRealm.beginTransaction();
+        CyclicTypePrimaryKey childObj = testRealm.createObject(CyclicTypePrimaryKey.class);
+        childObj.setName("Child");
+        childObj.setId(1);
+
+        CyclicTypePrimaryKey parentObj = new CyclicTypePrimaryKey(2);
+        parentObj.setObject(childObj);
+        testRealm.copyToRealm(parentObj);
+        testRealm.commitTransaction();
+
+        assertEquals(2, testRealm.where(CyclicTypePrimaryKey.class).count());
+    }
 
     public void testCopyToRealmList() {
         Dog dog1 = new Dog();
@@ -1306,16 +1409,6 @@ public void testCopyOrUpdateIterableChildObjects() {
         assertEquals(1, testRealm.allObjects(DogPrimaryKey.class).size());
     }
 
-    private void fileCopy(File src, File dst) throws IOException {
-        FileInputStream inStream = new FileInputStream(src);
-        FileOutputStream outStream = new FileOutputStream(dst);
-        FileChannel inChannel = inStream.getChannel();
-        FileChannel outChannel = outStream.getChannel();
-        inChannel.transferTo(0, inChannel.size(), outChannel);
-        inStream.close();
-        outStream.close();
-    }
-
     public void testOpeningOfEncryptedRealmWithDifferentKeyInstances() {
         byte[] key1 = new byte[64];
         byte[] key2 = new byte[64];
@@ -1482,7 +1575,6 @@ public void testWrongKeyShouldThrow() {
             fail();
         } catch (IllegalStateException ignored) {
         }
-
     }
 
     public void testUpdateObjectWithLinks() throws Exception {
@@ -1511,4 +1603,11 @@ public void testUpdateObjectWithLinks() throws Exception {
 
         testRealm.commitTransaction();
     }
+
+    public void testDeleteNonRealmFile() throws IOException {
+        File tmpFile = new File(getContext().getFilesDir(), "tmp");
+        tmpFile.delete();
+        assertTrue(tmpFile.createNewFile());
+        assertTrue(Realm.deleteRealmFile(tmpFile));
+    }
 }
diff --git a/realm/src/androidTest/java/io/realm/entities/FieldOrder.java b/realm/src/androidTest/java/io/realm/entities/FieldOrder.java
new file mode 100644
index 0000000000..ef32a51c4f
--- /dev/null
+++ b/realm/src/androidTest/java/io/realm/entities/FieldOrder.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+
+public class FieldOrder extends RealmObject {
+
+    private boolean field1;
+    private int field2;
+
+    public boolean isField1() {
+        return field1;
+    }
+
+    public void setField1(boolean field1) {
+        this.field1 = field1;
+    }
+
+    public int getField2() {
+        return field2;
+    }
+
+    public void setField2(int field2) {
+        this.field2 = field2;
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java b/realm/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
index 3bba1b003c..ce53189446 100644
--- a/realm/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
+++ b/realm/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
@@ -26,6 +26,13 @@
 
     private long id;
 
+    public PrimaryKeyAsString() {
+    }
+
+    public PrimaryKeyAsString(String name) {
+        this.name = name;
+    }
+
     public String getName() {
         return name;
     }
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java b/realm/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java
index 503c5a3120..51280a6a6c 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java
+++ b/realm/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java
@@ -9,7 +9,7 @@
 
     @Override
     public void setUp() {
-        TightDB.loadLibrary();
+        RealmCore.loadLibrary();
         //util.setDebugLevel(0); //Set to 1 to see more JNI debug messages
 
         table = new Table();
diff --git a/realm/src/androidTest/java/io/realm/internal/JNITransactions.java b/realm/src/androidTest/java/io/realm/internal/JNITransactions.java
index cbb78bfdfc..3106ea9625 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNITransactions.java
+++ b/realm/src/androidTest/java/io/realm/internal/JNITransactions.java
@@ -36,7 +36,24 @@ protected void deleteFile(String filename) throws IOException {
         }
     }
 
-    
+    private Table getTableWithStringPrimaryKey() {
+        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
+        WriteTransaction trans = db.beginWrite();
+        Table t = trans.getTable("TestTable");
+        t.addColumn(ColumnType.STRING, "colName");
+        t.setPrimaryKey("colName");
+        return t;
+    }
+
+    private Table getTableWithIntegerPrimaryKey() {
+        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
+        WriteTransaction trans = db.beginWrite();
+        Table t = trans.getTable("TestTable");
+        t.addColumn(ColumnType.INTEGER, "colName");
+        t.setPrimaryKey("colName");
+        return t;
+    }
+
     private void createDBFileName(){
         testFile = new File(
                 this.getContext().getFilesDir(),
@@ -319,24 +336,44 @@ public void testRemovingPrimaryKeyRemovesConstraint_typeSetters() {
         fail("Primary key not enforced.");
     }
 
+    public void testAddEmptyRowWithPrimaryKeyWrongTypeStringThrows() {
+        Table t = getTableWithStringPrimaryKey();
+        try {
+            t.addEmptyRowWithPrimaryKey(42);
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
 
-
-    /*  ARM Only works for Java 1.7 - NOT available in Android.
-
-    @Test(enabled=true)
-    public void mustReadARM() {
-        writeOneTransaction(1);
-
-        // Read from table
-        // System.out.println("mustReadARM.");
-        try (ReadTransaction t = new ReadTransaction(db)) {
-            EmployeeTable employees = new EmployeeTable(t);
-            assertEquals(true, employees.isValid());
-            assertEquals(1, employees.size());
+    public void testAddEmptyRowWithPrimaryKeyNullStringThrows() {
+        Table t = getTableWithStringPrimaryKey();
+        try {
+            t.addEmptyRowWithPrimaryKey(null);
+            fail();
+        } catch (IllegalArgumentException expected) {
         }
-        catch (Throwable e) {
+    }
 
+    public void testAddEmptyRowWithPrimaryKeyWrongTypeIntegerThrows() {
+        Table t = getTableWithIntegerPrimaryKey();
+        try {
+            t.addEmptyRowWithPrimaryKey("Foo");
+            fail();
+        } catch (IllegalArgumentException expected) {
         }
     }
-     */
+
+    public void testAddEmptyRowWithPrimaryKeyString() {
+        Table t = getTableWithStringPrimaryKey();
+        long rowIndex = t.addEmptyRowWithPrimaryKey("Foo");
+        assertEquals(1, t.size());
+        assertEquals("Foo", t.getRow(rowIndex).getString(0));
+    }
+
+    public void testAddEmptyRowWithPrimaryKeyLong() {
+        Table t = getTableWithIntegerPrimaryKey();
+        long rowIndex = t.addEmptyRowWithPrimaryKey(42);
+        assertEquals(1, t.size());
+        assertEquals(42, t.getRow(rowIndex).getLong(0));
+    }
 }
diff --git a/realm/src/main/java/io/realm/Realm.java b/realm/src/main/java/io/realm/Realm.java
index 6e058479d8..162c99a3d7 100644
--- a/realm/src/main/java/io/realm/Realm.java
+++ b/realm/src/main/java/io/realm/Realm.java
@@ -24,8 +24,8 @@
 import android.os.Looper;
 import android.os.Message;
 import android.support.v11.util.JsonReader;
-import android.util.Log;
 
+import org.jetbrains.annotations.NotNull;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -45,14 +45,15 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Scanner;
 import java.util.Set;
-import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmIOException;
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.ColumnIndices;
 import io.realm.internal.ColumnType;
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.RealmJson;
@@ -176,8 +177,7 @@
     private static final Set<Class<? extends RealmObject>> customSchema = new HashSet<Class<? extends RealmObject>>();
     private static final long UNVERSIONED = -1;
 
-    // Package protected to be reachable by proxy classes
-    static final Map<String, Map<String, Long>> columnIndices = new HashMap<String, Map<String, Long>>();
+    final ColumnIndices columnIndices = new ColumnIndices();
 
     static {
         RealmLog.add(BuildConfig.DEBUG ? new DebugAndroidLogger() : new ReleaseAndroidLogger());
@@ -213,8 +213,8 @@ private Realm(String absolutePath, byte[] key, boolean autoRefresh) {
     protected void finalize() throws Throwable {
         if (sharedGroup != null) {
             RealmLog.w("Remember to call close() on all Realm instances. " +
-                    "Realm " + path + " is being finalized without being closed, " +
-                    "this can lead to running out of native memory."
+                            "Realm " + path + " is being finalized without being closed, " +
+                            "this can lead to running out of native memory."
             );
         }
         super.finalize();
@@ -490,25 +490,16 @@ private static Realm create(File writableFolder, String filename, byte[] key) {
     }
 
     private static synchronized Realm createAndValidate(String absolutePath, byte[] key, boolean validateSchema,
-                                            boolean autoRefresh) {
+                                                        boolean autoRefresh) {
+        // Check thread local cache for existing Realm
         int id = absolutePath.hashCode();
         Map<Integer, Integer> localRefCount = referenceCount.get();
         Integer references = localRefCount.get(id);
         if (references == null) {
             references = 0;
         }
-        if (references == 0) {
-            AtomicInteger counter = openRealms.get(id);
-            if (counter == null) {
-                openRealms.put(id, new AtomicInteger(1));
-            } else {
-                counter.incrementAndGet();
-            }
-
-        }
         Map<Integer, Realm> realms = realmsCache.get();
         Realm realm = realms.get(absolutePath.hashCode());
-
         if (realm != null) {
             if (!Arrays.equals(realm.key, key)) {
                 throw new IllegalStateException(DIFFERENT_KEY_MESSAGE);
@@ -524,6 +515,17 @@ private static synchronized Realm createAndValidate(String absolutePath, byte[]
         realmsCache.set(realms);
         localRefCount.put(id, references + 1);
 
+        // Increment global reference counter
+        if (references == 0) {
+            AtomicInteger counter = openRealms.get(id);
+            if (counter == null) {
+                openRealms.put(id, new AtomicInteger(1));
+            } else {
+                counter.incrementAndGet();
+            }
+        }
+
+        // Initialize Realm schema if needed
         if (validateSchema) {
             try {
                 initializeRealm(realm);
@@ -630,34 +632,22 @@ private static void initializeRealm(Realm realm) {
                 }
 
                 // Populate the columnIndices table
-                Method fieldNamesMethod;
+                Method columnIndiciesMethod;
                 try {
-                    fieldNamesMethod = generatedClass.getMethod("getFieldNames");
+                    columnIndiciesMethod = generatedClass.getMethod("getColumnIndices");
                 } catch (NoSuchMethodException e) {
-                    throw new RealmException("Could not find the getFieldNames method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
+                    throw new RealmException("Could not find the getColumnIndices method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                 }
-                List<String> fieldNames;
+                Map<String,Long> indices;
                 try {
                     //noinspection unchecked
-                    fieldNames = (List<String>) fieldNamesMethod.invoke(null);
+                    indices = (Map<String,Long>) columnIndiciesMethod.invoke(null);
                 } catch (IllegalAccessException e) {
-                    throw new RealmException("Could not execute the getFieldNames method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
+                    throw new RealmException("Could not execute the getColumnIndices method in the generated " + generatedClassName + " class", e);
                 } catch (InvocationTargetException e) {
-                    throw new RealmException("An exception was thrown in the getFieldNames method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
-                }
-                Table table = realm.transaction.getTable(TABLE_PREFIX + modelClassName);
-                for (String fieldName : fieldNames) {
-                    long columnIndex = table.getColumnIndex(fieldName);
-                    if (columnIndex == -1) {
-                        throw new RealmMigrationNeededException("Field '" + fieldName + "' not found for type '" + modelClassName + "'");
-                    }
-                    Map<String, Long> innerMap = columnIndices.get(modelClassName);
-                    if (innerMap == null) {
-                        innerMap = new HashMap<String, Long>();
-                    }
-                    innerMap.put(fieldName, columnIndex);
-                    columnIndices.put(modelClassName, innerMap);
+                    throw new RealmException("An exception was thrown in the getColumnIndices method in the generated " + generatedClassName + " class", e);
                 }
+                realm.columnIndices.addClass((Class<? extends RealmObject>) generatedClass.getSuperclass(), indices);
             }
         } finally {
             if (commitNeeded) {
@@ -684,9 +674,8 @@ private static void initializeRealm(Realm realm) {
         }
 
         for (int i = 0; i < json.length(); i++) {
-            E obj = createObject(clazz);
             try {
-                realmJson.populateUsingJsonObject(obj, json.getJSONObject(i));
+                realmJson.createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), false);
             } catch (Exception e) {
                 throw new RealmException("Could not map Json", e);
             }
@@ -709,12 +698,9 @@ private static void initializeRealm(Realm realm) {
             return;
         }
         checkHasPrimaryKey(clazz);
-
         for (int i = 0; i < json.length(); i++) {
-            E obj = createStandaloneRealmObjectInstance(clazz);
             try {
-                realmJson.populateUsingJsonObject(obj, json.getJSONObject(i));
-                copyToRealmOrUpdate(obj);
+                realmJson.createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), true);
             } catch (Exception e) {
                 throw new RealmException("Could not map Json", e);
             }
@@ -795,8 +781,7 @@ private static void initializeRealm(Realm realm) {
         try {
             reader.beginArray();
             while (reader.hasNext()) {
-                E obj = createObject(clazz);
-                realmJson.populateUsingJsonStream(obj, reader);
+                realmJson.createUsingJsonStream(clazz, this, reader);
             }
             reader.endArray();
         } finally {
@@ -822,17 +807,21 @@ private static void initializeRealm(Realm realm) {
         }
         checkHasPrimaryKey(clazz);
 
-        JsonReader reader = new JsonReader(new InputStreamReader(in, "UTF-8"));
+        // As we need the primary key value we have to first parse the entire input stream as in the general
+        // case that value might be the last property :(
+        Scanner scanner = null;
         try {
-            reader.beginArray();
-            while (reader.hasNext()) {
-                E obj = createStandaloneRealmObjectInstance(clazz);
-                realmJson.populateUsingJsonStream(obj, reader);
-                copyToRealmOrUpdate(obj);
+            scanner = getFullStringScanner(in);
+            JSONArray json = new JSONArray(scanner.next());
+            for (int i = 0; i < json.length(); i++) {
+                realmJson.createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), true);
             }
-            reader.endArray();
+        } catch (JSONException e) {
+            throw new RealmException("Failed to read JSON", e);
         } finally {
-            reader.close();
+            if (scanner != null) {
+                scanner.close();
+            }
         }
     }
 
@@ -853,14 +842,11 @@ private static void initializeRealm(Realm realm) {
             return null;
         }
 
-        E obj = createObject(clazz);
         try {
-            realmJson.populateUsingJsonObject(obj, json);
+            return realmJson.createOrUpdateUsingJsonObject(clazz, this, json, false);
         } catch (Exception e) {
             throw new RealmException("Could not map Json", e);
         }
-
-        return obj;
     }
 
     /**
@@ -879,17 +865,11 @@ private static void initializeRealm(Realm realm) {
             return null;
         }
         checkHasPrimaryKey(clazz);
-
-        E obj = createStandaloneRealmObjectInstance(clazz);
-
         try {
-            realmJson.populateUsingJsonObject(obj, json);
-            copyToRealmOrUpdate(obj);
+            return realmJson.createOrUpdateUsingJsonObject(clazz, this, json, true);
         } catch (JSONException e) {
             throw new RealmException("Could not map Json", e);
         }
-
-        return obj;
     }
 
     /**
@@ -966,9 +946,7 @@ private static void initializeRealm(Realm realm) {
 
         JsonReader reader = new JsonReader(new InputStreamReader(inputStream, "UTF-8"));
         try {
-            E obj = createObject(clazz);
-            realmJson.populateUsingJsonStream(obj, reader);
-            return obj;
+            return realmJson.createUsingJsonStream(clazz, this, reader);
         } finally {
             reader.close();
         }
@@ -992,26 +970,24 @@ private static void initializeRealm(Realm realm) {
         }
         checkHasPrimaryKey(clazz);
 
-        E obj = createStandaloneRealmObjectInstance(clazz);
-        JsonReader reader = new JsonReader(new InputStreamReader(in, "UTF-8"));
+        // As we need the primary key value we have to first parse the entire input stream as in the general
+        // case that value might be the last property :(
+        Scanner scanner = null;
         try {
-            realmJson.populateUsingJsonStream(obj, reader);
-            copyToRealmOrUpdate(obj);
-        } catch (RuntimeException e) {
-            throw new RealmException("Could not create Json object from string", e);
+            scanner = getFullStringScanner(in);
+            JSONObject json = new JSONObject(scanner.next());
+            return realmJson.createOrUpdateUsingJsonObject(clazz, this, json, true);
+        } catch (JSONException e) {
+            throw new RealmException("Failed to read JSON", e);
+        } finally {
+            if (scanner != null) {
+                scanner.close();
+            }
         }
-
-        return obj;
     }
 
-    private <E extends RealmObject> E createStandaloneRealmObjectInstance(Class<E> clazz) {
-        try {
-            return clazz.newInstance();
-        } catch (InstantiationException e) {
-            throw new RealmException("Could not create an object of class: " + clazz, e);
-        } catch (IllegalAccessException e) {
-            throw new RealmException("Could not create an object of class: " + clazz, e);
-        }
+    private Scanner getFullStringScanner(InputStream in) {
+        return new Scanner(in, "UTF-8").useDelimiter("\\A");
     }
 
     /**
@@ -1057,8 +1033,29 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
      * @throws RealmException An object could not be created
      */
     public <E extends RealmObject> E createObject(Class<E> clazz) {
-        Table table;
-        table = tables.get(clazz);
+        Table table = initTable(clazz);
+        long rowIndex = table.addEmptyRow();
+        return get(clazz, rowIndex);
+    }
+
+    /**
+     * Creates a new object inside the Realm with the Primary key value initially set.
+     * If the value violates the primary key constraint, no object will be added and a
+     * {@link RealmException} will be thrown.
+     *
+     * @param clazz The Class of the object to create
+     * @param primaryKeyValue Value for the primary key field.
+     * @return The new object
+     * @throws {@link RealmException} if object could not be created.
+     */
+    <E extends RealmObject> E createObject(Class<E> clazz, Object primaryKeyValue) {
+        Table table = initTable(clazz);
+        long rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
+        return get(clazz, rowIndex);
+    }
+
+    private <E extends RealmObject> Table initTable(Class<E> clazz) {
+        Table table = tables.get(clazz);
         if (table == null) {
             Class<?> generatedClass = getProxyClass(clazz);
 
@@ -1083,8 +1080,7 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
             }
         }
 
-        long rowIndex = table.addEmptyRow();
-        return get(clazz, rowIndex);
+        return table;
     }
 
     private Class<?> getProxyClass(Class<?> clazz) {
@@ -1176,10 +1172,6 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
      */
     public <E extends RealmObject> E copyToRealm(E object) {
         checkNotNullObject(object);
-        if (isObjectInRealm(object)) {
-            return object;
-        }
-
         return copyOrUpdate(object, false);
     }
 
@@ -1196,10 +1188,6 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
     public <E extends RealmObject> E copyToRealmOrUpdate(E object) {
         checkNotNullObject(object);
         checkHasPrimaryKey(object);
-        if (isObjectInRealm(object)) {
-            return object;
-        }
-
         return copyOrUpdate(object, true);
     }
 
@@ -1298,8 +1286,8 @@ boolean contains(Class<?> clazz) {
         checkIfValid();
         Table table = getTable(clazz);
         TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
-        Long columnIndex = columnIndices.get(getClassSimpleName(clazz)).get(fieldName);
-        if (columnIndex == null || columnIndex < 0) {
+        long columnIndex = columnIndices.getColumnIndex(clazz, fieldName);
+        if (columnIndex < 0) {
             throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
         }
 
@@ -1612,10 +1600,6 @@ void setVersion(long version) {
         }
     }
 
-    private <E extends RealmObject> boolean isObjectInRealm(E object) {
-        return (object.realm != null && object.realm.id == this.id);
-    }
-
     private <E extends RealmObject> void checkNotNullObject(E object) {
         if (object == null) {
             throw new IllegalArgumentException("Null objects cannot be copied into Realm.");
@@ -1661,7 +1645,7 @@ public static synchronized void migrateRealmAtPath(String realmPath, byte[] key,
 
     /**
      * Delete the Realm file from the filesystem for the default Realm (named "default.realm").
-     * The realm must be unused and closed before calling this method.
+     * The Realm must be unused and closed before calling this method.
      * WARNING: Your Realm must not be open (typically when your app launch).
      *
      * @param context an Android {@link android.content.Context}.
@@ -1674,32 +1658,46 @@ public static boolean deleteRealmFile(Context context) {
 
     /**
      * Delete the Realm file from the filesystem for a custom named Realm.
-     * The realm must be unused and closed before calling this method.
+     * The Realm must be unused and closed before calling this method.
      *
      * @param context  an Android {@link android.content.Context}.
      * @param fileName the name of the custom Realm (i.e. "myCustomRealm.realm").
      * @return false if a file could not be deleted. The failing file will be logged.
      */
-    public static synchronized boolean deleteRealmFile(Context context, String fileName) {
+    public static boolean deleteRealmFile(Context context, String fileName) {
+        return deleteRealmFile(new File(context.getFilesDir(), fileName));
+    }
+
+    /**
+     * Delete the Realm file from the filesystem for a custom named Realm.
+     * The Realm must be unused and closed before calling this method.
+     *
+     * @param realmFile The reference to the Realm file.
+     * @return false if a file could not be deleted. The failing file will be logged.
+     */
+    public static synchronized boolean deleteRealmFile(File realmFile) {
         boolean result = true;
-        File writableFolder = context.getFilesDir();
+        File realmFolder = realmFile.getParentFile();
+        String fileName = realmFile.getName();
 
-        File realmFile = new File(writableFolder, fileName);
         int realmId = realmFile.getAbsolutePath().hashCode();
-
         AtomicInteger counter = openRealms.get(realmId);
         if (counter != null && counter.get() > 0) {
             throw new IllegalStateException("It's not allowed to delete the file associated with an open Realm. " +
                     "Remember to close() all the instances of the Realm before deleting its file.");
         }
 
-        List<File> filesToDelete = Arrays.asList(realmFile, new File(writableFolder, fileName + ".lock"));
+        List<File> filesToDelete = Arrays.asList(realmFile,
+                new File(realmFolder, fileName + ".lock"),
+                new File(realmFolder, fileName + ".lock_a"),
+                new File(realmFolder, fileName + ".lock_b"),
+                new File(realmFolder, fileName + ".log"));
         for (File fileToDelete : filesToDelete) {
             if (fileToDelete.exists()) {
                 boolean deleteResult = fileToDelete.delete();
                 if (!deleteResult) {
                     result = false;
-                    Log.w(TAG, "Could not delete the file " + fileToDelete);
+                    RealmLog.w("Could not delete the file " + fileToDelete);
                 }
             }
         }
@@ -1707,64 +1705,86 @@ public static synchronized boolean deleteRealmFile(Context context, String fileN
     }
 
     /**
-     * Compact a realm file. A realm file usually contain free/unused space.
+     * Compact a Realm file. A Realm file usually contain free/unused space.
      * This method removes this free space and the file size is thereby reduced.
-     * Objects within the realm files are untouched.
+     * Objects within the Realm files are untouched.
      * <p>
      * The file must be closed before this method is called.<br>
-     * The file system should have free space for at least a copy of the realm file.<br>
+     * The file system should have free space for at least a copy of the Realm file.<br>
      * The realm file is left untouched if any file operation fails.<br>
+     * Currently it is not possible to compact an encrypted Realm.<br>
      *
      * @param context an Android {@link android.content.Context}
      * @param fileName the name of the file to compact
+     * @param key Key for opening an encrypted Realm.
      * @return true if successful, false if any file operation failed
+     *
+     * @throws IllegalStateException if trying to compact a Realm that is already open.
      */
-    public static synchronized boolean compactRealmFile(Context context, String fileName) {
-        File realmFile = new File(context.getFilesDir(), fileName);
-        File tmpFile = new File(
-                context.getFilesDir(),
-                String.valueOf(System.currentTimeMillis()) + UUID.randomUUID() + ".realm");
+    public static synchronized boolean compactRealmFile(Context context, String fileName, byte[] key) {
+        if (key != null) {
+            throw new IllegalArgumentException("Cannot currently compact an encrypted Realm.");
+        }
 
-        Realm realm = null;
+        File realmFile = new File(context.getFilesDir(), fileName);
+        String path = realmFile.getAbsolutePath();
+        if (openRealms.get(path.hashCode()).get() > 0) {
+            throw new IllegalStateException("Cannot compact an open Realm");
+        }
+        SharedGroup sharedGroup = null;
+        boolean result = false;
         try {
-            realm = Realm.getInstance(context, fileName);
-            realm.writeCopyTo(tmpFile);
-            if (!realmFile.delete()) {
-                return false;
-            }
-            if (!tmpFile.renameTo(realmFile)) {
-                return false;
-            }
-        } catch (IOException e) {
-            return false;
+            sharedGroup = new SharedGroup(path, false, key);
+            result = sharedGroup.compact();
         } finally {
-            if (realm != null) {
-                realm.close();
+            if (sharedGroup != null) {
+                sharedGroup.close();
             }
         }
-        return true;
+        return result;
     }
 
     /**
-     * Compact a realm file. A realm file usually contain free/unused space.
+     * Compact a Realm file. A Realm file usually contain free/unused space.
      * This method removes this free space and the file size is thereby reduced.
-     * Objects within the realm files are untouched.
+     * Objects within the Realm files are untouched.
      * <p>
      * The file must be closed before this method is called.<br>
-     * The file system should have free space for at least a copy of the realm file.<br>
-     * The realm file is left untouched if any file operation fails.<br>
+     * The file system should have free space for at least a copy of the Realm file.<br>
+     * The Realm file is left untouched if any file operation fails.<br>
      *
      * @param context an Android {@link android.content.Context}
      * @return true if successful, false if any file operation failed
+     *
+     * @throws IllegalStateException if trying to compact a Realm that is already open.
      */
     public static boolean compactRealmFile(Context context) {
-        return compactRealmFile(context, DEFAULT_REALM_NAME);
+        return compactRealmFile(context, DEFAULT_REALM_NAME, null);
+    }
+
+    /**
+     * Compact a Realm file. A Realm file usually contain free/unused space.
+     * This method removes this free space and the file size is thereby reduced.
+     * Objects within the Realm files are untouched.
+     * <p>
+     * The file must be closed before this method is called.<br>
+     * The file system should have free space for at least a copy of the Realm file.<br>
+     * The Realm file is left untouched if any file operation fails.<br>
+     *
+     * @param context an Android {@link android.content.Context}
+     * @param fileName the name of the file to compact
+     * @return true if successful, false if any file operation failed
+     *
+     * @throws IllegalStateException if trying to compact a Realm that is already open.
+     */
+    public static synchronized boolean compactRealmFile(Context context, String fileName) {
+        return compactRealmFile(context, fileName, null);
     }
 
     /**
      * Returns the absolute path to where this Realm is persisted on disk.
      *
-     * @return The absolute path to the realm file.
+     * @return The absolute path to the Realm file.
      */
     public String getPath() {
         return path;
diff --git a/realm/src/main/java/io/realm/RealmList.java b/realm/src/main/java/io/realm/RealmList.java
index 429c9d33d6..26e6714a49 100644
--- a/realm/src/main/java/io/realm/RealmList.java
+++ b/realm/src/main/java/io/realm/RealmList.java
@@ -18,6 +18,7 @@
 
 import java.util.AbstractList;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 import io.realm.exceptions.RealmException;
@@ -76,11 +77,12 @@ public RealmList() {
      * @param objects Initial objects in the list.
      */
     public RealmList(E... objects) {
-        managedMode = false;
-        nonManagedList = new ArrayList<E>(objects != null ? objects.length : 0);
-        for (int i = 0; i < objects.length; i++) {
-            nonManagedList.add(objects[i]);
+        if (objects == null) {
+            throw new IllegalArgumentException("The objects argument cannot be null");
         }
+        managedMode = false;
+        nonManagedList = new ArrayList<E>(objects.length);
+        Collections.addAll(nonManagedList, objects);
     }
 
     /**
diff --git a/realm/src/main/java/io/realm/RealmQuery.java b/realm/src/main/java/io/realm/RealmQuery.java
index 1553fabfcd..76f9b08377 100644
--- a/realm/src/main/java/io/realm/RealmQuery.java
+++ b/realm/src/main/java/io/realm/RealmQuery.java
@@ -74,7 +74,7 @@ public RealmQuery(Realm realm, Class<E> clazz) {
         this.clazz = clazz;
         this.table = realm.getTable(clazz);
         this.query = table.where();
-        this.columns = Realm.columnIndices.get(clazz.getSimpleName());
+        this.columns = realm.columnIndices.getClassFields(clazz);
     }
 
     /**
@@ -89,7 +89,7 @@ public RealmQuery(RealmResults realmList, Class<E> clazz) {
         this.clazz = clazz;
         this.table = realm.getTable(clazz);
         this.query = realmList.getTable().where();
-        this.columns = Realm.columnIndices.get(clazz.getSimpleName());
+        this.columns = realm.columnIndices.getClassFields(clazz);
     }
 
     RealmQuery(Realm realm, LinkView view, Class<E> clazz) {
@@ -98,7 +98,7 @@ public RealmQuery(RealmResults realmList, Class<E> clazz) {
         this.query = view.where();
         this.view = view;
         this.table = realm.getTable(clazz);
-        this.columns = Realm.columnIndices.get(clazz.getSimpleName());
+        this.columns = realm.columnIndices.getClassFields(clazz);
     }
 
     private boolean containsDot(String s) {
@@ -169,6 +169,35 @@ private boolean containsDot(String s) {
         }
     }
 
+    /**
+     * Test if a field is null. Only works for relationships and RealmLists.
+     *
+     * @param fieldName - the field name
+     * @return The query object
+     * @throws java.lang.IllegalArgumentException if field is not a RealmObject or RealmList
+     */
+    public RealmQuery<E> isNull(String fieldName) {
+        // Currently we only support querying top-level
+        if (containsDot(fieldName)) {
+            throw new IllegalArgumentException("Checking for null in nested objects is not supported.");
+        }
+
+        // checking that fieldName has the correct type is done in C++
+        this.query.isNull(columns.get(fieldName));
+        return this;
+    }
+
+    /**
+     * Test if a field is not null. Only works for relationships and RealmLists.
+     *
+     * @param fieldName - the field name
+     * @return The query object
+     * @throws java.lang.IllegalArgumentException if field is not a RealmObject or RealmList
+     */
+    public RealmQuery<E> isNotNull(String fieldName) {
+        return this.beginGroup().not().isNull(fieldName).endGroup();
+    }
+
     // Equal
 
     /**
diff --git a/realm/src/main/java/io/realm/internal/ColumnIndices.java b/realm/src/main/java/io/realm/internal/ColumnIndices.java
new file mode 100644
index 0000000000..759c93d350
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/ColumnIndices.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+import io.realm.RealmObject;
+
+/**
+ * Utility class used to cache the mapping between object field names and their column indices.
+ */
+public class ColumnIndices {
+
+    private Map<Class<? extends RealmObject>, Map<String, Long>> classes = new HashMap<Class<? extends RealmObject>, Map<String, Long>>();
+
+    /**
+     * Add column indices from a given model class
+     */
+    public void addClass(Class<? extends RealmObject> clazz, Map<String, Long> indicies) {
+        classes.put(clazz, indicies);
+    }
+
+    /**
+     * Return mappings for the given class or null if no mapping exists.
+     */
+    public Map<String, Long> getClassFields(Class<? extends RealmObject> clazz) {
+        return classes.get(clazz);
+    }
+
+    /**
+     * Returns the column index for a given field on a clazz or -1 if no such field exists.
+     */
+    public long getColumnIndex(Class<? extends RealmObject> clazz, String fieldName) {
+        Map<String, Long> mapping = classes.get(clazz);
+        if (mapping != null) {
+            Long index = mapping.get(fieldName);
+            return (index != null) ? index : -1;
+        } else {
+            return -1;
+        }
+    }
+}
diff --git a/realm/src/main/java/io/realm/internal/Context.java b/realm/src/main/java/io/realm/internal/Context.java
index 7884eed62f..29ccb9122b 100644
--- a/realm/src/main/java/io/realm/internal/Context.java
+++ b/realm/src/main/java/io/realm/internal/Context.java
@@ -21,7 +21,7 @@
 
 class Context {
 
-    // Each group of related TightDB objects will have a Context object in the root.
+    // Each group of related Realm objects will have a Context object in the root.
     // The root can be a table, a group, or a shared group.
     // The Context object is used to store a list of native pointers 
     // whose disposal need to be handed over from the garbage 
diff --git a/realm/src/main/java/io/realm/internal/Group.java b/realm/src/main/java/io/realm/internal/Group.java
index 7d26b84234..20d724562c 100644
--- a/realm/src/main/java/io/realm/internal/Group.java
+++ b/realm/src/main/java/io/realm/internal/Group.java
@@ -32,7 +32,7 @@
     private final Context context;
 
     static {
-        TightDB.loadLibrary();
+        RealmCore.loadLibrary();
     }
 
     //
diff --git a/realm/src/main/java/io/realm/internal/TightDB.java b/realm/src/main/java/io/realm/internal/RealmCore.java
similarity index 89%
rename from realm/src/main/java/io/realm/internal/TightDB.java
rename to realm/src/main/java/io/realm/internal/RealmCore.java
index 71f667eb4a..6c02c63a75 100644
--- a/realm/src/main/java/io/realm/internal/TightDB.java
+++ b/realm/src/main/java/io/realm/internal/RealmCore.java
@@ -29,9 +29,9 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
- * Utility methods for TightDB.
+ * Utility methods for Realm Core.
  */
-public class TightDB {
+public class RealmCore {
 
 ///*
     private static final String FILE_SEP = File.separator;
@@ -47,11 +47,11 @@ private static String getJniFileName()
     {
         String os = System.getProperty("os.name").toLowerCase();
         if (os.indexOf("win") >= 0)
-            return "tightdb_jni32.dll or tightdb_jni64.dll";
+            return "realm_jni32.dll or realm_jni64.dll";
         if (os.indexOf("mac") >= 0)
-            return "libtightdb-jni.jnilib";
+            return "librealm-jni.jnilib";
         if (os.indexOf("nix") >= 0 || os.indexOf("nux") >= 0 || os.indexOf("sunos") >= 0)
-            return "libtightdb-jni.so";
+            return "librealm-jni.so";
         return "realm-jni";
     }
 */
@@ -117,7 +117,7 @@ public void run(){
         });
     }
 
-    private static void initTightDB() {
+    private static void init() {
         // Guarantee gc is done on JVM exit to clean up any native resources
         gcOnExit();
     }
@@ -127,19 +127,19 @@ public static void loadLibrary() {
             // only load library once
             return;
 
-        initTightDB();
+        init();
 
         String jnilib;
         if (osIsWindows()) {
             jnilib = loadLibraryWindows();
         }
         else {
-            String debug = System.getenv("TIGHTDB_JAVA_DEBUG");
+            String debug = System.getenv("REALM_JAVA_DEBUG");
             if (debug == null || debug.isEmpty()) {
-                jnilib = "tightdb-jni";
+                jnilib = "realm-jni";
             }
             else {
-                jnilib = "tightdb-jni-dbg";
+                jnilib = "realm-jni-dbg";
             }
             System.loadLibrary(jnilib);
         }
@@ -160,15 +160,15 @@ private static String loadLibraryWindows() {
 //*/
         // Load debug library first - if available
         String jnilib;
-        jnilib = loadCorrectLibrary("tightdb_jni32d", "tightdb_jni64d");
+        jnilib = loadCorrectLibrary("realm_jni32d", "realm_jni64d");
         if (jnilib != null) {
-            System.out.println("!!! TightDB debug version loaded. !!!\n");
+            System.out.println("!!! Realm debug version loaded. !!!\n");
         }
         else {
-            jnilib = loadCorrectLibrary("tightdb_jni32", "tightdb_jni64");
+            jnilib = loadCorrectLibrary("realm_jni32", "realm_jni64");
             if (jnilib == null) {
                 System.err.println("Searched java.library.path=" + System.getProperty("java.library.path"));
-                throw new RuntimeException("Couldn't load the TightDB JNI library 'tightdb_jni32.dll or tightdb_jni64.dll" +
+                throw new RuntimeException("Couldn't load the Realm JNI library 'realm_jni32.dll or realm_jni64.dll" +
                                            "'. Please include the directory to the library in java.library.path.");
             }
         }
diff --git a/realm/src/main/java/io/realm/internal/RealmJson.java b/realm/src/main/java/io/realm/internal/RealmJson.java
index 116b42bb9a..d421464d62 100644
--- a/realm/src/main/java/io/realm/internal/RealmJson.java
+++ b/realm/src/main/java/io/realm/internal/RealmJson.java
@@ -8,12 +8,13 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
+import io.realm.Realm;
 import io.realm.RealmObject;
 
 /**
  * Interface for classes capable of adding JSON data to both mananged and non-managed RealmObjects.
  */
 public interface RealmJson {
-    public <E extends RealmObject> void populateUsingJsonObject(E obj, JSONObject json) throws JSONException;
-    public <E extends RealmObject> void populateUsingJsonStream(E obj, JsonReader reader) throws IOException;
+    public <E extends RealmObject> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update) throws JSONException;
+    public <E extends RealmObject> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader) throws IOException;
 }
\ No newline at end of file
diff --git a/realm/src/main/java/io/realm/internal/SharedGroup.java b/realm/src/main/java/io/realm/internal/SharedGroup.java
index 4ce3b4de1a..9e1f6ca7fb 100644
--- a/realm/src/main/java/io/realm/internal/SharedGroup.java
+++ b/realm/src/main/java/io/realm/internal/SharedGroup.java
@@ -31,7 +31,7 @@
     private final Context context;
 
     static {
-        TightDB.loadLibrary();
+        RealmCore.loadLibrary();
     }
 
     public enum Durability {
@@ -223,6 +223,16 @@ public void reserve(long bytes) {
         nativeReserve(nativePtr, bytes);
     }
 
+    /**
+     * Compacts a shared group. This will block access to the shared group until done.
+     *
+     * @return True if compaction succeeded, false otherwise.
+     * @throws RuntimeException if using this within either a read or or write transaction.
+     */
+    public boolean compact() {
+        return nativeCompact(nativePtr);
+    }
+
     private native void nativeReserve(long nativePtr, long bytes);
 
     private native boolean nativeHasChanged(long nativePtr);
@@ -243,6 +253,8 @@ private native long nativeCreate(String databaseFile,
                                      boolean enableReplication,
                                      byte[] key);
 
+    private native boolean nativeCompact(long nativePtr);
+
     private void checkNativePtrNotZero() {
         if (this.nativePtr == 0) {
             throw new IOError(new RealmIOException("Realm could not be opened"));
diff --git a/realm/src/main/java/io/realm/internal/SharedGroupWithReplication.java b/realm/src/main/java/io/realm/internal/SharedGroupWithReplication.java
index c4a31b43d8..176d4b2291 100644
--- a/realm/src/main/java/io/realm/internal/SharedGroupWithReplication.java
+++ b/realm/src/main/java/io/realm/internal/SharedGroupWithReplication.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-/*package com.tightdb;
+/*package io.realm.internal;
 
 public class SharedGroupWithReplication extends SharedGroup {
 
diff --git a/realm/src/main/java/io/realm/internal/Table.java b/realm/src/main/java/io/realm/internal/Table.java
index 42d28b0af7..7a0065d51d 100644
--- a/realm/src/main/java/io/realm/internal/Table.java
+++ b/realm/src/main/java/io/realm/internal/Table.java
@@ -52,7 +52,7 @@
     protected static int TableCount = 0;
 
     static {
-        TightDB.loadLibrary();
+        RealmCore.loadLibrary();
     }
 
 
@@ -364,13 +364,12 @@ public void moveLastOver(long rowIndex) {
 
     protected native void nativeMoveLastOver(long nativeTablePtr, long rowIndex);
 
-    // Row Handling methods.
     public long addEmptyRow() {
         checkImmutable();
         if (hasPrimaryKey()) {
             long primaryKeyColumnIndex = getPrimaryKey();
             ColumnType type = getColumnType(primaryKeyColumnIndex);
-            switch(type) {
+            switch (type) {
                 case STRING:
                     if (findFirstString(primaryKeyColumnIndex, STRING_DEFAULT_VALUE) != NO_MATCH) {
                         throwDuplicatePrimaryKeyException(STRING_DEFAULT_VALUE);
@@ -390,6 +389,51 @@ public long addEmptyRow() {
         return nativeAddEmptyRow(nativePtr, 1);
     }
 
+    public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
+        checkImmutable();
+        checkHasPrimaryKey();
+        
+        long primaryKeyColumnIndex = getPrimaryKey();
+        ColumnType type = getColumnType(primaryKeyColumnIndex);
+        long rowIndex;
+        Row row;
+
+        // Add with primary key initially set
+        switch (type) {
+            case STRING:
+                if (!(primaryKeyValue instanceof String)) {
+                    throw new IllegalArgumentException("Primary key value is not a String: " + primaryKeyValue);
+                }
+                if (findFirstString(primaryKeyColumnIndex, (String)primaryKeyValue) != NO_MATCH) {
+                    throwDuplicatePrimaryKeyException(primaryKeyValue);
+                }
+                rowIndex = nativeAddEmptyRow(nativePtr, 1);
+                row = getRow(rowIndex);
+                row.setString(primaryKeyColumnIndex, (String) primaryKeyValue);
+                break;
+
+            case INTEGER:
+                long pkValue;
+                try {
+                    pkValue = new Long(primaryKeyValue.toString());
+                } catch (RuntimeException e) {
+                    throw new IllegalArgumentException("Primary key value is not a long: " + primaryKeyValue);
+                }
+                if (findFirstLong(primaryKeyColumnIndex, pkValue) != NO_MATCH) {
+                    throwDuplicatePrimaryKeyException(pkValue);
+                }
+                rowIndex = nativeAddEmptyRow(nativePtr, 1);
+                row = getRow(rowIndex);
+                row.setLong(primaryKeyColumnIndex, pkValue);
+                break;
+
+            default:
+                throw new RealmException("Cannot check for duplicate rows for unsupported primary key type: " + type);
+        }
+
+        return rowIndex;
+    }
+
     public long addEmptyRows(long rows) {
         checkImmutable();
         if (rows < 1) {
@@ -1202,6 +1246,12 @@ void checkImmutable() {
         }
     }
 
+    private void checkHasPrimaryKey() {
+        if (!hasPrimaryKey()) {
+            throw new IllegalStateException(getName() + " has no primary key defined");
+        }
+    }
+
     //
     // Aggregate functions
     //
diff --git a/realm/src/main/java/io/realm/internal/TableQuery.java b/realm/src/main/java/io/realm/internal/TableQuery.java
index 1090e6797e..e82eaa7c63 100644
--- a/realm/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/src/main/java/io/realm/internal/TableQuery.java
@@ -660,6 +660,14 @@ public Date minimumDate(long columnIndex) {
     protected native long nativeMinimumDate(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
 
+    // isNull and isNotNull
+    public TableQuery isNull(long columnIndex) {
+        nativeIsNull(nativePtr, columnIndex);
+        return this;
+    }
+
+    protected native void nativeIsNull(long nativePtr, long columnIndex);
+
     // count
 
     // TODO: Rename all start, end parameter names to firstRow, lastRow
diff --git a/realm/src/main/java/io/realm/internal/TableView.java b/realm/src/main/java/io/realm/internal/TableView.java
index f332007a2d..da409689b9 100644
--- a/realm/src/main/java/io/realm/internal/TableView.java
+++ b/realm/src/main/java/io/realm/internal/TableView.java
@@ -49,7 +49,7 @@
  *      byte[] imageData;
  *  }
  *
- * Once this class is compiled along with TightDB annotation processor
+ * Once this class is compiled along with Realm annotation processor
  * this will produce following classes.
  *
  * 1. Employee
diff --git a/realm/src/main/java/io/realm/internal/Util.java b/realm/src/main/java/io/realm/internal/Util.java
index e7c0b8dac4..3e0110f75b 100644
--- a/realm/src/main/java/io/realm/internal/Util.java
+++ b/realm/src/main/java/io/realm/internal/Util.java
@@ -21,7 +21,7 @@
 public class Util {
 
     static {
-        TightDB.loadLibrary();
+        RealmCore.loadLibrary();
     }
 
     public static long getNativeMemUsage() {
