diff --git a/CHANGELOG.md b/CHANGELOG.md
index aa00936b8d..b4917e5d97 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -4,6 +4,10 @@
 
 ### Enhancements
 
+* Added support for querying inverse relationships (#2904).
+* Moved inverse relationships out of beta stage.
+* Added `Realm.getDefaultConfiguration()` (#4725).
+
 ### Bug Fixes
 
 * [ObjectServer] Fixed a crash when an authentication error happend (#4726).
diff --git a/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java b/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java
index 3eb4afa3b9..eef7205372 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java
@@ -91,10 +91,14 @@
  * assert john.dogs.size() == 2;
  * assert fido.owners.size() == 2;
  * }
+ * <p>
+ * Querying inverse relationship is like querying any {@code RealmResults}. This means that an inverse relationship
+ * cannot be {@code null} but it can be empty (length is 0). It is possible to query fields in the source class. This is
+ * equivalent to link queries. Please read <a href="https://realm.io/docs/java/latest/#link-queries">for more
+ * information</a>.
  */
 @Retention(RetentionPolicy.CLASS)
 @Target(ElementType.FIELD)
-@Beta
 public @interface LinkingObjects {
     /**
      * The name of a field that contains a relation to an instance of the
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsQueryTests.java
index 70d5218ecc..91155ee79a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsQueryTests.java
@@ -17,7 +17,6 @@
 
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -30,7 +29,6 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-@Ignore
 @RunWith(AndroidJUnit4.class)
 public class LinkingObjectsQueryTests extends QueryTests {
 
@@ -65,6 +63,11 @@ public void query_startWithBacklink() {
 
         realm.commitTransaction();
 
+        // row 0: backlink to rows 1 and 2; row 1 link to row 0, included
+        // row 1: no backlink, not included
+        // row 2: no backlink, not included
+        // row 3: no backlink, not included
+        // summary: 1 row (gen1)
         RealmResults<AllJavaTypes> result = realm.where(AllJavaTypes.class)
                 .greaterThan(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_ID, 1)
                 .findAll();
@@ -100,12 +103,17 @@ public void query_backlinkInMiddle() {
 
         realm.commitTransaction();
 
-        // TODO: Explain what this test is doing
+        // row 0: no link, not included
+        // row 1: link to row 0, backlink to rows 1 and 2, row 2 has id < 2, included
+        // row 2: link to row 0, backlink to rows 1 and 2, row 2 has id < 2, included
+        // row 3: no link, not included
+        // summary: 2 rows (gen2A and gen2B)
         RealmResults<AllJavaTypes> result = realm.where(AllJavaTypes.class)
                 .lessThan(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_ID, 2)
                 .findAll();
-        assertEquals(1, result.size());
+        assertEquals(2, result.size());
         assertTrue(result.contains(gen2A));
+        assertTrue(result.contains(gen2B));
     }
 
     // Tests isNotNull on link's nullable field.
@@ -342,7 +350,11 @@ public void isEmpty() {
         for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
             switch (type) {
                 case LINKING_OBJECTS:
+                    // Row 0: backlink to row 0; not included
+                    // Row 1: backlink to row 1; not included
+                    // Row 2: no backlink; included
                     assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT).count());
+                    // Only row 1 has a linklist (and a backlink)
                     assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST).count());
                     break;
                 default:
@@ -357,7 +369,12 @@ public void isEmpty_acrossLink() {
         for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
             switch (type) {
                 case LINKING_OBJECTS:
+                    // Rows 0 and 1 are not included as they are linked to another row through FIELD_OBJECT
+                    // Row 2 is included (no link)
                     assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+                    // Row 0 has link to row 0 which has a backlink (list); not included
+                    // Row 1 has link to row 1 which has a backlink (list); not included
+                    // Row 2 has no link; included
                     assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_LIST).count());
                     break;
                 default:
@@ -378,9 +395,14 @@ public void isEmpty_acrossLinkingObjectObjectLink() {
                     assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_BINARY).count());
                     break;
                 case LIST:
-                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LIST).count());
+                    // Row 0: backlink to row 0, linklist is empty; included
+                    // Row 1: backlink to row 1, linklist to row 0; not included
+                    // Row 2: no backlink; included
+                    assertEquals(2, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LIST).count());
                     break;
                 case LINKING_OBJECTS:
+                    // Both row 0 and 1 have a link/backlink; not included
+                    // row 2 has no link/backlink and an empty list; included
                     assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
                     assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LO_LIST).count());
                     break;
@@ -393,20 +415,33 @@ public void isEmpty_acrossLinkingObjectObjectLink() {
     @Test
     public void isEmpty_acrossLinkingObjectListLink() {
         createIsEmptyDataSet(realm);
+        assertEquals(3, realm.where(AllJavaTypes.class).findAll().size());
         for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
             switch (type) {
                 case STRING:
+                    // Row 2 included (has no backlink)
                     assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_STRING).count());
                     break;
                 case BINARY:
+                    // Row 2 included (has no backlink)
                     assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_BINARY).count());
                     break;
                 case LIST:
                     assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LIST).count());
                     break;
                 case LINKING_OBJECTS:
-                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
-                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LO_LIST).count());
+                    // Row 0: Backlink (list) to row 1, row 1 backlink to row 1; not included
+                    // Row 1: Backlink (list) to row 2, row 2 no backlink; included
+                    // Row 2: No backlink (list); included
+                    assertEquals(2, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+
+                    // Step 1:
+                    //  Row 0 skipped; FIELD_LO_LIST.count > 0
+                    //  Row 1 included; FIELD_LO_LIST.count() == 0
+                    //
+                    // Step 2: now checking Row 2
+                    // Row 0 included: goes to Row 1 where FIELD_LO_LIST.count() == 0
+                    assertEquals(2, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LO_LIST).count());
                     break;
                 default:
                     fail("Unknown type: " + type);
@@ -420,7 +455,8 @@ public void isNotEmpty() {
         for (RealmFieldType type : SUPPORTED_IS_NOT_EMPTY_TYPES) {
             switch (type) {
                 case LINKING_OBJECTS:
-                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT).count());
+                    // Row 0 and 1 have a link/backlink so no row is empty
+                    assertEquals(0, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT).count());
                     assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST).count());
                     break;
                 default:
@@ -436,7 +472,8 @@ public void isNotEmpty_acrossLink() {
             switch (type) {
                 case LINKING_OBJECTS:
                     // tested in LinkingObjectsQueryTests;
-                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+                    // Row 0 and Row 1 have link/backlink - no empty
+                    assertEquals(0, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
                     assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_LIST).count());
                     break;
                 default:
@@ -451,6 +488,8 @@ public void isNotEmpty_acrossLinkingObjectObjectLink() {
         for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
             switch (type) {
                 case STRING:
+                    // Row 0: Follow link to row 0, and FIELD_STRING is empty ("")
+                    // Row 1: Follow link to row 1, and FIELD_STRING is not empty ("Foo")
                     assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_STRING).count());
                     break;
                 case BINARY:
@@ -460,8 +499,13 @@ public void isNotEmpty_acrossLinkingObjectObjectLink() {
                     assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LIST).count());
                     break;
                 case LINKING_OBJECTS:
-                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
-                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LO_LIST).count());
+                    // Both row 0 and 1 have a link/backlink
+                    assertEquals(2, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+
+                    // Row 0: Backlink to row 0, backlink list to row 1; included
+                    // Row 1: Backlink to row 1, backlink list to row 2; included
+                    // Row 2: No backlink; not empty
+                    assertEquals(2, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LO_LIST).count());
                     break;
                 default:
                     fail("Unknown type: " + type);
@@ -472,19 +516,30 @@ public void isNotEmpty_acrossLinkingObjectObjectLink() {
     @Test
     public void isNotEmpty_acrossLinkingObjectListLink() {
         createIsEmptyDataSet(realm);
+        assertEquals(3, realm.where(AllJavaTypes.class).findAll().size());
         for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
             switch (type) {
                 case STRING:
+                    // Row 0: Backlink list to row 1, string not empty ("Foo"); included
+                    // Row 1: Backlink list to row 2, string is empty; not included
+                    // Row 2: No backlink list; not included
                     assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_STRING).count());
                     break;
                 case BINARY:
                     assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_BINARY).count());
                     break;
                 case LIST:
-                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LIST).count());
+                    // Row 0: Backlink list to row 1, list to row 0; included
+                    // Row 1: Backlink list to row 2, list to row 1; included
+                    // Row 2: No backlink list; not included
+                    assertEquals(2, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LIST).count());
                     break;
                 case LINKING_OBJECTS:
                     assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+
+                    // Row 0: Backlink list to row 1, backlink list to row 2; included
+                    // Row 1: Backlink list to row 2, empty backlink list; not included
+                    // Row 2: Empty backlink list; not included
                     assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LO_LIST).count());
                     break;
                 default:
@@ -497,13 +552,13 @@ public void isNotEmpty_acrossLinkingObjectListLink() {
     // Creates 3 NullTypes objects. The objects are self-referenced (link) in
     // order to test link queries.
     //
-    // +-+--------+------+---------+--------+--------------------+
-    // | | string | link | numeric | binary | numeric (not null) |
-    // +-+--------+------+---------+--------+--------------------+
-    // |0| Fish   |    0 |       1 |    {0} |                  1 |
-    // |1| null   | null |    null |   null |                  0 |
-    // |2| Horse  |    1 |       3 |  {1,2} |                  3 |
-    // +-+--------+------+---------+--------+--------------------+
+    // +-+--------+------+---------+--------+--------------------+----------+
+    // | | string | link | numeric | binary | numeric (not null) | linklist |
+    // +-+--------+------+---------+--------+--------------------+----------+
+    // |0| Fish   |    0 |       1 |    {0} |                  1 |      [0] |
+    // |1| null   |    2 |    null |   null |                  0 |      [2] |
+    // |2| Horse  | null |       3 |  {1,2} |                  3 |     null |
+    // +-+--------+------+---------+--------+--------------------+----------+
     private void populateTestRealmForNullTests(Realm testRealm) {
         // 1 String
         String[] words = {"Fish", null, "Horse"};
@@ -565,8 +620,12 @@ private void populateTestRealmForNullTests(Realm testRealm) {
             nullTypesArray[i] = testRealm.copyToRealm(nullTypes);
         }
         nullTypesArray[0].setFieldObjectNull(nullTypesArray[0]);
-        nullTypesArray[1].setFieldObjectNull(null);
-        nullTypesArray[2].getFieldListNull().add(nullTypesArray[1]);
+        nullTypesArray[1].setFieldObjectNull(nullTypesArray[2]);
+        nullTypesArray[2].setFieldObjectNull(null);
+
+        nullTypesArray[0].getFieldListNull().add(nullTypesArray[1]);
+        nullTypesArray[1].getFieldListNull().add(nullTypesArray[2]);
+        nullTypesArray[2].getFieldListNull().clear(); // just to be sure
         testRealm.commitTransaction();
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/QueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/QueryTests.java
index 38e53896d9..976e31c3ea 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/QueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/QueryTests.java
@@ -53,8 +53,8 @@
         ArrayList<RealmFieldType> list = new ArrayList<>(Arrays.asList(
                 RealmFieldType.STRING,
                 RealmFieldType.BINARY,
-                RealmFieldType.LIST));
-                // TODO: LINKING_OBJECTS should be supported
+                RealmFieldType.LIST,
+                RealmFieldType.LINKING_OBJECTS));
         SUPPORTED_IS_EMPTY_TYPES = Collections.unmodifiableList(list);
         SUPPORTED_IS_NOT_EMPTY_TYPES = Collections.unmodifiableList(list);
 
@@ -63,7 +63,6 @@
         list.remove(RealmFieldType.UNSUPPORTED_MIXED);
         list.remove(RealmFieldType.UNSUPPORTED_TABLE);
         list.remove(RealmFieldType.UNSUPPORTED_DATE);
-        list.remove(RealmFieldType.LINKING_OBJECTS);
         NOT_SUPPORTED_IS_EMPTY_TYPES = Collections.unmodifiableList(list);
         NOT_SUPPORTED_IS_NOT_EMPTY_TYPES = Collections.unmodifiableList(list);
     }
@@ -92,15 +91,23 @@ protected final void createIsEmptyDataSet(Realm realm) {
         emptyValues.setFieldBinary(new byte[0]);
         emptyValues.setFieldObject(emptyValues);
         emptyValues.setFieldList(new RealmList<AllJavaTypes>());
-        realm.copyToRealm(emptyValues);
+        AllJavaTypes emptyValuesManaged = realm.copyToRealm(emptyValues);
 
         AllJavaTypes nonEmpty = new AllJavaTypes();
         nonEmpty.setFieldId(2);
         nonEmpty.setFieldString("Foo");
         nonEmpty.setFieldBinary(new byte[] {1, 2, 3});
         nonEmpty.setFieldObject(nonEmpty);
-        nonEmpty.setFieldList(new RealmList<AllJavaTypes>(emptyValues));
-        realm.copyToRealmOrUpdate(nonEmpty);
+        nonEmpty.setFieldList(new RealmList<AllJavaTypes>(emptyValuesManaged));
+        AllJavaTypes nonEmptyManaged = realm.copyToRealmOrUpdate(nonEmpty);
+
+        AllJavaTypes emptyValues2 = new AllJavaTypes();
+        emptyValues2.setFieldId(3);
+        emptyValues2.setFieldString("");
+        emptyValues2.setFieldBinary(new byte[0]);
+        emptyValues2.setFieldObject(null);
+        emptyValues2.setFieldList(new RealmList<AllJavaTypes>(nonEmptyManaged));
+        realm.copyToRealm(emptyValues2);
 
         realm.commitTransaction();
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index 4064615145..988975088a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -59,6 +59,7 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.mock;
@@ -91,15 +92,8 @@ public void tearDown() throws Exception {
         }
     }
 
-    private void clearDefaultConfiguration() throws NoSuchFieldException, IllegalAccessException {
-        final Field field = Realm.class.getDeclaredField("defaultConfiguration");
-        field.setAccessible(true);
-        field.set(null, null);
-    }
-
     @Test
-    public void setDefaultConfiguration_nullThrows() throws NoSuchFieldException, IllegalAccessException {
-        clearDefaultConfiguration();
+    public void setDefaultConfiguration_nullThrows() {
         try {
             Realm.setDefaultConfiguration(null);
             fail();
@@ -107,6 +101,26 @@ public void setDefaultConfiguration_nullThrows() throws NoSuchFieldException, Il
         }
     }
 
+    @Test
+    public void getDefaultConfiguration_returnsTheSameObjectThatSetDefaultConfigurationSet() {
+        final RealmConfiguration config = new RealmConfiguration.Builder().build();
+        Realm.setDefaultConfiguration(config);
+
+        assertSame(config, Realm.getDefaultConfiguration());
+    }
+
+    @Test
+    public void getDefaultConfiguration_returnsNullAfterRemoveDefaultConfiguration() {
+        final RealmConfiguration defaultConfiguration = Realm.getDefaultConfiguration();
+        try {
+            Realm.removeDefaultConfiguration();
+
+            assertNull(Realm.getDefaultConfiguration());
+        } finally {
+            Realm.setDefaultConfiguration(defaultConfiguration);
+        }
+    }
+
     @Test
     public void getInstance_nullConfigThrows() {
         try {
@@ -297,17 +311,16 @@ public void modules() {
     }
 
     @Test
-    public void setDefaultConfiguration() throws NoSuchFieldException, IllegalAccessException {
-        clearDefaultConfiguration();
+    public void setDefaultConfiguration() {
         Realm.setDefaultConfiguration(defaultConfig);
         realm = Realm.getDefaultInstance();
-        assertEquals(realm.getPath(), defaultConfig.getPath());
+        assertEquals(defaultConfig, realm.getConfiguration());
     }
 
     @Test
     public void getInstance() {
         realm = Realm.getInstance(defaultConfig);
-        assertEquals(realm.getPath(), defaultConfig.getPath());
+        assertEquals(defaultConfig, realm.getConfiguration());
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 0a8d50763c..e12978c71a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -18,21 +18,13 @@
 
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.After;
-import org.junit.Before;
 import org.junit.Ignore;
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
 import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Date;
-import java.util.List;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -52,9 +44,7 @@
 import io.realm.entities.PrimaryKeyAsBoxedShort;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.StringOnly;
-import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
-import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -2688,14 +2678,19 @@ public void isEmpty() {
         for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
             switch (type) {
                 case STRING:
-                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_STRING).count());
+                    assertEquals(2, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_STRING).count());
                     break;
                 case BINARY:
-                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_BINARY).count());
+                    assertEquals(2, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_BINARY).count());
                     break;
                 case LIST:
                     assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LIST).count());
                     break;
+                case LINKING_OBJECTS:
+                    // Row 2 does not have a backlink
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT).count());
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
                 default:
                     fail("Unknown type: " + type);
             }
@@ -2714,7 +2709,18 @@ public void isEmpty_acrossLink() {
                     assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY).count());
                     break;
                 case LIST:
-                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LIST).count());
+                    // Row 0: Backlink list to row 1, list to row 0; included
+                    // Row 1: Backlink list to row 2, list to row 1; included
+                    // Row 2: No backlink list; not included
+                    assertEquals(2, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LIST).count());
+                    break;
+                case LINKING_OBJECTS:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_LIST).count());
+
+                    // Row 0: Link to row 0, backlink to row 0; not included
+                    // Row 1: Link to row 1m backlink to row 1; not included
+                    // Row 2: Empty link; included
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
                     break;
                 default:
                     fail("Unknown type: " + type);
@@ -2781,6 +2787,10 @@ public void isNotEmpty() {
                 case LIST:
                     assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LIST).count());
                     break;
+                case LINKING_OBJECTS:
+                    assertEquals(2, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT).count());
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
                 default:
                     fail("Unknown type: " + type);
             }
@@ -2801,6 +2811,10 @@ public void isNotEmpty_acrossLink() {
                 case LIST:
                     assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LIST).count());
                     break;
+                case LINKING_OBJECTS:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_LIST).count());
+                    assertEquals(2, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+                    break;
                 default:
                     fail("Unknown type: " + type);
             }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
index 01158eb045..56746a003f 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
@@ -18,6 +18,7 @@
 
 #include <realm.hpp>
 #include <realm/query_expression.hpp>
+#include <realm/table.hpp>
 
 #include <shared_realm.hpp>
 #include <object_store.hpp>
@@ -66,17 +67,17 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableQuery_nativeValidateQuery(
 // If the corresponding entry in tablesArray is anything other than a nullptr, the link is a backlink.
 // In that case, the tablesArray element is the pointer to the backlink source table and the
 // indicesArray entry is the source column index in the source table.
-// FIXME!!!  This doesn't actually seem to be following backlinks.
 static TableRef getTableForLinkQuery(jlong nativeQueryPtr, JniLongArray& tablesArray, JniLongArray& indicesArray)
 {
-    TableRef table_ref = Q(nativeQueryPtr)->get_table();
+    auto table_ref = reinterpret_cast<Query *>(nativeQueryPtr)->get_table();
     jsize link_element_count = indicesArray.len() - 1;
-    for (int i = 0; i < link_element_count; i++) {
+    for (int i = 0; i < link_element_count; ++i) {
         auto col_index = size_t(indicesArray[i]);
-        auto table_ptr = TBL(tablesArray[i]);
+        auto table_ptr = reinterpret_cast<Table *>(tablesArray[i]);
         if (table_ptr == nullptr) {
             table_ref->link(col_index);
-        }  else {
+        }
+        else {
             table_ref->backlink(*table_ptr, col_index);
         }
     }
@@ -84,17 +85,22 @@ static TableRef getTableForLinkQuery(jlong nativeQueryPtr, JniLongArray& tablesA
 }
 
 // Return TableRef point to original table or the link table
-static TableRef getTableByArray(jlong nativeQueryPtr, JniLongArray& indicesArray)
+static TableRef getTableByArray(jlong nativeQueryPtr, JniLongArray& tablesArray, JniLongArray& indicesArray)
 {
-    TableRef table_ref = Q(nativeQueryPtr)->get_table();
+    auto table_ref = reinterpret_cast<Query *>(nativeQueryPtr)->get_table();
     jsize link_element_count = indicesArray.len() - 1;
-    for (int i = 0; i < link_element_count; i++) {
-        table_ref = table_ref->get_link_target(size_t(indicesArray[i]));
+    for (int i = 0; i < link_element_count; ++i) {
+        auto table_ptr = reinterpret_cast<Table *>(tablesArray[i]);
+        if (table_ptr == nullptr) {
+            table_ref = table_ref->get_link_target(static_cast<size_t>(indicesArray[i]));
+        }
+        else {
+            table_ref = TableRef(table_ptr);
+        }
     }
     return table_ref;
 }
 
-// FIXME!!!  This is a hasty attempt to fix the nullable queries.
 // I am not at all sure that it is even the right idea, let alone correct code. --gbm
 static bool isNullable(JNIEnv* env, Table* src_table_ptr, TableRef table_ref, jlong column_idx)
 {
@@ -844,7 +850,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3JZ(J
             if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Bool)) {
                 return;
             }
-            Q(nativeQueryPtr)->equal(S(index_arr[0]), value != 0 ? true : false);
+            Q(nativeQueryPtr)->equal(S(index_arr[0]), to_bool(value));
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
@@ -868,12 +874,13 @@ static void TableQuery_StringPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongA
     JniLongArray index_arr(env, columnIndexes);
     jsize arr_len = index_arr.len();
     try {
+        TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
         if (value == NULL) {
-            if (!TBL_AND_COL_NULLABLE(env, getTableByArray(nativeQueryPtr, index_arr).get(), index_arr[arr_len - 1])) {
+            if (!TBL_AND_COL_NULLABLE(env, table_ref.get(), index_arr[arr_len - 1])) {
                 return;
             }
         }
-        bool is_case_sensitive = caseSensitive ? true : false;
+        bool is_case_sensitive = to_bool(caseSensitive);
         JStringAccessor value2(env, value); // throws
         if (arr_len == 1) {
             if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_String)) {
@@ -901,7 +908,6 @@ static void TableQuery_StringPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongA
             }
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             switch (predicate) {
                 case StringEqual:
                     Q(nativeQueryPtr)
@@ -997,10 +1003,11 @@ static void TableQuery_BinaryPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongA
     JniLongArray index_arr(env, columnIndexes);
     jsize arr_len = index_arr.len();
     try {
+        TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
         JniByteArray bytes(env, value);
         BinaryData value2;
         if (value == NULL) {
-            if (!TBL_AND_COL_NULLABLE(env, getTableByArray(nativeQueryPtr, index_arr).get(), index_arr[arr_len - 1])) {
+            if (!TBL_AND_COL_NULLABLE(env, table_ref.get(), index_arr[arr_len - 1])) {
                 return;
             }
             value2 = BinaryData();
@@ -1027,7 +1034,6 @@ static void TableQuery_BinaryPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongA
             }
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             switch (predicate) {
                 case BinaryEqual:
                     Q(nativeQueryPtr)->and_query(table_ref->column<Binary>(size_t(index_arr[arr_len - 1])) == value2);
@@ -1490,21 +1496,21 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(JNIEnv* en
                                                                       jlongArray columnIndexes,
                                                                       jlongArray tablePointers)
 {
-    JniLongArray table_arr(env, tablePointers);
-    JniLongArray index_arr(env, columnIndexes);
-    jsize arr_len = index_arr.len();
-    Query* pQuery = Q(nativeQueryPtr);
     try {
-        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+        JniLongArray table_arr(env, tablePointers);
+        JniLongArray index_arr(env, columnIndexes);
+        jsize arr_len = index_arr.len();
+        auto pQuery = reinterpret_cast<Query *>(nativeQueryPtr);
+
         jlong column_idx = index_arr[arr_len - 1];
-        TableRef table_ref = getTableByArray(nativeQueryPtr, index_arr);
 
-        if (!isNullable(env, TBL(table_arr[arr_len - 1]), table_ref, column_idx)) {
+        TableRef table_ref = getTableByArray(nativeQueryPtr, table_arr, index_arr);
+        if (!isNullable(env, reinterpret_cast<Table *>(table_arr[arr_len - 1]), table_ref, column_idx)) {
             return;
         }
 
-        // FIXME!!!  Support a backlink as the last column in a field descriptor
-        int col_type = table_ref->get_column_type(S(column_idx));
+        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+        int col_type = src_table_ref->get_column_type(S(column_idx));
         if (arr_len == 1) {
             switch (col_type) {
                 case type_Link:
@@ -1530,7 +1536,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(JNIEnv* en
             }
         }
         else {
-            // FIXME!!!  Support a backlink as an internal column in a field descriptor
             switch (col_type) {
                 case type_Link:
                     ThrowException(env, IllegalArgument, "isNull() by nested query for link field is not supported.");
@@ -1621,15 +1626,16 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull(JNIEnv*
     jsize arr_len = index_arr.len();
     Query* pQuery = Q(nativeQueryPtr);
     try {
-        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
         jlong column_idx = index_arr[arr_len - 1];
-        TableRef table_ref = getTableByArray(nativeQueryPtr, index_arr);
 
+        TableRef table_ref = getTableByArray(nativeQueryPtr, table_arr, index_arr);
         if (!isNullable(env, TBL(table_arr[arr_len - 1]), table_ref, column_idx)) {
             return;
         }
 
-        int col_type = table_ref->get_column_type(S(column_idx));
+        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+
+        int col_type = src_table_ref->get_column_type(S(column_idx));
         if (arr_len == 1) {
             switch (col_type) {
                 case type_Link:
@@ -1700,25 +1706,30 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty(JNIEnv* e
     JniLongArray table_arr(env, tablePointers);
     JniLongArray index_arr(env, columnIndexes);
     jsize arr_len = index_arr.len();
-    Query* pQuery = Q(nativeQueryPtr);
+    Query* pQuery = reinterpret_cast<Query *>(nativeQueryPtr);
     try {
         TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
-        jlong column_idx = index_arr[arr_len - 1];
-        TableRef table_ref = getTableByArray(nativeQueryPtr, index_arr);
+        auto column_idx = static_cast<size_t>(index_arr[arr_len - 1]);
+
+        // Support a backlink as the last column in a field descriptor
+        Table* last = TBL(table_arr[arr_len-1]);
+        if (last != nullptr) {
+            pQuery->and_query(src_table_ref->column<BackLink>(*last, column_idx).count() == 0);
+            return;
+        }
 
-        // FIXME!!!  Support a backlink as the last column in a field descriptor
-        int col_type = table_ref->get_column_type(S(column_idx));
+        int col_type = src_table_ref->get_column_type(column_idx);
         if (arr_len == 1) {
             // Field queries
             switch (col_type) {
                 case type_Binary:
-                    pQuery->equal(S(column_idx), BinaryData("", 0));
+                    pQuery->equal(column_idx, BinaryData("", 0));
                     break;
                 case type_LinkList:
-                    pQuery->and_query(table_ref->column<LinkList>(S(column_idx)).count() == 0);
+                    pQuery->and_query(src_table_ref->column<LinkList>(column_idx).count() == 0);
                     break;
                 case type_String:
-                    pQuery->equal(S(column_idx), "");
+                    pQuery->equal(column_idx, "");
                     break;
                 case type_Link:
                 case type_Bool:
@@ -1733,16 +1744,15 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty(JNIEnv* e
         }
         else {
             // Linked queries
-            // FIXME!!!  Support a backlink as an internal column in a field descriptor
             switch (col_type) {
                 case type_Binary:
-                    pQuery->and_query(src_table_ref->column<Binary>(S(column_idx)) == BinaryData("", 0));
+                    pQuery->and_query(src_table_ref->column<Binary>(column_idx) == BinaryData("", 0));
                     break;
                 case type_LinkList:
-                    pQuery->and_query(src_table_ref->column<LinkList>(S(column_idx)).count() == 0);
+                    pQuery->and_query(src_table_ref->column<LinkList>(column_idx).count() == 0);
                     break;
                 case type_String:
-                    pQuery->and_query(src_table_ref->column<String>(S(column_idx)) == "");
+                    pQuery->and_query(src_table_ref->column<String>(column_idx) == "");
                     break;
                 case type_Link:
                 case type_Bool:
@@ -1760,6 +1770,76 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty(JNIEnv* e
     CATCH_STD()
 }
 
+JNIEXPORT void JNICALL
+Java_io_realm_internal_TableQuery_nativeIsNotEmpty(JNIEnv *env, jobject, jlong nativeQueryPtr,
+                                                   jlongArray columnIndexes, jlongArray tablePointers) {
+    JniLongArray table_arr(env, tablePointers);
+    JniLongArray index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.len();
+    Query* pQuery = reinterpret_cast<Query *>(nativeQueryPtr);
+    try {
+        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+        auto column_idx = static_cast<size_t>(index_arr[arr_len - 1]);
+
+        // Support a backlink as the last column in a field descriptor
+        auto last = reinterpret_cast<Table *>(table_arr[arr_len-1]);
+        if (last != nullptr) {
+            pQuery->and_query(src_table_ref->column<BackLink>(*last, column_idx).count() != 0);
+            return;
+        }
+
+        int col_type = src_table_ref->get_column_type(column_idx);
+        if (arr_len == 1) {
+            // Field queries
+            switch (col_type) {
+                case type_Binary:
+                    pQuery->not_equal(column_idx, BinaryData("", 0));
+                    break;
+                case type_LinkList:
+                    pQuery->and_query(src_table_ref->column<LinkList>(column_idx).count() != 0);
+                    break;
+                case type_String:
+                    pQuery->not_equal(column_idx, "");
+                    break;
+                case type_Link:
+                case type_Bool:
+                case type_Int:
+                case type_Float:
+                case type_Double:
+                case type_Timestamp:
+                default:
+                    ThrowException(env, IllegalArgument, "isNotEmpty() only works on String, byte[] and RealmList.");
+                    return;
+            }
+        }
+        else {
+            // Linked queries
+            switch (col_type) {
+                case type_Binary:
+                    pQuery->and_query(src_table_ref->column<Binary>(column_idx) != BinaryData("", 0));
+                    break;
+                case type_LinkList:
+                    pQuery->and_query(src_table_ref->column<LinkList>(column_idx).count() != 0);
+                    break;
+                case type_String:
+                    pQuery->and_query(src_table_ref->column<String>(column_idx) != "");
+                    break;
+                case type_Link:
+                case type_Bool:
+                case type_Int:
+                case type_Float:
+                case type_Double:
+                case type_Timestamp:
+                default:
+                    ThrowException(env, IllegalArgument,
+                                   "isNotEmpty() only works on String, byte[] and RealmList across links.");
+                    return;
+            }
+        }
+    }
+    CATCH_STD()
+}
+
 static void finalize_table_query(jlong ptr)
 {
     TR_ENTER_PTR(ptr)
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 35c1f89afc..ffd129701f 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -38,7 +38,6 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Scanner;
@@ -134,6 +133,8 @@
 
     public static final String DEFAULT_REALM_NAME = RealmConfiguration.DEFAULT_REALM_NAME;
 
+    private static final Object defaultConfigurationLock = new Object();
+    // guarded by `defaultConfigurationLock`
     private static RealmConfiguration defaultConfiguration;
 
     /**
@@ -195,7 +196,7 @@ public static synchronized void init(Context context) {
             }
             checkFilesDirAvailable(context);
             RealmCore.loadLibrary(context);
-            defaultConfiguration = new RealmConfiguration.Builder(context).build();
+            setDefaultConfiguration(new RealmConfiguration.Builder(context).build());
             ObjectServerFacade.getSyncFacadeIfPossible().init(context);
             BaseRealm.applicationContext = context.getApplicationContext();
             SharedRealm.initialize(new File(context.getFilesDir(), ".realm.temp"));
@@ -267,10 +268,15 @@ private static void checkFilesDirAvailable(Context context) {
      * was set and the thread opening the Realm was interrupted while the download was in progress.
      */
     public static Realm getDefaultInstance() {
-        if (defaultConfiguration == null) {
-            throw new IllegalStateException("Call `Realm.init(Context)` before calling this method.");
+        RealmConfiguration configuration = getDefaultConfiguration();
+        if (configuration == null) {
+            if (BaseRealm.applicationContext == null) {
+                throw new IllegalStateException("Call `Realm.init(Context)` before calling this method.");
+            } else {
+                throw new IllegalStateException("Set default configuration by using `Realm.setDefaultConfiguration(RealmConfiguration)`.");
+            }
         }
-        return RealmCache.createRealmOrGetFromCache(defaultConfiguration, Realm.class);
+        return RealmCache.createRealmOrGetFromCache(configuration, Realm.class);
     }
 
     /**
@@ -325,7 +331,20 @@ public static void setDefaultConfiguration(RealmConfiguration configuration) {
         if (configuration == null) {
             throw new IllegalArgumentException("A non-null RealmConfiguration must be provided");
         }
-        defaultConfiguration = configuration;
+        synchronized (defaultConfigurationLock) {
+            defaultConfiguration = configuration;
+        }
+    }
+
+    /**
+     * Returns the default configuration for {@link #getDefaultInstance()}.
+     *
+     * @return default configuration object or {@code null} if no default configuration is specified.
+     */
+    public static RealmConfiguration getDefaultConfiguration() {
+        synchronized (defaultConfigurationLock) {
+            return defaultConfiguration;
+        }
     }
 
     /**
@@ -333,7 +352,9 @@ public static void setDefaultConfiguration(RealmConfiguration configuration) {
      * fail until a new default configuration has been set using {@link #setDefaultConfiguration(RealmConfiguration)}.
      */
     public static void removeDefaultConfiguration() {
-        defaultConfiguration = null;
+        synchronized (defaultConfigurationLock) {
+            defaultConfiguration = null;
+        }
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
index c612bb6744..29ac82eb1c 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
@@ -245,9 +245,9 @@ protected final long addColumnDetails(Table table, String columnName, RealmField
      */
     @SuppressWarnings("unused")
     protected final void addBacklinkDetails(SharedRealm realm, String columnName, String sourceTableName, String sourceColumnName) {
-//        Table sourceTable = realm.getTable(Table.getTableNameForClass(sourceTableName));
-//        long columnIndex = sourceTable.getColumnIndex(sourceColumnName);
-//        indicesMap.put(columnName, new ColumnDetails(columnIndex, RealmFieldType.LINKING_OBJECTS, sourceTableName));
+        Table sourceTable = realm.getTable(Table.getTableNameForClass(sourceTableName));
+        long columnIndex = sourceTable.getColumnIndex(sourceColumnName);
+        indicesMap.put(columnName, new ColumnDetails(columnIndex, RealmFieldType.LINKING_OBJECTS, sourceTableName));
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
index f29688f891..e953656ce4 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
@@ -396,7 +396,9 @@ public TableQuery isEmpty(long[] columnIndices, long[] tablePtrs) {
     }
 
     public TableQuery isNotEmpty(long[] columnIndices, long[] tablePtrs) {
-        return not().isEmpty(columnIndices, tablePtrs);
+        nativeIsNotEmpty(nativePtr, columnIndices, tablePtrs);
+        queryValidated = false;
+        return this;
     }
 
     // Searching methods.
@@ -737,6 +739,8 @@ private void throwImmutable() {
 
     private native void nativeIsEmpty(long nativePtr, long[] columnIndices, long[] tablePtrs);
 
+    private native void nativeIsNotEmpty(long nativePtr, long[] columnIndices, long[] tablePtrs);
+
     private native long nativeFind(long nativeQueryPtr, long fromTableRow);
 
     private native long nativeFindAll(long nativeQueryPtr, long start, long end, long limit);
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index b1d1336a8c..4724b9c7d5 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -828,7 +828,7 @@ public SyncConfiguration build() {
                     String fileName = serverCertificateAssetName.substring(serverCertificateAssetName.lastIndexOf(File.separatorChar) + 1);
                     serverCertificateFilePath = new File(realmFileDirectory, fileName).getAbsolutePath();
                 } else {
-                    RealmLog.warn("SSL Verification is disable, server certificate provided will not be used");
+                    RealmLog.warn("SSL Verification is disabled, the provided server certificate will not be used.");
                 }
             }
 
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
index b64c5c69cd..82c024fb2f 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
@@ -182,7 +182,8 @@ public void combining_trustedRootCA_and_withoutSSLVerification_willThrow() {
                 .disableSSLVerification()
                 .build();
 
-        assertEquals("SSL Verification is disable, server certificate provided will not be used", testLogger.message);
+        assertEquals("SSL Verification is disabled, the provided server certificate will not be used.",
+                testLogger.message);
     }
 
     @Test
