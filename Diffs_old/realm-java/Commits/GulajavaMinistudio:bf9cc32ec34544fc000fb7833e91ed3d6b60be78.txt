diff --git a/CHANGELOG.md b/CHANGELOG.md
index 9134f567ec..d27d6508c8 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -12,6 +12,12 @@
 
 ### Internal
 
+## 3.1.4
+
+## Bug fixes
+
+* Added missing row validation check in certain cases on invalidated/deleted objects (#4540).
+
 ## 3.1.3 (2017-04-20)
 
 ### Enhancements
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index 24bd82fda5..4d4c051258 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -137,6 +137,7 @@ public void onSuccess() {
                 Realm newRealm = Realm.getInstance(looperThread.realmConfiguration);
                 assertEquals(1, newRealm.where(Owner.class).count());
                 assertEquals("Owner", newRealm.where(Owner.class).findFirst().getName());
+                newRealm.close();
                 looperThread.testComplete();
             }
         });
@@ -186,6 +187,7 @@ public void onError(Throwable error) {
                 assertEquals(0, newRealm.where(Owner.class).count());
                 assertNull(newRealm.where(Owner.class).findFirst());
                 assertEquals(runtimeException, error);
+                newRealm.close();
                 looperThread.testComplete();
             }
         });
@@ -368,32 +370,40 @@ public void onError(Throwable error) {
     public void executeTransactionAsync_onSuccessOnNonLooperThreadThrows() {
         Realm realm = Realm.getInstance(configFactory.createConfiguration());
         thrown.expect(IllegalStateException.class);
-        realm.executeTransactionAsync(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
+        try {
+            realm.executeTransactionAsync(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
 
-            }
-        }, new Realm.Transaction.OnSuccess() {
-            @Override
-            public void onSuccess() {
-            }
-        });
+                }
+            }, new Realm.Transaction.OnSuccess() {
+                @Override
+                public void onSuccess() {
+                }
+            });
+        } finally {
+            realm.close();
+        }
     }
 
     @Test
     public void executeTransactionAsync_onErrorOnNonLooperThreadThrows() {
         Realm realm = Realm.getInstance(configFactory.createConfiguration());
         thrown.expect(IllegalStateException.class);
-        realm.executeTransactionAsync(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
+        try {
+            realm.executeTransactionAsync(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
 
-            }
-        }, new Realm.Transaction.OnError() {
-            @Override
-            public void onError(Throwable error) {
-            }
-        });
+                }
+            }, new Realm.Transaction.OnError() {
+                @Override
+                public void onError(Throwable error) {
+                }
+            });
+        } finally {
+            realm.close();
+        }
     }
 
     // ************************************
diff --git a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
index 6e95a08106..e20ec38079 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
@@ -30,6 +30,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.entities.AllTypes;
+import io.realm.entities.StringOnly;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -58,6 +59,9 @@
     private final static Sort[] ORDER_ASC_ASC = {Sort.ASCENDING, Sort.ASCENDING};
     private final static Sort[] ORDER_ASC_DES = {Sort.ASCENDING, Sort.DESCENDING};
 
+    private static String chars;
+    private int numberOfPermutations;
+
     private void populateRealm(Realm realm) {
         realm.beginTransaction();
         realm.delete(AllTypes.class);
@@ -516,4 +520,61 @@ public void onChange(RealmResults<AllTypes> element) {
         allTypes.setColumnDate(new Date(TEST_SIZE));
         realm.commitTransaction();
     }
+
+    private void createAndTest(String str) {
+        realm.beginTransaction();
+        realm.delete(StringOnly.class);
+        for (int i = 0; i < str.length(); i++) {
+            StringOnly stringOnly = realm.createObject(StringOnly.class);
+            stringOnly.setChars(str.substring(i, i + 1));
+        }
+        realm.commitTransaction();
+        RealmResults<StringOnly> stringOnlies = realm.where(StringOnly.class).findAllSorted("chars");
+        for (int i = 0; i < chars.length(); i++) {
+            assertEquals(chars.substring(i, i + 1), stringOnlies.get(i).getChars());
+        }
+    }
+
+    // permute and swap: http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/
+    private void permute(String str, int l, int r) {
+        if (l == r) {
+            numberOfPermutations++;
+            createAndTest(str);
+        } else {
+            for (int i = l; i <= r; i++) {
+                str = swap(str,l,i);
+                permute(str, l+1, r);
+                str = swap(str,l,i);
+            }
+        }
+    }
+
+    private String swap(String a, int i, int j) {
+        char temp;
+        char[] charArray = a.toCharArray();
+        temp = charArray[i] ;
+        charArray[i] = charArray[j];
+        charArray[j] = temp;
+        return String.valueOf(charArray);
+    }
+
+    private int factorial(int n) {
+        int fac = 1;
+        for(int i = 1; i <= n; i++) {
+            fac *= i;
+        }
+        return fac;
+    }
+
+    @Test
+    public void sortCaseSensitive() {
+        chars = "'- !\"#$%&()*,./:;?_+<=>123aAbBcCxXyYzZ";
+        createAndTest(new StringBuffer(chars).reverse().toString());
+
+        // try all permutations - keep the list short
+        chars = "12aAbB";
+        numberOfPermutations = 0;
+        permute(chars, 0, chars.length()-1);
+        assertEquals(numberOfPermutations, factorial(chars.length()));
+    }
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
index bdb36b7709..8b491db0b4 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
@@ -385,11 +385,19 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeHasColumn(J
     return to_jbool(ndx != to_jlong_or_not_found(realm::not_found));
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNull(JNIEnv*, jobject, jlong nativeRowPtr,
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNull(JNIEnv* env, jobject, jlong nativeRowPtr,
                                                                             jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    return to_jbool(ROW(nativeRowPtr)->is_null(columnIndex));
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
+        return JNI_FALSE;
+    }
+
+    try {
+        return to_jbool(ROW(nativeRowPtr)->is_null(columnIndex));
+    }
+    CATCH_STD()
+    return JNI_FALSE;
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetNull(JNIEnv* env, jobject, jlong nativeRowPtr,
