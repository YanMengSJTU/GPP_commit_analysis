diff --git a/CHANGELOG.md b/CHANGELOG.md
index 771001e515..1f0570ff09 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -39,6 +39,7 @@
 
 * [ObjectServer] `SyncUserInfo` now also exposes a users metadata using `SyncUserInfo.getMetadata()`
 * Minor performance improvement when copy/insert objects into Realm.
+* [ObjectServer] Added preview support for partial synchronization (#5276). This feature is in `@Beta` and will probably change.
 
 ### Bug Fixes
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmListForValueTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmListForValueTests.java
index 0e8cddf5d4..3518becf0a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmListForValueTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmListForValueTests.java
@@ -900,7 +900,7 @@ public void execute(Realm realm) {
         list.size();
     }
 
-    @Test(expected = IllegalStateException.class)
+    @Test(expected = UnsupportedOperationException.class)
     public void where() {
         list.where();
     }
@@ -1556,7 +1556,7 @@ public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionCh
 
     @Test
     public void createSnapshot() {
-        thrown.expect(IllegalStateException.class);
+        thrown.expect(UnsupportedOperationException.class);
         thrown.expectMessage(is(RealmList.ALLOWED_ONLY_FOR_REALM_MODEL_ELEMENT_MESSAGE));
         list.createSnapshot();
     }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
index a7fff7a2ef..b2aaa7cc5a 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
@@ -40,7 +40,7 @@ public void setUp() {
     @Test
     public void realmLogin() throws URISyntaxException, JSONException {
         Token t = SyncTestUtils.createTestUser().getRefreshToken();
-        AuthenticateRequest request = AuthenticateRequest.realmLogin(t, new URI("realm://objectserver/" + t.identity() + "/default"));
+        AuthenticateRequest request = AuthenticateRequest.realmLogin(t, new URI("realm://objectserver/" + t.identity() + "/default").getPath());
 
         JSONObject obj = new JSONObject(request.toJson());
         assertEquals("/" + t.identity() + "/default", obj.get("path"));
@@ -61,7 +61,7 @@ public void userLogin() throws URISyntaxException, JSONException {
     @Test
     public void userRefresh() throws URISyntaxException, JSONException {
         Token t = SyncTestUtils.createTestUser().getRefreshToken();
-        AuthenticateRequest request = AuthenticateRequest.userRefresh(t, new URI("realm://objectserver/" + t.identity() + "/default"));
+        AuthenticateRequest request = AuthenticateRequest.userRefresh(t, new URI("realm://objectserver/" + t.identity() + "/default").getPath());
 
         JSONObject obj = new JSONObject(request.toJson());
         assertTrue(obj.has("path"));
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
index a113c1479d..20c8f764cd 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
@@ -63,7 +63,8 @@ JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeRefreshAccessToken(JN
         if (session) {
             JStringAccessor access_token(env, j_access_token);
             JStringAccessor realm_url(env, j_sync_realm_url);
-            session->refresh_access_token(access_token, std::string(realm_url));
+
+            session->refresh_access_token(access_token, std::string(session->config().realm_url()));
             return JNI_TRUE;
         }
         else {
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
index 68fe07ac89..9a891e070e 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
@@ -247,9 +247,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeEnableChangeNo
 }
 
 #if REALM_ENABLE_SYNC
-JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeCreateAndSetSyncConfig(
+JNIEXPORT jstring JNICALL Java_io_realm_internal_OsRealmConfig_nativeCreateAndSetSyncConfig(
     JNIEnv* env, jclass, jlong native_ptr, jstring j_sync_realm_url, jstring j_auth_url, jstring j_user_id,
-    jstring j_reresh_token, jbyte j_session_stop_policy)
+    jstring j_refresh_token, jboolean j_is_partial, jbyte j_session_stop_policy)
 {
     TR_ENTER_PTR(native_ptr)
     auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
@@ -310,7 +310,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeCreateAndSetSy
         std::shared_ptr<SyncUser> user = SyncManager::shared().get_existing_logged_in_user(sync_user_identifier);
         if (!user) {
             JStringAccessor realm_auth_url(env, j_auth_url);
-            JStringAccessor refresh_token(env, j_reresh_token);
+            JStringAccessor refresh_token(env, j_refresh_token);
             user = SyncManager::shared().get_user(sync_user_identifier, refresh_token);
         }
 
@@ -326,8 +326,13 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeCreateAndSetSy
         config.sync_config = std::make_shared<SyncConfig>(SyncConfig{
             user, realm_url, session_stop_policy, std::move(bind_handler), std::move(error_handler),
             nullptr, sync_encryption_key});
+        config.sync_config->is_partial = (j_is_partial == JNI_TRUE);
+
+        return to_jstring(env, config.sync_config->realm_url().c_str());
+
     }
     CATCH_STD()
+    return nullptr;
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetSyncConfigSslSettings(
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
index 474a4c54cd..9649f18563 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -19,6 +19,10 @@
 #include "object-store/src/sync/sync_manager.hpp"
 #include "object-store/src/sync/sync_config.hpp"
 #include "object-store/src/sync/sync_session.hpp"
+#include "object-store/src/results.hpp"
+#include "object-store/src/sync/partial_sync.hpp"
+
+#include "observable_collection_wrapper.hpp"
 #endif
 
 #include <realm/util/assert.hpp>
@@ -41,6 +45,10 @@ using namespace realm::jni_util;
 
 static const char* c_table_name_exists_exception_msg = "Class already exists: '%1'.";
 
+#if REALM_ENABLE_SYNC // used only for partial sync now
+typedef ObservableCollectionWrapper<Results> ResultsWrapper;
+#endif
+
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeInit(JNIEnv* env, jclass,
                                                                      jstring temporary_directory_path)
 {
@@ -501,3 +509,53 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeRegisterSchemaCh
         java_binding_context.set_schema_changed_callback(env, j_schema_changed_callback);
     }
 }
+
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeRegisterPartialSyncQuery(
+    REALM_UNUSED JNIEnv* env, REALM_UNUSED jobject j_shared_realm_instance, REALM_UNUSED jlong shared_realm_ptr, REALM_UNUSED jstring j_class_name,
+    REALM_UNUSED jstring j_query, REALM_UNUSED jobject j_callback)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+#if REALM_ENABLE_SYNC
+
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        JStringAccessor class_name(env, j_class_name);               // throws
+        JStringAccessor query(env, j_query);                         // throws
+
+        // The lambda will capture the copied reference and it will be unreferenced when the lambda's life cycle is over.
+        // That happens when the Realm is closed or the callback has been triggered once.
+        JavaGlobalRef j_callback_ref(env, j_callback);
+        JavaGlobalWeakRef j_shared_realm_instance_ref(env, j_shared_realm_instance);
+
+        static JavaClass shared_realm_class(env, "io/realm/internal/SharedRealm");
+        static JavaMethod partial_sync_cb(env, shared_realm_class, "runPartialSyncRegistrationCallback",
+                                          "(Ljava/lang/String;JLio/realm/internal/SharedRealm$PartialSyncCallback;)V");
+
+        auto cb = [j_callback_ref, j_shared_realm_instance_ref](Results results, std::exception_ptr err) {
+            JNIEnv* env = JniUtils::get_env(true);
+            j_shared_realm_instance_ref.call_with_local_ref(env, [&](JNIEnv*, jobject row_obj) {
+                if (err) {
+                    try {
+                        std::rethrow_exception(err);
+                    }
+                    catch (const std::exception& e) {
+                        env->CallVoidMethod(row_obj, partial_sync_cb, to_jstring(env, e.what()),
+                                            reinterpret_cast<jlong>(nullptr), j_callback_ref.get());
+                    }
+                    return;
+                }
+
+                auto wrapper = new ResultsWrapper(results);
+                env->CallVoidMethod(row_obj, partial_sync_cb, nullptr, reinterpret_cast<jlong>(wrapper),
+                                    j_callback_ref.get());
+            });
+        };
+
+        partial_sync::register_query(shared_realm, class_name, query, std::move(cb));
+    }
+    CATCH_STD()
+#else
+    REALM_TERMINATE("Unsupported operation. Only available when used with the Realm Object Server");
+#endif
+}
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 6644275d38..b5416f96e4 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -46,9 +46,10 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import io.reactivex.Flowable;
 import javax.annotation.Nullable;
 
+import io.reactivex.Flowable;
+import io.realm.annotations.Beta;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
@@ -1684,6 +1685,44 @@ public static boolean compactRealm(RealmConfiguration configuration) {
         return BaseRealm.compactRealm(configuration);
     }
 
+    /**
+     * If the Realm is a partially synchronized Realm, fetch and synchronize the objects of a given
+     * object type that match the given query (in string format).
+     *
+     * The results will be returned asynchronously in the callback.
+     *
+     * @param clazz the class to query.
+     * @param query string query.
+     * @param callback A callback used to vend the results of a partial sync fetch.
+     * @throws IllegalStateException if it is called from a non-Looper or {@link IntentService} thread.
+     * @throws IllegalStateException if called from a non-synchronized (Realm Object Server) Realm.
+     */
+    @Beta
+    public <E extends RealmModel> void subscribeToObjects(final Class<E> clazz, String query, final PartialSyncCallback<E> callback) {
+        checkIfValid();
+        if (!configuration.isSyncConfiguration()) {
+            throw new IllegalStateException("Partial sync is only available for synchronized Realm (Realm Object Server)");
+        }
+
+        sharedRealm.capabilities.checkCanDeliverNotification(BaseRealm.LISTENER_NOT_ALLOWED_MESSAGE);
+
+        String className = configuration.getSchemaMediator().getSimpleClassName(clazz);
+        SharedRealm.PartialSyncCallback internalCallback = new SharedRealm.PartialSyncCallback(className) {
+            @Override
+            public void onSuccess(io.realm.internal.Collection osResults) {
+                RealmResults<E> results = new RealmResults<>(Realm.this, osResults, clazz);
+                callback.onSuccess(results);
+            }
+
+            @Override
+            public void onError(RealmException error) {
+                callback.onError(error);
+            }
+        };
+
+        sharedRealm.registerPartialSyncQuery(query, internalCallback);
+    }
+
     Table getTable(Class<? extends RealmModel> clazz) {
         return schema.getTable(clazz);
     }
@@ -1800,4 +1839,9 @@ public void onError(Throwable exception) {
             super.onError(exception);
         }
     }
+
+    public static abstract class PartialSyncCallback<T extends RealmModel> {
+        public abstract void onSuccess(RealmResults<T> results);
+        public abstract void onError(RealmException error);
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index 7bcbe78c35..0b0ef1e75e 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -576,7 +576,7 @@ public int size() {
         if (isManaged()) {
             checkValidRealm();
             if (!osListOperator.forRealmModel()) {
-                throw new IllegalStateException(ALLOWED_ONLY_FOR_REALM_MODEL_ELEMENT_MESSAGE);
+                throw new UnsupportedOperationException(ALLOWED_ONLY_FOR_REALM_MODEL_ELEMENT_MESSAGE);
             }
             return RealmQuery.createQueryFromList(this);
         } else {
@@ -755,7 +755,7 @@ private void checkValidRealm() {
         }
         checkValidRealm();
         if (!osListOperator.forRealmModel()) {
-            throw new IllegalStateException(ALLOWED_ONLY_FOR_REALM_MODEL_ELEMENT_MESSAGE);
+            throw new UnsupportedOperationException(ALLOWED_ONLY_FOR_REALM_MODEL_ELEMENT_MESSAGE);
         }
         if (className != null) {
             return new OrderedRealmCollectionSnapshot<>(
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
index b4cf5a0e4d..2e4cce938a 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 
 import java.lang.reflect.InvocationTargetException;
+import java.net.URI;
 
 import io.realm.RealmConfiguration;
 import io.realm.exceptions.RealmException;
@@ -67,7 +68,7 @@ public void realmClosed(RealmConfiguration configuration) {
     }
 
     public Object[] getUserAndServerUrl(RealmConfiguration config) {
-        return new Object[7];
+        return new Object[8];
     }
 
     public static ObjectServerFacade getFacade(boolean needSyncFacade) {
@@ -86,7 +87,7 @@ public static ObjectServerFacade getSyncFacadeIfPossible() {
     }
 
     // If no session yet exists for this path. Wrap a new Java Session around an existing OS one.
-    public void wrapObjectStoreSessionIfRequired(RealmConfiguration config) {
+    public void wrapObjectStoreSessionIfRequired(OsRealmConfig config) {
     }
 
     public String getSyncServerCertificateAssetName(RealmConfiguration config) {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
index 3ff9eeb4de..afc199fe72 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
@@ -16,10 +16,14 @@
 
 package io.realm.internal;
 
+import java.net.URI;
+import java.net.URISyntaxException;
+
 import javax.annotation.Nullable;
 
 import io.realm.CompactOnLaunchCallback;
 import io.realm.RealmConfiguration;
+import io.realm.log.RealmLog;
 
 /**
  * Java wrapper of Object Store's Realm::Config.
@@ -157,6 +161,7 @@ OsRealmConfig build() {
     private final static long nativeFinalizerPtr = nativeGetFinalizerPtr();
 
     private final RealmConfiguration realmConfiguration;
+    private final URI resolvedRealmURI;
     private final long nativePtr;
     // Every SharedRealm instance has to be created from an OsRealmConfig instance. And the SharedRealm's NativeContext
     // object will be the same as the context here. This is because of we may create different SharedRealm instances
@@ -192,6 +197,7 @@ private OsRealmConfig(final RealmConfiguration config,
         boolean syncClientValidateSsl = (Boolean.TRUE.equals(syncConfigurationOptions[4]));
         String syncSslTrustCertificatePath = (String) syncConfigurationOptions[5];
         Byte sessionStopPolicy = (Byte) syncConfigurationOptions[6];
+        boolean isPartial = (Boolean.TRUE.equals(syncConfigurationOptions[7]));
 
         // Set encryption key
         byte[] key = config.getEncryptionKey();
@@ -232,12 +238,20 @@ private OsRealmConfig(final RealmConfiguration config,
         if (initializationCallback != null) {
             nativeSetInitializationCallback(nativePtr, initializationCallback);
         }
+
+        URI resolvedRealmURI  = null;
         // Set sync config
         if (syncRealmUrl != null) {
-            nativeCreateAndSetSyncConfig(nativePtr, syncRealmUrl, syncRealmAuthUrl, syncUserIdentifier,
-                    syncRefreshToken, sessionStopPolicy);
+            String resolvedSyncRealmUrl = nativeCreateAndSetSyncConfig(nativePtr, syncRealmUrl, syncRealmAuthUrl, syncUserIdentifier,
+                    syncRefreshToken, isPartial, sessionStopPolicy);
+            try {
+                resolvedRealmURI = new URI(resolvedSyncRealmUrl);
+            } catch (URISyntaxException e) {
+                RealmLog.error(e, "Cannot create a URI from the Realm URL address");
+            }
             nativeSetSyncConfigSslSettings(nativePtr, syncClientValidateSsl, syncSslTrustCertificatePath);
         }
+        this.resolvedRealmURI = resolvedRealmURI;
     }
 
     @Override
@@ -254,6 +268,10 @@ public RealmConfiguration getRealmConfiguration() {
         return realmConfiguration;
     }
 
+    public URI getResolvedRealmURI() {
+        return resolvedRealmURI;
+    }
+
     NativeContext getContext() {
         return context;
     }
@@ -274,8 +292,8 @@ private native void nativeSetSchemaConfig(long nativePtr, byte schemaMode, long
 
     private static native void nativeEnableChangeNotification(long nativePtr, boolean enableNotification);
 
-    private static native void nativeCreateAndSetSyncConfig(long nativePtr, String syncRealmUrl,
-                                                            String authUrl, String userId, String refreshToken, byte sessionStopPolicy);
+    private static native String nativeCreateAndSetSyncConfig(long nativePtr, String syncRealmUrl,
+                                                            String authUrl, String userId, String refreshToken, boolean isPartial, byte sessionStopPolicy);
 
     private static native void nativeSetSyncConfigSslSettings(long nativePtr,
                                                               boolean validateSsl, String trustCertificatePath);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 13ac86c7d8..32a52cc644 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -26,6 +26,7 @@
 import javax.annotation.Nullable;
 
 import io.realm.RealmConfiguration;
+import io.realm.exceptions.RealmException;
 import io.realm.internal.android.AndroidCapabilities;
 import io.realm.internal.android.AndroidRealmNotifier;
 
@@ -166,6 +167,21 @@ public int hashCode() {
         void onSchemaChanged();
     }
 
+    /**
+     * Callback function to be called from JNI by Object Store when the partial sync results returned.
+     */
+    @Keep
+    public abstract static class PartialSyncCallback {
+        private final String className;
+
+        protected PartialSyncCallback(String className) {
+            this.className = className;
+        }
+
+        public abstract void onSuccess(Collection results);
+        public abstract void onError(RealmException error);
+    }
+
     private final OsRealmConfig osRealmConfig;
     private final long nativePtr;
     final NativeContext context;
@@ -220,7 +236,7 @@ public static SharedRealm getInstance(RealmConfiguration config) {
      */
     public static SharedRealm getInstance(OsRealmConfig.Builder configBuilder) {
         OsRealmConfig osRealmConfig = configBuilder.build();
-        ObjectServerFacade.getSyncFacadeIfPossible().wrapObjectStoreSessionIfRequired(osRealmConfig.getRealmConfiguration());
+        ObjectServerFacade.getSyncFacadeIfPossible().wrapObjectStoreSessionIfRequired(osRealmConfig);
 
         return new SharedRealm(osRealmConfig);
     }
@@ -348,6 +364,10 @@ public boolean isAutoRefresh() {
         return nativeIsAutoRefresh(nativePtr);
     }
 
+    public void registerPartialSyncQuery(String query, PartialSyncCallback callback) {
+        nativeRegisterPartialSyncQuery(nativePtr, callback.className, query, callback);
+    }
+
     public RealmConfiguration getConfiguration() {
         return osRealmConfig.getRealmConfiguration();
     }
@@ -476,6 +496,26 @@ private static void runInitializationCallback(long nativeSharedRealmPtr, OsRealm
         callback.onInit(new SharedRealm(nativeSharedRealmPtr, osRealmConfig));
     }
 
+    /**
+     * Called from JNI when the partial sync callback is invoked from the ObjectStore.
+     * @param error if the partial sync query failed to register.
+     * @param nativeResultsPtr pointer to the {@code Results} of the partial sync query.
+     * @param callback the callback registered from the user to notify the success/error of the partial sync query.
+     */
+    @SuppressWarnings("unused")
+    private void runPartialSyncRegistrationCallback(@Nullable String error, long nativeResultsPtr,
+                                                           PartialSyncCallback callback) {
+        if (error != null) {
+            callback.onError(new RealmException(error));
+        } else {
+            @SuppressWarnings("ConstantConditions")
+            Table table = getTable(Table.getTableNameForClass(callback.className));
+            Collection results = new Collection(this, table, nativeResultsPtr, true);
+            callback.onSuccess(results);
+        }
+    }
+
+
     private static native void nativeInit(String temporaryDirectoryPath);
 
     private static native long nativeGetSharedRealm(long nativeConfigPtr, RealmNotifier notifier);
@@ -536,4 +576,7 @@ private static native long nativeCreateTableWithPrimaryKeyField(long nativeShare
     private static native long nativeGetSchemaInfo(long nativePtr);
 
     private static native void nativeRegisterSchemaChangedCallback(long nativePtr, SchemaChangedCallback callback);
+
+    private native void nativeRegisterPartialSyncQuery(
+            long nativeSharedRealmPtr, String className, String query, PartialSyncCallback callback);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index 88b0d9dc25..61de76ff92 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -89,6 +89,7 @@
     private final String serverCertificateFilePath;
     private final boolean waitForInitialData;
     private final OsRealmConfig.SyncSessionStopPolicy sessionStopPolicy;
+    private final boolean isPartial;
 
     private SyncConfiguration(File directory,
                                 String filename,
@@ -118,7 +119,8 @@ private SyncConfiguration(File directory,
                                 @Nullable
                                 String serverCertificateFilePath,
                                 boolean waitForInitialData,
-                                OsRealmConfig.SyncSessionStopPolicy sessionStopPolicy
+                                OsRealmConfig.SyncSessionStopPolicy sessionStopPolicy,
+                                boolean isPartial
     ) {
         super(directory,
                 filename,
@@ -146,6 +148,7 @@ private SyncConfiguration(File directory,
         this.serverCertificateFilePath = serverCertificateFilePath;
         this.waitForInitialData = waitForInitialData;
         this.sessionStopPolicy = sessionStopPolicy;
+        this.isPartial = isPartial;
     }
 
     /**
@@ -359,6 +362,21 @@ boolean isSyncConfiguration() {
         return sessionStopPolicy;
     }
 
+    /**
+     * Whether this configuration is for a partial synchronization Realm.
+     * Partial synchronization allows a synchronized Realm to be opened in such a way that
+     * only objects requested by the user are synchronized to the device. You can use it by setting
+     * the {@link Builder#partialRealm()}, opening the Realm, and then calling
+     * {@link Realm#subscribeToObjects(Class, String, Realm.PartialSyncCallback)} with the type of
+     * object you're interested in, a string containing a query determining which objects you want
+     * to subscribe to, and a callback which will report the results.
+     *
+     * @return {@code true} to open a partial synchronization Realm {@code false} otherwise.
+     */
+    public boolean isPartialRealm() {
+        return isPartial;
+    }
+
     /**
      * Builder used to construct instances of a SyncConfiguration in a fluent manner.
      */
@@ -394,6 +412,7 @@ boolean isSyncConfiguration() {
         @Nullable
         private String serverCertificateFilePath;
         private OsRealmConfig.SyncSessionStopPolicy sessionStopPolicy = OsRealmConfig.SyncSessionStopPolicy.AFTER_CHANGES_UPLOADED;
+        private boolean isPartial = false;
         /**
          * Creates an instance of the Builder for the SyncConfiguration.
          * <p>
@@ -819,6 +838,15 @@ public Builder waitForInitialRemoteData() {
             return this;
         }
 
+        /**
+         * Setting this will open a partially synchronized Realm.
+         * @see #isPartialRealm()
+         */
+        public SyncConfiguration.Builder partialRealm() {
+            this.isPartial = true;
+            return this;
+        }
+
         private String MD5(String in) {
             try {
                 MessageDigest digest = MessageDigest.getInstance("MD5");
@@ -964,7 +992,8 @@ public SyncConfiguration build() {
                     serverCertificateAssetName,
                     serverCertificateFilePath,
                     waitForServerChanges,
-                    sessionStopPolicy
+                    sessionStopPolicy,
+                    isPartial
             );
         }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index 102eaba041..3b31657ca3 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -101,6 +101,8 @@
     private static final byte STATE_VALUE_INACTIVE = 3;
     private static final byte STATE_VALUE_ERROR = 4;
 
+    private URI resolvedRealmURI;
+
     public enum State {
         WAITING_FOR_ACCESS_TOKEN(STATE_VALUE_WAITING_FOR_ACCESS_TOKEN),
         ACTIVE(STATE_VALUE_ACTIVE),
@@ -376,6 +378,10 @@ public void uploadAllLocalChanges() throws InterruptedException {
         }
     }
 
+    public void setResolvedRealmURI(URI resolvedRealmURI) {
+        this.resolvedRealmURI = resolvedRealmURI;
+    }
+
     /**
      * This method should only be called when guarded by the {@link #waitForChangesMutex}.
      * It will block into all changes have been either uploaded or downloaded depending on the chosen direction.
@@ -552,7 +558,7 @@ protected AuthenticateResponse execute() {
                 if (!isClosed && !Thread.currentThread().isInterrupted()) {
                     return authServer.loginToRealm(
                             getUser().getRefreshToken(), //refresh token in fact
-                            configuration.getServerUrl(),
+                            resolvedRealmURI,
                             getUser().getAuthenticationUrl()
                     );
                 }
@@ -629,7 +635,7 @@ private void refreshAccessToken(final AuthenticationServer authServer) {
             @Override
             protected AuthenticateResponse execute() {
                 if (!isClosed && !Thread.currentThread().isInterrupted()) {
-                    return authServer.refreshUser(getUser().getRefreshToken(), configuration.getServerUrl(), getUser().getAuthenticationUrl());
+                    return authServer.refreshUser(getUser().getRefreshToken(), resolvedRealmURI, getUser().getAuthenticationUrl());
                 }
                 return null;
             }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
index f4c3d4d9df..2b8616e8d7 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
@@ -93,9 +93,9 @@ public void realmClosed(RealmConfiguration configuration) {
             String syncRealmAuthUrl = user.getAuthenticationUrl().toString();
             String rosSerializedUser = user.toJson();
             byte sessionStopPolicy = syncConfig.getSessionStopPolicy().getNativeValue();
-            return new Object[]{rosUserIdentity, rosServerUrl, syncRealmAuthUrl, rosSerializedUser, syncConfig.syncClientValidateSsl(), syncConfig.getServerCertificateFilePath(), sessionStopPolicy};
+            return new Object[]{rosUserIdentity, rosServerUrl, syncRealmAuthUrl, rosSerializedUser, syncConfig.syncClientValidateSsl(), syncConfig.getServerCertificateFilePath(), sessionStopPolicy, syncConfig.isPartialRealm()};
         } else {
-            return new Object[7];
+            return new Object[8];
         }
     }
 
@@ -104,9 +104,10 @@ public static Context getApplicationContext() {
     }
 
     @Override
-    public void wrapObjectStoreSessionIfRequired(RealmConfiguration config) {
-        if (config instanceof SyncConfiguration) {
-            SyncManager.getSession((SyncConfiguration) config);
+    public void wrapObjectStoreSessionIfRequired(OsRealmConfig config) {
+        if (config.getRealmConfiguration() instanceof SyncConfiguration) {
+            SyncSession session = SyncManager.getSession((SyncConfiguration) config.getRealmConfiguration());
+            session.setResolvedRealmURI(config.getResolvedRealmURI());
         }
     }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java
index e921daec6c..bc333b9ab0 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java
@@ -56,11 +56,11 @@ public static AuthenticateRequest userLogin(SyncCredentials credentials) {
     /**
      * Generates a request for refreshing a user token.
      */
-    public static AuthenticateRequest userRefresh(Token userToken, URI serverUrl) {
+    public static AuthenticateRequest userRefresh(Token userToken, String serverUrl) {
         return new AuthenticateRequest("realm",
                 userToken.value(),
                 SyncManager.APP_ID,
-                serverUrl.getPath(),
+                serverUrl,
                 Collections.<String, Object>emptyMap()
         );
     }
@@ -68,12 +68,12 @@ public static AuthenticateRequest userRefresh(Token userToken, URI serverUrl) {
     /**
      * Generates a request for accessing a Realm
      */
-    public static AuthenticateRequest realmLogin(Token userToken, URI serverUrl) {
+    public static AuthenticateRequest realmLogin(Token userToken, String serverUrl) {
         // Authenticate a given Realm path using an already logged in user.
         return new AuthenticateRequest("realm",
                 userToken.value(),
                 SyncManager.APP_ID,
-                serverUrl.getPath(),
+                serverUrl,
                 Collections.<String, Object>emptyMap()
         );
     }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
index e3b5db8a09..c6fdeb9f36 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
@@ -66,7 +66,7 @@ public AuthenticateResponse loginUser(SyncCredentials credentials, URL authentic
     @Override
     public AuthenticateResponse loginToRealm(Token refreshToken, URI serverUrl, URL authenticationUrl) {
         try {
-            String requestBody = AuthenticateRequest.realmLogin(refreshToken, serverUrl).toJson();
+            String requestBody = AuthenticateRequest.realmLogin(refreshToken, serverUrl.getPath()).toJson();
             return authenticate(authenticationUrl, requestBody);
         } catch (Exception e) {
             return AuthenticateResponse.from(e);
@@ -76,7 +76,7 @@ public AuthenticateResponse loginToRealm(Token refreshToken, URI serverUrl, URL
     @Override
     public AuthenticateResponse refreshUser(Token userToken, URI serverUrl, URL authenticationUrl) {
         try {
-            String requestBody = AuthenticateRequest.userRefresh(userToken, serverUrl).toJson();
+            String requestBody = AuthenticateRequest.userRefresh(userToken, serverUrl.getPath()).toJson();
             return authenticate(authenticationUrl, requestBody);
         } catch (Exception e) {
             return AuthenticateResponse.from(e);
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
index 0c6f778b30..eb5c1a5701 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
@@ -446,4 +446,5 @@ public void run() {
         assertEquals(3, realm.where(StringOnly.class).count());
         realm.close();
     }
+
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/PartialSyncTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/PartialSyncTests.java
new file mode 100644
index 0000000000..1414e392ed
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/PartialSyncTests.java
@@ -0,0 +1,149 @@
+package io.realm.objectserver;
+
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.concurrent.CountDownLatch;
+
+import io.realm.Realm;
+import io.realm.RealmResults;
+import io.realm.StandardIntegrationTest;
+import io.realm.SyncConfiguration;
+import io.realm.SyncManager;
+import io.realm.SyncUser;
+import io.realm.TestHelper;
+import io.realm.exceptions.RealmException;
+import io.realm.objectserver.model.PartialSyncModule;
+import io.realm.objectserver.model.PartialSyncObjectA;
+import io.realm.objectserver.model.PartialSyncObjectB;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.UserFactory;
+import io.realm.TestSyncConfigurationFactory;
+
+import static org.hamcrest.number.OrderingComparison.greaterThan;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class PartialSyncTests extends StandardIntegrationTest {
+    @Rule
+    public TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
+
+    @Test
+    public void partialSync() throws InterruptedException {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+
+        final SyncConfiguration partialSyncConfig = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .modules(new PartialSyncModule())
+                .partialRealm()
+                .build();
+        SyncConfiguration adminConfig = configFactory
+                .createSyncConfigurationBuilder(adminUser, partialSyncConfig.getServerUrl().toString())
+                .modules(new PartialSyncModule())
+                .build();
+
+        // Using Admin user, populate the Realm.
+        Realm realm = Realm.getInstance(adminConfig);
+        realm.beginTransaction();
+        PartialSyncObjectA objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(0);
+        objectA.setString("realm");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(1);
+        objectA.setString("");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(2);
+        objectA.setString("");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(3);
+        objectA.setString("");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(4);
+        objectA.setString("realm");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(5);
+        objectA.setString("sync");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(6);
+        objectA.setString("partial");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(7);
+        objectA.setString("partial");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(8);
+        objectA.setString("partial");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(9);
+        objectA.setString("partial");
+
+        for (int i = 0; i < 10; i++) {
+            realm.createObject(PartialSyncObjectB.class).setNumber(i);
+        }
+        realm.commitTransaction();
+
+        SyncManager.getSession(adminConfig).uploadAllLocalChanges();
+        realm.close();
+
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        HandlerThread handlerThread = new HandlerThread("background");
+        handlerThread.start();
+        Handler handler = new Handler(handlerThread.getLooper());
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                final Realm partialSyncRealm = Realm.getInstance(partialSyncConfig);
+                assertTrue(partialSyncRealm.isEmpty());
+
+                partialSyncRealm.subscribeToObjects(PartialSyncObjectA.class, "number > 5", new Realm.PartialSyncCallback<PartialSyncObjectA>() {
+
+                    @Override
+                    public void onSuccess(RealmResults<PartialSyncObjectA> results) {
+                        assertEquals(4, results.size());
+                        for (PartialSyncObjectA object : results) {
+                            assertThat(object.getNumber(), greaterThan(5));
+                            assertEquals("partial", object.getString());
+                        }
+                        // make sure the Realm contains only PartialSyncObjectA
+                        assertEquals(0, partialSyncRealm.where(PartialSyncObjectB.class).count());
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(RealmException error) {
+                        fail(error.getMessage());
+                    }
+                });
+
+                // Invalid query
+                partialSyncRealm.subscribeToObjects(PartialSyncObjectA.class, "invalid_property > 5", new Realm.PartialSyncCallback<PartialSyncObjectA>() {
+
+                    @Override
+                    public void onSuccess(RealmResults<PartialSyncObjectA> results) {
+                        fail("Invalid query should not succeed");
+                    }
+
+                    @Override
+                    public void onError(RealmException error) {
+                        assertNotNull(error);
+                        partialSyncRealm.close();
+                        latch.countDown();
+                    }
+                });
+
+            }
+        });
+
+        TestHelper.awaitOrFail(latch);
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncModule.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncModule.java
new file mode 100644
index 0000000000..6552293cf7
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncModule.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.model;
+
+import io.realm.annotations.RealmModule;
+
+@RealmModule(classes = {PartialSyncObjectA.class, PartialSyncObjectB.class})
+public class PartialSyncModule {
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncObjectA.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncObjectA.java
new file mode 100644
index 0000000000..4af96f4768
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncObjectA.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.model;
+
+import io.realm.RealmObject;
+
+public class PartialSyncObjectA extends RealmObject {
+    private int number;
+    private String string;
+
+    public int getNumber() {
+        return number;
+    }
+
+    public void setNumber(int number) {
+        this.number = number;
+    }
+
+    public String getString() {
+        return string;
+    }
+
+    public void setString(String string) {
+        this.string = string;
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncObjectB.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncObjectB.java
new file mode 100644
index 0000000000..7a6c453229
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncObjectB.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.model;
+
+import io.realm.RealmObject;
+
+public class PartialSyncObjectB extends RealmObject {
+    private int number;
+    private String firstString;
+    private String secondString;
+
+    public int getNumber() {
+        return number;
+    }
+
+    public void setNumber(int number) {
+        this.number = number;
+    }
+
+    public String getFirstString() {
+        return firstString;
+    }
+
+    public void setFirstString(String firstString) {
+        this.firstString = firstString;
+    }
+
+    public String getSecondString() {
+        return secondString;
+    }
+
+    public void setSecondString(String secondString) {
+        this.secondString = secondString;
+    }
+}
